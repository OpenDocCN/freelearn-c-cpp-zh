["```cpp\n{ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \u2026 }\n```", "```cpp\nF(0) = 0\nF(1) = 1\n\u2026\nF(n) = F(n-1) + F(n-2)\n```", "```cpp\nF5 is equal to: \n\u00a0\u00a0\u00a0\u00a0F4 + F3, where F4 is equal to:\n\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0F3 + F2, where F3 is equal to:\n\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0F2 + F1, where F2 is equal to:\n\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0F1 + F0, where F1 = 1 and F0 = 0.\n\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0\u2026and F1 = 1.\n\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0\u2026and F2 is equal to:\n\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0F1 + F0, where F1 = 1 and F0 = 0.\n\u00a0\u00a0\u00a0\u00a0\u2026and F3 is equal to:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0F2 + F1, where F2 is equal to:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0F1 + F0, where F1 = 1 and F0 = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026and F1 = 1.\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0int Fibonacci(int n)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(n < 2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return n;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Fibonacci(n \u2013 1) + Fibonacci(n \u2013 2);\n\u00a0\u00a0\u00a0\u00a0}\n```", "```cpp\nconst int UNKNOWN = -1;\nconst int MAX_SIZE = 100000;\nvector<int> memo(MAX_SIZE, UNKNOWN);\nint Fibonacci(int n)\n{\n\u00a0\u00a0\u00a0\u00a0if(n < 2)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return n;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if(memo[n] != UNKNOWN)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return memo[n];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0int result = Fibonacci(n - 1) + Fibonacci(n - 2);\n\u00a0\u00a0\u00a0\u00a0memo[n] = result;\n\u00a0\u00a0\u00a0\u00a0return result;\n}\n```", "```cpp\nint Fibonacci(int n)\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<int> DP(n + 1, 0);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[1] = 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int i = 2; i <= n; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i] = DP[i-1] + DP[i-2];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return DP[n];\n} \n```", "```cpp\n10 quarters \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> $2.50\n9 quarters, 2 dimes, 1 nickel  -> $2.25 + $0.20 + $0.05\n9 quarters, 1 dime,  3 nickels -> $2.25 + $0.10 + $0.15\n9 quarters, 5 nickels \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> $2.25 + $0.25\n8 quarters, 4 dimes, 2 nickels -> $2.00 + $0.40 + $0.10\n8 quarters, 3 dimes, 4 nickels -> $2.00 + $0.30 + $0.20\n8 quarters, 2 dimes, 6 nickels -> $2.00 + $0.20 + $0.30\n```", "```cpp\nS = { 13, 79, 45, 29 }\nx = 42 \u2014> True (13 + 29)\nx = 25 \u2014> False \n```", "```cpp\n{ }\n{ 13 }\n{ 79 }\n{ 45 }\n{ 29 }\n{ 13, 79 }\n{ 13, 45 }\n{ 13, 29 }\n{ 79, 45 }\n{ 79, 29 }\n{ 45, 29 }\n{ 13, 79, 45 }\n{ 13, 79, 29 }\n{ 13, 45, 29 }\n{ 79, 45, 29 }\n{ 13, 79, 45, 29 }\n```", "```cpp\n0: 1\n1: 2\n2: 4\n3: 8\n4: 16\n5: 32\n6: 64\n7: 128\n\u2026\n```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n    using namespace std;\n    ```", "```cpp\n    #define DEBUG 0\n    #if DEBUG\n    #define PRINT(x) cerr << x\n    #else\n    #define PRINT(x) \n    #endif\n    ```", "```cpp\n    bool SubsetSum_BruteForce(vector<int> set, int sum)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    void GetAllSubsets(vector<int> set, vector<int> subset, int index, vector<vector<vector<int>>> &allSubsets)\n    {\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0// Terminate if the end of the set is reached\n    \u00a0\u00a0\u00a0\u00a0if(index == set.size()) \n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Add the accumulated subset to the results, indexed by size\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0allSubsets[subset.size()].push_back(subset);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Continue without adding element to subset\n    \u00a0\u00a0\u00a0\u00a0GetAllSubsets(set, subset, index + 1, allSubsets);\n    \u00a0\u00a0\u00a0\u00a0// Add element to subset\n    \u00a0\u00a0\u00a0\u00a0subset.push_back(set[index]);\n    \u00a0\u00a0\u00a0\u00a0GetAllSubsets(set, subset, index + 1, allSubsets);\n    }\n    ```", "```cpp\n    bool SubsetSum_BruteForce(vector<int> set, int target)\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<vector<vector<int>>> allSubsets(set.size() + 1);\n\n    \u00a0\u00a0\u00a0\u00a0GetAllSubsets(set, {}, 0, allSubsets);\n\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    ```", "```cpp\n    for(int size = 0; size <= set.size(); size++)\n    {\n    \u00a0\u00a0\u00a0\u00a0PRINT(\"SIZE = \" << size << endl);\n    \u00a0\u00a0\u00a0\u00a0for(auto subset : allSubsets[size])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int sum = 0;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PRINT(\"\\t{ \");\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto number : subset)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PRINT(number << \" \");\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += number;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PRINT(\"} = \" << sum << endl);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(sum == target) return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<int> set = { 13, 79, 45, 29 };\n    \u00a0\u00a0\u00a0\u00a0int target = 58;\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    bool found = SubsetSum_BruteForce(set, target);\n    if(found)\n    {\n    \u00a0\u00a0\u00a0\u00a0cout << \"Subset with sum \" << target << \" was found in the set.\" << endl;\n    }\n    else \n    {\n    \u00a0\u00a0\u00a0\u00a0cout << \"Subset with sum \" << target << \" was not found in the set.\" << endl;\n    }\n    ```", "```cpp\n    Subset with sum 58 was found in the set.\n    ```", "```cpp\n    int target = 1000000;\n    ```", "```cpp\n    Subset with sum 1000000 was not found in the set.\n    ```", "```cpp\n    #define DEBUG 1\n    ```", "```cpp\n    SIZE = 0\n    \u00a0\u00a0\u00a0\u00a0{ } = 0\n    SIZE = 1\n    \u00a0\u00a0\u00a0\u00a0{ 29 } = 29\n    \u00a0\u00a0\u00a0\u00a0{ 45 } = 45\n    \u00a0\u00a0\u00a0\u00a0{ 79 } = 79\n    \u00a0\u00a0\u00a0\u00a0{ 13 } = 13\n    SIZE = 2\n    \u00a0\u00a0\u00a0\u00a0{ 45 29 } = 74\n    \u00a0\u00a0\u00a0\u00a0{ 79 29 } = 108\n    \u00a0\u00a0\u00a0\u00a0{ 79 45 } = 124\n    \u00a0\u00a0\u00a0\u00a0{ 13 29 } = 42\n    \u00a0\u00a0\u00a0\u00a0{ 13 45 } = 58\n    \u00a0\u00a0\u00a0\u00a0{ 13 79 } = 92\n    SIZE = 3\n    \u00a0\u00a0\u00a0\u00a0{ 79 45 29 } = 153\n    \u00a0\u00a0\u00a0\u00a0{ 13 45 29 } = 87\n    \u00a0\u00a0\u00a0\u00a0{ 13 79 29 } = 121\n    \u00a0\u00a0\u00a0\u00a0{ 13 79 45 } = 137\n    SIZE = 4\n    \u00a0\u00a0\u00a0\u00a0{ 13 79 45 29 } = 166\n    Subset with sum 1000000 was not found in the set.\n    ```", "```cpp\nint Factorial(int n)\n{\n\u00a0\u00a0\u00a0\u00a0// Base case \u2014 stop recursing\n\u00a0\u00a0\u00a0\u00a0if(n == 1)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Recurse until base case is reached\n\u00a0\u00a0\u00a0\u00a0return n * Factorial(n - 1);\n}\n```", "```cpp\nIf sum of a given subset is equal to target : TRUE\n\nOtherwise:\n\u00a0\u00a0\u00a0\u00a0\u2014 If sum is greater than target : FALSE\n\u00a0\u00a0\u00a0\u00a0\u2014 If end of set is reached : FALSE\n```", "```cpp\nBase case \u2014> { } [SUM = 0]\n{ } \u2014> { 13 } [0 + 13 = 13]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { 79 } [0 + 79 = 79]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { 45 } [0 + 45 = 45]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 { 29 } [0 + 29 = 29]\n```", "```cpp\n{ 13 } \u2014> { 13 79 } [13 + 79 = 92]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ 13 45 } [13 + 45 = 58]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ 13 29 } [13 + 29 = 42]\n{ 79 } \u2014> { 79 45 } [79 + 45 = 124]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ 79 29 } [79 + 29 = 108]\n{ 45 } \u2014> { 45 29 } [45 + 29 = 74]\n```", "```cpp\nfor element of set at index i and subset ss:\n\u00a0\u00a0\u00a0\u00a0If sum of ss with set[i] is less than or equal to target: \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01) Append set[i] to ss\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02) Increment i \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Next state \u2014> (i = i + 1, ss = ss \u222a set[i])\n\u00a0\u00a0\u00a0\u00a0In any case: \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01) Do not append set[i] to ss\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02) Increment i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Next state \u2014> (i = i + 1, ss = ss)\n```", "```cpp\nfor element of set at index i and its sum as sum:\n\u00a0\u00a0\u00a0\u00a0If sum plus set[i] is less than or equal to target: \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01) Add value of set[i] to sum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02) Increment i \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Next state \u2014> (i = i + 1, sum = sum + set[i])\n\u00a0\u00a0\u00a0\u00a0In any case: \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01) Do not add value of set[i] to sum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02) Increment i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Next state \u2014> (i = i + 1, sum = sum)\n```", "```cpp\n    bool SubsetSum_Backtracking(vector<int> &set, int sum, int i) \n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    // The sum has been found\n    if(sum == 0)\n    {\n    \u00a0\u00a0\u00a0\u00a0return true;\n    }\n    // End of set is reached, or sum would be exceeded beyond this point\n    if(i == set.size() || set[i] > sum)\n    {\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    // Case 1: Add to sum\n    // Case 2: Leave as-is \n    return SubsetSum_Backtracking(set, sum \u2013 set[i], i + 1) \n    \u00a0\u00a0\u00a0\u00a0|| SubsetSum_Backtracking(set, sum, i + 1); \n    ```", "```cpp\n    sort(set.begin(), set.end());\n    bool found;\n\n    found = SubsetSum_BruteForce(set, target);\n    found = SubsetSum_Backtracking(set, target, 0); \n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <algorithm> \n    #include <time.h>\n    #include <iomanip>\n    ```", "```cpp\n    vector<string> types = \n    {\n    \u00a0\u00a0\u00a0\u00a0\"BRUTE FORCE\",\n    \u00a0\u00a0\u00a0\u00a0\"BACKTRACKING\",\n    \u00a0\u00a0\u00a0\u00a0\"MEMOIZATION\",\n    \u00a0\u00a0\u00a0\u00a0\"TABULATION\"\n    };\n    const int UNKNOWN = INT_MAX;\n    ```", "```cpp\n    void GetTime(clock_t &timer, string type)\n    {\n    \u00a0\u00a0\u00a0\u00a0// Subtract timer value from current time to get time elapsed\n    \u00a0\u00a0\u00a0\u00a0timer = clock() - timer;\n    \u00a0\u00a0\u00a0\u00a0// Display seconds elapsed\n    \u00a0\u00a0\u00a0\u00a0cout << \"TIME TAKEN USING \" << type << \": \" << fixed << setprecision(5) << (float)timer / CLOCKS_PER_SEC << endl; \n\n    \u00a0\u00a0\u00a0\u00a0timer = clock(); // Reset timer \n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<int> set = { 13, 79, 45, 29 };\n    \u00a0\u00a0\u00a0\u00a0int target = 58;\n    \u00a0\u00a0\u00a0\u00a0int tests = 2;\n    \u00a0\u00a0\u00a0\u00a0clock timer = clock();\n    \u00a0\u00a0\u00a0\u00a0sort(set.begin(), set.end());\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < tests; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool found;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch(i)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 0: found = SubsetSum_BruteForce(set, target); break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 1: found = SubsetSum_Backtracking(set, target, 0); break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(found)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Subset with sum \" << target << \" was found in the set.\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Subset with sum \" << target << \" was not found in the set.\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetTime(timer, types[i]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    vector<int> set = { 16, 1058, 22, 13, 46, 55, 3, 92, 47, 7, 98, 367, 807, 106, 333, 85, 577, 9, 3059 };\n    int target = 6076;\n    ```", "```cpp\n    Subset with sum 6076 was found in the set.\n    TIME TAKEN USING BRUTE FORCE: 0.89987\n    Subset with sum 6076 was found in the set.\n    TIME TAKEN USING BACKTRACKING: 0.00078\n    ```", "```cpp\n{ 1 5 6 2 3 9 } \nSum of { 1 5 } = 6\nSum of { 6 } = 6\nSum of { 1 2 3 } = 6\n```", "```cpp\n    bool SubsetSum_Memoization(vector<int> &set, int sum, int \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i, vector<vector<int>> &memo)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    if(sum == 0)\n    {\n    \u00a0\u00a0\u00a0\u00a0return true;\n    }\n    if(i == set.size() || set[i] > sum)\n    {\n    \u00a0\u00a0\u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    // Is this state's solution cached?\n    if(memo[i][sum] == UNKNOWN)\n    {\n    \u00a0\u00a0\u00a0\u00a0// If not, find the solution for this state and cache it\n    \u00a0\u00a0\u00a0\u00a0bool append = SubsetSum_Memoization(set, sum - set[i], i + 1, memo);\n    \u00a0\u00a0\u00a0\u00a0bool ignore = SubsetSum_Memoization(set, sum, i + 1, memo);\n    \u00a0\u00a0\u00a0\u00a0memo[i][sum] = append || ignore;\n    }\n    // Return cached value\n    return memo[i][sum];\n    ```", "```cpp\n    int tests = 3;\n    for(int i = 0; i < tests; i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0bool found;\n    \u00a0\u00a0\u00a0\u00a0switch(i)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 0: found = SubsetSum_BruteForce(set, target); break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 1: found = SubsetSum_Backtracking(set, target, 0); break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 2:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Initialize memoization table\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<vector<int>> memo(set.size(), vector<int>(7000, UNKNOWN));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0found = SubsetSum_Memoization(set, target, 0, memo);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n\n    \u00a0\u00a0\u00a0\u00a0if(found)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Subset with sum \" << target << \" was found in the set.\" << endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Subset with sum \" << target << \" was not found in the set.\" << endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0GetTime(timer, types[i]);\n    \u00a0\u00a0\u00a0\u00a0cout << endl;\n    }\n    ```", "```cpp\n    Subset with sum 6799 was not found in the set.\n    TIME TAKEN USING BRUTE FORCE: 1.00100\n    Subset with sum 6799 was not found in the set.\n    TIME TAKEN USING BACKTRACKING: 0.26454\n    Subset with sum 6799 was not found in the set.\n    TIME TAKEN USING MEMOIZATION: 0.00127\n    ```", "```cpp\nF[n] = F[n \u2013 1] + F[n \u2013 2];\n```", "```cpp\nfactorial[n] = factorial[n \u2013 1] * n;\n```", "```cpp\n    vector<vector<bool>> SubsetSum_Tabulation(vector<int> set)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    int maxSum = 0;\n    for(auto num : set) \n    {\n    \u00a0\u00a0\u00a0\u00a0maxSum += num;\n    }\n    vector<vector<bool>> DP(set.size() + 1, vector<bool>(maxSum + 1, false));\n    for(int i = 0; i < set.size(); i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0// Base case \u2014 a subset sum of 0 can be found at any index\n    \u00a0\u00a0\u00a0\u00a0DP[i][0] = true;\n    }\n    ```", "```cpp\n    for(int i = 1; i <= set.size(); i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int sum = 1; sum <= maxSum; sum++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    for(int i = 1; i <= set.size(); i++)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int sum = 1; sum <= maxSum; sum++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(sum < set[i-1])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][sum] = DP[i-1][sum];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DP[i][sum] = DP[i-1][sum]\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| DP[i-1][sum \u2013 set[i-1]];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    return DP;\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0vector<int> set = { 16, 1058, 22, 13, 46, 55, 3, 92, 47, 7, 98, 367, 807, 106, 333, 85, 577, 9, 3059 };\n    \u00a0\u00a0\u00a0\u00a0int target = 6076\n    \u00a0\u00a0\u00a0\u00a0int tests = 4;\n    \u00a0\u00a0\u00a0\u00a0clock_t timer = clock();\n    \u00a0\u00a0\u00a0\u00a0sort(set.begin(), set.end());\n    \u00a0\u00a0\u00a0\u00a0for(int i = 0; i < tests; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool found;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch(i)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case 3:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<vector<bool>> DP = SubsetSum_Tabulation(set);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0found = DP[set.size()][target];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    Subset with sum 6076 was found in the set.\n    TIME TAKEN USING BRUTE FORCE: 0.95602\n    Subset with sum 6076 was found in the set.\n    TIME TAKEN USING BACKTRACKING: 0.00082\n    Subset with sum 6076 was found in the set.\n    TIME TAKEN USING MEMOIZATION: 0.00058\n    Subset with sum 6076 was found in the set.\n    TIME TAKEN USING TABULATION: 0.00605\n    ```", "```cpp\n    int total = 0;\n    for(auto num : set) \n    {\n    \u00a0\u00a0\u00a0\u00a0total += num;\n    }\n    vector<vector<bool>> DP = SubsetSum_Tabulation(set);\n    vector<int> subsetSums;\n    for(int sum = 1; sum <= total; sum++)\n    {\n    \u00a0\u00a0\u00a0\u00a0if(DP[set.size()][sum])\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subsetSums.push_back(sum);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    cout << \"The set contains the following \" << subsetSums.size() << \" subset sums: \";\n    for(auto sum : subsetSums) \n    {\n    \u00a0\u00a0\u00a0\u00a0cout << sum << \" \";\n    }\n    cout << endl; \n    ```", "```cpp\n    The set contains the following 6760 subset sums: 3 7 9 10 12 13 16 19 20 22 \u2026\u2026 6790 6791 6793 6797 6800\n    ```", "```cpp\n6\n1 2 3 2 2 1\n```", "```cpp\n[0]: { 1 }\n[1]: { 2, 3 }\n[2]: { 3, 4, 5 }\n[3]: { 4, 5 }\n[4]: { 5, 6 }\n[5]: { 6 }  \n```", "```cpp\n0 > 1 > 2 > 3 > 4 > 5 > E\n0 > 1 > 2 > 3 > 4 > E\n0 > 1 > 2 > 3 > 5 > E\n0 > 1 > 2 > 4 > 5 > E\n0 > 1 > 3 > 4 > 5 > E\n0 > 1 > 2 > 4 > E\n0 > 1 > 2 > 5 > E\n0 > 1 > 3 > 4 > E\n0 > 1 > 3 > 5 > E\n```", "```cpp\nvector<int> Generate(int n)\n{\n\u00a0\u00a0\u00a0\u00a0vector<int> A(n);\n\n\u00a0\u00a0\u00a0\u00a0ULL val = 1;\n\n\u00a0\u00a0\u00a0\u00a0for(int i = 0; i < n; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val = (val * 1103515245 + 12345) / 65536;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val %= 32768;\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0A[i] = ((val % 10000) % (n \u2013 i)) + 1;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return A;\n}\n```", "```cpp\nbool doSomething = true;\nvoid DoStuff()\n{\n\u00a0\u00a0\u00a0\u00a0DoSomething();\n\u00a0\u00a0\u00a0\u00a0DoSomethingElse();\n\u00a0\u00a0\u00a0\u00a0DoAnotherThing();\n}\n```", "```cpp\nbool doSomething = false;\nvoid DoStuff()\n{\n\u00a0\u00a0\u00a0\u00a0if(doSomething == true)\n\u00a0\u00a0\u00a0\u00a0{ \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DoSomething();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0else \n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DoSomethingElse();\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nCase 1): A or B is empty\nA\u00a0\u00a0\u00a0= \"\"\nB\u00a0\u00a0\u00a0= \"\"\nLCS\u00a0= 0\nA\u00a0\u00a0\u00a0= \"A\"\nB\u00a0\u00a0\u00a0= \"\"\nLCS\u00a0= 0\nA\u00a0\u00a0\u00a0= \"\"\nB\u00a0\u00a0\u00a0= \"PNEUMONOULTRAMICROSCOPICSILICOVOLCANOCONIOSIS\"\nLCS\u00a0= 0\n```", "```cpp\nCase 2) Both A and B contain a single character\nA\u00a0\u00a0\u00a0= \"A\"\nB\u00a0\u00a0\u00a0= \"A\"\nLCS\u00a0= 1\nA\u00a0\u00a0\u00a0= \"A\"\nB\u00a0\u00a0\u00a0= \"B\"\nLCS\u00a0= 0\nCase 3) A has one character, B has two characters\nA\u00a0\u00a0\u00a0= \"A\"\nB\u00a0\u00a0\u00a0= \"AB\"\nLCS\u00a0= 1\nA\u00a0\u00a0\u00a0= \"A\"\nB\u00a0\u00a0\u00a0= \"BB\"\nLCS\u00a0= 0\n```", "```cpp\nCase 4) Both A and B contain two characters\nA:\u00a0\u00a0= \"AA\"\nB:\u00a0\u00a0= \"AA\"\nLCS = 2\nA\u00a0\u00a0\u00a0= \"BA\"\nB\u00a0\u00a0\u00a0= \"AB\"\nLCS = 1\nA\u00a0\u00a0\u00a0= \"AA\"\nB\u00a0\u00a0\u00a0= \"BB\"\nLCS = 0\n```", "```cpp\nCase 5) A and B both contain 3 characters\nA\u00a0\u00a0\u00a0= \"ABA\"\nB\u00a0\u00a0\u00a0= \"AAB\"\nLCS\u00a0= 2\u00a0\u00a0\u00a0\u00a0\nA\u00a0\u00a0\u00a0= \"ABC\"\nB\u00a0\u00a0\u00a0= \"BZC\"\nLCS\u00a0= 2\n```", "```cpp\nCase 6: A and B both contain 4 characters\nA\u00a0\u00a0\u00a0= AAAB\nB\u00a0\u00a0\u00a0= AAAA\n{ \"AAA_\", \"AAA_\" }\n{ \"AAA_\", \"AA_A\" }\n{ \"AAA_\", \"A_AA\" }\n{ \"AAA_\", \"_AAA\" }\nLCS = 3\nA\u00a0\u00a0\u00a0= AZYB\nB\u00a0\u00a0\u00a0= YZBA\u00a0\u00a0\u00a0\u00a0\n{ \"_Z_B\", \"_ZB_\" }\n{ \"__YB\", \"Y_B_\" }\nLCS = 2\n```", "```cpp\nif i exceeds length of A, or j exceeds length of B:\n\u2014 Terminate recursion and return length of subsequence\n```", "```cpp\nif A[i] = B[j]:\n\u2014 Increase length of subsequence by 1\n\u2014 Increment both i and j by 1 \n```", "```cpp\nOtherwise:\n\u00a0\u00a0\u00a0\u00a0Option 1) Explore further possibilities with i + 1, and j\n\u00a0\u00a0\u00a0\u00a0Option 2) Explore further possibilities with i, and j + 1\n\u00a0\u00a0\u00a0\u00a0LCS from this state is equal to maximum value of Option 1 and Option 2\n```", "```cpp\n    #include <iostream>\n    #include <time.h>\n    #include <iomanip>\n    #include <algorithm>\n    #include <utility>\n    #include <vector>\n    #include <strings.h>\n    #define DEBUG 1\n    #if DEBUG\n    #define PRINT(x) cerr << x\n    #else \n    #define PRINT(x)\n    #endif\n    using namespace std;\n    ```", "```cpp\n    vector<vector<pair<int, int>>> found;\n    int LCS_BruteForce(string A, string B, int i, int j, vector<pair<int, int>> subsequence)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    }\n    ```", "```cpp\n    // If i exceeds length of A, or j exceeds length of B:\n    if(i >= A.size() || j >= B.size())\n    {\n    \u00a0\u00a0\u00a0\u00a0found.push_back(subsequence);\n    \u00a0\u00a0\u00a0\u00a0//Terminate recursion and return length of subsequence\n    \u00a0\u00a0\u00a0\u00a0return subsequence.size();\n    }\n    // if A[i] = B[j]:\n    if(A[i] == B[j])\n    {\n    \u00a0\u00a0\u00a0\u00a0// Increase length of subsequence by 1\n    \u00a0\u00a0\u00a0\u00a0subsequence.push_back({ i, j });\n    \u00a0\u00a0\u00a0\u00a0// Increment both i and j by 1 \n    \u00a0\u00a0\u00a0\u00a0return LCS_BruteForce(A, B, i + 1, j + 1, subsequence);\n    }\u00a0\u00a0\u00a0\u00a0\n    /*\n    \u00a0\u00a0\u00a0\u00a0Option 1) Explore further possibilities with i + 1, and j\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0Option 2) Explore further possibilities with i, and j + 1\n    \u00a0\u00a0\u00a0\u00a0LCS from this state is equal to maximum value of Option 1 and Option 2\n    */\n    return max(LCS_BruteForce(A, B, i + 1, j, subsequence),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 LCS_BruteForce(A, B, i, j + 1, subsequence));\n    ```", "```cpp\n    int main() \n    {\n    \u00a0\u00a0\u00a0\u00a0string A, B;\n    \u00a0\u00a0\u00a0\u00a0cin >> A >> B;\n    \u00a0\u00a0\u00a0\u00a0int LCS = LCS_BruteForce(A, B, 0, 0, {}); \n    \u00a0\u00a0\u00a0\u00a0cout << \"Length of the longest common subsequence of \" << A << \" and \" << B << \" is: \" << LCS << endl;\n    \u00a0\u00a0\u00a0\u00a0\u2026\u00a0\u00a0\u00a0\u00a0\n    }\n    ```", "```cpp\n    void PrintSubsequences(string A, string B)\n    {\n    \u00a0\u00a0\u00a0\u00a0// Lambda function for custom sorting logic\n    \u00a0\u00a0\u00a0\u00a0sort(found.begin(), found.end(), [](auto a, auto b)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// First sort subsequences by length\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(a.size() != b.size())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return a.size() < b.size();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Sort subsequences of same size by lexicographical order of index\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return a < b;\n    \u00a0\u00a0\u00a0\u00a0});\n    \u00a0\u00a0\u00a0\u00a0// Remove duplicates \n    \u00a0\u00a0\u00a0\u00a0found.erase(unique(found.begin(), found.end()), found.end());\n    \u00a0\u00a0\u00a0\u00a0int previousSize = 0;\n    \u00a0\u00a0\u00a0\u00a0for(auto subsequence : found)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(subsequence.size() != previousSize)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0previousSize = subsequence.size();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PRINT(\"SIZE = \" << previousSize << endl);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Fill with underscores as placeholder characters\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0string a_seq(A.size(), '_');\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0string b_seq(B.size(), '_');\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto pair : subsequence)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Fill in the blanks with the characters of each string that are part of the subsequence\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a_seq[pair.first] = A[pair.first];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b_seq[pair.second] = B[pair.second];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PRINT(\"\\t\" << a_seq << \" | \" << b_seq << endl);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u2026\u2026\n    #if DEBUG\n    \u00a0\u00a0\u00a0\u00a0PrintSubsequences();\n    #endif\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    Length of the longest common subsequence of ABCX and ACYXB is: 3\n    SIZE = 1\n    \u00a0\u00a0\u00a0\u00a0A___ A____\n    SIZE = 2\n    \u00a0\u00a0\u00a0\u00a0AB__ A___B\n    \u00a0\u00a0\u00a0\u00a0A_C_ AC___\n    \u00a0\u00a0\u00a0\u00a0A__X A__X_\n    SIZE = 3\n    \u00a0\u00a0\u00a0\u00a0A_CX AC_X_\n    ```", "```cpp\nLCS(A, B, 0, 0) = 1 + LCS(A, B, 1, 1)\n```", "```cpp\nA = \"ABC\"\nB = \"AXB\"\nLCS of \"ABC\", \"AXB\" \n= max(LCS of \"AB\" and \"AXB\", LCS of \"ABC\" and \"AX\") \n= LCS of \"AB\" and \"AXB\"\n= \"AB\"\n```", "```cpp\nIf prefix for either string is empty:\n\u00a0\u00a0\u00a0LCS = 0\nOtherwise:\n\u00a0\u00a0\u00a0If character in last position of A's prefix is equal to character in last position of B's prefix:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LCS is equal to 1 + LCS of prefix of A with last character removed and prefix of B with last character removed\n\u00a0\u00a0\u00a0Otherwise:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 LCS is equal to maximum of:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01) LCS of A's current prefix and B's prefix with last character removed \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02) LCS of B's current prefix and A's prefix with last character removed \n```", "```cpp\nIf i = 0 or j = 0 (empty prefix):\n\u00a0\u00a0LCS(i, j) = 0\nOtherwise:\n\u00a0\u00a0If the last characters of both prefixes are equal:\n\u00a0\u00a0\u00a0\u00a0LCS(i, j) = LCS(i - 1, j - 1) + 1\n\u00a0\u00a0Otherwise:\n\u00a0\u00a0\u00a0\u00a0LCS(i, j) = Maximum of:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LCS(i - 1, j) \uf0e0 LCS for A's current prefix and B's prefix with the last character removed \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LCS(i, j - 1) \uf0e0 LCS for B's current prefix and A's prefix with the last character removed\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a02\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a04\u00a0\u00a0\u00a0\u00a05\u00a0\u00a0\u00a06\nMelody: \u00a0\u00a0\u00a0\u00a0{ \"A\", \"B\", \"C\", \"C\", \"E\", \"C, \"A\" }\nNote set: \u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\" }\nSubsets:\n\u00a0\u00a0\u00a0\u00a0{ 0, 2, 4 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 3, 4 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 4, 5 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"E\", \"C\" }\n\u00a0\u00a0\u00a0\u00a0{ 2, 4, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"C\", \"E\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 3, 4, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"C\", \"E\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 4, 5, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"E\", \"C\", \"A\" }\n\n\u00a0\u00a0\u00a0\u00a0{ 0, 2, 3, 4 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"C\", \"E\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 2, 4, 5 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\", \"C\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 2, 4, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 3, 4, 5 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\", \"C\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 3, 4, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 4, 5, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"E\", \"C\", \"A\" }  \n\u00a0\u00a0\u00a0\u00a0{ 2, 3, 4, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"C\", \"C\", \"E\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 2, 4, 5, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"C\", \"E\", \"C\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 3, 4, 5, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"C\", \"E\", \"C\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 2, 3, 4, 5 }\u00a0\u00a0\u00a0\u00a0   \u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"C\", \"E\", \"C\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 2, 3, 4, 6 }\u00a0\u00a0\u00a0\u00a0   \u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"C\", \"E\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 2, 4, 5, 6 }\u00a0\u00a0\u00a0\u00a0   \u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\", \"C\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 0, 3, 4, 5, 6 }\u00a0\u00a0\u00a0\u00a0   \u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\", \"C\", \"A\" }\n\u00a0\u00a0\u00a0\u00a0{ 2, 3, 4, 5, 6 }\u00a0\u00a0\u00a0\u00a0   \u2014>\u00a0\u00a0\u00a0\u00a0{ \"C\", \"C\", \"E\", \"C\", \"A\" }\n\n\u00a0\u00a0\u00a0\u00a0{ 0, 2, 3, 4, 5, 6 }\u00a0\u00a0\u00a0\u00a0\u2014>\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"C\", \"E\", \"C\", \"A\" }\nTotal Permutations = 21\n```", "```cpp\nC\u00a0\u00a0\u2014 B# (B# is pronounced as \"B sharp\")\nC#\u00a0\u2014 Db (Db is pronounced as \"D flat\")\nD#\u00a0\u2014 Eb\nE\u00a0\u00a0\u2014 Fb\nE#\u00a0\u2014 F\nF#\u00a0\u2014 Gb\nG#\u00a0\u2014 Ab\nA#\u00a0\u2014 Bb\nB\u00a0\u00a0\u2014 Cb\n```", "```cpp\n{ A#, B#, C# }\u00a0\u00a0\u00a0= { Bb, C, Db },\n{ Fb, Db, Eb }\u00a0\u00a0\u00a0= { E, C#, D# },\n{ C, B#, E#, F }\u00a0= { C, C, F, F }\nAnd so on\u2026\n```", "```cpp\nMelody:\u00a0\u00a0\u00a0\u00a0{ \"A\", \"B\", \"C\", \"C\", \"E\", \"C, \"A\" }\nNote Set:\u00a0\u00a0\u00a0\u00a0{ \"A\", \"C\", \"E\" }\n```", "```cpp\nMelody:\u00a0\u00a0\u00a0\u00a0{ \"A\", \"B\", \"D\", \"C#\", \"E\", \"A\", \"F#\", \"B\", \"C\", \"C#\", \"D\", \"E\" }\nNote Set:\u00a0\u00a0\u00a0\u00a0{ \"B\", \"D\", \"F#\", \"E\" }\n```", "```cpp\nMelody:    { \"Bb\", \"Db\", \"Ab\", \"G\", \"Fb\", \"Eb\", \"G\", \"G\", \"Ab\", \"A\", \"Bb\", \"Cb\", \"Gb\", \"G\", \"E\", \"A\", \"G#\" }\nNote Set:\u00a0\u00a0\u00a0\u00a0{ \"Ab\", \"E\", \"G\" }\n```", "```cpp\nMelody:    { \"C\", \"C#\", \"D\", \"Bb\", \"E#\", \"F#\", \"D\", \"C#\", \"A#\", \"B#\", \"C#\", \"Eb\", \"Gb\", \"A\", \"A#\", \"Db\", \"B\", \"D#\" }\nNote Set:\u00a0\u00a0\u00a0\u00a0{ \"Bb\", \"C#\", \"D#\", \"B#\" }\n```", "```cpp\nMelody:    { \"A#\", \"B\", \"D#\", \"F#\", \"Bb\", \"A\", \"C\", \"C#\", \"Db\", \"Fb\", \"G#\", \"D\", \"Gb\", \"B\", \"Ab\", \"G\", \"C\", \"Ab\", \"F\", \"F#\", \"E#\", \"G\", \"Db\" }\nNote Set:\u00a0\u00a0\u00a0\u00a0{ \"A\", \"Db\", \"Gb\", \"A#\", \"B\", \"F#\", \"E#\" }\n```"]