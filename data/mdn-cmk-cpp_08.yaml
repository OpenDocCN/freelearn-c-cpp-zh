- en: '*Chapter 8*: Testing Frameworks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：测试框架'
- en: 'Tenured professionals know that testing has to be automated. Someone explained
    that to them years ago or they learned the hard way. This practice isn''t as obvious
    to inexperienced programmers: it seems unnecessary, additional work that doesn''t
    bring much value. No wonder: when someone is just starting writing code, they''ll
    avoid writing complex solutions and contributing to vast code bases. Most likely,
    they''re the sole developer on their pet project. These early projects hardly
    ever need more than a few months to complete, so there''s hardly any opportunity
    to see how code rots over a longer period.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的专家知道测试必须自动化。有人向他们解释了这一点，或者他们通过艰苦的方式学到了。这种做法对于没有经验的程序员来说并不那么明显：它似乎是不必要的，额外的工作，并不会带来太多价值。难怪：当某人刚开始编写代码时，他们会避免编写复杂的解决方案和为庞大的代码库做出贡献。他们很可能是他们宠物项目的唯一开发者。这些早期的项目通常需要不到几个月就能完成，所以几乎没有任何机会看到代码在更长时间内是如何变质的。
- en: All these factors contribute toward the notion that writing tests is a waste
    of time and effort. The programming apprentice may say to themselves that they
    actually do test their code each time they execute the "build-and-run" routine.
    After all, they have manually confirmed that their code works and does what's
    expected. It's finally time to move on to the next task, right?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素共同构成了编写测试是浪费时间和精力的观念。编程实习生可能会对自己说，每次执行“构建-运行”流程时，他们实际上确实测试了他们的代码。毕竟，他们已经手动确认了他们的代码可以工作，并且做到了预期。现在是时候转向下一个任务了，对吧？
- en: Automated testing guarantees that new changes don't accidentally break our program.
    In this chapter, we'll learn why tests are important and how to use CTest (a tool
    bundled with CMake) to coordinate test execution. CTest is capable of querying
    available tests, filtering execution, shuffling, repeating, and time-limiting.
    We'll explore how to use those features, control the output of CTest, and handle
    test failures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试确保新的更改不会意外地破坏我们的程序。在本章中，我们将学习测试的重要性以及如何使用与CMake捆绑的CTest工具来协调测试执行。CTest能够查询可用的测试、过滤执行、洗牌、重复和限制时间。我们将探讨如何使用这些特性、控制CTest的输出以及处理测试失败。
- en: 'Next, we''ll adapt our project''s structure to support testing and create our
    own test runner. After discussing the basic principles, we''ll move on to adding
    popular testing frameworks: Catch2 and GoogleTest with its mocking library. Lastly,
    we''ll introduce detailed test coverage reporting with LCOV.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调整我们项目的结构以支持测试，并创建我们自己的测试运行器。在讨论基本原理之后，我们将继续添加流行的测试框架：Catch2和GoogleTest及其模拟库。最后，我们将介绍使用LCOV进行详细测试覆盖率报告。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Why are automated tests worth the trouble?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试为什么值得麻烦？
- en: Using CTest to standardize testing in CMake
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CTest在CMake中标准化测试
- en: Creating the most basic unit test for CTest
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为CTest创建最基本的单元测试
- en: Unit-testing frameworks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试框架
- en: Generating test coverage reports
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成测试覆盖率报告
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files present in this chapter on GitHub at the following
    link:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上的以下链接找到本章中存在的代码文件：
- en: '[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter08](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter08)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter08](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter08)'
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建本书中提供的示例，请始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符`<build tree>`和`<source tree>`替换为适当的路径。作为提醒：**build tree**是目标/输出目录的路径，**source
    tree**是您的源代码所在的路径。
- en: Why are automated tests worth the trouble?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试为什么值得麻烦？
- en: 'Imagine a factory line that has a machine putting holes in sheets of steel.
    These holes have to be of specific size and shape so that they can house bolts
    that will hold the finished product together. The designer of such a factory line
    will set up the machine, test if the holes are correct, and move on. Sooner or
    later, something will change: the factory will use different, thicker steel; a
    worker will accidentally change the hole size; or, simply, more holes need to
    be punched and the machine has to be upgraded. A smart designer will put quality-control
    checks at certain points on the line to make sure that the product follows the
    specification and retains its key qualities. Holes have to conform to particular
    requirements but it doesn''t really matter how they are created: drilled, punched,
    or laser-cut.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个工厂生产线，有一个机器在钢板上打孔。这些孔必须具有特定的尺寸和形状，以便它们可以容纳将最终产品固定的螺栓。这样一个工厂线的设计者会设置机器，测试孔是否正确，然后继续。迟早，一些东西会改变：工厂会使用不同、更厚的钢材；工人可能会意外地改变孔的大小；或者，简单地说，需要打更多的孔，机器必须升级。一个聪明的设计师会在生产线的某些点上设置质量控制检查，以确保产品遵循规格并保持其关键特性。孔必须符合特定的要求，但它们是如何产生的并不重要：钻孔、冲孔还是激光切割。
- en: 'The same approach finds application in software development: it''s very hard
    to predict which pieces of code will remain unchanged for years and which will
    see multiple revisions. As the functionality of the software expands, we need
    to make sure that we don''t accidentally break things. But we will. Even the best
    programmers will make mistakes because they can''t foresee all the implications
    of every change they make. As if that weren''t enough, developers often work on
    code written by someone else and they don''t know any of the intricate assumptions
    made earlier. They will read the code, build a rough mental model, add necessary
    changes, and hope they got it right. Most times, that''s true—until it isn''t.
    In such cases, an introduced bug can consume hours if not days to fix, not to
    mention the damage it can do to the product and the customers.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法在软件开发中也得到了应用：很难预测哪些代码将保持多年不变，哪些代码将经历多次修订。随着软件功能的扩展，我们需要确保我们不会意外地破坏东西。但是，我们还是会犯错。即使是最优秀的程序员也会犯错，因为他们无法预见他们所做的每一处改动的全部影响。更不用说，开发者经常在别人编写的代码上工作，他们不知道之前做出了哪些微妙的假设。他们会阅读代码，建立一个粗略的心理模型，添加必要的改动，并希望他们做对了。大多数时候，这是真的——直到它不再是。在这种情况下，引入的错误可能需要花费数小时甚至数天来修复，更不用说它可能对产品和客户造成的损害。
- en: On occasion, you will stumble upon some code that is really hard to understand
    and follow. You will not only question how the code came to be and what it does,
    but you will also start a witch-hunt to figure out who's to blame for creating
    such a mess. Don't be too surprised if it turns out that you're the author. It
    has happened to me, and it will happen to you. Sometimes, code is created in a
    hurry, without a full understanding of the problem. As developers, we're not only
    under pressure from deadlines or budgets. Woken up in the middle of the night
    to fix a critical failure, you'll be appalled at how certain errors can slip past
    code review.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你可能会遇到一些非常难以理解和跟进去的代码。你不仅会质疑这段代码是如何产生的以及它做了什么，你还会开始追查谁应该为创造这样的混乱负责。如果你发现自己是作者，也别太惊讶。这曾经发生在我身上，也会发生在你身上。有时候，代码是在匆忙中编写的，没有完全理解问题。作为开发者，我们不仅受到截止日期或预算的压力。半夜被叫醒修复一个关键故障，你会对某些错误如何逃过代码审查感到震惊。
- en: Most of this can be avoided with automated tests. These are pieces of code that
    check if another piece of code (used in production) is behaving correctly. As
    the name suggests, automated tests should be executed without prompts every time
    someone makes a change. It usually happens as part of the build process and is
    often added as a step to control the code quality before merging it into the repository.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些问题都可以通过自动化测试来避免。这些测试代码用于检查另一段代码（即生产中使用的代码）是否正确运行。正如其名，自动化测试应该在每次有人做出改动时无需提示地执行。这通常作为构建过程的一部分发生，并且经常作为控制代码质量的一个步骤，在将其合并到仓库之前执行。
- en: 'You may be tempted to avoid automated tests to save time. That would be a very
    costly lesson. Steven Wright rightfully said: "*Experience is something you don''t
    get until just after you need it.*" Trust me: unless you''re writing a one-off
    script for personal purposes or prototyping a non-production experiment, don''t
    skip writing tests. Initially, you might get annoyed by the fact that the code
    you meticulously crafted is constantly failing tests. But if you really think
    about it, that failed test just stopped you from adding a breaking change to production.
    The effort invested now will pay off as time is saved on bug-fixing (and full
    nights of sleep). Tests are not as hard to add and maintain as they may seem.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会有避免自动化测试以节省时间的冲动。这将是一个非常昂贵的教训。史蒂文·赖特（Steven Wright）说得对：“*经验是你需要的经验之后才得到的*。”相信我：除非你正在为个人目的编写一次性脚本，或者为非生产性原型编写脚本，否则不要跳过编写测试。最初，你可能会因为自己精心编写的代码不断在测试中失败而感到烦恼。但如果你真的思考一下，那个失败的测试刚刚阻止了你将一个破坏性更改推送到生产环境中。现在投入的努力将在节省修复bug（和完整的夜晚睡眠）方面得到回报。测试并不像看起来那么难以添加和维护。
- en: Using CTest to standardize testing in CMake
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CTest 在 CMake 中标准化测试
- en: Ultimately, automated testing involves nothing other than running an executable
    that sets your `test_my_app`, another will go with `unit_tests`, and a third will
    use something obscure or not provide tests at all. Discovering which file needs
    to be run, which framework is used, which arguments should be passed to the runner,
    and how to collect results are problems that users would like to avoid.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，自动化测试涉及到的不过是运行一个可执行文件，设置你的 `test_my_app`，另一个将使用 `unit_tests`，第三个将使用一些不明显或者根本不提供测试的文件。找出需要运行哪个文件，使用哪个框架，向运行器传递哪些参数，以及如何收集结果是用户希望避免的问题。
- en: 'CMake solves this by introducing a separate `ctest` command-line tool. It''s
    configured by the project''s author through listfiles and provides a unified way
    of executing tests: the same, standardized interface for every project built with
    CMake. If you follow this convention, you will enjoy other benefits down the line:
    adding the project to a (CI/CD) pipeline will be easier, surfacing them in (IDEs)
    such as Visual Studio or CLion—all of these things will be streamlined and more
    convenient. More importantly, you''ll get a more powerful test-running utility
    with very little investment.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 通过引入一个独立的 `ctest` 命令行工具来解决这个问题。它由项目作者通过列表文件进行配置，并为执行测试提供了一个统一的方式：对于使用
    CMake 构建的每个项目，都有一个相同的、标准化的接口。如果你遵循这个约定，你将享受其他好处：将项目添加到（CI/CD）流水线将更容易，在诸如 Visual
    Studio 或 CLion 等（IDE）中突出显示它们——所有这些事情都将得到简化，更加方便。更重要的是，你将用非常少的投入获得一个更强大的测试运行工具。
- en: 'How to execute tests with CTest on an already configured project? We''ll need
    to pick one of the following three modes of operation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在一个已经配置的项目上使用 CTest 执行测试？我们需要选择以下三种操作模式之一：
- en: Test
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Build-and-test
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建与测试
- en: Dashboard client
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板客户端
- en: 'The last mode allows you to send the results of the test to a separate tool
    called CDash (also from Kitware). CDash collects and aggregates software-quality
    test results in an easy-to-navigate dashboard, as illustrated in the following
    screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种模式允许您将测试结果发送到一个名为 CDash 的单独工具（也来自 Kitware）。CDash 通过一个易于导航的仪表板收集和汇总软件质量测试结果，如下面的屏幕截图所示：
- en: '![Figure 8.1 ‒ Screenshot of the CDash dashboard timeline view'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 ‒ CDash 仪表板时间轴视图的屏幕截图'
- en: '](img/Figure_8.1_B17205.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B17205.jpg)'
- en: Figure 8.1 ‒ Screenshot of the CDash dashboard timeline view
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 ‒ CDash 仪表板时间轴视图的屏幕截图
- en: CDash isn't in the scope of this book since it's an advanced solution used as
    a shared server, accessible for all developers in a company.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: CDash 不在本书的范围内，因为它是作为共享服务器的高级解决方案，可供公司中的所有开发者访问。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you''re interested in learning more online, reference the official documentation
    of CMake and visit the CDash website:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣在线学习，请参考 CMake 的官方文档并访问 CDash 网站：
- en: '[https://cmake.org/cmake/help/latest/manual/ctest.1.html#dashboard-client](https://cmake.org/cmake/help/latest/manual/ctest.1.html#dashboard-client)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cmake.org/cmake/help/latest/manual/ctest.1.html#dashboard-client](https://cmake.org/cmake/help/latest/manual/ctest.1.html#dashboard-client)'
- en: '[https://www.cdash.org/](https://www.cdash.org/)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.cdash.org/](https://www.cdash.org/)'
- en: 'Let''s get back to the first two modes. The command line for test mode looks
    like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到前两种模式。测试模式的命令行如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this mode, CTest should be executed in the build tree, after building the
    project with `cmake`. This is slightly cumbersome during the development cycle,
    as you''d need to execute multiple commands and change the working directory back
    and forth. To simplify the process, CTest added a second mode: `build-and-test`
    mode.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，应在构建树中执行CTest，在用`cmake`构建项目之后。在开发周期中，这有点繁琐，因为您需要执行多个命令并来回更改工作目录。为了简化这个过程，CTest增加了一个第二种模式：`build-and-test`模式。
- en: Build-and-test mode
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和测试模式
- en: 'To use this mode, we need to execute `ctest` starting with `--build-and-test`,
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模式，我们需要以`--build-and-test`开始执行`ctest`，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Essentially, this is a simple wrapper around the regular test mode that accepts
    a few build configuration options and allows us to append the command for the
    first mode— in other words, all options that can be passed to `ctest <options>`
    will work when passed to `ctest --build-and-test`. The only requirement here is
    to pass the full command after the `--test-command` argument. Contrary to what
    you might think, build-and-test mode won''t actually run any tests unless provided
    with `ctest` keyword after `--test-command`, like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这是一个简单的包装器，它围绕常规测试模式接受一些构建配置选项，并允许我们添加第一个模式下的命令——换句话说，所有可以传递给`ctest <options>`的选项，在传递给`ctest
    --build-and-test`时也会生效。这里唯一的要求是在`--test-command`参数之后传递完整的命令。与您可能认为的相反，除非在`--test-command`后面提供`ctest`关键字，否则构建和测试模式实际上不会运行任何测试，如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this command, we specify source and build paths, and select a build generator.
    All three are required and follow the rules for the `cmake` command, described
    in detail in [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014), *First
    Steps with CMake*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们需要指定源和构建路径，并选择一个构建生成器。这三个都是必需的，并且遵循`cmake`命令的规则，在[*第1章*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)、*CMake的初步步骤*中有详细描述。
- en: You may pass additional arguments to this mode. They come in three groups, controlling
    the configuration, the build process, or the tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以传递额外的参数给这个模式。它们分为三组，分别控制配置、构建过程或测试。
- en: 'Here are the arguments for controlling the configuration stage:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制配置阶段的参数：
- en: '`--build-options`—Any extra options for the `cmake` configuration (not the
    build tool) should be provided just before `--test-command`, which comes last.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-options`—任何额外的`cmake`配置（不是构建工具）选项应紧接在`--test-command`之前，这是最后一个参数。'
- en: '`--build-two-config`—Run the configuration stage for CMake twice.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-two-config`—为CMake运行两次配置阶段。'
- en: '`--build-nocmake`—Skip the configuration stage.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-nocmake`—跳过配置阶段。'
- en: '`--build-generator-platform`, `--build-generator-toolset`—Provide a generator-specific
    platform and toolset.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-generator-platform`, `--build-generator-toolset`—提供生成器特定的平台和工具集。'
- en: '`--build-makeprogram`—Specify a `make` executable when using Make- or Ninja-based
    generators.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-makeprogram`—在使用Make或Ninja生成器时指定`make`可执行文件。'
- en: 'Here are the arguments for controlling the build stage:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制构建阶段的参数：
- en: '`--build-target`—Build the specified target (instead of the `all` target).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-target`—构建指定的目标（而不是`all`目标）。'
- en: '`--build-noclean`—Build without building the `clean` target first.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-noclean`—在不首先构建`clean`目标的情况下进行构建。'
- en: '`--build-project`—Provide the name of the built project.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-project`—提供构建项目的名称。'
- en: 'This is the argument used to control the test stage:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于控制测试阶段的参数：
- en: '`--test-timeout`—Limit the execution of tests (provided in seconds).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--test-timeout`—限制测试的执行时间（以秒为单位）。'
- en: All that's left is to configure the regular testing mode after the `--test-command
    cmake` argument.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是在`--test-command cmake`参数之后配置常规测试模式。
- en: Test mode
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试模式
- en: Assuming that we have built our project and we're executing `ctest` in the build
    tree (or we're using the `build-and-test` wrapper), we can finally execute our
    tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经构建了我们的项目，并且我们在构建树中执行`ctest`（或者我们使用`build-and-test`包装器），我们最终可以执行我们的测试。
- en: A simple `ctest` command without any arguments is usually enough to get satisfactory
    results in most scenarios. If all tests pass, `ctest` will return a `0` exit code.
    Use this in your CI/CD pipeline to prevent faulty commits from merging to your
    repository's production branch.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何参数的情况下，一个简单的`ctest`命令通常足以在大多数场景中获得满意的结果。如果所有测试都通过，`ctest`将返回一个`0`的退出码。您可以在CI/CD管道中使用此命令，以防止有错误的提交合并到您仓库的生产分支。
- en: 'Writing good tests can be as challenging as writing the production code itself.
    We set up our SUT to be in a specific state, run a single test, and then tear
    down the SUT instance. This process is rather complex and can generate all sorts
    of issues: cross-test pollution, temporal and concurrency disruptions, resource
    contention, frozen execution due to deadlocks, and many others.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 编写好的测试可能和编写生产代码本身一样具有挑战性。我们将SUT设置为特定的状态，运行一个测试，然后拆除SUT实例。这个过程相当复杂，可能会产生各种问题：跨测试污染、时间和并发干扰、资源争用、由于死锁而导致的执行冻结，以及其他许多问题。
- en: We can employ strategies that help detect and solve some of these problems.
    CTest allows you to affect test selection, their order, produced output, time
    limits, repetition, and so on. The following sections will provide the necessary
    context and a brief overview of the most useful options. As always, refer to the
    CMake documentation for an exhaustive list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用一些策略来帮助检测和解决这些问题。CTest允许你影响测试选择、它们的顺序、产生的输出、时间限制、重复等等。以下部分将提供必要的上下文和对最有用选项的简要概述。像往常一样，请参阅CMake文档以获取详尽的列表。
- en: Querying tests
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询测试
- en: 'The first thing we might need to do is to understand which tests are actually
    written for the project. CTest offers an `-N` option, which disables execution
    and only prints a list, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要做的第一件事就是理解哪些测试实际上是为本项目编写的。CTest提供了一个`-N`选项，它禁用执行，只打印列表，如下所示：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You might want to use `-N` with the filters described in the next section to
    check which tests would be executed when a filter is applied.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想用下一节中描述的筛选器与`-N`一起使用，以检查当应用筛选器时会执行哪些测试。
- en: If you need a JSON format that can be consumed by automated tooling, execute
    `ctest` with `--show-only=json-v1`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个可以被自动化工具消费的JSON格式，请用`--show-only=json-v1`执行`ctest`。
- en: 'CTest also offers a mechanism to group tests with `LABELS` keyword. To list
    all available labels (without actually executing any tests), use `--print-labels`.
    This option is helpful when tests are defined manually with the `add_test(<name>
    <test-command>)` command in your listfile, as you are then able to specify individual
    labels through test properties, like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: CTest还提供了一个用`LABELS`关键字来分组测试的机制。要列出所有可用的标签（而不实际执行任何测试），请使用`--print-labels`。这个选项在测试用手动定义时很有帮助，例如在你的列表文件中使用`add_test(<name>
    <test-command>)`命令，因为你可以通过测试属性指定个别标签，像这样：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On the other hand, the frameworks we'll discuss later provide automatic test
    discovery, which unfortunately doesn't support such a granular level of labeling
    yet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们稍后讨论的框架提供了自动测试发现，不幸的是，它还不支持如此细粒度的标签。
- en: Filtering tests
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤测试
- en: There are plenty of reasons to run only a subset of all tests—the most common
    one might be the need to debug a single failing test or a module you're working
    on. There's no point in waiting for all other tests in that case. Other advanced
    testing scenarios will even go as far as partitioning test cases and distributing
    the load across a fleet of test runners.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多理由只运行所有测试的一部分——最常见的原因可能是需要调试一个失败的测试或你正在工作的模块。在这种情况下，等待所有其他测试是没有意义的。其他高级测试场景甚至可能将测试用例分区并在测试运行器集群上分布负载。
- en: 'These flags will filter tests according to the provided `<r>` **regular expression**
    (**regex**), as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志将根据提供的`<r>` **正则表达式**（**regex**）过滤测试，如下所示：
- en: '`-R <r>`, `--tests-regex <r>`—Only run tests with names matching `<r>`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-R <r>`, `--tests-regex <r>`—只运行名称匹配`<r>`的测试'
- en: '`-E <r>`, `--exclude-regex <r>`—Skip tests with names matching `<r>`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-E <r>`, `--exclude-regex <r>`—跳过名称匹配`<r>`的测试'
- en: '`-L <r>`, `--label-regex <r>`—Only run tests with labels matching `<r>`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-L <r>`, `--label-regex <r>`—只运行标签匹配`<r>`的测试'
- en: '`-LE <r>`, `--label-exclude <regex>`—Skip tests with labels matching `<r>`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-LE <r>`, `--label-exclude <正则表达式>`—跳过标签匹配`<r>`的测试'
- en: 'Advanced scenarios can be achieved with the `--tests-information` option (or
    the shorter form, `-I`). Use this filter to provide a range in a comma-separated
    format: `<start>, <end>, <step>`. Any of the fields can be empty, and after one
    more comma, you can append individual `<test-id>` values to run them additionally.
    Here are some examples:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--tests-information`选项（或更短的形式，`-I`）可以实现高级场景。用这个筛选器提供一个逗号分隔的范围内的值：`<开始>, <结束>,
    <步长>`。任意字段都可以为空，再有一个逗号之后，你可以附加个别`<测试ID>`值来运行它们。以下是几个例子：
- en: '`-I 3,,` will skip tests 1 and 2 (execution starts from the third test)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-I 3,,`将跳过1和2个测试（执行从第三个测试开始）'
- en: '`-I ,2,` will only run the first and second test'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-I ,2,`只运行第一和第二个测试'
- en: '`-I 2,,3` will run every third test, starting from the second test in the row'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-I 2,,3`将从第二行开始运行每个第三测试'
- en: '`-I ,0,,3,9,7` will only run the third, ninth, and seventh test'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-I ,0,,3,9,7`将只运行第三、第九和第七个测试'
- en: Optionally, CTest will accept the filename containing the specification in the
    same format. As you might imagine, users prefer filtering tests by name. This
    option can be used to distribute tests across multiple machines for really large
    suites.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 选择性地，CTest将接受包含规格的文件名，格式与上面相同。正如您所想象的，用户更喜欢按名称过滤测试。此选项可用于将测试分布到多台机器上，适用于非常大的测试套件。
- en: By default, the `-I` option used with `-R` will narrow the execution (only tests
    matching both requirements will run). Add the `-U` option if you need the union
    of the two to execute instead (any of the requirements will suffice).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，与`-R`一起使用的`-I`选项将缩小执行范围（仅运行同时满足两个要求的测试）。如果您需要两个要求的并集来执行（任一要求即可），请添加`-U`选项。
- en: As mentioned before, you can use the `-N` option to check the outcome of filtering.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以使用`-N`选项来检查过滤结果。
- en: Shuffling tests
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 洗牌测试
- en: Writing unit tests can be tricky. One of the more surprising problems to encounter
    is test coupling, which is a situation where one test affects another by incompletely
    setting or clearing the state of SUT. In other words, the first test to execute
    can "leak" its state and pollute the second test. Such coupling is bad news because
    it introduces unknown, implicit relations between tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试可能很棘手。遇到的一个更令人惊讶的问题就是测试耦合，这是一种情况，其中一个测试通过不完全设置或清除SUT的状态来影响另一个测试。换句话说，首先执行的测试可能会“泄漏”其状态，污染第二个测试。这种耦合之所以糟糕，是因为它引入了测试之间的未知、隐性关系。
- en: 'What''s worse, this kind of error is known to hide really well in the complexities
    of testing scenarios. We might detect it when it causes one of the tests to fail
    when it shouldn''t, but the opposite is equally possible: an incorrect state causes
    the test to pass when it shouldn''t. Such falsely passing tests give developers
    an illusion of security, which is even worse than not having tests at all. The
    assumption that the code is correctly tested may encourage bolder actions, leading
    to unexpected outcomes.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，这种错误在测试场景的复杂性中隐藏得非常好。我们可能会在它导致测试失败时检测到它，但反之亦然：错误的状态导致测试通过，而它本不该通过。这种虚假通过的测试给开发者带来了安全感，这比没有测试还要糟糕。代码正确测试的假设可能会鼓励更大胆的行动，导致意外的结果。
- en: One way of discovering such problems is by running each test in isolation. Usually,
    this is not the case when executing test runners straight from the testing framework
    without CTest. To run a single test, you'll need to pass a framework-specific
    argument to the test executable. This allows you to detect tests that are passing
    in the suite but are failing when executed on their own.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 发现此类问题的一种方法是单独运行每个测试。通常，当我们直接从测试框架中执行测试运行器而不使用CTest时，并非如此。要运行单个测试，您需要向测试可执行文件传递框架特定的参数。这允许您检测在测试套件中通过但在单独执行时失败的测试。
- en: CTest, on the other hand, effectively removes all memory-based cross-contamination
    of tests by implicitly executing every test case in a child CTest instance. You
    may even go further and add the `--force-new-ctest-process` option to enforce
    separate processes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，CTest有效地消除了所有基于内存的测试交叉污染，通过隐式执行子CTest实例中的每个测试用例。您甚至可以更进一步，添加`--force-new-ctest-process`选项以强制使用单独的进程。
- en: Unfortunately, this alone won't work if your tests are using external, contested
    resources such as GPUs, databases, or files. An additional precaution we can take
    is to simply randomize the order of test execution. Such disturbance is often
    enough to eventually detect such spuriously passing tests. CTest supports this
    strategy with the `--schedule-random` option.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，仅凭这一点还不足以应对测试使用的外部、争用资源，如GPU、数据库或文件。我们可以采取的额外预防措施之一是简单地随机化测试执行顺序。这种干扰通常足以最终检测到这种虚假通过的测试。CTest支持这种策略，通过`--schedule-random`选项。
- en: Handling failures
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理失败
- en: 'Here''s a famous quote from John C. Maxwell: "*Fail early, fail often, but
    always fail forward.*" This is exactly what we want to do when running unit tests
    (and perhaps in other areas of life). Unless you''re running your tests with a
    debugger attached, it''s not easy to learn where you made a mistake as CTest will
    keep things brief and only list tests that failed, without actually printing any
    of their output.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一句约翰·C· Maxwell 著名的名言：“*Fail early, fail often, but always fail forward.*”
    这正是我们在执行单元测试时（也许在生活的其他领域）想要做的事情。除非你在运行测试时附带了调试器，否则很难了解到你在哪里出了错，因为CTest会保持简洁，只列出失败的测试，而不实际打印它们的输出。
- en: Messages printed to `stdout` by the test case or the SUT might be invaluable
    to determine what was wrong exactly. To see them, we can run `ctest` with `--output-on-failure`.
    Alternatively, setting the `CTEST_OUTPUT_ON_FAILURE` environment variable will
    have the same effect.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 测试案例或SUT打印到`stdout`的信息可能对确定具体出了什么问题非常有价值。为了看到这些信息，我们可以使用`--output-on-failure`运行`ctest`。另外，设置`CTEST_OUTPUT_ON_FAILURE`环境变量也会有相同的效果。
- en: Depending on the size of the solution, it might make sense to stop execution
    after any of the tests fail. This can be done by providing the `--stop-on-failure`
    argument to `ctest`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据解决方案的大小，在任何一个测试失败后停止执行可能是有意义的。这可以通过向`ctest`提供`--stop-on-failure`参数来实现。
- en: CTest stores the names of failed tests. In order to save time in lengthy test
    suites, we can focus on these failed tests and skip running the passing tests
    until the problem is solved. This feature is enabled with the `--rerun-failed`
    option (any other filters will be ignored). Remember to run all tests after solving
    all issues to make sure that no regression has been introduced in the meantime.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: CTest存储了失败测试的名称。为了在漫长的测试套件中节省时间，我们可以关注这些失败的测试，并在解决问题前跳过运行通过的测试。这个特性可以通过使用`--rerun-failed`选项来实现（忽略其他任何过滤器）。记得在解决问题后运行所有测试，以确保在此期间没有引入回归。
- en: 'When CTest doesn''t detect any tests, it may mean two things: either tests
    aren''t there or there''s an issue with the project. By default, `ctest` will
    print a warning message and return a `0` exit code, to avoid muddying the waters.
    Most users will have enough context to understand which case they encountered
    and what to do next. However, in some environments, `ctest` will be executed always,
    as part of an automated pipeline. Then, we might need to explicitly say that a
    lack of tests should be interpreted as an error (and return a nonzero exit code).
    We can configure this behavior by providing the `--no-tests=error` argument. For
    the opposite behavior (no warning), use the `--no-tests=ignore` option.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当CTest没有检测到任何测试时，这可能意味着两件事：要么是测试不存在，要么是项目有问题。默认情况下，`ctest`会打印一条警告信息并返回一个`0`退出码，以避免混淆。大多数用户会有足够的上下文来理解他们遇到了哪种情况以及接下来应该做什么。然而，在某些环境中，`ctest`总是会执行，作为自动化流水线的一部分。那么，我们可能需要明确表示，测试的缺失应该被解释为错误（并返回非零退出码）。我们可以通过提供`--no-tests=error`参数来配置这种行为。要实现相反的行为（不警告），请使用`--no-tests=ignore`选项。
- en: Repeating tests
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复执行测试
- en: 'Sooner or later in your career, you''ll encounter tests that work correctly
    most of the time. I want to emphasize the word *most*. Once in a blue moon, these
    tests will fail for environmental reasons: because of incorrectly mocked time,
    issues with event loops, poor handling of asynchronous execution, parallelism,
    hash collisions, and other really complicated scenarios that don''t occur on every
    run. These unreliable tests are called "flaky tests".'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早在你的职业生涯中，你将会遇到那些大部分时间都能正确工作的测试。我想强调一下*most*这个词。偶尔，这些测试会因为环境原因而失败：由于错误地模拟了时间、事件循环问题、异步执行处理不当、并发性、散列冲突，以及其他在每次运行时都不会发生的非常复杂的情况。这些不可靠的测试被称为“flaky
    tests”。
- en: 'Such inconsistency seems a not-so-important problem. We might say that tests
    aren''t a real production environment and this is the ultimate reason why they
    sometimes fail. There is a grain of truth in this: tests aren''t meant to replicate
    every little detail, because it''s not viable. Tests are a simulation, an approximation
    of what might happen, and that''s usually good enough. Does it hurt to rerun tests
    if they''ll pass on the next execution?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不一致性看起来并不是一个很重要的问题。我们可能会说测试并不等同于真正的生产环境，这也是它们有时候会失败的根本原因。这种说法有一定的道理：测试不可能模拟每一个细节，因为这并不可行。测试是一种模拟，是对可能发生的事情的一种近似，这通常已经足够好了。如果测试在下次执行时会通过，重新运行测试有什么害处呢？
- en: 'Actually, it does. There are three main concerns, as outlined here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是有关系的。主要有三个担忧，如下所述：
- en: 'If you have gathered enough flaky tests in your code base, they will become
    a serious obstacle to the smooth delivery of code changes. It''s especially frustrating
    when you''re in a hurry: either getting ready to go home on a Friday afternoon
    or delivering a critical fix to a severe issue impacting your customers.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在你的代码库中收集了足够的不稳定测试，它们将成为代码变更顺利交付的一个严重障碍。尤其是当你急于回家（比如周五下午）或交付一个严重影响客户问题的紧急修复时，这种情况尤其令人沮丧。
- en: 'You can''t be truly sure that your flaky tests are failing because of the inadequacy
    of the testing environment. It may be the opposite: they fail because they replicated
    a rare scenario that already occurs in production. It''s just not obvious enough
    to raise an alert… yet.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你无法真正确信你的不稳定测试之所以失败是因为测试环境的不足。可能正好相反：它们失败是因为它们复现了一个在生产环境中已经发生的罕见场景。只是还没有足够明显地发出警报…
    而已。
- en: It's not the test that's flaky—it's your code! The environment is wonky from
    time to time—as programmers, we deal with that in a deterministic manner. If SUT
    behaves this way, it's a sign of a serious error—for example, the code might be
    reading from uninitialized memory.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是测试本身具有不稳定性——是你的代码有问题！环境有时确实会出问题——作为程序员，我们以确定性的方式处理这些问题。如果SUT以这种方式运行，这是一个严重错误的迹象——例如，代码可能正在读取未初始化的内存。
- en: 'There isn''t a perfect way to address all of the preceding cases—the multitude
    of possible reasons is simply too great. However, we might increase our chance
    of identifying flaky tests by running them repeatedly with the `–repeat <mode>:<#>`
    option. Three modes are available, as outlined here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种完美的方式来解决所有上述情况——可能的原因太多。然而，我们可以通过使用`–repeat <mode>:<#>`选项来重复运行测试，从而增加我们识别不稳定测试的机会。以下是三种可供选择的模式：
- en: '`until-fail`—Run test `<#>` times; all runs have to pass.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until-fail`—运行测试`<#>`次；所有运行都必须通过。'
- en: '`until-pass`—Run test up to `<#>` times; it has to pass at least once. This
    is useful when dealing with tests that are known to be flaky, but too difficult
    and important to debug or disable.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until-pass`—运行测试至`<#>`次；至少要通过一次。当处理已知具有不稳定性的测试时，这个方法很有用，但这些测试太难且重要，无法进行调试或禁用。'
- en: '`after-timeout`—Run test up to `<#>` times but retry only if the test is timing
    out. Use it in busy test environments.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after-timeout`—运行测试至`<#>`次，但只有在测试超时的情况下才重试。在繁忙的测试环境中使用它。'
- en: A general recommendation is to debug flaky tests as quickly as possible or get
    rid of them if they can't be trusted to produce consistent results.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一般建议尽快调试不稳定测试或如果它们不能被信任以产生一致的结果，就摆脱它们。
- en: Controlling output
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制输出
- en: Printing every piece of information to the screen every time would instantly
    get incredibly busy. CTest reduces the noise and collects the outputs of tests
    it executes to the log files, providing only the most useful information on regular
    runs. When things go bad and tests fail, you can expect a summary and possibly
    some logs if you enabled `--output-on-failure`, as mentioned earlier.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每次都将所有信息打印到屏幕上会立即变得非常繁忙。Ctest减少了噪音，并将它执行的测试的输出收集到日志文件中，在常规运行中只提供最有用的信息。当事情变坏，测试失败时，如果你启用了`--output-on-failure`（如前面所述），你可以期待一个摘要，可能还有一些日志。
- en: I know from experience that "enough information" is enough until it isn't. Sometimes,
    we may want to see the output of passed tests too, perhaps to check if they're
    truly working (and not just silently stopping without an error). To get access
    to more verbose output, add the `-V` option (or `--verbose` if you want to be
    explicit in your automated pipelines). If that's not enough, you might want `-VV`
    or `--extra-verbose`. For extremely in-depth debugging, use `--debug` (but be
    prepared for walls of text with all the details).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我从经验中知道，“足够的信息”是足够的，直到它不再足够。有时，我们可能希望查看通过测试的输出，也许是为了检查它们是否真的在正常工作（而不是默默地停止，没有错误）。为了获取更详细的输出，可以添加`-V`选项（或者如果你想在自动化管道中明确表示，可以使用`--verbose`）。如果这还不够，你可能想要`-VV`或`--extra-verbose`。对于非常深入的调试，可以使用`--debug`（但要做好准备，因为会有很多文本细节）。
- en: If you're looking for the opposite, CTest also offers "Zen mode" enabled with
    `-Q`, or `--quiet`. No output will be printed then (you can stop worrying and
    learn to love the calm). It seems that this option has no other use than to confuse
    people, but be aware that the output will still be stored in test files (in `./Testing/Temporary`
    by default). Automated pipelines can check if the exit code is a nonzero value
    and collect the log files for further processing without littering the main output
    with details that may confuse developers not familiar with the product.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在寻找相反的，CTest还提供了通过`-Q`启用的“禅模式”，或`--quiet`。那时将不会打印任何输出（你可以停止担心，学会平静）。似乎这个选项除了让人困惑之外没有其他用途，但请注意，输出仍然会存储在测试文件中（默认在`./Testing/Temporary`中）。自动化管道可以通过检查退出代码是否非零值，并在不向开发者输出可能混淆的详细信息的情况下，收集日志文件进行进一步处理。
- en: 'To store the logs in a specific path, use the `-O <file>`, `--output-log <file>`
    option. If you''re suffering from lengthy outputs, there are two limit options
    to cap them to the given number of bytes per test: `--test-output-size-passed
    <size>` and `--test-output-size-failed <size>`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要将在特定路径存储日志，请使用`-O <文件>`、`--output-log <文件>`选项。如果您苦于输出过长，有两个限制选项可以将它们限制为每个测试给定的字节数：`--test-output-size-passed
    <大小>`和`--test-output-size-failed <大小>`。
- en: Miscellaneous
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项
- en: 'There are a few other useful options that can be useful for your everyday testing
    needs, as outlined here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的有用选项，可以满足你日常测试需求，如下所述：
- en: '`-C <cfg>, --build-config <cfg>` (multi-configuration generators only)—Use
    this to specify which configuration to test. The `Debug` configuration usually
    has debugging symbols, making things easier to understand, but `Release` should
    be tested too, as heavy optimization options could potentially affect the behavior
    of SUT.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-C <配置>, --build-config <配置>`（仅限多配置生成器）—使用此选项指定要测试的配置。`Debug`配置通常包含调试符号，使事情更容易理解，但`Release`也应该测试，因为强烈的优化选项可能会潜在地影响SUT的行为。'
- en: '`-j <jobs>, --parallel <jobs>`—This sets the number of tests executed in parallel.
    It''s very useful to speed up the execution of long tests during development.
    Be mindful that in a busy environment (on a shared test runner), it might have
    an adverse effect due to scheduling. This can be slightly mitigated with the next
    option.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-j <作业数>, --parallel <作业数>`—这设置了并行执行的测试数量。在开发过程中，它非常有用，可以加快长测试的执行。请注意，在一个繁忙的环境中（在共享的测试运行器上），它可能会因调度而产生不利影响。这可以通过下一个选项稍微缓解。'
- en: '`--test-load <level>`—Use this to schedule parallel tests in a fashion that
    CPU load doesn''t exceed the `<level>` value (on a best-effort basis).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--test-load <级别>`—使用此选项以一种方式安排并行测试，使CPU负载不超过`<级别>`值（尽最大努力）。'
- en: '`--timeout <seconds>`—Use this to specify the default limit of time for a single
    test.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--timeout <秒>`—使用此选项指定单个测试的默认时间限制。'
- en: Now that we understand how to execute `ctest` in many different scenarios, let's
    learn how to add a simple test.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了如何在许多不同场景下执行`ctest`，那么让我们学习如何添加一个简单的测试。
- en: Creating the most basic unit test for CTest
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为CTest创建最基本的单元测试
- en: Writing unit tests is technically possible without any kind of framework. All
    we have to do is create an instance of the class we want to test, execute one
    of its methods, and check if the new state or value returned meets our expectations.
    Then, we report the result and delete the object under test. Let's try it out.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，编写单元测试可以在没有任何框架的情况下进行。我们只需要做的是创建一个我们想要测试的类的实例，执行其一种方法，并检查返回的新状态或值是否符合我们的期望。然后，我们报告结果并删除被测试对象。让我们试一试。
- en: 'We''ll use the following structure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下结构：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Starting from `main.cpp`, we can see it will use a `Calc` class, as illustrated
    in the following code snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从`main.cpp`开始，我们可以看到它将使用一个`Calc`类，如下面的代码片段所示：
- en: chapter08/01-no-framework/src/main.cpp
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/01-no-framework/src/main.cpp
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nothing too fancy—`main.cpp` simply includes the `calc.h` header and calls
    two methods of the `Calc` object. Let''s quickly glance at the interface of `Calc`,
    our SUT, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 并不太复杂—`main.cpp`简单地包含了`calc.h`头文件，并调用了`Calc`对象的两种方法。让我们快速看一下`Calc`的接口，我们的SUT如下：
- en: chapter08/01-no-framework/src/calc.h
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/01-no-framework/src/calc.h
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The interface is as simple as possible. We''re using `#pragma once` here—it
    works exactly like commonly seen preprocessor include guards and is understood
    by almost all modern compilers, despite not being part of the official standard.
    Let''s see the class implementation, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 界面尽可能简单。我们在这里使用了`#pragma once`——它的工作方式与常见的预处理器包含保护符完全一样，尽管它不是官方标准的一部分，但几乎所有现代编译器都能理解。让我们看看类的实现，如下所示：
- en: chapter08/01-no-framework/src/calc.cpp
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/01-no-framework/src/calc.cpp
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Uh-oh! We introduced a mistake! `Multiply` is ignoring the `b` argument and
    returns `a` squared instead. That should be detected by correctly written unit
    tests. So, let''s write some! Here we go:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们引入了一个错误！`Multiply`忽略了`b`参数，而是返回`a`的平方。这应该被正确编写的单元测试检测到。所以，让我们写一些！开始吧：
- en: chapter08/01-no-framework/test/calc_test.cpp
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/01-no-framework/test/calc_test.cpp
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start our `calc_test.cpp` file by writing two test methods, one for each
    tested method of SUT. If the value returned from the called method doesn't match
    expectations, each function will call `std::exit(1)`. We could use `assert()`,
    `abort()`, or `terminate()` here, but that would result in a less explicit `Subprocess
    aborted` message in the output of `ctest`, instead of the more readable `Failed`
    message.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始编写`calc_test.cpp`文件，其中包含两个测试方法，分别针对SUT的每个测试方法。如果从调用方法返回的值与期望不符，每个函数都将调用`std::exit(1)`。我们本可以使用`assert()`、`abort()`或`terminate()`，但那样的话，在`ctest`的输出中，我们将得到一个更难读的“Subprocess
    aborted”消息，而不是更易读的“Failed”消息。
- en: 'Time to create a test runner. Ours will be simple as possible because doing
    it correctly would require a ridiculous amount of work. Just look at the `main()`
    function we had to write in order to run just two tests:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '是时候创建一个测试运行器了。我们的将会尽可能简单，因为正确地做这将需要大量的工作。 just look at the `main()` function
    we had to write in order to run just two tests:'
- en: chapter08/01-no-framework/test/unit_tests.cpp
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/01-no-framework/test/unit_tests.cpp
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s a breakdown of what happens here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这里发生的事情的分解：
- en: We declare two external functions that will be linked from another translation
    unit.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明了两个外部函数，它们将从另一个翻译单元链接过来。
- en: If no arguments were provided, execute both tests (the zeroth element in `argv[]`
    is always the program name).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有提供任何参数，执行两个测试（`argv[]`中的零元素总是程序名）。
- en: If the first argument is an identifier of the test, execute it.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个参数是测试的标识符，执行它。
- en: If any of the tests fail, it internally calls `exit()` and returns with a `1`
    exit code.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有任何测试失败，它内部调用`exit()`并返回`1`退出码。
- en: If no tests were executed or all passed, it implicitly returns with a `0` exit
    code.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有执行任何测试或所有测试都通过，它隐式地返回`0`退出码。
- en: 'To run the first test, we''ll execute `./unit_tests 1`; to run the second,
    we''ll execute `./unit_tests 2`. We simplified the code as much as we could, and
    it still turned out to be pretty hard to read. Anyone who might need to maintain
    this section isn''t going to have a great time after adding a few more tests,
    not to mention that this functionality is pretty raw—debugging such a test suite
    will be a lot of work. Nevertheless, let''s see how we can use it with CTest,
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行第一个测试，我们将执行`./unit_tests 1`；要运行第二个，我们将执行`./unit_tests 2`。我们尽可能简化代码，但它仍然变得相当难以阅读。任何可能需要维护这一部分的人在添加更多测试后都不会有很好的时光，更不用说这个功能相当原始——调试这样一个测试套件将是一项艰巨的工作。尽管如此，让我们看看我们如何使用它与CTest，如下所示：
- en: chapter08/01-no-framework/CMakeLists.txt
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/01-no-framework/CMakeLists.txt
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We start with the usual heading and `enable_testing()`. This is to tell CTest
    that we''d like to enable tests in this directory and its subdirectories. Next,
    we''ll include two nested listfiles in each of the subdirectories: `src` and `test`.
    The highlighted `bin` value states that we''d like the binary output of `src`
    subdirectories to be placed in `<build_tree>/bin`. Otherwise, binary files would
    end up in `<build_tree>/src`, which could be confusing. After all, build artifacts
    are no longer source files.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从常用的标题和`enable_testing()`开始。这是为了告诉CTest我们想在当前目录及其子目录中启用测试。接下来，我们在每个子目录中包含两个嵌套的列表文件：`src`和`test`。高亮的`bin`值表示我们希望`src`子目录的二进制输出放在`<build_tree>/bin`中。否则，二进制文件将出现在`<build_tree>/src`中，这可能会引起混淆。毕竟，构建工件不再是源文件。
- en: 'The listfile for the `src` directory is very straightforward and contains a
    simple `main` target definition, as illustrated here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`目录的列表文件非常直接，包含一个简单的`main`目标定义，如下所示：'
- en: chapter08/01-no-framework/src/CMakeLists.txt
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/01-no-framework/src/CMakeLists.txt
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also need a listfile for the `test` directory, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为`test`目录编写一个列表文件，如下所示：
- en: chapter08/01-no-framework/test/CMakeLists.txt
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/01-no-framework/test/CMakeLists.txt
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have now defined a second `unit_tests` target that also uses the `src/calc.cpp`
    implementation file and respective header. Finally, we explicitly add two tests:
    `SumAddsTwoInts` and `MultiplyMultipliesTwoInts`. Each provides its ID as an argument
    to the `add_test()` command. CTest will simply take anything provided after the
    `COMMAND` keyword and execute it in a subshell, collecting the output and exit
    code. Don''t get too attached to `add_test()`—in the *Unit-testing frameworks*
    section, we''ll discover a much better way of dealing with test cases, so we''ll
    skip describing it in detail here.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义了第二个`unit_tests`目标，它也使用`src/calc.cpp`实现文件和相应的头文件。最后，我们明确添加了两个测试：`SumAddsTwoInts`和`MultiplyMultipliesTwoInts`。每个都将其ID作为`add_test()`命令的参数。`CTest`将简单地取`COMMAND`关键字之后提供的一切，并在子壳中执行它，收集输出和退出代码。不要对`add_test()`过于依赖——在*单元测试框架*部分，我们将发现处理测试用例的更好方法，所以我们在这里不详细描述它。
- en: 'This is how `ctest` works in practice when executed in the build tree:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在构建树中执行时`ctest`实际的工作方式：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: CTest executed both tests and reported that one of them is failing—the returned
    value from `Calc::Multiply` didn't meet expectations. Very good. We now know that
    our code has a bug, and someone should fix it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctest`执行了这两个测试，并报告说其中一个失败——`Calc::Multiply`返回的值没有达到预期。非常好。我们现在知道我们的代码有一个错误，有人应该修复它。'
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may have noticed that in most examples so far, we didn''t necessarily employ
    the project structure described in [*Chapter 3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078),
    *Setting Up Your First CMake Project*. This was done to keep things brief. This
    chapter discusses more advanced concepts, and therefore using a full structure
    is warranted. In your projects (no matter how small), it''s best to follow this
    structure from the start. As a wise man once said: "*You step onto the road, and
    if you don''t keep your feet, there''s no knowing where you might be swept off
    to.*"'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，在迄今为止的大多数例子中，我们并没有一定使用在第[*第3章*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078)，*设置你的第一个CMake项目*中描述的项目结构。这是为了保持事情的简洁。本章讨论更多高级概念，因此使用完整的结构是合适的。在你的项目中（无论多么小），最好从一开始就遵循这个结构。正如一个智者曾经说过：“*你踏上道路，如果你不保持你的脚步，你不知道会被冲到哪里.*”
- en: It's no secret that you should avoid building a testing framework as part of
    your own project. Even the most basic example is hard on the eyes, has a lot of
    overhead, and doesn't add any value. However, before we can adopt a unit-testing
    framework, we'll need to rethink the structure of the project.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，你应避免在项目中构建测试框架。即使是最基础的例子也会让人眼睛疲劳，开销很大，并且没有增加任何价值。然而，在我们采用单元测试框架之前，我们需要重新思考项目的结构。
- en: Structuring our projects for testing
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为测试搭建项目结构
- en: 'C++ has some limited introspection capabilities, but cannot offer such powerful
    retrospection features as Java can. This might be the very reason why writing
    tests and unit-testing frameworks for C++ code is much harder than in other, richer
    environments. One implication of such an economic approach is the fact that the
    programmer has to be more involved in crafting testable code. We''ll not only
    have to design our interfaces more carefully, but also answer questions about
    the practicalities, such as this: *How do we avoid doubling the compilation, and
    reuse artifacts between tests and production?*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: C++具有一些有限的内省能力，但无法提供像Java那样的强大回顾功能。这可能正是编写C++代码的测试和单元测试框架比在其他更丰富的环境中困难的原因。这种经济方法的含义之一是程序员必须更参与构造可测试代码。我们不仅要更仔细地设计我们的接口，还要回答关于实践问题，例如：*我们如何避免编译双重，并在测试和生产之间重用工件？*
- en: Compilation time might not be a significant problem for smaller projects, but
    as time flies, the projects grow. The need for short compilation loops does not
    go away. In the previous example, we appended all the `sut` sources to the unit-test
    executable apart from the `main.cpp` file. If you were reading closely, you will
    have noticed that we had some code in that file that didn't get tested (the contents
    of `main()` itself). By compiling the code twice, there's a slight chance that
    the produced artifacts won't be *exactly the same*. These things can potentially
    diverge over time (due to the addition of compilation flags and preprocessor directives).
    This may be especially dangerous when engineers contributing to the code base
    are in a rush, inexperienced, or simply unfamiliar with the project.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时间对于小型项目可能不是一个问题，但随着时间推移，项目会增长。对于短编译循环的需求并不会消失。在之前的例子中，我们将所有`sut`源文件附加到单元测试可执行文件中，除了`main.cpp`文件。如果你仔细阅读，你会发现我们在这个文件中有些代码是没有被测试的（`main()`本身的内容）。通过编译代码两次，产生的工件可能不会*完全相同*。这些事物可能会随着时间的推移而逐渐偏离（由于添加了编译标志和预处理器指令）。当工程师匆忙、缺乏经验或不熟悉项目时，这可能尤其危险。
- en: 'There are multiple ways of dealing with the problem, but the most elegant is
    to build your entire solution as a library and link it with unit tests. You might
    ask: "*How are we going to run it then?*" We''ll need a bootstrap executable that
    will link with the library and run its code.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题有多种方法，但最优雅的方法是将整个解决方案构建为一个库，并与单元测试链接。你可能会问：“*我们怎么运行它呢？*”我们需要一个引导可执行文件，它将链接库并运行其代码。
- en: 'Begin by renaming your current `main()` function to `run()`, `start_program()`,
    or something similar. Then, create another implementation file (`bootstrap.cpp`)
    with a new `main()` function, and this function only. This will be our adapter
    (or wrapper, if you will): its sole role is to provide an entry point and call
    the `run()` forwarding command-line arguments (if any). All that''s left is to
    link everything together, and we''ve got ourselves a testable project.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将您当前的`main()`函数重命名为`run()`、`start_program()`或类似名称。然后，创建另一个实现文件（`bootstrap.cpp`），其中包含一个新的`main()`函数，仅此而已。这将成为我们的适配器（或者说是包装器）：它的唯一作用是提供一个入口点并调用`run()`转发命令行参数（如果有）。剩下的就是将所有内容链接在一起，这样我们就有了一个可测试的项目。
- en: By renaming `main()`, we can now link SUT with tests and test its primary function
    too. Otherwise, we'd be in violation of the `main()` function. As promised in
    the *Separating main() for testing* section of [*Chapter 6*](B17205_06_Final_JC_ePub.xhtml#_idTextAnchor146),
    we'll explain this subject in detail.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重命名`main()`，我们现在可以链接被测试的系统（SUT）和测试，并且还能测试它的主要功能。否则，我们就违反了`main()`函数。正如[第6章](B17205_06_Final_JC_ePub.xhtml#_idTextAnchor146)“为测试分离main()”部分所承诺的，我们将详细解释这个主题。
- en: The testing framework may provide its own implementation of the `main()` function
    out of the box, so we don't need to write it. Usually, it will detect all tests
    that we've linked and execute them according to the desired configuration.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架可能提供自己的`main()`函数实现，所以我们不需要编写。通常，它会检测我们链接的所有测试，并根据所需配置执行它们。
- en: 'Artifacts produced by this approach can be grouped into the following targets:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法产生的工件可以分为以下目标：
- en: A `sut` library with production code
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有生产代码的`sut`库
- en: '`bootstrap` with a `main()` wrapper calling `run()` from `sut`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap`带有`main()`包装器，调用`sut`中的`run()`'
- en: '`unit tests` with a `main()` wrapper that runs all the tests on `sut`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`main()`包装器，运行所有`sut`测试的`单元测试`
- en: 'The following diagram shows the symbol relations between targets:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了目标之间的符号关系：
- en: '![Figure 8.2 ‒ Sharing artifacts between test and production executables'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 ‒ 在测试和生产可执行文件之间共享工件'
- en: '](img/Figure_8.2_B17205.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B17205.jpg)'
- en: Figure 8.2 ‒ Sharing artifacts between test and production executables
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 ‒ 在测试和生产可执行文件之间共享工件
- en: 'We end up with six implementation files that will produce their respective
    (`.o`) *object files*, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终会得到六个实现文件，它们将生成各自的（`.o`）*目标文件*，如下所示：
- en: '`calc.cpp`—The `Calc` class to be unit-tested. This is called a **unit under
    test** (**UUT**) because UUT is a specialization of SUT.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc.cpp`—要进行单元测试的`Calc`类。这被称为**被测试单元**（**UUT**），因为UUT是SUT的一个特化。'
- en: '`run.cpp`—Original entry point renamed `run()`, which can be now tested.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run.cpp`—原始入口点重命名为`run()`，现在可以进行测试。'
- en: '`bootstrap.cpp`—New `main()` entry point calling `run()`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap.cpp`—新的`main()`入口点调用`run()`。'
- en: '`calc_test.cpp`—Tests the `Calc` class.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc_test.cpp`—测试`Calc`类。'
- en: '`run_test.cpp`—New tests for `run()` can go here.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_test.cpp`—新增`run()`的测试可以放在这里。'
- en: '`unit_tests.o`—Entry point for unit tests, extended to call tests for `run()`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unit_tests.o`—单元测试的入口点，扩展为调用`run()`的测试。'
- en: 'The library that we''re about to build doesn''t actually need to be a factual
    library: static or shared. By creating an object library, we can avoid unnecessary
    archiving or linking. Technically speaking, it''s possible to shave a few moments
    by relying on dynamic linking for SUT, but more often than not, we''re making
    changes in both targets: `tests` and `sut`, canceling out any potential gains.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将构建的库实际上并不需要是一个实际的库：静态的或共享的。通过创建一个对象库，我们可以避免不必要的归档或链接。从技术上讲，通过为SUT依赖动态链接来节省几秒钟是可能的，但往往我们同时在两个目标上进行更改：`tests`和`sut`，抵消了任何潜在的收益。
- en: 'Let''s see how our files have changed, starting with the file previously named
    `main.cpp`, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的文件有哪些变化，首先是从先前命名为`main.cpp`的文件开始，如下所示：
- en: chapter08/02-structured/src/run.cpp
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/02-structured/src/run.cpp
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Not too many differences: renamed file and function. We also added a `return`
    statement as the compiler won''t do this implicitly for functions that are not
    `main()`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 变化并不大：重命名文件和函数。我们还添加了一个`return`语句，因为编译器不会隐式地为非`main()`函数这样做。
- en: 'The new `main()` function looks like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`main()`函数看起来像这样：
- en: chapter08/02-structured/src/bootstrap.cpp
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/02-structured/src/bootstrap.cpp
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As simple as possible—we''re declaring that the linker will provide the `run()`
    function from another translation unit, and we''re calling it. Next to change
    is the `src` listfile, which you can see here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能简单——我们声明链接器将从另一个翻译单元提供`run()`函数，并且我们调用它。接下来需要更改的是`src`列表文件，您可以看到这里：
- en: chapter08/02-structured/src/CMakeLists.txt
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/02-structured/src/CMakeLists.txt
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we created a `sut` library and marked `.` as a `PUBLIC` *include directory*
    so that it will be propagated to all targets that will link `sut` (that is, `bootstrap`
    and `unit_tests`). Note that *include directories* are relative to the listfile,
    therefore we can use a dot (`.`) to refer to the current `<source_tree>/src` directory.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个`sut`库，并将`.`标记为`PUBLIC` *包含目录*，以便将其传播到所有将链接`sut`的目标（即`bootstrap`和`unit_tests`）。请注意，*包含目录*是相对于列表文件的，因此我们可以使用点（`.`）来引用当前的`<source_tree>/src`目录。
- en: 'Time to update our `unit_tests` target. Here, we''ll remove the direct reference
    to the `../src/calc.cpp` file with a linking reference to `sut` for the `unit_tests`
    target. We''ll also add a new test for the primary function in the `run_test.cpp`
    file. We''ll skip discussing that for brevity, but if you''re interested, check
    out the online examples. Meanwhile, here''s the whole `test` listfile:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候更新我们的`unit_tests`目标了。在这里，我们将移除对`../src/calc.cpp`文件的直接引用，改为`sut`的链接引用作为`unit_tests`目标。我们还将为`run_test.cpp`文件中的主函数添加一个新测试。为了简洁起见，我们将跳过讨论那个部分，但如果您感兴趣，可以查看在线示例。同时，这是整个`test`列表文件：
- en: chapter08/02-structured/test/CMakeLists.txt
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/02-structured/test/CMakeLists.txt
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We should also register the new test, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注册新的测试，如下所示：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Done! By following this practice, you can be sure that your tests are executed
    on the very machine code that will be used in production.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！通过遵循这种做法，您可以确信您的测试是在将用于生产的实际机器代码上执行的。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The target names we're using here, `sut` and `bootstrap`, are chosen to make
    it very clear what they're about from the perspective of testing. In real-life
    projects, you should pick names that match the context of the production code
    (rather than tests). For example, for a FooApp, name your target `foo` instead
    of `bootstrap`, and `lib_foo` instead of `sut`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的目标名称`sut`和`bootstrap`，是为了让从测试的角度来看它们非常清晰。在实际项目中，您应该选择与生产代码上下文相匹配的名称（而不是测试）。例如，对于一个FooApp，将您的目标命名为`foo`，而不是`bootstrap`，将`lib_foo`命名为`sut`。
- en: Now that we know how to structure a testable project in appropriate targets,
    let's shift our focus to the testing frameworks themselves. We don't want to add
    every test case to our listfiles manually, do we?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何在一个适当的目标中结构一个可测试的项目，那么让我们将重点转移到测试框架本身。我们不想手动将每个测试用例添加到我们的列表文件中，对吧？
- en: Unit-testing frameworks
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试框架
- en: 'The previous section proves that it isn''t extremely complicated to write a
    tiny unit-testing driver. It wasn''t pretty, but believe it or not, professional
    developers actually *do like* to reinvent the wheel (theirs will be fancier, rounder,
    and faster than the legacy one). Don''t fall into this trap: you''ll create so
    much boilerplate that it could become a separate project. Introducing a popular
    unit-test framework to your solution aligns it to a standard that transcends projects
    and companies and will get you free updates and extensions for cheap. You can''t
    lose.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节证明了编写一个微小的单元测试驱动并不非常复杂。它可能不够美观，但信不信由你，专业开发者实际上*确实喜欢*重新发明轮子（他们的轮子会更漂亮、更圆、更快）。不要陷入这个陷阱：你会创建出如此多的模板代码，它可能成为一个独立的项目。将一个流行的单元测试框架引入你的解决方案中，可以使它符合超越项目和公司的标准，并为你带来免费的更新和扩展。你没有损失。
- en: How do we add a unit-testing framework to our project? Well, write tests in
    implementation files according to the chosen framework's rules and link these
    tests with a test runner provided by the framework. Test runners are your entry
    points that will start the execution of selected tests. Unlike the basic `unit_tests.cpp`
    file we saw earlier in the chapter, many of them will detect all the tests automatically.
    Beautiful.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将单元测试框架添加到我们的项目中呢？嗯，根据所选框架的规则在实现文件中编写测试，并将这些测试与框架提供的测试运行器链接起来。测试运行器是您的入口点，将启动所选测试的执行。与我们在本章早些时候看到的基本的`unit_tests.cpp`文件不同，许多它们将自动检测所有测试。太美了。
- en: 'There are two unit-testing frameworks I decided to introduce in this chapter.
    I picked them for the following reasons:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我决定介绍两个单元测试框架。我选择它们的原因如下：
- en: '**Catch2** is a relatively easy-to-learn and well-supported and -documented
    project. It offers simple test cases, but also provides elegant macros for **behavior-driven
    development** (**BDD**). It lacks some features but can be coupled with external
    tools when needed. You can visit its home page here: [https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Catch2** 是一个相对容易学习、得到良好支持和文档的项目。它提供了简单的测试用例，但同时也提供了用于**行为驱动开发**（**BDD**）的优雅宏。它缺少一些功能，但在需要时可以与外部工具配合使用。您可以在这里访问其主页：[https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2)。'
- en: '**GTest** is also very convenient, but much more advanced. Its key features
    are a rich set of assertions, user-defined assertions, death tests, fatal and
    non-fatal failures, value- and type-parametrized tests, XML test report generation,
    and mocking. The last one is delivered in the GMock module available from the
    same repository: [https://github.com/google/googletest](https://github.com/google/googletest).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GTest** 也非常方便，但功能更加强大。它的关键特性是一组丰富的断言、用户定义的断言、死亡测试、致命和非致命失败、值和类型参数化测试、XML测试报告生成以及模拟。最后一个是通过从同一存储库中可用的GMock模块提供的：
    [https://github.com/google/googletest](https://github.com/google/googletest)。'
- en: Which framework you should choose depends on your learning approach and the
    size of the project. If you prefer a slow, gradual process and don't need all
    the bells and whistles, go with Catch2\. Developers who prefer starting from the
    deep end and need a lot of firepower will benefit from choosing GTest.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该选择哪个框架取决于您的学习方法和项目大小。如果您喜欢缓慢、逐步的过程，并且不需要所有的花哨功能，那么选择Catch2。那些喜欢从深层次开始并需要大量火力支持的开发人员将受益于选择GTest。
- en: Catch2
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Catch2
- en: 'This framework, maintained by Martin Hořeňovský, is great for beginners and
    smaller projects. This is not to say that it can''t handle the bigger applications,
    as long as you keep in mind that there will be areas where additional tooling
    may be necessary. I would deviate too much from the topic of this book if I went
    into it in detail, but I still want to give you an overview. To start, let''s
    take a brief look at the implementation of a unit test we can write for our `Calc`
    class, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个由Martin Hořeňovský维护的框架，对于初学者和小型项目来说非常棒。这并不是说它不能处理更大的应用程序，只要你记住，只要记得在需要额外工具的区域会有所需要。如果我详细介绍这个框架，我就会偏离本书的主题太远，但我仍然想给你一个概述。首先，让我们简要地看看我们可以为我们的`Calc`类编写单元测试的实现，如下所示：
- en: chapter08/03-catch2/test/calc_test.cpp
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/03-catch2/test/calc_test.cpp
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That's it. These few lines are much more powerful than what we wrote in the
    previous examples. `CHECK()` macros will not only verify if the expectation is
    met—they will actually collect all failed assertions and present them in a single
    output so that you can do a single fix and avoid constant recompilation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这几行比我们之前写的例子要强大得多。`CHECK()`宏不仅验证期望是否满足——它们还会收集所有失败的断言，并在单个输出中呈现它们，这样你就可以进行一次修复，避免重复编译。
- en: 'Now, to the best part: we don''t need to add these tests anywhere or even inform
    CMake they exist; you can forget about `add_test()` because you won''t need it
    again. Catch2 will automatically register your tests with CTest if you let it.
    Adding the framework is very easy after configuring the project as described in
    the previous section. We need to bring it into the project with `FetchContent()`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最好的一部分：我们不需要在任何地方添加这些测试，甚至不需要通知CMake它们存在；你可以忘记`add_test()`，因为你再也用不到了。如果允许的话，Catch2会自动将你的测试注册到CTest。在上一节中描述的配置项目后，添加框架非常简单。我们需要使用`FetchContent()`将其引入项目。
- en: 'There are two major versions to choose from: `v2` and `v3`. Version 2 is offered
    as a single-header library (just `#include <catch2/catch.hpp>`) for C++11, and
    will be eventually deprecated by Version 3\. This one has multiple headers, is
    compiled as a static library, and requires C++14\. Of course, it''s recommended
    to go with the newer release if you can use modern C++ (yes—C++11 is no longer
    considered "modern"). When working with Catch2, you should pick a Git tag and
    pin it in your listfile. In other words, it is not guaranteed that an upgrade
    won''t break your code (it likely won''t, but don''t risk going with the `devel`
    branch if you don''t need to). To fetch Catch2, we need to provide a URL to the
    repository, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要版本可供选择：`v2`和`v3`。版本2作为一个单头库（只需`#include <catch2/catch.hpp>`）提供给C++11，最终将被版本3所取代。这个版本由多个头文件组成，被编译为静态库，并要求C++14。当然，如果你能使用现代C++（是的，C++11不再被认为是“现代”的），那么推荐使用更新的版本。在与Catch2合作时，你应该选择一个Git标签并在你的列表文件中固定它。换句话说，不能保证升级不会破坏你的代码（升级很可能不会破坏代码，但如果你不需要，不要使用`devel`分支）。要获取Catch2，我们需要提供一个仓库的URL，如下所示：
- en: chapter08/03-catch2/test/CMakeLists.txt
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/03-catch2/test/CMakeLists.txt
- en: '[PRE22]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we need to define our `unit_tests` target and link it with `sut` and
    with a framework-provided entry point and `Catch2::Catch2WithMain` library. Since
    Catch2 provides its own `main()` function, we no longer use the `unit_tests.cpp`
    file (this file can be removed). The code is illustrated in the following snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要定义我们的`unit_tests`目标，并将其与`sut`以及一个框架提供的入口点和`Catch2::Catch2WithMain`库链接。由于Catch2提供了自己的`main()`函数，我们不再使用`unit_tests.cpp`文件（这个文件可以删除）。代码如下所示：
- en: chapter08/03-catch2/test/CMakeLists.txt (continued)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/03-catch2/test/CMakeLists.txt（续）
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lastly, we use a `catch_discover_tests()` command defined in the module provided
    by Catch2 that will detect all test cases from `unit_tests` and register them
    with CTest, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用由Catch2提供的模块中定义的`catch_discover_tests()`命令，该命令将检测`unit_tests`中的所有测试用例并将它们注册到CTest，如下所示：
- en: chapter08/03-catch2/test/CMakeLists.txt (continued)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/03-catch2/test/CMakeLists.txt（续）
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Done. We just added a unit-testing framework to our solution. Let''s now see
    it in practice. The output from the test runner looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了。我们刚刚为我们的解决方案添加了一个单元测试框架。现在让我们看看它的实际应用。测试运行器的输出如下所示：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The direct execution of the runner (compiled `unit_test` executable) is slightly
    faster, but normally, you'd like to use the `ctest --output-on-failure` command
    instead of executing the test runner directly to get all the CTest benefits mentioned
    earlier. Note also that Catch2 was able to conveniently expand the `sut.Multiply(3,
    4)` expression to `9`, providing us with more context.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 直接执行运行器（编译的`unit_test`可执行文件）稍微快一点，但通常，你希望使用`ctest --output-on-failure`命令，而不是直接执行测试运行器，以获得前面提到的所有CTest好处。注意Catch2能够方便地将`sut.Multiply(3,
    4)`表达式扩展为`9`，为我们提供更多上下文。
- en: This concludes the setup of Catch2\. If you ever need to add more tests, just
    create implementation files and insert their paths to the list of sources for
    the `unit_tests` target.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了Catch2的设置。如果你还需要添加更多测试，只需创建实现文件并将它们的路径添加到`unit_tests`目标的源列表中。
- en: 'This framework has quite a few interesting tricks up its sleeve: event listeners,
    data generators, and micro benchmarking, but it doesn''t provide a mocking functionality.
    If you don''t know what mocks are, read on—we''ll cover that in a moment. Nevertheless,
    if you find yourself in need of mocks, you can always add one of the mocking frameworks
    next to Catch2, as listed here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架包含了一些有趣的小技巧：事件监听器、数据生成器和微基准测试，但它并不提供模拟功能。如果你不知道什么是模拟，继续阅读——我们马上就会涉及到这一点。然而，如果你发现自己需要模拟，你总是可以在这里列出的一些模拟框架旁边添加Catch2：
- en: FakeIt ([https://github.com/eranpeer/FakeIt](https://github.com/eranpeer/FakeIt))
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FakeIt ([https://github.com/eranpeer/FakeIt](https://github.com/eranpeer/FakeIt))
- en: Hippomocks ([https://github.com/dascandy/hippomocks](https://github.com/dascandy/hippomocks))
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hippomocks ([https://github.com/dascandy/hippomocks](https://github.com/dascandy/hippomocks))
- en: Trompeloeil ([https://github.com/rollbear/trompeloeil](https://github.com/rollbear/trompeloeil))
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Trompeloeil ([https://github.com/rollbear/trompeloeil](https://github.com/rollbear/trompeloeil))
- en: That said, for a more streamlined, advanced experience, there is another framework
    worth looking at.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 话说回来，对于一个更简洁、更先进的体验，还有另一个框架值得一看。
- en: GTest
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GTest
- en: 'There are a few important advantages when it comes to using GTest: it''s been
    around quite a long time and is highly recognized in the C++ community (thus,
    multiple IDEs support it natively). The company behind the biggest search engine
    on the planet is maintaining and using it extensively, so it''s quite unlikely
    it will become stale or abandoned any time soon. It can test C++11 and up, so
    if you''re stuck in a bit older environment, you''re in luck.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GTest有几个重要的优点：它已经存在很长时间，并且在C++社区中高度认可（因此，多个IDE支持它）。背后最大的搜索引擎公司的维护和广泛使用，所以它很可能在不久的将来变得过时或被遗弃。它可以测试C++11及以上版本，所以如果你被困在一个稍微老一点的环境中，你很幸运。
- en: 'The GTest repository comprises two projects: GTest (the main testing framework)
    and GMock (a library adding the mocking functionality). That means you can download
    both with a single `FetchContent()` call.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: GTest仓库包括两个项目：GTest（主测试框架）和GMock（一个添加模拟功能的库）。这意味着你可以用一个`FetchContent()`调用来下载它们。
- en: Using GTest
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GTest
- en: 'To use GTest, our project needs to follow the directions from the *Structuring
    our projects for testing* section. This is how we''d write a unit test in this
    framework:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用GTest，我们的项目需要遵循*为测试结构化项目*部分的方向。这就是我们在这个框架中编写单元测试的方法：
- en: chapter08/04-gtest/test/calc_test.cpp
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/04-gtest/test/calc_test.cpp
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since this example will be used also in GMock, I decided to put tests in a single
    `CalcTestSuite` class. Test suites are group related tests, so they can reuse
    the same fields, methods, setup (initialization), and teardown (cleanup) steps.
    To create a test suite, we need to declare a new class inheriting from `::testing::Test`
    and put reused elements (fields, methods) in its `protected` section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个例子也将用于GMock，我决定将测试放在一个`CalcTestSuite`类中。测试套件是相关测试的组，因此它们可以重用相同的字段、方法和设置（初始化）以及清理步骤。要创建一个测试套件，我们需要声明一个新的类，从`::testing::Test`继承，并将重用元素（字段、方法）放在其`protected`部分。
- en: Each test case in a test suite is declared with a `TEST_F()` preprocessor macro
    that stringifies provided names for the test suite and test case (there's also
    a simple `TEST()` macro that defines unaffiliated tests). Because we defined `Calc
    sut_` in the class, each test case can access it as if the test were a method
    of `CalcTestSuite`. In reality, each test case is run in its own class implicitly
    inheriting from `CalcTestSuite` (that's why we need the `protected` keyword).
    Note that reused fields are not meant to share any data between consecutive tests—their
    function is to keep the code *DRY*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件中的每个测试用例都是用`TEST_F()`预处理器宏声明的，该宏将测试套件和测试用例提供的名称字符串化（还有一个简单的`TEST()`宏，定义不相关的测试）。因为我们已经在类中定义了`Calc
    sut_`，每个测试用例可以像`CalcTestSuite`的一个方法一样访问它。实际上，每个测试用例在其自己的类中隐式继承自`CalcTestSuite`运行（这就是我们需要`protected`关键字的原因）。请注意，重用字段不是为了在连续测试之间共享任何数据——它们的目的是保持代码*DRY*。
- en: GTest doesn't offer natural syntax for assertions like Catch2 does. Instead,
    we need to use an explicit comparison, such as `EXPECT_EQ()`. By convention, we
    put the expected value as the first argument and the actual value as the second
    argument. There are many other assertions, helpers, and macros worth learning
    about.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: GTest没有提供像Catch2那样的自然断言语法。相反，我们需要使用一个显式的比较，比如`EXPECT_EQ()`。按照惯例，我们将期望值作为第一个参数，实际值作为第二个参数。还有许多其他断言、助手和宏值得学习。
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For detailed information on GTest, see the official reference material ([https://google.github.io/googletest/](https://google.github.io/googletest/)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GTest的详细信息，请参阅官方参考资料([https://google.github.io/googletest/](https://google.github.io/googletest/)).
- en: 'To add this dependency to our project, we need to decide which version to use.
    Unlike Catch2, GTest is leaning toward a "live at head" philosophy (originating
    from the Abseil project that GTest depends on). It states: "*If you build our
    dependency from source and follow our API, you shouldn''t have any issues.*" (Refer
    to the *Further reading* section for more details.)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此依赖项添加到我们的项目中，我们需要决定使用哪个版本。与Catch2不同，GTest倾向于采用“现场开发”的理念（起源于GTest所依赖的Abseil项目）。它指出：“*如果你从源代码构建我们的依赖项并遵循我们的API，你不会遇到任何问题。*”（更多详情请参阅*进阶阅读*部分。）
- en: If you're comfortable following this rule (and building from source isn't an
    issue), set your Git tag to the `master` branch. Otherwise, pick a release from
    the GTest repository. We can also choose to search the host machine for the installed
    copy first, as CMake offers a bundled `FindGTest` module to find the local installation.
    Since v3.20, CMake will use the upstream `GTestConfig.cmake` config-file, if it
    exists, instead of relying on the find-module, which might become outdated.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于遵循这个规则（并且从源代码构建没有问题），将你的Git标签设置为`master`分支。否则，从GTest仓库中选择一个版本。我们还可以选择首先在宿主机器上搜索已安装的副本，因为CMake提供了一个捆绑的`FindGTest`模块来查找本地安装。自v3.20起，CMake将使用上游的`GTestConfig.cmake`配置文件（如果存在），而不是依赖于可能过时的查找模块。
- en: 'In any case, adding a dependency on GTest looks like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，添加对GTest的依赖项看起来是这样的：
- en: chapter08/04-gtest/test/CMakeLists.txt
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/04-gtest/test/CMakeLists.txt
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We're following the same method as with Catch2—execute `FetchContent()` and
    build the framework from source. The only difference is the addition of the `set(gtest...)`
    command, as recommended by GTest authors to prevent overriding the parent project's
    compiler and linker settings on Windows.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循与Catch2相同的方法——执行`FetchContent()`并从源代码构建框架。唯一的区别是在GTest作者建议的`set(gtest...)`命令，以防止在Windows上覆盖父项目的编译器和链接器设置。
- en: 'Finally, we can declare our test runner executable, link it with `gtest_main`,
    and have our test cases automatically discovered thanks to the built-in CMake
    `GoogleTest` module, as illustrated here:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以声明我们的测试运行器可执行文件，链接`gtest_main`，并借助内置的CMake `GoogleTest`模块自动发现我们的测试用例，如下所示：
- en: chapter08/04-gtest/test/CMakeLists.txt (continued)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/04-gtest/test/CMakeLists.txt（续）
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This completes the setup of GTest. The output of the test runner is much more
    verbose than from Catch2, but we can pass `--gtest_brief=1` to limit it to failures
    only, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了GTest的设置。测试运行器的输出比Catch2更详细，但我们可以传递`--gtest_brief=1`来限制它仅显示失败，如下所示：
- en: '[PRE29]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Luckily, even the noisy output will be suppressed when running from CTest (unless
    we explicitly enable it on the `ctest --output-on-failure` command line).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，即使从CTest运行时，噪音输出也会被抑制（除非我们显式地在`ctest --output-on-failure`命令行上启用它）。
- en: Now that we have the framework in place, let's discuss mocking. After all, no
    test can be truly "unit" when it's coupled with other elements.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了框架，让我们讨论一下模拟。毕竟，当它与其他元素耦合时，没有任何测试可以真正称为“单元”。
- en: GMock
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GMock
- en: 'Writing true unit tests is about executing a piece of code in isolation from
    other pieces of code. Such a unit is understood as a self-contained element, either
    a class or a component. Of course, hardly any programs written in C++ have all
    of their units in clear isolation from others. Most likely, your code will rely
    heavily on some form of association relationship between classes. There''s only
    one problem with that: objects of such a class will require objects of another
    class, and those will require yet another. Before you know it, your entire solution
    is participating in a "unit test". Even worse, your code might be coupled to an
    external system and be dependent on its state—for example, specific records in
    a database, network packets coming in, or specific files stored on the disk.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 编写真正的单元测试是关于从其他代码中隔离执行一段代码。这样的单元被理解为一个自包含的元素，要么是一个类，要么是一个组件。当然，用C++编写的几乎没有任何程序将它们的所有单元与其他单元清晰地隔离。很可能，你的代码将严重依赖于类之间某种形式的关联关系。这种关系有一个问题：此类对象将需要另一个类的对象，而这些将需要另一个。在不知不觉中，你的整个解决方案就参与了一个“单元测试”。更糟糕的是，你的代码可能与外部系统耦合，并依赖于其状态——例如，数据库中的特定记录，网络数据包的传入，或磁盘上存储的特定文件。
- en: 'To decouple units for the purpose of testing, developers use **test doubles**
    or a special version of classes that are used by a class under test. Some examples
    include fakes, stubs, and mocks. Here are some rough definitions of these:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的而解耦单元，开发人员使用**测试替身**或类的特殊版本，这些类被测试类使用。一些例子包括伪造品、存根和模拟。以下是这些的一些大致定义：
- en: A **fake** is a limited implementation of some more complex class. An example
    could be an in-memory map instead of an actual database client.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伪造品**是某些更复杂类的有限实现。一个例子可能是在实际数据库客户端之内的内存映射。'
- en: A **stub** provides specific, canned answers to method calls, limited to responses
    used by tests. It can also record which methods were called and how many times
    this occurred.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**为方法调用提供特定的、预先录制的回答，限于测试中使用的回答。它还可以记录调用了哪些方法以及发生了多少次。'
- en: A **mock** is a bit more extended version of a stub. It will additionally verify
    if methods were called during the test as expected.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**是存根的一个更扩展版本。它还将验证测试期间方法是否如预期地被调用。'
- en: Such a test double is created at the beginning of a test and provided as an
    argument to the constructor of a tested class to be used instead of a real object.
    This mechanism is called **dependency injection**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个测试替身是在测试开始时创建的，作为测试类构造函数的参数提供，以代替真实对象使用。这种机制称为**依赖注入**。
- en: 'The problem with simple test doubles is the fact that they are *too simple*.
    To simulate behaviors for different test scenarios, we would have to provide many
    different doubles, one for every state in which the coupled object can be. This
    isn''t very practical and would scatter testing code across too many files. This
    is where GMock comes in: it allows developers to create a generic test double
    for a specific class and define its behavior for every test in line. GMock calls
    these doubles "mocks", but in reality, they''re a mixture of all the aforementioned
    types, depending on the occasion.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 简单测试替身的问题是它们*太简单*。为了为不同的测试场景模拟行为，我们可能需要提供许多不同的替身，每一个都是耦合对象可能处于的不同状态。这并不实用，并且会将测试代码分散到太多的文件中。这就是GMock出现的地方：它允许开发人员为特定类创建一个通用的测试替身，并在每一行中定义其行为。GMock将这些替身称为“模拟”，但实际上，它们是上述所有类型的混合，具体取决于场合。
- en: 'Consider the following example: let''s add a functionality to our `Calc` class
    that would add a random number to the provided argument. It will be represented
    by an `AddRandomNumber()` method that returns this sum as an `int`. How would
    we confirm the fact that the returned value is really an exact sum of something
    random and the value provided to the class? As we know, relying on randomness
    is key to many important processes, and if we''re using it incorrectly, we might
    suffer all kinds of consequences. Checking all random numbers until we exhaust
    all possibilities isn''t very practical.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：让我们为我们的`Calc`类添加一个功能，它将提供一个随机数添加到提供的参数。它将通过一个`AddRandomNumber()`方法表示，该方法返回这个和作为一个`int`。我们如何确认返回的值确实是随机数和提供给类的值的准确和？正如我们所知，依赖随机性是许多重要过程的关键，如果我们使用不当，我们可能会遭受各种后果。检查所有随机数直到我们耗尽所有可能性并不太实用。
- en: To test it, we need to wrap a random number generator in a class that could
    be mocked (or, in other words, replaced with a mock). Mocks will allow us to force
    a specific response, which is to "fake" generation of a random number. `Calc`
    will use that value in `AddRandomNumber()` and allow us to check if the returned
    value from that method meets expectations. The clean separation of random number
    generation to another unit is an added value (as we'll be able to exchange one
    type of generator for another).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我们需要将一个随机数生成器封装在一个可以被模拟（或者说，用一个模拟对象替换）的类中。模拟对象将允许我们强制一个特定的响应，即“伪造”一个随机数的生成。`Calc`将在`AddRandomNumber()`中使用这个值，并允许我们检查该方法返回的值是否符合预期。将随机数生成分离到另一个单元中是一个额外的价值（因为我们将能够交换一种生成器类型为另一种）。
- en: 'Let''s start with the public interface for the abstract generator. This will
    allow us to implement it in the actual generator and a mock, enabling us to use
    them interchangeably. We''ll execute the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从抽象生成器的公共接口开始。这将允许我们在实际生成器和模拟中实现它，使其可以相互替换。我们将执行以下代码：
- en: chapter08/05-gmock/src/rng.h
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/05-gmock/src/rng.h
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Classes implementing this interface will provide us with a random number from
    the `Get()` method. Note the `virtual` keyword—it has to be on all methods to
    be mocked unless we''d like to get involved with more complex template-based mocking.
    We also need to remember to add a virtual destructor. Next, we have to extend
    our `Calc` class to accept and store the generator, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此接口的类将从`Get()`方法提供随机数。注意`virtual`关键字——除非我们希望涉及更复杂的基于模板的模拟，否则所有要模拟的方法都必须有它，除非我们希望涉及更复杂的基于模板的模拟。我们还需要记得添加一个虚拟析构函数。接下来，我们需要扩展我们的`Calc`类以接受和存储生成器，如下所示：
- en: chapter08/05-gmock/src/calc.h
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章/05-gmock/源码/calc.h
- en: '[PRE31]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We included the header and added a method to provide random additions. Additionally,
    a field to store the pointer to the generator was created, along with a parameterized
    constructor. This is how dependency injection works in practice. Now, we implement
    these methods, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了头文件并添加了一个提供随机增加的方法。此外，创建了一个存储生成器指针的字段以及一个参数化构造函数。这就是依赖注入在实际工作中的运作方式。现在，我们实现这些方法，如下所示：
- en: chapter08/05-gmock/src/calc.cpp
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章/05-gmock/源码/calc.cpp
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the constructor, we''re assigning the provided pointer to a class field.
    We''re then using this field in `AddRandomNumber()` to fetch the generated value.
    The production code will use a real number generator; the tests will use mocks.
    Remember that we need to dereference pointers to enable polymorphism. As a bonus,
    we could possibly create different generator classes for different implementations.
    I just need one: a Mersenne Twister pseudo-random generator with uniform distribution,
    as illustrated in the following code snippet:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将提供的指针赋值给一个类字段。然后我们在`AddRandomNumber()`中使用这个字段来获取生成的值。生产代码将使用一个真正的数字生成器；测试将使用模拟。记住我们需要对指针进行解引用以启用多态。作为奖励，我们可能为不同的实现创建不同的生成器类。我只需要一个：一个梅森旋转伪随机生成器，具有均匀分布，如下面的代码片段所示：
- en: chapter08/05-gmock/src/rng_mt19937.cpp
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章/05-gmock/源码/rng_mt19937.cpp
- en: '[PRE33]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This code isn''t very efficient, but it will suffice for this simple example.
    The purpose is to generate numbers from `1` to `6` and return them to the caller.
    The header for this class is as simple as possible, as we can see here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不是非常高效，但它将适用于这个简单的例子。目的是生成`1`到`6`之间的数字并将它们返回给调用者。这个类的头文件尽可能简单，正如我们所见：
- en: chapter08/05-gmock/src/rng_mt19937.h
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章/05-gmock/源码/rng_mt19937.h
- en: '[PRE34]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And this is how we''re using it in the production code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在生产代码中使用它：
- en: chapter08/05-gmock/src/run.cpp
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章/05-gmock/源码/运行.cpp
- en: '[PRE35]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have created a generator and passed a pointer to it to the constructor of
    `Calc`. Everything is ready, and we can start writing our mock. To keep things
    organized, developers usually put mocks in a separate `test/mocks` directory.
    To prevent ambiguity, the header name has a `_mock` suffix. Here is the code we
    will execute:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个生成器，并将它的指针传递给`Calc`的构造函数。一切准备就绪，我们可以开始编写我们的模拟。为了保持组织性，开发人员通常将模拟放在一个单独的`test/mocks`目录中。为了防止模糊性，头文件名有一个`_mock`后缀。我们将执行以下代码：
- en: chapter08/05-gmock/test/mocks/rng_mock.h
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章/05-gmock/测试/模拟/rng_mock.h
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After adding the `gmock.h` header, we can declare our mock. As planned, it''s
    a class implementing the `RandomNumberGenerator` interface. Instead of writing
    methods ourselves, we need to use `MOCK_METHOD` macros provided by GMock. These
    are informing the framework as to which methods from the interface should be mocked.
    Use the following format (note the parentheses):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`gmock.h`头文件后，我们可以声明我们的模拟。如计划，它是一个实现`RandomNumberGenerator`接口的类。我们不需要自己编写方法，需要使用GMock提供的`MOCK_METHOD`宏。这些通知框架应该模拟接口中的哪些方法。使用以下格式（注意括号）：
- en: '[PRE37]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''re ready to use the mock in our test suite (previous test cases are omited
    for brevity), as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好在我们的测试套件中使用模拟（为了简洁，省略了之前的测试案例），如下所示：
- en: chapter08/05-gmock/test/calc_test.cpp
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章/05-gmock/测试/calc_test.cpp
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s break down the changes: we added the new header and created a new field
    for `rng_mock_` in the test suite. Next, the mock''s address is passed to the
    constructor of `sut_`. We can do that because fields are initialized in order
    of declaration (`rng_mock_` precedes `sut_`).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下更改：我们在测试套件中添加了新的头文件并为`rng_mock_`创建了一个新字段。接下来，将模拟的地址传递给`sut_`的构造函数。我们可以这样做，因为字段是按声明顺序初始化的（`rng_mock_`先于`sut_`）。
- en: In our test case, we call GMock's `EXPECT_CALL` macro on the `Get()` method
    of `rng_mock_`. This tells the framework to fail the test if the `Get()` method
    isn't called during execution. The `Times` chained call explicitly states how
    many calls must happen for the test to pass. `WillOnce` determines what the mocking
    framework does after the method is called (it returns `3`).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试用例中，我们对`rng_mock_`的`Get()`方法调用GMock的`EXPECT_CALL`宏。这告诉框架，如果在执行过程中没有调用`Get()`方法，则测试失败。`Times`链式调用明确指出，为了测试通过，必须发生多少次调用。`WillOnce`确定在方法调用后，模拟框架做什么（它返回`3`）。
- en: By virtue of using GMock, we're able to express mocked behavior alongside the
    expected outcome. This greatly improves readability and eases the maintenance
    of tests. Most importantly, though, it provides elasticity in each test case,
    as we get to differentiate what happens with a single, expressive statement.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 借助GMock，我们能够一边表达期望的结果，一边表达被模拟的行为。这极大地提高了可读性，并使得测试的维护变得更加容易。最重要的是，它在每个测试用例中提供了弹性，因为我们可以通过一个单一的表达式来区分发生了什么。
- en: 'Finally, we need to make sure that the `gmock` library is linked with a test
    runner. To achieve that, we add it to the `target_link_libraries()` list, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保`gmock`库与一个测试运行器链接。为了实现这一点，我们需要将其添加到`target_link_libraries()`列表中，如下所示：
- en: chapter08/05-gmock/test/CMakeLists.txt
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章/05-gmock/test/CMakeLists.txt
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we can enjoy all the benefits of GTest frameworks. Both GTest and GMock
    are very advanced tools with a vast multitude of concepts, utilities, and helpers
    for different occasions. This example (despite being a bit lengthy) only touches
    the surface of what's possible. I encourage you to incorporate them in your projects
    as they will greatly increase the quality of your code. A good place to start
    with GMock is the *Mocking for Dummies* page in the official documentation (you
    can find a link to this in the *Further reading* section).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以享受GTest框架的所有好处。GTest和GMock都是非常先进的工具，拥有大量的概念、实用程序和帮助器，适用于不同的场合。这个例子（尽管有点长）只是触及了可能实现的功能的表面。我鼓励你将它们纳入你的项目中，因为它们将极大地提高你的代码质量。开始使用GMock的一个好地方是官方文档中的*Mocking
    for Dummies*页面（你可以在*进阶阅读*部分找到这个链接）。
- en: Having tests in place, we should somehow measure what's tested and what isn't
    and strive to improve the situation. It's best to use automated tools that will
    collect and report this information.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有了测试之后，我们应该以某种方式衡量哪些部分被测试了，哪些没有，并努力改善这种情况。最好使用自动化工具来收集和报告这些信息。
- en: Generating test coverage reports
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成测试覆盖报告
- en: 'Adding tests to such a small solution isn''t incredibly challenging. The real
    difficulty comes with slightly more advanced and longer programs. Over the years,
    I have found that as I approach over 1,000 lines of code, it slowly becomes hard
    to track which lines and branches are executed during tests and which aren''t.
    After crossing 3,000 lines, it is nearly impossible. Most professional applications
    will have much more code than that. To deal with this problem, we can use a utility
    to understand which code lines are "covered" by test cases. Such code coverage
    tools hook up to the SUT and gather the information on the execution of each line
    during tests to present it in a convenient report like the one shown here:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 向如此小的解决方案中添加测试并不是非常具有挑战性。真正的困难来自于稍微高级一些和更长的程序。多年来，我发现当我接近1,000行代码时，逐渐变得难以跟踪测试中执行了哪些行和分支，哪些没有。超过3,000行后，几乎是不可能的。大多数专业应用程序将拥有比这更多的代码。为了解决这个问题，我们可以使用一个工具来了解哪些代码行被“测试用例覆盖”。这样的代码覆盖工具连接到SUT，并在测试中收集每行的执行信息，以方便的报告形式呈现，就像这里显示的这样：
- en: '![Figure 8.3 ‒ Code coverage report generated by LCOV'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 ‒ 由LCOV生成的代码覆盖报告'
- en: '](img/Figure_8.3_B17205.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B17205.jpg)'
- en: Figure 8.3 ‒ Code coverage report generated by LCOV
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 ‒ 由LCOV生成的代码覆盖报告
- en: 'These reports will show you which files are covered by tests and which aren''t.
    More than that, you can also take a peek inside the details of each file and see
    exactly which lines of code are executed and how many times this occurs. In the
    following screenshot, the `Calc` constructor was run `4` times, one time for each
    of the tests:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些报告将显示哪些文件被测试覆盖了，哪些没有。更重要的是，你还可以查看每个文件的具体细节，确切地看到哪些代码行被执行了，以及这种情况发生了多少次。在下面的屏幕截图中，`Calc`
    构造函数被执行了4次，每次都是针对不同的测试：
- en: '![Figure 8.4 ‒ Detailed view of a code coverage report'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 ‒ 代码覆盖报告的详细视图'
- en: '](img/Figure_8.4_B17205.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B17205.jpg)'
- en: Figure 8.4 ‒ Detailed view of a code coverage report
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 ‒ 代码覆盖报告的详细视图
- en: 'There are multiple ways of generating similar reports and they differ across
    platforms and compilers, but they generally follow the same procedure: prepare
    the SUT to be measured, and get the baseline, measure, and report.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 生成类似报告有多种方法，它们在平台和编译器之间有所不同，但它们通常遵循相同的程序：准备要测量的SUT，获取基线，测量和报告。
- en: The simplest tool for the job is called `gcov`, a coverage utility from the
    `gcov` to measure coverage. If you're using Clang, don't worry—Clang supports
    producing metrics in this format. You can get LCOV from the official repository
    maintained by the *Linux Test Project* ([https://github.com/linux-test-project/lcov](https://github.com/linux-test-project/lcov))
    or simply use a package manager. As the name suggests, it is a Linux-targeted
    utility. It's possible to run it on macOS, but the Windows platform is not supported.
    End users often don't care about test coverage, so it's usually fine to install
    LCOV manually in your own build environment instead of bolting it to the project.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这项工作的最简单工具名叫`gcov`，它是`gcov`的一个覆盖率工具，用于测量覆盖率。如果你在使用Clang，不用担心——Clang支持生成这种格式的指标。你可以从由*Linux测试项目*维护的官方仓库获取LCOV([https://github.com/linux-test-project/lcov](https://github.com/linux-test-project/lcov))，或者简单地使用包管理器。正如其名，它是一个面向Linux的工具。虽然可以在macOS上运行它，但不支持Windows平台。最终用户通常不关心测试覆盖率，所以通常可以手动在自建的构建环境中安装LCOV，而不是将其绑定到项目中。
- en: 'To measure coverage, we''ll need to do the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量覆盖率，我们需要做以下工作：
- en: Compile in the `Debug` configuration with compiler flags enabling code coverage.
    This will generate coverage note (`.gcno`) files.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`Debug`配置编译，使用编译器标志启用代码覆盖。这将生成覆盖注释（`.gcno`）文件。
- en: Link the test executable with the `gcov` library.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试可执行文件与`gcov`库链接。
- en: Gather coverage metrics for the baseline, without any tests being run.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不运行任何测试的情况下收集基线覆盖率指标。
- en: Run the tests. This will create coverage data (`.gcda`) files.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。这将创建覆盖数据（`.gcda`）文件。
- en: Collect the metrics to an aggregated information file.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将指标收集到聚合信息文件中。
- en: Generate a (`.html`) report.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个（`.html`）报告。
- en: We should start by explaining why the code has to be compiled in the `Debug`
    configuration. The most important reason is the fact that usually, `Debug` configurations
    have disabled any optimization with a `-O0` flag. CMake does this by default in
    the `CMAKE_CXX_FLAGS_DEBUG` variable (despite not stating this anywhere in the
    documentation). Unless you decided to override this variable, your debug build
    should be unoptimized. This is desired to prevent any inlining and other kinds
    of implicit code simplification. Otherwise, it would be really hard to trace which
    machine instruction came from which line of source code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该首先解释为什么代码必须以`Debug`配置编译。最重要的原因是，通常`Debug`配置使用`-O0`标志禁用了任何优化。CMake通过默认在`CMAKE_CXX_FLAGS_DEBUG`变量中实现这一点（尽管在文档中没有提到这一点）。除非你决定覆盖这个变量，否则你的调试构建应该是未优化的。这是为了防止任何内联和其他类型的隐式代码简化。否则，将很难追踪哪一行机器指令来自哪一行源代码。
- en: In the first step, we need to instruct the compiler to add the necessary instrumentation
    to our SUT. The exact flag to add is compiler-specific; however, two major compilers—GCC
    and Clang—offer the same `--coverage` flag that enables coverage, producing data
    in a GCC-compatible `gcov` format.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们需要指示编译器为我们的SUT添加必要的instrumentation。需要添加的确切标志是编译器特定的；然而，两个主要的编译器—GCC和Clang—提供相同的`--coverage`标志，以启用覆盖率，生成GCC兼容的`gcov`格式的数据。
- en: 'This is how we can add the coverage instrumentation to our exemplary SUT from
    the previous section:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何将覆盖率 instrumentation 添加到前面章节中的示例SUT：
- en: chapter08/06-coverage/src/CMakeLists.txt
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/06-coverage/src/CMakeLists.txt
- en: '[PRE40]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s break this down step by step, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分解，如下所述：
- en: Ensure that we're running in the `Debug` configuration with the `if(STREQUAL)`
    command. Remember that you won't be able to get any coverage unless you run `cmake`
    with the `-DCMAKE_BUILD_TYPE=Debug` option.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们正在使用`if(STREQUAL)`命令以`Debug`配置运行。记住，除非你使用`-DCMAKE_BUILD_TYPE=Debug`选项运行`cmake`，否则你无法获得任何覆盖率。
- en: Add `--coverage` to the `PRIVATE` *compile options* for all *object files* that
    are part of the `sut` library.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`sut`库的所有`object files`的`PRIVATE`编译选项添加`--coverage`。
- en: 'Add `--coverage` to the `PUBLIC` linker options: both GCC and Clang interpret
    this as a request to link the `gcov` (or compatible) library with all targets
    that depend on `sut` (due to propagated properties).'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`PUBLIC`链接器选项添加`--coverage`： both GCC和Clang将此解释为请求与所有依赖于`sut`的目标链接`gcov`（或兼容）库（由于传播属性）。
- en: The `add_custom_command()` command is introduced to clean any stale `.gcda`
    files. Reasons to add this command are discussed in detail in the *Avoiding the
    SEGFAULT gotcha* section.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`add_custom_command()`命令被引入以清除任何陈旧的`.gcda`文件。讨论添加此命令的原因在*避免SEGFAULT陷阱*部分中有详细说明。'
- en: This is enough to produce code coverage. If you're using an IDE such as Clion,
    you'll be able to run your unit tests with coverage and get the results in a built-in
    report view. However, this won't work in any automated pipeline that might be
    run in your CI/CD. To get reports, we'll need to generate them ourselves with
    LCOV.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以生成代码覆盖率。如果你使用的是Clion之类的IDE，你将能够运行带有覆盖率的单元测试，并在内置的报告视图中获取结果。然而，这不会在CI/CD中运行的任何自动化管道中工作。要获取报告，我们需要自己使用LCOV生成它们。
- en: 'For this purpose, it''s best to define a new target called `coverage`. To keep
    things clean, we''ll define a separate function, `AddCoverage`, in another file
    to be used in the `test` listfile, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为此目的，最好定义一个名为`coverage`的新目标。为了保持整洁，我们将在另一个文件中定义一个单独的函数`AddCoverage`，用于在`test`列表文件中使用，如下所示：
- en: chapter08/06-coverage/cmake/Coverage.cmake
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/06-coverage/cmake/Coverage.cmake
- en: '[PRE41]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding snippet, we first detect the paths for `lcov` and `genhtml`
    (two command-line tools from the LCOV package). The `REQUIRED` keyword instructs
    CMake to throw an error when they''re not found. Next, we add a custom `coverage`
    target with the following steps:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们首先检测`lcov`和`genhtml`（来自LCOV包的两个命令行工具）的路径。`REQUIRED`关键字指示CMake在找不到它们时抛出错误。接下来，我们按照以下步骤添加一个自定义的`coverage`目标：
- en: Clear the counters from any previous runs.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除之前运行的任何计数器。
- en: Run the `target` executable (using generator expressions to get its path). `$<TARGET_FILE:target>`
    is an exceptional generator expression, and it will implicitly add a dependency
    on `target` in this case, causing it to be built before executing all commands.
    We'll provide `target` as an argument to this function.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`target`可执行文件（使用生成器表达式获取其路径）。`$<TARGET_FILE:target>`是一个特殊的生成器表达式，在此情况下它会隐式地添加对`target`的依赖，使其在执行所有命令之前构建。我们将`target`作为此函数的参数提供。
- en: Collect metrics for the solution from the current directory (`-d .`) and output
    to a file (`-o coverage.info`).
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从当前目录（`-d .`）收集解决方案的度量，并输出到文件（`-o coverage.info`）中。
- en: Remove (`-r`) unwanted coverage data on system headers (`'/usr/include/*'`)
    and output to another file (`-o filtered.info`).
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除（`-r`）不需要的覆盖数据（`'/usr/include/*'`）并输出到另一个文件（`-o filtered.info`）。
- en: Generate an HTML report in the `coverage` directory, and add a `--legend` color.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`coverage`目录中生成HTML报告，并添加一个`--legend`颜色。
- en: Remove temporary `.info` files.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除临时`.info`文件。
- en: Specifying the `WORKING_DIRECTORY` keyword sets binary tree as working directory
    for all commands.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定`WORKING_DIRECTORY`关键字可以将二叉树作为所有命令的工作目录。
- en: 'These are the general steps for both GCC and Clang, but it''s important to
    know that the `gcov` tool''s version has to match the version of the compiler.
    In other words, you can''t use GCC''s `gcov` tool for Clang-compiled code. To
    point `lcov` to Clang''s `gcov` tool, we can use the `--gcov-tool` argument. The
    only problem here is that it has to be a single executable. To deal with that,
    we can provide a simple wrapper script (remember to mark it as an executable with
    `chmod +x`), as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是GCC和Clang通用的步骤，但重要的是要知道`gcov`工具的版本必须与编译器的版本匹配。换句话说，不能用GCC的`gcov`工具来编译Clang代码。要使`lcov`指向Clang的`gcov`工具，我们可以使用`--gcov-tool`参数。这里唯一的问题是它必须是一个单一的可执行文件。为了解决这个问题，我们可以提供一个简单的包装脚本（别忘了用`chmod
    +x`将其标记为可执行文件），如下所示：
- en: cmake/gcov-llvm-wrapper.sh
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: cmake/gcov-llvm-wrapper.sh
- en: '[PRE42]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'All of our calls to `${LCOV_PATH}` in the previous function should receive
    the following additional flag:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前函数中所有对`${LCOV_PATH}`的调用应接受以下额外标志：
- en: '[PRE43]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Make sure that this function is available for inclusion in the `test` listfile.
    We can do this by extending the *include search path* in the main listfile, as
    follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 确保此函数可用于包含在`test`列表文件中。我们可以通过在主列表文件中扩展*包含搜索路径*来实现：
- en: chapter08/06-coverage/CMakeLists.txt
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/06-coverage/CMakeLists.txt
- en: '[PRE44]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This small line allows us to include all `.cmake` files from the `cmake` directory
    in our project. We can now use `Coverage.cmake` in the `test` listfile, like so:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这行小代码允许我们将`cmake`目录中的所有`.cmake`文件包括在我们的项目中。现在我们可以在`test`列表文件中使用`Coverage.cmake`，如下所示：
- en: chapter08/06-coverage/test/CMakeLists.txt (fragment)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: chapter08/06-coverage/test/CMakeLists.txt（片段）
- en: '[PRE45]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To build this target, use the following commands (notice that first command
    ends with a `DCMAKE_BUILD_TYPE=Debug` build type selection):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个目标，请使用以下命令（注意第一个命令以`DCMAKE_BUILD_TYPE=Debug`构建类型选择结束）：
- en: '[PRE46]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After executing all of the mentioned steps, you will see a short summary like
    this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有提到的步骤后，你将看到一个简短的摘要，就像这样：
- en: '[PRE47]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, open the `coverage/index.html` file in your browser and enjoy the reports!
    There's only one small issue though…
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的浏览器中打开`coverage/index.html`文件，享受这些报告吧！不过有一个小问题……
- en: Avoiding the SEGFAULT gotcha
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免SEGFAULT陷阱
- en: 'We may get ourselves into trouble when we start editing sources in such a solution.
    This is because the coverage information is split into two parts, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始在如此解决方案中编辑源代码时，我们可能会陷入困境。这是因为覆盖信息被分成两部分，如下所示：
- en: '`gcno` files, or **GNU Coverage Notes**, generated during the compilation of
    the SUT'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcno`文件，或**GNU覆盖笔记**，在SUT编译期间生成'
- en: '`gcda` files, or **GNU Coverage Data**, generated **and updated** during test
    runs'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcda`文件，或**GNU覆盖数据**，在测试运行期间生成和更新'
- en: The "update" functionality is a potential source of segmentation faults. After
    we run our tests initially, we're left with a bunch of `gcda` files that don't
    get removed at any point. If we make some changes to the source code and recompile
    the *object files*, new `gcno` files will be created. However, there's no wipe
    step—the old `gcda` files still follow the stale source. When we execute the `unit_tests`
    binary (it happens in the `gtest_discover_tests` macro), the coverage information
    files won't match, and we'll receive a `SEGFAULT` (segmentation fault) error.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: “更新”功能是段错误的一个潜在来源。在我们最初运行测试后，我们留下了许多`gcda`文件，在任何时候都没有被移除。如果我们对源代码做一些更改并重新编译*对象文件*，将创建新的`gcno`文件。然而，没有擦除步骤——旧的`gcda`文件仍然跟随过时的源代码。当我们执行`unit_tests`二进制文件（它在`gtest_discover_tests`宏中发生）时，覆盖信息文件将不匹配，我们将收到一个`SEGFAULT`（段错误）错误。
- en: To avoid this problem, we should erase any stale `gcda` files. Since our `sut`
    instance is a `STATIC` library, we can hook the `add_custom_command(TARGET)` command
    to building events. The clean will be executed before the rebuild starts.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们应该删除任何过时的`gcda`文件。由于我们的`sut`实例是一个**静态**库，我们可以将`add_custom_command(TARGET)`命令挂钩到构建事件上。在重建开始之前，将执行清理。
- en: Find links to more information in the *Further reading* section.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在*进一步阅读*部分找到更多信息链接。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'On the surface, it may seem that complexities associated with proper testing
    are so great, they aren''t worth the effort. It''s striking how much code out
    there is running without any tests at all, the primary argument being that testing
    your software is a daunting endeavor. I''ll add: even more so if done manually.
    Unfortunately, without rigorous automated testing, visibility of any issues in
    the code is incomplete or non-existent. Untested code is often quicker to write
    (not always), but it''s definitely much slower to read, refactor, and fix.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在表面上看，似乎与适当测试相关的复杂性如此之大，以至于不值得付出努力。令人惊讶的是，运行没有任何测试的代码量有多少，主要论点是测试软件是一个令人畏惧的任务。我要补充的是：如果手动完成，更是如此。不幸的是，如果没有严格的自动化测试，代码中任何问题的可见性是不完整或根本不存在的。未测试的代码通常写起来更快（并非总是如此），但肯定更慢阅读、重构和修复。
- en: 'In this chapter, we outlined some key reasons for going forward with tests
    from the get-go. One of the most compelling is mental health and a good night''s
    sleep. Not one developer lies in their bed thinking: *I can''t wait to be woken
    up in a few hours to put out some fires and fix bugs*. But seriously: catching
    errors before deploying them to production can be a life-saver for you (and the
    company).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了从一开始就进行测试的一些关键原因。其中最引人入胜的是心理健康和一个良好的夜晚睡眠。没有开发人员会躺在床上想：“我迫不及待地想在几小时后醒来灭火和修复bug。”但认真地说：在部署到生产之前捕获错误，可能对你（和公司）来说是个救命稻草。
- en: 'When it comes to testing utilities, CMake really shows its true strength. CTest
    can do wonders in detecting faulty tests: isolation, shuffling, repetition, timeouts.
    All these techniques are extremely handy and available through a simple flag straight
    from the command line. We also learned how we can use CTest to list tests, filter
    them, and control the output of test cases, but most importantly, we now know
    the true power of adopting a standard solution across the board. Any project built
    with CMake can be tested exactly the same, without investigating any details about
    its internals.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到测试工具，CMake确实显示了其真正的实力。CTest可以在检测错误测试方面做到 wonders：隔离、洗牌、重复、超时。所有这些技术都非常方便，并且可以通过简单的命令行标志直接使用。我们还学会了如何使用CTest列出测试、过滤测试以及控制测试用例的输出，但最重要的是，我们现在知道了采用标准解决方案的真正力量。任何使用CMake构建的项目都可以以完全相同的方式进行测试，而无需调查其内部细节。
- en: Next, we structured our project to simplify the process of testing and reuse
    the same *object files* between production code and test runners. It was interesting
    to write our own test runner, but maybe let's focus on the actual problem our
    program should solve and invest time in embracing a popular third-party testing
    framework.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们优化了项目结构，以简化测试过程并在生产代码和测试运行器之间复用相同的*对象文件*。编写自己的测试运行器很有趣，但也许让我们专注于程序应该解决的实际问题，并投入时间去拥抱一个流行的第三方测试框架。
- en: Speaking of which, we learned the very basics of Catch2 and GTest. We further
    dove into details of the GMock library and understood how test doubles work to
    make true unit tests possible. Lastly, we set up some reporting with LCOV. After
    all, there's nothing better than hard data to prove that our solution is, in fact,
    fully tested.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这个，我们学习了Catch2和GTest的基础知识。我们进一步深入研究了GMock库的细节，并理解了测试替身是如何工作以使真正的单元测试成为可能的。最后，我们使用LCOV设置了报告。毕竟，没有什么比硬数据更能证明我们的解决方案实际上是完全测试过的了。
- en: In the next chapter, we'll discuss more useful tooling to improve the quality
    of our source code and find issues we didn't even know existed.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论更多有用的工具来提高源代码的质量并发现我们甚至不知道存在的 issue。
- en: Further reading
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information you can refer to the following links:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接获取更多信息：
- en: '*CMake documentation on CTest*: [https://cmake.org/cmake/help/latest/manual/ctest.1.html](https://cmake.org/cmake/help/latest/manual/ctest.1.html)'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CMake关于CTest的文档*：[https://cmake.org/cmake/help/latest/manual/ctest.1.html](https://cmake.org/cmake/help/latest/manual/ctest.1.html)'
- en: '*Catch2 documentation*:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Catch2文档*：'
- en: '[https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md)'
- en: '[https://github.com/catchorg/Catch2/blob/devel/docs/tutorial.md](https://github.com/catchorg/Catch2/blob/devel/docs/tutorial.md)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/catchorg/Catch2/blob/devel/docs/tutorial.md](https://github.com/catchorg/Catch2/blob/devel/docs/tutorial.md)'
- en: '*GMock tutorial*: [https://google.github.io/googletest/gmock_for_dummies.html](https://google.github.io/googletest/gmock_for_dummies.html)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GMock教程*：[https://google.github.io/googletest/gmock_for_dummies.html](https://google.github.io/googletest/gmock_for_dummies.html)'
- en: '*Abseil:* [https://abseil.io/](https://abseil.io/)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Abseil*：[https://abseil.io/](https://abseil.io/)'
- en: '*Live at head with Abseil:* [https://abseil.io/about/philosophy#we-recommend-that-you-choose-to-live-at-head](https://abseil.io/about/philosophy#we-recommend-that-you-choose-to-live-at-head)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与Abseil一起生活在头部*：[https://abseil.io/about/philosophy#we-recommend-that-you-choose-to-live-at-head](https://abseil.io/about/philosophy#we-recommend-that-you-choose-to-live-at-head)'
- en: '*Why Abseil is becoming a dependency of GTest*: [https://github.com/google/googletest/issues/2883](https://github.com/google/googletest/issues/2883)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GTest为何依赖Abseil*：[https://github.com/google/googletest/issues/2883](https://github.com/google/googletest/issues/2883)'
- en: '*Coverage in GCC*:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GCC中的覆盖率*：'
- en: '[https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)'
- en: '[https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html](https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html](https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html)'
- en: '[https://gcc.gnu.org/onlinedocs/gcc/Gcov-Data-Files.html](https://gcc.gnu.org/onlinedocs/gcc/Gcov-Data-Files.html)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gcc.gnu.org/onlinedocs/gcc/Gcov-Data-Files.html](https://gcc.gnu.org/onlinedocs/gcc/Gcov-Data-Files.html)'
- en: '*Coverage in Clang*: [https://clang.llvm.org/docs/SourceBasedCodeCoverage.html](https://clang.llvm.org/docs/SourceBasedCodeCoverage.html)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Clang中的覆盖率*：[https://clang.llvm.org/docs/SourceBasedCodeCoverage.html](https://clang.llvm.org/docs/SourceBasedCodeCoverage.html)'
- en: '*LCOV documentation for command-line tools*:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令行工具的LCOV文档*:'
- en: '[http://ltp.sourceforge.net/coverage/lcov/lcov.1.php](http://ltp.sourceforge.net/coverage/lcov/lcov.1.php)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://ltp.sourceforge.net/coverage/lcov/lcov.1.php](http://ltp.sourceforge.net/coverage/lcov/lcov.1.php)'
- en: '[http://ltp.sourceforge.net/coverage/lcov/genhtml.1.php](http://ltp.sourceforge.net/coverage/lcov/genhtml.1.php)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://ltp.sourceforge.net/coverage/lcov/genhtml.1.php](http://ltp.sourceforge.net/coverage/lcov/genhtml.1.php)'
- en: '*GCOV update functionality*: [https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html#Invoking-Gcov](https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html#Invoking-Gcov)'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GCOV更新功能*: [https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html#Invoking-Gcov](https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html#Invoking-Gcov)'
