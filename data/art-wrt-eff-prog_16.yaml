- en: '*Assessments*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*评估*'
- en: '[*Chapter 1*](B16229_01_Epub_AM.xhtml#_idTextAnchor014):'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第1章*](B16229_01_Epub_AM.xhtml#_idTextAnchor014):'
- en: In many domains, the size of the problems grows as fast as or even faster than
    the available computational resources. As computing becomes more ubiquitous, heavy
    workloads may have to be executed on processors of limited power.
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在许多领域，问题的规模增长得与可用的计算资源一样快，甚至更快。随着计算变得更加普遍，重型工作负载可能必须在有限功率的处理器上执行。
- en: Single-core processing power largely stopped increasing about 15 years ago,
    and the advances in processor design and manufacturing largely translate into
    more processing cores and a large number of specialized computing units. Making
    the best use of these resources does not happen automatically and requires an
    understanding of how they work.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单核处理能力大约15年前基本停止增长，处理器设计和制造方面的进步主要转化为更多的处理核心和大量的专用计算单元。充分利用这些资源并不会自动发生，需要了解它们的工作原理。
- en: Efficiency refers to using more of the available computational resources more
    of the time and not doing any unnecessary work. Performance refers to meeting
    specific targets that depend on the problem the program is designed to solve.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 效率是指更多地利用可用的计算资源，而不做任何不必要的工作。性能是指满足依赖于程序设计解决的问题的特定目标。
- en: 'In different environments, the definition of performance may be completely
    different: the raw speed of the computation may be all that matters in a supercomputer,
    but it is not relevant in an interactive system as long as the system is faster
    than the person interacting with it.'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的环境中，性能的定义可能完全不同：在超级计算机中，计算的原始速度可能是唯一重要的，但在交互式系统中，只要系统比与之交互的人更快，速度就不相关。
- en: Performance must be measured; the proof of success or the guidance to the causes
    of the failure is in the quantitative measurement results and their analysis.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能必须进行测量；成功的证明或失败原因的指导在于定量测量结果及其分析。
- en: '[*Chapter 2*](B16229_02_Epub_AM.xhtml#_idTextAnchor026):'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第2章*](B16229_02_Epub_AM.xhtml#_idTextAnchor026):'
- en: Performance measurements are needed for two main reasons. First, they are used
    to define targets and describe the current status; without such measurements,
    we cannot say whether performance is poor or excellent; neither can we judge whether
    the performance targets are met. Second, measurements are used to study the effects
    of various factors on performance, evaluate the results of code changes and other
    optimizations.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能测量有两个主要原因。首先，它们用于定义目标并描述当前状态；没有这样的测量，我们无法判断性能是差还是优；也无法判断性能目标是否达到。其次，测量用于研究各种因素对性能的影响，评估代码更改和其他优化的结果。
- en: There is no single way to measure performance for all situations because there
    are usually too many contributing factors and causes to analyze using a single
    approach and because of the sheer volume of data that is needed to characterize
    the performance fully.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有一种单一的方法可以适用于所有情况的性能测量，因为通常有太多的影响因素和原因需要使用单一方法进行分析，而且需要大量数据来充分描述性能。
- en: 'Benchmarking done by manual instrumentation of the code has the advantage that
    it can collect any data you want, and it is easy to put the data in context: for
    each line of code, you know what function or step of the algorithm it belongs
    to. The main limitation is in the invasive nature of the method: you have to know
    what parts of the code to instrument and be able to do so; any areas of the code
    that are not covered by the data gathering instrumentation will not be measured.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对代码进行手动仪器化的基准测试具有可以收集所需任何数据的优势，并且很容易将数据放入上下文：对于每行代码，您都知道它属于哪个函数或算法的步骤。主要限制在于该方法的侵入性：您必须知道要对代码的哪些部分进行仪器化，并且能够这样做；未被数据收集仪器覆盖的代码区域将不被测量。
- en: Profiling is used to gather data on the distribution of the execution time or
    other metrics across the program. It can be done on the function or module level
    or at a lower level down to a single machine instruction. However, collecting
    the data at the lowest level of detail for the entire program at once is usually
    not practical, so the programs are usually profiled in stages, from coarse to
    fine granularity profiles.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能分析用于收集程序执行时间或其他指标在整个程序中的分布数据。它可以在函数或模块级别进行，也可以在更低级别，甚至到单个机器指令的级别。然而，通常不太实际地在整个程序的最低级别收集数据，因此程序通常会分阶段进行性能分析，从粗到细的粒度。
- en: Small scale and micro-benchmarks are used to quickly iterate on code changes
    and evaluate their impact on performance. They can also be used to analyze the
    performance of small code fragments in detail. Care must be taken to ensure that
    the context of the execution in the micro-benchmark resembles that of the real
    program as closely as possible.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小规模和微基准测试用于快速迭代代码更改并评估其对性能的影响。它们还可以用于详细分析小代码片段的性能。必须小心确保微基准测试中执行的上下文尽可能地类似于真实程序的执行上下文。
- en: '[*Chapter 3*](B16229_03_Epub_AM.xhtml#_idTextAnchor047):'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第3章*](B16229_03_Epub_AM.xhtml#_idTextAnchor047):'
- en: Modern CPUs have multiple computing units, many of which can operate at the
    same time. Using as much of the CPU computing power as possible at any time is
    the way to maximize a program's efficiency.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现代CPU具有多个计算单元，其中许多可以同时运行。尽可能多地利用CPU的计算能力是最大化程序效率的方法。
- en: Any two computations that can be done at the same time take only as much time
    as the longer of the two computations; the other one is effectively *free*. In
    many programs, we can replace some computations that are to be done in the future
    with other computations that can be done now. Often the tradeoff is doing more
    computations now than would have been done later, but even that improves the overall
    performance as long as the extra computations take no additional time because
    they are done in parallel with some other work that has to be done anyway.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何可以同时进行的两个计算所需的时间只有较长的那个计算所需的时间；另一个实际上是*免费*的。在许多程序中，我们可以用可以立即完成的其他计算替换将来要完成的一些计算。通常，权衡是现在做更多的计算，而不是以后做更多的计算，但只要额外的计算不需要额外的时间，因为它们与必须完成的其他工作并行进行，这甚至可以提高整体性能。
- en: This situation is known as data dependency. The countermeasure is the pipelining,
    where part of the future computation that does not depend on any unknown data
    is executed in parallel with the code that precedes it in the program order.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种情况被称为数据依赖性。对策是流水线处理，其中不依赖于任何未知数据的未来计算的一部分与程序顺序中其前面的代码并行执行。
- en: Conditional branches make the future computations indeterminate, which prevents
    the CPU from pipeline them. The CPU attempts to predict the code that will be
    executed so that it can maintain the pipeline. Whenever such a prediction fails,
    the pipeline must be flushed, and the results of all instructions that were predicted
    incorrectly are discarded.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件分支使未来的计算变得不确定，这阻止了CPU对其进行流水线处理。CPU试图预测将要执行的代码，以便它可以维持流水线。每当这样的预测失败时，流水线必须被清空，并且所有被错误预测的指令的结果都被丢弃。
- en: 'Any code that may or may not be needed but is executed based on the CPU''s
    branch prediction is evaluated speculatively. In the speculative execution context,
    any action that cannot be undone must not be fully committed: the CPU cannot overwrite
    the memory, do any I/O operations, issue interrupts, or report any errors. The
    CPU has the necessary hardware to hold these actions *suspended* until the speculatively
    executed code is confirmed as real code, or not. In the latter case, all would-be
    results of the speculative execution are discarded with no observable effects.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于CPU的分支预测可能需要或可能不需要的任何代码都会被进行推测性评估。在推测执行上下文中，任何无法撤销的操作都不得完全提交：CPU不能覆盖内存，执行任何I/O操作，发出中断，或报告任何错误。CPU具有必要的硬件来暂停这些操作，直到推测执行的代码被确认为真实代码，或者不是。在后一种情况下，推测执行的所有结果都将被丢弃，没有可观察的影响。
- en: 'A well-predicted branch typically has only a minor impact on performance. Therefore,
    the two main solutions to performance degradation caused by mispredicted branches
    are: rewrite the code such that the conditions become more predictable or change
    the computations to use conditionally accessed data instead of conditionally executed
    code. The latter is known as branchless computing.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个良好预测的分支通常对性能影响不大。因此，性能下降由于错误预测的分支的两个主要解决方案是：重写代码，使条件更可预测，或者改变计算以使用有条件访问的数据而不是有条件执行的代码。后者被称为无分支计算。
- en: '[*Chapter 4*](B16229_04_Epub_AM.xhtml#_idTextAnchor064):'
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第4章*]：'
- en: Modern CPUs are significantly faster than even the best memories. The latency
    for accessing a random location in memory is several nanoseconds, enough time
    for the CPU to execute dozens of operations. Even in streaming access, the overall
    memory bandwidth is not enough to supply the CPU with the data at the same speed
    it can carry out the computations.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现代CPU的速度明显快于甚至最好的内存。访问内存中的随机位置的延迟为几纳秒，足够CPU执行数十个操作。即使在流式访问中，整体内存带宽也不足以以与CPU执行计算相同的速度提供数据。
- en: 'The memory system includes a hierarchy of caches between the CPU and the main
    memory, so the first factor affecting the speed is the size of the data set: this
    ultimately determines whether the data fits into a cache or not. For a given size,
    the memory access pattern is critical: if the hardware can predict the next access,
    it can hide the latency by starting the transfer of data into the cache before
    this data is requested.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存系统包括CPU和主内存之间的一系列缓存，因此影响速度的第一个因素是数据集的大小：这最终决定了数据是否适合缓存。对于给定的大小，内存访问模式至关重要：如果硬件可以预测下一个访问，它可以通过在请求数据之前开始将数据传输到缓存来隐藏延迟。
- en: Often inefficient memory access is evident from a performance profile or timer
    output; this is particularly true for well-modularized code with good encapsulation
    of data. If the timing profile does not show the parts of the code that dominate
    the performance, the cache effectiveness profile may show which data is accessed
    inefficiently throughout the code.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，低效的内存访问可以从性能概要或计时器输出中看出；这对于良好模块化的代码和良好封装数据尤其如此。如果时间概要未显示出主导性能的代码部分，缓存效果概要可能显示出整个代码中访问效率低下的数据。
- en: Any optimization that uses less memory is likely to improve memory performance
    since more of the data fits into the cache. However, sequential access to a large
    amount of data is likely to be faster than random access to a smaller amount of
    data, unless the smaller data fits into the L1 cache, or, at most, the L2 cache.
    Optimizations that directly target the memory performance usually take the form
    of data structure optimizations, aimed mostly at avoiding random access and indirect
    memory access. To go beyond these, we usually have to change the algorithms to
    change memory access patterns to more cache-friendly ones.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何使用更少内存的优化都有可能改善内存性能，因为更多的数据可以放入缓存中。然而，对大量数据进行顺序访问通常比对少量数据进行随机访问更快，除非较小的数据适合于L1缓存，或者至多适合于L2缓存。直接针对内存性能的优化通常采取数据结构优化的形式，主要旨在避免随机访问和间接内存访问。要超越这些，通常需要改变算法以改变内存访问模式为更适合缓存的模式。
- en: '[*Chapter 5*](B16229_05_Epub_AM.xhtml#_idTextAnchor084):'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：
- en: The memory model describes the interaction of threads through shared memory;
    it is the set of restrictions and guarantees that are given when multiple threads
    access the same data in memory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存模型描述了通过共享内存进行线程交互的方式；它是在多个线程访问内存中相同数据时给出的一组限制和保证。
- en: On the one hand, if we did not need the shared data, all threads would run completely
    independently, and the program would scale perfectly as long as more processors
    are available. Also, writing such a program is no harder than writing a single-threaded
    program. On the other hand, all the bugs related to concurrency ultimately arise
    from invalid access to some shared data.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一方面，如果我们不需要共享数据，所有线程将完全独立运行，并且只要有更多的处理器可用，程序就会完美扩展。此外，编写这样的程序并不比编写单线程程序更难。另一方面，所有与并发相关的错误最终都源于对某些共享数据的无效访问。
- en: 'The overall memory model is a superposition of the several memory models for
    different components of the system: first of all, the hardware has a memory model
    that applies to any program running on it. The OS and the runtime environment
    may provide additional restrictions and guarantees. Finally, the compiler implements
    the memory model of the language such as C++ and may impose additional restrictions
    if it offers a stricter memory model than the language requires.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整体内存模型是系统不同组件的几个内存模型的叠加：首先，硬件有一个适用于在其上运行的任何程序的内存模型。操作系统和运行时环境可能提供额外的限制和保证。最后，编译器实现了诸如C++之类的语言的内存模型，并且如果它提供比语言要求更严格的内存模型，则可能会施加额外的限制。
- en: Several factors limit the performance of concurrent programs. First is the availability
    of work to be done in parallel (this problem is to be solved by advances in concurrent
    algorithms and is outside of the scope of this book). Second is the availability
    of the hardware to actually do this work (we have seen the example of a program
    becoming memory-bound). Finally, any time the threads must access the same data
    (shared data) concurrently, this access must be synchronized, and the ability
    of the compiler and the hardware to optimize the execution across such synchronized
    accesses is severely limited.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几个因素限制了并发程序的性能。首先是并行可用的工作量（这个问题需要通过并发算法的进步来解决，超出了本书的范围）。其次是实际执行这项工作的硬件的可用性（我们已经看到了程序变得内存绑定的例子）。最后，每当线程必须同时访问相同的数据（共享数据）时，这种访问必须同步，而编译器和硬件在这种同步访问的执行优化能力受到严重限制。
- en: '[*Chapter 6*](B16229_06_Epub_AM.xhtml#_idTextAnchor103):'
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第6章*]：'
- en: A lock-based program, in general, cannot be guaranteed to do useful work toward
    the end goal at all times. In a lock-free program, at least one thread is guaranteed
    to make such progress, and in a wait-free program, all threads make progress toward
    the end goal all the time.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般来说，基于锁的程序不能保证始终对最终目标做出有用的工作。在无锁程序中，至少有一个线程保证会取得进展，而在无等待程序中，所有线程始终朝着最终目标取得进展。
- en: '"Wait-free" should be understood in the algorithmic sense: each thread completes
    one step of the algorithm and immediately moves on to the next one, and the computed
    results are never wasted or discarded due to the synchronization between threads.
    It does not mean that a particular step takes the same time when the computer
    runs many threads as it does on one thread; the contention for the hardware access
    is still there.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “无等待”应该从算法的角度理解：每个线程完成算法的一步，然后立即转移到下一步，计算结果由于线程之间的同步而永远不会被浪费或丢弃。这并不意味着当计算机运行多个线程时，特定步骤所需的时间与在单个线程上运行时相同；硬件访问的争用仍然存在。
- en: 'While the most commonly thought about drawback of locks is their relatively
    high cost, this is not the main reason to avoid their use: a good algorithm can
    often reduce the amount of data sharing enough that the cost of the lock itself
    is not a major issue. The more severe problem is the complexity of managing many
    locks in a program that needs fine-granularity data synchronization: locking large
    amounts of data with a single lock means that only one thread can operate on all
    the locked data, but using many locks for small chunks of data leads to deadlocks,
    or at least very complex lock management.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管人们通常认为锁的主要缺点是它们的相对高成本，但这并不是避免使用它们的主要原因：一个好的算法通常可以减少数据共享的量，以至于锁本身的成本不是一个主要问题。更严重的问题是在需要细粒度数据同步的程序中管理许多锁的复杂性：使用单个锁锁定大量数据意味着只有一个线程可以操作所有被锁定的数据，但使用许多锁锁定小块数据会导致死锁，或者至少非常复杂的锁管理。
- en: 'The difference is not in the implementation of the counter itself but in the
    data dependency: a counter has no dependencies and, therefore, does not need to
    provide any memory order guarantees. An index, on the other hand, should guarantee
    that the array or the container element indexed by a particular value is visible
    to a thread when the thread reads this index value.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 差异不在于计数器本身的实现，而在于数据依赖性：计数器没有依赖性，因此不需要提供任何内存顺序保证。另一方面，索引应该保证当线程读取此索引值时，由特定值索引的数组或容器元素对线程可见。
- en: The key feature of the publishing protocol is that it allows many consumer threads
    to access the same data without locking while guaranteeing that the data generated
    by the producer thread is visible to the consumers before they access this data.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布协议的关键特征是它允许许多消费者线程在不加锁的情况下访问相同的数据，同时保证生产者线程生成的数据在消费者访问这些数据之前对其可见。
- en: '[*Chapter 7*](B16229_07_Epub_AM.xhtml#_idTextAnchor117):'
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第7章*]：'
- en: 'Any data structure designed for thread safety must have a transactional interface:
    every operation must either not change the state of the data structure or transform
    it from one well-defined state to another well-defined state.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保线程安全，设计的任何数据结构都必须具有事务接口：每个操作要么不改变数据结构的状态，要么将其从一个明确定义的状态转换为另一个明确定义的状态。
- en: 'This comes to the general observation of the performance of concurrent code:
    the more shared variables there are, the slower the code is. A complex data structure
    usually needs more data shared between threads that access it concurrently. In
    addition, there are simple algorithms (some are wait-free) that allow limited
    thread-safe operations on the data structures.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这带来了对并发代码性能的一般观察：共享的变量越多，代码就越慢。通常情况下，复杂的数据结构通常需要更多在并发访问时共享的数据。此外，还有一些简单的算法（有些是无等待的），允许对数据结构进行有限的线程安全操作。
- en: 'With an efficient lock, a lock-guarded data structure is not necessarily slower.
    Often, it is faster. Again, it comes to how many variables are shared: a lock-free
    scheme that requires multiple atomic variables may be slower than a single lock.
    We also have to consider the locality of the access: if the data structure is
    accessed in one or two places (like a queue), the lock can be quite efficient.
    A data structure with many elements that can all be accessed simultaneously is
    likely to have very poor performance if the entire data structure must be locked
    every time.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用高效的锁，受锁保护的数据结构不一定更慢。通常情况下，它更快。再次，这取决于有多少变量是共享的：需要多个原子变量的无锁方案可能比单个锁更慢。我们还必须考虑访问的局部性：如果数据结构只在一个或两个地方被访问（比如队列），那么锁可能非常有效。如果整个数据结构每次都必须被锁定，那么具有许多可以同时访问的元素的数据结构可能性能非常差。
- en: The main challenge is that adding memory to a data structure is usually a very
    disruptive operation that requires rearranging large parts of the internal data.
    It is difficult to do this while allowing other concurrent operations on the same
    data structure. For a lock-guarded data structure, this is of little concern (sometimes
    the lock is held for much longer than usual when one thread has to manage memory,
    but long delays can happen for other reasons as well, the program has to expect
    it). In lock-free data structures, it is very hard to manage memory if it affects
    the entire data structure. Nodal data structures do all their memory management
    on a single thread and use the publishing protocol to add new nodes to the structure,
    but sequential data structures may require data reallocation or at least complex
    internal memory management. In such cases, double-checked locking should be used
    to lock down the entire data structure while its memory is being reorganized.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要挑战在于向数据结构添加内存通常是一项非常具有破坏性的操作，需要重新排列内部数据的大部分内容。在允许同一数据结构上的其他并发操作的同时进行这项操作是很困难的。对于受锁保护的数据结构，这并不是什么大问题（有时当一个线程必须管理内存时，锁的持有时间比平常要长得多，但长时间的延迟也可能由其他原因引起，程序必须预料到）。在无锁数据结构中，如果内存影响整个数据结构，那么管理内存就非常困难。节点数据结构在单个线程上执行所有内存管理，并使用发布协议将新节点添加到结构中，但顺序数据结构可能需要数据重新分配，或者至少需要复杂的内部内存管理。在这种情况下，应该使用双重检查锁定来锁定整个数据结构，同时重新组织其内存。
- en: The A-B-A problem is common to all lock-free implementations of nodal data structures
    that use the position of data in memory to detect when a change was made. The
    problem happens when a new node is allocated in the memory of a previously deleted
    node. This creates the potential data race when another thread observes identical
    initial and final memory addresses, and the assumption is made that the data structure
    is unchanged. Multiple solutions exist, but all of them use various techniques
    to defer the deallocation of memory until the reallocation at the same address
    is no longer a problem.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A-B-A问题是所有使用内存中数据位置来检测更改的无锁节点数据结构实现中的常见问题。当在先前删除的节点的内存中分配新节点时，就会出现这个问题。当另一个线程观察到相同的初始和最终内存地址时，就会产生潜在的数据竞争，并且会假设数据结构没有发生变化。存在多种解决方案，但它们都使用各种技术来推迟内存的释放，直到在相同地址的重新分配不再是一个问题。
- en: '[*Chapter 8*](B16229_08_Epub_AM.xhtml#_idTextAnchor138):'
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第8章*]：'
- en: Without the standard giving some guarantees on the behavior of C++ programs
    in the presence of threads, it is not possible to write any portable concurrent
    C++ programs. Of course, in practice, we were using concurrency long before C++11,
    but this was made possible by the compiler writers who chose to follow an additional
    standard, such as POSIX. The downside of that situation was that these additional
    standards varied. There was no portable way to write, for example, concurrent
    programs for Linux and Windows without conditional compilation and OS-specific
    extensions for each platform. Similarly, atomic operations were implemented as
    CPU-specific extensions. Also, there were some subtle differences between various
    standards followed by different compilers, which occasionally resulted in very
    hard-to-find bugs.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果标准没有在存在线程的情况下对C++程序的行为提供一些保证，那么就不可能编写任何可移植的并发C++程序。当然，在实践中，我们在C++11之前就已经在使用并发，但这是由选择遵循其他标准的编译器编写者所做的。这种情况的缺点是这些额外的标准是不同的。没有一种可移植的方法可以在Linux和Windows等平台上编写并发程序，而不需要为每个平台进行条件编译和特定于操作系统的扩展。同样，原子操作是作为特定于CPU的扩展实现的。此外，不同编译器遵循的各种标准之间存在一些微妙的差异，这有时会导致非常难以发现的错误。
- en: 'The use of parallel algorithms is very simple: any algorithm that has a parallel
    version can be invoked with an execution policy as the first argument. If this
    is the parallel execution policy, the algorithm will run on multiple threads.
    To achieve the best performance, on the other hand, it may be necessary to redesign
    parts of the program. In particular, parallel algorithms provide no benefit if
    the data sequence is too short (what constitutes short depends on the algorithm
    and the cost of operating on the data elements). It may be necessary, therefore,
    to redesign the program to operate on larger sequences at once.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行算法的使用非常简单：任何具有并行版本的算法都可以通过执行策略作为第一个参数来调用。如果这是并行执行策略，算法将在多个线程上运行。然而，为了实现最佳性能，可能需要重新设计程序的部分。特别是，如果数据序列太短（短的定义取决于算法和操作数据元素的成本），并行算法将不会带来任何好处。因此，可能需要重新设计程序以一次操作更大的序列。
- en: Coroutines are functions that can suspend their own execution. After suspension,
    the control is returned to the caller (or to the resumer if this is not the first
    suspension). The coroutine can be resumed from any location in the code, from
    a different function or another coroutine, even from another thread.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协程是可以暂停自己的执行的函数。在暂停后，控制权将返回给调用者（或者如果这不是第一次暂停，则返回给恢复者）。协程可以从代码的任何位置、从不同的函数或另一个协程，甚至从另一个线程中恢复。
- en: '[*Chapter 9*](B16229_09_Epub_AM.xhtml#_idTextAnchor149):'
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第9章*]：'
- en: If it is necessary to make a copy of the object, then passing it by value accomplishes
    that. The programmer has to be careful to avoid making a second, unnecessary copy.
    Usually, this is done by moving from the function parameter; however, the programmer
    is responsible for not using the moved-from object as the compiler will not prevent
    it.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要对对象进行复制，那么通过值传递可以实现。程序员必须小心避免进行第二次不必要的复制。通常，这是通过从函数参数中移动来完成的；然而，程序员有责任不使用已移动的对象，因为编译器不会阻止它。
- en: In the most common case, when the function operates on the object but does not
    affect its lifetime, the function should not get any access that allows it to
    affect the ownership. Even if the object ownership is managed by shared pointers,
    such functions should use references or raw pointers instead of creating unnecessary
    copies of shared pointers.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最常见的情况下，当函数操作对象但不影响其生命周期时，函数不应该获得任何允许其影响所有权的访问。即使对象所有权由共享指针管理，这样的函数也应该使用引用或原始指针，而不是创建共享指针的不必要副本。
- en: Return value optimization refers to the compiler optimization technique where
    a local variable is returned by value from a function. The optimization effectively
    removes the local variable and constructs the result directly in the memory allocated
    for it by the caller. This optimization is particularly useful in factory functions
    that must construct and return objects.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回值优化是指编译器优化技术，其中局部变量通过值从函数返回。该优化有效地删除了局部变量，并直接在调用者分配的内存中构造结果。这种优化在必须构造和返回对象的工厂函数中特别有用。
- en: 'In memory-bound programs, the run time is limited by the speed of getting data
    to and from memory. Using less memory often leads directly to a faster running
    program. The second reason is more straightforward: memory allocations themselves
    take time. In concurrent programs, they also involve a lock, which serializes
    part of the execution.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内存受限的程序中，运行时间受到从内存中获取数据的速度的限制。使用更少的内存通常直接导致程序运行更快。第二个原因更直接：内存分配本身需要时间。在并发程序中，它们还涉及锁，这会使部分执行串行化。
- en: '[*Chapter 10*](B16229_10_Epub_AM.xhtml#_idTextAnchor167):'
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第10章*]：'
- en: 'The most important constraint is that the result (or, more strictly, the observable
    behavior) of the program must not change. The bar here is high: the compiler is
    allowed to optimize only when it can be proven that the results are correct for
    all possible inputs. The second consideration is practicality: the compiler has
    to make tradeoffs between compilation time and efficiency of the optimized code.
    Even with the highest optimization enabled, it may be too expensive to prove that
    some code transformations do not break the program.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最重要的约束是程序的结果（或者更严格地说，可观察的行为）不能改变。这里的标准很高：编译器只有在可以证明对所有可能的输入结果都是正确的情况下才能进行优化。第二个考虑因素是实用性：编译器必须在编译时间和优化代码的效率之间进行权衡。即使启用了最高级别的优化，证明某些代码转换不会破坏程序可能会太昂贵。
- en: 'In addition to the obvious effect (elimination of the function call), inlining
    enables the compiler to analyze a larger fragment of code. Without inlining, the
    compiler generally has to assume that "anything is possible" inside a function
    body. With inlining, the compiler can see, for example, whether the call to the
    function produces any observable behavior, such as I/O. The inlining is beneficial
    only up to a point: when overdone, it increases the size of the machine code.
    Also, the compilers have difficulties analyzing very long code fragments (the
    longer the fragment, the more memory and time it takes for the optimizer to process
    it). Compilers have heuristics that determine whether a particular function is
    worth inlining.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了明显的效果（消除函数调用）之外，内联还使编译器能够分析更大的代码片段。没有内联，编译器通常必须假设函数体内“任何事情都有可能发生”。通过内联，编译器可以看到，例如，调用函数是否产生了任何可观察的行为，比如I/O。内联只有到一定程度才是有益的：当过度使用时，会增加机器代码的大小。此外，编译器难以分析非常长的代码片段（代码片段越长，优化器处理它所需的内存和时间就越多）。编译器有启发式方法来确定是否值得内联特定函数。
- en: If the compiler does not make an optimization, it is often because this transformation
    is not guaranteed to be correct. The compiler does not have the same knowledge
    of how the program is going to be used that the programmer does; any combination
    of inputs is assumed to be valid. The other common reason is that the optimization
    is not expected to be universally effective. The compiler may be right on this
    count, but if the measurements show that the programmer is right, the optimization
    would have to be forced into the source code somehow.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果编译器没有进行优化，通常是因为这种转换不能保证是正确的。编译器不具有与程序员相同的关于程序如何使用的知识；任何输入组合都被假定为有效。另一个常见的原因是，优化不会普遍有效。编译器可能在这一点上是正确的，但如果测量结果表明程序员是正确的，那么优化就必须以某种方式强制进入源代码中。
- en: The main benefit of inlining is not that it eliminates the cost of the function
    call. Rather, it is that it allows the compiler to see what is going on inside
    the function. This enables continuous analysis of the code that immediately precedes
    and follows the function call. Some optimizations that were not possible when
    each section of the code was considered in isolation become possible when a larger
    code fragment is optimized as a single basic block.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内联的主要好处不是消除函数调用的成本，而是允许编译器看到函数内部发生了什么。这使得对函数调用前后的代码进行连续分析成为可能。在将每个代码段视为独立部分时无法进行的一些优化，在将更大的代码片段作为单个基本块进行优化时就变得可能了。
- en: '[*Chapter 11*](B16229_11_Epub_AM.xhtml#_idTextAnchor176):'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第11章*](B16229_11_Epub_AM.xhtml#_idTextAnchor176):'
- en: 'Undefined behavior is what happens when a program is executed out of contract:
    the specification says what the valid inputs are and what the results should be.
    If invalid input is detected, this is also a part of the contract. If the invalid
    input is not detected and the program proceeds on the (false) assumption that
    the input is valid, the results are undefined: the specification does not say
    what must happen.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未定义行为是程序在执行时违反合同的情况：规范说明了有效的输入是什么，结果应该是什么。如果检测到无效输入，这也是合同的一部分。如果未检测到无效输入，并且程序在（错误的）假设输入是有效的情况下继续进行，结果是未定义的：规范没有说明必须发生什么。
- en: 'In C++, there are two main reasons for allowing undefined behavior. First of
    all, there are operations that require hardware support or are executed differently
    on different hardware. It may be very difficult or even impossible to deliver
    a specific result on some hardware systems. The second reason is performance:
    it may be expensive to guarantee a specific outcome across all computing architectures.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++中，允许未定义行为有两个主要原因。首先，有一些操作需要硬件支持，或者在不同的硬件上执行方式不同。在某些硬件系统上，很难甚至不可能产生特定的结果。第二个原因是性能：在所有计算架构上保证特定结果可能是昂贵的。
- en: No, an undefined result does not mean that the result must be wrong. The desired
    result is also permitted under undefined behavior, it's just not guaranteed. Further,
    undefined behavior taints the entire program. Compiling the same code in a file
    together with some other code may produce unexpected results. A new version of
    the compiler may be able to make better optimizations on the assumption that undefined
    behavior never happens. You should run the sanitizer and fix the errors it reports.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，未定义的结果并不意味着结果一定是错误的。期望的结果也是在未定义行为下允许的，只是不被保证。此外，未定义行为会影响整个程序。将相同的代码与其他代码一起编译在一个文件中可能会产生意想不到的结果。编译器的新版本可能能够更好地优化，假设未定义行为永远不会发生。您应该运行检测工具并修复它报告的错误。
- en: 'For the same reason, the C++ standard does it: performance. If there is a special
    case that is hard to handle correctly without adding overhead to the "normal"
    case, you may choose not to handle the special case at all. While it is preferable
    to detect this situation at run time, such detection may also be expensive. In
    this case, the input validation should be optional. If the user supplies an invalid
    input but fails to run the detection tool, the program''s behavior is undefined
    since the algorithm itself assumes that the input is valid and that assumption
    has been violated.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于同样的原因，C++标准也是如此：性能。如果有一种特殊情况很难在不增加“正常”情况的开销的情况下正确处理，那么可以选择不处理这种特殊情况。虽然最好在运行时检测到这种情况，但这种检测也可能很昂贵。在这种情况下，输入验证应该是可选的。如果用户提供了无效的输入但未运行检测工具，则程序的行为是未定义的，因为算法本身假设输入是有效的，而这一假设已经被违反。
- en: '[*Chapter 12*](B16229_12_Epub_AM.xhtml#_idTextAnchor184):'
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第12章*](B16229_12_Epub_AM.xhtml#_idTextAnchor184):'
- en: Design for performance boils down to creating a design that does not prevent
    high-performing algorithms and implementations by imposing constraints incompatible
    with such implementations.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现高性能，设计的关键在于创建一个设计，不会通过施加与这种实现不兼容的约束来阻止高性能算法和实现。
- en: In general, the less the interface reveals the internal details of a component,
    the more freedom the implementer has. This should be balanced against the freedom
    of the client to use efficient algorithms.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总的来说，接口揭示组件的内部细节越少，实现者就越自由。这应该与客户使用高效算法的自由相平衡。
- en: Higher-level interfaces allow for better performance because they allow the
    implementer to temporarily violate the invariants specified by the interface contract.
    The initial and the final states of the component are visible to the caller and
    must maintain these invariants. However, if the implementer knows that the intermediate
    states are not exposed to the outside world, a more efficient temporary state
    can often be found.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更高级的接口可以提供更好的性能，因为它们允许实现者暂时违反接口合同中规定的不变性。组件的初始状态和最终状态对调用者可见，并且必须保持这些不变性。然而，如果实现者知道中间状态不会暴露给外部世界，通常可以找到更有效的临时状态。
- en: The short answer is, we can't. The objective is, then, to find a way to collect
    such measurements. This is done by measuring the performance of modeling benchmarks
    and prototypes and using the results to estimate performance limitations that
    result from different design decisions.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简短的回答是，我们不能。因此，目标是找到一种收集这些测量数据的方法。这是通过测量建模基准和原型的性能，并利用结果来估计由不同设计决策产生的性能限制来实现的。
