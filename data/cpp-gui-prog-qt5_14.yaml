- en: Qt Quick and QML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick和QML
- en: In this chapter, we are going to learn something very different from the rest
    of the chapters in this book. Qt consists of two different methods for developing
    an application. The first method is Qt Widgets and C++, which we have covered
    in all previous chapters. The second method is using Qt Quick controls and the
    QML scripting language, which we will be covering in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习与本书其他章节非常不同的内容。Qt包括两种不同的应用开发方法。第一种方法是Qt Widgets和C++，这是我们在之前所有章节中都涵盖过的内容。第二种方法是使用Qt
    Quick控件和QML脚本语言，这将在本章中介绍。
- en: 'In this chapter, we will cover the following topics :'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to Qt Quick and QML
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Qt Quick和QML
- en: Qt Quick Widgets and Controls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick控件和控制
- en: Qt Quick Designer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick设计师
- en: Qt Quick Layouts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick布局
- en: Basic QML Scripting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的QML脚本
- en: Are you ready? Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？让我们开始吧！
- en: Introduction to Qt Quick and QML
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Qt Quick和QML
- en: In the following section, we will learn what Qt Quick and QML are, and how we
    can make use of them to develop Qt applications without the need for writing C++
    code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将学习Qt Quick和QML是什么，以及如何利用它们来开发Qt应用程序，而无需编写C++代码。
- en: Introducing Qt Quick
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Qt Quick
- en: '**Qt Quick** is a module in Qt that provides a whole set of user-interface
    engines and language infrastructure for developing touch-oriented and visual-oriented
    applications. Instead of using the usual Qt Widgets for user-interface design,
    developers who choose Qt Quick will be using the Qt Quick objects and controls
    instead.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt Quick**是Qt中的一个模块，为开发面向触摸和视觉的应用程序提供了一整套用户界面引擎和语言基础设施。开发人员选择Qt Quick后，将使用Qt
    Quick对象和控件，而不是通常的Qt Widgets进行用户界面设计。'
- en: Furthermore, developers will be writing their code using the QML language, which
    has similar syntax to **JavaScript**, rather than writing in C++ code. You can,
    however, use the C++ API provided by Qt to extend the QML application by cross-calling
    each language's functions (calling C++ functions in QML, and vice versa).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，开发人员将使用类似于**JavaScript**的QML语言编写代码，而不是使用C++代码。但是，您可以使用Qt提供的C++ API来扩展QML应用程序，通过相互调用每种语言的函数（在QML中调用C++函数，反之亦然）。
- en: 'Developers can choose which method they prefer for developing their applications
    by choosing the right option when creating the project. Instead of choosing the
    usual Qt Widgets Application option, developers can pick Qt Quick Application,
    which tells Qt Creator to create different starting files and settings for your
    project that empowers the Qt Quick modules:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以通过在创建项目时选择正确的选项来选择他们喜欢的开发应用程序的方法。开发人员可以选择Qt Quick应用程序而不是通常的Qt Widgets应用程序选项，这将告诉Qt
    Creator为您的项目创建不同的起始文件和设置，从而增强Qt Quick模块：
- en: '![](img/43e54681-0742-4983-9a4e-70c933538d25.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43e54681-0742-4983-9a4e-70c933538d25.png)'
- en: 'When you''re creating a Qt Quick Application project, Qt Creator will ask you
    to choose the Minimal required Qt version for your project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建Qt Quick应用程序项目时，Qt Creator将要求您选择项目的最低要求Qt版本：
- en: '![](img/3077a542-a06f-4c6a-96d6-2b84826ebc78.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3077a542-a06f-4c6a-96d6-2b84826ebc78.png)'
- en: Once you have selected a Qt version, Qt Quick Designer will determine which
    features to enable and which widgets will appear on the QML Types window. We will
    talk more about those in later sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 选择了Qt版本后，Qt Quick设计师将确定要启用哪些功能，并在QML类型窗口上显示哪些小部件。我们将在后面的部分中更多地讨论这些内容。
- en: Introducing QML
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍QML
- en: '**QML** (**Qt Modeling Language**) is a user-interface markup language for
    designing touch-friendly user interfaces, similar to how CSS works on HTML. Unlike
    C++ or JavaScript, which are both imperative languages, QML is a declarative language.
    In declarative programming, you only express the logic in your script without
    describing its control flow. It simply tells the computer what to do, instead
    of how to do it. Imperative programing, however, requires statements to specify
    actions.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**QML**（**Qt建模语言**）是一种用于设计触摸友好用户界面的用户界面标记语言，类似于CSS在HTML上的工作方式。与C++或JavaScript不同，它们都是命令式语言，QML是一种声明式语言。在声明式编程中，您只需在脚本中表达逻辑，而不描述其控制流。它只是告诉计算机要做什么，而不是如何做。然而，命令式编程需要语句来指定操作。'
- en: 'When you open up your newly created Qt Quick project, you will see `main.qml`
    and `MainForm.ui.qml` in your project, instead of the usual `mainwindow.h` and
    `mainwindow.cpp` files. You can see this in the project directory in the following
    screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开新创建的Qt Quick项目时，您将在项目中看到`main.qml`和`MainForm.ui.qml`，而不是通常的`mainwindow.h`和`mainwindow.cpp`文件。您可以在以下截图中的项目目录中看到这一点：
- en: '![](img/fc36ad7d-787e-4a09-bde7-f95ab7c362df.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc36ad7d-787e-4a09-bde7-f95ab7c362df.png)'
- en: 'This is because the entire project will be mainly running on QML instead of
    C++. The only C++ file you will see is `main.cpp`, and all that does is load the
    `main.qml` file during the application startup. The code that does this in `main.cpp`
    is shown in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为整个项目主要将在QML上运行，而不是在C++上。您将看到的唯一C++文件是`main.cpp`，它在应用程序启动时只是加载`main.qml`文件。`main.cpp`中执行此操作的代码如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should have realized that there are two types of QML files, one with the
    extension `.qml`, and another with extension `.ui.qml`. Even though they are both
    running on the same syntax and so forth, they serve a very different purpose in
    your project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经意识到有两种类型的QML文件，一种是扩展名为`.qml`，另一种是扩展名为`.ui.qml`。尽管它们都使用相同的语法等，但它们在项目中的作用是非常不同的。
- en: First, the `.ui.qml` file (with an extra .`ui` at the beginning) serves as the
    declarative file for Qt Quick-based user interface design. You can edit a `.ui.qml`
    file, using the Qt Quick Designer visual editor, and easily design your application's
    GUI. You can also add your own code to the file, but there are some limitations
    on what code they can contain, especially those related to logic code. When you
    run your Qt Quick application, the Qt Quick engine will read through all the information
    stored in the `.ui.qml` file and construct the user interface accordingly, which
    is very similar to the `.ui` file used in Qt Widgets applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`.ui.qml`文件（在开头多了一个`.ui`）用作基于Qt Quick的用户界面设计的声明文件。您可以使用Qt Quick Designer可视化编辑器编辑`.ui.qml`文件，并轻松设计应用程序的GUI。您也可以向文件添加自己的代码，但对文件中可以包含的代码有一些限制，特别是与逻辑代码相关的限制。当运行Qt
    Quick应用程序时，Qt Quick引擎将阅读`.ui.qml`文件中存储的所有信息，并相应地构建用户界面，这与Qt Widgets应用程序中使用的`.ui`文件非常相似。
- en: Then, we have another file with only the `.qml` extension. This file is only
    used for constructing the logic and functionality in your Qt Quick application,
    much like the `.h` and `.cpp` files used in the Qt Widget application. These two
    different formats separate the visual definitions of your application from its
    logic blocks. This allows the developer to apply the same logic code to different
    user interface templates. You cannot open a `.qml` file using Qt Quick Designer,
    since it is not used for GUI declaration. `.qml` files are written by developers
    by hand, and they have no restrictions on the QML language features they use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有另一个只有`.qml`扩展名的文件。这个文件仅用于构建Qt Quick应用程序中的逻辑和功能，就像Qt Widget应用程序中使用的`.h`和`.cpp`文件一样。这两种不同的格式将应用程序的视觉定义与其逻辑块分开。这使开发人员能够将相同的逻辑代码应用于不同的用户界面模板。您不能使用Qt
    Quick Designer打开`.qml`文件，因为它不用于GUI声明。`.qml`文件是由开发人员手动编写的，对他们使用的QML语言特性没有限制。
- en: 'Let''s look at the differences with both of these QML files by first opening
    up `MainForm.ui.qml`. By default, Qt Creator will open up the user interface designer
    (Qt Quick Designer); however, let''s move over to code-editing mode by pressing
    the Edit button on the left panel:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先打开`MainForm.ui.qml`，看看这两个QML文件的区别。默认情况下，Qt Creator将打开用户界面设计师（Qt Quick Designer）；然而，让我们通过按左侧面板上的编辑按钮切换到代码编辑模式：
- en: '![](img/d2c87dda-ef9d-45f7-89c1-0bc053484c75.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2c87dda-ef9d-45f7-89c1-0bc053484c75.png)'
- en: 'Then, you will be able to see the QML script that forms the user interface
    you just saw in the design mode. Let''s analyze this code to see how QML works
    compared to C++. The first thing you see in the `MainForm.ui.qml` is this line
    of code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将能够看到形成您在设计模式中看到的用户界面的QML脚本。让我们分析这段代码，看看QML与C++相比是如何工作的。在`MainForm.ui.qml`中，您首先看到的是这行代码：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is quite straightforward; we need to import the `Qt Quick` module with
    the appropriate version number. Different Qt Quick versions may have different
    functionalities, and support different widget controls. Sometimes, even the syntax
    could be slightly different. Please make sure you pick the right version for your
    project, and that it supports the features you need. If you don't know which version
    to use, do consider the latest version.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单明了；我们需要导入带有适当版本号的`Qt Quick`模块。不同的Qt Quick版本可能具有不同的功能，并支持不同的部件控件。有时，甚至语法可能略有不同。请确保为您的项目选择正确的版本，并确保它支持您需要的功能。如果不知道要使用哪个版本，请考虑使用最新版本。
- en: 'Next, we will see different GUI objects (which we call QML types) being declared
    between two curly braces. The first one that we see is a `Rectangle` type:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到在两个大括号之间声明的不同GUI对象（我们称之为QML类型）。我们首先看到的是`Rectangle`类型：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Rectangle` type, in this case, is the window background, much like the
    central widget used in the Qt Widget Application project. Let''s look at the other
    QML types that are under the `Rectangle`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Rectangle`类型是窗口背景，类似于Qt Widget应用程序项目中使用的中央窗口部件。让我们看看`Rectangle`下面的其他QML类型：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `MousArea` type, as its name implies, is an invincible shape that detects
    mouse clicks and touch events. You can basically turn anything into a button by
    placing a `MouseArea` on top of it. After that, we also have a `TextEdit` type,
    which acts exactly like a `Line Edit` widget in a Qt Widget Application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`MousArea`类型，顾名思义，是一个检测鼠标点击和触摸事件的无形形状。您基本上可以通过在其上放置`MouseArea`将任何东西变成按钮。之后，我们还有一个`TextEdit`类型，其行为与Qt
    Widget应用程序中的`Line Edit`部件完全相同。'
- en: You may have noticed that there are two properties in the `Rectangle` declaration
    that carry the `alias` keyword. These two properties expose the `MouseArea` and
    `TextEdit` types, and allow other QML scripts to interact with them, which we
    will learn how to do next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在`Rectangle`声明中有两个带有`alias`关键字的属性。这两个属性公开了`MouseArea`和`TextEdit`类型，并允许其他QML脚本与它们交互，接下来我们将学习如何做到这一点。
- en: 'Now, open up `main.qml` and look at its code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`main.qml`并查看其代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the code above, there is a `Window` type that is only available by importing
    the `QtQuick.Window` module. After setting the properties of the `Window` type,
    the `MainForm` type is declared. This `MainForm` type is actually the entire user
    interface  we saw previously in `MainForm.ui.qml`. Since the `MouseArea` and `TextEdit` types
    have been exposed in `MainForm.ui.qml`, we can now access and make use of them
    in `main.qml`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，有一个`Window`类型，只能通过导入`QtQuick.Window`模块才能使用。设置了`Window`类型的属性后，声明了`MainForm`类型。这个`MainForm`类型实际上就是我们之前在`MainForm.ui.qml`中看到的整个用户界面。由于`MouseArea`和`TextEdit`类型已在`MainForm.ui.qml`中公开，我们现在可以在`main.qml`中访问并使用它们。
- en: QML also uses the signal-and-slot mechanism provided by Qt, but in a slightly
    different form of writing, since we're no longer writing C++ code. For example,
    we can see `onClicked` being used in the code above, which is a built-in signal
    equivalent to `clicked()` in a Qt Widgets Application. Since the `.qml` file is
    the place where we define the application logic, we can define what happens when
    `onClicked` is being called. On the other hand, we cannot do the same in `.ui.qml` since
    only visual-related code is allowed in it. You will get warnings from Qt Creator
    if you try to write logic-related code in a `.ui.qml` file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: QML还使用Qt提供的信号和槽机制，但写法略有不同，因为我们不再编写C++代码。例如，我们可以在上面的代码中看到`onClicked`的使用，这是一个内置信号，相当于Qt
    Widgets应用程序中的`clicked()`。由于`.qml`文件是我们定义应用程序逻辑的地方，我们可以定义`onClicked`被调用时发生的事情。另一方面，我们不能在`.ui.qml`中做同样的事情，因为它只允许与视觉相关的代码。如果你尝试在`.ui.qml`文件中编写逻辑相关的代码，Qt
    Creator会发出警告。
- en: 'Just like the Qt Widgets Application, you can also build and run the project
    the same way as before. The default example application looks something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Qt Widgets应用程序一样，您也可以像以前一样构建和运行项目。默认示例应用程序看起来像这样：
- en: '![](img/cfbfa37c-2ba3-4e65-b456-4735c5c90efa.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfbfa37c-2ba3-4e65-b456-4735c5c90efa.png)'
- en: You might realize that the build process is pretty fast. This is because QML
    code doesn't get compiled into binary by default. QML is an interpreted language,
    just like JavaScript, and thus it doesn't need to be compiled in order for it
    to be executed. All the QML files will just get packed into your application's
    resource system during the build process. Then, the QML files will be loaded and
    interpreted by the Qt Quick engine once the application is started.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会意识到构建过程非常快。这是因为QML代码默认不会被编译成二进制代码。QML是一种解释性语言，就像JavaScript一样，因此不需要编译就可以执行。在构建过程中，所有QML文件将被打包到应用程序的资源系统中。然后，在应用程序启动时，Qt
    Quick引擎将加载和解释QML文件。
- en: However, you can still choose to compile your QML scripts into binary, using
    the `Qt Quick Compiler` program included in Qt, to make the code execution slightly
    faster than usual. It is an optional step that is not required unless you are
    trying to run your application on an embedded system that has very limited resources.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您仍然可以选择使用包含在Qt中的`Qt Quick Compiler`程序将您的QML脚本编译成二进制代码，以使代码执行速度略快于通常情况。这是一个可选步骤，除非您要在资源非常有限的嵌入式系统上运行应用程序，否则不需要。
- en: Now that we have understood what **Qt Quick **and **QML** language are, let's
    take a look at all the different QML types provided by Qt.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了**Qt Quick**和**QML**语言是什么，让我们来看看Qt提供的所有不同的QML类型。
- en: Qt Quick widgets and controls
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick小部件和控件
- en: In Qt Quick's realm, widgets and controls are known as `QML types`. By default,
    **Qt Quick Designer** provides us with a set of basic QML types. You can also
    import additional QML types that come with different modules. Furthermore, you
    can even create your own custom QML types if none of the existing ones fit, your
    needs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick的领域中，小部件和控件被称为`QML类型`。默认情况下，**Qt Quick Designer**为我们提供了一组基本的QML类型。您还可以导入随不同模块提供的其他QML类型。此外，如果没有现有的类型符合您的需求，甚至可以创建自定义的QML类型。
- en: 'Let''s take a look at what QML types come with Qt Quick Designer by default.
    First off, here are the QML types under the Basic category:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Qt Quick Designer默认提供的QML类型。首先，这是基本类别下的QML类型：
- en: '![](img/87221c3c-f5cb-4409-a1aa-2e1b86f76030.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87221c3c-f5cb-4409-a1aa-2e1b86f76030.png)'
- en: 'Let''s have a look at the different options:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同的选项：
- en: '**Border Image**: Border Image is a QML type that is designed to create scalable
    rectangular shapes that can maintain their corner shapes and borders.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Border Image**：Border Image是一个设计用来创建可维持其角形状和边框的可伸缩矩形形状的QML类型。'
- en: '**Flickable**: Flickable is a QML type that contains all its children types,
    and, displays them within its clipping area. Flickable has also been extended
    and used by the `ListView` and `GridView` types for scrolling long content. It
    can also be moved by a touchscreen flick gesture.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flickable**：Flickable是一个包含所有子类型的QML类型，并在其裁剪区域内显示它们。Flickable还被`ListView`和`GridView`类型扩展和用于滚动长内容。它也可以通过触摸屏轻扫手势移动。'
- en: '**Focus Scope**: Focus Scope is a low-level QML type that is used to facilitate
    the construction of other QML types that can acquire keyboard focus when being
    pressed or released. We usually don''t directly use this QML type, but rather
    use other types that are directly inherited from it, such as `GroupBox`, `ScrollView`,
    `StatusBar`, and so on.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Focus Scope**：Focus Scope是一个低级别的QML类型，用于促进其他QML类型的构建，这些类型在被按下或释放时可以获得键盘焦点。我们通常不直接使用这种QML类型，而是使用直接从它继承的其他类型，如`GroupBox`、`ScrollView`、`StatusBar`等。'
- en: '**Image**: The `Image` type is pretty much self-explanatory. It loads an image
    either locally or from a network.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Image**：`Image`类型基本上是不言自明的。它可以加载本地或网络上的图像。'
- en: '**Item**: The `Item` type is the most basic QML type for all visual items in
    Qt Quick. All the visual items in Qt Quick inherit from this `Item` type.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Item**：`Item`类型是Qt Quick中所有可视项的最基本的QML类型。Qt Quick中的所有可视项都继承自这个`Item`类型。'
- en: '**Mouse****Area**: We have seen the example usage of the `MouseArea` type in
    the default Qt Quick Application project. It detects mouse clicks and touch events
    within a predefined area, and calls the clicked signal whenever it detects one.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MouseArea**：我们已经在默认的Qt Quick应用程序项目中看到了`MouseArea`类型的示例用法。它在预定义区域内检测鼠标点击和触摸事件，并在检测到时调用clicked信号。'
- en: '**Rectangle**: A `Rectangle` QML type is pretty similar to the `Item` type,
    except it has a background that can be filled with solid color or a gradient.
    Optionally, you can also add a border to it with its own color and thickness.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rectangle**：`Rectangle` QML类型与`Item`类型非常相似，只是它有一个可以填充纯色或渐变的背景。您还可以选择使用自己的颜色和厚度添加边框。'
- en: '**Text**: The `Text` QML type is also pretty self-explanatory. It simply displays
    a line of text on the window. You can use it to display both plain and rich text
    with a specific font family and font size.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**：`Text` QML类型也很容易理解。它只是在窗口上显示一行文本。您可以使用它来显示特定字体系列和字体大小的纯文本和富文本。'
- en: '**Text Edit**: The Text Edit QML type is equivalent to the `Text Edit` widget
    in Qt Widgets Application. It allows the user to key in the text when being focused.
    It can display both plain and formatted text, which is very different from the
    `Text Input` type.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本编辑**：文本编辑QML类型相当于Qt Widgets应用程序中的`文本编辑`小部件。当焦点在它上面时，允许用户输入文本。它可以显示纯文本和格式化文本，这与`文本输入`类型非常不同。'
- en: '**Text Input**: The Text Input QML type is equivalent to the Line Edit widget
    in Qt Widgets Application, in that it can only display a single line of editable
    plain text, which is different from the `Text Edit` type. You can also apply an
    input constraint to it through a validator or input mask. It can also be used
    for password input fields by setting the `echoMode` to `Password` or `PasswordEchoOnEdit`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本输入**：文本输入QML类型相当于Qt Widgets应用程序中的行编辑小部件，因为它只能显示单行可编辑的纯文本，这与`文本编辑`类型不同。您还可以通过验证器或输入掩码对其应用输入约束。通过将`echoMode`设置为`Password`或`PasswordEchoOnEdit`，它也可以用于密码输入字段。'
- en: 'The QML types that we have discussed here are the most basic ones that come
    with Qt Quick Designer by default. These are also the basic building blocks used
    for constructing some other more complex QML types. There are many additional
    modules that come with Qt Quick that we can import into our project, for example,
    if we add the following line to our `MainForm.ui.qml` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的QML类型是Qt Quick Designer默认提供的最基本的类型。这些也是用于构建其他更复杂的QML类型的基本构建块。Qt Quick还提供了许多额外的模块，我们可以将其导入到我们的项目中，例如，如果我们在`MainForm.ui.qml`文件中添加以下行：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A bunch of additional QML types will then appear on your Qt Quick Designer
    when you switch over to Design mode:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当您切换到设计模式时，Qt Quick Designer将在您的Qt Quick Designer上显示一堆额外的QML类型：
- en: '![](img/64d47d41-00c4-45c9-9bbe-80aff6dc8bd3.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64d47d41-00c4-45c9-9bbe-80aff6dc8bd3.png)'
- en: We won't go through all these QML types one by one, as there are too many of
    them. If you are interested in learning more about these QML types, please visit
    the following link:[ https://doc.qt.io/qt-5.10/qtquick-controls-qmlmodule.html](https://doc.qt.io/qt-5.10/qtquick-controls-qmlmodule.html)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会逐一介绍所有这些QML类型，因为它们太多了。如果您有兴趣了解更多关于这些QML类型的信息，请访问以下链接：[https://doc.qt.io/qt-5.10/qtquick-controls-qmlmodule.html](https://doc.qt.io/qt-5.10/qtquick-controls-qmlmodule.html)
- en: Qt Quick Designer
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick Designer
- en: Next, we will look at the Qt Quick Designer layout for the Qt Quick Application
    project. When you open up a `.ui.qml` file, Qt Quick Designer, the designer tool
    included in the Qt Creator toolset, will be launched automatically for you.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下Qt Quick Designer对Qt Quick应用程序项目的布局。当您打开一个`.ui.qml`文件时，Qt Quick Designer，即包含在Qt
    Creator工具集中的设计工具，将自动为您启动。
- en: Those of you who have followed all the example projects since the very first
    chapter of this book may realize the Qt Quick Designer looks a bit different from
    the one we have been using all this time. This is because the Qt Quick project
    is very different from the Qt Widgets project, so naturally the designer tool
    should also look different to suit its needs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自从本书第一章以来一直跟随所有示例项目的读者可能会意识到，Qt Quick Designer看起来与我们一直在使用的设计工具有些不同。这是因为Qt Quick项目与Qt
    Widgets项目非常不同，因此设计工具自然也应该有所不同以适应其需求。
- en: 'Let''s look at how the Qt Quick Designer looks in the Qt Quick project:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Qt Quick项目中的Qt Quick Designer是什么样子的：
- en: '![](img/a20022be-e9e5-4630-baa7-4c0b82b689c5.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a20022be-e9e5-4630-baa7-4c0b82b689c5.png)'
- en: 'Library: The Library window displays all the QML types available for the current
    project. You can click and drag it to the canvas window to add it to your UI.
    You can also create your own custom QML type and display it here.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库：库窗口显示当前项目可用的所有QML类型。您可以单击并将其拖动到画布窗口中以将其添加到您的UI中。您还可以创建自己的自定义QML类型并在此处显示。
- en: 'Resources: The Resources window displays all the resources in a list, which
    can then be used in your UI design.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源：资源窗口以列表形式显示所有资源，然后可以在UI设计中使用。
- en: 'Imports: The Imports window allows you to import different Qt Quick modules
    into your current project.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入：导入窗口允许您将不同的Qt Quick模块导入到当前项目中。
- en: 'Navigator: The Navigator window displays the items in the current QML file
    as a tree structure. It''s similar to the object operator window in the Qt Widgets
    Application project.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航器：导航器窗口以树形结构显示当前QML文件中的项目。它类似于Qt Widgets应用程序项目中的对象操作器窗口。
- en: 'Connections: The Connections window consists of several different tabs: Connections,
    Bindings, Properties, and Backends. These tabs allow you to add Connections (signal-and-slot),
    Bindings, and Properties to your QML file, without switching over to Edit mode.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接：连接窗口由几个不同的选项卡组成：连接、绑定、属性和后端。这些选项卡允许您在不切换到编辑模式的情况下向您的QML文件添加连接（信号和槽）、绑定和属性。
- en: 'State Pane: State pane displays the different states in the QML project that
    typically describe UI configurations, such as the UI controls, their properties
    and behavior, and available actions.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态窗格：状态窗格显示QML项目中的不同状态，通常描述UI配置，例如UI控件、它们的属性和行为以及可用操作。
- en: 'Canvas: Canvas is the working area where you design your application UI.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画布：画布是您设计应用程序UI的工作区。
- en: 'Properties Pane: Similar to the property editor we used in Qt Widgets Application
    projects, the Properties pane in the QML designer displays the properties of the
    selected item. You can immediately see the result in the UI after changing the
    values here.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性窗格：与我们在Qt Widgets应用程序项目中使用的属性编辑器类似，QML设计师中的属性窗格显示所选项目的属性。在更改这里的值后，您可以立即在UI中看到结果。
- en: Qt Quick layouts
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick布局
- en: 'Just like the Qt Widget applications, a layout system also exists in Qt Quick
    applications. The only difference is it''s called the Positioners in Qt Quick:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与Qt Widget应用程序一样，Qt Quick应用程序中也存在布局系统。唯一的区别是在Qt Quick中称为定位器：
- en: '![](img/ee431b85-661f-47d1-9709-8f4d7a64297b.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee431b85-661f-47d1-9709-8f4d7a64297b.png)'
- en: The most noticeable similarity is the Column and Row positioners. These two
    are exactly the same as the Vertical Layout and Horizontal Layout in Qt Widgets
    Application. Besides that, the Grid positioner is also the same as the Grid Layout.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的相似之处是列和行定位器。这两者与Qt Widgets应用程序中的垂直布局和水平布局完全相同。除此之外，网格定位器也与网格布局相同。
- en: The only extra thing in Qt Quick is the Flow positioner. The items contained
    within the Flow positioner arrange themselves like words on a page, with items
    arranged in lines along one axis, and lines of items placed next to each other
    along another axis.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick中唯一额外的是Flow定位器。Flow定位器中包含的项目会像页面上的单词一样排列，项目沿一个轴排成一行，然后沿另一个轴放置项目行。
- en: '![](img/931898a3-240c-472c-91f7-58409ec5cbc9.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/931898a3-240c-472c-91f7-58409ec5cbc9.png)'
- en: Basic QML scripting
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的QML脚本
- en: In the following section, we will learn how to create our very first Qt Quick
    application using Qt Quick Designer and QML!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习如何使用Qt Quick Designer和QML创建我们的第一个Qt Quick应用程序！
- en: Setting up the project
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: Without further ado, let's put our hands on QML and create a Qt Quick application
    ourselves! For this example project, we are going to create a dummy login screen
    using Qt Quick Designer and a QML script. First, let's open up Qt Creator and
    create a new project by going to File | New File or Project...
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们动手使用QML创建一个Qt Quick应用程序吧！在这个示例项目中，我们将使用Qt Quick Designer和一个QML脚本创建一个虚拟登录界面。首先，让我们打开Qt
    Creator，并通过转到文件|新建文件或项目...来创建一个新项目。
- en: 'After that, select Qt Quick Application and press Choose.... After that, press
    Next all the way until the project is created. We are just going to use all the
    default settings for this example project, including the Minimal required Qt version:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，选择Qt Quick应用程序并按“选择”....之后，一直按“下一步”直到项目创建完成。我们将在这个示例项目中使用所有默认设置，包括最小所需的Qt版本：
- en: '![](img/f61ed1c4-6c26-438d-a9d0-adfe3d663049.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f61ed1c4-6c26-438d-a9d0-adfe3d663049.png)'
- en: 'Once the project has been created, we need to add a few image files to our
    project, so that we can use them later:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建完成后，我们需要向项目中添加一些图像文件，以便稍后使用它们：
- en: '![](img/984d0ff3-798c-46fe-9d4c-5b9745e3590c.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/984d0ff3-798c-46fe-9d4c-5b9745e3590c.png)'
- en: 'You can get the source files (including these images) at our GitHub page: [http://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5](http://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的GitHub页面上获取源文件（包括这些图像）：[http://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5](http://github.com/PacktPublishing/Hands-On-GUI-Programming-with-C-QT5)
- en: 'We can add these images to our project by right-clicking on the `qml.qrc` file
    in the Project pane and selecting Open in Editor. Add a new prefix called `images`,
    and add all the image files into that prefix:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过右键单击项目窗格中的`qml.qrc`文件并选择在编辑器中打开来将这些图像添加到我们的项目中。添加一个名为`images`的新前缀，并将所有图像文件添加到该前缀中：
- en: '![](img/44cb6357-0d0f-4a8c-83c4-c8182c2cafbb.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44cb6357-0d0f-4a8c-83c4-c8182c2cafbb.png)'
- en: 'After that, open up `MainForm.ui.qml`, and delete everything in the QML file.
    We start all over by adding an Item type to the canvas, set its size to 400 x
    400, and call it the `loginForm`. After that, add an `Image` type underneath it,
    and call it `background`. We then apply the background image to the `Image` type,
    and the canvas now looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，打开`MainForm.ui.qml`，并删除QML文件中的所有内容。我们通过向画布添加一个Item类型，将其大小设置为400 x 400，并将其命名为`loginForm`来重新开始。之后，在其下方添加一个`Image`类型，并将其命名为`background`。然后将背景图像应用到`Image`类型上，画布现在看起来像这样：
- en: '![](img/885c2157-4e28-477d-8ccd-ebc2c3e669ec.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/885c2157-4e28-477d-8ccd-ebc2c3e669ec.png)'
- en: 'Then, add a `Rectangle` type under the `Image` type (background), and open
    up the Layout tab in the Properties pane. Enable both the vertical and horizontal
    anchor options. After that, set the `width` to `402`, the `height` to `210`, and
    the `vertical anchor margin` to `50`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Image`类型（背景）下添加一个`Rectangle`类型，并在属性窗格中打开布局选项卡。启用垂直和水平锚定选项。之后，将`width`设置为`402`，`height`设置为`210`，将`vertical
    anchor margin`设置为`50`：
- en: '![](img/4b63ff3b-64b7-4cf3-919d-de2c5407db44.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b63ff3b-64b7-4cf3-919d-de2c5407db44.png)'
- en: 'Following that, we set the rectangle''s color to `#fcf9f4` and border color
    to `#efedeb`, then set the border value to `1`. The user interface so far looks
    something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们将矩形的颜色设置为`#fcf9f4`，边框颜色设置为`#efedeb`，然后将边框值设置为`1`。到目前为止，用户界面看起来像这样：
- en: '![](img/2046715a-edfc-44b7-bd96-490ea0da78b6.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2046715a-edfc-44b7-bd96-490ea0da78b6.png)'
- en: 'Next, add an Image QML type under the rectangle, and set its anchor settings
    to top anchor and horizontal anchor. We then set its top anchor margin to `-110`
    and apply the logo image to its `image source` property. You can turn the QML
    type''s bounding rectangle and stripes on and off by clicking on the little button
    located on top of your canvas, so that it''s easier to look at the result, especially
    when your canvas is full of stuff:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在矩形下添加一个Image QML类型，并将其锚定设置为顶部锚定和水平锚定。然后将其顶部锚定边距设置为`-110`，并将logo图像应用到其`image
    source`属性上。您可以通过单击位于画布顶部的小按钮来打开和关闭QML类型的边界矩形和条纹，这样在画布上充满内容时更容易查看结果：
- en: '![](img/fd8bc259-88d1-458d-bcae-9d0aa18e09ab.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd8bc259-88d1-458d-bcae-9d0aa18e09ab.png)'
- en: 'Then, we add three `Rectangle` types to the canvas under the `loginRect` rectangle,
    and call them `emailRect`, `passwordRect`, and `loginButton`. The anchor settings
    for the rectangles are shown as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`loginRect`矩形下的画布中添加了三个`Rectangle`类型，并将它们命名为`emailRect`、`passwordRect`和`loginButton`。矩形的锚定设置如下所示：
- en: '![](img/b5ff6a01-25f6-4081-92bb-6e0607e3bf95.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5ff6a01-25f6-4081-92bb-6e0607e3bf95.png)'
- en: 'Then, we set the `border` value of both the `emailRect` and `passwordRect` to
    `1`, the `color` to `#ffffff` and the `bordercolor` to `#efedeb`. As for the `loginButton`,
    we set the `border` to `0`, the `radius` to `2` and the `color` to `#27ae61`.
    The login screen now looks like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`emailRect`和`passwordRect`的`border`值设置为`1`，`color`设置为`#ffffff`，`bordercolor`设置为`#efedeb`。至于`loginButton`，我们将`border`设置为`0`，`radius`设置为`2`，`color`设置为`#27ae61`。登录屏幕现在看起来像这样：
- en: '![](img/d5578076-0799-402b-a013-554a56330e25.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5578076-0799-402b-a013-554a56330e25.png)'
- en: 'Looks good so far. Next, we''re going to add a `TextInput`, `Image`, `MouseArea`,
    and a `Text` QML type to both the `emailRect` and the `passwordRect`. Since there
    are many QML types here, I will list the properties that need to be set:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。接下来，我们将在`emailRect`和`passwordRect`中添加`TextInput`、`Image`、`MouseArea`和`Text`
    QML类型。由于这里有许多QML类型，我将列出需要设置的属性：
- en: 'TextInput:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TextInput：
- en: Selection color set to `#4f0080`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择颜色设置为`#4f0080`
- en: Enable left anchor, right anchor, and vertical anchor
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用左锚点、右锚点和垂直锚点
- en: Left anchor margin `20`, right anchor margin `40` and vertical margin 3
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左锚点边距`20`，右锚点边距`40`，垂直边距`3`
- en: Set echoMode to Password for password input only
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为密码输入设置echoMode为Password
- en: 'Image:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Image：
- en: Enable right anchor and vertical anchor
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用右锚点和垂直锚点
- en: Right anchor margin set to `10`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右锚点边距设置为`10`
- en: Set image source to email icon or password icon respectively
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像源设置为电子邮件图标或密码图标
- en: Set image fill mode to PreserveAspectFit
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像填充模式设置为PreserveAspectFit
- en: 'MouseArea:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MouseArea：
- en: Enable fill parent item
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用填充父项
- en: 'Text:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Text：
- en: Set the text property to `E-Mail` and `Password` respectively
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本属性分别设置为`E-Mail`和`Password`
- en: Text color set to `#cbbdbd`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本颜色设置为`#cbbdbd`
- en: Text alignment set to Left and Top
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本对齐设置为左对齐和顶部对齐
- en: Enable left anchor, right anchor, and vertical anchor
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用左锚点、右锚点和垂直锚点
- en: Left anchor margin `20`, right anchor margin `40`, and vertical margin -1
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左锚点边距`20`，右锚点边距`40`，垂直边距`-1`
- en: Once you're done, add a `MouseArea` and `Text` to the `loginButton` as well.
    Enable `fill parent item` for the `MouseArea`, and enable both `vertical` and
    `horizontal anchors` for the `Text` QML type. Then, set its `text` property to
    `LOGIN`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，还要为`loginButton`添加`MouseArea`和`Text`。为`MouseArea`启用`fill parent item`，为`Text`
    QML类型启用`vertical`和`horizontal anchors`。然后，将其`text`属性设置为`LOGIN`。
- en: You don't have to follow all my steps by 100%, they are just a guideline for
    you to achieve a similar result as the screenshot above. However, it's better
    for you to apply your own design and create something unique!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必完全按照我的步骤进行，它们只是指导您实现与上面截图类似的结果的指南。但是，最好您应用自己的设计并创建独特的东西！
- en: 'Phew! After the long process above, our login screen should now look something
    like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！经过上面漫长的过程，我们的登录屏幕现在应该看起来像这样：
- en: '![](img/b17e64f5-faef-47a9-abd5-88669f766d47.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b17e64f5-faef-47a9-abd5-88669f766d47.png)'
- en: 'One last thing we need to do before moving on to `main.qml` is to expose some
    of the QML types in our login screen, so that we can link it to our `main.qml`
    file for logic programming. We can, in fact, do this directly on the designer
    tool. All you need to do is to click on the small rectangle icon located next
    to the object name, and make sure the three lines on the icon are penetrating
    the rectangular box, like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在转到`main.qml`之前，我们还需要做一件事，那就是公开我们登录屏幕中的一些QML类型，以便我们可以将其链接到我们的`main.qml`文件进行逻辑编程。实际上，我们可以直接在设计工具上做到这一点。您只需点击对象名称旁边的小矩形图标，并确保图标上的三条线穿过矩形框，就像这样：
- en: '![](img/882dcceb-99d9-4358-9e59-a444ab53d9d3.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/882dcceb-99d9-4358-9e59-a444ab53d9d3.png)'
- en: The QML types that we need to expose/export are `emailInput` (TextInput), `emailTouch`
    (MouseArea), `emailDisplay` (Text), `passwordInput` (TextInput), `passwordTouch`
    (MouseArea), `passwordDisplay` (Text), and `loginMouseArea` (MouseArea). Once
    you have done all that, let's open up `main.qml`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要公开/导出的QML类型是`emailInput`（TextInput）、`emailTouch`（MouseArea）、`emailDisplay`（Text）、`passwordInput`（TextInput）、`passwordTouch`（MouseArea）、`passwordDisplay`（Text）和`loginMouseArea`（MouseArea）。完成所有这些后，让我们打开`main.qml`。
- en: 'At first, our `main.qml` should look something like this, which will just open
    an empty window:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的`main.qml`应该看起来像这样，它只会打开一个空窗口：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, add in the `MainForm` object, and set its anchor setting to `anchors.fill:
    parent`. Then, print out a line of text, `Login pressed`, on the console window
    when the `loginButton` is clicked (or touched, if running on the touch device):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '之后，添加`MainForm`对象，并将其锚点设置为`anchors.fill: parent`。然后，当点击（或触摸，如果在触摸设备上运行）`loginButton`时，在控制台窗口上打印一行文本“Login
    pressed”：'
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After that, we are going to program the behavior when the `MouseArea` on the
    email input is clicked/touched. Since we are manually creating our own text field,
    instead of using the `TextField` QML type provided by the `QtQuick.Controls` module,
    we must manually hide and show the `E-Mail` and `Password` text displays, as well
    as changing the input focus when the user  clicks/touches down on the `MouseArea`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将编写`MouseArea`在电子邮件输入上被点击/触摸时的行为。由于我们手动创建自己的文本字段，而不是使用`QtQuick.Controls`模块提供的`TextField`
    QML类型，我们必须手动隐藏和显示`E-Mail`和`Password`文本显示，并在用户点击/触摸`MouseArea`时更改输入焦点。
- en: 'The reason why I chose not to use the `TextField` type is that I can hardly
    customize the `TextField''s` visual presentation, so why don''t I create my own?
    The code for doing manual focus for the email input looks like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择不使用`TextField`类型的原因是，我几乎无法自定义`TextField`的视觉呈现，那么为什么不创建自己的呢？手动为电子邮件输入设置焦点的代码如下：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After that, do the same for the password field:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，对密码字段执行相同操作：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That''s it; we''re done! You can now compile and run the program. You should
    get something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们完成了！现在您可以编译和运行程序。您应该会得到类似这样的结果：
- en: '![](img/e4f5430c-1afb-4481-842b-fa0dcb61ffea.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4f5430c-1afb-4481-842b-fa0dcb61ffea.png)'
- en: If you're not seeing the images, and are getting error messages that say Qt
    is unable to open the images, please go back to your `MainForm.ui.qml` and add
    in the prefix `image/` to the front of the source property. This is because Qt
    Quick Designer loads the images without the prefix, while your final program needs
    the prefix. After you have added the prefix, you may realize you no longer see
    the images getting displayed on Qt Quick Designer, but it will work just fine
    in your final program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到图片，并且收到错误消息说Qt无法打开图片，请返回到您的`MainForm.ui.qml`，并在源属性的前面添加前缀`image/`。这是因为Qt
    Quick Designer加载图片时没有前缀，而您的最终程序需要前缀。添加了前缀后，您可能会意识到在Qt Quick Designer中不再看到图片显示，但在最终程序中将正常工作。
- en: I'm not sure if this is a bug or if they intended it like that. Hopefully, Qt's
    developers can get it fixed, and we won't have to do that extra step anymore.
    That's it; hopefully, you have understood the similarities and differences between
    Qt Widgets Application and Qt Quick Application. You can now pick the best option
    from the two to fit your project's needs!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定这是一个错误还是他们有意这样做的。希望Qt的开发人员可以解决这个问题，这样我们就不必再做额外的步骤了。就是这样，希望您已经理解了Qt Widgets应用程序和Qt
    Quick应用程序之间的相似之处和不同之处。现在您可以从这两者中选择最适合您项目需求的选项了！
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned what Qt Quick is and how to create a program
    using the QML language. In the following chapter, we are going to learn how to
    export our Qt project to different platforms without much hassle. Let's go!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Qt Quick是什么，以及如何使用QML语言创建程序。在接下来的章节中，我们将学习如何将我们的Qt项目轻松导出到不同的平台。让我们开始吧！
