- en: Project Structure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'In this chapter, we will create a new multiproject solution that will be the
    foundation of our example application. We will apply a Model View Controller pattern,
    separating the user interface and business logic. We will also introduce Qt’s
    unit testing framework—QtTest—and demonstrate how to integrate it into our solution.
    We will cover these things in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个新的多项目解决方案，这将是我们示例应用程序的基础。我们将应用模型视图控制器模式，将用户界面和业务逻辑分离。我们还将介绍Qt的单元测试框架—QtTest，并演示如何将其集成到我们的解决方案中。我们将在本章中涵盖以下内容：
- en: Projects, MVC, and unit testing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目、MVC和单元测试
- en: Creating a library project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建库项目
- en: Creating a unit tests project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单元测试项目
- en: Creating a user interface project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户界面项目
- en: Mastering MVC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握MVC
- en: The QObject base class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QObject基类
- en: QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML
- en: Controlling project output
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制项目输出
- en: Projects, MVC, and unit testing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目、MVC和单元测试
- en: The scratchpad application we built in the previous chapter is a Qt project,
    represented by a `.pro` file. In a business environment, technical solutions are
    generally developed as part of company initiatives, and these initiatives are
    generally also called **projects**. To try and minimize confusion (and the number
    of times the word project appears!), we’ll use project to mean a Qt project defined
    by a `.pro` file and the word initiative to refer to projects in the business
    sense.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中构建的草稿应用是一个Qt项目，由一个`.pro`文件表示。在商业环境中，技术解决方案通常作为公司倡议的一部分开发，这些倡议通常也被称为**项目**。为了尽量减少混淆（和项目出现的次数！），我们将使用项目来表示由`.pro`文件定义的Qt项目，倡议一词用来指代商业意义上的项目。
- en: The initiative we will work on will be a generic client management system. It
    will be something that can be tweaked and re purposed for multiple applications—for
    a supplier managing customers, a health service managing patients, and so on.
    It will perform common tasks found over and over in real-world **Line of Business**
    (**LOB**) applications, principally adding, editing, and deleting data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开展的倡议是一个通用的客户管理系统。它将是一个可以调整和重新用于多个应用程序的东西—供应商管理客户、卫生服务管理患者等。它将执行现实世界**业务线**（**LOB**）应用程序中一遍又一遍发现的常见任务，主要是添加、编辑和删除数据。
- en: Our scratchpad application is entirely encapsulated within a single project.
    For smaller applications, this is perfectly viable. However, with larger code
    bases, particularly with several developers involved, it often pays to break things
    up into more manageable pieces.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的草稿应用完全封装在一个项目中。对于较小的应用程序，这是完全可行的。然而，对于较大的代码库，特别是涉及多个开发人员的情况，通常最好将事情分解成更易管理的部分。
- en: 'We will be using a super lightweight implementation of the **Model View Controller**
    (**MVC**) architectural pattern. If you haven’t come across MVC before, it is
    primarily used to decouple business logic from the user interface. The user interface
    (View) relays commands to a switchboard style class (Controller) to retrieve the
    data and perform actions it needs. The controller in turn delegates the responsibility
    for the data, logic, and rules to data objects (Models):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用超轻量级的**模型视图控制**（**MVC**）架构模式的实现。如果你之前没有接触过MVC，它主要用于将业务逻辑与用户界面解耦。用户界面（视图）向一个类似于交换机的类（控制器）传达命令，以检索数据并执行所需的操作。控制器反过来将数据、逻辑和规则的责任委托给数据对象（模型）：
- en: '![](img/39853104-b5e4-4dc3-985b-febae3c11f56.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39853104-b5e4-4dc3-985b-febae3c11f56.png)'
- en: The key is that the **View** knows about the **Controller** and the **Model**,
    as it needs to send commands to the **Controller** and display the data held in
    the **Model**. The **Controller** knows about the **Model** as it needs to delegate
    work to it, but it doesn’t know about the **View**. The Model knows nothing about
    either the **Controller** or the **View**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是**视图**知道**控制器**和**模型**，因为它需要向**控制器**发送命令并显示**模型**中保存的数据。**控制器**知道**模型**，因为它需要将工作委托给它，但它不知道**视图**。模型对**控制器**或**视图**一无所知。
- en: A key benefit of designing the application this way in a business environment
    is that dedicated UX specialists can work on the views while programmers work
    on the business logic. A secondary boon is that because the business logic layer
    knows nothing about the UI, you add, edit, and even totally replace user interfaces
    without affecting the logic layer. A great use case would be to have a “full fat”
    UI for a desktop application and a companion “half fat” UI for a mobile device,
    both of which can use the same business logic. With all this in mind, we will
    physically segregate our UI and business logic into separate projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中以这种方式设计应用程序的一个关键好处是，专门的用户体验专家可以在视图上工作，而程序员可以在业务逻辑上工作。第二个好处是，因为业务逻辑层对UI一无所知，所以你可以添加、编辑，甚至完全替换用户界面而不影响逻辑层。一个很好的用例是为桌面应用程序拥有“全功能”UI，为移动设备拥有一个伴侣“半功能”UI，两者都可以使用相同的业务逻辑。考虑到所有这些，我们将把我们的UI和业务逻辑物理上分开成两个项目。
- en: We will also look at integrating automated unit tests into our solution. Unit
    testing and **Test Driven Development** (**TDD**) has really grown in popularity
    in recent times and when developing applications in a business environment, you
    will more than likely be expected to write unit tests alongside your code. If
    not, you should really propose doing it as it holds a lot of value. Don’t worry
    if you haven’t done any unit testing before; it’s very straightforward, and we’ll
    discuss it in more detail later in the book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究如何将自动化单元测试集成到我们的解决方案中。单元测试和**测试驱动开发**（**TDD**）在最近变得非常流行，当在商业环境中开发应用程序时，你很可能会被要求在编写代码时编写单元测试。如果没有，你应该提议这样做，因为它具有很大的价值。如果你以前没有进行过单元测试，不要担心；它非常简单，我们将在本书的后面更详细地讨论它。
- en: 'Finally, we need a way to aggregate these subprojects together so that we don’t
    have to open them individually. We will achieve this with an umbrella solution
    project that does nothing other than tying the other projects together. This is
    how we will lay out our projects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种方法来将这些子项目聚合在一起，以便我们不必单独打开它们。我们将通过一个伞解决方案项目来实现这一点，该项目除了将其他项目绑在一起外，什么也不做。这就是我们将布置我们的项目的方式：
- en: '![](img/83ae32f5-c0eb-43b2-8d40-d977d7fb3a9c.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83ae32f5-c0eb-43b2-8d40-d977d7fb3a9c.png)'
- en: Project creation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目创建
- en: In the previous chapter, we saw how easy it is to set up a new project just
    by creating a few text files. However, we’ll create our new solution using Qt
    Creator.  We will use the new project wizard to guide us through creating a top-level
    solution and a single subproject.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了通过创建一些文本文件来设置新项目是多么容易。但是，我们将使用Qt Creator创建我们的新解决方案。我们将使用新项目向导来引导我们创建一个顶级解决方案和一个单个子项目。
- en: 'From the top menu, select File > New File or Project and then Projects > Other
    Project > Subdirs Project and click on Choose…:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部菜单中，选择文件>新文件或项目，然后选择项目>其他项目>Subdirs项目，然后单击“选择...”：
- en: '![](img/ab5a4f70-f441-44b3-bcc1-118ee4ccb301.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab5a4f70-f441-44b3-bcc1-118ee4ccb301.png)'
- en: 'Subdirs Project is the template we need for our top-level solution project.
    Give it the name `cm` and create it in our `qt` projects folder:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Subdirs Project是我们需要的顶级解决方案项目的模板。将其命名为`cm`，并在我们的`qt`项目文件夹中创建：
- en: '![](img/466aba05-c61f-436c-82d6-203ad4fe6731.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/466aba05-c61f-436c-82d6-203ad4fe6731.png)'
- en: 'On the Kit Selection pane, check the Desktop Qt 5.10.0 MinGW 32bit kit we installed.
    Feel free to select additional kits you want to try out if you have them installed,
    but it’s not necessary. Click on Next:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kit Selection窗格中，选中我们安装的Desktop Qt 5.10.0 MinGW 32位套件。如果您已安装其他套件，可以随意选择要尝试的其他套件，但这并非必需。然后单击“下一步”：
- en: '![](img/16fccb2b-40e0-484c-a43a-7e926efe6c68.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16fccb2b-40e0-484c-a43a-7e926efe6c68.png)'
- en: 'As discussed, version control is beyond the scope of this book, so in the Project
    Management pane, select None from the Add to version control dropdown. Click on Finish
    & Add Subproject:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，版本控制超出了本书的范围，因此在项目管理窗格中，从“添加到版本控制”下拉菜单中选择“无”。然后单击“完成并添加子项目”：
- en: '![](img/04cabdf6-7274-4e07-a775-ee9320205a4a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04cabdf6-7274-4e07-a775-ee9320205a4a.png)'
- en: 'We’ll add the user interface project as the first subproject. The wizard follows
    more or less the same pattern as the steps we''ve just followed, so perform the
    following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把用户界面项目作为第一个子项目添加。向导遵循的步骤与我们刚刚遵循的步骤更多或更少相同，因此执行以下操作：
- en: Select Projects > Application > Qt Quick Application - Empty and click on Choose...
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择项目>应用程序>Qt Quick应用程序-空，并单击“选择...”
- en: In the Project Location dialog, give it the name `cm-ui` (for Client Management
    - User Interface), leave the location as our new `cm` folder, and click on Next.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目位置对话框中，将其命名为`cm-ui`（用于客户端管理-用户界面），将位置保留为我们的新`cm`文件夹，然后单击“下一步”。
- en: In the Define Build System dialog, select the build system qmake and click on Next.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义构建系统对话框中，选择构建系统qmake，然后单击“下一步”。
- en: In the Define Project Details dialog, leave the default minimal Qt version of
    QT 5.9 and the Use Qt Virtual Keyboard box unchecked then click on Next.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义项目详细信息对话框中，保留默认的最小Qt版本QT 5.9和未选中使用Qt虚拟键盘框，然后单击“下一步”。
- en: In the Kit Selection dialog, pick the Desktop Qt 5.10.0 MinGW 32bit kit plus
    any other kits you wish to try and click on Next.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kit Selection对话框中，选择桌面Qt 5.10.0 MinGW 32位套件以及您希望尝试的其他套件，然后单击“下一步”。
- en: Finally, in the Project Management dialog, skip version control (leave it as
    <None>) and click on Finish.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在项目管理对话框中，跳过版本控制（将其保留为<无>）并单击“完成”。
- en: 'Our top-level solution and UI projects are now up and running, so let’s add
    the other subprojects. Add the business logic project next, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶级解决方案和UI项目现在已经启动，所以让我们按照以下步骤添加其他子项目。接下来添加业务逻辑项目，如下所示：
- en: In the Projects pane, right-click on the top-level `cm` folder and select New
    Subproject….
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“项目”窗格中，右键单击顶级`cm`文件夹，然后选择“新建子项目...”。
- en: Select Projects > Library > C++ Library and click on Choose....
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择项目>库> C++库，并单击“选择...”。
- en: In the Introduction and Project Location dialog, pick Shared Library as the
    Type, name it `cm-lib`, create it in `<Qt Projects>/cm`, and then click on Next.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在介绍和项目位置对话框中，选择共享库作为类型，将其命名为`cm-lib`，在`<Qt Projects>/cm`中创建它，然后单击“下一步”。
- en: In the Select Required Modules dialog, just accept the default of QtCore and
    click on Next.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择所需模块对话框中，只接受QtCore的默认设置，然后单击“下一步”。
- en: In the **Class Information** dialog, we get the opportunity to create a new
    class to get us started. Give the class name `Client`, with the `client.h` header
    file and the `client.cpp` source file, and then click on Next.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类信息**对话框中，我们有机会创建一个新类来帮助我们入门。给出类名`Client`，使用`client.h`头文件和`client.cpp`源文件，然后单击“下一步”。
- en: Finally, in the Project Management dialog, skip version control (leave it as
    <None>) and click on Finish.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在项目管理对话框中，跳过版本控制（将其保留为<无>）并单击“完成”。
- en: 'Finally, we will repeat the process to create our unit testing project:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将重复这个过程来创建我们的单元测试项目：
- en: New Subproject....
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新子项目....
- en: Projects > Other Project > Qt Unit Test.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目>其他项目>Qt单元测试。
- en: Project name `cm-tests`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目名称`cm-tests`。
- en: Include QtCore and QtTest.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括QtCore和QtTest。
- en: Create the `ClientTests` test class with the `testCase1` test slot and the `client-tests.cpp` filename. Set
    the Type as Test and check Generate initialization and cleanup code.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ClientTests`测试类，其中包括`testCase1`测试槽和`client-tests.cpp`文件名。将类型设置为测试，并检查生成初始化和清理代码。
- en: Skip version control and Finish.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过版本控制并完成。
- en: 'That was a lot of dialog boxes to get through, but we’ve now got our skeleton
    solution in place. Your project folders should look as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚经历了很多对话框，但现在我们已经将骨架解决方案放置好了。您的项目文件夹应该如下所示：
- en: '![](img/6a2a887e-58db-4347-8bf2-67aefbd91625.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a2a887e-58db-4347-8bf2-67aefbd91625.png)'
- en: We’ll now take a look at each project in turn and make some tweaks before we
    start adding our content.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们依次查看每个项目，并在开始添加内容之前进行一些调整。
- en: cm-lib
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cm-lib
- en: First off, head to file explorer and create a new subfolder underneath `cm-lib`
    called `source`; move `cm-lib_global.h` there. Create another subfolder in `source`
    called `models` and move both the `Client` class files there.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前往文件资源管理器，在`cm-lib`下创建一个名为`source`的新子文件夹；将`cm-lib_global.h`移动到其中。在`source`中创建另一个名为`models`的子文件夹，并将`Client`类文件都移动到其中。
- en: 'Next, back in Qt Creator, open up `cm-lib.pro` and edit it as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在Qt Creator中，打开`cm-lib.pro`并编辑如下：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As this is a library project, we do not need to load the default GUI module,
    so we exclude it using the `QT` variable. The `TARGET` variable is the name we
    wish to give our binary output (for example, `cm-lib.dll`). It is optional and
    will default to the project name if not provided, but we’ll be explicit. Next,
    rather than having a `TEMPLATE` of app as we saw in our scratchpad application,
    this time we use `lib` to give us a library. We add c++14 features via the `CONFIG`
    variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个库项目，我们不需要加载默认的GUI模块，因此我们使用`QT`变量将其排除。`TARGET`变量是我们希望给我们的二进制输出的名称（例如`cm-lib.dll`）。这是可选的，如果未提供，将默认为项目名称，但我们将明确指定。接下来，与我们在草稿应用程序中看到的`app`模板不同，这次我们使用`lib`来创建一个库。我们通过`CONFIG`变量添加了c++14特性。
- en: The `cm-lib_global.h` file is a helpful little bit of preprocessor boilerplate
    we can use to export our shared library symbols, and you’ll see that put to use
    soon. We use the `CMLIB_LIBRARY` flag in the `DEFINES` variable to trigger this
    export.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`cm-lib_global.h`文件是一个有用的预处理器样板，我们可以用它来导出我们的共享库符号，您很快就会看到它的用途。我们在`DEFINES`变量中使用`CMLIB_LIBRARY`标志来触发此导出。'
- en: Finally, we have slightly rewritten the `SOURCES` and `HEADERS` variable lists
    to account for the new file locations after we moved things around a bit, and
    we add the source folder (which is where all of our code will live) to the `INCLUDEPATH`
    so that the path is searched when we use `#include` statements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们稍微重写了`SOURCES`和`HEADERS`变量列表，以考虑在我们移动了一些东西之后的新文件位置，并且我们将源文件夹（这是我们所有代码的所在地）添加到`INCLUDEPATH`中，这样当我们使用`#include`语句时就可以搜索到路径。
- en: Right-click on the `cm-lib` folder in the Projects pane and select Run qmake.
    When that has finished, right-click again and select **Rebuild**. Everything should
    be green and happy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗格中右键单击`cm-lib`文件夹，选择运行qmake。完成后，再次右键单击并选择**重新构建**。一切应该都是绿色和愉快的。
- en: cm-tests
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cm-tests
- en: 'Create new `source/models` subfolders and move `client-tests.cpp` there. Switch
    back to Qt Creator and edit `cm-tests.pro`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的`source/models`子文件夹，并将`client-tests.cpp`移动到那里。切换回Qt Creator并编辑`cm-tests.pro`：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This follows pretty much the same approach as with `cm-lib`, with the exception
    that we want a console app rather than a library. We don’t need the GUI module,
    but we will add the `testlib` module to get access to the Qt Test features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与`cm-lib`的方法相同，唯一的区别是我们想要一个控制台应用程序而不是一个库。我们不需要GUI模块，但我们将添加`testlib`模块以获取Qt测试功能的访问权限。
- en: There really isn’t much to this subproject just yet, but you should be able
    to run qmake and rebuild successfully.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个子项目还没有太多内容，但您应该能够成功运行qmake并重新构建。
- en: cm-ui
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cm-ui
- en: 'Create two subfolders this time: `source` and `views`. Move `main.cpp` into
    `source` and `main.qml` into `views`. Rename `qml.qrc` as `views.qrc` and edit
    `cm-ui.pro`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这次创建两个子文件夹：`source`和`views`。将`main.cpp`移动到`source`中，将`main.qml`移动到`views`中。将`qml.qrc`重命名为`views.qrc`，并编辑`cm-ui.pro`：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our UI is written in QML, which requires the `qml` and `quick` modules, so we
    add those. We edit the `RESOURCES` variable to pick up our renamed resource file
    and also edit the `QML_IMPORT_PATH` variable, which we will cover in detail when
    we get into custom QML modules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的UI是用QML编写的，需要`qml`和`quick`模块，所以我们添加了这些。我们编辑`RESOURCES`变量以获取我们重命名的资源文件，并编辑`QML_IMPORT_PATH`变量，我们将在进入自定义QML模块时详细介绍。
- en: 'Next, edit `views.qrc` to account for the fact that we have moved the `main.qml`
    file into the `views` folder.  Remember to right-click and Open With > Plain Text
    Editor:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`views.qrc`以考虑我们已将`main.qml`文件移动到`views`文件夹中。记得右键单击并选择“使用其他应用程序打开”>“纯文本编辑器”：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we also need to edit a line in `main.cpp` to account for the file
    move:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要编辑`main.cpp`中的一行以考虑文件移动：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should now be able to run qmake and rebuild the `cm-ui` project. Before
    we run it, let’s take a quick look at the build configuration button now that
    we have multiple projects open:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够运行qmake并重新构建`cm-ui`项目。在运行之前，让我们快速看一下构建配置按钮，因为现在我们有多个项目打开了：
- en: '![](img/dff629a5-d049-416c-a917-5f3dccd1f080.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dff629a5-d049-416c-a917-5f3dccd1f080.png)'
- en: 'Note that now, along with the Kit and Build options, we must also select the
    executable we wish to run. Ensure that `cm-ui` is selected and then run the application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在除了工具链和构建选项之外，我们还必须选择要运行的可执行文件。确保选择了`cm-ui`，然后运行应用程序：
- en: '![](img/c87febe8-c33b-44c7-bafc-7e60d634a23e.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c87febe8-c33b-44c7-bafc-7e60d634a23e.png)'
- en: Hello World indeed. It's fairly uninspiring stuff, but we have a multiproject
    solution building and running happily, which is a great start. Close the application
    when you simply can’t take any more fun!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确实是世界你好。这是相当令人失望的东西，但我们已经成功地构建和运行了一个多项目解决方案，这是一个很好的开始。当您无法再忍受更多乐趣时，请关闭应用程序！
- en: Mastering MVC
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC的掌握
- en: Now that our solution structure is in place, we’ll get started on the MVC implementation.
    As you’ll see, it is very minimal and incredibly easy to set up.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的解决方案结构已经就位，我们将开始MVC实现。正如您将看到的那样，它非常简单，非常容易设置。
- en: 'First, expand `cm-ui > Resources > views.qrc > / > views`, right-click on `main.qml`,
    select Rename, and rename the file as `MasterView.qml`. If you get a message about
    project editing, just select Yes to continue anyway:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，展开`cm-ui > Resources > views.qrc > / > views`，右键单击`main.qml`，选择重命名，将文件重命名为`MasterView.qml`。如果收到有关项目编辑的消息，请选择“是”以继续：
- en: '![](img/e30af2b8-81b4-4c6f-9ac3-df51ea1e6ecc.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e30af2b8-81b4-4c6f-9ac3-df51ea1e6ecc.png)'
- en: If you do get the error message, the file will still appear as `main.qml` in
    the Projects pane, but the file will have been renamed in the filesystem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到错误消息，文件仍将在项目窗格中显示为`main.qml`，但文件在文件系统中已被重命名。
- en: 'Next, edit `views.qrc` (right-click on it and select Open With > Plain Text
    Editor). Replace the content as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`views.qrc`（右键单击它，然后选择使用纯文本编辑器打开）。将内容替换为以下内容：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you recall how we load this QML file in `main.cpp`, the syntax is `qrc:<prefix><filename>`.
    We previously had a `/` prefix and a `views/main.qml` relative filename. This
    gave us `qrc:/views/main.qml`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我们如何在`main.cpp`中加载这个QML文件，语法是`qrc:<prefix><filename>`。我们以前有一个`/`前缀和一个`views/main.qml`相对文件名。这给了我们`qrc:/views/main.qml`。
- en: A prefix of `/` isn’t terribly descriptive. As you add more and more QML files,
    it’s really helpful to organize them into blocks with meaningful prefixes. Having
    unstructured resource blocks also makes the Projects pane ugly and more difficult
    to navigate, as you just saw when you had to drill down through `views.qrc > /
    > views`. So, the first step is to rename the prefix from `/` to `/views`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`/`的前缀并不是非常描述性的。随着您添加更多的QML文件，将它们组织成具有有意义前缀的块会非常有帮助。拥有无结构的资源块也会使项目面板变得混乱，导航起来更加困难，就像您刚才在`views.qrc
    > / > views`中看到的那样。因此，第一步是将前缀从`/`重命名为`/views`。'
- en: However, with a prefix of `/views` and a relative filename of `views/main.qml`,
    our URL is now `qrc:/views/views/main.qml`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`/views`作为前缀和`views/main.qml`作为相对文件名，我们的URL现在是`qrc:/views/views/main.qml`。
- en: This is worse than it was before, and we still have a deep folder structure
    in `views.qrc`. Fortunately, we can add an *alias* for our file to make both of
    these problems go away. You can use the alias of a resource in place of the relative
    path, so if we assign an alias of `main.qml`, we can replace `views/main.qml`
    with simply `main.qml`, giving us `qrc:/views/main.qml`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以前更糟糕了，在`views.qrc`中我们仍然有一个深层的文件夹结构。幸运的是，我们可以为我们的文件添加一个*别名*来解决这两个问题。您可以使用资源的别名来代替相对路径，因此如果我们分配一个`main.qml`的别名，我们可以用`main.qml`来替换`views/main.qml`，得到`qrc:/views/main.qml`。
- en: That’s concise and descriptive, and our Projects pane is neater too.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是简洁和描述性的，我们的项目面板也更整洁了。
- en: So, going back to our updated version of `views.qrc`, we have simply updated
    the name of the file from `main.qml` to `MasterView.qml`, consistent with the
    file rename we performed, and we have also provided a shortcut alias, so we don't
    have to specify views twice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到我们更新后的`views.qrc`版本，我们只是将文件名从`main.qml`更新为`MasterView.qml`，与我们执行的文件重命名一致，并且我们还提供了一个快捷别名，这样我们就不必两次指定views。
- en: 'We now need to update our code in `main.cpp` to reflect these changes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更新`main.cpp`中的代码以反映这些更改：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should be able to run qmake, and build and run to verify that nothing has
    broken.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够运行qmake，并构建和运行以验证没有出现问题。
- en: 'Next, we’ll create a `MasterController` class, so right-click on the `cm-lib`
    project and select Add New… > C++ > C++ Class > Choose…:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`MasterController`类，因此右键单击`cm-lib`项目，然后选择添加新内容… > C++ > C++类 > 选择…：
- en: '![](img/2b36133d-dd2e-4811-9167-1b302283441b.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b36133d-dd2e-4811-9167-1b302283441b.png)'
- en: Use the Browse… button to create the `source/controllers` subfolder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“浏览…”按钮创建`source/controllers`子文件夹。
- en: By selecting QObject as the base class and including it, Qt Creator will write
    some of the boilerplate code for us. You can always add it yourself later, so
    don’t feel like it’s a necessary part of creating a new class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择QObject作为基类并包含它，Qt Creator将为我们编写一些样板代码。您随后可以自己添加它，所以不要觉得这是创建新类的必要部分。
- en: Once you’ve skipped version control and created the class, declare and define
    it as follows. Our `MasterController` doesn’t do anything particularly exciting
    just yet, we’re just doing the groundwork.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您跳过了版本控制并创建了类，声明和定义如下。我们的`MasterController`目前还没有做任何特别激动人心的事情，我们只是在做基础工作。
- en: 'Here''s `master-controller.h`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`master-controller.h`：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All we’ve really added to the default implementation Qt Creator gave us is the `CMLIBSHARED_EXPORT` macro
    Qt Creator wrote for us in `cm-lib_global.h` to take care of our shared library
    exports, and to put the class inside a namespace.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正添加到Qt Creator默认实现的只是`CMLIBSHARED_EXPORT`宏，Qt Creator在`cm-lib_global.h`中为我们编写的，以处理我们的共享库导出，并将类放在一个命名空间中。
- en: I always have the project name as a root namespace and then additional namespaces
    that reflect the physical location of the class files within the source directory,
    so in this case, I use `cm::controllers`, as the class is located in the directory `source/controllers`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是将项目名称作为根命名空间，然后是反映源目录中类文件物理位置的其他命名空间，所以在这种情况下，我使用`cm::controllers`，因为该类位于`source/controllers`目录中。
- en: 'This is `master-controller.cpp`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`master-controller.cpp`：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I use a slightly unorthodox style in the implementation file—most people just
    add `using namespace cm::controllers;` at the top of the `.cpp` file. I often
    like to put the code within the scope of namespaces because it becomes collapsible
    in the IDE. By repeating the innermost namespace scope (*controllers* in this
    example), you can break your code up into collapsible regions much like you can
    in C#, which helps with navigation in larger files, as you can collapse the sections
    you’re not interested in. It makes no functional difference, so use whichever
    style you prefer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现文件中，我使用了一个略微不正统的风格——大多数人只是在`.cpp`文件的顶部添加`using namespace cm::controllers;`。我经常喜欢将代码放在命名空间的范围内，因为在IDE中可以折叠它。通过重复最内层的命名空间范围（在这个例子中是*controllers*），您可以将代码分解成可折叠的区域，就像在C#中一样，这有助于在更大的文件中进行导航，因为您可以折叠您不感兴趣的部分。这在功能上没有任何区别，所以使用您喜欢的风格。
- en: QObject
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QObject
- en: So, what is this funky **QObject** thingy we are inheriting from which keeps
    popping up? Well, it’s the base class for all Qt objects, and it gives us some
    powerful features for free.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们继承的这个古怪的**QObject**是什么东西？它是所有Qt对象的基类，并且它为我们提供了一些强大的功能。
- en: QObjects organize themselves into object hierarchies with a *parent* object
    assuming ownership of their *child* objects, which means we don’t have to worry
    (as much!) about memory management. For example, if we have an instance of a Client
    class derived from QObject that is the parent of an Address also derived from
    QObject, then the address is automatically destroyed when the client is destroyed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: QObjects将自己组织成对象层次结构，*parent*对象承担其*child*对象的所有权，这意味着我们不必太担心内存管理。例如，如果我们有一个从QObject派生的Client类的实例，它是从QObject派生的Address的父类，那么当客户端被销毁时，地址会自动被销毁。
- en: QObjects carry metadata that allows a degree of type inspection and is the backbone
    for interaction with QML. They can also communicate with each other via an event
    subscription mechanism where the events are emitted as *signals* and the subscribed
    delegates are known as *slots*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: QObjects携带元数据，允许一定程度的类型检查，并且是与QML交互的支柱。它们还可以通过事件订阅机制相互通信，其中事件被发射为*signals*，订阅的代理被称为*slots*。
- en: All you need to remember for now is that for any custom classes you write where
    you want to interact with it in the UI, ensure that it derives from QObject. Whenever
    you do derive from QObject, ensure that you always add the magical Q_OBJECT macro
    to your class before you do anything else. It injects a bunch of super complicated
    boilerplate code that you don’t need to understand in order to use QObjects effectively.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要记住的是，对于您编写的任何自定义类，如果您希望在UI中与之交互，请确保它派生自QObject。每当您从QObject派生时，请确保在做任何其他事情之前始终向您的类添加神奇的Q_OBJECT宏。它注入了一堆超级复杂的样板代码，您不需要理解就可以有效地使用QObjects。
- en: 'We are now at the point where we need to reference code from one subproject
    (`MasterController` in `cm-lib`) in another (`cm-ui`). We first need to be able
    to access the declarations for our `#include` statements. Edit the `INCLUDEPATH`
    variable in `cm-ui.pro` as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要引用一个子项目（`cm-lib`中的`MasterController`）中的代码到另一个子项目（`cm-ui`）中。我们首先需要能够访问我们的`#include`语句的声明。编辑`cm-ui.pro`中的`INCLUDEPATH`变量如下：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `\` symbol is a “continue on to the next line” indicator, so you can set
    a variable to multiple values spanning several lines. Just like console commands,
    ‘..’ means traverse up a level, so here we are stepping up out of the local folder
    (`cm-ui`) and then down into the `cm-lib` folder to get at its source code. You
    need to be careful that the project folders remain in the same location relative
    to each other, else this won’t work.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`\`符号是“继续到下一行”的指示符，因此您可以将一个变量设置为跨越多行的多个值。就像控制台命令一样，‘..’表示向上遍历一个级别，所以这里我们从本地文件夹（`cm-ui`）中跳出，然后进入`cm-lib`文件夹以获取其源代码。您需要小心，项目文件夹保持相对位置不变，否则这将无法工作。'
- en: Just below this, we’ll tell our UI project where to find the implementation
    (compiled binary) of our library project. If you take a look at the filesystem
    alongside the top-level `cm` project folder, you will see one or more build folders,
    for example, build-cm-Desktop_Qt_5_9_0_MinGW_32bit-Debug. Each folder is created
    when we run qmake for a given kit and configuration and is populated with the
    output when we build.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们将告诉我们的UI项目在哪里找到我们的库项目的实现（已编译的二进制文件）。如果您查看与顶级`cm`项目文件夹并排的文件系统，您会看到一个或多个构建文件夹，例如，build-cm-Desktop_Qt_5_9_0_MinGW_32bit-Debug。每个文件夹在为给定的工具包和配置运行qmake时创建，并在构建时填充输出。
- en: Next, navigate to the folder relevant to the kit and configuration you are using,
    and you will find a cm-lib folder with another configuration folder inside it.
    Copy this file path; for example, I am using the MinGW 32 bit kit in Debug configuration,
    so my path is `<Qt Projects>/build-cm-Desktop_Qt_5_10_0_MinGW_32bit-Debug/cm-lib/debug`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导航到与您正在使用的工具包和配置相关的文件夹，您会发现一个带有另一个配置文件夹的cm-lib文件夹。复制这个文件路径；例如，我正在使用MinGW
    32位工具包进行调试配置，所以我的路径是`<Qt Projects>/build-cm-Desktop_Qt_5_10_0_MinGW_32bit-Debug/cm-lib/debug`。
- en: 'In that folder, you will find the compiled binaries relevant for your OS, for
    example, `cm-lib.dll` on Windows. This is the folder we want our `cm-ui` project
    to reference for the `cm-lib` library implementation. To set this up, add the
    following statement to `cm-ui.pro`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个文件夹中，您会找到与您的操作系统相关的已编译二进制文件，例如，在Windows上是`cm-lib.dll`。这是我们希望我们的`cm-ui`项目引用的`cm-lib`库实现的文件夹。为了设置这一点，将以下语句添加到`cm-ui.pro`中：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`LIBS` is the variable used to add referenced libraries to the project. The
    `-L` prefix denotes a directory, while `-l` denotes a library file. Using this
    syntax allows us to ignore the file extensions (`.a`, `.o`, `.lib`) and prefixes
    (lib...), which can vary between operating systems and let qmake figure it out.
    We use the special `$$` symbol to access the value of the `PWD` variable, which
    contains the working directory of the current project (the full path to `cm/cm-ui`
    in this case). From that location, we then drill up two directories with `../..`
    to get us to the Qt projects folder. From there, we drill back down to the location
    where we know the `cm-lib` binaries are built.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIBS`是用于向项目添加引用库的变量。`-L`前缀表示目录，而`-l`表示库文件。使用这种语法允许我们忽略文件扩展名（`.a`，`.o`，`.lib`）和前缀（lib...），这些可能因操作系统而异，让qmake自行解决。我们使用特殊的`$$`符号来访问`PWD`变量的值，该变量包含当前项目的工作目录（在这种情况下是`cm/cm-ui`的完整路径）。然后，我们从该位置向上两个目录，使用`../..`来到Qt项目文件夹。然后，我们再次向下钻取到我们知道`cm-lib`二进制文件构建的位置。'
- en: Now, this is painful to write, ugly as hell, and will fall over as soon as we
    switch kits or configurations, but we will come back and tidy up all this later.
    With the project references all wired up, we can head on over to `main.cpp` in
    `cm-ui`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个写起来很痛苦，丑陋得要命，一旦我们切换工具包或配置，它就会崩溃，但我们稍后会回来整理所有这些。项目引用都已连接好，我们可以前往`cm-ui`中的`main.cpp`。
- en: 'To be able to use a given class in QML, we need to register it, which we do
    in `main()` before we create the QML Application Engine. First, include the `MasterController`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在QML中使用给定的类，我们需要在创建QML应用程序引擎之前在`main()`中注册它。首先，包括`MasterController`：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, right after the `QGuiApplication` is instantiated but before the `QQmlApplicationEngine`
    is declared, add the following line:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在实例化`QGuiApplication`之后但在声明`QQmlApplicationEngine`之前，添加以下行：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What we are doing here is registering the type with the QML engine. Note that
    the template parameter must be fully qualified with all namespaces. We will add
    the type’s metadata into a module called CM with a version number 1.0, and we
    want to refer to this type as `MasterController` in QML markup.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将类型注册到QML引擎中。请注意，模板参数必须使用所有命名空间进行完全限定。我们将类型的元数据添加到一个名为CM的模块中，版本号为1.0，并且我们希望在QML标记中将此类型称为`MasterController`。
- en: 'Then, we instantiate an instance of `MasterController` and inject it into the
    root QML context:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实例化`MasterController`的一个实例，并将其注入到根QML上下文中：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that you need to set the context property before loading the QML file,
    and you will also need to add the following header:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在加载QML文件之前，您需要设置上下文属性，并且还需要添加以下标头：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, we’ve created a controller, registered it with the QML engine, and it’s
    good to go. What now? Let’s do our first bit of QML.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经创建了一个控制器，将其注册到了QML引擎中，并且一切就绪。现在呢？让我们开始我们的第一段QML。
- en: QML
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML
- en: '**Qt Modeling Language** (**QML**) is a hierarchical declarative language for
    user interface layout with a syntax similar to **JavaScript Object Notation**
    (**JSON**). It can bind to C++ objects via Qt’s meta object system and also supports
    inline JavaScript. It’s much like HTML or XAML but without the XMLness. If you
    are someone who likes JSON more than XML, this can only be a good thing!'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt建模语言**（**QML**）是一种用于用户界面布局的分层声明性语言，其语法类似于**JavaScript对象表示法**（**JSON**）。它可以通过Qt的元对象系统绑定到C++对象，并且还支持内联JavaScript。它很像HTML或XAML，但没有XML的繁琐。如果你更喜欢JSON而不是XML，这只能是一件好事！'
- en: Go ahead and open up `MasterView.qml`, and we’ll see what’s going on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 继续打开`MasterView.qml`，我们将看到发生了什么。
- en: The first thing you’ll see is a couple of `import` statements. They are similar
    to `#include` statements in C++—they bring in pieces of functionality that we
    want to use in the view. They can be packed and versioned modules as with QtQuick
    2.9, or they can be relative paths to local content.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到的第一件事是一对`import`语句。它们类似于C++中的`#include`语句，它们引入了我们想要在视图中使用的功能部分。它们可以是打包和版本化的模块，如QtQuick
    2.9，也可以是指向本地内容的相对路径。
- en: Next, the QML hierarchy begins with a Window object. The scope of the object
    is represented by the subsequent `{}`, so everything within the braces is either
    a property or child of the object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，QML层次结构从一个Window对象开始。对象的范围由随后的{}表示，因此括号内的所有内容都是对象的属性或子对象。
- en: 'Properties follow JSON property syntax, of the form key: value. A notable difference
    is that speech marks are not required unless you are providing a string literal
    as a value. Here, we are setting the `visible` property of the Window object to
    be `true` and the size of the window to be 640 x 480 pixels, and we are displaying
    Hello World in the title bar.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '属性遵循JSON属性语法，形式为key: value。一个显着的区别是，除非您提供字符串文字作为值，否则不需要引号。在这里，我们将窗口对象的`visible`属性设置为`true`，窗口的大小设置为640
    x 480像素，并在标题栏中显示Hello World。'
- en: 'Let’s change the title and add a simple message. Replace the Hello World title
    with Client Management and insert a Text component inside the body of the Window:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改标题并添加一个简单的消息。将Hello World的标题更改为Client Management，并在窗口的正文中插入一个Text组件：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save your changes, and Run qmake and Run the application:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您的更改，并运行qmake并运行应用程序：
- en: '![](img/8a1da88e-5508-40df-b5f6-20da69d33968.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a1da88e-5508-40df-b5f6-20da69d33968.png)'
- en: Let’s make `MasterController` start earning its keep and rather than hard-coding
    our welcome message in the UI, we’ll obtain it dynamically from our controller.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让`MasterController`开始发挥作用，而不是在UI中硬编码我们的欢迎消息，我们将从我们的控制器动态获取它。
- en: 'Edit `master-controller.h` and add a new public property of the `QString` type called
    `welcomeMessage`, setting it to an initial value:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`master-controller.h`，并添加一个名为`welcomeMessage`的新的`QString`类型的公共属性，并将其设置为初始值：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will also need to `#include <QString>`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要`#include <QString>`。
- en: 'In order to be able to access this member from QML, we need to configure a
    new property. After the Q_OBJECT macro but before the first public access modifier,
    add the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从QML访问此成员，我们需要配置一个新的属性。在Q_OBJECT宏之后但在第一个公共访问修饰符之前，添加以下内容：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are creating a new property of the QString type that QML can access. QML
    will refer to the property as `ui_welcomeMessage` and when called, will get (or
    set) the value in the `MEMBER` variable called `welcomeMessage`. We are explicitly
    setting the value of the variable up front and will not change it, so it will
    remain `CONSTANT`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个新的`QString`类型的属性，QML可以访问。QML将把属性称为`ui_welcomeMessage`，在调用时，将获取（或设置）`MEMBER`变量中称为`welcomeMessage`的值。我们明确地设置了变量的值，并且不会更改它，因此它将保持`CONSTANT`。
- en: You can simply name the property `welcomeMessage`, rather than `ui_welcomeMessage`.
    My personal preference is to explicitly name things that are solely intended for
    UI consumption with a ui_ prefix to differentiate them from member variables and
    methods. Do whatever works for you.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以简单地将属性命名为`welcomeMessage`，而不是`ui_welcomeMessage`。我个人偏好于明确地为仅用于UI消耗的事物添加ui_前缀，以将其与成员变量和方法区分开。做适合您的事情。
- en: 'Head back to `MasterView.qml`, and we will put this property to use. Change
    the `text` property of the `Text` component to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`MasterView.qml`，我们将使用这个属性。将`Text`组件的`text`属性更改为以下内容：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note how the QML editor recognizes `masterController` and even offers code completion
    for it. Now, rather than displaying a string literal as the message, the QML will
    access the `ui_welcomeMessage` property of the instance of `MasterController`
    we injected into the root context in `main()`, which will, in turn, get the value
    of the `welcomeMessage` member variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意QML编辑器如何识别`masterController`，甚至为其提供代码完成。现在，QML不再显示字符串文字作为消息，而是访问我们在`main()`中注入到根上下文中的`MasterController`实例的`ui_welcomeMessage`属性，这将进而获取`welcomeMessage`成员变量的值。
- en: 'Build and Run, and you should now see the message coming from the `MasterController`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行，现在您应该能够看到来自`MasterController`的消息：
- en: '![](img/fe3e204d-88f4-4203-9859-f16bde93e547.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe3e204d-88f4-4203-9859-f16bde93e547.png)'
- en: We now have a working mechanism for QML to call into C++ code and get hold of
    whatever data and business logic we want to provide it. Here, an important thing
    to note is that our `MasterController` knows nothing about the existence of `MasterView`, and
    this is a key part of the MVC pattern.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个让QML调用C++代码并获取我们想要提供的任何数据和业务逻辑的工作机制。在这里，需要注意的一点是我们的`MasterController`对`MasterView`的存在一无所知，这是MVC模式的关键部分。
- en: Project output
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目输出
- en: In order to let our `cm-ui` project know where to find the implementation of
    `cm-lib`, we used the `LIBS` variable in our project file. It was a pretty ugly
    folder name, but it’s only one line and everything has worked perfectly well,
    so it could be tempting to leave things as they are. However, look forward to
    when we are ready to produce our first build for testing or even production. We’ve
    written some really clever code, and everything is building and running beautifully.
    We switch the configuration from Debug to Release and...everything falls over.
    The problem is that we’ve hard-coded the library path in our project file to look
    in the `Debug` folder. Change to a different kit or another operating system and
    the problem is even worse, as you will have binary compatibility issues from using
    different compilers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的`cm-ui`项目知道在哪里找到`cm-lib`的实现，我们在项目文件中使用了`LIBS`变量。这是一个相当丑陋的文件夹名，但只有一行，一切都运行得很完美，所以很容易就会让事情保持原样。然而，期待着当我们准备好为测试或者生产制作我们的第一个构建时。我们编写了一些非常聪明的代码，一切都构建和运行得很好。我们将配置从Debug切换到Release然后...一切都垮掉了。问题在于我们在项目文件中硬编码了库路径，以便在`Debug`文件夹中查找。切换到不同的套件或另一个操作系统，问题会更糟，因为使用不同的编译器会导致二进制兼容性问题。
- en: 'Let’s set a few goals:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设定一些目标：
- en: Get rid of the unwieldy `build-cm…` folders
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摆脱笨重的`build-cm…`文件夹
- en: Aggregate all the compiled binary output into one common folder `cm/binaries`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有编译后的二进制输出聚合到一个共同的文件夹`cm/binaries`
- en: Hide all temporary build artifacts in their own folders `cm/<project>/build`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有临时构建工件隐藏在它们自己的文件夹`cm/<project>/build`
- en: Create separate build and binary folders for different compilers and architectures
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同的编译器和架构创建单独的构建和二进制文件夹
- en: Detect those compilers and architectures automatically
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动检测这些编译器和架构
- en: So, where do these funny long folder names come from in the first place? In
    Qt Creator, click on the Projects mode icon in the navigation bar. Down the left-hand
    side in the Build & Run section, select Desktop Qt 5.9.0 MinGW 32 bit > Build.
    Here, you will see the Build Settings for the MinGW kit in this solution and under
    the Shadow build checkbox, you will recognize the long build directory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些有趣的长文件夹名字首先是从哪里来的呢？在Qt Creator中，点击导航栏中的项目模式图标。在左侧的构建和运行部分，选择桌面Qt 5.9.0
    MinGW 32位 > 构建。在这里，您将看到此解决方案中MinGW套件的构建设置，并在影子构建复选框下，您将认出长的构建目录。
- en: 'We need to leave shadow builds enabled as this gives us the capability to perform
    builds to alternative locations for different kits. We will control the exact
    output of our builds in the `.pro` files, but we still need to specify a build
    directory here to keep Qt Creator happy. Enter <Qt Projects>/shadow-builds. Repeat
    this setting for each build configuration (Debug/Release/Profile) using the dropdown
    at the top of the pane, and for all the kits you are using:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要保持影子构建的启用，因为这使我们能够对不同的套件执行构建到替代位置的能力。我们将在`.pro`文件中控制我们构建的确切输出，但我们仍然需要在这里指定一个构建目录，以使Qt
    Creator保持愉快。输入<Qt Projects>/shadow-builds。使用窗格顶部的下拉菜单重复此设置，为每个构建配置(Debug/Release/Profile)和您正在使用的所有套件：
- en: '![](img/09a8328e-26ef-439f-8546-7eb661821236.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09a8328e-26ef-439f-8546-7eb661821236.png)'
- en: In your filesystem, delete any of the old `build-cm…` folders. Right-click on
    the solution folder and Run qmake. After qmake has finished, you should see that
    shell `cm-lib`, `cm-tests`, and `cm-ui` folders have been created in <Qt Projects>/shadow-builds
    and that the long `build-cm…` folders have not reappeared.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的文件系统中，删除任何旧的`build-cm…`文件夹。右键单击解决方案文件夹并运行qmake。qmake完成后，您应该看到`cm-lib`，`cm-tests`和`cm-ui`文件夹已经在<Qt
    Projects>/shadow-builds中创建，并且长的`build-cm…`文件夹没有重新出现。
- en: The first step for dynamically setting any relative path is to know which path
    you are currently on. We’ve already seen that in action in qmake when we used
    `$$PWD` to get the project working directory. To help us visualize what is going
    on, let’s introduce our first qmake function—`message()`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 动态设置任何相对路径的第一步是知道您当前所在的路径。我们已经在qmake中看到了`$$PWD`的作用，以获取项目工作目录。为了帮助我们可视化正在发生的事情，让我们介绍我们的第一个qmake函数——`message()`。
- en: 'Add the following line to `cm.pro`—it doesn’t matter where in the file it goes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm.pro`中添加以下行——放在文件的任何位置都可以：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following line to `cm-lib.pro`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-lib.pro`中添加以下行：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `message()` is a test function supported by qmake that outputs the supplied
    string parameter to the console. Note that you don’t need to surround the text
    with double quotes. When you save the changes, you will see the **Project Working
    Directory** (**PWD**) of both the solution project and the library project logged
    out to the General Messages console:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`message()`是qmake支持的测试函数，它将提供的字符串参数输出到控制台。请注意，您不需要用双引号括起文本。当您保存更改时，您将看到解决方案项目和库项目的**项目工作目录**（**PWD**）被记录到General
    Messages控制台中：'
- en: '`Project MESSAGE: cm project dir: C:/projects/qt/cm`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project MESSAGE: cm project dir: C:/projects/qt/cm`'
- en: '`Project MESSAGE: cm-lib project dir: C:/projects/qt/cm/cm-lib`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project MESSAGE: cm-lib project dir: C:/projects/qt/cm/cm-lib`'
- en: qmake actually takes multiple passes over `.pro` files, so whenever you use
    `message()`, you may see the same output several times over in the console. You
    can filter out the majority of duplicates using `message()` in conjunction with
    a scope—`!build_pass:message(Here is my message)`. This prevents the `message()`
    method from being called during the build pass.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: qmake实际上会对`.pro`文件进行多次处理，因此每当您使用`message()`时，您可能会在控制台中看到相同的输出多次。您可以使用`message()`与作用域一起来过滤掉大部分重复的内容——`!build_pass:message(Here
    is my message)`。这可以防止在构建过程中调用`message()`方法。
- en: 'If we look back at the default behavior of Qt Creator for shadow builds, we’ll
    see that the aim was to allow multiple builds to sit alongside each other. This
    is achieved by constructing distinct folder names containing the kit, platform,
    and build configuration:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾Qt Creator对于影子构建的默认行为，我们会发现其目的是允许多个构建并存。这是通过构建包含工具包、平台和构建配置的不同文件夹名称来实现的：
- en: '`build-cm-solution-Desktop_Qt_5_10_0_MinGW_32bit-Debug`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`build-cm-solution-Desktop_Qt_5_10_0_MinGW_32bit-Debug`'
- en: You can see just by looking at the folder name that the contents are from a
    build of the **cm** project using the Qt 5.10.0 for Desktop MinGW 32bit kit in
    Debug mode. We’ll now reimplement this approach in a cleaner and more flexible
    way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过查看文件夹名称，您就可以看出其中的内容是使用Qt 5.10.0为Desktop MinGW 32位工具包在调试模式下构建的**cm**项目。我们现在将以更清晰和更灵活的方式重新实施这种方法。
- en: Rather than concatenating the information into one long folder name, we'll prefer
    a hierarchical structure consisting of the `Operating System > Compiler > Processor
    Architecture > Build Configuration` folders.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更喜欢一个分层结构，包括`操作系统 > 编译器 > 处理器架构 > 构建配置`文件夹，而不是将信息连接成一个很长的文件夹名称。
- en: 'Let’s first hard-code this path and then move on to automating it. Edit `cm-lib.pro`
    and add this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先硬编码此路径，然后再进行自动化。编辑`cm-lib.pro`并添加以下内容：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is to reflect that we are building with the MinGW 32bit kit on Windows
    in Debug mode. Replace *Windows* with *osx* or *Linux* if you are on a different
    OS. We’ve added another call to `message()` to output this destination directory
    in the General Messages console. Remember that `$$PWD` extracts the working directory
    of the `.pro` file being processed (`cm-lib.pro` in this case), so this gives
    us `<Qt Projects>/cm/cm-lib`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了反映我们正在使用MinGW 32位工具包在Windows上以调试模式构建。如果您使用不同的操作系统，请将*Windows*替换为*osx*或*Linux*。我们在General
    Messages控制台中添加了另一个`message()`调用以输出此目标目录。请记住，`$$PWD`提取正在处理的`.pro`文件（在本例中为`cm-lib.pro`）的工作目录，因此这给了我们`<Qt
    Projects>/cm/cm-lib`。
- en: Right-click on the `cm-lib` project, run qmake, and build. Ensure that you have
    the MinGW kit selected, along with Debug mode.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`cm-lib`项目，运行qmake并构建。确保选择了MinGW工具包以及调试模式。
- en: Navigate to `<Qt Projects>/cm/binaries/<OS>/gcc/x86/debug` in the filesystem,
    and you will see our library binaries without the associated clutter of build
    artifacts. This is a good first step, but if you now change the build configuration
    to Release or switch kits, the destination directory will remain the same, which
    is not what we want.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中导航到`<Qt Projects>/cm/binaries/<OS>/gcc/x86/debug`，您将看到我们的库二进制文件，而不会有构建工件的混乱。这是一个很好的第一步，但是如果您现在将构建配置更改为Release或切换工具包，目标目录将保持不变，这不是我们想要的。
- en: The technique we are about to implement will be used in all three of our projects,
    so rather than having to duplicate the configuration in all of our `.pro` files,
    let’s extract the configuration to a shared file and include it instead.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将实施的技术将在我们的三个项目中使用，因此我们不必在所有的`.pro`文件中重复配置，让我们将配置提取到一个共享文件中并进行包含。
- en: 'In the root `cm` folder, create two new empty text files called `qmake-target-platform.pri`
    and `qmake-destination-path.pri`. In `cm-lib.pro`, `cm-tests.pro`, and `cm-ui.pro`, add
    these lines:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在根目录`cm`文件夹中，创建两个名为`qmake-target-platform.pri`和`qmake-destination-path.pri`的新空文本文件。在`cm-lib.pro`，`cm-tests.pro`和`cm-ui.pro`中添加以下行：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Add these lines somewhere near the top of the `*.pro` files. The exact order
    doesn’t matter too much as long as they are before the `DESTDIR` variable is set.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`*.pro`文件的顶部附近添加这些行。只要它们在设置`DESTDIR`变量之前，确切的顺序并不太重要。
- en: 'Edit `qmake-target-platform.pri` as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`qmake-target-platform.pri`如下：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we are leveraging the platform detection capabilities of qmake to inject
    personalized flags into the `CONFIG` variable. On each operating system, different
    platform variables become available. For example, on Windows, the `win32` variable is
    present, Linux is represented by `linux`, and Mac OS X by `macx`. We can use these
    platform variables with curly braces to act like if statements:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了qmake的平台检测功能，将个性化标志注入`CONFIG`变量中。在每个操作系统上，不同的平台变量变得可用。例如，在Windows上，存在`win32`变量，Linux由`linux`表示，Mac
    OS X由`macx`表示。我们可以使用这些平台变量与花括号一起充当if语句：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can consider different combinations of platform variables to figure out what
    compiler and processor architecture the currently selected kit is using, and then
    add developer-friendly flags to the `CONFIG`, which we can use later in our `.pro`
    files. Remember that we are trying to construct a build path—`Operating System
    > Compiler > Processor Architecture > Build Configuration`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑不同的平台变量组合，以确定当前选择的套件正在使用的编译器和处理器架构，然后向`CONFIG`添加开发人员友好的标志，以便稍后在我们的`.pro`文件中使用。请记住，我们正在尝试构建一个构建路径——`操作系统
    > 编译器 > 处理器架构 > 构建配置`。
- en: 'When you save these changes, you should see the flags similar to the following
    in the General Message console:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存这些更改时，你应该会在通用消息控制台中看到类似以下的标志：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Try switching kits or changing the build configuration, and you should see
    different output. When I switch my kit to Visual Studio 2017 64 bit in Release
    mode, I now get this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试切换套件或更改构建配置，你应该会看到不同的输出。当我将套件切换到Visual Studio 2017 64位的Release模式时，我现在得到了这个结果：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the same project on a Linux machine with the MinGW 64 bit kit, I get this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MinGW 64位套件的Linux机器上，我得到了这个结果：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On a Mac using Clang 64 bit, I get the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Clang 64位的Mac上，我得到了以下结果：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To get this to work on Windows, I had to make an assumption as `QMAKE_TARGET.arch` is
    not correctly detected for MSVC2017, so I assumed that if the compiler is MSVC2017,
    then it must be x64 as there was no 32 bit kit available.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其在Windows上工作，我不得不做一个假设，因为`QMAKE_TARGET.arch`在MSVC2017上没有正确检测到，所以我假设如果编译器是MSVC2017，那么它必须是x64，因为没有32位套件可用。
- en: 'Now that all the platform detection is done, we can construct the destination
    path dynamically. Edit `qmake-destination-path.pri`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的平台检测都已完成，我们可以动态构建目标路径。编辑`qmake-destination-path.pri`：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we create four new variables—*platform_path*, *compiler_path*, *processor_path*,
    and *build_path*—and assign default values to them all. We then use the `CONFIG`
    flags we created in the previous file and construct our folder hierarchy, storing
    it in a variable of our own, called `DESTINATION_PATH`. For example, if we detect
    Windows as the operating system, we add the `PLATFORM_WIN` flag to `CONFIG` and
    as a result of that, set `platform_path` to `windows`. Switching between kits
    and configurations on Windows, I now get these messages:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了四个新变量——*platform_path*、*compiler_path*、*processor_path*和*build_path*——并为它们都分配了默认值。然后我们使用了在前一个文件中创建的`CONFIG`标志，并构建了我们的文件夹层次结构，将其存储在我们自己的变量`DESTINATION_PATH`中。例如，如果我们检测到操作系统是Windows，我们会将`PLATFORM_WIN`标志添加到`CONFIG`中，从而将`platform_path`设置为`windows`。在Windows上切换套件和配置，我现在得到了这些消息：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, I get this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我得到了这个结果：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'On Linux, I get the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，我得到了以下结果：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On Mac OS, this is what I get:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS上，我得到了这个结果：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can just combine these platform detection and destination path creation
    tricks in one file, but by keeping them separate, you can use the flags elsewhere
    in your project files. In any case, we are now dynamically creating a path based
    on our build environment and storing it in a variable for later use.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些平台检测和目标路径创建技巧结合在一个文件中，但通过将它们分开，你可以在项目文件的其他地方使用这些标志。无论如何，我们现在正在根据我们的构建环境动态创建路径，并将其存储在一个变量中以供以后使用。
- en: 'The next thing to do is to plug this `DESTINATION_PATH` variable into our project
    files. While we’re here, we can also structure our build artifacts using the same
    mechanism by adding a few more lines. Add the following to all three `*.pro` files,
    replacing the `DESTDIR` statement already in `cm-lib.pro`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的事情是将这个`DESTINATION_PATH`变量插入到我们的项目文件中。在这里，我们还可以使用相同的机制来构建我们的构建产物，通过添加几行代码。将以下内容添加到所有三个`*.pro`文件中，替换`cm-lib.pro`中已有的`DESTDIR`语句：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Temporary build artifacts will now be placed into discreet directories within
    the build folder.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 临时构建产物现在将放置在构建文件夹内的离散目录中。
- en: 'Finally, we can fix the problem that brought us here in the first place. In
    `cm-tests` and `cm-ui`, we can now set the `LIBS` variable using our new dynamic
    destination path:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以解决最初导致我们来到这里的问题。在`cm-tests`和`cm-ui`中，我们现在可以使用我们新的动态目标路径设置`LIBS`变量：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can now right-click on the `cm` project, run qmake, and build to automatically
    build all three subprojects in one step. All the output will be sent to the correct
    place and the library binaries can be easily located by the other projects. You
    can switch kits and configurations and not have to worry about referencing the
    wrong libraries.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以右键单击`cm`项目，运行qmake，并构建以自动构建所有三个子项目。所有的输出将被发送到正确的位置，库二进制文件可以很容易地被其他项目找到。你可以切换套件和配置，而不必担心引用错误的库。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took our project creation skills up to the next level, and
    our solution is now starting to take shape. We implemented an MVC pattern and
    bridged the gap between our UI and business logic projects. We dabbled with our
    first bit of QML and took a look at the cornerstone of the Qt framework, QObject.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们的项目创建技能提升到了一个新的水平，我们的解决方案现在开始成形。我们实现了MVC模式，并弥合了UI和业务逻辑项目之间的差距。我们尝试了我们的第一点QML，并研究了Qt框架的基石QObject。
- en: We removed all those unsightly `build-cm…` folders, flexed our qmake muscles,
    and took control of where all of our files go. All binaries are now placed in
    the `cm/binaries` folder, organized by platform, compiler, processor architecture,
    and build configuration. All temporary build artifacts that aren’t required by
    the end user are now hidden away. We can freely switch kits and build configurations,
    and have our output automatically rerouted to the correct location.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了所有那些难看的`build-cm…`文件夹，展示了我们的qmake技巧，并控制了所有文件的位置。所有的二进制文件现在都放在`cm/binaries`文件夹中，按平台、编译器、处理器架构和构建配置进行组织。所有不需要的临时构建产物现在都被隐藏起来。我们可以自由切换套件和构建配置，并且我们的输出会自动重定向到正确的位置。
- en: In [Chapter 3](a1bf2971-bc20-4266-92fd-d005dfdb3338.xhtml), *User Interface*,
    we will design our UI and get stuck in some more QML.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](a1bf2971-bc20-4266-92fd-d005dfdb3338.xhtml)中，*用户界面*，我们将设计我们的UI，并深入了解更多的QML。
