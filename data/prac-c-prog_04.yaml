- en: Preprocessing and Compilation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理和编译
- en: There are several preprocessor statements that can help you determine which
    source code needs to be compiled and which needs to be excluded from being compiled.
    That is, a condition can be applied and the desired statements will be compiled
    only if the specified condition is true. These directives can be nested for more
    precise branching. There are numerous preprocessor statements, such as `#if`,
    `#ifdef`, `#ifndef`, `#else`, `#elif`, and `#endif`, that can be used to collect
    statements into blocks that we want to be compiled when the specified condition
    is true.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个预处理器语句可以帮助您确定哪些源代码需要编译，哪些需要排除编译。也就是说，可以应用条件，并且只有当指定的条件为真时，所需的语句才会被编译。这些指令可以嵌套以实现更精确的分支。有大量的预处理器语句，如`#if`、`#ifdef`、`#ifndef`、`#else`、`#elif`和`#endif`，可以用来将语句收集到我们希望在指定条件为真时编译的块中。
- en: 'Some of the advantages of using macros are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏的一些优点如下：
- en: The execution speed of the program increases as the value or code of the macro
    is substituted by the name of the macro. So, the time involved in invoking or
    calling the functions by the compiler is saved.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当宏的值或代码被宏名替换时，程序的执行速度会提高。因此，编译器调用或调用函数所涉及的时间被节省了。
- en: Macros reduce the length of the program.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏可以缩短程序的长度。
- en: The main disadvantage of using a macro is that the size of the program increases
    prior to the compilation of the program, as all the macros are substituted by
    their code. In this chapter, we will learn how to apply conditional compilation
    using preprocessor directives.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏的主要缺点是，在程序编译之前，程序的大小会增加，因为所有宏都被它们的代码替换。在本章中，我们将学习如何使用预处理器指令应用条件编译。
- en: We will also learn how to implement validation in the program by making use
    of assertions. Assertions are a sort of validation check for different critical
    statements of the program. If those assertions or expressions don't validate or
    return false, then an error is displayed and the program is aborted. The main
    difference between this and usual error handling is that assertions can be disabled
    at runtime.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何通过使用断言来实现程序中的验证。断言是对程序中不同关键语句进行验证的一种检查方式。如果这些断言或表达式未验证或返回false，则显示错误并终止程序。与通常的错误处理相比，主要区别在于断言可以在运行时禁用。
- en: If the `#define NDEBUG` macro is defined near the `#include <assert.h>` directive,
    it will disable the assert function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`#include <assert.h>`指令附近定义了`#define NDEBUG`宏，它将禁用断言函数。
- en: Besides the normal asserts, there are also asserts that are referred to as static
    or compile-time asserts, which are used to catch errors at the time of compilation.
    Such asserts can be used to do compile-time validations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常的断言外，还有一些被称为静态或编译时断言的断言，它们用于在编译时捕获错误。这些断言可以用于进行编译时验证。
- en: In addition to this, we will learn how to use stringize and token-pasting operators
    using the example of a pizza parlor.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将通过比萨店示例学习如何使用字符串化和标记粘贴运算符。
- en: 'In this chapter, we will learn how to make the following recipes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何制作以下菜谱：
- en: Performing conditional compilation with directives
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指令进行条件编译
- en: Applying assertions for validation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用断言进行验证
- en: Using assertions to ensure a pointer is not pointing to `NULL`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断言确保指针不是指向`NULL`
- en: Catching errors early with compile-time assertions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编译时断言提前捕获错误
- en: Applying stringize and token-pasting operators
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用字符串化和标记粘贴运算符
- en: Let's start with the first recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个菜谱开始。
- en: Performing conditional compilation with directives
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指令进行条件编译
- en: In this recipe, we will learn how to apply conditional compilation. We will
    define certain macros, and then, by applying the `#if`, `#ifdef`, `#ifndef`, `#else`,
    `#elif`, `#endif`, and `#undef` preprocessor directives, we will direct the compiler
    to compile the desired code. Considering the example of a bookstore, let's assume
    that a user is asked to enter the price of the book. The program will apply different
    discounts, festival offers, a discount coupon, and Kindle options on the basis
    of the `Qty` macro, which represents the quantity or number of books purchased
    by the user. The program also defines other macros that determine different offers
    that are applicable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何应用条件编译。我们将定义某些宏，然后通过应用`#if`、`#ifdef`、`#ifndef`、`#else`、`#elif`、`#endif`和`#undef`预处理器指令，我们将指导编译器编译所需的代码。以书店为例，假设用户被要求输入书籍的价格。程序将根据代表用户购买书籍的数量或数量的`Qty`宏应用不同的折扣、节日优惠、折扣券和Kindle选项。程序还定义了其他宏，以确定不同的适用优惠。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to perform conditional compilation with preprocessor directives:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用预处理器指令进行条件编译：
- en: 'Define a `Qty` macro and assign it an initial value:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`Qty`宏并为其分配一个初始值：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The user will be prompted to enter the price of a book:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将被提示输入书籍的价格：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The total number of books is computed using the `Qty*price` formula:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Qty*price`公式计算书籍的总数：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the basis of the `Qty` macro, the `#if`, `#elif`, `#else`, and `#endif` directives
    are used to determine the discount on the total number.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`Qty`宏，使用`#if`、`#elif`、`#else`和`#endif`指令来确定总金额的折扣。
- en: 'Once the discount percentage is determined, the amount after deducting the
    discount is computed and is assigned to the `afterDisc` variable:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确定了折扣百分比，就会计算折扣后的金额，并将其分配给`afterDisc`变量：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The festival discount is also computed on the basis of the `FestivalOffer`
    macro. That is, the `#ifdef`, `#else`, and `#endif` directives are used to confirm
    whether the `FestivalOffer` macro is defined and, accordingly, the amount that
    the customer has to pay after deducting the festival discount is computed:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节日折扣也是基于`FestivalOffer`宏计算的。也就是说，使用`#ifdef`、`#else`和`#endif`指令来确认是否已定义`FestivalOffer`宏，并相应地计算客户在扣除节日折扣后需要支付的金额：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `#if defined` directive is used to confirm whether the `DiscountCoupon`
    macro is defined in the program or not. And, accordingly, the user is informed
    whether they are eligible for the discount coupon:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`#if defined`指令来确认程序中是否定义了`DiscountCoupon`宏。相应地，用户会被告知他们是否有资格获得折扣券：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preprocessor directives, `#ifndef` and `#endif`, are used to determine
    whether the `Kindle` macro is defined or not. If the `Kindle` macro is not yet
    defined, it is defined and its value is set. Accordingly, the user is informed
    of how many months they will be eligible for the `Kindle` version of the book:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预处理器指令`#ifndef`和`#endif`用于确定是否已定义`Kindle`宏。如果`Kindle`宏尚未定义，则将其定义并设置其值。相应地，用户会被告知他们将有资格获得`Kindle`版书籍的多少个月：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The program for performing conditional compilation with preprocessor directives
    is shown in the following code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预处理器指令进行条件编译的程序如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解幕后，以便更好地理解代码。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Four macros, called `Qty`, `FestivalOffer`, `DiscountCoupon`, and `Kindle`,
    are defined with the values of `10`, `2`, `5`, and `2`, respectively. The user
    is prompted to enter the price of a book. The value entered by the user is assigned
    to the variable price. The `#if`, `#elif`, `#else`, and `#endif` conditional directives are
    then used to determine the amount of discount to be applied to the books depending
    on the value of the `Qty` macro. Because, the current value of the `Qty` macro
    is `10`, the value of the discount variable will be set to `15` through the preprocessor
    directives. The value of the `discount` variable can be changed at any time simply
    by changing the value of the `Qty` macro. The total number of the books is computed
    by multiplying the values of `Qty` by the price, and the resultant value is assigned
    to the `totalAmount` variable. Because the user is given some kind of discount
    on the basis of the `Qty` value, the amount that the user has to pay after deducting
    the discount is computed and the resulting amount is assigned to the `afterDisc`
    variable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了四个宏，分别称为`Qty`、`FestivalOffer`、`DiscountCoupon`和`Kindle`，它们的值分别为`10`、`2`、`5`和`2`。用户被提示输入书籍的价格。用户输入的值被分配给变量`price`。然后使用`#if`、`#elif`、`#else`和`#endif`条件指令根据`Qty`宏的值确定应用于书籍的折扣金额。因为当前`Qty`宏的值为`10`，通过预处理器指令将折扣变量的值设置为`15`。`discount`变量的值可以随时通过更改`Qty`宏的值来更改。通过将`Qty`的值乘以价格来计算书籍的总数，并将结果值分配给`totalAmount`变量。因为用户根据`Qty`值获得某种折扣，所以计算扣除折扣后的金额，并将结果值分配给`afterDisc`变量。
- en: Again, because the `FestivalOffer` macro is defined, the `#ifdef`, `#else`,
    and `#endif` preprocessor directives are used to compute the amount that the customer
    has to pay after deducting a festival discount of 2%. We can always comment out
    the `#define FestivalOffer` statement to undefine the macro; in this case, no
    festival discount will be given to the customer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于`FestivalOffer`宏被定义，使用了`#ifdef`、`#else`和`#endif`预处理器指令来计算在扣除2%节日折扣后客户需要支付的金额。我们总是可以通过注释掉`#define
    FestivalOffer`语句来取消宏的定义；在这种情况下，将不会向客户提供节日折扣。
- en: The total amount is displayed on the screen as well as the amount after deducting
    the discount. And if the festival offer is applied, the amount after deducting
    the festival offer is also displayed on the screen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总金额以及扣除折扣后的金额都会在屏幕上显示。如果应用了节日优惠，扣除节日优惠后的金额也会在屏幕上显示。
- en: The `#if defined` directive is used to confirm whether the `DiscountCoupon`
    macro is defined or not. Because currently in the program the `DiscountCoupon`
    macro is defined and is assigned the value of `5`, a message is displayed informing
    that they are eligible for an additional discount coupon of $5 too. You can always
    comment out the `DiscountCoupon` macro if you want to avoid giving any discount
    coupons. The Kindle version of the book has to be given to the customer for at
    least a month. Because the `Kindle` macro is defined in the program and is assigned
    the value of `2`, a message is displayed on the screen informing the user that
    they are allowed to use the Kindle version of the book for 2 months. However,
    if you comment out the `Kindle` macro, the `#ifndef` and `#endif` preprocessor
    directives are used to set the value of the `Kindle` macro to `1` if the `Kindle`
    macro is not defined in the program. Therefore, if the `Kindle` macro is not defined
    in the program, a message will be displayed informing the user that they are allowed
    to use the Kindle version of the book for 1 month.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`#if defined`指令来确认`DiscountCoupon`宏是否被定义。因为目前程序中`DiscountCoupon`宏被定义，并赋值为`5`，会显示一条消息告知他们还有资格获得额外的5美元折扣券。如果您想避免提供任何折扣券，可以总是注释掉`DiscountCoupon`宏。书籍的Kindle版本至少需要提供给客户一个月。因为程序中定义了`Kindle`宏，并赋值为`2`，屏幕上会显示一条消息告知用户他们可以使用书籍的Kindle版本2个月。然而，如果您注释掉`Kindle`宏，如果程序中没有定义`Kindle`宏，`#ifndef`和`#endif`预处理器指令将用于将`Kindle`宏的值设置为`1`。因此，如果程序中没有定义`Kindle`宏，会显示一条消息告知用户他们可以使用书籍的Kindle版本1个月。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, this means that the `condcompile.c` program is
    successfully compiled into a `.exe` file: `condcompile.exe`. On executing the
    file, the user will be prompted to enter the price of the book and, according
    to the defined macros, the total amount and the discounted amount will be displayed,
    as shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下截图所示。因为没有在编译过程中出现错误，这意味着`condcompile.c`程序已成功编译成`.exe`文件：`condcompile.exe`。在执行文件时，用户将被提示输入书籍的价格，并根据定义的宏，将显示总金额和折扣金额，如下截图所示：
- en: '![](img/28aac8ff-2af0-4b37-a5e7-c5d4819acca5.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28aac8ff-2af0-4b37-a5e7-c5d4819acca5.png)'
- en: Figure 4.1
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1
- en: 'Next, keeping the value of the `Qty` macro to `10` and try commenting out the
    following two macros:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，保持`Qty`宏的值为`10`，并尝试注释掉以下两个宏：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding program will show the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序将显示以下输出：
- en: '![](img/834f3be7-668d-4eed-a126-08433a8f22dd.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/834f3be7-668d-4eed-a126-08433a8f22dd.png)'
- en: Figure 4.2
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2
- en: You can see in the output that because the value of the `Qty` macro is still 
     `10`, the customer will continue to get a discount of 15% as shown in the preceding
    screenshot. Additionally, the festival discount is not given to the customer at
    all. Because `DiscountCoupon` macro is still defined, the customer will continue
    to get discount coupon of $5  and the Kindle version is reduced to 1 month.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在输出中看到，由于`Qty`宏的值仍然是`10`，客户将继续获得前面截图所示的15%折扣。此外，节日折扣根本未给予客户。因为`DiscountCoupon`宏仍然被定义，客户将继续获得5美元的折扣券，Kindle版本的价格降低到1个月。
- en: 'As we mentioned earlier, the `#undef` directive removes the current definition
    of the macro. The following code snippet uses the defined macro and then undefines
    it after using it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`#undef`指令移除了当前宏的定义。以下代码片段使用定义的宏，并在使用后将其取消定义：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see that the `qty` macro is used and then undefined after usage. Now,
    let's move on to the next recipe!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`qty`宏被使用，并在使用后未定义。现在，让我们继续到下一个配方！
- en: Applying assertions for validation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用断言进行验证
- en: In this recipe, we will learn how to implement validation using assertion. The
    program will ask the user to enter the information of the passengers that are
    flying from one place to another. Using assertions, we can ensure that the number
    of passengers entered is a positive number. If the number of passengers entered
    is zero or a negative value, the program will abort.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何使用断言实现验证。程序将要求用户输入从一地飞往另一地的乘客信息。使用断言，我们可以确保输入的乘客数量是正数。如果输入的乘客数量为零或负数，程序将终止。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a validation check using assertion. The recipe
    will not allow the program to run if the value of the number of passengers is
    zero or negative:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用断言创建验证检查。如果乘客数量的值为零或负数，则该配方将不允许程序运行：
- en: 'The user is prompted to enter how many passengers are flying:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被提示输入飞行乘客的数量：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An `assert` instance is defined to ensure that the value of the number of passengers
    should not be `0` or negative. If the user enters a value of `0` or negative for
    the number of passengers, an error message will be displayed showing the line
    number, and the program will abort:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了一个`assert`实例以确保乘客数量的值不应为`0`或负数。如果用户为乘客数量输入了`0`或负数值，将显示错误消息，显示行号，并且程序将终止：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the value for the number of passengers entered is a positive value, the
    user is asked to supply other information such as where the flight is going from,
    where the flight is going to, and the date of the journey:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入的乘客数量值为正数，用户将被要求提供其他信息，例如航班从哪里出发，航班飞往哪里，以及旅行的日期：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The entered information of the passengers is then displayed on the screen:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘客输入的信息随后显示在屏幕上：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The program for implementing a validation check using assertions is shown in
    the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断言实现验证检查的程序如下代码片段所示：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The program prompts the user to enter the information of the passengers that
    are flying from one place to another on a specific date. In order to ensure that
    the value of the number of passengers is not zero or negative, an assertion is
    used. The `assert` expression validates the value assigned to the `noOfPassengers`
    variable. It checks whether the value of the `noOfPassengers` variable is greater
    than `0` or not. If it is, the program will continue to execute the rest of the
    statements; otherwise, the filename and the line number are sent to the standard
    error and the program is aborted.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 程序提示用户输入特定日期从一地飞往另一地的乘客信息。为了确保乘客数量的值不是零或负数，使用了断言。`assert`表达式验证分配给`noOfPassengers`变量的值。它检查`noOfPassengers`变量的值是否大于`0`。如果是，程序将继续执行其余的语句；否则，将文件名和行号发送到标准错误，并终止程序。
- en: If the assert statement is validated, that is, if the value assigned to `noOfPassengers`
    is more than 0, then the user is asked to enter the other details of the passengers
    such as where the flight is going from, where the flight is going to, and the
    date of the journey. The entered information is then displayed on the screen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言语句得到验证，即`noOfPassengers`分配的值大于0，那么将要求用户输入乘客的其他详细信息，例如航班从哪里出发，航班飞往哪里，以及旅行的日期。然后，输入的信息将显示在屏幕上。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, this means the `assertdemoprog.c` program is
    successfully compiled into a `.exe` file: `assertdemoprog.exe`. On executing the
    file, the user is prompted to enter the number of passengers flying. If the number
    of passengers entered is a positive value, the program will run perfectly, as
    shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下面的截图所示。因为没有在编译过程中出现错误，这意味着`assertdemoprog.c`程序已成功编译成`.exe`文件：`assertdemoprog.exe`。在执行文件时，将提示用户输入乘客数量。如果输入的乘客数量是正数，程序将完美运行，如下面的截图所示：
- en: '![](img/a8ed6c5c-aec4-48ea-ad7a-2ad23728242f.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8ed6c5c-aec4-48ea-ad7a-2ad23728242f.png)'
- en: Figure 4.3
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3
- en: 'While executing the program for the second time, if the value entered is negative
    or zero for the `noOfPassengers` variable, an error will be displayed showing
    the program name and line number, and the program is aborted. The specified error
    message, `"Number of passengers should be a positive integer"`, will be displayed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次执行程序时，如果`noOfPassengers`变量的输入值是负数或零，将显示一个错误，显示程序名称和行号，并终止程序。指定的错误信息“`Number
    of passengers should be a positive integer`”将被显示：
- en: '![](img/2564dea6-39f1-4278-907f-968da70c2525.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2564dea6-39f1-4278-907f-968da70c2525.png)'
- en: Figure 4.4
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4
- en: Voilà! We have successfully applied assertions to validate our data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功应用断言来验证我们的数据。
- en: Using assertions to ensure a pointer is not pointing to NULL
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用断言确保指针不是指向NULL
- en: Let's perform one more recipe on assertions. Let's apply assertions to ensure
    that a pointer is not pointing to `NULL` and is instead pointing to a memory address
    that is to be accessed. Essentially, in this recipe, we will learn to compute
    the average of a few numbers, where the numbers are stored in an array, and the
    array elements are accessed through a pointer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在断言上再做一个练习。让我们应用断言以确保指针不是指向`NULL`，而是指向要访问的内存地址。本质上，在这个练习中，我们将学习计算一些数字的平均值，这些数字存储在数组中，而数组元素是通过指针访问的。
- en: How to do it…
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to ensure that the pointer is not `NULL` and is pointing
    to a memory address by making use of assertions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用断言，遵循以下步骤以确保指针不是`NULL`并且指向一个内存地址：
- en: 'Define an array containing a number of integers whose average is to be computed:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含要计算平均值的整数数组的数组：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set a pointer to point to the array:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个指针指向数组：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define a function for calculating the average of the array elements. A pointer
    to an array and the count of the number of values in the array are both passed
    to this function:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于计算数组元素平均值的函数。将数组的指针和数组中值的数量都传递给这个函数：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the function, define an `assert` expression that ensures that the pointer
    is not `NULL`. If the pointer is `NULL`, the program will display an error and
    will be aborted:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，定义一个`assert`表达式以确保指针不是`NULL`。如果指针是`NULL`，程序将显示错误并终止：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the pointer is not `NULL`, the array elements will be accessed through the
    pointer and their average will be computed and displayed on the screen:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指针不是`NULL`，则将通过指针访问数组元素，并计算它们的平均值并在屏幕上显示：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The program for implementing a validation that ensures the pointer is not `NULL`
    and is pointing to a memory address is shown as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实现验证以确保指针不是`NULL`且指向内存地址的程序如下所示：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this program, the average of several integers is computed via an array. That
    is, a number of integers whose average is supposed to be computed are assigned
    to an array and an integer pointer is used to access the array elements. A function
    named `findaverage` is defined, to which the integer pointer and the count of
    the numbers are passed. In the function, an assert is used that ensures that the
    pointer is not `NULL`. If the pointer is not `NULL`, the array elements are accessed
    through the pointer and their addition is done. After the addition of the numbers,
    their average is computed. The computed average is then returned to the `main`
    function where the average is displayed on the screen. If the pointer is not pointing
    to the array and is instead pointing to `NULL`, the program will display an error
    and will be aborted.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，通过数组计算了几个整数的平均值。也就是说，将需要计算平均值的整数数量分配给一个数组，并使用一个整数指针来访问数组元素。定义了一个名为`findaverage`的函数，将整数指针和数字的数量传递给它。在函数中，使用断言确保指针不是`NULL`。如果指针不是`NULL`，则通过指针访问数组元素并执行加法。在数字加法之后，计算平均值。然后，将计算出的平均值返回到`main`函数，在屏幕上显示平均值。如果指针没有指向数组而是指向`NULL`，程序将显示错误并终止。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, this means the `assertprog.c` program is
    successfully compiled into a `.exe` file: `assertprog.exe`. Because the pointer
    is pointing to the array while executing the file, we get the average of the numerical
    values specified in the array, as shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下面的截图所示。因为在编译过程中没有出现错误，这意味着`assertprog.c`程序已成功编译成`.exe`文件：`assertprog.exe`。因为执行文件时指针指向数组，所以我们得到数组中指定的数值的平均值，如下面的截图所示：
- en: '![](img/eff14225-a107-4587-b190-6064448afbc4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eff14225-a107-4587-b190-6064448afbc4.png)'
- en: Figure 4.5
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5
- en: 'Next, comment out the following line in which the pointer is pointing to the
    array:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注释掉以下行，其中指针指向数组：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `ptr` pointer now is pointing to `NULL`. Hence, on running the program,
    it will display an error, as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptr`指针现在正指向`NULL`。因此，在运行程序时，它将显示一个错误，如下面的截图所示：'
- en: '![](img/624d22ac-a2ce-443c-b887-c8c630b8c7cf.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/624d22ac-a2ce-443c-b887-c8c630b8c7cf.png)'
- en: Figure 4.6
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6
- en: Voilà! We have successfully used assertions to ensure that our pointer is not
    pointing to `NULL`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用断言确保我们的指针没有指向`NULL`。
- en: Now, let's move on to the next recipe!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Catching errors early with compile-time assertions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编译时断言提前捕获错误
- en: In this recipe, we will make use of assertions to detect errors at the time
    of compilation. Essentially, we will create a structure and will make a compile-time
    assertion that ensures the size of the structure is of some specific bytes. The
    program will abort if the size of the structure is not equal to the specified
    value. This constraint will help in determining the capacity of storage and also
    in the easy maintenance of records, that is, for deletes and updates.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用断言在编译时检测错误。本质上，我们将创建一个结构，并创建一个编译时断言，确保结构的大小是某些特定的字节。如果结构的大小不等于指定的值，程序将终止。这个约束将有助于确定存储容量，也有助于记录的简单维护，即删除和更新。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create a compile-time `assert` expression that ensures
    that the user-defined structure is a specified number of bytes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建编译时`assert`表达式，以确保用户定义的结构是特定字节数：
- en: 'Define a structure with a few members:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含几个成员的结构：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define a compile-time assert that puts a constraint on the size of the structure.
    The program will compile only when the assert is validated, that is, the size
    of the structure is exactly equal to the bytes mentioned in the `assert` expression:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个编译时断言，对结构体的大小施加约束。只有当断言得到验证时，即结构体的大小与 `assert` 表达式中提到的字节数完全相等时，程序才会编译：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the main body of the program, you can write any executable code. This code
    will compile and execute only when the `assert` expression is validated:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序的主体中，你可以编写任何可执行代码。只有当 `assert` 表达式得到验证时，这段代码才会编译并执行：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The program for implementing compile-time validation to ensure that the size
    of a structure is exactly equal to a specific number of bytes is shown in the
    following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实现编译时验证以确保结构体大小正好等于特定字节数的程序如下所示：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A structure is defined by the name `customers`, which consists of a few members.
    The members of the structure are of different data types. A compile-time assert
    is defined that places a constraint on the size of the `customers` structure to
    be of 28 bytes exactly. That means the program will not be compiled if the size
    of the structure is less than or greater than 28 bytes. The `main` function simply
    displays the size of different data types such as `int`, `float`, and `char`.
    The program also displays the size of the complete `customers` structure.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体通过名称 `customers` 定义，它包含几个成员。结构体的成员具有不同的数据类型。定义了一个编译时断言，对 `customers` 结构体的大小施加了28字节的精确约束。这意味着如果结构体的大小小于或大于28字节，程序将无法编译。`main`
    函数简单地显示不同数据类型的大小，例如 `int`、`float` 和 `char`。程序还显示了完整的 `customers` 结构体的大小。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    the size of the `customers` structure is exactly the same as that specified in
    the compile-time assert, the program compiles perfectly and the `compileassert.c`
    program is successfully compiled into a `.exe` file: `compileassert.exe`. On executing
    the file, we get the output showing the size of different data types and that
    of the `customers` structure, as shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用 GCC 编译，如下面的截图所示。因为 `customers` 结构体的大小与编译时断言中指定的完全相同，所以程序编译完美，`compileassert.c`
    程序成功编译成 `.exe` 文件：`compileassert.exe`。在执行文件后，我们得到以下输出，显示了不同数据类型和 `customers` 结构体的大小，如下面的截图所示：
- en: '![](img/7cbaed44-eb2f-4a71-b992-a6a0f7873255.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7cbaed44-eb2f-4a71-b992-a6a0f7873255.png)'
- en: Figure 4.7
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7
- en: 'After changing the value in the `assert` function, that is, if the size of
    the structure does not match the value mentioned in the compile-time assert, we
    get a compilation error as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改 `assert` 函数中的值之后，即如果结构体的大小与编译时断言中提到的值不匹配，我们将得到以下编译错误：
- en: '![](img/52d6a4b4-f1df-48bb-abe4-2f2b92be8de6.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52d6a4b4-f1df-48bb-abe4-2f2b92be8de6.png)'
- en: Figure 4.8
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8
- en: Voilà! We have successfully implemented compile-time assertions to be able to
    catch errors early in the system. Now, let's move on to the next recipe!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功实现了编译时断言，以便能够尽早捕捉到系统中的错误。现在，让我们继续下一个菜谱！
- en: Applying stringize and token-pasting operators
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用字符串化和标记粘贴运算符
- en: The stringize or hash symbol (`#`) can be used in a macro definition to convert
    the macro parameter into a string constant. You can imagine that the parameter
    is enclosed in double quotes and returned. It is also known as a token-concatenation
    operator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串化或哈希符号 (`#`) 可以在宏定义中使用，将宏参数转换为字符串常量。你可以想象参数被双引号包围并返回。它也被称为标记连接运算符。
- en: The token-pasting operator (`##`) combines two parameters when used in a macro
    definition. That is, the two parameters on either side of each `##` operator are
    joined into a single string. More precisely, it performs string concatenation
    on the two parameters to form a new string.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 标记粘贴运算符 (`##`) 在宏定义中使用时将两个参数组合在一起。也就是说，每个 `##` 运算符两侧的参数被连接成一个单独的字符串。更精确地说，它对两个参数执行字符串连接，以形成一个新字符串。
- en: In this recipe, we will learn how to apply stringize and token-pasting operators
    in computing. The user is asked to specify a certain pizza size and their desired
    toppings and, accordingly, the price of the pizza is displayed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在计算中应用字符串化和标记粘贴运算符。用户被要求指定一定的披萨大小和他们的所需配料，相应地，披萨的价格将被显示。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Following these steps to create a recipe that uses stringize and token-pasting
    operators:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个使用`stringize`和`token-pasting`运算符的配方：
- en: 'Define a macro with the name `pizzaprice` using a token-pasting operator:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`token-pasting`运算符定义一个名为`pizzaprice`的宏：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define one more macro with the name `convertIntoStr` using a stringize operator:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串化运算符定义一个名为`convertIntoStr`的宏：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define a few variables such as `smallnormal`, `mediumnormal`, `largenormal`,
    and `smallextra` that represent the price for a pizza of different pizza sizes
    and toppings:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些变量，例如`smallnormal`、`mediumnormal`、`largenormal`和`smallextra`，它们代表不同大小和配料的披萨价格：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The user is asked to enter the pizza size desired by the customer and the size
    entered is assigned to the `pizzasize` variable:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户输入客户想要的披萨大小，输入的大小被分配给`pizzasize`变量：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, the user is asked to specify whether the pizza is desired with normal
    cheese or extra cheese, and the choice entered by the user is assigned to the
    `topping` variable:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，询问用户是否希望披萨有普通奶酪或加奶酪，用户输入的选择被分配给`topping`变量：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, branching is done on the basis of the value of the `topping` variable:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据`topping`变量的值进行分支：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Additionally, the size entered in the `pizzasize` variable is compared to check
    whether the pizza size is small, medium, or large and, accordingly, the arguments
    are passed to the `pizzaprice` macro:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，输入到`pizzasize`变量中的大小与检查比，以确定披萨大小是小型、中型还是大型，并相应地传递参数到`pizzaprice`宏：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `pizzaprice` macro joins the `pizzasize` and `topping` arguments together
    and expands them into a concatenated variable:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pizzaprice`宏将`pizzasize`和`topping`参数连接起来，并将它们扩展为连接变量：'
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, `small` can be replaced by `medium` or `large` depending on the size chosen
    by the user. Additionally, `extra` can be replaced by `normal` if the user wants
    a pizza with normal cheese.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`small`可以根据用户选择的大小替换为`medium`或`large`。此外，如果用户想要普通奶酪披萨，`extra`可以替换为`normal`。
- en: 'The value of the concatenated variable is displayed as the price of the specified
    pizza with the desired toppings:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将连接变量的值显示为指定披萨和所需配料的定价：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The program for applying stringize and token-pasting operators is shown in
    the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用`stringize`和`token-pasting`运算符的程序如下所示：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以便更好地理解它。
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A token-pasting operator is used to define a macro with the name `pizzaprice`.
    This macro concatenates the two `a` and `b` parameters into a single string. In
    addition to this, a stringize operator is used to define a macro with the name
    `convertIntoStr`, which converts the `str` parameter into a string. A number of
    variables are defined, such as `smallnormal`, `mediumnormal`, `largenormal`, and `smallextra`.
    These variables represent the price of a small-sized normal pizza, a medium-sized
    normal pizza, a large-sized normal pizza, and a small-sized pizza with extra cheese,
    respectively. The `normal` suffix declares that this is the price of a pizza with
    a regular amount of cheese. The `extra` suffix indicates that this variable represents
    the price of a pizza with extra cheese.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`token-pasting`运算符定义一个名为`pizzaprice`的宏。此宏将两个`a`和`b`参数连接成一个字符串。此外，使用`stringize`运算符定义一个名为`convertIntoStr`的宏，该宏将`str`参数转换为字符串。定义了多个变量，例如`smallnormal`、`mediumnormal`、`largenormal`和`smallextra`。这些变量分别代表小型普通披萨的价格、中型普通披萨的价格、大型普通披萨的价格和加奶酪的小型披萨的价格。`normal`后缀表示这是含有常规奶酪量的披萨价格。`extra`后缀表示这个变量代表加奶酪披萨的价格。
- en: The user is prompted to enter what pizza size the customer is ordering. The
    size entered is assigned to the `pizzasize` variable. After that, the user is
    asked whether the pizza is desired with normal cheese or extra cheese and the
    choice that is entered is assigned to the `topping` variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提示用户输入客户订购的披萨大小。输入的大小被分配给`pizzasize`变量。之后，询问用户是否希望披萨有普通奶酪或加奶酪，输入的选择被分配给`topping`变量。
- en: Next, branching is done on the basis of the value in the `topping` variable.
    If the topping is normal, the string in `pizzasize` is compared to check whether
    the pizza size is small, medium, or large and, accordingly, the arguments are
    passed to the `pizzaprice` macro. For example, if the user has entered small as
    the pizza size and the topping as extra, the `pizzaprice` macro is invoked with
    two parameters (small and extra). The `pizzaprice` macro, being a token-pasting
    operator, will concatenate the small and extra strings into `smallextra`, and
    hence the value of the `smallextra` variable will be displayed as the price of
    the small-sized pizza with extra cheese as a topping.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据 `topping` 变量的值进行分支。如果配料是正常的，则将 `pizzasize` 中的字符串进行比较，以检查披萨大小是小型、中型还是大型，并相应地传递参数给
    `pizzaprice` 宏。例如，如果用户输入小型作为披萨大小，配料为额外，则 `pizzaprice` 宏将使用两个参数（小型和额外）被调用。`pizzaprice`
    宏作为一个标记粘贴操作符，将小型和额外字符串连接到 `smallextra`，因此 `smallextra` 变量的值将显示为带有额外奶酪配料的中小型披萨的价格。
- en: The `pizzasize` and `topping` variables are combined into a concatenated string,
    and hence will access the value in the respective variable. Finally, the `convertIntoStr`
    macro is invoked, which includes a stringize operator to display a `Thanks for
    visiting us` string at the end of the bill.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`pizzasize` 和 `topping` 变量被合并成一个连接字符串，因此将访问相应变量的值。最后，调用 `convertIntoStr` 宏，该宏包含一个字符串化操作符，在账单末尾显示一个
    `Thanks for visiting us` 字符串。'
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `preconcat.c` program is successfully
    compiled into a `.exe` file: `preconcat.exe`. On executing the file, the user
    will be asked to enter the desired pizza size and toppings and, accordingly, the
    program will display the price of the pizza, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用 GCC 编译，如下面的截图所示。由于编译过程中没有出现错误，`preconcat.c` 程序成功编译成 `.exe` 文件：`preconcat.exe`。执行该文件时，用户将被要求输入所需的披萨大小和配料，相应地，程序将显示披萨的价格，如下面的截图所示：
- en: '![](img/823df427-5c4a-4fd6-b4fa-9e6fb64c8007.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/823df427-5c4a-4fd6-b4fa-9e6fb64c8007.png)'
- en: Figure 4.9
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9
- en: Voilà! We have successfully applied the stringize and token-pasting operators
    and created custom pizza orders.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功应用了字符串化和标记粘贴操作符，并创建了自定义披萨订单。
