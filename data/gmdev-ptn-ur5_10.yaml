- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Optimization through Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过模式进行优化
- en: 'In this last chapter, we are going to discuss the last thing we should think
    about before releasing our games: optimization. Optimization patterns are designed
    to leave our code functioning as it was before but in a faster, more elegant way
    that impacts our hardware less. This chapter is quite wordy, but the underlying
    principles that guide these patterns require a certain understanding of how the
    hardware resources at our disposal work. By the end, we will have covered everything
    from how to help the CPU do its job better to making a system you can plug into
    any game to make it potentially faster at runtime.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将讨论在发布游戏之前我们应该考虑的最后一件事：优化。优化模式旨在让我们的代码在功能上保持不变，但以更快、更优雅的方式运行，对硬件的影响更小。本章内容相当多，但指导这些模式的底层原理需要我们对可用的硬件资源工作方式有一定的理解。到结束时，我们将涵盖从如何帮助CPU更好地工作到创建一个可以插入任何游戏以使其在运行时可能更快运行的系统的所有内容。
- en: 'The patterns making this possible are the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使这成为可能的是以下模式：
- en: '**Dirty Flag**, which focuses on reducing the number of times we need to update
    calculated values.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脏标志**，它专注于减少我们需要更新计算值次数。'
- en: '**Data Locality**, which concerns optimizing the code layout to work with the
    way the CPU’s memory works. As a description, this sounds much more complicated
    than the reality of the application.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据局部性**，这涉及到优化代码布局以适应CPU内存工作方式。作为一个描述，这听起来比应用的现实情况要复杂得多。'
- en: '**Object Pooling**, where we offset as much of the heavy memory allocation
    processing to the start of the game, where it can be excused under a loading screen,
    so as not to impact runtime efficiency.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象池化**，我们将尽可能多的内存分配处理工作推迟到游戏开始时，这样可以在加载屏幕下进行，以免影响运行时效率。'
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Using dirty flags to reduce unnecessary processing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脏标志来减少不必要的处理
- en: How data locality affects code efficiency
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据局部性如何影响代码效率
- en: Object pooling our resources to save time later
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象池化我们的资源以节省后续时间
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The starting point for this chapter can really be from any project, but we
    have a branch of the GitHub repository that carries on from where [*Chapter 9*](B18297_09.xhtml#_idTextAnchor130)
    left off. This provides a set of systems we can integrate with the Object Pooler
    we will be building. You can find this starting point in the [*Chapter 10*](B18297_10.xhtml#_idTextAnchor148)
    branch here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点可以从任何项目开始，但我们有一个GitHub仓库的分支，它从[*第9章*](B18297_09.xhtml#_idTextAnchor130)结束的地方继续。这提供了一套我们可以与将要构建的对象池器集成的系统。您可以在以下[*第10章*](B18297_10.xhtml#_idTextAnchor148)分支中找到这个起点：
- en: '[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter10](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter10)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter10](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter10)'
- en: Using dirty flags to reduce unnecessary processing
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脏标志来减少不必要的处理
- en: Dirty flag involves updating values only when they are needed. The best explanation
    of how it works comes in the context of base-level engine development and the
    transform hierarchy. When you set a local location on a transform, you are indicating
    that you want to be *x*, *y*, and *z* units away from the parent’s location. This
    is easy enough to update, but in doing this, we are also changing the transform’s
    world space location. It is easy to calculate the matrix that will deal with this
    local-to-world space conversion, then multiply our vector by it; that process
    doesn’t even cost many resources. Then, we must remember that this is a hierarchy.
    What if we were moving the root of a tree that is hundreds of transforms deep?
    Not a great position to be in for multiple reasons, but if the parent of a transform
    moves, then the child moves with it, and so on, recursively. This presents a lot
    of world space value transforms that need to be updated every time any parent
    in the tree is changed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 脏标志涉及仅在需要时更新值。关于其工作原理的最好解释出现在基础级引擎开发和变换层次结构中。当你在一个变换上设置局部位置时，你是在表明你想要距离父位置 *x*、*y*
    和 *z* 单位。这很容易更新，但在这样做的同时，我们也在改变变换的世界空间位置。计算处理这种局部到世界空间转换的矩阵很容易，然后我们将我们的向量乘以它；这个过程甚至不耗费很多资源。然后，我们必须记住这是一个层次结构。如果我们移动一个深度达数百个变换的树的根，那将是一个不太好的位置，有多个原因，但如果一个变换的父变换移动，那么子变换也会随之移动，以此类推，递归地。这会带来很多需要更新的世界空间值变换。
- en: To make the utility of dirty flag easier to quantify, we can consider a hypothetical
    situation where we have a hierarchy of transforms that is 100 parent-child connections
    deep. We want to move each of them like they are a chain with a torque ripple.
    Starting at the top of the hierarchy and moving down, at every step, we update
    the position of the transform at that level to a new local location defined by
    some periodic function. With each local update, we also update the local-to-world
    matrix for every transform lower in the hierarchy as they will have moved in world
    space, as shown in *Figure 10**.1*. This would require (101-n) matrix updates
    at each step, which means to move the entire hierarchy of 100 transforms, we will
    end up with the 100th triangular number, which is 5,050\. I think we can safely
    say that’s ridiculous and there has to be a better way. Consider the utility of
    the work done. Why are we updating these transforms? So that something else can
    read its world space location and get an accurate, up-to-date value. Have we read
    the world space location at any point in this algorithm? No. The function for
    setting the local location doesn’t need the world space location. So, do we need
    to update the local to world matrices of these objects? Not until something else
    needs us to or the end of the frame is reached. For the best case, that means
    we could get away with only 100 matrix updates at the very end. That is the purpose
    of the dirty flag pattern.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使脏标志的效用更容易量化，我们可以考虑一个假设的情况，即我们有一个深度为100个父-子连接的变换层次结构。我们想要像链条一样移动它们，每个都带有扭矩波动。从层次结构的顶部开始向下移动，在每一步，我们将该级别的变换位置更新为新定义的局部位置，该位置由某个周期函数确定。随着每个局部更新的进行，我们也会更新层次结构中每个较低变换的局部到世界矩阵，因为它们将在世界空间中移动，如图
    *图10*.1 所示。这将需要每一步进行 (101-n) 个矩阵更新，这意味着要移动整个100个变换的层次结构，我们将得到第100个三角数，即5,050。我认为我们可以安全地说这是荒谬的，肯定有更好的方法。考虑所做工作的效用。我们为什么要更新这些变换？为了让其他东西能够读取其世界空间位置并获得准确、最新的值。我们在算法的任何点上读取过世界空间位置吗？没有。设置局部位置的函数不需要世界空间位置。那么，我们需要更新这些对象的局部到世界矩阵吗？不是直到其他东西需要我们这样做，或者帧结束时。在最佳情况下，这意味着我们可以在最后只进行100次矩阵更新。这就是脏标志模式的目的。
- en: '![Figure 10.1 – Diagram showing a local location change affecting the world
    space location of its child](img/Figure_10.01_B18297.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 展示局部位置变化影响其子变换世界空间位置的图](img/Figure_10.01_B18297.jpg)'
- en: Figure 10.1 – Diagram showing a local location change affecting the world space
    location of its child
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 展示局部位置变化影响其子变换世界空间位置的图
- en: Now, let’s look at the application of dirty flags.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看脏标志的应用。
- en: Application of dirty flags
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脏标志的应用
- en: In practice, this whole pattern is just a Boolean value; when the object is
    considered *dirty*, the Boolean is one value, and when it is *clean*, it is the
    other. Which way around that is doesn’t matter, as long as it’s consistent with
    the naming. An object is dirty if it has pending changes that still need to be
    made to the values it represents. In our example, we postpone the local-to-world
    matrix update until something requests the matrix or the end of the frame is reached.
    During the time between the change to the local location and the matrix update,
    the transform is considered dirty.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，整个模式只是一个布尔值；当对象被认为是“脏”时，布尔值是一个值，当它是“干净”时，它是另一个值。哪种方式是反的并不重要，只要它与命名保持一致。一个对象是脏的，如果它有尚未完成的更改，这些更改需要应用到它所表示的值上。在我们的例子中，我们推迟局部到世界矩阵的更新，直到有人请求矩阵或帧末到达。在局部位置更改和矩阵更新之间的这段时间里，变换被认为是脏的。
- en: The mechanics of how this is dealt with then extend beyond the Boolean value.
    On raising a dirty flag, that object is added to a relevant static dirty list
    of objects. For our transform, that means it, and all the transforms below it
    in the hierarchy, will be added recursively to a static list of other dirty transforms.
    We then have some cleaning function that describes how to go from a dirty state
    to a clean state. With the transform, that would be a function that calculates
    the updated local-to-world matrix.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种问题的机制超出了布尔值。在设置一个脏标志时，该对象会被添加到一个相关的静态脏对象列表中。对于我们的变换，这意味着它以及它在层次结构中下面的所有变换都会递归地添加到另一个静态的脏变换列表中。然后我们有一个清理函数，它描述了如何从脏状态转换到干净状态。对于变换来说，这将是计算更新后的局部到世界矩阵的函数。
- en: That example is only something you’d have to be worried about if you were designing
    your own engine, but the dirty flag pattern can be applied to great effect anywhere
    you have a value that may be updated several times before it is needed. You can
    find this pattern in `destroy` command, which marks actors for destruction at
    the end of the frame due to the trickle-down effects of removing them. There will
    be cases where you are storing data that needs to be displayed to the UI and the
    dirty flag pattern can reduce the number of times you tell the UI to update per
    frame; it should only happen once at most per frame.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那个例子只有在设计自己的引擎时才需要担心，但脏标志模式可以应用于任何可能需要更新多次的值。你可以在`destroy`命令中找到这个模式，该命令在帧末标记演员进行销毁，这是由于移除它们时的级联效应。将会有一些情况，你需要存储需要显示给UI的数据，而脏标志模式可以减少每帧告诉UI更新的次数；它最多每帧只应该发生一次。
- en: Next, we’ll go deeper, from a one-variable pattern to a guiding principle of
    optimization that we can apply anywhere.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更深入地探讨，从单变量模式到一个我们可以应用于任何地方的优化指导原则。
- en: How data locality affects code efficiency
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据局部性如何影响代码效率
- en: This is a simple concept that requires very little to implement. We all actively
    think about how variables take up memory. We tend to forget that instructions
    also take up memory. They must be loaded from storage into faster memory, then
    into the CPU to be executed. CPUs try to make things run quicker by leveraging
    the fact that they have very fast, very small storage within them called the cache.
    The cache allows the CPU to pre-load instructions ready for execution and store
    its state in case of temporary context switching. This pre-loading behavior is
    necessary for the CPU to run at its most efficient as while there has been a technology
    race in CPU speeds, that hasn’t been mirrored in the world of RAM. You might be
    able to store massive programs entirely in your RAM but the bus speed of the motherboard
    limits how many instructions can be sent to the CPU per second. When we reach
    the bottleneck, it doesn’t matter how fast the CPU cores are at calculating results,
    as they would spend most of their time idle, waiting for instruction. Pre-loading
    provides a mechanism that has the potential to fix this by sending large chunks
    of instructions to the CPU cache for processing. We say *potential to fix* as
    when pulling instructions from RAM, there is no way of knowing which instructions
    will be next. That information is in the instruction daisy chain and can only
    be accessed once the work is done. This means that the contents of the CPU cache
    are entirely dictated by the geography of our system architecture.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的概念，实现起来所需很少。我们都会积极思考变量如何占用内存。我们往往忘记指令也会占用内存。它们必须从存储中加载到更快的内存中，然后进入CPU执行。CPU通过利用它们内部非常快、非常小的存储（称为缓存）来尝试使事物运行得更快。缓存允许CPU预先加载即将执行的指令，并在临时上下文切换的情况下存储其状态。这种预先加载行为对于CPU以最高效的方式运行是必要的，因为虽然CPU速度的技术竞赛一直在进行，但在RAM的世界中并没有得到相应的反映。你可能能够将庞大的程序完全存储在RAM中，但主板的总线速度限制了每秒可以发送到CPU的指令数量。当我们达到瓶颈时，CPU核心的计算速度有多快并不重要，因为它们会花费大部分时间空闲，等待指令。预先加载提供了一种机制，有可能通过将大量指令发送到CPU缓存进行处理来解决这个问题。我们说“有可能解决”是因为在从RAM中提取指令时，无法知道下一个指令是什么。这些信息在指令菊花链中，只有当工作完成时才能访问。这意味着CPU缓存的全部内容完全由我们系统架构的地域性决定。
- en: That’s lots of technical terms, so let’s explain it with an analogy. Imagine
    working in a factory where your job is to build flatpack furniture. You’re really
    fast at your job when you have the materials and can put together each piece lighting
    fast. The catch is, you can only see one instruction at a time, and when you need
    pieces, you must request them from a porter. These resources, such as panels and
    screws, are stored in a warehouse miles away. When you request something, the
    porter spends a day traveling to and from the warehouse, which means you can only
    get one instruction completed per day regardless of how fast you work. Most of
    your time is spent staring at the wall. In this example, you are the CPU, executing
    instructions, and the porter is the data bus, ferrying instructions from RAM to
    be executed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多技术术语，所以让我们用一个类比来解释它。想象一下在一个工厂工作，你的工作是组装平板家具。当你有材料并且可以快速组装每个部件时，你工作得非常快。但是，你一次只能看到一条指令，当你需要部件时，你必须向搬运工请求。这些资源，如面板和螺丝，存储在几英里外的仓库中。当你请求某物时，搬运工需要一天的时间来回旅行，这意味着无论你工作得多快，你每天只能完成一条指令。你大部分的时间都在盯着墙看。在这个例子中，你是CPU，正在执行指令，而搬运工是数据总线，负责将指令从RAM运送到执行。
- en: One day, a new manager is brought in who decides to revamp the process. They
    change the material request process so that now, when the porter gets the required
    item, they also get everything else within arm’s reach. This bundle of screws
    and panels is then dumped on the ground in your workstation. In real terms, we
    call this the CPU cache, a tiny amount of extremely fast memory within the CPU.
    The benefit of this is that when you get your next instruction, there is a chance
    you already have the required materials next to you. If not, then all the materials
    need to be taken back and a new bunch collected. It then stands to reason that
    if the warehouse is organized so that materials that are often requested together
    are placed near each other, the porter is more likely to take the correct materials
    for the next instruction as well. Nothing needs to change about the porter’s knowledge
    of the situation or skills, simply proper planning at the start to achieve an
    efficient outcome.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，一位新经理被引入并决定改革流程。他们改变了物料请求流程，现在当搬运工拿到所需物品时，他们也会得到所有触手可及的其他物品。这堆螺丝和面板随后被扔在你的工作站地上。在实际情况中，我们称之为CPU缓存，这是CPU内部的一小块极快内存。这种做法的好处是，当你获取下一个指令时，你有可能已经拥有了所需的材料。如果没有，那么所有材料都需要被取回，并收集新的材料。因此，如果仓库被组织得使得经常一起请求的材料放置在一起，搬运工更有可能为下一个指令取到正确的材料。搬运工对情况的了解或技能不需要有任何改变，只需在开始时进行适当的规划，以实现高效的结果。
- en: As programmers, we can be the warehouse manager in that example, making sure
    that the data a function requires is physically close to that function so that
    when the CPU request for resources comes in, the cache is more likely to fill
    with useful data. When the CPU can execute from the cache, that is called a cache
    hit. Likewise, when the data needs to be requested, that is a cache miss. We want
    to achieve as many cache hits as possible to reduce the number of times the cache
    needs to be refilled. The gains from achieving high levels of cache hits are surprising;
    sometimes, they can be up to 50 times faster due to organizing data effectively.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们可以在那个例子中扮演仓库经理的角色，确保函数所需的数据在物理上靠近该函数，以便当CPU请求资源时，缓存更有可能填充有用数据。当CPU可以从缓存中执行时，这被称为缓存命中。同样，当需要请求数据时，这被称为缓存未命中。我们希望尽可能多地实现缓存命中，以减少缓存需要重新填充的次数。实现高缓存命中的收益是惊人的；有时，由于有效地组织数据，它们可以快上50倍。
- en: We’re going to have a look at two methods for implementing data locality as
    a principle but there are doubtless others that, now that you understand the problem,
    will make more sense as implementations. Let’s look at the two methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨两种实现数据局部性原则的方法，但毫无疑问，一旦你理解了这个问题，还会有其他方法在实现上更加合理。让我们来看看这两种方法。
- en: Hot/cold splitting
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热冷分割
- en: The first technique is very similar to how the type object pattern from [*Chapter
    9*](B18297_09.xhtml#_idTextAnchor130) needed to consider implicit and explicit
    data, but instead of thinking about what the values are defining, we look at how
    frequently they are accessed. The go-to example of this would be an NPC in a game
    with loot drops. The NPC’s health is accessed regularly as they heal and take
    damage over their life cycle, whereas the loot table, which describes what items
    they drop on, is accessed once at the end of the object’s life. We can classify
    the frequently accessed data as hot; this can stay in the object as member variables.
    The more single-use data, such as loot tables, is then marked as cold and separated
    off into a struct, held inside the object as a pointer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术非常类似于在[*第9章*](B18297_09.xhtml#_idTextAnchor130)中提到的类型对象模式需要考虑隐式和显式数据，但不是思考这些值定义了什么，而是观察它们被访问的频率。这个例子中最好的例子可能是一个游戏中带有掉落物品的非玩家角色（NPC）。NPC的健康值在其生命周期中会定期被访问，因为它们会治疗和受到伤害，而描述它们掉落物品的物品表只在对象生命周期的末尾被访问一次。我们可以将频繁访问的数据分类为“热”数据；这些数据可以作为成员变量保留在对象中。而像物品表这样的单次使用数据，则标记为“冷”数据，并分离到一个结构体中，作为指针存储在对象内部。
- en: Why do all this? It has to do with the size of the object when being pulled
    into the cache. When the object is pulled in, all data it directly contains makes
    up the amount of space it takes up in the cache. That means that all pointers
    effectively only take up the space of `uint64_t`. The data they point to is not
    necessarily loaded until it is directly accessed, as it is declared physically
    elsewhere, hence the pointer. Without separating our hot and cold data, as we
    described previously, our class takes up more cache memory than is necessary with
    data that is unlikely to be needed, increasing the chance of a cache miss.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么做所有这些？这与对象被拉入缓存时的大小有关。当对象被拉入缓存时，它直接包含的所有数据构成了它在缓存中占据的空间量。这意味着所有指针实际上只占据`uint64_t`的空间。它们指向的数据不一定在直接访问之前被加载，因为它们在物理上声明在其他地方，这就是指针的原因。如果没有像我们之前描述的那样分离我们的热数据和冷数据，我们的类将占用比必要的更多缓存内存，这增加了缓存未命中的可能性。
- en: Contiguous arrays
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连续数组
- en: 'The second technique is using contiguous arrays of data. We know that there
    are two types of memory: stack and heap. Data locality is the main reason why
    stack memory is considered faster. Everything in the stack has been defined before
    the program runs and so it is neatly organized. Arrays of data are held in the
    stack and are defined together in one continuous line. This makes the CPU cache
    more efficient when looping over these elements as they have been stored physically
    closer to one another. This is part of the reason why data-oriented ECS is faster,
    as discussed back in [*Chapter 4*](B18297_04.xhtml#_idTextAnchor057). However,
    dynamic collections and pointers are declared in heap memory at runtime. We sacrifice
    that benefit of efficiency for the flexibility of defining data at a later point.
    Data on the heap uses whatever free space is available and because of this may
    end up defining multiple objects large distances from each other. *Figure 10**.2*
    shows visually how storing an array of values instead of an array of pointers
    can make a difference to what is loaded into the cache. This is a concept to keep
    in mind when we implement an object pool later in this chapter. When we spawn
    objects, they are held as `TObjectPtrs` in a `TArray`. Could this array be made
    into a standard C++ array? What dynamic property would we have to sacrifice to
    do this? It would likely be dynamic sizing, but do you need that in your context?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术是使用连续的数据数组。我们知道有两种内存类型：栈和堆。数据局部性是栈内存被认为更快的主要原因。栈中的所有内容在程序运行之前都已定义，因此组织得井井有条。数据数组存储在栈中，并在一条连续的行中定义。这使得在循环遍历这些元素时，CPU缓存更加高效，因为它们在物理上存储得更近。这是数据导向的ECS更快的一部分原因，正如在[*第4章*](B18297_04.xhtml#_idTextAnchor057)中讨论的那样。然而，动态集合和指针在运行时声明在堆内存中。我们为了在稍后定义数据的灵活性而牺牲了效率。堆上的数据使用可用的任何空闲空间，因此可能最终定义多个彼此距离较远的大型对象。*图10.2*展示了将值数组而不是指针数组存储在内存中可以如何影响加载到缓存中的内容。这是我们在本章稍后实现对象池时需要记住的概念。当我们生成对象时，它们被作为`TObjectPtrs`存储在`TArray`中。这个数组能否被转换成标准的C++数组？我们为了这样做需要牺牲哪些动态属性？这很可能是动态大小，但你的上下文中需要这个吗？
- en: '![Figure 10.2 – Possible layout of an array of pointers versus an array of
    values in memory](img/Figure_10.02_B18297.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 内存中指针数组与值数组的可能布局](img/Figure_10.02_B18297.jpg)'
- en: Figure 10.2 – Possible layout of an array of pointers versus an array of values
    in memory
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 内存中指针数组与值数组的可能布局
- en: 'So, is the solution to just use arrays of data all the time? Well, no. There
    are many situations where pointers and dynamic collections are still necessary
    within object-oriented programming. This is more a point to consider their usage,
    and if you can replace a dynamic collection with a static array, then do so. This
    point is especially important to remember in our last pattern of the book coming
    up next: Object Pooling.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，解决方案是不是总是使用数据数组呢？嗯，不是的。在面向对象编程中，有许多情况下仍然需要指针和动态集合。这更多的是一个考虑它们的使用的问题，如果你可以用静态数组替换动态集合，那么就替换。这一点在我们接下来要讨论的本书的最后一个模式中尤为重要：对象池。
- en: Object pooling our resources to save time later
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将资源池化以节省后续时间
- en: 'The last pattern we are discussing in this book is object pooling. This pattern
    aims to tackle one of the core problems with the CPU: allocating and deallocating
    memory is a slow process. Every time you spawn a new actor, the space it needs
    in memory must be reserved in the right subdivisions for each variable and handed
    back to the game process ready to receive data. Every time you delete an actor,
    that memory must be freed from all references and returned to the heap. For something
    such as a minigun spawning 3,000 projectiles per minute, that means a lot of allocation
    of the chunks for memory, which are all the same size. Object pooling is the practice
    of predicting this massive cost and offsetting it to a place where the lag it
    causes is not so noticeable. This for us means spawning all the projectiles we
    could possibly need at the start of the game and hiding them. When one is required,
    it is taken from the shelf of deactivated projectiles, teleported to the right
    position, and activated. Then, to preserve the pool’s integrity, when it would
    have been destroyed, it is simply deactivated and returned to the shelf with the
    other pooled items. Although this pattern does make the one frame when the level
    has just loaded much worse, as we are spawning all the projectiles at once, we
    can disguise this under a loading screen. This offset can dramatically increase
    the processing speed during hectic gameplay sequences when there would have been
    a lot of spawning and destroying occurring. Our pool then stays active until the
    end of the level when all objects are destroyed together, again under a loading
    screen.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本书讨论的最后一种模式是对象池。这种模式旨在解决CPU的一个核心问题：分配和释放内存是一个缓慢的过程。每次生成一个新的actor时，它所需的内存空间必须在每个变量的正确子分区中预留，并返回给游戏进程以接收数据。每次删除一个actor时，必须从所有引用中释放该内存，并将其返回到堆中。对于像每分钟发射3,000发子弹的迷你炮这样的东西，这意味着大量的内存块分配，这些块都是相同的大小。对象池的做法是预测这种巨大的成本，并将其转移到导致延迟不那么明显的位置。对我们来说，这意味着在游戏开始时生成我们可能需要的所有子弹，并将它们隐藏起来。当需要时，它从已停用的子弹架上取下，传送到正确的位置，并激活。然后，为了保持池的完整性，当它本应被销毁时，它只是被停用并返回到与其他池化项目一起的架子上。尽管这种模式确实会使关卡刚刚加载时的那一帧变得更糟，因为我们一次性生成了所有子弹，但我们可以在加载屏幕下掩盖这一点。这种偏移可以在紧张的游戏玩法序列中显著提高处理速度，在这些序列中会有大量的生成和销毁发生。然后，我们的池保持活跃，直到关卡结束，所有对象一起被销毁，再次在加载屏幕下。
- en: With the theory covered, let’s make some object pools.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 理论讲解完毕后，让我们来创建一些对象池。
- en: Implementing object pooling
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现对象池
- en: There are a few ways we could look at implementing this and, realistically,
    if it works to spawn the objects you need in a place where you can access them,
    then it is the best method for you. The implementation options are as a world
    subsystem, level actor component, game mode component, or floating actor in the
    level.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几种方式来看待实现这一点，并且从现实的角度来看，如果它能在你可以访问它们的地方生成所需的对象，那么这就是对你来说最好的方法。实现选项包括作为世界子系统、关卡actor组件、游戏模式组件或在关卡中的浮动actor。
- en: World subsystem
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 世界子系统
- en: 'Subsystems are Unreal’s effort at implementing a standardized form of the singleton
    pattern we covered in [*Chapter 8*](B18297_08.xhtml#_idTextAnchor113) with limited
    scope. This form it takes means that we can make an almost static class that we
    know will exist for the lifetime of whatever it is attached to. Subsystems are,
    however, not well protected with regard to access as anything with reference to
    their attached object can call functions on them. This is why they tend to be
    used for hidden logic behavior systems that run regardless of interaction. This
    results in most of the public functions on them being getters to get the state
    of something they are processing. There are five levels of subsystem that exist.
    Let’s describe them in order of decreasing lifetime:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 子系统是虚幻引擎实现我们已在[*第8章*](B18297_08.xhtml#_idTextAnchor113)中介绍的单例模式标准化形式的一种尝试，其作用范围有限。这种形式意味着我们可以创建一个几乎静态的类，我们知道它将存在于它所附加的任何事物的生命周期内。然而，子系统在访问方面并没有得到很好的保护，因为任何与它们附加的对象相关的都可以调用它们上的函数。这就是为什么它们倾向于用于无论交互与否都会运行的隐藏逻辑行为系统。这导致它们上的大多数公共函数都是获取器，用于获取它们正在处理的事物的状态。存在五种子系统级别。让我们按生命周期递减的顺序来描述它们：
- en: '**Engine**: Exists in both the editor and the game for the length of the executable
    running.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引擎**：存在于编辑器和游戏运行期间。'
- en: '**Editor**: Runs as an editor tool and will not build with the game.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器**：作为编辑器工具运行，不会与游戏一起构建。'
- en: '`UGameInstance` and so exists for the play session while the executable is
    running. Only one instance can exist at a time.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UGameInstance` 存在于可执行文件运行期间的游戏会话中。同一时间只能存在一个实例。'
- en: '`ULocalPlayer` it is attached to and moves between levels in the same way.
    There is one instance per local player.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ULocalPlayer` 是与之关联并在不同级别之间移动的对象。每个本地玩家都有一个实例。'
- en: '`UWorld` it is attached to. There is one instance per `UWorld` that is currently
    loaded.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UWorld` 是与之关联的。每个当前加载的`UWorld`都有一个实例。'
- en: It is important to consider the scope of the system being created and match
    it to the parent that best describes its lifetime. For an object pooler, this
    would be a world subsystem as any objects spawned in a pool will exist within
    a world so when that world is unloaded, they will be too. If the system was made
    as a local player subsystem, this would break references when changing maps and
    possibly spawn items in menu worlds where they are unnecessary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑正在创建的系统的范围并将其与最佳描述其生命周期的父类匹配是很重要的。对于一个对象池器，这将是世界子系统，因为任何在池中生成的对象都将存在于世界中，所以当世界卸载时，它们也会被卸载。如果系统被制作为一个本地玩家子系统，那么在更改地图时可能会破坏引用，并在菜单世界中生成不必要的物品。
- en: LevelScriptActor child
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LevelScriptActor子类
- en: The `ALevelScriptActor` is what people know on the blueprint side as the level
    blueprint. It provides a place for level-specific code to execute. This can be
    useful for tutorials where the mechanics are built badly in order to introduce
    them slowly, or for map-based mechanics, such as the “Levolutions” in Battlefield
    4, where each map has the ability to completely change if different conditions
    are met. What isn’t advertised very well in the Unreal documentation is that we
    can change the level blueprint in the C++ layer. Simply create a new C++ child
    of `ALevelScriptActor` and add your code here. This new child can be where we
    set up systems for object pooling as the `ALevelScriptActor` exists in a hidden
    state for as long as our world exists and has easy access to anything else within
    the world outliner for that particular map. The downside of this is that every
    new map created in the editor comes with a level blueprint that already inherits
    from the base `ALevelScriptActor` class. This means every new map would have to
    have its level blueprint manually reparented to your custom C++ type, which could
    lead to a lot of admin with easily missable steps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALevelScriptActor` 是在蓝图侧人们所熟知的级别蓝图。它为特定级别的代码执行提供了一个位置。这在教程中很有用，因为可以通过这种方式逐步介绍机制，或者用于基于地图的机制，例如《战地4》中的“Levolutions”，其中每个地图都有能力在满足不同条件时完全改变。在虚幻引擎的文档中并没有很好地宣传的是，我们可以在C++层更改级别蓝图。只需创建一个`ALevelScriptActor`的新的C++子类，并将代码添加到这里。这个新的子类可以用来设置对象池系统，因为`ALevelScriptActor`存在于一个隐藏状态，只要我们的世界存在，并且可以轻松访问特定地图的世界大纲中的任何其他内容。这种方法的缺点是，在编辑器中创建的每个新地图都附带一个已经从基础`ALevelScriptActor`类继承的级别蓝图。这意味着每个新地图都必须手动将级别蓝图重新关联到自定义的C++类型，这可能导致大量的管理任务，并且容易遗漏步骤。'
- en: Game mode component
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏模式组件
- en: The game mode is a class that is guaranteed to be in every level, so there is
    the option to make the object pooler an actor component that is attached to it,
    or consolidate the behavior into the game mode inheritance hierarchy with a custom
    pooling game mode, which innately has the logic for running an object pool built
    in. This approach would require some diligence on the part of the designers as
    making a new level or prototyping a new game mode would require the component
    to be added or the correct parent to be selected; but it would make the implementation
    easy seeing as it is collected in one place and self-contained within an easily
    accessible system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式是一个在每个级别中都保证存在的类，因此可以选择将对象池器制作为一个附加到它的演员组件，或者将行为整合到游戏模式继承层次结构中，使用自定义的池化游戏模式，这种模式内建了运行对象池的逻辑。这种方法要求设计师要细心，因为创建新的级别或原型设计新的游戏模式时，需要添加组件或选择正确的父类；但鉴于它集中在一个易于访问的系统内，并且是自包含的，实现起来会变得简单。
- en: Floating actor
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮动演员
- en: 'The last method of getting an object pooler to work is the simplest but least
    elegant solution: making it into an actor that you spawn into the level. The benefit
    of this is you can easily have multiple object pools for different things or segregate
    your object pools by area if you are dealing using world partition, the system
    we discussed back in [*Chapter 3*](B18297_03.xhtml#_idTextAnchor046). The setup
    is also simple as all the GUI for setting it up is collected into the details
    panel for that object pool. The reason we call this method inelegant is down to
    how it must be managed. With there being no central method for referencing it
    or making sure the required functions have been called, it leaves a lot up to
    the end user and therefore is error prone.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 获取对象池器工作的最后一种方法是简单但不太优雅的解决方案：将其制作成一个actor，并将其实例化到关卡中。这种方法的优点是你可以轻松地为不同的事物拥有多个对象池，或者如果你在使用世界分区（我们在[*第3章*](B18297_03.xhtml#_idTextAnchor046)中讨论过的系统）处理时，可以根据区域隔离你的对象池。设置也很简单，因为所有用于设置的GUI都收集在那个对象池的详细信息面板中。我们之所以称这种方法为不优雅，是因为它必须如何管理。由于没有中央方法来引用它或确保已调用所需的函数，这给最终用户留下了很多工作，因此容易出错。
- en: Making an object pool
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象池
- en: Before we start, the object pooling pattern is probably the most useful pattern
    to have in a plugin that we can take between projects. So, anything we make here
    should probably be done as part of a new plugin, which we can make within rider
    using the right-click menu on the game project. Simply select `ObjectPooler`.
    Then, just be sure to add new classes for the object pooler under the new folder
    this creates in the **Source** directory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，对象池模式可能是我们在插件中拥有的最有用的模式之一，我们可以将其应用于不同的项目。因此，我们在这里创建的任何内容都应该作为新插件的一部分来完成，我们可以在Rider中使用游戏项目的右键菜单创建这个新插件。只需简单地选择`ObjectPooler`。然后，确保在创建的**源**目录下的新文件夹中添加用于对象池的新类。
- en: '![Figure 10.3 – Screenshot of the plugin creation process within Rider](img/Figure_10.03_B18297.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – Rider中插件创建过程的截图](img/Figure_10.03_B18297.jpg)'
- en: Figure 10.3 – Screenshot of the plugin creation process within Rider
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – Rider中插件创建过程的截图
- en: 'Our first step is to make the struct that will define the attributes of a single
    type of pool. The code for this is presented next, but let’s explain some of the
    key points. First, the `BlueprintType` property in the `USTRUCT` block, in combination
    with the `EditAnywhere` property specifiers, will allow the end user to change
    the pool behavior in the editor. There is also the constructor, which must give
    every property a value as a struct cannot be a `nullptr` in memory. Saving the
    `_ActorName` variable as an `FString` is done to make debugging easier, but if
    you prefer to save it as an `FName`, that works and will save some processing
    when the pool is warming up:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建一个结构体，它将定义单个类型池的属性。下面的代码展示了这一点，但让我们解释一些关键点。首先，`USTRUCT`块中的`BlueprintType`属性，结合`EditAnywhere`属性指定符，将允许最终用户在编辑器中更改池的行为。还有一个构造函数，它必须为每个属性提供一个值，因为结构体在内存中不能是`nullptr`。将`_ActorName`变量保存为`FString`是为了使调试更容易，但如果你更喜欢将其保存为`FName`，这也是可以的，并且当池预热时可以节省一些处理时间：
- en: PooledObjectData.h struct
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: PooledObjectData.h 结构体
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we’ll turn our attention to the component that will be on every object
    that came from the pool. We use an actor component instead of making a new child
    of `AActor` that must then be inherited from as it provides a clean separation
    between the object existing and doing what it needs to and the hook that attaches
    it back to the pool it came from. With this setup, we can dynamically spawn the
    component at runtime and attach it to the object when it joins the pool, keeping
    reference only to the component. This should make the pool totally class agnostic,
    improving its versatility.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注每个来自池的对象上都会有的组件。我们使用actor组件而不是创建`AActor`的新子类，因为这样必须从它继承，因为它在对象存在和执行所需操作以及将其附加回来源池的钩子之间提供了清晰的分离。在这种设置下，我们可以在运行时动态地实例化组件并将其附加到对象上，同时只保留对组件的引用。这应该使池完全不受类限制，提高其通用性。
- en: 'Elements to note in the following class definition would be the custom initializer
    function allowing us to set the component up properly (more on that when we get
    to the object pool side) and the `BlueprintCallable` function used to recycle
    the actor. The recycle function is to be used instead of the standard `Destroy`
    on the actor as it will return its owning actor to the pool it came from. A useful
    extension you might want to add here would be to save the index of the pool it
    is supposed to return to. This will save some string comparisons later:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下类定义中需要注意的元素包括允许我们正确设置组件的自定义初始化函数（当我们到达对象池方面时会有更多关于这个的讨论）以及用于回收actor的`BlueprintCallable`函数。回收函数应该用于替代actor上的标准`Destroy`操作，因为它会将拥有actor返回到它原来的池中。你可能想要添加的一个有用扩展是保存它应该返回到的池的索引。这将节省一些后续的字符串比较：
- en: PooledObject.h
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PooledObject.h
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The implementation of these functions is then very simple as most of the logic
    will be run in the pool itself. The only interesting point of note here is the
    `OnComponentDestroyed` override. This function removes the `RecycleSelf` function
    as a listener to a delegate on the pooler as a safety in case the pooler functionality
    is ignored, and the object is deleted in error:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的实现非常简单，因为大部分逻辑将在池本身中运行。这里值得注意的唯一有趣点是`OnComponentDestroyed`重写。这个函数移除了`RecycleSelf`函数作为池管理器的委托监听者，作为一个安全措施，以防池管理器功能被忽略，对象被错误删除：
- en: PooledObject.cpp
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PooledObject.cpp
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now for the main event, the object pool itself. Breaking down the definition,
    we start with a new delegate type with no arguments. This exists as a tether for
    each of the objects taken from the pool. If we need to recall them due to a level
    change, we can broadcast this delegate to recycle all active objects. We then
    have the definition of a new struct type. This only exists as a workaround for
    the fact that the template collections inside Unreal do not cater to multi-dimensional
    arrays. We would like to store an array of pools that in themselves are arrays.
    So, to get around this limitation, we define a new struct type that will hold
    all the objects we consider to be a part of one pool:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是主要事件，对象池本身。分解定义，我们从一个没有参数的新委托类型开始。这个委托作为从池中取出的每个对象的连接。如果我们需要因为关卡变化而召回它们，我们可以广播这个委托来回收所有活动对象。然后我们有新结构体类型的定义。这个结构体只存在作为解决Unreal内部模板集合不适用于多维数组的事实。我们希望存储一个池的数组，而这些池本身也是数组。因此，为了克服这个限制，我们定义了一个新的结构体类型，它将包含我们认为是单个池一部分的所有对象：
- en: ObjectPool.h excerpt part 1
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ObjectPool.h摘录部分1
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next is the object pooler class. An exception to the rule, we don’t mark this
    as abstract. The reason for this is this actor just needs to exist. There is no
    need for any visual elements and so it can exist entirely on the C++ side, calling
    back to our separation rules for establishing the fuzzy layer in [*Chapter 1*](B18297_01.xhtml#_idTextAnchor016).
    The API includes functions for broadcasting the cleanup delegate, getting an object
    from the pool, and two methods for returning an object to the pool with either
    a `UPooledObject` component reference or a straight `AActor` reference. We’ll
    go over why there are two later in the definitions. In the protected section,
    we need a `BeginPlay` override, an array of the data about the pools marked as
    `EditAnywhere` for designers to use the tool, and an array of the struct we made
    earlier to store a reference to every object this pool spawns. You could make
    this simpler by having a different object pool per object type, but that creates
    more actors than is necessary in the scene. Lastly, there is a private function
    for regenerating objects that have been deleted, leaving holes in the pool:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对象池器类。这是规则的例外，我们并没有将其标记为抽象类。原因在于这个actor只需要存在。没有必要任何视觉元素，因此它完全可以在C++端存在，回调到我们为在[*第一章*](B18297_01.xhtml#_idTextAnchor016)中建立模糊层而设定的分离规则。API包括广播清理委托、从池中获取对象以及两种将对象返回池的方法，一种是通过`UPooledObject`组件引用，另一种是直接通过`AActor`引用。我们将在定义中稍后解释为什么有两种方法。在受保护部分，我们需要一个`BeginPlay`重写，一个标记为`EditAnywhere`的池数据数组，以便设计师使用工具，以及一个存储这个池产生的每个对象引用的我们之前创建的结构体数组。你可以通过为每种对象类型创建不同的对象池来简化这一点，但这会在场景中创建不必要的actor。最后，还有一个用于再生已被删除并留下空缺的对象的私有函数：
- en: ObjectPool.h excerpt part 2
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ObjectPool.h摘录部分2
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With everything declared, we can move on to the definitions of our functions.
    To start, we have the `broadcast` function, which works as its name suggests,
    and the `BeginPlay` override for *warming up* the pool by spawning all the requested
    objects. Each pool iterates over the predefined number of times spawning new actors
    in the world. The code here names them and crucially adds an instance of the `UPooledObject`
    component to them. Having the pooler add this component dynamically means that
    the person who developed the actor being pooled didn’t need to know this was going
    to be added as a pooled class. This implementation uses `NewObject<>`, `RegisterComponent`,
    and `AddInstanceComponent` to create and add the component to the new actor as
    we are in runtime, and we would like to see the component in the actor details
    panel for debugging purposes. The new component needs its initialization function
    running before we hide it from view, disable its collision, and stop it from executing:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一切声明完毕后，我们可以继续到函数的定义。首先，我们有`broadcast`函数，正如其名所示，以及用于通过生成所有请求的对象来预热池的`BeginPlay`重写。每个池都会遍历预定义的次数，在世界上生成新的演员。这里的代码给它们命名，并关键地给它们添加一个`UPooledObject`组件的实例。让池动态添加此组件意味着开发被池化的演员的人不需要知道这将作为一个池化类被添加。这种实现使用`NewObject<>`、`RegisterComponent`和`AddInstanceComponent`在运行时创建并添加组件到新演员，我们希望为了调试目的在演员详细信息面板中看到该组件。新组件需要在我们将它从视图中隐藏、禁用其碰撞并停止其执行之前运行其初始化函数：
- en: ObjectPool.cpp excerpt part 1
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ObjectPool.cpp摘录部分1
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The method for getting an object from the pool has been made with an FString
    argument to make it as foolproof as possible, but it is advised that you establish
    an enum type that can be used to reference the pools as indexes. In its current
    form, it goes through a few steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 获取池中对象的方法定义了一个FString参数，使其尽可能无懈可击，但建议您建立一个枚举类型，可以用来引用池作为索引。在其当前形式中，它经过几个步骤：
- en: Finds the index of the pool that matches the input string, returning `out` if
    one isn’t found.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找与输入字符串匹配的池的索引，如果没有找到，则返回`out`。
- en: 'Loops through the objects in the found pool to find the next object, which
    is marked as inactive:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在找到的池中循环遍历对象以找到下一个对象，该对象被标记为非活动状态：
- en: If a `nullptr` is found, then regenerate an object at that position and return
    it as it will be available.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发现`nullptr`，则在那个位置重新生成一个对象，并将其返回，因为它将可用。
- en: If the end of the list is reached, then check whether the pool is allowed to
    grow. If it can, then make and return the new item; otherwise, it would be sensible
    to output a warning so that the designers know the pool probably needs expanding.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果达到列表的末尾，则检查池是否允许增长。如果可以，则创建并返回新项；否则，输出警告是有意义的，这样设计者就会知道池可能需要扩展。
- en: 'In the following code, the section for returning the object, if it is new or
    existing, is repeated due to the slightly different situations where a new object
    must have the component added and initialized but then does not need to be deactivated:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，由于新对象必须添加和初始化组件，但随后不需要将其停用，因此返回对象（无论是新对象还是现有对象）的部分因情况略有不同而重复：
- en: ObjectPool.cpp excerpt part 2
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ObjectPool.cpp摘录部分2
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The two recycling functions act as a way to do overloading with `UFUNCTION`s.
    Unreal does not support this standard C++ practice out of the box, and so we must
    define new functions for each as a workaround. In this case, the `RecycleActor`
    function tries to get a `UPooledObject` component reference from the input actor.
    It may be worth adding a summary comment above this function, with triple forward
    slashes, letting the user know that it may fail and a better method would be to
    use the `UPooledObject` version. If it succeeds, it then calls the `RecyclePooledObject`
    function with this new information. Otherwise, it currently does nothing, but
    this may be a good place to log out the situation as a warning and maybe have
    the function return a Boolean value on successful recycling as feedback on the
    action. The main recycling function simply returns the object to its initial disabled
    and hidden state in the pool, resetting the `_IsActive` flag in the pooled component:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个回收函数作为使用`UFUNCTION`s进行重载的一种方式。虚幻引擎不支持这种标准的C++实践，因此我们必须为每个定义新的函数作为解决方案。在这种情况下，`RecycleActor`函数试图从输入演员中获取`UPooledObject`组件引用。在此函数上方添加一个带有三个斜杠的总结注释可能是有益的，让用户知道它可能会失败，更好的方法可能是使用`UPooledObject`版本。如果成功，它将调用带有新信息的`RecyclePooledObject`函数。否则，目前它什么也不做，但这可能是一个记录情况作为警告的好地方，也许可以让函数在成功回收时返回一个布尔值作为对操作的反馈。主要的回收函数只是将对象返回到池中的初始禁用和隐藏状态，重置池组件中的`_IsActive`标志：
- en: ObjectPool.cpp excerpt part 3
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ObjectPool.cpp摘录第3部分
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last function rounding out our object pooler is a function for regenerating
    items. This could maybe be separated better to make it more useful, in the `GetPooledActor`
    function, but as it stands, this follows the standard object generation as in
    the `BeginPlay` method, just with a twist. It uses indexes to add an object to
    a specific place in the pooled array. There is a lot of room for improvement with
    this function to make it more versatile, but that is left to your implementation’s
    needs:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个完善我们的对象池器的函数是一个用于重新生成项目的函数。这可能可以更好地分离以使其更有用，在`GetPooledActor`函数中，但按照目前的状况，它遵循标准对象生成，就像`BeginPlay`方法一样，只是略有不同。它使用索引将对象添加到池数组中的特定位置。这个函数有很多改进的空间，使其更加灵活，但这取决于你的实现需求：
- en: ObjectPool.cpp excerpt part 4
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ObjectPool.cpp摘录第4部分
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As stated a few times previously, this object pooler will do the job, but it
    is very basic in its utility. There are many extensions that you could, and probably
    should, consider, such as having pool groups so that objects are pooled based
    on the requested groups from the level or making it into a world subsystem that
    is universal to that world, allowing easy setup via the P**roject Settings** panel.
    However, the principle use of it stays the same: to offset the cost of spawning
    to the start of a level, where it can be hidden under a loading screen.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述几次，这个对象池器会完成工作，但它在实用性方面非常基础。你可以考虑，也许应该考虑许多扩展，例如拥有池组，以便根据从级别请求的组来池化对象，或者将其制作成一个通用于该世界的世界子系统，通过“项目设置”面板轻松设置。然而，它的主要用途保持不变：将生成成本偏移到级别的开始，在那里它可以在加载屏幕下隐藏。
- en: Using what we have created in its current form is quite simple. Simply drag
    an instance of the object pooler into your world from the Project panel and set
    up its data variable in the details panel. Once the game starts, it will spawn
    all the required objects in and hide them. To get an object, all you need to do
    is obtain a reference to the pooler somehow and call the `GetPooledObject` function,
    as shown in *Figure 10**.4*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们目前的形式所创建的内容相当简单。只需从项目面板中将对象池器的实例拖到你的世界中，并在详细信息面板中设置其数据变量。一旦游戏开始，它将生成所有必需的对象并将它们隐藏起来。要获取一个对象，你只需要以某种方式获取池器的引用并调用`GetPooledObject`函数，如图*图10.4*所示。
- en: '![Figure 10.4 – Screenshot of the blueprint usage of the object pooler](img/Figure_10.04_B18297.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 对象池器蓝图使用的截图](img/Figure_10.04_B18297.jpg)'
- en: Figure 10.4 – Screenshot of the blueprint usage of the object pooler
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 对象池器蓝图使用的截图
- en: With that, we are at the end of our journey through object pooling. If you have
    been following along, you will not only have an object pooler that you can migrate
    between projects but also an idea of how you can remake and improve it to suit
    specific needs as and when required. Not only this, but the end of this section
    also brings us to the end of the chapter and the book. Even though this wasn’t
    specifically designed as a book to be read in order, from cover to cover, if you
    have been following this journey from the beginning, then you have a good set
    of practical skills and templates for how to improve your code in numerous ways.
    There will be some more parting words of wisdom after this, but let’s round this
    chapter content out by saying that it is more important to get something working
    than to build it exactly correct from the start, which is why the term refactoring
    exists.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就结束了关于对象池的旅程。如果你一直跟随着，你不仅将拥有一个可以在项目之间迁移的对象池器，而且还将了解如何根据需要对其进行重构和改进以适应特定需求。不仅如此，本节的结尾也标志着章节和本书的结束。尽管这本书并不是专门设计成按顺序从头到尾阅读的，但如果从开始你就一直跟随这个旅程，那么你将拥有一套实用的技能和模板，可以以多种方式改进你的代码。在此之后，还会有一些更多的智慧之词，但让我们通过说，比起一开始就精确构建，更重要的是让某个功能能正常工作，这就是为什么存在重构这个术语的原因。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this last chapter, we have covered three patterns that will boost the efficiency
    of your game, if implemented correctly. In game development, optimization should
    not be something you consider until it becomes a problem. It is far more important
    that you get something working first. Data locality should probably be considered
    as a first measure as it requires the least refactoring of code. Likewise, an
    object pool is something we would always recommend you have in your project, via
    a plugin, on standby for when you start to spawn a lot of the same object. The
    dirty flag pattern is much more situational, though, and is only applicable when
    an object has lots of edits versus few read actions per second. Armed with these
    tools, you should be able to make a dent in the frame rate, destroying the spaghetti
    mess that all projects become before release. There are always more ways to optimize
    code beyond this too – some not quite so obvious – but the key is to remember
    that all data and all instructions are stored somewhere and actions using them
    require them to be moved, which takes time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们讨论了三种可以提高游戏效率的模式，如果正确实施的话。在游戏开发中，优化不应该是在它成为问题后才考虑的事情。首先确保某个功能能正常工作要重要得多。数据局部性可能应该首先考虑，因为它需要最少的代码重构。同样，对象池是我们始终推荐你在项目中通过插件保留的，以备在开始大量生成相同对象时使用。然而，脏标志模式则更加具体，只有在对象每秒有大量编辑操作而读取操作很少的情况下才适用。有了这些工具，你应该能够对帧率产生影响，破坏在发布前所有项目都会变成的意大利面式的混乱。除此之外，还有更多优化代码的方法——一些并不那么明显——但关键是要记住，所有数据和所有指令都存储在某个地方，使用它们的行为需要将它们移动，这需要时间。
- en: 'You can find the finished project with all the elements from this book completed
    on GitHub in the same place as the other chapters in the `Complete` branch. Feel
    free to create a fork from here and make your own improvements to each of these
    patterns:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完成的项目，其中包含了本书的所有元素，在同一位置，与其他章节一样，都在`Complete`分支中。你可以从这里创建一个分支，并对这些模式中的每一个进行自己的改进：
- en: '[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Complete](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Complete)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Complete](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Complete)'
- en: 'A final rule: Good code doesn’t make a game good, but it does make your team
    better.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最后的规则：好的代码不能使游戏变得好，但它确实能让你团队变得更好。
