["```cpp\nint a{4};\nstd::cout << a << std::endl;\nint b{a};\n++b;\nstd::cout << \"hello\" << std::endl;\nb--;\nstd::cout << (b + 1) << std::endl;\n```", "```cpp\nchar one;\nchar two;\n```", "```cpp\nstruct S\n{\n  char a;             // location #1\n  int b: 5;           // location #2\n  unsigned c: 11;\n  unsigned :0;        // :0 separates bit fields\n  unsigned d: 8;      // location #3\n  struct {\n    int ee: 8;\n  } e;                // location #4 \n};\n```", "```cpp\nvoid process_vector(const std::vector<int>& vec) \n{\n // calculate the sum and print it\n}\n\nint main()\n{\n std::vector<int> vec1{1, 2, 3, 4, 5};\n std::vector<int> vec2{6, 7, 8, 9, 10};\n std::vector<int> vec3{11, 12, 13, 14, 15};\n process_vector(vec1); // takes A amount of time\n process_vector(vec2); // takes A amount of time\n process_vector(vec3); // takes A amount of time\n}\n```", "```cpp\n#include <thread> #include <iostream>\n\nvoid foo() { std::cout << \"Testing a thread in C++\" << std::endl; }\n\nint main() \n{\n std::thread test_thread{foo};\n}\n```", "```cpp\n#include <thread>\n#include <iostream>\n\nvoid print_numbers_in_background() \n{\n auto ix{0};  // Attention: an infinite loop!\n while (true) {\n std::cout << \"Background: \" << ix++ << std::endl;\n }\n}\n\nint main()\n{\n std::thread background{print_numbers_in_background};\n  auto jx{0};\n  while (jx < 1000000) {\n    std::cout << \"Main: \" << jx++ << std::endl;\n  }\n}\n```", "```cpp\n...\nMain: 90\nMain: 91\nBackground: 149\nBackground: 150\nBackground: 151\nBackground: 152\nBackground: 153\nBackground: \nMain: 92\nMain: 93\n...\n```", "```cpp\n#include <thread>\n#include <iostream>\n\nvoid print_numbers_in_background()\n{\n  // code omitted for brevity\n}\n\nint main()\n{\n  std::thread background{print_numbers_in_background};\n  // the while loop omitted for brevity\n background.join();\n}\n```", "```cpp\nstd::thread t{foo};\nt.detach(); \n```", "```cpp\n#include <thread>\n\nint main() {\n  std::thread tl{[]{\n std::cout << \"A lambda passed to the thread\";\n }};\n  tl.join();\n}\n```", "```cpp\n#include <thread>\n\nclass TestTask\n{\npublic:\n  TestTask() = default;\n\n void operator()() {\n state_++;\n }\n\nprivate:\n  int state_ = 0;\n};\n\nint main() {\n  std::thread t{TestTask()};\n  t.join();\n}\n```", "```cpp\nclass thread_raii\n{\npublic:\n  explicit thread_raii(std::thread& t)\n    : thread_(std::move(t))\n  {}\n\n  ~thread_raii() {\n    thread_.join();  \n  }\n\nprivate:\n  std::thread thread_;\n};\n\nvoid foo() {\n  std::cout << \"Testing thread join\";\n}\n\nint main() {\n std::thread t{foo};\n thread_raii r{t};\n  // will automatically join the thread\n}\n```", "```cpp\nclass thread_raii\n{\npublic:\n  explicit thread_raii(std::thread& t)\n    : thread_(std::move(t))\n  {}\n\n ~thread_raii()\n {\n if (thread_.joinable()) {\n thread_.join();\n }\n }\nprivate:\n  std::thread thread_;\n};\n```", "```cpp\nstd::jthread jt{TestTask()};\n```", "```cpp\nint main()\n{\n std::jthread background{print_numbers_in_background};\n  auto jx{0};\n  while (jx < 1000000) {\n    std::cout << \"Main: \" << jx << std::endl;\n  }\n  // The main thread is about to finish, so we request the background thread to stop\n background.request_stop();\n}\n```", "```cpp\nvoid foo(int one, int two) {\n  // do something\n}\n\nstd::thread t{foo, 4, 2};\n```", "```cpp\nclass big_object {};\n\nvoid make_changes(big_object&);\n\nvoid error_prone()\n{\n  big_object b;\n std::jthread t{make_changes, b};\n  // do something else\n}\n```", "```cpp\nstd::thread t{make_changes, std::ref(b)};\n```", "```cpp\n#include <thread>\n#include <vector>\n\nstd::vector<std::thread> pool;\n```", "```cpp\nvoid process_incoming_connections() {\n  if (new connection from client) {\n    t = create_thread(); // potential overhead\n    t.handle_requests(client);\n  }\n}\nwhile (true) {\n  process_incoming_connections();\n}\n```", "```cpp\n#include <queue>\n#include <thread>\n\nclass ThreadPool\n{\npublic:\n  ThreadPool(int number_of_threads = 1000) {\n    for (int ix = 0; ix < number_of_threads; ++ix) {\n      pool_.push(std::thread());\n    }\n  }\n\n  std::thread get_free_thread() {\n    if (pool_.empty()) {\n      throw std::exception(\"no available thread\");\n    }\n    auto t = pool_.front();\n    pool_.pop();\n    return t;\n  }\n\n  void push_thread(std::thread t) {\n    pool_.push(t);\n  }\n\nprivate:\n  std::queue<std::thread> pool_;\n};\n```", "```cpp\nThreadPool pool;\nvoid process_incoming_connections() {\n  if (new connection from client) {\n    auto t = pool.get_free_thread();\n    t.handle_request(client);\n  }\n}\n\nwhile (true) {\n  process_incoming_connections();\n}\n```", "```cpp\nint global = 0;\n\nvoid inc() {\n  global = global + 1;\n}\n...\nstd::thread t1{inc};\nstd::thread t2{inc};\n```", "```cpp\n#include <mutex>\n...\nstd::mutex locker;\nvoid inc() {\n  locker.lock();\n  global = global + 1;\n  locker.unlock();\n}\n...\nstd::thread t1{inc};\nstd::thread t2{inc};\n\n```", "```cpp\nstd::mutex locker;\nvoid inc() {\n  std::lock_guard g(locker);\n  global = global + 1;\n}\n```", "```cpp\nvoid swap(X& left, X& right)\n{\n  std::lock(left.mt, right.mt);\n  std::lock_guard<std::mutex> lock1(left.mt, std::adopt_lock);\n  std::lock_guard<std::mutex> lock2(right.mt, std::adopt_lock);\n  // do the actual swapping\n}\n```", "```cpp\nclass MySingleton\n{\npublic:\n static MySingleton* get_instance() {\n if (instance_ == nullptr) {\n instance_ = new MySingleton();\n }\n return instance_;\n }\n\n  // code omitted for brevity\nprivate:\n  static inline MySingleton* instance_ = nullptr;\n};\n```", "```cpp\nvoid create_something_unique() \n{\n MySingleton* inst = MySingleton::get_instance();\n  // do something useful\n}\n\nvoid create_something_useful() \n{\n  MySingleton* anotherInst = MySingleton::get_instance();\n  // do something unique\n}  \n\nstd::thread t1{create_something_unique};\nstd::thread t2{create_something_useful};\nt1.join();\nt2.join();\n// some other code\n```", "```cpp\nclass MySingleton\n{\npublic:\n  static MySingleton* get_instance() {\n std::lock_guard lg{mutex_};\n    if (instance_ == nullptr) {\n      instance_ = new MySingleton();\n    }\n    return instance_;\n  }\n\n  // code omitted for brevity\nprivate:\n static std::mutex mutex_;\n  static MySingleton* instance_;\n}\n```", "```cpp\nstatic MySingleton* get_instance() {\n  if (instance_ == nullptr) {\n std::lock_guard lg{mutex_};\n if (instance_ == nullptr) {\n instance_ = new MySingleton();\n }\n  }\n  return instance_;\n}\n```", "```cpp\nauto f = read_file(\"filename\");\ncout << \"Welcome to the app!\";\nprocess_file_contents(f);\n```", "```cpp\nauto p = read_file_async(\"filename\");\ncout << \"Welcome to the app!\";\nprocess_file_contents(p); // we shouldn't be able to do this\n```", "```cpp\ntask<void> process_image()\n{\n  image i = co_await request_image(\"url\");\n  // do something useful with the image\n}\n```"]