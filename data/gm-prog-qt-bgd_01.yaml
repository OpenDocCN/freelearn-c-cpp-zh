- en: Chapter 1. Introduction to Qt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Qt简介
- en: '*In this chapter, you will learn what Qt is and how it evolved. We will pay
    special attention to the differences between Qt''s major versions 4 and 5\. Finally,
    you will learn to decide on which of the available Qt licensing schemes to choose
    for our projects.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在本章中，您将学习Qt是什么以及它是如何演变的。我们将特别关注Qt的主要版本4和5之间的区别。最后，您将学习如何决定为我们的项目选择哪种可用的Qt许可方案。*'
- en: The cross-platform programming
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台编程
- en: 'Qt is an application programming framework that is used to develop cross-platform
    applications. What this means is that software written for one platform can be
    ported and executed on another platform with little or no effort. This is obtained
    by limiting the application source code to a set of calls to routines and libraries
    available to all the supported platforms, and by delegating all tasks that may
    differ between platforms (such as drawing on the screen and accessing system data
    or hardware) to Qt. This effectively creates a layered environment (as shown in
    the following figure), where Qt hides all platform-dependent aspects from the
    application code:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个用于开发跨平台应用程序的应用程序编程框架。这意味着为某个平台编写的软件可以轻松地移植到另一个平台并执行，几乎不需要做任何工作。这是通过将应用程序源代码限制为所有支持的平台都可用的一组例程和库的调用，并将所有可能在平台之间不同的任务（如屏幕绘制、访问系统数据或硬件）委托给Qt来实现的。这实际上创建了一个分层环境（如下图所示），Qt隐藏了所有平台相关的方面，使其从应用程序代码中不可见：
- en: '![The cross-platform programming](img/8874OS_01_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![跨平台编程](img/8874OS_01_01.jpg)'
- en: 'Of course, at times we need to use some functionality that Qt doesn''t provide.
    In such situations, it is important to use conditional compilation like the one
    used in the following code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时我们需要使用Qt不提供的一些功能。在这种情况下，使用条件编译，如以下代码中所示，是很重要的：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register there to have the files e-mailed directly to you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: '*What just happened?*'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Before the code is compiled, it is first fed to a preprocessor that may change
    the final text that is going to be sent to a compiler. When it encounters a `#ifdef`
    directive, it checks for the existence of a label that will follow (such as `Q_OS_WIN32`),
    and only includes a block of code in compilation if the label is defined. Qt makes
    sure to provide proper definitions for each system and compiler so that we can
    use them in such situations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码编译之前，它首先被传递到一个预处理器，该预处理器可能会更改将要发送给编译器的最终文本。当它遇到`#ifdef`指令时，它会检查是否存在一个随后的标签（例如`Q_OS_WIN32`），并且只有在标签被定义的情况下才将代码块包含在编译中。Qt确保为每个系统和编译器提供适当的定义，以便我们可以在这种情况下使用它们。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can find a list of all such macros in the Qt reference manual under the
    term "QtGlobal".
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Qt参考手册中找到所有此类宏的列表，在“QtGlobal”这个术语下。
- en: Qt Platform Abstraction
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt平台抽象
- en: Qt itself is separated into two layers. One is the core Qt functionality that
    is implemented in a standard C++ language, which is essentially platform-independent.
    The other is a set of small plugins that implement a so-called **Qt Platform Abstraction**
    (**QPA**) that contains all the platform-specific code related to creating windows,
    drawing on surfaces, using fonts, and so on. Therefore, porting Qt to a new platform
    in practice boils down to implementing the QPA plugin for it, provided the platform
    uses one of the supported standard C++ compilers. Because of this, providing basic
    support for a new platform is work that can possibly be done in a matter of hours.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Qt本身分为两层。一层是在标准C++语言中实现的Qt核心功能，它基本上是平台无关的。另一层是一组小型插件，实现了所谓的**Qt平台抽象**（**QPA**），它包含所有与创建窗口、在表面上绘制、使用字体等相关联的平台特定代码。因此，在实践中将Qt移植到新平台实际上归结为为它实现QPA插件，前提是这个平台使用支持的标准C++编译器之一。正因为如此，为新的平台提供基本支持可能是几个小时就能完成的工作。
- en: Supported platforms
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的平台
- en: 'The framework is available for a number of platforms, ranging from classical
    desktop environments through embedded systems to mobile phones. The following
    table lists down all the platforms and compiler families that Qt supports at the
    time of writing. It is possible that when you are reading this, a couple more
    rows could have been added to this table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架适用于多种平台，从传统的桌面环境到嵌入式系统，再到移动电话。以下表格列出了在撰写本文时Qt支持的所有平台和编译器家族。有可能在你阅读本文时，此表可能已增加了几行：
- en: '| Platform | QPA plugins | Supported compilers |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | QPA 插件 | 支持的编译器 |'
- en: '| --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Linux | XCB (X11) and Wayland | GCC, LLVM (clang), and ICC |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Linux | XCB (X11) 和 Wayland | GCC, LLVM (clang), 和 ICC |'
- en: '| Windows XP, Vista, 7, 8, and 10 | Windows | MinGW, MSVC, and ICC |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Windows XP, Vista, 7, 8, and 10 | Windows | MinGW, MSVC, and ICC |'
- en: '| Mac OS X | Cocoa | LLVM (clang) and GCC |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Mac OS X | Cocoa | LLVM (clang) 和 GCC |'
- en: '| Linux Embedded | DirectFB, EGLFS, KMS, and Wayland | GCC |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Linux Embedded | DirectFB, EGLFS, KMS, 和 Wayland | GCC |'
- en: '| Windows Embedded | Windows | MSVC |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Windows Embedded | Windows | MSVC |'
- en: '| Android | Android | GCC |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Android | Android | GCC |'
- en: '| iOS | iOS | LLVM (clang) and GCC |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| iOS | iOS | LLVM (clang) 和 GCC |'
- en: '| Unix | XCB (X11) | GCC |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Unix | XCB (X11) | GCC |'
- en: '| RTOS (QNX, VxWorks, and INTEGRITY) | qnx | qcc, dcc, and GCC |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| RTOS (QNX, VxWorks, 和 INTEGRITY) | qnx | qcc, dcc 和 GCC |'
- en: '| BlackBerry 10 | qnx | qcc |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| BlackBerry 10 | qnx | qcc |'
- en: '| Windows 8 (WinRT) | winrt | MSVC |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| Windows 8 (WinRT) | winrt | MSVC |'
- en: '| Maemo, MeeGo, and Sailfish OS | XCB (X11) | GCC |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Maemo, MeeGo, 和 Sailfish OS | XCB (X11) | GCC |'
- en: '| Google Native Client (unsupported) | pepper | GCC |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Google Native Client (unsupported) | pepper | GCC |'
- en: A journey through time
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时光之旅
- en: The development of Qt was started in 1991 by two Norwegians—Eirik Chambe-Eng
    and Haavard Nord, who were looking to create a cross-platform GUI programming
    toolkit. The first commercial client of Trolltech (the company that created the
    Qt toolkit) was the European Space Agency. The commercial use of Qt helped Trolltech
    sustain further development. At that time, Qt was available for two platforms—Unix/X11
    and Windows; however, developing with Qt for Windows required buying a proprietary
    license, which was a significant drawback in porting the existing Unix/Qt applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 的发展始于 1991 年，由两位挪威人——Eirik Chambe-Eng 和 Haavard Nord——发起，他们希望创建一个跨平台的 GUI
    编程工具包。Trolltech（创建 Qt 工具包的公司）的第一个商业客户是欧洲航天局。Qt 的商业使用帮助 Trolltech 持续发展。当时，Qt 可用于两个平台——Unix/X11
    和 Windows；然而，使用 Qt 为 Windows 开发需要购买专有许可证，这在移植现有的 Unix/Qt 应用程序时是一个重大的缺点。
- en: A major step forward was the release of Qt Version 3.0 in 2001, which saw the
    initial support for Mac as well as an option to use Qt for Unix and Mac under
    a liberal GPL license. Still, Qt for Windows was only available under a paid license.
    Nevertheless, at that time, Qt had support for all the important players in the
    market—Windows, Mac, and Unix desktops, with Trolltech's mainstream product and
    Qt for embedded Linux.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2001 年 Qt 3.0 版本的发布是一个重要的进步，它看到了对 Mac 的初始支持，以及使用自由 GPL 许可证在 Unix 和 Mac 下使用 Qt
    的选项。尽管如此，Qt for Windows 仍然仅限于付费许可证。然而，在当时，Qt 已经支持市场上的所有重要参与者——Windows、Mac 和 Unix
    桌面，以及 Trolltech 的主流产品和 Qt for 嵌入式 Linux。
- en: 'In 2005, Qt 4.0 was released, which was a real breakthrough for a number of
    reasons. First, the Qt API was completely redesigned, which made it cleaner and
    more coherent. Unfortunately, at the same time, it made the existing Qt-based
    code incompatible with 4.0, and many applications needed to be rewritten from
    scratch or required much effort to be adapted to the new API. It was a difficult
    decision, but from the time perspective, we can see it was worth it. Difficulties
    caused by changes in the API were well countered by the fact that Qt for Windows
    was finally released under GPL. Many optimizations were introduced that made Qt
    significantly faster. Lastly, Qt, which was a single library until now, was divided
    into a number of modules:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 2005 年，Qt 4.0 发布，这在多个方面都是一个真正的突破。首先，Qt API 完全重新设计，使其更加简洁和一致。不幸的是，与此同时，它使得现有的基于
    Qt 的代码与 4.0 不兼容，许多应用程序需要从头开始重写，或者需要大量努力才能适应新的 API。这是一个艰难的决定，但从时间角度来看，我们可以看到这是值得的。API
    变化带来的困难被 Qt for Windows 最终在 GPL 下发布的事实很好地抵消了。引入了许多优化，使 Qt 显著更快。最后，Qt，直到现在都是一个单一库，被分割成多个模块：
- en: '![A journey through time](img/8874OS_01_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![时光之旅](img/8874OS_01_02.jpg)'
- en: This allowed programmers to only link to the functionality that they used in
    their applications, reducing the memory footprint and dependencies of their software.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得程序员只需链接到他们在应用程序中使用的功能，从而减少了软件的内存占用和依赖。
- en: In 2008, Trolltech was sold to Nokia, which at that time was looking for a software
    framework to help it expand and replace its Symbian platform in the future. The
    Qt community became divided, some people were thrilled, others worried after seeing
    Qt's development get transferred to Nokia. Either way, new funds were pumped into
    Qt, speeding up its progress and opening it for mobile platforms—Symbian and then
    Maemo and MeeGo.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 2008 年，Trolltech 被诺基亚收购，当时诺基亚正在寻找一个软件框架来帮助其扩展并未来取代其 Symbian 平台。Qt 社区因此出现了分歧，一些人看到
    Qt 的发展转向诺基亚后感到兴奋，而另一些人则感到担忧。无论如何，新的资金被注入到 Qt 中，加速了其发展，并使其对移动平台——Symbian、Maemo
    和 MeeGo 开放。
- en: For Nokia, Qt was not considered a product of its own, but rather a tool. Therefore,
    they decided to introduce Qt to more developers by adding a very liberal LGPL
    license that allowed the usage of the framework for both open and closed source
    development.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于诺基亚来说，Qt 并没有被看作是自己的产品，而是一种工具。因此，他们决定通过添加一个非常自由的 LGPL 许可证来向更多开发者介绍 Qt，该许可证允许在开源和闭源开发中使用该框架。
- en: Bringing Qt to new platforms and less powerful hardware required a new approach
    to create user interfaces and to make them more lightweight, fluid, and eye candy.
    Nokia engineers working on Qt came up with a new declarative language to develop
    such interfaces—the **Qt Modeling Language** (**QML**) and a Qt runtime for it
    called Qt Quick.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Qt 带到新的平台和较弱的硬件上需要一种新的方法来创建用户界面，并使它们更加轻量级、流畅和美观。在 Qt 上工作的诺基亚工程师提出了一种新的声明性语言来开发此类界面——**Qt
    模型语言**（**QML**）以及为其提供的 Qt 运行时 Qt Quick。
- en: The latter became the primary focus of the further development of Qt, practically
    stalling all nonmobile-related work, channeling all efforts to make Qt Quick faster,
    easier, and more widespread. Qt 4 was already in the market for 7 years and it
    became obvious that another major version of Qt had to be released. It was decided
    to bring more engineers to Qt by allowing anyone to contribute to the project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 后者成为了 Qt 进一步发展的主要焦点，实际上阻碍了所有非移动相关的工作，将所有努力集中在使 Qt Quick 更快、更简单和更普及上。Qt 4 已经在市场上存在了
    7 年，显然需要发布 Qt 的另一个主要版本。决定通过允许任何人向项目贡献来吸引更多工程师加入 Qt。
- en: Nokia did not manage to finish working on Qt 5.0\. As a result of an unexpected
    turn over of Nokia toward different technology in 2011, the Qt division was sold
    in mid-2012 to the Finnish company Digia that managed to complete the effort and
    release Qt 5.0 in December of the same year.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 诺基亚未能完成 Qt 5.0 的开发工作。由于 2011 年诺基亚对不同技术的意外转向，Qt 部门在 2012 年中旬被出售给了芬兰公司 Digia，该公司完成了这项工作，并在同年
    12 月发布了 Qt 5.0。
- en: New in Qt 5
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 5 的新特性
- en: The API of Qt 5 does not differ much from that of Qt 4\. Therefore, Qt 5 is
    almost completely source compatible with its predecessor, which means that we
    only need a minimal effort to port the existing applications to Qt 5\. This section
    gives a brief introduction to the major changes between versions 4 and 5 of Qt.
    If you are already familiar with Qt 4, this can serve as a small compendium of
    what you need to pay attention to if you want to use the features of Qt 5 to their
    fullest extent.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 5 的 API 与 Qt 4 的 API 差别不大。因此，Qt 5 几乎完全与前辈源代码兼容，这意味着我们只需要最小的努力就可以将现有应用程序移植到
    Qt 5。本节简要介绍了 Qt 4 和 5 版本之间主要的更改。如果您已经熟悉 Qt 4，这可以作为一个小型的汇编，如果您想最大限度地使用 Qt 5 的功能，则需要关注的内容。
- en: Restructured codebase
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新构建的代码库
- en: The biggest change compared to the previous major release of Qt and the one
    that is immediately visible when we try to build an older application against
    Qt 5 is that the whole framework was refactored into a different set of modules.
    Because it expanded over time and became harder to maintain and update for the
    growing number of platforms that it supported, a decision was made to split the
    framework into much smaller modules contained in two module groups—Qt Essentials
    and Qt Add-ons. A major decision relating to the split was that each module could
    now have its own independent release schedule.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Qt 之前的主要版本相比，最大的变化是整个框架被重构为另一组模块。由于它随着时间的推移而扩展，并且对于它所支持的不断增长的平台集合来说，维护和更新变得更加困难，因此决定将框架拆分为包含在两个模块组中的更小的模块——Qt
    Essentials 和 Qt Add-ons。与拆分相关的一个重大决定是，每个模块现在都可以有自己的独立发布计划。
- en: Qt Essentials
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Qt Essentials
- en: 'The Essentials group contains modules that are mandatory to implement for every
    supported platform. This implies that if you are implementing your system using
    modules from this group only, you can be sure that it can be easily ported to
    any other platform that Qt supports. Some of the modules are explained as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 必需模块组包含每个支持平台都必须实现的模块。这意味着如果您仅使用此组中的模块来实现您的系统，您可以确信它可以轻松地移植到 Qt 支持的任何其他平台。以下是一些模块的说明：
- en: The QtCore module contains the most basic Qt functionality that all other modules
    rely on. It provides support for event processing, meta-objects, data I/O, text
    processing, and threading. It also brings a number of frameworks such as the animation
    framework, the State Machine framework, and the plugin framework.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QtCore 模块包含所有其他模块所依赖的最基本的 Qt 功能。它提供对事件处理、元对象、数据 I/O、文本处理和线程的支持。它还带来了许多框架，例如动画框架、状态机框架和插件框架。
- en: The Qt GUI module provides basic cross-platform support to build user interfaces.
    It is much smaller compared with the same module from Qt 4, as the support for
    widgets and printing has been moved to separate modules. Qt GUI contains classes
    that are used to manipulate windows that can be rendered using either the raster
    engine (by specifying `QSurface::RasterSurface` as the surface type) or OpenGL
    (`QSurface::OpenGLSurface`). Qt supports desktop OpenGL as well as OpenGL ES 1.1
    and 2.0.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt GUI 模块提供了构建用户界面的基本跨平台支持。与 Qt 4 中相同的模块相比，它要小得多，因为对小部件和打印的支持已移至单独的模块。Qt GUI
    包含用于操作可以使用光栅引擎（通过指定 `QSurface::RasterSurface` 作为表面类型）或 OpenGL (`QSurface::OpenGLSurface`)
    渲染的窗口的类。Qt 支持桌面 OpenGL 以及 OpenGL ES 1.1 和 2.0。
- en: The Qt Network module brings support for IPv4 and IPv6 networking using TCP
    and UDP as well as by controlling the device connectivity state. Compared to Qt
    4, this module improves IPv6 support, adds support for opaque SSL keys (such as
    hardware key devices) and UDP multicast, and assembles MIME multipart messages
    to be sent over HTTP. It also extends support for DNS lookups.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 网络模块提供了使用 TCP 和 UDP 以及通过控制设备连接状态来支持 IPv4 和 IPv6 网络的功能。与 Qt 4 相比，此模块增强了 IPv6
    支持，增加了对不透明 SSL 密钥（如硬件密钥设备）和 UDP 多播的支持，并将 MIME 多部分消息组装成通过 HTTP 发送的格式。它还扩展了对 DNS
    查询的支持。
- en: Qt Multimedia allows programmers to access audio and video hardware (including
    cameras and FM radio) to record and play multimedia content.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 多媒体允许程序员访问音频和视频硬件（包括摄像头和 FM 收音机）以记录和播放多媒体内容。
- en: Qt SQL brings a framework that is used to manipulate SQL databases in an abstract
    way.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt SQL 提供了一个框架，用于以抽象方式操作 SQL 数据库。
- en: Qt WebKit is a port of the WebKit 2 web browser engine to Qt. It provides classes
    to display and manipulate web content and integrates with your desktop application.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt WebKit 是 WebKit 2 网络浏览器引擎到 Qt 的移植。它提供了用于显示和操作网页内容的类，并与您的桌面应用程序集成。
- en: Qt Widgets extends the GUI module with the ability to create a user interface
    using widgets, such as buttons, edit boxes, labels, data views, dialog boxes,
    menus, and toolbars that are arranged using a special layout engine. It also contains
    the implementation of an object-oriented 2D graphics canvas called **Graphics
    View**. When porting Qt 4 applications to Qt 5, it is a good idea to start by
    enabling support of the widgets module (by adding *QT += widgets* to the project
    file) and then work your way down from here.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Widgets 通过使用小部件（如按钮、编辑框、标签、数据视图、对话框、菜单和工具栏）以及使用特殊布局引擎排列的能力扩展了 GUI 模块，以创建用户界面。它还包含一个名为
    **Graphics View** 的面向对象的 2D 图形画布的实现。当将 Qt 4 应用程序移植到 Qt 5 时，一个好的做法是首先启用对 widgets
    模块的支持（通过在项目文件中添加 *QT += widgets*），然后从这里开始逐步工作。
- en: Qt Quick is an extension of Qt GUI, which provides means to create lightweight
    fluid user interfaces using QML. It is described in more detail later in this
    chapter as well as in [Chapter 9](ch09.html "Chapter 9. Qt Quick Basics"), *Qt
    Quick Basics*.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick 是 Qt GUI 的扩展，它提供了使用 QML 创建轻量级流畅用户界面的方法。在本章的后续部分以及[第 9 章](ch09.html
    "第 9 章。Qt Quick 基础")中，即 *Qt Quick 基础*，有更详细的描述。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are also other modules in this group, but we will not focus on them in
    this book. If you want to learn more about them, you can look them up in the Qt
    reference manual.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此组中还有其他模块，但在此书中我们将不会关注它们。如果您想了解更多关于它们的信息，可以在 Qt 参考手册中查找。
- en: Qt Add-ons
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Qt 插件
- en: This group contains modules that are optional for any platform. This means that
    if a particular functionality is not available on some platform or there is nobody
    willing to spend time working on this functionality for a platform, it will not
    prevent Qt from supporting this platform.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此组包含任何平台都可选的模块。这意味着如果某些平台上的特定功能不可用，或者没有人愿意花时间为此平台工作此功能，它将不会阻止 Qt 支持此平台。
- en: Some of the most important modules are QtConcurrent for parallel processing,
    Qt Script that allows us to use JavaScript in C++ applications, Qt3D that provides
    high-level OpenGL building blocks, and Qt XML Patterns that helps us to access
    XML data. Many others are also available, but we will not cover them here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最重要的模块包括 QtConcurrent 用于并行处理、Qt Script 允许我们在 C++ 应用程序中使用 JavaScript、Qt3D 提供高级
    OpenGL 构建块以及 Qt XML Patterns 帮助我们访问 XML 数据。还有许多其他模块也可用，但在此处我们将不涉及它们。
- en: Qt Quick 2.0
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt Quick 2.0
- en: The largest upgrade to Qt functionality-wise is Qt Quick 2.0\. In Qt 4, the
    framework was implemented on top of Graphics View. This proved to be too slow
    when used with low-end hardware even with OpenGL ES acceleration enabled. This
    is because of the way Graphics View renders its content—it iterates all the items
    in sequence, calculates and sets its transformation matrix, paints the item, recalculates
    and resets the matrix for the next item, paints it, and so on. Since an item can
    contain any generic content drawn in an arbitrary order, it requires frequent
    changes to the GL pipeline, causing major slowdowns.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能方面，Qt 的最大升级是 Qt Quick 2.0。在 Qt 4 中，该框架是在 Graphics View 之上实现的。即使启用了 OpenGL
    ES 加速，当与低端硬件一起使用时，这也证明速度过慢。这是因为 Graphics View 渲染其内容的方式——它按顺序迭代所有项目，计算并设置其变换矩阵，绘制项目，重新计算并重置下一个项目的矩阵，绘制它，依此类推。由于一个项目可以包含任何以任意顺序绘制的通用内容，因此它需要频繁更改
    GL 管道，导致严重减速。
- en: The new version of Qt Quick instead uses a scene-graph approach. It describes
    the whole scene as a graph of attributes and well-known operations. To paint the
    scene, information about the current state of the graph is gathered and the scene
    is rendered in a more optimal way. For example, it can first draw triangle strips
    from all items, then render fonts from all items, and so on. Furthermore, since
    the state of each item is represented by a subgraph, changes to each item can
    be tracked and it can be decided whether the visual representation of a particular
    item needs to be updated or not.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 的新版本采用了场景图方法。它将整个场景描述为一个属性和已知操作的图。为了绘制场景，会收集关于当前图状态的详细信息，并以更优化的方式渲染场景。例如，它可以先从所有项目中绘制三角形带，然后从所有项目中渲染字体，依此类推。此外，由于每个项目的状态由一个子图表示，因此可以跟踪每个项目的更改，并决定特定项目的视觉表示是否需要更新。
- en: The old `QDeclarativeItem` class was replaced by `QQuickItem`, which has no
    ties to the Graphics View architecture. There is no routine available where you
    can directly paint the item, but there is a `QQuickPaintedItem` class available
    that aids in porting old code by rendering content based on `QPainter` to a texture
    and then rendering that texture using a scene-graph. Such items are, however,
    significantly slower than those directly using the graph approach, so if performance
    is important, they should be avoided.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的 `QDeclarativeItem` 类已被 `QQuickItem` 替换，它与图形视图架构没有关联。没有可以直接绘制项的常规方法，但有一个 `QQuickPaintedItem`
    类可用，它通过将基于 `QPainter` 的内容渲染到纹理中，然后使用场景图渲染该纹理来帮助移植旧代码。然而，这类项的运行速度比直接使用图形方法慢得多，所以如果性能很重要，应避免使用。
- en: Qt Quick plays an important role in Qt 5 and it is very useful to create games.
    We will cover this technology in detail in [Chapters 9](ch09.html "Chapter 9. Qt
    Quick Basics"), *Qt Quick Basics* and [Chapter 10](ch10.html "Chapter 10. Qt Quick"),
    *Qt Quick*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 在 Qt 5 中扮演着重要角色，并且对于创建游戏非常有用。我们将在第 9 章 [Qt Quick Basics](ch09.html
    "第 9 章。Qt Quick 基础") 和第 10 章 [Qt Quick](ch10.html "第 10 章。Qt Quick") 中详细介绍这项技术。
- en: Meta-objects
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元对象
- en: In Qt 4, adding signals and slots to a class required the presence of a meta-object
    (that is, an instance of a class that describes another class) for that class.
    This was done by subclassing `QObject`, adding the `Q_OBJECT` macro to it, and
    declaring signals and slots in special scopes of the class. In Qt 5, this is still
    possible and advised in many situations, but we now have new interesting possibilities.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 4 中，将信号和槽添加到类需要该类的元对象（即描述另一个类的类的实例）的存在。这是通过从 `QObject` 派生，向其中添加 `Q_OBJECT`
    宏，并在类的特殊作用域中声明信号和槽来完成的。在 Qt 5 中，这仍然是可能的，并且在许多情况下是建议的，但我们现在有了一些新的有趣的可能性。
- en: It is now acceptable to connect a signal to any compatible member function of
    a class or any callable entity, such as a standalone function or function object
    (`functor`). A side-effect is a compile-time compatibility check of the signal
    and the slot (as opposed to the runtime check of the "old" syntax).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将信号连接到类的任何兼容成员函数或任何可调用实体（例如独立函数或函数对象（`functor`））是可以接受的。副作用是信号和槽（与“旧”语法的运行时检查相对）的编译时兼容性检查。
- en: C++11 support
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++11 支持
- en: In August 2011, ISO approved a new standard for C++, commonly referred to as
    C++11\. It provides a number of optimizations and makes it easier for programmers
    to create effective code. While you could use C++11 together with Qt 4, it didn't
    provide any dedicated support for it. This has changed with Qt 5, which is now
    aware of C++11 and supports many of the constructs introduced by the new version
    of the language. In this book, we will sometimes use C++11 features in our code.
    Some compilers have C++11 support enabled by default, in others, you need to enable
    it. Don't worry if your compiler doesn't support C++11\. Each time we use such
    features, I will make you aware of it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 2011 年 8 月，ISO 批准了新的 C++ 标准，通常称为 C++11。它提供了一系列优化，并使程序员更容易创建有效的代码。虽然您可以将 C++11
    与 Qt 4 一起使用，但它并没有提供任何针对它的专用支持。这种情况在 Qt 5 中发生了变化，Qt 5 现在了解 C++11 并支持语言新版本引入的许多构造。在这本书中，我们有时会在代码中使用
    C++11 功能。一些编译器默认启用了 C++11 支持，而在其他编译器中，您需要启用它。如果您的编译器不支持 C++11，请不要担心。每次我们使用这些功能时，我都会让您知道。
- en: Choosing the right license
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的许可证
- en: Qt is available under two different licensing schemes—you can choose between
    a commercial license and an open source one. We will discuss both here to make
    it easier for you to choose. If you have any doubts regarding whether a particular
    licensing scheme applies to your use case, better consult a professional lawyer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 可在两种不同的许可方案下使用——您可以选择商业许可或开源许可。我们将在这里讨论两者，以便您更容易选择。如果您对特定许可方案是否适用于您的用例有任何疑问，最好咨询专业律师。
- en: An open source license
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源许可证
- en: The advantage of open source licenses is that we don't have to pay anyone to
    use Qt; however, the downside is that there are some limitations imposed on how
    it can be used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 开源许可证的优势是，我们不必为使用 Qt 向任何人付费；然而，缺点是它对如何使用 Qt 施加了一些限制。
- en: When choosing the open source edition, we have to decide between GPL 3.0 and
    LGPL 2.1 or 3\. Since LGPL is more liberal, in this chapter we will focus on it.
    Choosing LGPL allows you to use Qt to implement systems that are either open source
    or closed source—you don't have to reveal the sources of your application to anyone
    if you don't want to.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择开源版本时，我们必须在GPL 3.0和LGPL 2.1或3之间做出选择。由于LGPL更为自由，在本章中我们将重点关注它。选择LGPL允许您使用Qt实现开源或闭源的系统——如果您不想，您不必向任何人透露您应用程序的源代码。
- en: 'However, there are a number of restrictions you need to be aware of:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您需要了解一些限制：
- en: Any modifications that you make to Qt itself need to be made public, for example,
    by distributing source code patches alongside your application binary.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您对Qt本身所做的任何修改都需要公开，例如，通过将源代码补丁与您的应用程序二进制文件一起分发。
- en: LGPL requires that users of your application must be able to replace Qt libraries
    that you provide them with other libraries with the same functionality (for example,
    a different version of Qt). This usually means that you have to dynamically link
    your application against Qt so that the user can simply replace Qt libraries with
    his own. You should be aware that such substitutions can decrease the security
    of your system, thus, if you need it to be very secure, open source might not
    be the option for you.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LGPL要求您的应用程序用户必须能够用具有相同功能的其他库（例如，Qt的不同版本）替换您提供的Qt库。这通常意味着您必须将应用程序动态链接到Qt，以便用户可以简单地用自己的Qt库替换它们。您应该意识到，这种替换可能会降低您系统的安全性，因此，如果您需要非常安全，开源可能不是您的选择。
- en: LGPL is incompatible with a number of licenses, especially proprietary ones,
    so it is possible that you won't be able to use Qt with some commercial components.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LGPL与许多许可证不兼容，尤其是专有许可证，因此您可能无法使用Qt与某些商业组件一起使用。
- en: The open source edition of Qt can be downloaded directly from [http://www.qt.io](http://www.qt.io).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的开源版本可以直接从[http://www.qt.io](http://www.qt.io)下载。
- en: A commercial license
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 商业许可证
- en: All these restrictions are lifted if you decide to buy a commercial license
    for Qt. This allows you to keep the entire source code a secret, including any
    changes you may want to incorporate in Qt. You can freely link your application
    statically against Qt, which means fewer dependencies, a smaller deployment bundle
    size, and a faster startup. It also increases the security of your application,
    as end users cannot inject their own code into the application by replacing a
    dynamically loaded library with their own.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定为Qt购买商业许可证，所有这些限制都将被解除。这允许您将整个源代码保密，包括您可能想要合并到Qt中的任何更改。您可以自由地将应用程序静态链接到Qt，这意味着更少的依赖项、更小的部署包大小和更快的启动速度。它还提高了您应用程序的安全性，因为最终用户无法通过用自己的代码替换动态加载的库来向应用程序中注入自己的代码。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To buy a commercial license, go to [http://qt.io/buy](http://qt.io/buy).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要购买商业许可证，请访问[http://qt.io/buy](http://qt.io/buy)。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the architecture of Qt. We saw how it evolved
    over time and we had a brief overview of what it looks like now. Qt is a complex
    framework and we will not manage to cover it all, as some parts of its functionality
    are more important for game programming than others that you can learn on your
    own in case you ever need them. Now that you know what Qt is, we can proceed with
    the next chapter where you will learn how to install Qt on your development machine.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Qt的架构。我们看到了它是如何随着时间的推移而演变的，并对现在的样子进行了简要概述。Qt是一个复杂的框架，我们无法涵盖所有内容，因为其功能的一些部分对于游戏编程来说比其他部分更重要，您可以在需要时自行学习。现在您已经了解了Qt是什么，我们可以继续下一章，在那里您将学习如何在您的开发机器上安装Qt。
