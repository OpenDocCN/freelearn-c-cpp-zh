- en: Understanding and Designing Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和设计模板
- en: Templates are a unique feature of C++ by which functions and classes have the
    ability to support generic data types – in other words, we can implement a function
    or class independent of a particular data type; for example, a client may request
    a `max()` function to handle different data types. Instead of implementing and
    maintaining many similar functions by using function overloading, we can just
    implement one `max()` and pass the data type as a parameter. Moreover, templates
    can work together with multiple inheritance and operator overloading to create
    powerful generic data structures and algorithms in C++ such as the **Standard
    Template Library** (**STL**). Additionally, templates can also be applied to compile-time
    computation, compile-time and runtime code optimization, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是C++的一个独特特性，通过它，函数和类能够支持通用数据类型——换句话说，我们可以实现一个与特定数据类型无关的函数或类；例如，客户可能会请求一个`max()`函数来处理不同的数据类型。我们可以通过模板来实现一个`max()`，并将数据类型作为参数传递，而不是通过函数重载来实现和维护许多类似的函数。此外，模板可以与多重继承和运算符重载一起工作，以在C++中创建强大的通用数据结构和算法，如**标准模板库**（**STL**）。此外，模板还可以应用于编译时计算、编译时和运行时代码优化等。
- en: In this chapter, we will learn about the syntax of function and class templates,
    their instantiations, and their specializations. Then, we will introduce *variadic*
    templates and their applications. Next, we will discuss template parameters and
    the corresponding arguments that are used for instantiating them. After that,
    we'll learn how to implement a type *trait* and how to use this type of information
    to optimize algorithms. Finally, we will present techniques that we can use to
    speed up programs when they're executed, which includes compile-time computation,
    compile-time code optimization, and static polymorphism.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习函数和类模板的语法，它们的实例化和特化。然后，我们将介绍*可变参数*模板及其应用。接下来，我们将讨论模板参数及用于实例化它们的相应参数。之后，我们将学习如何实现类型*特性*，以及如何利用这种类型的信息来优化算法。最后，我们将介绍在程序执行时可以使用的加速技术，包括编译时计算、编译时代码优化和静态多态性。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Exploring function and class templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索函数和类模板
- en: Understanding variadic templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可变参数模板
- en: Understanding template parameters and arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模板参数和参数
- en: What are traits?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是特性？
- en: Template meta-programming and its applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板元编程及其应用
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)。
- en: Exploring function and class templates
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索函数和类模板
- en: We will start this section by introducing the syntax of function templates and
    their instantiations, deductions, and specializations. Then, we will move on to
    class templates and look at similar concepts, as well as examples.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从介绍函数模板的语法及其实例化、推导和特化开始这一部分。然后，我们将转向类模板，并查看类似的概念和示例。
- en: Motivation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: So far,when we have defined a function or a class, we have had to provide input,
    output, and intermediate parameters. For example, let's say we have a function
    to performs the addition of two int type integers. How do we extend this so that
    it handles all the other basic data types, such as float, double, char, and so
    on? One way is to use function overloading by manually copying, pasting, and slightly
    modifying each function. Another way is to define a macro to do the addition operation.
    Both approaches have their own side effects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们定义函数或类时，我们必须提供输入、输出和中间参数。例如，假设我们有一个函数来执行两个int类型整数的加法。我们如何扩展它，以便处理所有其他基本数据类型，如float、double、char等？一种方法是使用函数重载，手动复制、粘贴和稍微修改每个函数。另一种方法是定义一个宏来执行加法操作。这两种方法都有各自的副作用。
- en: Moreover, what happens if we fix a bug or add a new feature for one type, and
    this update needs to be done for all the other overloading functions and classes
    later? Instead of using this silly copy-paste-and-replacement method, do we have
    a better way of handling this kind of situation?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们修复一个bug或为一个类型添加一个新功能，这个更新需要在以后的所有其他重载函数和类中完成吗？除了使用这种愚蠢的复制-粘贴-替换方法外，我们有没有更好的方法来处理这种情况？
- en: In fact, this is a generic problem that any computer language can face. Pioneered
    by the general-purpose functional programming **Meta Language** (**ML**) in 1973,
    ML permits writing common functions or types that differ only in the set of types
    that they operate on when used, thus reducing duplication. Later inspired by the
    parameterized modules provided in the **chartered life underwriter** (**CLU**)
    and the generics provided by Ada, C++ adopted the template concept, which allows
    functions and classes to operate with generic types. In other words, it allows
    a function or class to work on different data types without them needing to be
    rewritten.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是任何计算机语言都可能面临的一个通用问题。1973年由通用函数式编程**元语言**（**ML**）首创，ML允许编写通用函数或类型，这些函数或类型在使用时只在它们操作的类型集合上有所不同，从而减少了重复。后来受到**特许人寿保险师**（**CLU**）提供的参数化模块和Ada提供的泛型的启发，C++采用了模板概念，允许函数和类使用通用类型。换句话说，它允许函数或类在不需要重写的情况下处理不同的数据类型。
- en: Actually, from an abstract point of view, C++ functions or class templates (such
    as cookie cutters) serve as a pattern for creating other similar functions or
    classes. The basic idea behind this is to create a function or class template
    without having to specify the exact type(s) of some or all variables. Instead,
    we define a function or class template using placeholder types, called **template
    type parameters**. Once we have a function or class template, we can automatically
    generate functions or classes by using an algorithm that has been implemented
    in other compilers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从抽象的角度来看，C++函数或类模板（如饼干模具）用作创建其他类似函数或类的模式。这背后的基本思想是创建一个函数或类模板，而无需指定某些或所有变量的确切类型。相反，我们使用占位符类型来定义函数或类模板，称为**模板类型参数**。一旦我们有了函数或类模板，我们可以通过在其他编译器中实现的算法自动生成函数或类。
- en: 'There are three kinds of templates in C++: *function* templates, *class* templates,
    and *variadic* templates. We''ll take a look at these next.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++中有三种模板：*函数*模板、*类*模板和*可变参数*模板。我们接下来将看看这些。
- en: Function templates
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数模板
- en: 'A function template defines how a family of functions can be generated. A family
    here means a group of functions that behave similarly. As shown in the following
    diagram, this includes two phases:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板定义了如何生成一组函数。这里的一组函数指的是行为类似的一组函数。如下图所示，这包括两个阶段：
- en: Creating a function template; that is, the rules on how to write it.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数模板；即编写它的规则。
- en: 'Template instantiation; that is, the rules that are used to generate functions
    from their template:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板实例化；即用于从模板生成函数的规则：
- en: '![](img/4ba0b575-0a51-403e-8a1f-1f3b03c37817.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ba0b575-0a51-403e-8a1f-1f3b03c37817.png)'
- en: Function template format
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板格式
- en: In **part I** of the preceding diagram, we discuss the format that will be used
    to create a function template for generic types, but with respect to the **specialized
    template**, which we also refer to as the **primary template**. Then, in **part
    II**, we introduce the three ways to generate functions from the template. Lastly,
    the specialization *and* overloading subsection tells us how to customize the
    **primary template** (by changing its behavior) for special types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图的**part I**中，我们讨论了用于创建通用类型函数模板的格式，但是关于**专门化模板**，我们也称之为**主模板**。然后，在**part
    II**中，我们介绍了从模板生成函数的三种方式。最后，专门化和重载子节告诉我们如何为特殊类型自定义**主模板**（通过改变其行为）。
- en: Syntax
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: 'There are two ways to define function templates, as shown in the following
    code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种定义函数模板的方式，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `identifier_i (i=1,…,n)` is the type or class parameter and `function_declaration`
    declares the function body part. The only difference in the preceding two declarations
    is the keywords –one uses `class` while the other uses `typename`, but both have
    the same meaning and behavior. Since a type (such as the basic types – int, float,
    double,enum, struct, union, and so on) is not a class, the `typename` keyword
    method was introduced to avoid confusion.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`identifier_i (i=1,…,n)`是类型或类参数，`function_declaration`声明了函数体部分。在前两个声明中唯一的区别是关键字
    - 一个使用`class`，而另一个使用`typename`，但两者的含义和行为都是相同的。由于类型（如基本类型 - int、float、double、enum、struct、union等）不是类，因此引入了`typename`关键字方法以避免混淆。
- en: 'For example, the classic find maximum value function template, `app_max()`,
    can be declared as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，经典的查找最大值函数模板`app_max()`可以声明如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function template can work for many data types or classes, as long as there's
    a copy-constructible type where the *a>b *expression is valid. For user-defined
    classes, this means that the greater-than operator (>) must be defined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 只要存在可复制构造的类型，其中 *a>b *表达式有效，这个函数模板就可以适用于许多数据类型或类。对于用户定义的类，这意味着必须定义大于号（>）。
- en: Note that the function template and template function are different things.
    Function template refers to a kind of template that's used to generate functions
    by a compiler, so the compiler does not generate any object code for it. On the
    other hand,template function means an instance from a function template. Since
    it is a function, the corresponding object code is generated by the compiler. However, the
    latest C++ standard documents suggest avoiding using the imprecision term template
    function. Therefore, we will use function templates and member function templates
    in this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数模板和模板函数是不同的东西。函数模板指的是一种模板，用于由编译器生成函数，因此编译器不会为其生成任何目标代码。另一方面，模板函数意味着来自函数模板的实例。由于它是一个函数，编译器会生成相应的目标代码。然而，最新的C++标准文档建议避免使用不精确的术语模板函数。因此，在本书中我们将使用函数模板和成员函数模板。
- en: Instantiation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化
- en: 'Since we may potentially have an infinite number of types and classes, the
    concept of function templates not only saves space in the source code file but
    also makes code easier to read and maintain. However, compared to writing separate
    functions or classes for the different data types that are used in our applications,
    it does not produce smaller object code. For instance, consider a program using
    a float and int version of `app_max()`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能有无限多种类型和类，函数模板的概念不仅节省了源代码文件中的空间，而且使代码更易于阅读和维护。然而，与为应用程序中使用的不同数据类型编写单独的函数或类相比，它并不会产生更小的目标代码。例如，考虑使用`app_max()`的float和int版本的程序：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The compiler will generate two new functions in the object file, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将在目标文件中生成两个新函数，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This process of creating a new definition of a function from a function template
    declaration is called **template instantiation**. During this instantiation process,
    the compiler determines the template arguments and generates actual functional
    code on demand for your application. Typically, there are three forms: *explicit*
    *instantiations*, *implicit instantiations*, and *template deductions*. In the
    next sections, let''s discuss each form.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数模板声明中创建函数的新定义的过程称为**模板实例化**。在这个实例化过程中，编译器确定模板参数，并根据应用程序的需求生成实际的功能代码。通常有三种形式：*显式实例化*，*隐式实例化*和*模板推断*。在接下来的部分，让我们讨论每种形式。
- en: Explicit instantiations
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式实例化
- en: 'A lot of very useful C++ function templates can be written and consumed without
    ever using explicit instantiation, but we will describe them here just so you
    know that they do exist if you ever need them. First, let''s have a look at the
    syntax of explicit instantiations before C++11\. There are two forms, as shown
    in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多非常有用的C++函数模板可以在不使用显式实例化的情况下编写和使用，但我们将在这里描述它们，只是让您知道如果您需要它们，它们确实存在。首先，让我们看一下C++11之前显式实例化的语法。有两种形式，如下所示：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An explicit instantiation definition, also known as a **directive**, forces
    the instantiation of a function template for certain type(s), regardless of the
    template function that will be called in the **future**. The location of the explicit
    instantiations can be anywhere after the definition of the function template,
    and it is only allowed to appear once for a given argument list in the source
    code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实例化定义，也称为**指令**，强制为特定类型的函数模板实例化，无论将来将调用哪个模板函数。显式实例化的位置可以在函数模板的定义之后的任何位置，并且在源代码中对于给定的参数列表只允许出现一次。
- en: 'The syntax for explicit instantiation directives, since C++11, is as follows.
    Here, we can see that the `extern` keyword is added before the `template` keyword:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，显式实例化指令的语法如下。在这里，我们可以看到在`template`关键字之前添加了`extern`关键字：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the `extern` keyword prevents implicit instantiations of that function
    template (see the next section for more details).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`extern`关键字可以防止该函数模板的隐式实例化（有关更多详细信息，请参阅下一节）。
- en: 'Regarding the previously declared `app_max()` function template, it can be
    explicitly instantiated using the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于之前声明的`app_max()`函数模板，可以使用以下代码进行显式实例化：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It can also be explicitly instantiated using the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用以下代码进行显式实例化：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This can also be done in a template argument deduced way:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以以模板参数推断的方式完成：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, this can also be done like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这也可以这样做：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Moreover, there are some other rules for explicit instantiation. If you want
    to find out more, please refer to the *Further reading* section [10] for more
    details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，显式实例化还有一些其他规则。如果您想了解更多，请参考*进一步阅读*部分[10]以获取更多详细信息。
- en: Implicit instantiations
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式实例化
- en: 'When a function is called, the definition of that function needs to exist.
    If this function has not been explicitly instantiated, an implicit instantiation
    approach is reached, in which the list of template arguments need to be either
    explicitly supplied or deduced from the context. `Part A` of the following program
    provides some examples of the implicit instantiation of `app_max()` in this catalog:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，该函数的定义需要存在。如果这个函数没有被显式实例化，将会采用隐式实例化的方法，其中模板参数的列表需要被显式提供或从上下文中推断出。以下程序的A部分提供了`app_max()`的隐式实例化的一些示例。
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The implicit instantiations of lines `A`, `B`, `C`, and `D` are `int app_max<int>(int,int)`,
    `float app_max<float>(float, float>)`, `int app_max<int>(int,int)`, and `double
    app_max<double>(double, double)`, respectively.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 行`A`，`B`，`C`和`D`的隐式实例化分别是`int app_max<int>(int,int)`，`float app_max<float>(float,
    float>)`，`int app_max<int>(int,int)`和`double app_max<double>(double, double)`。
- en: Deduction
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推断
- en: When you call a template function, the compiler needs to figure out the template
    arguments first, even if not every template argument is specified. Most of the
    time, it will deduce the missing template arguments from the function arguments.
    For example, in part B of the preceding function, when you call `app_max(5, 8)`
    in line `E`, the compiler deduces the template argument as an int type, `(int
    app_max<int>(int,int))`, because the input parameters, `5` and `8`, are integers.
    Similarly, line `F` will be deduced as a float type, that is, `float app_max<float>(float,float)`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用模板函数时，编译器首先需要确定模板参数，即使没有指定每个模板参数。大多数情况下，它会从函数参数中推断出缺失的模板参数。例如，在上一个函数的B部分中，当在行`E`中调用`app_max(5,
    8)`时，编译器会推断模板参数为int类型，即`(int app_max<int>(int,int))`，因为输入参数`5`和`8`都是整数。同样，行`F`将被推断为浮点类型，即`float
    app_max<float>(float,float)`。
- en: However, what happens if there is confusion during instantiation? For instance,
    in the commented out line for `G` of the previous program, depending on the compiler,
    it might call `app_max<double>(double, double), app_max<int>(int, int)`, or just
    give a compile error message. The best way to help the compiler deduce the type
    is to call the function template by giving a template argument explicitly. In
    this case, if we call `app_max<double>(5, 8.0)`, any confusion will be resolved.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果在实例化过程中出现混淆会发生什么？例如，在上一个程序中对`G`的注释行中，根据编译器的不同，可能会调用`app_max<double>(double,
    double)`，`app_max<int>(int, int)`，或者只是给出一个编译错误消息。帮助编译器推断类型的最佳方法是通过显式给出模板参数来调用函数模板。在这种情况下，如果我们调用`app_max<double>(5,
    8.0)`，任何混淆都将得到解决。
- en: From the compiler's point of view, there are several ways to do template argument
    deduction – deduction from a function call, deduction from a type, auto type deduction,
    and non-deduced contexts [4]. However, from a programmer's point of view, you
    should never write fancy code to ill-use the concept of function template deduction
    to confuse other programmers such as line G in the previous example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从编译器的角度来看，有几种方法可以进行模板参数推导——从函数调用中推导，从类型中推导，自动类型推导和非推导上下文[4]。然而，从程序员的角度来看，你不应该编写花哨的代码来滥用函数模板推导的概念，以混淆其他程序员，比如前面示例中的G行。
- en: Specialization and overloading
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专门化和重载
- en: Specialization allows us to customize the template code for a given set of template
    arguments. It allows us to define a special behavior for specific template arguments.
    A specialization is still a template; you still need an instantiation to get the
    real code (automatically by the compiler).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 专门化允许我们为给定的模板参数集自定义模板代码。它允许我们为特定的模板参数定义特殊行为。专门化仍然是一个模板；你仍然需要一个实例化来获得真正的代码（由编译器自动完成）。
- en: 'In the following sample code, the primary function template, `T app_max(T a,
    T b)`, will return `a` or `b` based on the return of operator *a>b,* but we can
    specialize it for `T = std::string` so that we only compare the 0*-th* elements
    of `a` and `b`; that is, `a[0] >b[0]`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例代码中，主要函数模板`T app_max(T a, T b)`将根据`operator *a>b,*`的返回值返回`a`或`b`，但我们可以将其专门化为`T
    = std::string`，这样我们只比较`a`和`b`的第0个元素；也就是说，`a[0] >b[0]`：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code defines a primary template first, and then it explicitly
    specializes `T` as `std::string`; that is, instead of comparing the values of
    `a` and `b`, we only care about `a[0]` and `b[0]` (the behavior of `app_max()`
    is specialized). In the test function, `line A` calls `app_max<int>(int,int)`
    and `line B` calls the specialized version because there is no ambiguity at the
    deduction time. If we uncomment lines `C` and `D`, the primary function template, `char*
    app_max<char > (char*, char*)`*,* will be called, since `char*` and `std::string`
    are different data types.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码首先定义了一个主模板，然后将`T`显式专门化为`std::string`；也就是说，我们只关心`a`和`b`的`a[0]`和`b[0]`（`app_max()`的行为被专门化）。在测试函数中，`行A`调用`app_max<int>(int,int)`，`行B`调用专门化版本，因为在推导时没有歧义。如果我们取消注释`C`和`D`行，将调用主函数模板`char*
    app_max<char > (char*, char*)`，因为`char*`和`std::string`是不同的数据类型。
- en: 'Essentially, specialization somewhat conflicts with function overload resolution:
    the compiler needs an algorithm to resolve this conflict by finding the right
    match among the template and overloading functions. The algorithm for selecting
    the right function involves the following two steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种程度上讲，专门化与函数重载解析有些冲突：编译器需要一种算法来解决这种冲突，找到模板和重载函数中的正确匹配。选择正确函数的算法包括以下两个步骤：
- en: Perform overload resolution among regular functions and non-specialized templates.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在常规函数和非专门化模板之间进行重载解析。
- en: If a non-specialized template is selected, check if a specialization exists
    that would be a better match for it.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果选择了非专门化的模板，请检查是否存在一个更适合它的专门化。
- en: 'For example, in the following code block, we''re declaring the primary (`line
    0`) and specialized function templates (`lines 1-4`), as well as the overload
    functions (`lines 5-6)` of `f()`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码块中，我们声明了主要（`行0`）和专门化的函数模板（`行1-4`），以及`f()`的重载函数（`行5-6`）：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`f()` will be called several times in the following code block. Based on the
    preceding two-step rule, we can show which function is chosen in the comments.
    We''ll explain the reason for doing this after:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`f()`将在下面的代码块中被多次调用。根据前面的两步规则，我们可以在注释中显示选择了哪个函数。我们将在此之后解释这样做的原因：'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For `lines A` and `line B`, since `f()` defined in `lines 5` and `line 6` are
    regular functions, they have the highest priority to be chosen, so `f(i)` and
    `f(i,d)` will choose them, respectively. For `line C`, because the specialized
    template exists, the `f()` generated from `line 4` is a better match than what
    was created from `line 1`. For `line D`, since `c` is a `complex<double>` type,
    only the primary function template defined in `line 1` matches it. `Line E` will
    choose `f()` that was created by `line 2` because the two input variables are
    the same type. Finally, `lines F` and `line G` will pick up the functions created
    from the templates in lines `0` and `3`, respectively.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`行A`和`行B`，由于`行5`和`行6`中定义的`f()`是常规函数，它们具有最高的优先级被选择，所以`f(i)`和`f(i,d)`将分别选择它们。对于`行C`，因为存在专门化的模板，从`行4`生成的`f()`比从`行1`生成的更匹配。对于`行D`，由于`c`是`complex<double>`类型，只有在`行1`中定义的主要函数模板与之匹配。`行E`将选择由`行2`创建的`f()`，因为两个输入变量是相同类型。最后，`行F`和`行G`将分别选择`行0`和`行3`中的模板创建的函数。
- en: Having learned about the functional templates, we will now move on to class
    templates.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了函数模板之后，我们现在将转向类模板。
- en: Class templates
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类模板
- en: A class template defines a family of classes, and it is often used to implement
    a container. For example, the C++ Standard Library contains many class templates,
    such as `std::vector`, `std::map`, `std::deque`, and so on. In *OpenCV*, `cv::Mat`
    is a very powerful class template and it can handle 1D, 2D, and 3D matrices or
    images with built-in data types such as `int8_t`, `uint8_t`, `int16_t`, `uint16_t`,
    `int32_t`, `uint32_t`, `float`, `double`, and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板定义了一组类，并且通常用于实现容器。例如，C++标准库包含许多类模板，如`std::vector`、`std::map`、`std::deque`等。在OpenCV中，`cv::Mat`是一个非常强大的类模板，它可以处理具有内置数据类型的1D、2D和3D矩阵或图像，如`int8_t`、`uint8_t`、`int16_t`、`uint16_t`、`int32_t`、`uint32_t`、`float`、`double`等。
- en: 'Similar to function templates, as shown in the following diagram, the concept
    of class templates contains a template creation syntax, its specialization, and
    its implicit and explicit instantiations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数模板类似，如下图所示，类模板的概念包含模板创建语法、其专门化以及其隐式和显式实例化：
- en: '![](img/2f784eca-cdaf-490e-9514-942bf80883ac.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f784eca-cdaf-490e-9514-942bf80883ac.png)'
- en: In **part I** of the preceding diagram, with a certain syntax format, we can
    create a class template for generic types, also known as a primary template, and
    it can be customized for special types with different member functions and/or
    variables. Once we have a class template, in **part II**, the compiler will instantiate
    it to template classes either explicitly or implicitly based on the application's
    demand.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表的**part I**中，使用特定的语法格式，我们可以为通用类型创建一个类模板，也称为主模板，并且可以根据应用的需求为特殊类型定制不同的成员函数和/或变量。一旦有了类模板，在**part
    II**中，编译器将根据应用的需求显式或隐式地将其实例化为模板类。
- en: Now, let's look at the syntax for creating a class template.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下创建类模板的语法。
- en: Syntax
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: 'The syntax for creating a class template is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类模板的语法如下：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we have the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有以下内容：
- en: '`template_parameter-list` (see the link in *further reading* context [10]) is
    a non-empty comma-separated list of the template parameters, each of which is
    either a non-type parameter, a type parameter, a template parameter, or a parameter
    pack of any of those.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template_parameter-list`（参见*进一步阅读*上下文中的链接[10]）是模板参数的非空逗号分隔列表，每个参数都是非类型参数、类型参数、模板参数或任何这些的参数包。'
- en: '`class-declaration` is the part that''s used to declare a class that contains
    a class name and its body in curly brackets. By doing so, the declared class name
    also becomes a template name.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class-declaration`是用于声明包含类名和其主体的类的部分，用大括号括起来。通过这样做，声明的类名也成为模板名。'
- en: 'For example, we can define a class template, `V`, so that it contains all kinds
    of 1D data types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个类模板`V`，使其包含各种1D数据类型：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we have this class template, the compiler can generate classes during the
    instantiation process. For the reason we mentioned in the *Function template*
    subsection, we will avoid using the imprecise term `template` class in this book.
    Instead, we will use the class template.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了这个类模板，编译器就可以在实例化过程中生成类。出于我们在*函数模板*子节中提到的原因，我们将避免在本书中使用不精确的术语`template`类。相反，我们将使用类模板。
- en: Instantiation
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化
- en: 'Considering the class template, `V`, we defined in the previous section, we''ll
    assume the following declarations appear later:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前一节中我们定义的类模板`V`，我们假设后面会出现以下声明：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, the compiler will create three instances of the `V` class, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器将创建`V`类的三个实例，如下所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similar to function template instantiation, there are two forms of class template
    instantiation – explicit instantiation and implicit instantiation. Let's take
    a look at them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数模板实例化类似，类模板实例化有两种形式 - 显式实例化和隐式实例化。让我们来看看它们。
- en: Explicit instantiation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式实例化
- en: 'The syntax for explicit instantiation is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实例化的语法如下：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An explicit instantiation definition forces instantiation of the class, struct,
    or union they refer to. In the C++0x standard, the implicit instantiation of a
    template specialization or its members is suppressed. Similar to the explicit
    instantiation of function templates, the location of this explicit instantiation
    can be anywhere after its template definition, and it is only permitted to be
    defined once in the entire program in one file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实例化定义会强制实例化它们所引用的类、结构或联合体。在C++0x标准中，模板特化或其成员的隐式实例化被抑制。与函数模板的显式实例化类似，这种显式实例化的位置可以在其模板定义之后的任何位置，并且在整个程序中只允许定义一次。
- en: Moreover, since C++11, an implicit instantiation step will be bypassed by an
    explicit instantiation declaration (extern template). This can be used to reduce
    compilation times.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，自C++11以来，显式实例化声明（extern template）将绕过隐式实例化步骤，这可以用于减少编译时间。
- en: 'Going back to the template class, `V`, we can explicitly instantiate it as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 回到模板类`V`，我们可以显式实例化它如下：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, we can do the following (since C++11):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样做（自C++11以来）：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The compiler will present us with an error message if we explicitly instantiate
    a function or class template but there is no corresponding definition in the program,
    as shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们显式实例化函数或类模板，但程序中没有相应的定义，编译器将给出错误消息，如下所示：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code block, we defined a class template between lines A and
    B, and then we implemented its member function, `foo()`, from `lines C` to `line
    D`. Next, we explicitly instantiated it for the `int` type at `line E`. Since
    the code block between `lines F` and `line G` is commented out (which means that
    there is no corresponding definition of `foo()` for this explicit `int` type instantiation),
    we have a linkage error. To fix this, we need to replace `#if 0` with `#if 1`
    at `line F`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们在A行和B行之间定义了一个类模板，然后我们从C行到D行实现了它的成员函数`foo()`。接下来，我们在E行明确地为`int`类型实例化了它。由于在F行和G行之间的代码块被注释掉了（这意味着对于这个显式的`int`类型实例化，没有相应的`foo()`定义），我们会得到一个链接错误。为了解决这个问题，我们需要在F行用`#if
    1`替换`#if 0`。
- en: 'Finally, there are some additional restrictions for explicit instantiation
    declarations, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，显式实例化声明还有一些额外的限制，如下所示：
- en: '**Static**: A static class member can be named, but a static function cannot
    be allowed in an explicit instantiation declaration.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态：静态类成员可以命名，但静态函数不能在显式实例化声明中允许。
- en: '**Inline**: There is no effect for inline functions in explicit instantiation
    declarations, and inline functions are implicitly instantiated.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联：在显式实例化声明中，内联函数没有影响，内联函数会被隐式实例化。
- en: '**Class and its members**: It is no equivalent for explicitly instantiating
    a class and all its members.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类及其成员：显式实例化类及其所有成员没有等价物。
- en: Implicit instantiation
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式实例化
- en: 'When referring to a template class, the compiler will only generate code from
    its template on-demand if it has not been explicitly instantiated or explicitly
    specialized. This is called **implicit instantiation**, and its syntax is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用模板类时，如果没有显式实例化或显式专门化，编译器将只在需要时从其模板生成代码。这称为**隐式实例化**，其语法如下：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For a non-pointer object, a template class is instantiated and its object is
    created, but only the member functions used by this object are generated. For
    a pointer object, unless a member is used in the program, it is not instantiated.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非指针对象，模板类被实例化并创建其对象，但只生成此对象使用的成员函数。对于指针对象，除非程序中使用了成员，否则不会实例化。
- en: 'Consider the following example, where we define a class template, `X` ,in the
    `ch4_5_class_template_implicit_inst.h` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，在该示例中，我们在`ch4_5_class_template_implicit_inst.h`文件中定义了一个名为`X`的类模板。
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, it is included by the following four `cpp` files, which has `ain()` in
    each:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它被以下四个`cpp`文件包含，每个文件中都有`ain()`：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In `ch4_5_class_template_implicit_inst_A.cpp`, the compiler will implicitly
    instantiate the `X<int>` and `X<float>` classes, and then create the `xi` and
    `xf` objects. But since `X::f()` and `X::g()` are not used, they are not instantiated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch4_5_class_template_implicit_inst_A.cpp`中，编译器将隐式实例化`X<int>`和`X<float>`类，然后创建`xi`和`xf`对象。但由于未使用`X::f()`和`X::g()`，它们不会被实例化。
- en: 'Now, let''s look at `ch4_5_class_template_implicit_inst_B.cpp`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`ch4_5_class_template_implicit_inst_B.cpp`：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the compiler will implicitly instantiate the `X<int>` class, create the `xi` object,
    and then generate the `X<int>::f()` function, but not `X<int>::g()`. Similarly,
    it will instantiate the `X<float>` class, create the `xf` object, and generate
    the `X<float>::g()` function, but not `X<float>::f()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编译器将隐式实例化`X<int>`类，创建`xi`对象，然后生成`X<int>::f()`函数，但不会生成`X<int>::g()`。类似地，它将实例化`X<float>`类，创建`xf`对象，并生成`X<float>::g()`函数，但不会生成`X<float>::f()`。
- en: 'Then, we have `ch4_5_class_template_implicit_inst_C.cpp`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`ch4_5_class_template_implicit_inst_C.cpp`：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since `p_xi` and `p_xf` are pointer objects, there is no need to instantiate
    their corresponding template classes through the compiler.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`p_xi`和`p_xf`是指针对象，因此无需通过编译器实例化它们对应的模板类。
- en: 'Finally, we have `ch4_5_class_template_implicit_inst_D.cpp`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`ch4_5_class_template_implicit_inst_D.cpp`：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will implicitly instantiate `X<int>` and `X<int>::f()`, but not `X<int>::g()`;
    similarly, for `X<float>`, `X<float>::f()` and `X<float>::g()` will be instantiated.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将隐式实例化`X<int>`和`X<int>::f()`，但不会实例化`X<int>::g()`；同样，对于`X<float>`，将实例化`X<float>::f()`和`X<float>::g()`。
- en: Specialization
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专门化
- en: Similar to function specialization, the explicit specialization of a class template
    defines a different implementation for a primary template when a specific type
    is passed as a template parameter. However, it is still a class template and you
    need to get the real code by instantiation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数专门化类似，当将特定类型作为模板参数传递时，类模板的显式专门化定义了主模板的不同实现。但是，它仍然是一个类模板，您需要通过实例化来获得真正的代码。
- en: 'For example, let''s suppose that we have a `struct X` template that can store
    one element of any data type, and it has just one member function named `increase()`.
    But for the char type data, we want a different implementation of `increase()`
    and need to add a new member function called `toUpperCase()` to it. Therefore,
    we decide to declare a class template specialization for that type. We do this
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个`struct X`模板，可以存储任何数据类型的一个元素，并且只有一个名为`increase()`的成员函数。但是对于char类型数据，我们希望`increase()`有不同的实现，并且需要为其添加一个名为`toUpperCase()`的新成员函数。因此，我们决定为该类型声明一个类模板专门化。我们可以这样做：
- en: 'Declare a primary class template:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个主类模板：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This step declares a primary class template in which its constructor initializes
    the `m` member variable and `increase()` adds one to `m` and returns its value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步声明了一个主类模板，其中它的构造函数初始化了`m`成员变量，`increase()`将`m`加一并返回其值。
- en: 'Next, we need to perform specialization for the char type data:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为char类型数据执行专门化：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This step creates a specialized (with respect to the primary class template)
    class template with an additional member function, `toUpperCase()`, for the char
    type data only.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步为char类型数据创建了一个专门化（相对于主类模板），并为其添加了一个额外的成员函数`toUpperCase()`。
- en: 'Now, we run a test:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们进行测试：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, we have a `main()` function to test it. In line A, `x1` is an object
    that has been implicitly instantiated from the primary template, `X<T>`*.* Since
    the initial value of `x1.m` is `5`, `6` will be returned from `x1.increase()`.
    In `line B`, `x2` is an object instantiated from the specialization template, `X<char>`,
    and the value of `x2.m` is `b` when it is executed. After calling `x2.toUpperCase()`,
    `B` will be the return value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个`main()`函数来测试它。在A行，`x1`是一个从主模板`X<T>`隐式实例化的对象。由于`x1.m`的初始值是`5`，所以`x1.increase()`将返回`6`。在B行，`x2`是从专门化模板`X<char>`实例化的对象，当它执行时，`x2.m`的值是`b`。在调用`x2.toUpperCase()`之后，`B`将是返回值。
- en: The complete code for this example can be found at `ch4_6_class_template_specialization.cpp`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码可以在`ch4_6_class_template_specialization.cpp`中找到。
- en: 'In summary, the syntax that''s used in the class template''s explicit specialization
    is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在类模板的显式专门化中使用的语法如下：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, the empty template parameter list, `template <>`, is used to explicitly
    declare it as a template specialization and `<template argument list>` is the
    type parameter(s) to be specialized. For example, in `ex4_6_class_template_specialization.cpp`,
    we use the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，空的模板参数列表`template <>`用于显式声明它为模板专门化，`<template argument list>`是要专门化的类型参数。例如，在`ex4_6_class_template_specialization.cpp`中，我们使用以下内容：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, `<char>` after `X` identifies the type we are going to declare a template
    class specialization for.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`X`之后的`<char>`标识了我们要为其声明模板类专门化的类型。
- en: Additionally, when we do specializations for a template class, all its members
    – even those that are identical in the primary template – must be defined because
    there is no inheritance concept for the primary template during template specializations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们为模板类进行特化时，即使在主模板中相同的成员也必须被定义，因为在模板特化期间没有主模板的继承概念。
- en: Next, we'll take a look at partial specialization. This is a general statement
    of explicit specialization. Compared to the format of explicit specialization,
    which only has a template argument list, both the template parameter list and
    argument list are required for a partial specialization. For a template instantiation,
    the partial specialization template will be selected by the compiler if a user's
    template argument list matches a subset of the template arguments. Then, a new
    class definition from the partial specialization template will be generated by
    the compiler.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下部分特化。这是显式特化的一般陈述。与只有模板参数列表的显式特化格式相比，部分特化需要模板参数列表和参数列表。对于模板实例化，如果用户的模板参数列表与模板参数的子集匹配，编译器将选择部分特化模板，然后编译器将从部分特化模板生成新的类定义。
- en: 'In the following example, for the primary class template `A`, we can partially
    specialize it for const `T` in the argument list. Note that both of them have
    the same parameter list, which is `<typename T>`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，对于主类模板`A`，我们可以为参数列表中的const `T`进行部分特化。请注意，它们的参数列表相同，即`<typename T>`：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the following example, the primary class template `B` has two parameters:
    `<typename T1` and `typename T2 >`. We partially specialize it by `T1=int`, keeping
    `T2` unchanged:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，主类模板`B`有两个参数：`<typename T1`和`typename T2 >`。我们通过`T1=int`进行部分特化，保持`T2`不变：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, in the following example, we can see that the number of template parameters
    in a partial specialization does not have to match the parameter numbers that
    appeared in the original primary template. However, the number of template arguments
    (appearing after the class name in angle brackets) must match the number and type
    of the parameters in the primary template:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下面的示例中，我们可以看到部分特化中的模板参数数量不必与原始主模板中出现的参数数量匹配。然而，模板参数的数量（出现在尖括号中的类名后面）必须与主模板中的参数数量和类型匹配：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, a class template partial specialization is still a class template. You
    must provide definitions for its member functions and number variables separately.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类模板的部分特化仍然是一个类模板。您必须为其成员函数和数量变量分别提供定义。
- en: 'To end this section, let''s summarize what we''ve learned so far. In the following
    table, you can see a comparison between function and class templates, their instantiation,
    and specialization:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结束本节，让我们总结一下我们到目前为止学到的内容。在下表中，您可以看到函数和类模板、它们的实例化和特化之间的比较：
- en: '|  | **Function Templates** | **Class Templates** | **Comments** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| | **函数模板** | **类模板** | **注释** |'
- en: '| Declaration | `template <class T1, class T2>``void f(T1 a, T2 b) { ... }`
    | `template <class T1, class T2>``class X { ... };` | The declaration defines
    a function/class template, `<class T1, class T2>` called template parameters.
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: 声明|`template <class T1, class T2>` `void f(T1 a, T2 b) { ... }`|`template <class
    T1, class T2>` `class X { ... };`|声明定义了一个函数/类模板，`<class T1, class T2>`称为模板参数。
- en: '| ExplicitInstantiation | `template void f <int, int >( int, int);`orextern
    template`void f <int, int >( int, int);`(since C++11) | `template class X<int,
    float>;`or`extern template class X<int,float>;`(since C++11) | After instantiation
    there are now functions/classes, but they are called template functions/classes.
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: 显式实例化|`template void f <int, int >( int, int);`或`extern template`void f <int,
    int >( int, int);`（自C++11起）|`template class X<int, float>;`或`extern template class
    X<int,float>;`（自C++11起）|实例化后现在有函数/类，但它们被称为模板函数/类。
- en: '| ImplicitInstantiation | {...`f(3, 4.5);``f<char, float>(120, 3.14);`} | {...`X<int,float>
    obj;``X<char, char> *p;`} | When a function call or a class object/pointer is
    declared, if it has not been explicitly instantiated, the implicit instantiation
    approach used. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: 隐式实例化|{...`f(3, 4.5);` `f<char, float>(120, 3.14);`}|{...`X<int,float> obj;`
    `X<char, char> *p;`}|当函数调用或类对象/指针声明时，如果没有被显式实例化，则使用隐式实例化方法。
- en: '| Specialization | `template <>``void f<int,float>(int a, float b)``{ ... }`
    | `template <>``class X <int, float>{ ... };` | A fully customized version (no
    parameter list) of the primary template still needs to be instantiated. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: 特化|`template <>` `void f<int,float>(int a, float b)`|`template <>` `class X
    <int, float>{ ... };`|主模板的完全定制版本（无参数列表）仍然需要被实例化。
- en: '| Partial Specialization | `template <class T>``void f<T,T>(T a, T b)``{ ...
    }` | `template <class T>``class X <T, T>{ ... };` | A partial customized version
    (has a parameter list) of the primary template still needs to be instantiated.
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: 部分特化|`template <class T>` `void f<T, T>(T a, T b)`|`template <class T>` `class
    X <T, T>`|主模板的部分定制版本（有参数列表）仍然需要被实例化。
- en: 'Five concepts need to be emphasized here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要强调五个概念：
- en: '**Declaration**: We need to follow the syntax that''s used to define a function
    or class template. At this point, a function or class template by itself is not
    a type, a function, or any other entity. In other words, there are only template
    definitions in the source file and no code, which can be complied to an object
    file, is generated.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明**：我们需要遵循用于定义函数或类模板的语法。此时，函数或类模板本身不是类型、函数或任何其他实体。换句话说，在源文件中只有模板定义，没有代码可以编译成对象文件。'
- en: '**Implicit Instantiation**: For any code to appear, a template must be instantiated.
    During this process, it becomes imperative to determine the template arguments
    so that the compiler can generate an actual function or class. In other words,
    they are compiled on-demand, which means that compiling the code of a template
    function or class does not happen until an instantiation with specific template
    arguments is given.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式实例化**：对于任何代码的出现，都必须实例化一个模板。在这个过程中，必须确定模板参数，以便编译器可以生成实际的函数或类。换句话说，它们是按需编译的，这意味着在给定特定模板参数的实例化之前，模板函数或类的代码不会被编译。'
- en: '**Explicit Instantiation**: Tells the compiler to instantiate the template
    with the given types, regardless of whether they are used. Typically, it is used
    for providing libraries.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式实例化**：告诉编译器使用给定类型实例化模板，无论它们是否被使用。通常用于提供库。'
- en: '****Full Specialization****: This has no parameter list (fully customized);
    it only has an argument list. The most useful thing about template specialization
    is that you can create special templates for particular type arguments.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****完全特化****：这没有参数列表（完全定制）；它只有一个参数列表。模板特化最有用的一点是，您可以为特定类型参数创建特殊模板。'
- en: '**Partial Specialization**: This is similar to fully specialization, but is
    part parameter list (partially customized) and part argument list.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分特化**：这类似于完全特化，但是部分参数列表（部分定制）和部分参数列表。'
- en: Understanding variadic templates
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解可变模板
- en: In the previous section, we learned how to write function or class templates
    with a fixed number of type parameters. But since C++11, standard generic functions
    and class templates can accept a variable number of type parameters. This is called **variadic
    templates**, which is an extension of C++ in *Further reading* context [6]. We
    will learn about the syntax and usage of variadic templates by looking at examples.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们学习了如何编写具有固定数量类型参数的函数或类模板。但自C++11以来，标准通用函数和类模板可以接受可变数量的类型参数。这被称为**可变模板**，它是C++的扩展，详情请参阅*Further
    reading* [6]。我们将通过示例学习可变模板的语法和用法。
- en: Syntax
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: 'If a function or class template takes zero or more parameters, it can be defined
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数或类模板需要零个或多个参数，可以定义如下：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, `<typename ... Args>` declares a parameter pack. Note that here, `Args`
    is not a keyword; you can use any valid variable names. The preceding class/function
    template can take any number of `typename` as its arguments need to be instantiated,
    as shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<typename ... Args>`声明了一个参数包。请注意，这里的`Args`不是关键字；您可以使用任何有效的变量名。前面的类/函数模板可以接受任意数量的`typename`作为其需要实例化的参数，如下所示：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If a variadic template needs at least one type parameter, then the following
    definition is used:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可变模板需要至少一个类型参数，则使用以下定义：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Similarly, we can instantiate them by using the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用以下代码来实例化它们：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, we created the `y1` and `y2` objects from the instantiations
    of the variadic class template, `Y`, with one and three template arguments, respectively.
    For the variadic function `goo` template, we instantiate it as two template functions
    with two and three template arguments, respectively.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了`y1`和`y2`对象，它们是通过具有一个和三个模板参数的可变类模板`Y`的实例化而得到的。对于可变函数`goo`模板，我们将它实例化为两个模板函数，分别具有两个和三个模板参数。
- en: Examples
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'The following is probably the simplest example that shows a variadic template
    being used to find the minimum values of any input argument list. This example
    is using the concept of recursion until it reaches `my_min(double n)` to exit:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下可能是最简单的示例，展示了使用可变模板来查找任何输入参数列表的最小值。这个示例使用了递归的概念，直到达到`my_min(double n)`为止：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `printf()` variadic function is probably one of the most useful and powerful
    functions in C or C++; however, it''s not type-safe. In the following code block,
    we''re adopting the classic type-safe `printf()` example to demonstrate the usefulness
    of variadic template. As always, first, we need to define a base function, `void
    printf_vt(const char *s)`, which ends the recursion:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf()`可变参数函数可能是C或C++中最有用和强大的函数之一；但是，它不是类型安全的。在下面的代码块中，我们采用了经典的类型安全`printf()`示例来演示可变模板的用处。首先，我们需要定义一个基本函数`void
    printf_vt(const char *s)`，它结束了递归：'
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, in its variadic template function, `printf_vt()`, whenever `%` is hit,
    the value is printed, and the rest is passed to its recursion until the base function
    is reached:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在其可变模板函数`printf_vt()`中，每当遇到`%`时，该值被打印，其余部分被传递给递归，直到达到基本函数：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we can test and compare it with the traditional `printf()` using the
    following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下代码进行测试和比较传统的`printf()`。
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: At the beginning of the first line, we can see some ASCII characters from `printf()`
    because the corresponding variable type of `%s` should be a pointer to chars,
    but we give it a type of `std::string`. To fix this, we need to pass `s.c_str()`.
    However, with the variadic template version function, we do not have this issue.
    Moreover, we only need to provide `%`, which is even better – at least, it is
    for this implementation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行的开头，我们可以看到一些来自`printf()`的ASCII字符，因为`%s`的相应变量类型应该是指向字符的指针，但我们给它一个`std::string`类型。为了解决这个问题，我们需要传递`s.c_str()`。然而，使用可变模板版本的函数，我们就没有这个问题。此外，我们只需要提供`%`，这甚至更好
    - 至少对于这个实现来说是这样。
- en: 'In summary, this section briefly introduced variadic templates and their applications.
    Variadic templates provide the following benefits (since C++11):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，本节简要介绍了可变模板及其应用。可变模板提供了以下好处（自C++11以来）：
- en: It is a lightweight extension to the template family.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是模板家族的一个轻量级扩展。
- en: It demonstrates the ability to implement numerous template libraries without
    the use of ugly templates and preprocessor macros. Thus, the implementation code
    is capable of being understood and debugged, and it saves compile time as well.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它展示了在不使用丑陋的模板和预处理宏的情况下实现大量模板库的能力。因此，实现代码可以被理解和调试，并且还节省了编译时间。
- en: It enables type-safe implementations of `printf()` variadic functions.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使`printf()`可变参数函数的类型安全实现成为可能。
- en: Next, we will explore template parameters and arguments.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨模板参数和参数。
- en: Exploring template parameters and arguments
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模板参数和参数
- en: We learned about function and class templates and their instantiations in previous
    two sections. We know that, when defining a template, its parameter list need
    to be given. While we instantiate it, the corresponding argument list must be
    provided. In this section, we will further study the classifications and details
    of these two lists.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两节中，我们学习了函数和类模板及其实例化。我们知道，在定义模板时，需要给出其参数列表。而在实例化时，必须提供相应的参数列表。在本节中，我们将进一步研究这两个列表的分类和细节。
- en: Template parameters
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板参数
- en: 'Recall the following syntax, which is used to define a class/function template.
    There is a `<>` symbol after the `template` keyword, in which one or more template
    parameters must be given:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下以下语法，用于定义类/函数模板。在`template`关键字后面有一个`<>`符号，在其中必须给出一个或多个模板参数：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A parameter inside the parameter list could be one of the following three types:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表中的参数可以是以下三种类型之一：
- en: '`Non-type template parameter`: Refers to the compile-time constant values,
    such as integers and pointers, that reference static entities. These are often
    referred to as non-type parameters.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`非类型模板参数`：指的是编译时常量值，如整数和指针，引用静态实体。这些通常被称为非类型参数。'
- en: '`Type template parameter`: This refers to either built-in type names or user-defined
    classes.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类型模板参数`：指的是内置类型名称或用户定义的类。'
- en: '`Template template parameter`: This indicates the parameters are other templates.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模板模板参数`：表示参数是其他模板。'
- en: We'll discuss these in more detail in the following subsections.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的小节中更详细地讨论这些内容。
- en: Non-type template parameter
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非类型模板参数
- en: 'The syntax of the non-type template parameter is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 非类型模板参数的语法如下：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `type` is one of the following types – integral type, enumeration, pointer
    to object or to function, `lvalue` reference to an object or to a function, pointer
    to member object or to member function, and `std::nullptr_t` (since C++11). Additionally,
    we may put arrays and/or function types in template declarations, but they are
    automatically replaced with data and/or function pointer(s).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`type`是以下类型之一 - 整数类型、枚举、对象或函数的指针、对象或函数的`lvalue`引用、成员对象或成员函数的指针，以及`std::nullptr_t`（自C++11起）。此外，我们可以在模板声明中放置数组和/或函数类型，但它们会自动替换为数据和/或函数指针。
- en: 'The following example shows a class template that uses a non-type template
    parameter, `int N`. In `main()`, we instantiate and create an object, `x`, and
    thus `x.a` has five elements with initial values of `1`. After setting its fourth
    element value as `10`, we print the output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个使用非类型模板参数`int N`的类模板。在`main()`中，我们实例化并创建了一个对象`x`，因此`x.a`有五个初始值为`1`的元素。在将其第四个元素的值设置为`10`后，我们打印输出：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is an example of a function template that uses `const char*`
    as a non-type template parameter:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`const char*`作为非类型模板参数的函数模板示例：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In `main()`, we successfully instantiate `foo()` with `str1` and `str2` since
    they are both compile-time constant values and have external linkages. Then, if
    we uncomment lines 3-5, the compiler will report error messages. The reasons for
    getting these compiler errors are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们成功地用`str1`和`str2`实例化了`foo()`，因为它们都是编译时常量值并且具有外部链接。然后，如果我们取消注释第3-5行，编译器将报告错误消息。出现这些编译器错误的原因如下：
- en: '**Line 3**: `str3` is not a const variable, so the value being pointed to by
    `str3` cannot be changed. However, the value of `str3` can be changed.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3行**：`str3`不是一个const变量，所以`str3`指向的值不能被改变。然而，`str3`的值可以被改变。'
- en: '**Line 4**: `str4` is not a valid template argument of the `const char*` type
    because it has no linkage.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第4行**：`str4`不是`const char*`类型的有效模板参数，因为它没有链接。'
- en: '**Line 5**: `str5` is not a valid template argument of the `const char*` type
    because it has no linkage.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5行**：`str5`不是`const char*`类型的有效模板参数，因为它没有链接。'
- en: Another of the most common usages of non-type parameters is the size of an array.
    If you want to find out more, please go to [https://stackoverflow.com/questions/33234979](https://stackoverflow.com/questions/33234979).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 非类型参数的最常见用法之一是数组的大小。如果您想了解更多，请访问[https://stackoverflow.com/questions/33234979](https://stackoverflow.com/questions/33234979)。
- en: Type template parameter
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型模板参数
- en: 'The syntax of the type template parameter is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 类型模板参数的语法如下：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Note:**Here, we use the `typename` and `class` keywords interchangeably.
    Inside the body of the template declaration, the name of a type parameter is a
    `typedef-name`. When the template is instantiated, it aliases the type supplied.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**在这里，我们可以互换使用`typename`和`class`关键字。在模板声明的主体内，类型参数的名称是`typedef-name`。当模板被实例化时，它将别名为提供的类型。'
- en: 'Now, let''s look at some examples:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些例子：
- en: 'A type template parameter without the default:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有默认值的类型模板参数：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A type template parameter with the default:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有默认值的类型模板参数：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A type template parameter pack:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型模板参数包：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This template parameter pack can accept zero or more template arguments, and
    it only works on C++11 onward.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板参数包可以接受零个或多个模板参数，并且仅适用于C++11及以后的版本。
- en: Template template parameter
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板模板参数
- en: 'The syntax of the template template parameter is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模板参数的语法如下：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Note**: In template template parameter declaration, only the `class` keyword
    can be used; `typename` is not allowed. In the body of the template declaration,
    the name of a parameter is a `template-name`, and we need arguments to instantiate
    it.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在模板模板参数声明中，只能使用`class`关键字；不允许使用`typename`。在模板声明的主体中，参数的名称是`template-name`，我们需要参数来实例化它。'
- en: 'Now, suppose you have a function that acts as a stream output operator for
    a list of objects:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您有一个函数，它充当对象列表的流输出运算符：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'From the preceding code, you can see that for sequence containers such as vectors,
    double end queues, and a multitude of map types, they are the same. Hence, using
    the concept of the template template parameter, it would be possible to have a
    single operator, `<<`, to rule them all. An example of this can be found in `exch4_tp_c.cpp`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，您可以看到对于序列容器（如向量，双端队列和多种映射类型），它们是相同的。因此，使用模板模板参数的概念，可以有一个单一的运算符`<<`来控制它们。这种情况的示例可以在`exch4_tp_c.cpp`中找到：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 前面程序的输出如下：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As expected, the first part of the output for each call is the template function
    name in a `pretty` format, while the second part outputs the element values of
    each container.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，每次调用的输出的第一部分是`pretty`格式的模板函数名称，而第二部分输出每个容器的元素值。
- en: Template arguments
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板参数
- en: To instantiate a template, all the template parameters must be replaced with
    their corresponding template arguments. The arguments are either explicitly provided,
    deduced from the initializer (for class templates), deduced from the context (for
    function templates), or defaulted. Since there are three categories of template
    parameters, we will have three corresponding template arguments as well. These
    are template non-type arguments, template type arguments, and template template
    arguments*.* Besides these, we will also discuss the default template arguments.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化模板，必须用相应的模板参数替换所有模板参数。参数可以是显式提供的，从初始化程序中推导出（对于类模板），从上下文中推导出（对于函数模板），或者默认值。由于有三种模板参数类别，我们也将有三个相应的模板参数。这些是模板非类型参数，模板类型参数和模板模板参数。除此之外，我们还将讨论默认模板参数。
- en: Template non-type arguments
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板非类型参数
- en: Recall that non-type template parameters refer to compile-time constant values
    such as integers, pointers, and references to static entities. A non-type template
    argument provided in the template argument list must match with one of these values.
    Typically, non-type template arguments are used for class initialization or the
    class container's size specifications.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，非类型模板参数是指编译时常量值，如整数，指针和对静态实体的引用。在模板参数列表中提供的非类型模板参数必须与这些值中的一个匹配。通常，非类型模板参数用于类初始化或类容器的大小规格。
- en: Although a discussion of the detailed rules for each type (integral and arithmetic
    types, pointers to objects/functions/members, `lvalue` reference parameters, and
    so on) of non-type argument is beyond the scope of this book, the overall general
    rule is that the template non-type arguments should be converted into constant
    expressions of the corresponding template parameters.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管讨论每种类型（整数和算术类型，指向对象/函数/成员的指针，`lvalue`引用参数等）的详细规则超出了本书的范围，但总体的一般规则是模板非类型参数应转换为相应模板参数的常量表达式。
- en: 'Now, let''s take a look at the following example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看下面的例子：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding code, in `part 1`, we defined three template structs with different
    non-type template parameters. Then, in `part 2`, we declared two overload functions
    and `struct Y`. Finally, in `part 3`, we looked at the correct way to instantiate
    them by different non-type arguments.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在`part 1`中，我们定义了具有不同非类型模板参数的三个模板结构。然后，在`part 2`中，我们声明了两个重载函数和`struct
    Y`。最后，在`part 3`中，我们看了通过不同的非类型参数正确实例化它们的方法。
- en: Template type arguments
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板类型参数
- en: Compared to the template non-type arguments, the rule of a template type argument
    (for a type template parameter) is simple and requires that it must be a `typeid`.
    Here, a `typeid` is a standard C++ operator that returns type identification information
    at runtime. It basically returns a `type_info` object that can be compared with
    other `type_info` objects.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 与模板非类型参数相比，模板类型参数（用于类型模板参数）的规则很简单，要求必须是`typeid`。在这里，`typeid`是一个标准的C++运算符，它在运行时返回类型识别信息。它基本上返回一个可以与其他`type_info`对象进行比较的`type_info`对象。
- en: 'Now, let''s look at the following example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看下面的例子：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this example, in `part 1`, we defined three classes and function templates:
    the class template C with its type template parameter, two function templates
    with a type template parameter, and a non-type template parameter, respectively.
    In `part 2`, we have an incomplete `struct A` and an unnamed type, `struct B`.
    Finally, in `part 3`, we tested them. The outputs of the four `typeid()` in Ubuntu
    18.04 are as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在`part 1`中，我们定义了三个类和函数模板：具有其类型模板参数的类模板C，具有类型模板参数的两个函数模板，以及一个非类型模板参数。在`part
    2`中，我们有一个不完整的`struct A`和一个无名类型`struct B`。最后，在`part 3`中，我们对它们进行了测试。在Ubuntu 18.04中四个`typeid()`的输出如下：
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'From x86 MSVC v19.24, we have the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从x86 MSVC v19.24，我们有以下内容：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Additionally, since `A`, A*, `B`, and `int()` have typeids, the code segment
    from lines A to D is linked with the template type classes or functions. Only
    line E is instantiated from the non-type template parameter function template,
    that is, `f()`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于`A`，A*，`B`和`int()`具有typeid，因此从A到D行的代码段与模板类型类或函数相关联。只有E行是从非类型模板参数函数模板实例化的，即`f()`。
- en: Template template arguments
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板模板参数
- en: For a template template parameter, its corresponding template argument is the
    name of a class template or a template alias. While finding a template to match
    the template template argument, only primary class templates are considered.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模板模板参数，其对应的模板参数是类模板或模板别名的名称。在查找与模板模板参数匹配的模板时，只考虑主类模板。
- en: Here, a primary template refers to the template that is being specialized. Even
    though their parameter lists might match, the compiler will not consider any partial
    specialization with that of the template template parameter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，主模板是指正在进行特化的模板。即使它们的参数列表可能匹配，编译器也不会考虑与模板模板参数的部分特化。
- en: 'Here is an example of a template template argument:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模板模板参数的示例：
- en: '[PRE61]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this example, we're defining a primary class template, `X`, and its specialization,
    then a class template, `Y`, with a template template parameter. Next, we implicitly
    instantiate `Y` with template template argument `X` and create an object, `c`.
    Finally, `main()` outputs the names of the four `typeid()`, and the results are
    `int`, `char`, `char`, and `char`, respectively.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个主类模板`X`及其特化，然后是一个带有模板模板参数的类模板`Y`。接下来，我们隐式实例化`Y`，并使用模板模板参数`X`创建一个对象`c`。最后，`main()`输出了四个`typeid()`的名称，结果分别是`int`、`char`、`char`和`char`。
- en: Default template arguments
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认模板参数
- en: 'In C++, a function is called by passing arguments, and the arguments are used
    by the function. If, while invoking a function, the arguments are not passed,
    the default values are used. Similar to the function parameter default values,
    template parameters can have default arguments. When we define a template, we
    can set its default arguments, like so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，通过传递参数来调用函数，并且函数使用这些参数。如果在调用函数时未传递参数，则使用默认值。与函数参数默认值类似，模板参数可以有默认参数。当我们定义模板时，可以设置其默认参数，如下所示：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'There are certain rules that need to be followed when we set the default arguments
    for template parameters:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置模板参数的默认参数时，需要遵循一些规则：
- en: The declaration order matters – the declaration of the default template arguments
    must be on the top of the primary template declaration. For instance, in the preceding
    example, you cannot move the code at lines 3 and 4 after line 9.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明顺序很重要——默认模板参数的声明必须在主模板声明的顶部。例如，在前面的例子中，不能将代码移动到第3行和第4行之后的第9行之后。
- en: 'If one parameter has a default argument, then all the parameters after it must
    also have default arguments. For example, the following code is incorrect:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个参数有默认参数，那么它后面的所有参数也必须有默认参数。例如，以下代码是不正确的：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You cannot give the same parameter default arguments twice in the same scope.
    For example, you will get an error message if you use the following code:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一作用域中不能给相同的参数设置默认参数两次。例如，如果使用以下代码，将收到错误消息：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, we have discussed two lists: `template_parameter_list` and `template_argument_list`.
    These are used in function or class template creation and instantiation*,* respectively*.*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们讨论了两个列表：`template_parameter_list`和`template_argument_list`。这些分别用于函数或类模板的创建和实例化。
- en: 'We also learned about two other important rules:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了另外两个重要规则：
- en: 'When we define a class or function template, we need to give its `template_parameter_list`:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们定义类或函数模板时，需要给出其`template_parameter_list`：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When we instantiate them, we must provide the corresponding `argument_list`:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们实例化它们时，必须提供相应的`argument_list`：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The parameter or argument types in these two lists can be classified into three
    categories, as shown in the following table. Note that although the top row is
    for class templates, these properties also apply to function templates:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个列表中的参数或参数类型可以分为三类，如下表所示。请注意，尽管顶行是用于类模板，但这些属性也适用于函数模板：
- en: '|  | **When defining a template****template** **<template_parameter_list> class
    X { ... }** | **When instantiating a template****class X<template_argument_list>
    x** |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|  | **定义模板时****template** **<template_parameter_list> class X { ... }** |
    **实例化模板时****class X<template_argument_list> x** |'
- en: '| non-type | An entity in this parameter list can be one of the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '| 非类型 | 此参数列表中的实体可以是以下之一：'
- en: Integral or enumeration
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数或枚举
- en: Pointer to object or pointer to function
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象指针或函数指针
- en: '`lvalue` reference to an object or `lvalue` reference to a function'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对对象的`lvalue`引用或对函数的`lvalue`引用
- en: Pointer to member
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员指针
- en: C++11 std `::nullptr_t` C++11 ends
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++11 std `::nullptr_t` C++11 结束
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Non-type arguments in this list are expressions whose value can be determined
    at compile time.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此列表中的非类型参数是在编译时可以确定其值的表达式。
- en: Such arguments must be constant expressions, addresses of functions or objects
    with external linkage, or addresses of static class members.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些参数必须是常量表达式、具有外部链接的函数或对象的地址，或者静态类成员的地址。
- en: Non-type arguments are normally used to initialize a class or to specify the
    sizes of class members.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非类型参数通常用于初始化类或指定类成员的大小。
- en: '|'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| type | An entity in this parameter list can be one of the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '| 类型 | 此参数列表中的实体可以是以下之一：'
- en: Must start with typename or class.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须以typename或class开头。
- en: Inside the body of the template declaration, the name of a type parameter is
    a `typedef-name`. When the template is instantiated, it aliases the type supplied.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板声明的主体中，类型参数的名称是`typedef-name`。当模板被实例化时，它将别名为提供的类型。
- en: '|'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The type of argument must have a `typeid`*.*
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的类型必须有`typeid`。
- en: It cannot be a local type, a type with no linkage, an unnamed type, or a type
    compounded from any of these types.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能是局部类型、没有链接的类型、无名类型或由这些类型中的任何一个构成的类型。
- en: '|'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| template | An entity in this parameter list can be one of the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '| 模板 | 此参数列表中的实体可以是以下之一：'
- en: '`template <parameter-list>` class name'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template <parameter-list>` class name'
- en: '`template <parameter-list>` class ... name (optional) (since C++11)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template <parameter-list>` class ... name (optional) (自C++11起)'
- en: '| A template argument in this list is the name of a class template. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 此列表中的模板参数是类模板的名称。|'
- en: In the upcoming section, we will explore how to implement traits in C++ and
    optimize algorithms using them.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨如何在C++中实现特征，并使用它们优化算法。
- en: Exploring traits
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索特征
- en: Generic programming means writing code that works with any data type under certain
    requirements. It is the most efficient way of delivering reusable high-quality
    code in the software engineering industry. However, there are times in generic
    programming where being generic just isn't good enough. Whenever the differences
    between types are too complex, it is very hard for an efficient generic to optimize
    a common implement. For example, while implementing a sort function template,
    if we know the argument type is a linked list but not an array, a different strategy
    will be implemented to optimize the performance.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程意味着编写适用于特定要求下的任何数据类型的代码。这是在软件工程行业中提供可重用高质量代码的最有效方式。然而，在泛型编程中有时候泛型并不够好。每当类型之间的差异过于复杂时，一个高效的泛型优化常见实现就会变得非常困难。例如，当实现排序函数模板时，如果我们知道参数类型是链表而不是数组，就会实现不同的策略来优化性能。
- en: Although template specialization is one approach to overcome this problem, it
    doesn't provide type-related information in a broad way. A type trait is a technique
    that's used to collect information about the type. With its help, we can make
    more intelligent decisions to develop high-quality optimized algorithms in generic
    programming.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模板特化是克服这个问题的一种方法，但它并不能以广泛的方式提供与类型相关的信息。类型特征是一种用于收集有关类型信息的技术。借助它，我们可以做出更明智的决策，开发高质量的优化算法。
- en: In this section, we will introduce how to implement a type trait, and then show
    you how to use type information to optimize algorithms.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何实现类型特征，然后向您展示如何使用类型信息来优化算法。
- en: Type trait implementation
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型特征实现
- en: To understand type traits, we'll look at the classic implementations of `boost::is_void`
    and `boost::is_pointer`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解类型特征，我们将看一下`boost::is_void`和`boost::is_pointer`的经典实现。
- en: boost::is_void
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: boost::is_void
- en: 'First, let''s look at one of the simplest traits classes, the `is_void` trait,
    which was created by boost. It defines a generic template that''s used to implement
    the default behavior; that is, accept a void type, but anything else is void.
    Hence, we have `is_void::value = false`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下最简单的特征类之一，即由boost创建的`is_void`特征类。它定义了一个通用模板，用于实现默认行为；也就是说，接受void类型，但其他任何类型都是void。因此，我们有`is_void::value
    = false`。
- en: '[PRE67]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we fully specialize it for the void type:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对void类型进行了完全特化：
- en: '[PRE68]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Thus, we have a complete traits type that can be used to detect if any given
    type, `T`, `is_void` by checking the following expression:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个完整的特征类型，可以用来检测任何给定类型`T`是否通过检查以下表达式`is_void`。
- en: '[PRE69]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Next, let's learn how to use partial specialization in `boost::is_pointer` traits.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何在`boost::is_pointer`特征中使用部分特化。
- en: boost::is_pointer
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: boost::is_pointer
- en: 'Similar to the `boost::avoid` traits, a primary class template is defined as
    follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 与`boost::avoid`特征类类似，首先定义了一个主类模板：
- en: '[PRE70]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, it is partially specialized for all pointer types:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它对所有指针类型进行了部分特化：
- en: '[PRE71]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we have a complete traits type that can be used to detect if any given
    type, `T`, `is_pointer` by checking the following expression:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个完整的特征类型，可以用来检测任何给定类型`T`是否通过检查以下表达式`is_pointer`。
- en: '[PRE72]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Since the boost type traits feature has already been formally introduced to
    the C++ 11 Standard Library, we can show the usage of `std::is_void` and `std::is_pointer`
    without including the preceding source code in the following example:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于boost类型特征功能已经正式引入到C++ 11标准库中，我们可以在下面的示例中展示`std::is_void`和`std::is_pointer`的用法，而无需包含前面的源代码：
- en: '[PRE73]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The preceding code sets the `boolalpha` format flag for the string stream at
    the beginning. By doing so, all the bool values are extracted by their text representation,
    which is either true or false. Then, we use several `std::cout` to print the values
    of `is_void<T>::value` and `is_pointer<T>::value`*.* The output of each value
    is displayed at the end of the corresponding commented-out line.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在字符串流的开头设置了`boolalpha`格式标志。通过这样做，所有的布尔值都以它们的文本表示形式提取，即true或false。然后，我们使用几个`std::cout`来打印`is_void<T>::value`和`is_pointer<T>::value`的值。每个值的输出显示在相应的注释行末尾。
- en: Optimizing algorithms using traits
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特征优化算法
- en: 'Instead of talking about this topic in a generic abstract way, we will use
    a classic optimized copy example to show the usage of type traits. Consider the
    standard library algorithm known as `copy`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个经典的优化复制示例来展示类型特征的用法，而不是以一种泛型抽象的方式来讨论这个主题。考虑标准库算法`copy`：
- en: '[PRE74]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Obviously, we can write a generic version of `copy()` for any iterator types,
    that is, `It1` and `It2` here. However, as explained by the authors of the boost
    library, there are some circumstances where the copy operation can be performed
    by `memcpy()`. We can use `memcpy()` if all of the following conditions are satisfied:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以为任何迭代器类型编写`copy()`的通用版本，即这里的`It1`和`It2`。然而，正如boost库的作者所解释的那样，有些情况下复制操作可以通过`memcpy()`来执行。如果满足以下所有条件，我们可以使用`memcpy()`：
- en: Both types of iterator, `It1` and `It2`, are pointers.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`It1`和`It2`这两种迭代器都是指针。'
- en: '`It1` and `It2` must point to the same type, except for const and volatile
    qualifiers'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`It1`和`It2`必须指向相同的类型，除了const和volatile限定符'
- en: A trivial assignment operator must be provided by the type that `It1` points
    to.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`It1`指向的类型必须提供一个平凡的赋值运算符。'
- en: 'Here, the trivial assignment operator means that the type is either a scalar
    type or one of the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，平凡的赋值运算符意味着该类型要么是标量类型，要么是以下类型之一：
- en: There is no user-defined assignment operator for the type.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类型没有用户定义的赋值运算符。
- en: There is no reference type of data members inside the type.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类型内部没有数据成员的引用类型。
- en: Trivial assignment operators must be defined in all the base classes and data
    member objects.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有基类和数据成员对象必须定义平凡的赋值运算符。
- en: Here, a scalar type includes an arithmetic type, enumeration type, pointer,
    pointer to member, or const- or volatile-qualified version of one of these types.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，标量类型包括算术类型、枚举类型、指针、成员指针，或者这些类型的const或volatile修饰版本。
- en: 'Now, let''s take a look at the original implementation. It includes two parts
    – the copier class template and the user interface function, that is, `copy()`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下原始实现。它包括两部分 - 复制器类模板和用户界面函数，即`copy()`：
- en: '[PRE75]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As mentioned in the comment lines, the preceding copier class template has
    two static function templates – one is the primary and the other is fully specialized.
    The primary does an element-by-element hard copy, while the full specialization
    one copies all the elements at once via `memcpy()`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如注释行中所述，前面的复制器类模板有两个静态函数模板 - 一个是主要的，另一个是完全专门化的。主要的函数模板进行逐个元素的硬拷贝，而完全专门化的函数模板通过`memcpy()`一次性复制所有元素：
- en: '[PRE76]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: To optimize the copy operation, the preceding user interface function defines
    two `remove_cv` template objects, `v1_t` and `v2_t`, and then evaluates whether
    `can_opt` is true. After that, the `do_copy()` template function is called. By
    using the test code posted in the boost utility library (`algo_opt_ examples.cpp`),
    we can see that there is a significant improvement in using the optimized implementation;
    that is, it could be 8 or 3 times faster for copying char or int types of data.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化复制操作，前面的用户界面函数定义了两个`remove_cv`模板对象，`v1_t`和`v2_t`，然后评估`can_opt`是否为真。之后，调用`do_copy()`模板函数。通过使用boost实用程序库中发布的测试代码（`algo_opt_
    examples.cpp`），我们可以看到使用优化实现有显著改进；即对于复制char或int类型的数据，速度可能提高8倍或3倍。
- en: 'Finally, let''s conclude this section with the following highlights:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们用以下要点总结本节：
- en: A trait gives additional information other than just the type. It is implemented
    through template specializations.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征除了类型之外还提供额外的信息。它通过模板特化来实现。
- en: By convention, traits are always implemented as structs. The structs that are
    used to implement traits are known as trait classes.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照惯例，特征总是作为结构体实现。用于实现特征的结构体称为特征类。
- en: Bjarne Stroustrup said that we should think of a trait as a small object whose
    main purpose is to carry information that's used by another object or algorithm
    to determine policy or implementation details. *Further* *reading* context [4]
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bjarne Stroustrup说我们应该将特征视为一个小对象，其主要目的是携带另一个对象或算法使用的信息，以确定策略或实现细节。*进一步阅读*上下文[4]
- en: Scott Meyers also summarized that we should use traits classes to gather information
    about types *Further reading* context [5].
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scott Meyers还总结说我们应该使用特征类来收集有关类型的信息*进一步阅读*上下文[5]。
- en: Traits can help us implement generic algorithms in an efficient/optimized way.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征可以帮助我们以高效/优化的方式实现通用算法。
- en: Next, we will explore template metaprogramming in C++.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨C++中的模板元编程。
- en: Exploring template metaprogramming
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模板元编程
- en: A programming technique in which computer programs have the ability to treat
    other programs as their data is known as **metaprogramming**. This means that
    a program can be designed to read, generate, analyze, or transform other programs,
    and even modify itself while running. One kind of metaprogramming is a compiler,
    which takes a text format program as an input language (C, Fortran, Java, and
    so on) and produces another binary machine code format program in an output language.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 一种计算机程序具有将其他程序视为其数据的能力的编程技术被称为**元编程**。这意味着程序可以被设计为读取、生成、分析或转换其他程序，甚至在运行时修改自身。一种元编程是编译器，它以文本格式程序作为输入语言（C、Fortran、Java等），并以另一种二进制机器代码格式程序作为输出语言。
- en: C++ **template metaprogramming** (**TMP**) means producing metaprograms in C++
    using templates. It has two components – a template must be defined, and a defined
    template must be instantiated. TMP is Turing-complete, which means it has the
    capability to compute anything that is computable, at least in principle. Also,
    because variables are all immutable (variables are constants) in TMP, recursion
    rather than iteration is used to process the elements of a set.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: C++ **模板元编程**（**TMP**）意味着使用模板在C++中生成元程序。它有两个组成部分 - 必须定义一个模板，并且必须实例化已定义的模板。TMP是图灵完备的，这意味着它至少在原则上有能力计算任何可计算的东西。此外，因为在TMP中变量都是不可变的（变量是常量），所以递归而不是迭代用于处理集合的元素。
- en: Why do we need TMP? Because it can speed up our programs during execution time!
    But since there is no free lunch in the optimization world, the prices we paid
    for TMP are longer compile-time and/or larger binary code sizes. Additionally,
    not every problem can be solved with TMP; it only works when we're computing something
    that is constant during compile time; for example, finding out all the primary
    numbers that are smaller than a constant integer, the factorial of a constant
    integer, unrolling a constant number of loops or iterations, and so on.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要TMP？因为它可以加速程序的执行时间！但在优化世界中并没有免费的午餐，我们为TMP付出的代价是更长的编译时间和/或更大的二进制代码大小。此外，并非每个问题都可以用TMP解决；它只在我们在编译时计算某些常量时才起作用；例如，找出小于常量整数的所有质数，常量整数的阶乘，展开常量次数的循环或迭代等。
- en: 'From a practical point of view, template metaprogramming has the ability to
    solve problems in the following three categories: compile-time computation, compile-time
    optimization, and replacing dynamic polymorphism with static polymorphism by avoiding
    virtual table lookup during runtime. In the following subsections, we will provide
    examples from each category to demonstrate how metaprogramming works.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度来看，模板元编程有能力解决以下三类问题：编译时计算、编译时优化，以及通过在运行时避免虚拟表查找，用静态多态性替换动态多态性。在接下来的小节中，我们将提供每个类别的示例，以演示元编程的工作原理。
- en: Compile-time computation
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时计算
- en: Typically, if the inputs and outputs of a task are known at compile-time, we
    can use template metaprogramming to do the computation during compilation and
    thus save any runtime overhead and the memory footprint. This is really useful
    in real-time intense CPU utilization projects.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果任务的输入和输出在编译时已知，我们可以使用模板元编程来在编译期间进行计算，从而节省任何运行时开销和内存占用。这在实时强度CPU利用项目中非常有用。
- en: 'Let''s take a look at the factorial function, which calculates `*n*!`. This
    is the product of all positive integers less than or equal to *n, *with 0!=1 by
    definition. Thanks to the concept of recursion, we can implement this using a
    simple function, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下计算`*n*!`的阶乘函数。这是小于或等于*n*的所有正整数的乘积，其中根据定义0!=1。由于递归的概念，我们可以使用一个简单的函数来实现这一点，如下所示：
- en: '[PRE77]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`f1()` does the computation at runtime, while `f2()` can do it either at runtime
    or compile-time, depending on its usage.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1()`在运行时进行计算，而`f2()`可以根据使用情况在运行时或编译时进行计算。'
- en: 'Similarly, by using a template with a non-type parameter, its specialization,
    and the recursion concept, the template metaprogramming version of this problem
    is as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过使用带有非类型参数的模板，它的特化和递归概念，这个问题的模板元编程版本如下：
- en: '[PRE78]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, we created a class template with a non-type parameter, and like other
    const expressions, values of `const static uint32_t` or enumeration constants
    are evaluated at compile time. This compile-time evaluation constraint means only
    const variables make sense. Also, since we are working with classes only, static
    objects make sense.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个带有非类型参数的类模板，与其他const表达式一样，`const static uint32_t`或枚举常量的值在编译时计算。这种编译时评估约束意味着只有const变量有意义。此外，由于我们只使用类，静态对象才有意义。
- en: 'When the compiler sees a new argument for a template, it creates a new instance
    of the template. For instance, when the compiler sees `fact<10>::value` and it
    tries to create an instance of `fact` with the argument as 10, it turns out that
    `fact<9>` must also be created. For `fact<9>`, it needs `fact<8>` and so on. Finally,
    the compiler uses `fact<0>::value` (which is 1), and the recursion during compile
    time terminates. This process can be seen in the following code block:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器看到模板的新参数时，它会创建模板的新实例。例如，当编译器看到`fact<10>::value`并尝试使用参数为10创建`fact`的实例时，结果是必须创建`fact<9>`。对于`fact<9>`，它需要`fact<8>`等等。最后，编译器使用`fact<0>::value`（即1），并且在编译时的递归终止。这个过程可以在以下代码块中看到：
- en: '[PRE79]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note that to be able to use templates in this way, we must provide a constant
    argument in template argument list. That''s why if you uncomment the last two
    lines of code, you will get a complaint from the compiler: `fact:template parameter
    n: m: a variable with non-static storage duration cannot be used as a non-type
    argument`.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，为了能够以这种方式使用模板，我们必须在模板参数列表中提供一个常量参数。这就是为什么如果取消注释代码的最后两行，编译器会投诉：`fact:template
    parameter n: m: a variable with non-static storage duration cannot be used as
    a non-type argument`。'
- en: 'Finally, let''s end this subsection by briefly comparing the **constexpr functions**
    (**CF**) and TMP:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过简要比较**constexpr函数**（CF）和TMP来结束本小节：
- en: '**Computation time**: CF executes at either compile-time or runtime, depending
    on its usage, but TMP only executes at compile time.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算时间**：CF根据使用情况在编译时或运行时执行，但TMP只在编译时执行。'
- en: '**Argument lists**: CF can only take values, but TMP can take both value and
    type parameters.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数列表**：CF只能接受值，但TMP可以接受值和类型参数。'
- en: '**Control structure**: CF can use recursion, conditions, and loops, but TMP
    only uses recursion.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构：CF可以使用递归、条件和循环，但TMP只能使用递归。
- en: Compile-time code optimization
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时代码优化
- en: Although the previous example can calculate the factorial of a constant integer
    at compile-time, we can use a runtime loop to unroll the dot-products of two -*n*
    vectors (where *n* is known at compile time). The benefit of a more traditional
    length-*n* vector is that unrolling the loops is feasible, which results in very
    optimized code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子可以在编译时计算常量整数的阶乘，但我们可以使用运行时循环来展开两个-*n*向量的点积（其中*n*在编译时已知）。传统长度-*n*向量的好处是可以展开循环，从而产生非常优化的代码。
- en: 'As an example, the traditional dot-product function template can be implemented
    in the following way:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，传统的点积函数模板可以以以下方式实现：
- en: '[PRE80]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '**Loop unrolling **means that if we can optimize the for loop inside the `dotp()` function
    as `a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]`, then it will save
    more runtime computations. That is exactly what metaprogramming does in the following
    code block:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环展开**意味着如果我们可以优化`dotp()`函数内部的for循环为`a[0]*b[0] + a[1]*b[1] + a[2]*b[2] +
    a[3]*b[3] + a[4]*b[4]`，那么它将节省更多的运行时计算。这正是元编程在以下代码块中所做的：'
- en: '[PRE81]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Similar to the factorial metaprogramming example, in the `dotp<5, float>::result(
    a, b)` statement, the instantiation process recursively does the following computing:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于阶乘元编程示例，在`dotp<5, float>::result(a, b)`语句中，实例化过程递归执行以下计算：
- en: '[PRE82]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Since *N* is 5, it recursively calls the `dotp<n`, `float>::results()` template
    function four times until `dotp<1`, `float>::results()` is reached. The final
    expression that's evaluated by `dotp<5`, `float>::result( a, b)` is displayed
    in the last two lines of the preceding block.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*N*为5，它递归调用`dotp<n, float>::results()`模板函数四次，直到达到`dotp<1, float>::results()`。由`dotp<5,
    float>::result(a, b)`计算的最终表达式显示在前面块的最后两行中。
- en: Static polymorphism
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态多态
- en: Polymorphism means multiple functions have the same name. Dynamic polymorphism
    allows users to determine the actual function method to be executed at runtime
    (see [chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details of Object-Oriented
    Programming*, for more details*), *while *static* polymorphism means that the
    actual function to call (or, in general, the actual code to run) is known at compile
    time. By default, C++ matches a function call with the correct function definition
    at compile time by checking the types and/or the number of arguments. This process
    is also called **static binding** or **overloading***.* However, by using a virtual
    function, the compiler also does dynamic binding or overriding in runtime.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 多态意味着多个函数具有相同的名称。动态多态允许用户在运行时确定要执行的实际函数方法，而静态多态意味着在编译时已知要调用的实际函数（或者一般来说，要运行的实际代码）。默认情况下，C++通过检查类型和/或参数的数量在编译时匹配函数调用与正确的函数定义。这个过程也被称为静态绑定或重载。然而，通过使用虚函数，编译器也可以在运行时进行动态绑定或覆盖。
- en: 'For example, in the following code, a virtual function, `alg()`, is defined
    in both base `class B` and derived `class D`. When we use the derived object pointer
    `p` as an instance pointer of the base class, the `p->alg()` function call will
    invoke the derived `alg()` defined in the derived class:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码中，虚函数`alg()`在基类B和派生类D中都有定义。当我们使用派生对象指针`p`作为基类的实例指针时，`p->alg()`函数调用将调用派生类中定义的`alg()`：
- en: '[PRE83]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'However, in cases where the polymorphism behavior is invariant and can be determined
    at compile-time, the **Curiously Recurring Template Pattern** (**CRTP**) can be
    used to achieve static polymorphism, which imitates static polymorphism and resolves
    the binding at compile time. Thus, the program will get out of checking `virtual-lookup-table`
    at runtime. The following code implements the previous example in a static polymorphism
    way:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在多态行为不变且可以在编译时确定的情况下，可以使用奇异递归模板模式（CRTP）来实现静态多态，模拟静态多态并在编译时解析绑定。因此，程序将在运行时摆脱对虚拟查找表的检查。以下代码以静态多态的方式实现了前面的示例：
- en: '[PRE84]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In summary, the general idea of template metaprogramming is to let the compiler
    do some computation during compilation time. In this way, the runtime overhead
    can be resolved to a certain degree. The reason we can compute something during
    compilation time is that something is constant before runtime.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，模板元编程的一般思想是让编译器在编译时进行一些计算。通过这种方式，可以在一定程度上解决运行时开销的问题。我们之所以能够在编译时计算某些东西，是因为在运行时之前，某些东西是常量。
- en: As mentioned in further reading context [14],C++ TMP is a very powerful method
    for performing computational tasks at compilation time. The first approach is
    not easy, and we must be very careful regarding compile errors because the templates
    tree is unrolled. From a practical point of view, the boost **Metaprogramming
    Library** (**MPL**) is a good reference to start. It provides a compile-time TMP
    framework for algorithms, sequences, and metafunctions in a general-purpose way.
    Moreover, the new `std::variant` and `std::visit` features in C++17 can also be
    used for static polymorphism for scenarios where there are no related types sharing
    the inheritance kind of an interface.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如进一步阅读中提到的，C++ TMP 是一种非常强大的方法，可以在编译时执行计算任务。第一种方法并不容易，我们必须非常小心处理编译错误，因为模板树是展开的。从实际角度来看，boost
    元编程库（MPL）是一个很好的起点。它以通用方式提供了用于算法、序列和元函数的编译时 TMP 框架。此外，C++17 中的新特性 std::variant
    和 std::visit 也可以用于静态多态，适用于没有相关类型共享继承接口的情况。
- en: Summary
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we discussed generic programming-related topics in C++. Starting
    by reviewing C macros and function overloading, we introduced the development
    motivations of C++ templates. Then, we presented the syntax of class and function
    templates with a fixed number of parameters, as well as their specializations
    and instantiations. Since C++11, variadic templates are accepted by the standard
    generic function and class templates. Based on this, we further classified the
    template parameters and arguments into three categories: non-type template parameters/arguments,
    type template parameters/arguments, and template template parameters/arguments.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了C++中与泛型编程相关的主题。从回顾C宏和函数重载开始，我们介绍了C++模板的开发动机。然后，我们介绍了具有固定数量参数的类和函数模板的语法，以及它们的特化和实例化。自C++11以来，标准泛型函数和类模板已经接受可变参数模板。基于此，我们进一步将模板参数和参数分为三类：非类型模板参数/参数，类型模板参数/参数和模板模板参数/参数。
- en: We also learned about traits and template metaprogramming. As a byproduct of
    template specialization, traits classes can provide us with more information about
    types. With the help of type information, eventually, the optimizations of implementing
    generic algorithms become possible. Another application of class and/or function
    templates is to compute some constant tasks during compile time via recursion,
    which is called template metaprogramming. It has the ability to perform compile-time
    computation and/or optimization, as well as avoid virtual table lookup during
    runtime.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了特性和模板元编程。作为模板特化的副产品，特性类可以为我们提供有关类型的更多信息。借助类型信息，最终可以实现实现通用算法的优化。类和/或函数模板的另一个应用是通过递归在编译时计算一些常量任务，这被称为模板元编程。它具有执行编译时计算和/或优化的能力，并且可以避免在运行时进行虚拟表查找。
- en: Now, you should have a deep understanding of templates. You should be able to
    create your own function and class templates in applications, as well as practice
    using traits to optimize your algorithm and use template metaprogramming to do
    compile-time computation for additional optimization
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对模板有了深入的了解。你应该能够在应用程序中创建自己的函数和类模板，并练习使用特性来优化你的算法，并使用模板元编程来进行编译时计算以进行额外的优化。
- en: In the next chapter, we will learn about memory and management-related topics,
    such as the concept of memory access, allocation and de-allocation techniques,
    and garbage collection basics. This is the most unique feature of C++, and thus
    it must be understood by every C++ developer.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习有关内存和管理相关主题的内容，例如内存访问、分配和释放技术的概念，以及垃圾收集基础知识。这是C++最独特的特性，因此每个C++开发人员都必须了解。
- en: Questions
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Questions
- en: What are the side effects of macros?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏的副作用是什么？
- en: What is a class/function template? What is a template class/function?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类/函数模板？什么是模板类/函数？
- en: What is a template parameter list? What is a template argument list? Once we
    have a class template, we can instantiate it either explicitly or implicitly.
    In what kind of scenario is explicit instantiation necessary?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是模板参数列表？什么是模板参数列表？一旦我们有了一个类模板，我们可以显式或隐式地实例化它。在什么样的情况下，显式实例化是必要的？
- en: What does polymorphism mean in C++? What is the difference between function
    overloading and function overriding?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++中，多态是什么意思？函数重载和函数覆盖之间有什么区别？
- en: What are type traits? How do we implement a type trait?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类型特征？我们如何实现类型特征？
- en: In the `ch4_5_class_template_implicit_inst_B.cpp` file, we said implicit instantiation
    generates the `X<int>` class, and then creates the `xi` object and generates the
    `X<int>::f()` function, but not `X<int>::g()`. How can you verify that `X<int>::g()`
    is not generated?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch4_5_class_template_implicit_inst_B.cpp`文件中，我们说隐式实例化生成了`X<int>`类，然后创建了`xi`对象并生成了`X<int>::f()`函数，但没有生成`X<int>::g()`。如何验证`X<int>::g()`没有生成？
- en: Using template metaprogramming, solve the problem of *f(x,n) = x^n*, where *n*
    is a const and *x* is a variable.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模板元编程解决*f(x,n) = x^n*的问题，其中*n*是一个const，*x*是一个变量。
- en: Extend  `ch4_17_loop_unrolling_metaprogramming.cpp` to values of n=10,100,10^3,10^4,10^6,
    ..., until you reach your system memory limits. Compare the compile time, object
    file size, and running CPU time.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ch4_17_loop_unrolling_metaprogramming.cpp`扩展到n=10,100,10^3,10^4,10^6，直到达到系统内存限制。比较编译时间、目标文件大小和运行CPU时间。
- en: Further reading
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Further reading
- en: 'As referenced throughout this chapter, have a look at the following sources
    to find out more regarding what was covered in this chapter:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章中所引用的，查看以下来源，以了解本章涵盖的更多内容：
- en: Milner, R., Morris, L., Newey, M. (1975). *A Logic for Computable Functions
    with Reflexive and Polymorphic Types.* Proceedings of the Conference on Proving
    and Improving Programs.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Milner, R., Morris, L., Newey, M. (1975). *A Logic for Computable Functions
    with Reflexive and Polymorphic Types.* Proceedings of the Conference on Proving
    and Improving Programs.
- en: '[https://www.research.ed.ac.uk/portal/en/publications/a-logic-for-computable-functions-with-reflexive-and-polymorphic-types(9a69331e-b562-4061-8882-2a89a3c473bb).html](https://www.research.ed.ac.uk/portal/en/publications/a-logic-for-computable-functions-with-reflexive-and-polymorphic-types(9a69331e-b562-4061-8882-2a89a3c473bb).html)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.research.ed.ac.uk/portal/en/publications/a-logic-for-computable-functions-with-reflexive-and-polymorphic-types(9a69331e-b562-4061-8882-2a89a3c473bb).html](https://www.research.ed.ac.uk/portal/en/publications/a-logic-for-computable-functions-with-reflexive-and-polymorphic-types(9a69331e-b562-4061-8882-2a89a3c473bb).html)'
- en: '*Curtis, Dorothy (2009-11-06). CLU home page.*Programming Methodology Group,
    Computer Science and Artificial Intelligence Laboratory. Massachusetts Institute
    of Technology.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Curtis, Dorothy (2009-11-06). CLU home page.*Programming Methodology Group,
    Computer Science and Artificial Intelligence Laboratory. Massachusetts Institute
    of Technology.'
- en: '[http://www.pmg.csail.mit.edu/CLU.html](http://www.pmg.csail.mit.edu/CLU.html)'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.pmg.csail.mit.edu/CLU.html](http://www.pmg.csail.mit.edu/CLU.html)'
- en: '*Technical Corrigendum for Ada 2012*, published by ISO. Ada Resource Association.
    2016-01-29.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Technical Corrigendum for Ada 2012*, published by ISO. Ada Resource Association.
    2016-01-29.'
- en: https://www.adaic.org/2016/01/technical-corrigendum-for-ada-2012-published-by-iso/
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://www.adaic.org/2016/01/technical-corrigendum-for-ada-2012-published-by-iso/
- en: B. Stroustrup, *C++.*
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B. Stroustrup, *C++.*
- en: '[https://dl.acm.org/doi/10.5555/1074100.1074189](https://dl.acm.org/doi/10.5555/1074100.1074189)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dl.acm.org/doi/10.5555/1074100.1074189](https://dl.acm.org/doi/10.5555/1074100.1074189)'
- en: '*S. Meyers, Effective C++ 55 Specific Ways to Improve Your Programs and Designs
    (3rd Edition), Chapter 7.*'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S. Meyers, Effective C++ 55 Specific Ways to Improve Your Programs and Designs
    (3rd Edition), Chapter 7.*'
- en: '[https://www.oreilly.com/library/view/effective-c-55/0321334876/](https://www.oreilly.com/library/view/effective-c-55/0321334876/)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.oreilly.com/library/view/effective-c-55/0321334876/](https://www.oreilly.com/library/view/effective-c-55/0321334876/)'
- en: D. Gregor and J. Järvi (February 2008). *Variadic Templates for C++0x.*Journal
    of Object Technology. pp. 31–51
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D. Gregor and J. Järvi (February 2008). *Variadic Templates for C++0x.*Journal
    of Object Technology. pp. 31–51
- en: '[http://www.jot.fm/issues/issue_2008_02/article2.pdf](http://www.jot.fm/issues/issue_2008_02/article2.pdf)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.jot.fm/issues/issue_2008_02/article2.pdf](http://www.jot.fm/issues/issue_2008_02/article2.pdf)'
- en: '[https://www.boost.org/](https://www.boost.org/) for type traits, unit testing
    etc.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.boost.org/](https://www.boost.org/) for type traits, unit testing
    etc.'
- en: '[https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzarg/templates.htm](https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzarg/templates.htm) for
    generic templates discussions.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzarg/templates.htm](https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzarg/templates.htm) for
    generic templates discussions.'
- en: '[https://stackoverflow.com/questions/546669/c-code-analysis-tool](https://stackoverflow.com/questions/546669/c-code-analysis-tool) for
    code analysis tools.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://stackoverflow.com/questions/546669/c-code-analysis-tool](https://stackoverflow.com/questions/546669/c-code-analysis-tool) for
    code analysis tools.'
- en: '[https://en.cppreference.com](https://en.cppreference.com) for template explicit
    instantiations.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.cppreference.com](https://en.cppreference.com) for template explicit
    instantiations.'
- en: '[http://www.cplusplus.com](http://www.cplusplus.com) for library references
    and usage examples.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.cplusplus.com](http://www.cplusplus.com) for library references
    and usage examples.'
- en: '[http://www.drdobbs.com/cpp/c-type-traits/184404270](http://www.drdobbs.com/cpp/c-type-traits/184404270) for
    type-traits.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.drdobbs.com/cpp/c-type-traits/184404270](http://www.drdobbs.com/cpp/c-type-traits/184404270) for
    type-traits.'
- en: '[https://accu.org/index.php/journals/424](https://accu.org/index.php/journals/424) for
    template metaprogramming.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://accu.org/index.php/journals/424](https://accu.org/index.php/journals/424) for
    template metaprogramming.'
- en: '[https://en.wikipedia.org/wiki/Template_metaprogramming](https://en.wikipedia.org/wiki/Template_metaprogramming) for
    template metaprogramming.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Template_metaprogramming](https://en.wikipedia.org/wiki/Template_metaprogramming)
    用于模板元编程。'
- en: 'K. Czarnecki, U. W. Eisenecker, *Generative Programming: Methods, Tools, and
    Applications*, Chapter 10.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'K. Czarnecki, U. W. Eisenecker, *Generative Programming: Methods, Tools, and
    Applications*, 第10章。'
- en: 'N. Josuttis; D. Gregor and D. Vandevoorde, *C++ Templates: The Complete Guide
    (2nd Edition)*, Addison-Wesley Professional 2017.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'N. Josuttis; D. Gregor 和 D. Vandevoorde, *C++ Templates: The Complete Guide
    (2nd Edition)*, Addison-Wesley Professional 2017。'
