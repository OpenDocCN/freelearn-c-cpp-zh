- en: '*Chapter 15*: Rendering Instanced Crowds'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：渲染实例化人群'
- en: This final chapter explores how to render large crowds using instancing. Crowd
    rendering is an interesting topic because it moves pose generation (sampling)
    and blending onto the GPU, making the entire animation pipeline run in a vertex
    shader.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章探讨了如何使用实例化来渲染大型人群。人群渲染是一个有趣的话题，因为它将姿势生成（采样）和混合移动到了GPU上，使整个动画流水线在顶点着色器中运行。
- en: To move pose generation to the vertex shader, animation information needs to
    be encoded in a texture. The focus of this chapter will be encoding animation
    data into textures and using that texture to create an animated pose.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将姿势生成移动到顶点着色器中，需要将动画信息编码到纹理中。本章的重点将是将动画数据编码到纹理中，并使用该纹理创建动画姿势。
- en: Without instancing, drawing a large crowd would mean making lots of draw calls,
    which would hurt the frame rate. Using instancing, one mesh can be drawn many
    times. If there is only one draw call, the animated poses for each character in
    the crowd will need to be generated differently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 没有实例化，绘制大量人群意味着需要进行大量的绘制调用，这将影响帧率。使用实例化，一个网格可以被多次绘制。如果只有一个绘制调用，人群中每个角色的动画姿势将需要不同的生成。
- en: 'In this chapter, you will explore moving animation sampling into the vertex
    shader in order to draw large crowds. The following topics will be covered in
    this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将探讨将动画采样移动到顶点着色器中以绘制大型人群。本章将涵盖以下主题：
- en: Storing arbitrary data in textures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在纹理中存储任意数据
- en: Retrieving arbitrary data from textures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从纹理中检索任意数据
- en: Baking animations into a texture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动画烘焙到纹理中
- en: Sampling animation textures in a vertex shader
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶点着色器中对动画纹理进行采样
- en: Optimizing the crowd system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化人群系统
- en: Storing data in textures
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在纹理中存储数据
- en: Sampling animations is not a trivial task. There are a lot of loops and functions,
    which makes animation sampling on the GPU a difficult problem. One way to address
    this problem is to simplify it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPU上进行动画采样并不是一件简单的事情。有很多循环和函数，这使得在GPU上进行动画采样成为一个困难的问题。解决这个问题的一种方法是简化它。
- en: Instead of sampling an animation in real-time, it could be sampled at set time
    intervals. The process of sampling an animation at set intervals and writing the
    resulting data to a file is called baking.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与实时采样动画不同，可以在设定的时间间隔内进行采样。在设定的时间间隔内对动画进行采样并将结果数据写入文件的过程称为烘焙。
- en: Once the animation data is baked, the shader no longer has to sample an actual
    animation clip. Instead, it can look up the nearest sampled pose based on time.
    So, where does this animation data get baked to? Animation can be baked into textures.
    Textures can be used as data buffers, and there is already an easy way to read
    texture data in shaders.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 动画数据烘焙后，着色器就不再需要采样实际的动画片段。相反，它可以根据时间查找最近的采样姿势。那么，这些动画数据烘焙到哪里呢？动画可以烘焙到纹理中。纹理可以用作数据缓冲区，并且已经有一种简单的方法在着色器中读取纹理数据。
- en: Normally, the storage type and information in a texture is abstracted away by
    the sampling function in the shader. For example, the `texture2D` function in
    GLSL takes normalized `uv` coordinates as an argument and returns a four-component
    vector with values ranging from `0` to `1`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，纹理中的存储类型和信息都是由着色器中的采样函数抽象出来的。例如，GLSL中的`texture2D`函数以归一化的`uv`坐标作为参数，并返回一个四分量向量，其值范围从`0`到`1`。
- en: But none of that information is what's in the texture. When a texture is created
    with `glTexImage2D`, it takes an internal texture format (`GL_RGBA`), a source
    format (usually `GL_RGBA` again), and a data type (usually `GL_UNSIGNED_BYTE`).
    These parameters are used to convert whatever the underlying data type is into
    the normalized values that `texture2D` returns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是纹理中的信息并不是这样的。当使用`glTexImage2D`创建纹理时，它需要一个内部纹理格式（`GL_RGBA`），一个源格式（通常再次是`GL_RGBA`）和一个数据类型（通常是`GL_UNSIGNED_BYTE`）。这些参数用于将底层数据类型转换为`texture2D`返回的归一化值。
- en: There are two problems with this when it comes to storing arbitrary data in
    textures. The first is the granularity of the data. In the case of `GL_RGBA`,
    each sampled floating-point component only has 256 unique values. Second, what
    if a value needs to be stored that is not normalized to the `0` to `1` range?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在将任意数据存储在纹理中时，存在两个问题。第一个是数据的粒度。在`GL_RGBA`的情况下，每个采样的浮点分量只有256个唯一值。第二，如果需要存储的值不是归一化到`0`到`1`范围内的呢？
- en: This is where floating-point textures come in. You can create a four-component
    floating-point texture that has a `GL_RGBA32F` format. This texture will be much
    larger than other textures because each pixel will store four full 32-bit floating-point
    numbers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是浮点纹理的用武之地。您可以创建一个具有`GL_RGBA32F`格式的四分量浮点纹理。这个纹理会比其他纹理大得多，因为每个像素将存储四个完整的32位浮点数。
- en: A floating-point texture can store arbitrary data. In the following section,
    you will learn how to retrieve the arbitrary data from a floating-point texture.
    After that, you will explore how a shader can read data from a floating-point
    texture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点纹理可以存储任意数据。在接下来的部分，您将学习如何从浮点纹理中检索任意数据。之后，您将探讨着色器如何从浮点纹理中读取数据。
- en: Reading data from textures
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从纹理中读取数据
- en: This section explores how animation data stored in textures can be retrieved
    in a shader. In this section, you will learn how to sample the texture and what
    sampler states should be used when sampling the texture.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了如何在着色器中检索存储在纹理中的动画数据。在本节中，您将学习如何对纹理进行采样以及在采样纹理时应该使用哪些采样器状态。
- en: Once the data is in the right format, sampling it becomes the next challenge.
    The `glTexImage2D` function expects normalized `uv` coordinates and returns a
    normalized value. On the other hand, the `texelFetch` function can be used to
    sample a texture using pixel coordinates and return the raw data at those coordinates.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据格式正确，对其进行采样就成为下一个挑战。`glTexImage2D`函数期望归一化的`uv`坐标并返回一个归一化值。另一方面，`texelFetch`函数可以用于使用像素坐标对纹理进行采样并返回这些坐标处的原始数据。
- en: 'The `texelFetch` glsl takes three arguments: a sampler, an `ivec2`, and an
    integer. `ivec2` is the *x* and *y* coordinates of the pixel being sampled, in
    pixel space. The last integer is the mip level to use, which, for this chapter,
    will always be `0`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`texelFetch` glsl接受三个参数：一个采样器，一个`ivec2`和一个整数。`ivec2`是被采样的像素的*x*和*y*坐标，以像素空间为单位。最后一个整数是要使用的mip级别，对于本章来说，将始终为`0`。'
- en: A mipmap is a chain of progressively lower resolution versions of the same image.
    When a mip level is scaled down, data is lost. This data loss alters the contents
    of the animation. Avoid generating mips for animation textures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: mipmap是同一图像的逐渐降低分辨率版本的链。当mip级别缩小时，数据会丢失。这种数据丢失会改变动画的内容。避免为动画纹理生成mip。
- en: Because the data needs to be read in exactly the same way it was written out,
    any interpolation would ruin the animation data as well. Make sure that animation
    textures are sampled using nearest neighbor sampling.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因为需要以与写出时完全相同的方式读取数据，任何插值也会破坏动画数据。确保使用最近邻采样来对动画纹理进行采样。
- en: Using `texelFetch` instead of `glTexImage2D` to sample a texture should return
    the correct data. Textures can be sampled in either the vertex or the fragment
    shader. In the next section, you will explore what animation data should be stored
    in these floating-point textures.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`texelFetch`而不是`glTexImage2D`来对纹理进行采样应该返回正确的数据。纹理可以在顶点着色器或片段着色器中进行采样。在下一节中，您将探索这些浮点纹理中应该存储什么动画数据。
- en: Encoding animation data
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码动画数据
- en: Now that you know how to read and write data to a texture, the next question
    is, what data needs to be written in the texture? You will be encoding animation
    data into textures. Each animation clip will be sampled at set intervals. The
    resulting poses from all those samples will be stored in a texture.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何读取和写入数据到纹理了，下一个问题是，纹理中需要写入什么数据？你将把动画数据编码到纹理中。每个动画片段将在设定的间隔内进行采样。所有这些样本的结果姿势将存储在纹理中。
- en: 'To encode this data, the *x* axis of the texture will represent time. The *y*
    axis of the texture will represent a bone in the skeleton being animated. Each
    bone will take up three rows: one for the position, one for the rotation, and
    one for the scale.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编码这些数据，纹理的*x*轴将表示时间。纹理的*y*轴将表示正在进行动画的骨骼。每个骨骼将占用三行：一个用于位置，一个用于旋转，一个用于缩放。
- en: The animation clip will be sampled at set intervals to make sure that there
    are as many samples as the texture is wide. For example, for a *256x256* animation
    texture, the animation clip will need to be sampled 256 times.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 动画片段将在设定的间隔内进行采样，以确保纹理的宽度有多少个样本。例如，对于一个*256x256*的动画纹理，动画片段将需要被采样256次。
- en: When sampling the animation clip to encode it into a texture, for each sample,
    you will find the world space transform of each bone and write it into the texture.
    The *y* coordinate is going to be `joint_index * 3 + component`, where the valid
    components are `position = 0`, `rotation = 1`, and `scale = 3`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在对动画片段进行采样以将其编码到纹理中时，对于每个样本，您将找到每个骨骼的世界空间变换并将其写入纹理。*y*坐标将是`joint_index * 3 +
    component`，其中有效的组件是`position = 0`，`rotation = 1`和`scale = 3`。
- en: Once these values have been written to the texture, upload the texture to the
    GPU and use it. In the next section, you will explore how a shader evaluates this
    animation texture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些值被写入纹理，就将纹理上传到GPU并使用它。在下一节中，您将探索着色器如何评估这个动画纹理。
- en: Exploring per-instance data
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索每个实例数据
- en: When rendering a large crowd, each actor in the crowd has certain properties.
    In this section, you will explore what that per-instance data is and how to pass
    it to the shader. This will greatly reduce the amount of data that is uploaded
    to the GPU as uniform arrays every frame.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染大量人群时，人群中的每个演员都有特定的属性。在本节中，您将探索每个实例数据是什么，以及如何将其传递给着色器。这将大大减少每帧上传到GPU的统一数组的数据量。
- en: Moving the skinning pipeline to a vertex shader does not completely remove needing
    to pass crowd-related uniform to the shader. Every actor in a crowd will need
    some data uploaded to the GPU. The per-instance data is much smaller than what
    would be uploaded if pose palette matrices were being used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将蒙皮管道移动到顶点着色器并不能完全消除需要将与人群相关的统一数据传递给着色器。人群中的每个演员都需要一些数据上传到GPU。每个实例数据比使用姿势调色板矩阵上传的数据要小得多。
- en: Each actor in the crowd will need a position, rotation, and scale to build a
    model matrix. Actors will need to know the current frame to sample and the time
    between the current and next frames to blend.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 人群中的每个演员都需要位置、旋转和缩放来构建模型矩阵。演员需要知道当前帧进行采样以及当前帧和下一帧之间的时间来进行混合。
- en: The total size of each actor's instance data is 11 floats and 2 integers. That's
    only 52 bytes per instance. Per-instance data will always be passed using uniform
    arrays. The size of each array is the number of actors the crowd contains. Each
    element of the array represents a unique actor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个演员实例数据的总大小是11个浮点数和2个整数。每个实例只有52个字节。每个实例数据将始终使用统一数组传递。数组的大小是人群包含的演员数量。数组的每个元素代表一个独特的演员。
- en: The shader will be responsible for building the appropriate matrices out of
    the per-instance data and the animation texture. Blending between the current
    and next frame is optional; the blend will not be 100% correct, but it should
    still look good.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器将负责从每个实例数据和动画纹理构建适当的矩阵。当前帧和下一帧之间的混合是可选的；混合可能不会100%正确，但它应该看起来还不错。
- en: In the next section, you will implement an `AnimationTexture` class, which will
    let you work with animated textures in code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将实现一个`AnimationTexture`类，它将让您在代码中使用动画纹理。
- en: Creating an animation texture
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画纹理
- en: 'In this section, you will implement all the code needed to work with floating-point
    textures in a `AnimTexture` class. Each `AnimTexture` object will contain a 32-bit
    floating point RGBA texture. There will be two copies of this data: one on the
    CPU and one uploaded to the GPU.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，您将实现所有需要在`AnimTexture`类中使用浮点纹理的代码。每个`AnimTexture`对象将包含一个32位浮点RGBA纹理。这些数据将有两份：一份在CPU上，一份上传到GPU上。
- en: The CPU buffer is kept around to easily modify the contents of the texture in
    bulk before saving it to disk, or uploading it to OpenGL. It keeps the API simple
    at the cost of some additional memory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CPU缓冲区保留下来，以便在保存到磁盘之前或上传到OpenGL之前轻松修改纹理的内容。这样做可以简化API，但会增加一些额外的内存。
- en: There is no standard 32-bit texture format, so saving and writing to disk will
    simply dump the binary contents of the `AnimTexture` class to disk. In the next
    section, you will begin to implement the `AnimTexture` class. This class will
    provide an easy-to-use interface for implementing 32-bit floating-point textures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 没有标准的32位纹理格式，因此保存和写入磁盘将简单地将`AnimTexture`类的二进制内容转储到磁盘上。在下一节中，您将开始实现`AnimTexture`类。这个类将提供一个易于使用的接口，用于实现32位浮点纹理。
- en: Declaring the AnimTexture class
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明AnimTexture类
- en: Animation textures are assumed to always be square; the width and height don't
    need to be tracked separately. It should be enough to use a single size variable.
    The `AnimTexture` class will always have two copies of the texture in memory at
    a time, one on the CPU and one on the GPU.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 动画纹理被假定总是正方形的；宽度和高度不需要分别跟踪。使用单个大小变量应该足够了。`AnimTexture`类将始终在内存中同时拥有两份纹理，一份在CPU上，一份在GPU上。
- en: 'Create a new file called `AnimTexture.h` and declare the `AnimTexture` class
    in this file. Follow these steps to declare the `AnimTexture` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`AnimTexture.h`的新文件，并在这个文件中声明`AnimTexture`类。按照以下步骤声明`AnimTexture`类：
- en: 'Declare the `AnimTexture` class. It has three member variables: a floating-point
    array, an integer for the size of the texture, and a handle to the OpenGL texture
    object:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`AnimTexture`类。它有三个成员变量：一个浮点数组，一个纹理大小的整数，以及一个指向OpenGL纹理对象的句柄：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare `AnimTexture` with a default constructor, copy constructor, assignment
    operator, and destructor:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`AnimTexture`具有默认构造函数、复制构造函数、赋值运算符和析构函数：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Declare functions in order to save `AnimTexture` to disk and to load it up
    again:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明函数，以便将`AnimTexture`保存到磁盘并再次加载：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Declare a function to upload the data from the `mData` variable to an OpenGL
    texture:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个函数，将数据从`mData`变量上传到OpenGL纹理：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Declare getters and setter functions for the CPU side data that `AnimTexture`
    contains:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`AnimTexture`包含的CPU端数据的getter和setter函数：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare `GetTexel`, which takes the *x* and *y* coordinates and returns a `vec4`,
    as well as a `SetTexel` function to set `vec3` or `quat` objects. These functions
    will write to the texture''s data:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`GetTexel`，它接受*x*和*y*坐标并返回一个`vec4`，以及一个`SetTexel`函数来设置`vec3`或`quat`对象。这些函数将写入纹理的数据：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Declare functions to bind and unbind the texture for rendering. This will be
    done the same way as the `Set` and `Unset` functions of the `Texture` class:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明绑定和解绑纹理以进行渲染的函数。这将与`Texture`类的`Set`和`Unset`函数的方式相同：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `AnimTexture` class is a convenient way to work with floating-point textures.
    The `get` and `SetTexel` methods can read and write to the texture using an intuitive
    API. In the next section, you will begin to implement the `AnimTexture` class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimTexture`类是一种方便的处理浮点纹理的方式。`get`和`SetTexel`方法可以使用直观的API读取和写入纹理。在下一节中，您将开始实现`AnimTexture`类。'
- en: Implementing the AnimTexture class
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`AnimTexture`类
- en: In this section, you will implement the `AnimTexture` class, which contains
    OpenGL code for working with floating-point textures and provides an easy-to-use
    API. If you want to use a graphics API other than OpenGL, this class will need
    to be rewritten using that API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，您将实现`AnimTexture`类，其中包含用于处理浮点纹理的OpenGL代码，并提供一个易于使用的API。如果您想使用除了OpenGL之外的图形API，那么这个类将需要使用该API进行重写。
- en: When an `AnimTexture` is saved to disk, the entire `mData` array is written
    to the file as a large binary blob. This large texture data takes up quite a bit
    of memory; for example, a *512x512* texture takes up about 4 MB. Texture compression
    is not a good fit, since the animation data needs to be precise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当`AnimTexture`保存到磁盘时，整个`mData`数组将作为一个大的二进制块写入文件。这个大的纹理数据占用了相当多的内存；例如，一个*512x512*的纹理大约占用4MB。纹理压缩不适用，因为动画数据需要精确。
- en: The `SetTexel` functions are the main way we will be writing data to the animation
    texture. These functions take *x* and *y* coordinates, as well as a `vec3` or
    quaternion value. The function needs to figure out the right index into the `mData`
    array based on the given *x* and *y* coordinates, then set the pixel values accordingly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetTexel`函数是我们将要写入动画纹理数据的主要方式。这些函数接受*x*和*y*坐标，以及`vec3`或四元数值。函数需要根据给定的*x*和*y*坐标找出`mData`数组中的正确索引，然后相应地设置像素值。'
- en: 'Create a new file called `AnimTexture.cpp`. Implement the `AnimTexture` class
    in this new file. Now, follow these steps to implement the `AnimTexture` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`AnimTexture.cpp`的新文件。在这个新文件中实现`AnimTexture`类。现在，按照以下步骤实现`AnimTexture`类：
- en: 'Implement the default constructor. It should set data and size to zero and
    generate a new OpenGL shader handle:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现默认构造函数。它应该将数据和大小设置为零，并生成一个新的OpenGL着色器句柄：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the copy constructor. It should do the same thing that the default
    constructor does and use the assignment operator to copy the actual texture data:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现复制构造函数。它应该做与默认构造函数相同的事情，并使用赋值运算符来复制实际的纹理数据：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement the assignment operator. It only needs to copy the CPU side data;
    the OpenGL handle can be left alone:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现赋值运算符。它只需要复制CPU端的数据；OpenGL句柄可以不变：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the destructor of the `AnimTexture` class. It should delete the internal
    floating-point array and free the OpenGL handle that the class is holding onto:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`AnimTexture`类的析构函数。它应该删除内部浮点数组，并释放类所持有的OpenGL句柄：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implement the `Save` function. It should write the size of `AnimTexture` to
    the file and write the contents of `mData` as a large binary blob:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Save`函数。它应该将`AnimTexture`的大小写入文件，并将`mData`的内容作为一个大的二进制块写入：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Implement the `Load` function to load serialized animation data back into memory:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Load`函数，将序列化的动画数据加载回内存：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implement the `UploadDataToGPU` function. Its implementation is very similar
    to `Texture::Load` but uses `GL_RGBA32F` instead of `GL_FLOAT`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`UploadDataToGPU`函数。它的实现方式与`Texture::Load`非常相似，但使用的是`GL_RGBA32F`而不是`GL_FLOAT`：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement the size, OpenGL handle, and floating-point data getter functions:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现大小、OpenGL句柄和浮点数据获取函数：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Implement the `resize` function, which should set the size of the `mData` array.
    The argument this function takes is the width or height of the animation texture:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`resize`函数，它应该设置`mData`数组的大小。这个函数的参数是动画纹理的宽度或高度：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Implement the `Set` function. It works similar to `Texture::Set`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Set`函数。它的工作方式类似于`Texture::Set`：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement the `UnSet` function. It works similar to `Texture::UnSet`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`UnSet`函数。它的工作方式类似于`Texture::UnSet`：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement the `SetTexel` function, which takes a vector, `3`, as an argument.
    This function should set the unused A component of the pixel to `0`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`SetTexel`函数，它以矢量`3`作为参数。这个函数应该将像素的未使用的A分量设置为`0`：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement the `SetTexel` function, which takes a quaternion as an argument:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`SetTexel`函数，它以四元数作为参数：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the `GetTexel` function. This function will always return a `vec4`,
    which contains every component of the pixel:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`GetTexel`函数。这个函数将始终返回一个`vec4`，其中包含像素的每个分量：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this section, you learned how to create a 32-bit floating-point texture and
    manage the data inside it. The `AnimTexture` class should let you work with floating-point
    textures using an intuitive API, without you having to worry about any OpenGL
    functions. In the next section, you will create a function that will sample an
    animation clip and write the resulting animation data to a texture.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学会了如何创建一个32位浮点纹理并管理其中的数据。`AnimTexture`类应该让您使用直观的API来处理浮点纹理，而不必担心任何OpenGL函数。在下一节中，您将创建一个函数，该函数将对动画剪辑进行采样，并将结果的动画数据写入纹理。
- en: Animation baker
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画烘焙器
- en: In this section, you will learn how to take an animation clip and encode it
    into an animation texture. This process is called baking.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何将动画剪辑编码到动画纹理中。这个过程称为烘焙。
- en: Texture baking is implemented using a helper function that bakes the animation
    into a texture. This `Bake` function will sample the animation at set intervals
    and write the skeleton hierarchy for each sample into a floating-point texture.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个辅助函数实现纹理烘焙。这个`Bake`函数将在设定的间隔内对动画进行采样，并将每个采样的骨骼层次结构写入浮点纹理中。
- en: 'For arguments, the `Bake` function needs a skeleton, an animation clip, and
    a reference to an `AnimTexture` to write to. The skeleton is important as it provides
    the rest pose, which will be used for any joint that isn''t present in the animation
    clip. Every joint of the skeleton will get baked into the texture. Let''s get
    started:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于参数，`Bake`函数需要一个骨架、一个动画剪辑，以及一个要写入的`AnimTexture`的引用。骨架很重要，因为它提供了静止姿势，这将用于动画剪辑中不存在的任何关节。骨架的每个关节都将被烘焙到纹理中。让我们开始吧：
- en: 'Create a new file called `AnimBaker.h` and add the declaration of the `BakeAnimationToTexture`
    function to it:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AnimBaker.h`的新文件，并在其中添加`BakeAnimationToTexture`函数的声明：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new file called `AnimBaker.cpp`. Begin implementing the `BakeAnimationToTexture`
    function in this file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AnimBaker.cpp`的新文件。开始在这个文件中实现`BakeAnimationToTexture`函数：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To bake an animation into a texture, first, create a pose that the animation
    will be sampled into. Then, loop across the *x* dimension of the texture, which
    is time:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将动画烘焙到纹理中，首先创建一个动画将被采样到的姿势。然后，循环遍历纹理的*x*维度，即时间：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For each iteration, find the normalized value of the iterator (`iterator index
    / (size - 1)`). Multiply the normalized time by the duration of the clip, then
    add the start time of the clip. Sample the clip at this time for the current pixel:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每次迭代，找到迭代器的归一化值（迭代器索引/（大小-1））。将归一化时间乘以剪辑的持续时间，然后加上剪辑的开始时间。在当前像素的这个时间点对剪辑进行采样：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the clip has been sampled, loop through all the joints in the bind pose.
    Find the global transform of the current joint and write the data into the texture
    using `SetTexel`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦剪辑被采样，就循环遍历绑定姿势中的所有关节。找到当前关节的全局变换，并使用`SetTexel`将数据写入纹理：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before the `Bake` function returns, call the `UploadTextureDataToGPU` function
    on the provided animation texture. This will make the texture usable immediately
    after it has been baked:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Bake`函数返回之前，调用提供的动画纹理上的`UploadTextureDataToGPU`函数。这将使纹理在被烘焙后立即可用：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At a high level, the animation texture is used as a timeline where the *x* axis
    is time and the *y* axis is the transform of an animated joint at that time. In
    the next section, you will create the crowd shader. The crowd shader uses the
    date baked into a texture by `BakeAnimationToTexture` to sample an animation's
    current pose.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，动画纹理被用作时间轴，其中*x*轴是时间，*y*轴是该时间点上动画关节的变换。在下一节中，您将创建人群着色器。人群着色器使用`BakeAnimationToTexture`烘焙到纹理中的数据来采样动画的当前姿势。
- en: Creating a crowd shader
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建人群着色器
- en: 'To render a crowd, you will need to create a new shader. The crowd shader will
    have projection and view uniforms, but no model uniform. This is because all actors
    are drawn with the same projection and view matrices but require a unique model
    matrix. Instead of model matrices, the shader will have three uniform arrays:
    one for position, one for rotation, and one for scale.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要呈现一个群众，您需要创建一个新的着色器。群众着色器将具有投影和视图统一，但没有模型统一。这是因为所有演员都是用相同的投影和视图矩阵绘制的，但需要一个独特的模型矩阵。着色器将有三个统一数组：一个用于位置，一个用于旋转，一个用于比例，而不是模型矩阵。
- en: The value that will be placed into these arrays will be an instance index –
    the index of the current mesh being rendered. Each vertex gets a copy of its mesh
    instance through a built-in `glsl` variable, `gl_InstanceID`. Each vertex will
    construct a model matrix using the position, rotation, and scale uniform arrays.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将放入这些数组的值是一个实例索引-当前正在呈现的网格的索引。每个顶点都通过内置的`glsl`变量`gl_InstanceID`获得其网格实例的副本。每个顶点将使用位置、旋转和比例统一数组构造一个模型矩阵。
- en: The inverse bind pose is like a matrix uniform array with regular skinning,
    but the animated pose is not. To find the animated pose, the shader will have
    to sample the animation texture. Since each vertex is skinned to four vertices,
    the animated pose has to be found four times for every vertex.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 反向绑定姿势就像一个矩阵统一数组，具有常规的蒙皮，但动画姿势不是。要找到动画姿势，着色器将不得不对动画纹理进行采样。由于每个顶点被绑定到四个顶点，所以必须为每个顶点找到四次动画姿势。
- en: 'Create a new file called `crowd.vert`. The crowd shader will be implemented
    in this file. Follow these steps to implement the crowd shader:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`crowd.vert`的新文件。群众着色器将在此文件中实现。按照以下步骤实现群众着色器：
- en: 'Begin implementing the shader by defining two constants: one for the maximum
    number of bones and one for the maximum number of supported instances:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义两个常量来开始实现着色器：一个用于骨骼的最大数量，一个用于支持的实例的最大数量：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Declare the uniforms that are shared by all actors in the crowd. This includes
    the view and projection matrices, inverse bind pose palette, and animation texture:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明所有群众演员共享的制服。这包括视图和投影矩阵，反向绑定姿势调色板和动画纹理：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Declare the uniforms that are unique to each actor in the crowd. This includes
    the transformation of the actor, the current and next frame, and the blend time:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明每个群众演员独有的统一。这包括演员的变换，当前和下一帧，以及混合时间：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare the vertex structure. Per-vertex data is the same as for any skinned
    mesh:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明顶点结构。每个顶点的数据与任何蒙皮网格的数据相同：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare the output values for the crowd shader:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明群众着色器的输出值：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement a function that multiplies a vector and a quaternion. This function
    will have the same implementation as the `transformVector` function you built
    in [*Chapter 4*](B16191_04_Final_JC_ePub.xhtml#_idTextAnchor069)*, Implementing
    Quaternions*, except it''s running in a shader:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个函数，该函数将一个向量和一个四元数相乘。这个函数将与您在[*第4章*]（B16191_04_Final_JC_ePub.xhtml#_idTextAnchor069）*实现四元数*中构建的`transformVector`函数具有相同的实现，只是它在着色器中运行：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement the `GetModel` function. Given an instance index, this function should
    sample the animation texture and return a *4x4* transformation matrix:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`GetModel`函数。给定一个实例索引，该函数应该从动画纹理中采样并返回一个*4x4*变换矩阵：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement the `GetPose` function with a joint and an instance where this function
    should return the animated world matrix of the joint. Begin the implementation
    by finding the x and y positions to sample the animation texture with:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用关节和实例实现`GetPose`函数，该函数应返回关节的动画世界矩阵。通过找到x和y位置来采样动画纹理开始实现：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Sample the current frame''s position, rotation, and scale from the animation
    texture:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从动画纹理中采样当前帧的位置、旋转和比例：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Sample the next frame''s position, rotation, and scale from the animation texture:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从动画纹理中采样下一帧的位置、旋转和比例：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Interpolate between the transforms of both frames:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个帧之间进行插值：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the interpolated position, rotation, and scale to return a 4x4 matrix:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用插值的位置、旋转和比例返回一个4x4矩阵：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Begin implementing the main function of the shader by finding all four of the
    animated pose matrices, as well as the model matrix for the current actor in the
    crowd. Use `gl_InstanceID` to get the ID of the currently drawn actor:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过找到着色器的主函数来实现着色器的主要功能，找到所有四个动画姿势矩阵，以及群众中当前演员的模型矩阵。使用`gl_InstanceID`来获取当前绘制的演员的ID：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Continue implementing the main function by finding the `skin` matrix for the
    vertex:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过找到顶点的`skin`矩阵来继续实现主函数：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finish implementing the main function by putting the position and normal through
    the skinned vertex''s transformation pipeline:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将位置和法线通过蒙皮顶点的变换管道来完成实现主函数：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this section, you implemented the crowd shader. This vertex shader uses an
    animation texture to construct the animated pose of each vertex being rendered.
    It moves the pose generation part of the skinning pipeline to the GPU. The shader
    is meant to render instanced meshes; it uses `gl_InstanceID` to determine which
    instance is currently being rendered.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您实现了群众着色器。这个顶点着色器使用动画纹理来构建正在呈现的每个顶点的动画姿势。它将蒙皮管道的姿势生成部分移动到了GPU上。该着色器旨在呈现实例化的网格；它使用`gl_InstanceID`来确定当前正在呈现的实例。
- en: This shader is a good place to start, but there is always room for improvement.
    The shader is currently using a lot of uniform indices. Some lower-end machines
    might not provide enough uniforms. Several optimization strategies will be covered
    near the end of this chapter. In the next section, you will implement a `Crowd`
    class to help manage all the data that the Crowd shader needs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器是一个很好的起点，但总有改进的空间。该着色器目前使用了大量的统一索引。一些低端机器可能提供不了足够的统一。本章末尾将介绍几种优化策略。在下一节中，您将实现一个`Crowd`类来帮助管理Crowd着色器需要的所有数据。
- en: Creating the Crowd utility class
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Crowd实用程序类
- en: In this section, you will be building the `Crowd` class. This is a utility class
    that will render large crowds with an easy-to-use API. The `Crowd` class encapsulates
    the state of a crowd.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将构建`Crowd`类。这是一个实用类，可以使用易于使用的API渲染大量人群。`Crowd`类封装了人群的状态。
- en: The `Crowd` class must maintain the instance data of each actor in the class.
    To accommodate this, you will need to declare a maximum number of actors. Then,
    all the actor-specific information can be stored in arrays of structures where
    the index is the actor ID.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Crowd`类必须维护类中每个演员的实例数据。为了适应这一点，您需要声明一个最大演员数量。然后，所有特定于演员的信息可以存储在结构数组中，其中索引是演员ID。'
- en: Actor-specific data includes the actor's world transform, as well as data related
    to its animation playback. The animation data is what frames are being interpolated,
    the interpolation value, and the key times for the current and next frames.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于演员的数据包括演员的世界变换，以及与其动画播放相关的数据。动画数据是哪些帧正在插值，插值值，以及当前和下一帧的关键时间。
- en: 'Create a new file called `Crowd.h`. The `Crowd` class will be declared in this
    file. Follow these steps to declare the `Crowd` class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Crowd.h`的新文件。`Crowd`类将在此文件中声明。按照以下步骤声明`Crowd`类：
- en: 'Define the maximum number of crowd actors as `80`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将人群演员的最大数量定义为`80`：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Start declaring the `Crowd` class by creating vectors for all instance data.
    This includes data for each actor''s transformation, animation frame, and time,
    as well as frame interpolation information:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为所有实例数据创建向量来声明`Crowd`类。这包括每个演员的变换、动画帧和时间的数据，以及帧插值信息：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Declare the `AdjustTime`, `UpdatePlaybackTimes`, `UpdateFrameIndices`, and
    `UpdateInterpolationTimes` functions. The `AdjustTime` function is similar to
    `Clip::AdjustTimeToFitRange`; it makes sure that a given time is valid:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`AdjustTime`、`UpdatePlaybackTimes`、`UpdateFrameIndices`和`UpdateInterpolationTimes`函数。`AdjustTime`函数类似于`Clip::AdjustTimeToFitRange`；它确保给定时间是有效的：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare getter and setter functions for the size of the crowd and for the `Transform`
    property of each actor:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为人群的大小和每个演员的`Transform`属性声明getter和setter函数：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, declare the `Update` and `SetUniforms` functions. These are the functions
    that will advance the current animation and update the per-instance shader uniforms:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，声明`Update`和`SetUniforms`函数。这些函数将推进当前动画并更新每个实例的着色器uniforms：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Crowd` class provides an intuitive interface for managing the per-instance
    information of every actor in a crowd. In the next section, you will begin to
    implement the `Crowd` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Crowd`类为管理人群中每个演员的每个实例信息提供了直观的接口。在下一节中，您将开始实现`Crowd`类。'
- en: Implementing the Crowd class
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Crowd类
- en: The `Crowd` class provides a convenient way for you to manage all the actors
    in a crowd. Most of the complexity of this class is in calculating the correct
    playback information. This work is done in the `Update` function. The `Update`
    function uses three helper functions, that is, `UpdatePlaybackTimes`, `UpdateFrameIndices`,
    and `UpdateInterpolateionTimes`, to work.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Crowd`类为您提供了一种方便的方式来管理人群中的所有演员。这个类的大部分复杂性在于计算正确的播放信息。这项工作在`Update`函数中完成。`Update`函数使用三个辅助函数，即`UpdatePlaybackTimes`、`UpdateFrameIndices`和`UpdateInterpolateionTimes`来工作。'
- en: The current animation playback time for each actor in the crowd will be stored
    in the `mCurrentPlayTimes` vector. The `mNextPlayTimes` vector is the estimated
    next time in the animation, which allows the two sampled frames to interpolate.
    The `UpdatePlaybackTimes` function will be updating both these vectors.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 人群中每个演员的当前动画播放时间将存储在`mCurrentPlayTimes`向量中。`mNextPlayTimes`向量是动画的预计下一个时间，这允许两个采样帧进行插值。`UpdatePlaybackTimes`函数将更新这两个向量。
- en: It's important to guess the playback time of the next frame because the sample
    rate of the animation texture is unknown. If an animation is encoded at 240 FPS
    and is played back at 60 FPS, for example, then the next frame is going to be
    four samples away.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测下一帧的播放时间很重要，因为动画纹理的采样率是未知的。例如，如果动画以240 FPS编码，并以60 FPS播放，那么下一帧将相隔四个采样。
- en: The `mFrames` vector contains two component integer vectors. The first component
    is the `u` texture coordinate of the current animation frame. The second component
    is the `v` texture coordinate of the animation frame that would be shown in the
    next frame. The `v` texture coordinate is the joint index.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`mFrames`向量包含两个组件整数向量。第一个组件是当前动画帧的`u`纹理坐标。第二个组件是下一帧中将显示的动画帧的`v`纹理坐标。`v`纹理坐标是关节索引。'
- en: The `UpdateFrameIndex` function is responsible for updating this vector. To
    find the *x* coordinate of the current frame, normalize the frame time and then
    multiply the normalized frame time by the size of the texture. You can normalize
    a frame's time by subtracting the start time from the frame time and dividing
    the result by the duration of the clip.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateFrameIndex`函数负责更新这个向量。要找到当前帧的*x*坐标，需要对帧时间进行归一化，然后将归一化的帧时间乘以纹理的大小。可以通过从开始时间减去帧时间并将结果除以剪辑的持续时间来归一化帧的时间。'
- en: The shader will need to interpolate between the current animated pose and the
    next animated pose. To do this, it needs to know the current normalized time between
    the frames of the two poses. This is stored in the `mTimes` variable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器需要在当前动画姿势和下一个动画姿势之间进行插值。为此，它需要知道两个姿势帧之间的当前归一化时间。这存储在`mTimes`变量中。
- en: The `mTimes` variable is updated by the `UpdateInterpolationTimes` function.
    This function finds the duration of the current frame, then normalizes the playback
    time relative to the current frame to that duration.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`mTimes`变量由`UpdateInterpolationTimes`函数更新。该函数找到当前帧的持续时间，然后将播放时间相对于当前帧归一化到该持续时间。'
- en: To update the `Crowd` class, you have to call the `UpdatePlaybackTimes`, `UpdateFrameIndices`,
    and `UpdateInterpolateionTimes` functions, in that order. After this is done,
    the `Crowd` class can set its uniform values with the `SetUniforms` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新`Crowd`类，您必须按顺序调用`UpdatePlaybackTimes`、`UpdateFrameIndices`和`UpdateInterpolateionTimes`函数。完成后，`Crowd`类可以使用`SetUniforms`函数设置其uniform值。
- en: 'Create a new file called `Crowd.cpp`. The `Crowd` class will be implemented
    in this file. Follow these steps to implement the `Crowd` class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Crowd.cpp`的新文件。`Crowd`类将在此文件中实现。按照以下步骤实现`Crowd`类：
- en: 'Implement the size getter and setter functions. The setter function needs to
    set the `size` of all the vectors contained in the `Crowd` class:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现大小的获取器和设置器函数。设置器函数需要设置`Crowd`类中包含的所有向量的`size`：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement the getter and setter functions for actor transformation. Position,
    rotation, and scale are kept in separate vectors; the actor getter and setter
    functions hide that implementation in favor of using `Transform` objects:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现演员变换的获取器和设置器函数。位置、旋转和缩放保存在单独的向量中；演员的获取器和设置器函数隐藏了该实现，而是使用`Transform`对象：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the `AdjustTime` function; it''s similar to the `Clip::AdjustTimeToFitRange`
    function:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`AdjustTime`函数；它类似于`Clip::AdjustTimeToFitRange`函数：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement the `UpdatePlaybackTimes` helper function. This function will advance
    the play time for all actors by delta time:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`UpdatePlaybackTimes`辅助函数。该函数将按照增量时间推进所有演员的播放时间：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement the `UpdateFrameIndices` function. This function will convert the
    current play time into pixel coordinates along the animation texture''s *x* axis:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`UpdateFrameIndices`函数。该函数将当前播放时间转换为沿动画纹理*x*轴的像素坐标：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Implement the `UpdateInterpolationTimes` function. This function should find
    the interpolation time between the current and next animated frames:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`UpdateInterpolationTimes`函数。该函数应该找到当前和下一个动画帧之间的插值时间：
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement the `Update` method. This method relies on the `UpdatePlaybackTimes`,
    `UpdateFrameIndices`, and `UpdateInterpolationTimes` helper functions:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Update`方法。该方法依赖于`UpdatePlaybackTimes`、`UpdateFrameIndices`和`UpdateInterpolationTimes`辅助函数：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement the `SetUniforms` function, which passes the vectors contained in
    the `Crowd` class to the crowd shader as uniform arrays:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`SetUniforms`函数，将`Crowd`类中包含的向量传递给人群着色器作为uniform数组：
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Using the `Crowd` class should be intuitive: create a crowd, set the playback
    times and model transforms of its actors, and draw the crowd. In the next section,
    you will explore an example of how the `Crowd` class can be used to draw a large
    crowd.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Crowd`类应该是直观的：创建一个人群，设置其演员的播放时间和模型变换，然后绘制人群。在下一节中，您将探讨如何使用`Crowd`类来绘制大型人群的示例。
- en: Using the Crowd class
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Crowd类
- en: Using the `Crowd` class should be intuitive, but the rendering code might not
    be immediately obvious. The non-instance uniforms of the crowd shader, such as
    the view or projection matrices, still need to be set manually. The only uniforms
    that the `Set` function of the `Crowd` class sets are the per-actor uniforms.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Crowd`类应该是直观的，但渲染代码可能不会立即显而易见。人群着色器的非实例uniform，如视图或投影矩阵，仍然需要手动设置。`Crowd`类的`Set`函数设置的唯一uniform是每个演员的uniform。
- en: 'Instead of rendering with the `Draw` method of the `Mesh` class, render using
    the `DrawInstanced` method. For the number of instances argument, pass the size
    of the crowd. The following code snippet shows a minimal example of how a crowd
    can be drawn:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`Mesh`类的`Draw`方法进行渲染，而是使用`DrawInstanced`方法。对于实例数量参数，传递人群的大小。以下代码片段显示了如何绘制人群的最小示例：
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For the most part, the code looks similar to a regular skinned mesh. That is
    because the instance-specific uniforms are set by the `SetUniforms` function of
    the `Crowd` class. Every other uniform is set the same way as before. In the next
    section, you will explore how two animations can be blended in the vertex shader.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，代码看起来与常规蒙皮网格相似。这是因为`Crowd`类的`SetUniforms`函数设置了特定实例的uniform值。其他uniform的设置方式与以前相同。在下一节中，您将探讨如何在顶点着色器中混合两个动画。
- en: In this section, you created a `Crowd` class, which provides an easy-to-use
    interface so that you can set the uniforms required by the `Crowd` shader. A demonstration
    of how the `Crowd` class can be used to render a large crowd was also covered.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您创建了一个`Crowd`类，它提供了一个易于使用的接口，以便您可以设置`Crowd`着色器所需的uniform。还介绍了如何使用`Crowd`类来渲染大型人群的演示。
- en: Blending animations
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合动画
- en: It is possible to blend between two animations in a vertex shader. There are
    two reasons why you may would want to avoid blending between animations in a vertex
    shader. First, doing so will double the amount of texel fetches, which will make
    the shader more expensive.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中可以在两个动画之间进行混合。有两个原因可能会导致你不希望在顶点着色器中进行动画混合。首先，这样做会使着色器的texel获取量翻倍，使着色器更加昂贵。
- en: 'This explosion of texel fetches happens because you would have to retrieve
    two copies of the pose matrices – one for each animation – and then blend between
    them. The shader code for doing so might look like the following code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种texel获取的激增发生是因为您必须检索姿势矩阵的两个副本 - 每个动画一个 - 然后在它们之间进行混合。执行此操作的着色器代码可能如下代码片段所示：
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The other reason is that the blend isn't technically correct. The shader is
    doing linear blending in world space. The resulting blended skeleton will look
    good but won't be the same as if the joints were interpolated in local space.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是混合在技术上不正确。着色器在世界空间中进行线性混合。结果混合的骨架看起来不错，但与在本地空间中进行插值的关节不同。
- en: If you're cross-fading between two poses, the blend is short and is only meant
    to hide the transition. In most cases, whether or not the transition is technically
    correct won't matter as much as the transition looking smooth. In the next section,
    you will explore using alternate texture formats.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在两个姿势之间进行淡入淡出，混合是短暂的，只是为了隐藏过渡。在大多数情况下，过渡是否在技术上正确并不像过渡看起来平滑那样重要。在下一节中，您将探索使用替代纹理格式。
- en: Exploring texture formats
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索纹理格式
- en: Animation textures are currently stored in the 32-bit floating-point texture
    format. This is an easy format to store animation textures in because it's the
    same format as the source data. This method won't work well on mobile hardware.
    The memory bandwidth from main memory to tiler memory is a scarce resource.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 动画纹理目前以32位浮点纹理格式存储。这是一种容易存储动画纹理的格式，因为它与源数据的格式相同。这种方法在移动硬件上效果不佳。从主内存到图块内存的内存带宽是一种稀缺资源。
- en: To target mobile platforms, consider changing from `GL_RGBA32F` to `GL_RGBA`
    with a `GL_UNSIGNED_BYTE` storage type. Switching to a standard texture format
    does mean losing some data. With a `GL_UNSIGNED_BYTE` storage type, each component
    of a color is limited to 256 unique values. These values are normalized when sampling
    and will be returned in a 0 to 1 range.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了针对移动平台，考虑从`GL_RGBA32F`更改为带有`GL_UNSIGNED_BYTE`存储类型的`GL_RGBA`。切换到标准纹理格式确实意味着丢失一些数据。使用`GL_UNSIGNED_BYTE`存储类型，颜色的每个分量都限制在256个唯一值。这些值在采样时被标准化，并将返回在0到1的范围内。
- en: If any of the animation information stores values are not in the 0 to 1 range,
    the data will need to be normalized. The normalization scale factor will need
    to be passed to the shader as a uniform. If you are targeting mobile hardware,
    you probably only want to store rotation information anyway, which is already
    in the 0 to 1 range.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何动画信息存储值不在0到1的范围内，数据将需要被标准化。标准化比例因子将需要作为统一传递给着色器。如果你的目标是移动硬件，你可能只想存储旋转信息，这些信息已经在0到1的范围内。
- en: In the next section, you will explore how multiple animation textures can be
    combined into a single texture. This reduces the number of textures that need
    to be bound for a crowd to play multiple animations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将探索如何将多个动画纹理合并成单个纹理。这减少了需要绑定的纹理数量，以便人群播放多个动画。
- en: Combining animation textures
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并动画纹理
- en: The act of combining many smaller textures into one larger texture is called
    atlasing. A large texture that contains multiple smaller textures is often called
    a texture atlas. The benefit of atlasing textures is needing to use fewer texture
    samplers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将许多较小的纹理合并成一个较大的纹理的行为称为纹理合并。包含多个较小纹理的大纹理通常称为纹理图集。纹理合并的好处是需要使用较少的纹理采样器。
- en: 'The crowd rendering system presented in this chapter has one major drawback:
    while the crowd can play animations at different time offsets, they can only play
    the same animation. There is an easy way to work around this: atlas multiple animation
    textures onto one large texture.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的人群渲染系统有一个主要缺点：虽然人群可以以不同的时间偏移播放动画，但他们只能播放相同的动画。有一个简单的方法可以解决这个问题：将多个动画纹理合并到一个大纹理上。
- en: A *1024x1024* texture, for example, can contain 16 smaller *256x256* textures.
    This means any member of the crowd could play 1 of 16 animations. An additional
    "offset" uniform has to be added to the per-instance data of the shader. This
    offset uniform would be an array of `MAX_INSTANCES` size.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个*1024x1024*的纹理可以包含16个较小的*256x256*纹理。这意味着人群中的任何成员都可以播放16种动画中的一种。着色器的每个实例数据都需要添加一个额外的“偏移”统一。这个偏移统一将是一个`MAX_INSTANCES`大小的数组。
- en: For each character being rendered, the `GetPose` function would have to apply
    the offset before retrieving the animation texels. In the next section, you will
    explore different techniques that you can use to optimize the crowd shader by
    minimizing texel fetches.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个被渲染的角色，`GetPose`函数在检索动画纹素之前必须应用偏移。在下一节中，您将探索不同的技术，可以使用这些技术来通过最小化纹素获取来优化人群着色器。
- en: Optimizing texel fetches
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化纹素获取
- en: Even on a gaming PC, rendering over 200 crowd characters will take more than
    4 milliseconds, which is a pretty long time, assuming you have a 16.6 ms frame
    time. So, why is crowd rendering so expensive?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在游戏PC上，渲染超过200个人群角色将花费超过4毫秒的时间，这是一个相当长的时间，假设您有16.6毫秒的帧时间。那么，为什么人群渲染如此昂贵呢？
- en: Every time the `GetPose` helper function is called, the shader performs 6 texel
    fetches. Since each vertex is skinned to four influences, that's 24 texel fetches
    per vertex! Even with a low poly model, that is a lot of texel fetches. Optimizing
    this shader will boil down to minimizing the number of texel fetches.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`GetPose`辅助函数时，着色器执行6个纹素获取。由于每个顶点都被蒙皮到四个影响，每个顶点需要24个纹素获取！即使是低多边形模型，这也是大量的纹素获取。优化这个着色器将归结为最小化纹素获取的数量。
- en: The following sections present different strategies you can use to minimize
    the number of texel fetches per vertex.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分介绍了您可以使用的不同策略，以最小化每个顶点的纹素获取数量。
- en: Limiting influences
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制影响
- en: 'A naive way to optimize texel fetches would be to add a branch to the shader
    code. After all, if the weight of the matrix is 0, why bother getting the pose?
    This optimization could be implemented as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 优化纹素获取的一种天真的方法是在着色器代码中添加一个分支。毕竟，如果矩阵的权重为0，为什么要获取姿势呢？这种优化可以实现如下：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the best-case scenario, this might save a little bit of time. In the worst-case
    scenario (where every bone has exactly four influences), this will actually add
    an extra cost to the shader since now, every influence comes with a conditional
    branch.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在最理想的情况下，这可能会节省一点时间。在最坏的情况下（每个骨骼恰好有四个影响），这实际上会给着色器增加额外的成本，因为现在每个影响都带有一个条件分支。
- en: A better way to limit texel fetches would be to limit bone influences. 3DCC
    tools such as Blender, 3DS Max, or Maya have export options to limit the maximum
    number of bone influences per vertex. You should limit the maximum number of bone
    influences to 1 or 2.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 限制纹理获取的更好方法是限制骨骼影响。Blender、3DS Max或Maya等3DCC工具具有导出选项，可以限制每个顶点的最大骨骼影响数量。您应该将最大骨骼影响数量限制为1或2。
- en: Generally, in a large crowd, it's hard to make out the fine details on individual
    actors. Because of this, lowering the bone influences to 1, effectively rigid
    skinning the crowd, is often doable. In the next section, you will explore how
    limiting the number of animated components can help reduce the number of texel
    fetches per vertex.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在人群中，很难看清个别演员的细节。因此，将骨骼影响降低到1，有效地使人群的皮肤刚性化，通常是可行的。在接下来的部分，您将探讨如何通过限制动画组件的数量来帮助减少每个顶点的纹理获取次数。
- en: Limiting animated components
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制动画组件
- en: Consider an animated human character. Human joints only rotate; they never translate
    or scale. If you know that an animation is only animating one or two components
    per joint, the `GetPose` function can be edited to sample less data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个动画的人类角色。人类关节只旋转；它们永远不会平移或缩放。如果您知道一个动画只对每个关节进行一到两个组件的动画，`GetPose`函数可以被编辑以采样更少的数据。
- en: 'There is an added benefit here: the number of bones that can be encoded into
    an animation texture increases. If you''re encoding the position, rotation, and
    scale, the maximum number of joints is `texture size / 3`. If you are encoding
    just one component, the number of joints that can be encoded is the size of the
    texture.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个额外的好处：可以将编码到动画纹理中的骨骼数量增加。如果您编码位置、旋转和缩放，最大关节数为`纹理大小/3`。如果您只编码一个组件，可以编码的关节数就是纹理的大小。
- en: This optimization will make a *256x256* texture able to encode 256 rotations
    instead of 85 transforms. In the next section, you will explore whether interpolation
    between frames is needed or not.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化将使*256x256*纹理能够编码256个旋转，而不是85个变换。在下一节中，您将探讨是否需要在帧之间进行插值。
- en: Not interpolating
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不进行插值
- en: Consider the animation texture. It samples the animation in set increments to
    fill out every column of the texture. At 256 samples, you can encode 3.6 seconds
    of animation at 60 FPS.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑动画纹理。它以设定的增量对动画进行采样，以填充纹理的每一列。在256个样本中，您可以在60 FPS下编码3.6秒的动画。
- en: Whether or not interpolation is needed will depend on the size of the animation
    texture and the length of the animation being encoded. For most in-game character
    animations such as run, walk, attach, or die, interpolation doesn't need frame
    interpolation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 是否需要插值将取决于动画纹理的大小和被编码的动画长度。对于大多数游戏角色动画，如奔跑、行走、攻击或死亡，不需要帧插值。
- en: With this optimization, the amount of data that's sent to the GPU is greatly
    reduced. The frames uniform can change from an `ivec2` to an `int`, cutting the
    size of the data in half. This means that the time uniform can go away completely.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种优化，发送到GPU的数据量大大减少。帧统一可以从`ivec2`变为`int`，将数据大小减半。这意味着时间统一可以完全消失。
- en: In the next section, you will explore what the combined effect of the three
    optimizations that you just learned about is.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将探讨您刚刚学到的三种优化的综合效果。
- en: Combining these optimizations
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合这些优化
- en: 'Let''s explore the impact that these optimizations can have, assuming all three
    of the following optimizations are implemented:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨这些优化可能产生的影响，假设以下三种优化都已实施：
- en: Limit the number of bone influences to 2.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将骨骼影响的数量限制为2。
- en: Only animate the rotation component of the transform.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只对变换的旋转组件进行动画。
- en: Do not interpolate between frames.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在帧之间进行插值。
- en: This will have reduced the number of texel fetches from 24 per vertex to just
    2 per vertex. The number of joints that can be encoded into an animation texture
    will increase, and the amount of data that is transferred to the GPU each frame
    will be reduced considerably.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把每个顶点的纹理获取次数从24减少到2。可以编码到动画纹理中的关节数量将增加，并且每帧传输到GPU的数据量将大大减少。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to encode animation data to textures, as well
    as how to interpret the data in a vertex shader. Several strategies for improving
    performance by changing how the animation data is encoded were also covered. This
    technique of writing data into a texture can be used to bake any kind of sampled
    data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何将动画数据编码到纹理中，以及如何在顶点着色器中解释数据。还介绍了通过改变动画数据编码方式来改善性能的几种策略。将数据写入纹理的这种技术可以用于烘焙任何类型的采样数据。
- en: 'To bake an animation, you need to clip out into a texture. This clip was sampled
    at set intervals. The global position of every bone was recorded at each interval
    and written to a texture. In this animation texture, every joint takes up three
    rows: one for position, one for rotation, and one for scale.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要烘焙动画，您需要将其剪辑到纹理中。这个剪辑是在设定的间隔内采样的。每个骨骼的全局位置在每个间隔都被记录并写入纹理。在这个动画纹理中，每个关节占据三行：一个用于位置，一个用于旋转，一个用于缩放。
- en: You rendered the crowd mesh using instancing and created a shader that can read
    per-instance data from uniform arrays. Per instance-data for actors of the crowd,
    such as position, rotation, and scale, were passed to the shader as uniform arrays
    and interpreted using the instance ID as an index into those arrays.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用实例化渲染了人群网格，并创建了一个可以从统一数组中读取每个实例数据的着色器。人群演员的每个实例数据，如位置、旋转和缩放，都作为统一数组传递给着色器，并使用实例ID作为这些数组的索引进行解释。
- en: Finally, you created the `Crowd` class. This utility class provides an easy-to-use
    interface for managing actors in a crowd. This class will automatically populate
    the per-instance uniform of the crowd shader. Using this class, you can easily
    create large, interesting crowds.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您创建了`Crowd`类。这个实用类提供了一个易于使用的界面，用于管理人群中的演员。这个类将自动填充人群着色器的每个实例统一。使用这个类，您可以轻松地创建大型、有趣的人群。
- en: There are two samples for this chapter in the downloadable content of this book.
    `Sample00` is all the code we wrote in this chapter. `Sample01`, on the other
    hand, demonstrates how to use this code to render large crowds in practice.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的可下载内容中有本章的两个示例。`Sample00`是本章中我们编写的所有代码。另一方面，`Sample01`演示了如何在实践中使用这些代码来渲染大规模人群。
