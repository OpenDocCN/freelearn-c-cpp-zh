- en: Diving into Modern C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入现代C++
- en: The C++ programming language has been changed dramatically since its invention
    in 1979\. Some people in this era might be a little bit scared to code using C++
    language since it is not user-friendly. The memory management we have to deal
    with sometimes makes people unwilling to use this language. Fortunately, since
    **C++11**--also known as **modern C++**, along with **C++14** and **C++17**--has
    been released, numerous features have been introduced to simplify our code in
    the C++ language. Moreover, the best part of it is that the C++ programming language
    is a great language for any project, from low-level programming to web programming,
    as well as functional programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自1979年发明以来，C++编程语言发生了巨大变化。在这个时代，有些人可能会有点害怕使用C++语言编码，因为它不够用户友好。我们有时必须处理的内存管理有时会让人不愿意使用这种语言。幸运的是，自**C++11**--也被称为**现代C++**，以及**C++14**和**C++17**--发布以来，已经引入了许多功能来简化我们在C++语言中的代码。而且，最好的部分是C++编程语言是任何项目的绝佳语言，从低级编程到Web编程，以及函数式编程。
- en: 'This chapter is the best place to start our journey in this book, as it is
    addressed to the C++ programmers to refresh their knowledge and will discuss the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是我们在本书中开始旅程的最佳地方，因为它是为C++程序员设计的，可以更新他们的知识，并将讨论以下主题：
- en: Understanding several new features in modern C++
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解现代C++中的一些新功能
- en: Implementing the C++ Standard Libraries in modern C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代C++中实现C++标准库
- en: The use of the Lambda expression and all features included in C++ Lambda
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lambda表达式和C++ Lambda中包含的所有功能
- en: Using smart pointer to avoid manual memory management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能指针避免手动内存管理
- en: Dealing with many return values using tuples
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组处理多个返回值
- en: Getting closer with several new features in modern C++
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解现代C++中的一些新功能
- en: So, what is new in modern C++ in comparison to the old one? There are so many
    changes in modern C++ compared to the old one, and the book pages will dramatically
    increase if we discuss all of them. However, we will discuss the new features
    in modern C++, which we should know about, to make us more productive in coding
    activities. We will discuss several new keywords, such as `auto`, `decltype`,
    and `nullptr`. We will also discuss the enhancement of the `begin()` and `end()`
    function that has now become a non-member class function. We will also discuss
    the augmented support for the `for-each` technique to iterate over collections
    using the `range-based for loop` techniques.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现代C++与旧版本相比有什么新功能？与旧版本相比，现代C++中有很多变化，如果我们讨论所有这些变化，书页将大幅增加。然而，我们将讨论现代C++中的新功能，我们应该了解这些功能，以使我们在编码活动中更加高效。我们将讨论几个新关键字，如`auto`、`decltype`和`nullptr`。我们还将讨论`begin()`和`end()`函数的增强，这些函数现在已成为非成员类函数。我们还将讨论对使用`range-based
    for loop`技术迭代集合的`for-each`技术的增强支持。
- en: The next few subsections in this chapter will also discuss the new features
    of modern C++, namely Lambda expressions, smart pointers, and tuples, which were
    just added in the C++11 release.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的接下来几个小节还将讨论现代C++的新功能，即Lambda表达式、智能指针和元组，这些功能刚刚在C++11发布中添加。
- en: Defining the data type automatically using the auto keyword
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`auto`关键字自动定义数据类型
- en: Prior to the modern C++, the C++ language has a keyword named `auto` that is
    used to explicitly specify that the variable should have **automatic duration**.
    The automatic duration that adheres to the variable will create the variable at
    the point of definition (and initialized, if relevant) and destroy the variable
    when the block they are defined in is exited. For instance, the local variable
    will be created when it is defined at the beginning of the function and destroyed
    when the program exits the function where the local variable is there.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代C++之前，C++语言有一个名为`auto`的关键字，用于明确指定变量应具有**自动持续时间**。遵循变量的自动持续时间将在定义点创建变量（如果相关，则初始化），并在退出定义它们的块时销毁变量。例如，局部变量将在函数开始时定义并在程序退出包含局部变量的函数时销毁。
- en: Since C++11, the `auto` keyword is used to tell the compiler to deduce the actual
    type of a variable that is being declared from its initializer. And since C++14,
    the keyword can also be applied to a function to specify the return type of the
    function that is a trailing return type. Now, in modern C++, the use of the `auto`
    keyword to specify the automatic duration is abolished since all variables are
    set to automatic duration by default.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，`auto`关键字用于告诉编译器从其初始化程序推断出正在声明的变量的实际类型。自C++14以来，该关键字还可以应用于函数，以指定函数的返回类型，即尾随返回类型。现在，在现代C++中，使用`auto`关键字指定自动持续时间已被废除，因为默认情况下所有变量都设置为自动持续时间。
- en: 'The following is an `auto.cpp` code demonstrating the use of the `auto` keyword
    in the variables. We will define four variables with the `auto` keyword, and then
    find out the data type for each variable using the `typeid()` function. Let''s
    take a look:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`auto.cpp`代码，演示了变量中使用`auto`关键字。我们将使用`auto`关键字定义四个变量，然后使用`typeid()`函数找出每个变量的数据类型。让我们来看一下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see in the preceding code, we have an `a` variable that will store
    the `integer` value and have a `b` variable that will store the `double` value.
    We calculate the addition of `a` and `b` and store the result in variable `c`.
    Here, we expect that `c` will store the `double` object since we add the `integer`
    and `double` object. The last is the `d` variable that will store the `initializer_list<double>`
    data type. When we run the preceding code, we will see the following output on
    the console:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，我们有一个将存储`整数`值的变量`a`，并且有一个将存储`双精度`值的变量`b`。我们计算`a`和`b`的加法，并将结果存储在变量`c`中。在这里，我们期望`c`将存储`双精度`对象，因为我们添加了`整数`和`双精度`对象。最后是将存储`initializer_list<double>`数据类型的变量`d`。当我们运行前面的代码时，将在控制台上看到以下输出：
- en: '![](img/5d5e1164-6f13-4afb-9011-c6444f0c3589.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d5e1164-6f13-4afb-9011-c6444f0c3589.png)'
- en: As can be seen in the preceding snapshot, we are just given the first character
    of the data type, such as `i` for `integer`, `d` for `double`, and `St16initializer_listIdE`
    for `initializer_list<double>`, that is the last lowercase `d` character that
    stands for `double`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的快照所示，我们只给出了数据类型的第一个字符，比如`i`代表`整数`，`d`代表`双精度`，`St16initializer_listIdE`代表`initializer_list<double>`，最后一个小写的`d`字符代表`双精度`。
- en: We may have to enable the **Run-Time Type Information** (**RTTI**) feature in
    our compiler options to retrieve the data type object. However, GCC has enabled
    the feature by default. Also, the output of the use of the `typeid()` function
    depends on the compiler. We may get the raw type name or just a symbol as we did
    in the preceding example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在编译器选项中启用**运行时类型信息**（**RTTI**）功能来检索数据类型对象。然而，GCC已经默认启用了这个功能。此外，`typeid()`函数的使用输出取决于编译器。我们可能会得到原始类型名称，或者就像我们在前面的例子中所做的那样，只是一个符号。
- en: 'Besides, for variable, as we discussed earlier, the `auto` keyword can also
    be applied to a function to deduce a function''s return type automatically. Suppose
    we have the following trivial function named `add()` to calculate the addition
    of two parameters:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于变量，正如我们之前讨论的那样，`auto`关键字也可以应用于函数，自动推断函数的返回类型。假设我们有以下名为`add()`的简单函数来计算两个参数的加法：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can refactor the preceding method to use the `auto` keyword, as we can see
    in the following lines of code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构前面的方法来使用`auto`关键字，如下所示的代码行：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Similar to the auto-type variable, the compiler can decide the correct return
    type based on the returned value of the function. And, as shown in the preceding
    code, the function will indeed return the integer value since we just add two
    integer values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与自动类型变量类似，编译器可以根据函数的返回值决定正确的返回类型。正如前面的代码所示，该函数确实返回整数值，因为我们只是添加了两个整数值。
- en: 'Another feature that uses the `auto` keyword in modern C++ is trailing the
    return type syntax. By using this feature, we can specify the return type, the
    rest of the function prototype, or function signature. From the preceding code,
    we can refactor it to use the feature as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++中使用`auto`关键字的另一个特性是尾返回类型语法。通过使用这个特性，我们可以指定返回类型，函数原型的其余部分，或函数签名。从前面的代码中，我们可以重构它以使用以下特性：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You might ask me why we have to specify the data type again after the arrow
    symbol (`->`), even though we have used the `auto` keyword. We will find the answer
    when we cover the `decltype` keyword in the next section. Also, by using this
    feature, we can now refactor the preceding `auto.cpp` code a little bit by modifying
    the syntax of the `main()` method, instead of the following syntax of `main()`
    function signature:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我为什么我们在箭头符号(`->`)之后再次指定数据类型，即使我们已经使用了`auto`关键字。当我们在下一节讨论`decltype`关键字时，我们将找到答案。此外，通过使用这个特性，我们现在可以通过修改`main()`方法的语法来稍微重构前面的`auto.cpp`代码，而不是`main()`函数签名的以下语法：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can change the signature syntax into the following line of code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将签名语法改为以下代码行：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we will see all of our code in this book using this trailing return type
    feature to apply the modern C++ syntax.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到本书中的所有代码都使用这个尾返回类型特性来应用现代C++语法。
- en: Querying the type of an expression using the decltype keyword
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用decltype关键字查询表达式的类型
- en: We discussed in the preceding section that the `auto` keyword can automatically
    deduce the type of the variable based on the type of values it stores. The keyword
    can also deduce the function's return type based on the type of its return value.
    Now, let's combine the `auto` keyword and the `decltype` keyword to gain the power
    of modern C++.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分讨论了`auto`关键字可以根据其存储的值的类型自动推断变量的类型。该关键字还可以根据其返回值的类型推断函数的返回类型。现在，让我们结合`auto`关键字和`decltype`关键字，获得现代C++的功能。
- en: 'Before we combine the two keywords, we will find out what the `decltype` keyword
    is used for--it is used for asking the type of an object or an expression. Let''s
    take a look at the following several lines of trivial variable declaration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结合这两个关键字之前，我们将找出`decltype`关键字的用途--它用于询问对象或表达式的类型。让我们看一下以下几行简单的变量声明：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, based on the preceding code, we can declare other variables using the
    `decltype` keyword as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于前面的代码，我们可以使用`decltype`关键字声明其他变量，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see in the preceding code, we can specify the type of an object based
    on another object''s type. Now, let''s suppose we need to refactor the preceding
    `add()` method to become a template. Without the `auto` and `decltype` keyword,
    we will have the following template implementation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们可以根据另一个对象的类型指定对象的类型。现在，假设我们需要重构前面的`add()`方法成为一个模板。没有`auto`和`decltype`关键字，我们将有以下模板实现：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Fortunately, since the `auto` keyword can specify the return type of the function,
    which is a trailing return type, and the `decltype` keyword can deduce the type
    based on the expression, we can refactor the preceding template as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，由于`auto`关键字可以指定函数的返回类型，即尾返回类型，而`decltype`关键字可以根据表达式推断类型，我们可以将前面的模板重构如下：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To prove, let''s compile and run the following `decltype.cpp` code. We will
    use the following template to calculate the addition of two different value types--`integer`
    and `double`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明，让我们编译和运行以下的`decltype.cpp`代码。我们将使用以下模板来计算两种不同值类型--`整数`和`双精度`的加法：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The compilation process should run smoothly without error. We will see the
    following output on the screen if we run the preceding code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程应该可以顺利进行，没有错误。如果我们运行前面的代码，我们将在屏幕上看到以下输出：
- en: '![](img/9b573b77-6cc6-41a6-94cb-8fc04dd314c8.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b573b77-6cc6-41a6-94cb-8fc04dd314c8.png)'
- en: As we can see, we have successfully combined the `auto` and `decltype` keyword
    to create a template simpler than we usually do before the modern C++ is announced.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们成功地结合了`auto`和`decltype`关键字，创建了一个比现代C++宣布之前通常更简单的模板。
- en: Pointing to a null pointer
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指向空指针
- en: 'Another new feature in modern C++ is a keyword named `nullptr` that replaces
    the `NULL` macro to represent a null pointer. Now, there''s no ambiguity in the
    use of the `NULL` macro for zero numeric or a null pointer. Let''s suppose we
    have the following two method''s signature in our declaration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++中的另一个新功能是一个名为`nullptr`的关键字，它取代了`NULL`宏来表示空指针。现在，在使用`NULL`宏表示零数字或空指针时不再存在歧义。假设我们在声明中有以下两个方法的签名：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The former function will pass a pointer as the argument and the latter will
    pass the integer number as its argument. Then, we invoke the `funct()` method
    and pass the `NULL` macro as the parameter, as shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数将传递一个指针作为参数，后一个将传递整数作为参数。然后，我们调用`funct()`方法并将`NULL`宏作为参数传递，如下所示：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What we intend to call is the former function. However, since we pass the `NULL`
    parameters, which is basically defined as `0`, the latter function will be invoked.
    In modern C++, we can use the `nullptr` keyword to ensure that we will pass a
    null pointer to the argument. The invocation of the `funct()` method should be
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算调用前一个函数。然而，由于我们传递了`NULL`参数，它基本上被定义为`0`，后一个函数将被调用。在现代C++中，我们可以使用`nullptr`关键字来确保我们将传递一个空指针给参数。调用`funct()`方法应该如下：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now the compiler will invoke the former function since it passes a null pointer
    to the argument, and this is what we expect. There will be no ambiguity anymore,
    and it will avoid unnecessary future problems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器将调用前一个函数，因为它将一个空指针传递给参数，这是我们期望的。不再存在歧义，将避免不必要的未来问题。
- en: Returning an iterator using non-member begin() and end() function
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非成员begin()和end()函数返回迭代器
- en: 'Prior to modern C++, to iterate a sequence, we call the `begin()` and `end()`
    member method of each container. For array, we can iterate its element by iterating
    the index. Since C++11, the language has a non-member function--`begin()` and
    `end()`--to retrieve the iterator of the sequence. Let''s suppose we have an array
    of the following elements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代C++之前，要迭代一个序列，我们需要调用每个容器的`begin()`和`end()`成员方法。对于数组，我们可以通过迭代索引来迭代它的元素。自C++11以来，语言有一个非成员函数--`begin()`和`end()`--来检索序列的迭代器。假设我们有以下元素的数组：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the language doesn''t have the `begin()` and `end()` function, we need
    to iterate the elements of the array using the index we can see in the following
    lines of code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当语言没有`begin()`和`end()`函数时，我们需要使用索引来迭代数组的元素，可以在下面的代码行中看到：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Fortunately, using the `begin()` and `end()` function, we can refactor the
    preceding `for` loop to become as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用`begin()`和`end()`函数，我们可以重构前面的`for`循环如下：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see, the use of the `begin()` and `end()` function creates a compact
    code since we don''t need to worry about the length of the array because the iterator
    pointer of `begin()` and `end()` will do it for us. For comparison, let''s take
    a look at the following `begin_end.cpp` code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用`begin()`和`end()`函数创建了一个紧凑的代码，因为我们不需要担心数组的长度，因为`begin()`和`end()`的迭代器指针会为我们做这件事。为了比较，让我们看一下以下的`begin_end.cpp`代码：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To prove the preceding code, we can compile the code, and, when we run it,
    the following output should be displayed on the console screen:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明前面的代码，我们可以编译代码，当我们运行它时，应该在控制台屏幕上显示以下输出：
- en: '![](img/3219ad51-9855-43ce-b596-536273d9c047.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3219ad51-9855-43ce-b596-536273d9c047.png)'
- en: As we can see in the screenshot, we've got the exact same output when we use
    the conventional `for-loop` or `begin()` and `end()` functions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在屏幕截图中看到的，当我们使用传统的`for-loop`或`begin()`和`end()`函数时，我们得到了完全相同的输出。
- en: Iterating over collections using range-based for loops
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于范围的for循环迭代集合
- en: 'In the modern C++, there is a new feature that is augmented to support the
    `for-each` technique to iterate over collections. This feature is useful if you
    want to do something to the elements of a collection or array without caring about
    the number of elements or the indexes. The syntax of the feature is also simple.
    Suppose we have an array named `arr` and we want to iterate each element using
    the `range-based for loop` technique; we can use the following syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代C++中，有一个新功能被增强，支持“for-each”技术来迭代集合。如果你想对集合或数组的元素做一些操作而不关心元素的数量或索引，这个功能就很有用。这个功能的语法也很简单。假设我们有一个名为`arr`的数组，我们想要使用`range-based
    for loop`技术迭代每个元素，我们可以使用以下语法：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, we can refactor our preceding `begin_end.cpp` code to use `range-based
    for loop` as we can see in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以重构我们之前的`begin_end.cpp`代码，使用`range-based for loop`，如下所示：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The syntax we see in the preceding code is simpler now. If we compile the preceding
    code, we should find no error and, if we run the code, we should see the following
    output on the console screen:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中看到的语法现在更简单了。如果我们编译前面的代码，应该不会出现错误，如果我们运行代码，应该在控制台屏幕上看到以下输出：
- en: '![](img/3f3f2d37-a65c-491d-86e6-c0cc8523e391.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f3f2d37-a65c-491d-86e6-c0cc8523e391.png)'
- en: We now have a new technique to iterate over the collection without caring about
    the indexes of the collection. We will keep using it in this book.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种新的技术来迭代集合，而不必关心集合的索引。我们将在本书中继续使用它。
- en: Leveraging the use of C++ language with the C++ Standard Libraries
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用C++语言与C++标准库
- en: The C++ Standard Libraries are a powerful set of classes and functions that
    have many capabilities needed to create an application. They are controlled by
    the C++ ISO Standard Committee and is influenced by the **Standard Template Libraries**
    (**STL**), which were the generic libraries before C++11 was introduced. All features
    in Standard Libraries are declared in `std namespace` and no headers end in `.h`
    anymore (except 18 headers of the ISO C90 C Standard Library that is incorporated
    into the C++ Standard Libraries).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库是一个强大的类和函数集合，具有创建应用程序所需的许多功能。它们由C++ ISO标准委员会控制，并受到**标准模板库**（**STL**）的影响，在C++11引入之前是通用库。标准库中的所有功能都在`std命名空间`中声明，不再以`.h`结尾的头文件（除了18个ISO
    C90 C标准库的头文件，它们被合并到了C++标准库中）。
- en: There are several header files containing the declaration of the C++ Standard
    Libraries. However, it is almost impossible to discuss all header files in these
    tiny chapters. We will, therefore, talk about some features that we will use most
    in our daily coding activities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库中包含了几个头文件，其中包含了C++标准库的声明。然而，在这些小章节中几乎不可能讨论所有的头文件。因此，我们将讨论一些我们在日常编码活动中最常使用的功能。
- en: Placing any objects in the container
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将任何对象放入容器中
- en: '**Container** is an object that is used to store other objects and manage the
    memory that is used by the objects it contains. An array is a new feature added
    in C++11 to store the collection of specific data types. It is a sequence container
    since it stores the same data type objects and arranges them linearly. Let''s
    take a look at the following code snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**是用来存储其他对象并管理它所包含的对象的内存的对象。数组是C++11中添加的一个新特性，用于存储特定数据类型的集合。它是一个序列容器，因为它存储相同数据类型的对象并将它们线性排列。让我们看一下以下代码片段：'
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we can see in the preceding code, we instance a new array named `arr`, set
    its length as `10`, and only approve the `int` element. As we can guess, the output
    of the code is a line of numbers `0` through `9`, which is shown in the original
    data, and the other line will show the altered data, as we can see in the following
    screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们实例化了一个名为`arr`的新数组，将其长度设置为`10`，并且只批准`int`元素。我们可以猜到，代码的输出是一行数字`0`到`9`，显示了原始数据，另一行将显示更改后的数据，如我们在以下截图中所看到的：
- en: '![](img/9bf41be3-c581-4cf9-87d9-be35bc06f403.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bf41be3-c581-4cf9-87d9-be35bc06f403.png)'
- en: There is no performance issue if we declare an array using `std::array`; we
    use in the `array.cpp` code and compare it with a usual array as we use in the
    `begin_end.cpp` code. However, in modern C++, we are given a new array declaration
    that has a friendly value semantic, so that it can be passed to or returned from
    functions by value. Also, the interface of this new array declaration makes it
    more convenient to find the size, and use it with **Standard Template Library**
    (**STL**)-style iterator-based algorithms.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`std::array`声明一个数组，就不会有性能问题；我们在`array.cpp`代码中使用它，并将其与在`begin_end.cpp`代码中使用的普通数组进行比较。然而，在现代C++中，我们有一个新的数组声明，它具有友好的值语义，因此可以按值传递给函数或从函数中返回。此外，这个新数组声明的接口使得更方便地找到大小，并与**标准模板库**（**STL**）风格的基于迭代器的算法一起使用。
- en: 'It is good to use an array as the container since we can store the data and
    manipulate them. We can also sort and find a specific element if we want. However,
    since the array is a compile-time non-resizable object, we have to decide the
    size of the array we intend to use at the very beginning as we cannot change the
    size later. In other words, we cannot insert or remove the element from the existing
    array. As a solution to this problem, and for the best practice of using the container
    as well, we can now use a `vector` to store our collection. Let''s take a look
    at the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组作为容器是很好的，因为我们可以存储数据并对其进行操作。我们还可以对其进行排序，并查找特定元素。然而，由于数组是一个在编译时不可调整大小的对象，我们必须在最开始决定要使用的数组的大小，因为我们不能后来改变大小。换句话说，我们不能在现有数组中插入或删除元素。作为解决这个问题的方法，以及为了最佳实践使用容器，我们现在可以使用`vector`来存储我们的集合。让我们看一下以下代码：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we have a `vector` instance in our preceding code instead of an `array`
    instance. As we can see, we give an additional value for the `vector` instance
    using the `push_back()` method. We can add the value anytime we want. The manipulation
    of each element is also easier since `vector` has an `at()` method that returns
    a reference to the element of the specific index. The following screenshot is
    what we will see as the output when running the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们之前的代码中有一个`vector`实例，而不是一个`array`实例。正如我们所看到的，我们使用`push_back()`方法为`vector`实例添加了一个额外的值。我们可以随时添加值。每个元素的操作也更容易，因为`vector`有一个`at()`方法，它返回特定索引的元素的引用。运行代码时，我们将看到以下截图作为输出：
- en: '![](img/d6c12da0-75ee-450a-b324-a86e4bf59dad.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6c12da0-75ee-450a-b324-a86e4bf59dad.png)'
- en: It is better to always use the `at()` method instead of the `[]` operator when
    we want to access the specific element by its index in a `vector` instance. It's
    because, when we accidentally access the out of range position, the `at()` method
    will throw an `out_of_range` exception. Otherwise, the `[]` operator will give
    undefined behavior.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要通过索引访问`vector`实例中的特定元素时，最好始终使用`at()`方法而不是`[]`运算符。这是因为，当我们意外地访问超出范围的位置时，`at()`方法将抛出一个`out_of_range`异常。否则，`[]`运算符将产生未定义的行为。
- en: Using algorithms
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用算法
- en: 'We can sort the elements of the collection we have in `array` or `vector`,
    as well as find specific content of the element. For these purposes, we have to
    use the algorithm feature provided by the C++ Standard Library. Let''s take a
    look at the following code to demonstrate the sorting element capability in the
    algorithm feature:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对`array`或`vector`中的集合元素进行排序，以及查找特定内容的元素。为了实现这些目的，我们必须使用C++标准库提供的算法功能。让我们看一下以下代码，以演示算法功能中排序元素的能力：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we see in the preceding code, we invoked the `sort()` method twice. First,
    we just supplied the range of the elements we wanted to sort. Then we added the
    comparison function, `comparer()`, to be provided to the `sort()` method to gain
    more flexibility the method has. The output we will see on the console from the
    preceding code is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，我们两次调用了`sort()`方法。首先，我们只提供了我们想要排序的元素的范围。然后，我们添加了比较函数`comparer()`，以便将其提供给`sort()`方法，以获得更多灵活性。从前面的代码中，我们将在控制台上看到的输出如下：
- en: '![](img/a39ab3f7-55b8-4dda-8f2f-4d253d92f0d9.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a39ab3f7-55b8-4dda-8f2f-4d253d92f0d9.png)'
- en: From the preceding screenshot, we can see that we have six elements in a `vector`
    at the beginning. We then sort the elements of the vector using a simple `sort()`
    method. Then, we invoke the `sort()` method again, but instead of a simple `sort()`
    method, we now supply `comparer()` to the `sort()` method. As a result, the vector
    elements will be sorted descendingly since the `comparer()` function looks for
    the greater value from two inputs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以看到一开始`vector`中有六个元素。然后，我们使用简单的`sort()`方法对向量的元素进行排序。然后，我们再次调用`sort()`方法，但现在不是简单的`sort()`方法，而是将`comparer()`提供给`sort()`方法。结果，向量元素将按降序排序，因为`comparer()`函数从两个输入中寻找更大的值。
- en: 'Now, let''s move to another capability the algorithm feature has, which is
    finding a particular element. Let''s suppose we have the `Vehicle` class in our
    code. It has two private fields named `m_vehicleType` and `m_totalOfWheel`, and
    we can retrieve the value from the getter methods named `GetType()` and `GetNumOfWheel()`
    respectively. It also has two constructors, which are the default constructor
    and the user-defined one. The declaration of the class should be as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向算法特性具有的另一个功能，即查找特定元素。假设我们在代码中有`Vehicle`类。它有两个名为`m_vehicleType`和`m_totalOfWheel`的私有字段，我们可以从getter方法`GetType()`和`GetNumOfWheel()`中检索值。它还有两个构造函数，分别是默认构造函数和用户定义的构造函数。类的声明应该如下所示：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The implementation of the `Vehicle` class is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`类的实现如下：'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will store a collection of `Vehicle` in the `vector` container, and then
    we will search for some elements based on its property. The code will be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`vector`容器中存储一组`Vehicle`，然后根据其属性搜索一些元素。代码如下：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see, we instance four `Vehicle` objects, then store them in `vector`.
    There, we try to find the vehicle that has two wheels. The `find_if()` function
    is used for this purpose. We also have the `TwoWheeled()` method to provide the
    comparison value. Since we are finding the two-wheeled vehicle, we will inspect
    the `totalOfWheel` variable in the `Vehicle` class by invoking the `GetNumOfWheel()`
    method. In contrast, if we want to find the element that doesn''t conform to the
    comparison value, we can use the `find_if_not()` function, which had been added
    in C++11\. The output we get should look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们实例化了四个`Vehicle`对象，然后将它们存储在`vector`中。在那里，我们试图找到有两个轮子的车辆。`find_if()`函数用于此目的。我们还有`TwoWheeled()`方法来提供比较值。由于我们正在寻找两轮车辆，我们将通过调用`GetNumOfWheel()`方法来检查`Vehicle`类中的`totalOfWheel`变量。相反，如果我们想找到不符合比较值的元素，我们可以使用在C++11中添加的`find_if_not()`函数。我们得到的输出应该是这样的：
- en: '![](img/7c5af549-86c7-4414-896e-e9fe96a9cb20.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c5af549-86c7-4414-896e-e9fe96a9cb20.png)'
- en: As we can see in the `vehicle.cpp` code and `find.cpp` code, we now add the
    `using namespace std;` line in the `*.cpp` files. We do this to make our coding
    activity become more productive since we don't have to type many words. In contrast,
    in `vehicle.h`, we still using `std::` followed by the methods or properties name
    rather than use the std namespace at the beginning. It's best practice to not
    declare `using namespace` in header files since the header files are the files
    we will deliver if we create some libraries for instances. The user of our library
    may have another method with the same name as the function our library has. It
    will definitely create conflict between these two functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`vehicle.cpp`代码和`find.cpp`代码中看到的，我们现在在`*.cpp`文件中添加了`using namespace std;`行。我们这样做是为了使我们的编码活动变得更加高效，因为我们不必输入太多的单词。相反，在`vehicle.h`中，我们仍然使用`std::`后跟方法或属性名称，而不是在开头使用std命名空间。在头文件中最好不要声明`using
    namespace`，因为头文件是我们将为实例创建一些库时要交付的文件。我们库的用户可能有与我们的库具有相同名称的函数。这肯定会在这两个函数之间创建冲突。
- en: 'Another algorithm feature we will use most is the `for_each` loop. Instead
    of using the `for` loop, the use of the `for_each` loop will make our code more
    concise in many cases. It''s also simpler and less error prone than a `for` loop
    because we can define a specific function for the `for_each` loop. Now let''s
    refactor our previous code to use the `for_each` loop. The code is written as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最常使用的另一个算法特性是`for_each`循环。使用`for_each`循环而不是使用`for`循环，在许多情况下会使我们的代码更简洁。它也比`for`循环更简单，更不容易出错，因为我们可以为`for_each`循环定义一个特定的函数。现在让我们重构我们之前的代码以使用`for_each`循环。代码如下所示：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, with the `for_each` loop, we have a clearer code. We only need to provide
    the first and last iterator and then pass a function--the `PrintOut()` function
    in this case--that will be invoked in each element in the range.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`for_each`循环，我们有了更清晰的代码。我们只需要提供第一个和最后一个迭代器，然后传递一个函数--在这种情况下是`PrintOut()`函数--它将在范围内的每个元素中被调用。
- en: Simplifying the function notation using a Lambda expression
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda表达式简化函数表示
- en: 'The Lambda expression is an anonymous notation that represents something that
    performs an operation or calculation. In functional programming, the Lambda expression
    is useful to produce the first class and pure function, which we will discuss
    in separate chapters in this book. For now, let''s familiarize ourselves with
    this new feature introduced in C++11 by investigating three basic parts of the
    Lambda expression:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是一个匿名符号，表示执行操作或计算的东西。在函数式编程中，Lambda表达式对于生成第一类和纯函数非常有用，我们将在本书的不同章节中讨论。现在，让我们通过研究Lambda表达式的三个基本部分来熟悉C++11中引入的这个新特性。
- en: 'capturing list: []'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '捕获列表: []'
- en: 'parameter list: ()'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '参数列表: ()'
- en: 'body: {}'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '主体: {}'
- en: 'The order of these three basic parts is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个基本部分的顺序如下：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The capturing list part is also used as a mark to identify the Lambda expression.
    It is a placeholder to value to be involved in the expression. The only capture
    defaults are the ampersand symbol (`&`), which will implicitly capture the automatic
    variables by reference, and the equal sign (`=`), which will implicitly capture
    the automatic variables by copy (we will discuss it further in the upcoming section).
    The parameter list is similar to the capturing list in every function where we
    can pass the value to it. The body is the implementation of the function itself.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获列表部分也用作标记来识别Lambda表达式。它是一个占位符，用于在表达式中涉及的值。唯一的捕获默认值是和符号（`&`），它将隐式地通过引用捕获自动变量，以及等号（`=`），它将隐式地通过复制捕获自动变量（我们将在接下来的部分进一步讨论）。参数列表类似于每个函数中的捕获列表，我们可以向其传递值。主体是函数本身的实现。
- en: Using the Lambda expression for a tiny function
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda表达式进行微小函数
- en: 'Imagine we have a tiny one-line function that we invoke only once. It''s better
    if we write the operation of that function directly when we need it. We actually
    had this function in our previous example when discussing the C++ Standard Library.
    Just go back to the `for_each.cpp` file and we will find the `PrintOut()` function
    that is only invoked once by `for_each()`. We can make this `for_each` loop more
    readable if we use Lambda. Let''s take a look at the following code snippet to
    examine how we refactor the `for_each.cpp` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个只调用一次的微小单行函数。最好的做法是在需要时直接编写该函数的操作。实际上，在我们讨论C++标准库时，我们在之前的示例中就有这样的函数。只需返回到`for_each.cpp`文件，我们将找到`for_each()`仅调用一次的`PrintOut()`函数。如果我们使用Lambda，可以使这个`for_each`循环更易读。让我们看一下以下代码片段，以查看我们如何重构`for_each.cpp`文件：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, we have transformed the `PrintOut()` function that we used in
    the `for_each.cpp` file into a Lambda expression and passed it to the `for_each`
    loop. It will indeed give the same output as the `for_each.cpp` file does. However,
    now our code becomes more concise and readable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已经将在`for_each.cpp`文件中使用的`PrintOut()`函数转换为Lambda表达式，并将其传递给`for_each`循环。它确实会产生与`for_each.cpp`文件相同的输出。但是，现在我们的代码变得更加简洁和易读。
- en: Using the Lambda expression for multiline functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于多行函数的Lambda表达式
- en: 'The Lambda expression can also be used for multiline functions, so we can put
    the body of the function on it. This will make our code more readable as well.
    Let''s make a new code. In that code, we will have an integer collection and an
    intent to inspect whether the selected element is the prime number or not. We
    can make a separate function, for instance, `PrintPrime()`, then invoke it. However,
    since the prime number checking operation is called only once, it''s more readable
    if we transform it into a Lambda expression. The code should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式也可以用于多行函数，因此我们可以将函数的主体放在其中。这将使我们的代码更易读。让我们编写一个新代码。在该代码中，我们将有一个整数集合和一个意图来检查所选元素是否为质数。我们可以创建一个单独的函数，例如`PrintPrime()`，然后调用它。但是，由于质数检查操作只调用一次，如果我们将其转换为Lambda表达式，代码会更易读。代码应该如下所示：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output we should see on the screen is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在屏幕上看到的输出如下：
- en: '![](img/04d24940-d788-4a9d-a8cd-006f15cfc228.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04d24940-d788-4a9d-a8cd-006f15cfc228.png)'
- en: As we can see in the preceding screenshot, we have successfully identified the
    prime number by using the Lambda expression.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的屏幕截图中所见，我们已成功使用Lambda表达式识别了质数。
- en: Returning a value from the Lambda expression
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Lambda表达式返回值
- en: 'Our two preceding samples of the Lambda expression are just for the purpose
    to print on console. It means the function does not need to return any value.
    However, we can ask the Lambda expression to return a value for an instance if
    we do the calculation inside the function and return the calculation result. Let''s
    take a look at the following code to examine the use of this Lambda:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的两个Lambda表达式示例只是用于在控制台上打印。这意味着函数不需要返回任何值。但是，我们可以要求Lambda表达式返回一个值，例如，如果我们在函数内部进行计算并返回计算结果。让我们看一下以下代码，以查看如何使用这个Lambda：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When we use the `transform()` method in the preceding code, we have a Lambda
    expression that returns a value from the calculation of `n * n`. However, there's
    no return type stated in the expression. This is because we can omit the statement
    of the return type since the compiler has understood that the expression will
    return an `integer` value. So, after we have another vector, `vect2`, which has
    the same size as `vect`, we can invoke the `transform()` method along with the
    Lambda expression, and the value of `vect` will be doubled and stored in `vect2`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在前面的代码中使用`transform()`方法时，我们有一个Lambda表达式，它从`n * n`的计算中返回一个值。但是，表达式中没有声明返回类型。这是因为我们可以省略返回类型的声明，因为编译器已经理解到表达式将返回一个`整数`值。因此，在我们有另一个与`vect`大小相同的向量`vect2`之后，我们可以调用`transform()`方法以及Lambda表达式，`vect`的值将加倍并存储在`vect2`中。
- en: 'We can, if we want to, specify the return type to the Lambda expression. As
    we can see in the preceding code, we transformed the `vect3` vector based on all
    values of the `vect` vector, but now we specify the return type to `double` using
    the arrow symbol (`->`). The result of the preceding code should be like the following
    screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以为Lambda表达式指定返回类型。正如我们在前面的代码中所看到的，我们根据`vect`向量的所有值转换了`vect3`向量，但现在我们使用箭头符号(`->`)指定了返回类型为`double`。前面代码的结果应该如下截图所示：
- en: '![](img/e395ef78-2ab2-418d-a186-6fe8b1884f70.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e395ef78-2ab2-418d-a186-6fe8b1884f70.png)'
- en: As we can see from the preceding screenshot, we have successfully found the
    doubled and average result using the Lambda expression.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的截图中所看到的，我们已经成功地使用Lambda表达式找到了加倍和平均值的结果。
- en: Capturing a value to the Lambda expression
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获值到Lambda表达式
- en: 'In our previous Lambda expression examples, we keep the capturing part and
    the square bracket (`[]`) empty since the Lambda doesn''t capture anything and
    doesn''t have any extra member variable in the anonymous object generated by the
    compiler. We can also specify the object we want to capture in the Lambda expression
    by specifying it in this square bracket. Let''s take a look at the following piece
    of code to go through the discussion:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的Lambda表达式示例中，我们保持了捕获部分和方括号(`[]`)为空，因为Lambda没有捕获任何东西，并且在编译器生成的匿名对象中没有任何额外的成员变量。我们还可以通过在这个方括号中指定要捕获的对象来指定我们想要在Lambda表达式中捕获的对象。让我们看一下以下代码片段来讨论一下：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we will try to capture the value in the Lambda expression,
    explicitly and implicitly. Let''s suppose we have two variables, `a` and `b`,
    and we want to explicitly capture the values, we can specify them in the Lambda
    expression using the `[a,b]` statement, and then using the values inside the function
    body. Moreover, if we wish to capture the value implicitly, just use `[=]` for
    the capturing part and then the expression will know which variable we intend
    to use when we specify them in the function body. If we run the preceding code,
    we will get the following output on the screen:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将尝试在Lambda表达式中显式和隐式地捕获值。假设我们有两个变量`a`和`b`，我们想要显式地捕获这些值，我们可以在Lambda表达式中使用`[a,b]`语句指定它们，然后在函数体内部使用这些值。此外，如果我们希望隐式地捕获值，只需使用`[=]`作为捕获部分，然后表达式将知道我们在函数体中指定的变量。如果我们运行前面的代码，我们将在屏幕上得到以下输出：
- en: '![](img/f55d1c5a-b38f-4bed-a8e2-b2e2945878c8.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f55d1c5a-b38f-4bed-a8e2-b2e2945878c8.png)'
- en: 'We can also mutate the state of the values we capture without modifying the
    value outside the Lambda expression function body. For this purpose, we can use
    the same techniques as used previously, and add the `mutable` keyword as shown
    in the following block of code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以改变我们捕获的值的状态，而不修改Lambda表达式函数体外的值。为此，我们可以使用与之前相同的技术，并在以下代码块中添加`mutable`关键字：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code will double the element of the `vect` vector. It uses capturing
    by value in the Lambda expression and also the `mutable` keyword. As we can see,
    we passed the vector element by reference `(int& x)` and multiplied it by two,
    then changed the value of `a` and `b`. However, since we use the `mutable` keyword,
    the final result of `a` and `b` will remain the same, although, we have passed
    the vector by reference. The output on the console looks like the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将对`vect`向量的元素进行加倍。它在Lambda表达式中使用值捕获，并且使用了`mutable`关键字。正如我们所看到的，我们通过引用传递了向量元素`(int&
    x)`并将其乘以2，然后改变了`a`和`b`的值。然而，由于我们使用了`mutable`关键字，`a`和`b`的最终结果将保持不变，尽管我们已经通过引用传递了向量。控制台上的输出如下截图所示：
- en: '![](img/a1a58756-c71c-4554-afd8-05f6e71dff45.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1a58756-c71c-4554-afd8-05f6e71dff45.png)'
- en: 'If we want to change the value of the `a` and `b` variables, we have to use
    the Lambda expression to capture by reference. We can do this by passing the reference
    to the angle bracket in the Lambda expression, for instance, `[&a, &b]`. For more
    detail, let''s take a look at the following piece of code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要改变`a`和`b`变量的值，我们必须使用Lambda表达式通过引用进行捕获。我们可以通过在Lambda表达式的尖括号中传递引用来实现这一点，例如`[&a,
    &b]`。更多细节，请看以下代码片段：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code has the same behavior with the `lambda_capturing_by_value_mutable.cpp`
    file that will double the element of the `vect` vector. However, by capturing
    by reference, it now also modifies the value of `a` and `b` when they are processed
    in the `for_each` loop. The `a` and `b` values will be changed at the end of the
    code, as we can see in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与`lambda_capturing_by_value_mutable.cpp`文件具有相同的行为，它将对`vect`向量的元素进行加倍。然而，通过引用捕获，它现在在`for_each`循环中处理`a`和`b`的值时也会修改它们。`a`和`b`的值将在代码结束时被改变，正如我们在以下截图中所看到的：
- en: '![](img/7d62a43b-5efe-443e-899c-c80c88f26608.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d62a43b-5efe-443e-899c-c80c88f26608.png)'
- en: Preparing the value using initialization captures
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用初始化捕获准备值
- en: 'Another great feature of the Lambda expression coming up in C++14 is its initialization
    captures. The expression can capture a value of the variable and assign it to
    the expression''s variable. Let''s take a look at the following piece of code
    implementing the initialization captures:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C++14中Lambda表达式的另一个重要特性是其初始化捕获。该表达式可以捕获变量的值并将其赋给表达式的变量。让我们看一下以下实现初始化捕获的代码片段：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we can see in the preceding code, we have an int variable named `a` with
    the value `5`. The Lambda expression, `myLambda`, then captures the `a` value
    and executes it in the code. The result is that now the `a` value will be `7`
    since it is added by `2`. The following output screenshot should appear in our
    console window when we run the preceding code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们有一个名为`a`的int变量，其值为`5`。然后，Lambda表达式`myLambda`捕获了`a`的值并在代码中执行。结果是现在`a`的值将是`7`，因为它被加上了`2`。当我们运行前面的代码时，以下输出截图应该出现在我们的控制台窗口中：
- en: '![](img/66131890-ed47-4d35-93cc-c79b68cbd840.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66131890-ed47-4d35-93cc-c79b68cbd840.png)'
- en: From the preceding snapshot, we see that we can prepare the value to be included
    in the calculation inside the Lambda expression.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的快照中，我们可以看到可以在Lambda表达式中准备要包含在计算中的值。
- en: Writing a generic Lambda expression to be used many times with many different
    data types
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个通用的Lambda表达式，可以多次使用，适用于许多不同的数据类型
- en: 'Before C++14, we have to specifically state the type of the parameter list.
    Fortunately, now in C++14, Lambda expressions accept `auto` as a valid parameter
    type. Therefore, we can now build a generic Lambda expression as demonstrated
    in the following code. In that code, we have only one Lambda expression to find
    out which is the greatest value between two numbers passed to the expression.
    We will use the `auto` keyword in parameter declaration so it can be passed by
    any data type. Therefore, the `findMax()` function parameters can be passed by
    both the `int` and `float` data type. The code should be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++14之前，我们必须明确声明参数列表的类型。幸运的是，现在在C++14中，Lambda表达式接受`auto`作为有效的参数类型。因此，我们现在可以构建一个通用的Lambda表达式，如下面的代码所示。在该代码中，我们只有一个Lambda表达式，用于找出传递给表达式的两个数字中的最大值。我们将在参数声明中使用`auto`关键字，以便可以传递任何数据类型。因此，`findMax()`函数的参数可以传递`int`和`float`数据类型。代码应该如下所示：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output we will see on the console should be as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制台上看到的输出应该如下所示：
- en: '![](img/f2d0eb85-dba1-4aa5-bd8e-445522a4e8a2.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2d0eb85-dba1-4aa5-bd8e-445522a4e8a2.png)'
- en: The C++17 language plans to introduce two new features for the Lambda expression--they
    are capturing `*this`, which allows the expression to capture the enclosing object
    by copy, and the `constexpr` Lambda expressions, which allows us to use the result
    of the Lambda expressions and generate `constexpr` objects at compile time. However,
    since C++17 has not been released yet, we cannot try it for now.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: C++17语言计划为Lambda表达式引入两个新特性--它们是捕获`*this`，允许表达式通过复制捕获封闭对象，以及`constexpr` Lambda表达式，允许我们在编译时使用Lambda表达式的结果并生成`constexpr`对象。然而，由于C++17尚未发布，我们现在无法尝试它。
- en: Avoiding manual memory management with smart pointers
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能指针避免手动内存管理
- en: The smart pointers are highly useful and have an essential knowledge in using
    C++ efficiently. C++11 added many new abilities for the smart pointer we can find
    in the `memory` header file. For a long time, before C++11, we used `auto_ptr`
    as a smart pointer. However, it was quite unsafe since it had incompatible copy
    semantics. It's also deprecated now, and we should not use it anymore. Fortunately,
    C++ has presented `unique_ptr`, which has a similar functionality, but with additional
    features, such as adding `deleters` and support for arrays. Anything we can do
    with `auto_pt`, we can and should do with `unique_ptr` instead. We will discuss
    `unique_ptr` in depth along with other new smart pointers in C++11--`shared_ptr`
    and `weak_ptr`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针在使用C++时非常有用，并且对于高效使用C++来说具有重要的知识。C++11在`memory`头文件中添加了许多智能指针的新功能。在C++11之前的很长一段时间里，我们使用`auto_ptr`作为智能指针。然而，它相当不安全，因为它具有不兼容的复制语义。它现在也已经被弃用，我们不应该再使用它。幸运的是，C++引入了`unique_ptr`，它具有类似的功能，但具有额外的功能，例如添加`deleters`和对数组的支持。我们可以用`unique_ptr`做任何`auto_ptr`能做的事情，而且应该使用`unique_ptr`来代替。我们将深入讨论`unique_ptr`以及C++11中的其他新智能指针--`shared_ptr`和`weak_ptr`。
- en: Replacing a raw pointer using unique_ptr
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用unique_ptr替换原始指针
- en: The next pointer we will see is the `unique_ptr` pointer. It is fast, efficient,
    and a near drop-in replacement for raw or naked pointers. It provides exclusive
    ownership semantics, which exclusively owns the object that it points to. By its
    exclusiveness, it can destroy the object when its destructor is called if it has
    a non-null pointer. It also cannot be copied due to its exclusiveness. It has
    no copy constructor and copy assignment. Although it cannot be copied, it can
    be moved since it provides a move constructor and a move assignment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看到的指针是`unique_ptr`指针。它快速、高效，并且几乎可以直接替换原始指针。它提供独占所有权语义，独占它指向的对象。由于其独占性，如果它具有非空指针，则可以在其析构函数被调用时销毁对象。由于其独占性，它也不能被复制。它没有复制构造函数和复制赋值。尽管它不能被复制，但它可以被移动，因为它提供了移动构造函数和移动赋值。
- en: 'These are the methods we can use to construct `unique_ptr`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可以用来构造`unique_ptr`的方法：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Based on the preceding code, `up1` and `up2` will construct two new `unique_ptr`
    that point to nothing (null), whereas `up3` will point to the address that holds
    the `1234` value. However, C++14 adds a new library function to construct `unique_ptr`,
    that is, `make_unique`. So, we can construct a new `unique_ptr` pointer as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述代码，`up1`和`up2`将构造指向空（null）的两个新的`unique_ptr`，而`up3`将指向保存`1234`值的地址。然而，C++14添加了一个新的库函数来构造`unique_ptr`，即`make_unique`。因此，我们可以按照以下方式构造一个新的`unique_ptr`指针：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `up4` variable will also point to the address that holds the `1234` value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`up4`变量也将指向保存`1234`值的地址。'
- en: 'Now, let''s take a look at the following block of code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下代码块：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We try to construct a new `unique_ptr` pointer that points to the address that
    holds a `BodyMass` data type. In `BodyMass`, we have a constructor as well as
    a destructor. Now, let''s see how the `unique_ptr` pointer works by running the
    preceding code. The output we get on the screen should be like the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试构造一个新的`unique_ptr`指针，该指针指向保存`BodyMass`数据类型的地址。在`BodyMass`中，我们有一个构造函数和一个析构函数。现在，让我们通过运行上述代码来看看`unique_ptr`指针是如何工作的。我们在屏幕上得到的输出应该如下截图所示：
- en: '![](img/1f91c15d-0216-4193-9396-a4d0aba1463d.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f91c15d-0216-4193-9396-a4d0aba1463d.png)'
- en: As we can see in the preceding screenshot, the constructor is invoked when we
    construct `unique_ptr`. Moreover, unlike the traditional C++ language, where we
    have to free the memory up when we use a pointer, in modern C++, the memory will
    be freed up automatically when it is out of scope. We can see that the destructor
    of `BodyMass` is invoked when the program exits, which means `myWeight` is out
    of scope.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中看到的，当我们构造`unique_ptr`时，构造函数被调用。此外，与传统的C++语言不同，我们在使用指针时必须释放内存，而在现代C++中，当超出范围时，内存将自动释放。我们可以看到，当程序退出时，`BodyMass`的析构函数被调用，这意味着`myWeight`已经超出范围。
- en: 'Now, let''s test the exclusiveness of `unique_ptr` by analyzing the following
    code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过分析以下代码片段来测试`unique_ptr`的独占性：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we can see in the preceding code, we see that we can''t assign the `unique_ptr`
    instance to another pointer since it will break the exclusiveness of `unique_ptr`.
    The compiler will throw an error if we make the following expression:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，我们不能将`unique_ptr`实例分配给另一个指针，因为这将破坏`unique_ptr`的独占性。如果我们执行以下表达式，编译器将抛出错误：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, we can assign the value of the `unique_ptr` to another object since
    it has been allocated. To prove it, we have added a copy constructor to log when
    the following expression is executed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以将`unique_ptr`的值分配给另一个对象，因为它已经被分配。为了证明这一点，我们已经添加了一个复制构造函数来记录当执行以下表达式时：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we run the preceding `unique_ptr_2.cpp` code, we will see the following
    output on the screen:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`unique_ptr_2.cpp`代码，我们将在屏幕上看到以下输出：
- en: '![](img/f33ba25b-3a90-47b9-a234-0d796c2c263e.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f33ba25b-3a90-47b9-a234-0d796c2c263e.png)'
- en: As we can see in the preceding screenshot, the copy constructor is called when
    the copy assignment is executed. It proves that we can copy the value of the `unique_ptr`
    object but not the object itself.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中看到的，当执行复制赋值时，复制构造函数被调用。这证明了我们可以复制`unique_ptr`对象的值，但不能复制对象本身。
- en: 'As we discussed earlier, `unique_ptr` has moved the constructor, although it
    has no copy constructor. The use of this construction can be found in the following
    piece of code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，`unique_ptr`已经移动了构造函数，尽管它没有复制构造函数。这种构造的使用可以在以下代码片段中找到：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding code, we have two new functions--`GetBodyMass()` and `UpdateBodyMass()`.
    We construct a new `unique_ptr` object from the `GetBodyMass()` function, then
    we update the value of its *Weight* using the `UpdateBodyMass()` function. We
    can see that we use the `move` function when we pass an argument to the `UpdateBodyMass()`
    function. It''s because `unique_ptr` has no copy constructor, and it has to be
    moved in order to update the value of its property. The screen output of the preceding
    code is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个新函数--`GetBodyMass()`和`UpdateBodyMass()`。我们从`GetBodyMass()`函数构造一个新的`unique_ptr`对象，然后使用`UpdateBodyMass()`函数更新其*Weight*的值。我们可以看到，当我们将参数传递给`UpdateBodyMass()`函数时，我们使用`move`函数。这是因为`unique_ptr`没有复制构造函数，必须移动才能更新其属性的值。前面代码的屏幕输出如下：
- en: '![](img/5188478c-d944-4612-b5cf-2b73c89a204d.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5188478c-d944-4612-b5cf-2b73c89a204d.png)'
- en: Sharing objects using shared_ptr
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用shared_ptr共享对象
- en: 'In contrast to `unique_ptr`, `shared_ptr` implements shared ownership semantics,
    so it offers the ability of copy constructor and copy assignment. Although they
    have a difference in the implementation, `shared_ptr` is actually the counted
    version of `unique_ptr`. We can call the `use_count()` method to find out the
    counter value of the `shared_ptr` reference. Each instance of the `shared_ptr`
    valid object is counted as one. We can copy the `shared_ptr` instance to other
    `shared_ptr` variables and the reference count will be incremented. When a `shared_ptr`
    object is destroyed, the destructor decrements the reference count. The object
    will be deleted only if the count reaches zero. Now let''s examine the following
    `shared_ptr` code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与`unique_ptr`相比，`shared_ptr`实现了共享所有权语义，因此提供了复制构造函数和复制赋值。尽管它们在实现上有所不同，但`shared_ptr`实际上是`unique_ptr`的计数版本。我们可以调用`use_count()`方法来查找`shared_ptr`引用的计数值。每个`shared_ptr`有效对象的实例被计为一个。我们可以将`shared_ptr`实例复制到其他`shared_ptr`变量中，引用计数将增加。当销毁`shared_ptr`对象时，析构函数会减少引用计数。只有当计数达到零时，对象才会被删除。现在让我们来检查以下`shared_ptr`代码：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Before we examine each line of the preceding code, let''s take a look at the
    following output that should appear on the console window:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查前面代码的每一行之前，让我们来看一下应该出现在控制台窗口上的以下输出：
- en: '![](img/88c9cd88-ace1-4cb8-a3bf-bd423b32376a.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88c9cd88-ace1-4cb8-a3bf-bd423b32376a.png)'
- en: First, we create a `shared_ptr` object named `sp1` without instantiating it.
    From the console, we see that `sp1` is not initialized and the counter is still
    `0`. It is also not unique since the pointer is pointed to nothing. We then construct
    `sp1` using the `make_shared` method. Now, `sp1` is initialized and the counter
    becomes `1`. It also becomes unique since it's only one of the `shared_ptr` object
    (proven by the value of the counter that is `1`). Next, we create another variable
    named `sp2`, and copy `sp1` to it. As a result, `sp1` and `sp2` now share the
    same object proven by the counter and the uniqueness value. Then, invoking the
    `reset()` method in `sp2` will destroy the object of `sp2`. Now, the counter of
    `sp1` becomes `1`, and it is unique again.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`sp1`的`shared_ptr`对象，但没有实例化它。从控制台上，我们看到`sp1`没有被初始化，计数器仍然是`0`。它也不是唯一的，因为指针指向了空。然后我们使用`make_shared`方法构造`sp1`。现在，`sp1`被初始化，计数器变为`1`。它也变得唯一，因为它是唯一的`shared_ptr`对象之一（计数器的值为`1`证明了这一点）。接下来，我们创建另一个名为`sp2`的变量，并将`sp1`复制给它。结果，`sp1`和`sp2`现在共享相同的对象，计数器和唯一性值证明了这一点。然后，在`sp2`中调用`reset()`方法将销毁`sp2`的对象。现在，`sp1`的计数器变为`1`，它再次变得唯一。
- en: In the `shared_ptr_1.cpp` code, we declare the `unique_ptr` object using `shared_ptr<int>`,
    then invoke `make_shared<int>` to instance the pointer. It's because we just need
    to analyze the `shared_ptr` behavior. However, we should use `make_shared<>` for
    shared pointers since it has to keep the reference counter somewhere in memory
    and allocates the counter and memory for objects together instead of two separate
    allocations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shared_ptr_1.cpp`代码中，我们使用`shared_ptr<int>`声明`unique_ptr`对象，然后调用`make_shared<int>`来实例化指针。这是因为我们只需要分析`shared_ptr`的行为。然而，我们应该为共享指针使用`make_shared<>`，因为它必须在内存中保留引用计数，并且将对象的计数器和内存一起分配，而不是两个单独的分配。
- en: Tracking the objects using a weak_ptr pointer
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用weak_ptr指针跟踪对象
- en: 'We have discussed the `shared_ptr` in the preceding section. The pointer is
    actually a little bit fat pointer. It logically points to two objects, the object
    being managed and the pointing counter using the `use_count()` method. Every `shared_ptr`
    basically has a strong reference count that prevents the object from being deleted
    and a weak reference count that does not prevent the object being deleted if the
    `shared_ptr` object''s use count reaches 0, although we don''t even use the weak
    reference count. For this reason, we can use only one reference count so we can
    use the `weak_ptr` pointer. The `weak_ptr` pointer refers to an object that is
    managed by `shared_ptr`. The advantage of `weak_ptr` is that it can be used to
    refer to an object, but we can only access it if the object still exists and without
    preventing the object from being deleted by some other reference holder if the
    strong reference count reaches zero. It is useful when we deal with data structures.
    Let''s take a look at the following block of code to analyze the use of `weak_ptr`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分讨论了`shared_ptr`。该指针实际上是一个有点胖的指针。它逻辑上指向两个对象，即被管理的对象和使用`use_count()`方法的指针计数器。每个`shared_ptr`基本上都有一个防止对象被删除的强引用计数和一个不防止对象被删除的弱引用计数，尽管我们甚至没有使用弱引用计数。因此，我们可以只使用一个引用计数，因此我们可以使用`weak_ptr`指针。`weak_ptr`指针指向由`shared_ptr`管理的对象。`weak_ptr`的优势在于，它可以用来引用一个对象，但只有在对象仍然存在且不会阻止其他引用持有者删除对象时才能访问它，如果强引用计数达到零。这在处理数据结构时非常有用。让我们看一下下面的代码块，分析`weak_ptr`的使用：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Before we analyze the preceding code, let''s take a look at the following screenshot
    from the output console if we run the code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析前面的代码之前，让我们看一下如果运行代码，从输出控制台中得到的以下截图：
- en: '![](img/ed5b0412-e22b-4ff3-86b2-2cb32d2480b7.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed5b0412-e22b-4ff3-86b2-2cb32d2480b7.png)'
- en: At first, we instantiate `shared_ptr` and, as we discussed previously, the `weak_ptr`
    points to the object managed by `shared_ptr`. We then assign `wp` to the `shared_ptr`
    variable, `sp`. After we have a `weak_ptr` pointer, we then check its behavior.
    By calling the `expired()` method, we can figure out whether the referenced object
    was already deleted. And, since the `wp` variable is just constructed, it is not
    expired yet. The `weak_ptr` pointer also holds the value of the object counting
    by calling the `use_count()` method, as we used in `shared_ptr`. We then invoke
    the `locked()` method to create a `shared_ptr` that manages the referenced object
    and finds the value `weak_ptr` is pointing at. We now have a `shared_ptr` variable
    pointing to the address that holds the `1234` value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化`shared_ptr`，正如我们之前讨论的，`weak_ptr`指向由`shared_ptr`管理的对象。然后我们将`wp`赋给`shared_ptr`变量`sp`。有了`weak_ptr`指针后，我们可以检查它的行为。通过调用`expired()`方法，我们可以判断引用的对象是否已经被删除。由于`wp`变量刚刚构造，它还没有过期。`weak_ptr`指针还通过调用`use_count()`方法来保存对象计数的值，就像我们在`shared_ptr`中使用的那样。然后我们调用`locked()`方法来创建一个管理引用对象的`shared_ptr`，并找到`weak_ptr`指向的值。现在我们有一个`shared_ptr`变量指向持有`1234`值的地址。
- en: We reset `sp` to `nullptr` afterward. Although we don't touch the `weak_ptr`
    pointer, it is also changed. As we can see from the console screenshot, now `wp`
    is expired since the object has been deleted. The counter also changes and becomes
    `0` since it points to nothing. Moreover, it is unlocked since the `shared_ptr`
    object has been deleted.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`sp`重置为`nullptr`。虽然我们没有触及`weak_ptr`指针，但它也发生了变化。从控制台截图中可以看到，现在`wp`已经过期，因为对象已被删除。计数器也变为`0`，因为它指向了空。此外，它已解锁，因为`shared_ptr`对象已被删除。
- en: Storing many different data types using tuples
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元组存储许多不同的数据类型
- en: 'We will get acquainted with tuples, an object that is able to hold a collection
    of elements, and each element can be of a different type. It is a new feature
    in C++11 and gives power to functional programming. The tuples will be most useful
    when creating a function that returns the value. Moreover, since functions don''t
    change the global state in functional programming, we can return the tuples for
    all the values we need to change instead. Now, let''s examine the following piece
    of code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将熟悉元组，这是一个能够容纳一系列元素的对象，每个元素可以是不同类型的。这是C++11中的一个新特性，为函数式编程赋予了力量。当创建一个返回值的函数时，元组将是最有用的。此外，由于在函数式编程中函数不会改变全局状态，我们可以返回元组以替代所有需要改变的值。现在，让我们来看一下下面的代码片段：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding code, we created two tuples, `t1` and `t2`, with different
    constructing techniques using `tuple<int, string, bool>` and `make_tuple`. However,
    these two different techniques will give the same result. Obviously, in the code,
    we access each element in tuples using `get<x>(y)`, where `x` is the index and
    `y` is the tuple object. And, with confidence, we will get the following result
    on the console:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`tuple<int, string, bool>`和`make_tuple`使用不同的构造技术创建了两个元组`t1`和`t2`。然而，这两种不同的技术将给出相同的结果。显然，在代码中，我们使用`get<x>(y)`访问元组中的每个元素，其中`x`是索引，`y`是元组对象。并且，我们将在控制台上得到以下结果：
- en: '![](img/d1853ef6-56aa-4020-949d-d1e527e4f8ff.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1853ef6-56aa-4020-949d-d1e527e4f8ff.png)'
- en: Unpacking tuples values
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解包元组值
- en: 'Another useful member that functions in the tuples classes is `tie()`, which
    is used to unpack a tuple into individual objects or create a tuple of `lvalue`
    references. Also, we have the `ignore` helper class in tuples, a placeholder to
    skip an element when unpacking a tuple is using `tie()`. Let''s see the use of
    `tie()` and `ignore` in the following block of code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类中的另一个有用成员是 `tie()`，它用于将元组解包为单独的对象或创建 `lvalue` 引用的元组。此外，我们在元组中还有 `ignore`
    辅助类，用于在使用 `tie()` 解包元组时跳过一个元素的占位符。让我们看看下面的代码块中 `tie()` 和 `ignore` 的用法：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding code, we have the same two tuples that `tuples_1.cpp` has.
    We want to unpack `t1` into variables `i`, `s`, and `b` respectively, using the
    `tie()` method. Then, we unpack `t2` to the `s` variable only, ignoring the `int`
    and `bool` data in `t2`. If we run the code, the output should be as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有与 `tuples_1.cpp` 相同的两个元组。我们想要使用 `tie()` 方法将 `t1` 解包为变量 `i`、`s` 和
    `b`。然后，我们只将 `t2` 解包到变量 `s` 中，忽略 `t2` 中的 `int` 和 `bool` 数据。如果我们运行代码，输出应该如下所示：
- en: '![](img/cb5b261a-d591-4942-8062-caadadba0aac.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb5b261a-d591-4942-8062-caadadba0aac.png)'
- en: Returning a tuple value type
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回元组值类型
- en: 'As we discussed earlier, we can maximize the use of tuples in functional programming
    when we want to write a function that returns multiple data. Let''s take a look
    at the following block of code to know how to return the tuple and access the
    return value:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，当我们想要编写一个返回多个数据的函数时，我们可以在函数式编程中最大程度地利用元组。让我们看看下面的代码块，了解如何返回元组并访问返回值：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we can see in the preceding code, we have a new function named `GetData()`
    returning a `Tuple` value. From that function, we will consume the data returning
    from it. We begin with creating the name variable and get the value from the `GetData()`
    function. We can also use the `tie()` method to unpack the tuple coming from the
    `GetData()` function, as we can see in the code when we access the data when ID
    = `2`. The output on the console should be like the following screenshot when
    we run the code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上面的代码中所看到的，我们有一个名为 `GetData()` 的新函数，返回一个 `Tuple` 值。从该函数中，我们将消耗返回的数据。我们首先创建名为
    name 的变量，并从 `GetData()` 函数中获取值。我们还可以使用 `tie()` 方法解包从 `GetData()` 函数返回的元组，正如我们在代码中访问
    ID = `2` 时所看到的。当我们运行代码时，控制台上的输出应该如下截图所示：
- en: '![](img/f46900eb-e1ba-4d02-9f88-af7b6a43b879.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f46900eb-e1ba-4d02-9f88-af7b6a43b879.png)'
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have refreshed our experience in the C++ language by completing this chapter.
    Now we know that C++ is more modern, and it comes with numerous features that
    assist us in creating a better program. We can use the Standard Library to make
    our code efficient since we don't need to write too many redundant functions.
    We can use the Lambda expression to make our code tidy, easy to read, and easy
    to maintain. We can also use the smart pointer so we don't need to worry about
    memory management anymore. Moreover, as we are concerned about immutability in
    functional programming, we will discuss that deeper in the next chapter; the use
    of tuples can help us ensure that no global state is involved in our code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，我们已经刷新了对 C++ 语言的经验。现在我们知道 C++ 更加现代化，它带来了许多功能，帮助我们创建更好的程序。我们可以使用标准库使我们的代码更加高效，因为我们不需要编写太多冗余的函数。我们可以使用
    Lambda 表达式使我们的代码整洁、易读和易于维护。我们还可以使用智能指针，这样我们就不需要再担心内存管理了。此外，由于我们关注函数式编程中的不可变性，我们将在下一章中更深入地讨论这一点；元组的使用可以帮助我们确保我们的代码中不涉及全局状态。
- en: In the next chapter, we will discuss First-Class and Pure Function, which is
    used to purify our class and ensure that no outside state is involved in the current
    function. As a result, it will avoid side effects in our functional code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论头等和纯函数，它用于净化我们的类并确保当前函数中不涉及外部状态。因此，它将避免我们的函数式代码中产生副作用。
