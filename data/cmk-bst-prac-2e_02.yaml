- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Kickstarting CMake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 CMake
- en: If you’re developing software using C++ or C, you have probably heard about
    CMake before. Over the last 20 years, CMake has evolved into something that’s
    an industry standard when it comes to building C++ applications. But CMake is
    more than just a build system – it is a build system generator, which means it
    produces instructions for other build systems such as Makefile, Ninja, Visual
    Studio, QtCreator, Android Studio, and XCode. It does not stop at building software
    – CMake also includes features that support installing, packaging, and testing
    software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 C++ 或 C 开发软件，可能已经听说过 CMake。过去 20 年，CMake 已经发展成为构建 C++ 应用程序的行业标准。但 CMake
    不仅仅是一个构建系统——它是一个构建系统生成器，这意味着它为其他构建系统（如 Makefile、Ninja、Visual Studio、QtCreator、Android
    Studio 和 XCode）生成指令。CMake 不止于构建软件——它还包括支持安装、打包和测试软件的功能。
- en: As a de facto industry standard, CMake is a must-know technology for any C++
    programmer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为事实上的行业标准，CMake 是每个 C++ 程序员必须了解的技术。
- en: In this chapter, you will get a high-level overview of what CMake is and learn
    about the necessary basics to build your first program. We will have a look at
    CMake’s build process and provide an overview of how to use the CMake language
    to configure build processes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为你提供 CMake 的高层次概述，并介绍构建你的第一个程序所需的基础知识。我们将了解 CMake 的构建过程，并概述如何使用 CMake 语言来配置构建过程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: CMake in a nutshell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 简介
- en: Installing CMake
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 CMake
- en: The CMake build process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 构建过程
- en: Writing CMake files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 CMake 文件
- en: Different toolchains and build configurations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的工具链和构建配置
- en: Single-configuration and multi-configuration generators
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单配置和多配置生成器
- en: Let’s begin!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the examples in this chapter, you will need a recent C++ compiler that
    understands C++17\. Although the examples are not complex enough to require the
    functionality of the new standard, the examples have been set up accordingly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章中的示例，你需要一个支持 C++17 的最新 C++ 编译器。尽管这些示例并不复杂到需要新标准的功能，但它们已经相应地设置好了。
- en: 'We recommend using any of the compilers listed here to run the examples:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用这里列出的任何编译器来运行示例：
- en: '**Linux**: GCC 9 or newer, Clang 10 or newer'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux**: GCC 9 或更新版本，Clang 10 或更新版本'
- en: '**Windows**: MSVC 19 or newer or MinGW 9.0.0 or newer'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**: MSVC 19 或更新版本，或 MinGW 9.0.0 或更新版本'
- en: '**macOS**: AppleClang 10 or newer'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**macOS**: AppleClang 10 或更新版本'
- en: The complete samples used in this chapter can be found at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/tree/main/chapter01](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/tree/main/chapter01)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的完整示例可以在 [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/tree/main/chapter01](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/tree/main/chapter01)
    找到
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To try out any examples in this book, we have provided a ready-made Docker container
    that contains all the requirements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试本书中的任何示例，我们提供了一个现成的 Docker 容器，包含所有必要的依赖。
- en: You can find it at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)
    找到它。
- en: CMake in a nutshell
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMake 简介
- en: CMake is open source and available on many platforms. It is also compiler-independent,
    making it a very strong tool when it comes to building and distributing cross-platform
    software. All these features make it a valuable tool for building software in
    a modern way – that is, by relying heavily on build automation and built-in quality
    gates.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 是开源的，且可在多个平台上使用。它也是与编译器无关的，这使得它在构建和分发跨平台软件时非常强大。所有这些功能使它成为以现代方式构建软件的宝贵工具——即通过依赖构建自动化和内置质量门控。
- en: 'CMake consists of three command-line tools:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 包含三个命令行工具：
- en: '`cmake`: CMake itself, which is used to generate build instructions'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake`: CMake 本身，用于生成构建指令'
- en: '`ctest`: CMake’s test utility, which is used to detect and run tests'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctest`: CMake 的测试工具，用于检测和运行测试'
- en: '`cpack`: CMake’s packaging tool, which is used to pack software into convenient
    installers, such as DEB, RPM, and self-extracting installers'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpack`: CMake 的打包工具，用于将软件打包成方便的安装程序，如 DEB、RPM 和自解压安装程序'
- en: 'There are also two interactive tools:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个互动工具：
- en: '`cmake-gui`: A GUI frontend to help with configuring projects'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake-gui`: 一个图形界面前端，帮助配置项目'
- en: '`ccmake`: An interactive terminal UI for configuring CMake'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ccmake`：用于配置CMake的交互式终端UI'
- en: 'The `cmake-gui` tool can be used to conveniently configure a CMake build and
    select the compiler to be used:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake-gui`工具可以方便地配置CMake构建并选择要使用的编译器：'
- en: '![Figure 1.1 – cmake-gui after configuring a project](img/B30947_01_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 配置项目后的cmake-gui界面](img/B30947_01_01.jpg)'
- en: Figure 1.1 – cmake-gui after configuring a project
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 配置项目后的cmake-gui界面
- en: 'If you’re working on the console but still want to have an interactive configuration
    of CMake, then `ccmake` is the right tool. While not as convenient as `cmake-gui`,
    it offers the same functionality. This is especially useful when you must configure
    CMake remotely over an `ssh` shell or similar:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在控制台工作，但仍希望拥有交互式配置CMake的功能，那么`ccmake`是合适的工具。虽然它没有`cmake-gui`那么方便，但提供了相同的功能。当你必须通过`ssh`
    shell或类似方式远程配置CMake时，这尤其有用：
- en: '![Figure 1.2 – Configuring a project using ccmake](img/B30947_01_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 使用ccmake配置项目](img/B30947_01_02.jpg)'
- en: Figure 1.2 – Configuring a project using ccmake
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 使用ccmake配置项目
- en: The advantages of CMake over a regular build system are manyfold. First, there
    is the cross-platform aspect. With CMake, it is much easier to create build instructions
    for a variety of compilers and platforms without the need to know the specifics
    of the respective build system in depth.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CMake相比于常规构建系统有许多优势。首先是跨平台特性。使用CMake，你可以更容易地为各种编译器和平台创建构建指令，而无需深入了解各自构建系统的具体细节。
- en: Then, there is CMake’s ability to discover system libraries and dependencies,
    which lessens the pain of locating the correct libraries for building a piece
    of software considerably. An additional bonus is that CMake integrates nicely
    with package managers such as Conan and vcpkg.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，CMake能够发现系统库和依赖，这大大减少了寻找正确库文件来构建软件的麻烦。额外的好处是，CMake与包管理器如Conan和vcpkg的集成非常顺畅。
- en: It is not just the ability to build software for multiple platforms, but also
    its native support for testing, installing, and packaging software that makes
    CMake a much better candidate for building software than just a single-build system.
    Being able to define everything from building and over-testing to packaging at
    a single point helps tremendously with maintaining projects in the long run.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CMake不仅具备为多个平台构建软件的能力，还原生支持软件的测试、安装和打包，这使得CMake在构建软件时比单一构建系统更具优势。能够在一个统一的地方定义从构建、过度测试到打包的所有内容，对于长期维护项目极为有帮助。
- en: The fact that CMake itself has very few dependencies on the system and can run
    on the command line without user interaction makes it very suitable for build
    system automatization in CI/CD pipelines.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CMake本身对系统的依赖非常少，且可以在命令行上无须用户交互地运行，这使得它非常适合用于CI/CD流水线中的构建系统自动化。
- en: Now that we have briefly covered what CMake can do, let’s learn how to install
    CMake.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要介绍了CMake的功能，接下来让我们学习如何安装CMake。
- en: Installing CMake
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装CMake
- en: CMake is freely available to download from [https://cmake.org/download/](https://cmake.org/download/).
    It is available as either a precompiled binary or as source code. For most use
    cases, the precompiled binary is fully sufficient, but since CMake itself has
    very few dependencies, building a version is also possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CMake可以从[https://cmake.org/download/](https://cmake.org/download/)免费下载。它提供了预编译的二进制文件或源代码。对于大多数使用场景，预编译的二进制文件已经完全足够，但由于CMake本身依赖很少，构建一个版本也是可能的。
- en: Any major Linux distribution offers CMake over its package repositories. Although
    the pre-packaged versions of CMake are not usually the latest releases, these
    installations are often sufficient to use if the system is regularly updated.
    Another convenient way to install CMake is by using `pip`, the Python package
    manager.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何主要的Linux发行版都提供了CMake的安装包。虽然预打包的CMake版本通常不是最新发布版本，但如果系统经常更新，这些安装包通常足以使用。另一种方便的安装方式是使用Python包管理器`pip`。
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The minimum version of CMake to use with the examples in this book is `3.23`.
    We recommend that you download the appropriate version of CMake manually to ensure
    that you get the correct version.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中示例所需使用的最低CMake版本为`3.23`。我们建议你手动下载适当版本的CMake，以确保获得正确的版本。
- en: Building CMake from source
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源代码构建CMake
- en: CMake is written in C++ and uses Make to build itself. Building CMake from scratch
    is possible, but for most use cases, using the binary downloads will do just fine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 是用 C++ 编写的，并使用 Make 构建自身。从零开始构建 CMake 是可能的，但对于大多数使用场景，使用二进制下载版本就足够了。
- en: 'After downloading the source package from [https://cmake.org/download/](https://cmake.org/download/),
    extract it to a folder and run the following commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://cmake.org/download/](https://cmake.org/download/) 下载源代码包后，将其解压到一个文件夹，并运行以下命令：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to build `cmake-gui` as well, configure it with the `--qt-gui`
    option. This requires Qt to be installed. Configuring it will take a while, but
    once it’s done, CMake can be installed using the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还想构建 `cmake-gui`，可以使用 `--qt-gui` 选项进行配置。这要求你安装 Qt。配置过程可能会花些时间，但完成后，你可以使用以下命令安装
    CMake：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To test whether the installation was successful, you can execute the following
    command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试安装是否成功，你可以执行以下命令：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will print out the version of CMake, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出 CMake 的版本，类似于这样：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that CMake is installed on your machine, you are ready to build your first
    project. Let’s go!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，CMake 已经安装在你的机器上，你可以开始构建你的第一个项目了。让我们开始吧！
- en: Building your first project
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的第一个项目
- en: 'Now, it’s time to get your hands dirty and see if your installation worked.
    We have provided an example of a simple `hello world` project that you can download
    and build right away. Open a console, type in the following, and you’ll be ready
    to go:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候动手看看你的安装是否成功了。我们提供了一个简单的 `hello world` 项目的示例，你可以立即下载并构建。打开一个控制台，输入以下命令，你就可以开始了：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will result in an executable called `ch_simple_executable` that prints
    out `Welcome to CMake Best Practices` on the console.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为 `ch_simple_executable` 的可执行文件，在控制台上输出 `Welcome to CMake Best Practices`。
- en: 'Let’s have a detailed look at what happened here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看发生了什么：
- en: 'First, the example repository is checked out using Git. The file structure
    of the example CMake project located in the `chapter01/simple_executable` subfolder
    will look like this before the build:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 Git 检出示例仓库。示例 CMake 项目位于 `chapter01/simple_executable` 子文件夹中，构建前的文件结构如下所示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Apart from the folder containing the source code, there is a file called `CMakeLists.txt`.
    This file contains the instructions for CMake on how to create build instructions
    for the project and how to build it. Every CMake project has a `CmakeLists.txt`
    file at the root of the project, but there might be many files with that name
    in various subfolders.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含源代码的文件夹外，还有一个名为 `CMakeLists.txt` 的文件。该文件包含了 CMake 如何为项目创建构建指令及如何构建它的指令。每个
    CMake 项目在项目根目录下都有一个 `CMakeLists.txt` 文件，但在各个子文件夹中可能还有多个同名的文件。
- en: After cloning the repository, the build process is started with `cmake –S .
    -B build`. This tells CMake to use the current directory as a source directory
    and a directory called `build` to place the build artifacts in. We will look a
    bit closer at the concept of source and build folders later in this chapter. CMake’s
    build process is a two-stage process. The first step, which is usually called
    *configuration*, reads the `CMakeLists.txt` file and generates an instruction
    for the native build toolchain of the system. In the second step, these build
    instructions are executed, and the executables or libraries are built.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆完仓库后，构建过程通过 `cmake –S . -B build` 命令启动。这告诉 CMake 使用当前目录作为源目录，并使用名为 `build`
    的目录来存放构建产物。我们将在本章稍后详细讨论源目录和构建目录的概念。CMake 的构建过程是一个两阶段的过程。第一步，通常称为 *配置*，读取 `CMakeLists.txt`
    文件并生成本地构建工具链的指令。第二步，执行这些构建指令，构建出可执行文件或库。
- en: During the configuration step, the build requirements are checked, the dependencies
    are resolved, and the build instructions are generated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置步骤中，检查构建要求，解决依赖关系，并生成构建指令。
- en: Configuring a project also creates a file called `CMakeCache.txt` that contains
    all the information that’s needed to create the build instructions. The next call
    to `cmake --build ./build` executes the build by internally calling CMake; if
    you are on Windows, it does so by invoking the Visual Studio compiler. This is
    the actual step for compiling the binaries. If everything went well, there should
    be an executable named `ch1_simple_executable` in the `build` folder.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置项目时还会创建一个名为 `CMakeCache.txt` 的文件，包含创建构建指令所需的所有信息。接下来执行 `cmake --build ./build`
    命令时，会通过内部调用 CMake 来执行构建；如果你使用的是 Windows，它会通过调用 Visual Studio 编译器来完成。这个步骤就是实际的二进制文件编译过程。如果一切顺利，`build`
    文件夹中应该会有一个名为 `ch1_simple_executable` 的可执行文件。
- en: 'In the preceding example, we specified the source and build folder explicitly
    by passing the `-S` and `-B` command-line option. This is generally the recommended
    way to work with CMake. There is a shorter way to work with CMake using relative
    paths that are also often seen on online tutorials:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们通过传递 `-S` 和 `-B` 命令行选项显式指定了源代码和构建文件夹。这通常是与 CMake 一起工作的推荐方法。还有一种更简短的方法，使用相对路径工作，这种方法在在线教程中也经常见到：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we first created the build folder, then *cd’d* into it and used `cmake`
    with relative paths. By default, CMake will assume that it is started in the folder
    where the binaries and build artifacts are to be created.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建了构建文件夹，然后*cd* 进入该文件夹，并使用带有相对路径的 `cmake`。默认情况下，CMake 会假设它在要创建二进制文件和构建工件的文件夹中启动。
- en: Explicitly passing the build and source directory often comes in handy when
    using CMake in a continuous integration environment since being explicit helps
    with maintainability. It is also helpful if you want to create different build
    directories for different configurations, such as when you’re building cross-platform
    software.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 显式传递构建目录和源目录在使用 CMake 进行持续集成时通常很有用，因为明确指定有助于维护。如果你想为不同的配置创建不同的构建目录（例如在构建跨平台软件时），这也很有帮助。
- en: Now, how does CMake know which files to compile and which binary artifacts to
    create? For this, it uses text files containing the build instructions, commonly
    called `CMakeLists.txt`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，CMake 如何知道编译哪些文件以及创建哪些二进制文件呢？为此，它使用包含构建指令的文本文件，通常称为`CMakeLists.txt`。
- en: A minimal CMakeLists.txt file
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个最小的 CMakeLists.txt 文件
- en: 'For a very simple `hello world` example, the `CMakeLists.txt` file only consists
    of a few lines of instructions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个非常简单的 `hello world` 示例，`CMakeLists.txt` 文件只包含几行指令：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s understand these instructions in a bit more detail:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地理解这些指令：
- en: The first line defines the minimum version of CMake that’s required to build
    this project. Every `CmakeLists.txt` file starts with this directive. This is
    used to warn the user if the project uses features of CMake that are only available
    from a certain version upward. Generally, we recommend setting the version to
    the lowest version that supports the features used in the project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了构建此项目所需的 CMake 最低版本。每个 `CMakeLists.txt` 文件都以此指令开始。该指令用于提醒用户，如果项目使用了仅在某个版本及以上的
    CMake 特性，这时就会显示警告。一般来说，我们建议将版本设置为支持项目中使用特性所需的最低版本。
- en: The next directive is the name, version, and description of the project to be
    built, followed by the programming languages that are used in the project. Here,
    we use `CXX` to mark this as a C++ project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个指令是要构建项目的名称、版本和描述，之后是项目中使用的编程语言。这里，我们使用 `CXX` 来标记这是一个 C++ 项目。
- en: The `add_executable` directive tells CMake that we want to build an executable
    (as opposed to a library or a custom artifact, which we will cover later in this
    book).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_executable` 指令告诉 CMake 我们要构建一个可执行文件（与库或自定义工件不同，后者我们将在本书稍后介绍）。'
- en: The `target_sources` statement tells CMake where to look for the sources for
    the executable called `ch1_simple_executable` and that the visibility of the sources
    is limited to the executable. We will go into the specifics of the single commands
    later in this book.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_sources` 语句告诉 CMake 在哪里查找名为 `ch1_simple_executable` 的可执行文件的源代码，并且源代码的可见性仅限于该可执行文件。我们将在本书稍后部分详细介绍单个命令的具体内容。'
- en: Congratulations – you are now able to create software programs with CMake. But
    to understand what is going on behind the commands, let’s look at the CMake build
    process in detail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——你现在可以使用 CMake 创建软件程序了。但是，要了解命令背后发生了什么，我们接下来将详细了解 CMake 构建过程。
- en: Understanding the CMake build process
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 CMake 构建过程
- en: 'CMake’s build process works in two steps, as shown in the following diagram.
    First, if it’s invoked without any special flags, CMake scans the system for any
    usable toolchains during the configuration process and then decides what its output
    should be. The second step, which is when `cmake --build` is invoked, is the actual
    compilation and building process:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 的构建过程分为两个步骤，如下图所示。首先，如果没有使用任何特殊标志调用，CMake 会在配置过程中扫描系统，查找可用的工具链，然后决定输出结果应该是什么。第二步是在调用
    `cmake --build` 时，实际的编译和构建过程。
- en: '![Figure 1.3 – CMake’s two-stage build process](img/B30947_01_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – CMake 的两阶段构建过程](img/B30947_01_03.jpg)'
- en: Figure 1.3 – CMake’s two-stage build process
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – CMake 的两阶段构建过程
- en: The standard output is Unix Makefiles unless the only detected compiler is Microsoft
    Visual Studio, in which case a Visual Studio solution (`.sln`) will be created.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输出是 Unix Makefiles，除非唯一检测到的编译器是 Microsoft Visual Studio，在这种情况下将创建一个 Visual
    Studio 解决方案（`.sln`）。
- en: 'To change the generator, you can pass the `-G` option to CMake, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改生成器，可以将 `-G` 选项传递给 CMake，像这样：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will generate files to be used with Ninja ([https://ninja-build.org/](https://ninja-build.org/)),
    an alternative build generator. Many generators are available for CMake. A list
    of the ones that are supported natively can be found on CMake’s website: [https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成供 Ninja 使用的文件（[https://ninja-build.org/](https://ninja-build.org/)），Ninja
    是一种替代的构建生成器。CMake 有许多可用的生成器。可以在 CMake 的官方网站上找到支持的生成器列表：[https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html)。
- en: There are two main types of generators – the ones where there are many Makefile
    flavors and Ninja generators, which are generally used from the command line,
    and the ones that create build files for an IDE such as Visual Studio or Xcode.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器主要分为两类——一种是有多种 Makefile 版本和 Ninja 生成器，通常从命令行使用，另一种是为 Visual Studio 或 Xcode
    等 IDE 创建构建文件。
- en: 'CMake differentiates between *single-configuration generators* and *multi-configuration
    generators*. When using single-configuration generators, the build files have
    to be rewritten each time the configuration is changed; multi-configuration build
    systems can manage different configurations without the need to regenerate. Although
    the examples in this book use single-configuration generators, they would also
    work on multi-configuration generators. For most of the examples, the chosen generator
    is irrelevant; otherwise, it will be mentioned:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 区分 *单配置生成器* 和 *多配置生成器*。使用单配置生成器时，每次更改配置时必须重写构建文件；而多配置构建系统可以在不需要重新生成的情况下管理不同的配置。尽管本书中的示例使用单配置生成器，但它们也适用于多配置生成器。对于大多数示例，选择的生成器无关紧要；如果有区别，会特别提到：
- en: '| **Generator** | **Multi-Configuration** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **生成器** | **多配置** |'
- en: '| Makefiles (all flavors) | No |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| Makefiles（所有版本） | 否 |'
- en: '| Ninja | No |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| Ninja | 否 |'
- en: '| Ninja-Multi | Yes |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Ninja-Multi | 是 |'
- en: '| Xcode | Yes |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| Xcode | 是 |'
- en: '| Visual Studio | Yes |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Visual Studio | 是 |'
- en: In addition, there are extra generators that use a normal generator but also
    produce project information for an editor or IDE, such as Sublime Text 2, Kate
    Editor, CodeBlocks, or Eclipse. For each, you can select whether the editor should
    use Make or Ninja to internally build the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些额外的生成器，它们使用普通的生成器，但还会为编辑器或 IDE 生成项目信息，例如 Sublime Text 2、Kate 编辑器、CodeBlocks
    或 Eclipse。对于每个生成器，你可以选择编辑器是否应该使用 Make 或 Ninja 来内部构建应用程序。
- en: After the call, CMake will create a lot of files in the `build` folder, with
    the most notable being the `CMakeCache.txt` file. This is where all the detected
    configurations are stored. The main benefit of caching the configuration is that
    subsequent runs of CMake run faster. Note that when you’re using `cmake-gui`,
    the first step is split into configuring the project and generating the build
    file. However, when it’s run from the command line, the steps are merged into
    one. Once configured, all the build commands are executed from the `build` folder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 调用后，CMake 会在 `build` 文件夹中创建许多文件，其中最显著的是 `CMakeCache.txt` 文件。这里存储了所有检测到的配置。缓存配置的主要好处是，后续的
    CMake 运行速度更快。请注意，当使用 `cmake-gui` 时，第一步被拆分为配置项目和生成构建文件。然而，当从命令行运行时，这些步骤合并为一个。一旦配置完成，所有构建命令都会从
    `build` 文件夹执行。
- en: Source folders and build folders
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源文件夹和构建文件夹
- en: In CMake, two logical folders exist. One is the `source` folder, which contains
    a hierarchical set of projects, while the other is a `build` folder, which contains
    the build instructions, cache, and all the generated binaries and artifacts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMake 中，存在两个逻辑文件夹。一是 `source` 文件夹，包含一个分层的项目集合；另一个是 `build` 文件夹，包含构建指令、缓存以及所有生成的二进制文件和产物。
- en: The root of the `source` folder is wherever the top `CMakeLists.txt` file is
    located. The `build` folder can be placed inside the `source` folder, but some
    people prefer to have it in another location. Both are fine; note that for the
    examples in this book, we decided to keep the `build` folder inside the `source`
    folder. The `build` folder is often called just `build`, but it can take any name,
    including prefixes and suffixes for different platforms. When using a `build`
    folder inside the source tree, it is a good idea to add it to `.gitignore` so
    that it does not get checked in accidentally.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 文件夹的根目录是顶级 `CMakeLists.txt` 文件所在的位置。`build` 文件夹可以放在 `source` 文件夹内，但有些人喜欢将其放在其他位置。两者都可以，值得注意的是，本书中的示例决定将
    `build` 文件夹放在 `source` 文件夹内。`build` 文件夹通常仅称为 `build`，但它可以有任何名称，包括针对不同平台的前后缀。在源代码树中使用
    `build` 文件夹时，建议将其添加到 `.gitignore` 中，以避免意外提交。'
- en: When configuring a CMake project, the project and folder structure of the `source`
    folder are recreated inside the `build` folder so that all the build artifacts
    are in the same position. In each mapped folder, there is a subfolder called `CMakeFiles`
    that contains all the information that’s generated by CMake’s configuration step.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 CMake 项目时，`source` 文件夹的项目和文件夹结构会在 `build` 文件夹中重新创建，从而使所有构建产物都位于相同的位置。在每个映射的文件夹中，会有一个名为
    `CMakeFiles` 的子文件夹，其中包含 CMake 配置步骤生成的所有信息。
- en: 'The following code shows an example structure for a CMake project:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一个 CMake 项目的示例结构：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you execute the CMake configuration, the file structure of the CMake project
    is mapped into the `build` folder. Each folder containing a `CMakeLists.txt` file
    will be mapped, and a subfolder called `CMakeFiles` will be created, which contains
    the internal information that’s used by CMake for building:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 CMake 配置时，CMake 项目的文件结构会映射到 `build` 文件夹中。每个包含 `CMakeLists.txt` 文件的文件夹都会被映射，并会创建一个名为
    `CMakeFiles` 的子文件夹，其中包含 CMake 用于构建的内部信息：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When it comes to handling build folders and build configurations, an important
    distinction is between single-configuration generators and multi-configuration
    generators.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理构建文件夹和构建配置时，一个重要的区分是单配置生成器与多配置生成器之间的区别。
- en: Single-configuration and multi-configuration generators
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单配置生成器和多配置生成器
- en: In CMake, generators are responsible for creating native build systems (e.g.,
    Makefiles, Visual Studio solutions) based on the platform for which a project
    is built and often also on the developer’s preferences. The two main types of
    generators in CMake are single-configuration and multi-configuration generators.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMake 中，生成器负责根据项目构建的平台以及开发者的偏好，创建本地构建系统（例如 Makefile、Visual Studio 解决方案）。CMake
    中的两种主要生成器类型是单配置生成器和多配置生成器。
- en: The main difference is that single-configuration generators generate build-system
    information, where each build configuration, such as debug or release, corresponds
    to a single build directory. There will be more details about the different build
    types later in the chapter. If the build configuration is switched (e.g. from
    a debug to a release build), the user either has to choose a different build directory
    or the previous information will be overwritten.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于单配置生成器生成构建系统信息，其中每个构建配置（例如调试或发布）对应一个单独的构建目录。关于不同构建类型的更多细节将在本章后面介绍。如果切换构建配置（例如从调试构建切换到发布构建），用户必须选择一个不同的构建目录，否则之前的信息将被覆盖。
- en: For multi-configuration generators, one build directory can contain multiple
    configurations, and which one to choose is only passed on the build step.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多配置生成器，一个构建目录可以包含多个配置，选择哪个配置仅在构建步骤中指定。
- en: Whether to choose a single- or multi-configuration generator often boils down
    to personal preference or the convenient availability of the tools for a certain
    operating system. As a rule of thumb, one can say that single-configuration generators
    are slightly easier to use from the command line and in CI environments, where
    multi-configuration generators might have better integration into IDEs. So far,
    we have used the existing `CMakeLists.txt` to learn about the CMake build process.
    We learned about the configuration and the build step, as well as generators,
    and that we need `CMakeLists.txt` files to pass the necessary information to CMake.
    So, let’s go a step further and see what the `CMakeLists.txt` files look like
    and how the CMake language works.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 是否选择单配置生成器或多配置生成器，通常取决于个人偏好或某个操作系统中工具的便捷性。作为一个经验法则，可以说单配置生成器在命令行和CI环境中稍微更容易使用，而多配置生成器可能在IDE中有更好的集成。目前，我们已经使用现有的`CMakeLists.txt`来了解CMake的构建过程。我们学习了配置和构建步骤，以及生成器，并了解到我们需要`CMakeLists.txt`文件将必要的信息传递给CMake。那么，接下来让我们更进一步，看看`CMakeLists.txt`文件的样子以及CMake语言是如何工作的。
- en: Writing CMake files
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写CMake文件
- en: When you’re writing CMake files, there are a few core concepts and language
    features that you need to know about. We won’t cover every detail of the language
    here as CMake’s documentation does a pretty good job at this – especially when
    it comes to being comprehensive. In the following sections, we will provide an
    overview of the core concepts and language features. Further chapters will dive
    into the details of different aspects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写CMake文件时，有一些核心概念和语言特性是你需要了解的。我们在这里不会涵盖语言的每个细节，因为CMake的文档已经做得相当不错，尤其是在全面性方面。接下来的章节将提供核心概念和语言特性的概述，后续章节会深入探讨不同方面的细节。
- en: The full documentation for the language can be found at [https://cmake.org/cmake/help/latest/manual/cmake-language.7.html](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的完整文档可以在[https://cmake.org/cmake/help/latest/manual/cmake-language.7.html](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html)找到。
- en: The CMake language – a 10,000-foot overview
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMake语言 – 一个10000英尺的概览
- en: CMake uses configuration files called `CMakeLists.txt` files to determine build
    specifications. These files are written in a scripting language, often called
    CMake as well. The language itself is simple and supports variables, string functions,
    macros, function definitions, and importing other CMake files.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CMake使用名为`CMakeLists.txt`的配置文件来确定构建规范。这些文件是用一种脚本语言编写的，通常也叫做CMake。该语言本身简单，支持变量、字符串函数、宏、函数定义和导入其他CMake文件。
- en: Apart from lists, there is no support for data structures such as structs or
    classes. But it is this relative simplicity that makes the CMake project inherently
    maintainable if done properly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列表外，没有对结构体或类等数据结构的支持。但正是这种相对简单性，使得CMake项目在正确执行时本质上更容易维护。
- en: 'The syntax is based on keywords and whitespace-separated arguments. For example,
    the following command tells CMake which files are to be added to a library:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 语法基于关键字和空格分隔的参数。例如，以下命令告诉CMake哪些文件需要添加到库中：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `PUBLIC` and `PRIVATE` keywords denote the visibility of the files when
    they’re linked against this library and serve as delimiters between the lists
    of files.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUBLIC`和`PRIVATE`关键字表示文件在与此库链接时的可见性，并且充当文件列表之间的分隔符。'
- en: Additionally, the CMake language supports so-called “generator expressions,”
    which are evaluated during build system generation. These are commonly used to
    specify special information for each build configuration that is generated during
    the configuration phase of the project. They will be covered later in this chapter,
    in the *Generator* *expressions* section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CMake语言还支持所谓的“生成器表达式”，这些表达式在构建系统生成时进行评估。它们通常用于在项目的配置阶段，为每个生成的构建配置指定特定信息。它们将在本章后面的*生成器*
    *表达式*部分进行详细介绍。
- en: Projects
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目
- en: CMake organizes the various build artifacts, such as libraries, executables,
    tests, and documentation, into projects. There is always exactly one root project,
    although the projects can be encapsulated into each other. As a rule, there should
    only be one project per `CMakeLists.txt` file, which means that each project has
    to have a separate folder in the source directory.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 将各种构建产物（如库、可执行文件、测试和文档）组织成项目。总是有一个根项目，尽管这些项目可以彼此封装。原则上，每个 `CMakeLists.txt`
    文件中应该只有一个项目，这意味着每个项目必须在源目录中有一个单独的文件夹。
- en: 'Projects are described like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 项目描述如下：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The current project that’s being parsed is stored in the `PROJECT_NAME` variable.
    For the root project, this is also stored in `CMAKE_PROJECT_NAME`, which is useful
    for determining whether a project is standalone or encapsulated in another. Since
    version `3.21`, there’s also a `PROJECT_IS_TOP_LEVEL` variable to directly determine
    whether the current project is a top-level project. Additionally, with `<PROJECT-NAME>_IS_TOP_LEVEL`,
    you can detect whether a specific project is a top-level project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当前正在解析的项目存储在 `PROJECT_NAME` 变量中。对于根项目，这个信息也存储在 `CMAKE_PROJECT_NAME` 变量中，这对于判断一个项目是独立的还是被封装在另一个项目中非常有用。自版本
    `3.21` 起，还引入了 `PROJECT_IS_TOP_LEVEL` 变量，用于直接判断当前项目是否为顶级项目。此外，使用 `<PROJECT-NAME>_IS_TOP_LEVEL`，可以检测某个特定项目是否为顶级项目。
- en: 'The following are some additional variables regarding the projects. All of
    them can be prefixed with `CMAKE_` for the root project. If they’re not defined
    in the `project()` directive, the strings are empty:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些与项目相关的附加变量。对于根项目，所有这些变量都可以以 `CMAKE_` 为前缀。如果在 `project()` 指令中没有定义它们，则这些字符串为空：
- en: '`PROJECT_DESCRIPTION`: The description string of the project'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_DESCRIPTION`：项目的描述字符串'
- en: '`PROJECT_HOMEPAGE_URL`: The URL string for the project'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_HOMEPAGE_URL`：项目的 URL 字符串'
- en: '`PROJECT_VERSION`: The full version that’s given to the project'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION`：赋予项目的完整版本号'
- en: '`PROJECT_VERSION_MAJOR`: The first number of the version string'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION_MAJOR`：版本字符串中的第一个数字'
- en: '`PROJECT_VERSION_MINOR`: The second number of the version string'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION_MINOR`：版本字符串中的第二个数字'
- en: '`PROJECT_VERSION_PATCH`: The third number of the version string'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION_PATCH`：版本字符串中的第三个数字'
- en: '`PROJECT_VERSION_TWEAK`: The fourth number of the version string'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION_TWEAK`：版本字符串中的第四个数字'
- en: 'Each project has a source and binary directory, and they may be encapsulated
    in each other. Let’s assume that each of the `CMakeFiles.txt` files in the following
    example defines a project:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有一个源目录和一个二进制目录，它们可能会彼此封装。假设以下示例中的每个 `CMakeFiles.txt` 文件都定义了一个项目：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When parsing the `CMakeLists.txt` file in the root folder, `PROJECT_NAME` and
    `CMAKE_PROJECT_NAME` will both be `CMakeBestPractices`. When you’re parsing `chapter_1/CMakeLists.txt`,
    the `PROJECT_NAME` variable will change to `"Chapter_1"` but `CMAKE_PROJECT_NAME`
    will stay as `CMakeBestPractices`, as set in the file in the root folder.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析根文件夹中的 `CMakeLists.txt` 文件时，`PROJECT_NAME` 和 `CMAKE_PROJECT_NAME` 都将是 `CMakeBestPractices`。当你解析
    `chapter_1/CMakeLists.txt` 时，`PROJECT_NAME` 变量将更改为 `"Chapter_1"`，但 `CMAKE_PROJECT_NAME`
    仍然保持为 `CMakeBestPractices`，这是根文件夹中的设置。
- en: Although projects can be nested, it is good practice to write them in a way
    that they can work standalone. While they may depend on other projects that are
    lower in the file hierarchy, there should be no need for a project to live as
    a child of another. It is possible to put multiple calls to `project()` in the
    same `CMakeLists.txt` file, but we discourage this practice as it tends to make
    projects confusing and hard to maintain. In general, it is better to create a
    `CmakeLists.txt` file for each project and organize the structure with subfolders.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管项目可以嵌套，但最好以独立的方式编写它们，使其能够单独工作。虽然它们可能依赖于文件层次结构中较低的其他项目，但不应将某个项目作为另一个项目的子项目。可以在同一个
    `CMakeLists.txt` 文件中多次调用 `project()`，但我们不推荐这种做法，因为它往往会使项目变得混乱，难以维护。通常，更好的做法是为每个项目创建一个单独的
    `CMakeLists.txt` 文件，并通过子文件夹组织结构。
- en: This book’s GitHub repository, which contains the examples in this book, is
    organized in a hierarchical way, where each chapter is a separate project that
    may contain even more projects for different sections and examples.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的 GitHub 仓库，包含了本书中的示例，采用层次化的方式组织，其中每个章节都是一个独立的项目，可能包含更多的项目来处理不同的部分和示例。
- en: While each example can be built on its own, you can also build this whole book
    from the root of the repository.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个示例都可以单独构建，但你也可以从仓库的根目录构建整个书籍项目。
- en: Variables
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'Variables are a core part of the CMake language. Variables can be set using
    the `set` command and deleted using `unset`. Variable names are case-sensitive.
    The following example shows how to set a variable named `MYVAR` and assign a value
    of `1234` to it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是 CMake 语言的核心部分。可以使用`set`命令设置变量，使用`unset`命令删除变量。变量名是区分大小写的。下面的示例展示了如何设置一个名为`MYVAR`的变量并将值`1234`赋给它：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To delete the `MYVAR` variable, we can use `unset`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除`MYVAR`变量，可以使用`unset`：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The general code convention is to write variables in all caps. Internally, variables
    are always represented as strings.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的代码约定是将变量写成全大写字母。内部变量始终表示为字符串。
- en: 'You can access the value of a variable with the `$` sign and curly brackets:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`$`符号和花括号访问变量的值：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Variable references can even be nested and are evaluated inside out:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 变量引用甚至可以嵌套，并按内外顺序进行评估：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Variables might be scoped in the following way:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可能具有以下作用域：
- en: '**Function scope**: Variables that are set inside a function are only visible
    inside the function.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数作用域**：在函数内部设置的变量仅在该函数内可见。'
- en: '**Directory scope**: Each of the subdirectories in a source tree binds variables
    and includes any variable bindings from the parent directory.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录作用域**：源树中的每个子目录都会绑定变量，并包括父目录中的任何变量绑定。'
- en: '**Persistent cache**: Cached variables can be either system- or user-defined.
    These persist their values over multiple runs.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久缓存**：缓存变量可以是系统定义的或用户定义的。这些变量会在多次运行中保持其值。'
- en: Passing the `PARENT_SCOPE` option to `set()` makes the variable visible in the
    parent scope.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将`PARENT_SCOPE`选项传递给`set()`会使变量在父作用域中可见。
- en: CMake comes with a wide variety of predefined variables. These are prefixed
    with `CMAKE_`. A full list is available at [https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了多种预定义变量。这些变量以`CMAKE_`为前缀。完整列表可在[https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html)查看。
- en: Lists
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表
- en: 'Even though CMake stores variables as strings internally, it is possible to
    work with lists in CMake by splitting values with a semicolon. Lists can be created
    by either passing multiple *unquoted* variables to `set()` or directly as a semicolon-separated
    string:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CMake 内部将变量存储为字符串，但可以通过用分号分隔值来处理 CMake 中的列表。列表可以通过将多个*未加引号*的变量传递给`set()`，或者直接传递一个分号分隔的字符串来创建：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Manipulating lists by modifying their contents, reordering, or finding things
    can be done using the `list` command. The following code will query `MYLIST` for
    the index of the `abc` value and then retrieve the value and store it in the variable
    called `ABC`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`list`命令来操作列表，修改其内容、重新排序或查找项。以下代码将查询`MYLIST`中`abc`值的索引，并检索该值并将其存储在名为`ABC`的变量中：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To append a value to a list, we can use the `APPEND` keyword. Here, the `xyz`
    value is appended to `MYLIST`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要向列表中添加一个值，可以使用`APPEND`关键字。这里，`xyz`值被追加到`MYLIST`中：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Cached variables and options
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存变量和选项
- en: CMake caches some variables so that they run faster in subsequent builds. The
    variables are stored in `CMakeCache.txt` files. Usually, you don’t have to edit
    them manually, but they are great for debugging builds that do not behave as expected.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 会缓存某些变量，以便在随后的构建中运行得更快。这些变量存储在`CMakeCache.txt`文件中。通常，你不需要手动编辑它们，但它们在调试行为异常的构建时非常有用。
- en: 'All the variables that are used to configure the build are cached. To cache
    a custom variable called `ch1_MYVAR` with the `foo` value, you can use the `set`
    command, like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于配置构建的变量都会被缓存。要缓存一个名为`ch1_MYVAR`、值为`foo`的自定义变量，可以使用`set`命令，如下所示：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that cached variables must have a type and a documentation string that
    provides a quick summary of them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，缓存变量必须具有类型和文档字符串，以提供其简要总结。
- en: 'Most of the cached variables that are automatically generated are marked as
    advanced, which means they are hidden from the user in `cmake-gui` and `ccmake`
    by default. To make them visible, they have to be toggled explicitly. If additional
    cache variables are generated by a `CMakeLists.txt` file, they can also be hidden
    by calling the `mark_as_advanced(MYVAR)` command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数自动生成的缓存变量都标记为高级，这意味着它们在`cmake-gui`和`ccmake`中默认是隐藏的。要使它们可见，必须显式切换它们。如果`CMakeLists.txt`文件生成了其他缓存变量，它们也可以通过调用`mark_as_advanced(MYVAR)`命令来隐藏：
- en: '![Figure 1.4 – Left – cmake-gui does not show variables marked as advanced.
    Right – Marking the Advanced checkbox displays all the variables marked as advanced](img/B30947_01_04.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 左侧 – cmake-gui 不显示标记为高级的变量。右侧 – 标记“高级”复选框会显示所有标记为高级的变量](img/B30947_01_04.jpg)'
- en: Figure 1.4 – Left – cmake-gui does not show variables marked as advanced. Right
    – Marking the Advanced checkbox displays all the variables marked as advanced
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 左侧 – cmake-gui 不显示标记为高级的变量。右侧 – 标记“高级”复选框会显示所有标记为高级的变量
- en: As a rule of thumb, any option or variable that the user should not change should
    be marked as advanced. A common case for marking variables as advanced is when
    writing CMake modules or when searching for dependencies, as we will see in [*Chapter
    5*](B30947_05.xhtml#_idTextAnchor084), *Integrating Third-Party Libraries and
    Dependency Management*, and [*Chapter 13*](B30947_13.xhtml#_idTextAnchor198),
    *Reusing* *CMake Code*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一条经验法则是，任何用户不应更改的选项或变量应标记为高级。标记变量为高级的常见情况是在编写 CMake 模块或查找依赖项时，正如我们在[*第 5 章*](B30947_05.xhtml#_idTextAnchor084)《集成第三方库和依赖管理》和[*第
    13 章*](B30947_13.xhtml#_idTextAnchor198)《重用 CMake 代码》中所见。
- en: 'For simple boolean cache variables, CMake also provides the `option` keywordwhich
    has a default value of `OFF` unless specified otherwise. These variables can also
    depend on each other via the `CMakeDependentOption` module:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的布尔缓存变量，CMake 还提供了 `option` 关键字，默认值为 `OFF`，除非另行指定。这些变量也可以通过 `CMakeDependentOption`
    模块相互依赖：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Options are often a convenient way to specify simple project configurations.
    They are cache variables of the `bool` type. If a variable with the same name
    as the option already exists, a call to `option` does nothing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 选项通常是指定简单项目配置的便捷方式。它们是 `bool` 类型的缓存变量。如果已经存在与选项同名的变量，则调用 `option` 不会执行任何操作。
- en: Properties
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: Properties in CMake are values that are attached to a specific object or scope
    of CMake, such as a file, target, directory, or test case. Properties can be set
    or changed by using the `set_property` function. To read the value of a property,
    you can use the `get_property` function, which follows a similar pattern. By default,
    `set_property` overwrites the values that are already stored inside a property.
    Values can be added to the current value by passing `APPEND` or `APPEND_STRING`
    to `set_property`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 中的属性是附加到特定对象或 CMake 范围的值，如文件、目标、目录或测试用例。可以通过使用 `set_property` 函数来设置或更改属性。要读取属性的值，可以使用
    `get_property` 函数，它遵循类似的模式。默认情况下，`set_property` 会覆盖已经存储在属性中的值。可以通过将 `APPEND` 或
    `APPEND_STRING` 传递给 `set_property` 来将值添加到当前值中。
- en: 'The full signature is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的函数签名如下：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The scope specifier may have the following values:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 范围说明符可以具有以下值：
- en: '`GLOBAL`: Global properties that affect the whole build process.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLOBAL`：影响整个构建过程的全局属性。'
- en: '`DIRECTORY <dir>`: Properties that are bound to the current directory or the
    directories specified in `<dir>`. These can also be set directly using the `set_directory_properties`
    command.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DIRECTORY <dir>`：绑定到当前目录或 `<dir>` 中指定目录的属性。也可以通过使用 `set_directory_properties`
    命令直接设置。'
- en: '`TARGET <targets>`: Properties of specific targets. They can also be set using
    the `set_target_properties` function.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET <targets>`：特定目标的属性。也可以通过使用 `set_target_properties` 函数来设置。'
- en: '`SOURCE <files>`: Applies a property to a list of source files. They can also
    be set directly using `set_source_files_properties`. Additionally, there are the
    `SOURCE DIRECTORY` and `SOURCE TARGET_DIRECTORY` extended options:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOURCE <files>`：将一个属性应用于源文件列表。也可以通过使用 `set_source_files_properties` 直接设置。此外，还有
    `SOURCE DIRECTORY` 和 `SOURCE TARGET_DIRECTORY` 扩展选项：'
- en: '`DIRECTORY <dirs>`: This sets the property for the source files in the directory’s
    scope. The directory must already be parsed by CMake by either being the current
    directory or by being added with `add_subdirectory`.'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DIRECTORY <dirs>`：为目录范围内的源文件设置属性。该目录必须已经由 CMake 解析，或者是当前目录，或者是通过 `add_subdirectory`
    添加的。'
- en: '`TARGET_DIRECTORY <targets>`: This sets the property to the directory where
    the specified targets are created. Again, the targets must already exist at the
    point where the property is set.'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_DIRECTORY <targets>`：将属性设置为指定目标所在的目录。同样，目标必须在设置属性时已经存在。'
- en: '`INSTALL <files>`: This sets the properties for installed files. These can
    be used to control the behavior of `cpack`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSTALL <files>`：为已安装的文件设置属性。这些可以用于控制 `cpack` 的行为。'
- en: '`TEST <tests>`: This sets the properties for tests. They can also be set directly
    using `set_test_properties`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEST <tests>`：设置测试的属性。也可以通过`set_test_properties`直接设置。'
- en: '`CACHE <entry>`: This sets the properties for cached variables. The most common
    ones include setting variables as advanced or adding documentation strings to
    them.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CACHE <entry>`：设置缓存变量的属性。最常见的包括将变量设置为高级选项或为其添加文档字符串。'
- en: The full list of supported properties, sorted by their different entities, can
    be found at [https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的属性完整列表，按其不同实体排序，可以在[https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html)找到。
- en: It is good practice to use direct functions such as `set_target_properties`
    and `set_test_properties` when modifying properties instead of the more general
    `set_property` command. Using explicit commands avoids making mistakes and confusion
    between the property names and is generally more readable. There’s also the `define_property`
    function, which creates a property without setting the value. We advise that you
    don’t use this as properties should always have a sane default value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改属性时，使用诸如`set_target_properties`和`set_test_properties`等直接函数比使用更通用的`set_property`命令更好。使用显式命令可以避免错误和属性名称混淆，通常更具可读性。还有`define_property`函数，它创建一个没有设置值的属性。我们建议你不要使用它，因为属性应该始终有一个合理的默认值。
- en: Loops and conditions
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环和条件
- en: Like any programming language, CMake supports conditional and loop blocks. Conditional
    blocks are in between `if()`, `elseif()`, `else()`, and `endif()` statements.
    Conditions are expressed using various keywords.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何编程语言一样，CMake支持条件和循环块。条件块位于`if()`、`elseif()`、`else()`和`endif()`语句之间。条件使用各种关键字表达。
- en: 'Unary keywords are prefixed before the value, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一元关键字位于值之前，如下所示：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The unary keywords to be used in conditions are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用于条件的一元关键字如下：
- en: '`COMMAND`: True if the supplied value is a command'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMAND`：如果提供的值是命令，则为`true`'
- en: '`DEFINED`: True if the value is a defined *variable*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFINED`：如果值是已定义的*变量*，则为`true`'
- en: 'Additionally, there are unary filesystem conditions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一元文件系统条件：
- en: '`EXISTS`: True if the passed file or directory exits'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXISTS`：如果传递的文件或目录存在，则为`true`'
- en: '`IS_DIRECTORY`: Checks whether the supplied path is a directory'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_DIRECTORY`：检查提供的路径是否是一个目录'
- en: '`IS_SYMLINK`: True if the supplied path is a symbolic link'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_SYMLINK`：如果提供的路径是符号链接，则为`true`'
- en: '`IS_ABSOULTE`: Checks whether a supplied path is an absolute path'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_ABSOLUTE`：检查提供的路径是否是绝对路径'
- en: 'Binary tests compare two values and are placed between the values to be compared,
    like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 二元测试比较两个值，并将它们放在需要比较的值之间，如下所示：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The binary operators are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 二元运算符如下：
- en: '`LESS`, `GREATER`, `EQUAL`, `LESS_EQUAL`, and `GREATER_EQUAL`: These compare
    numeric values.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LESS`、`GREATER`、`EQUAL`、`LESS_EQUAL`和`GREATER_EQUAL`：这些比较数值。'
- en: '`STRLESS`, `STREQUAL`, `STRGREATER`, `STRLESS_EQUAL`, and `STRGREATER_EQUAL`:
    These lexicographically compare strings.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STRLESS`、`STREQUAL`、`STRGREATER`、`STRLESS_EQUAL`和`STRGREATER_EQUAL`：这些按字典顺序比较字符串。'
- en: '`VERSION_LESS`, `VERSION_EQUAL`, `VERSION_GREATER`, `VERSION_LESS_EQUAL`, and
    `VERSION_GREATER_EQUAL`: These compare version strings.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VERSION_LESS`、`VERSION_EQUAL`、`VERSION_GREATER`、`VERSION_LESS_EQUAL`和`VERSION_GREATER_EQUAL`：这些比较版本字符串。'
- en: '`MATCHES`: These compare against a regular expression.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MATCHES`：这些与正则表达式进行比较。'
- en: '`IS_NEWER_THAN`: Checks which of the two files that passed has been modified
    recently. Unfortunately, this is not very precise because if both files have the
    same timestamp, it also returns true. There is also more confusion because if
    either of the files is missing, the result is also true.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_NEWER_THAN`：检查传递的两个文件中哪个文件最近被修改。不幸的是，这并不十分精确，因为如果两个文件有相同的时间戳，它也会返回`true`。还有更多的混淆，因为如果任一文件缺失，结果也会是`true`。'
- en: Finally, there are the Boolean `OR`, `AND`, and `NOT` operators.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有布尔运算符`OR`、`AND`和`NOT`。
- en: Loops are either achieved by `while()` and `endwhile()` or `foreach()` and `endforeach()`.
    Loops can be terminated using `break()`; `continue()` aborts the current iteration
    and starts the next one immediately.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 循环可以通过`while()`和`endwhile()`或`foreach()`和`endforeach()`实现。循环可以通过`break()`终止；`continue()`会中止当前的迭代并立即开始下一次迭代。
- en: '`while` loops take the same conditions as an `if` statement. The following
    example loops as long as `MYVAR` is less than `5`. Note that to increase the variable,
    we are using the `math()` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的条件与`if`语句相同。下面的例子在`MYVAR`小于`5`时循环。请注意，为了增加变量值，我们使用了`math()`函数：'
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In addition to `while` loops, CMake also has loops for iterating over lists
    or ranges:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`while`循环，CMake还提供了用于遍历列表或范围的循环：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`for` loops over a specific range can be created by using the `RANGE` keyword:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环可以通过使用`RANGE`关键字在特定范围内创建：'
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Although the `RANGE` version of `foreach()` could work with only a `stop` variable,
    it is good practice to always specify both the start and end values.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`foreach()`的`RANGE`版本只需要一个`stop`变量就能工作，但最好还是始终指定起始和结束值。
- en: Functions
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are defined by `function()`/`endfunction()`. Functions open a new
    scope for variables, so all the variables that are defined inside are not accessible
    from the outside unless the `PARENT_SCOPE` option is passed to `set()`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 函数由`function()`/`endfunction()`定义。函数为变量开启了新的作用域，因此在函数内部定义的所有变量在外部不可访问，除非将`PARENT_SCOPE`选项传递给`set()`。
- en: 'Functions are case-insensitive and are invoked by calling the name of `function`,
    followed by parentheses:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不区分大小写，通过调用`function`的名称并加上圆括号来调用：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Functions are a great way to make parts of your CMake reusable and often come
    in handy when you’re working on larger projects.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是让你的CMake部分可重用的好方法，通常在处理较大项目时非常有用。
- en: Macros
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宏
- en: CMake macros are defined using the `macro()`/`endmacro()` commands. They are
    a bit like functions, with the difference that in functions, the arguments are
    true variables, whereas in macros, they are string replacements. This means that
    all the arguments of a macro must be accessed using curly brackets.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CMake宏通过`macro()`/`endmacro()`命令定义。它们有点像函数，不同之处在于函数中的参数是真正的变量，而宏中的参数是字符串替换。这意味着宏的所有参数必须使用花括号访问。
- en: Another difference is that by calling a function, control is transferred to
    the functions. Macros are executed as if the macro’s body was pasted into the
    calling state’s place. This means that macros do not create scopes regarding variables
    and control flow. Consequently, it is highly recommended to avoid calling `return()`
    in macros as this would stop the scope from executing where the macro is called.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是通过调用函数，控制权会转移到函数中。宏的执行方式像是将宏的主体粘贴到调用位置一样。这意味着宏不会创建与变量和控制流相关的作用域。因此，强烈建议避免在宏中调用`return()`，因为这会阻止宏调用位置的作用域执行。
- en: Targets
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The build system of CMake is organized as a set of logical targets that correspond
    to an executable, library, or custom command or artifact, such as documentation
    or similar.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的构建系统是作为一组逻辑目标组织的，这些目标对应于可执行文件、库或自定义命令或工件，例如文档或类似的内容。
- en: There are three major ways to create a target in CMake – `add_executable`, `add_library`,
    and `add_custom_target`. The first two are used to create executables and static
    or shared libraries, while the third can contain almost any custom command to
    be executed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake中有三种主要方式来创建目标——`add_executable`、`add_library`和`add_custom_target`。前两个用于创建可执行文件和静态或共享库，而第三个则可以包含几乎任何自定义命令来执行。
- en: Targets can be made dependent on each other so that one target has to be built
    before another.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目标可以相互依赖，以确保一个目标在另一个目标之前构建。
- en: It is good practice to work with targets instead of global variables when you’re
    setting properties for build configurations or compiler options. Some of the target
    properties have visibility modifiers such as `PRIVATE`, `PUBLIC`, or `INTERFACE`
    to denote which requirements are transitive – that is, which properties have to
    be “inherited” by a dependent target.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置构建配置或编译器选项的属性时，最好使用目标而不是全局变量。一些目标属性有可见性修饰符，如`PRIVATE`、`PUBLIC`或`INTERFACE`，用以表示哪些要求是传递性的——也就是说，哪些属性必须被依赖的目标“继承”。
- en: Generator expressions
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: Generator expressions are small statements evaluated during the build’s configuration
    phase. Most functions allow generator expressions to be used, with a few exceptions.
    They take the form of `$<OPERATOR:VALUE>`, where `OPERATOR` is applied or compared
    to `VALUE`. You can think of generator expressions as small inline `if-statements`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式是构建配置阶段评估的小语句。大多数函数允许使用生成器表达式，但也有少数例外。生成器表达式的形式为`$<OPERATOR:VALUE>`，其中`OPERATOR`应用或比较`VALUE`。你可以将生成器表达式看作是小型的内联`if`语句。
- en: 'In the following example, a generator expression is being used to set different
    compile definitions for `my_target` depending on whether the build configuration
    is debug or release:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，使用生成器表达式根据构建配置是调试还是发布，设置`my_target`的不同编译定义：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This example tells CMake to evaluate the `CONFIG` variable to either `Debug`
    or `Release` and if it matches either, define either `MY_DEBUG_FLAG` or `MY_RELEASE_FLAG`
    for the `my_target` target. Generator expressions come in very handy for writing
    platform- and compiler-independent CMake files. In addition to querying values,
    generator expressions can be used to transform strings and lists:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例告诉CMake评估`CONFIG`变量，值可以是`Debug`或`Release`，如果匹配其中一个，则为`my_target`目标定义`MY_DEBUG_FLAG`或`MY_RELEASE_FLAG`。生成器表达式在编写平台和编译器独立的CMake文件时非常有用。除了查询值之外，生成器表达式还可以用来转换字符串和列表：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will output `cmake`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出`cmake`。
- en: You can learn more about generator expressions at [https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html)了解更多关于生成器表达式的信息。
- en: Most CMake commands can handle generator expressions, but there are a few notable
    exceptions such as the `file()` command for file operations and the `execute_process()`
    command to call third-party programs during the configuration step.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数CMake命令都能处理生成器表达式，但有一些显著的例外，如用于文件操作的`file()`命令和在配置步骤中调用第三方程序的`execute_process()`命令。
- en: Another thing to keep an eye out for is which generator expressions are available
    at which stage of the configuration or generation step. For multi-configuration
    generators, for instance, the `$<CONFIG:...>` might not be set during the configuration
    step as the build configuration is usually only passed during the build step.
    In the next section, we will learn how CMake can be told which toolchain to use
    and how to configure the different build types, such as debug or release.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事项是，在配置或生成步骤的哪个阶段可以使用哪些生成器表达式。例如，对于多配置生成器，`$<CONFIG:...>`在配置步骤期间可能未设置，因为构建配置通常只在构建步骤期间传递。在下一节中，我们将学习如何告诉CMake使用哪个工具链，以及如何配置不同的构建类型，如调试或发布。
- en: CMake policies
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMake策略
- en: For the top-level `CMakeLists.txt` file, `cmake_minimum_required` must be called
    before any call to the project as it also sets which internal policies for CMake
    are used to build the project.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于顶层的`CMakeLists.txt`文件，`cmake_minimum_required`必须在任何项目调用之前调用，因为它还设置了用于构建项目的CMake内部策略。
- en: Policies are used to maintain backward compatibility across multiple CMake releases.
    They can be configured to use the `OLD` behavior, which means that `cmake` behaves
    backward compatible, or as `NEW`, which means the new policy is in effect. As
    each new version will introduce new rules and features, policies will be used
    to warn you of backward compatibility issues. Policies can be disabled or enabled
    using the `cmake_policy` call.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 策略用于在多个CMake版本之间保持向后兼容性。它们可以配置为使用`OLD`行为，这意味着`cmake`表现出向后兼容性，或者使用`NEW`，这意味着新策略生效。由于每个新版本都会引入新规则和新特性，策略将用于警告你可能存在的向后兼容性问题。策略可以通过`cmake_policy`调用进行禁用或启用。
- en: 'In the following example, the `CMP0121` policy has been set to a backward-compatible
    value. `CMP0121` was introduced in CMake version 3.21 and checks whether index
    variables for the `list()` commands are in a valid format – that is, whether they
    are integers:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`CMP0121`策略已设置为向后兼容的值。`CMP0121`是在CMake 3.21版本中引入的，它检查`list()`命令的索引变量是否符合有效格式——即它们是否为整数：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By setting `cmake_policy(SET CMP0121 OLD)`, backward compatibility is enabled
    and the preceding code will not produce a warning, despite the access to `MYLIST`
    with the `"any"` index, which is not an integer.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`cmake_policy(SET CMP0121 OLD)`，启用了向后兼容性，尽管前面的代码访问了`MYLIST`的`"any"`索引（不是整数），但不会产生警告。
- en: 'Setting the policy to `NEW` will throw an error – `[build] list index: any
    is not a valid index` – during the configuration step of CMake.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '将策略设置为`NEW`将在CMake配置步骤中抛出一个错误——`[build] list index: any is not a valid index`。'
- en: Avoid setting single policies except when you’re including legacy projects
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在包含遗留项目，否则避免设置单一策略。
- en: Generally, policies should be controlled by setting the `cmake_minimum_required`
    command and not by changing individual policies. The most common use case for
    changing single policies is when you’re including legacy projects as subfolders.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应该通过设置 `cmake_minimum_required` 命令来控制策略，而不是通过更改单个策略。更改单个策略的最常见使用场景是将遗留项目作为子文件夹包含时。
- en: So far, we have covered the basic concepts behind the CMake language, which
    is used to configure build systems. CMake is used to generate build instructions
    for different kinds of builds and languages. In the next section, we will learn
    how to specify the compiler to use and how builds can be configured.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了 CMake 语言背后的基本概念，它用于配置构建系统。CMake 用于为不同类型的构建和语言生成构建指令。在下一节中，我们将学习如何指定要使用的编译器，以及如何配置构建。
- en: Different toolchains and build types
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的工具链和构建类型
- en: The power of CMake comes from the fact that you can use the same build specification
    – that is, `CMakeLists.``txt` – for various compiler toolchains without the need
    to rewrite anything. A toolchain typically consists of a series of programs that
    can compile and link binaries, as well as create archives and similar.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 的强大之处在于，你可以使用相同的构建规范——即 `CMakeLists.txt`——来适配不同的编译器工具链，而无需重写任何内容。一个工具链通常由一系列程序组成，能够编译和链接二进制文件，创建归档文件等。
- en: 'CMake supports a variety of languages that the toolchains can be configured
    for. In this book, we will focus on C++. Configuring the toolchain for different
    programming languages is done by replacing the `CXX` part of the following variables
    with the respective language tag:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 支持多种语言，可以为其配置工具链。本书将重点讲解 C++。为不同编程语言配置工具链的方法是，将以下变量中的 `CXX` 部分替换为相应的语言标签：
- en: C
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: CXX – C++
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CXX – C++
- en: CUDA
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUDA
- en: OBJC – Objective C
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OBJC – Objective C
- en: OBJCXX – Objective C++
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OBJCXX – Objective C++
- en: Fortran
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fortran
- en: HIP – HIP C++ runtime API for NVIDIA and AMD GPUs
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HIP – NVIDIA 和 AMD GPU 的 HIP C++ 运行时 API
- en: ISPC – C-Based SPMD programming language
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISPC – 基于 C 的 SPMD 编程语言
- en: ASM – Assembler
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASM – 汇编器
- en: If a project does not specify its language, it’s assumed that C and CXX are
    being used.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目没有指定语言，则默认假设使用 C 和 CXX。
- en: 'CMake will automatically detect the toolchain to use by inspecting the system,
    but if needed, this can be configured by environment variables or, in the case
    of cross-compiling, by providing a toolchain file. This toolchain is stored in
    the cache, so if the toolchain changes, the cache must be deleted and rebuilt.
    If multiple compilers are installed, you can specify a non-default compiler by
    either setting the environment variables as `CC` for C or `CXX` for a C++ compiler
    before calling CMake. Here, we’re using the CXX environment variable to overwrite
    the default compiler to be used in CMake:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 会通过检查系统自动检测要使用的工具链，但如果需要，可以通过环境变量进行配置，或者在交叉编译的情况下，通过提供工具链文件来配置。这个工具链会存储在缓存中，因此如果工具链发生变化，必须删除并重新构建缓存。如果安装了多个编译器，可以通过在调用
    CMake 前设置环境变量（如 `CC` 用于 C 编译器，`CXX` 用于 C++ 编译器）来指定非默认的编译器。在这里，我们使用 CXX 环境变量来覆盖
    CMake 使用的默认编译器：
- en: '[PRE33]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, you can overwrite the C++ compiler to use by passing the respective
    `cmake` variable using `-D`, as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过传递相应的 `cmake` 变量并使用 `-D` 来覆盖使用的 C++ 编译器，如下所示：
- en: '[PRE34]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Both methods ensure that CMake is using GCC version 7 to build instead of whatever
    default compiler is available in the system. Avoid setting the compiler toolchain
    inside the `CMakeLists.txt` files as this clashes with the paradigm that states
    that CMake files should be platform- and compiler-agnostic.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都确保 CMake 使用 GCC 版本 7 来构建，而不是系统中可用的任何默认编译器。避免在 `CMakeLists.txt` 文件中设置编译器工具链，因为这与
    CMake 文件应该是平台和编译器无关的理念相冲突。
- en: By default, the linker is automatically selected by the chosen compiler, but
    it is possible to select a different one by passing the path to the linker executable
    with the `CMAKE_CXX_LINKER` variable.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，链接器会由所选的编译器自动选择，但也可以通过传递链接器可执行文件的路径，并使用 `CMAKE_CXX_LINKER` 变量来选择不同的链接器。
- en: Build types
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建类型
- en: When you’re building C++ applications, it is quite common to have various build
    types, such as a debug build that contains all debug symbols and release builds
    that are optimized.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 C++ 应用程序时，通常会有多种构建类型，例如包含所有调试符号的调试构建和经过优化的发布构建。
- en: 'CMake natively provides four build types:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 原生提供四种构建类型：
- en: '`Debug`: This is non-optimized and contains all the debug symbols. Here, all
    the asserts are enabled. This is the same as setting `-O0 -g` for GCC and Clang.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug`：未优化，包含所有调试符号，并启用所有断言。与在 GCC 和 Clang 中设置 `-O0 -g` 相同。'
- en: '`Release`: This is optimized for speed without debugging symbols and asserts
    disabled. Usually, this is the build type that is shipped. This is the same as
    `-``O3 -DNDEBUG`.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Release`：针对速度进行了优化，不包含调试符号，且禁用断言。通常，这就是发布时使用的构建类型。等同于 `-O3 -DNDEBUG`。'
- en: '`RelWithDebInfo`: This provides optimized code and includes debug symbols but
    disabled asserts, which is the same as `-O2 -``g -DNDEBUG`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelWithDebInfo`：提供优化后的代码，并包含调试符号，但禁用断言，等同于 `-O2 -g -DNDEBUG`。'
- en: '`MinSizeRel`: This is the same as `Release` but optimized for a small binary
    size instead of speed, which would be `-Os -DNDEBUG`. Note that this configuration
    is not supported for all generators on all platforms.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinSizeRel`：与 `Release` 相同，但针对小二进制文件大小进行了优化，而不是优化速度，这通常对应 `-Os -DNDEBUG`。注意，并非所有生成器在所有平台上都支持此配置。'
- en: Note that the build types must be passed during the configuration state for
    single-configuration generators such as CMake or Ninja. For multi-target generators
    such as MSVC, they are not used during the configuration step but are specified
    during the build step. It is possible to create custom build types, which can
    be a convenient way, for instance, to specify a build to generate code coverage,
    but they usually do not work for every compiler, so there is a bit of caution
    needed. An example of a custom build type can be found in [*Chapter 7*](B30947_07.xhtml#_idTextAnchor113),
    *Seamlessly Integrating Code Quality Tools with CMake*. Since CMake supports such
    a wide variety of toolchains, generators, and languages, a frequent question is
    how to find and maintain working combinations of these options. Here, presets
    can help.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，构建类型必须在配置阶段传递给单配置生成器，例如 CMake 或 Ninja。对于多目标生成器，如 MSVC，它们不会在配置步骤中使用，而是在构建步骤中指定。也可以创建自定义构建类型，这可以方便地用于指定生成代码覆盖的构建，但通常并非所有编译器都能支持，因此需要一些谨慎。有关自定义构建类型的示例，请参见
    [*第 7 章*](B30947_07.xhtml#_idTextAnchor113)，*无缝集成代码质量工具与 CMake*。由于 CMake 支持各种各样的工具链、生成器和语言，一个常见的问题是如何找到并维护这些选项的有效组合。在这里，预设可以提供帮助。
- en: Maintaining good build configurations with presets
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预设保持良好的构建配置
- en: 'A common problem when building software with CMake is how to share good or
    working configurations to build a project. Often, people and teams have a preferred
    way of where the build artifacts should go, which generator to use on which platform,
    or just the desire that the CI environment should use the same settings to build
    as they do locally. Since CMake 3.19 came out in December 2020, this information
    can be stored in `CMakePresets.json` files, which are placed in the root directory
    of a project. Additionally, each user can superimpose their configuration with
    a `CMakeUserPresets.json` file. The basic presets are usually placed under version
    control, but the user presets are not checked into the version system. Both files
    follow the same JSON format, with the top-level outline being as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 CMake 构建软件时，一个常见的问题是如何共享良好的或可用的配置来构建项目。通常，团队和个人都有偏好的构建产物存放位置、使用哪种生成器在某个平台上构建，或者希望
    CI 环境使用与本地相同的设置进行构建。自 2020 年 12 月 CMake 3.19 发布以来，这些信息可以存储在 `CMakePresets.json`
    文件中，该文件位于项目的根目录。此外，每个用户还可以通过 `CMakeUserPresets.json` 文件覆盖自己的配置。基本的预设通常会放在版本控制下，但用户的预设不会被提交到版本系统中。两个文件都遵循相同的
    JSON 格式，顶层结构如下：
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first line, `"version": 6`, denotes the schema version of the JSON file.
    CMake 3.23 supports up to version six, but it is expected that new releases will
    bring new versions of the schema.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行，`"version": 6`，表示 JSON 文件的架构版本。CMake 3.23 支持最多版本六，但预计新的版本发布将带来新的架构版本。'
- en: Next, `cmakeMinimumRequired{...}` specifies which version of CMake to use. Although
    this is optional, it is good practice to put this in here and match the version
    with the one specified in the `CMakeLists.txt` file.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`cmakeMinimumRequired{...}` 指定了需要使用的 CMake 版本。虽然这是可选的，但最好将其包含在内，并确保版本与 `CMakeLists.txt`
    文件中指定的版本匹配。
- en: After that, the various presets for the different build stages can be added
    with `configurePresets`, `buildPresets`, and `testPresets`. As the name suggests,
    `configurePresets` applies to the configure stage of CMake’s build process, while
    the other two are used for the build and test stages. The build and test presets
    may inherit one or more configure presets. If no inheritance is specified, they
    apply to all the previous steps.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，可以通过 `configurePresets`、`buildPresets` 和 `testPresets` 添加不同构建阶段的各种预设。如其名所示，`configurePresets`
    适用于 CMake 构建过程的配置阶段，而其他两个则用于构建和测试阶段。构建和测试预设可以继承一个或多个配置预设。如果没有指定继承关系，它们将应用于所有先前的步骤。
- en: To see what presets have been configured in a project, run `cmake --list-presets`
    to see a list of available presets. To build using a preset, run `cmake --build
    --``preset name`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看项目中已配置的预设，可以运行 `cmake --list-presets` 查看可用预设的列表。要使用预设进行构建，运行 `cmake --build
    --``preset name`。
- en: To see the full specification of the JSON schema, go to [https://cmake.org/cmake/help/v3.21/manual/cmake-presets.7.html](https://cmake.org/cmake/help/v3.21/manual/cmake-presets.7.html).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 JSON 模式的完整规格，请访问 [https://cmake.org/cmake/help/v3.21/manual/cmake-presets.7.html](https://cmake.org/cmake/help/v3.21/manual/cmake-presets.7.html)。
- en: Presets are a good way to share knowledge about how to build a project in a
    very explicit way. At the time of writing, more and more IDEs and editors are
    adding support for CMake presets natively, especially for handling cross-compilation
    with toolchains. Here, we’re only giving you the briefest overview of CMake presets;
    they will be covered in more depth in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible* *Build* *Environments*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 预设是共享如何以非常明确的方式构建项目知识的好方法。撰写本文时，越来越多的 IDE 和编辑器原生支持 CMake 预设，尤其是在处理跨编译和工具链时。在这里，我们只为你提供了
    CMake 预设的简要概述；它们将在 [*第 9 章*](B30947_09.xhtml#_idTextAnchor146) 中更深入地介绍，*创建可重复的*
    *构建* *环境*。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we provided you with a brief overview of CMake. First, you
    learned how to install and run a simple build. Then, you learned about the two-stage
    build process of CMake and single-configuration and multi-configuration generators.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为你提供了 CMake 的简要概述。首先，你学习了如何安装并运行一个简单的构建。接着，你了解了 CMake 的两阶段构建过程以及单配置生成器和多配置生成器。
- en: By now, you should be able to build the examples provided in this book’s GitHub
    repository at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
    You learned about the core features of the CMake language, such as variables,
    targets, and policies. We briefly covered functions and macros, as well as conditional
    statements and loops for flow control. As you continue reading this book, you
    will use what you have learned so far to discover further good practices and techniques
    to move from simple one-target projects to complex software projects that keep
    being maintainable through a good CMake setup.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能够构建本书 GitHub 仓库中提供的示例：[https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)。你学习了
    CMake 语言的核心功能，如变量、目标和策略。我们简要介绍了函数和宏，以及用于流程控制的条件语句和循环。随着你继续阅读本书，你将运用到目前为止所学的内容，探索更多好的实践和技巧，将从简单的单目标项目过渡到复杂的软件项目，并通过良好的
    CMake 配置保持其可维护性。
- en: In the next chapter, we will learn how some of the most common tasks in CMake
    can be performed and how CMake works together with various IDEs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何执行 CMake 中一些最常见的任务，以及 CMake 如何与各种 IDE 配合工作。
- en: Further reading
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章中讨论的主题，请参考以下资源：
- en: 'The official CMake documentation: [https://cmake.org/cmake/help/latest/](https://cmake.org/cmake/help/latest/)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '官方 CMake 文档: [https://cmake.org/cmake/help/latest/](https://cmake.org/cmake/help/latest/)'
- en: 'The official CMake tutorial: [https://cmake.org/cmake/help/latest/guide/tutorial/index.html](https://cmake.org/cmake/help/latest/guide/tutorial/index.html)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '官方 CMake 教程: [https://cmake.org/cmake/help/latest/guide/tutorial/index.html](https://cmake.org/cmake/help/latest/guide/tutorial/index.html)'
- en: Questions
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题，以测试你对本章内容的理解：
- en: How do you start the configure step of CMake?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何启动 CMake 的配置步骤？
- en: What is the difference between single-configuration and multi-configuration
    generators?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单配置生成器和多配置生成器之间有什么区别？
- en: How do you start the build step of CMake?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何启动 CMake 的构建步骤？
- en: Which executable from CMake can be used to run tests?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 CMake 可执行文件可以用于运行测试？
- en: Which executable from CMake is used for packaging?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 CMake 可执行文件用于打包？
- en: What are targets in CMake?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 中的目标是什么？
- en: What is the difference between properties and variables?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性和变量有什么区别？
- en: What are CMake presets used for?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 预设的用途是什么？
- en: Answers
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'The following are the answers to the preceding questions:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面问题的答案：
- en: 'You can start the configure step of CMake with the following command:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过以下命令开始 CMake 的配置步骤：
- en: '`cmake -S /path/to/source -``B /path/to/build`'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cmake -S /path/to/source -``B /path/to/build`'
- en: Single-configuration generators will only generate build files for one type
    of build, such as debug or release builds. Multi-configuration generators will
    generate build instructions for all available build types in one go.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单配置生成器只会生成一个类型构建的构建文件，例如调试或发布构建。多配置生成器会一次性生成所有可用构建类型的构建指令。
- en: 'You can start the build step of CMake using:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令开始 CMake 的构建步骤：
- en: '[PRE36]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following executable from CMake can be used to run tests:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是可以用于运行测试的 CMake 可执行文件：
- en: '[PRE37]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following executable from CMake is used for packaging:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是可以用于打包的 CMake 可执行文件：
- en: '[PRE38]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Targets in CMake are logical units around which CMake organizes a build. They
    can be executables, libraries, or contain custom commands.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 中的目标是围绕构建组织的逻辑单元。它们可以是可执行文件、库，或包含自定义命令。
- en: Unlike variables, properties are attached to a specific object or scope.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与变量不同，属性是附加到特定对象或作用域上的。
- en: CMake presets are used to share working configurations for a build.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 预设用于共享构建的工作配置。
