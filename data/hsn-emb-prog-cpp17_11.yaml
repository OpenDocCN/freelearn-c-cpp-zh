- en: Example - Building Monitoring and Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 建筑物监测和控制
- en: 'The monitoring of conditions within a building, including the temperature,
    humidity, and CO[2] levels is becoming increasingly more common, with the goal
    being to adjust heating, cooling, and ventilation systems to keep the occupants
    of the building as comfortable as possible. In this chapter, such a system is
    explored and implemented. The following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑物内部条件的监测，包括温度、湿度和CO[2]水平，正在变得越来越普遍，目标是调整供暖、制冷和通风系统，以使建筑物的居住者尽可能舒适。在本章中，将探讨并实施这样的系统。将涵盖以下主题：
- en: Creating complex firmware for the ESP8266
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为ESP8266创建复杂的固件
- en: Integrating an MCU into an IP-based network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将MCU集成到基于IP的网络中
- en: Adding CO[2] and I2C-based sensors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加CO[2]和基于I2C的传感器
- en: Using GPIO and PWM to control relays and DC voltage-controlled fans
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPIO和PWM来控制继电器和直流电压控制风扇
- en: Connecting networked nodes using a central controller
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中央控制器连接网络节点
- en: Plants, rooms, and beyond
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 植物、房间和更多
- en: In [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, we looked at developing firmware for the ESP8266
    MCU to complement a soil humidity sensor and pump, to ensure that a connected
    plant would be provided with sufficient water from the water tank.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中，我们研究了为ESP8266 MCU开发固件，以配合土壤湿度传感器和水泵，以确保连接的植物能够从水箱中获得足够的水。
- en: 'As we noted in that chapter, the firmware used is highly modular and has the
    highly flexible MQTT-based interface so that it can be used for a wide variety
    of modules. This chapter covers the system in which the firmware originated: **Building
    Management and Control** (**BMaC**), originally developed just to monitor rooms
    for their temperature, humidity, and CO² levels, but later expanded to keep tabs
    on coffee machines and meeting room occupancy, and ultimately to control the air-conditioning
    throughout the building.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在那一章中指出的，所使用的固件是高度模块化的，并具有高度灵活的基于MQTT的接口，因此可以用于各种模块。本章涵盖了固件起源的系统：**建筑管理和控制**（**BMaC**），最初只是用于监测房间的温度、湿度和CO²水平，但后来扩展到监控咖啡机和会议室的占用情况，并最终控制整栋建筑的空调。
- en: The BMaC project's current development status can be found at the author's GitHub
    account at [https://github.com/MayaPosch/BMaC](https://github.com/MayaPosch/BMaC).
    The version we are covering here is as it exists at this point, with us covering
    how this system came to be and what it looks like today, and why.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: BMaC项目的当前开发状态可以在作者的GitHub帐户[https://github.com/MayaPosch/BMaC](https://github.com/MayaPosch/BMaC)中找到。我们在这里涵盖的版本是目前的版本，我们将介绍这个系统的起源以及今天的样子，以及原因。
- en: Developmental history
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发展历史
- en: The BMaC project started when sensors were to be added around an office building
    in order to measure temperature and other parameters, such as relative humidity.
    After deciding to use ESP8266 MCUs along with DHT22 temperature and humidity sensors,
    a simple prototype was put together, using a basic firmware written using the
    Sming framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: BMaC项目始于在办公楼周围添加传感器以测量温度和其他参数，如相对湿度。在决定使用ESP8266 MCU和DHT22温湿度传感器后，使用Sming框架编写了基本固件，制作了一个简单的原型。
- en: It was found that DHT22 sensors were generally rather bulky and not very precise.
    The breakout boards used also had an improper resistor mounted on them, leading
    to the wrong temperature being reported. This sensor type also had the disadvantage
    of using its own one-wire protocol, instead of a standard interface method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 发现DHT22传感器通常相当笨重且不太精确。使用的分板还安装了不正确的电阻，导致温度报告错误。这种传感器类型还有一个缺点，即使用自己的单线协议，而不是标准接口方法。
- en: The DHT22 sensors got swapped out with BME280 MEMS sensors, which measure temperature,
    humidity, and also air pressure. A CO[2] sensor was added as well, in the form
    of the MH-Z19\. This required the firmware to support these additional sensors
    too. The sensor readings would be sent as MQTT messages, with a backend service
    subscribing to these topics, and writing them to a time series database (InfluxDB),
    for viewing and analysis.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DHT22传感器被BME280 MEMS传感器替换，后者可以测量温度、湿度和气压。还添加了CO[2]传感器，即MH-Z19。这也需要固件支持这些额外的传感器。传感器读数将作为MQTT消息发送，后端服务订阅这些主题，并将它们写入时间序列数据库（InfluxDB）以供查看和分析。
- en: Decisions had to be made when the possibility of reading out the counters for
    products from the fully automatic Jura coffee machines was considered, and with
    it whether separate firmware would have to be developed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑从全自动Jura咖啡机中读取产品计数器的可能性时，必须做出决定，以及是否需要开发单独的固件。
- en: Instead of separate firmware, the decision was made to use the same firmware
    for all ESP8266 nodes. This meant that they needed to have the functionality to
    somehow enable individual features and to support specific sensors and other features.
    This led to the development of new firmware, which allowed remote commands, sent
    over MQTT, to toggle feature modules on or off, along with other management features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用相同的固件来处理所有ESP8266节点，而不是单独的固件。这意味着它们需要具有某种功能来启用个别功能，并支持特定的传感器和其他功能。这导致了新固件的开发，该固件允许通过MQTT发送远程命令来切换功能模块的开启或关闭，以及其他管理功能。
- en: Along with the new firmware, a **command and control** (**C&C**) server was
    added, used by the individual nodes to retrieve their configuration, along with
    an administration application to be used to add new nodes and add or edit the
    node configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的固件，还添加了一个**命令和控制**（**C&C**）服务器，用于个别节点检索其配置，以及一个管理应用程序，用于添加新节点和添加或编辑节点配置。
- en: With this framework in place, it became possible to add new features quickly.
    These included the addition of motion sensors, for detecting the presence of people
    in a room, to ultimately the controlling of air-conditioning units, as the existing
    centralized control in the office building was found to be inadequate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个框架，就可以快速添加新功能。这些功能包括添加运动传感器，用于检测房间内人员的存在，最终控制空调单元，因为发现办公楼中的现有集中控制不足以满足需求。
- en: 'The system as a whole can be visualized like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统可以像这样进行可视化：
- en: '![](img/d784b62d-39db-497b-91d4-8914218b0cde.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d784b62d-39db-497b-91d4-8914218b0cde.png)'
- en: In the upcoming sections, we will be taking a detailed look at each of these
    aspects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细查看每个方面。
- en: Functional modules
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能模块
- en: 'Here is a list of modules in this firmware:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该固件中的模块列表：
- en: '| **Name** | **Feature** | **Description** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **特性** | **描述** |'
- en: '| THP | Temperature, Humidity, Pressure | Central class for THP sensors. Enables
    BME280 functionality by default. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| THP | 温度、湿度、气压 | THP传感器的中心类。默认情况下启用BME280功能。 |'
- en: '| CO[2] | CO[2] value | Measures CO[2] <indexentry content="functional modules,
    Building Management and Control (BMaC):CO[2]">values using an MH-Z19 or compatible
    sensor. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| CO[2] | CO[2]值 | 使用MH-Z19或兼容传感器测量CO[2] <indexentry content="功能模块，建筑管理和控制（BMaC）：CO[2]">值。
    |'
- en: '| Jura | TopTronics EEPROM counters | Reads out the counters for various products
    from the EEPROM. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Jura | TopTronics EEPROM 计数器 | 从EEPROM中读取各种产品的计数器数值。 |'
- en: '| JuraTerm | TopTronics remote control | Allows a remote service to send TopTronics
    (classic, v5-style) commands to a supported coffee machine. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| JuraTerm | TopTronics 远程控制 | 允许远程服务向支持的咖啡机发送TopTronics（经典，v5风格）命令。 |'
- en: '| Motion | Motion detection | Uses an HC-SR501 PIR motion sensor or compatible
    to detect motion. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 运动 | 运动检测 | 使用HC-SR501 PIR运动传感器或兼容设备来检测运动。 |'
- en: '| PWM | PWM output | Sets a pulse-width modulation output on one or more pins.
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| PWM | PWM输出 | 在一个或多个引脚上设置脉冲宽度调制输出。 |'
- en: '| I/O | I/O expansion | Supports the MCP23008 eight-channel I/O expander module
    via I2C. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| I/O | I/O扩展 | 通过I2C支持MCP23008八通道I/O扩展器模块。 |'
- en: '| Switch | Persistent switch | Controls a switch that uses a latching relay
    or equivalent for switching. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 开关 | 持久开关 | 控制使用闩锁继电器或等效物进行切换的开关。 |'
- en: '| Plant | Watering plants | Reads out an analog soil sensor to determine soil
    humidity, activating a pump when needed. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 植物 | 浇水植物 | 读取模拟土壤传感器的数值，确定土壤湿度，需要时激活水泵。 |'
- en: Firmware source
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固件源代码
- en: In this section, we look at the source code for the ESP8266 firmware as used
    with the BMaC system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看与BMaC系统一起使用的ESP8266固件的源代码。
- en: Core
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心
- en: The core of the firmware we already looked at in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, including the entry point, the `OtaCore` class,
    and the `BaseModule` class, which provide all of the functionality needed to make
    individual modules initialize and to allow them to be enabled and disabled using
    the MQTT interface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中查看了固件的核心，*示例-带Wi-Fi的土壤湿度监测器*，包括入口点、`OtaCore`类和`BaseModule`类，它们提供了使单独的模块初始化并允许使用MQTT接口启用和禁用它们所需的所有功能。
- en: Modules
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: 'Of the firmware modules, we already looked at the plant module in [Chapter
    5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil Humidity Monitor
    with Wi-Fi*. Here we will look at the remaining modules, starting with the THP
    module:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在固件模块中，我们已经在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中查看了植物模块，*示例-带Wi-Fi的土壤湿度监测器*。在这里，我们将查看其余的模块，从THP模块开始：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This module has the provisions to act as a generic interface to a wide variety
    of temperature, humidity, and air-pressure sensors. As this was not a requirement
    at the time, it merely acted as a pass-through for the BME280 module. It registers
    itself with the base module when called and calls the respective functions on
    the BME280 module when its own are called.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块具有作为各种温度、湿度和气压传感器的通用接口的功能。由于当时并不需要这个功能，它只是作为BME280模块的传递。当被调用时，它会在基础模块中注册自己，并在调用自己的函数时调用BME280模块的相应函数。
- en: To make it more versatile, the class would be extended to allow for commands
    to be received—possibly over MQTT as well on its own topic—which would then enable
    a specific sensor module, or even a collection of them, when using separate temperature
    and air pressure sensors, for example.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加多功能，该类将被扩展以允许接收命令——可能是通过MQTT以及自己的主题——这样就可以在使用单独的温度和气压传感器时启用特定的传感器模块，甚至是它们的集合，例如使用单独的温度和气压传感器。
- en: Regardless of whether it is being used or not in this firmware, let's take a
    look at the DHT module so that we can compare it with the BME280 module later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无论在该固件中是否被使用，让我们来看看DHT模块，以便以后可以将其与BME280模块进行比较。
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of note is that while the class is static, any variables that would take up
    considerable memory—such as library class instances—are defined as pointers. This
    forms a compromise between having the module available for easy use and going
    for a more complicated, fully dynamic solution. As most MCUs tend to keep as much
    of the program code as possible in the ROM until it is used, this should keep
    both SRAM and ROM usage to a minimum.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然该类是静态的，但会占用大量内存的任何变量——例如库类实例——都被定义为指针。这形成了在使模块易于使用和选择更复杂的完全动态解决方案之间的折衷。由于大多数MCU倾向于尽可能将程序代码保存在ROM中，直到使用时才将其保存，这应该将SRAM和ROM的使用保持在最低水平。
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To initialize the module, we ensure that we can safely use the **general-purpose
    input/output** (**GPIO**) pins we intend to use, create a new instance of the
    sensor class from the library, and set it up before creating the 2-second timer
    that will perform the scheduled sensor read-out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化该模块，我们确保可以安全地使用我们打算使用的**通用输入/输出**（**GPIO**）引脚，从库中创建传感器类的新实例，并在创建执行计划的传感器读数的2秒定时器之前对其进行设置。
- en: Since we create a new instance of the  sensor class upon initializing there
    should never be an existing instance of this class, but we check in case the init()
    function gets called again a second time for some reason. Calling the initialization
    function on the timer a second time could also be included in this block, but
    isn't strictly required as there is no harmful effect from initializing the timer
    again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在初始化时创建了传感器类的新实例，因此不应该存在此类的现有实例，但我们检查以防init()函数由于某种原因再次被调用。在计时器上第二次调用初始化函数也可以包括在此块中，但并不是严格要求的，因为再次初始化计时器不会产生有害影响。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To shut down the module, we stop the timer and release the GPIO pin we were
    using, before cleaning up all resources we used. As we have claimed the pin we're
    using previously when we initialized the module we should have no issues releasing
    it again, but we check to make sure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭模块，我们停止计时器并释放我们使用的GPIO引脚，然后清理我们使用的所有资源。由于我们在初始化模块时已经声明了我们使用的引脚，所以再次释放它不应该有问题，但我们会检查以确保。
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is an example of how one could later change the GPIO pin used by a module,
    here using the old text-based command format that early versions of the BMaC firmware
    used to use. We could also receive this information via an MQTT topic, or by actively
    querying the command and control server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，说明如何稍后更改模块使用的GPIO引脚，这里使用早期版本BMaC固件使用的旧文本命令格式。我们也可以通过MQTT主题接收此信息，或者通过主动查询命令和控制服务器。
- en: Note that to change the pin used by the sensor one would have to restart the
    sensor by deleting the class instance and creating a new instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要更改传感器使用的引脚，必须通过删除类实例并创建新实例来重新启动传感器。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, for the `BME280` sensor module, its code looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于`BME280`传感器模块，其代码如下：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, it''s familiar-looking implementation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一个看起来很熟悉的实现：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, this module was basically copied from the DHT one, and then modified
    to fit the BME280 sensor. The similarities between those two modules was one of
    the motivations behind developing the THP module, in order to exploit these similarities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个模块基本上是从DHT模块复制过来的，然后修改以适应BME280传感器。这两个模块之间的相似之处是开发THP模块的动机之一，以利用这些相似之处。
- en: As with the DHT module, we can see that we rely on an external library to do
    the heavy lifting for us, with us merely having to call the functions on the library
    class to set up the sensor and get the data from it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与DHT模块一样，我们可以看到我们依赖外部库来为我们完成大部分工作，我们只需调用库类上的函数来设置传感器并从中获取数据。
- en: CO2 module
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CO2模块
- en: For the CO[2] module, no attempt has been made yet to make it work with multiple
    types of CO[2] sensors. The first CO[2] sensor used was the MH-Z14, before it
    <indexentry content="modules, Building Management and Control (BMaC):CO[2] module">switched
    to the more compact MH-Z19 sensor. Both of these use the same protocol on their
    **universal asynchronous receiver/transmitter** (**UART**) interface, however.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CO[2]模块，尚未尝试使其与多种CO[2]传感器兼容。首先使用的CO[2]传感器是MH-Z14，然后切换到更紧凑的MH-Z19传感器。这两者在它们的**通用异步收发器/发送器**（**UART**）接口上使用相同的协议。
- en: On the ESP8266 there are two UARTs, though only one is complete, with a receive
    (RX) and send (TX) line. The second UART only has a TX line. This essentially
    limits this MCU to a single UART and thus single UART-based sensor.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在ESP8266上有两个UART，但只有一个是完整的，具有接收（RX）和发送（TX）线。第二个UART只有一个TX线。这基本上将这个MCU限制为单个UART，因此只能使用基于单个UART的传感器。
- en: These sensors also have a single-wire interface in addition to the UART-based
    interface, where the sensor outputs the current sensor reading using a specific
    encoding that has to be received and decoded using the specific distance between
    pulses on that signal wire. This is similar to the DHT-22's single-wire protocol.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些传感器除了基于UART的接口外，还有一个单线接口，传感器使用特定的编码输出当前的传感器读数，必须使用信号线上脉冲之间的特定距离进行接收和解码。这类似于DHT-22的单线协议。
- en: 'Using the UART is obviously significantly easier, and it''s what we ended up
    using with this module:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用UART要容易得多，这也是我们最终使用这个模块的原因：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see here the callback function that will be used with the UART when
    we receive data. We also have a few other variables whose meaning will <indexentry
    content="modules, Building Management and Control (BMaC):CO[2] module">become
    clear in a moment:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到将与UART一起使用的回调函数，当我们接收数据时将使用它。我们还有一些其他变量，它们的含义将在一会儿变得清晰：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the static initializations, we define the command that we will be sending
    to the CO[2] sensor, which will tell it to send us its currently measured value.
    We define a number of counters and the related timer instance, which we will be
    using to analyze the CO[2] levels we receive.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态初始化中，我们定义了将发送给CO[2]传感器的命令，告诉它向我们发送当前测量值。我们定义了一些计数器和相关的计时器实例，我们将使用它们来分析我们收到的CO[2]水平。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Starting this module triggers the registering of the pins, which we need for
    the UART, with the UART started at a baud rate of 9,600\. Our receive callback
    is also registered. The pin registration routine in the core class is meant for
    housekeeping and therefore cannot really fail. In case of an overlapping pin mapping
    with another module, we might want to release the first pin registration if the
    second registration fails.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 启动此模块会触发引脚的注册，我们需要这些引脚用于UART，UART以9600的波特率启动。我们还注册了接收回调。核心类中的引脚注册例程用于日常维护，因此实际上不会失败。如果与另一个模块存在重叠的引脚映射，我们可能希望在第二次注册失败时释放第一个引脚注册。
- en: The GPIO pins used by the serial interface are set in the same core class and
    would have to be modified there. The main reason behind this lack of configurability
    is that the GPIO pins on the ESP8266 are fairly limited in what features they
    support, which is why the hardware UART is basically always found on these two
    pins, leaving the other pins for other functionality.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 串行接口使用的GPIO引脚在同一个核心类中设置，并且必须在那里进行修改。这种可配置性缺乏的主要原因是ESP8266上的GPIO引脚在支持的功能方面相当有限，这就是为什么硬件UART基本上总是在这两个引脚上找到，而其他引脚用于其他功能。
- en: The timer we start will read out the sensor every 30 seconds, keeping in mind
    that the first 3 minutes of sensor readings are useless as the sensor takes <indexentry
    content="modules, Building Management and Control (BMaC):CO[2] module">about that
    long to warm up.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动的定时器将每30秒读取一次传感器，要记住前3分钟的传感器读数是无用的，因为传感器需要大约那么长的时间来预热。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Reading out the sensor is as easy as writing the series of bytes we defined
    during the static initialization phase to the sensor, and waiting for the sensor
    to respond by sending data back to us into our RX buffer, which will trigger our
    callback function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 读取传感器的操作就像将我们在静态初始化阶段定义的一系列字节写入传感器一样简单，然后等待传感器通过将数据发送回我们的RX缓冲区来响应，这将触发我们的回调函数。
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The configuration method was also left unimplemented here, but could be used
    to disable events (explained in the next part) and make various adjustments dynamically:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 配置方法在这里也没有实现，但可以用来禁用事件（在下一部分中解释）并动态进行各种调整：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the callback, we get the characters as they come in on the RX line. We wait
    until we have nine characters waiting for us in the RX buffer, which is the <indexentry
    content="modules, Building Management and Control (BMaC):CO[2] module">number
    of bytes we are expecting to receive from the CO[2] sensor. We could also validate
    the checksum for the received data, for which the MH-Z19 datasheet gives the following
    C code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，我们会在RX线上接收到字符时进行处理。我们等待直到在RX缓冲区中有九个字符等待我们，这是我们期望从CO[2]传感器接收到的字节数。我们还可以验证接收数据的校验和，对于这个，MH-Z19数据表给出了以下C代码：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This routine calculates the checksum for the received data as a single byte,
    which we can then compare with the value contained in the 9th byte of the received
    data to see whether the values match.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程计算接收数据的校验和作为一个单字节，然后我们可以将其与接收数据的第9个字节中包含的值进行比较，看看这些值是否匹配。
- en: Returning to our own code, we process the bytes to calculate the **parts per
    million** (**PPM**) of the CO[2] molecules the sensor detected. This value is
    immediately published to its respective MQTT topic.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们自己的代码，我们处理字节来计算传感器检测到的CO[2]分子的**百万分之几**（**PPM**）。这个值会立即发布到其相应的MQTT主题。
- en: After this, we compare the new PPM value to see whether we have crossed any
    of the three preset trigger levels, the first one of which indicates a safe CO[2 ]level,
    the second an elevated CO[2 ]level, and the third a very high CO[2] level that
    requires attention. When we exceed or return to a lower trigger level, an event
    is published for this on the MQTT topic.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们比较新的PPM值，看看我们是否已经超过了三个预设的触发级别中的任何一个，第一个表示安全的CO[2]水平，第二个表示升高的CO[2]水平，第三个表示需要注意的非常高的CO[2]水平。当我们超过或返回到较低的触发级别时，将在MQTT主题上发布一个事件。
- en: Jura
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jura
- en: This is another module which uses the UART. It was used with a number of Jura
    coffee machines, which used the common TopTronics electronics used by other coffee
    machine manufacturers as well. To enable reading out these coffee machines, an
    ESP8266 module was integrated into a small, plastic enclosure which just had a
    serial connector on one side. This connected with a standard nine-pin serial cable
    to the so-called service port on the back of the machine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个使用UART的模块。它曾与许多Jura咖啡机一起使用，这些咖啡机使用了其他咖啡机制造商常用的TopTronics电子设备。为了能够读取这些咖啡机的信息，ESP8266模块被集成到一个小型塑料外壳中，外壳的一侧只有一个串行连接器。这个连接器通过标准的九针串行电缆连接到机器背面的所谓的服务端口。
- en: The serial port on the machine provided 5V when it was powered on, which thus
    also turned on the ESP8266 node when the coffee machine was on. The plastic enclosure
    could then be hidden away behind the machine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当咖啡机通电时，机器上的串行端口提供5V电压，这也会在咖啡机开启时打开ESP8266节点。塑料外壳可以隐藏在机器后面。
- en: 'The module for this feature looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的模块看起来像这样：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The only really noticeable thing about this class declaration is the method
    name involving a coffee maker. We''ll see in a second what it does:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类声明中唯一真正显著的是涉及咖啡机的方法名。我们马上就会看到它的作用：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As is common, the coffee machine''s UART runs at 9,600 baud. We set the serial
    callback method, and start a timer for reading out the EEPROM''s product counters.
    Since we are talking about a coffee machine, reading out the counters more than
    once a minute is somewhat silly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 和通常一样，咖啡机的UART运行在9600波特率。我们设置了串行回调方法，并启动了一个定时器来读取EEPROM的产品计数器。因为我们在谈论咖啡机，所以每分钟读取计数器超过一次有点愚蠢：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To read out the EEPROM''s counters, we need to send the command for this to
    the machine''s UART. This command will tell it to send us the contents of the
    first row in the EEPROM. Unfortunately, the machine''s protocol doesn''t use plain
    text, but requires a bit of special encoding, which we do in the next method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取EEPROM的计数器，我们需要将此命令发送到机器的UART。这个命令会告诉它向我们发送EEPROM的第一行内容。不幸的是，机器的协议不使用纯文本，而是需要一些特殊的编码，我们会在下一个方法中进行编码：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This method takes in a string, appending the required EOL characters and encoding
    each byte into four bytes, putting the data bits into each new byte''s second
    and fifth bit, the rest of the bits all being a 1\. These four bytes are then
    sent to the machine''s UART with a small delay between each write to ensure correct
    reception:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受一个字符串，附加所需的EOL字符，并将每个字节编码为四个字节，将数据位放入每个新字节的第二和第五位，其余位都是1。然后，这四个字节被发送到机器的UART，每次写入之间有小延迟以确保正确接收：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the serial receive callback, we decode each byte we receive using the same
    process we used to encode the data we sent to the machine, buffering the decoded
    bytes until we detect the end of the response (linefeed, LF) character. We then
    read out the 16-bit counters, which we then publish on the MQTT topic for them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在串行接收回调中，我们使用与我们用来对发送到机器的数据进行编码相同的过程来解码我们接收到的每个字节，缓冲解码后的字节，直到检测到响应结束（换行符，LF）字符。然后我们读出16位计数器，然后将其发布到MQTT主题上。
- en: JuraTerm
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JuraTerm
- en: The JuraTerm module is similar to the Jura one, but it accepts remote commands,
    encodes them in the same way as the Jura module, and returns the decoded response.
    In the project it used to be the Jura class until it got superseded by the new
    Jura class and this one was delegated to just a terminal class. In a future revision
    this module's functionality will therefore be merged into the main Jura class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JuraTerm模块类似于Jura模块，但它接受远程命令，以与Jura模块相同的方式对其进行编码，并返回解码后的响应。在项目中，它曾经是Jura类，直到被新的Jura类取代，这个类被委托为终端类。在将来的修订版中，这个模块的功能将被合并到主Jura类中。
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we start this module, we register an MQTT topic to receive commands. This
    allows us to receive the coffee machine commands. We basically act as a straight
    pass-through for these commands, except for this one particular command. This
    command that we filter out would erase the machine's EEPROM, which is something
    which we are unlikely to want.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动这个模块时，我们注册一个MQTT主题来接收命令。这允许我们接收咖啡机命令。我们基本上充当这些命令的直通车，除了这一个特定的命令。我们过滤掉的这个命令会擦除机器的EEPROM，这是我们不太可能想要的。
- en: 'Again, we use the same method to encode the command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的方法来编码命令：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Instead of interpreting the data in any way, we merely return the response on
    its respective MQTT topic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅仅返回其相应的MQTT主题上的响应，而不对数据进行任何解释。
- en: Motion
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Motion
- en: The motion module is intended to work with **passive infrared** (**PIR**) sensors.
    These have onboard logic that determine when a trigger point has been reached,
    at which point they change an interrupt pin into a high signal. We can use this
    to determine whether a person is in a room, or is walking through a hallway.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运动模块旨在与**被动红外**（**PIR**）传感器一起使用。这些传感器具有内置逻辑，确定何时达到触发点，此时它们将中断引脚更改为高信号。我们可以使用这个来确定一个人是否在房间里，或者是在走廊里走动。
- en: 'Its code looks as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其代码如下：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of note here is that we explicitly move the interrupt handler method into the
    MCU's SRAM with the IRAM_ATTR keyword, to prevent any delay when the interrupt
    gets called.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们明确将中断处理程序方法移入MCU的SRAM中，以防止中断调用时出现任何延迟。
- en: 'Its implementation is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其实现如下：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A PIR sensor requires warm-up time to stabilize its readings. We give it a minute
    using the warm-up timer. We also set the mode for the GPIO pin we're using.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: PIR传感器需要预热时间来稳定其读数。我们使用预热计时器给它一分钟。我们还设置了我们使用的GPIO引脚的模式。
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After the sensor has finished warming up, we stop its timer and attach the
    interrupt to handle any signals from the sensor. We''ll check up on the shared
    variable with the interrupt routine, to see whether the value has changed, publishing
    the current value every 5 seconds:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器完成预热后，我们停止其计时器，并附加中断以处理传感器发出的任何信号。我们将使用中断例程检查共享变量，以查看值是否已更改，并每5秒发布当前值：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When checking the current sensor value, we make it a point to ignore the first
    time that the sensor reports `LOW`. This in order to ensure that we ignore moments
    when people do not move a lot in the room. The resulting value is then published
    on the MQTT topic:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查当前传感器值时，我们特意忽略传感器报告“LOW”的第一次。这是为了确保我们忽略人们在房间里不经常移动的时刻。然后将得到的值发布到MQTT主题上：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The interrupt handler merely updates the local Boolean value. Because of the
    relatively long transition times for most processing circuits for PIR sensor there
    is quite a bit of time (seconds) before the sensor will detect motion again, creating
    dead zones. Here we keep track of the last registered value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序仅更新本地布尔值。由于大多数PIR传感器的处理电路的转换时间相对较长，传感器再次检测到运动之前有相当长的时间（几秒钟），从而产生死区。在这里，我们跟踪上次注册的值。
- en: PWM
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PWM
- en: The reason why the PWM module was developed was to have a way to generate an
    analog output voltage using an external RC filter circuit. This was in order to
    control the fan of the ceiling-mounted air-conditioning units, whose fan controller
    accepts a voltage of between 0 and 10 volts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: PWM模块的开发原因是为了通过外部RC滤波电路生成模拟输出电压的方法。这是为了控制天花板空调的风扇，其风扇控制器接受0至10伏特之间的电压。
- en: 'An interesting feature of this module is that it has its own binary protocol
    to allow for remote control, which is how the air-conditioning service can directly
    control the fan speeds via the ceiling-mounted nodes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块的一个有趣特性是它有自己的二进制协议，以实现远程控制，这就是天花板节点通过空调服务直接控制风速的方式：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The implementation is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We define the commands that will be available with the PWM module here as an
    enumeration:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义PWM模块可用的命令作为枚举：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we start this module, we register the MQTT topic on which the module will
    be able to receive commands. When shutting down, we deregister this topic again.
    We use the `HardwarePWM` class from Sming to enable PWM on individual pins.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动这个模块时，我们注册一个MQTT主题，以便模块能够接收命令。关闭时，我们再次注销这个主题。我们使用Sming的`HardwarePWM`类在单独的引脚上启用PWM。
- en: 'The rest of the module is simply the command processor:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的其余部分只是命令处理器：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The protocol implemented by the preceding method is the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法实现的协议如下：
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '**命令** | **含义** | **有效负载** | **返回值** |'
- en: '| 0x01 | Start the module | uint8 (number of pins)uint8* (one byte per pin
    number) | 0x00/0x01 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: 0x01 | 启动模块 | uint8（引脚数量）uint8*（每个引脚编号一个字节）| 0x00/0x01 |
- en: '| 0x02 | Stop the module | - | 0x00/0x01 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: 0x02 | 停止模块 | - | 0x00/0x01 |
- en: '| 0x04 | Set the PWM duty level | uint8 (pin number)uint8 (duty cycle, 0 -
    100) | 0x00/0x01 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: 0x04 | 设置PWM占空比 | uint8（引脚编号）uint8（占空比，0-100）| 0x00/0x01 |
- en: '| 0x08 | Get the PWM duty level | uint8 (pin number). | uint8 (duty level)
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: 0x08 | 获取PWM占空比 | uint8（引脚编号）| uint8（占空比）|
- en: '| 0x10 | Returns the active pins | - | uint8* (one pin number per byte) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: 0x10 | 返回活动引脚 | - | uint8*（每个字节一个引脚编号）|
- en: For each command, we parse the string of bytes we receive, checking the number
    of bytes to see whether we get the expected number, and then interpreting them
    as commands and their payload. We either return a 0 (failure) or a 1 (success),
    or a payload with the desired information.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个命令，我们解析接收到的字节串，检查字节数以查看是否获得了预期的数量，然后将其解释为命令及其有效负载。我们要么返回0（失败）或1（成功），要么返回所需信息的有效负载。
- en: One obvious addition that could be made here would be to add some kind of checksum
    to the received command, along with sanity checks on the received data. While
    code like this will work great in a secure environment with encrypted MQTT links
    and a reliable network connection, other environments may be less forgiving, with
    corrupted data and false data being injected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以明显增加的一个补充是在接收到的命令中添加某种校验和，并对接收到的数据进行合理性检查。虽然这样的代码在具有加密MQTT链接和可靠网络连接的安全环境中运行良好，但其他环境可能不太宽容，会出现数据损坏和虚假数据注入的情况。
- en: I/O
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O
- en: Sometimes all we need is just a lot of GPIO pins that connect to things like
    relays, so that we can turn heating valves on or off. This was the reason behind
    this module. The nodes that were being installed on the ceiling had not just an
    I2C bus being used for the environmental sensors, but also the UART for CO[2]
    measurements and four pins for PWM output.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们只需要很多连接到继电器等设备的GPIO引脚，以便我们可以打开或关闭加热阀。这就是这个模块背后的原因。安装在天花板上的节点不仅使用于环境传感器的I2C总线，还用于CO[2]测量的UART和四个PWM输出引脚。
- en: As more GPIO was needed to turn the relays that controlled the valves on the
    water lines to the air-conditioning units on or off, a dedicated GPIO expander
    chip was added to the I2C bus to provide eight more GPIO pins.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要更多的GPIO来控制水线上空调单元的阀门的继电器的开关，因此在I2C总线上添加了专用的GPIO扩展芯片，以提供另外八个GPIO引脚。
- en: 'This module allows for an external service like the air-conditioning service
    to directly set these new GPIO pins as high or low:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块允许外部服务（如空调服务）直接将这些新的GPIO引脚设置为高电平或低电平：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This class wraps the MCP23008 I/O expander device, keeping a local copy of
    its direction, pull-up, and GPIO state registers for easy updating and control:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包装了MCP23008 I/O扩展器设备，保留了其方向、上拉和GPIO状态寄存器的本地副本，以便轻松更新和控制：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We keep a local copy of three registers on the I2C GPIO expander device—the
    I/O direction (`iodir`), pull-up register (`gppu`), and the pin I/O level (`gpio`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在I2C GPIO扩展器设备上保留了三个寄存器的本地副本——I/O方向（`iodir`），上拉寄存器（`gppu`）和引脚I/O电平（`gpio`）：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We again define a number of commands in the form of an enumeration, along with
    one for the pin direction of the GPIO expander:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次以枚举的形式定义了一些命令，以及GPIO扩展器的引脚方向。
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Initializing and starting the module is similar to the PWM module, with us registering
    an MQTT topic to receive commands on. The difference here is that since we are
    using an I2C device, we have to make sure that the I2C functionality has been
    started already.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化和启动模块与PWM模块类似，我们注册一个MQTT主题以接收命令。不同之处在于，由于我们使用的是I2C设备，因此我们必须确保I2C功能已经启动。
- en: 'Next, we address the command-processing method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理命令处理方法：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Its protocol looks as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其协议如下：
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '**命令** | **含义** | **有效负载** | **返回值** |'
- en: '| 0x01 | Start the module | uint8 I2C address offset (0-7, optional) | 0x010x00/0x01
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: 0x01 | 启动模块 | uint8 I2C地址偏移（0-7，可选）| 0x010x00/0x01 |
- en: '| 0x02 | Stop the module | - | 0x020x00/0x01 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: 0x02 | 停止模块 | - | 0x020x00/0x01 |
- en: '| 0x04 | Returns I/O mode, pull-up, and level state | - | 0x040x00/0x01 (result)uint8
    (iodir register)uint8 (gppu register)uint8 (gpio register) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: 0x04 | 返回I/O模式，上拉和电平状态 | - | 0x040x00/0x01（结果）uint8（iodir寄存器）uint8（gppu寄存器）uint8（gpio寄存器）|
- en: '| 0x08 | Set a pin to a specific mode (In/Out) | uint8 (pin number, 0 - 7)uint8
    (0: output, 1: input) | 0x080x00/0x01 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: 0x08 | 将引脚设置为特定模式（输入/输出）| uint8（引脚编号，0-7）uint8（0：输出，1：输入）| 0x080x00/0x01 |
- en: '| 0x10 | Set a pin''s pull-up resistor (Low/High) | uint8 (pin number, 0 -
    7)uint8 (pin pull-up state, 0/1) | 0x100x00/0x01 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: 0x10 | 设置引脚的上拉电阻（低/高）| uint8（引脚编号，0-7）uint8（引脚上拉状态，0/1）| 0x100x00/0x01 |
- en: '| 0x20 | Set a pin to either Low or High | uint8 (pin number, 0-7)uint8 (pin
    state, 0/1) | 0x20 0x00/0x01 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: 0x20 | 将引脚设置为低电平或高电平 | uint8（引脚编号，0-7）uint8（引脚状态，0/1）| 0x20 0x00/0x01 |
- en: '| 0x40 | Read the current pin value (Low, High) | uint8 (pin number) | 0x40
    0x00/0x01 uint8 (pin number) uint8 (pin value) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: 0x40 | 读取当前引脚值（低，高）| uint8（引脚编号）| 0x40 0x00/0x01 uint8（引脚编号）uint8（引脚值）|
- en: '| 0x80 | Return whether this module has been initialized | - | 0x80 0x00/0x01
    uint8 (module state, 0/1). |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: 0x80 | 返回此模块是否已初始化 | - | 0x80 0x00/0x01 uint8（模块状态，0/1）|
- en: Similar to the protocol for the PWM module, either a Boolean value is returned
    to indicate success, or the requested payload is returned. We also return the
    command that was called in the response.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与PWM模块的协议类似，返回一个布尔值表示成功，或者返回请求的有效负载。我们还在响应中返回调用的命令。
- en: The command is a single byte, allowing for a maximum of eight commands since
    we are using bit flags. This could be extended to 256 commands if we wanted to.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令是一个字节，因为我们使用的是位标志，所以最多可以有八个命令。如果需要，可以将其扩展到256个命令。
- en: Possible improvements to this module's code include consolidating duplicated
    code into (inline) function calls and conceivably the use of a sub-class that
    would manage the setting and toggling of individual bits with a more higher-level
    API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块代码的可能改进包括将重复的代码合并为（内联）函数调用，以及可能使用子类来管理使用更高级API设置和切换单个位。
- en: Switch
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换
- en: 'Since each section of the office had its own central switch that would switch
    the water in the pipes that flowed to the FCUs, this had to be controllable from
    the backend server as well. Using a latching relay configuration, it was possible
    to both switch between heating and cooling configurations, as well as have a memory
    element that could be read out by the node:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于办公室的每个区域都有自己的中央开关，可以切换流向FCU的管道中的水，因此这也必须可以从后端服务器进行控制。使用闸门继电器配置，可以在加热和冷却配置之间进行切换，并且可以具有可以由节点读取的存储元素：
- en: 'This system was assembled on a single board that was used to replace the original
    manual switch, using the following module to control it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统是在一个单板上组装的，用于替换原始手动开关，使用以下模块来进行控制：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Its implementation is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其实现如下：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This module is very similar to the PWM and I/O modules, with the registering
    of an MQTT topic to allow communication using its own binary protocol. Here, the
    device that is being controlled is fairly simple. It is a latching relay with
    two sides, one of which is connected to the connections that are being switched
    between, while the other side is used as a one-bit memory cell.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块与PWM和I/O模块非常相似，注册了一个MQTT主题，以允许使用自己的二进制协议进行通信。在这里，被控制的设备相当简单。它是一个带有两个侧面的闸门继电器，其中一个侧面连接到正在切换的连接，而另一侧用作一位存储单元。
- en: As both sides of this type of relay will switch simultaneously, we can count
    on the side connected to the MCU to match the position of that on the side connected
    to the rest of the system. Even after a power failure or reset of the MCU, we
    can simply read out the values of the pins connected to the relay to find out
    the state of the system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种继电器的两侧将同时切换，因此我们可以指望连接到MCU的一侧与连接到系统其余部分的一侧的位置相匹配。即使在MCU断电或复位后，我们也可以简单地读取与继电器连接的引脚的值，以找出系统的状态。
- en: 'The resulting protocol looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的协议如下所示：
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **含义** | **有效负载** | **返回值** |'
- en: '| 0x01 | Switch to Position 1 | - | 0x010x00/0x01 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | 切换到位置1 | - | 0x010x00/0x01 |'
- en: '| 0x02 | Switch to Position 2 | - | 0x020x00/0x01 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | 切换到位置2 | - | 0x020x00/0x01 |'
- en: '| 0x04 | Return the current state | - | 0x040x00/0x01 (result)uint8 (active
    pin 0x00, 0x01) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | 返回当前状态 | - | 0x040x00/0x01（结果）uint8（活动引脚0x00、0x01）|'
- en: Command and control server
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令和控制服务器
- en: As alluded to earlier in this chapter, a so-called **command and control** (**C&C**)
    server is essentially a database containing information on individual nodes and
    their configuration, for use by the nodes themselves and administration tools
    like the one in the next section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面提到过，所谓的**命令和控制**（**C&C**）服务器本质上是一个包含有关各个节点及其配置信息的数据库，供节点自身和下一节中的管理工具使用。
- en: 'It also includes an HTTP server, for use with HTTP-based **over-the-air** (**OTA**)
    updates. Since the BMaC system is MQTT-based, this server is also written as an
    MQTT client:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包括一个HTTP服务器，用于支持基于HTTP的**空中**（**OTA**）更新。由于BMaC系统是基于MQTT的，因此该服务器也被编写为MQTT客户端：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We're using the Mosquitto C++ MQTT client along with the POCO framework to provide
    us with the required functionality.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Mosquitto C++ MQTT客户端以及POCO框架来为我们提供所需的功能。
- en: 'The `Listener` class is next:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Listener`类：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We include the headers from POCO for the SQLite database functionality, which
    forms the database backend for this application. The class itself derives from
    the Mosquitto C++ class, providing us with all the basic MQTT functionalities
    along with a few function stubs, which we still have to implement in a moment:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括POCO的头文件，用于SQLite数据库功能，它构成了该应用程序的数据库后端。该类本身派生自Mosquitto C++类，为我们提供了所有基本的MQTT功能以及一些函数存根，我们稍后还需要实现：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We define a structure for a single node:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为单个节点定义了一个结构：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the constructor, we attempt to connect to the MQTT broker, using the provided
    host and port. We also set up a connection with the SQLite database, and ensure
    that it has valid nodes and a firmware table:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们尝试连接到MQTT代理，使用提供的主机和端口。我们还建立与SQLite数据库的连接，并确保它具有有效的节点和固件表：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We reimplement the callback for when a connection has been established with
    the MQTT broker. In this method, we subscribe to all the MQTT topics in which
    we are interested.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新实现了当与MQTT代理建立连接时的回调。在这个方法中，我们订阅了所有我们感兴趣的MQTT主题。
- en: 'The next method is called whenever we receive an MQTT message on one of the
    topics which we subscribed to:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是每当我们在我们订阅的主题中接收到MQTT消息时调用的。
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We validate the payload we receive for each topic. For this first topic, we
    expect its payload to contain the MAC address of the node which wants to receive
    its configuration. We make sure that this seems to be the case, then continue:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证我们接收到的每个主题的有效负载。对于这个第一个主题，我们期望其有效负载包含想要接收其配置的节点的MAC地址。我们确保似乎是这种情况，然后继续：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We attempt to find the MAC address in the database, reading out the node's configuration
    if found and making it the payload for the return message.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试在数据库中找到MAC地址，如果找到，则读取节点的配置并将其作为返回消息的有效负载。
- en: 'The next topics are used with the administration tool:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的主题与管理工具一起使用：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the case of this payload string, we return the binary data for a map image
    that should exist in the local folder. This map contains the layout of the building
    we are administrating, for displaying in the tool.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此有效负载字符串，我们返回应存在于本地文件夹中的地图图像的二进制数据。该地图包含我们管理的建筑物的布局，用于在工具中显示。
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding section reads out every single node in the database and returns
    it in a binary, serialized format.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分读取数据库中的每个节点，并以二进制序列化格式返回。
- en: 'Next, we create a new node and add it to the database:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新节点并将其添加到数据库中：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Updating a node''s configuration is also possible:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以更新节点的配置：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we look at the topic handler for deleting a node''s configuration:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下删除节点配置的主题处理程序：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we looked at the CO[2] module of the firmware earlier, we saw that it
    generated CO[2] events. These also end up here in this example, in order to generate
    events in JSON format, which we send to some HTTP-based API. We then use the HTTPS
    client in POCO to send this JSON to the remote server (here set to localhost):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前查看固件的CO[2]模块时，我们发现它生成了CO[2]事件。这些事件也会在这个示例中出现，以便以JSON格式生成事件，然后将其发送到一些基于HTTP的API。然后，我们使用POCO中的HTTPS客户端将此JSON发送到远程服务器（此处设置为localhost）。
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, for managing the stored firmware images, we can use the following topic.
    Which node uses which firmware version can be set in each node's configuration,
    though as we saw earlier, the default is to use the latest firmware.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了管理存储的固件映像，我们可以使用以下主题。每个节点的配置中可以设置节点使用哪个固件版本，尽管如前所述，默认情况是使用最新的固件。
- en: 'Using this topic, we can list the available firmware images or upload a new
    one:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个主题，我们可以列出可用的固件映像或上传新的固件：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: On each successful MQTT topic subscription, this method is called, allowing
    us to do something else if needed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次成功的MQTT主题订阅时，将调用此方法，允许我们在需要时执行其他操作。
- en: 'Next, we look at the HTTP server component, starting with the HTTP request
    handler factory:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下HTTP服务器组件，从HTTP请求处理程序工厂开始：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This handler will always return an instance of the following class:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序将始终返回以下类的实例：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This class looks fairly impressive, yet mostly does just an SQLite database
    lookup for the node ID (MAC address) and returns the appropriate firmware image
    if found.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类看起来相当令人印象深刻，但大部分只是对节点ID（MAC地址）进行SQLite数据库查找，并在找到时返回适当的固件映像。
- en: Administration tool
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理工具
- en: Using the APIs implemented by the C&C server, a GUI-based administration tool
    was created using the Qt5 framework and the Mosquitto MQTT client library was
    developed, allowing for the basic management of nodes. They were overlaid on top
    of a layout graphic of buildings.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C&C服务器实现的API，使用Qt5框架创建了基于GUI的管理工具，并开发了Mosquitto MQTT客户端库，允许对节点进行基本管理。它们被叠加在建筑物的布局图上。
- en: While basically usable, it was found that a graphical tool was fairly complicated
    to develop. It was also limited to a single floor of a building, unless one were
    to have a really large map containing all of the floors with the nodes mapped
    onto this. This would have been quite clumsy, obviously.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基本上可用，但发现开发图形工具相当复杂。除非有一个包含所有楼层的大地图，并将节点映射到该地图上，否则它也仅限于建筑物的单个楼层。显然，这将非常笨拙。
- en: In the source code provided with this chapter, the administration tool can be
    found as well, to serve as an example of how one could implement it. For the sake
    of brevity, the code for it has been omitted here.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章提供的源代码中，还可以找到管理工具，作为如何实现的示例。为了简洁起见，这里省略了其代码。
- en: Air-conditioning service
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空调服务
- en: 'To control air-conditioning units, a service much like the C&C one was developed,
    using the same basic template. The interesting parts of its source are the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制空调设备，开发了一个类似C&C的服务，使用相同的基本模板。其源代码的有趣部分如下：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The definition for this class in the AC service gives a good overview of the
    functionality of this class. It's essentially a wrapper around an SQLite database,
    containing information on nodes, valves, and cooling/heating switches. It also
    contains the timers that will keep triggering the application to check the status
    of the system, to compare it to the target state, and to make adjustments if necessary.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: AC服务中对该类的定义很好地概述了该类的功能。它基本上是围绕一个SQLite数据库的封装，包含有关节点、阀门和冷却/加热开关的信息。它还包含将持续触发应用程序以检查系统状态、将其与目标状态进行比较并在必要时进行调整的定时器。
- en: 'This class is used extensively by the `Listener` class of this application
    for keeping track of the status of nodes and the connected AC units, along with
    those switches and valves controlling the water flow:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被这个应用程序的`Listener`类广泛使用，用于跟踪节点和连接的空调单元的状态，以及控制水流的开关和阀门：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The way that this application works is that the `Nodes` class timers will cause
    the `Listener` class to publish on the topics for the PWM, IO, and Switch modules,
    inquiring about the state of the devices that are supposed to be active.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的工作方式是，`Nodes`类的定时器将导致`Listener`类发布PWM、IO和Switch模块的主题，查询应该处于活动状态的设备的状态。
- en: This kind of active loop system is common in industrial applications, as it
    provides constant validation of the system to detect quickly if something isn't
    working as intended.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的主动循环系统在工业应用中很常见，因为它提供了对系统的持续验证，以快速检测是否有任何不按预期工作的情况。
- en: InfluxDB for recording sensor readings
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于记录传感器读数的InfluxDB
- en: Recording the sensor readings and later the statistics read from the coffee
    machines was a priority from the beginning. The ideal database for this kind of
    data is a time series database, of which Influx is a common one. The biggest problem
    with this database is that it does not support MQTT, only offering its HTTP and
    native interface.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，记录传感器读数以及后来从咖啡机读取的统计数据就是一个优先任务。这种数据的理想数据库是时间序列数据库，Influx是其中一个常见的数据库。这个数据库的最大问题是它不支持MQTT，只提供其HTTP和本地接口。
- en: 'To fix this, a simple MQTT-to-Influx HTTP line protocol bridge was written,
    again using the Mosquitto client library as well as the POCO framework''s HTTP
    functionality:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，编写了一个简单的MQTT到Influx HTTP线协议桥，再次使用Mosquitto客户端库以及POCO框架的HTTP功能：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the constructor, we connect to the MQTT broker, and create either an HTTP
    or HTTPS client, depending on which protocol has been set in the configuration
    file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们连接到MQTT代理，并创建一个HTTP或HTTPS客户端，具体取决于配置文件中设置的协议：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Instead of fixed MQTT topics to subscribe to, we use the topics that are defined
    in the configuration file, here provided to us as a single string with each topic
    separated by a comma.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用固定的MQTT主题进行订阅，而是使用在配置文件中定义的主题，这里以单个字符串的形式提供给我们，每个主题之间用逗号分隔。
- en: We also create an STL map containing the name of the time series to record for
    the topic, taking the final part of the MQTT topic after the last slash. One could
    make this further configurable, but for the topics used in the BMaC system this
    limitation was no consideration as it not necessary to have more complex topics.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建一个STL映射，其中包含要记录的主题的时间序列的名称，取自最后一个斜杠后的MQTT主题的最后部分。这可以进一步配置，但对于BMaC系统中使用的主题来说，这个限制并不是一个考虑，因为没有必要使用更复杂的主题。
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When we get a new MQTT message in, we find the name of the Influx time series
    for it, then create a string to send to the InfluxDB server. The assumption here
    is that the payload consists of the MAC address of the node which sent the message
    followed by a semi-colon.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到一个新的MQTT消息时，我们找到它对应的Influx时间序列的名称，然后创建一个字符串发送到InfluxDB服务器。这里的假设是负载包括发送消息的节点的MAC地址，后跟一个分号。
- en: We simply get the part after the semi-colon to set it as the value, and use
    the MAC as the location. This we then send to the database server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需获取分号后的部分设置为值，并使用MAC作为位置。然后我们将其发送到数据库服务器。
- en: Security aspects
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全方面
- en: During the development of this system it became soon obvious that security would
    be a paramount aspect of the system. For that reason we looked at adding transport
    layer security (TLS) encryption. This would use the integrated axTLS encryption
    library in the Sming framework together with AES certificates (host and client)
    to provide both verification that the host (servers) and clients (nodes) are who
    they say they are, but also provide a secure encrypted link.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发这个系统的过程中，很快就显而易见的是安全将是系统的一个重要方面。因此，我们考虑添加传输层安全（TLS）加密。这将使用Sming框架中集成的axTLS加密库，以及AES证书（主机和客户端）来提供主机（服务器）和客户端（节点）是他们所说的人的验证，同时提供一个安全的加密链接。
- en: In [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, we already looked at the handling of these client
    certificates and setting up of an encrypted MQTT connection. One detail which
    is not obvious from that were the troubles which we encountered while setting
    up this certificate system. As mentioned in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, the ESP8266 does not have enough memory to allocate
    the default TLS handshake buffers and requires the use of the SSL fragment size
    extension on the side of the server (host).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中，*示例-带Wi-Fi的土壤湿度监测器*，我们已经看到了如何处理这些客户端证书并建立加密的MQTT连接。从中并不明显的一个细节是我们在设置这个证书系统时遇到的麻烦。正如在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中提到的，*示例-带Wi-Fi的土壤湿度监测器*，ESP8266没有足够的内存来分配默认的TLS握手缓冲区，并且需要在服务器（主机）端使用SSL片段大小扩展。
- en: Unfortunately we found that the commonly used MQTT broker we were using (Mosquitto)
    did not support this SSL extension and would therefore require that clients used
    the default double 16 kB buffer. The first solution to this would be to recompile
    the Mosquitto broker after making a few changes to its source code to change this
    setting.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们发现我们使用的常用MQTT代理（Mosquitto）不支持这个SSL扩展，因此需要客户端使用默认的双16 kB缓冲区。解决这个问题的第一个方法是在对其源代码进行一些更改后重新编译Mosquitto代理以更改此设置。
- en: The better solution and the one which we ultimately implemented was to install
    a proxy software (HAProxy) which functioned as the TLS endpoint, handling the
    certificates and redirecting the decrypted traffic to the MQTT broker via the
    local loopback (localhost) interface.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案，也是我们最终实施的解决方案，是安装一个代理软件（HAProxy），它作为TLS端点，处理证书并通过本地回环（localhost）接口将解密的流量重定向到MQTT代理。
- en: With the SSL fragment size option set to 1-2 kB everything worked as intended
    and we had a building-wide, wireless monitoring and control system that allowed
    for secure communications of sensitive information and delicate control commands.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将SSL片段大小选项设置为1-2 kB后，一切都按预期工作，我们拥有了一个覆盖整栋建筑的无线监控和控制系统，可以安全地传输敏感信息和精密的控制命令。
- en: Future developments
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来发展
- en: There are still many additions that can be made to this system. From the number
    of sensors that could be supported, further GPIO expander chips, air-conditioning
    system configurations, room occupancy detection linked into a calendar backend,
    to clearing out scheduled meetings at an office where nobody showed up, and so
    on.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统仍然可以进行许多补充。从可以支持的传感器数量，进一步的GPIO扩展芯片，空调系统配置，与日历后端连接的房间占用检测，到清除在没有人出现的办公室预定会议等等。
- en: There is also the option of switching from ESP8266 as the MCU to a different
    one, such as ARM-based MCUs, to get wired Ethernet options, along with better
    debug and development tools. As convenient as it is to have an MCU with Wi-Fi,
    which one can just stick anywhere and theoretically have it work, the development
    tools for the ESP8266 aren't that great, and the lack of wired communication options
    (without using external chips) means that everything either works or doesn't depending
    on the quality of the Wi-Fi network.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选择，从ESP8266作为MCU切换到其他MCU，比如基于ARM的MCU，以获得有线以太网选项，以及更好的调试和开发工具。虽然将MCU与Wi-Fi结合在一起非常方便，可以随处粘贴并在理论上使其工作，但ESP8266的开发工具并不是那么好，而且缺乏有线通信选项（不使用外部芯片）意味着一切要么工作要么不工作，取决于Wi-Fi网络的质量。
- en: As BMaC involves the automation of a building, it is desirable to have a certain
    level of reliability, which is hard to guarantee with a Wi-Fi network, though
    for less crucial components (coffee machine statistics, sensor readings, and so
    on) this is unlikely to be an issue. Conceivably a hybrid network with both wired
    and wireless options could be the future.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BMaC涉及建筑物的自动化，因此希望具有一定的可靠性，而通过Wi-Fi网络很难保证这一点，尽管对于较不重要的组件（咖啡机统计数据、传感器读数等），这可能不是一个问题。可以想象未来可能会出现既有有线选项又有无线选项的混合网络。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how a building-wide monitoring and management
    system was developed, what its components looked like, and what lessons were learned
    during its development.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何开发了一个建筑物范围的监控和管理系统，它的组件是什么样的，以及在开发过程中学到了什么教训。
- en: The reader is expected to understand now how such a large-scale embedded system
    is constructed and functions, and should be able either to use the BMaC system
    themselves or implement a similar system.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 读者现在应该理解这样一个大规模嵌入式系统是如何构建和运行的，并且应该能够自己使用BMaC系统或实施类似的系统。
- en: In the next chapter we will look at developing embedded projects using the Qt
    framework.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍使用Qt框架开发嵌入式项目。
