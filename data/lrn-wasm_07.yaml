- en: Creating an Application from Scratch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始创建一个应用程序
- en: Now it's time to apply your knowledge! Since one of WebAssembly's primary design
    goals is to execute within and integrate well with the existing web platform,
    it makes sense to build a web application to test it out. Even though WebAssembly's
    current feature set is rather limited, we can utilize the technology at a basic
    level. In this chapter, we will build a single-page application from scratch that
    utilizes Wasm modules within the context of the *Core Specification*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是应用你的知识的时候了！由于WebAssembly的主要设计目标之一是在现有的Web平台内执行并与之很好地集成，因此构建一个Web应用程序来测试它是有意义的。即使WebAssembly的当前功能集相当有限，我们仍然可以在基本水平上利用这项技术。在本章中，我们将从头开始构建一个单页应用程序，该应用程序在*核心规范*的上下文中利用Wasm模块。
- en: 'By the end of this chapter, you''ll know how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将知道如何：
- en: Write functions that perform simple computations with C
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写使用C执行简单计算的函数
- en: Build a basic JavaScript application with Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue构建一个基本的JavaScript应用程序
- en: Integrate Wasm into your JavaScript application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Wasm集成到您的JavaScript应用程序中
- en: Identify the capabilities and limitations of WebAssembly in its current form
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定WebAssembly在当前形式下的能力和限制
- en: Run and test a JavaScript application using `browser-sync`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`browser-sync`运行和测试JavaScript应用程序
- en: Cook the Books – making WebAssembly accountable
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cook the Books – 使WebAssembly负责
- en: As mentioned before, WebAssembly's current feature set is rather limited. We
    can use Emscripten to greatly extend the capabilities of a web application, but
    that carries the cost of noncompliance with the official specification and the
    addition of glue code. We can still use WebAssembly effectively today, which brings
    us to the application we'll build in this chapter. In this section, we will review
    the libraries and tools we'll use to build the application, as well as a brief
    overview of its functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，WebAssembly的当前功能集相当有限。我们可以使用Emscripten大大扩展Web应用程序的功能，但这会带来与官方规范的不兼容以及添加粘合代码的成本。我们仍然可以有效地使用WebAssembly，这就是我们将在本章中构建的应用程序。在本节中，我们将回顾构建应用程序所使用的库和工具，以及其功能的简要概述。
- en: Overview and functionality
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述和功能
- en: 'In WebAssembly''s current form, we can pass numbers between a Wasm module and
    JavaScript code with relative ease. An accounting application seems like a logical
    choice in terms of real-world applicability. The only contention I have with accounting
    software is that it''s a little boring (no offense). We''re going to *spice it
    up* a bit by building in some unethical accounting practices. The application
    is named *Cook the Books*, a term associated with accounting fraud. Investopedia
    provides the following definition of Cook the Books:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebAssembly的当前形式中，我们可以相对容易地在Wasm模块和JavaScript代码之间传递数字。在现实世界中，会计应用程序似乎是一个合乎逻辑的选择。我对会计软件唯一的争议是它有点无聊（无意冒犯）。我们将通过一些不道德的会计实践来*调味*一下。该应用程序被命名为*Cook
    the Books*，这是与会计欺诈相关的术语。Investopedia提供了对Cook the Books的以下定义：
- en: '"Cook the Books is an idiom describing fraudulent activities performed by corporations
    in order to falsify their financial statements. Typically, cooking the books involves
    augmenting financial data to yield previously nonexistent earnings. Examples of
    techniques used to cook the books involve accelerating revenues, delaying expenses,
    manipulating pension plans, and implementing synthetic leases."'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '"Cook the Books是一个成语，用来描述公司为了伪造其财务报表而进行的欺诈活动。通常，Cook the Books涉及增加财务数据以产生以前不存在的收益。用于Cook
    the Books的技术示例包括加速收入，延迟支出，操纵养老金计划以及实施合成租赁。"'
- en: 'The Investopedia page at [https://www.investopedia.com/terms/c/cookthebooks.asp](https://www.investopedia.com/terms/c/cookthebooks.asp)
    offers detailed examples of what constitutes cooking the books. We''ll take a
    simple approach for our application. We will allow the user to enter a transaction
    with a raw and cooked amount. The raw amount represents the actual amount of money
    that was either deposited or withdrawn, while the cooked amount is what everyone
    else will see. The application will generate pie charts that display expenses
    and income by category for either the raw or cooked transactions. The user will
    be able to easily toggle between the two views. The application consists of the
    following components:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Investopedia页面[https://www.investopedia.com/terms/c/cookthebooks.asp](https://www.investopedia.com/terms/c/cookthebooks.asp)提供了构成Cook
    the Books的详细示例。我们将为我们的应用程序采取简单的方法。我们将允许用户输入一个交易，包括原始金额和虚假金额。原始金额代表实际存入或取出的金额，而虚假金额是其他人看到的金额。该应用程序将生成显示原始或虚假交易的按类别显示支出和收入的饼图。用户可以轻松地在两种视图之间切换。该应用程序包括以下组件：
- en: Tabs for switching between transactions and charts
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在交易和图表之间切换的选项卡
- en: Table that displays transactions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示交易的表格
- en: Buttons that allow a user to add, edit, or remove a transaction
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户添加、编辑或删除交易的按钮
- en: Modal dialog for adding/updating a transaction
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于添加/更新交易的模态对话框
- en: Pie charts to display the income/expenses by category
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示按类别的收入/支出的饼图
- en: JavaScript libraries used
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用的JavaScript库
- en: The JavaScript portion of the application will use several libraries served
    from a CDN. It will also use one locally installed library to watch for changes
    in the code. The following sections will describe each library and its purpose
    in the application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的JavaScript部分将使用从CDN提供的几个库。它还将使用一个本地安装的库来监视代码的更改。以下各节将描述每个库及其在应用程序中的目的。
- en: Vue
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue
- en: Vue is a JavaScript framework that allows you to split an application into individual
    components for ease of development and debugging. We're using it to avoid having
    one monolithic JavaScript file with all of our application logic and another monolithic
    HTML file with the entire UI. Vue was chosen because it doesn't require the added
    complexity of a build system and allows us to use HTML, CSS, and JavaScript without
    having to do any transpiling. The official website is [https://vuejs.org](https://vuejs.org).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Vue是一个JavaScript框架，允许您将应用程序拆分为单独的组件，以便于开发和调试。我们使用它来避免一个包含所有应用程序逻辑的单片JavaScript文件和另一个包含整个UI的单片HTML文件。选择Vue是因为它不需要构建系统的额外复杂性，并且允许我们在不进行任何转换的情况下使用HTML、CSS和JavaScript。官方网站是[https://vuejs.org](https://vuejs.org)。
- en: UIkit
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UIkit
- en: UIkit is the frontend framework we will use to add styling and layout to our
    application. There are dozens of alternatives, like Bootstrap or Bulma, that offer
    comparable components and functionality. But I chose UIkit because of the helpful
    utility classes and added JavaScript functionality. You can view the documentation
    at [https://getuikit.com](https://getuikit.com).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: UIkit是我们将用来为应用程序添加样式和布局的前端框架。有数十种替代方案，如Bootstrap或Bulma，它们提供了类似的组件和功能。但我选择了UIkit，因为它具有有用的实用类和附加的JavaScript功能。您可以在[https://getuikit.com](https://getuikit.com)上查看文档。
- en: Lodash
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lodash
- en: Lodash is an excellent utility library that provides methods for performing
    common actions in JavaScript that aren't already built into the language. We will
    use it to perform calculations and manipulate the transactions data. Documentation
    and installation instructions can be found at [https://lodash.com](https://lodash.com).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Lodash是一个出色的实用程序库，提供了在JavaScript中执行常见操作的方法，这些方法在语言中尚未内置。我们将使用它来执行计算和操作交易数据。文档和安装说明可以在[https://lodash.com](https://lodash.com)找到。
- en: Data-driven documents
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据驱动文档
- en: '**Data-driven documents** (**D3**) is a multi-faceted library that allows you
    to translate data into impressive visualizations. D3''s API consists of several
    modules that range from array manipulation to charting and transitions. We will
    use D3 primarily to create the pie charts, but we''ll also take advantage of some
    of the utility methods it provides. You can find more information at [https://d3js.org](https://d3js.org).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据驱动文档**（**D3**）是一个多功能库，允许您将数据转化为令人印象深刻的可视化效果。D3的API由几个模块组成，从数组操作到图表和过渡。我们将主要使用D3来创建饼图，但我们也将利用它提供的一些实用方法。您可以在[https://d3js.org](https://d3js.org)找到更多信息。'
- en: Other libraries
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他库
- en: In order to display currency values in the correct format and ensure the user
    enters a valid dollar amount, we will utilize the **accounting.js** ([http://openexchangerates.github.io/accounting.js](http://openexchangerates.github.io/accounting.js))
    and **vue-numeric** ([https://kevinongko.github.io/vue-numeric](https://kevinongko.github.io/vue-numeric))
    libraries. To simplify development, we'll set up a basic `npm` project and use
    **browser-sync** ([https://www.browsersync.io](https://www.browsersync.io)) to
    immediately see code changes reflected in the running application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以正确的格式显示货币值并确保用户输入有效的美元金额，我们将利用**accounting.js**（[http://openexchangerates.github.io/accounting.js](http://openexchangerates.github.io/accounting.js)）和**vue-numeric**（[https://kevinongko.github.io/vue-numeric](https://kevinongko.github.io/vue-numeric)）库。为了简化开发，我们将设置一个基本的`npm`项目，并使用**browser-sync** （[https://www.browsersync.io](https://www.browsersync.io)）来立即看到运行应用程序中的代码更改。
- en: C and the build process
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C和构建过程
- en: The application uses C since we're performing simple calculations with basic
    algebra. It wouldn't make sense to use C++ in this case. That would introduce
    the added step of ensuring the functions we need to call from JavaScript are wrapped
    in an `extern` block. We'll write the calculation functions in a single C file
    and compile it down to a single Wasm module. We can continue to use VS Code's
    Tasks functionality to perform the build, but the arguments will need to be updated
    since we'll only compile a single file. Let's move on to project configuration.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序使用C，因为我们正在进行基本代数的简单计算。在这种情况下使用C++是没有意义的。这将引入一个额外的步骤，确保我们需要从JavaScript调用的函数被包装在`extern`块中。我们将在一个单独的C文件中编写计算函数，并将其编译成一个单独的Wasm模块。我们可以继续使用VS
    Code的任务功能来执行构建，但是参数将需要更新，因为我们只编译一个文件。让我们继续进行项目配置。
- en: Setting up the project
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: WebAssembly hasn't been around long enough to have established best practices
    with regard to folder structure, file naming conventions, and so on. If you were
    to search for best practices for C/C++ or JavaScript projects, you'd encounter
    a great deal of conflicting advice and strongly held opinions. With that in mind,
    let's spend this section setting up our project with the required configuration
    files.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly还没有存在足够长的时间来建立关于文件夹结构、文件命名约定等方面的最佳实践。如果您搜索C/C++或JavaScript项目的最佳实践，您会遇到大量相互矛盾的建议和坚定的观点。考虑到这一点，让我们在本节中花时间设置我们的项目所需的配置文件。
- en: The code for this project is located in the `/chapter-07-cook-the-books` folder
    in the `learn-webassembly` repository. You must have this code available when
    we get to the JavaScript portion of the application. I won't be providing the
    source code for all of the Vue components in the book, so you need to copy them
    from the repository.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码位于`learn-webassembly`存储库中的`/chapter-07-cook-the-books`文件夹中。当我们进行应用程序的JavaScript部分时，您必须拥有此代码。我不会提供书中所有Vue组件的源代码，因此您需要从存储库中复制它们。
- en: Configuring for Node.js
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Node.js配置
- en: In the interest of keeping the application as simple as possible, we'll avoid
    a build/bundling tool like Webpack or Rollup.js. This allows us to cut down on
    the number of required dependencies and ensures that any issues you run into aren't
    caused by a breaking change in a build dependency.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能保持应用程序的简单性，我们将避免使用Webpack或Rollup.js等构建/捆绑工具。这样可以减少所需的依赖项数量，并确保您遇到的任何问题都不是由构建依赖项的重大更改引起的。
- en: 'We''ll create a Node.js project because it allows us to run scripts and install
    a dependency locally for development purposes. We''ve used the `/book-examples`
    folder up to this point, but we''ll create a new project folder outside of `/book-examples`
    to configure a different default build task in VS Code. Open a terminal, `cd`
    into the desired folder, and enter the following commands:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Node.js项目，因为它允许我们运行脚本并为开发目的本地安装依赖项。到目前为止，我们使用了`/book-examples`文件夹，但我们将在`/book-examples`之外创建一个新的项目文件夹，以配置VS
    Code中不同的默认构建任务。打开终端，`cd`到所需的文件夹，并输入以下命令：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `-y` command forgoes the prompts and populates the `package.json` file
    with sensible defaults. Once completed, run the following command to install `browser-sync`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`-y`命令跳过提示，并使用合理的默认值填充`package.json`文件。完成后，运行以下命令安装`browser-sync`：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `-D` is optional and indicates that the library is a development dependency.
    You would use the `-D` flag if you were building and distributing the application,
    so I included it to adhere to common practice. I''d recommend installing that
    specific version to ensure the `start` script runs without any issues. After `browser-sync`
    installs, add the following entry to the `scripts` entry in the `package.json`
    file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`-D`是可选的，表示该库是开发依赖项。如果您正在构建和分发应用程序，您将使用`-D`标志，因此我包含它以遵循常见做法。我建议安装特定版本以确保`start`脚本可以正常运行。安装完`browser-sync`后，将以下条目添加到`package.json`文件中的`scripts`条目中：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run `npm init` with the `-y` flag, there should be an existing script
    named `test`, which I omitted for clarity. If you didn't run it with the `-y`
    flag, you may need to create the `scripts` entry.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`-y`标志运行`npm init`，应该会有一个名为`test`的现有脚本，为了清晰起见，我省略了它。如果您没有使用`-y`标志运行它，您可能需要创建`scripts`条目。
- en: 'You can populate the `"description"` and `"author"` keys if desired. The file
    should end up looking similar to this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以填写`"description"`和`"author"`键。文件最终应该看起来类似于这样：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you omit the `--no-open` flag from the `start` script, the browser will open
    automatically. The flag was included to prevent issues with users running in a
    headless environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从`start`脚本中省略了`--no-open`标志，浏览器将自动打开。该标志被包含在其中以防止用户在无头环境中运行时出现问题。
- en: Adding files and folders
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加文件和文件夹
- en: 'Create two new folders within the root folder: `/lib` and `/src`. The JavaScript,
    HTML, CSS, and Wasm files will be located in the `/src` folder while the C file
    will be in `/lib`. I only want to include files that are used by the web application
    in `/src`. We''ll never use the C file directly from the application, only the
    compiled output.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在根文件夹中创建两个新文件夹：`/lib`和`/src`。JavaScript、HTML、CSS和Wasm文件将位于`/src`文件夹中，而C文件将位于`/lib`文件夹中。我只想在`/src`中包含Web应用程序使用的文件。我们永远不会直接从应用程序中使用C文件，只会使用编译后的输出。
- en: Copy the `/.vscode` folder from your `/book-examples` project into the root
    folder. This will ensure you're using the existing C/C++ settings and give you
    a good starting point for the build task.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将`/book-examples`项目中的`/.vscode`文件夹复制到根文件夹中。这将确保您使用现有的C/C++设置，并为构建任务提供一个良好的起点。
- en: If you're using macOS or Linux, you'll have to use the terminal to copy the
    folder; you can accomplish this by running the `cp -r command`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS或Linux，您将需要使用终端来复制文件夹；您可以通过运行`cp -r`命令来实现这一点。
- en: Configuring the build step
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置构建步骤
- en: 'We need to modify the default build step in the `/.vscode/tasks.json` file
    to accommodate our updated workflow. The arguments for the build step we used
    in our `/book-examples` project allowed us to compile whichever file was currently
    active in the editor. It also output the `.wasm` file into the same folder as
    the source C file. However, this configuration doesn''t make sense for this project.
    We''ll always compile the same C file that is output to the compiled `.wasm` file
    in a specific folder. To accomplish this, update the `args` array in the `Build`
    task in `/.vscode/tasks.json` with the following contents:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`/.vscode/tasks.json`文件中的默认构建步骤，以适应我们更新后的工作流。我们在`/book-examples`项目中使用的构建步骤的参数允许我们编译当前在编辑器中活动的任何文件。它还将`.wasm`文件输出到与源C文件相同的文件夹中。然而，这个配置对于这个项目来说是没有意义的。我们将始终编译相同的C文件，并将输出到特定文件夹中的编译后的`.wasm`文件。为了实现这一点，在`/.vscode/tasks.json`中的`Build`任务的`args`数组中更新为以下内容：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We changed the input and output paths, which are the first and last elements
    in the `args` array. Now both are static paths that always compile and output
    the same files regardless of which file is open in the active editor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改了输入和输出路径，它们是`args`数组中的第一个和最后一个元素。现在两者都是静态路径，无论打开的是哪个文件，都会编译和输出相同的文件。
- en: Setting up a mock API
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置模拟API
- en: 'We need some mock data and a means of persisting any updates. If you store
    the data locally in a JSON file, any changes you make to the transactions will
    be lost as soon as you refresh the page. We could set up a local server with a
    library like Express, mock a database, write routes, and so on. But instead we''re
    going to take advantage of the excellent development tooling available online.
    The online too jsonstore.io is allows you to store JSON data for small projects
    and provides endpoints out of the box. Take the following steps to get your mock
    API up and running:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些模拟数据和一种持久化任何更新的方法。如果您将数据存储在本地的JSON文件中，那么您对交易所做的任何更改都将在刷新页面后丢失。我们可以使用Express这样的库来设置一个本地服务器，模拟一个数据库，编写路由等等。但是，相反地，我们将利用在线可用的优秀开发工具。在线工具jsonstore.io允许您为小型项目存储JSON数据，并提供开箱即用的端点。按照以下步骤来启动和运行您的模拟API：
- en: Navigate to [https://www.jsonstore.io/](https://www.jsonstore.io/) and press
    the Copy button to copy the endpoint to your clipboard; this is the endpoint you'll
    be making HTTP requests to.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://www.jsonstore.io/](https://www.jsonstore.io/)并点击复制按钮将端点复制到剪贴板；这是您将发出HTTP请求的端点。
- en: Go to the JSFiddle at [https://jsfiddle.net/mikerourke/cta0km6d](https://jsfiddle.net/mikerourke/cta0km6d),
    paste your jsonstore.io endpoint into the input, and press the Populate Data button.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到JSFiddle网站[https://jsfiddle.net/mikerourke/cta0km6d](https://jsfiddle.net/mikerourke/cta0km6d)，将您的jsonstore.io端点粘贴到输入中，然后按“填充数据”按钮。
- en: Open up a new tab and paste your jsonstore.io endpoint in the address bar and
    add `/transactions` to the end of the URL and press *Enter*. If you see the contents
    of the JSON file in your browser, the API setup was successful.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新标签，并在地址栏中粘贴您的jsonstore.io端点，然后在URL的末尾添加`/transactions`，然后按*Enter*。如果您在浏览器中看到JSON文件的内容，则API设置成功。
- en: Keep that jsonstore.io endpoint handy—you'll need it when we build the JavaScript
    portion of the app.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将jsonstore.io端点保持方便——在构建应用程序的JavaScript部分时会用到它。
- en: Downloading the C stdlib Wasm
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载C stdlib Wasm
- en: We need the `malloc()` and `free()` functions from C's standard library for
    the functionality in our C code. WebAssembly doesn't have these functions built
    in, so we need to provide our own implementation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要C标准库中的`malloc()`和`free()`函数来实现我们C代码中的功能。WebAssembly没有内置这些函数，因此我们需要提供自己的实现。
- en: Fortunately, someone has already built that for us; we just need to download
    the module and include it in the instantiation step. The module can be downloaded
    from Guy Bedford's `wasm-stdlib-hack` GitHub repository at [https://github.com/guybedford/wasm-stdlib-hack](https://github.com/guybedford/wasm-stdlib-hack).
    You need the `memory.wasm` file from the `/dist` folder. Once the file is downloaded,
    create a folder named `/assets` in the `/src` folder of your project and copy
    the `memory.wasm` file there.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有人已经为我们构建了这个；我们只需要下载模块并将其包含在实例化步骤中。该模块可以从Guy Bedford的`wasm-stdlib-hack`
    GitHub存储库[https://github.com/guybedford/wasm-stdlib-hack](https://github.com/guybedford/wasm-stdlib-hack)中下载。您需要从`/dist`文件夹中下载`memory.wasm`文件。下载文件后，在项目的`/src`文件夹中创建一个名为`/assets`的文件夹，并将`memory.wasm`文件复制到其中。
- en: You can copy the `memory.wasm` file from the `/chapter-07-cook-the-books/src/assets`
    folder of the `learn-webassembly` repository instead of downloading it from GitHub.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`learn-webassembly`存储库的`/chapter-07-cook-the-books/src/assets`文件夹中复制`memory.wasm`文件，而不是从GitHub上下载它。
- en: The final result
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终结果
- en: 'After performing these steps, your project should look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些步骤后，您的项目应如下所示：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building the C portion
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建C部分
- en: The C portion of the application will aggregate transaction and category amounts.
    The calculations we perform in C could be done just as easily in JavaScript, but
    WebAssembly is ideal for computation. We'll dive deeper into more complex usage
    of C/C++ in [Chapter 8](384a3356-a9ca-4c3c-99e7-e632c6228a0b.xhtml), *Porting
    a Game with Emscripten*, but for now we're trying to limit our scope to what can
    be done within the confines of the *Core Specification*. In this section, we'll
    write some C code to demonstrate how to integrate WebAssembly with a web application
    without the use of Emscripten.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的C部分将聚合交易和类别金额。我们在C中执行的计算可以很容易地在JavaScript中完成，但WebAssembly非常适合计算。我们将在第8章《使用Emscripten移植游戏》中深入探讨C/C++的更复杂用法，但现在我们试图限制我们的范围，以符合“核心规范”的限制。在本节中，我们将编写一些C代码，以演示如何在不使用Emscripten的情况下将WebAssembly与Web应用程序集成。
- en: Overview
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We will write some C functions that calculate the grand totals as well as the
    ending balances for raw and cooked transactions. In addition to calculating the
    grand totals, we need to calculate the totals for each category for display in
    the pie charts. All of these calculations will be performed in a single C file
    and compiled down to a single Wasm file that will be instantiated when the application
    loads. C can be a little daunting for the uninitiated, so our code will be sacrificing
    some efficiency for the sake of clarity. I'd like to take a moment to apologize
    to the C/C++ programmers reading this book; you're not going to like what you
    C.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一些C函数，用于计算原始和烹饪交易的总额以及结余。除了计算总额外，我们还需要计算每个类别的总额，以在饼图中显示。所有这些计算将在单个C文件中执行，并编译为单个Wasm文件，该文件将在应用程序加载时实例化。对于未经培训的人来说，C可能有点令人生畏，因此为了清晰起见，我们的代码将牺牲一些效率。我想抽出一点时间向阅读本书的C/C++程序员道歉；你们可能不会喜欢你们所看到的C代码。
- en: In order to perform calculations dynamically, we need to allocate and deallocate
    memory as transactions are added and deleted. To accomplish this, we'll use a
    **doubly linked list**. A doubly linked list is a data structure that allows us
    to remove items or *nodes* inside a list and add and edit nodes as needed. Nodes
    are added using `malloc()` and removed using `free()`, both of which are provided
    by the `memory.wasm` module you downloaded in the previous section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动态执行计算，我们需要在添加和删除交易时分配和释放内存。为此，我们将使用**双向链表**。双向链表是一种数据结构，允许我们在列表内部删除项目或*节点*，并根据需要添加和编辑节点。节点使用`malloc()`添加，使用`free()`删除，这两者都是在上一节中下载的`memory.wasm`模块提供的。
- en: A note regarding workflow
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于工作流程的说明
- en: The order of operations in terms of development doesn't reflect how you would
    normally build an application that uses WebAssembly. The workflow would consist
    of jumping between C/C++ and JavaScript to achieve the desired results. In this
    case, the functionality that we're offloading from JavaScript into WebAssembly
    is already known, so we'll write the C code up front.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 开发操作的顺序并不反映通常构建使用WebAssembly的应用程序的方式。工作流程将包括在C/C++和JavaScript之间跳转，以实现所需的结果。在这种情况下，我们从JavaScript中转移到WebAssembly的功能已经知道，因此我们将首先编写C代码。
- en: C file contents
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C文件内容
- en: Let's walk through each section of the C file. Create a file in the `/lib` folder
    named `main.c` and populate it with the following contents in each section. It'll
    be easier to comprehend what's happening in the C file if we break it into smaller
    chunks. Let's start with the *Declarations *section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个讨论C文件的每个部分。在`/lib`文件夹中创建一个名为`main.c`的文件，并在每个部分中填充以下内容。如果我们将其分成较小的块，那么更容易理解C文件中发生的事情。让我们从*声明*部分开始。
- en: Declarations
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明
- en: 'The first section contains declarations we will use to create and traverse
    the doubly linked list, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含我们将用于创建和遍历双向链表的声明，如下所示：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Node` struct is used to represent a transaction or category. The `transactionsHead`
    and `categoriesHead` node instances represent the first node in each linked list
    we'll use (one for transactions and one for categories). The `AmountType` the `enum`
    isn't required, but we'll discuss how it's useful when we get to the section of
    code that utilizes it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`结构用于表示交易或类别。`transactionsHead`和`categoriesHead`节点实例表示我们将使用的每个链表中的第一个节点（一个用于交易，一个用于类别）。`AmountType`枚举不是必需的，但当我们到达使用它的代码部分时，我们将讨论它的用途。'
- en: Linked list operations
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表操作
- en: 'The second section contains the two functions used to add and delete nodes
    from the linked list:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含用于向链表中添加和删除节点的两个函数：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The comments within the code describe what's happening at each step. When we
    need to add a Node to the list, we have to allocate the memory taken up by the
    `struct` `Node` using `malloc()` and append it to the last node in the linked
    list. If we need to delete a node, we have to remove it from the linked list and
    deallocate the memory that the node was using by calling the `free()` function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的注释描述了每个步骤发生的情况。当我们需要向列表中添加一个节点时，我们必须使用`malloc()`分配`struct` `Node`占用的内存，并将其附加到链表中的最后一个节点。如果我们需要删除一个节点，我们必须从链表中删除它，并通过调用`free()`函数释放节点使用的内存。
- en: transactions operations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易操作
- en: 'The third section contains functions to add, edit, and remove transactions
    from the `transactions` linked list, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含用于向`transactions`链表中添加、编辑和删除交易的函数，如下所示：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `appendNode()` and `deleteNode()` functions we reviewed in the previous
    section aren't intended to be called from the JavaScript code. Instead, calls
    to `addTransaction()`, `editTransaction()`, and `removeTransaction()` are used
    to update the local linked list. The `addTransaction()` function calls the `appendNode()`
    function to add the data passed in as arguments to a new node in the local linked
    list. The `removeTransaction()` calls the `deleteNode()` function to delete the
    corresponding transaction node. The `findNodeById()` function is used to determine
    which node needs to be updated or deleted within the linked list based on the
    specified ID.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一部分中审查的`appendNode()`和`deleteNode()`函数并不打算从JavaScript代码中调用。相反，调用`addTransaction()`、`editTransaction()`和`removeTransaction()`用于更新本地链表。`addTransaction()`函数调用`appendNode()`函数将传递的数据添加到本地链表中的新节点中。`removeTransaction()`调用`deleteNode()`函数删除相应的交易节点。`findNodeById()`函数用于根据指定的ID确定需要在链表中更新或删除的节点。
- en: transactions calculations
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易计算
- en: 'The fourth section contains functions to calculate the grand totals and final
    balances for raw and cooked `transactions`, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分包含用于计算原始和处理后`transactions`的总额和最终余额的函数，如下所示：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `AmountType enum` we declared in the declarations section is used here to
    avoid **magic numbers**. It makes it easy to remember that `1` represents raw
    transactions and `2` represents cooked transactions. The grand totals for both
    raw and cooked transactions are calculated in the `calculateGrandTotals()` function,
    even though we're only asking for one type in `getGrandTotalForType()`. Since
    we can only return a single value from a Wasm function, we end up looping through
    all of the transactions twice when we call `getGrandTotalForType()` for both raw
    and cooked transactions. With a relatively small amount of transactions and the
    simplicity of the calculation, this doesn't present any issues. The `getFinalBalanceForType()`
    returns the grand total plus the specified `initialBalance`. You'll see this in
    action when we add the ability to change initial balances in the web application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在声明部分中声明的`AmountType enum`在这里用于避免**魔术数字**。这使得很容易记住`1`代表原始交易，`2`代表处理后的交易。原始和处理后的交易的总额都是在`calculateGrandTotals()`函数中计算的，即使在`getGrandTotalForType()`中只请求一个类型。由于我们只能从Wasm函数中返回一个值，当我们为原始和处理后的交易都调用`getGrandTotalForType()`时，我们最终会循环遍历所有交易两次。对于相对较少的交易量和计算的简单性，这并不会产生任何问题。`getFinalBalanceForType()`返回指定`initialBalance`加上总额。当我们在Web应用程序中添加更改初始余额的功能时，您将看到这一点。
- en: Category calculations
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别计算
- en: 'The fifth and final section contains functions to calculate totals by category,
    which we''ll utilize in the pie charts, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第五和最后一部分包含用于按类别计算总额的函数，我们将在饼图中使用，如下所示：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `buildValuesByCategoryList()` function is called whenever the `recalculateForCategories()`
    or `getCategoryTotal()` functions are called. The function loops through all of
    the transactions in the `transactions` linked list and creates a node in a separate
    linked list for each corresponding category with the aggregated raw and total
    amounts. The `upsertCategoryNode()` function looks for a node that corresponds
    to the `categoryId` in the `categories` linked list. If it finds it, the raw and
    cooked transaction amounts are added to the existing amounts on that node, otherwise
    a new node is created for said category. The `recalculateForCategories()` function
    is called to ensure the category totals are up to date with any transactions changes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用`recalculateForCategories()`或`getCategoryTotal()`函数时，都会调用`buildValuesByCategoryList()`函数。该函数循环遍历`transactions`链表中的所有交易，并为每个对应的类别创建一个节点，其中包含聚合的原始和总金额。`upsertCategoryNode()`函数在`categories`链表中查找与`categoryId`对应的节点。如果找到，则将原始和处理后的交易金额添加到该节点上的现有金额中，否则为该类别创建一个新节点。调用`recalculateForCategories()`函数以确保类别总额与任何交易更改保持最新。
- en: Compiling to Wasm
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译为Wasm
- en: After populating the file, we need to compile it down to Wasm for use in the
    JavaScript portion of the application. Run the build task by selecting Tasks |
    Run Build Task... from the menu or using the keyboard shortcut *Cmd*/*Ctrl* +
    *Shift* + *B*. If the build was successful, you'll see a file named `main.wasm`
    in the `/src/assets` folder. If an error occurred, the terminal should provide
    details on how to resolve it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 填充文件后，我们需要将其编译为Wasm，以便在应用程序的JavaScript部分中使用。通过从菜单中选择任务 | 运行构建任务... 或使用键盘快捷键*Cmd*/*Ctrl*
    + *Shift* + *B*来运行构建任务。如果构建成功，您将在`/src/assets`文件夹中看到一个名为`main.wasm`的文件。如果出现错误，终端应提供有关如何解决错误的详细信息。
- en: 'If you''re not using VS Code, open a terminal instance in the `/cook-the-books`
    folder and run the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用VS Code，请在`/cook-the-books`文件夹中打开终端实例，并运行以下命令：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That's it for the C code. Let's move on to the JavaScript portion.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: C代码就是这样。让我们继续进行JavaScript部分。
- en: Building the JavaScript portion
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建JavaScript部分
- en: The JavaScript portion of the application presents the transactions data to
    the user and allows them to easily add, edit, and remove transactions. The application
    is split across several files to simplify the development process and uses the
    libraries described in the *JavaScript libraries used* section of this chapter.
    In this section, we will build the application step by step, starting with the
    API and global state interaction layer. We'll write functions to instantiate and
    interact with our Wasm module and review the Vue components required to build
    the user interface.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的JavaScript部分向用户呈现交易数据，并允许他们轻松添加、编辑和删除交易。该应用程序分为几个文件，以简化开发过程，并使用本章节中描述的库。在本节中，我们将逐步构建应用程序，从API和全局状态交互层开始。我们将编写函数来实例化和与我们的Wasm模块交互，并审查构建用户界面所需的Vue组件。
- en: Overview
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: The application is broken down into contexts to simplify the development process.
    We'll build the application from the bottom up to ensure we don't have to bounce
    back and forth between the different contexts when writing code. We'll start with
    the Wasm interaction code, then move on to the global store and API interaction.
    I'll describe the purpose of each Vue component, but the source code will only
    be provided for a select few. If you're following along and wish to run the application
    locally, you'll need to copy the `/src/components` folder from the `/chapter-07-cook-the-books`
    folder in the `learn-webassembly` repository into the `/src` folder of your project.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序被分解为上下文，以简化开发过程。我们将从底层开始构建应用程序，以确保在编写代码时不必在不同的上下文之间来回跳转。我们将从Wasm交互代码开始，然后转向全局存储和API交互。我将描述每个Vue组件的目的，但只会为少数几个提供源代码。如果您正在跟随并希望在本地运行应用程序，则需要将`learn-webassembly`存储库中`/chapter-07-cook-the-books`文件夹中的`/src/components`文件夹复制到您的项目的`/src`文件夹中。
- en: A note about browser compatibility
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于浏览器兼容性的说明
- en: Before we start writing any code, you must ensure your browser supports the
    newer JavaScript features we'll use in the application. Your browser has to support
    ES Modules (`import` and `export`), the Fetch API, and `async` / `await`. You
    need at least Version 61 of Google Chrome or Version 60 of Firefox. You can check
    which version you're currently using by selecting About Chrome or About Firefox
    from the menu bar. I'm currently running the application with Chrome Version 67
    and Firefox Version 61 without any issues.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写任何代码之前，您必须确保您的浏览器支持我们将在应用程序中使用的较新的JavaScript功能。您的浏览器必须支持ES模块（`import`和`export`）、Fetch
    API和`async`/`await`。您至少需要Google Chrome的版本61或Firefox的版本60。您可以通过从菜单栏中选择关于Chrome或关于Firefox来检查您当前使用的版本。我目前正在使用Chrome版本67和Firefox版本61运行应用程序，没有任何问题。
- en: Creating a Wasm instance in initializeWasm.js
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在initializeWasm.js中创建一个Wasm实例
- en: 'You should have two compiled Wasm files in the `/src/assets` folder of your
    project: `main.wasm` and `memory.wasm`. Since we need to utilize the `malloc()`
    and `free()` functions exported from `memory.wasm` in the `main.wasm` code, our
    loading code is going to look different from the earlier examples. Create a file
    in the `/src/store` folder named `initializeWasm.js` and populate it with the
    following contents:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目的`/src/assets`文件夹中应该有两个编译好的Wasm文件：`main.wasm`和`memory.wasm`。由于我们需要在`main.wasm`代码中使用从`memory.wasm`导出的`malloc()`和`free()`函数，我们的加载代码将与之前的示例有所不同。在`/src/store`文件夹中创建一个名为`initializeWasm.js`的文件，并填充以下内容：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The file''s default `export` function, `initializeWasm()`, performs the following
    steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的默认`export`函数`initializeWasm()`执行以下步骤：
- en: Create a new `WebAssembly.Memory` instance (`wasmMemory`).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`WebAssembly.Memory`实例（`wasmMemory`）。
- en: Call the `fetchAndCompileModules()` function to get a `WebAssembly.Module` instance
    for `memory.wasm` (`compiledMemory`) and `main.wasm` (`compiledMain`).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fetchAndCompileModules()`函数以获取`memory.wasm`（`compiledMemory`）和`main.wasm`（`compiledMain`）的`WebAssembly.Module`实例。
- en: Instantiate `compiledMemory` (`memoryInstance`) and pass the `wasmMemory` into
    the `importObj`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`compiledMemory`（`memoryInstance`）并将`wasmMemory`传递给`importObj`。
- en: Pass `compiledMain`, `memoryInstance`, and `wasmMemory` into the `instantiateMain()`
    function.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`compiledMain`、`memoryInstance`和`wasmMemory`传递给`instantiateMain()`函数。
- en: Instantiate `compiledMain` and pass the exported `malloc()` and `free()` functions
    from `memoryInstance` along with `wasmMemory` into the `importObj`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`compiledMain`并将从`memoryInstance`导出的`malloc()`和`free()`函数以及`wasmMemory`传递给`importObj`。
- en: Return the `exports` property of the `Instance` returned from `instantiateMain`
    (`mainInstance`).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回从`instantiateMain`返回的`Instance`的`exports`属性。
- en: As you can see, the process is more complex when you have dependencies within
    Wasm modules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当Wasm模块内部存在依赖关系时，该过程更加复杂。
- en: You may have noticed that the `malloc` and `free` methods on the `memoryInstance` `exports`
    property weren't prefixed with an underscore. This is because the `memory.wasm`
    file was compiled using LLVM without Emscripten, which doesn't add the `_`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到`memoryInstance`的`exports`属性上的`malloc`和`free`方法没有用下划线前缀。这是因为`memory.wasm`文件是使用LLVM而不是Emscripten编译的，后者不会添加下划线。
- en: Interacting with Wasm in WasmTransactions.js
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WasmTransactions.js中与Wasm交互
- en: 'We will use JavaScript''s `class` syntax to create a wrapper that encapsulates
    the Wasm interaction functions. This allows us to make changes to the C code quickly
    without having to search through the entire application to find where Wasm functions
    are being called. If you rename a method in the C file, you only need to rename
    it one place. Create a new file in the `/src/store` folder named `WasmTransactions.js`
    and populate it with the following contents:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JavaScript的`class`语法来创建一个封装Wasm交互函数的包装器。这使我们能够快速更改C代码，而无需搜索整个应用程序以找到调用Wasm函数的位置。如果您在C文件中重命名一个方法，您只需要在一个地方重命名它。在`/src/store`文件夹中创建一个名为`WasmTransactions.js`的新文件，并填充以下内容：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the `initialize()` function is called on an instance of the class, the
    return value of the `initializeWasm()` function is assigned to the `instance`
    property of the class. The `class` methods call functions from `this.instance`
    and, if applicable, return the desired results. Note the `AMOUNT_TYPE` object
    referenced in the `getCurrentBalances()` and `getCategoryTotals()` functions.
    This corresponds to the `AmountType enum` in our C file. The `AMOUNT_TYPE` object
    is declared globally in the `/src/main.js` file where the application is loaded.
    Now that we have our Wasm interaction code written, let's move on to API interaction
    code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当对类的实例调用`initialize（）`函数时，`initializeWasm（）`函数的返回值被分配给类的`instance`属性。`class`方法调用`this.instance`中的函数，并在适用的情况下返回所需的结果。请注意`getCurrentBalances（）`和`getCategoryTotals（）`函数中引用的`AMOUNT_TYPE`对象。这对应于我们C文件中的`AmountType
    enum`。`AMOUNT_TYPE`对象在加载应用程序的`/src/main.js`文件中全局声明。现在我们已经编写了Wasm交互代码，让我们继续编写API交互代码。
- en: Utilizing the API in api.js
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在api.js中利用API
- en: 'The API provides means for adding, editing, removing, and querying transactions
    in the form of HTTP methods defined on a fetch call. To simplify the process of
    performing these actions, we''ll write some API `wrapper` functions. Create a
    file in the `/src/store` folder named `api.js` and populate it with the following
    contents:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: API提供了在fetch调用上定义的HTTP方法的方式来添加、编辑、删除和查询交易。为了简化执行这些操作的过程，我们将编写一些API“包装”函数。在`/src/store`文件夹中创建一个名为`api.js`的文件，并填充以下内容：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You'll need the jsonstore.io endpoint you created in the *Setting up the project*
    section in order to interact with the API. Replace `[JSONSTORE.IO ENDPOINT]` with
    your jsonstore.io endpoint. Ensure the endpoint doesn't end with a forward slash
    or the word transactions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在*设置项目*部分创建的jsonstore.io端点才能与API交互。将`[JSONSTORE.IO ENDPOINT]`替换为您的jsonstore.io端点。确保端点不以斜杠或单词transactions结尾。
- en: Managing global state in store.js
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在store.js中管理全局状态
- en: The file that manages global state in the application has a lot of moving parts.
    Consequently, we will break the code down into smaller chunks and walk through
    each section individually. Create a file in the `/src/store` folder named `store.js`
    and populate it with the contents from each of the following sections.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中管理全局状态的文件有很多组成部分。因此，我们将代码分解成较小的块，并逐个部分地进行讲解。在`/src/store`文件夹中创建一个名为`store.js`的文件，并填充以下各部分的内容。
- en: The import and store declarations
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和存储声明
- en: 'The first section contains `import` statements and the `wasm` and `state` properties
    on the exported `store` object, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含`import`语句和导出的`store`对象上的`wasm`和`state`属性，如下所示：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All API interaction is limited to the `store.js` file. Since we need to manipulate,
    add, and search transactions, all of the exported functions from `api.js` are
    imported. The `store` object holds the `WasmTransactions` instance in the `wasm`
    property and initial state in the `state` property. The values in `state` are
    referenced in multiple locations throughout the application. The `store` object
    will be added to the global `window` object when the application loads, so all
    components have access to the global state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有API交互都限于`store.js`文件。由于我们需要操作、添加和搜索交易，所以从`api.js`导出的所有函数都被导入。`store`对象在`wasm`属性中保存了`WasmTransactions`实例，并在`state`属性中保存了初始状态。`state`中的值在应用程序的多个位置引用。当应用程序加载时，`store`对象将被添加到全局`window`对象中，因此所有组件都可以访问全局状态。
- en: Transactions operations
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易操作
- en: 'The second section contains functions that manage transactions in the Wasm
    instance (through the `WasmTransactions` instance) and the API, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含管理Wasm实例（通过`WasmTransactions`实例）和API中的交易的函数，如下所示：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `populateTransactions()` function fetches all of the transactions from the
    API and loads them into the global state and the Wasm instance. The category names
    are extrapolated from the `transactions` array in the `getCategories()` function.
    The results are passed to the `WasmTransactions` instance when `store.wasm.populateInWasm()`
    is called.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: populateTransactions（）函数从API中获取所有交易，并将它们加载到全局状态和Wasm实例中。类别名称是从`getCategories（）`函数中的`transactions`数组中推断出来的。当调用`store.wasm.populateInWasm（）`时，结果将传递给`WasmTransactions`实例。
- en: The `addTransaction()`, `editTransaction()`, and `removeTransaction()` functions
    perform the actions that correspond with their names. All three functions manipulate
    the Wasm instance and update the data on the API through a fetch call. Each of
    the functions call `this.hideTransactionModal()` because changes to a transaction
    can only be made through the `TransactionModal` component. Once the change is
    successfully made, the modal should close. Let's look at the `TransactionModal`
    management code next.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTransaction()`、`editTransaction()`和`removeTransaction()`函数执行与它们的名称相对应的操作。所有三个函数都操作Wasm实例，并通过fetch调用更新API上的数据。每个函数都调用`this.hideTransactionModal()`，因为只能通过`TransactionModal`组件对交易进行更改。一旦更改成功，模态应该关闭。接下来让我们看一下`TransactionModal`管理代码。'
- en: TransactionModal management
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易模态管理
- en: 'The third section contains functions to manage the visibility and content of
    the `TransactionModal` component (located in `/src/components/TransactionsTab/TransactionModal.js`)
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含管理`TransactionModal`组件（位于`/src/components/TransactionsTab/TransactionModal.js`）的可见性和内容的函数，如下所示：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `showTransactionModal()` and `hideTransactionModal()` functions should be
    self-explanatory. The `hide()` or `show()` method of `UIkit.modal()` is called
    on the DOM element representing the `TransactionModal`. The `getActiveTransaction()`
    function returns the transaction record associated with the `activeTransactionId`
    value in global state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`showTransactionModal()`和`hideTransactionModal()`函数应该是不言自明的。在代表`TransactionModal`的DOM元素上调用`UIkit.modal()`的`hide()`或`show()`方法。`getActiveTransaction()`函数返回与全局状态中的`activeTransactionId`值相关联的交易记录。'
- en: Balances calculation
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 余额计算
- en: 'The fourth section contains functions that calculate and update the balances
    object in global state:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分包含计算和更新全局状态中`balances`对象的函数：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `updateInitialBalance()` function sets the property value in the `balances`
    object in global state based on the `amount` and `fieldName` arguments. The `recalculateBalances()`
    function updates all of the fields on the `balances` object to reflect any changes
    made to the initial balances or transactions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateInitialBalance()`函数根据`amount`和`fieldName`参数设置全局状态中`balances`对象的属性值。`recalculateBalances()`函数更新`balances`对象上的所有字段，以反映对初始余额或交易所做的任何更改。'
- en: Store initialization
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储初始化
- en: 'The final section of code in the file initializes the store:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的最后一部分代码初始化了存储：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `initializeStore()` function instantiates the Wasm module, fetches all transactions
    from the API, and populates the contents of state. This function is called from
    the application loading code in `/src/main.js`, which we'll cover in the next
    section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeStore()`函数实例化Wasm模块，从API获取所有交易，并填充状态的内容。这个函数是从`/src/main.js`中的应用程序加载代码中调用的，我们将在下一节中介绍。'
- en: Loading the application in main.js
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在main.js中加载应用程序
- en: 'We need an entry point to load our application. Create a file in the `/src`
    folder named `main.js` and populate it with the following contents:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个入口点来加载我们的应用程序。在`/src`文件夹中创建一个名为`main.js`的文件，并填充以下内容：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This file is loaded after the libraries are fetched and loaded from CDNs in
    `/src/index.html`. We use the global `Vue` object to specify that we want to use
    the `VueNumeric` component. We add the `store` object exported from `/store/store.js`
    to `window` as `$store`. This isn't the most robust solution, but will be sufficient
    given the scope of the application. If you were creating a production application,
    you'd use a library like **Vuex** or **Redux** for global state management. We'll
    forego this approach in the interest of keeping things simple.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是在从`/src/index.html`中的CDN中获取和加载库之后加载的。我们使用全局的`Vue`对象来指定我们要使用`VueNumeric`组件。我们将从`/store/store.js`导出的`store`对象添加到`window`中作为`$store`。这不是最健壮的解决方案，但在应用程序的范围内将足够。如果你正在创建一个生产应用程序，你会使用像**Vuex**或**Redux**这样的库来进行全局状态管理。出于简化的目的，我们将放弃这种方法。
- en: We also added `AMOUNT_TYPE` to the `window` object. This was done to ensure
    the entire application can reference the `AMOUNT_TYPE` value, rather than specify
    a magic number. After values are assigned to `window`, the `initializeStore()`
    function is called. If the `initializeStore()` function fired successfully, a
    new `Vue` instance is created to render the application. Let's add the web assets
    next, then move on to the Vue components.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`AMOUNT_TYPE`添加到`window`对象中。这样做是为了确保整个应用程序可以引用`AMOUNT_TYPE`值，而不是指定一个魔术数字。在将值分配给`window`之后，将调用`initializeStore()`函数。如果`initializeStore()`函数成功触发，将创建一个新的`Vue`实例来渲染应用程序。接下来让我们添加web资源，然后转向Vue组件。
- en: Adding the web assets
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加web资源
- en: 'Before we start adding Vue components to the application, let''s create the
    HTML and CSS files that house our markup and styles. Create a file in the `/src`
    folder named `index.html` and populate it with the following contents:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向应用程序添加Vue组件之前，让我们创建包含我们标记和样式的HTML和CSS文件。在`/src`文件夹中创建一个名为`index.html`的文件，并填充以下内容：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''re only using the HTML file to fetch libraries from CDNs, specify a `<div>`
    that Vue can render to, and load `main.js` to start the application. Note the
    `type="module"` attribute on the final `<script>` element. This allows us to use
    ES modules throughout our application. Now let''s add the CSS file. Create a file
    in the `/src` folder named `styles.css` and populate it with the following contents:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用HTML文件从CDN中获取库，指定Vue可以渲染的`<div>`，并加载`main.js`来启动应用程序。请注意最后一个`<script>`元素上的`type="module"`属性。这允许我们在整个应用程序中使用ES模块。现在让我们添加CSS文件。在`/src`文件夹中创建一个名为`styles.css`的文件，并填充以下内容：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This file has only a few classes because most of the styling will be handled
    at the component level. In the next section, we'll review the Vue components that
    make up our application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件只有几个类，因为大部分的样式将在组件级别处理。在下一节中，我们将回顾构成我们应用程序的Vue组件。
- en: Creating the Vue components
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Vue组件
- en: With Vue, we can create separate components that encapsulate their own functionality,
    then compose these components to build an application. This makes debugging, extensibility,
    and change management much easier than storing the application in a single monolithic
    file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue，我们可以创建单独的组件，封装其自身的功能，然后组合这些组件来构建应用程序。这比将应用程序存储在单个庞大文件中更容易进行调试、扩展和变更管理。
- en: 'The application uses a single-component-per-file development methodology. Before
    we start reviewing the component files, let''s look at the finished product. The
    following screenshot is of the application with the TRANSACTIONS tab selected:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序使用单文件组件开发方法。在开始审查组件文件之前，让我们看看最终产品。以下屏幕截图显示了选择了TRANSACTIONS选项卡的应用程序：
- en: '![](img/5fd7ee43-480d-4d13-8b0c-370bd2f851ba.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fd7ee43-480d-4d13-8b0c-370bd2f851ba.png)'
- en: Running the application with TRANSACTIONS tab visible
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TRANSACTIONS选项卡运行应用程序
- en: 'Here''s a screenshot of the application with the CHARTS tab selected:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用程序的屏幕截图，选择了CHARTS选项卡：
- en: '![](img/593e5d7b-16ae-416e-91c6-a44a890d495c.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/593e5d7b-16ae-416e-91c6-a44a890d495c.png)'
- en: Running the application with the CHARTS tab visible
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CHARTS选项卡运行应用程序
- en: The structure of a Vue component
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue组件的结构
- en: 'A Vue component is simply a file with an exported object containing properties
    that define how that component should look and behave. The properties must be
    given names that adhere to the Vue API. You can read about these properties and
    other aspects of the Vue API at [https://vuejs.org/v2/api](https://vuejs.org/v2/api).
    The following code represents an example component containing the elements of
    the Vue API used in this application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Vue组件只是一个包含属性的导出对象文件，定义了该组件的外观和行为。这些属性必须具有符合Vue API的名称。您可以在[https://vuejs.org/v2/api](https://vuejs.org/v2/api)上阅读有关这些属性和Vue
    API的其他方面。以下代码代表包含此应用程序中使用的Vue API元素的示例组件：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The comments above each property describe its purpose, albeit at a very high
    level. Let's see Vue in action by reviewing the `App` component.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上面每个属性的注释描述了其目的，尽管在非常高的层次上。让我们通过审查`App`组件来看看Vue的实际运行情况。
- en: The App component
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: App组件
- en: 'The `App` component is the base component that renders all of the child components
    in the application. We''ll briefly review the `App` component''s code to gain
    a better understanding of Vue. Going forward, we''ll describe the role each remaining
    component plays, but only review sections of the corresponding code. The contents
    of the `App` component file, located at `/src/components/App.js`, are shown as
    follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件是渲染应用程序中所有子组件的基本组件。我们将简要审查`App`组件的代码，以更好地理解Vue。接下来，我们将描述每个剩余组件的作用，但只审查相应代码的部分。`App`组件文件的内容，位于`/src/components/App.js`，如下所示：'
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We use the `components` property to specify the other Vue components we''ll
    render in the `template` for the `App` component. The `data()` function, which
    returns the local state, is used to keep track of balances and which tab is active
    (TRANSACTIONS or CHARTS). The `methods` property contains two functions: `onTransactionChange()`
    and `onTabClick()`. The `onTransactionChange()` function calls `$store.recalculateBalances()`
    and updates `balances` in local state if a change is made to a transaction record.
    The `onTabClick()` function changes the value of `activeTab` in the local state
    to the `data-tab` attribute of the clicked tab. Finally, the `template` property
    contains the markup used to render the component.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`components`属性指定在`App`组件的`template`中渲染的其他Vue组件。`data()`函数返回本地状态，用于跟踪余额和活动的选项卡（TRANSACTIONS或CHARTS）。`methods`属性包含两个函数：`onTransactionChange()`和`onTabClick()`。`onTransactionChange()`函数调用`$store.recalculateBalances()`，如果对交易记录进行更改，则更新本地状态中的`balances`。`onTabClick()`函数将本地状态中的`activeTab`值更改为所点击选项卡的`data-tab`属性。最后，`template`属性包含用于渲染组件的标记。
- en: If you're not using single file components in Vue (`.vue` extension), you need
    to convert the component name to kebab case in the template property. For example,
    in the `App` component shown earlier, `BalancesBar` was changed to `<balances-bar>`
    in the `template`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Vue中不使用单文件组件（`.vue`扩展名），则需要将模板属性中的组件名称转换为kebab case。例如，在前面显示的`App`组件中，`BalancesBar`被更改为`<balances-bar>`。
- en: The BalancesBar
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BalancesBar
- en: 'The `/components/BalancesBar` folder contains two component files: `BalanceCard.js`
    and `BalancesBar.js`. The `BalancesBar` component persists across the TRANSACTIONS
    and CHARTS tabs and is located directly under the tab control. It contains four
    of the `BalanceCard` components, one for each balance type: initial raw, current
    raw, initial cooked, and current cooked. The first and third cards representing
    the initial balances contain inputs so the balance can be changed. The second
    and fourth cards representing the current balances are calculated dynamically
    in the Wasm module (using the `getFinalBalanceForType()` function). The following
    snippet, taken from the `BalancesBar` component, demonstrates Vue''s binding syntax:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`/components/BalancesBar`文件夹包含两个组件文件：`BalanceCard.js`和`BalancesBar.js`。`BalancesBar`组件跨越TRANSACTIONS和CHARTS选项卡，并直接位于选项卡控制下方。它包含四个`BalanceCard`组件，分别对应四种余额类型：初始原始、当前原始、初始熟练和当前熟练。代表初始余额的第一和第三张卡包含输入，因此余额可以更改。代表当前余额的第二和第四张卡在Wasm模块中动态计算（使用`getFinalBalanceForType()`函数）。以下代码片段来自`BalancesBar`组件，演示了Vue的绑定语法：'
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `:` preceding the `value` and `onChange` attributes indicate that these
    properties are bound to the Vue component. If the value of `balances.initialRaw`
    changes, the value displayed in the `BalanceCard` will update as well. The `onBalanceChange()`
    function for this card updates the value of `balances.initialRaw` in global state.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`和`onChange`属性之前的`:`表示这些属性绑定到了Vue组件。如果`balances.initialRaw`的值发生变化，`BalanceCard`中显示的值也会更新。此卡的`onBalanceChange()`函数会更新全局状态中`balances.initialRaw`的值。'
- en: The TransactionsTab
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TransactionsTab
- en: 'The `/components/TransactionsTab` folder contains the following four component
    files:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`/components/TransactionsTab`文件夹包含以下四个组件文件：'
- en: '`ConfirmationModal.js`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfirmationModal.js`'
- en: '`TransactionModal.js`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionModal.js`'
- en: '`TransactionsTab.js`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionsTab.js`'
- en: '`TransactionsTable.js`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionsTable.js`'
- en: 'The `TransactionsTab` component contains the `TransactionsTable` and `TransactionsModal`
    components, as well as a button used to add new transactions. Changes and additions
    are done through the `TransactionModal` component. The `TransactionsTable` contains
    all of the current transactions with buttons on each row to either edit or delete
    the transaction. If the user presses the Delete button, the `ConfirmationModal`
    component appears and prompts the user to proceed. If the user presses Yes, the
    transaction is deleted. The following snippet, taken from the `methods` property
    in the `TransactionsTable` component, demonstrates how display values are formatted:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransactionsTab`组件包含`TransactionsTable`和`TransactionsModal`组件，以及用于添加新交易的按钮。更改和添加是通过`TransactionModal`组件完成的。`TransactionsTable`包含所有当前的交易，每行都有按钮，可以编辑或删除交易。如果用户按下删除按钮，`ConfirmationModal`组件将出现并提示用户继续。如果用户按下“是”，则删除交易。以下摘录来自`TransactionsTable`组件的`methods`属性，演示了如何格式化显示值：'
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding `getFormattedTransactions()` function shown applies formatting
    to the `rawAmount`, `cookedAmount`, and `transactionDate` fields within each `transaction`
    record. This is done to ensure the value being displayed includes a dollar sign
    (for amounts) and is presented in a user-friendly format.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`getFormattedTransactions()`函数应用格式化到每个`transaction`记录中的`rawAmount`、`cookedAmount`和`transactionDate`字段。这样做是为了确保显示的值包括美元符号（对于金额）并以用户友好的格式呈现。
- en: The ChartsTab
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ChartsTab
- en: 'The `/components/ChartsTab` folder contains two component files: `ChartsTab.js`
    and `PieChart.js`. The `ChartsTab` component contains two instances of the `PieChart`
    component, one for income and one for expenses. Each `PieChart` component displays
    either the raw or cooked percentages by category. The user can switch between
    raw or cooked views via buttons directly above the chart. The `drawChart()` method
    in `PieChart.js` uses D3 to render the pie chart and legend. It uses D3''s built-in
    animations to animate each piece of the pie when loading:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`/components/ChartsTab`文件夹包含两个组件文件：`ChartsTab.js`和`PieChart.js`。`ChartsTab`组件包含两个`PieChart`组件的实例，一个用于收入，一个用于支出。每个`PieChart`组件显示按类别的原始或烹饪百分比。用户可以通过图表上方的按钮在原始或烹饪视图之间切换。`PieChart.js`中的`drawChart()`方法使用D3来渲染饼图和图例。它使用D3的内置动画在加载时对饼图的每个部分进行动画处理：'
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Running the application
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: You've written and compiled the C code and added the frontend logic. It's time
    to start the application and interact with it. In this section, we will validate
    your application's `/src` folder, run the application, and test out the features
    to ensure everything is working correctly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经编写并编译了C代码，并添加了前端逻辑。现在是时候启动应用程序并与之交互了。在本节中，我们将验证应用程序的`/src`文件夹，运行应用程序，并测试功能，以确保一切都正常工作。
- en: Validating the /src folder
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证/src文件夹
- en: 'Before starting the application, reference the following structure to ensure
    your `/src` folder is structured correctly and contains the following contents:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动应用程序之前，请参考以下结构，确保您的/src文件夹结构正确，并包含以下内容：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If everything matches up, you're ready to proceed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切匹配，您就可以继续了。
- en: Start it up!
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动它！
- en: 'To start the application, open up a terminal in the `/cook-the-books` folder
    and run the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动应用程序，请在`/cook-the-books`文件夹中打开终端并运行以下命令：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`browser-sync` the development dependency we installed in the first section
    of this chapter, acts as a local server (like the `serve` library). It makes the
    application accessible in the browser from the port specified in the `package.json`
    file (in this case, `4000`). If you navigate to `http://localhost:4000/index.html`
    in your browser, you should see this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`browser-sync`是我们在本章第一节安装的开发依赖项，它充当本地服务器（类似于`serve`库）。它使应用程序可以从`package.json`文件中指定的端口（在本例中为`4000`）在浏览器中访问。如果您在浏览器中导航到`http://localhost:4000/index.html`，您应该会看到这个：'
- en: '![](img/fc07674b-a7b5-4fd6-8593-6a0429558e2e.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc07674b-a7b5-4fd6-8593-6a0429558e2e.png)'
- en: Application on initial load
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 初始加载的应用程序
- en: We're using `browser-sync` instead of `serve` because it watches for changes
    in your files and automatically reloads the application if you make a change.
    To see this in action, try changing the contents of the title bar in `App.js`
    from `Cook the Books` to `Broil the Books`. The browser will refresh and you'll
    see the updated text in the title bar.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`browser-sync`而不是`serve`，因为它会监视文件的更改，并在您进行更改时自动重新加载应用程序。要看到它的效果，请尝试将`App.js`中标题栏的内容从`Cook
    the Books`更改为`Broil the Books`。浏览器将刷新，您将在标题栏中看到更新后的文本。
- en: Testing it out
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试一下
- en: To ensure everything is working correctly, let's test out the application. Each
    of the following sections describes an action and expected behavior for a particular
    function of the application. Follow along to see if you're getting the expected
    results. If you run into an issue, you can always refer back to the `/chapter-07-cook-the-books`
    folder in the `learn-webassembly` repository.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一切都正常工作，请测试一下应用程序。以下各节描述了应用程序特定功能的操作和预期行为。跟着操作，看看是否得到了预期结果。如果遇到问题，您可以随时参考`learn-webassembly`存储库中`/chapter-07-cook-the-books`文件夹。
- en: Changing initial balances
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改初始余额
- en: Try changing the input values on the INITIAL RAW BALANCE and INITIAL COOKED
    BALANCE `BalanceCard` components. The CURRENT RAW BALANCE and CURRENT COOKED BALANCE card
    values should update to reflect your changes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改“INITIAL RAW BALANCE”和“INITIAL COOKED BALANCE”`BalanceCard`组件上的输入值。当前的“CURRENT
    RAW BALANCE”和“CURRENT COOKED BALANCE”卡片数值应该更新以反映您的更改。
- en: Creating a new transaction
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新交易
- en: Make a note of the current raw and cooked balances, then press the blue Add
    button at the bottom-right corner of the window. It should load the `TransactionModal`
    component. Populate the inputs, make a note of the **Type**, **Raw Amount**, and
    **Cooked Amount** you entered, then press the Save button.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记下当前的原始和处理后的余额，然后按下窗口右下角的蓝色添加按钮。它应该加载`TransactionModal`组件。填写输入，记下**类型**，**原始金额**和**处理后的金额**，然后按保存按钮。
- en: 'The balances should have updated to reflect the new amounts. If you picked
    Withdrawal for the **Type**, the balances should decrease, otherwise, they increase
    (for Deposit) as shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 余额应该已经更新以反映新的金额。如果您选择了“提款”作为**类型**，则余额应该减少，否则，它们会增加（存款）如下截图所示：
- en: '![](img/dace2c59-c6f4-4039-ae01-3b6f3293777a.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dace2c59-c6f4-4039-ae01-3b6f3293777a.png)'
- en: TransactionModal when adding a new transaction
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新交易时的TransactionModal
- en: Deleting an existing transaction
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除现有交易
- en: 'Pick a row within the `TransactionsTable` component, note the amounts, and
    press the button that looks like a trash can for that record. The `ConfirmationModal`
    component should appear. When you press the **Yes** button, the transaction record
    should no longer be present in the table and the current balances should update
    to reflect the amounts associated with the deleted transaction as shown in the
    following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TransactionsTable`组件中选择一行，注意金额，然后按下该记录的垃圾桶按钮。`ConfirmationModal`组件应该出现。当您按下**是**按钮时，交易记录应该不再出现在表中，并且当前余额应该更新以反映与已删除交易相关的金额，如下截图所示：
- en: '![](img/850ece1d-3df5-4919-9380-e268ba3975b6.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/850ece1d-3df5-4919-9380-e268ba3975b6.png)'
- en: Confirmation modal shown after delete button is pressed
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下删除按钮后显示确认模态
- en: Editing an existing transaction
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑现有交易
- en: Follow the same procedure as you did for creating a new transaction, except
    change the existing amounts. Check the current balances to ensure they reflect
    the updated transaction amounts.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按照创建新交易的相同步骤，除了更改现有金额。检查当前余额以确保它们反映了更新后的交易金额。
- en: Testing the Charts tab
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试图表选项卡
- en: 'Select the Charts tab to load the `ChartsTab` component. Press the buttons
    in each `PieChart` component to switch between the raw and cooked views. The pie
    charts should re-render with the updated values:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“图表”选项卡以加载`ChartsTab`组件。按下每个`PieChart`组件中的按钮以在原始视图和处理后的视图之间切换。饼图应该重新渲染以显示更新后的值：
- en: '![](img/24cbe04a-2d49-49cb-9d5b-09cb6f6c3699.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24cbe04a-2d49-49cb-9d5b-09cb6f6c3699.png)'
- en: Contents of CHARTS tab with different amount types selected
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 选择CHARTS选项卡的内容，选择不同的金额类型
- en: Wrap up
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations, you just built an application that uses WebAssembly! Tell your
    friends! Now that you understand the capabilities and limitations of WebAssembly,
    it's time to expand our horizons and use some of the excellent features Emscripten
    provides.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您刚刚构建了一个使用WebAssembly的应用程序！告诉您的朋友！现在您了解了WebAssembly的能力和限制，是时候扩展我们的视野，并使用Emscripten提供的一些出色功能了。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built an accounting application from scratch that uses WebAssembly
    without any of the extra features Emscripten provides. By adhering to the *Core
    Specification*, we demonstrated the limitations of WebAssembly in its current
    form. However, we were able to perform computation quickly through the use of
    Wasm modules, which is well suited for accounting. We used Vue to split our application
    into components, UIkit for the design and layout, and D3 to create pie charts
    from our transactions data. In [Chapter 8](384a3356-a9ca-4c3c-99e7-e632c6228a0b.xhtml), *Porting
    a Game with Emscripten*, we'll take full advantage of Emscripten to port an existing
    C++ code base to WebAssembly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从头开始构建了一个会计应用程序，该应用程序使用WebAssembly而没有Emscripten提供的任何额外功能。通过遵守*核心规范*，我们展示了WebAssembly在其当前形式下的限制。然而，我们能够通过使用Wasm模块快速执行计算，这非常适合会计。我们使用Vue将应用程序拆分为组件，使用UIkit进行设计和布局，并使用D3从我们的交易数据创建饼图。在[第8章](384a3356-a9ca-4c3c-99e7-e632c6228a0b.xhtml)中，*使用Emscripten移植游戏*，我们将充分利用Emscripten将现有的C++代码库移植到WebAssembly。
- en: Questions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why did we use Vue for this application (instead of React or Angular)?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在这个应用程序中使用Vue（而不是React或Angular）？
- en: Why did we use C instead of C++ for this project?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在这个项目中使用C而不是C++？
- en: Why did we need to set up a mock API using jsonstore.io instead of storing the
    data locally in a JSON file?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要使用jsonstore.io设置一个模拟API，而不是在本地的JSON文件中存储数据？
- en: What is the name of the data structure we used for managing transactions in
    the C file?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在C文件中使用的数据结构的名称是什么？
- en: Which functions did we need from the `memory.wasm` file and what are they used
    for?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`memory.wasm`文件中需要哪些函数，它们用于什么？
- en: Why did we create a wrapper class around the Wasm module?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要在Wasm模块周围创建一个包装类？
- en: Why did we make the `$store` object global?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们将`$store`对象设为全局？
- en: Which libraries could you use in a production application for managing global
    state?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产应用程序中，您可以使用哪些库来管理全局状态？
- en: Why are we using `browser-sync`, instead of `serve`, to run the application?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么使用`browser-sync`而不是`serve`来运行应用程序？
- en: Further reading
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Vue: [https://vuejs.org](https://vuejs.org)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Vue: [https://vuejs.org](https://vuejs.org)'
