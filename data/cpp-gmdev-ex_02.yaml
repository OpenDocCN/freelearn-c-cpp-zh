- en: C++ Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 概念
- en: In this chapter, we will explore the basics of writing a C++ program. Here,
    we will cover just enough to wrap our heads around the capabilities of the C++
    programming language. This will be required to understand the code used in this
    book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨编写 C++ 程序的基础。在这里，我们将涵盖足够的内容，以便我们能够理解 C++ 编程语言的能力。这将有助于理解本书中使用的代码。
- en: 'To run the examples, use Visual Studio 2017\. You can download the community
    version for free at [https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，请使用 Visual Studio 2017。您可以在 [https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/)
    免费下载社区版：
- en: '![](img/db0f902d-4364-49e3-9ae1-534447c62654.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db0f902d-4364-49e3-9ae1-534447c62654.png)'
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Program basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序基础
- en: Variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: Statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句
- en: Iteration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代
- en: Functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Arrays and pointers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和指针
- en: '`Struct` and `Enum`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Struct` 和 `Enum`'
- en: Classes and inheritance
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和继承
- en: Program basics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序基础
- en: C++ is a programming language, but what exactly is a program? A program is a
    set of instructions executed in sequence to give a desired output.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 是一种编程语言，但究竟什么是程序？程序是一系列按顺序执行的指令，以产生期望的输出。
- en: 'Let''s look at our first program:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的第一个程序：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can look at this code line by line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以逐行查看此代码。
- en: The hash (`#`) `include` is used when we want to include anything that is using
    valid C++ syntax. In this case, we are including a standard C++ library in our
    program. The file we want to include is then specified inside the `<>` angle brackets.
    Here, we are including a file called `iostream.h`. This file handles the input
    and output of data to the console/screen.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要包含任何使用有效 C++ 语法的内容时，使用 `#` `include`。在这种情况下，我们正在将标准 C++ 库包含到我们的程序中。我们想要包含的文件指定在
    `<>` 角括号内。在这里，我们包含了一个名为 `iostream.h` 的文件。该文件处理数据到控制台/屏幕的输入和输出。
- en: On the second line, the `//` double slash marks the initiation of a code comment.
    Comments in code are not executed by the program. They are mainly to tell the
    person looking at the code what the code is currently doing. It is good practice
    to comment your code so that when you look at code you wrote a year ago, you will
    know what the code does.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，`//` 双斜杠标志着代码注释的开始。代码中的注释不会被程序执行。它们主要是为了告诉查看代码的人当前代码正在做什么。注释代码是一个好的实践，这样当你查看一年前写的代码时，你会知道代码的作用。
- en: Basically, `main()` is a function. We will cover functions shortly, but a `main`
    function is the first function that is executed in a program, also called the
    entry point. A function is used to perform a certain task. Here, the printing
    of `Hello, World` is tasked to the `main` function. The contents that need to
    be executed must be enclosed in the curly brackets of the function. The `int`
    preceding the `main()` keyword suggests that the function will return an integer.
    This is why we have returned 0 at the end of the main function, suggesting that
    the program can be executed and can terminate without errors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`main()` 是一个函数。我们将在稍后介绍函数，但 `main` 函数是程序中首先执行的函数，也称为入口点。函数用于执行特定任务。在这里，打印
    `Hello, World` 的任务分配给了 `main` 函数。需要执行的内容必须包含在函数的大括号内。在 `main()` 关键字之前的前缀 `int`
    暗示该函数将返回一个整数。这就是为什么我们在 `main` 函数的末尾返回 0，表明程序可以执行且可以无错误地终止。
- en: When we want to print out something to the console/screen, we use the `std::cout`
    (console out) C++ command to send something to the screen. Whatever we want to
    send out should start and end with the output operator, `<<`. Furthermore, `<<std::endl`
    is another C++ command, which specifies the end of a era line and that nothing
    else should be printed on the line afterward. We have to use the prefix before `std::` to
    tell C++ that we are using the standard namespace with the `std` namespace. But
    why are namespaces necessary? We need namespaces because anyone can declare a
    variable name with `std`. How would the compiler differentiate between the two
    types of `std`? For this, we have namespaces to differentiate between the two.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将某些内容打印到控制台/屏幕上时，我们使用 C++ 的 `std::cout`（控制台输出）命令将内容发送到屏幕。我们想要发送的内容应该以输出操作符
    `<<` 开始和结束。此外，`<<std::endl` 是另一个 C++ 命令，它指定了行尾，并且在该行之后不应打印任何其他内容。我们必须在 `std::`
    前使用前缀来告诉 C++ 我们正在使用带有 `std` 命名空间的标准命名空间。但为什么命名空间是必要的呢？我们需要命名空间是因为任何人都可以使用 `std`
    声明一个变量名。编译器如何区分这两种类型的 `std` 呢？为此，我们有了命名空间来区分它们。
- en: Note that the two lines of code we have written in the main function have a
    semicolon (`;`) at the end of each line. The semicolon tells the compiler that
    this is the end of the instructions for that line of code so that the program
    can stop reading when it gets to the semicolon and go to the next line of instruction.
    Consequently, it is important to add a semicolon at the end of each line of instruction
    as it is mandatory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在主函数中编写的两行代码的每一行都以分号（`;`）结尾。分号告诉编译器这是该行代码指令的结束，以便程序在到达分号时停止读取并转到下一行指令。因此，在每条指令的末尾添加分号是强制性的。
- en: 'The two lines of code we wrote before can be written in one line as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的两行代码可以合并为一行，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though it is written in a single line, for the compiler, there are two
    instructions with both instructions ending with a semicolon.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它只写了一行，对于编译器来说，有两个指令，两个指令都以分号结尾。
- en: The first instruction is to print out `Hello, World` to the console, and the
    second instruction is to terminate the program without any errors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令是将`Hello, World`打印到控制台，第二条指令是终止程序而不产生错误。
- en: It is a very common mistake to forget semicolons, and it happens to beginners
    as well as experienced programmers every now and then. So it's good to keep this
    in mind, for when you encounter your first set of compiler errors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记分号是一个非常常见的错误，即使是经验丰富的程序员有时也会犯这个错误。所以，当你遇到第一组编译器错误时，记住这一点是很好的。
- en: 'Let''s run this code in Visual Studio using the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤在Visual Studio中运行此代码：
- en: Open up Visual Studio and create a new project by going to File | New | Project.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio，通过File | New | Project创建一个新项目。
- en: On the left-hand side, select Visual C++ and then Other. For the Project Type,
    select Empty Project. Give this project a Name. Visual Studio automatically names
    the first project `MyFirstProject`. You can name it whatever you like.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧，选择Visual C++然后选择Other。对于Project Type，选择Empty Project。给这个项目一个名称。Visual Studio自动将第一个项目命名为`MyFirstProject`。你可以随意命名。
- en: 'Select the Location that you want the project to be saved in:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要项目保存的位置：
- en: '![](img/e0d2ffa8-f51c-466e-9909-8c7b997c796e.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e0d2ffa8-f51c-466e-9909-8c7b997c796e.png)'
- en: 'Once the project is created, in Solution Explorer, right-click and select Add | New
    Item:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，在Solution Explorer中，右键单击并选择Add | New Item：
- en: '![](img/552989f8-944f-4b65-bc77-e97a21607b67.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/552989f8-944f-4b65-bc77-e97a21607b67.png)'
- en: 'Create a new `.cpp` file, called the `Source` file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`.cpp`文件，称为`Source`文件：
- en: '![](img/0d158b87-6031-4a65-b7ba-5e5c18ccdeb6.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d158b87-6031-4a65-b7ba-5e5c18ccdeb6.png)'
- en: Copy the code at the start of the section into the `Source.cpp` file.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该节开始的代码复制到`Source.cpp`文件中。
- en: Now press the *F5* key on the keyboard or press the Local Window Debugger button
    at the top of the window to run the application.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按键盘上的*F5*键或按窗口顶部的Local Window Debugger按钮来运行应用程序。
- en: 'A popup of the console should appear upon running the program. To make the
    console stay so that we can see what is happening, add the following highlighted
    lines to the code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序时，应该会弹出一个控制台窗口。为了使控制台保持打开状态，以便我们可以看到正在发生的事情，请将以下突出显示的行添加到代码中：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What `_getch()` does is it stalls the program and waits for a character input
    to the console without printing the character to the console. So, the program
    will wait for some input and then close the console.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`_getch()`的作用是使程序暂停并等待控制台输入字符，而不将字符打印到控制台。因此，程序将等待一些输入然后关闭控制台。'
- en: To see what is printed to the console, we just add it for convenience. To use
    this function, we need to include the `conio.h` header.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看打印到控制台的内容，我们只需添加它以方便使用。要使用此功能，我们需要包含`conio.h`头文件。
- en: 'When you run the project again, you will see the following output:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你再次运行项目时，你将看到以下输出：
- en: '![](img/fcf0fe01-072d-4c2b-b94c-10af283b00e3.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fcf0fe01-072d-4c2b-b94c-10af283b00e3.png)'
- en: Now that we know how to run a basic program, let's look at the different data
    types that are included in C++.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何运行一个基本程序，让我们看看C++中包含的不同数据类型。
- en: Variables
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: A variable is used to store a value. Whatever value you store in a variable
    is stored in the memory location associated with that memory location. You assign
    a value to a variable with the following syntax.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 变量用于存储值。你存储在变量中的任何值都存储在与之关联的内存位置。你可以使用以下语法给变量赋值。
- en: 'We can first declare a variable type by specifying a type and then the variable
    name:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先通过指定类型和变量名来声明变量类型：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `type` is the variable type and `variable` is the name of the variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`type`是变量类型，`variable`是变量的名称。
- en: 'Next, we can assign a value to a variable:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以给变量赋值：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that value is assigned to the variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个值已经赋给了变量。
- en: 'Or, you can both declare the variable and assign a value to it in a single
    line, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在一行中同时声明变量并给它赋值，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before you set a variable, you have to specify the variable type. You can then
    use the equals sign (`=`)  to assign a value to a variable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置变量之前，你必须指定变量类型。然后你可以使用等号（`=`）给变量赋值。
- en: 'Let''s look at some example code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例代码：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace the previous code with this code in `Source.cpp` and run the application.
    This is the output you should get:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source.cpp`中将之前的代码替换为以下代码并运行应用程序。你应该得到以下输出：
- en: '![](img/210ab313-7c05-4037-9b0e-552296501051.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/210ab313-7c05-4037-9b0e-552296501051.png)'
- en: In this program, we specify the data type as `int`. An `int` is a C++ data type
    that can store integers. So, it cannot store decimal values. We declare a variable
    called `n`, and then we assign a value of `42` to it. Do not forget to add the
    semicolon at the end of the line.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们指定数据类型为`int`。`int`是C++数据类型，可以存储整数。因此，它不能存储小数。我们声明一个名为`n`的变量，并将其赋值为`42`。不要忘记在行尾添加分号。
- en: In the next line, we print the value to the console. Note that to print the
    value of `n`, we just pass in `n` in `cout` and don't have to add quotation marks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们将值打印到控制台。请注意，为了打印`n`的值，我们只需在`cout`中传递`n`，而无需添加引号。
- en: On a 32-bit system, an int variable uses 4 bytes (which is equal to 32 bits)
    of memory. This basically means the int data type can hold values between 0 and
    2^(32)-1 (4,294,967,295). However, one bit is needed to describe the sign for
    the value (positive or negative), which leaves 31 bits remaining to express the
    actual value. Therefore, a signed int can hold values between -2^(31) (-2,147,483,648)
    and 2^(31)-1 (2,147,483,647).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位系统上，`int`变量使用4个字节（等于32位）的内存。这基本上意味着`int`数据类型可以存储从0到2^32-1（4,294,967,295）的值。然而，需要一个位来描述值的符号（正或负），这留下了31位来表示实际值。因此，有符号的`int`可以存储从-2^31（-2,147,483,648）到2^31-1（2,147,483,647）的值。
- en: 'Let''s look at some other data types:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他一些数据类型：
- en: '`bool`: A bool can have only two values. It can either store `true` or `false`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：布尔值只能有两个值。它可以存储`true`或`false`。'
- en: '`char`: These stores integers ranging between *-128* and *127*. Note that `char` or
    character variables are used to store ASCII characters such as single characters—letters,
    for example.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`：这些存储介于 *-128* 和 *127* 之间的整数。请注意，`char`或字符变量用于存储ASCII字符，例如单个字符——例如字母。'
- en: '`short` and `long`: These are also integer types, but they are able to store
    more information than just int. The size of int is system-dependent and `long` and `short` have
    fixed sizes irrespective of the system used.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`和`long`：这些也是整数类型，但它们能够存储比`int`更多的信息。`int`的大小依赖于系统，而`long`和`short`的大小不依赖于使用的系统。'
- en: '`float`: This is a floating point type. This means that it can store values
    with decimal spaces such as 3.14, 0.000875, and -9.875\. It can store data with
    up to seven decimal places.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：这是一个浮点类型。这意味着它可以存储带有小数点的值，例如3.14、0.000875和-9.875。它可以存储最多七位小数的值。'
- en: '`double`: This is a `float` with more precision. It can store decimal values
    up to 15 decimal places.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：这是一个精度更高的`float`类型。它可以存储最多15位小数的十进制值。'
- en: '| **Data type** | **Minimum** | **Maximum** | **Size (bytes)** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **最小值** | **最大值** | **大小（字节）** |'
- en: '| `bool` | `false` | `true` | 1 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `false` | `true` | 1 |'
- en: '| `char` | -128 | 127 | 1 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `char` | -128 | 127 | 1 |'
- en: '| `short` | -32768 | 327677 | 2 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `short` | -32768 | 32767 | 2 |'
- en: '| `int` | -2,147,483,648 | 2,147,483,647 | 4 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `int` | -2,147,483,648 | 2,147,483,647 | 4 |'
- en: '| `long` | -2,147,483,648 | 2,147,483,647 | 4 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `long` | -2,147,483,648 | 2,147,483,647 | 4 |'
- en: '| `float` | 3.4 x 10-38 | 3.4 x 1038 | 4 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 3.4 x 10^-38 | 3.4 x 10^38 | 4 |'
- en: '| `double` | 1.7 x 10-308 | 1.7 x 10308 | 8 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 1.7 x 10^-308 | 1.7 x 10^308 | 8 |'
- en: You also have unsigned data types of the same data type used to maximize the
    range of values they can store. Unsigned data types are used to store positive
    values. Consequently, all unsigned values start at 0.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有相同数据类型的无符号数据类型，用于最大化它们可以存储的值的范围。无符号数据类型用于存储正值。因此，所有无符号值都从0开始。
- en: So, `char` and unsigned `char` can store positive values from *0* to *255*.
    Similar to unsigned `char`, we have unsigned `short`, `int`, and `long`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`char`和`unsigned char`可以存储从*0*到*255*的正值。与`unsigned char`类似，我们还有`unsigned
    short`、`int`和`long`。
- en: 'You can assign values to `bool`, `char`, and `float`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像下面这样给`bool`、`char`和`float`赋值：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the output when you run the application:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行应用程序时的输出结果：
- en: '![](img/9a39d2bf-6f9a-4811-ada9-21637386af5c.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a39d2bf-6f9a-4811-ada9-21637386af5c.png)'
- en: 'Everything is printing fine except `d`, which was assigned `-82`. What happened
    here? Well that''s because `d` can store only unsigned values, so if we assign
    it `-82`, it gives a garbage value. Change it to just `82` without the negative
    sign and it will print the correct value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`d`之外，所有内容打印都很正常，`d`被分配了`-82`。这里发生了什么？嗯，这是因为`d`只能存储无符号值，所以如果我们给它分配`-82`，它就会得到一个垃圾值。将其更改为不带负号的`82`，它就会打印出正确的值：
- en: '![](img/37ecd2c1-7dd6-4c2b-afd4-efad93a7f10e.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37ecd2c1-7dd6-4c2b-afd4-efad93a7f10e.png)'
- en: Unlike int, `bool` stores a binary value where `false` is `0` and `true` is
    `1`. So, when you print out the values of `true` and `false,` the output will
    be `1` and `0`, respectively.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与`int`不同，`bool`存储一个二进制值，其中`false`是`0`，`true`是`1`。所以，当你打印出`true`和`false`的值时，输出将分别是`1`和`0`。
- en: Basically, `char` stores characters specified with single quotation marks, and
    values with decimals are printed just how you stored the values in the floats.
    An `f` is added at the end of the value when assigning a `float`, to tell the
    system that it is a float and not a double.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`char`存储用单引号指定的字符，带有小数点的值以你存储在浮点数中的方式打印。在分配`float`时，在值末尾添加一个`f`，以告诉系统它是一个浮点数而不是双精度数。
- en: Strings
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Variables that are non-numerical are either a single character or a series of
    characters called strings. In C++, a series of characters can be stored in a special
    variable called a string. A string is provided through a standard `string` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 非数值变量要么是一个字符，要么是一系列称为字符串的字符。在C++中，一系列字符可以存储在一个特殊变量中，称为字符串。字符串通过标准`string`类提供。
- en: To declare and use `string` objects, we have to include the string header file.
    After `#include <conio.h>`, also add `#include <string>` at the top of the file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明和使用`string`对象，我们必须包含字符串头文件。在`#include <conio.h>`之后，还要在文件顶部添加`#include <string>`。
- en: A string variable is declared in the same way as other variable types, except
    before the string type you have to use the `std` namespace.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串变量声明的方式与其他变量类型相同，只是在字符串类型之前你必须使用`std`命名空间。
- en: 'If you don''t like adding the `std::` namespace prefix, you can also add the
    line using the `std` namespace after `#include`. This way, you won''t have to
    add the `std::` prefix, as the program will understand well enough without it. However,
    it can be printed out just like other variables:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢添加`std::`命名空间前缀，你还可以在`#include`之后添加使用`std`命名空间的行。这样，你就不需要添加`std::`前缀，因为程序没有它也能很好地理解。然而，它和其他变量一样可以打印出来：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![](img/5e15a6ea-e0d9-43d3-84ab-2a98a765b715.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e15a6ea-e0d9-43d3-84ab-2a98a765b715.png)'
- en: Operators
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: An operator is a symbol that performs a certain operation on a variable or expression.
    So far, we have used the `=` sign, which calls an assignment operator that assigns
    a value or expression from the right-hand side of the equals sign to a variable
    on the left-hand side.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是一个符号，它在变量或表达式上执行某种操作。到目前为止，我们已经使用了`=`符号，它调用一个赋值运算符，将等号右侧的值或表达式赋给等号左侧的变量。
- en: 'The simplest form of other kinds of operators are arithmetic operators such
    as `+`, `-`, `*`, `/`, and `%`. These operators operate on a variable such as
    `int` and `float`. Let''s look at some of the use cases of these operators:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其他种类运算符的最简单形式是算术运算符，如`+`、`-`、`*`、`/`和`%`。这些运算符作用于变量，如`int`和`float`。让我们看看这些运算符的一些用法示例：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of this is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果如下：
- en: '![](img/65128404-ecb2-46e3-b7b7-59628d79f69c.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65128404-ecb2-46e3-b7b7-59628d79f69c.png)'
- en: 'Let''s look at examples for other operations as well:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他操作的示例：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/7c4b2181-08a3-41f4-9d1d-204d800b3126.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c4b2181-08a3-41f4-9d1d-204d800b3126.png)'
- en: 'The `+`, `-`, `*`, and `/` signs are self-explanatory. However, there is one
    more arithmetic operator: `%`, which is called the modulus operator. It returns
    the remainder of a division.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`、`-`、`*`和`/`符号是自解释的。然而，还有一个算术运算符：`%`，称为取模运算符。它返回除法的余数。'
- en: How many times is 5 contained in 36? The answer is 7 times with a remainder
    of 1\. That's why the result is 1.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 5在36中包含多少次？答案是7次，余数为1。这就是为什么结果是1的原因。
- en: Apart from the arithmetic operators, we also have an increment/decrement operator.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算术运算符之外，我们还有增量/减量运算符。
- en: In programming, we increment variables often. You can do `a=a+1;` to increment
    and `a=a-1;` to decrement a variable value. Alternatively, you can even do `a+=1;`
    and `a-=1;` to increment and decrement, but in C++ programming there is an even
    shorter way of doing that, which is by using the `++` and `--` signs to increment
    and decrement the value of a variable by `1`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们经常递增变量。你可以用 `a=a+1;` 来递增，用 `a=a-1;` 来递减变量值。或者，你也可以用 `a+=1;` 和 `a-=1;`
    来递增和递减，但在 C++ 编程中，有一个更短的方法来做这件事，那就是使用 `++` 和 `--` 符号来递增和递减变量的值 `1`。
- en: 'Let''s look at an example of how to use it to increment and decrement a value
    by `1`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用它来递增和递减一个值 `1` 的例子：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of this is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果如下：
- en: '![](img/c5c178b9-4af7-4629-aa5b-ba4199bcf6b9.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5c178b9-4af7-4629-aa5b-ba4199bcf6b9.png)'
- en: 'Consequently, the `++` or `--` operator increments the value permanently. If
    the `++` operator is to the left of the variable, it is called a pre-increment
    operator. If it is put afterward, it is called a post-increment operator. There
    is a slight difference between the two. If we put `++` on the other side, we get
    the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`++` 或 `--` 运算符永久地递增值。如果 `++` 运算符在变量左侧，它被称为前递增运算符。如果它放在后面，它被称为后递增运算符。两者之间有一点区别。如果我们把
    `++` 放在另一边，我们得到以下输出：
- en: '![](img/c82be4c4-d840-4ff4-bb17-fc06c49869c1.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c82be4c4-d840-4ff4-bb17-fc06c49869c1.png)'
- en: In this case, `a` and `b` are incremented and decremented in the next line.
    So, when you print the values, it prints out the correct result.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`a` 和 `b` 在下一行中递增和递减。所以，当你打印这些值时，它会打印出正确的结果。
- en: It doesn't make a difference here, as it is a simple example, but overall it
    does make a difference, and it is good to understand this difference. In this
    book, we will mostly be using post-increment operators.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，这没有区别，但总的来说，它确实有区别，了解这个区别是好的。在这本书中，我们将主要使用后递增运算符。
- en: In fact, this is how C++ got its name; it is an increment of C.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这就是 C++ 得名的原因；它是 C 的一个增量。
- en: Apart from arithmetic, increment, and decrement operators, you also have logical
    and comparison operators.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算术、递增和递减运算符之外，你还有逻辑和比较运算符。
- en: 'The logical operators are shown in the following table:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符如下表所示：
- en: '| **Operator** | **Operation** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **操作** |'
- en: '| `!` | NOT |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 非 |'
- en: '| `&&` | AND |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 与 |'
- en: '| `&#124;&#124;` | OR |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 或 |'
- en: 'Here are the comparison operators:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是比较运算符：
- en: '| **Operator** | **Comparison** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **比较** |'
- en: '| `==` | Equal to |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 等于 |'
- en: '| `!=` | Not equal to |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 |'
- en: '| `<` | Less than |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `>` | Greater than |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `<=` | Less than equal to |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于等于 |'
- en: '| `>=` | Greater than equal to |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于等于 |'
- en: We will cover these operators in the next section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中介绍这些运算符。
- en: Statements
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句
- en: A program may not always be linear. Depending on your requirements, you might
    have to branch out or bifurcate, repeat a set of code, or take a decision. For
    this, there are conditional statements and loops.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序可能不总是线性的。根据你的需求，你可能需要分支或分叉，重复一组代码，或者做出决定。为此，有条件语句和循环。
- en: In a conditional statement, you check whether a condition is true. If it is,
    you will go ahead and execute the statement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件语句中，你检查一个条件是否为真。如果是，你将执行该语句。
- en: 'The first of the conditional statements is the `if` statement. The syntax for
    this looks as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件语句是 `if` 语句。这个语句的语法如下：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s look at how to use this in the following code. Let''s use one of the
    comparison operators here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在以下代码中使用它。这里我们使用一个比较运算符：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/e402a9c9-70c9-43f8-9eb0-f17d2f4dfe28.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e402a9c9-70c9-43f8-9eb0-f17d2f4dfe28.png)'
- en: We check the whether `a` is greater than `b`, and if the condition is true,
    then we print out the statement.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查 `a` 是否大于 `b`，如果条件为真，则打印出该语句。
- en: 'But what if the opposite is true? For this, we have the `if...else` statement,
    which is a statement that basically executes the alternate statement. The syntax
    looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果情况相反呢？为此，我们有 `if...else` 语句，这是一个基本上执行替代语句的语句。其语法如下：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s look at it in code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码来看看：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, the values of `a` and `b` are changed so that `b` is greater than `a`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a` 和 `b` 的值被改变，使得 `b` 大于 `a`：
- en: '![](img/d33a93af-67d9-45e0-b2da-ceaf56148e7d.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d33a93af-67d9-45e0-b2da-ceaf56148e7d.png)'
- en: 'One thing to note is that after the `if` and `else` conditions, C++ will execute
    a single line of statement. If there are multiple statements after `if` or `else`,
    then the statements need to be in curly brackets, as shown:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一点是，在 `if` 和 `else` 条件之后，C++ 将执行单行语句。如果有多个语句在 `if` 或 `else` 之后，则这些语句需要用大括号括起来，如下所示：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also have the `if` statements after using `else if`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `else if` 之后，也可以有 `if` 语句：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/92d616ff-1edb-4d1f-a7fb-d23a7cab258d.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92d616ff-1edb-4d1f-a7fb-d23a7cab258d.png)'
- en: Iteration
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代
- en: 'Iteration is the process of calling the same statement repeatedly. C++ has
    three iteration statements: the `while`, `do...while`, and `for` statements. Iteration
    is also commonly referred to as loops.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是重复调用相同语句的过程。C++ 有三个迭代语句：`while`、`do...while` 和 `for` 语句。迭代也常被称为循环。
- en: 'The `while` loop syntax looks like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环的语法如下所示：'
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s look at it in action:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的实际操作：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the output of this code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此代码的输出：
- en: '![](img/2725dc8f-d8ce-4816-8b9c-9e54c0f3558a.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2725dc8f-d8ce-4816-8b9c-9e54c0f3558a.png)'
- en: Here, the value of `n` is printed to the console until the condition is met.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`n` 的值会被打印到控制台，直到满足条件为止。
- en: 'The `do while` statement is almost the same as a `while` statement except,
    in this case, the statement is executed first and then the condition is tested.
    The syntax is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`do while` 语句几乎与 `while` 语句相同，只是在这种情况下，首先执行语句，然后测试条件。语法如下：'
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can give it a go yourself and see the result.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己尝试并查看结果。
- en: 'The loop that is most commonly used in programming is the `for` loop. The syntax
    for this looks as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中最常用的循环是 `for` 循环。其语法如下所示：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `for` loop is very self-contained. In `while` loops, we have to initialize
    `n` outside the `while` loop, but in the `for` loop, the initialization is done
    in the declaration of the `for` loop itself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环非常自包含。在 `while` 循环中，我们必须在 `while` 循环外部初始化 `n`，但在 `for` 循环中，初始化是在 `for`
    循环的声明中完成的。'
- en: 'Here is the same example as the `while` loop but with the `for` loop:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是与 `while` 循环相同的示例，但使用的是 `for` 循环：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output is the same as the `while` loop but at look how compact the code
    is compared to the `while` loop. Also, `n` is scoped locally to the `for` loop
    body.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与 `while` 循环相同，但与 `while` 循环相比，代码更加紧凑。此外，`n` 在 `for` 循环体中是局部作用域。
- en: 'We can also increment `n` by `2` instead of `1`, as shown:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将 `n` 增加 `2` 而不是 `1`，如下所示：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the output of this code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此代码的输出：
- en: '![](img/c036ead1-efc4-45f9-acf8-b5cf3d0dd940.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c036ead1-efc4-45f9-acf8-b5cf3d0dd940.png)'
- en: Jump statements
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳转语句
- en: As well as condition and iteration statements, you also have the `break` and
    `continue` statements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了条件和迭代语句，你还有 `break` 和 `continue` 语句。
- en: The `break` statement is used to break out of an iteration. We can leave a loop
    and force it to quit if a certain condition is met.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句用于跳出迭代。如果满足某个条件，我们可以离开循环并强制其退出。'
- en: 'Let''s look at the `break` statement in use:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `break` 语句的使用情况：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of this is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出的结果如下所示：
- en: '![](img/88644fcd-80df-47cb-bcbc-d165d4353fc9.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88644fcd-80df-47cb-bcbc-d165d4353fc9.png)'
- en: 'The `continue` statement will skip the current iteration and continue the execution
    of the statement until the end of the loop. In the `break` code, replace `break`
    with `continue` to see the difference:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句将跳过当前迭代，并继续执行直到循环结束的语句。在 `break` 代码中，将 `break` 替换为 `continue`
    以查看差异：'
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the output when `break` is replaced with `continue`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `break` 替换为 `continue` 时，这是输出结果：
- en: '![](img/18313505-c6f3-493b-b6b5-3faaf9960e19.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18313505-c6f3-493b-b6b5-3faaf9960e19.png)'
- en: Switch statement
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Switch 语句
- en: The last of the statements is the `switch` statement. A `switch` statement checks
    for several cases of values, and if a value matches the expression, then it executes
    the corresponding statement and breaks out of the `switch` statement. If it doesn't
    find any of the values, then it will output a default statement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个语句是 `switch` 语句。`switch` 语句检查多个值的几种情况，如果值与表达式匹配，则执行相应的语句并退出 `switch` 语句。如果没有找到任何值，则输出默认语句。
- en: 'The syntax for it looks as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其语法如下所示：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This looks very familiar to the `else if` statements, but this is more sophisticated.
    Here is an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与 `else if` 语句非常相似，但更为复杂。以下是一个示例：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/0e139fba-5539-47cb-887f-01c76a864c8b.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e139fba-5539-47cb-887f-01c76a864c8b.png)'
- en: Change the value of `a` to equal `2` and you will see that it prints out the
    statement when the `2` case is correct.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将`a`的值改为等于`2`，你就会看到当`2`的情况正确时，它会打印出该语句。
- en: Also note that it is important to add the `break` statement. If you forget to
    add it, then the program will not break out of the statement.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，添加`break`语句是很重要的。如果你忘记添加它，那么程序将无法跳出该语句。
- en: Functions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: So far, we have written all of our code in the main function. This is fine if
    you are doing a single task, but once you start doing more with a program, the
    code will become bigger and over a period of time everything will be in the main
    function, which will look very confusing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在`main`函数中编写了所有的代码。如果你只做一项任务，这是可以的，但一旦你开始用程序做更多的事情，代码就会变得更大，随着时间的推移，所有内容都会在`main`函数中，这会显得非常混乱。
- en: With functions, you can break your code up into smaller, manageable chunks.
    This will enable you to structure your program better.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数，你可以将你的代码拆分成更小、更易于管理的块。这将使你能够更好地组织你的程序。
- en: 'A function has the following syntax:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有以下语法：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Going from left to right, `type` here is the return type. After performing a
    statement, a function is capable of returning a value. This value could be of
    any type, so we specify a type here. A function has only one variable at a time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，这里的`type`是返回类型。在执行一个语句之后，函数能够返回一个值。这个值可以是任何类型，所以我们在这里指定一个类型。函数一次只能有一个变量。
- en: The function name is the name of the function itself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名就是函数本身的名称。
- en: Then, inside brackets, you will pass in parameters. These parameters are variables
    of a certain type that are passed into the function to perform a certain function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在括号内，你将传入参数。这些参数是传递给函数的特定类型的变量，以便执行特定功能。
- en: 'Here is an example: two parameters are passed in but you can pass as many parameters
    you want. You can pass in more than one parameter per function, and each parameter
    is separated by a comma.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：传入两个参数，但你可以传入你想要的任何数量的参数。你可以在每个函数中传入多个参数，每个参数之间用逗号分隔。
- en: 'Let''s look at this example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个例子：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we create a new function called `add`. For now, make sure the functions
    are added before the `main` function; otherwise, `main` will not know that the
    function exists.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`add`的新函数。目前，请确保在`main`函数之前添加函数；否则，`main`将不知道函数的存在。
- en: The `add` function doesn't return anything so we use the `void` keyword at the
    start of the function. Not all functions have to return a value. Next, we name
    the function `add` and then pass in two parameters, which are `a` and `b` of the
    `int` type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`函数不返回任何内容，所以我们使用`void`关键字在函数的开始处。并不是所有的函数都必须返回一个值。接下来，我们命名函数为`add`，然后传入两个参数，这两个参数是`int`类型的`a`和`b`。'
- en: In the function, we create a new variable called `c` of the `int` type, add
    the values of the arguments passed in, and assign it to `c`. The new `add` function
    finally prints out the value of `c`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，我们创建了一个名为`c`的新变量，其类型为`int`，将传入的参数值相加，并将其赋值给`c`。新的`add`函数最终会打印出`c`的值。
- en: Furthermore, in the `main` function, we create two variables called `x` and
    `y` of the `int` type, call the `add` function, and pass in `x` and `y` as arguments.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`main`函数中，我们创建了两个名为`x`和`y`的`int`类型变量，调用了`add`函数，并将`x`和`y`作为参数传入。
- en: 'When we call the function, we pass the value of `x` to `a` and the value of
    `y` to `b`, which is added and stored in `c` to get the following output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，我们将`x`的值传递给`a`，将`y`的值传递给`b`，它们相加并存储在`c`中，得到以下输出：
- en: '![](img/354f93b0-a0d7-48bd-be85-984f3576a4f5.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/354f93b0-a0d7-48bd-be85-984f3576a4f5.png)'
- en: When you create new functions, make sure they are written above the main function;
    otherwise, it will not be able to see the functions and the compiler will throw
    errors.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建新的函数时，请确保它们写在`main`函数之上；否则，它将看不到函数，编译器会抛出错误。
- en: 'Now let''s write one more function. This time, we will make sure the function
    returns a value. Create a new function called `multiply`, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再写一个函数。这次，我们将确保函数返回一个值。创建一个名为`multiply`的新函数，如下所示：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `main` function, after we''ve called the `add` function, add the following
    lines:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，在调用`add`函数之后，添加以下行：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the `multiply` function, we have a return type of `int`, so the function
    will expect a return value at the end of the function, which we return using the
    `return` keyword. The returned value is the `a` variable multiplied by the `b` variable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `multiply` 函数中，我们有一个返回类型为 `int`，因此函数在函数末尾期望有一个返回值，我们使用 `return` 关键字返回。返回值是
    `a` 变量与 `b` 变量的乘积。
- en: In the `main` function, we create a new variable called `c`; call the `multiply`
    function and pass in `12` and `32`. After being multiplied, the return value will
    be assigned to the value of `c`. After this, we print out the value of `c` in
    the `main` function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建了一个名为 `c` 的新变量；调用 `multiply` 函数并传入 `12` 和 `32`。在乘法之后，返回值将被分配给
    `c` 的值。之后，我们在 `main` 函数中打印出 `c` 的值。
- en: 'The output of this is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果如下：
- en: '![](img/967e8f0e-e1b1-482a-8263-24577e2445f2.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/967e8f0e-e1b1-482a-8263-24577e2445f2.png)'
- en: We can have a function with the same name, but we can pass in different variables
    or different numbers of them. This is called **function overloading**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个具有相同名称的函数，但我们可以传入不同的变量或不同数量的变量。这被称为**函数重载**。
- en: 'Create a new function called `multiply`, but this time pass in floats and set
    the return value to a float as well:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `multiply` 的新函数，但这次传入浮点数并设置返回值为浮点数：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is called function overloading, where the function name is the same, but
    it takes different types of arguments.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为函数重载，其中函数名称相同，但它接受不同类型的参数。
- en: 'In the `main` function, after we''ve printed the value of `c`, add the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，在我们打印了 `c` 的值之后，添加以下代码：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So, what is this `f` after the float value? Well, `f` just converts the doubles
    to floats. If we don't add the `f`, then the value will be treated as a double
    by the compiler.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，浮点值后面的这个 `f` 是什么意思呢？嗯，`f` 只是将双精度浮点数转换为浮点数。如果我们不加 `f`，编译器将把值视为双精度浮点数。
- en: 'When you run the program, you''ll get the value of `d` printed out:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会得到打印出的 `d` 的值：
- en: '![](img/b65d3cd7-08d3-45c4-8696-e3e0bbef664d.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b65d3cd7-08d3-45c4-8696-e3e0bbef664d.png)'
- en: Scope of variables
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: You may have noticed that we have two variables called `c` in the program right
    now. There is a `c` in the `main` function as well as a `c` in the `add` function.
    How is it that they are both named `c` but have different values?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在程序中现在有两个名为 `c` 的变量。`main` 函数中有一个 `c`，`add` 函数中也有一个 `c`。它们都命名为 `c`
    但值却不同，这是怎么回事？
- en: In C++, there is the concept of a local variable. This means that the definition
    of a variable is confined to the local block of code it is defined in. Consequently,
    the `c` variable in the `add` function is treated differently to the `c` variable
    in the `main` function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，存在局部变量的概念。这意味着变量的定义仅限于其定义的局部代码块内。因此，`add` 函数中的 `c` 变量与 `main` 函数中的 `c`
    变量处理方式不同。
- en: There are also global variables, which need to be declared outside of the function
    or block of code. Any piece of code written between curly brackets is considered
    to be a block of code. Consequently, for a variable to be considered a global
    variable, it needs to be in the body of the program or it needs to be declared
    outside a block of code of a function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还有全局变量，需要在函数或代码块外部声明。任何写在花括号之间的代码都被认为是代码块。因此，要使变量成为全局变量，它需要位于程序的主体中，或者它需要在函数的代码块外部声明。
- en: Arrays
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: So far, we have only looked at single variables, but what if we want a bunch
    of variables grouped together? Like the ages of all the students in a class, for
    example. You can keep creating separate variables, `a`, `b`, `c`, `d`, and so
    on, and to access each you would have to call each of them, which is cumbersome,
    as you won't know the kind of data they hold.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了单个变量，但如果我们想将一些变量分组在一起呢？比如一个班级所有学生的年龄。你可以继续创建单独的变量，`a`、`b`、`c`、`d`
    等等，要访问每个变量，你必须调用它们，这很麻烦，因为你不知道它们持有的数据类型。
- en: To organize data better, we can use arrays. Arrays use continuous memory space
    to store values in a series, and you can access each element with an index number.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地组织数据，我们可以使用数组。数组使用连续的内存空间按顺序存储值，你可以使用索引号访问每个元素。
- en: 'The syntax for arrays is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的语法如下：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, we can store the ages of five students as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以如下存储五个学生的年龄：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When creating an array with a set number of values, you don't have to specify
    a size but it is a good idea to do so. To access each value, we use the index
    from `0` - `4` as the first element with a value of `12` at the *0*^(th) index
    and the last element, `9`, in the fourth index.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建具有固定数量值的数组时，你不必指定大小，但这样做是个好主意。要访问每个值，我们使用从 `0` 到 `4` 的索引作为第一个元素，其值为 `12`
    在第 *0*^(th) 索引处，以及最后一个元素，`9` 在第四个索引处。
- en: 'Let''s see how to use this in code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在代码中使用它：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/fd294672-6bf8-4079-a37a-e8fc68a426ad.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd294672-6bf8-4079-a37a-e8fc68a426ad.png)'
- en: 'To access each element in the array, you can use a `or` loop:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组中的每个元素，你可以使用 `or` 循环：
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of this is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/f2fb6e1c-1141-4cd6-9ece-33babd21ca9a.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2fb6e1c-1141-4cd6-9ece-33babd21ca9a.png)'
- en: Instead of calling `age[0]` and so on, we use the `i` index from the `for` loop
    itself and pass it into the `age` array to print out the index and the value stored
    at the index.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是调用 `age[0]` 等等，而是使用 `for` 循环本身的 `i` 索引，并将其传递到 `age` 数组中以打印出索引和存储在该索引处的值。
- en: 'The `age` array is a single-dimension array. In graphics programming, we have
    seen that we use a two-dimensional array, which is mostly a 4x4 matrix. Let''s
    look at an example of a two-dimensional 4x4 array. A two-dimensional array is
    defined as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`age` 数组是一维数组。在图形编程中，我们看到了我们使用二维数组，这通常是一个 4x4 矩阵。让我们看看二维 4x4 数组的示例。二维数组定义如下：'
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To access each element, you use a nested `for` loop.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问每个元素，你使用嵌套的 `for` 循环。
- en: 'Let''s look at this in the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下代码中看看这个：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/6ce38321-4a90-44a5-ae31-f4e3c4b05723.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ce38321-4a90-44a5-ae31-f4e3c4b05723.png)'
- en: As a test, create two matrices and attempt to carry out matrix multiplication.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试，创建两个矩阵并尝试执行矩阵乘法。
- en: You can even pass arrays as parameters to functions, shown in the following
    example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数组作为参数传递给函数，以下是一个示例。
- en: 'Here, the `matrixPrinter` function doesn''t return anything but prints out
    the values stored in each element of the 4x4 matrix:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`matrixPrinter` 函数不返回任何内容，而是打印出 4x4 矩阵中每个元素存储的值：
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can even use an array of `char` to create a string of words. Unlike `int`
    and `float` arrays, the characters in an array don't have to be in curly brackets
    and they don't need to be separated by a comma.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用 `char` 数组来创建一个单词字符串。与 `int` 和 `float` 数组不同，数组中的字符不必放在花括号内，也不需要用逗号分隔。
- en: 'To create a character array, you define it as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个字符数组，你定义如下：
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can print out the values just by calling out the name of the array, as
    follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用数组的名称来打印出值，如下所示：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of this is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/ac0cc047-284e-4f87-9c3e-82df5035dfa5.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac0cc047-284e-4f87-9c3e-82df5035dfa5.png)'
- en: Pointers
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: Whenever we declare new variables so that we can store values in them, we actually
    send a memory allocation request to the operating system. The operating system
    will try to reserve a block of continuous memory for our application if there
    is enough free memory left.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们声明新变量以便在其中存储值时，我们实际上向操作系统发送一个内存分配请求。如果剩余足够的空闲内存，操作系统将尝试为我们的应用程序保留一块连续的内存。
- en: When we want to access the value stored in that memory space, we call the variable
    name.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要访问存储在该内存空间中的值时，我们调用变量名。
- en: We don't have to worry about the memory location where we have stored the value.
    However, what if we want to get the address of the location where the variable
    is stored?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心存储值的内存位置。然而，如果我们想获取变量存储位置的地址呢？
- en: The address that locates the variable within the memory is called a reference
    to the variable. To access this, we use an address of the `&` operator. To get
    the address location, we place the operator before the variable.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 定位变量在内存中的地址称为变量的引用。要访问此，我们使用 `&` 操作符的地址。要获取地址位置，我们将操作符放在变量之前。
- en: Pointers are variables, and like any other variables they are used to store
    a value; however, this specific variable type allows the storage of the address—the
    reference—of another variable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是变量，就像任何其他变量一样，它们用于存储一个值；然而，这种特定的变量类型允许存储另一个变量的地址——即引用。
- en: In C/C++, every variable can also be declared as a pointer that holds a reference
    to a value of a certain data type by preceding its variable name with an asterisk
    (`*`). This means, for example, that an `int` pointer holds a reference to a memory
    address where a value of an `int` may be stored.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++中，每个变量也可以通过在其变量名前加一个星号（`*`）来声明为指针，该指针持有对特定数据类型值的引用。这意味着，例如，`int`指针持有对可能存储`int`值的内存地址的引用。
- en: A pointer can be used with any built-in or custom data type. If we access the
    value of a `pointer` variable, we will simply get the memory address it references.
    So, in order to access the actual value a `pointer` variable references, we have
    to use the so-called dereferencing operator (`*`).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可以用在任何内置或自定义数据类型上。如果我们访问`pointer`变量的值，我们只会得到它引用的内存地址。因此，为了访问`pointer`变量引用的实际值，我们必须使用所谓的解引用运算符（`*`）。
- en: 'If we have a variable called `age` and assign a value to it, to get the reference
    address location we use `&age` to store this address in a variable. To store the
    reference address, we can''t just use a regular variable; we have to use a `pointer`
    variable and use the dereference operator before it to access the address, as
    follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个名为`age`的变量并将其赋值，为了获取引用地址位置，我们使用`&age`来存储这个地址。为了存储引用地址，我们不能只是使用常规变量；我们必须使用指针变量，并在它之前使用解引用运算符来访问地址，如下所示：
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the pointer location will store the address of where the `age` variable
    value is stored.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，指针位置将存储`age`变量值存储的地址。
- en: 'If we print the value of `location`, we will get the reference address where
    `age` is stored:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印`location`的值，我们将得到存储`age`的引用地址：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is the output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![](img/b6df33e6-80d7-4ce0-b645-f33759b7c0b0.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6df33e6-80d7-4ce0-b645-f33759b7c0b0.png)'
- en: This value might be different for you, as the location will be different from
    machine to machine.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值对于你可能不同，因为位置会因机器而异。
- en: To get the location of where the `location` variable itself is stored, we can
    print out `&location` as well.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`location`变量本身存储的位置，我们可以同时打印出`&location`。
- en: 'This is the memory location of the variable on my system memory:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是变量在我的系统内存中的内存位置：
- en: '![](img/b6df33e6-80d7-4ce0-b645-f33759b7c0b0.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6df33e6-80d7-4ce0-b645-f33759b7c0b0.png)'
- en: 'Let''s look at another example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看另一个例子：
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we create two `int` variables; one is a regular `int` and the other is
    a pointer type.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了两个`int`变量；一个是常规的`int`，另一个是指针类型。
- en: We first set the `age` variable equal to `18`, then we set the address of `age`,
    and assign it to the `pointer` variable called `pointer`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`age`变量设置为`18`，然后设置`age`的地址，并将其分配给名为`pointer`的指针变量。
- en: The `int` pointer is now pointing to the same address where the `age` variable
    stores its `int` value.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`int`指针正指向存储`age`变量`int`值的同一地址。
- en: Next, use the dereference operator on the `pointer` variable to give us access
    to the `int` values stored at the referenced address and change the current value
    to `12`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`pointer`变量上使用解引用运算符，以获得对引用地址存储的`int`值的访问，并将当前值更改为`12`。
- en: 'Now, when we print out the value of the `age` variable, we will see that the
    previous statement has indeed changed the value of the `age` variable. A null
    pointer is a pointer that is not pointing to anything, and is set as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打印出`age`变量的值时，我们将看到前面的语句确实改变了`age`变量的值。空指针是一个不指向任何内容的指针，其设置如下：
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Pointers are very much associated with arrays. As arrays are nothing but continuous
    sequences of memory, we can use pointers with them.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 指针与数组紧密相关。因为数组不过是连续的内存序列，所以我们可以使用指针与它们一起使用。
- en: 'Consider our arrays example from the arrays section:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在数组部分提到的数组示例：
- en: '[PRE47]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Instead of using the index, we can use pointers to point to the values in the
    array.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用索引，而是用指针指向数组中的值。
- en: 'Consider the following code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the `main` function, we create a pointer called `pointer`, as well as an
    array with five elements. We assign the array to the pointer. This causes the
    pointer to get the location of the address of the first element of the array. So,
    when we print the value pointed to by the pointer, we get the value of the first
    element of the array.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们创建了一个名为`pointer`的指针，以及一个包含五个元素的数组。我们将数组分配给指针。这导致指针获取数组第一个元素的地址。因此，当我们打印指针指向的值时，我们得到数组的第一个元素的值。
- en: With `pointer`, we can also increment and decrement as a regular `int`. However,
    unlike a regular `int` increment, which increments the value of the variable when
    you increment a pointer, it will point to the next memory location. So, when we
    increment `p` it is now pointing to the next memory location of the array. Incrementing
    and decrementing a pointer means moving the referenced address by a certain number
    of bytes. The number of bytes depends on the data type that is used for the `pointer`
    variable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`指针`，我们也可以像常规`int`一样递增和递减。然而，与常规`int`递增不同，当你递增指针时，它会增加变量的值，而指针会指向下一个内存位置。所以，当我们递增`p`时，它现在指向数组的下一个内存位置。递增和递减指针意味着将引用的地址移动一定数量的字节。字节数取决于用于`指针`变量的数据类型。
- en: Here, the pointer is the `int` type, so when we move the pointer by one, it
    moves 4 bytes and points to the next integer. When we print the value that `p`
    is pointing to now, it prints the second element's value.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，指针是`int`类型，所以当我们移动指针一个单位时，它移动4个字节并指向下一个整数。当我们打印`p`现在指向的值时，它打印第二个元素的值。
- en: We can also get the value of other elements in the array by getting the pointer's
    current location and by adding to it the *n*^(th) number you want to get from
    the current location using `*(p + n)`, where `n` is the *n*^(th) element from
    `p`. So, when we do `*(p + 3)`, we will get the third element from where `p` is
    pointing to currently. Since `p` was incremented to the second element, the third element
    from the second element is the fifth element, and so the value of the fifth element
    is printed out.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过获取指针的当前位置并添加到它，使用`*(p + n)`来获取数组中其他元素的价值，其中`n`是从当前位置获取的*第n*个数字。所以，当我们做`*(p
    + 3)`时，我们将从`p`当前指向的位置获取第三个元素。由于`p`递增到了第二个元素，从第二个元素开始的第三个元素是第五个元素，因此打印出第五个元素的价值。
- en: However, this doesn't change the location to which `p` is pointing, which is
    still the second position.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并没有改变`p`指向的位置，它仍然是第二个位置。
- en: 'Here is the output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出的结果：
- en: '![](img/c84858ca-fb47-4851-864f-9a3f0ffc6b5f.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c84858ca-fb47-4851-864f-9a3f0ffc6b5f.png)'
- en: Structs
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: Structures or structs are used to group data together. A `struct` can have different
    data elements in it, called members, integers, floats, chars, and so on. You can
    create many objects of a similar `struct` and store values in the `struct` for
    data management.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体或`struct`用于将数据组合在一起。一个`struct`可以包含不同的数据元素，称为成员，整数、浮点数、字符等。你可以创建许多类似`struct`的对象，并在`struct`中存储值以进行数据管理。
- en: 'The syntax of `struct` is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`的语法如下：'
- en: '[PRE49]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'An object of `struct` can be created as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 可以如下创建`struct`对象：
- en: '[PRE50]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: An object is an instance of `struct` where we can assign properties to the data
    types we created while creating the `struct`. An example of this is as follows.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象是`struct`的一个实例，在创建`struct`时我们可以将属性分配给创建的数据类型。以下是一个例子。
- en: 'In a situation in which you want to maintain a database of student ages and
    the height of a section, your `struct` definition will look like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在你想要维护学生年龄和班级身高数据库的情况下，你的`struct`定义将如下所示：
- en: '[PRE51]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now you can create an array of objects and store the values for each student:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建一个对象数组并存储每个学生的值：
- en: '[PRE52]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here is the output of this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出的结果：
- en: '![](img/985f22ee-a493-4659-898e-c272f9b9520f.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/985f22ee-a493-4659-898e-c272f9b9520f.png)'
- en: Enums
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: Enums are used for enumerating items in a list. When comparing items, it is
    easier to compare names rather than just numbers. For example, the days in a week
    are Monday to Sunday. In a program, we will assign Monday to 0, Tuesday to 1,
    and Sunday to 7, for example. To check whether today is Friday, you will have
    to count to and arrive at 5\. However, wouldn't it be easier to just check if
    `Today == Friday`?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举用于在列表中列举项目。当比较项目时，比较名称比仅仅比较数字更容易。例如，一周中的日子是星期一到星期日。在一个程序中，我们将星期一分配给0，星期二分配给1，星期日分配给7，例如。要检查今天是否是星期五，你必须数到并到达5。然而，检查`Today
    == Friday`不是更容易吗？
- en: 'For this, we have enumerations, declared as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们有枚举，声明如下：
- en: '[PRE53]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'So, in our example, it would be something like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的例子中，它可能看起来像这样：
- en: '[PRE54]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output of this is as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果如下：
- en: '![](img/e3ebe1ed-2404-4b2e-95e8-632edc7e607a.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3ebe1ed-2404-4b2e-95e8-632edc7e607a.png)'
- en: Also note that, `Monday = 0`. If we don't use initializers, the first item's
    value is set to `0`. Each following item that does not use an initializer will
    use the value of the preceding item plus `1` for its value.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`Monday = 0`。如果我们不使用初始化器，第一个项目的值将被设置为 `0`。每个后续未使用初始化器的项目将使用前一个项目的值加上 `1`
    作为其值。
- en: Classes
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'In C++, structs and classes are identical. You can do exactly the same thing
    with both of them. The only difference is the default access specifier: `public`
    for structs and `private` for classes.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，结构和类是相同的。你可以用它们做完全一样的事情。唯一的区别是默认的访问修饰符：结构为 `public`，类为 `private`。
- en: 'The declaration of a class looks like the following code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 类的声明如下所示：
- en: '[PRE55]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A class starts with the `class` keyword, followed by the name of the class.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 类以 `class` 关键字开头，后跟类的名字。
- en: 'In a class, we first specify the access specifiers. There are three access
    specifiers: `public`, `private`, and `protected`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中，我们首先指定访问修饰符。有三个访问修饰符：`public`、`private` 和 `protected`：
- en: '`public`: All members are accessible from anywhere.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：所有成员在任何地方都可以访问。'
- en: '`private`: Members are accessible from within the class itself only.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：成员仅可以从类内部访问。'
- en: '`protected`: Members are accessed by other classes that inherit from the class.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：成员可以被继承自该类的其他类访问。'
- en: By default, all members are private.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有成员都是私有的。
- en: Furthermore, `name();` and `~name();` are called the constructor and destructor
    of a class. They have the same name as the name of the class itself.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`name();` 和 `~name();` 被称为类的构造函数和析构函数。它们的名字与类的名字本身相同。
- en: The constructor is a special function that gets called when you create a new
    object of the class. The destructor is called when the object is destroyed.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个特殊函数，当创建类的新的对象时会被调用。析构函数在对象被销毁时被调用。
- en: We can customize a constructor to set values before using the member variables.
    This is called constructor overloading.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自定义构造函数来在使用成员变量之前设置值。这被称为构造函数重载。
- en: Notice that although the constructor and destructor are functions no return
    is provided. This is because they are not there for returning values.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管构造函数和析构函数是函数，但它们没有提供返回值。这是因为它们不是为了返回值而存在的。
- en: 'Let''s look at an example of a class where we create a class called `shape`.
    This has two member variables for the `a` and `b` sides and a member function,
    which calculates and prints the area:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个类的例子，我们创建了一个名为 `shape` 的类。这个类有两个成员变量 `a` 和 `b` 的边，以及一个成员函数，该函数计算并打印面积：
- en: '[PRE56]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We use the class by creating objects of the class.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建类的对象来使用类。
- en: 'Here, we create two objects, called `square` and `rectangle`. We set the values
    by calling the custom constructor, which sets the value of `a` and `b`. Then,
    we call the `area` function of the object by using the dot operator by pressing
    the `.` button on the keyboard after typing the name of the object:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了两个对象，分别称为 `square` 和 `rectangle`。我们通过调用自定义构造函数来设置值，该构造函数设置 `a` 和 `b`
    的值。然后，我们通过使用点操作符（在键盘上按下 `.` 按钮后输入对象的名字）调用对象的 `area` 函数：
- en: '[PRE57]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/717a6526-c61b-429d-840f-8fd28cd8a2a1.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/717a6526-c61b-429d-840f-8fd28cd8a2a1.png)'
- en: Inheritance
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: One of the key features of C++ is inheritance, with which we can create classes
    that are derived from other classes so that derived or the child class automatically
    includes some of its parent's member variables and functions.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的一个关键特性是继承，通过它可以创建从其他类派生出来的类，这样派生类或子类会自动包含其父类的一些成员变量和函数。
- en: For example, we looked at the `shape` class. From this, we can have a separate
    class called `circle` and another class called `triangle` that has the same properties
    as other shapes, such as area.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们研究了 `shape` 类。从这一点出发，我们可以有一个名为 `circle` 的单独类，另一个名为 `triangle` 的类，它具有与其他形状相同的属性，例如面积。
- en: 'The syntax for an inherited class is as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 继承类的语法如下所示：
- en: '[PRE58]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that `accessSpecifier` could be `public`, `private`, or `protected` depending
    on the minimum access level you want to provide to the parent member variables
    and functions.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`accessSpecifier` 可以是 `public`、`private` 或 `protected`，具体取决于你想要提供给父成员变量和函数的最小访问级别。
- en: 'Let''s look at an example of inheritance. Consider the same `shape` class,
    which will be the parent class:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看继承的一个例子。考虑相同的 `shape` 类，它将是父类：
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since we want the `triangle` class to access `a` and `b` of the parent class,
    we have to set the access specifier to protected, as shown previously; otherwise,
    it will be set to private by default. In addition to this, we also change the
    data type to floats for more precision. After doing this, we create a `setValues`
    function instead of the constructor to set the values for `a` and `b`. We then
    create a child class of `shape` and call it `triangle`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望`triangle`类能够访问父类的`a`和`b`，我们必须将访问修饰符设置为protected，如前所述；否则，它将默认设置为private。除此之外，我们还更改了数据类型为float以获得更高的精度。完成这些后，我们创建了一个名为`setValues`的函数来设置`a`和`b`的值。然后我们创建了一个`shape`类的子类，命名为`triangle`：
- en: '[PRE60]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Due to inheritance from the `shape` class, we don't have to add the `a` and
    `b` member variables, and we don't need to add the `setValues` member function either, as
    this is inherited from the `shape` class. We just add a new function called `area`,
    which calculates the area of a triangle.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从`shape`类继承，我们不需要添加`a`和`b`成员变量，也不需要添加`setValues`成员函数，因为这些是从`shape`类继承的。我们只需添加一个名为`area`的新函数，该函数计算三角形的面积。
- en: 'In the main function, we create an object of the `triangle` class, set the
    values, and print the area, as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们创建了一个`triangle`类的对象，设置了值，并按如下方式打印面积：
- en: '[PRE61]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here is the output of this:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个输出的内容：
- en: '![](img/724e481f-d5f1-4dac-a6cd-1a66fa15d3ac.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/724e481f-d5f1-4dac-a6cd-1a66fa15d3ac.png)'
- en: 'To calculate the area of `circle`, we modify the `shape` class and add a new
    overloaded `setValues` function, as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算`circle`的面积，我们修改了`shape`类并添加了一个新的重载的`setValues`函数，如下所示：
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We will then add a new inherited class, called `circle`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将添加一个新的继承类，命名为`circle`：
- en: '[PRE63]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the main function, we create a new `circle` object, set the radius, and
    print the area:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们创建一个新的`circle`对象，设置半径，并打印面积：
- en: '[PRE64]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here is the output of this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个输出的内容：
- en: '![](img/12973d84-a6e2-44ed-b42c-4c574172df4f.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12973d84-a6e2-44ed-b42c-4c574172df4f.png)'
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of programming—from what variables are
    and how to store values in them, to looking at operators and statements, to how
    to decide when each is required. After that, we looked at iterators and functions,
    which can be used to make our job simpler and automate the code as much as possible.
    Arrays and pointers help us to group and store data of a similar type, and with
    `struct` and `enum` we can create custom data types. Finally, we looked at classes
    and inheritance, which is the crux of using C++ and makes it convenient to define
    our data types with custom properties.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了编程的基础知识——从变量是什么以及如何将值存储在它们中，到查看运算符和语句，到如何决定何时需要它们。之后，我们探讨了迭代器和函数，这些可以简化我们的工作并尽可能自动化代码。数组和指针帮助我们分组和存储类似类型的数据，而`struct`和`enum`则允许我们创建自定义数据类型。最后，我们探讨了类和继承，这是使用C++的关键，使得定义具有自定义属性的我们的数据类型变得方便。
- en: In the next chapter, we will look at the foundation of graphics programming
    and explore how three-dimensional and two-dimensional objects are displayed on
    the screen.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨图形编程的基础，并探索如何在屏幕上显示三维和二维对象。
