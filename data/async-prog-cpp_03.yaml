- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: How to Create and Manage Threads in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在C++中创建和管理线程
- en: As we learned in the previous two chapters, threads are the smallest and most
    lightweight units of execution within a program. Each thread takes care of a unique
    task defined by a sequence of instructions running on allocated CPU resources
    by the OS scheduler. Threads play a critical role when managing concurrency within
    a program aiming to maximize the overall utilization of CPU resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前两章所学，线程是程序中执行的最小且最轻量级的单元。每个线程负责由操作系统调度器在分配的CPU资源上运行的指令序列定义的唯一任务。当管理程序中的并发性以最大化CPU资源利用率时，线程发挥着关键作用。
- en: During the program’s startup process, after the kernel passes the execution
    to the process, the C++ runtime creates the main thread and executes the **main()**
    function. After that, additional threads can be created to split the program into
    different tasks that can run concurrently and share resources. This way, the program
    can handle multiple tasks, improving efficiency and responsiveness.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的启动过程中，在内核将执行权传递给进程之后，C++运行时创建主线程并执行**main()**函数。之后，可以创建额外的线程来将程序分割成不同的任务，这些任务可以并发运行并共享资源。这样，程序可以处理多个任务，提高效率和响应速度。
- en: In this chapter, we will learn the basics of how to create and manage threads
    using modern C++ features. In the subsequent chapters, we will come across explanations
    of C++ lock synchronization primitives (mutexes, semaphores, barriers, and spinlocks),
    lock-free synchronization primitives (atomic variables), coordination synchronization
    primitives (condition variables), and approaches using C++ to solve or avoid potential
    problems when using concurrency or multithreading (race conditions or data races,
    deadlocks, livelocks, starvation, oversubscription, load balancing, and thread
    exhaustion).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用现代C++特性创建和管理线程的基础知识。在随后的章节中，我们将遇到关于C++锁同步原语（互斥锁、信号量、屏障和自旋锁）、无锁同步原语（原子变量）、协调同步原语（条件变量）以及使用C++解决或避免并发或多线程使用时潜在问题的方法的解释（竞争条件或数据竞争、死锁、活锁、饥饿、过载订阅、负载均衡和线程耗尽）。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要主题：
- en: How to create, manage, and cancel threads in C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C++中创建、管理和取消线程
- en: How to pass arguments to threads and get results back from the thread
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向线程传递参数并从线程获取结果
- en: How to sleep a thread or yield execution to other threads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让线程休眠或让其他线程执行
- en: What jthread objects are and why they are useful
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jthread对象是什么以及为什么它们有用
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will develop different solutions using C++11 and C++20.
    Therefore, we will need to install the **GNU Compiler Collection** ( **GCC** ),
    specifically GCC 13, as well as Clang 8 (see [https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)
    for further details on C++ compiler support).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用C++11和C++20开发不同的解决方案。因此，我们需要安装**GNU编译器集合**（**GCC**），特别是GCC 13，以及Clang
    8（有关C++编译器支持的详细信息，请参阅[https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)）。
- en: 'You can find more information about GCC at [https://gcc.gnu.org](https://gcc.gnu.org)
    . You can find information on how to install GCC here: [https://gcc.gnu.org/install/index.html](https://gcc.gnu.org/install/index.html)
    .'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://gcc.gnu.org](https://gcc.gnu.org)找到更多关于GCC的信息。你可以在[https://gcc.gnu.org/install/index.html](https://gcc.gnu.org/install/index.html)找到有关如何安装GCC的信息。
- en: 'For more information about Clang, a compiler frontend supporting several languages
    including C++, visit [https://clang.llvm.org](https://clang.llvm.org) . Clang
    is part of the LLVM compiler infrastructure project ( [https://llvm.org](https://llvm.org)
    ). C++ support in Clang is documented here: [https://clang.llvm.org/cxx_status.html](https://clang.llvm.org/cxx_status.html)
    .'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于支持包括C++在内的多种语言的编译器前端Clang的信息，请访问[https://clang.llvm.org](https://clang.llvm.org)。Clang是LLVM编译器基础设施项目的一部分（[https://llvm.org](https://llvm.org)）。Clang中的C++支持在此处文档化：[https://clang.llvm.org/cxx_status.html](https://clang.llvm.org/cxx_status.html)。
- en: 'In this book, some code snippets do not show the libraries included. Additionally,
    some functions, even the main ones, might be simplified, showing only the relevant
    instructions. You can find all the complete code in the following GitHub repository:
    [https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)
    .'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，一些代码片段没有显示包含的库。此外，一些函数，即使是主要的函数，也可能被简化，只显示相关的指令。你可以在以下 GitHub 仓库中找到所有完整的代码：[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)。
- en: Under the **scripts** folder in the root directory in the preceding GitHub repository,
    you can find a script called **install_compilers.sh** that might be of help with
    installing the required compilers in Debian-based Linux systems. The script has
    been tested in Ubuntu 22.04 and 24.04.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个 GitHub 仓库的根目录下的 **scripts** 文件夹中，你可以找到一个名为 **install_compilers.sh** 的脚本，这个脚本可能有助于在基于
    Debian 的 Linux 系统中安装所需的编译器。该脚本已在 Ubuntu 22.04 和 24.04 上进行了测试。
- en: 'The examples for this chapter are located under the **Chapter_03** folder.
    All source code files can be compiled using C++20 with CMake as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例位于 **Chapter_03** 文件夹下。所有源代码文件都可以使用 C++20 和 CMake 编译，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Executables will be generated under the **bin** directory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件将在 **bin** 目录下生成。
- en: The thread library – an introduction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程库——简介
- en: The main library to create and manage threads in C++ is the thread library.
    First, let’s go through a recap about threads. Then we will dive into what the
    thread library offers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中创建和管理线程的主要库是线程库。首先，让我们回顾一下线程。然后我们将深入了解线程库提供了什么。
- en: What are threads? Let’s do a recap
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是线程？让我们回顾一下
- en: The purpose of threads is to execute multiple simultaneous tasks in a process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的目的是在一个进程中执行多个同时任务。
- en: As we have seen in the previous chapter, a thread has its own stack, local data,
    and CPU registers such as **Instruction Pointer** ( **IP** ) and **Stack Pointer**
    ( **SP** ), but shares the address space and virtual memory of its parent process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中看到的，线程有自己的堆栈、局部数据和 CPU 寄存器，如 **指令指针** ( **IP** ) 和 **堆栈指针** ( **SP**
    )，但与父进程共享地址空间和虚拟内存。
- en: In the user space, we can differentiate between **native threads** and **lightweight
    or virtual threads** . Native threads are the ones created by the OS when using
    some kernel APIs. The C++ thread objects create and manage these types of threads.
    On the other hand, lightweight threads are like native threads, except that they
    are emulated by a runtime or library. In C++, **coroutines** belong to this group.
    As described in the previous chapter, lightweight threads have faster context
    switching than native threads. Also, multiple lightweight threads can run in the
    same native thread and can be much smaller than native threads.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户空间中，我们可以区分 **原生线程** 和 **轻量级或虚拟线程**。原生线程是在使用某些内核 API 时由操作系统创建的。C++ 线程对象创建和管理这些类型的线程。另一方面，轻量级线程类似于原生线程，但它们是由运行时或库模拟的。如前一章所述，轻量级线程比原生线程具有更快的上下文切换。此外，多个轻量级线程可以在同一个原生线程中运行，并且可以比原生线程小得多。
- en: In this chapter, we will start learning about native threads. In [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164)
    , we will learn about lightweight threads in the form of coroutines.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始学习原生线程。在 [*第 8 章*](B22219_08.xhtml#_idTextAnchor164) 中，我们将学习以协程形式存在的轻量级线程。
- en: The C++ thread library
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 线程库
- en: In C++, threads allow multiple functions to run concurrently. The **thread**
    class defines a type-safe interface to a native thread. This class is defined
    in the **std::thread** library, in the **<thread>** header file in the **Standard
    Template Library** ( **STL** ). It is available from C++11 onward.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，线程允许多个函数并发运行。**线程**类定义了一个对原生线程的类型安全接口。这个类在 **std::thread** 库中定义，位于 **Standard
    Template Library** ( **STL** ) 的 **<thread>** 头文件中。从 C++11 开始，它就可用。
- en: Before the inclusion of the thread library in the C++ STL, developers used platform-specific
    libraries such as the POSIX thread ( **pthread** ) library in Unix or Linux OSs,
    the **C Runtime** ( **CRT** ) and Win32 libraries for Windows NT and CE systems,
    or third-party libraries such as **Boost.Threads** . In this book, we will only
    use modern C++ features. As **<thread>** is available and provides a portable
    abstraction on top of platform-specific mechanisms, none of these libraries will
    be used or explained. In [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) , we
    will introduce **Boost.Asio** , and in [*Chapter 10*](B22219_10.xhtml#_idTextAnchor212)
    , **Boost.Cobalt** . Both libraries provide advanced frameworks to deal with asynchronous
    I/O operations and coroutines.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ STL 中包含线程库之前，开发者使用特定平台的库，例如 Unix 或 Linux 操作系统中的 POSIX 线程（**pthread**）库，Windows
    NT 和 CE 系统的 **C 运行时**（**CRT**）和 Win32 库，或者第三方库如 **Boost.Threads**。在这本书中，我们将只使用现代
    C++ 功能。由于 **<thread>** 可用并提供在特定平台机制之上的可移植抽象，因此不会使用或解释这些库。在 [*第 9 章*](B22219_09.xhtml#_idTextAnchor184)
    中，我们将介绍 **Boost.Asio**，在 [*第 10 章*](B22219_10.xhtml#_idTextAnchor212) 中，**Boost.Cobalt**。这两个库都提供了处理异步
    I/O 操作和协程的高级框架。
- en: Now it’s time to learn about the different thread operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习不同的线程操作了。
- en: Thread operations
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程操作
- en: In this section, we will learn how to create threads, pass arguments during
    their construction, return values from threads, cancel threads execution, catch
    exceptions, and much more.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何创建线程，在它们的构造过程中传递参数，从线程返回值，取消线程执行，捕获异常，以及更多。
- en: Thread creation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程创建
- en: When a thread is created, it executes immediately. It is only delayed by the
    OS scheduling process. If there are not enough resources to run both parent and
    child threads in parallel, the order in which they will run is not defined.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个线程时，它将立即执行。它只是被操作系统调度过程所延迟。如果没有足够的资源并行运行父线程和子线程，它们运行的顺序是不确定的。
- en: The constructor argument defines the function or **function** object to be executed
    by the thread. This callable object should not return anything, as its return
    value will be ignored. If for some reason the thread execution ends with an exception,
    **std::terminate** is called unless an exception is caught, as we will see later
    in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数参数定义了线程将要执行的功能或**函数**对象。这个可调用对象不应该返回任何内容，因为它的返回值将被忽略。如果由于某种原因线程执行以异常结束，除非捕获到异常，否则将调用
    **std::terminate**，正如我们将在本章后面看到的那样。
- en: In the following examples, we create six threads using different callable objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用不同的可调用对象创建了六个线程。
- en: '**t1** using a function pointer:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**t1** 使用函数指针：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**t2** using a lambda function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**t2** 使用 lambda 函数：'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**t3** using an embedded lambda function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**t3** 使用内嵌的 lambda 函数：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**t4** using a **function** object where **operator()** is overloaded:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**t4** 使用**函数**对象，其中**operator()**被重载：'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**t5** using a non-static **member** function by passing the address of the
    **member** function and the address of an object to call the **member** function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**t5** 通过传递**成员**函数的地址和对象的地址来使用非静态**成员**函数调用**成员**函数：'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**t6** using a static **member** function where only the address of the **member**
    function is needed as the method is static:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**t6** 使用静态**成员**函数，其中只需要**成员**函数的地址，因为方法是静态的：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Thread creation incurs some overhead that can be reduced by using thread pools,
    as we will explore in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 线程创建会产生一些开销，可以通过使用线程池来减少，正如我们将在 [*第 4 章*](B22219_04.xhtml#_idTextAnchor074)
    中探讨的那样。
- en: Checking hardware concurrency
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查硬件并发
- en: One of the strategies for effective thread management, which is related to scalability
    and performance and was commented on in the previous chapter, is to balance the
    number of threads with the available resources to avoid over-subscription.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有效线程管理的一种策略，这与可扩展性和性能相关，并在上一章中进行了评论，是平衡线程数与可用资源以避免过度订阅。
- en: 'To retrieve the number of concurrent threads supported by the OS, we can use
    the **std::thread::hardware_concurrency()** function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索操作系统支持的并发线程数，我们可以使用 **std::thread::hardware_concurrency()** 函数：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The value returned by this function must be considered to only provide a hint
    about the number of threads that will run concurrently. It is also sometimes not
    well defined, thus returning a value of **0** .
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回的值必须被视为仅提供有关将要并发运行的线程数的提示。它有时也不太明确，因此返回值为 **0**。
- en: Synchronized stream writing
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步流写入
- en: When we print messages to the console by using **std::cout** from two or more
    threads, the output result can be messy. This is due to a **race condition** happening
    in the output stream.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用来自两个或更多线程的**std::cout**向控制台打印消息时，输出结果可能会很混乱。这是由于输出流中发生的**竞态条件**造成的。
- en: As commented in the previous chapter, race conditions are bugs in software that
    happen in concurrent and multithreaded programs, whose behavior depends on the
    sequence of events happening on a shared resource where at least one of the actions
    is not atomic. We will learn more about how to avoid them in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074)
    . Additionally, we will learn how to debug race conditions using Clang’s sanitizers
    in [*Chapter 12*](B22219_12.xhtml#_idTextAnchor243) .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，竞态条件是并发和多线程程序中的软件错误，其行为取决于在共享资源上发生的事件序列，其中至少有一个操作不是原子的。我们将在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中了解更多如何避免它们。此外，我们还将学习如何使用Clang的sanitizers在[*第12章*](B22219_12.xhtml#_idTextAnchor243)中调试竞态条件。
- en: The following code snippet shows two threads printing a sequence of numbers.
    The **t1** thread should print lines containing the **1 2 3 4** sequence. The
    **t2** thread should print the **5 6 7 8** sequence. Each thread prints its sequence
    100 times. Before the main thread exits, it waits for **t1** and **t2** to finish
    by using **join()** .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了两个线程打印一系列数字。**t1**线程应打印包含**1 2 3 4**序列的行。**t2**线程应打印**5 6 7 8**序列。每个线程打印其序列100次。在主线程退出之前，它使用**join()**等待**t1**和**t2**完成。
- en: More about joining threads later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面将详细介绍如何加入线程。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, running the previous example shows some lines with the following content:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，运行前面的示例显示了一些包含以下内容的行：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To avoid these issues, we can simply write from a specific thread or use a
    **std::ostringstream** object that makes atomic calls to the **std::cout** object:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，我们可以简单地从一个特定的线程写入，或者使用一个**std::ostringstream**对象，该对象对**std::cout**对象进行原子调用：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From C++20 onward, we also can use the **std::osyncstream** objects. They behave
    similarly to **std::cout** but with writing synchronization between threads accessing
    the same stream. However, as only the transfer step from its internal buffer to
    the output stream is synchronized, every thread needs its own **std::osyncstream**
    instance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++20开始，我们还可以使用**std::osyncstream**对象。它们的行为类似于**std::cout**，但在访问同一流的线程之间具有写入同步。然而，由于只有从其内部缓冲区到输出流的传输步骤是同步的，因此每个线程都需要自己的**std::osyncstream**实例。
- en: The internal buffer is transferred when the stream is destroyed, which is when
    **emit()** is explicitly called.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当流被销毁时，内部缓冲区会被转移，这是在显式调用**emit()**时发生的。
- en: 'The following is a simple solution to allow synchronization on each printed
    line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的解决方案，允许在每行打印上进行同步：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both solutions will output the sequences without interleaving them
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种解决方案都将输出序列，而不进行交错。
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As this approach is now the official C++20 way of avoiding race conditions when
    outputting content, we will use **std::osyncstream** as the default approach throughout
    the rest of this book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方法现在是官方C++20避免输出内容时发生竞态条件的官方方法，因此我们将使用**std::osyncstream**作为本书其余部分默认的方法。
- en: Sleeping the current thread
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使当前线程休眠
- en: '**std::this_thread** is a namespace. It gives access to functions from the
    current thread to yield the execution to another thread or block the execution
    of the current task and wait for a period.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::this_thread**是一个命名空间。它提供了从当前线程访问函数以将执行权交予另一个线程或阻塞当前任务的执行并等待一段时间的功能。'
- en: The **std::this_thread::sleep_for** and **std::this_thread::sleep_until** functions
    block the execution of the thread for a given amount of time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::this_thread::sleep_for**和**std::this_thread::sleep_until**函数会阻塞线程的执行给定的时间长度。'
- en: '**std::this_thread::sleep_for** sleeps for at least a given duration. The blockage
    can be longer depending on how the OS scheduler decides to run tasks, or due to
    some resource contention delays.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::this_thread::sleep_for**至少休眠给定的时间长度。阻塞时间可能更长，这取决于操作系统调度器如何决定运行任务，或者由于某些资源争用延迟。'
- en: Resource contention
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 资源争用
- en: Resource contention occurs when demand exceeds supply for a certain shared resource,
    leading to performance degradation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当对某个共享资源的需求超过供应时，就会发生资源争用，导致性能下降。
- en: '**std::this_thread::sleep_until** works like **std::this_thread::sleep_for**
    . However, instead of sleeping for a duration, it sleeps until a specific time
    point has been reached. The clock where the time point is computed must meet the
    **Clock** requirement (you can find more information on this here: [https://en.cppreference.com/w/cpp/named_req/Clock](https://en.cppreference.com/w/cpp/named_req/Clock)
    ). It is recommended by the standard to use a steady clock instead of the system
    clock to set up the duration.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::this_thread::sleep_until**与**std::this_thread::sleep_for**类似。然而，它不是睡眠一段时间，而是睡眠直到达到特定的时间点。计算时间点所使用的时钟必须满足**Clock**要求（你可以在这里找到更多信息：[https://en.cppreference.com/w/cpp/named_req/Clock](https://en.cppreference.com/w/cpp/named_req/Clock)）。标准建议使用稳定的时钟而不是系统时钟来设置持续时间。'
- en: Identifying a thread
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程识别
- en: When debugging multithreaded solutions, it is useful to know which thread is
    executing a given function. Each thread can be identified by an identifier, making
    it possible to log in its value for traceability and debugging.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试多线程解决方案时，知道哪个线程正在执行给定的函数是有用的。每个线程都可以通过一个标识符来识别，这使得可以记录其值以进行跟踪和调试。
- en: '**std::thread::id** is a lightweight class that defines a unique identifier
    of thread objects ( **std::thread** and **std::jthread** , which we will introduce
    later in this chapter). This identifier is retrieved by using the **get_id()**
    function.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::thread::id**是一个轻量级类，它定义了线程对象（**std::thread**和**std::jthread**，我们将在本章后面介绍）的唯一标识符。该标识符通过使用**get_id()**函数检索。'
- en: Thread identifier objects can be compared, serialized, and printed via an output
    stream. They can also be used as a key in mapping containers, as they are supported
    by the **std::hash** function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 线程标识符对象可以通过输出流进行比较、序列化和打印。它们也可以用作映射容器中的键，因为它们支持**std::hash**函数。
- en: 'The following example prints the identifier of the **t** thread. Later in this
    chapter, we will learn how to create a thread and sleep for an interval of time:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例打印了**t**线程的标识符。在本章后面，我们将学习如何创建线程并睡眠一段时间：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Remember that when a thread finishes, its identifier can be reused by a future
    thread.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当一个线程完成时，其标识符可以被未来的线程重用。
- en: Passing arguments
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递参数
- en: Arguments can be passed to the thread by value, by reference, or as pointers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过值、引用或指针将参数传递给线程。
- en: 'Here we can see how to pass arguments by value:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到如何通过值传递参数：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Passing by value avoids data races. However, it is much more costly, as data
    is copied across.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值传递可以避免数据竞争。然而，它的成本要高得多，因为数据需要复制。
- en: 'The next example shows how to pass values by reference:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例显示了如何通过引用传递值：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or as **const-reference** :'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者作为**const-reference**：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Passing by reference is achieved by using **ref()** (non-const references) or
    **cref()** (const-references). Both are defined in the **<functional>** header
    file. This lets the variadic template define the thread constructor to treat the
    argument as a reference.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递是通过使用**ref()**（非const引用）或**cref()**（const引用）实现的。这两个都在**<functional>**头文件中定义。这允许变长模板定义线程构造函数，将参数作为引用处理。
- en: These helper functions are used to generate **std::reference_wrapper** objects,
    which wrap a reference in a copyable and assignable object. Missing these functions
    when passing arguments makes the arguments to be passed by value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助函数用于生成**std::reference_wrapper**对象，这些对象将引用包装在可复制和可赋值的对象中。在传递参数时缺少这些函数会使参数以值的方式传递。
- en: 'You can also move an object into a thread as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以按照以下方式将对象移动到线程中：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, note that trying to access the **v** vector in the main thread after
    it is moved into the **t** thread would result in undefined behavior.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在将**v**向量移动到**t**线程后，在主线程中尝试访问它会导致未定义的行为。
- en: 'Finally, we can also allow threads to access variables by lambda captures:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以允许线程通过lambda捕获访问变量：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the **str** variable is accessed by the **t** thread as a reference
    captured by the embedded lambda function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**str**变量是通过嵌入的lambda函数捕获的引用被**t**线程访问的。
- en: Returning values
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: To return values that have been computed in a thread, we can use a shared variable
    with a synchronization mechanism such as a mutex, lock, or atomic variable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回线程中计算出的值，我们可以使用带有同步机制（如互斥锁、锁或原子变量）的共享变量。
- en: 'In the following code snippet, we can see how to return a value computed by
    a thread by using an argument passed by a non-const reference (using **ref()**
    ). The **result** variable is computed within the **t** thread in the **func**
    function. The resulting value can be seen from the main thread. As we will learn
    in the next section, the **join()** function simply waits for the **t** thread
    to finish before letting the main thread continue running and checking the **result**
    variable afterward:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们可以看到如何通过使用非const引用传递的参数来返回线程计算出的值（使用**ref()**）。在**func**函数中，**result**变量在**t**线程中被计算。从主线程中可以看到结果值。正如我们将在下一节中学习的，**join()**函数只是等待**t**线程完成，然后让主线程继续运行，并在之后检查**result**变量：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The **reference** argument can be a reference to the input object itself, or
    to another variable where we want the result to be stored, as done in this example
    with the **result** variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**reference** 参数可以是输入对象的引用，或者是我们想要存储结果的另一个变量，就像在这个示例中用**result**变量所做的那样。'
- en: 'We can also return the value using a lambda capture, as shown in the following
    example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用lambda捕获来返回值，如下面的示例所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also do this by writing into a shared variable protected by a mutex,
    locking the mutex (using **std::lock_guard** , for example) before executing the
    writing operation. However, we will dive deeper into these mechanisms in [*Chapter
    4*](B22219_04.xhtml#_idTextAnchor074) :'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过写入由互斥锁保护的共享变量来实现这一点，在执行写入操作之前锁定互斥锁（例如使用**std::lock_guard**）。然而，我们将在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中更深入地探讨这些机制：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is a more elegant way of returning values from threads. This involves
    using futures and promises, which we will learn about in [*Chapter 6*](B22219_06.xhtml#_idTextAnchor125)
    .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从线程返回值有更优雅的方法。这涉及到使用future和promise，我们将在[*第6章*](B22219_06.xhtml#_idTextAnchor125)中学习。
- en: Moving threads
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动线程
- en: Threads can be moved but not copied. This is to avoid having two different thread
    objects to represent the same hardware thread.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以移动但不能复制。这是为了避免有两个不同的线程对象来表示相同的硬件线程。
- en: 'In the following example, **t1** is moved to **t2** using **std::move** . Therefore,
    **t2** inherits the same identifier as **t1** had before being moved and **t1**
    is not joinable, as it no longer contains any valid thread anymore:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，**t1**使用**std::move**移动到**t2**。因此，**t2**继承了**t1**移动之前的相同标识符，而**t1**不再可连接，因为它不再包含任何有效的线程：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When a **std::thread** object is moved to another **std::thread** object, the
    move-from-thread object will reach a state where it does not represent a real
    thread anymore. This situation also happens to thread objects resulting from the
    default constructor after detaching or joining them. We will introduce these operations
    in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个**std::thread**对象被移动到另一个**std::thread**对象时，移动线程对象将达到一个不再表示真实线程的状态。这种情况也发生在分离或连接后由默认构造函数生成的线程对象上。我们将在下一节中介绍这些操作。
- en: Waiting for a thread to finish
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待线程完成
- en: There are use cases where a thread needs to wait for another thread to finish
    so that it can use the result computed by the latter thread. Other use cases involve
    running a thread in the background, detaching it, and continuing to execute the
    main thread.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些用例需要线程等待另一个线程完成，以便它可以使用后者线程计算出的结果。其他用例包括在后台运行线程，将其分离，并继续执行主线程。
- en: Joining a thread
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接线程
- en: The **join()** function blocks the current thread while waiting for the completion
    of the joining thread identified by the thread object where the **join()** function
    is being called. This ensures that the joining thread has terminated after **join()**
    returns (see the *Thread life cycle* section in [*Chapter 2*](B22219_02.xhtml#_idTextAnchor035)
    for more details).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**join()** 函数在等待由调用**join()**函数的线程对象指定的连接线程完成时阻塞当前线程。这确保了在**join()**返回后连接线程已经终止（有关更多详细信息，请参阅[*第2章*](B22219_02.xhtml#_idTextAnchor035)中的*线程生命周期*部分）。'
- en: It is easy to forget to use a **join()** function. **Joining Thread** ( **jthread**
    ) solves that problem. It is available from C++20 onward. We will introduce it
    in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记使用**join()**函数。**Joining Thread**（**jthread**）解决了这个问题。它从C++20开始可用。我们将在下一节中介绍它。
- en: Checking whether a thread is joinable
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查线程是否可连接
- en: A thread is considered joinable and therefore active if the **join()** function
    has not been called in that thread. This is true even if the thread has finished
    executing code but still has not been joined. On the other hand, a default constructed
    thread or a thread that has already been joined is *not* joinable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个线程中没有调用 **join()** 函数，则该线程被认为是可连接的并且是活跃的。即使线程已经执行了代码但尚未连接，这也是正确的。另一方面，默认构造的线程或已经连接的线程是不可连接的。
- en: To check whether a thread is joinable, just use the **std::thread::joinable()**
    function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查线程是否可连接，只需使用 **std::thread::joinable()** 函数。
- en: 'Let us see the usage of **std::thread::join()** and **std::thread::joinable()**
    in the following example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例中 **std::thread::join()** 和 **std::thread::joinable()** 的用法：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After **t1** has been constructed using the default constructor (not specifying
    a callable object), the thread will not be joinable. As **t2** is constructed
    specifying a function, **t2** is joinable after construction. However, when **t1**
    and **t2** are swapped, **t1** becomes joinable again and **t2** is not joinable
    anymore. Then the main thread waits for **t1** to join, so it is no longer joinable.
    Trying to join **t2** , a non-joinable thread, results in undefined behavior.
    Finally, not joining a joinable thread will lead to resource leaks or potential
    program crashes due to the unexpected use of shared resources.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认构造函数（未指定可调用对象）构造 **t1** 后，该线程将不可连接。由于 **t2** 构造时指定了函数，**t2** 在构造后是可连接的。然而，当
    **t1** 和 **t2** 交换时，**t1** 再次变为可连接的，而 **t2** 则不再可连接。然后主线程等待 **t1** 连接，因此它不再可连接。尝试连接一个不可连接的线程
    **t2** 将导致未定义的行为。最后，不连接一个可连接的线程将导致资源泄漏或由于共享资源的意外使用而可能引发程序崩溃。
- en: Daemon thread by detaching
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过分离实现守护线程
- en: If we want a thread to continue running in the background as a **daemon thread**
    but finish the execution of the current thread, we can use the **std::thread::detach()**
    function. A daemon thread is a thread that performs some tasks in the background
    that do not need to run to completion. If the main program exits, all daemon threads
    are terminated. As commented earlier, a thread must join or detach before the
    main thread terminates, otherwise the program will abort its execution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望一个线程作为守护线程在后台继续运行，但完成当前线程的执行，我们可以使用 **std::thread::detach()** 函数。守护线程是在后台执行一些不需要运行到完成的任务的线程。如果主程序退出，所有守护线程都将被终止。如前所述，线程必须在主线程终止之前连接或分离，否则程序将中止执行。
- en: After calling **detach** , the detached thread cannot be controlled or joined
    (as it is waiting for its completion) using the **std::thread** object, as this
    object no longer represents the detached thread.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 **detach** 之后，分离的线程无法通过 **std::thread** 对象进行控制或连接（因为它正在等待其完成），因为这个对象不再代表分离的线程。
- en: 'The following example shows a daemon thread called **t** that is detached just
    after construction, running the **daemonThread()** function in the background.
    This function executes for three seconds and then exits, finishing the thread
    execution. Meanwhile, the main thread sleeps for one more second than the thread
    execution time before exiting:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个名为 **t** 的守护线程，它在构造后立即分离，在后台运行 **daemonThread()** 函数。这个函数执行三秒钟后退出，完成线程执行。同时，主线程在退出前比线程执行时间多睡一秒钟：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Joining threads – the jthread class
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程连接 – jthread 类
- en: 'From C++20 onward, there is a new class: **std::jthread** . This class is like
    **std:thread** but with the additional functionality that the thread rejoins on
    destruction, following the **Resource Acquisition is Initialization** ( **RAII**
    ) technique. It can be canceled or stopped in some scenarios.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C++20 开始，有一个新的类：**std::jthread**。这个类类似于 **std::thread**，但增加了额外的功能，即线程在析构时自动重新连接，遵循
    **资源获取即初始化**（**RAII**）技术。在某些情况下，它可以被取消或停止。
- en: 'As you can see in the following example, a **jthread** thread has the same
    interface as **std::thread** . The only difference is that we do not need to call
    the **join()** function to ensure that the main thread waits for the **t** thread
    to join:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下示例所示，**jthread** 线程具有与 **std::thread** 相同的接口。唯一的区别是我们不需要调用 **join()** 函数来确保主线程等待
    **t** 线程连接：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When two **std::jthread** s are destroyed, their destructors are called in
    reverse order from their constructors. To demonstrate this behavior, let us implement
    a thread wrapper class that prints some messages when the wrapped thread is created
    and destroyed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个**std::jthread**被销毁时，它们的析构函数按照从构造函数相反的顺序被调用。为了演示这种行为，让我们实现一个线程包装类，当包装的线程被创建和销毁时打印一些消息：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using this **JthreadWrapper** wrapper class, we start three threads that execute
    the **func** function. Each will wait for a second before exiting:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个**JthreadWrapper**包装类，我们启动了三个线程来执行**func**函数。每个线程将在退出前等待一秒钟：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This program will show the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序将显示以下输出：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, **t1** is created first, then **t2** , and finally **t3** . The
    destructors follow the reverse order, with **t3** being destroyed first, then
    **t2** , and **t1** last.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**t1**首先被创建，然后是**t2**，最后是**t3**。析构函数遵循相反的顺序，**t3**首先被销毁，然后是**t2**，最后是**t1**。
- en: As jthreads avoid pitfalls when we forget to use **join** in a thread, we simply
    prefer to use **std::jthread** over **std::thread** . There might be cases where
    we need to use explicit calls to **join()** to be sure that threads have been
    joined and resources properly freed up before moving to another task.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于jthreads在忘记在线程中使用**join**时可以避免陷阱，我们更倾向于使用**std::jthread**而不是**std::thread**。可能会有一些情况，我们需要显式调用**join()**来确保在移动到另一个任务之前线程已经连接并且资源已经适当释放。
- en: Yielding thread execution
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让出线程执行
- en: A thread can also decide to pause its execution, let the implementation reschedule
    the execution of threads, and give the chance to other threads to run.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 线程也可以决定暂停其执行，让实现重新调度线程的执行，并给其他线程运行的机会。
- en: The **std::this_thread::yield** method provides a hint to the OS to reschedule
    another thread. The behavior is implementation-dependent, depending on the OS
    scheduler and the current state of the system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::this_thread::yield**方法向操作系统提供提示以重新调度另一个线程。其行为依赖于实现，取决于操作系统调度程序和系统的当前状态。'
- en: Some Linux implementations suspend the current thread and move it back to a
    queue of threads to schedule all threads with the same priority. If this queue
    is empty, the yield has no effect.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Linux实现会挂起当前线程并将其移回一个线程队列以调度具有相同优先级的所有线程。如果这个队列是空的，则让出（yield）没有效果。
- en: 'The following example shows two threads, **t1** and **t2** , executing the
    same work function. They randomly choose to either do some work (locking a mutex,
    as we will learn about in the next chapter, and waiting for three seconds) or
    yield the execution to the other thread:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了两个线程，**t1**和**t2**，执行相同的工作函数。它们随机选择要么做一些工作（锁定互斥锁，我们将在下一章中了解）或让出执行权给另一个线程：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When running this example, when the execution reaches the yield command, we
    can see how the thread that is currently running stops and enables the other thread
    to restart its execution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此示例时，当执行达到让出（yield）命令时，我们可以看到当前运行的线程如何停止并允许其他线程重新启动其执行。
- en: Threads cancellation
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程取消
- en: If we are no longer interested in the result that a thread is computing, we
    will want to cancel that thread and avoid more computation costs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不再对线程正在计算的结果感兴趣，我们希望取消该线程并避免更多的计算成本。
- en: Killing a thread could be a solution. However, that leaves resources that belong
    to the thread handling, such as other threads started from that thread, locks,
    connections, and so on. This could mean ending the program with undefined behavior,
    a critical section locked under a mutex, or any other unexpected issue.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 杀死线程可能是一个解决方案。然而，这会留下属于线程处理者的资源，例如从该线程启动的其他线程、锁、连接等。这可能导致程序以未定义的行为结束，在互斥锁下锁定关键部分，或任何其他意外问题。
- en: To avoid these problems, we need a data race-free mechanism to let the thread
    know about the intention to stop its execution (to request a stop) so that the
    thread can take all the specific steps needed to cancel its work and terminate
    gracefully.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，我们需要一个无数据竞争的机制，让线程知道停止执行（请求停止）的意图，以便线程可以采取所有必要的具体步骤来取消其工作并优雅地终止。
- en: One of the possible ways of achieving this is by using an atomic variable that
    is periodically checked by the thread. We will explore atomic variables at length
    in the next chapter. For now, let’s define an atomic variable as a variable that
    many threads can write or read from without any locking mechanism or data race
    due to its atomic transaction operations and memory model.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种可能方式是使用原子变量，该变量由线程定期检查。我们将在下一章详细探讨原子变量。现在，让我们将原子变量定义为一个变量，许多线程可以无任何锁定机制或由于原子事务操作和内存模型导致的数据竞争来读写它。
- en: 'As an example, let us create a **Counter** class that calls a callback every
    second. This is done infinitely until the **running** atomic variable is set to
    **false** , when a caller uses the **stop()** function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们创建一个**Counter**类，该类每秒调用一次回调。这是无限期进行的，直到调用者使用**stop()**函数将**running**原子变量设置为**false**：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the caller function, we will instantiate **Counter** as follows. Then, when
    desired (here, that is after three seconds), we will call the **stop()** function,
    letting **Counter** exit the loop and terminate the thread execution:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数中，我们将如下实例化**Counter**。然后，在需要的时候（这里是在三秒后），我们将调用**stop()**函数，让**Counter**退出循环并终止线程执行：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since C++20, there has been a new mechanism called **cooperative interruption**
    of a thread. This is available via **std::stop_token** .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++20以来，出现了一种新的线程协作中断机制。这可以通过**std::stop_token**来实现。
- en: The thread knows that a stop was requested by checking the result of calling
    the **std::stop_token::stop_requested()** function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 线程通过调用**std::stop_token::stop_requested()**函数的结果来检查是否请求了停止。
- en: To produce **stop_token** , we will use a **stop_source** object via the **std::stop_source::get_token()**
    function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成**stop_token**，我们将通过**stop_source**对象使用**std::stop_source::get_token()**函数。
- en: This thread cancellation mechanism is implemented in **std::jthead** objects
    via an internal member of the **std::stop_source** type where the shared stop
    state is stored. The **jthread** constructor accepts **std::stop_token** as its
    first argument. This is used when a stop is requested during execution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种线程取消机制是通过**std::jthead**对象中**std::stop_source**类型的内部成员实现的，其中存储了共享的停止状态。**jthread**构造函数接受**std::stop_token**作为其第一个参数。这用于在执行期间请求停止。
- en: Therefore, **std::jthread** exposes some additional functions to manage stop
    tokens compared with **std::thread** objects. These functions are **get_stop_source()**
    , **get_stop_token()** , and **request_stop()** .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与**std::thread**对象相比，**std::jthread**暴露了一些额外的函数来管理停止令牌。这些函数是**get_stop_source()**、**get_stop_token()**和**request_stop()**。
- en: When **request_stop()** is called, it issues a stop request to the internal
    stop state, which is atomically updated to avoid race conditions (you will learn
    more about atomic variables in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074)
    ).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用**request_stop()**时，它向内部停止状态发出停止请求，该状态原子更新以避免竞争条件（你将在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中了解更多关于原子变量的内容）。
- en: Let us check how all these functions work in the following example.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下示例中所有这些函数是如何工作的。
- en: 'First, we will define a template function to show the properties of a stop
    item object ( **stop_token** or **stop_source** ):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个模板函数来展示停止项对象（**stop_token**或**stop_source**）的属性：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, within the **main()** function, we will start a worker thread, acquire
    its stop token object, and show its properties:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在**main()**函数中，我们将启动一个工作线程，获取其停止令牌对象，并展示其属性：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Worker1** is running the **func_with_stop_token()** function that is defined
    in the ensuing code block. In this function, the stop token is checked by using
    the **stop_requested()** function. If this function returns **true** , a stop
    was requested, so the function simply returns, terminating the thread execution.
    Otherwise, it runs the next loop iteration, sleeping the current thread for further
    300 ms until the next stop request check:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Worker1**正在运行定义在下述代码块中的**func_with_stop_token()**函数。在这个函数中，通过使用**stop_requested()**函数来检查停止令牌。如果这个函数返回**true**，则表示请求了停止，因此函数简单地返回，终止线程执行。否则，它将运行下一个循环迭代，使当前线程休眠300毫秒，直到下一次停止请求检查：'
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can request a stop from the main thread by using the stop token returned
    by the thread object as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用线程对象返回的停止令牌来从主线程请求停止，如下所示：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also, we can request a stop from a different thread. For this, we need to pass
    a **stop_source** object. In the following code snippet, we can see how a thread
    stopper is created with a **stop_source** object as an argument, acquired from
    the **worker2** worker thread:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以从不同的线程请求停止。为此，我们需要传递一个**stop_source**对象。在下面的代码片段中，我们可以看到如何使用从**worker2**工作线程获取的**stop_source**对象创建一个线程停止器：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The **stopper** thread waits for 0.5 seconds and requests a stop from the **stop_source**
    object. Then **worker2** becomes aware of that request and terminates its execution,
    as explained earlier.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**stopper**线程等待0.5秒，然后从**stop_source**对象请求停止。然后**worker2**意识到这个请求，并终止其执行，如前所述。'
- en: 'We can also register a callback function that will invoke a function when a
    stop is requested via a stop token or stop source. This can be done by using the
    **std::stop_callback** object, as shown in the ensuing code block:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注册一个回调函数，当通过停止令牌或停止源请求停止时，将调用该函数。这可以通过使用**std::stop_callback**对象来实现，如下面的代码块所示：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If a **std::stop_callback** object is destroyed, its execution is prevented.
    For example, this scoped stop callback will not execute, as the callback object
    is destroyed when going out of scope:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果销毁了**std::stop_callback**对象，将阻止其执行。例如，这个作用域内的停止回调将不会执行，因为回调对象在超出作用域时被销毁：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After a stop has already been requested, a new stop callback object will execute
    immediately. In the following example, if a stop has been requested for **worker2**
    , **callback_after_stop** will execute the lambda function just after construction:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在已经请求停止之后，新的停止回调对象将立即执行。在以下示例中，如果已经为**worker2**请求了停止，**callback_after_stop**将在构造后立即执行lambda函数：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Catching exceptions
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获异常
- en: Any unhandled exception thrown within a thread needs to be caught within that
    thread. Otherwise, the C++ runtime calls **std::terminate** , causing the program
    to terminate abruptly. This causes unexpected behavior, data loss, or even program
    crashes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程内部抛出的任何未处理的异常都需要在该线程内部捕获。否则，C++运行时会调用**std::terminate**，导致程序突然终止。这会导致意外的行为、数据丢失，甚至程序崩溃。
- en: One solution is to use try-catch blocks within the thread to catch exceptions.
    However, only exceptions thrown within that thread will be caught. Exceptions
    do not propagate to other threads.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是在线程内部使用try-catch块来捕获异常。然而，只有在该线程内部抛出的异常才会被捕获。异常不会传播到其他线程。
- en: To propagate an exception to another thread, one thread can capture it and store
    it into a **std::exception_ptr** object, then use shared memory techniques to
    pass it to another thread, where the **std::exception_ptr** object will be checked
    and the exception re-thrown if needed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要将异常传播到另一个线程，一个线程可以捕获它并将其存储到**std::exception_ptr**对象中，然后使用共享内存技术将其传递到另一个线程，在那里将检查**std::exception_ptr**对象并在需要时重新抛出异常。
- en: 'The following example shows this approach:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这种方法：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we can see how a **std::runtime_error** exception is thrown when executing
    the **func** function by the **t** thread. The exception is caught and stored
    in **captured_exception** , a **std::exception_ptr** shared object protected by
    a mutex. The type and value of the thrown exception are determined by calling
    the **std::current_exception()** function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到当**t**线程执行**func**函数时抛出的**std::runtime_error**异常。异常被捕获并存储在**captured_exception**中，这是一个由互斥锁保护的**std::exception_ptr**共享对象。抛出异常的类型和值是通过调用**std::current_exception()**函数确定的。
- en: In the main thread, the **while** loop runs until an exception is captured.
    The exception is re-thrown in the main thread by calling **std::rethrow_exception(captured_exception)**
    . It is caught again by the main thread where the **catch** block is executed,
    printing a message to the console via the **std::cerr** error stream.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程中，**while**循环会一直运行，直到捕获到异常。通过调用**std::rethrow_exception(captured_exception)**在主线程中重新抛出异常。异常再次被主线程捕获，在**catch**块中执行，通过**std::cerr**错误流向控制台打印消息。
- en: We will learn a better solution in [*Chapter 6*](B22219_06.xhtml#_idTextAnchor125)
    by using futures and promises.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B22219_06.xhtml#_idTextAnchor125)中学习一个更好的解决方案，通过使用future和promise。
- en: Thread-local storage
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程局部存储
- en: '**Thread-local Storage** ( **TLS** ) is a memory management technique that
    allows each thread to have its own instance of a variable. This technique allows
    threads to store thread-specific data that is not accessible by other threads,
    avoiding race conditions and improving performance. This is because the overhead
    of synchronization mechanisms to access these variables is removed.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程局部存储**（**TLS**）是一种内存管理技术，允许每个线程拥有自己的变量实例。这种技术允许线程存储其他线程无法访问的线程特定数据，避免竞态条件并提高性能。这是因为访问这些变量的同步机制的开销被消除了。'
- en: TLS is implemented by the OS and accessible by using the **thread_local** keyword,
    which has been available since C++11. **thread_local** provides a uniform way
    to use the TLS capabilities of many OSs and avoid compiler-specific language extensions
    for accessing the TLS feature (some examples of such extensions are the TLS Windows
    API, the **__declspec(thread)** MSVC compiler language extension, or the **__thread**
    GCC compiler language extension).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: TLS由操作系统实现，可以通过使用**thread_local**关键字访问，该关键字自C++11以来一直可用。**thread_local**提供了一种统一的方式来使用许多操作系统的TLS功能，并避免使用特定编译器的语言扩展来访问TLS功能（此类扩展的示例包括TLS
    Windows API、**__declspec(thread)** MSVC编译器语言扩展或**__thread** GCC编译器语言扩展）。
- en: To use TLS with compilers that do not support C++11 or newer versions, use **Boost.Library**
    . This provides the **boost::thread_specific_ptr** container, which implements
    portable TLS.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用不支持C++11或更高版本的编译器的TLS，请使用**Boost.Library**。这提供了**boost::thread_specific_ptr**容器，它实现了可移植的TLS。
- en: 'Thread-local variables can be declared as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 线程局部变量可以声明如下：
- en: Globally
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局范围内
- en: In namespaces
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名空间中
- en: As class static member variables
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为类的静态成员变量
- en: Inside functions; it has the same effect as variables allocated with the **static**
    keyword, meaning that the variables are allocated for the lifetime of the program
    and their value are carried through the next function call
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部；它具有与使用**static**关键字分配的变量相同的效果，这意味着变量在程序的生命周期内分配，其值在下一个函数调用中传递
- en: 'The following examples show three threads calling the **multiplyByTwo** function
    with different arguments. This function sets the value of the **val** thread-local
    variable to the argument value, multiplies it by 2, and prints to the console:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了三个线程使用不同参数调用**multiplyByTwo**函数。此函数将**val**线程局部变量的值设置为参数值，将其乘以2，并打印到控制台：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running this code snippet will show the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码片段将显示以下输出：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we can see that each thread operated on its input argument, resulting
    in **t1** printing **2** , **t2** printing **4** , and **t3** printing **6** .
    The main thread running the main function can also access its thread local variable,
    **val** , which has a value that is set to **1** when the program starts but only
    used when printed out to console at the end of the main function before exiting
    the program.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到每个线程都操作其输入参数，导致**t1**打印**2**，**t2**打印**4**，**t3**打印**6**。运行主函数的主线程也可以访问其线程局部变量**val**，该变量在程序开始时设置为**1**，但在主函数结束时打印到控制台之前仅用于打印，然后退出程序。
- en: As with any technique, there are some drawbacks. TLS increases memory usage,
    as a variable is created per thread, so it could be problematic in resource-constrained
    environments. Also, accessing TLS variables might have some overhead compared
    with regular variables. This can be problematic in performance-critical software.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何技术一样，也有一些缺点。TLS会增加内存使用量，因为每个线程都会创建一个变量，所以在资源受限的环境中可能会出现问题。此外，访问TLS变量可能比常规变量有一些开销。这在性能关键型软件中可能是一个问题。
- en: Using many of the techniques we have learned so far, let’s build a timer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们迄今为止学到的许多技术，让我们构建一个计时器。
- en: Implementing a timer
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现计时器
- en: Let us implement a timer that accepts intervals and callback functions. The
    timer will execute the callback function at each interval. Also, the user will
    be able to stop the timer by calling its **stop()** function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个接受间隔和回调函数的计时器。计时器将在每个间隔执行回调函数。此外，用户可以通过调用其**stop()**函数来停止计时器。
- en: 'The following snippet shows an implementation of the timer:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了计时器的实现：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The **Timer** constructor accepts a **Callback** function (a **std::function<void(void)>**
    object) and a **std::chrono::duration** object defining the period or interval
    when the callback will be executed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**Timer**构造函数接受一个**Callback**函数（一个**std::function<void(void)>**对象）和一个定义回调将执行的周期或间隔的**std::chrono::duration**对象。'
- en: Then a **std::jthread** object is created with a lambda expression, whereby
    a loop calls the callback in intervals of time. This loop checks whether a stop
    has been requested via **stop_token** , which is enabled by using the **stop()**
    **Timer** API function. When this is the case, the loop exits and the thread terminates.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 lambda 表达式创建一个 **std::jthread** 对象，其中循环以时间间隔调用回调函数。这个循环检查是否通过 **stop_token**
    请求停止，这是通过使用 **stop()** **计时器** API 函数来实现的。当这种情况发生时，循环退出，线程终止。
- en: 'Here is how to use it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用它的：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this example, we started the timer that will print the **Callback: Running**
    message every second. After three seconds, the main thread will call the **timer.stop()**
    function, terminating the timer thread. The main thread then waits for 500 milliseconds
    before exiting.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们启动了计时器，每秒将打印**回调：运行**消息。三秒后，主线程将调用**timer.stop()**函数，终止计时器线程。然后主线程等待
    500 毫秒后退出。
- en: 'This is the output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As an exercise, you can slightly modify this example to implement a timeout
    class that calls a callback function if there is no input event within a given
    timeout interval. This is a common pattern when dealing with network communications
    where a packet replay request is sent if no packets have been received for some
    time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以稍微修改这个示例来实现一个超时类，如果给定超时间隔内没有输入事件，它会调用回调函数。在处理网络通信时，这是一个常见的模式，如果在一段时间内没有接收到数据包，则会发送数据包重放请求。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create and manage threads, how to pass arguments
    or retrieve results, how TLS works, and how to wait for a thread to finish. We
    also learned how to make a thread yield control to others or cancel its execution.
    If something goes wrong and an exception is thrown, we now know how to pass the
    exception between threads and avoid an unexpected program termination. Finally,
    we implemented a **timer** class that periodically runs a callback function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何创建和管理线程，如何传递参数或检索结果，如何工作 TLS，以及如何等待线程完成。我们还学习了如何使线程将控制权交给其他线程或取消其执行。如果出现问题并抛出异常，我们现在知道如何在线程之间传递异常并避免意外的程序终止。最后，我们实现了一个
    **计时器** 类，该类定期运行回调函数。
- en: In the next chapter, we will learn about thread safety, mutual exclusion, and
    atomic operations. That will include mutexes, locking and lock-free algorithms,
    and memory synchronization ordering, among other topics. That knowledge will help
    us develop thread-safe data structures and algorithms.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习线程安全、互斥和原子操作。这包括互斥锁、锁定和无锁算法，以及内存同步排序，以及其他主题。这些知识将帮助我们开发线程安全的数组和算法。
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Compiler support: [https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器支持：[https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)
- en: 'GCC releases: [https://gcc.gnu.org/releases.html](https://gcc.gnu.org/releases.html)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 版本：[https://gcc.gnu.org/releases.html](https://gcc.gnu.org/releases.html)
- en: 'Clang: [https://clang.llvm.org](https://clang.llvm.org)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang：[https://clang.llvm.org](https://clang.llvm.org)
- en: 'Clang 8 documentation: [https://releases.llvm.org/8.0.0/tools/clang/docs/index.html](https://releases.llvm.org/8.0.0/tools/clang/docs/index.html)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 8 文档：[https://releases.llvm.org/8.0.0/tools/clang/docs/index.html](https://releases.llvm.org/8.0.0/tools/clang/docs/index.html)
- en: 'LLVM project: [https://llvm.org](https://llvm.org)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 项目：[https://llvm.org](https://llvm.org)
- en: 'Boost.Threads: [https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html](https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Threads：[https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html](https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html)
- en: 'P0024 – Technical Specification for Parallelism: [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P0024 – 并行技术规范：[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html)
- en: 'TLS proposal: [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS 提案：[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm)
- en: '*Thread Launching for* *C++0X* : [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++0X 的线程启动*：[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html)'
- en: 'TLS from IBM: [https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html](https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IBM的TLS: [https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html](https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html)'
- en: '*Data that is private to a* *thread* : [https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread](https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线程专有的* 数据: [https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread](https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread)'
- en: '**Resource Acquisition Is Initialization** ( **RAII** ): [https://en.cppreference.com/w/cpp/language/raii](https://en.cppreference.com/w/cpp/language/raii)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源获取即初始化** ( **RAII** ): [https://en.cppreference.com/w/cpp/language/raii](https://en.cppreference.com/w/cpp/language/raii)'
- en: Bjarne Stroustrup, *A Tour of C++* , Third Edition, 18.2 and 18.7.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bjarne Stroustrup, *C++之旅*，第三版，18.2和18.7。
