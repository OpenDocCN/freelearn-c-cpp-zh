- en: Chapter 12. Working with UE4 APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 使用UE4 API
- en: The **Application Programming Interface** (**API**) is the way in which you,
    as the programmer, instruct the engine, and so the PC, what to do. All of UE4's
    functionality is encapsulated into modules, including very basic and core functionality.
    Each module has an API for it. To use an API, there is a very important linkage
    step, where you must list all APIs that you will be using in your build in a `ProjectName.Build.cs`
    file, which is located in your **Solution Explorer** window.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口（API）是您作为程序员指示引擎和PC要执行的操作的方式。UE4的所有功能都封装在模块中，包括非常基本和核心的功能。每个模块都有一个API。要使用API，有一个非常重要的链接步骤，在其中必须在`ProjectName.Build.cs`文件中列出您将在构建中使用的所有API，该文件位于**Solution
    Explorer**窗口中。
- en: Tip
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not name any of your UE4 projects the exact same name as one of the UE4 API
    names!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将任何UE4项目命名为与UE4 API名称完全相同的名称！
- en: '![Working with UE4 APIs](img/00286.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![使用UE4 API](img/00286.jpeg)'
- en: 'There are a variety of APIs inside the UE4 engine that expose functionality
    to various essential parts of it. Some of the interesting APIs that we''ll explore
    in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: UE4引擎中有各种API，可以向其各个重要部分公开功能。本章中我们将探索一些有趣的API，包括以下内容：
- en: Core/Logging API – Defining a custom log category
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Core/Logging API – 定义自定义日志类别
- en: Core/Logging API – `FMessageLog` to write messages to the **Message Log**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Core/Logging API – 使用`FMessageLog`将消息写入**Message Log**
- en: Core/Math API – Rotation using `FRotator`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Core/Math API – 使用`FRotator`进行旋转
- en: Core/Math API – Rotation using `FQuat`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Core/Math API – 使用`FQuat`进行旋转
- en: Core/Math API – Rotation using `FRotationMatrix` to have one object face another
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Core/Math API – 使用`FRotationMatrix`进行旋转，使一个对象面向另一个对象
- en: Landscape API – Landscape generation with Perlin noise
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Landscape API – 使用Perlin噪声生成地形
- en: Foliage API – Adding trees procedurally to your level
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Foliage API – 在您的关卡中以程序化方式添加树木
- en: Landscape and Foliage APIs – Map generation using Landscape and Foliage APIs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Landscape and Foliage APIs – 使用Landscape和Foliage APIs生成地图
- en: GameplayAbilities API – Triggering an actor's gameplay abilities with game controls
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayAbilities API – 使用游戏控制触发角色的游戏能力
- en: GameplayAbilities API – Implementing stats with `AttributeSet`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayAbilities API – 使用`AttributeSet`实现统计数据
- en: GameplayAbilities API – Implementing buffs with `GameplayEffect`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayAbilities API – 使用`GameplayEffect`实现增益效果
- en: GameplayTags API – Attaching `GameplayTags` to an actor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayTags API – 将`GameplayTags`附加到角色
- en: GameplayTasks API – Making things happen with `GameplayTasks`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameplayTasks API – 使用`GameplayTasks`实现游戏任务
- en: HTTP API – Web request
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP API – 网络请求
- en: HTTP API – Progress bars
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP API – 进度条
- en: Introduction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The UE4 engine's base functionality available in the editor is quite broad.
    The functionality from C++ code is actually grouped out into little sections called
    APIs. There is a separate API module for each important functionality in the UE4
    codebase. This is done to keep the codebase highly organized and modular.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: UE4引擎在编辑器中提供的基本功能非常广泛。C++代码的功能实际上被分组到称为API的小节中。UE4代码库中的每个重要功能都有一个单独的API模块。这样做是为了保持代码库高度组织和模块化。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using different APIs may require special linkage in your `Build.cs` file! If
    you are getting build errors, be sure to check that the linkage with the correct
    APIs is there!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的API可能需要在您的`Build.cs`文件中进行特殊链接！如果出现构建错误，请确保检查与正确的API的链接是否存在！
- en: 'The complete API listing is located in the following documentation: [https://docs.unrealengine.com/latest/INT/API/](https://docs.unrealengine.com/latest/INT/API/).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的API列表位于以下文档中：[https://docs.unrealengine.com/latest/INT/API/](https://docs.unrealengine.com/latest/INT/API/)。
- en: Core/Logging API – Defining a custom log category
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Core/Logging API – 定义自定义日志类别
- en: 'UE4 itself defines several logging categories, including categories such as
    `LogActor`, which has any log messages to do with the `Actor` class, and `LogAnimation`,
    which logs messages about Animations. In general, UE4 defines a separate logging
    category for each module. This allows developers to output their log messages
    to different logging streams. Each log steam''s name is prefixed to the outputted
    message as shown in the following example log messages from the engine:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: UE4本身定义了几个日志类别，包括`LogActor`等类别，其中包含与`Actor`类相关的任何日志消息，以及`LogAnimation`，用于记录有关动画的消息。一般来说，UE4为每个模块定义了一个单独的日志类别。这允许开发人员将其日志消息输出到不同的日志流中。每个日志流的名称作为前缀添加到输出的消息中，如引擎中的以下示例日志消息所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above are sample log messages from the engine, each prefixed with their
    log category. Warning messages appear in yellow and have **Warning** added to
    the front as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以上是引擎中的示例日志消息，每个消息前都有其日志类别的前缀。警告消息以黄色显示，并在前面添加了**Warning**。
- en: 'The example code you will find on the Internet tends to use `LogTemp` for a
    UE4 project''s own messages, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您在互联网上找到的示例代码往往使用`LogTemp`作为UE4项目自己的消息，如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can actually improve upon this formula by defining our own custom `LogCategory`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以通过定义自己的自定义`LogCategory`来改进这个公式。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have a UE4 project ready in which you'd like to define a custom log. Open a
    header file that will be included in almost all files using this log.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个UE4项目，您想要定义一个自定义日志。打开一个将在几乎所有使用此日志的文件中包含的头文件。
- en: How to do it…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Open the main header file for your project; for example, if your project''s
    name is `Pong`, you''ll open `Pong.h`. Add the following line of code after `#include
    Engine.h`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的项目的主头文件；例如，如果您的项目名称是`Pong`，则打开`Pong.h`。在`#include Engine.h`之后添加以下代码行：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Defined in `AssertionMacros.h`, there are three arguments to this declaration,
    which are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AssertionMacros.h`中定义了此声明的三个参数，如下所示：
- en: '`CategoryName`: This is the log category name being defined (`LogPong` here)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryName`：这是正在定义的日志类别名称（这里是`LogPong`）'
- en: '`DefaultVerbosity`: This is the default verbosity to use on log messages'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultVerbosity`：这是要在日志消息上使用的默认详细程度'
- en: '`CompileTimeVerbosity`: This is the verbosity to bake into compiled code'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompileTimeVerbosity`：这是编译代码中的详细程度'
- en: 'Inside the main `.cpp` file for your project, include the following line of
    code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的主`.cpp`文件中，包含以下代码行：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use your log with the various display categories, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用各种显示类别的日志，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![How to do it…](img/00287.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤](img/00287.jpeg)'
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Logging works by outputting messages to the **Output Log** (**Window** | **Developer
    Tools** | **Output Log**) as well as a file. All information outputted to the
    **Output Log** is also mirrored to a simple text file that is located in your
    project's `/Saved/Logs` folder. The extension of the log files is `.log`, with
    the most recent one being named `YourProjectName.log`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 日志通过将消息输出到“输出日志”（“窗口”|“开发者工具”|“输出日志”）以及文件中来工作。所有输出到“输出日志”的信息也会复制到项目的“/Saved/Logs”文件夹中的一个简单文本文件中。日志文件的扩展名为“.log”，其中最新的一个被命名为“YourProjectName.log”。
- en: There's more…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can enable or suppress log messages for a particular log channel from within
    the editor using the following console commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下控制台命令在编辑器中启用或禁止特定日志通道的日志消息：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you'd like to edit the initial values of the output levels of some of the
    built-in log types, you can use a C++ class to create changes to the `Engine.ini`
    config file. You can change the initial values in the `engine.ini` configuration
    file. See [https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime](https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime)
    for more details.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想编辑一些内置日志类型的输出级别的初始值，可以使用C++类来对`Engine.ini`配置文件进行更改。您可以在`engine.ini`配置文件中更改初始值。有关更多详细信息，请参见[https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime](https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime)。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`UE_LOG` sends its output to **Output Window**. If you''d like to use the more
    specialized **Message Log** window in addition, you can alternatively use the
    `FMessageLog` object to write your output messages. `FMessageLog` writes to both
    the **Message Log** and the **Output Window**. See the next recipe for details.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UE_LOG`将其输出发送到“输出窗口”。如果您还想使用更专门的“消息日志”窗口，您可以使用`FMessageLog`对象来编写输出消息。`FMessageLog`同时写入“消息日志”和“输出窗口”。有关详细信息，请参见下一个教程。'
- en: Core/Logging API – FMessageLog to write messages to the Message Log
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心/日志API - 使用FMessageLog将消息写入消息日志
- en: '`FMessageLog` is an object that allows you to write output messages to the
    **Message Log** (**Window** | **Developer Tools** | **Message Log**) and **Output
    Log** (**Window** | **Developer Tools** | **Output Log**) simultaneously.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`FMessageLog`是一个对象，允许您将输出消息同时写入“消息日志”（“窗口”|“开发者工具”|“消息日志”）和“输出日志”（“窗口”|“开发者工具”|“输出日志”）。'
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Have your project ready and some information to log to **Message Log**. Display
    **Message Log** in your UE4 Editor. The following screenshot is of the **Message
    Log**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好您的项目和一些要记录到“消息日志”的信息。在UE4编辑器中显示“消息日志”。以下屏幕截图是“消息日志”的样子：
- en: '![Getting ready](img/00288.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00288.jpeg)'
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Add `#define` to your main header file (`ProjectName.h`) defining `LOCTEXT_NAMESPACE`
    as something unique to your codebase:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的主头文件（`ProjectName.h`）中添加`#define`，将`LOCTEXT_NAMESPACE`定义为您的代码库中的某个唯一值：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `#define` is used by the `LOCTEXT()` macro, which we use to generate `FText`
    objects, but is not seen in output messages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`#define`被`LOCTEXT()`宏使用，我们用它来生成`FText`对象，但在输出消息中看不到它。
- en: 'Declare your `FMessageLog` by constructing it somewhere very global. You can
    use `extern` in your `ProjectName.h` file. Consider the following piece of code
    as an example:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在非常全局的位置构建您的`FMessageLog`来声明它。您可以在`ProjectName.h`文件中使用`extern`。考虑以下代码片段作为示例：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And then, create your `FMessageLog` by defining it in a `.cpp` file and registering
    it with `MessageLogModule`. Be sure to give your logger a clear and unique name
    on construction. It''s the category of your log that will appear to the left of
    your log messages in **Output Log**. For example, `ProjectName.cpp`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`.cpp`文件中定义并使用`MessageLogModule`注册您的`FMessageLog`。在构建时，请确保为您的记录器提供一个清晰且唯一的名称。它是您的日志类别将出现在“输出日志”中的日志消息左侧的位置。例如，`ProjectName.cpp`：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `KEY` to `LOCTEXT` (first argument) must be unique or you will get a previously
    hashed string back. If you'd like, you can include a `#define` that repeats the
    argument to `LOCTEXT` twice, as we did earlier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`KEY`到`LOCTEXT`（第一个参数）必须是唯一的，否则您将得到一个先前散列的字符串。如果您愿意，您可以包含一个`#define`，将参数重复两次传递给`LOCTEXT`，就像我们之前做的那样。'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Log your messages using the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码记录您的消息：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code utilizes the `FTEXT()` macro defined earlier. Be sure it is in your
    codebase.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码利用了之前定义的`FTEXT()`宏。请确保它在您的代码库中。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Constructing your message log again after initialization retrieves a copy of
    the original message log. For example, at any place in the code, you can write
    the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化后重新构建消息日志可以检索到原始消息日志的副本。例如，在代码的任何位置，您可以编写以下代码：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Core/Math API – Rotation using FRotator
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心/数学API - 使用FRotator进行旋转
- en: Rotation in UE4 has such complete implementation that it can be hard to choose
    how to rotate your objects. There are three main methods—`FRotator`, `FQuat`,
    and `FRotationMatrix`. This recipe outlines the construction and use of the first
    of the three different methods for the rotation of objects—the `FRotator`. Using
    this, and the following two recipes, you can select at a glance a method to use
    to rotate your objects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中，旋转有着完整的实现，因此很难选择如何旋转您的对象。有三种主要方法——`FRotator`、`FQuat`和`FRotationMatrix`。本教程概述了这三种不同方法之一——`FRotator`的构建和使用。使用这个方法和下面的两个教程，您可以一目了然地选择一个用于旋转对象的方法。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have a UE4 project that has an object you can get a C++ interface with. For
    example, you can construct a C++ class Coin that derives from `Actor` to test
    out rotations with. Override the `Coin::Tick()` method to apply your rotations
    from the C++ code. Alternatively, you can call these rotation functions in the
    `Tick` event from Blueprints.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个UE4项目，其中有一个你可以使用C++接口的对象。例如，你可以构造一个从`Actor`派生的C++类Coin来测试旋转。重写`Coin::Tick()`方法来应用你的旋转代码。或者，你可以在蓝图中的`Tick`事件中调用这些旋转函数。
- en: In this example, we will rotate an object at a rate of one degree per second.
    The actual rotation will be the accumulated time since the object was created.
    To get this value, we'll just call `GetWorld()->TimeSeconds`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将以每秒一度的速度旋转一个物体。实际的旋转将是物体创建后累积的时间。为了获得这个值，我们只需调用`GetWorld()->TimeSeconds`。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a custom C++ derivative of the `Actor` class called `Coin`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Coin`的自定义C++派生类，继承自`Actor`类。
- en: In the C++ code, override the `::Tick()` function of the `Coin` actor derivative.
    This will allow you to effect a change to the actor in each frame.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++代码中，重写`Coin`派生类的`::Tick()`函数。这将允许你在每一帧中对角色进行更改。
- en: 'Construct your `FRotator. FRotators` can be constructed using a stock pitch,
    yaw, and roll constructor, as shown in the following example:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造你的`FRotator`。`FRotators`可以使用标准的俯仰、偏航和滚转构造函数来构造，如下例所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Your `FRotator` will be constructed as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的`FRotator`将按以下方式构造：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The standard orientation for an object in UE4 is with Forward facing down the
    *+X* axis. Right is the *+Y* axis, and Up is *+Z*.![How to do it…](img/00289.jpeg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4中，对象的标准方向是前方朝下的*+X*轴。右侧是*+Y*轴，上方是*+Z*轴。![如何做到这一点...](img/00289.jpeg)
- en: 'Pitch is rotation about the *Y* axis (across), yaw is rotation about the *Z*
    axis (up), and roll is rotation about the *X* axis. This is best understood in
    the following three points:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 俯仰是绕*Y*轴（横向）旋转，偏航是绕*Z*轴（上下）旋转，滚转是绕*X*轴旋转。这在以下三点中最容易理解：
- en: '**Pitch**: If you think of an airplane in UE4 standard coordinates, the *Y*
    axis goes along the wingspan (pitching tilts it forward and backward)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**俯仰**：如果你想象一个UE4标准坐标系中的飞机，*Y*轴沿着翼展（俯仰将其向前和向后倾斜）'
- en: '**Yaw**: The *Z* axis goes straight up and down (yawing turns it left and right)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏航**：*Z*轴直上直下（偏航将其左右旋转）'
- en: '**Roll**: The *X* axis goes straight along the fuselage of the plane (rolling
    does barrel rolls)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚转**：*X*轴沿着飞机机身直线（滚转进行卷筒翻滚）'
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You should note that in other conventions, the *X* axis is pitch, the *Y* axis
    is yaw, and the *Z* axis is roll.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，在其他约定中，*X*轴是俯仰，*Y*轴是偏航，*Z*轴是滚转。
- en: 'Apply your `FRotator` to your actor using the `SetActorRotation` member function,
    as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetActorRotation`成员函数将你的`FRotator`应用到你的角色上，如下所示：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Core/Math API – Rotation using FQuat
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心/数学API - 使用FQuat进行旋转
- en: 'Quaternions sound intimidating, but they are extremely easy to use. You may
    want to review the theoretical math behind them using the following videos:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数听起来很吓人，但它们非常容易使用。你可能想通过以下视频来了解它们背后的理论数学：
- en: Fantastic Quaternions by Numberphile – [https://www.youtube.com/watch?v=3BR8tK-LuB0](https://www.youtube.com/watch?v=3BR8tK-LuB0)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numberphile的《奇妙的四元数》- [https://www.youtube.com/watch?v=3BR8tK-LuB0](https://www.youtube.com/watch?v=3BR8tK-LuB0)
- en: Understanding Quaternions by Jim Van Verth – [http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding](http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jim Van Verth的《理解四元数》- [http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding](http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding)
- en: However, we won't cover the math background here! In fact, you don't need to
    understand much about the math background quaternions to use them extremely effectively.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里我们不会涉及数学背景！实际上，你不需要对四元数的数学背景有太多的了解就能极其有效地使用它们。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have a project ready and an `Actor` with an override `::Tick()` function that
    we can enter the C++ code into.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个项目和一个具有重写`::Tick()`函数的`Actor`，我们可以在其中输入C++代码。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To construct a quaternion, the best constructor to use is as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造四元数时，最好使用以下构造函数：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**For example, to define a twisting rotation**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**例如，定义一个扭曲旋转**：'
- en: Quaternions have quaternion addition, quaternion subtraction, multiplication
    by a scalar, and division by a scalar defined for them, amongst other functions.
    They are extremely useful to rotate things at arbitrary angles, and point objects
    at one another.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数还定义了四元数加法、四元数减法、乘以标量和除以标量等运算，以及其他函数。它们非常有用，可以将物体以任意角度旋转，并将物体指向彼此。
- en: How it works…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Quaterions are a bit strange, but using them is quite simple. If *v* is the
    axis around which to rotate, and ![How it works…](img/00290.jpeg) is the magnitude
    of the angle of rotation, then we get the following equations for the components
    of a quaternion:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数有点奇怪，但使用它们非常简单。如果*v*是旋转的轴，![它是如何工作的...](img/00290.jpeg)是旋转角度的大小，那么我们可以得到以下四元数分量的方程：
- en: '![How it works…](img/00291.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00291.jpeg)'
- en: 'So, for example, rotation about ![How it works…](img/00292.jpeg) by an angle
    of ![How it works…](img/00293.jpeg) will have the following quaternion components:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，绕![它是如何工作的...](img/00292.jpeg)旋转![它是如何工作的...](img/00293.jpeg)角度将具有以下四元数分量：
- en: '![How it works…](img/00294.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00294.jpeg)'
- en: Three of the four components of the quaternion (*x*, *y*, and *z*) define the
    axis around which to rotate (scaled by the sine of half the angle of rotation),
    while the fourth component (*w*) has only the cosine of half the angle to rotate
    with.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数的四个分量中的三个分量（*x*、*y*和*z*）定义了旋转的轴（乘以旋转角度一半的正弦值），而第四个分量（*w*）只有旋转角度一半的余弦值。
- en: There's more…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Quaternions, being themselves vectors, can be rotated. Simply extract the (*x*,
    *y*, *z*) components of the quaternion, normalize, and then rotate that vector.
    Construct a new quaternion from that new unit vector with the desired angle of
    rotation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数本身是向量，可以进行旋转。只需提取四元数的(*x*, *y*, *z*)分量，进行归一化，然后旋转该向量。使用所需旋转角度构造一个新的四元数，该四元数由该新单位向量构成。
- en: 'Multiplying quaternions together represents a series of rotations that happen
    subsequently. For example, rotation of 45º about the *X* axis, followed by a rotation
    of 45º about the *Y* axis will be composed by the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将四元数相乘表示一系列连续发生的旋转。例如，绕*X*轴旋转45º，然后绕*Y*轴旋转45º将由以下组成：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Core/Math API – Rotation using FRotationMatrix to have one object face another
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心/数学API-使用FRotationMatrix进行旋转，使一个对象面向另一个对象
- en: '`FRotationMatrix` offers matrix construction using a series of `::Make*` routines.
    They are easy to use and useful to get one object to face another. Say you have
    two objects, one of which is following the other. We want the rotation of the
    follower to always be facing what it is following. The construction methods of
    `FRotationMatrix` make this easy to do.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`FRotationMatrix`提供了使用一系列`::Make*`例程进行矩阵构造的功能。它们易于使用，对于使一个对象面向另一个对象非常有用。假设您有两个对象，其中一个对象跟随另一个对象。我们希望跟随者的旋转始终面向其所跟随的对象。`FRotationMatrix`的构造方法使这一点变得容易。'
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: Have two actors in a scene, one of which should face the other.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中有两个演员，其中一个应该面向另一个演员。
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the follower's `Tick()` method, look into the available constructors under
    the `FRotationMatrix` class. Available are a bunch of constructors that will let
    you specify a rotation for an object (from stock position) by reorienting one
    or more of the *X*, *Y*, *Z* axes, named with the `FRotationMatrix::Make*()` pattern.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在跟随者的`Tick()`方法中，查看`FRotationMatrix`类下可用的构造函数。提供了一系列构造函数，可以通过重新定位一个或多个*X*、*Y*、*Z*轴来指定对象的旋转，命名为`FRotationMatrix::Make*()`模式。
- en: 'Assuming you have a default stock orientation for your actor (with Forward
    facing down the *+X* axis, and up facing up the *+Z* axis), find the vector from
    the follower to the object he is following, as shown in this piece of code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您的演员具有默认的初始方向（前进沿着*+X*轴向下，向上沿着*+Z*轴向上），请找到从跟随者到他所跟随的对象的向量，如下所示：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Getting one object to look at another, with a desired up vector, can be done
    by calling the correct function, depending on your object''s stock orientation.
    Usually, you want to reorient the *X* axis (Forward), while specifying either
    the *Y* axis (Right) or *Z* axis (Up) vectors (`FRotationMatrix::MakeFromXY()`).
    For example, to make an actor look along a `lookAlong` vector, with its right
    side facing right, we''d construct and set `FRotationMatrix` for it as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使一个对象看向另一个对象，并具有所需的上向量，可以通过调用正确的函数来完成，具体取决于对象的默认方向。通常，您希望重新定位*X*轴（前进），同时指定*Y*轴（右）或*Z*轴（上）向量（`FRotationMatrix::MakeFromXY()`）。例如，要使一个演员沿着`lookAlong`向量朝向，其右侧面向右侧，我们可以构造并设置其`FRotationMatrix`如下：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Landscape API – Landscape generation with Perlin noise
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 景观API-使用Perlin噪声生成景观
- en: If you use `ALandscape` in your scene, you may want to program the heights on
    it using code instead of manually brushing it in. To access the `ALandscape` object
    and its functions inside of your code, you must compile and link in the `Landscape`
    and `LandscapeEditor` APIs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在场景中使用`ALandscape`，您可能希望使用代码而不是手动刷入来编程设置其高度。要在代码中访问`ALandscape`对象及其函数，您必须编译和链接`Landscape`和`LandscapeEditor`API。
- en: '![Landscape API – Landscape generation with Perlin noise](img/00295.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![景观API-使用Perlin噪声生成景观](img/00295.jpeg)'
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: Generating a landscape is not terribly challenging. You need to link in both
    the `Landscape` and `LandscapeEditor` APIs, and also have a programmatic way to
    set the height values across the map. In this recipe, we'll show how to use the
    Perlin noise for this.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 生成景观并不是非常具有挑战性。您需要链接`Landscape`和`LandscapeEditor`API，并且还需要以编程方式设置地图上的高度值。在本示例中，我们将展示如何使用Perlin噪声来实现这一点。
- en: Previously, you may have seen Perlin noise used for coloration, but that is
    not all it is good for. It is excellent for terrain heights as well. You can sum
    multiple Perlin noise values to get beautiful fractal noise. It is worth a brief
    study of Perlin noise to understand how to get good outputs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，您可能已经看到过Perlin噪声用于着色，但这并不是它的全部用途。它也非常适用于地形高度。您可以将多个Perlin噪声值相加，以获得美丽的分形噪声。值得简要研究Perlin噪声，以了解如何获得良好的输出。
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Retrieve the Perlin noise module from [http://webstaff.itn.liu.se/~stegu/aqsis/aqsis-newnoise/](http://webstaff.itn.liu.se/~stegu/aqsis/aqsis-newnoise/).
    The two files you'll need are `noise1234.h` and `noise1234.cpp` (or you can select
    another pair of noise generation files from this repository if you wish). Link
    these files into your project and be sure to `#include YourPrecompiledHeader.h`
    into `noise1234.cpp`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://webstaff.itn.liu.se/~stegu/aqsis/aqsis-newnoise/](http://webstaff.itn.liu.se/~stegu/aqsis/aqsis-newnoise/)检索Perlin噪声模块。您需要的两个文件是`noise1234.h`和`noise1234.cpp`（或者您可以从此存储库中选择另一对噪声生成文件）。将这些文件链接到您的项目中，并确保在`noise1234.cpp`中`#include
    YourPrecompiledHeader.h`。
- en: Link in the `Landscape` and `LandscapeEditor` APIs in your `Project.Build.cs`
    file.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Project.Build.cs`文件中链接`Landscape`和`LandscapeEditor`API。
- en: 'Construct an interface using UMG that allows you to click a **Generate** button
    to call a C++ function that will ultimately populate the current Landscape with
    Perlin noise values. You can do this as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用UMG构建一个界面，允许您点击一个**生成**按钮来调用一个C++函数，最终用Perlin噪声值填充当前景观。您可以按照以下步骤进行操作：
- en: Right-click on your **Content Browser** and select **User Interface** | **Widget
    Blueprint**.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击**内容浏览器**，选择**用户界面** | **小部件蓝图**。
- en: Populate **Widget Blueprint** with a single button that kicks off a single `Gen()`
    function. The `Gen()` function can be attached to your `Chapter12GameMode` derived
    class object as that is easy to retrieve from the engine. The `Gen()` function
    must be `BlueprintCallable UFUNCTION()`. (See the *Creating a UFUNCTION* section
    in [Chapter 2](part0032_split_000.html#UGI01-c0ca69a0411046888a488e5085138121
    "Chapter 2. Creating Classes"), *Creating Classes*, for details on how to do so.)![How
    to do it…](img/00296.jpeg)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个单独的按钮填充**Widget Blueprint**，该按钮启动一个单独的`Gen()`函数。`Gen()`函数可以附加到你的`Chapter12GameMode`派生类对象上，因为从引擎中检索它很容易。`Gen()`函数必须是`BlueprintCallable
    UFUNCTION()`。（有关如何执行此操作的详细信息，请参见[第2章](part0032_split_000.html#UGI01-c0ca69a0411046888a488e5085138121
    "第2章。创建类")中的*创建UFUNCTION*部分，*创建类*。）![操作步骤…](img/00296.jpeg)
- en: Be sure to display your UI by creating it and adding it to the viewport in one
    of your booting Blueprints; for example, in your HUD's `BeginPlay` event.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保通过在其中一个启动蓝图中创建并将其添加到视口来显示你的UI；例如，在你的HUD的`BeginPlay`事件中。
- en: '![How to do it…](img/00297.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤…](img/00297.jpeg)'
- en: Create a Landscape using the UE4 Editor. The landscape will be assumed to stay
    on screen. We will only modify its values using code.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用UE4编辑器创建一个景观。假设景观将保持在屏幕上。我们只会使用代码修改它的值。
- en: 'Inside your map generation routine, modify your `ALandscape` object using code
    that does the following:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的地图生成例程中，使用以下代码修改你的`ALandscape`对象：
- en: 'Find the `Landscape` object in the level by searching through all objects in
    the `Level`. We do this using a C++ function that returns `TArray` of all `Landscape`
    instances in the level:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过搜索`Level`中的所有对象来找到级别中的`Landscape`对象。我们使用一个返回级别中所有`Landscape`实例的`TArray`的C++函数来实现这一点：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Initialize the world''s `ULandscapeInfo` objects for `ALandscape` editing using
    the very important line, which is as follows:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下非常重要的行初始化世界的`ULandscapeInfo`对象，如下所示：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding line of code is extremely important. Without it, the `ULandscapeInfo`
    objects will not be initialized and your code will not work. Surprisingly, this
    is a static member function of the `ULandscapeInfo` class, and so it initializes
    all `ULandscapeInfo` objects within the level.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码非常重要。如果没有它，`ULandscapeInfo`对象将不会被初始化，你的代码将无法工作。令人惊讶的是，这是`ULandscapeInfo`类的静态成员函数，因此它会初始化级别中的所有`ULandscapeInfo`对象。
- en: Get extents of your `ALandscape` object so that we can compute the number of
    height values we will need to generate.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取你的`ALandscape`对象的范围，以便我们可以计算需要生成的高度值的数量。
- en: Creates a set of height values to replace original values.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一组高度值来替换原始值。
- en: Calls `LandscapeEditorUtils::SetHeightmapData( landscape, data );` to park new
    landscape height values into your `ALandscape` object.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`LandscapeEditorUtils::SetHeightmapData( landscape, data );`将新的地形高度值放入你的`ALandscape`对象中。
- en: 'For example, use the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下代码：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The initial values of `heightmap` will all be `32768` (`SHRT_MAX` (or `USHRT_MAX/2+1`))
    when the map is completely flat. This is because the map uses unsigned shorts
    (`uint16`) for its values, making it incapable of taking on negative values. For
    the map to dip below `z=0`, the programmers made the default value half of the
    maximum value of `heightmap`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当地图完全平坦时，`heightmap`的初始值将全部为`32768`（`SHRT_MAX`（或`USHRT_MAX/2+1`））。这是因为地图使用无符号短整数（`uint16`）作为其值，使其无法取负值。为了使地图低于`z=0`，程序员将默认值设为`heightmap`的最大值的一半。
- en: How it works…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The Perlin noise function is used to generate a height value for (*x*, *y*)
    coordinate pairs. The 2D version of Perlin noise is used so that we can get a
    Perlin noise value based on 2-space spatial coordinates.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Perlin噪声函数用于为（*x*，*y*）坐标对生成高度值。使用2D版本的Perlin噪声，以便我们可以根据2D空间坐标获取Perlin噪声值。
- en: There's more…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: You can play with the Perlin noise functions with the spatial coordinates of
    the map, and assign the heights of the maps to different combinations of the Perlin
    noise function. You will want to use a sum of multiple octaves of the Perlin noise
    function to get more detail into the landscape.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用地图的空间坐标来玩弄Perlin噪声函数，并将地图的高度分配给Perlin噪声函数的不同组合。你将希望使用多个Octave的Perlin噪声函数的总和来获得更多的地形细节。
- en: 'The `PerlinNoise2D` generation function looks as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerlinNoise2D`生成函数如下所示：'
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `PerlinNoise2D` function accounts for the fact that the mid-level value
    of the function (sea level or flat land) should have a value of `SHRT_MAX` (`32768`).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerlinNoise2D`函数考虑到函数的中间值（海平面或平地）应该具有`SHRT_MAX`（`32768`）的值。'
- en: Foliage API – Adding trees procedurally to your level
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Foliage API - 使用代码将树木程序化地添加到你的级别中
- en: The **Foliage** API is a great way to populate your level with trees using code.
    If you do it this way, then you can get some good results without having to manually
    produce a natural looking randomness by hand.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**Foliage** API是使用代码填充级别中的树木的好方法。如果你这样做，那么你可以获得一些不错的结果，而不必手动产生自然的随机性。'
- en: We will correlate the placement of foliage with the Perlin noise value so that
    the chance to place a tree at a given location is higher when the Perlin noise
    values are higher.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据Perlin噪声值与植被的放置位置相关联，以便在Perlin噪声值较高时在给定位置放置树木的机会更大。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before using the code interface to the Foliage API, you should try the in-editor
    feature to familiarize yourself with the feature. After that, we will discuss
    using the code interface to place the foliage in the level.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Foliage API的代码接口之前，你应该尝试使用编辑器中的功能来熟悉该功能。之后，我们将讨论使用代码接口在级别中放置植被。
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Important! Keep in mind that the material for a `FoliageType` object must have
    the **Used with Instanced Static Meshes** checkbox checked in its panel. If you
    do not do so, then the material cannot be used to shade a foliage material.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要！请记住，`FoliageType`对象的材质必须在其面板中选中**Used with Instanced Static Meshes**复选框。如果不这样做，那么该材质将无法用于着色植被材质。
- en: '![Getting ready](img/00298.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/00298.jpeg)'
- en: Be sure to check the **Used with Instanced Static Meshes** checkbox for your
    materials that you use on your `FoliageType`, otherwise your Foliage will appear
    gray.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为您在`FoliageType`上使用的材质勾选**与实例化静态网格一起使用**复选框，否则您的植被将显示为灰色。
- en: How to do it…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: Manually
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动
- en: From the **Modes** panel, select the picture of a small growing plant with leaves
    ![Manually](img/00299.jpeg).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**模式**面板中，选择带有叶子的小型植物的图片![手动](img/00299.jpeg)。
- en: Click on the **+ Add Foliage Type** drop-down menu and select to construct a
    new `Foliage` object.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**+ 添加植被类型**下拉菜单，并选择构建一个新的`Foliage`对象。
- en: Save the `Foliage` object by whatever name you wish.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按您希望的名称保存`Foliage`对象。
- en: Double-click to edit your new `Foliage` object. Select Mesh from your project,
    preferably a tree-shaped object, to paint foliage into the landscape with.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击以编辑您的新`Foliage`对象。从项目中选择网格，最好是树形状的对象，以在景观中绘制植被。
- en: Adjust Paint Brush Size and Paint Density to your liking. Left click to start
    painting in foliage.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整画笔大小和绘画密度以适合您的喜好。左键单击开始在植被中绘画。
- en: '*Shift* + click to erase foliage that you''ve put down. The Erase density value
    tells you how much foliage to leave behind when erasing.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Shift* + 单击以擦除您放置的植被。擦除密度值告诉您在擦除时要留下多少植被。'
- en: Procedurally
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序化
- en: 'If you would like the engine to distribute the foliage in the level for you,
    you have a few steps to cover before being able to do so from within the editor.
    These steps are as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望引擎为您在关卡中分布植被，您需要完成以下几个步骤：
- en: Go to the **Content Browser** and right-click to create a few `FoliageType`
    objects to distribute procedurally in the level.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**内容浏览器**，右键单击创建一些`FoliageType`对象以在关卡中进行程序化分布。
- en: Click **Edit** | **Editor Preferences**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**编辑** | **编辑器首选项**。
- en: Click the **Experimental** tab.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**实验**选项卡。
- en: Enable the **Procedural Foliage** checkbox. This allows you access to the **Procedural
    Foliage** classes from within the Editor.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**程序化植被**复选框。这允许您从编辑器中访问**程序化植被**类。
- en: Go back to **Content Browser**, right-click and create **Miscellaneous** | **Procedural
    Foliage Spawner**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回**内容浏览器**，右键单击并创建**杂项** | **程序化植被生成器**。
- en: Double-click to open your **Procedural Foliage Spawner** and select-in the `FoliageTypes`
    that you created in step 1.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击打开您的**程序化植被生成器**，并选择在步骤1中创建的`FoliageTypes`。
- en: Drag your **Procedural Foliage Spawner** onto the level and size it such that
    it contains the area where you want your procedural foliage laid out.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的**程序化植被生成器**拖放到关卡中，并调整大小，使其包含您想要布置程序化植被的区域。
- en: From the Brushes menu, drag on a few Procedural Foliage Blocker volumes. Place
    a few of these inside the **Procedural Foliage Spawner** volume to block foliage
    from appearing in these areas.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从画笔菜单中，拖动几个程序化植被阻挡体积。将其中几个放置在**程序化植被生成器**体积内，以阻止植被出现在这些区域。
- en: Open the menus downwards and click **SIMULATE**. The **Procedural Foliage Spawner**
    should fill with foliage.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下打开菜单，点击**模拟**。**程序化植被生成器**应该会填充植被。
- en: Experiment with the settings to get the foliage distributions that you like.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的设置以获得您喜欢的植被分布。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The preceding recipe generates foliage prior to gameplay start. If you're interested
    in procedural foliage spawning at runtime, see the next recipe, *Landscape and
    Foliage API – Map generation using Landscape and Foliage APIs*.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的示例在游戏开始前生成植被。如果您对运行时程序化植被生成感兴趣，请参阅下一个示例，*Landscape and Foliage API - 使用Landscape和Foliage
    API进行地图生成*。
- en: Landscape and Foliage API – Map generation using Landscape and Foliage APIs
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Landscape and Foliage API - 使用Landscape和Foliage API进行地图生成
- en: We can use the earlier mentioned landscape generation code to create a landscape,
    and the procedural foliage functionality to randomly distribute some foliage on
    it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面提到的地形生成代码创建一个地形，并使用程序化植被功能在其上随机分布一些植被。
- en: Combining the capabilities of the Landscape API and Foliage API will allow you
    to procedurally generate complete maps. In this recipe, we will outline how this
    is done.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 结合Landscape API和Foliage API的功能，您可以程序化生成完整的地图。在本示例中，我们将概述如何实现这一点。
- en: We will programmatically create a landscape and populate it with foliage using
    code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用代码编程创建一个地形，并使用代码填充植被。
- en: '![Landscape and Foliage API – Map generation using Landscape and Foliage APIs](img/00300.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Landscape and Foliage API - 使用Landscape和Foliage API进行地图生成](img/00300.jpeg)'
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To prepare to perform this recipe, we will need a UE4 project with a `Generate`
    button to kick off generation. You can see the *Landscape API – Landscape generation
    with Perlin noise* recipe for an example of how to do this. You simply need to
    create a small UMG UI widget that has a `Generate` button. Connect the `OnClick`
    event of your `Generate` button to a C++ `UFUNCTION()` inside any C++ global object,
    such as your `Chapter12GameMode` object, that will be used to generate your terrain.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备执行此示例，我们需要一个UE4项目，其中包含一个`Generate`按钮来启动生成。您可以参考*Landscape API - 使用Perlin噪声生成地形*示例来了解如何做到这一点。您只需要创建一个小的UMG
    UI小部件，其中包含一个`Generate`按钮。将您的`Generate`按钮的`OnClick`事件连接到C++全局对象中的一个C++ `UFUNCTION()`，例如您的`Chapter12GameMode`对象，该对象将用于生成地形。
- en: How to do it…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: Enter a loop that attempts to place *N* trees, where *N* is the number of trees
    to place randomly, which is specified in the `UPROPERTY()` of the `Chapter12GameMode`
    object.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入一个循环，尝试放置*N*棵树，其中*N*是要随机放置的树木数量，由`Chapter12GameMode`对象的`UPROPERTY()`指定。
- en: Get random XY coordinates from within a 2D box bounding the landscape object.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从包围地形对象的2D框中获取随机XY坐标。
- en: Get the Perlin noise value `@ (x, y)`. You may use a different Perlin noise
    formulation than the one used to determine landscape heights for foliage placement.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取Perlin噪声值`@(x, y)`。您可以使用与用于确定植被放置的地形高度的Perlin噪声公式不同的Perlin噪声公式。
- en: Generate a random number. If the number generated is within the range of units
    of the Perlin noise function there, then place a tree using the `SpawnFoliageInstance`
    function. Otherwise, do not place a tree there.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个随机数。如果生成的数字在Perlin噪声函数的单位范围内，则使用`SpawnFoliageInstance`函数放置一棵树。否则，不要在那里放置一棵树。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You should note that we are covering randomness in location using the underlying
    randomness in the spot we choose to test for tree placement. The actual chance
    to place a tree there depends on the Perlin noise value there, and whether it
    is within the range of units of `PerlinTreeValue`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到，我们使用所选择的位置的底层随机性来覆盖位置的随机性。在那里放置一棵树的实际机会取决于那里的Perlin噪声值，以及它是否在`PerlinTreeValue`的单位范围内。
- en: Very dense tree distributions will look like isocontours on the map then. The
    width of the isocontours is the range of units.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 非常密集的树分布将看起来像地图上的等值线。等值线的宽度是单位的范围。
- en: How it works…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Perlin noise works by generating smooth noise. For each location in an interval,
    (say *[-1, 1]*), there is a smoothly varying Perlin noise value.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Perlin噪声通过生成平滑的噪声来工作。对于区间中的每个位置（比如[-1, 1]），都有一个平滑变化的Perlin噪声值。
- en: '![How it works…](img/00301.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00301.jpeg)'
- en: Perlin noise values are sampled on a 2D texture. At each pixel (and even in
    between), we can get a very smoothly varying noise value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Perlin噪声值在2D纹理上进行采样。在每个像素（甚至在像素之间），我们可以得到一个非常平滑变化的噪声值。
- en: Adding octaves (or integer multiples) to some variable that travels in distance
    across the Perlin noise function allows us to get jaggy-looking effects; for example,
    the tufts in clouds or crags in mountains are gotten by wider-spaced samples,
    which give faster varying noise.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨越Perlin噪声函数的距离上添加八度（或整数倍）到某个变量中，可以得到锯齿状的效果；例如，云朵中的小丛和山脉中的岩壁是通过更宽间隔的样本获得的，这些样本给出了更快变化的噪声。
- en: To get cool-looking Perlin noise outputs, we will simply apply math functions
    to sampled Perlin noise values; for example, the sin and cos functions can generate
    some cool looking marble effects for you.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得漂亮的Perlin噪声输出，我们只需对采样的Perlin噪声值应用数学函数；例如，sin和cos函数可以为您生成一些很酷的大理石效果。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Perlin noise becomes periodic, that is, tileable, with the Perlin noise functions
    provided by the earlier linked implementation in this recipe. By default, Perlin
    noise is not periodic. If you need your Perlin noise to be periodic, be careful
    which library function you are calling.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此处链接的实现提供的Perlin噪声函数，Perlin噪声变得周期性，即可平铺。默认情况下，Perlin噪声不是周期性的。如果您需要Perlin噪声是周期性的，请注意调用哪个库函数。
- en: The base Perlin noise function is a deterministic function that returns the
    same value every time you call it with the same value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Perlin噪声函数是一个确定性函数，每次调用它时都会返回相同的值。
- en: There's more…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You may also set up sliders inside your `Chapter12GameMode` object derivative
    to affect the foliage and landscape generation, including parameters such as the
    following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`Chapter12GameMode`对象派生类中设置滑块，以影响植被和地形的生成，包括以下参数：
- en: Amplitude of the landscape
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地形的振幅
- en: Density of the foliage
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 植被密度
- en: Isocontour level for foliage
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 植被的等值线水平
- en: Variance in foliage height or scale
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 植被高度或比例的方差
- en: GameplayAbilities API – Triggering an actor's gameplay abilities with game controls
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameplayAbilities API - 使用游戏控制触发角色的游戏能力
- en: The **GameplayAbilities** API can be used to attach C++ functions to invoke
    on certain button pushes, triggering the game unit to exhibit its abilities during
    play in response to keystroke events. In this recipe, we will show you how to
    do that.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**GameplayAbilities** API可用于将C++函数附加到特定按钮推送上，在游戏单位在游戏中对按键事件的响应中展示其能力。在本教程中，我们将向您展示如何做到这一点。'
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Enumerate and describe your game character's abilities. You will need to know
    what your character does in response to key events to code in this recipe.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举并描述游戏角色的能力。您需要知道您的角色对按键事件的响应以编码此处的代码。
- en: 'There are several objects that we need to use here; they are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个我们需要使用的对象，它们如下：
- en: '`UGameplayAbility` class—this is needed to derivate the C++ class instances
    of the `UGameplayAbility` class, one derivative class for each ability.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UGameplayAbility`类 - 这是为了派生C++类的`UGameplayAbility`类实例，每个能力都有一个派生类。'
- en: Define what each ability does in `.h` and `.cpp` by overriding available functions,
    such as `UGameplayAbility::ActivateAbility`, `UGameplayAbility::InputPressed`,
    `UGameplayAbility::CheckCost`, `UGameplayAbility::ApplyCost`, `UGameplayAbility::ApplyCooldown`,
    and so on
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重写可用函数（如`UGameplayAbility::ActivateAbility`、`UGameplayAbility::InputPressed`、`UGameplayAbility::CheckCost`、`UGameplayAbility::ApplyCost`、`UGameplayAbility::ApplyCooldown`等）在`.h`和`.cpp`中定义每个能力的功能。
- en: '`GameplayAbilitiesSet`—this is a `DataAsset` derivative object that contains
    a series of enum''d command values, and blueprints of the corresponding `UGameplayAbility`
    derivative classes that define the behavior for that particular input command.
    Each GameplayAbility is kicked off by a keystroke or mouse click, which is set
    in `DefaultInput.ini`.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameplayAbilitiesSet` - 这是一个`DataAsset`派生对象，包含一系列枚举的命令值，以及定义该特定输入命令行为的`UGameplayAbility`派生类的蓝图。每个GameplayAbility都由按键或鼠标点击触发，这在`DefaultInput.ini`中设置。'
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: In the following, we'll implement a `UGameplayAbility` derivative called `UGameplayAbility_Attack`
    for a `Warrior` class object. We'll attach this gameplay functionality to input
    command string `Ability1`, which we'll activate on the left-mouse button click.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将为`Warrior`类对象实现一个名为`UGameplayAbility_Attack`的`UGameplayAbility`派生类。我们将把这个游戏功能附加到输入命令字符串`Ability1`上，然后在鼠标左键点击时激活它。
- en: Link the `GameplayAbilities` API in your `ProjectName.Build.cs` file.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProjectName.Build.cs`文件中链接`GameplayAbilities` API。
- en: Derive a C++ class from `UGameplayAbility`. For example, write a C++ `UCLASS
    UGameplayAbility_Attack`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`UGameplayAbility`派生一个C++类。例如，编写一个C++ `UCLASS UGameplayAbility_Attack`。
- en: 'In the very least, you want to override the following:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少，您需要重写以下内容：
- en: The `UGameplayAbility_Attack::CanActivateAbility` member function to indicate
    when the actor is allowed to invoke the ability.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UGameplayAbility_Attack::CanActivateAbility`成员函数来指示角色何时可以调用该能力。
- en: The `UGameplayAbility_Attack::CheckCost` function to indicate whether the player
    can afford to use ability or not. This is extremely important, because if this
    returns false, ability invocation should fail.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UGameplayAbility_Attack::CheckCost`函数来指示玩家是否能够负担得起使用能力。这非常重要，因为如果返回false，能力调用应该失败。
- en: The `UGameplayAbility_Attack::ActivateAbility` member function and write the
    code that the `Warrior` is to execute when his `Attack` ability is activated.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UGameplayAbility_Attack::ActivateAbility`成员函数，并编写当`Warrior`激活他的`Attack`能力时要执行的代码。
- en: The `UGameplayAbility_Attack::InputPressed` member function and to respond to
    the key input event assigned to the ability.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UGameplayAbility_Attack::InputPressed`成员函数，并响应分配给该能力的按键输入事件。
- en: Derive a Blueprint class from your `UGameplayAbility_Attack` object inside the
    UE4 editor.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4编辑器中从您的`UGameplayAbility_Attack`对象派生一个蓝图类。
- en: 'Inside the editor, navigate to **Content Browser** and create a `GameplayAbilitiesSet`
    object by:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，导航到**内容浏览器**并创建一个`GameplayAbilitiesSet`对象：
- en: Right clicking on **Content Browser** and selecting **Miscellaneous** | **Data
    Asset**
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击**内容浏览器**，选择**杂项** | **数据资产**
- en: In the dialog box that follows, select `GameplayAbilitySet` for Data Asset Class
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在随后的对话框中，选择`GameplayAbilitySet`作为数据资产类
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In fact, the `GameplayAbilitySet` object is a `UDataAsset` derivative. It is
    located in `GameplayAbilitySet.h` and contains a single member function, `GameplayAbilitySet::GiveAbilities()`,
    which I strongly recommend you not to use for reasons listed in a later step.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`GameplayAbilitySet`对象是一个`UDataAsset`派生类。它位于`GameplayAbilitySet.h`中，并包含一个单一的成员函数`GameplayAbilitySet::GiveAbilities()`，我强烈建议您不要使用，原因将在后面的步骤中列出。
- en: '![How to do it…](img/00302.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00302.jpeg)'
- en: Name your `GameplayAbilitySet` data asset something related to the `Warrior`
    object so we know to select it into the `Warrior` class (for example, `WarriorGameplayAbilitySet`).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的`GameplayAbilitySet`数据资产命名为与`Warrior`对象相关的名称，以便我们知道要将其选择到`Warrior`类中（例如，`WarriorGameplayAbilitySet`）。
- en: Double-click to open and edit the new `WarriorAbilitySet` Data Asset. Stack
    in a list of `GameplayAbility` class derivative Blueprints by clicking **+** on
    the `TArray` object inside of it. Your `UGameplayAbility_Attack` object must appear
    in the dropdown.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击打开并编辑新的`WarriorAbilitySet`数据资产。通过在其中的`TArray`对象上点击**+**，将一系列`GameplayAbility`类派生蓝图堆叠在其中。您的`UGameplayAbility_Attack`对象必须出现在下拉列表中。
- en: Add `UPROPERTY UGameplayAbilitySet* gameplayAbilitySet` member to your `Warrior`
    class. Compile, run, and select-in `WarriorAbilitySet` as it sits in **Content
    Browser** (created in steps 5 to 7) of the abilities that this `Warrior` is capable
    of.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`UPROPERTY UGameplayAbilitySet* gameplayAbilitySet`成员添加到您的`Warrior`类中。编译、运行，并在**内容浏览器**中选择`WarriorAbilitySet`（在步骤5到7中创建）作为此`Warrior`能够使用的能力。
- en: Ensure that your `Actor` class derivative also derives from the `UAbilitySystemInterface`
    interface. This is extremely important so that calls to `(Cast<IAbilitySystemInterface>(yourActor))->GetAbilitySystemComponent()`
    succeed.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的`Actor`类派生类也派生自`UAbilitySystemInterface`接口。这非常重要，以便对`(Cast<IAbilitySystemInterface>(yourActor))->GetAbilitySystemComponent()`的调用成功。
- en: Sometime after the construction of your actor, call `gameplayAbilitySet->GiveAbilities(
    abilitySystemComponent );` or enter a loop, as shown in the following step where
    you invoke `abilitySystemComponent->GiveAbility()` for each ability listed in
    your `gameplayAbilitySet`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建角色之后的某个时候，调用`gameplayAbilitySet->GiveAbilities(abilitySystemComponent);`或进入一个循环，如下一步所示，在其中为您的`gameplayAbilitySet`中列出的每个能力调用`abilitySystemComponent->GiveAbility()`。
- en: Write an override for `AWarrior::SetupPlayerInputComponent( UInputComponent*
    Input )` to connect the input controller to the Warrior's GameplayAbility activations.
    After doing so, iterate over each GameplayAbility listed in your GameplayAbilitySet's
    **Abilities** group.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`AWarrior::SetupPlayerInputComponent(UInputComponent* Input)`编写一个重写，将输入控制器连接到Warrior的GameplayAbility激活。这样做后，迭代每个在您的GameplayAbilitySet的**Abilities**组中列出的GameplayAbility。
- en: Tip
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not use the `GameplayAbilitySet::GiveAbilities()` member function because
    it doesn't give you access to the set of `FGameplayAbilitySpecHandle` objects
    that you actually need to later bind and invoke the ability to an input component.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`GameplayAbilitySet::GiveAbilities()`成员函数，因为它不会给您访问实际上需要绑定和调用能力到输入组件的一组`FGameplayAbilitySpecHandle`对象。
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You must subclass and link in a set of `UGameplayAbility` objects to your actor's
    `UAbilitySystemComponent` object through a series of calls to `UAbilitySystemComponent::GiveAbility(
    spec )` with appropriately constructed `FGameplayAbilitySpec` objects. What this
    does is it decks out your actor with this bunch of `GameplayAbilities`. The functionality
    of each `UGameplayAbility`, its cost, cooldown, and activation is all neatly contained
    within the `UGameplayAbility` class derivative that you will construct.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须通过一系列对`UAbilitySystemComponent::GiveAbility(spec)`的调用，将一组`UGameplayAbility`对象子类化并链接到您的角色的`UAbilitySystemComponent`对象中，其中包括适当构造的`FGameplayAbilitySpec`对象。这样做的目的是为您的角色装备这一组`GameplayAbilities`。每个`UGameplayAbility`的功能、成本、冷却和激活都被整洁地包含在您将构建的`UGameplayAbility`类派生类中。
- en: There's more…
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You''ll want to carefully code in a bunch of the other functions that are available
    in the `GameplayAbility.h` header file, including implementations for the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要仔细编写一堆其他可在`GameplayAbility.h`头文件中使用的函数，包括以下实现：
- en: '`SendGameplayEvent`: This is a function to notify GameplayAbility that some
    general gameplay event has happened.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SendGameplayEvent`：这是一个通知GameplayAbility发生了一些常规游戏事件的函数。'
- en: '`CancelAbility`: This is a function to stop an ability''s usage midway through,
    and giving the ability an interrupted state.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CancelAbility`：这是一个函数，用于在使用能力过程中停止能力，并给予能力中断状态。'
- en: Keep in mind that there are a bunch of existing `UPROPERTY` near the bottom
    of the `UGameplayAbility` class declaration that either activate or cancel the
    ability upon addition or removal of certain `GameplayTags`. See the following
    *GameplayTags API – Attaching GameplayTags to an actor* recipe for more details.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，在`UGameplayAbility`类声明的底部附近有一堆现有的`UPROPERTY`，它们在添加或删除某些`GameplayTags`时激活或取消能力。有关详细信息，请参阅以下*GameplayTags
    API - 将GameplayTags附加到Actor*的示例。
- en: A bunch more! Explore the API and implement those functions you find to be useful
    in your code.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多！探索API并在代码中实现那些您认为有用的功能。
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `GameplayAbilities` API is a rich and nicely interwoven series of objects
    and functions. Really explore `GameplayEffects`, `GameplayTags` and `GameplayTasks`
    and how they integrate with the `UGameplayAbility` class to fully explore the
    functionality the library has to offer.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameplayAbilities` API是一系列丰富且巧妙交织的对象和函数。真正探索`GameplayEffects`，`GameplayTags`和`GameplayTasks`以及它们如何与`UGameplayAbility`类集成，以充分探索库所提供的功能。'
- en: GameplayAbilities API – Implementing stats with UAttributeSet
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameplayAbilities API - 使用UAttributeSet实现统计信息
- en: The `GameplayAbilities` API allows you to associate a set of attributes, that
    is, `UAttributeSet`, to an Actor. `UAttributeSet` describes properties appropriate
    for that Actor's in-game attributes, such as `Hp`, `Mana`, `Speed`, `Armor`, `AttackDamage`,
    and so on. You can either define a single game-wide set of attributes common to
    all Actors, or several different sets of attributes appropriate for the different
    classes of actors.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameplayAbilities` API允许您将一组属性（即`UAttributeSet`）与Actor关联起来。`UAttributeSet`描述了适用于该Actor的游戏属性的属性，例如`Hp`，`Mana`，`Speed`，`Armor`，`AttackDamage`等等。您可以定义一个适用于所有Actor的单个全局游戏属性集，或者适用于不同类别的Actor的几个不同的属性集。'
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: '`AbilitySystemComponent` is the first thing you will need to add to your actors
    to equip them to use *GameAbilities API* and `UAttributeSet`s. To define your
    custom `UAttributeSet`, you will simply derive from the `UAttributeSet` base class
    and extend the base class with your own series of `UPROPERTY` members. After that,
    you must register your custom `AttributeSet` with your `Actor` class'' `AbilitySystemComponent`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbilitySystemComponent`是您需要添加到Actor中的第一件事，以使其能够使用*GameAbilities API*和`UAttributeSet`。要定义自定义的`UAttributeSet`，您只需从`UAttributeSet`基类派生，并使用自己的一系列`UPROPERTY`成员扩展基类。之后，您必须将自定义的`AttributeSet`注册到`Actor`类的`AbilitySystemComponent`中。'
- en: How to do it…
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Link to the `GameplayAbilities` API in your `ProjectName.Build.cs` file.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProjectName.Build.cs`文件中链接到`GameplayAbilities` API。
- en: 'In its own file, derive from the `UAttributeSet` class and deck the class out
    with a set of `UPROPERTY` that you want each Actor to have in their property set.
    For example, you might want to declare your `UAttributeSet` derivate class similar
    to the following piece of code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自己的文件中，从`UAttributeSet`类派生，并使用一组`UPROPERTY`装饰该类，这些属性将在每个Actor的属性集中使用。例如，您可能希望声明类似于以下代码片段的`UAttributeSet`派生类：
- en: '[PRE24]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If your code is networked, you might want to enable replication on each of the
    `UPROPERTY` with the replicated declaration in the `UPROPERTY` macro.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码是网络化的，您可能希望在`UPROPERTY`的每个副本声明中启用复制。
- en: 'Connect `GameUnitAttributeSet` with your `AbilitySystemComponent` inside your
    `Actor` class by calling the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用以下代码将`GameUnitAttributeSet`与`Actor`类中的`AbilitySystemComponent`连接起来：
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can put this call somewhere in `PostInitializeComponents()`, or in code
    that is called later than that.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此调用放在`PostInitializeComponents()`的某个位置，或者在稍后调用的代码中。
- en: Once you have registered `UAttributeSet`, you can move on with the next recipe
    and apply `GameplayEffect` to some of the elements in the attribute set.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您注册了`UAttributeSet`，您可以继续下一个步骤，并将`GameplayEffect`应用于属性集中的某些元素。
- en: Be sure your `Actor` class object implements `IAbilitySystemInterface` by deriving
    from it. This is extremely important as the `UAbilitySet` object will attempt
    a cast to `IAbilitySystemInterface` to call `GetAbilitySystemComponent()` on it
    at various places in the code.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的`Actor`类对象通过从其派生来实现`IAbilitySystemInterface`。这非常重要，因为`UAbilitySet`对象将尝试将其转换为`IAbilitySystemInterface`，以在代码的各个位置调用`GetAbilitySystemComponent()`。
- en: How it works…
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`UAttributeSets` simply allow you to enumerate and define attributes of different
    actors. `GameplayEffects` will be your means to make changes to the attributes
    of a specific actor.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`UAttributeSets`只是允许您枚举和定义不同Actor的属性。`GameplayEffects`将是您对特定Actor的属性进行更改的手段。'
- en: There's more…
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can code in definitions of `GameplayEffects`, which will be things that
    act on the AbilitySystemComponent's `AttributeSet` collections. You can also write
    `GameplayTasks` for generic functions that run at specific time or events, or
    even in response to tag addition (`GameplayTagResponseTable.cpp`). You can define
    `GameplayTags` to modify GameplayAbility behavior as well as select and match
    gameplay units during play.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写`GameplayEffects`的定义，这些定义将对AbilitySystemComponent的`AttributeSet`集合产生影响。您还可以编写`GameplayTasks`，用于在特定时间或事件运行的通用函数，甚至是响应标签添加（`GameplayTagResponseTable.cpp`）。您可以定义`GameplayTags`来修改GameplayAbility的行为，并在游戏过程中选择和匹配游戏单位。
- en: GameplayAbilities API – Implementing buffs with GameplayEffect
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameplayAbilities API - 使用GameplayEffect实现增益效果
- en: A buff is just an effect that introduces a temporary, permanent, or recurring
    change to a game unit's attributes from its `AttributeSet`. Buffs can either be
    good or bad, supplying either bonuses or penalties. For example, you might have
    a hex buff that slows a unit to half speed, an angel wing buff that increases
    unit speed by 2x, or a cherub buff that recovers `5 hp` every five seconds for
    three minutes. A `GameplayEffect` affects an individual gameplay attributes in
    the `UAttributeSet` attached to an `AbilitySystemComponent` of an Actor.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: A buff is just an effect that introduces a temporary, permanent, or recurring
    change to a game unit's attributes from its `AttributeSet`. Buffs can either be
    good or bad, supplying either bonuses or penalties. For example, you might have
    a hex buff that slows a unit to half speed, an angel wing buff that increases
    unit speed by 2x, or a cherub buff that recovers `5 hp` every five seconds for
    three minutes. A `GameplayEffect` affects an individual gameplay attributes in
    the `UAttributeSet` attached to an `AbilitySystemComponent` of an Actor.
- en: Getting ready
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Getting ready
- en: Brainstorm your game units' effects that happen during the game. Be sure that
    you've created an `AttributeSet`, shown in the previous recipe, with gameplay
    attributes that you'd like to affect. Select an effect to implement and follow
    the succeeding steps with your example.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Brainstorm your game units' effects that happen during the game. Be sure that
    you've created an `AttributeSet`, shown in the previous recipe, with gameplay
    attributes that you'd like to affect. Select an effect to implement and follow
    the succeeding steps with your example.
- en: Tip
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tip
- en: You may want to turn `LogAbilitySystem` to a `VeryVerbose` setting by going
    to the **Output Log** and typing [PRE26]
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: You may want to turn `LogAbilitySystem` to a `VeryVerbose` setting by going
    to the **Output Log** and typing [PRE26]
- en: // Create GameplayEffect recovering 50 hp one time only to unit
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: // Create GameplayEffect recovering 50 hp one time only to unit
- en: CONSTRUCT_CLASS( UGameplayEffect, RecoverHP );
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: CONSTRUCT_CLASS( UGameplayEffect, RecoverHP );
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: AddModifier( RecoverHP,
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: AddModifier( RecoverHP,
- en: GET_FIELD_CHECKED( UGameUnitAttributeSet, Hp ),
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: GET_FIELD_CHECKED( UGameUnitAttributeSet, Hp ),
- en: EGameplayModOp::Additive, FScalableFloat( 50.f ) );
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: EGameplayModOp::Additive, FScalableFloat( 50.f ) );
- en: '[PRE28]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: RecoverHP->DurationPolicy = EGameplayEffectDurationType::HasDuration;
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: RecoverHP->DurationPolicy = EGameplayEffectDurationType::HasDuration;
- en: RecoverHP->DurationMagnitude = FScalableFloat( 10.f );
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: RecoverHP->DurationMagnitude = FScalableFloat( 10.f );
- en: RecoverHP->ChanceToApplyToTarget = 1.f;
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: RecoverHP->ChanceToApplyToTarget = 1.f;
- en: RecoverHP->Period = .5f;
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: RecoverHP->Period = .5f;
- en: '[PRE29]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: FActiveGameplayEffectHandle recoverHpEffectHandle =
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: FActiveGameplayEffectHandle recoverHpEffectHandle =
- en: AbilitySystemComponent->ApplyGameplayEffectToTarget( RecoverHP,
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: AbilitySystemComponent->ApplyGameplayEffectToTarget( RecoverHP,
- en: AbilitySystemComponent, 1.f );
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: AbilitySystemComponent, 1.f );
- en: '[PRE30]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: FActiveGameplayEffectHandle recoverHpEffectHandle =
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: FActiveGameplayEffectHandle recoverHpEffectHandle =
- en: AbilitySystemComponent->ApplyGameplayEffectToTarget( RecoverHP,
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: AbilitySystemComponent->ApplyGameplayEffectToTarget( RecoverHP,
- en: AbilitySystemComponent, 1.f );
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: AbilitySystemComponent, 1.f );
- en: if( recoverHpEffectHandle ) {
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: if( recoverHpEffectHandle ) {
- en: recoverHpEffectHandle->AddLambda( []() {
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: recoverHpEffectHandle->AddLambda( []() {
- en: Info( "RecoverHp Effect has been removed." );
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Info( "RecoverHp Effect has been removed." );
- en: '} );'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '} );'
- en: '}'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE31]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = GameplayTags )
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = GameplayTags )
- en: TArray<FString> GameplayTagTableNames;
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: TArray<FString> GameplayTagTableNames;
- en: '[PRE32]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: IGameplayTagsModule::Get().GetGameplayTagsManager().
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: IGameplayTagsModule::Get().GetGameplayTagsManager().
- en: LoadGameplayTagTable( GameplayTagTableNames );
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: LoadGameplayTagTable( GameplayTagTableNames );
- en: '[PRE33]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: // Like a constructor.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: // Like a constructor.
- en: UGameplayTask_CreateParticles* UGameplayTask_CreateParticles::ConstructTask(
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: UGameplayTask_CreateParticles* UGameplayTask_CreateParticles::ConstructTask(
- en: TScriptInterface<IGameplayTaskOwnerInterface> TaskOwner,
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: TScriptInterface<IGameplayTaskOwnerInterface> TaskOwner,
- en: UParticleSystem* particleSystem,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: UParticleSystem* particleSystem,
- en: FVector location )
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: FVector location )
- en: '{'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: UGameplayTask_CreateParticles* task =
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: UGameplayTask_CreateParticles* task =
- en: NewTask<UGameplayTask_CreateParticles>( TaskOwner );
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: NewTask<UGameplayTask_CreateParticles>( TaskOwner );
- en: // Fill fields
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: // Fill fields
- en: if( task )
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: if( task )
- en: '{'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: task->ParticleSystem = particleSystem;
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: task->ParticleSystem = particleSystem;
- en: task->Location = location;
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: task->Location = location;
- en: '}'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return task;
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: return task;
- en: '}'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE34]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: void UGameplayTask_CreateEmitter::Activate()
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: void UGameplayTask_CreateEmitter::Activate()
- en: '{'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Super::Activate();
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Super::Activate();
- en: UGameplayStatics::SpawnEmitterAtLocation( GetWorld(),
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: UGameplayStatics::SpawnEmitterAtLocation( GetWorld(),
- en: ParticleSystem->GetDefaultObject<UParticleSystem>(),
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ParticleSystem->GetDefaultObject<UParticleSystem>(),
- en: Location );
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Location );
- en: '}'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE35]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: UGameplayTask_CreateParticles* task =
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: UGameplayTask_CreateParticles* task =
- en: UGameplayTask_CreateParticles::ConstructTask( this,
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: UGameplayTask_CreateParticles::ConstructTask( this,
- en: particleSystem, FVector( 0.f, 0.f, 200.f ) );
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: particleSystem, FVector( 0.f, 0.f, 200.f ) );
- en: if( GameplayTasksComponent )
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: if( GameplayTasksComponent )
- en: '{'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: GameplayTasksComponent->AddTaskReadyForActivation( *task );
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: GameplayTasksComponent->AddTaskReadyForActivation( *task );
- en: '}'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE36]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '#include "Runtime/Online/HTTP/Public/HttpManager.h"'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "Runtime/Online/HTTP/Public/HttpManager.h"'
- en: '#include "Runtime/Online/HTTP/Public/HttpModule.h"'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "Runtime/Online/HTTP/Public/HttpModule.h"'
- en: '#include "Runtime/Online/HTTP/Public/HttpRetrySystem.h"'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "Runtime/Online/HTTP/Public/HttpRetrySystem.h"'
- en: '[PRE37]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: TSharedRef<IHttpRequest> http=FHttpModule::Get().CreateRequest();
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: TSharedRef<IHttpRequest> http=FHttpModule::Get().CreateRequest();
- en: '[PRE38]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: void HttpRequestComplete( FHttpRequestPtr request,
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: void HttpRequestComplete( FHttpRequestPtr request,
- en: FHttpResponsePtr response, bool success );
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: FHttpResponsePtr response, bool success );
- en: '[PRE39]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: FHttpRequestCompleteDelegate& delegate = http->OnProcessRequestComplete();
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: FHttpRequestCompleteDelegate& delegate = http->OnProcessRequestComplete();
- en: '[PRE40]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: delegate.BindLambda(
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 委托.BindLambda(
- en: // Anonymous, inlined code function (aka lambda)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: // Anonymous, inlined code function (aka lambda)
- en: '[]( FHttpRequestPtr request, FHttpResponsePtr response, bool success ) -> void'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[]( FHttpRequestPtr request, FHttpResponsePtr response, bool success ) -> void'
- en: '{'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'UE_LOG( LogTemp, Warning, TEXT( "Http Response: %d, %s" ),'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 'UE_LOG( LogTemp, Warning, TEXT( "Http Response: %d, %s" ),'
- en: request->GetResponse()->GetResponseCode(),
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: request->GetResponse()->GetResponseCode(),
- en: '*request->GetResponse()->GetContentAsString() );'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*request->GetResponse()->GetContentAsString() );'
- en: '});'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE41]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: delegate.BindUObject( this, &AChapter12GameMode::HttpRequestComplete );
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: delegate.BindUObject( this, &AChapter12GameMode::HttpRequestComplete );
- en: '[PRE42]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: PlainObject* plainObject = new PlainObject();
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: PlainObject* plainObject = new PlainObject();
- en: delegate.BindRaw( plainObject, &PlainObject::httpHandler );
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: delegate.BindRaw( plainObject, &PlainObject::httpHandler );
- en: // plainObject cannot be DELETED Until httpHandler gets called..
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: // plainObject cannot be DELETED Until httpHandler gets called..
- en: '[PRE43]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '// C-style function for handling the HTTP response:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '// C-style function for handling the HTTP response:'
- en: void httpHandler( FHttpRequestPtr request,
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: void httpHandler( FHttpRequestPtr request,
- en: FHttpResponsePtr response, bool success )
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: FHttpResponsePtr response, bool success )
- en: '{'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'Info( "static: Http req handled" );'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'Info( "static: Http req handled" );'
- en: '}'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: delegate.BindStatic( &httpHandler );
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: delegate.BindStatic( &httpHandler );
- en: '[PRE44]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: http->SetURL( TEXT( "http://unrealengine.com" ) );
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: http->SetURL( TEXT( "http://unrealengine.com" ) );
- en: '[PRE45]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: http->ProcessRequest();
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: http->ProcessRequest();
- en: '[PRE46]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: HandleRequestProgress( FHttpRequestPtr request, int32 sentBytes, int32 receivedBytes
    )
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: HandleRequestProgress( FHttpRequestPtr request, int32 sentBytes, int32 receivedBytes
    )
- en: '[PRE47]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: TSharedRef<IHttpRequest> http = HttpModule::Get().CreateRequest();
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: TSharedRef<IHttpRequest> http = HttpModule::Get().CreateRequest();
- en: '[PRE48]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: http->OnRequestProgress().BindLambda( []( FHttpRequestPtr request, int32 sentBytes,
    int32 receivedBytes ) -> void
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: http->OnRequestProgress().BindLambda( []( FHttpRequestPtr request, int32 sentBytes,
    int32 receivedBytes ) -> void
- en: '{'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int32 totalLen = request->GetResponse()->GetContentLength();
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: int32 totalLen = request->GetResponse()->GetContentLength();
- en: float perc = (float)receivedBytes/totalLen;
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: float perc = (float)receivedBytes/totalLen;
- en: if( HttpProgressBar )
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（HttpProgressBar）
- en: HttpProgressBar->SetPercent( perc );
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: HttpProgressBar->SetPercent( perc );
- en: '} );'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '} );'
- en: '```'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Process your request with `http->ProcessRequest()`.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`http->ProcessRequest()`处理您的请求。
- en: How it works…
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `OnRequestProgress()` callback gets fired every so often with the bytes
    sent and bytes received HTTP progress. We will compute the total percent of the
    download that is complete by calculating `(float)receivedBytes/totalLen`, where
    `totalLen` is the HTTP response's total length in bytes. Using the lambda function
    we attached to the `OnRequestProgress()` delegate callback, we can call the UMG
    widget's `.SetPercent()` member function to reflect the download's progress.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnRequestProgress()`回调会定期触发，显示已发送和已接收的字节的HTTP进度。我们将通过计算`(float)receivedBytes/totalLen`来计算下载完成的总百分比，其中`totalLen`是HTTP响应的总字节长度。使用我们附加到`OnRequestProgress()`委托回调的lambda函数，我们可以调用UMG小部件的`.SetPercent()`成员函数来反映下载的进度。'
