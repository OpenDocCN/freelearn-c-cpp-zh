- en: Assessments
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: Why should you care about software architecture?
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么您应该关心软件架构？
- en: Architecture allows you to achieve and maintain the requisite qualities of software.
    Being mindful and caring about it prevents a project from having accidental architecture,
    thereby losing quality, and also prevents software decay.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构允许您实现和维护软件的必要特性。关注和关心它可以防止项目出现意外的架构，从而失去质量，并且可以防止软件腐败。
- en: Should the architect be the ultimate decision maker in an Agile team?
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敏捷团队中，架构师应该是最终的决策者吗？
- en: No. Agile is about empowering the whole team. An architect brings their experience
    and knowledge to the table, but if a decision has to be accepted by the whole
    team, the team should own it, not just the architect. Considering the needs of
    stakeholders is also of great importance here.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不。敏捷是关于赋予整个团队权力。架构师将他们的经验和知识带到了桌面上，但如果一个决定必须得到整个团队的接受，那么团队应该拥有它，而不仅仅是架构师。考虑利益相关者的需求在这里也非常重要。
- en: How does the **Single Responsibility Principle** (**SRP**) relate to cohesion?
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单一责任原则**（SRP）与内聚性有何关系？'
- en: Following the SRP leads to better cohesion. If a component starts having multiple
    responsibilities, usually it becomes less cohesive. In such instances, it's best
    to just refactor it into multiple components, each having a single responsibility.
    This way, we increase cohesiveness, so the code becomes easier to understand,
    develop, and maintain.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循SRP会导致更好的内聚性。如果一个组件开始具有多个责任，通常它的内聚性会降低。在这种情况下，最好将其重构为多个组件，每个组件都具有单一责任。这样，我们增加了内聚性，使代码更容易理解，开发和维护。
- en: During what phases of a project's lifetime can benefit be derived from having
    an architect?
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的生命周期的哪些阶段可以从拥有架构师中获得好处？
- en: An architect can bring value to a project from its inception until the time
    it goes into maintenance. The most value can be achieved during the early phases
    of the project's development, as this is where key decisions about how it should
    look will be taken. However, this doesn't mean that architects cannot be valuable
    during development. They can keep the project on the right course and on track.
    By aiding decisions and overseeing the project, they ensure that the code doesn't
    end up with accidental architecture and is not subject to software decay.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构师可以从项目开始直到进入维护阶段为项目带来价值。最大的价值可以在项目开发的早期阶段实现，因为这是关于项目外观应该如何的关键决定。然而，这并不意味着架构师在开发过程中没有价值。他们可以确保项目走上正确的道路并保持在轨道上。通过协助决策和监督项目，他们确保代码不会出现意外的架构，并且不会受到软件腐败的影响。
- en: What's the benefit of following the SRP?
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循SRP的好处是什么？
- en: Code that follows the SRP is easier to understand and maintain. This also means
    that it has fewer bugs.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循SRP的代码更容易理解和维护。这也意味着它有更少的错误。
- en: Chapter 2
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: What are the traits of a RESTful service?
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RESTful服务的特点是什么？
- en: Obviously, the use of REST APIs.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，使用REST API。
- en: Statelessness – Each request contains all the data required for its processing.
    Remember, this doesn't mean that RESTful services cannot use databases, quite
    the opposite.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态性-每个请求包含其处理所需的所有数据。请记住，这并不意味着RESTful服务不能使用数据库，恰恰相反。
- en: Using cookies instead of keeping sessions.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cookie而不是保持会话。
- en: What toolkit can you use to assist you in creating a resilient distributed architecture?
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用哪些工具包来帮助您创建弹性分布式架构？
- en: Simian Army by Netflix.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix的Simian Army。
- en: Should you use centralized storage for your microservices? Why/why not?
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微服务中应该使用集中式存储吗？为什么/为什么不？
- en: Microservices should use decentralized storage. Each microservice should choose
    the storage type that suits it best, as this leads to increased efficiency and
    scalability.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务应该使用分散式存储。每个微服务应该选择最适合自己的存储类型，因为这会提高效率和可扩展性。
- en: When should you write a stateful service instead of a stateless one?
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该编写有状态的服务而不是无状态的服务？
- en: Only when it's not reasonable to have a stateless one and you won't need to
    scale. For instance, when the client and service have to keep their state in sync
    or when the state to send would be enormous.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在没有理由使用无状态服务并且您不需要扩展时才需要有状态服务。例如，当客户端和服务必须保持它们的状态同步或者要发送的状态非常庞大时。
- en: How does a broker differ from a mediator?
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经纪人和中介者有何不同？
- en: A mediator "mediates" between services, so it needs to know how to process each
    request. A broker only knows where to send each request, so it's a lightweight
    component. It can be used to create a publisher-subscriber (pub-sub) architecture.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者在服务之间“调解”，因此需要知道如何处理每个请求。经纪人只知道将每个请求发送到哪里，因此它是一个轻量级组件。它可以用来创建发布-订阅（pub-sub）架构。
- en: What is the difference between an N-tier and an N-layer architecture?
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N层架构和N层架构之间有什么区别？
- en: Layers are logical and specify how you organize your code. Tiers are physical
    and specify how you run your code. Each tier has to be separated by others, either
    by being run in a different process, or even on a different machine.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次是逻辑的，指定了代码的组织方式。层是物理的，指定了代码的运行方式。每个层必须与其他层分离，可以通过在不同的进程中运行，甚至在不同的机器上运行来实现。
- en: How should you approach replacing a monolith with a microservice-based architecture?
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该如何处理用微服务架构替换单体架构？
- en: Incrementally. Carve small microservices out of the monolith. You can use the
    strangler pattern described in *Chapter 4, Architectural and System Design*, to
    help you with this.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步进行。从单体架构中剥离出小的微服务。您可以使用《第4章，架构和系统设计》中描述的窒息者模式来帮助您完成这项工作。
- en: Chapter 3
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: What are quality attributes?
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 质量属性是什么？
- en: Traits, or qualities, that a system may have. Often called "ilities," as many
    of them have this postfix in their names, for instance, portability.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可能具有的特征或特质。通常被称为“ilities”，因为它们的名称中许多都有这个后缀，例如可移植性。
- en: What sources should you use when gathering requirements?
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收集需求时应该使用哪些来源？
- en: The context of your system, existing documentation, and the system's stakeholders.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的上下文，现有文档和系统的利益相关者。
- en: How should you be able to tell whether a requirement is architecturally significant?
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您定义一个函数时，如何能够判断一个需求是否具有架构重要性？
- en: '**A****rchitecturally significant requirements** (**A****SRs**) often require
    a separate software component, impact a large part of the system, are hard to
    achieve, and/or force you to make trade-offs.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构重要需求**（**ASRs**）通常需要一个单独的软件组件，影响系统的大部分，难以实现，和/或迫使您做出权衡。'
- en: How should you document graphically the functional requirements various parties
    may have regarding your system?
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该如何以图形方式记录各方可能对系统的功能需求？
- en: Prepare a use case diagram.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备一个用例图。
- en: When is development view documentation useful?
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发视图文档何时有用？
- en: In cases where you're developing a large system with many modules and need to
    communicate global constraints and common design choices to all the software teams.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您开发具有许多模块并且需要将全局约束和常见设计选择传达给所有软件团队的大型系统的情况下。
- en: How should you automatically check whether your code's API documentation is
    out of date?
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何自动检查您的代码API文档是否过时？
- en: Doxygen has built-in checks, like the one that warns you about mismatches between
    the function signatures and their parameters in comments.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Doxygen具有内置检查，比如警告您关于函数签名和注释中的参数之间不匹配的检查。
- en: How should you show on a diagram that a given operation is handled by different
    components of the system?
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该如何在图表上显示给定操作是由系统的不同组件处理的？
- en: Use one of the UML interaction diagrams for this purpose. Sequence diagrams
    are a good choice, although communication diagrams can be fine in certain scenarios,
    too.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为此目的使用UML交互图之一。序列图是一个不错的选择，尽管在某些情况下通信图也可以很好地完成。
- en: Chapter 4
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: What is event sourcing?
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事件溯源？
- en: This is an architectural pattern that relies on keeping track of events that
    change the state of the system instead of keeping track of the state *per se*.
    It brings benefits such as lower latency, free audit logs, and debugability.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种架构模式，依赖于跟踪改变系统状态的事件，而不是跟踪状态*本身*。它带来了诸如较低的延迟、免费审计日志和可调试性等好处。
- en: What are the practical consequences of the CAP theorem?
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAP定理的实际后果是什么？
- en: As network partitions happen, if you want a distributed system, you'll need
    to choose between consistency and availability. In cases of partitions, you can
    either return stale data, an error, or risk timeouts.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着网络分区的发生，如果您想要一个分布式系统，您需要在一致性和可用性之间做出选择。在分区的情况下，您可以返回陈旧的数据、错误，或者冒风险超时。
- en: What can you use Netflix's Chaos Monkey for?
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以如何使用Netflix的Chaos Monkey？
- en: It can help you prepare for unexpected downtime of your services.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以帮助您为服务的意外停机做好准备。
- en: Where can caching be applied?
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存可以应用在哪里？
- en: Either on your client's side, in front of web servers, databases, or applications,
    or on a host near your potential client, depending on your needs.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在客户端的一侧，在Web服务器、数据库或应用程序的前面，或者在靠近潜在客户端的主机上，具体取决于您的需求。
- en: How should you prevent your app from going down when an entire data center does?
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该如何防止应用程序在整个数据中心崩溃时？
- en: By using geodes.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用地理。
- en: Why should you use an API gateway?
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该使用API网关？
- en: To simplify client code, as it doesn't need to hardcode the addresses of your
    service instances.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化客户端代码，因为它不需要硬编码服务实例的地址。
- en: How can Envoy help you to achieve various architectural goals?
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Envoy如何帮助您实现各种架构目标？
- en: It aids your system's fault tolerance by providing backpressure, circuit breaking,
    automatic retries, and outlier detection.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过提供背压、断路器、自动重试和异常检测来帮助系统的容错性。
- en: It aids deployability by allowing canary releases and blue-green deployments.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过允许金丝雀发布和蓝绿部署来帮助部署能力。
- en: It also offers load balancing, tracing, monitoring, and metrics.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还提供负载平衡、跟踪、监控和度量。
- en: Chapter 5
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: How should you ensure each file of our code that's open, will be closed when
    no longer in use?
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当不再使用时，如何确保我们代码的每个打开的文件都会关闭？
- en: By using the RAII idiom; for instance, by using `std::unique_ptr`, which will
    close it in its destructor.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用RAII习惯用法；例如，通过使用`std::unique_ptr`，它将在其析构函数中关闭它。
- en: When should you use "naked" pointers in C++ code?
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++代码中什么时候应该使用“裸”指针？
- en: Only to pass optional (nullable) references.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅用于传递可选（可空）引用。
- en: What is a deduction guide?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是推断指南？
- en: A way of telling the compiler what parameters it should deduce for a template.
    They can be implicit or user-defined.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种告诉编译器应该为模板推断哪些参数���方法。它们可以是隐式的或用户定义的。
- en: When should you use `std::optional`, and when should you use `gsl::not_null`?
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用`std::optional`，何时应该使用`gsl::not_null`？
- en: The former is for cases where we want to pass the contained value around. The
    latter just passes the pointer to it. Also, the former can be empty, while the
    latter will always point to an object.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前者是用于我们想要传递包含的值的情况。后者只是传递指向它的指针。此外，前者可以为空，而后者总是指向一个对象。
- en: How do range algorithms differ from views?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 范围算法与视图有何不同？
- en: Algorithms are eager, while views are lazy. Algorithms also allow the use of
    projections.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法是急切的，而视图是懒惰的。算法还允许使用投影。
- en: How should you constrain your type more than just by specifying the concept
    name when you're defining a function?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义函数时，如何能够比仅指定概念名称更多地限制您的类型？
- en: By using a `requires` clause.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`requires`子句。
- en: How does `import X` differ from `import <X>`?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import X`与`import <X>`有何不同？'
- en: The latter allows macros from the imported `X` header to be visible.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后者允许从导入的`X`头文件中可见宏。
- en: Chapter 6
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: What are the rules of three, five, and zero?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三、五和零的规则是什么？
- en: Best practices to follow for writing types with unsurprising semantics and fewer
    bugs.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写具有可预测语义和更少错误的类型的最佳实践。
- en: When should you use niebloids versus hidden friends?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用niebloids而不是隐藏的朋友？
- en: Niebloids "disable" ADL, while hidden friends rely on it to be found. The former
    can therefore speed up compilation (fewer overloads to consider), while the latter
    can help you implement customization points.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Niebloids“禁用”ADL，而隐藏的友元依赖于它被找到。因此，前者可以加快编译速度（考虑的重载更少），而后者可以帮助您实现定制点。
- en: How can an `Array` interface be improved to be more production-ready?
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何改进`Array`接口以更适合生产？
- en: '`begin`, `end`, and their constant and reverse equivalents should be added
    so it can be used like a proper container. Traits such as `value_type`, `pointer`,
    and `iterator` can be useful to reuse it in generic code. Sprinkling the members
    with `constexpr` and `noexcept` could aid safety and performance. The `const`
    overload for `operator[]` is also missing.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该添加`begin`，`end`及其常量和反向等效项，以便它可以像一个适当的容器一样使用。例如，`value_type`，`pointer`和`iterator`等特性可以在通用代码中重用。在成员中添加`constexpr`和`noexcept`可以增加安全性和性能。`operator[]`的`const`重载也是缺失的。
- en: What are fold expressions?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 折叠表达式是什么？
- en: Expressions that fold, or reduce, a parameter pack over a binary functor. In
    other words, statements that apply a given operation to all the passed variadic
    template arguments so that a single value (or `void`) is produced.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折叠表达式是指将参数包在二元函数器上折叠或减少的表达式。换句话说，这些语句将给定操作应用于所有传递的可变模板参数，以便产生单个值（或`void`）。
- en: When shouldn't you use static polymorphism?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时不应该使用静态多态性？
- en: When you need to provide the consumers of your code with a way to add more types
    at runtime.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要为您的代码的消费者提供一种在运行时添加更多类型的方法时。
- en: How can we save on one more allocation in the winking out example?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在眨眼示例中如何节省一次额外的分配？
- en: By avoiding the resizing of the vector when adding elements.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过避免在添加元素时调整向量的大小。
- en: Chapter 7
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: What's the difference between installing and exporting your targets in CMake?
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CMake中安装和导出目标有什么区别？
- en: Exporting means the targets will be available for other projects that try to
    find our package, even if our code is not installed. CMake's package registry
    can be used to store data about locations of the exported targets. The binaries
    never leave the build directory. Installation requires the targets to be copied
    somewhere and, if it's not a system directory, setting up paths to the config
    files or the targets themselves.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出口意味着目标将对其他试图找到我们的软件包的项目可用，即使我们的代码没有安装。 CMake的软件包注册表可用于存储有关导出目标位置的数据。二进制文件永远不会离开构建目录。安装需要将目标复制到某个地方，并且如果不是系统目录，则设置路径到配置文件或目标本身。
- en: How should you make your template code compile faster?
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使您的模板代码编译更快？
- en: Follow the Rule of Chiel.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循Chiel的规则。
- en: How should you use multiple compilers with Conan?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在Conan中使用多个编译器？
- en: Use Conan profiles.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Conan配置文件。
- en: What should you do if you'd like to compile your Conan dependencies with the
    pre-C++11 GCC ABI?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想使用先前的C++11 GCC ABI编译您的Conan依赖项，应该怎么做？
- en: Set `compiler.libcxx` to `libstdc++` instead of `libstdc++11`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`compiler.libcxx`设置为`libstdc++`而不是`libstdc++11`。
- en: How should you ensure that you force a specific C++ standard in CMake?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CMake中如何确保强制使用特定的C++标准？
- en: By calling `set_target_properties(our_target PROPERTIES CXX_STANDARD our_required_cxx_standard
    CXX_STANDARD_REQUIRED YES CXX_EXTENSIONS NO)`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`set_target_properties(our_target PROPERTIES CXX_STANDARD our_required_cxx_standard
    CXX_STANDARD_REQUIRED YES CXX_EXTENSIONS NO)`。
- en: How should you build documentation in CMake and ship it along with your RPM
    package?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CMake中如何构建文档并将其与您的RPM软件包一起发布？
- en: Create a target to generate the documentation as described in [Chapter 3](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=26&action=edit),
    *Functional and Nonfunctional Requirements*, install it to `CMAKE_INSTALL_DOCDIR`,
    and then make sure the path is not specified in the `CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST`
    variable.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个目标以生成文档，如[第3章](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=26&action=edit)中所述，“功能和非功能需求”，将其安装到`CMAKE_INSTALL_DOCDIR`，然后确保路径未在`CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST`变量中指定。
- en: Chapter 8
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ��8章
- en: What is the base layer of the testing pyramid?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔的基础层是什么？
- en: Unit tests.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试。
- en: What kinds of non-functional tests are there?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些非功能测试？
- en: Performance, endurance, security, availability, integrity, and usability.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能，耐久性，安全性，可用性，完整性和可用性。
- en: What is the name of a famous method for root cause analysis?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个著名的根本原因分析方法的名字是什么？
- en: 5 whys
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5个为什么
- en: Is it possible to test compile-time code in C++?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++中是否可能测试编译时代码？
- en: Yes, for example, using `static_assert`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，例如使用`static_assert`。
- en: What should you use when writing unit tests for code with external dependencies?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为具有外部依赖项的代码编写单元测试时应该使用什么？
- en: Test doubles such as mocks and fakes.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试替身，比如模拟和伪造。
- en: What is the role of unit tests in Continuous Integration/Continuous Deployment?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试在持续集成/持续部署中的作用是什么？
- en: They are the basis of a gating mechanism and act as an early warning feature.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是一个门控机制的基础，并作为一个早期警告功能。
- en: Name some tools that allow the testing of infrastructure code.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些允许测试基础设施代码的工具。
- en: Serverspec, Testinfra, Goss.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serverspec，Testinfra，Goss。
- en: Is it a good idea to access the class's private attributes and methods in a
    unit test?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单元测试中访问类的私有属性和方法是一个好主意吗？
- en: You should design classes in such a way that you never have to access their
    private attributes directly.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该设计类，以便您永远不必直接访问它们的私有属性。
- en: Chapter 9
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: In what ways does Continuous Integration save time during development?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持续集成在开发过程中如何节省时间？
- en: It allows you to catch bugs earlier and fix them before they enter production.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您在进入生产之前捕获错误并修复它们。
- en: Do you need separate tools to implement Continuous Integration and Continuous
    Deployment?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要单独的工具来实现持续集成和持续部署吗？
- en: The pipelines are usually written using a single tool; multiple tools are used
    for actual testing and deployment.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流水线通常使用单个工具编写；实际测试和部署使用多个工具。
- en: When does it make sense to perform a code review in a meeting?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在会议中进行代码审查何时是有意义的？
- en: When an asynchronous code review is taking too long.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当异步代码审查时间太长时。
- en: What tools can you use to assess the quality of your code during Continuous
    Integration?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在持续集成期间，您可以使用哪些工具来评估代码的质量？
- en: Tests, static analysis.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试，静态分析。
- en: Who participates in specifying BDD scenarios?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁参与指定BDD场景？
- en: Developers, QA, the business.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员、QA、业务。
- en: When should you consider using immutable infrastructure? When should you rule
    it out?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应考虑使用不可变基础设施？何时应该排除它？
- en: It is best used with stateless services or services that can outsource storage
    using a database or a network storage. It is not suitable for stateful services.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它最适用于无状态服务或可以使用数据库或网络存储外包存储的服务。不适用于有状态服务。
- en: How would you characterize the differences between Ansible, Packer, and Terraform?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何描述Ansible、Packer和Terraform之间的区别？
- en: Ansible is designed for the configuration management of existing VMs, Packer
    is for building cloud VM images, and Terraform is for building the cloud infrastructure
    (such as networks, VMs, and load balancers).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible旨在对现有VM的配置管理，Packer用于构建云VM镜像，Terraform用于构建云基础设施（如网络、VM和负载均衡器）。
- en: Chapter 10
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: Why is security important in modern systems?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么安全在现代系统中很重要？
- en: Modern systems are typically connected to a network and are therefore potentially
    vulnerable to external attacks.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代系统通常连接到网络，因此可能容易受到外部攻击。
- en: What are some of the challenges associated with concurrency?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发性带来的一些挑战是什么？
- en: Code is harder to design and to debug. Update problems may arise.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更难设计和调试。可能会出现更新问题。
- en: What are the C++ core guidelines?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++核心指南是什么？
- en: Best practices that document how to build C++ systems.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录如何构建C++系统的最佳实践。
- en: What's the difference between secure coding and defensive coding?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全编码和防御性编码之间有什么区别？
- en: Secure coding offers robustness to end users, whereas defensive coding offers
    robustness to interface consumers.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全编码为最终用户提供了健壮性，而防御性编码为接口消费者提供了健壮性。
- en: How should you check whether your software contains known vulnerabilities?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该如何检查您的软件是否包含已知的漏洞？
- en: By using a CVE database or an automated scanner such as OWASP Dependency-Check
    or Snyk.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用CVE数据库或自动扫描程序，如OWASP Dependency-Check或Snyk。
- en: What's the difference between static and dynamic analysis?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态分析和动态分析之间有什么区别？
- en: Static analysis is performed on source code without executing it. Dynamic analysis
    requires execution.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态分析是在不执行源代码的情况下执行的。动态分析需要执行。
- en: What's the difference between static and dynamic linking?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态链接和动态链接之间有什么区别？
- en: With static linking, the executable contains all the code necessary to run the
    application. With dynamic linking, some parts of the code (the dynamic libraries)
    are shared between different executables.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态链接，可执行文件包含运行应用程序所需的所有代码。使用动态链接，一些代码部分（动态库）在不同的可执行文件之间共享。
- en: How can you use the compiler to fix security problems?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何使用编译器来解决安全问题？
- en: Modern compilers include sanitizers that check for certain flaws.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代编译器包括检查某些缺陷的消毒剂。
- en: How can you implement security awareness in your Continuous Integration pipeline?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何在持续集成流程中实施安全意识？
- en: By using automated tools that scan for vulnerabilities and perform all kinds
    of static and dynamic analysis.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用扫描漏洞并执行各种静态和动态分析的自动化工具。
- en: Chapter 11
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: What can we learn from the performance results from this chapter's microbenchmarks?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从本章微基准测试的性能结果中学到什么？
- en: The fact that a binary search is a lot faster than a linear search, even if
    the number of elements to check is not that high. This means that computational
    complexity (aka the Big O) matters. Probably on your machine, even the longest
    search on the biggest dataset for a binary search was still faster than the shortest
    one for a linear search!
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分搜索比线性搜索快得多，即使要检查的元素数量并不那么多。这意味着计算复杂度（也称为大O）很重要。可能在您的机器上，即使对于二分搜索的最大数据集上的最长搜索也比线性搜索的最短搜索还要快！
- en: Depending on your cache sizes, you may have also noticed how increasing the
    required memory caused slowdowns when the data could no longer fit in specific
    cache levels.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据缓存大小，您可能还注意到当数据无法适应特定缓存级别时，增加所需内存会导致减速。
- en: Is how we traverse a multi-dimensional array important for performance? Why/why
    not?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何遍历多维数组对性能重要吗？为什么/为什么不？
- en: It's crucial, as we may access the data linearly in memory, which the CPU prefetcher
    would like and reward us with better performance, or jump through the memory,
    hindering thereby our performance.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是至关重要的，因为我们可能会在内存中线性访问数据，CPU预取器会喜欢并奖励我们更好的性能，或者跳过内存，从而阻碍我们的性能。
- en: In our coroutines example, why can't we create our thread pool inside the `do_routine_work`
    function?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的协程示例中，为什么我们不能在`do_routine_work`函数内创建我们的线程池？
- en: Because of lifetime issues.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为寿命问题。
- en: How can we rework our coroutine example so that it uses a generator instead
    of just tasks?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何重新设计我们的协程示例，以便它使用生成器而不仅仅是任务？
- en: The body of the generator would need to `co_yield`. Also, the threads from our
    pool would need to synchronize, probably using an atomic.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器的主体需要`co_yield`。此外，我们池中的线程需要同步，可能需要使用原子操作。
- en: Chapter 12
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: What are the properties of a service in service-oriented architecture?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向服务的架构中服务的属性是什么？
- en: It is a representation of business activity with a defined outcome.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是业务活动的代表，具有明确定义的结果。
- en: It is self-contained.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是自包含的。
- en: It is opaque to its users.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对用户是不透明的。
- en: It may be composed of other services
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能由其他服务组成
- en: What are some of the benefits of web services?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web服务的一些好处是什么？
- en: They are easy to debug using common tools, they work well with firewalls, and
    they may take advantage of existing infrastructure, such as load balancing, caching,
    and CDNs.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们易于使用常见工具进行调试，与防火墙配合良好，并且可以利用现有基础设施，如负载平衡、缓存和CDN。
- en: When are microservices not a good choice?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务不是一个好选择的时候是什么时候？
- en: When the cost of RPC and redundancy outweighs the benefits.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当RPC和冗余成本超过收益时。
- en: What are some of the use cases of message queues?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息队列的一些用例是什么？
- en: IPC, transactional services, IoT.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPC，事务服务，物联网。
- en: What are some of the benefits of choosing JSON over XML?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择JSON而不是XML的一些好处是什么？
- en: JSON requires lower overhead, is gaining in popularity over XML, and should
    be easier to read by a human.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON需要更低的开销，正在取代XML的流行，并且应该更容易被人类阅读。
- en: How does REST build on web standards?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST如何建立在Web标准之上？
- en: It uses HTTP verbs and URLs as building blocks.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用HTTP动词和URL作为构建块。
- en: How do cloud platforms differ from traditional hosting?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云平台与传统托管有何不同？
- en: Cloud platforms offer easy-to-use APIs, meaning the resources can be programmed.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云平台提供易于使用的API，这意味着可以编程资源。
- en: Chapter 13
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: How do microservices help you to use the system's resources better?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务如何帮助您更好地利用系统资源？
- en: It is easier to scale just the resources that are lacking instead of entire
    systems.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅扩展缺乏的资源比整个系统更容易。
- en: How can microservices and monoliths coexist (in an evolving system)?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务和单体应用程序如何共存（在不断发展的系统中）？
- en: New features may be developed as microservices, while some features may be split
    and outsourced from the monolith.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新功能可以开发为微服务，而某些功能可以从单体中拆分和外包。
- en: Which types of teams benefit the most from microservices?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的团队最能从微服务中受益？
- en: Cross-functional autonomous teams following DevOps principles.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循DevOps原则的跨功能自主团队。
- en: Why is it necessary to have a mature DevOps approach when introducing microservices?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在引入微服务时为什么需要成熟的DevOps方法？
- en: Testing and deploying lots of microservices is almost impossible to be effected
    manually by separate teams.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过单独的团队手动测试和部署大量微服务几乎是不可能的。
- en: What is a unified logging layer?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 统一的日志层是什么？
- en: It is a configurable facility for collecting, processing, and storing logs.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个可配置的收集、处理和存储日志的设施。
- en: How do logging and tracing differ?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志和跟踪有何不同？
- en: Logging is usually human-readable and focused on operations, whereas tracing
    is usually machine-readable and focused on debugging.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志通常是人类可读的，侧重于操作，而跟踪通常是机器可读的，侧重于调试。
- en: Why might REST not be the best choice for connecting microservices?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么REST可能不是连接微服务的最佳选择？
- en: It may provide bigger overhead compared to gRPC, for example.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与gRPC相比，它可能提供更大的开销。
- en: What are the deployment strategies for microservices? What are the benefits
    of each of them?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务的部署策略是什么？每种策略的好处是什么？
- en: Single service per host – easier to tweak the machines to the workload.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个主机一个服务-更容易调整机器以适应工作负载。
- en: Multiple services per host – better utilization of resources.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个主机多个服务-更好地利用资源。
- en: Chapter 14
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: How do application containers differ from operating system containers?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序容器与操作系统容器有何不同？
- en: Application containers are designed to host a single process, while operating
    system containers usually run all the processes typically available in a Unix
    system.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序容器旨在托管单个进程，而操作系统容器通常运行Unix系统中通常可用的所有进程。
- en: What are some early examples of sandboxing environments in Unix systems?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unix系统中沙盒环境的一些早期示例是什么？
- en: chroot, BSD Jails, Solaris Zones.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: chroot，BSD Jails，Solaris Zones。
- en: Why are containers a good fit for microservices?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么容器非常适合微服务？
- en: They offer a unified interface to run applications regardless of the underlying
    technology.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了一个统一的接口，可以运行应用程序，而不受基础技术的影响。
- en: What are the main differences between containers and virtual machines?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器和虚拟机之间的主要区别是什么？
- en: Containers are more lightweight as they don't require a hypervisor, a copy of
    an operating system kernel, or auxiliary processes, such as an init system or
    syslog.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器更轻量级，因为它们不需要虚拟化程序、操作系统内核的副本，或者辅助进程，比如init系统或syslog。
- en: When are application containers a bad choice?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序容器何时不是一个好选择？
- en: When you want to put a multi-process application in a single container.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您想将多进程应用程序放入单个容器中时。
- en: Name some tools for building multi-platform container images.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建多平台容器映像的一些工具是什么？
- en: manifest-tool, docker buildx.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: manifest-tool，docker buildx。
- en: Besides Docker, what are some other container runtimes?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了Docker，还有哪些其他容器运行时？
- en: Podman, containerd, CRI-O.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman，containerd，CRI-O。
- en: What are some popular orchestrators?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些流行的编排器是什么？
- en: Kubernetes, Docker Swarm, Nomad.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes，Docker Swarm，Nomad。
- en: Chapter 15
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: What's the difference between running your applications in the cloud and making
    them cloud-native?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在云中运行应用程序和使它们成为云原生应用程序有什么区别？
- en: Cloud-native design encompasses modern technologies such as containers and serverless
    that break the dependency on virtual machines.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生设计包括现代技术，如容器和无服务器，打破了对虚拟机的依赖。
- en: Can you run cloud-native applications on-premises?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在本地运行云原生应用程序吗？
- en: Yes, it's possible with solutions such as OpenStack, for example.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，例如可以使用OpenStack等解决方案。
- en: What's the minimum **highly available** (**HA**) cluster size for Kubernetes?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes的最小**高可用**（**HA**）集群大小是多少？
- en: The minimum HA cluster requires three nodes in the control plane and three worker
    nodes.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小的HA集群需要控制平面中的三个节点和三个工作节点。
- en: Which Kubernetes object represents a microservice that allows network connections?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Kubernetes对象代表允许网络连接的微服务？
- en: Service.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务。
- en: Why is logging insufficient in distributed systems?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在分布式系统中日志不足？
- en: Gathering logs and looking for correlations between them in distributed systems
    is problematic. Distributed tracing is better suited for certain use cases.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分布式系统中收集日志并查找它们之间的关联是有问题的。分布式跟踪更适合某些用例。
- en: How does a service mesh help with building secure systems?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务网格如何帮助构建安全系统？
- en: A service mesh abstracts connectivity between different systems, which allows
    encryption and auditing to be applied.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格抽象了不同系统之间的连接，从而可以应用加密和审计。
- en: How does GitOps increase productivity?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitOps如何提高生产力？
- en: It uses a familiar tool, Git, to handle the CI/CD without the need to write
    dedicated pipelines.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用一个熟悉的工具Git来处理CI/CD，而无需编写专门的流水线。
- en: What's the standard CNCF project for monitoring?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控的标准CNCF项目是什么？
- en: Prometheus.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus。
