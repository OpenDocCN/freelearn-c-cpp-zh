- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Numeric and Range -Based Operations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值和范围基础运算
- en: In this chapter, you will uncover the potential of the powerful numeric and
    sorting operations of the C++ **Standard Template Library** (**STL**). These functions
    breathe life into sequences, making tasks such as accumulation, transformation,
    and querying using sorted ranges a breeze. Readers will gain insights into elementary
    and advanced numeric operations and discover the utility of working with sorted
    collections. When paired with best practices, this chapter ensures developers
    have a robust toolset to optimize, parallelize, and handle numeric data with finesse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将发现 C++ **标准模板库**（**STL**）强大的数值和排序操作潜力。这些函数为序列注入生命力，使得使用排序范围进行累积、转换和查询变得轻而易举。读者将深入了解基本和高级数值运算，并发现与排序集合一起工作的实用性。结合最佳实践，本章确保开发者拥有一个强大的工具集，以优化、并行化并优雅地处理数值数据。
- en: 'This chapter will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Basic numeric operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数值运算
- en: Advanced numeric operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级数值运算
- en: Operations on sorted ranges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序范围上的操作
- en: Best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Basic numeric operations
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数值运算
- en: Unearthing the power of the C++ STL’s numeric functions is a refreshing experience.
    In this section, we’ll dive deep into the foundational numeric operations. By
    mastering these, you’ll unlock the capability to generate sequences, compute comprehensive
    summaries, and efficiently execute sophisticated operations on contiguous elements.
    So, buckle up, and let’s get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 发现 C++ STL 数值函数的力量是一种令人耳目一新的体验。在本节中，我们将深入探讨基础数值运算。通过掌握这些，你将解锁生成序列、计算综合摘要以及高效执行连续元素上的复杂操作的能力。所以，系好安全带，让我们开始吧！
- en: Generating sequences with std::iota
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::iota 生成序列
- en: 'The first treasure we’re going to unearth is `std::iota`. It’s a simple yet
    powerful tool in the numeric operations chest. `std::iota` fills a range with
    a sequence of consecutive values. Starting from an initial value, it assigns increasing
    values to subsequent elements in the range. Here, you can see that `std::itoa`
    fills a vector with five consecutive integers, starting with 1:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要挖掘的第一个宝藏是 `std::iota`。它是数值运算工具箱中的一个简单而强大的工具。`std::iota` 用连续值填充一个范围。从一个初始值开始，它将递增的值分配给范围中后续的元素。在这里，你可以看到
    `std::itoa` 用五个连续整数填充了一个向量，从 1 开始：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This function is a boon when you want a container to hold many contiguous sequences
    of numbers without manually inputting each one. Consider a scenario where you
    want a `std::vector` to hold timesteps for a constructive simulation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要一个容器来存储许多连续的数字序列而不需要手动输入每一个时，这个函数将是一个福音。考虑这样一个场景，你想要一个 `std::vector` 来存储构造性模拟的时间步长：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the example output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `std::iota` is used to generate a sequence of time steps, which
    can be used to model the behavior of a system over time. While this is a simplified
    example, in real-world applications, you can use `std::iota` as a foundation for
    more complex simulations and modeling scenarios, such as physics simulations,
    financial modeling, or scientific research.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`std::iota` 用于生成时间步长的序列，这可以用来模拟系统随时间的行为。虽然这是一个简化的例子，但在实际应用中，你可以将 `std::iota`
    作为更复杂模拟和建模场景的基础，例如物理模拟、金融建模或科学研究。
- en: '`std::iota` helps create a time series or discrete event timeline, which can
    be a fundamental component in various computational simulations and modeling tasks.
    Its value becomes more apparent when integrated into larger, more complex systems
    where time sequencing or indexing is crucial.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::iota` 有助于创建时间序列或离散事件时间线，这可以是各种计算模拟和建模任务的基本组成部分。当它集成到更大的、更复杂的系统中，时间序列或索引至关重要时，其价值变得更加明显。'
- en: Summing elements with std::accumulate
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::accumulate 求和元素
- en: 'Say you have a sequence of numbers and wish to find their sum (or maybe a product).
    Enter `std::accumulate`. This algorithm is primarily used to compute the sum over
    a range of elements. Let’s look at the following simple example in action:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一系列数字，并希望找到它们的和（或者可能是一个乘积）。请使用 `std::accumulate`。此算法主要用于计算元素范围的总和。让我们看看以下简单示例的实际操作：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is primarily used to compute the sum of a range of elements, but its power
    doesn’t stop there. With its flexible design, `std::accumulate` can also be employed
    for other operations, such as finding products or concatenating strings. By providing
    a custom binary operation, its applications are broadened significantly. Here
    is a simple example of how `std::accumulate` can be used with strings:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它主要用于计算元素范围的和，但它的功能并不仅限于此。凭借其灵活的设计，`std::accumulate` 也可以用于其他操作，例如查找乘积或连接字符串。通过提供自定义二元操作，其应用范围显著扩大。以下是一个简单的示例，说明如何使用
    `std::accumulate`：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the example output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With some creativity, `std::accumulate` can become a versatile tool in your
    algorithmic toolbox.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些创意，`std::accumulate` 可以成为你算法工具箱中的多功能工具。
- en: Adjacent elements and their interactions with std::adjacent_difference
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相邻元素及其与 `std::adjacent_difference` 的交互
- en: Sometimes, we’re interested in individual elements and pairs of adjacent elements.
    The STL has got your back here with `std::adjacent_difference`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们感兴趣的是单个元素和相邻元素的对。STL 通过 `std::adjacent_difference` 为此提供了支持。
- en: '`std::adjacent_difference` calculates the difference between an element and
    its predecessor and stores it in another sequence. This operation is beneficial
    in tasks such as computing discrete derivatives.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::adjacent_difference` 计算一个元素与其前驱之间的差值，并将其存储在另一个序列中。这种操作在计算离散导数等任务中很有用。'
- en: 'The following code demonstrates the usage of `std::adjacent_difference`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了 `std::adjacent_difference` 的用法：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Not just for differences, you can pass custom binary operations to `std::adjacent_difference`
    to achieve varied results, such as ratios. Let’s look at the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅限于差异，你还可以将自定义二元操作传递给 `std::adjacent_difference` 以实现不同的结果，例如比率。让我们看看以下示例：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the example output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Inner products with std::inner_product
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `std::inner_product` 的内积
- en: 'This function is a marvel for those who’ve dabbled in linear algebra. `std::inner_product`
    calculates the dot product of two ranges. As you might recall, the dot product
    is the sum of the products of corresponding pairs from two sequences. Let’s look
    at how to compute the dot product of two vectors:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些涉足线性代数的人来说，这个函数是一个奇迹。`std::inner_product` 计算两个范围的点积。你可能还记得，点积是两个序列中对应对的乘积之和。让我们看看如何计算两个向量的点积：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`std::inner_product` isn’t just limited to integers or plain multiplication.
    Custom binary operations can be tailored to work on different types and operations.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::inner_product` 不仅限于整数或普通乘法。自定义二元操作可以针对不同类型和操作进行定制。'
- en: 'Here are some real-world examples to demonstrate that `std::inner_product`
    can work with custom binary operations tailored to different types and operations
    beyond just integers and plain multiplication:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些现实世界的例子，以证明 `std::inner_product` 可以与针对不同类型和操作（而不仅仅是整数和普通乘法）定制的自定义二元操作一起工作：
- en: '`std::inner_product` to calculate the weighted average of elements in two containers,
    where one container holds values, and the other container holds the corresponding
    weights. The custom binary operation would perform the element-wise multiplication
    of the values and weights and then sum them up to find the weighted average.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::inner_product` 用于计算两个容器中元素的加权平均值，其中一个容器包含值，另一个容器包含相应的权重。自定义二元操作将执行值和权重的逐元素乘法，然后将它们相加以找到加权平均值。'
- en: '`std::inner_product` with a custom binary operation to calculate the portfolio’s
    total value by multiplying the asset prices by their respective quantities and
    summing them up.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义二元操作计算投资组合的总价值，通过将资产价格乘以其相应的数量并求和。
- en: '`std::inner_product` can be used with a custom binary operation for this purpose.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::inner_product` 可以使用自定义二元操作来完成此目的。'
- en: '`std::inner_product` can be adapted with a custom binary operation to perform
    matrix multiplication efficiently.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::inner_product` 可以通过自定义二元操作进行适配，以高效地执行矩阵乘法。'
- en: '`std::inner_product` to perform complex number operations, such as calculating
    the inner product of two complex vectors or finding the sum of the squares of
    complex numbers. The custom binary operation would be tailored to complex number
    arithmetic.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::inner_product`执行复数运算，例如计算两个复数向量的内积或找到复数平方的和。自定义的二元操作将针对复数算术进行定制。
- en: '`std::inner_product` with a custom binary operation that concatenates strings.
    This allows you to join a collection of strings efficiently.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义的二元操作将字符串连接起来的`std::inner_product`。这允许你高效地连接字符串集合。
- en: '`std::inner_product` can be adapted with a custom binary operation to perform
    color blending based on the desired algorithm.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::inner_product`可以通过自定义的二元操作进行适配，以根据所需的算法执行颜色混合。'
- en: These examples illustrate that `std::inner_product` is a versatile algorithm
    that can be customized for various types and operations. This makes it useful
    in many real-world applications beyond simple integer multiplication.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例说明`std::inner_product`是一个多才多艺的算法，可以根据各种类型和操作进行定制。这使得它在许多现实世界的应用中非常有用，而不仅仅是简单的整数乘法。
- en: In this section, we have seen that the basic numeric operations provided by
    the C++ STL pave the way for the efficient computation, generation, and manipulation
    of sequences. They transform how developers approach problems, allowing for swift
    and effective solutions. As we’ve seen, these algorithms are versatile and, with
    a pinch of creativity, can be adapted to a myriad of tasks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了C++ STL提供的基本数值操作为高效计算、生成和操作序列铺平了道路。它们改变了开发者解决问题的方法，使得快速有效的解决方案成为可能。正如我们所见，这些算法是多才多艺的，只需一点创意，就可以适应无数任务。
- en: With these tools in your utility belt, you’re now equipped to generate sequences,
    compute quick summaries, and perform intricate operations on consecutive elements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工具包中有了这些工具，你现在可以生成序列，计算快速摘要，并对连续元素执行复杂操作。
- en: Advanced numeric operations
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数值操作
- en: In order to take our journey with the numeric operations of the C++ STL a step
    further, let’s look at the advanced numerical procedures that elevate data handling
    and make parallelism and concurrency allies in the pursuit of performance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步探索C++ STL的数值操作之旅，让我们来看看那些提升数据处理能力并使并行性和并发成为性能追求盟友的高级数值过程。
- en: Remember our discussion about generating sequences and computing summaries?
    Well, imagine supercharging these operations to process enormous volumes of data
    efficiently by harnessing the power of multiple processors. This is precisely
    where advanced numeric operations shine. Parallel algorithms, introduced in C++17,
    provide the means to achieve this, ensuring our computations are both swift and
    efficient, even in concurrent environments.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们关于生成序列和计算摘要的讨论吗？好吧，想象一下通过利用多个处理器的力量，将这些操作超级充电以高效处理大量数据。这正是高级数值操作大放异彩的地方。C++17中引入的并行算法提供了实现这一目标的方法，确保我们的计算既快速又高效，即使在并发环境中也是如此。
- en: When dealing with vast datasets, sequential processing often doesn’t cut it.
    Take the example of summing up a large vector of numbers. Doing it in a straight
    line gets the job done but might not be the quickest. However, the operation can
    be sped up significantly by splitting the data and working on chunks concurrently.
    This is the essence of parallel algorithms, and functions such as `std::reduce`
    exemplify this. Instead of sequentially accumulating values, `std::reduce` can
    accumulate subtotals in parallel and then combine them, offering a significant
    boost in performance for large datasets.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量数据集时，顺序处理通常不够。以计算大量数字向量的总和为例。直接进行操作可以完成任务，但可能不是最快的。然而，通过分割数据并在多个数据块上并行工作，可以显著加快操作速度。这正是并行算法的精髓，而像`std::reduce`这样的函数就是这一点的例证。`std::reduce`不是顺序累积值，而是在并行中累积子总计，然后合并它们，为大型数据集提供了显著的性能提升。
- en: 'To see this in action, let’s calculate the sum of all numbers in a large vector
    in parallel:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一过程在实际中的应用，让我们并行计算一个大型向量中所有数字的总和：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the example output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Diving into parallel operations requires a nuanced approach. While the promise
    of speed is tempting, one must be cautious. Parallelism introduces challenges
    such as ensuring thread safety and managing data races. Thankfully, the STL offers
    a remedy through execution policies. By specifying an execution policy, such as
    `std::execution::par`, when invoking an algorithm, we can direct it to run in
    parallel. Additionally, there’s `std::execution::par_unseq` for parallel and vectorized
    execution, ensuring even greater throughput.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 深入并行操作需要细致的方法。虽然速度的承诺很有吸引力，但必须谨慎。并行引入了挑战，如确保线程安全和处理数据竞争。幸运的是，STL通过执行策略提供了补救措施。通过指定执行策略，例如在调用算法时使用`std::execution::par`，我们可以指导它并行运行。此外，还有`std::execution::par_unseq`，用于并行和向量化执行，确保更高的吞吐量。
- en: Speaking of transformation, let’s look into `std::transform_reduce`. This is
    a fusion of `std::transform` and `std::reduce`. It applies a transformation function
    to each range element and reduces the results into a single value, which can be
    parallelized. For instance, if we had a vector of numbers and wanted to square
    each element and then sum up the squared values, `std::transform_reduce` would
    be our go-to, especially when dealing with a substantial amount of data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 说到转换，让我们来看看`std::transform_reduce`。这是`std::transform`和`std::reduce`的结合。它对每个范围元素应用转换函数，并将结果归约成一个单一值，这可以并行化。例如，如果我们有一个数字向量，并想对每个元素进行平方然后求和，`std::transform_reduce`将是我们的首选，尤其是在处理大量数据时。
- en: 'Let’s see how we can use `std::transform_reduce` to square each element of
    a vector and then sum up the squared values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`std::transform_reduce`对向量的每个元素进行平方，然后对平方值求和：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is the example output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Another feather in the cap of advanced operations is the `std::inclusive_scan`
    and `std::exclusive_scan` duo. These are powerful tools for generating prefix
    sums. `std::inclusive_scan` includes the ith input element in the ith sum, whereas
    `std::exclusive_scan` doesn’t. Like their fellow advanced numeric operations,
    they, too, can be supercharged with parallel execution for heightened performance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 高级操作的另一项亮点是`std::inclusive_scan`和`std::exclusive_scan`这对组合。这些是生成前缀和的强大工具。`std::inclusive_scan`将第i个输入元素包含在第i个和中，而`std::exclusive_scan`则不包含。像它们的其他高级数值操作一样，它们也可以通过并行执行来增强性能。
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A `i` in the input sequence, the corresponding element in the output sequence
    contains the sum of all elements from index `0` to `i` in the input sequence.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入序列中的`i`，输出序列中相应的元素包含从输入序列索引`0`到`i`的所有元素的总和。
- en: Parallel operations can be resource-intensive. It’s essential to ensure that
    the hardware can handle the parallelism and that the amount of data is large enough
    to justify the overhead of concurrent execution. Additionally, always be vigilant
    about potential pitfalls such as data races or deadlocks. The key is constantly
    weighing the pros and cons, analyzing the specific requirements, and choosing
    the most suitable approach.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 并行操作可能非常耗费资源。确保硬件能够处理并行性，并且数据量足够大，足以证明并发执行的开销是必要的。此外，始终警惕潜在的问题，如数据竞争或死锁。关键在于不断权衡利弊，分析具体要求，并选择最合适的方案。
- en: Operations on sorted ranges
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对排序范围的运算
- en: The allure of sorting isn’t just about placing elements for the sake of neatness.
    Instead, it is about the power it grants us in subsequent operations—streamlined
    navigation, efficient querying, and enhanced manipulation capabilities. For C++
    developers, understanding operations on sorted ranges is like acquiring a new
    set of superpowers. Armed with the C++ STL’s tools for these sorted sequences,
    the world of efficient algorithmic operations becomes an open field, ready for
    exploration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 排序的吸引力并不仅仅是为了整齐排列元素。相反，它赋予我们在后续操作中的强大能力——简化导航、高效查询和增强的操纵能力。对于C++开发者来说，理解对排序范围的运算就像是获得了一套新的超级能力。凭借C++
    STL为这些排序序列提供的工具，高效的算法操作世界变得一片开阔，等待探索。
- en: So, what’s the big deal about having sorted ranges? Consider the difference
    between looking for a book in a disordered pile versus finding it on a neatly
    organized shelf. When the data are sorted, algorithms can take shortcuts, such
    as dividing and conquering, leading to logarithmic rather than linear-time complexities.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，拥有排序范围有什么大不了的？考虑一下在杂乱无章的一堆书中找书和在整齐排列的书架上找书的区别。当数据排序后，算法可以采取捷径，例如分而治之，从而实现对数时间复杂度而不是线性时间复杂度。
- en: A primary technique leveraged for sorted ranges is `std::lower_bound` and `std::upper_bound`
    are your go-to functions for this purpose. The former finds the first position
    where a value should be inserted to maintain the order, while the latter identifies
    the last suitable spot. Together, they can determine the range of entries equivalent
    to a given value. If you’ve ever marveled at the rapidity with which some applications
    return search results, binary search techniques such as these are often to thank.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序范围中，一个主要的技巧是利用 `std::lower_bound` 和 `std::upper_bound`，这两个函数是您实现此目的的首选。前者用于找到应该插入值以保持顺序的第一个位置，而后者则标识最后一个合适的点。共同使用，它们可以确定与给定值等效的条目范围。如果您曾对某些应用程序返回搜索结果的快速性感到惊奇，那么这些二分搜索技术通常要归功于它们。
- en: Continuing on the topic of queries, `std::equal_range` steps in as a combination
    of the aforementioned functions, returning both the lower and upper bounds of
    a value in a sorted range; if you just need a straightforward check, `std::binary_search`
    tells you if an element exists in the sorted range. These tools simplify querying,
    making it both swift and precise.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论查询的话题，`std::equal_range` 作为上述函数的组合出现，返回排序范围内一个值的上下界；如果您只需要一个简单的检查，`std::binary_search`
    会告诉您元素是否存在于排序范围内。这些工具简化了查询过程，使其既快速又精确。
- en: However, operations on sorted ranges aren’t confined to searches. Set operations,
    reminiscent of our elementary math lessons, come alive with sorted data. If you’ve
    two sorted sequences and wish to determine their common elements, `std::set_intersection`
    is the tool for the job. For those elements that belong to one sequence but not
    to the other, turn to `std::set_difference`. If you’re in the mood to combine
    the elements of two sequences while maintaining the sort order, `std::set_union`
    stands ready. Last but not least, for finding elements unique to each sequence,
    `std::set_symmetric_difference` serves the purpose.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对排序范围的运算并不局限于搜索。集合运算，类似于我们的基础数学课程，在排序数据中变得生动起来。如果您有两个排序序列，并希望确定它们的公共元素，`std::set_intersection`
    就是完成这项工作的工具。对于属于一个序列但不属于另一个序列的元素，转向 `std::set_difference`。如果您想要合并两个序列的元素同时保持排序顺序，`std::set_union`
    就准备好了。最后但同样重要的是，为了找到每个序列中独特的元素，`std::set_symmetric_difference` 扮演着这个角色。
- en: Imagine the power that these operations grant. Comparing two large datasets
    to find commonalities or differences is a frequent requirement in many applications,
    from databases to data analytics. By working on sorted ranges, these operations
    become feasible and efficient.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这些运算赋予我们的力量。比较两个大型数据集以找到共同点或差异是许多应用程序的常见需求，从数据库到数据分析。通过在排序范围内工作，这些运算变得可行且高效。
- en: Sorted operations presume, quite reasonably, that the data is sorted. If this
    invariant isn’t maintained, the results can be unpredictable. So, ensuring the
    sort order is paramount before diving into these operations. Thankfully, with
    functions such as `std::is_sorted`, one can verify the sorted nature of a range
    before venturing further.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 排序操作合理地假设数据是有序的。如果这个不变量没有得到维护，结果可能是不可预测的。因此，在深入这些操作之前，确保排序顺序至关重要。幸运的是，通过像 `std::is_sorted`
    这样的函数，可以在进一步操作之前验证范围的排序性质。
- en: 'Let’s pull all of these concepts together into a quick example of how they
    can be used:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有这些概念结合起来，快速看一下它们是如何被使用的：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the example output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is evident from these examples that operations on sorted ranges unlock a
    realm of possibilities. They exemplify the blend of mathematical theory and practical
    coding, creating a robust framework for developers to navigate, query, and manipulate
    data with unparalleled efficiency. As we move forward, we’ll explore the best
    practices associated with numeric and range-based operations, ensuring that as
    we harness their power, we do so with precision, efficiency, and finesse. The
    journey of discovery and mastery continues!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中可以看出，对排序范围的运算解锁了一个广阔的可能性领域。它们展示了数学理论与实际编码的结合，为开发者提供了一个强大的框架，以无与伦比的效率导航、查询和操作数据。随着我们继续前进，我们将探讨与数值和基于范围的运算相关的最佳实践，确保我们在利用它们的力量时，能够做到精确、高效和优雅。探索和掌握的旅程仍在继续！
- en: Best practices
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'The following best practices are associated with numeric and range-based operations:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些与数值和基于范围的运算相关的最佳实践：
- en: '`std::stable_sort` may prove more efficient than other sorting methods for
    a nearly sorted dataset. Thus, understanding your dataset’s characteristics is
    pivotal when deciding appropriate operations.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于几乎已排序的数据集，`std::stable_sort` 可能比其他排序方法更有效。因此，在决定适当的操作时，了解数据集的特征至关重要。
- en: '`std::is_sorted` before proceeding with sorted operations is recommended.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行排序操作之前推荐使用 `std::is_sorted`。
- en: '**Using parallel algorithms judiciously**: With the growing emphasis on concurrency,
    parallel algorithms present an attractive option to boost performance. The C++
    STL provides parallel versions of many standard algorithms. While these algorithms
    capitalize on multiple CPU cores to deliver faster results, they can also introduce
    challenges, especially regarding thread safety. A primary concern in concurrent
    programming is a shared mutable state. Issues arise when multiple threads attempt
    to simultaneously modify the same data. To use parallel algorithms safely, it’s
    critical that threads either work on distinct data sections or employ synchronization
    tools, such as mutexes, to manage simultaneous data modifications.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明智地使用并行算法**：随着对并发的日益重视，并行算法成为提高性能的一个有吸引力的选择。C++ STL 为许多标准算法提供了并行版本。虽然这些算法利用多个
    CPU 核心来提供更快的执行结果，但它们也可能引入挑战，尤其是在线程安全方面。并发编程中的一个主要问题是共享可变状态。当多个线程试图同时修改相同的数据时，就会产生问题。为了安全地使用并行算法，线程要么在独立的数据部分上工作，要么使用如互斥锁之类的同步工具来管理同时的数据修改。'
- en: Furthermore, parallelism isn’t always the answer. The overhead from managing
    multiple threads can sometimes negate the benefits of parallel execution, especially
    for small datasets or straightforward tasks. To determine the effectiveness of
    parallelism in a given scenario, it’s beneficial to profile your code in both
    sequential and parallel configurations. This assessment aids in choosing the most
    efficient method.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，并行化并不总是答案。管理多个线程的开销有时可能会抵消并行执行的好处，尤其是在处理小数据集或简单任务时。为了确定并行化在特定场景中的有效性，最好在顺序和并行配置下对代码进行性能分析。这种评估有助于选择最有效的方法。
- en: In this section, we’ve explored how to choose the right algorithms in the C++
    STL based on data properties, emphasizing the importance of dataset characteristics
    such as size and distribution. Selecting an appropriate algorithm, such as `std::stable_sort`,
    for nearly sorted data is crucial for optimal performance. We also highlighted
    the necessity of maintaining data order for sorted operations, using tools such
    as `std::is_sorted` to ensure data integrity. Parallel algorithms were discussed,
    focusing on their benefits and complexities, such as thread safety. The key takeaway
    is that parallelism, while powerful, requires careful consideration, especially
    regarding dataset size and task complexity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何根据数据属性在 C++ STL 中选择合适的算法，强调了数据集特征（如大小和分布）的重要性。对于几乎已排序的数据，选择如 `std::stable_sort`
    这样的适当算法对于最佳性能至关重要。我们还强调了在排序操作中维护数据顺序的必要性，使用如 `std::is_sorted` 这样的工具来确保数据完整性。讨论了并行算法，重点关注它们的优点和复杂性，如线程安全。关键要点是，虽然并行化功能强大，但需要仔细考虑，尤其是在数据集大小和任务复杂性方面。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have immersed ourselves in the versatile world of algorithms
    provided by the C++ STL that handle numeric sequences and operate on sorted ranges.
    We started with basic numeric operations, such as generating sequences with `std::iota`,
    summing elements with accumulate, and exploring the interactions of adjacent elements
    with `std::adjacent_difference`. The chapter explored more complex tasks, such
    as computing inner products with `std::inner_product`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了 C++ STL 提供的用于处理数值序列并在排序范围内操作的算法的多样世界。我们从基本的数值操作开始，例如使用 `std::iota`
    生成序列，使用 `accumulate` 累加元素，以及使用 `std::adjacent_difference` 探索相邻元素之间的交互。本章探讨了更复杂的任务，例如使用
    `std::inner_product` 计算内积。
- en: These operations are essential in data handling and analysis within STL containers,
    facilitating tasks from simple accumulations to complex transformations. The information
    presented is crucial for developers, as it enhances efficiency and efficacy when
    performing numerical computations and prepares them for high-performance scenarios,
    especially when dealing with large datasets.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作在 STL 容器中的数据处理和分析中是必不可少的，它们简化了从简单累加到复杂转换的各种任务。对于开发者来说，这些信息至关重要，因为它在执行数值计算时提高了效率和效果，并为他们准备应对高性能场景，尤其是在处理大数据集时。
- en: The chapter also covered advanced numeric operations, which are particularly
    beneficial in parallel computing environments. We learned how to employ parallel
    algorithms for data transformation and summarization, ensuring high performance
    in concurrent environments. Operations on sorted ranges were explored, illustrating
    the efficiency of binary search techniques and the functionality of set operations,
    which are significantly optimized by the data’s sorted nature.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涵盖了高级数值运算，这在并行计算环境中尤其有益。我们学习了如何使用并行算法进行数据转换和汇总，确保在并发环境中高性能。对排序范围的操作得到了探讨，展示了二分搜索技术的效率和集合运算的功能，这些操作由于数据的排序性质而得到了显著优化。
- en: In the next chapter, we will venture into ranges, representing a more contemporary
    approach to sequences in C++. We will explore why there has been a shift toward
    range-based operations, understand the essence and power of these modern STL components,
    and explore their composability for sorting and searching algorithms. This upcoming
    chapter will empower readers with the knowledge to embrace the full potential
    of the modern STL, making informed decisions on when and how to apply these new
    tools in their C++ programming endeavors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索范围的概念，这代表了 C++ 中序列的更现代的方法。我们将探讨为什么转向基于范围的运算变得流行，理解这些现代 STL 组件的本质和力量，并探索它们在排序和搜索算法中的可组合性。这一即将到来的章节将赋予读者拥抱现代
    STL 全部潜能的知识，使他们能够在 C++ 编程实践中做出明智的决策，了解何时以及如何应用这些新工具。
