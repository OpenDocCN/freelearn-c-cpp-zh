- en: 13\. Enemy Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 敌人人工智能
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter begins with a brief recap of how the enemy AI will behave for the
    `SuperSideScroller` game. From there, you will learn about Controllers in the
    context of Unreal Engine 4 and learn how to create an AI Controller. Then, you
    will learn more about AI navigation in Unreal Engine 4 by adding a Nav Mesh to
    the main level of the game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以简要回顾《超级横向卷轴》游戏中敌人人工智能的行为方式开始。然后，你将学习虚幻引擎4中的控制器，并学习如何创建一个AI控制器。接着，你将学习如何通过在游戏的主要关卡中添加导航网格来更多地了解虚幻引擎4中的AI导航。
- en: By the end of this chapter, you will be able to create a navigable space where
    the enemy can move. You will also be able to create an enemy AI pawn and navigate
    it across locations using Blackboard and behavior trees. Lastly, you will know
    how to create and implement a player projectile class and add visual elements
    to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，你将能够创建一个敌人可以移动的可导航空间。你还将能够创建一个敌人AI角色，并使用黑板和行为树在不同位置之间导航。最后，你将学会如何创建和实现一个玩家投射物类，并为其添加视觉元素。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, you added layered animations for the player character
    using Animation Blending with a combination of Anim Slots, Animation Blueprints,
    and blending functions such as Layered Blend per Bone.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你使用了动画混合、动画插槽、动画蓝图和混合函数（如每骨层混合）为玩家角色添加了分层动画。
- en: In this chapter, you will learn how to use a Nav Mesh to create a navigable
    space inside of the game world that the enemy can move in. Defining the navigable
    space of a level is crucial for allowing **artificial intelligence** (**AI**)
    to access and move to specific areas of your level.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用导航网格在游戏世界内创建一个可导航的空间，使敌人可以在其中移动。定义关卡的可导航空间对于允许人工智能访问和移动到关卡的特定区域至关重要。
- en: Next, you will create an enemy AI pawn that can navigate between patrol point
    locations inside the game world using a combination of the AI tools present inside
    Unreal Engine 4, including *Blackboards* and *behavior trees*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个敌人AI角色，使用虚幻引擎4中的*黑板*和*行为树*等AI工具在游戏世界内的巡逻点位置之间导航。
- en: You will also learn how to use a Nav Mesh to create a navigable space inside
    the game world where the enemy can move. Defining the navigable space of a level
    is crucial for allowing the AI to access and move to specific areas of your level.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何使用导航网格在游戏世界内创建一个可导航的空间，使敌人可以在其中移动。定义关卡的可导航空间对于允许AI访问和移动到关卡的特定区域至关重要。
- en: Lastly, you'll learn how to create a player projectile class in C++ and how
    to implement the `OnHit()` collision event function to recognize and log when
    the projectile hits an object in the game world. In addition to creating the class,
    you will then create a Blueprint of this player projectile class and add visual
    elements to the player projectile, such as a Static Mesh.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习如何在C++中创建一个玩家投射物类，以及如何实现`OnHit()`碰撞事件函数来识别并记录投射物击中游戏世界中的物体。除了创建类之外，你还将创建这个玩家投射物类的蓝图，并为玩家投射物添加视觉元素，如静态网格。
- en: The `SuperSideScroller` game is finally coming together and you will be in a
    good position by the end of this chapter to move on to *Chapter 14*, *Spawning
    the Player Projectile*, where you will handle adding elements of polish to the
    game, such as SFX and VFX.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 《超级横向卷轴》游戏终于要完成了，通过本章的学习，你将在很好的位置上，可以继续学习*第14章*《生成玩家投射物》，在那里你将处理游戏的一些细节，如音效和视觉效果。
- en: The primary focus of this chapter is to take the C++ enemy class you created
    in *Chapter 12*, *Animation Blending and Montages*, and bring this enemy to life
    using AI. Unreal Engine 4 uses many different tools to achieve AI such as AI Controllers,
    Blackboards, and behavior trees, all of which you will learn about and use in
    this chapter. Before you jump into these systems, let's take a moment to learn
    about how AI is used in games in recent history. AI has certainly evolved since
    the days of *Super Mario Bros*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要重点是使用人工智能使你在*第12章*《动画混合和蒙太奇》中创建的C++敌人类活灵活现。虚幻引擎4使用许多不同的工具来实现人工智能，如AI控制器、黑板和行为树，你将在本章中学习并使用这些工具。在你深入了解这些系统之前，让我们花一点时间了解近年来游戏中人工智能的使用方式。自从《超级马里奥兄弟》以来，人工智能显然已经发展了许多。
- en: Enemy AI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人人工智能
- en: What is AI? This term can mean many things, depending on the field and context
    that it is used in, so let's define it in a way that makes sense regarding the
    subject of video games.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是人工智能？这个术语可以有很多不同的含义，取决于它所用于的领域和背景，因此让我们以一种对视频游戏主题有意义的方式来定义它。
- en: '**AI** is an entity that is aware of its environment and performs choices that
    will help optimally achieve its intended purpose. AI uses what are called **finite
    state machines** to switch between more than one state based on the input it receives
    from the user or its environment. For example, a video game AI can switch between
    an offensive state to a defensive state based on its current health.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**AI**是一个意识到自己环境并做出选择以最优化地实现其预期目的的实体。AI使用所谓的**有限状态机**根据其从用户或环境接收到的输入切换多个状态之间。例如，视频游戏中的AI可以根据其当前的健康状态在攻击状态和防御状态之间切换。'
- en: 'In games such as *Hello Neighbor*, which was developed in Unreal Engine 4,
    and *Alien: Isolation*, the goal of the AI is to find the player as efficiently
    as possible, but also to follow some predetermined patterns defined by the developers
    to ensure that the player can outsmart it. *Hello Neighbor* adds a very creative
    element to its AI by having it learn from the players'' past actions and tries
    to outsmart the player based on the knowledge it learns.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在《你好邻居》和《异形：孤立》等游戏中，AI的目标是尽可能高效地找到玩家，同时也遵循开发者定义的一些预定模式，以确保玩家可以智胜。《你好邻居》通过让AI从玩家过去的行为中学习并试图根据所学知识智胜玩家，为其AI添加了一个非常有创意的元素。
- en: 'You can find an informative breakdown of how the AI works in this video by
    the publishers of the game, *TinyBuild Games*, here: [https://www.youtube.com/watch?v=Hu7Z52RaBGk](https://www.youtube.com/watch?v=Hu7Z52RaBGk).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在游戏发布商*TinyBuild Games*的视频中找到有关AI如何工作的信息：[https://www.youtube.com/watch?v=Hu7Z52RaBGk](https://www.youtube.com/watch?v=Hu7Z52RaBGk)。
- en: Interesting and fun AI is crucial to any game, and depending on the game you
    are making, this can mean a very complex or very simplistic AI. The AI that you
    will be creating for the `SuperSideScroller` game will not be as sophisticated
    as those mentioned previously, but it will fill the needs of the game we are seeking
    to create.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣和有趣的AI对于任何游戏都至关重要，取决于您正在制作的游戏，这可能意味着非常复杂或非常简单的AI。您将为“SuperSideScroller”游戏创建的AI不会像之前提到的那些那样复杂，但它将满足我们希望创建的游戏的需求。
- en: 'Let''s break down how the enemy will behave:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析一下敌人的行为方式：
- en: The enemy will be a very simple enemy that has a basic back and forth movement
    pattern and will not support any attacks; only by colliding with the player character
    will they be able to inflict any damage.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人将是一个非常简单的敌人，具有基本的来回移动模式，不会支持任何攻击；只有与玩家角色碰撞，它们才能造成伤害。
- en: However, we need to set the locations to move between for the enemy AI.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，我们需要设置敌人AI要移动的位置。
- en: Next, we decide whether the AI should change locations, should constantly move
    between locations, or should there be a pause in between selecting a new location
    to move to?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们决定AI是否应该改变位置，是否应该在不同位置之间不断移动，或者在选择新位置移动之间是否应该有暂停？
- en: Fortunately for us, Unreal Engine 4 provides us with a wide array of tools that
    we can use to develop such complex AI. In the case of our project, however, we
    will use these tools to create a simplistic enemy type. Let's start by discussing
    what an AI Controller is in Unreal Engine 4.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于我们来说，虚幻引擎4为我们提供了一系列工具，我们可以使用这些工具来开发复杂的AI。然而，在我们的项目中，我们将使用这些工具来创建一个简单的敌人类型。让我们首先讨论一下虚幻引擎4中的AI控制器是什么。
- en: AI Controller
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI控制器
- en: Let's discuss what the main difference is between a **Player Controller** and
    an **AI Controller**. Both of these actors derive from the base **Controller class**,
    and a Controller is used to take control of a **Pawn** or **Character** in order
    to control the actions of said pawn or character.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论**玩家控制器**和**AI控制器**之间的主要区别是什么。这两个角色都是从基本的**Controller类**派生出来的，控制器用于控制一个**Pawn**或**Character**的行动。
- en: While a Player Controller relies on the input of an actual player, an AI Controller
    applies AI to the characters they possess and responds to the environment based
    on the rules set forth by the AI. By doing so, the AI can make intelligent decisions
    in response to the player and other external factors, without the actual player
    explicitly telling it to do so. Multiple instances of the same AI pawn can share
    the same AI Controller, and the same AI Controller can be used across different
    AI pawn classes. AI, like all actors inside Unreal Engine 4, are spawned through
    the `UWorld` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家控制器依赖于实际玩家的输入，而AI控制器则将AI应用于他们所拥有的角色，并根据AI设置的规则对环境做出响应。通过这样做，AI可以根据玩家和其他外部因素做出智能决策，而无需实际玩家明确告诉它这样做。多个相同的AI
    pawn实例可以共享相同的AI控制器，并且相同的AI控制器可以用于不同的AI pawn类。像虚幻引擎4中的所有角色一样，AI是通过`UWorld`类生成的。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will be learning more about the `UWorld` class in *Chapter 14*, *Spawning
    the Player Projectile*, but as a reference, please read more here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第14章*“生成玩家投射物”中了解更多关于`UWorld`类的信息，但作为参考，请在这里阅读更多：[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.html)。
- en: The most important aspect of both the Player Controller and the AI Controller
    is the pawns they will control. Let's learn more about how AI Controllers handle
    this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家控制器和AI控制器的最重要的方面是它们将控制的pawns。让我们更多地了解AI控制器如何处理这一点。
- en: Auto Possess AI
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动拥有AI
- en: 'Like all Controllers, the AI Controller must possess a *pawn*. In C++, you
    can use the following function to possess a pawn:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有控制器一样，AI控制器必须拥有一个*pawn*。在C++中，您可以使用以下函数来拥有一个pawn：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also use the following function to unpossess a pawn:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下功能取消拥有一个pawn：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There's also the `void AController::OnPossess(APawn* InPawn)` and `void AController::OnUnPossess()`
    functions, which are called whenever the `Possess()` and `UnPossess()` functions
    are called, respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`void AController::OnPossess(APawn* InPawn)`和`void AController::OnUnPossess()`函数，分别在调用`Possess()`和`UnPossess()`函数时调用。
- en: 'When it comes to AI, especially in the context of Unreal Engine 4, there are
    two methods in which AI Pawns or Characters can be possessed by an AI Controller.
    Let''s take a look at these options:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在AI方面，特别是在虚幻引擎4的背景下，AI Pawns或Characters可以被AI Controller占有的方法有两种。让我们看看这些选项：
- en: '`Placed in World`: This first method is how you will be handling AI in this
    project; you will manually place these enemy actors into your game world, and
    the AI will take care of the rest once the game begins.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “放置在世界中”：这是您将在此项目中处理AI的第一种方法；一旦游戏开始，您将手动将这些敌人角色放置到游戏世界中，AI将在游戏开始后处理其余部分。
- en: '`Spawned`: This second method is only a little more complicated because it
    requires an explicit function call, either in C++ or Blueprint, to `Spawn` an
    instance of a specified class. The `Spawn Actor` method requires a handful of
    parameters, including the `World` object and `Transform` parameters such as `Location`
    and `Rotation`, to ensure that the instance that is spawned is spawned correctly.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “生成”：这是第二种方法，稍微复杂一些，因为它需要一个显式的函数调用，无论是在C++还是Blueprint中，都需要“生成”指定类的实例。`Spawn
    Actor`方法需要一些参数，包括`World`对象和`Transform`参数，如`Location`和`Rotation`，以确保正确生成实例。
- en: '`Placed in World or Spawned`: If you are unsure of which method you want to
    use, a safe option would be `Placed in World or Spawned`; that way, both methods
    are supported.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`放置在世界中或生成`：如果您不确定要使用哪种方法，一个安全的选项是`放置在世界中或生成`；这样两种方法都受支持。'
- en: For the purposes of the `SuperSideScroller` game, you will be using the `Placed
    In World` option because the AI you will create will be manually placed in the
    game level.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了`SuperSideScroller`游戏，您将使用`Placed In World`选项，因为您将手动放置游戏级别中的AI。
- en: 'Exercise 13.01: Implementing AI Controllers'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01：实现AI控制器
- en: Before the enemy pawn can do anything, it needs to be possessed by an AI Controller.
    This also needs to happen before any logic can be performed by the AI. This exercise
    will be performed within the Unreal Engine 4 editor. By the end of this exercise,
    you will have created an AI Controller and applied it to the enemy that you created
    in the previous chapter. Let's begin by creating the AI Controller actor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在敌人pawn可以执行任何操作之前，它需要被AI控制器占有。这也需要在AI执行任何逻辑之前发生。这个练习将在虚幻引擎4编辑器中进行。完成这个练习后，您将创建一个AI控制器并将其应用于您在上一章中创建的敌人。让我们开始创建AI控制器角色。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: Head to the `Content Browser` interface and navigate to the `Content/Enemy`
    directory.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`内容浏览器`界面，导航到`内容/Enemy`目录。
- en: '*Right-click* on the `Enemy` folder and select the `New Folder` option. Name
    this new folder `AI`. In the new `AI` folder directory, *right-click* and select
    the `Blueprint Class` option.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*`Enemy`文件夹，选择`新建文件夹`选项。将这个新文件夹命名为`AI`。在新的`AI`文件夹目录中，*右键单击*并选择`蓝图类`选项。'
- en: From the `Pick Parent Class` dialogue box, expand `All Classes` and manually
    search for the `AIController` class.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`选择父类`对话框中，展开`所有类`并手动搜索`AIController`类。
- en: '*Left-click* this class option and then *left-click* on the green `Select`
    option at the bottom to create a new `Blueprint` from this class. Please refer
    to the following screenshot to know where to find the `AIController` class. Also,
    take note of the tooltip that appears when hovering over the class option; it
    contains useful information about this class from the developers:![Figure 13.1:
    The AIController asset class, as found in the Pick Parent Class dialogue box'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*此类选项，然后*左键单击*底部的绿色`选择`选项以从此类创建一个新的`蓝图`。请参考以下截图以了解在哪里找到`AIController`类。还要注意悬停在类选项上时出现的工具提示；它包含有关开发人员的有用信息：![图13.1：在选择父类对话框中找到的AIController资产类'
- en: '](img/B16183_13_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_01.jpg)'
- en: 'Figure 13.1: The AIController asset class, as found in the Pick Parent Class
    dialogue box'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：在选择父类对话框中找到的AIController资产类
- en: With this new `AIController Blueprint` created, name this asset `BP_AIControllerEnemy`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了这个新的`AIController蓝图`后，将此资产命名为`BP_AIControllerEnemy`。
- en: With the AI Controller created and named, it's time to assign this asset to
    the first enemy Blueprint that you made in the previous chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: AI控制器已创建并命名，现在是将此资产分配给您在上一章中创建的第一个敌人蓝图的时候了。
- en: Navigate to the `/Enemy/Blueprints` directly to find `BP_Enemy`. *Double-click*
    to open this Blueprint.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接导航到`/Enemy/Blueprints`，找到`BP_Enemy`。*双击*打开此蓝图。
- en: In the `Details` panel of the first enemy `Blueprint`, there is a section labeled
    `Pawn`. This is where you can set different parameters regarding the AI functionality
    of `Pawn` or `Character`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个敌人`蓝图`的`详细信息`面板中，有一个标有`Pawn`的部分。这是您可以设置关于`Pawn`或`Character`的AI功能的不同参数的地方。
- en: The `AI Controller Class` parameter determines, as its name suggests, which
    AI Controller to use for this enemy. *Left-click* on the dropdown to find and
    select the AI Controller you made earlier; that is, `BP_AIController_Enemy`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AI控制器类`参数确定了要为此敌人使用哪个AI控制器，*左键单击*下拉菜单以查找并选择您之前创建的AI控制器；即`BP_AIController_Enemy`。'
- en: With this exercise complete, the enemy AI now knows which AI Controller to use.
    This is crucial because it is in the AI Controller where the AI will use and execute
    the behavior tree you will create later in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，敌人AI现在知道要使用哪个AI控制器。这是至关重要的，因为在AI控制器中，AI将使用并执行您将在本章后面创建的行为树。
- en: The AI Controller is now assigned to the enemy, which means you are almost ready
    to start developing the actual intelligence for this AI. There is still one important
    topic to discuss before doing so, and that is the Navigation Mesh.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: AI控制器现在已分配给敌人，这意味着您几乎可以开始为这个AI开发实际的智能了。在这样做之前，还有一个重要的话题需要讨论，那就是导航网格。
- en: Navigation Mesh
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航网格
- en: One of the most crucial aspects of any AI, especially in video games, is the
    ability to navigate the environment in a sophisticated manner. In Unreal Engine
    4, there is a way for the engine to tell the AI which parts of an environment
    navigable and which parts are not. This is done through a **Navigation Mesh**,
    or **Nav Mesh** for short.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 任何AI的最关键方面之一，尤其是在视频游戏中，就是以复杂的方式导航环境。在虚幻引擎4中，引擎有一种方法告诉AI哪些环境部分是可导航的，哪些部分不是。这是通过**导航网格**或**Nav
    Mesh**来实现的。
- en: The term Mesh is misleading here because it's implemented through a volume in
    the editor. We will need a Navigation Mesh in our level so that our AI can effectively
    navigate the playable bounds of the game world. We'll add one together in the
    following exercise.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的Mesh一词有误导性，因为它是通过编辑器中的一个体积来实现的。我们需要在我们的级别中有一个导航网格，这样我们的AI才能有效地导航游戏世界的可玩范围。我们将在下面的练习中一起添加一个。
- en: Unreal Engine 4 also supports a `Dynamic Navigation Mesh`, which allows the
    Nav Mesh to update in real-time as dynamic objects move around the environment.
    This results in the AI recognizing these changes in the environment and updating
    their pathing/navigation appropriately. This book will not cover this, but you
    can access the configuration options via `Project Settings -> Navigation Mesh
    -> Runtime Generation`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎4还支持`动态导航网格`，允许导航网格在动态对象在环境中移动时实时更新。这导致AI能够识别环境中的这些变化，并相应地更新它们的路径/导航。本书不会涵盖这一点，但您可以通过`项目设置
    -> 导航网格 -> 运行时生成`访问配置选项。
- en: 'Exercise 13.02: Implementing a Nav Mesh Volume for the AI Enemy'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.02：为AI敌人实现导航网格体积
- en: In this exercise, you will add a Navigation Mesh to `SideScrollerExampleMap`
    and explore how Navigation Meshes work in Unreal Engine 4\. You'll also learn
    how to parameterize this volume for the needs of your game. This exercise will
    be performed within the Unreal Engine 4 editor.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将向`SideScrollerExampleMap`添加一个导航网格，并探索在虚幻引擎4中导航网格的工作原理。您还将学习如何为游戏的需求参数化这个体积。这个练习将在虚幻引擎4编辑器中进行。
- en: By the end of this exercise, you will have a stronger understanding of the Nav
    Mesh. You will also be able to implement this volume in your own level in the
    activity that follows this exercise. Let's begin by adding the Nav Mesh volume
    to the level.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本练习，您将更加了解导航网格。您还将能够在接下来的活动中在自己的关卡中实现这个体积。让我们开始向关卡添加导航网格体积。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: If you do not already have the map open, please open `SideScrollerExampleMap`
    by navigating to `File` and *left-clicking* on the `Open Level` option. From the
    `Open Level` dialogue box, navigate to `/SideScrollerCPP/Maps` to find `SideScrollerExampleMap`.
    Select this map with a *left-click* and then *left-click* `Open` at the bottom
    to open the map.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未打开地图，请通过导航到`文件`并*左键单击*`打开级别`选项来打开`SideScrollerExampleMap`。从`打开级别`对话框，导航到`/SideScrollerCPP/Maps`找到`SideScrollerExampleMap`。用*左键单击*选择此地图，然后在底部*左键单击*`打开`以打开地图。
- en: With the map opened, navigate to the right-hand side to find the `Modes` panel.
    The `Modes` panel is a set of easily accessible actor types such as `Volumes`,
    `Lights`, `Geometry`, and others. Under the `Volumes` category, you will find
    the `Nav Mesh Bounds Volume` option.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开地图后，导航到右侧找到`模式`面板。`模式`面板是一组易于访问的角色类型，如`体积`、`灯光`、`几何`等。在`体积`类别下，您会找到`Nav Mesh
    Bounds Volume`选项。
- en: '*Left-click* and drag this volume into the map/scene. By default, you will
    see the outline of the volume in the editor. Press the `P` key to visualize the
    `Navigation` area that the volume encompasses, but make sure that the volume is
    intersecting with the ground geometry in order to see the green visualization,
    as shown in the following screenshot:![Figure 13.2: Areas outlined in green are
    perceived as navigable by the engine and the AI'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*并将此体积拖入地图/场景中。默认情况下，您将在编辑器中看到体积的轮廓。按`P`键可可视化体积所包含的`导航`区域，但请确保体积与地面几何相交，以便看到绿色可视化，如下面的屏幕截图所示：![图13.2：引擎和AI感知为可导航的区域轮廓'
- en: '](img/B16183_13_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_02.jpg)'
- en: 'Figure 13.2: Areas outlined in green are perceived as navigable by the engine
    and the AI'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：引擎和AI感知为可导航的区域轮廓
- en: With the `Nav Mesh` volume in place, let's adjust its shape so that the volume
    extends to the entire area of the level. After this, you'll learn how to adjust
    the parameters of the `Nav Mesh` volume for the purposes of the game.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Nav Mesh`体积后，让我们调整它的形状，使体积延伸到整个关卡区域。之后，您将学习如何调整`Nav Mesh`体积的参数以适应游戏的目的。
- en: '*Left-click* to select `NavMeshBoundsVolume` and navigate to its `Details`
    panel. There is a section labeled `Brush Settings` that allows you to adjust the
    shape and size of the volume. Find the values that fit best for you. Some suggested
    settings are `Brush Type: Additive`, `Brush Shape: Box`, `X: 3000.0`, `Y: 3000.0`,
    and `Z: 3000.0`.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*选择`NavMeshBoundsVolume`并导航到其`详细信息`面板。有一个标有`刷设置`的部分，允许您调整体积的形状和大小。找到最适合您的值。一些建议的设置是`刷类型：添加`，`刷形状：盒子`，`X：3000.0`，`Y：3000.0`和`Z：3000.0`。'
- en: 'Notice that when the shape and dimensions of `NavMeshBoundsVolume` change,
    `Nav Mesh` will adjust and recalculate the navigable area. This can be seen in
    the following screenshot. You will also notice that the upper platforms are not
    navigable; you will fix this later:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当`NavMeshBoundsVolume`的形状和尺寸发生变化时，`Nav Mesh`将调整并重新计算可导航区域。这可以在下面的屏幕截图中看到。您还会注意到上层平台是不可导航的；您稍后会修复这个问题。
- en: '![Figure 13.3: Now, NavMeshBoundsVolume extends to the entire playable'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3：现在，NavMeshBoundsVolume延伸到整个可播放区域'
- en: area of the example map
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例地图的区域
- en: '](img/B16183_13_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_03.jpg)'
- en: 'Figure 13.3: Now, NavMeshBoundsVolume extends to the entire playable area of
    the example map'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：现在，NavMeshBoundsVolume延伸到整个可播放区域的示例地图
- en: By completing this exercise, you have placed your first `NavMeshBoundsVolume`
    actor into the game world and, using the debug key, `'P'`, visualized the navigable
    area in the default map. Next, you will learn more about the `RecastNavMesh` actor,
    which is also created when placing `NavMeshBoundsVolume` into the level.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经将第一个`NavMeshBoundsVolume`角色放入了游戏世界，并使用调试键`'P'`可视化了默认地图中的可导航区域。接下来，您将学习更多关于`RecastNavMesh`角色的知识，当将`NavMeshBoundsVolume`放入关卡时，也会创建这个角色。
- en: Recasting the Nav Mesh
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重塑导航网格
- en: 'When you added `NavMeshBoundsVolume`, you may have noticed that another actor
    was created automatically: a `RecastNavMesh` actor called `RecastNavMesh-Default`.
    This `RecastNavMesh` acts as the "brain" of the Nav Mesh because it contains the
    parameters needed to adjust the Nav Mesh that directly influences how the AI navigates
    the given area.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加`NavMeshBoundsVolume`时，您可能已经注意到另一个角色被自动创建：一个名为`RecastNavMesh-Default`的`RecastNavMesh`角色。这个`RecastNavMesh`充当了导航网格的“大脑”，因为它包含了调整导航网格所需的参数，直接影响AI在给定区域的导航。
- en: 'The following screenshot shows this asset, as seen from the `World Outliner`
    tab:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此资产，从 `World Outliner` 选项卡中看到：
- en: '![Figure 13.4: The RecastNavMesh actor, as seen from the World Outliner tab'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4：从世界大纲器选项卡中看到的 RecastNavMesh actor'
- en: '](img/B16183_13_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_04.jpg)'
- en: 'Figure 13.4: The RecastNavMesh actor, as seen from the World Outliner tab'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：从世界大纲器选项卡中看到的 RecastNavMesh actor
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are a lot of parameters that exist in `RecastNavMesh`, and we will only
    be covering the important parameters in this book. For more information, check
    out [https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html](https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecastNavMesh` 中存在许多参数，我们只会在本书中涵盖重要的参数。有关更多信息，请查看 [https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html](https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.html)。'
- en: 'There are only two primary sections that are important to you right now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有两个对您重要的主要部分：
- en: '`Display`: The `Display` section, as the name suggests, only contains parameters
    that affect the visual debug display of the generated navigable area of `NavMeshBoundsVolume`.
    It is recommended that you try toggling each of the parameters under this category
    to see how it affects the display of the generated Nav Mesh.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Display`：`Display` 部分，顾名思义，只包含影响 `NavMeshBoundsVolume` 生成的可导航区域的可视化调试显示的参数。建议您尝试切换此类别下的每个参数，以查看它如何影响生成的
    Nav Mesh 的显示。'
- en: '`Generation`: The `Generation` category contains a set of values that act as
    a rule set for how the Nav Mesh will generate and determine which areas of geometry
    are navigable, and which are not. There are many options here, which can make
    the concept very daunting, but let''s discuss just a handful of the parameters
    under this category:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Generation`：`Generation` 类别包含一组值，作为 Nav Mesh 生成和确定哪些几何区域是可导航的，哪些不可导航的规则集。这里有很多选项，这可能使概念非常令人生畏，但让我们只讨论这个类别下的一些参数：'
- en: '`Cell Size` refers to the accuracy in which the Nav Mesh can generate navigable
    space within an area. You will be updating this value in the next step of this
    exercise, so you''ll see how this affects the navigable area in real time.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cell Size` 指的是 Nav Mesh 在区域内生成可导航空间的精度。您将在本练习的下一步中更新此值，因此您将看到这如何实时影响可导航区域。'
- en: '`Agent Radius` refers to the radius of the actor that will be navigating this
    area. In the case of your game, the radius to set here is the radius of the collision
    component of the character with the largest radius.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent Radius` 指的是将要在该区域导航的角色的半径。在您的游戏中，这里设置的半径是具有最大半径的角色的碰撞组件的半径。'
- en: '`Agent Height` refers to the height of the actor that will be navigating this
    area. In the case of your game, the height to set here is the Half Height of the
    collision component of the character with the largest Half Height. You can multiply
    it by `2.0f` to get the full height.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent Height` 指的是将要在该区域导航的角色的高度。在您的游戏中，这里设置的高度是具有最大 Half Height 的角色的碰撞组件的一半高度。您可以将其乘以
    `2.0f` 来获得完整的高度。'
- en: '`Agent Max Slope` refers to the slope angle for inclines that can exist in
    your game world. By default, the value is `44` degrees, and this is a parameter
    you will leave alone unless your game requires that it changes.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent Max Slope` 指的是游戏世界中可以存在的斜坡的坡度角度。默认情况下，该值为 `44` 度，这是一个参数，除非您的游戏需要更改，否则您将不会更改。'
- en: '`Agent Max Step Height` refers to the height of steps, regarding staircase
    steps, that can be navigated by the AI. Much like `Agent Max Slope`, this is a
    parameter that you will more than likely leave alone unless your game specifically
    requires this value to change.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent Max Step Height` 指的是 AI 可以导航的台阶的高度，关于楼梯台阶。与 `Agent Max Slope` 类似，这是一个参数，除非您的游戏明确需要更改此值，否则您很可能不会更改。'
- en: Now that you have learned about the Recast Nav Mesh parameters, let's put this
    knowledge into practice with the next exercise, where will walk you through changing
    a few of these parameters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 Recast Nav Mesh 参数，让我们将这些知识付诸实践，进行下一个练习，其中将指导您更改其中一些参数。
- en: 'Exercise 13.03: Recasting Nav Mesh Volume Parameters'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.03：重新设置 Nav Mesh 体积参数
- en: Now that you have the `Nav Mesh` volume in the level, it is time to change the
    parameters of the `Recast Nav Mesh` actor so that the Nav Mesh allows the enemy
    AI to navigate across platforms that are thinner than others. This exercise will
    be performed within the Unreal Engine 4 editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您在关卡中有了 `Nav Mesh` 体积，是时候改变 `Recast Nav Mesh` actor 的参数，以便 Nav Mesh 允许敌人 AI
    在比其他平台更薄的平台上导航。这个练习将在虚幻引擎 4 编辑器中进行。
- en: 'The following step will help you complete this exercise:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: 'You will be updating `Cell Size` and `Agent Height` so that they fit the needs
    of your character and the accuracy needed for the Nav Mesh:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将更新 `Cell Size` 和 `Agent Height`，使其适应您的角色的需求和 Nav Mesh 所需的精度：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows that the upper platforms are now navigable because
    of the changes we made to `Cell Size`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了由于我们对 `Cell Size` 进行的更改，上层平台现在是可导航的：
- en: '![Figure 13.5: Changing Cell Size from 19.0f to 5.0f allows for the narrow'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5：将 Cell Size 从 19.0f 更改为 5.0f，使狭窄的上层平台可导航'
- en: upper platforms to be navigable
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上层平台可导航
- en: '](img/B16183_13_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_05.jpg)'
- en: 'Figure 13.5: Changing Cell Size from 19.0f to 5.0f allows for the narrow upper
    platforms to be navigable'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：将 Cell Size 从 19.0f 更改为 5.0f，使狭窄的上层平台可导航
- en: With `SuperSideScrollerExampleMap` set up with its own `Nav Mesh`, you can now
    move on and create the AI logic for the enemy. Before doing so, complete the following
    activity to create your own level, with its own unique layout and `NavMeshBoundsVolume`
    actor that you can use for the remainder of this project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为 `SuperSideScrollerExampleMap` 设置自己的 `Nav Mesh`，您现在可以继续并为敌人创建 AI 逻辑。在这样做之前，完成以下活动，创建您自己的关卡，具有独特的布局和
    `NavMeshBoundsVolume` actor，您可以在本项目的其余部分中使用。
- en: 'Activity 13.01: Creating a New Level'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.01：创建新级别
- en: Now that you have added `NavMeshBoundsVolume` to the example map, it is time
    to create your own map for the purposes of the rest of the `Super SideScroller`
    game. By creating your own map, you will have a better understanding of how `NavMeshBoundsVolume`
    and the properties of `RecastNavMesh` affect the environment they are placed in.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在示例地图中添加了`NavMeshBoundsVolume`，是时候为`Super SideScroller`游戏的其余部分创建你自己的地图了。通过创建自己的地图，你将更好地理解`NavMeshBoundsVolume`和`RecastNavMesh`的属性如何影响它们所放置的环境。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before moving on to the solution for this activity, if you need an example
    level that will work for the remaining chapters of the `SuperSideScroller` game,
    then don''t worry – this chapter comes with the `SuperSideScroller.umap` asset,
    as well as a map called `SuperSideScroller_NoNavMesh`, which does not contain
    the `NavMeshBoundsVolume`. You can use `SuperSideScroller.umap` as a reference
    for how to create your own level, or to get ideas on how to improve your own level.
    You can download the map here: [https://packt.live/3lo7v2f](https://packt.live/3lo7v2f).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续解决这个活动之前，如果你需要一个可以用于`SuperSideScroller`游戏剩余章节的示例级别，那就不用担心了——本章附带了`SuperSideScroller.umap`资源，以及一个名为`SuperSideScroller_NoNavMesh`的地图，不包含`NavMeshBoundsVolume`。你可以使用`SuperSideScroller.umap`作为创建自己级别的参考，或者获取如何改进自己级别的想法。你可以在这里下载地图：[https://packt.live/3lo7v2f](https://packt.live/3lo7v2f)。
- en: 'Perform the following steps to create a simplistic map:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤创建一个简单的地图：
- en: Create a `New Level`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`新级别`。
- en: Name this level `SuperSideScroller`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个级别命名为`SuperSideScroller`。
- en: Using the static mesh assets provided by default in the `Content Browser` interface
    of this project, create an interesting space with different elevations to navigate.
    Add your player character `Blueprint` to the level, and make sure it is possessed
    by `Player Controller 0`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该项目的`内容浏览器`界面中默认提供的静态网格资源，创建一个有不同高度的有趣空间以导航。将你的玩家角色`Blueprint`添加到级别中，并确保它由`Player
    Controller 0`控制。
- en: Add the `NavMeshBoundsVolume` actor to your level and adjust its dimensions
    so that it fits the space you created. In the example map provided for this activity,
    the dimensions set should be `1000.0`, `5000.0`, and `2000.0` in the *X*, *Y*,
    and *Z* axes, respectively.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NavMeshBoundsVolume` actor添加到你的级别中，并调整其尺寸，使其适应你创建的空间。在为这个活动提供的示例地图中，设置的尺寸应分别为`1000.0`、`5000.0`和`2000.0`，分别对应*X*、*Y*和*Z*轴。
- en: Make sure to enable debug visualization for `NavMeshBoundsVolume` by pressing
    the `P` key.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过按下`P`键启用`NavMeshBoundsVolume`的调试可视化。
- en: Adjust the parameters of the `RecastNavMesh` actor so that `NavMeshBoundsVolume`
    works well for your level. In the case of the provided example map, the `Cell
    Size` parameter is set to `5.0f`, `Agent Radius` is set to `42.0f`, and `Agent
    Height` is set to `192.0f`. Use these values as a reference.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`RecastNavMesh` actor的参数，使`NavMeshBoundsVolume`在你的级别中运行良好。在提供的示例地图中，`Cell
    Size`参数设置为`5.0f`，`Agent Radius`设置为`42.0f`，`Agent Height`设置为`192.0f`。使用这些值作为参考。
- en: 'Expected Output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 13.6: SuperSideScroller map'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6：SuperSideScroller地图'
- en: '](img/B16183_13_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_06.jpg)'
- en: 'Figure 13.6: SuperSideScroller map'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：SuperSideScroller地图
- en: By the end of this activity, you will have a level that contains the required
    `NavMeshBoundsVolume` and settings for the `RecastNavMesh` actor. This will allow
    the AI we'll develop in the upcoming exercises to function correctly. Again, if
    you are unsure of how the level should look, please refer to the provided example
    map, `SuperSideScroller.umap`. Now, it is time to jump into developing the AI
    for the `SuperSideScroller` game.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个活动的结束，你将拥有一个包含所需的`NavMeshBoundsVolume`和`RecastNavMesh` actor设置的级别。这将允许我们在接下来的练习中开发的AI能够正确运行。再次强调，如果你不确定级别应该是什么样子，请参考提供的示例地图`SuperSideScroller.umap`。现在，是时候开始开发`SuperSideScroller`游戏的AI了。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Behavior Trees and Blackboards
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为树和黑板
- en: Behavior trees and Blackboards work together to allow our AI to follow different
    logical paths and make decisions based on a variety of conditions and variables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树和黑板共同工作，允许我们的AI遵循不同的逻辑路径，并根据各种条件和变量做出决策。
- en: A **behavior tree** (**BT**) is a visual scripting tool that allows you to tell
    a pawn what to do based on certain factors and parameters. For example, a BT can
    tell an AI to move to a certain location based on whether the AI can see the player.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为树**（**BT**）是一种可视化脚本工具，允许你根据特定因素和参数告诉一个角色该做什么。例如，一个行为树可以告诉一个AI根据AI是否能看到玩家而移动到某个位置。'
- en: To give an example of how BTs and Blackboards are used in games, let's look
    at the game *Gears of War 5*, which was developed with Unreal Engine 4\. The AI
    in Gears of War 5, and throughout the Gears of War series, always try to flank
    the player, or force the player out of cover. In order to do this, a key component
    of the AI logic is to know who the player is, and where the player is. A reference
    variable to the player, and a location vector to store the location of the player,
    exist in the Blackboard. The logic that determines how these variables are used
    and how the AI will use this information is performed inside the behavior tree.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明行为树和黑板在游戏中的使用，让我们看看使用虚幻引擎4开发的游戏*战争机器5*。战争机器5中的AI，以及整个战争机器系列，总是试图包抄玩家，或者迫使玩家离开掩体。为了做到这一点，AI逻辑的一个关键组成部分是知道玩家是谁，以及玩家在哪里。在黑板中存在一个对玩家的引用变量，以及一个用于存储玩家位置的位置向量。确定这些变量如何使用以及AI将如何使用这些信息的逻辑是在行为树中执行的。
- en: The Blackboard is where you define the set of variables that are required in
    order to have the behavior tree perform actions and use those values for decision-making.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板是你定义的一组变量，这些变量是行为树执行动作和使用这些值进行决策所需的。
- en: The behavior tree is where you create the Tasks that you want the AI to perform,
    such as moving to a location, or performing a custom Task that you create. Like
    many of the in-editor tools in Unreal Engine 4, behavior trees are, for the most
    part, a very visual scripting experience.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树是您创建希望AI执行的任务的地方，例如移动到某个位置，或执行您创建的自定义任务。与Unreal Engine 4中的许多编辑工具一样，行为树在很大程度上是一种非常视觉化的脚本体验。
- en: '**Blackboards** are where you define the variables, also known as **Keys**,
    that will then be referenced by the **behavior tree**. The Keys you create here
    can be used in **Tasks**, **Services**, and **Decorators** to serve different
    purposes based on how you want the AI to function. The following screenshot shows
    an example set of variable Keys that can be referenced by its associated behavior
    tree.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑板**是您定义变量的地方，也称为**键**，然后行为树将引用这些变量。您在这里创建的键可以在**任务**、**服务**和**装饰器**中使用，以根据您希望AI如何运行来实现不同的目的。以下截图显示了一个示例变量键集，可以被其关联的行为树引用。'
- en: 'Without a Blackboard, behavior trees would have no way of passing and storing
    information across different Tasks, Services, or Decorators, rendering it useless:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 没有黑板，行为树将无法在不同的任务、服务或装饰器之间传递和存储信息，因此变得无用。
- en: '![Figure 13.7: An example set of variables inside a Blackboard that'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7：黑板中的一组变量示例'
- en: can be accessed in the behavior tree
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在行为树中访问
- en: '](img/B16183_13_07.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_07.jpg)'
- en: 'Figure 13.7: An example set of variables inside a Blackboard that can be accessed
    in the behavior tree'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：黑板中的一组变量示例，可以在行为树中访问
- en: '**Behavior trees** are composed of a set of **objects** – that is, **Composites**,
    **Tasks**, **Decorators**, and **Services** – that work together to define how
    the AI will behave and respond based on the conditions and logic flow that you
    set. All behavior trees begin with what is called the Root where the logic flow
    begins; this cannot be modified and has only one execution branch. Let''s take
    a look at these objects in more detail:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为树**由一组**对象**组成 - 即**复合体**、**任务**、**装饰器**和**服务** - 它们共同定义了AI根据您设置的条件和逻辑流动来行为和响应的方式。所有行为树都始于所谓的根，逻辑流从这里开始；这不能被修改，只有一个执行分支。让我们更详细地看看这些对象：'
- en: Composites
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合体
- en: 'Composite nodes function as a means to tell the behavior tree how to go about
    performing Tasks and other actions. The following screenshot shows the full list
    of Composite nodes that Unreal Engine gives you by default: Selector, Sequence,
    and Simple Parallel.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 复合节点的功能是告诉行为树如何执行任务和其他操作。以下截图显示了Unreal Engine默认提供的所有复合节点的完整列表：选择器、序列和简单并行。
- en: 'Composite nodes can also have Decorators and Services attached to them in order
    to have optional conditions applied before a behavior tree branch is executed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 复合节点也可以附加装饰器和服务，以便在执行行为树分支之前应用可选条件：
- en: '![Figure 13.8: The full list of Composite nodes – Selector, Sequence, and Simple
    Parallel'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8：复合节点的完整列表 - 选择器、序列和简单并行'
- en: '](img/B16183_13_08.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_08.jpg)'
- en: 'Figure 13.8: The full list of Composite nodes – Selector, Sequence, and Simple
    Parallel'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：复合节点的完整列表 - 选择器、序列和简单并行
- en: '`Selector`: The Selector composite node executes its children from left to
    right and will stop executing when one of the children Tasks succeeds. Using the
    example shown in the following screenshot, if the `FinishWithResult` task is successful,
    the parent Selector succeeds, which will cause the Root to execute again and `FinishWithResult`
    to execute once more. This pattern will continue until `FinishWithResult` fails.
    The Selector will then execute `MakeNoise`. If `MakeNoise` fails, the `Selector`
    fails, and the Root will execute again. If the `MakeNoise` task succeeds, then
    the Selector will succeed, and the Root will execute again. Depending on the flow
    of the behavior tree, if the Selector fails or succeeds, the next composite branch
    will begin to execute. In the following screenshot, there are no other composite
    nodes, so if the Selector fails or succeeds, the Root node will be executed again.
    However, if there were a Sequence composite node with multiple Selector nodes
    underneath, each Selector would attempt to successfully execute its children.
    Regardless of success or failure, each Selector will attempt execution sequentially:![Figure
    13.9: An example of how a Selector Composite node can be used in a behavior tree'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`选择器`：选择器复合节点从左到右执行其子节点，并且当其中一个子任务成功时将停止执行。使用以下截图中显示的示例，如果`FinishWithResult`任务成功，父选择器成功，这将导致根再次执行，并且`FinishWithResult`再次执行。这种模式将持续到`FinishWithResult`失败。然后选择器将执行`MakeNoise`。如果`MakeNoise`失败，`选择器`失败，根将再次执行。如果`MakeNoise`任务成功，那么选择器将成功，根将再次执行。根据行为树的流程，如果选择器失败或成功，下一个复合分支将开始执行。在以下截图中，没有其他复合节点，因此如果选择器失败或成功，根节点将再次执行。但是，如果有一个序列复合节点，并且其下有多个选择器节点，每个选择器将尝试按顺序执行其子节点。无论成功与否，每个选择器都将依次执行：![图13.9：选择器复合节点在行为树中的使用示例'
- en: '](img/B16183_13_09.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_09.jpg)'
- en: 'Figure 13.9: An example of how a Selector Composite node can be used in a behavior
    tree'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：选择器复合节点在行为树中的使用示例
- en: Note that when adding Tasks and `Composite` nodes, you will notice numeric values
    on the top-right corners of each node. These numbers indicate the order in which
    these nodes will be executed. The pattern follows the *top* to *bottom*, *left*
    to *right*, paradigm, and these values help you keep track of the ordering. Any
    disconnected Task or `Composite` node will be given a value of `–1` to indicate
    that it is unused.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当添加任务和`复合`节点时，您会注意到每个节点的右上角有数字值。这些数字表示这些节点将被执行的顺序。模式遵循*从上到下*，*从左到右*的范式，这些值可以帮助您跟踪顺序。任何未连接的任务或`复合`节点将被赋予值`-1`，以表示未使用。
- en: '`Sequence`: The `Sequence` composite node executes its children from left to
    right and will stop executing when one of the children Tasks fails. Using the
    example shown in the following screenshot, if the `Move To` task is successful,
    then the parent Sequence node will execute the `Wait` task. If the `Wait` task
    is successful, then the Sequence is successful, and `Root` will execute again.
    If the `Move To` task fails, however, the Sequence will fail and `Root` will execute
    again, causing the `Wait` task to never execute:![Figure 13.10: An example of
    how a Sequence Composite node'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`序列`：`序列`组合节点从左到右执行其子节点，并且当其中一个子任务失败时将停止执行。使用下面截图中显示的示例，如果`移动到`任务成功，那么父`序列`节点将执行`等待`任务。如果`等待`任务成功，那么序列成功，`根`将再次执行。然而，如果`移动到`任务失败，序列将失败，`根`将再次执行，导致`等待`任务永远不会执行：![图13.10：序列组合节点示例'
- en: can be used in a behavior tree
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在行为树中使用
- en: '](img/B16183_13_10.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_10.jpg)'
- en: 'Figure 13.10: An example of how a Sequence Composite node can be used in a
    behavior tree'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：序列组合节点在行为树中的使用示例
- en: '`Simple Parallel`: The `Simple Parallel` composite node allows you to execute
    a `Task` and a new standalone branch of logic simultaneously. The following screenshot
    shows a very basic example of what this will look like. In this example, a task
    used to `Wait` for `5` seconds is being executed at the same time as a new `Sequence`
    of Tasks is being executed:![Figure 13.11: An example of how a Selector Composite
    node can be used in a behavior tree'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`简单并行`：`简单并行`组合节点允许您同时执行`任务`和一个新的独立逻辑分支。下面的截图显示了这将是什么样子的一个非常基本的示例。在这个示例中，用于等待`5`秒的任务与执行一系列新任务的`序列`同时执行：![图13.11：选择器组合节点在行为树中的使用示例'
- en: '](img/B16183_13_11.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_11.jpg)'
- en: 'Figure 13.11: An example of how a Selector Composite node can be used in a
    behavior tree'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：选择器组合节点在行为树中的使用示例
- en: 'The `Simple Parallel` composite node is also the only `Composite` node that
    has a parameter in its `Details` panel, which is `Finish Mode`. There are two
    options:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`简单并行`组合节点也是唯一在其`详细信息`面板中具有参数的`组合`节点，即`完成模式`。有两个选项：'
- en: '`Immediate`: When set to `Immediate`, the Simple Parallel will finish successfully
    once the main Task finishes. In this case, after the `Wait` task finishes, the
    background tree Sequence will abort and the entire `Simple Parallel` will execute
    again.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`立即`：当设置为`立即`时，简单并行将在主任务完成后立即成功完成。在这种情况下，`等待`任务完成后，后台树序列将中止，整个`简单并行`将再次执行。'
- en: '`Delayed`: When set to `Delayed`, the Simple Parallel will finish successfully
    once the background tree finishes its execution and the Task finishes. In this
    case, the `Wait` task will finish after `5` seconds, but the entire `Simple Parallel`
    will wait for the `Move To` and `PlaySound` Tasks to execute before restarting.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`延迟`：当设置为`延迟`时，简单并行将在后台树完成执行并且任务完成后立即成功完成。在这种情况下，`等待`任务将在`5`秒后完成，但整个`简单并行`将等待`移动到`和`播放声音`任务执行后再重新开始。'
- en: Tasks
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: 'These are Tasks that our AI can perform. Unreal provides us with built-in Tasks
    for us to use by default, but we can also create our own in both Blueprints and
    in C++. This includes Tasks such as telling our AI to `Move To` a specific location,
    `Rotate To a direction`, and even telling the AI to fire its weapon. It''s also
    important to know that you can create your own custom Tasks using Blueprints.
    Let''s briefly discuss two of the Tasks you will be using to develop the AI for
    the enemy character:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的AI可以执行的任务。虚幻引擎默认提供了内置任务供我们使用，但我们也可以在蓝图和C++中创建自己的任务。这包括任务，如告诉我们的AI`移动到`特定位置，`旋转到一个方向`，甚至告诉AI开火。还要知道，您可以使用蓝图创建自定义任务。让我们简要讨论一下您将用来开发敌人角色AI的两个任务：`
- en: '`Move To Task`: This is one of the more commonly used Tasks in behavior trees,
    and you will be using this task in the upcoming exercises in this chapter. `Move
    To task` uses the navigation system to tell the AI how and where to move based
    on the location it is given. You will use this task to tell the AI enemy where
    to go.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`移动到任务`：这是行为树中常用的任务之一，在本章的后续练习中将使用此任务。`移动到任务`使用导航系统告诉AI如何移动以及移动的位置。您将使用此任务告诉AI敌人要去哪里。'
- en: '`Wait Task`: This is another commonly used task in behavior trees because it
    allows a delay in between task execution if the logic requires it. This can be
    used to allow the AI to wait a few seconds before moving to a new location.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`等待任务`：这是行为树中另一个常用的任务，因为它允许在任务执行之间延迟。这可以用于允许AI在移动到新位置之前等待几秒钟。'
- en: Decorators
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: '`Decorators` are conditions that can be added to Tasks or `Composite` nodes,
    such as a `Sequence` or `Selector`, that allows branching logic to occur. As an
    example, we can have a `Decorator` that checks whether or not the enemy knows
    the location of the player. If so, we can tell that enemy to move toward that
    last known location. If not, we can tell our AI to generate a new location and
    move there instead. It is also important to know that you can create your own
    custom Decorators using Blueprints.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`装饰器`是可以添加到任务或`组合`节点（如`序列`或`选择器`）的条件，允许分支逻辑发生。例如，我们可以有一个`装饰器`来检查敌人是否知道玩家的位置。如果是，我们可以告诉敌人朝着上次已知的位置移动。如果不是，我们可以告诉我们的AI生成一个新位置并移动到那里。还要知道，您可以使用蓝图创建自定义装饰器。'
- en: Let's also briefly discuss the Decorator you will be using to develop the AI
    for the enemy character – the `Is At Location` decorator. This determines whether
    the controlled pawn is at the location specified in the Decorator itself. This
    will be useful to you to ensure that the behavior tree is not executing until
    you know the AI has reached its given location.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下您将用来开发敌人角色AI的装饰器——`在位置`装饰器。这确定了受控棋子是否在装饰器本身指定的位置。这对您很有用，可以确保行为树在您知道AI已到达给定位置之前不执行。
- en: Services
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: '`Services` work a lot like Decorators because they can be linked with `Tasks`
    and `Composite` nodes. The main difference is that a `Service` allows us to execute
    a branch of nodes based on the interval defined in the Service. It also important
    to know that you can create your own custom Services using Blueprints.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Services`与`Decorators`非常相似，因为它们可以与`Tasks`和`Composite`节点链接。主要区别在于`Service`允许我们根据服务中定义的间隔执行一系列节点。还要知道，您可以使用蓝图创建自定义服务。'
- en: 'Exercise 13.04: Creating the AI Behavior Tree and Blackboard'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.04：创建AI行为树和黑板
- en: Now that you have had an overview of behavior trees and Blackboards, this exercise
    will guide you through creating these assets, telling the AI controller to use
    the behavior tree you created, and assigning the Blackboard to the behavior tree.
    The Blackboard and behavior tree assets you will create here will be used for
    the `SuperSideScroller` game. This exercise will be performed within the Unreal
    Engine 4 editor.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对行为树和黑板有了概述，这个练习将指导您创建这些资产，告诉AI控制器使用您创建的行为树，并将黑板分配给行为树。您在这里创建的黑板和行为树资产将用于`SuperSideScroller`游戏。此练习将在虚幻引擎4编辑器中执行。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Within the `Content Browser` interface, navigate to the `/Enemy/AI` directory.
    This is the same directory where you created the AI Controller.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`界面中，导航到`/Enemy/AI`目录。这是您创建AI控制器的相同目录。
- en: In this directory, *right-click* within the blank area of the `Content Browser`
    interface, navigate to the `Artificial Intelligence` option, and select `Behavior
    Tree` to create the `Behavior Tree` asset. Name this asset `BT_EnemyAI`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录中，在`Content Browser`界面的空白区域*右键单击*，导航到`Artificial Intelligence`选项，并选择`Behavior
    Tree`以创建`Behavior Tree`资产。将此资产命名为`BT_EnemyAI`。
- en: In the same directory as the previous step, *right-click* again within the blank
    area of the `Content Browser` interface, navigate to the `Artificial Intelligence`
    option, and select `Blackboard` to create the `Blackboard` asset. Name this asset
    `BB_EnemyAI`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的相同目录中，在`Content Browser`界面的空白区域再次*右键单击*，导航到`Artificial Intelligence`选项，并选择`Blackboard`以创建`Blackboard`资产。将此资产命名为`BB_EnemyAI`。
- en: Before we move on to telling the AI controller to run this new behavior tree,
    let's first assign the Blackboard to this behavior tree so that they are properly connected.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续告诉AI控制器运行这个新行为树之前，让我们首先将黑板分配给这个行为树，以便它们正确连接。
- en: Open `BT_EnemyAI` by *double-clicking* the asset in the `Content Browser` interface.
    Once opened, navigate to the `Details` panel on the right-hand side and find the
    `Blackboard Asset` parameter.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*双击*`Content Browser`界面中的资产打开`BT_EnemyAI`。一旦打开，导航到右侧的`Details`面板，并找到`Blackboard
    Asset`参数。
- en: '*Left-click* the dropdown menu on this parameter and find the `BB_EnemyAI`
    `Blackboard` asset you created earlier. Compile and save the behavior tree before
    closing it.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击此参数上的下拉菜单，并找到您之前创建的`BB_EnemyAI` `Blackboard`资产。在关闭之前编译和保存行为树。
- en: Next, open the AI Controller `BP_AIController_Enemy` asset by *double-clicking*
    it inside the `Content Browser` interface. Inside the controller, *right-click*
    and search for the `Run Behavior Tree` function.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过*双击*`Content Browser`界面内的AI控制器`BP_AIController_Enemy`资产来打开它。在控制器内，*右键单击*并搜索`Run
    Behavior Tree`函数。
- en: 'The `Run Behavior Tree` function is very straightforward: you assign a `Behavior
    Tree` to the controller and the function returns whether the behavior tree successfully
    began its execution.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run Behavior Tree`函数非常简单：您将行为树分配给控制器，函数返回行为树是否成功开始执行。'
- en: 'Lastly, connect the `Event BeginPlay` event node to the execution pin of the
    `Run Behavior Tree` function and assign `Behavior Tree asset BT_EnemyAI`, which
    you created earlier in this exercise:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Event BeginPlay`事件节点连接到`Run Behavior Tree`函数的执行引脚，并分配`Behavior Tree`资产`BT_EnemyAI`，这是您在此练习中创建的：
- en: .
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: '![Figure 13.12: Assigning the BT_EnemyAI behavior tree'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12：分配BT_EnemyAI行为树'
- en: '](img/B16183_13_12.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_12.jpg)'
- en: 'Figure 13.12: Assigning the BT_EnemyAI behavior tree'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：分配BT_EnemyAI行为树
- en: With this exercise complete, the enemy AI Controller now knows to run the `BT_EnemyAI`
    behavior tree, and this behavior tree knows to use the Blackboard asset called
    `BB_EnemyAI`. With this in place, you can begin to use the behavior tree logic
    to develop the AI so that the enemy character can move around the level.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，敌人AI控制器现在知道运行`BT_EnemyAI`行为树，并且此行为树知道使用名为`BB_EnemyAI`的黑板资产。有了这一点，您可以开始使用行为树逻辑来开发AI，以便敌人角色可以在级别中移动。
- en: 'Exercise 13.05: Creating a New Behavior Tree Task'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.05：创建新的行为树任务
- en: The goal of this exercise is to develop an AI task for the enemy AI that will
    allow the character to find a random point to move to within the bounds of the
    `Nav Mesh` volume in your level.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的目标是为敌人AI开发一个AI任务，使角色能够在您级别的`Nav Mesh`体积范围内找到一个随机点进行移动。
- en: Although the `SuperSideScroller` game will only allow two-dimensional movement,
    let's get the AI to move anywhere within the 3D space of the level that you created
    in *Activity 13.01*, *Creating a New Level*, and then work to constrain the enemy
    to two dimensions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`SuperSideScroller`游戏只允许二维移动，让我们让AI在您在*Activity 13.01*中创建的级别的三维空间中移动，然后努力将敌人限制在二维空间内。
- en: 'Follow these steps to create this new Task for the enemy:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为敌人创建新的任务：
- en: First, open the Blackboard asset you created in the previous exercise, `BB_EnemyAI`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开您在上一个练习中创建的黑板资产`BB_EnemyAI`。
- en: '*Left-click* on the `New Key` option at the top-left of `Blackboard` and select
    the `Vector` option. Name this vector `MoveToLocation`. You will use this `vector`
    variable to track the next move for the AI as it decides where to move to.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Blackboard`的左上方*左键单击*`New Key`选项，并选择`Vector`选项。将此向量命名为`MoveToLocation`。您将使用此`vector`变量来跟踪AI的下一个移动位置。
- en: For the purposes of this enemy AI, you will need to create a new `Task` because
    the currently available Tasks inside Unreal do not fit the needs of the enemy behavior.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个敌方AI的目的，你需要创建一个新的“任务”，因为目前在虚幻中可用的任务不符合敌方行为的需求。
- en: Navigate to and open the `Behavior Tree` asset you created in the previous exercise,
    `BT_EnemyAI`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到并打开你在上一个练习中创建的“行为树”资产，`BT_EnemyAI`。随机点选择的
- en: '*Left-click* on the `New Task` option on the top toolbar. When creating a new
    `Task`, it will automatically open the task asset for you. However, if you have
    already created a Task, a dropdown list of options will appear when selecting
    the `New Task` option. Before working on the logic of this `Task`, you will rename
    the asset.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部工具栏上*左键单击*“新建任务”选项。创建新的“任务”时，它会自动为你打开任务资产。但是，如果你已经创建了一个任务，在选择“新建任务”选项时会出现一个下拉选项列表。在处理这个“任务”的逻辑之前，你需要重命名资产。
- en: Close the `Task` asset window and navigate to `/Enemy/AI/`, which is where the
    `Task` was saved to. By default, the name provided is `BTTask_BlueprintBase_New`.
    Rename this asset `BTTask_FindLocation`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭“任务”资产窗口，导航到`/Enemy/AI/`，这是“任务”保存的位置。默认情况下，提供的名称是`BTTask_BlueprintBase_New`。将此资产重命名为`BTTask_FindLocation`。
- en: With the new `Task` asset named, *double-click* to open `Task Editor`. New Tasks
    will have their Blueprint graphs completely empty and will not provide you with
    any default events to use in the graph.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名新的“任务”资产后，*双击*打开“任务编辑器”。新的任务将使它们的蓝图图完全为空，并且不会为你提供任何默认事件来在图中使用。
- en: '*Right-click* within the graph and from the context-sensitive search, find
    the `Event Receive Execute AI` option.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*图中，在上下文敏感搜索中找到“事件接收执行AI”选项。'
- en: '*Left-click* the `Event Receive Execute AI` option to create the event node
    in the `Task` graph, as shown in the following screenshot:![Figure 13.13: Event
    Receive Execute AI returns both the Owner'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*“事件接收执行AI”选项，在“任务”图中创建事件节点，如下截图所示：![图13.13：事件接收执行AI返回所有者和受控角色'
- en: Controller and the Controlled Pawn
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器和受控角色
- en: '](img/B16183_13_13.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_13.jpg)'
- en: 'Figure 13.13: Event Receive Execute AI returns both the Owner Controller and
    the Controlled Pawn'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13：事件接收执行AI返回所有者控制器和受控角色
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Event Receive Execute AI` event will give you access to both the **Owner
    Controller** and the **Controlled Pawn**. You will use the Controlled Pawn for
    this Task in the upcoming steps.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: “事件接收执行AI”事件将让你可以访问**所有者控制器**和**受控角色**。在接下来的步骤中，你将使用受控角色来完成这个任务。
- en: Each `Task` requires a call to the `Finish Execute` function so that the `Behavior
    Tree` asset knows when it can move onto the next `Task` or branches off the tree.
    *Right-click* in the graph and search for `Finish Execute` via the context-sensitive
    search.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个“任务”都需要调用“完成执行”函数，以便“行为树”资产知道何时可以继续下一个“任务”或从树上分支出去。在图中*右键单击*，通过上下文敏感搜索搜索“完成执行”。
- en: '*Left-click* the `Finish Execute` option from the context-sensitive search
    to create the node inside the Blueprint graph of your `Task`, as shown in the
    following screenshot:![Figure 13.14: The Finish Execute function, which has a
    Boolean parameter that determines whether the Task is successful'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*上下文敏感搜索中的“完成执行”选项，在你的“任务”蓝图图中创建节点，如下截图所示：![图13.14：完成执行函数，其中包含一个布尔参数，用于确定任务是否成功'
- en: '](img/B16183_13_14.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_14.jpg)'
- en: 'Figure 13.14: The Finish Execute function, which has a Boolean parameter that
    determines whether the Task is successful'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14：完成执行函数，其中包含一个布尔参数，用于确定任务是否成功
- en: The next function that you need is called `GetRandomLocationInNavigableRadius`.
    This function, as the name suggests, returns a random vector location within a
    defined radius of the navigable area. This will allow the enemy character to find
    random locations and move to those locations.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的下一个函数叫做“在可导航半径内获取随机位置”。这个函数，顾名思义，返回可导航区域内定义半径内的随机向量位置。这将允许敌方角色找到随机位置并移动到这些位置。
- en: '*Right-click* in the graph and search for `GetRandomLocationInNavigableRadius`
    inside the context-sensitive search. *Left-click* the `GetRandomLocationInNavigableRadius`
    option to place this function inside the graph.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*图中，在上下文敏感搜索中搜索“在可导航半径内获取随机位置”。*左键单击*“在可导航半径内获取随机位置”选项，将此函数放置在图中。'
- en: With these two functions in place, and with `Event Receive Execute AI` ready,
    it is time to obtain the random location for the enemy AI.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个函数，并且准备好了“事件接收执行AI”，现在是时候为敌方AI获取随机位置了。
- en: 'From the `Controlled Pawn` output of `Event Receive Execute AI`, find the `GetActorLocation`
    function via the context-sensitive search:![Figure 13.15: The enemy pawn''s location
    will serve as the origin'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“事件接收执行AI”的“受控角色”输出中，通过上下文敏感搜索找到“获取角色位置”函数：![图13.15：敌方角色的位置将作为原点
- en: of the random point selection
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '](img/B16183_13_15.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_15.jpg)'
- en: 'Figure 13.15: The enemy pawn''s location will serve as the origin of the random
    point selection'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15：敌方角色的位置将作为随机点选择的原点
- en: 'Connect the vector return value from `GetActorLocation` to the `Origin` vector
    input parameter of the `GetRandomLocationInNavigableRadius` function, as shown
    in the following screenshot. Now, this function will use the enemy AI pawn''s
    location as the origin for determining the next random point:![Figure 13.16: Now,
    the enemy pawn location will be used as the origin'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“获取角色位置”的向量返回值连接到“获取可导航半径内随机位置”的“原点”向量输入参数，如下截图所示。现在，这个函数将使用敌方AI角色的位置作为确定下一个随机点的原点：![图13.16：现在，敌方角色的位置将被用作随机点向量搜索的原点
- en: of the random point vector search
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 的随机点向量搜索
- en: '](img/B16183_13_16.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_16.jpg)'
- en: 'Figure 13.16: Now, the enemy pawn location will be used as the origin of the
    random point vector search'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16：现在，敌方角色的位置将被用作随机点向量搜索的原点
- en: Next, you need to tell the `GetRandomLocationInNavigableRadius` function the
    `Radius` in which to check for the random point in the navigable area of the level.
    Set this value to `1000.0f`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要告诉“GetRandomLocationInNavigableRadius”函数要检查级别可导航区域中的随机点的“半径”。将此值设置为“1000.0f”。
- en: The remaining parameters, `Nav Data` and `Filter Class`, can remain as they
    are. Now that you are getting a random location from `GetRandomLocationInNavigableRadius`,
    you will need to be able to store this value in the `Blackboard` vector that you
    created earlier in this exercise.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的参数，“Nav Data”和“Filter Class”，可以保持不变。现在，您正在从“GetRandomLocationInNavigableRadius”获取随机位置，您需要能够将此值存储在您在本练习中创建的“Blackboard”向量中。
- en: To get a reference to the `Blackboard` vector variable, you need to create a
    new variable inside of this `Task` that's of the `Blackboard Key Selector` type.
    Create this new variable and name it `NewLocation`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获得对“Blackboard”向量变量的引用，您需要在此“Task”内创建一个“Blackboard Key Selector”类型的新变量。创建此新变量并命名为“NewLocation”。
- en: You now need to make this variable a `Public` variable so that it can be exposed
    inside the behavior tree. *Left-click* on the 'eye' icon so that the eye is visible.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要将此变量设置为“Public”变量，以便在行为树中公开。*左键单击* “眼睛”图标，使眼睛可见。
- en: 'With the `Blackboard Key Selector` variable ready, *left-click* and drag out
    a `Getter` of this variable. Then, pull from this variable and search for `Set
    Blackboard Value as Vector`, as shown in the following screenshot:![Figure 13.17:
    Set Blackboard Value has a variety of different types to support the different
    variables that can exist inside the Blackboard'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了“Blackboard Key Selector”变量准备好后，*左键单击* 并拖动此变量的“Getter”。然后，从此变量中拉出并搜索“Set Blackboard
    Value as Vector”，如下屏幕截图所示：![图13.17：Set Blackboard Value有各种不同类型，支持Blackboard中可能存在的不同变量
- en: '](img/B16183_13_17.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_17.jpg)'
- en: 'Figure 13.17: Set Blackboard Value has a variety of different types to support
    the different variables that can exist inside the Blackboard'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17：Set Blackboard Value有各种不同类型，支持Blackboard中可能存在的不同变量
- en: 'Connect the `RandomLocation` output vector from `GetRandomLocationInNavigableRadius`
    to the `Value` vector input parameter of `Set Blackboard Value as Vector`. Then,
    connect the execution pins of these two function nodes. The result will look as
    follows:![Figure 13.18: Now, the Blackboard vector value is assigned this new
    random location'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“GetRandomLocationInNavigableRadius”的“RandomLocation”输出向量连接到“Set Blackboard
    Value as Vector”的“Value”向量输入参数。然后，连接这两个函数节点的执行引脚。结果将如下所示：![图13.18：现在，Blackboard向量值被分配了这个新的随机位置
- en: '](img/B16183_13_18.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_18.jpg)'
- en: 'Figure 13.18: Now, the Blackboard vector value is assigned this new random
    location'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18：现在，Blackboard向量值被分配了这个新的随机位置
- en: Lastly, you will use the `Return Value` Boolean output parameter of the `GetRandomLocationInNavigableRadius`
    function as the means to determine whether the `Task` executes successfully.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将使用“GetRandomLocationInNavigableRadius”函数的“Return Value”布尔输出参数来确定“Task”是否成功执行。
- en: 'Connect the Boolean output parameter to the `Success` input parameter of the
    `Finish Execute` function and connect the execution pins of the `Set Blackboard
    Value as Vector` and `Finish Execute` function nodes. The following screenshot
    shows the final result of the `Task` logic:![Figure 13.19: The final setup for
    the Task'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布尔输出参数连接到“Finish Execute”函数的“Success”输入参数，并连接“Set Blackboard Value as Vector”和“Finish
    Execute”函数节点的执行引脚。以下屏幕截图显示了“Task”逻辑的最终结果：![图13.19：任务的最终设置
- en: '](img/B16183_13_19.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_19.jpg)'
- en: 'Figure 13.19: The final setup for the Task'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19：任务的最终设置
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3lmLyk5](https://packt.live/3lmLyk5).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到前面的屏幕截图的完整分辨率，以便更好地查看：[https://packt.live/3lmLyk5](https://packt.live/3lmLyk5)。
- en: By completing this exercise, you have created your first custom `Task` using
    Blueprints in Unreal Engine 4\. You now have a task that finds a random location
    within the navigable bounds of the `Nav Mesh Volume` of your level using the enemy
    pawn as the origin of this search. In the next exercise, you will implement this
    new `Task` in the behavior tree and see the enemy AI move around your level.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，您已经使用虚幻引擎 4 中的蓝图创建了您的第一个自定义“Task”。现在，您有一个任务，可以在级别的“Nav Mesh Volume”的可导航边界内找到一个随机位置，使用敌人的
    pawn 作为此搜索的起点。在下一个练习中，您将在行为树中实现这个新的“Task”，并看到敌人 AI 在您的级别周围移动。
- en: 'Exercise 13.06: Creating the Behavior Tree Logic'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.06：创建行为树逻辑
- en: The goal of this exercise is to implement the new `Task` you created in the
    previous exercise inside the behavior tree in order to have the enemy AI find
    a random location within the navigable space of your level and then move to this
    location. You will use a combination of the `Composite`, `Task`, and `Services`
    nodes to accomplish this behavior. This exercise will be performed within the
    Unreal Engine 4 editor.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是在行为树中实现您在上一个练习中创建的新“Task”，以便使敌人 AI 在级别的可导航空间内找到一个随机位置，然后移动到该位置。您将使用“Composite”、“Task”和“Services”节点的组合来实现此行为。本练习将在虚幻引擎
    4 编辑器中进行。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: To start, open the behavior tree you created in *Exercise 13.04*, *Creating
    the AI Behavior Tree and Blackboard*, which is `BT_EnemyAI`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开您在“Exercise 13.04”中创建的行为树，“Creating the AI Behavior Tree and Blackboard”，即“BT_EnemyAI”。
- en: Inside this `Behavior Tree`, *left-click* and drag from the bottom of the `Root`
    node and select the `Sequence` node from the context-sensitive search. The result
    will be the `Root` that's connected to the `Sequence` composite node.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此“行为树”中，*左键单击* 并从“Root”节点底部拖动，并从上下文敏感搜索中选择“Sequence”节点。结果将是将“Root”连接到“Sequence”复合节点。
- en: Next, from the `Sequence` node, *left-click* and drag to bring up the context-sensitive
    menu. In this menu, search for the `Task` you created in the last previous, `BTTask_FindLocation`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从“Sequence”节点*左键单击*并拖动以打开上下文敏感菜单。在此菜单中，搜索您在上一个任务中创建的“任务”，即“BTTask_FindLocation”。
- en: By default, the `BTTask_FindLocation` task should automatically assign the `New
    Location` key selector variable to the `MovetoLocation` vector variable from `Blackboard`.
    If this doesn't happen, you can assign this selector manually in the `Details`
    panel of the Task.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，“BTTask_FindLocation”任务应自动将“New Location”键选择器变量分配给“Blackboard”的“MovetoLocation”向量变量。如果没有发生这种情况，您可以在任务的“详细信息”面板中手动分配此选择器。
- en: Now, `BTTask_FindLocation` will assign the `NewLocation` selector to the `MovetoLocation`
    vector variable from `Blackboard`. This means that the random location that's
    returned from the task will be assigned to the `Blackboard` variable and that
    you can reference this variable in other Tasks.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“BTTask_FindLocation”将把“NewLocation”选择器分配给“Blackboard”的“MovetoLocation”向量变量。这意味着从任务返回的随机位置将被分配给“Blackboard”变量，并且您可以在其他任务中引用此变量。
- en: Now that you are finding a valid random location and assigning this location
    to the `Blackboard` variable, that is, `MovetoLocation`, you can use the `Move
    To` task to tell the AI to move to this location.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您正在查找有效的随机位置并将此位置分配给“Blackboard”变量，即“MovetoLocation”，您可以使用“Move To”任务告诉AI移动到此位置。
- en: '*Left-click* and pull from the `Sequence` composite node. Then, from the context-sensitive
    search, find the `Move To` task. Your `Behavior Tree` will now look as follows:![Figure
    13.20: After selecting the random location, the Move To task'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*并从“Sequence”复合节点中拖动。然后，在上下文敏感搜索中找到“Move To”任务。您的“行为树”现在将如下所示：![图13.20：选择随机位置后，移动任务'
- en: will let the AI move to this new location
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将让AI移动到这个新位置
- en: '](img/B16183_13_20.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_20.jpg)'
- en: 'Figure 13.20: After selecting the random location, the Move To task will let
    the AI move to this new location'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20：选择随机位置后，移动任务将让AI移动到这个新位置
- en: By default, the `Move To` task should assign `MoveToLocation` as its `Blackboard
    Key` value. If it doesn't, select the task. In its `Details` panel, you will find
    the `Blackboard Key` parameter, which is where you can assign the variable. While
    in the `Details` panel, also set `Acceptable Radius` to `50.0f`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，“Move To”任务应将“MoveToLocation”分配为其“Blackboard Key”值。如果没有，请选择任务。在其“详细信息”面板中，您将找到“Blackboard
    Key”参数，您可以在其中分配变量。在“详细信息”面板中，还将“可接受半径”设置为“50.0f”。
- en: Now, the behavior tree finds the random location using the `BTTask_FindLocation`
    custom task and tells the AI to move to that location using the `MoveTo` task.
    These two Tasks communicate the location to each other by referencing the `Blackboard`
    vector variable called `MovetoLocation`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，行为树使用“BTTask_FindLocation”自定义任务找到随机位置，并使用“MoveTo”任务告诉AI移动到该位置。这两个任务通过引用名为“MovetoLocation”的“Blackboard”向量变量相互通信位置。
- en: The last thing to do here is to add a `Decorator` to the `Sequence` composite
    node so that it ensures that the enemy character is not at a random location before
    executing the tree again to find and move to a new location.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要做的最后一件事是向“Sequence”复合节点添加一个“Decorator”，以确保敌人角色在再次执行树以查找并移动到新位置之前不处于随机位置。
- en: '*Right-click* on the top area of the `Sequence` and select `Add Decorator`.
    From the dropdown, *left-click* and select `Is at Location`.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*“Sequence”的顶部区域，然后选择“添加装饰者”。从下拉菜单中*左键单击*并选择“在位置”。'
- en: Since you already have a vector parameter inside `Blackboard`, this `Decorator`
    should automatically assign `MovetoLocation` as `Blackboard Key`. Verify this
    by selecting the `Decorator` and making sure `Blackboard Key` is assigned to `MovetoLocation`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于您已经在“Blackboard”中有一个向量参数，“Decorator”应自动将“MovetoLocation”分配为“Blackboard Key”。通过选择“Decorator”并确保“Blackboard
    Key”分配给“MovetoLocation”来验证这一点。
- en: 'With the Decorator in place, you have completed the behavior tree. The final
    result will look as follows:![Figure 13.21: The final setup for the behavior tree
    for the AI enemy'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了装饰者，您已经完成了行为树。最终结果将如下所示：![图13.21：AI敌人行为树的最终设置
- en: '](img/B16183_13_21.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_21.jpg)'
- en: 'Figure 13.21: The final setup for the behavior tree for the AI enemy'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21：AI敌人行为树的最终设置
- en: This behavior tree is telling the AI to find a random location using `BTTask_FindLocation`
    and assign this location to the Blackboard value called `MovetoLocation`. When
    this task is successful, the behavior tree will execute the `MoveTo` task, which
    will tell the AI to move to this new random location. The Sequence is wrapped
    in a `Decorator` that ensures that the enemy AI is at `MovetoLocation` before
    executing again, just as a safety net for the AI.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个行为树告诉AI使用“BTTask_FindLocation”找到一个随机位置，并将此位置分配给名为“MovetoLocation”的Blackboard值。当此任务成功时，行为树将执行“MoveTo”任务，该任务将告诉AI移动到这个新的随机位置。序列包含一个“Decorator”，它确保敌方AI在再次执行之前处于“MovetoLocation”，就像AI的安全网一样。
- en: Before you can test the new AI behavior, make sure to place a `BP_Enemy AI`
    into your level if one is not already there from previous exercises and activities.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试新的AI行为之前，确保将“BP_Enemy AI”放入您的级别中，如果之前的练习和活动中没有的话。
- en: 'Now, if you use `PIE`, or `Simulate`, you will see the enemy AI run around
    the map and move to random locations within `Nav Mesh Volume`:![Figure 13.22:
    The enemy AI will now move from location to location'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您使用“PIE”或“模拟”，您将看到敌方AI在“Nav Mesh Volume”内围绕地图奔跑并移动到随机位置：![图13.22：敌方AI现在将从一个位置移动到另一个位置
- en: '](img/B16183_13_22.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_22.jpg)'
- en: 'Figure 13.22: The enemy AI will now move from location to location'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.22：敌方AI现在将从一个位置移动到另一个位置
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There can be some cases where the enemy AI will not move. This can be caused
    by the `GetRandomLocationInNavigableRadius` function not returning `True`. This
    is a known issue, and if it occurs, please restart the editor and try again.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，敌人AI不会移动。这可能是由于“在可导航半径内获取随机位置”函数未返回“True”引起的。这是一个已知问题，如果发生，请重新启动编辑器并重试。
- en: By completing this exercise, you have created a fully functional behavior tree
    that allows the enemy AI to find and move to a random location within the navigable
    bounds of your level using `Nav Mesh Volume`. The Task you created in the previous
    exercise allows you to find this random point, while the `Move To` task allows
    the AI character to move toward this new location.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经创建了一个完全功能的行为树，允许敌人AI在您的级别的可导航范围内找到并移动到一个随机位置。您在上一个练习中创建的任务允许您找到这个随机点，而“移动到”任务允许AI角色朝着这个新位置移动。
- en: Due to how the `Sequence` composite node works, each task must complete successfully
    before it can move on to the next task, so first, the enemy successfully finds
    a random location and then moves toward this location. Only when the `Move To`
    task completes will the entire behavior tree start over and choose a new random location.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“序列”组合节点的工作方式，每个任务必须在继续下一个任务之前成功完成，所以首先，敌人成功找到一个随机位置，然后朝着这个位置移动。只有当“移动到”任务完成时，整个行为树才会重新开始并选择一个新的随机位置。
- en: Now, you can move on to the next activity, where you will add to this behavior
    tree in order to have the AI wait between selecting a new random point so that
    the enemy isn't constantly moving.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以继续进行下一个活动，在这个活动中，您将添加到这个行为树，以便让AI在选择新的随机点之间等待，这样敌人就不会不断移动。
- en: 'Activity 13.02: AI Moving to the Player Location'
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.02：AI移动到玩家位置
- en: In the previous exercise, you were able to have the AI enemy character move
    to random locations within the bounds of `Nav Mesh Volume` by using a custom `Task`
    and the `MoveTo` task together.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，您能够让AI敌人角色通过使用自定义“任务”和“移动到”任务一起移动到“导航网格体”范围内的随机位置。
- en: In this activity, you will continue from the previous exercise and update the
    behavior tree. You will take advantage of the `Wait` task by using a `Decorator`,
    and also create your own new custom task to have the AI follow the player character
    and update its position every few seconds.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将继续上一个练习并更新行为树。您将利用“等待”任务使用一个“装饰器”，并创建自己的新自定义任务，让AI跟随玩家角色并每隔几秒更新其位置。
- en: 'The following steps will help you complete this activity:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个活动：
- en: Inside the `BT_EnemyAI` behavior tree that you created in the previous exercise,
    you will continue from where you left off and create a new Task. Do this by selecting
    `New Task` from the toolbar and choosing `BTTask_BlueprintBase`. Name this new
    Task `BTTask_FindPlayer`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您之前创建的“BT_EnemyAI”行为树中，您将继续从上次离开的地方创建一个新任务。通过从工具栏中选择“新任务”并选择“BTTask_BlueprintBase”来完成这个任务。将这个新任务命名为“BTTask_FindPlayer”。
- en: In the `BTTask_FindPlayer` Task, create a new Event called `Event Receive Execute
    AI`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“BTTask_FindPlayer”任务中，创建一个名为“Event Receive Execute AI”的新事件。
- en: Find the `Get Player Character` function in order to get a reference to the
    player; make sure to use `Player Index 0`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到“获取玩家角色”函数，以获取对玩家的引用；确保使用“Player Index 0”。
- en: From the player character, call the `Get Actor Location` function in order to
    find the players' current location.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从玩家角色中调用“获取角色位置”函数，以找到玩家当前的位置。
- en: Create a new Blackboard Key `Selector` variable inside this Task. Name this
    variable `NewLocation`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个任务中创建一个新的黑板键“选择器”变量。将此变量命名为“NewLocation”。
- en: '*Left-click* and drag the `NewLocation` variable into the graph. From this
    variable, search for the `Set Blackboard Value` function as `Vector`.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*并将“NewLocation”变量拖入图表中。从该变量中，搜索“设置黑板数值”函数为“向量”。'
- en: Connect `Set Blackboard Value` as a `Vector` function to the execution pin of
    the Event's `Receive Execute AI` node.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“设置黑板数值”作为“向量”函数连接到事件“接收执行AI”节点的执行引脚。
- en: Add the `Finish Execute` function, ensuring that the Boolean `Success` parameter
    is `True`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加“完成执行”函数，确保布尔值“成功”参数为“True”。
- en: Lastly, connect `Set Blackboard Value` as a `Vector` function to the `Finish
    Execute` function.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将“设置黑板数值”作为“向量”函数连接到“完成执行”函数。
- en: Save and compile the Task `Blueprint` and return to the `BT_EnemyAI` behavior
    tree.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译任务“蓝图”，返回到“BT_EnemyAI”行为树。
- en: Replace the `BTTask_FindLocation` Task with the new `BTTask_FindPlayer` Task
    so that this new Task is now the first task underneath the `Sequence` composite
    node.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用新的“BTTask_FindPlayer”任务替换“BTTask_FindLocation”任务，使得这个新任务现在是“序列”组合节点下的第一个任务。
- en: Add a new `PlaySound` task as the third task underneath the `Sequence` composite
    node by following the custom `BTTask_FindLocation` and `Move To` Tasks.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下自定义“BTTask_FindLocation”和“Move To”任务，在“序列”组合节点下方添加一个新的“播放声音”任务作为第三个任务。
- en: In the `Sound to Play` parameter, add the `Explosion_Cue SoundCue` asset.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“播放声音”参数中，添加“Explosion_Cue SoundCue”资产。
- en: Add an `Is At Location` Decorator to the `PlaySound` Task and ensure that the
    `MovetoLocation` Key is assigned to this `Decorator`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“播放声音”任务中添加一个“是否在位置”装饰器，并确保将“移动到位置”键分配给该装饰器。
- en: Add a new `Wait` Task as the fourth Task underneath the `Sequence` composite
    node following the `PlaySound` Tasks.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“序列”组合节点下方添加一个新的“等待”任务作为第四个任务，跟随“播放声音”任务。
- en: Set the `Wait` task to wait `2.0f` seconds before completing successfully.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“等待”任务设置为等待“2.0f”秒后成功完成。
- en: 'The expected output is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 13.23: Enemy AI following the player and updating to the player'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.23：敌人AI跟随玩家并每2秒更新一次玩家'
- en: location every 2 seconds
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 每2秒
- en: '](img/B16183_13_23.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_23.jpg)'
- en: 'Figure 13.23: Enemy AI following the player and updating to the player location
    every 2 seconds'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.23：敌人AI跟随玩家并每2秒更新一次玩家位置
- en: The enemy AI character will move to the players' last known location in the
    navigable space of the level and pause for `2.0f` seconds between each player
    position.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 敌方AI角色将移动到关卡中可导航空间内玩家的最后已知位置，并在每个玩家位置之间暂停`2.0f`秒。
- en: Note
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: With this activity complete, you have learned to create a new Task that allows
    the AI to find the player location and move to the player's last known position.
    Before moving onto the next set of exercises, remove the `PlaySound` task and
    replace the `BTTask_FindPlayer` task with the `BTTask_FindLocation` task you created
    in *Exercise 13.05*, *Creating a New Behavior Tree Task*. Please refer to *Exercise
    13.05,* *Creating a New Behavior Tree Task* and *Exercise 13.06*, *Creating the
    Behavior Tree Logic*, to ensure the Behavior Tree is returned correctly. You will
    be using the `BTTask_FindLocation` task in the upcoming exercises.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，您已经学会了创建一个新的任务，使AI能够找到玩家位置并移动到玩家的最后已知位置。在进行下一组练习之前，删除`PlaySound`任务，并用您在*Exercise
    13.05*中创建的`BTTask_FindLocation`任务替换`BTTask_FindPlayer`任务。请参考*Exercise 13.05*，*Creating
    a New Behavior Tree Task*和*Exercise 13.06*，*Creating the Behavior Tree Logic*，以确保行为树正确返回。您将在即将进行的练习中使用`BTTask_FindLocation`任务。
- en: In the next exercise, you will address this issue by developing a new `Blueprint`
    actor that will allow you to set up specific positions that the AI can move toward.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将通过开发一个新的`Blueprint`角色来解决这个问题，这将允许您设置AI可以朝向的特定位置。
- en: 'Exercise 13.07: Creating the Enemy Patrol Locations'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.07：创建敌方巡逻位置
- en: 'The current issue with the AI enemy character is that they can move freely
    around the 3D navigable space because the behavior tree allows them to find a
    random location within that space. Instead, the AI needs to be given patrol points
    that you can specify and change in the editor. It will then choose one of these
    patrol points at random to move to. This is what you will do for the `SuperSideScroller`
    game: create patrol points that the enemy AI can move to. This exercise will show
    you how to create these patrol points using a simple *Blueprint* actor. This exercise
    will be performed within the Unreal Engine 4 editor.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 目前AI敌人角色的问题在于它们可以在3D可导航空间中自由移动，因为行为树允许它们在该空间内找到一个随机位置。相反，AI需要被给予您可以在编辑器中指定和更改的巡逻点。然后它将随机选择其中一个巡逻点进行移动。这就是您将为`SuperSideScroller`游戏做的事情：创建敌方AI可以移动到的巡逻点。本练习将向您展示如何使用简单的*Blueprint*角色创建这些巡逻点。本练习将在Unreal
    Engine 4编辑器中执行。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: First, navigate to the `/Enemy/Blueprints/` directory. This is where you will
    create the new `Blueprint` actor that will be used for the AI patrol points.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到`/Enemy/Blueprints/`目录。这是您将创建用于AI巡逻点的新`Blueprint`角色的位置。
- en: In this directory, *right-click* and choose the `Blueprint Class` option by
    *left-clicking* this option from the menu.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录中，*右键单击*并选择`Blueprint Class`选项，然后从菜单中*左键单击*此选项。
- en: 'From the `Pick Parent Class` menu prompt, *left-click* the `Actor` option to
    create a new `Blueprint` based on the `Actor` class:![Figure 13.24: The Actor
    class is the base class for all objects that'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Pick Parent Class`菜单提示中，*左键单击*`Actor`选项，创建一个基于`Actor`类的新`Blueprint`：![图13.24：Actor类是所有对象的基类
- en: can be placed or spawned in the game world
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 可以放置或生成在游戏世界中
- en: '](img/B16183_13_24.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_24.jpg)'
- en: 'Figure 13.24: The Actor class is the base class for all objects that can be
    placed or spawned in the game world'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.24：Actor类是可以放置或生成在游戏世界中的所有对象的基类
- en: Name this new asset `BP_AIPoints` and open this `Blueprint` by *double-clicking*
    the asset in the `Content Browser` interface.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此新资产命名为`BP_AIPoints`，并通过在`Content Browser`界面中*双击*资产来打开此`Blueprint`。
- en: Note
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The interface for `Blueprints` shares many of the same features and layouts
    as other systems, such as `Animation Blueprints` and `Tasks`, so this should all
    look familiar to you.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blueprints`的界面与其他系统（如`Animation Blueprints`和`Tasks`）共享许多相同的功能和布局，因此这些都应该对您来说很熟悉。'
- en: Navigate to the `Variables` tab on the left-hand side of the Blueprint UI and
    *left-click* on the `+Variable` button. Name this variable `Points`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图UI左侧的`Variables`选项卡中导航，*左键单击*`+Variable`按钮。将此变量命名为`Points`。
- en: From the `Variable Type` dropdown, *left-click* and select the `Vector` option.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Variable Type`下拉菜单中，*左键单击*并选择`Vector`选项。
- en: Next, you will need to make this vector variable an `Array` so that you can
    store multiple patrol locations. *Left-click* the yellow icon next to `Vector`
    and *left-click* to select the `Array` option.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要将这个向量变量设置为`Array`，以便可以存储多个巡逻位置。*左键单击*`Vector`旁边的黄色图标，然后*左键单击*选择`Array`选项。
- en: 'The last step for setting up the `Points` vector variable is to enable `Instance
    Editable` and `Show 3D Widget`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`Points`向量变量的最后一步是启用`Instance Editable`和`Show 3D Widget`：
- en: The `Instance Editable` parameter allows this vector variable to be publicly
    visible on the actor when placed in a level, allowing each instance of this actor
    to have this variable available to edit.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Instance Editable`参数允许此向量变量在放置在级别中的角色上公开可见，使得每个此角色的实例都可以编辑此变量。'
- en: '`Show 3D Widget` allows you to position the vector value by using a visible
    3D transform widget in the editor viewport. You will see what this means in the
    next steps of this exercise. It is also important to note that the `Show 3D Widget`
    option is only available for variables that involve an actor transform, such as
    `Vectors` and `Transforms`.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Show 3D Widget`允许您使用编辑器视口中可见的3D变换小部件来定位向量值。您将在本练习的后续步骤中看到这意味着什么。还需要注意的是，`Show
    3D Widget`选项仅适用于涉及演员变换的变量，例如`Vectors`和`Transforms`。'
- en: With the simple actor set up, it is time to place the actor into the level and
    begin setting up the *Patrol Point* locations.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的角色设置完成后，现在是将角色放置到关卡中并开始设置*巡逻点*位置的时候了。
- en: 'Add the `BP_AIPoints` actor Blueprint into your level, as shown in the following screenshot:![Figure
    13.25: The BP_AIPoints actor now in the level'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BP_AIPoints` actor蓝图添加到您的级别中，如下所示：![图13.25：BP_AIPoints actor现在在级别中
- en: '](img/B16183_13_25.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_25.jpg)'
- en: 'Figure 13.25: The BP_AIPoints actor now in the level'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.25：BP_AIPoints actor现在在级别中
- en: With the `BP_AIPoints` actor selected, navigate to its `Details` panel and find
    the `Points` variable.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`BP_AIPoints` actor，导航到其`Details`面板，并找到`Points`变量。
- en: 'Next, you can add a new element to the vector array by *left-clicking* on the
    `+` symbol, as shown here:![Figure 13.26: You can have many elements inside of
    an array, but the larger the array, the more memory is allocated'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以通过*左键单击*`+`符号向向量数组添加新元素，如下所示：![图13.26：数组中可以有许多元素，但数组越大，分配的内存就越多
- en: '](img/B16183_13_26.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_26.jpg)'
- en: 'Figure 13.26: You can have many elements inside of an array, but the larger
    the array, the more memory is allocated'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26：数组中可以有许多元素，但数组越大，分配的内存就越多
- en: 'When you add a new element to the vector array, you will see a 3D widget appear
    that you can then *left-click* to select and move around the level, as shown here:![Figure
    13.27: The first Patrol Point vector location'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您向向量数组添加新元素时，将会出现一个3D小部件，您可以*左键单击*以选择并在级别中移动，如下所示：![图13.27：第一个巡逻点向量位置
- en: '](img/B16183_13_27.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_27.jpg)'
- en: 'Figure 13.27: The first Patrol Point vector location'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27：第一个巡逻点向量位置
- en: Note
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you update the position of the 3D widget that represents the element of the
    vector array, the 3D coordinates will update in the `Details` panel for the `Points`
    variable.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当您更新代表向量数组元素的3D小部件的位置时，`Details`面板中的3D坐标将更新为`Points`变量。
- en: 'Finally, add as many elements into the vector array as you would like for the
    context of your level. Keep in mind that the positions of these patrol points
    should line up so that they make a straight line along the horizontal axis, parallel
    to the direction in which the character will move. The following screenshot shows
    the setup in the example `SideScroller.umap` level included in this exercise:![Figure
    13.28: The example Patrol Point path, as seen'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将尽可能多的元素添加到向量数组中，以适应您级别的上下文。请记住，这些巡逻点的位置应该对齐，使它们沿水平轴成一条直线，与角色移动的方向平行。以下屏幕截图显示了本练习中包含的示例`SideScroller.umap`级别中的设置：![图13.28：示例巡逻点路径，如图所示
- en: in the SideScroller.umap example level
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在SideScroller.umap示例级别中
- en: '](img/B16183_13_28.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_28.jpg)'
- en: 'Figure 13.28: The example Patrol Point path, as seen in the SideScroller.umap
    example level'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28：示例巡逻点路径，如在SideScroller.umap示例级别中所见
- en: Continue to repeat the final step to create multiple patrol points and position
    the 3D widgets as you see fit. You can use the provided `SideScroller.umap` example
    level as a reference on how to set up these `Patrol Points`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续重复最后一步，创建多个巡逻点并根据需要放置3D小部件。您可以使用提供的`SideScroller.umap`示例级别作为设置这些`巡逻点`的参考。
- en: By completing this exercise, you have created a new `Actor` Blueprint that contains
    a `Vector`array of positions that you can now manually set using a 3D widget in
    the editor. With the ability to manually set the *Patrol Point* positions, you
    have full control over where the AI can move to, but there is one problem. There
    is no functionality in place to choose a point from this array and to pass it
    to the behavior tree so that the AI can move between these *Patrol Points*. Before
    you set up this functionality, let's learn a bit more about Vectors and Vector
    Transformation, as this knowledge will prove useful in the next exercise.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经创建了一个包含`Vector`位置数组的新`Actor`蓝图，现在可以使用编辑器中的3D小部件手动设置这些位置。通过手动设置*巡逻点*位置的能力，您可以完全控制AI可以移动到的位置，但是有一个问题。目前还没有功能来从这个数组中选择一个点并将其传递给行为树，以便AI可以在这些*巡逻点*之间移动。在设置这个功能之前，让我们先了解更多关于向量和向量变换的知识，因为这些知识将在下一个练习中证明有用。
- en: Vector Transformation
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量变换
- en: 'Before you jump into the next exercise, it is important that you get to know
    about Vector Transformation and, more importantly, what the `Transform Location`
    function does. When it comes to an actor''s location, there are two ways of thinking
    of its position: in terms of world space and local space. An actor''s position
    in world space is its location relative to the world itself; in more simple terms,
    this is the location where you place the actual actor into the level. An actor''s
    local position is its location relative to either itself or a parent actor.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个练习之前，重要的是您了解一下向量变换，更重要的是了解`Transform Location`函数的作用。当涉及到角色的位置时，有两种思考其位置的方式：世界空间和本地空间。角色在世界空间中的位置是相对于世界本身的位置；更简单地说，这是您将实际角色放置到级别中的位置。角色的本地位置是相对于自身或父级角色的位置。
- en: 'Let''s consider the `BP_AIPoints` actor as an example of what world space and
    local space are. Each of the locations of the `Points` array are local-space Vectors
    because they are positions relative to the world-space position of the `BP_AIPoints`
    actor itself. The following screenshot shows the list of Vectors in the `Points`
    array, as shown in the previous exercise. These values are positions relative
    to the location of the `BP_AIPoints` actor in your level:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`BP_AIPoints` actor作为世界空间和本地空间的示例。`Points`数组的每个位置都是本地空间向量，因为它们是相对于`BP_AIPoints`
    actor本身的世界空间位置的位置。以下屏幕截图显示了`Points`数组中的向量列表，如前面的练习所示。这些值是相对于您级别中`BP_AIPoints`
    actor的位置的位置：
- en: '![Figure 13.29: The local-space position Vectors of the Points array, relative'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.29：Points数组的本地空间位置向量，相对'
- en: to the world-space position of the BP_AIPoints actor
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 到BP_AIPoints actor的世界空间位置
- en: '](img/B16183_13_29.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_29.jpg)'
- en: 'Figure 13.29: The local-space position Vectors of the Points array, relative
    to the world-space position of the BP_AIPoints actor'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.29：相对于BP_AIPoints actor的世界空间位置，Points数组的本地空间位置向量
- en: 'In order to have the enemy AI move to the correct world space location of these
    `Points`, you need to use a function called `Transform Location`. This function
    takes in two parameters:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使敌人AI移动到这些`Points`的正确世界空间位置，您需要使用一个名为`Transform Location`的函数。这个函数接受两个参数：
- en: '`T`: This is the supplied `Transform` that you use to convert the vector location
    parameter from a local-space into a world-space value.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`：这是您用来将向量位置参数从局部空间转换为世界空间值的提供的`Transform`。'
- en: '`Location`: This is the `location` that is to be converted from local space
    to world space.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位置`：这是要从局部空间转换为世界空间的`位置`。'
- en: The result of this vector transformation is then returned as the Return Value
    of the function. You will use this function in the next exercise to return a randomly
    selected vector point from the `Points` array and convert that value from a local-space
    vector into a world-space vector. This new world-space vector will then be used
    to tell the enemy AI where to move relative to the world. Let's implement this
    now.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将向量转换的结果作为函数的返回值。您将在下一个练习中使用此函数，从`Points`数组中返回一个随机选择的向量点，并将该值从局部空间向量转换为世界空间向量。然后，将使用这个新的世界空间向量来告诉敌人AI在世界中如何移动。让我们现在实现这个。
- en: 'Exercise 13.08: Selecting a Random Point in an Array'
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.08：在数组中选择一个随机点
- en: Now that you have more information about Vectors and Vector Transformation,
    you can move onto this exercise, where you will create a simple `Blueprint` function
    to select one of the *Patrol Point* vector locations and transform its vector
    from a local space value into a world space value using a built-in function called
    `Transform Location`. By returning the world space value of the vector position,
    you can then pass this value to the *behavior tree* so that the AI will move to
    the correct position. This exercise will be performed within the Unreal Engine
    4 editor.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对向量和向量转换有了更多的了解，您可以继续进行这个练习，在这个练习中，您将创建一个简单的`蓝图`函数，选择一个*巡逻点*向量位置中的一个，并使用名为`Transform
    Location`的内置函数将其向量从局部空间值转换为世界空间值。通过返回向量位置的世界空间值，然后将这个值传递给*行为树*，使得AI将移动到正确的位置。这个练习将在虚幻引擎4编辑器中进行。
- en: 'The following steps will help you complete this exercise. Let''s start by creating
    the new function:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习。让我们从创建新函数开始：
- en: Navigate back to the `BP_AIPoints` Blueprint and create a new function by *left-clicking*
    the `+` button next to the `Functions` category on the left-hand side of the Blueprint
    editor. Name this function `GetNextPoint`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航回`BP_AIPoints`蓝图，并通过*左键单击*蓝图编辑器左侧的`函数`类别旁边的`+`按钮来创建一个新函数。将此函数命名为`GetNextPoint`。
- en: Before you add logic to this function, select this function by *left-clicking*
    it under the `Functions` category to access its `Details` panel.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为这个函数添加逻辑之前，通过*左键单击*`函数`类别下的函数来选择此函数，以访问其`详细信息`面板。
- en: In the `Details` panel, enable the `Pure` parameter so that this function is
    labeled as a `Pure Function`. You learned about `Pure Functions` in *Chapter 11*,
    *Blend Spaces 1D, Key Bindings, and State Machines*, when working in the Animation
    Blueprint for the player character; the same thing is happening here.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“详细信息”面板中，启用“Pure”参数，以便将此函数标记为“纯函数”。在*第11章*中，*混合空间1D，键绑定和状态机*中，当在玩家角色的动画蓝图中工作时，您了解了“纯函数”；在这里也是一样的。
- en: 'Next, the `GetNextPoint` function needs to return a vector that the behavior
    tree can use to tell the enemy AI where to move to. Add this new output by *left-clicking*
    on the `+` symbol under the `Outputs` category of the `Details` function. Make
    the variable of type `Vector` and give it the name `NextPoint`, as shown in the
    following screenshot:![Figure 13.30: Functions can return multiple variables of
    different types,'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`GetNextPoint`函数需要返回一个向量，行为树可以用来告诉敌人AI要移动到哪里。通过*左键单击*`详细信息`函数类别下的`+`符号来添加这个新的输出。将变量类型设置为`Vector`，并将其命名为`NextPoint`，如下面的屏幕截图所示：![图13.30：函数可以返回不同类型的多个变量，
- en: depending on the needs of your logic
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的逻辑需求
- en: '](img/B16183_13_30.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_30.jpg)'
- en: 'Figure 13.30: Functions can return multiple variables of different types, depending
    on the needs of your logic'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.30：函数可以返回不同类型的多个变量，根据您的逻辑需求
- en: 'When adding an `Output` variable, the function will automatically generate
    a `Return` node and place it into the function graph, as shown in the following
    screenshot. You will use this output to return the new vector patrol point for
    the enemy AI to move to:![Figure 13.31: The automatically generated Return Node
    for the function, including the NewPoint vector output variable'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加`输出`变量时，函数将自动生成一个`Return`节点并将其放入函数图中，如下面的屏幕截图所示。您将使用这个输出来返回敌人AI移动到的新向量巡逻点：![图13.31：函数的自动生成返回节点，包括NewPoint向量输出变量
- en: '](img/B16183_13_31.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_31.jpg)'
- en: 'Figure 13.31: The automatically generated Return Node for the function, including
    the NewPoint vector output variable'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.31：函数的自动生成返回节点，包括NewPoint向量输出变量
- en: Now that the function groundwork is completed, let's start adding the logic.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数的基础工作已经完成，让我们开始添加逻辑。
- en: 'In order to pick a random position, first, you need to find the length of the
    `Points` array. Create a `Getter` of the `Points` vector and from this vector
    variable, *left-click* and drag to search for the `Length` function, as shown
    in the following screenshot:![Figure 13.32: The Length function is a pure function
    that returns the length of the array'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了选择一个随机位置，首先需要找到`Points`数组的长度。创建`Points`向量的`Getter`，从这个向量变量中*左键单击*并拖动以搜索`Length`函数，如下面的屏幕截图所示：![图13.32：Length函数是一个纯函数，返回数组的长度
- en: '](img/B16183_13_32.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_32.jpg)'
- en: 'Figure 13.32: The Length function is a pure function that returns the length
    of the array'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.32：Length函数是一个纯函数，返回数组的长度
- en: 'With the integer output of the `Length` function, *left-click* and drag out
    to use the context-sensitive search to find the `Random Integer` function, as
    shown in the following screenshot. The `Random Integer` function returns a random
    integer between `0` and `Max value`; in this case, this is the `Length` of the
    `Points` vector array:![Figure 13.33: Using Random Integer will allow the function
    to return'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Length`函数的整数输出，*左键单击*并拖动以使用上下文敏感搜索找到`Random Integer`函数，如下截图所示。`Random Integer`函数返回一个在`0`和`最大值`之间的随机整数；在这种情况下，这是`Points`向量数组的`Length`：![图13.33：使用随机整数将允许函数返回
- en: a random vector from the Points vector array
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Points`向量数组中获取一个随机向量
- en: '](img/B16183_13_33.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_33.jpg)'
- en: 'Figure 13.33: Using Random Integer will allow the function to return a random
    vector from the Points vector array'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.33：使用随机整数将允许函数从`Points`向量数组中返回一个随机向量
- en: So far, you are generating a random integer between `0` and the Length of the
    `Points` vector array. Next, you need to find the element of the `Points` vector
    array at the index position of the returned `Random Integer`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你正在生成一个在`Points`向量数组的长度之间的随机整数。接下来，你需要找到返回的`Random Integer`的索引位置处`Points`向量数组的元素。
- en: Do this by creating a new `Getter of the Points` vector array. Then, *left-click*
    and drag to search for the `Get (a copy)` function.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个新的`Points`向量数组的`Getter`。然后，*左键单击*并拖动以搜索`Get (a copy)`函数。
- en: Next, connect the Return Value of the `Random Integer` function to the input
    of the `Get (a copy)` function. This will tell the function to choose a random
    integer and use that integer as the index to return from the `Points` vector array.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`Random Integer`函数的返回值连接到`Get (a copy)`函数的输入。这将告诉函数选择一个随机整数，并使用该整数作为要从`Points`向量数组返回的索引。
- en: Now that you are getting a random vector from the `Points` vector array, you
    need to use the `Transform Location` function in order to convert the location
    from a local space into a world space vector.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你从`Points`向量数组中获取了一个随机向量，你需要使用`Transform Location`函数将位置从局部空间转换为世界空间向量。
- en: As you have learned already, the Vectors in the `Points` array are local space
    positions relative to the position of the `BP_AIPoints` actor in the level. As
    a result, you need to use the `Transform Location` function to convert the randomly
    selected local space vector into a world-space vector so that the AI enemy moves
    to the correct position.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经学到的那样，`Points`数组中的向量是相对于关卡中`BP_AIPoints`角色位置的局部空间位置。因此，你需要使用`Transform
    Location`函数将随机选择的局部空间向量转换为世界空间向量，以便AI敌人移动到正确的位置。
- en: '*Left-click* and drag from the vector output of the `Get (a copy)` function
    and via the context-sensitive search, find the `Transform Location` function.'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*并从`Get (a copy)`函数的向量输出处拖动，并通过上下文敏感搜索，找到`Transform Location`函数。'
- en: Connect the vector output of the `Get (a copy)` function to the `Location` input
    of the `Transform Location` function.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Get (a copy)`函数的向量输出连接到`Transform Location`函数的`Location`输入。
- en: The final step is to use the transform of the Blueprint actor itself as the
    `T` parameter of the `Transform Location` function. Do this by *right-clicking*
    inside the graph and via the context-sensitive search, find the `GetActorTransform`
    function and connect it to the `Transform Location` parameter, `T`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用蓝图角色本身的变换作为`Transform Location`函数的`T`参数。通过*右键单击*图表并通过上下文敏感搜索，找到`GetActorTransform`函数并将其连接到`Transform
    Location`参数`T`。
- en: 'Finally, connect the `Return Value` vector from the `Transform Location` function
    and connect it to the `NewPoint` vector output of the function:![Figure 13.34:
    The final logic set up for the GetNextPoint function'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Transform Location`函数的`Return Value`向量连接到函数的`NewPoint`向量输出：![图13.34：`GetNextPoint`函数的最终逻辑设置
- en: '](img/B16183_13_34.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_34.jpg)'
- en: 'Figure 13.34: The final logic set up for the GetNextPoint function'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.34：`GetNextPoint`函数的最终逻辑设置
- en: Note
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/35jlilb](https://packt.live/35jlilb).'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到前面的截图的全分辨率以便更好地查看：[https://packt.live/35jlilb](https://packt.live/35jlilb)。
- en: By completing this exercise, you have created a new Blueprint function inside
    the `BP_AIPoints` actor that takes a random index from the `Points` array variable,
    transforms it into a world space vector value using the `Transform Location` function,
    and returns this new vector value. You will use this function inside the `BTTask_FindLocation`
    task, inside the AI behavior tree, so that the enemy will move to one of the points
    you have set up. Before you can do this, the enemy AI needs a reference to the
    `BP_AIPoints` actor so that it knows which points it can select from and move
    to. We'll do this in the following exercise.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你在`BP_AIPoints`角色内创建了一个新的蓝图函数，该函数从`Points`数组变量中获取一个随机索引，使用`Transform
    Location`函数将其转换为世界空间向量值，并返回这个新的向量值。你将在AI行为树中的`BTTask_FindLocation`任务中使用这个函数，以便敌人移动到你设置的其中一个点。在你这样做之前，敌人AI需要一个对`BP_AIPoints`角色的引用，以便它知道可以从哪些点中选择并移动。我们将在下一个练习中完成这个任务。
- en: 'Exercise 13.09: Referencing the Patrol Point Actor'
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.09：引用巡逻点角色
- en: Now that the `BP_AIPoints` actor has a function that returns a random transformed
    location from its array of vector patrol points, you need to have the enemy AI
    reference this actor in the level so that it knows which patrol points to reference.
    To do this, you will add a new `Object Reference` variable to the enemy character
    Blueprint and assign the `BP_AIPoints` actor that you placed in your level earlier.
    This exercise will be performed within the Unreal Engine 4 editor. Let's get started
    by adding the *Object Reference*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`BP_AIPoints`角色有一个从其向量巡逻点数组中返回随机转换位置的函数，你需要让敌人AI在关卡中引用这个角色，以便它知道要引用哪些巡逻点。为此，你将在敌人角色蓝图中添加一个新的`Object
    Reference`变量，并分配之前放置在关卡中的`BP_AIPoints`角色。这个练习将在虚幻引擎4编辑器中进行。让我们开始添加*Object Reference*。
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An `Object Reference Variable` stores a reference to a specific class object
    or actor. With this reference variable, you can get access to the publicly exposed
    variables, events, and functions that this class has available.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`对象引用变量`存储对特定类对象或演员的引用。有了这个引用变量，您可以访问此类可用的公开变量、事件和函数。'
- en: 'The following steps will help you complete this exercise:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Navigate to the `/Enemy/Blueprints/` directory and open the enemy character
    Blueprint `BP_Enemy` by *double-clicking* the asset from the `Content Browser`
    interface.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`/Enemy/Blueprints/`目录，并通过*双击*`内容浏览器`界面中的资产打开敌人角色蓝图`BP_Enemy`。
- en: Create a new variable of the `BP_AIPoints` type and make sure the variable type
    is of `Object Reference`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`BP_AIPoints`类型的新变量，并确保变量类型为`对象引用`。
- en: In order to reference the existing `BP_AIPoints` actor in your level, you need
    to make the variable from the previous step a `Public Variable` by enabling the
    `Instance Editable` parameter. Name this variable `Patrol Points`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了引用级别中现有的`BP_AIPoints`演员，您需要通过启用`实例可编辑`参数使上一步的变量成为`公共变量`。将此变量命名为`巡逻点`。
- en: 'Now that you have the object reference set, navigate to your level and select
    your enemy AI. The following screenshot shows the enemy AI placed in the provided
    example level; that is, `SuperSideScroller.umap`. If you don''t have an enemy
    placed in your level, please do so now:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经设置了对象引用，导航到您的级别并选择您的敌人AI。下面的截图显示了放置在提供的示例级别中的敌人AI；即`SuperSideScroller.umap`。如果您的级别中没有放置敌人，请立即这样做：
- en: Note
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Placing an enemy into a level works the same as it does for any other actor
    in Unreal Engine 4\. *Left-click* and drag the enemy AI Blueprint from the Content
    Browser interface into the level.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 将敌人放置到级别中与Unreal Engine 4中的任何其他演员一样。*左键单击*并从内容浏览器界面将敌人AI蓝图拖放到级别中。
- en: '![Figure 13.35: The enemy AI placed in the example level SuperSideScroller.umap'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.35：敌人AI放置在示例级别SuperSideScroller.umap中
- en: '](img/B16183_13_35.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_35.jpg)'
- en: 'Figure 13.35: The enemy AI placed in the example level SuperSideScroller.umap'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.35：敌人AI放置在示例级别SuperSideScroller.umap中
- en: From its `Details` panel, find the `Patrol Points` variable under the `Default`
    category. The last thing to do here is assign the `BP_AIPoints` actor we already
    placed in the level in *Exercise 13.07*, *Creating the Enemy Patrol Locations*.
    Do this by *left-clicking* the dropdown menu for the `Patrol Points` variable
    and finding the actor from the list.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从其`详细信息`面板中，在`默认`类别下找到`巡逻点`变量。这里要做的最后一件事是通过*左键单击*`巡逻点`变量的下拉菜单，并从列表中找到在*练习13.07*中已经放置在级别中的`BP_AIPoints`演员。 '
- en: With this exercise complete, the enemy AI in your level now has a reference
    to the `BP_AIPoints` actor in your level. With a valid reference in place, the
    enemy AI can use this actor to determine which set of points to move between inside
    the `BTTask_FindLocation` task. All that is left to do now is update the `BTTask_FindLocation`
    task so that it uses these points instead of finding a random location.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您的级别中的敌人AI现在引用了级别中的`BP_AIPoints`演员。有了有效的引用，敌人AI可以使用这个演员来确定在`BTTask_FindLocation`任务中移动的点集。现在要做的就是更新`BTTask_FindLocation`任务，使其使用这些点而不是找到一个随机位置。
- en: 'Exercise 13.10: Updating BTTask_FindLocation'
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.10：更新BTTask_FindLocation
- en: The final step in completing the enemy AI patrolling behavior is to replace
    the logic inside `BTTask_FindLocation` so that it uses the `GetNextPoint` function
    from the `BP_AIPoints` actor instead of finding a random location within the navigable
    space of your level. This exercise will be performed within the Unreal Engine
    4 editor.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 完成敌人AI巡逻行为的最后一步是替换`BTTask_FindLocation`中的逻辑，使其使用`BP_AIPoints`演员的`GetNextPoint`函数，而不是在级别的可导航空间内查找随机位置。这个练习将在Unreal
    Engine 4编辑器中执行。
- en: As a reminder, check back and see how the `BTTask_FindLocation` task looked
    at the end of *Exercise 13.05*, *Creating a New Behavior Tree Task*, before you
    start.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，在开始之前，回顾一下*练习13.05*结束时`BTTask_FindLocation`任务的外观。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: 'The first thing to do is take the returned `Controlled Pawn` reference from
    `Event Receive Execute AI` and cast it to `BP_Enemy`, as shown in the following
    screenshot. This way, you can access the `Patrol Points` object reference variable
    from the previous exercise:![Figure 13.36: Casting also ensures that the returned
    Controlled Pawn'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的是从`Event Receive Execute AI`中获取返回的`Controlled Pawn`引用，并将其转换为`BP_Enemy`，如下截图所示。这样，您就可以访问上一个练习中的`巡逻点`对象引用变量：![图13.36：转换还确保返回的Controlled
    Pawn
- en: is of the BP_Enemy class type
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 是BP_Enemy类类型的
- en: '](img/B16183_13_36.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_36.jpg)'
- en: 'Figure 13.36: Casting also ensures that the returned Controlled Pawn is of
    the BP_Enemy class type'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.36：转换还确保返回的Controlled Pawn是BP_Enemy类类型
- en: Next, you can access the `Patrol Points` object reference variable by *left-clicking*
    and dragging from the `As BP Enemy` pin under the cast to `BP_Enemy`, and via
    the context-sensitive search, finding `Patrol Points`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以通过*左键单击*并从`转换为BP_Enemy`下的`As BP Enemy`引脚中拖动，并通过上下文敏感搜索找到`巡逻点`对象引用变量。
- en: From the `Patrol Points` reference, you can *left-click* and drag to search
    for the `GetNextPoint` function that you created in *Exercise 13.08*, *Selecting
    a Random Point in an Array*.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`巡逻点`引用中，您可以*左键单击*并拖动以搜索您在*练习13.08*中创建的`GetNextPoint`函数，*选择数组中的随机点*。
- en: Now, you can connect the `NextPoint` vector output parameter of the `GetNextPoint`
    function to the `Set Blackboard Value as Vector` function and connect the execution
    pins from the cast to the `Set Blackboard Value as Vector` function. Now, each
    time the `BTTask_FindLocation` task is executed, a new random patrol point will
    be set.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以将`GetNextPoint`函数的`NextPoint`向量输出参数连接到`Set Blackboard Value as Vector`函数，并将执行引脚从转换连接到`Set
    Blackboard Value as Vector`函数。现在，每次执行`BTTask_FindLocation`任务时，都会设置一个新的随机巡逻点。
- en: Lastly, connect the `Set Blackboard Value as Vector` function to the `Finish
    Execute` function and manually set the `Success` parameter to `True` so that this
    task will always succeed if the cast is successful.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Set Blackboard Value as Vector`函数连接到`Finish Execute`函数，并手动将`Success`参数设置为`True`，以便如果转换成功，此任务将始终成功。
- en: 'As a failsafe, create a duplicate of `Finish Execute` and connect to the `Cast
    Failed` execution pin of the `Cast` function. Then, set the `Success` parameter
    to `False`. This will act as a failsafe so that if, for any reason, `Controlled
    Pawn` is not of the `BP_Enemy` class, the task will fail. This is a good debugging
    practice to ensure the functionality of the task for its intended AI class:![Figure
    13.37: It is always good practice to account for any casting failures in your
    logic'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为备用方案，创建`Finish Execute`的副本并连接到`Cast`函数的`Cast Failed`执行引脚。然后，将`Success`参数设置为`False`。这将作为备用方案，以便如果由于任何原因`Controlled
    Pawn`不是`BP_Enemy`类，任务将失败。这是一个很好的调试实践，以确保任务对其预期的AI类的功能性：![图13.37：在逻辑中考虑任何转换失败总是一个很好的实践
- en: '](img/B16183_13_37.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_37.jpg)'
- en: 'Figure 13.37: It is always good practice to account for any casting failures
    in your logic'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.37：在逻辑中考虑任何转换失败总是一个很好的实践
- en: Note
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3n58THA](https://packt.live/3n58THA).'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到前面的截图的全分辨率版本以便更好地查看：[https://packt.live/3n58THA](https://packt.live/3n58THA)。
- en: With the `BTTask_FindLocation` task updated to use the random patrol point from
    the `BP_AIPoints` actor reference in the enemy, the enemy AI will now move between
    the patrol points at random.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`BTTask_FindLocation`任务更新为使用敌人中`BP_AIPoints`角色引用的随机巡逻点，敌人AI现在将在巡逻点之间随机移动。
- en: '![Figure 13.38: The enemy AI now moving between the patrol point locations
    in the level'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.38：敌人AI现在在关卡中的巡逻点位置之间移动'
- en: '](img/B16183_13_38.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_38.jpg)'
- en: 'Figure 13.38: The enemy AI now moving between the patrol point locations in
    the level'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.38：敌人AI现在在关卡中的巡逻点位置之间移动
- en: With this exercise complete, the enemy AI now uses the reference to the `BP_AIPoints`
    actor in the level to find and move to the patrol points in the level. Each instance
    of the enemy character in the level can have its own reference to another unique
    instance of the `BP_AIPoints` actor or can share the same instance reference.
    It is up to you how you would like each enemy AI to move throughout the level.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，敌人AI现在使用对关卡中`BP_AIPoints`角色的引用，以找到并移动到关卡中的巡逻点。关卡中的每个敌人角色实例都可以引用另一个唯一实例的`BP_AIPoints`角色，也可以共享相同的实例引用。由您决定每个敌人AI如何在关卡中移动。
- en: Player Projectile
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家抛射物
- en: For the last section of this chapter, you will focus on creating the base of
    the player projectile, which can be used to destroy enemies. The goal is to create
    the appropriate actor class, introduce the required collision and projectile movement
    components to the class, and set up the necessary parameters for the projectile's
    motion behavior.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一部分，您将专注于创建玩家抛射物的基础，该基础可用于摧毁敌人。目标是创建适当的角色类，引入所需的碰撞和抛射物移动组件到类中，并设置抛射物运动行为的必要参数。
- en: For the sake of simplicity, the player projectile will not use gravity, will
    destroy enemies with one hit, and the projectile itself will be destroyed on hitting
    any surface; it will not bounce off walls, for example. The primary goal of the
    player projectile is to have a projectile that the player can spawn and use to
    destroy enemies throughout the level. In this chapter, you will set up the basic
    framework functionality, while in *Chapter 14*, *Spawning the Player Projectile*,
    you will add sound and visual effects. Let's get started by creating the player
    projectile class.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，玩家的抛射物将不使用重力，将在一次命中时摧毁敌人，并且抛射物本身将在撞击任何表面时被摧毁；例如，它不会从墙上弹开。玩家抛射物的主要目标是让玩家可以生成并用来摧毁整个关卡中的敌人的抛射物。在本章中，您将设置基本的框架功能，而在*第14章*中，*生成玩家抛射物*，您将添加声音和视觉效果。让我们开始创建玩家抛射物类。
- en: 'Exercise 13.11: Creating the Player Projectile'
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.11：创建玩家抛射物
- en: Up until this point, we have been working on in the Unreal Engine 4 editor to
    create our enemy AI. For the player projectile, we will be using C++ and Visual
    Studio to create this new class. The player projectile will allow the player to
    destroy enemies that are placed in the level. This projectile will have a short
    lifespan, travel at a high speed, and will collide with both enemies and the environment.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在虚幻引擎4编辑器中工作，创建我们的敌人AI。对于玩家抛射物，我们将使用C++和Visual Studio来创建这个新类。玩家抛射物将允许玩家摧毁放置在关卡中的敌人。这个抛射物将有一个短暂的寿命，以高速行进，并且将与敌人和环境发生碰撞。
- en: The goal of this exercise is to set up the base actor class for the player projectile
    and begin outlining the functions and components needed in the header file for
    the projectile.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目标是为玩家的抛射物设置基础角色类，并开始在抛射物的头文件中概述所需的函数和组件。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: First, you will need to create a new C++ class using the `Actor` class as the
    parent class for the player projectile. Next, name this new actor class `PlayerProjectile`
    and *left-click* on the `Create Class` option at the bottom-right of the menu
    prompt.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要使用`Actor`类作为玩家抛射物的父类来创建一个新的C++类。接下来，将这个新的actor类命名为`PlayerProjectile`，并*左键单击*菜单提示的底部右侧的`Create
    Class`选项。
- en: After creating the new class, Visual Studio will generate the required source
    and header files for the class and open these files for you. The actor base class
    comes included with a handful of default functions that you will not need for
    the player projectile.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新类后，Visual Studio将为该类生成所需的源文件和头文件，并为您打开这些文件。actor基类包含了一些默认函数，对于玩家抛射物来说是不需要的。
- en: 'Find the following lines of code inside the `PlayerProjectile.h` file and remove
    them:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.h`文件中找到以下代码行并删除它们：
- en: '[PRE3]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These lines of code represent the declarations of the `Tick()` and `BeginPlay()`
    functions that are included in every Actor-based class by default. The `Tick()`
    function is called on every frame and allows you to perform logic on every frame,
    which can get expensive, depending on what you are trying to do. The `BeginPlay()`
    function is called when this actor is initialized and play has started. This can
    be used to perform logic on the actor as soon as it enters the world. These functions
    are being removed because they are not required for `Player Projectile` and will
    just clutter the code.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行代表了默认情况下包含在每个基于Actor的类中的`Tick()`和`BeginPlay()`函数的声明。`Tick()`函数在每一帧都会被调用，允许您在每一帧上执行逻辑，这可能会变得昂贵，取决于您要做什么。`BeginPlay()`函数在此actor被初始化并开始播放时被调用。这可以用来在actor进入世界时立即执行逻辑。这些函数被删除是因为它们对于`Player
    Projectile`不是必需的，只会使代码混乱。
- en: 'After removing these lines from the `PlayerProjectile.h` header file, you can
    now remove the following lines from the `PlayerProjectile.cpp` source files as
    well:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.h`头文件中删除这些行后，您还可以从`PlayerProjectile.cpp`源文件中删除以下行：
- en: '[PRE4]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These lines of code represent the function implementations of the two functions
    you removed in the previous step; that is, `Tick()` and `BeginPlay()`. Again,
    these are being removed because they serve no purposes for `Player Projectile`
    and just add clutter to the code. Additionally, without the declarations inside
    the `PlayerProjectile.h` header file, you would receive a compilation error if
    you were to try to compile this code as is. The only remaining function will be
    the constructor for the projectile class, which you will use to initialize the
    components of the projectile in the next exercise. Now that you have removed the
    unnecessary code from the `PlayerProjectile` class, let's add the functions and
    components required for the projectile.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行代表了您在上一步中删除的两个函数的函数实现；也就是说，`Tick()`和`BeginPlay()`。同样，这些被删除是因为它们对于`Player
    Projectile`没有任何作用，只会给代码增加混乱。此外，如果没有在`PlayerProjectile.h`头文件中声明，您将无法编译这些代码。唯一剩下的函数将是抛射物类的构造函数，您将在下一个练习中用它来初始化抛射物的组件。现在您已经从`PlayerProjectile`类中删除了不必要的代码，让我们添加抛射物所需的函数和组件。
- en: 'Inside the `PlayerProjectile.h` header file, add the following components.
    Let''s discuss these components in detail:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.h`头文件中，添加以下组件。让我们详细讨论这些组件：
- en: '[PRE5]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are three different components you are adding here. The first is the collision
    component, which you will use for the projectile to recognize collisions with
    enemies and environment assets. The next component is the projectile movement
    component, which you should be familiar with from the last project. This will
    allow the projectile to behave like a projectile. The final component is the static
    mesh component. You will use this to give this projectile a visual representation
    so that it can be seen in-game.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在添加三个不同的组件。首先是碰撞组件，您将用它来使抛射物识别与敌人和环境资产的碰撞。接下来的组件是抛射物移动组件，您应该从上一个项目中熟悉它。这将允许抛射物表现得像一个抛射物。最后一个组件是静态网格组件。您将使用它来为这个抛射物提供一个视觉表示，以便在游戏中看到它。
- en: 'Next, add the following function signature code to the `PlayerProjectile.h`
    header file, under the `public` access modifier:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下函数签名代码添加到`PlayerProjectile.h`头文件中，在`public`访问修饰符下：
- en: '[PRE6]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This final event declaration will allow the player projectile to respond to
    `OnHit` events from the `CollisionComp` component you created in the previous
    step.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的事件声明将允许玩家抛射物响应您在上一步中创建的`CollisionComp`组件的`OnHit`事件。
- en: 'Now, in order to have this code compile, you will need to implement the function
    from the previous step in the `PlayerProjectile.cpp` source file. Add the following
    code:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了使这段代码编译，您需要在`PlayerProjectile.cpp`源文件中实现上一步的函数。添加以下代码：
- en: '[PRE7]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `OnHit` event provides you with a lot of information about the collision
    that takes place. The most important parameter that you will be working with in
    the next exercise is the `OtherActor` parameter. The `OtherActor` parameter will
    tell you the actor in which this `OnHit` event is responding to. This will allow
    you to know if this other actor was an enemy. You will use this information to
    destroy the enemies when the projectile hits them.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnHit`事件为您提供了关于发生的碰撞的大量信息。您将在下一个练习中使用的最重要的参数是`OtherActor`参数。`OtherActor`参数将告诉您此`OnHit`事件响应的actor。这将允许您知道这个其他actor是否是敌人。当抛射物击中它们时，您将使用这些信息来摧毁敌人。'
- en: Lastly, navigate back into the Unreal Engine editor and *left-click* the `Compile`
    option to compile the new code.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回虚幻引擎编辑器，*左键单击*`Compile`选项来编译新代码。
- en: With this exercise complete, you now have the framework ready for the `Player
    Projectile` class. The class has the required components for `Projectile Movement`,
    `Collision`, and `Static Mesh`, as well as the event signature ready for the `OnHit`
    collision so that the projectile can recognize collisions with other actors.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您现在已经为`Player Projectile`类准备好了框架。该类具有`Projectile Movement`、`Collision`和`Static
    Mesh`所需的组件，以及为`OnHit`碰撞准备的事件签名，以便弹丸可以识别与其他角色的碰撞。
- en: In the next exercise, you will continue to customize and enable parameters for
    `Player Projectile` so that it behaves the way you need it to for the `SuperSideScroller`
    project.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将继续自定义并启用`Player Projectile`的参数，以使其在`SuperSideScroller`项目中按您的需求运行。
- en: 'Exercise 13.12: Initializing Player Projectile Settings'
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.12：初始化玩家投射物设置
- en: Now that the framework of the `PlayerProjectile` class is in place, it's time
    to update the constructor of this class with the default settings needed for the
    projectile so that it moves and behaves as you want it to. In order to do this,
    you will need to initialize the `Projectile Movement`, `Collision`, and `Static
    Mesh` components.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`PlayerProjectile`类的框架已经就位，是时候更新该类的构造函数，以便为弹丸设置所需的默认设置，使其移动和行为符合您的要求。为此，您需要初始化`Projectile
    Movement`、`Collision`和`Static Mesh`组件。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Open Visual Studio and navigate to the `PlayerProjectile.cpp` source file.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并导航到`PlayerProjectile.cpp`源文件。
- en: 'Before adding any code to the constructor, include the following files inside
    the `PlayerProjectile.cpp` source file:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加任何代码之前，在`PlayerProjectile.cpp`源文件中包括以下文件：
- en: '[PRE8]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These header files will allow you to initialize and update the parameters of
    the projectile movement component, the sphere collision component, and the static
    mesh component respectively. Without these files included, the `PlayerProjectile`
    class wouldn't know how to handle these components and how to access their functions
    and parameters.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头文件将允许您初始化和更新弹丸移动组件、球体碰撞组件和静态网格组件的参数。如果不包括这些文件，`PlayerProjectile`类将不知道如何处理这些组件以及如何访问它们的函数和参数。
- en: 'By default, the `APlayerProjectile::APlayerProjectile()` constructor function
    includes the following line:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`APlayerProjectile::APlayerProjectile()`构造函数包括以下行：
- en: '[PRE9]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line of code can be removed entirely because it is not required in the
    player projectile.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码可以完全删除，因为在玩家投射物中不需要。
- en: 'In the `PlayerProjectile.cpp` source file, add the following lines to the `APlayerProjectile::APlayerProjectile()`
    constructor:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.cpp`源文件中，将以下行添加到`APlayerProjectile::APlayerProjectile()`构造函数中：
- en: '[PRE10]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first line initializes the sphere collision component and assigns it to
    the `CollisionComp` variable you created in the previous exercise. `Sphere Collision
    Component` has a parameter called `InitSphereRadius`. This will determine the
    size, or radius, of the collision actor by default; in this case, a value of `15.0f`
    works well. Next, set `Collision Profile Name` for the collision component to
    `BlockAll` so that the collision profile is set to `BlockAll`, which means this
    collision component will respond to `OnHit` when it collides with other objects.
    Lastly, the last line you added allows the `OnComponentHit` event to respond with
    the function you created in the previous exercise:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行初始化了球体碰撞组件，并将其分配给您在上一个练习中创建的`CollisionComp`变量。`Sphere Collision Component`有一个名为`InitSphereRadius`的参数。这将确定碰撞角色的大小或半径，默认情况下，值为`15.0f`效果很好。接下来，将碰撞组件的`Collision
    Profile Name`设置为`BlockAll`，以便将碰撞配置文件设置为`BlockAll`，这意味着当它与其他对象发生碰撞时，此碰撞组件将响应`OnHit`。最后，您添加的最后一行允许`OnComponentHit`事件使用您在上一个练习中创建的函数进行响应：
- en: '[PRE11]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This means that when the collision component receives the `OnComponentHit` event
    from a collision event, it will respond with that function; however, this function
    is empty at the moment. You will add code to this function later in this chapter.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当碰撞组件接收到来自碰撞事件的`OnComponentHit`事件时，它将使用该函数进行响应；但是，此函数目前为空。您将在本章后面的部分向此函数添加代码。
- en: 'The last thing to do with `Collision Component` is to set this component as
    the `root` component of the player projectile actor. Add the following line of
    code in the constructor, after the lines from *Step 4*:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Collision Component`的最后一件事是将该组件设置为玩家投射物角色的`root`组件。在构造函数中，在*Step 4*的行之后添加以下代码行：'
- en: '[PRE12]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the collision component set up and ready, let''s move on to the `Projectile
    Movement` component. Add the following lines to the constructor:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 碰撞组件设置好并准备好后，让我们继续进行`Projectile Movement`组件。将以下行添加到构造函数中：
- en: '[PRE13]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This first line initializes `Projectile Movement Component` and assigns it to
    the `ProjectileMovement` variable you created in the previous exercise. Next,
    we set `CollisionComp` as the updated component of the projectile movement component.
    The reason we're doing this is because the `Projectile Movement` component will
    use the `root` component of the actor as the component to move. Then, you are
    setting the gravity scale of the projectile to `0.0f` because the player projectile
    should not be affected by gravity; the behavior should allow the projectile to
    travel at the same speed, at the same height, and not be influenced by gravity.
    Lastly, you are setting both the `InitialSpeed` and `MaxSpeed` parameters to `500.0f`.
    This will allow the projectile to instantly start moving at this speed and remain
    at this speed for the duration of its lifetime. The player projectile will not
    support any kind of acceleration motion.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行初始化了`Projectile Movement Component`并将其分配给你在上一个练习中创建的`ProjectileMovement`变量。接下来，我们将`CollisionComp`设置为投射物移动组件的更新组件。我们这样做的原因是因为`Projectile
    Movement`组件将使用角色的`root`组件作为移动的组件。然后，你将投射物的重力比例设置为`0.0f`，因为玩家投射物不应受重力影响；其行为应该允许投射物以相同的速度、相同的高度移动，并且不受重力影响。最后，你将`InitialSpeed`和`MaxSpeed`参数都设置为`500.0f`。这将使投射物立即以这个速度开始移动，并在其寿命期间保持这个速度。玩家投射物不支持任何形式的加速运动。
- en: 'With the projectile movement component initialized and set up, it is time to
    do the same for `Static Mesh Component`. Add the following code after the lines
    from the previous step:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化并设置了投射物移动组件后，现在是为`Static Mesh Component`做同样的操作的时候了。在上一步的代码行之后添加以下代码：
- en: '[PRE14]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This first line initializes `Static Mesh Component` and assigns it to the `MeshComp`
    variable you created in the previous exercise. Then, you attach this static mesh
    component to `RootComponent` using a struct called `FAttachmentTransformRules`
    to ensure that the `Static Mesh Component` keeps its world transform during the
    attachment which is `CollisionComp` from *Step 5* of this exercise.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行初始化了`Static Mesh Component`并将其分配给你在上一个练习中创建的`MeshComp`变量。然后，使用名为`FAttachmentTransformRules`的结构将这个静态网格组件附加到`RootComponent`，以确保`Static
    Mesh Component`在附加时保持其世界变换，这是这个练习的*步骤5*中的`CollisionComp`。
- en: Note
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information about the `FAttachmentTransformRules` struct
    here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.html).'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到有关`FAttachmentTransformRules`结构的更多信息：[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.html)。
- en: 'Lastly, let''s give `Player Projectile` an initial life span of `3` seconds
    so that the projectile will automatically be destroyed if it doesn''t collide
    with anything after this time. Add the following code to the end of the constructor:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们给`Player Projectile`一个初始寿命为`3`秒，这样如果投射物在这段时间内没有与任何物体碰撞，它将自动销毁。在构造函数的末尾添加以下代码：
- en: '[PRE15]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Lastly, navigate back into the Unreal Engine editor and *left-click* the `Compile`
    option to compile the new code.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回虚幻引擎编辑器，*左键单击*`Compile`选项来编译新代码。
- en: By completing this exercise, you have set up the groundwork for `Player Projectile`
    so that it can be created as a *Blueprint* actor inside the editor. All three
    required components are initialized and contain the default parameters that you
    want for this projectile. All we need to do now is create the *Blueprint* from
    this class to see it in the level.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经为`Player Projectile`设置了基础工作，以便它可以在编辑器中作为*Blueprint* actor创建。所有三个必需的组件都已初始化，并包含了你想要的这个投射物的默认参数。现在我们只需要从这个类创建*Blueprint*来在关卡中看到它。
- en: 'Activity 13.03: Creating the Player Projectile Blueprint'
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.03：创建玩家投射物蓝图
- en: 'To conclude this chapter, you will create the `Blueprint` actor from the new
    `PlayerProjectile` class and customize this actor so that it uses a placeholder
    shape for `Static Mesh Component` for debugging purposes. This allows you to view
    the projectile in the game world. Then, you will add a `UE_LOG()` function to
    the `APlayerProjectile::OnHit` function inside the `PlayerProjectile.cpp` source
    file so that you can ensure that this function is called when the projectile comes
    into contact with an object in the level. You will need to perform the following steps:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，你将从新的`PlayerProjectile`类创建`Blueprint` actor，并自定义这个actor，使其使用一个用于调试目的的`Static
    Mesh Component`的占位形状。这样可以在游戏世界中查看投射物。然后，你将在`PlayerProjectile.cpp`源文件中的`APlayerProjectile::OnHit`函数中添加一个`UE_LOG()`函数，以确保当投射物与关卡中的物体接触时调用这个函数。你需要执行以下步骤：
- en: Inside the `Content Browser` interface, create a new folder called `Projectile`
    in the `/MainCharacter` directory.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`界面中，在`/MainCharacter`目录中创建一个名为`Projectile`的新文件夹。
- en: In this directory, create a new Blueprint from the `PlayerProjectile` class,
    which you created in *Exercise 13.11*, *Creating the Player Projectile*. Name
    this Blueprint `BP_PlayerProjectile`.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个目录中，从你在*练习13.11*中创建的`PlayerProjectile`类创建一个新的蓝图，命名为`BP_PlayerProjectile`。
- en: Open `BP_PlayerProjectile` and navigate to its components. Select the `MeshComp`
    component to access its settings.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_PlayerProjectile`并导航到它的组件。选择`MeshComp`组件以访问其设置。
- en: Add the `Shape_Sphere` mesh to the Static Mesh parameter of the `MeshComp `component.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Shape_Sphere`网格添加到`MeshComp`组件的静态网格参数中。
- en: 'Update the Transform of `MeshComp` so that it fits the `Scale and Location
    of the CollisionComp` component. Use the following values:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`MeshComp`的变换，使其适应`CollisionComp`组件的比例和位置。使用以下值：
- en: '[PRE16]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Compile and save the `BP_PlayerProjectile` Blueprint.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并保存`BP_PlayerProjectile`蓝图。
- en: Navigate to the `PlayerProjectile.cpp` source file in Visual Studio and find
    the `APlayerProjectile::OnHit` function.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中导航到`PlayerProjectile.cpp`源文件，并找到`APlayerProjectile::OnHit`函数。
- en: Inside the function, implement the `UE_LOG` call so that the logged line is
    of `LogTemp`, `Warning log level`, and displays the text `HIT`. `UE_LOG` was covered
    back in *Chapter 11*, *Blend Spaces 1D, Key Bindings, and State Machines*.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，实现`UE_LOG`调用，以便记录的行是`LogTemp`，`Warning log level`，并显示文本`HIT`。`UE_LOG`在*第11章*，*Blend
    Spaces 1D，Key Bindings和State Machines*中有所涉及。
- en: Compile your code changes and navigate to the level where you placed the `BP_PlayerProjectile`
    actor in the previous exercise. If you don't have this actor added to the level,
    do so now.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码更改并导航到您在上一个练习中放置`BP_PlayerProjectile`角色的级别。如果您还没有将此角色添加到级别中，请立即添加。
- en: Before testing, make sure to open the Output Log in the `Window` option. From
    the `Window` dropdown, hover over the `Developers Tools` option and *left-click*
    to select `Output Log`.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试之前，请确保在`Window`选项中打开`Output Log`。从`Window`下拉菜单中，悬停在`Developers Tools`选项上，*左键单击*以选择`Output
    Log`。
- en: Use `PIE` and watch out for the log warning inside `Output Log` when the projectile
    collides with something.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PIE`并在抛射物与某物发生碰撞时注意`Output Log`中的日志警告。
- en: 'The following is the expected output:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 13.39: Scale of the MeshComp better fits the size of the Collision
    Comp'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.39：MeshComp的比例更适合Collision Comp的大小'
- en: '](img/B16183_13_39.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_39.jpg)'
- en: 'Figure 13.39: Scale of the MeshComp better fits the size of the Collision Comp'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.39：MeshComp的比例更适合Collision Comp的大小
- en: 'The log warning should be as follows:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 日志警告应如下所示：
- en: '![Figure 13.40: When the projectile hits an object, the text HIT is shown in
    the Output Log'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.40：当抛射物击中物体时，在输出日志中显示文本HIT'
- en: '](img/B16183_13_40.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_13_40.jpg)'
- en: 'Figure 13.40: When the projectile hits an object, the text HIT is shown in
    the Output Log'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.40：当抛射物击中物体时，在输出日志中显示文本HIT
- en: With this final activity complete, `Player Projectile` is ready for the next
    chapter, where you will spawn this projectile when the player uses the `Throw`
    action. You will update the `APlayerProjectile::OnHit` function so that it destroys
    the enemy that it collides with and becomes an effective offensive tool for the
    player to use against the enemies.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这最后一个活动后，`Player Projectile`已准备好进入下一章，在这一章中，当玩家使用`Throw`动作时，您将生成此抛射物。您将更新`APlayerProjectile::OnHit`函数，以便它销毁与之发生碰撞的敌人，并成为玩家用来对抗敌人的有效进攻工具。
- en: Note
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Summary
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use the different aspects of the AI tools
    offered by Unreal Engine 4, including Blackboards, behavior trees, and AI Controllers.
    With a combination of both custom created Tasks and default Tasks provided by
    Unreal Engine 4, and with a Decorator, you were able to have the enemy AI navigate
    within the bounds of the Nav Mesh you added to your own level.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用Unreal Engine 4提供的AI工具的不同方面，包括黑板、行为树和AI控制器。通过自定义创建的任务和Unreal Engine
    4提供的默认任务的组合，并使用装饰器，您能够使敌人AI在您自己级别中添加的Nav Mesh的范围内导航。
- en: On top of this, you created a new Blueprint actor that allows you to add patrol
    points with the use of a `Vector` array variable. You then added a new function
    to this actor that selects one of these points at random, converts its location
    from local space into world space, and then returns this new value for use by
    the enemy character.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，您还创建了一个新的蓝图角色，允许您使用`Vector`数组变量添加巡逻点。然后，您为此角色添加了一个新函数，该函数随机选择其中一个点，将其位置从局部空间转换为世界空间，然后返回此新值供敌人角色使用。
- en: With the ability to randomly select a Patrol Point, you updated the custom `BTTask_FindLocation`
    task to find and move to the selected Patrol Point, allowing the enemy to move
    from each Patrol Point at random. This brought the enemy AI character to a whole
    new level of interaction with the player and the environment.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 通过能够随机选择巡逻点，您更新了自定义的`BTTask_FindLocation`任务，以查找并移动到所选的巡逻点，使敌人能够从每个巡逻点随机移动。这将使敌人AI角色与玩家和环境的互动达到一个全新的水平。
- en: Lastly, you created the Player Projectile that the player will be able to use
    in order to destroy enemies within the environment. You took advantage of both
    `Projectile Movement Component` and `Sphere Component` to allow for both projectile
    movement and to recognize and respond to collisions within the environment.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您创建了玩家抛射物，玩家将能够使用它来摧毁环境中的敌人。您利用了`Projectile Movement Component`和`Sphere Component`，以允许抛射物移动并识别和响应环境中的碰撞。
- en: With the Player Projectile in a functional state, it is time to move on to the
    next chapter, where you will use `Anim Notifies` to spawn the projectile when
    the player uses the `Throw` action.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 随着玩家抛射物处于功能状态，现在是时候进入下一章了，在这一章中，您将使用`Anim Notifies`在玩家使用`Throw`动作时生成抛射物。
