["```cpp\nchrome.exe      1044   Running    marius.bancila    25180  32-bit\nchrome.exe      10100  Running    marius.bancila   227756  32-bit\ncmd.exe         512    Running    SYSTEM               48  64-bit\nexplorer.exe    7108   Running    marius.bancila    29529  64-bit\nskype.exe       22456  Suspended  marius.bancila      656  64-bit\n```", "```cpp\n 1\n 1   1\n 1   2   1\n 1   3   3   1\n1   4   6   4   1\n```", "```cpp\nunsigned int number_of_digits(unsigned int const i)\n{\n   return i > 0 ? (int)log10((double)i) + 1 : 1;\n}\n\nvoid print_pascal_triangle(int const n)\n{\n   for (int i = 0; i < n; i++) \n   {\n      auto x = 1;\n      std::cout << std::string((n - i - 1)*(n / 2), ' ');\n      for (int j = 0; j <= i; j++) \n      {\n         auto y = x;\n         x = x * (i - j) / (j + 1);\n         auto maxlen = number_of_digits(x) - 1;\n         std::cout << y << std::string(n - 1 - maxlen - n%2, ' ');\n      }\n      std::cout << std::endl;\n   }\n}\n```", "```cpp\nint main()\n{\n   int n = 0;\n   std::cout << \"Levels (up to 10): \";\n   std::cin >> n;\n   if (n > 10)\n      std::cout << \"Value too large\" << std::endl;\n   else\n      print_pascal_triangle(n);\n}\n```", "```cpp\nenum class procstatus {suspended, running};\nenum class platforms {p32bit, p64bit};\n\nstruct procinfo\n{\n   int         id;\n   std::string name;\n   procstatus  status;\n   std::string account;\n   size_t      memory;\n   platforms   platform;\n};\n```", "```cpp\nstd::string status_to_string(procstatus const status)\n{\n   if (status == procstatus::suspended) return \"suspended\";\n   else return \"running\";\n}\n\nstd::string platform_to_string(platforms const platform)\n{\n   if (platform == platforms::p32bit) return \"32-bit\";\n   else return \"64-bit\";\n}\n```", "```cpp\nvoid print_processes(std::vector<procinfo> processes)\n{\n   std::sort(\n      std::begin(processes), std::end(processes),\n      [](procinfo const & p1, procinfo const & p2) {\n         return p1.name < p2.name; });\n\n   for (auto const & pi : processes)\n   {\n      std::cout << std::left << std::setw(25) << std::setfill(' ')\n                << pi.name;\n      std::cout << std::left << std::setw(8) << std::setfill(' ')\n                << pi.id;\n      std::cout << std::left << std::setw(12) << std::setfill(' ')\n                << status_to_string(pi.status);\n      std::cout << std::left << std::setw(15) << std::setfill(' ')\n                << pi.account;\n      std::cout << std::right << std::setw(10) << std::setfill(' ')\n                << (int)(pi.memory/1024);\n      std::cout << std::left << ' ' << platform_to_string(pi.platform);\n      std::cout << std::endl;\n   }\n}\n```", "```cpp\nint main()\n{\n   using namespace std::string_literals;\n\n   std::vector<procinfo> processes\n   {\n      {512, \"cmd.exe\"s, procstatus::running, \"SYSTEM\"s, \n            148293, platforms::p64bit },\n      {1044, \"chrome.exe\"s, procstatus::running, \"marius.bancila\"s, \n            25180454, platforms::p32bit},\n      {7108, \"explorer.exe\"s, procstatus::running, \"marius.bancila\"s,  \n            2952943, platforms::p64bit },\n      {10100, \"chrome.exe\"s, procstatus::running, \"marius.bancila\"s, \n            227756123, platforms::p32bit},\n      {22456, \"skype.exe\"s, procstatus::suspended, \"marius.bancila\"s, \n            16870123, platforms::p64bit }, \n   };\n\n   print_processes(processes);\n}\n```", "```cpp\nnamespace fs = std::experimental::filesystem;\n\nvoid remove_empty_lines(fs::path filepath)\n{\n   std::ifstream filein(filepath.native(), std::ios::in);\n   if (!filein.is_open())\n      throw std::runtime_error(\"cannot open input file\");\n\n   auto temppath = fs::temp_directory_path() / \"temp.txt\";\n   std::ofstream fileout(temppath.native(), \n   std::ios::out | std::ios::trunc);\n   if (!fileout.is_open())\n      throw std::runtime_error(\"cannot create temporary file\");\n\n   std::string line;\n   while (std::getline(filein, line))\n   {\n      if (line.length() > 0 &&\n      line.find_first_not_of(' ') != line.npos)\n      {\n         fileout << line << '\\n';\n      }\n   }\n   filein.close();\n   fileout.close();\n\n   fs::remove(filepath);\n   fs::rename(temppath, filepath);\n}\n```", "```cpp\nnamespace fs = std::experimental::filesystem;\n\nstd::uintmax_t get_directory_size(fs::path const & dir,\n                                  bool const follow_symlinks = false)\n{\n   auto iterator = fs::recursive_directory_iterator(\n      dir,\n      follow_symlinks ? fs::directory_options::follow_directory_symlink : \n                        fs::directory_options::none);\n\n   return std::accumulate(\n      fs::begin(iterator), fs::end(iterator),\n      0ull,\n      [](std::uintmax_t const total,\n         fs::directory_entry const & entry) {\n             return total + (fs::is_regular_file(entry) ?\n                    fs::file_size(entry.path()) : 0);\n   });\n}\n\nint main()\n{\n   std::string path;\n   std::cout << \"Path: \";\n   std::cin >> path;\n   std::cout << \"Size: \" << get_directory_size(path) << std::endl;\n}\n```", "```cpp\nnamespace fs = std::experimental::filesystem;\nnamespace ch = std::chrono;\n\ntemplate <typename Duration>\nbool is_older_than(fs::path const & path, Duration const duration)\n{\n   auto ftimeduration = fs::last_write_time(path).time_since_epoch();\n   auto nowduration = (ch::system_clock::now() - duration)\n                      .time_since_epoch();\n   return ch::duration_cast<Duration>(nowduration - ftimeduration)\n                      .count() > 0;\n}\n\ntemplate <typename Duration>\nvoid remove_files_older_than(fs::path const & path, \n                             Duration const duration)\n{\n   try\n   {\n      if (fs::exists(path))\n      {\n         if (is_older_than(path, duration))\n         {\n            fs::remove(path);\n         }\n         else if(fs::is_directory(path))\n         {\n            for (auto const & entry : fs::directory_iterator(path))\n            {\n               remove_files_older_than(entry.path(), duration);\n            }\n         }\n      }\n   }\n   catch (std::exception const & ex)\n   {\n      std::cerr << ex.what() << std::endl;\n   }\n}\n```", "```cpp\nint main()\n{\n   using namespace std::chrono_literals;\n\n#ifdef _WIN32\n   auto path = R\"(..\\Test\\)\";\n#else\n   auto path = R\"(../Test/)\";\n#endif\n\n   remove_files_older_than(path, 1h + 20min);\n}\n```", "```cpp\nnamespace fs = std::experimental::filesystem;\n\nstd::vector<fs::directory_entry> find_files(\n   fs::path const & path,\n   std::string_view regex)\n{\n   std::vector<fs::directory_entry> result;\n   std::regex rx(regex.data());\n\n   std::copy_if(\n      fs::recursive_directory_iterator(path),\n      fs::recursive_directory_iterator(),\n      std::back_inserter(result),\n      [&rx](fs::directory_entry const & entry) {\n         return fs::is_regular_file(entry.path()) &&\n                std::regex_match(entry.path().filename().string(), rx);\n   });\n\n   return result;\n}\n```", "```cpp\nint main()\n{\n   auto dir = fs::temp_directory_path();\n   auto pattern = R\"(wct[0-9a-zA-Z]{3}\\.tmp)\";\n   auto result = find_files(dir, pattern);\n\n   for (auto const & entry : result)\n   {\n      std::cout << entry.path().string() << std::endl;\n   }\n}\n```", "```cpp\nnamespace fs = std::experimental::filesystem;\n\nclass logger\n{\n   fs::path logpath;\n   std::ofstream logfile;\npublic:\n   logger()\n   {\n      auto name = uuids::to_string(uuids::uuid_random_generator{}());\n      logpath = fs::temp_directory_path() / (name + \".tmp\");\n      logfile.open(logpath.c_str(), std::ios::out|std::ios::trunc);\n   }\n\n   ~logger() noexcept\n   {\n      try {\n         if(logfile.is_open()) logfile.close();\n         if (!logpath.empty()) fs::remove(logpath);\n      }\n      catch (...) {}\n   }\n\n   void persist(fs::path const & path)\n   {\n      logfile.close();\n      fs::rename(logpath, path);\n      logpath.clear();\n   }\n\n   logger& operator<<(std::string_view message)\n   {\n      logfile << message.data() << '\\n';\n      return *this;\n   }\n};\n```", "```cpp\nint main()\n{\n   logger log;\n   try \n   {\n      log << \"this is a line\" << \"and this is another one\";\n      throw std::runtime_error(\"error\");\n   }\n   catch (...) \n   {\n      log.persist(R\"(lastlog.txt)\");\n   }\n}\n```"]