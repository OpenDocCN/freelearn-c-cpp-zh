- en: Detecting External Libraries and Programs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测外部库和程序
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Detecting the Python interpreter
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测Python解释器
- en: Detecting the Python library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测Python库
- en: Detecting Python modules and packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测Python模块和包
- en: Detecting the BLAS and LAPACK math libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测BLAS和LAPACK数学库
- en: Detecting the OpenMP parallel environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测OpenMP并行环境
- en: Detecting the MPI parallel environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测MPI并行环境
- en: Detecting the Eigen library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测Eigen库
- en: Detecting the Boost libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测Boost库
- en: 'Detecting external libraries: I. Using `pkg-config`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测外部库：I. 使用`pkg-config`
- en: 'Detecting external libraries: II. Writing a find-module'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测外部库：II. 编写一个查找模块
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'Projects often depend on other projects and libraries. This chapter demonstrates
    how to detect external libraries, frameworks, and projects and how to link to
    these. CMake has a rather extensive set of prepackaged modules to detect the most
    commonly used libraries and programs, such as Python and Boost, for example. You
    can get a list of existing modules using `cmake --help-module-list`. However,
    not all libraries and programs are covered and from time to time you will have
    to provide your own detection scripts. In this chapter, we will discuss the necessary
    tools and discover the find family of CMake commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 项目通常依赖于其他项目和库。本章演示了如何检测外部库、框架和项目以及如何链接到这些。CMake有一个相当广泛的预打包模块集，用于检测最常用的库和程序，例如Python和Boost。你可以使用`cmake
    --help-module-list`获取现有模块的列表。然而，并非所有库和程序都被覆盖，有时你将不得不提供自己的检测脚本。在本章中，我们将讨论必要的工具并发现CMake命令的查找家族：
- en: '`find_file` to find a full path to a named file'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_file`来查找一个指定文件的完整路径'
- en: '`find_library` to find a library'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_library`来查找一个库'
- en: '`find_package` to find and load settings from an external project'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package`来查找并加载来自外部项目的设置'
- en: '`find_path` to find a directory containing the named file'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_path`来查找包含指定文件的目录'
- en: '`find_program` to find a program'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_program`来查找一个程序'
- en: You can use the `--help-command` command-line switch to print the documentation
    for any of the CMake built-in commands to screen.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`--help-command`命令行开关来打印任何CMake内置命令的文档到屏幕上。
- en: Detecting the Python interpreter
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测Python解释器
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-01).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-01)找到。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Python is a very popular dynamic language. Many projects package tools written
    in Python together with their main programs and libraries, or use Python scripts
    in the configuration or build process. In such cases, it is important to ensure
    that the runtime dependency on the Python interpreter is also satisfied. This
    recipe will show how to detect and use the Python interpreter at the configuration
    step. We will introduce the `find_package` command, which will be used throughout
    this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种非常流行的动态语言。许多项目将用Python编写的工具与它们的主程序和库一起打包，或者在配置或构建过程中使用Python脚本。在这种情况下，确保运行时依赖于Python解释器也得到满足是很重要的。本食谱将展示如何在配置步骤中检测和使用Python解释器。我们将介绍`find_package`命令，该命令将在本章中广泛使用。
- en: How to do it
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We will build up the `CMakeLists.txt` file step by step:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步构建`CMakeLists.txt`文件：
- en: 'We start out by defining the minimum CMake version and project name. Note that
    for this example we will not need any language support:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义最小CMake版本和项目名称。请注意，对于这个例子，我们将不需要任何语言支持：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we use the `find_package` command to find the Python interpreter:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`find_package`命令来查找Python解释器：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we execute a Python command and capture its output and return value:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们执行一个Python命令并捕获其输出和返回值：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we print the return value and the output of the Python command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们打印Python命令的返回值和输出：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can examine the output of the configuration step:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以检查配置步骤的输出：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: '`find_package` is a wrapper command for CMake modules written for discovering
    and setting up packages. These modules contain CMake commands to identify packages
    in standard locations on the system. The files for the CMake modules are called
    `Find<name>.cmake` and the commands they contain will be run internally when a
    call to `find_package(<name>)` is issued.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_package`是CMake模块的包装命令，用于发现和设置软件包。这些模块包含用于在系统上的标准位置识别软件包的CMake命令。CMake模块的文件称为`Find<name>.cmake`，当发出`find_package(<name>)`调用时，它们包含的命令将在内部运行。'
- en: 'In addition to actually discovering the requested package on your system, find
    modules also set up a handful of useful variables, reflecting what was actually
    found, which you can use in your own `CMakeLists.txt`. In the case of the Python
    interpreter, the relevant module is `FindPythonInterp.cmake`, which is shipped
    with CMake, and sets the following variables:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际在系统上发现请求的软件包之外，查找模块还设置了一组有用的变量，反映实际找到的内容，可以在自己的`CMakeLists.txt`中使用。对于Python解释器，相关模块是`FindPythonInterp.cmake`，随CMake一起提供，并设置以下变量：
- en: '`PYTHONINTERP_FOUND`, a Boolean signaling whether the interpreter was found'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHONINTERP_FOUND`，一个布尔值，表示是否找到了解释器'
- en: '`PYTHON_EXECUTABLE`, the path to the executable for the Python interpreter'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHON_EXECUTABLE`，Python解释器可执行文件的路径'
- en: '`PYTHON_VERSION_STRING`, the full version of the Python interpreter'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHON_VERSION_STRING`，Python解释器的完整版本号'
- en: '`PYTHON_VERSION_MAJOR`, the major version of the Python interpreter'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHON_VERSION_MAJOR`，Python解释器的主版本号'
- en: '`PYTHON_VERSION_MINOR`, the minor version of the Python interpreter'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHON_VERSION_MINOR`，Python解释器的小版本号'
- en: '`PYTHON_VERSION_PATCH`, the patch number of the Python interpreter'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHON_VERSION_PATCH`，Python解释器的补丁号'
- en: 'It is possible to force CMake to look for specific versions of a package. For
    example, use this to request any version of the Python interpreter greater or
    equal to 2.7:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以强制CMake查找特定版本的软件包。例如，使用此方法请求Python解释器的版本大于或等于2.7：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is also possible to enforce that dependencies are satisfied:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以强制要求满足依赖关系：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, CMake will abort configuration if no suitable executable for the
    Python interpreter is found in the usual lookup locations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果在常规查找位置找不到适合的Python解释器可执行文件，CMake将中止配置。
- en: CMake has modules for finding many widespread software packages. We recommend
    to always search the CMake online documentation for existing `Find<package>.cmake`
    modules and to read their documentation before using them. The documentation for
    the `find_package` command can be found at [https://cmake.org/cmake/help/v3.5/command/find_package.html](https://cmake.org/cmake/help/v3.5/command/find_package.html).
    A good alternative to online documentation is to browse CMake module sources in [https://github.com/Kitware/CMake/tree/master/Modules](https://github.com/Kitware/CMake/tree/master/Modules)
    - their headers document the variables that a module uses, as well as the variables
    set by the module that can be used in your `CMakeLists.txt`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CMake有许多用于查找广泛使用的软件包的模块。我们建议始终在CMake在线文档中搜索现有的`Find<package>.cmake`模块，并在使用它们之前阅读其文档。`find_package`命令的文档可以在[https://cmake.org/cmake/help/v3.5/command/find_package.html](https://cmake.org/cmake/help/v3.5/command/find_package.html)找到。在线文档的一个很好的替代方法是浏览[https://github.com/Kitware/CMake/tree/master/Modules](https://github.com/Kitware/CMake/tree/master/Modules)中的CMake模块源代码
    - 它们的标题文档说明了模块使用的变量以及模块设置的变量，可以在自己的`CMakeLists.txt`中使用。
- en: There is more
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'Sometimes, packages are not installed in standard locations and CMake might
    fail to locate them correctly. It is possible to tell CMake to look into certain
    specific locations to find certain software using the CLI switch `-D` to pass
    the appropriate option. In the case of the Python interpreter, you may configure
    with the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，软件包未安装在标准位置，CMake可能无法正确找到它们。可以使用CLI开关`-D`告诉CMake在特定位置查找特定软件以传递适当的选项。对于Python解释器，可以按以下方式配置：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will correctly identify the Python executable in the non-standard `/custom/location/python` installation
    directory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正确识别安装在非标准`/custom/location/python`目录中的Python可执行文件。
- en: Every package is different and the `Find<package>.cmake` modules try to take
    that into account and offer a unified interface for detection. When a package
    that is installed on the system cannot be found by CMake, we recommend you read
    the documentation for the corresponding detection module to understand how to
    instruct CMake correctly. You can browse the documentation directly in the terminal,
    in this case using `cmake --help-module FindPythonInterp`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包都不同，`Find<package>.cmake`模块试图考虑到这一点并提供统一的检测接口。当系统上安装的包无法被CMake找到时，我们建议您阅读相应检测模块的文档，以了解如何正确指导CMake。您可以直接在终端中浏览文档，例如使用`cmake
    --help-module FindPythonInterp`。
- en: 'Independently of detecting packages, we would like to mention a handy helper
    module for printing variables. In this recipe, we have used the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无论检测包的情况如何，我们都想提到一个方便的打印变量的辅助模块。在本食谱中，我们使用了以下内容：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A handy alternative for debugging is to use the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的一个便捷替代方法是使用以下内容：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This produces the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For more documentation on convenience macros for printing properties and variables,
    see [https://cmake.org/cmake/help/v3.5/module/CMakePrintHelpers.html](https://cmake.org/cmake/help/v3.5/module/CMakePrintHelpers.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于打印属性和变量的便捷宏的更多文档，请参见[https://cmake.org/cmake/help/v3.5/module/CMakePrintHelpers.html](https://cmake.org/cmake/help/v3.5/module/CMakePrintHelpers.html)。
- en: Detecting the Python library
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测Python库
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-02)
    and has a C example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-02)找到，包含一个C语言示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'The use of Python tools to analyze and manipulate output from compiled programs
    is nowadays widespread. However, there are also other, more powerful ways of combining
    an interpreted language such as Python with compiled languages such as C or C++.
    One way is to *extend* Python by providing new types and new functionalities on
    these types *via* C or C++ modules, compiled into shared libraries. This will
    be the topic of recipes in [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*. Another approach is to *embed* the Python interpreter into a C or C++
    program. Both approaches require the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，使用Python工具分析和操作编译程序的输出已经非常普遍。然而，还有其他更强大的方法将解释型语言（如Python）与编译型语言（如C或C++）结合。一种方法是通过提供新的类型和在这些类型上的新功能来*扩展*Python，通过将C或C++模块编译成共享库。这将是[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*中食谱的主题。另一种方法是*嵌入*Python解释器到一个C或C++程序中。这两种方法都需要以下内容：
- en: A working version of the Python interpreter
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的Python解释器版本
- en: The availability of the Python header file `Python.h`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的Python头文件`Python.h`
- en: The Python runtime library `libpython`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python运行时库`libpython`
- en: All three components have to be pinned to the exact same version. We have demonstrated
    how to find the Python interpreter; in this recipe, we will show how to find the
    two missing ingredients for a successful embedding.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个组件必须锁定到完全相同的版本。我们已经演示了如何找到Python解释器；在本食谱中，我们将展示如何找到成功嵌入所需的两个缺失成分。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use a simple example of Python embedding into a C program that can
    be found on the Python documentation pages. The source file is called `hello-embedded-python.c`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python文档页面上找到的一个简单的Python嵌入到C程序的示例。源文件名为`hello-embedded-python.c`：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code samples will initialize an instance of the Python interpreter within
    the program and print the date using the `time` Python module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码示例将在程序中初始化Python解释器的一个实例，并使用Python的`time`模块打印日期。
- en: The embedding sample code can be found online in the Python documentation pages
    at [https://docs.python.org/2/extending/embedding.html](https://docs.python.org/2/extending/embedding.html)
    and [https://docs.python.org/3/extending/embedding.html](https://docs.python.org/3/extending/embedding.html).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入示例代码可以在Python文档页面上在线找到，网址为[https://docs.python.org/2/extending/embedding.html](https://docs.python.org/2/extending/embedding.html)和[https://docs.python.org/3/extending/embedding.html](https://docs.python.org/3/extending/embedding.html)。
- en: How to do it
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'These are the steps to follow in our `CMakeLists.txt`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`CMakeLists.txt`中，需要遵循以下步骤：
- en: 'The first block contains the minimum CMake version, project name, and required
    language:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一块包含最小CMake版本、项目名称和所需语言：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this recipe we enforce the use of the C99 standard for C. This is not strictly
    required for linking with Python, but is something you might want to have in place:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本食谱中，我们强制使用C99标准进行C语言编程。这严格来说不是链接Python所必需的，但可能是您想要设置的东西：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Find the Python interpreter. This is now a required dependency:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到Python解释器。现在这是一个必需的依赖项：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Find the Python header and library. The appropriate module is called `FindPythonLibs.cmake`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到Python头文件和库。适当的模块称为`FindPythonLibs.cmake`：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We add an executable target which uses the `hello-embedded-python.c` source
    file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个使用`hello-embedded-python.c`源文件的可执行目标：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The executable includes the `Python.h` header file. Thus, the include directories
    for this target have to include the Python include directory, accessible from
    the `PYTHON_INCLUDE_DIRS` variable:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可执行文件包含`Python.h`头文件。因此，此目标的包含目录必须包含Python包含目录，可通过`PYTHON_INCLUDE_DIRS`变量访问：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we link the executable to the Python library, accessible *via* the
    `PYTHON_LIBRARIES` variable:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将可执行文件链接到Python库，通过`PYTHON_LIBRARIES`变量访问：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we are ready to run the configuration step:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备运行配置步骤：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we execute the build step and run the executable:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们执行构建步骤并运行可执行文件：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The `FindPythonLibs.cmake` module will look in standard locations for the Python
    header and library. Since these are required dependencies of our project, configuration
    will stop with an error if these are not found.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindPythonLibs.cmake`模块将在标准位置查找Python头文件和库。由于这些是我们项目的必需依赖项，如果找不到这些依赖项，配置将停止并出现错误。'
- en: 'Notice that we explicitly asked CMake to detect the installation of the Python
    executable. This is to ensure that executable, header, and library all have a
    matching version. This is paramount to ensure that there are no mismatches between
    versions that could cause crashes at runtime. We have achieved this by using `PYTHON_VERSION_MAJOR`
    and `PYTHON_VERSION_MINOR`, defined in `FindPythonInterp.cmake`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们明确要求CMake检测Python可执行文件的安装。这是为了确保可执行文件、头文件和库具有匹配的版本。这对于确保运行时不会出现版本不匹配导致的崩溃至关重要。我们通过使用`FindPythonInterp.cmake`中定义的`PYTHON_VERSION_MAJOR`和`PYTHON_VERSION_MINOR`实现了这一点：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the `EXACT` keyword, we have constrained CMake to detect a particular,
    and in this case matching, version of the Python include files and libraries.
    For an even closer match, we could have used the precise `PYTHON_VERSION_STRING`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EXACT`关键字，我们已约束CMake检测特定且在这种情况下匹配的Python包含文件和库版本。为了更精确匹配，我们可以使用精确的`PYTHON_VERSION_STRING`：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is more
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'How do we make sure that the Python header and libraries are correctly located
    even when they are not in a standard installation directory? For the Python interpreter,
    it is possible to force CMake to look in specific directories by passing the `PYTHON_LIBRARY`
    and `PYTHON_INCLUDE_DIR` options *via* the `-D` option to the CLI. These options
    specify the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保即使Python头文件和库不在标准安装目录中，它们也能被正确找到？对于Python解释器，可以通过将`PYTHON_LIBRARY`和`PYTHON_INCLUDE_DIR`选项通过`-D`选项传递给CLI来强制CMake在特定目录中查找。这些选项指定以下内容：
- en: '`PYTHON_LIBRARY`, the path to the Python library'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHON_LIBRARY`，Python库的路径'
- en: '`PYTHON_INCLUDE_DIR`, the path to where `Python.h` is located'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHON_INCLUDE_DIR`，`Python.h`所在的路径'
- en: This ensures that the desired version of Python will be picked up.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保将选择所需的Python版本。
- en: Sometimes it is necessary to pass `-D PYTHON_EXECUTABLE`, `-D PYTHON_LIBRARY`,
    and `-D PYTHON_INCLUDE_DIR` to the CMake CLI in order to locate all necessary
    components and pin them down to the exact same version.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要将`-D PYTHON_EXECUTABLE`、`-D PYTHON_LIBRARY`和`-D PYTHON_INCLUDE_DIR`传递给CMake
    CLI，以便找到所有必需的组件并将它们固定到完全相同的版本。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'It might be very difficult to exactly pin the Python interpreter and its development
    components to be of the exact same version. This is especially true for those
    cases where they are installed in non-standard locations or there is more than
    one version of each installed on your system. New Python detection modules have
    been added to CMake in its version 3.12 that are aimed at solving this vexing
    problem. The detection portion of our `CMakeLists.txt` would also be greatly simplified
    to:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要精确匹配Python解释器及其开发组件的版本可能非常困难。这在它们安装在非标准位置或系统上安装了多个版本的情况下尤其如此。CMake在其版本3.12中添加了新的Python检测模块，旨在解决这个棘手的问题。我们的`CMakeLists.txt`中的检测部分也将大大简化：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We encourage you to read the documentation for the new module at: [https://cmake.org/cmake/help/v3.12/module/FindPython.html](https://cmake.org/cmake/help/v3.12/module/FindPython.html)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您阅读新模块的文档：[https://cmake.org/cmake/help/v3.12/module/FindPython.html](https://cmake.org/cmake/help/v3.12/module/FindPython.html)
- en: Detecting Python modules and packages
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测Python模块和包
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-03)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-03)找到，并包含一个C++示例。本配方适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In the previous recipe, we showed how to detect the Python interpreter and how
    to compile a simple C program, embedding the Python interpreter. Both are fundamental
    tasks to get you off the ground when combining Python and a compiled language.
    Often, your code will depend on specific Python modules, be they Python tools,
    compiled programs embedding Python, or libraries extending it. For example, NumPy
    has become very popular in the scientific community for problems involving matrix
    algebra. In projects that depend on Python modules or packages, it is important
    to make sure that the dependency on these Python modules is satisfied. This recipe
    will show how to probe the user's environment to find specific Python modules
    and packages.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个配方中，我们展示了如何检测Python解释器以及如何编译一个简单的C程序，嵌入Python解释器。这两项任务是结合Python和编译语言时的基础。通常，你的代码会依赖于特定的Python模块，无论是Python工具、嵌入Python的编译程序，还是扩展它的库。例如，NumPy在涉及矩阵代数的问题中在科学界变得非常流行。在依赖于Python模块或包的项目中，确保这些Python模块的依赖得到满足是很重要的。本配方将展示如何探测用户的环境以找到特定的Python模块和包。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will try a slightly more involved embedding example in a C++ program. The
    example is again taken from the Python online documentation ([https://docs.python.org/3.5/extending/embedding.html#pure-embedding](https://docs.python.org/3.5/extending/embedding.html#pure-embedding))
    and shows how to execute functions from a user-defined Python module by calling
    the compiled C++ executable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在C++程序中尝试一个稍微更复杂的嵌入示例。该示例再次取自Python在线文档（[https://docs.python.org/3.5/extending/embedding.html#pure-embedding](https://docs.python.org/3.5/extending/embedding.html#pure-embedding)），并展示了如何通过调用编译的C++可执行文件来执行用户定义的Python模块中的函数。
- en: 'The Python 3 example code (`Py3-pure-embedding.cpp`) contains the following
    source code (see [https://docs.python.org/2/extending/embedding.html#pure-embedding](https://docs.python.org/2/extending/embedding.html#pure-embedding)
    for the corresponding Python 2 equivalent):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3示例代码（`Py3-pure-embedding.cpp`）包含以下源代码（有关相应的Python 2等效内容，请参见[https://docs.python.org/2/extending/embedding.html#pure-embedding](https://docs.python.org/2/extending/embedding.html#pure-embedding)）：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The Python code that we wish to embed (`use_numpy.py`) uses NumPy to set up
    a matrix with all matrix elements set to 1.0:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望嵌入的Python代码（`use_numpy.py`）使用NumPy设置一个矩阵，其中所有矩阵元素都设置为1.0：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'In the following code, we wish to be able to check whether NumPy is available
    using CMake. We will first need to make sure that the Python interpreter, headers,
    and libraries are all available on our system. We will then move on to make sure
    that NumPy is available:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们希望使用CMake检查NumPy是否可用。首先，我们需要确保Python解释器、头文件和库都在我们的系统上可用。然后，我们将继续确保NumPy可用：
- en: 'First, we define the minimum CMake version, project name, language, and C++
    standard:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义最小CMake版本、项目名称、语言和C++标准：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finding the interpreter, headers, and libraries is achieved exactly as in the
    previous recipe:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到解释器、头文件和库的过程与之前的脚本完全相同：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Properly packaged Python modules are aware of their installation location and
    version. This can be probed by executing a minimal Python script. We can execute
    this step *within* our `CMakeLists.txt`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确打包的Python模块知道它们的安装位置和版本。这可以通过执行一个最小的Python脚本来探测。我们可以在`CMakeLists.txt`内部执行这一步骤：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `_numpy_status` variable will be an integer if NumPy was found or a string
    with some error message otherwise, whereas `_numpy_location` will contain the
    path to the NumPy module. If NumPy is found, we save its location to a new variable
    simply called `NumPy`. Notice that the new variable is cached; this means that
    CMake creates a persistent variable that can be later modified by the user:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_numpy_status`变量将在找到NumPy时为整数，否则为带有某些错误消息的字符串，而`_numpy_location`将包含NumPy模块的路径。如果找到NumPy，我们将其位置保存到一个简单的名为`NumPy`的新变量中。请注意，新变量被缓存；这意味着CMake创建了一个持久变量，用户可以稍后修改它：'
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next step is to check the version of the module. Once again, we deploy
    some Python magic in our `CMakeLists.txt`, saving the version into a `_numpy_version`
    variable:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是检查模块的版本。再次，我们在`CMakeLists.txt`中部署一些Python魔法，将版本保存到一个`_numpy_version`变量中：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we let the `FindPackageHandleStandardArgs` CMake package set up the
    `NumPy_FOUND` variable and output status information in the correct format:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们让`FindPackageHandleStandardArgs`CMake包设置`NumPy_FOUND`变量并以正确格式输出状态信息：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once all dependencies have been correctly found, we can compile the executable
    and link it to the Python libraries:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有依赖项都被正确找到，我们就可以编译可执行文件并将其链接到Python库：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We also have to make sure that `use_numpy.py` is available in the build directory:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须确保`use_numpy.py`在构建目录中可用：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can test the detection and embedding of the code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以测试检测和嵌入代码：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: There are three new CMake commands in this recipe: `execute_process` and `add_custom_command`,
    which are always available, and `find_package_handle_standard_args`, which requires
    `include(FindPackageHandleStandardArgs)`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个CMake脚本中，有三个新的CMake命令：`execute_process`和`add_custom_command`，它们总是可用的，以及`find_package_handle_standard_args`，它需要`include(FindPackageHandleStandardArgs)`。
- en: The `execute_process` command will execute one or more commands as child processes
    to the currently issued CMake command. The return value for the last child process
    will be saved into the variable passed as an argument to `RESULT_VARIABLE`, while
    the contents of the standard output and standard error pipes will be saved into
    the variables passed as arguments to `OUTPUT_VARIABLE` and `ERROR_VARIABLE`. `execute_process`
    allows us to execute arbitrary commands and use their results to infer the configuration
    of our system. In our case, we first use it to make sure that NumPy is available
    and then to obtain the version of the module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute_process`命令将执行一个或多个作为当前发出的CMake命令的子进程的命令。最后一个子进程的返回值将被保存到作为参数传递给`RESULT_VARIABLE`的变量中，而标准输出和标准错误管道的内容将被保存到作为参数传递给`OUTPUT_VARIABLE`和`ERROR_VARIABLE`的变量中。`execute_process`允许我们执行任意命令，并使用它们的结果来推断我们系统的配置。在我们的例子中，我们首先使用它来确保NumPy可用，然后获取模块的版本。'
- en: 'The `find_package_handle_standard_args` command provides the standard tool
    for handling common operations related to finding programs and libraries installed
    on a given system. The version-related options, `REQUIRED` and `EXACT`, are all
    correctly handled without further CMake code when referring to this command. The
    additional options `QUIET` and `COMPONENTS`, which we will meet shortly, are also
    handled under the hood by this CMake command. In this recipe, we have used the
    following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_package_handle_standard_args`命令提供了处理与在给定系统上找到的程序和库相关的常见操作的标准工具。版本相关的选项，`REQUIRED`和`EXACT`，在引用此命令时都得到了正确处理，无需进一步的CMake代码。额外的选项`QUIET`和`COMPONENTS`，我们很快就会遇到，也由这个CMake命令在幕后处理。在这个脚本中，我们使用了以下内容：'
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The command will set the variable to signal that the module was found (`NumPy_FOUND`)
    when all required variables are set to valid file paths (`NumPy`). It will also
    set the version to the passed version variable (` _numpy_version`) and print out
    status messages for the user:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有必需的变量都被设置为有效的文件路径（`NumPy`）时，该命令将设置变量以发出模块已被找到的信号（`NumPy_FOUND`）。它还将设置版本到传递的版本变量（`_numpy_version`），并为用户打印出状态消息：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the present recipe, we have not used these variables further. What we could
    have done is to stop the configuration if `NumPy_FOUND` was returned as `FALSE`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们没有进一步使用这些变量。我们可以做的是，如果`NumPy_FOUND`被返回为`FALSE`，则停止配置。
- en: 'Finally, we should comment on the section of the code that copies `use_numpy.py`
    to the build directory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该对将`use_numpy.py`复制到构建目录的代码段进行评论：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We could have achieved the copying with a `file(COPY ...)` command. Here, we
    opted to use `add_custom_command` to make sure that the file gets copied every
    time it changes, not only the first time we run the configuration. We will return
    to `add_custom_command` in more detail in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml)*,
    Configure-time and Build-time Operations*. Note also the `target_sources` command,
    which adds the dependency to `${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py`; this
    was done to make sure that building the `pure-embedding` target triggers the preceding
    custom command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用`file(COPY ...)`命令来实现复制。在这里，我们选择使用`add_custom_command`以确保每次文件更改时都会复制文件，而不仅仅是在我们首次运行配置时。我们将在[第5章](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml)*,
    配置时间和构建时间操作*中更详细地回顾`add_custom_command`。还请注意`target_sources`命令，它将依赖项添加到`${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py`；这样做是为了确保构建`pure-embedding`目标会触发前面的自定义命令。
- en: Detecting the BLAS and LAPACK math libraries
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测BLAS和LAPACK数学库
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-04)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-04)找到，并包含一个C++示例。本食谱适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'Many numerical codes rely heavily on matrix and vector operations. Think for
    example of matrix-vector and matrix-matrix products, the solution of linear system
    of equations, the calculation of eigenvalues and eigenvectors or singular-value
    decompositions. These operations might be so ubiquitous in the code base or might
    have to be run on such large data sets that the availability of efficient implementations
    becomes an absolute necessity in your code. Fortunately, there are libraries just
    for that: the basic linear algebra subprograms (BLAS) and the linear algebra package
    (LAPACK) offer *standard* APIs for many tasks involving linear algebraic manipulations.
    Different vendors provide different implementations, but all of them share the
    same API. While the actual programming languages for the underlying implementation
    of the math libraries varied over time (Fortran, C, Assembly), the remaining historical
    trace is the Fortran calling convention. Our task in this recipe will be to link
    against these libraries and show how to seamlessly work with a library written
    in a different language, considering the above-mentioned calling convention.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数值代码严重依赖于矩阵和向量运算。例如，考虑矩阵-向量和矩阵-矩阵乘积、线性方程组的解、特征值和特征向量的计算或奇异值分解。这些操作可能在代码库中无处不在，或者必须在大数据集上运行，以至于高效的实现变得绝对必要。幸运的是，有专门为此目的的库：基本线性代数子程序（BLAS）和线性代数包（LAPACK）提供了*标准*API，用于涉及线性代数操作的许多任务。不同的供应商提供不同的实现，但它们都共享相同的API。尽管数学库底层实现所用的实际编程语言随时间而变化（Fortran、C、汇编），但留下的历史痕迹是Fortran调用约定。在本食谱中，我们的任务将是链接到这些库，并展示如何无缝地使用用不同语言编写的库，考虑到上述调用约定。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To demonstrate the detection and linking of math libraries, we wish to compile
    a C++ program that takes the dimension of a matrix as command-line input, generates
    a random square matrix **A**, a random vector **b** and solves the ensuing linear
    systems of equations: **Ax** = **b**. In addition, we will scale the random vector **b** by
    a random factor. The subroutines we need to use are `DSCAL` from BLAS, to perform
    the scaling and `DGESV` from LAPACK to find the solution of the linear system
    of equations. The listing for the example C++ code contains (`linear-algebra.cpp`):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示数学库的检测和链接，我们希望编译一个C++程序，该程序接受矩阵维数作为命令行输入，生成一个随机方阵**A**，一个随机向量**b**，并解决随之而来的线性方程组：**Ax**
    = **b**。此外，我们将用一个随机因子缩放随机向量**b**。我们需要使用的子程序是来自BLAS的`DSCAL`，用于执行缩放，以及来自LAPACK的`DGESV`，用于找到线性方程组的解。示例C++代码的列表包含在（`linear-algebra.cpp`）中：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are using the random library, introduced in C++11, to generate a random distribution
    between -1.0 and 1.0\. `C_DSCAL` and `C_DGESV` are interfaces to the BLAS and
    LAPACK libraries, respectively, taking care of the name mangling in order to call
    these functions from a different programming language. This is done in the following
    interface files in combination with a CMake module which we will discuss further
    below.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用C++11中引入的随机库来生成-1.0到1.0之间的随机分布。`C_DSCAL`和`C_DGESV`是BLAS和LAPACK库的接口，分别负责名称修饰，以便从不同的编程语言调用这些函数。这是在以下接口文件中与我们将进一步讨论的CMake模块结合完成的。
- en: 'The file `CxxBLAS.hpp` wraps the BLAS routine with `extern "C"` linkage:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`CxxBLAS.hpp`使用`extern "C"`链接包装BLAS例程：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The corresponding implementation file `CxxBLAS.cpp` contains:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的实现文件`CxxBLAS.cpp`包含：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The files `CxxLAPACK.hpp` and `CxxLAPACK.cpp` perform corresponding translations
    for the LAPACK calls.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`CxxLAPACK.hpp`和`CxxLAPACK.cpp`为LAPACK调用执行相应的翻译。
- en: How to do it
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'The corresponding `CMakeLists.txt` contains the following building blocks:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`CMakeLists.txt`包含以下构建块：
- en: 'We define the minimum CMake version, the project name and supported languages:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了最小CMake版本、项目名称和支持的语言：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We require the C++11 standard:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要求使用C++11标准：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Further, we verify whether Fortran and C/C++ compilers work together and generate
    the header file which will take care of name mangling. Both functions are provided
    by the `FortranCInterface` module:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们验证Fortran和C/C++编译器是否能协同工作，并生成处理名称修饰的头部文件。这两项功能均由`FortranCInterface`模块提供：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We then ask CMake to find BLAS and LAPACK. These are required dependencies:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们要求CMake查找BLAS和LAPACK。这些是必需的依赖项：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we add a library with our sources for the BLAS and LAPACK wrappers and
    link against `LAPACK_LIBRARIES` which brings in also `BLAS_LIBRARIES`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个包含我们源代码的库，用于BLAS和LAPACK包装器，并链接到`LAPACK_LIBRARIES`，这也引入了`BLAS_LIBRARIES`：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that the include directories and link libraries for this target are declared
    as `PUBLIC` and therefore any additional target depending on the math library
    will also set these directories in its include directories.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，该目标的包含目录和链接库被声明为`PUBLIC`，因此任何依赖于数学库的额外目标也会在其包含目录中设置这些目录。
- en: 'Finally, we add an executable target and link to `math`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个可执行目标，并链接到`math`：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the configuration step we can focus on the relevant output:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置步骤中，我们可以专注于相关的输出：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we build and test the executable:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们构建并测试可执行文件：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: '`FindBLAS.cmake` and `FindLAPACK.cmake` will look in standard locations for
    libraries offering the standard BLAS and LAPACK APIs. For the former, the module
    will look for the Fortran implementation of the `SGEMM` function, for single-precision
    matrix-matrix products for general matrices. For the latter, the module searches
    for the Fortran implementation of the `CHEEV` function, for the calculation of
    eigenvalues and eigenvectors of complex, Hermitian matrices. These lookups are
    carried out internally by compiling a small program calling these functions and
    trying to link against the candidate libraries. If that fails, it signals that
    a compliant library is not available on the system.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindBLAS.cmake`和`FindLAPACK.cmake`将在标准位置查找提供标准BLAS和LAPACK API的库。对于前者，模块将查找Fortran实现的`SGEMM`函数，用于单精度矩阵-矩阵乘法，适用于一般矩阵。对于后者，模块搜索Fortran实现的`CHEEV`函数，用于计算复数、Hermitian矩阵的特征值和特征向量。这些查找是通过内部编译一个调用这些函数的小程序并尝试链接到候选库来执行的。如果失败，则表明系统上没有符合要求的库。'
- en: Every compiler performs name-mangling of symbols when generating machine code
    and unfortunately conventions for this operation are not universal, but compiler-dependent.
    To overcome this difficulty, we have used the `FortranCInterface` module ([https://cmake.org/cmake/help/v3.5/module/FortranCInterface.html](https://cmake.org/cmake/help/v3.5/module/FortranCInterface.html))
    to both verify that the Fortran and C/C++ compilers work together and to generate
    a Fortran-C interface header `fc_mangle.h` which is compatible with the compiler
    in question. The generated `fc_mangle.h` must then be included in the interface
    header files `CxxBLAS.hpp` and `CxxLAPACK.hpp`. We had to add C and Fortran support
    to the list of `LANGUAGES` in order to use `FortranCInterface`. Of course we could
    have defined own preprocessor definitions instead, however at the price of limited
    portability.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编译器在生成机器代码时都会对符号进行名称混淆，不幸的是，这项操作的约定不是通用的，而是编译器依赖的。为了克服这个困难，我们使用了`FortranCInterface`模块（[https://cmake.org/cmake/help/v3.5/module/FortranCInterface.html](https://cmake.org/cmake/help/v3.5/module/FortranCInterface.html)）来验证Fortran和C/C++编译器是否能协同工作，并生成一个与所讨论编译器兼容的Fortran-C接口头文件`fc_mangle.h`。生成的`fc_mangle.h`然后必须包含在接口头文件`CxxBLAS.hpp`和`CxxLAPACK.hpp`中。为了使用`FortranCInterface`，我们不得不在`LANGUAGES`列表中添加C和Fortran支持。当然，我们可以定义自己的预处理器定义，但代价是有限的移植性。
- en: We will discuss the interoperability of Fortran and C more closely in [Chapter
    9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language Projects*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*中更详细地讨论Fortran和C的互操作性。
- en: Nowadays, many implementations of BLAS and LAPACK already ship with a thin C
    layer wrapper around the Fortran subroutines. These wrappers have been standardized
    over the years and are called CBLAS and LAPACKE.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多BLAS和LAPACK的实现已经附带了一个围绕Fortran子程序的薄C层包装器。这些包装器多年来已经标准化，被称为CBLAS和LAPACKE。
- en: There is more
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: Many numerical codes rely heavily on matrix algebra operations and it is important
    to correctly link against high-performance implementations of the BLAS and LAPACK
    APIs. There is a large variability in the way vendors package their libraries
    for different architectures and parallel environments. `FindBLAS.cmake` and `FindLAPACK.cmake`
    will most likely not be able to locate an existing library in all possible cases.
    If that happens, you can explicitly set the libraries from the CLI *via* the `-D`
    option.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数值代码严重依赖于矩阵代数操作，正确地链接到高性能的BLAS和LAPACK API实现非常重要。不同供应商在不同架构和并行环境下打包其库的方式存在很大差异。`FindBLAS.cmake`和`FindLAPACK.cmake`很可能无法在所有可能的情况下定位现有的库。如果发生这种情况，您可以通过CLI的`-D`选项显式设置库。
- en: Detecting the OpenMP parallel environment
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测OpenMP并行环境
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05)
    and has a C++ and Fortran example. The recipe is valid with CMake version 3.9
    (and higher) and has been tested on GNU/Linux, macOS, and Windows. In [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05),
    we also provide examples compatible with CMake 3.5.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05)找到，并包含C++和Fortran示例。该食谱适用于CMake版本3.9（及以上），并在GNU/Linux、macOS和Windows上进行了测试。在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05)，我们还提供了与CMake
    3.5兼容的示例。
- en: Today, basically any computer on the market is a multi-core machine and for
    programs focusing on performance, we may have to focus on these multi-core CPUs
    and use concurrency in our programming models. OpenMP is the standard for shared-memory
    parallelism on multi-core CPUs. Existing programs often do not need to be radically
    modified or rewritten in order to benefit from OpenMP parallelization. Once the
    performance-critical sections in the code are identified, for example using a
    profiling tool, the programmer can add preprocessor directives that will instruct
    the compiler to generate parallel code for those regions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，市场上的基本任何计算机都是多核机器，对于专注于性能的程序，我们可能需要关注这些多核CPU，并在我们的编程模型中使用并发。OpenMP是多核CPU共享内存并行性的标准。现有的程序通常不需要进行根本性的修改或重写，以从OpenMP并行化中受益。一旦在代码中确定了性能关键部分，例如使用分析工具，程序员可以添加预处理器指令，这些指令将指示编译器为这些区域生成并行代码。
- en: In this recipe, we will show how to compile a program containing OpenMP directives,
    provided we use an OpenMP-aware compiler. Many Fortran, C, and C++ compilers exist
    that can take advantage of OpenMP parallelism. CMake provides very good support
    for OpenMP in combination with C, C++, or Fortran for relatively recent versions
    of CMake. This recipe will show you how to detect and link to OpenMP using imported
    targets for simple C++ and Fortran programs when using CMake 3.9 or above.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将展示如何编译包含OpenMP指令的程序，前提是我们使用的是支持OpenMP的编译器。许多Fortran、C和C++编译器都可以利用OpenMP的并行性。CMake对C、C++或Fortran的相对较新版本提供了非常好的OpenMP支持。本教程将向您展示如何在使用CMake
    3.9或更高版本时，为简单的C++和Fortran程序检测并链接OpenMP使用导入的目标。
- en: Depending on the Linux distribution, the Clang compiler may not have OpenMP
    support in its default version. This recipe **will not work** on macOS unless
    a separate libomp installation ([https://iscinumpy.gitlab.io/post/omp-on-high-sierra/](https://iscinumpy.gitlab.io/post/omp-on-high-sierra/))
    or a non-Apple version of Clang (e.g., provided by Conda) or the GNU compilers
    are used.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Linux发行版的不同，默认版本的Clang编译器可能不支持OpenMP。本教程**不适用于**macOS，除非使用单独的libomp安装（[https://iscinumpy.gitlab.io/post/omp-on-high-sierra/](https://iscinumpy.gitlab.io/post/omp-on-high-sierra/)）或非Apple版本的Clang（例如，由Conda提供）或GNU编译器。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'C and C++ programs can access OpenMP functionality by including the `omp.h` header
    file and by linking to the correct library. The compiler will generate parallel
    code according to preprocessor directives preceding the performance-critical sections.
    In this recipe, we will build the following example source code (`example.cpp`).
    This code sums integers from 1 to *N,* where *N* is given as a command-line argument:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++程序可以通过包含`omp.h`头文件并链接正确的库来访问OpenMP功能。编译器将根据性能关键部分之前的预处理器指令生成并行代码。在本教程中，我们将构建以下示例源代码（`example.cpp`）。该代码将1到*N*的整数求和，其中*N*作为命令行参数给出：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In Fortran, one needs to use the `omp_lib` module and link to the correct library.
    Use of parallel directives is once again possible in code comments preceding the
    performance-critical sections. The corresponding `example.F90` contains the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fortran中，需要使用`omp_lib`模块并链接到正确的库。在性能关键部分之前的代码注释中再次可以使用并行指令。相应的`example.F90`包含以下内容：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Our `CMakeLists.txt` for the C++ and Fortran examples will follow a template
    that is largely similar between the two languages:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的C++和Fortran示例的`CMakeLists.txt`将遵循一个在两种语言之间大体相似的模板：
- en: 'Both define a minimum CMake version, project name, and language (`CXX` or `Fortran`;
    we will show the C++ version):'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者都定义了最小CMake版本、项目名称和语言（`CXX`或`Fortran`；我们将展示C++版本）：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For the C++ example, we require the C++11 standard:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于C++示例，我们需要C++11标准：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Both call `find_package` to search for OpenMP:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者都调用`find_package`来搜索OpenMP：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we define the executable target and link to the imported target provided
    by the `FindOpenMP` module (in the Fortran case, we link against `OpenMP::OpenMP_Fortran`):'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义可执行目标并链接到`FindOpenMP`模块提供的导入目标（在Fortran情况下，我们链接到`OpenMP::OpenMP_Fortran`）：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we can configure and build the code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以配置并构建代码：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let us first test it out in parallel (in this example using four cores):'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先让我们在并行环境下测试一下（本例中使用四个核心）：
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For comparison, we can rerun the example with the number of OpenMP threads
    set to 1:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了比较，我们可以将示例重新运行，将OpenMP线程数设置为1：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Our simple example seems to work: the code compiled and linked, and we observe
    a speed-up when running on multiple cores. The fact that the speed-up is not a
    perfect multiple of `OMP_NUM_THREADS` is not our concern in this recipe, since
    we focus on the CMake aspect of a project which requires OpenMP. We have found
    linking to OpenMP to be extremely compact thanks to imported targets provided
    by a reasonably modern `FindOpenMP` module:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单示例似乎有效：代码已编译并链接，并且在运行于多个核心时我们观察到了加速。加速不是`OMP_NUM_THREADS`的完美倍数并不是本教程的关注点，因为我们专注于需要OpenMP的项目中的CMake方面。我们发现由于`FindOpenMP`模块提供的导入目标，链接OpenMP极其简洁：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We did not have to worry about compile flags or about include directories -
    these settings and dependencies are encoded in the definition of the library `OpenMP::OpenMP_CXX`
    which is of the `IMPORTED` type. As we mentioned in Recipe 3, *Building and linking
    static and shared libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries*, `IMPORTED` libraries are pseudo-targets
    that fully encode usage requirements for dependencies outside our own project.
    To use OpenMP one needs to set compiler flags, include directories, and link libraries.
    All of these are set as properties on the `OpenMP::OpenMP_CXX` target and transitively
    applied to our `example` target simply by using the `target_link_libraries` command.
    This makes using libraries within our CMake scripts exceedingly easy. We can print
    the properties of interface with the `cmake_print_properties` command, offered
    by the `CMakePrintHelpers.cmake` standard module:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心编译标志或包含目录——这些设置和依赖关系都编码在库`OpenMP::OpenMP_CXX`的定义中，该库属于`IMPORTED`类型。正如我们在第3个配方中提到的，*构建和链接静态和共享库*，在[第1章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)，*从简单的可执行文件到库*中，`IMPORTED`库是伪目标，它们完全编码了外部依赖的使用要求。要使用OpenMP，需要设置编译器标志、包含目录和链接库。所有这些都作为属性设置在`OpenMP::OpenMP_CXX`目标上，并通过使用`target_link_libraries`命令间接应用于我们的`example`目标。这使得在我们的CMake脚本中使用库变得非常容易。我们可以使用`cmake_print_properties`命令打印接口的属性，该命令由`CMakePrintHelpers.cmake`标准模块提供：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that all properties of interest have the prefix `INTERFACE_`, because these
    properties usage requirements for any target wanting to *interface* and use the
    OpenMP target.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有感兴趣的属性都带有前缀`INTERFACE_`，因为这些属性的使用要求适用于任何希望*接口*并使用OpenMP目标的目标。
- en: 'For CMake versions below 3.9, we would have to do a bit more work:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CMake版本低于3.9的情况，我们需要做更多的工作：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For CMake versions below 3.5, we might need to explicitly define compile flags
    for a Fortran project.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CMake版本低于3.5的情况，我们可能需要为Fortran项目明确定义编译标志。
- en: In this recipe, we have discussed C++ and Fortran, but the arguments and approach
    are valid also for a C project.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们讨论了C++和Fortran，但论点和方法同样适用于C项目。
- en: Detecting the MPI parallel environment
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测MPI并行环境
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06)
    and has a C++ and C example. The recipe is valid with CMake version 3.9 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows. In [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06),
    we also provide a C example compatible with CMake 3.5.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06)找到，并包含C++和C的示例。该配方适用于CMake版本3.9（及以上），并在GNU/Linux、macOS和Windows上进行了测试。在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06)，我们还提供了一个与CMake
    3.5兼容的C示例。
- en: 'An alternative and often complementary approach to OpenMP shared-memory parallelism
    is the Message Passing Interface (MPI), which has become the *de facto* standard
    for modeling a program executing in parallel on a distributed memory system. Although
    modern MPI implementations allow shared-memory parallelism as well, a typical
    approach in high-performance computing is to use OpenMP within a compute node
    combined with MPI across compute nodes. The implementation of the MPI standard
    consists of the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与OpenMP共享内存并行性的一种替代且通常互补的方法是消息传递接口（MPI），它已成为在分布式内存系统上并行执行程序的*事实*标准。尽管现代MPI实现也允许共享内存并行性，但在高性能计算中，典型的方法是使用OpenMP在计算节点内结合MPI跨计算节点。MPI标准的实现包括以下内容：
- en: Runtime libraries.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时库。
- en: Header files and Fortran 90 modules.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头文件和Fortran 90模块。
- en: Compiler wrappers, which invoke the compiler that was used to build the MPI
    library with additional command-line arguments to take care of include directories
    and libraries. Usually, the available compiler wrappers are `mpic++`/`mpiCC`/`mpicxx`
    for C++, `mpicc` for C, and `mpifort` for Fortran.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器包装器，它调用用于构建MPI库的编译器，并带有额外的命令行参数来处理包含目录和库。通常，可用的编译器包装器包括`mpic++`/`mpiCC`/`mpicxx`用于C++，`mpicc`用于C，以及`mpifort`用于Fortran。
- en: 'MPI launcher: This is the program you should call to launch a parallel execution
    of your compiled code. Its name is implementation-dependent and it is usually
    one of the following: `mpirun`, `mpiexec`, or `orterun`.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MPI启动器：这是您应该调用的程序，用于启动编译代码的并行执行。其名称取决于实现，通常是以下之一：`mpirun`、`mpiexec`或`orterun`。
- en: This recipe will show how to find a suitable MPI implementation on your system
    in order to compile a simple MPI "Hello, World" program.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将展示如何在系统上找到合适的MPI实现，以便编译简单的MPI“Hello, World”程序。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The example code (`hello-mpi.cpp`, downloaded from [http://www.mpitutorial.com](http://www.mpitutorial.com)),
    which we will compile in this recipe, will initialize the MPI library, have every
    process print its name, and eventually finalize the library:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例代码（`hello-mpi.cpp`，从[http://www.mpitutorial.com](http://www.mpitutorial.com)下载），我们将在本示例中编译，将初始化MPI库，让每个进程打印其名称，并最终关闭库：
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How to do it
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'In this recipe, we set out to find the MPI implementation: library, header
    files, compiler wrappers, and launcher. To do so, we will leverage the `FindMPI.cmake`
    standard CMake module:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们旨在找到MPI实现：库、头文件、编译器包装器和启动器。为此，我们将利用`FindMPI.cmake`标准CMake模块：
- en: 'First, we define the minimum CMake version, project name, supported language,
    and language standard:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义最小CMake版本、项目名称、支持的语言和语言标准：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We then call `find_package` to locate the MPI implementation:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用`find_package`来定位MPI实现：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We define the executable name and, source, and similarly to the previous recipe,
    link against the imported target:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义可执行文件的名称和源代码，并且与前面的示例类似，链接到导入的目标：
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let us configure and build the executable:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们配置并构建可执行文件：
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To execute this program in parallel, we use the `mpirun` launcher (in this
    case, using two tasks):'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了并行执行此程序，我们使用`mpirun`启动器（在这种情况下，使用两个任务）：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: Remember that the compiler wrapper is a thin layer around the compiler used
    to build the MPI library. Under the hood, it will call the same compiler and augment
    it with additional arguments, such as include paths and libraries, needed to successfully
    build a parallel program.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，编译器包装器是围绕编译器的一层薄层，用于构建MPI库。在底层，它将调用相同的编译器，并为其添加额外的参数，如包含路径和库，以成功构建并行程序。
- en: 'Which flags does the wrapper actually apply when compiling and linking a source
    file? We can probe this using the `--showme` option to the compiler wrapper. To
    find out the compiler flags we can use:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器在编译和链接源文件时实际应用哪些标志？我们可以使用编译器包装器的`--showme`选项来探测这一点。要找出编译器标志，我们可以使用：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Whereas to find out the linker flags we use the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出链接器标志，我们使用以下方法：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Similarly to the previous OpenMP recipe, we have found the linking to MPI to
    be extremely compact thanks to the imported targets provided by a reasonably modern `FindMPI` module:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个OpenMP示例类似，我们发现链接到MPI非常简洁，这得益于相对现代的`FindMPI`模块提供的导入目标：
- en: '[PRE70]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We did not have to worry about compile flags or about include directories -
    these settings and dependencies are already encoded as `INTERFACE`-type properties
    in the `IMPORTED` target provided by CMake.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心编译标志或包含目录 - 这些设置和依赖关系已经作为`INTERFACE`类型属性编码在CMake提供的`IMPORTED`目标中。
- en: 'And as discussed in the previous recipe, for CMake versions below 3.9, we would
    have to do a bit more work:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在前一个示例中讨论的，对于CMake版本低于3.9的情况，我们需要做更多的工作：
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this recipe, we have discussed C++, but the arguments and approach are equally
    valid for a C or Fortran project.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们讨论了C++，但参数和方法同样适用于C或Fortran项目。
- en: Detecting the Eigen library
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测Eigen库
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07)
    and has a C++ example. The recipe is valid with CMake version 3.9 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows. In [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07),
    we also provide a C++ example compatible with CMake 3.5.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07)找到，包含一个C++示例。本示例适用于CMake版本3.9（及以上），并在GNU/Linux、macOS和Windows上进行了测试。在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07)，我们还提供了一个与CMake
    3.5兼容的C++示例。
- en: The BLAS library offers a standardized interface for common operations involving
    matrices and vectors. This interface was however standardized with the Fortran
    language in mind. While we have shown how these libraries can be used more or
    less directly from C++, it may be desirable to have a higher-level interface in
    modern C++ programs.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: BLAS库为涉及矩阵和向量的常见操作提供了一个标准化的接口。然而，这个接口是针对Fortran语言标准化的。虽然我们已经展示了如何从C++中或多或少直接使用这些库，但在现代C++程序中可能希望有一个更高层次的接口。
- en: The header-only Eigen library uses template programming to offer such an interface.
    Its matrix and vector types are intuitive to use and even provide type checking
    at compile time, to ensure that incompatible matrix dimensions are not mixed.
    Dense and sparse matrix operations, such as matrix-matrix products, solvers for
    linear systems, and eigenvalue problems, are also implemented using expression
    templates for efficiency. From version 3.3, Eigen can be linked to the BLAS and
    LAPACK libraries, which provides the flexibility to offload certain operations
    to the implementation given in these libraries for additional performance.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Eigen库作为头文件使用模板编程来提供这样的接口。其矩阵和向量类型易于使用，甚至在编译时提供类型检查，以确保不混合不兼容的矩阵维度。密集和稀疏矩阵操作，如矩阵-矩阵乘积、线性系统求解器和特征值问题，也使用表达式模板实现效率。从版本3.3开始，Eigen可以链接到BLAS和LAPACK库，这提供了灵活性，可以将某些操作卸载到这些库中提供的实现以获得额外的性能。
- en: This recipe will show how to find the Eigen library and to instruct it to use
    OpenMP parallelization and offload some of the work to the BLAS library.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将展示如何找到Eigen库，并指示它使用OpenMP并行化并将部分工作卸载到BLAS库。
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this example, we will compile a program that allocates a random square matrix
    and vector of dimension passed from the command line. We will then solve the linear
    system **Ax**=**b** using LU decomposition. We will use the following source code
    (`linear-algebra.cpp`):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将编译一个程序，该程序分配一个随机方阵和从命令行传递的维度的向量。然后，我们将使用LU分解求解线性系统**Ax**=**b**。我们将使用以下源代码（`linear-algebra.cpp`）：
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Matrix-vector multiplications and LU decompositions are implemented in Eigen,
    but can optionally be offloaded to the BLAS and LAPACK libraries. In this recipe,
    we only consider offloading to the BLAS library.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-向量乘法和LU分解在Eigen中实现，但可以选择卸载到BLAS和LAPACK库。在本配方中，我们只考虑卸载到BLAS库。
- en: How to do it
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'In this project, we will find the Eigen and BLAS libraries, as well as OpenMP,
    and instruct Eigen to use OpenMP parallelization and to offload part of the linear
    algebra work to the BLAS library:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将找到Eigen和BLAS库，以及OpenMP，并指示Eigen使用OpenMP并行化，并将部分线性代数工作卸载到BLAS库：
- en: 'We first declare the minimum CMake version, project name, and use of the C++11
    language:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明CMake的最低版本、项目名称以及使用C++11语言：
- en: '[PRE73]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We also ask for OpenMP, since Eigen can make use of shared-memory parallelism
    for dense operations:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还请求OpenMP，因为Eigen可以利用共享内存并行性进行密集操作：
- en: '[PRE74]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We search for Eigen by calling `find_package` in `CONFIG` mode (we will discuss
    this in the next section):'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用`find_package`在`CONFIG`模式下搜索Eigen（我们将在下一节讨论这一点）：
- en: '[PRE75]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If Eigen was found, we print out a helpful status message. Notice that we are
    using the `Eigen3::Eigen` target. As we have learnt in the previous two recipes,
    this is an `IMPORTED` target, offered by the native CMake scripts distributed
    with Eigen:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到Eigen，我们会打印出有帮助的状态消息。请注意，我们正在使用`Eigen3::Eigen`目标。正如我们在前两个配方中学到的，这是一个`IMPORTED`目标，由Eigen分发的原生CMake脚本提供：
- en: '[PRE76]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, we declare an executable target for our source file:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的源文件声明一个可执行目标：
- en: '[PRE77]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We then find BLAS. Notice that the dependency is now not required:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们找到BLAS。请注意，依赖项现在不是必需的：
- en: '[PRE78]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If BLAS is found, we set the corresponding compile definition and link libraries
    for the executable target:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到BLAS，我们为可执行目标设置相应的编译定义和链接库：
- en: '[PRE79]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, we link to the imported `Eigen3::Eigen` and `OpenMP::OpenMP_CXX` targets.
    This is enough to set all the necessary compile and link flags:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们链接到导入的`Eigen3::Eigen`和`OpenMP::OpenMP_CXX`目标。这足以设置所有必要的编译和链接标志：
- en: '[PRE80]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We are now ready to configure the project:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经准备好配置项目：
- en: '[PRE81]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we compile and test the code. Observe that the binary uses, in this
    case, four available threads:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们编译并测试代码。请注意，在这种情况下，二进制文件使用了四个可用线程：
- en: '[PRE82]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How it works
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Eigen provides native CMake support, which makes it easy to set up a C++ project
    using it. Starting from version 3.3, Eigen ships CMake modules that export the
    appropriate target, `Eigen3::Eigen`, which we have used here.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Eigen 提供了原生的 CMake 支持，这使得使用它来设置 C++ 项目变得简单。从版本 3.3 开始，Eigen 提供了 CMake 模块，导出适当的
    target，即 `Eigen3::Eigen`，我们在这里使用了它。
- en: You will have noticed the `CONFIG` option to the `find_package` command. This
    signals to CMake that the package search will not proceed through a `FindEigen3.cmake`
    module, but rather through the `Eigen3Config.cmake`, `Eigen3ConfigVersion.cmake`,
    and `Eigen3Targets.cmake` files provided by the Eigen3 package in the standard
    location, `<installation-prefix>/share/eigen3/cmake`. This package location mode
    is called "Config" mode and is more versatile than the `Find<package>.cmake` approach
    we have been using so far. For more information about "Module" mode versus "Config"
    mode, please consult the official documentation at [https://cmake.org/cmake/help/v3.5/command/find_package.html](https://cmake.org/cmake/help/v3.5/command/find_package.html).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到 `find_package` 命令的 `CONFIG` 选项。这向 CMake 发出信号，表明包搜索不会通过 `FindEigen3.cmake`
    模块进行，而是通过 Eigen3 包在标准位置提供的 `Eigen3Config.cmake`、`Eigen3ConfigVersion.cmake` 和
    `Eigen3Targets.cmake` 文件进行，即 `<installation-prefix>/share/eigen3/cmake`。这种包位置模式称为“Config”模式，比我们迄今为止使用的
    `Find<package>.cmake` 方法更灵活。有关“Module”模式与“Config”模式的更多信息，请查阅官方文档：[https://cmake.org/cmake/help/v3.5/command/find_package.html](https://cmake.org/cmake/help/v3.5/command/find_package.html)。
- en: Also note that while the Eigen3, BLAS, and OpenMP dependencies were declared
    as `PUBLIC` dependencies, the `EIGEN_USE_BLAS` compile definition was declared
    as `PRIVATE`. Instead of linking the executable directly, we could collect the
    library dependencies in a separate library target. Using the `PUBLIC`/`PRIVATE`
    keywords, we can then adjust the visibility of the corresponding flags and definitions
    to dependents of the library target.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，尽管 Eigen3、BLAS 和 OpenMP 依赖项被声明为 `PUBLIC` 依赖项，但 `EIGEN_USE_BLAS` 编译定义被声明为
    `PRIVATE`。我们不是直接链接可执行文件，而是可以将库依赖项收集到一个单独的库目标中。使用 `PUBLIC`/`PRIVATE` 关键字，我们可以调整相应标志和定义对库目标依赖项的可见性。
- en: There is more
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'CMake will look for config modules in a predefined hierarchy of locations.
    First off is `CMAKE_PREFIX_PATH`, while `<package>_DIR` is the next search path.
    Thus, if Eigen3 was installed in a non-standard location, we can use two alternatives
    to tell CMake where to look for it:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 会在预定义的位置层次结构中查找配置模块。首先是 `CMAKE_PREFIX_PATH`，而 `<package>_DIR` 是下一个搜索路径。因此，如果
    Eigen3 安装在非标准位置，我们可以使用两种替代方法来告诉 CMake 在哪里查找它：
- en: 'By passing the installation prefix for Eigen3 as `CMAKE_PREFIX_PATH`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递 Eigen3 的安装前缀作为 `CMAKE_PREFIX_PATH`：
- en: '[PRE83]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'By passing the location of the configuration files as `Eigen3_DIR`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递配置文件的位置作为 `Eigen3_DIR`：
- en: '[PRE84]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Detecting the Boost libraries
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测 Boost 库
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-08)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在 [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-08)
    获取，并包含一个 C++ 示例。该食谱适用于 CMake 版本 3.5（及以上），并在 GNU/Linux、macOS 和 Windows 上进行了测试。
- en: The Boost libraries are a collection of general-purpose C++ libraries. These
    libraries provide a lot of functionality that may be indispensable in a modern
    C++ project, but which is not yet available through the C++ standard. For example,
    Boost provides components for metaprogramming, handling optional arguments, and
    filesystem manipulations, among others. Many of these libraries have later been
    adopted by the C++11, C++14, and C++17 standards, but many Boost components are
    still the libraries of choice for code bases that have to keep compatibility with
    older compilers.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 库是一系列通用目的的 C++ 库。这些库提供了许多现代 C++ 项目中可能必不可少的特性，而这些特性在 C++ 标准中尚未提供。例如，Boost
    提供了元编程、处理可选参数和文件系统操作等组件。许多这些库后来被 C++11、C++14 和 C++17 标准采纳，但对于需要保持与旧编译器兼容性的代码库，许多
    Boost 组件仍然是首选库。
- en: This recipe will show you how to detect and link against some components of
    the Boost libraries.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您展示如何检测并链接 Boost 库的某些组件。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The source code we will compile is one of the examples for the filesystem library
    provided by Boost to interact with the filesystem. This library is conveniently
    cross-platform and abstracts the differences between operating systems and filesystems
    into a coherent, high-level API. The following example code (`path-info.cpp`)
    will accept a path as an argument and print a report about its components to the
    screen:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编译的源代码是Boost提供的文件系统库的示例之一，用于与文件系统交互。该库方便地跨平台，并将操作系统与文件系统的差异抽象成一个连贯的高级API。以下示例代码（`path-info.cpp`）将接受一个路径作为参数，并将其组件的报告打印到屏幕上：
- en: '[PRE85]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How to do it
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Boost consists of many different libraries and these can be used almost independently
    from each other. Internally, CMake represents this library collection as a collection
    of components. The `FindBoost.cmake` module can search not only for the full installation
    of the library collection but also for particular components and their dependencies
    within the collection, if any. We will build up the corresponding `CMakeLists.txt`
    step by step:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Boost包含许多不同的库，这些库几乎可以独立使用。在内部，CMake将这个库集合表示为组件集合。`FindBoost.cmake`模块不仅可以搜索整个库集合的安装，还可以搜索集合中特定组件及其依赖项（如果有的话）。我们将逐步构建相应的`CMakeLists.txt`：
- en: 'We first declare the minimum CMake version, project name, language, and enforce
    the use of the C++11 standard:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明了最低CMake版本、项目名称、语言，并强制使用C++11标准：
- en: '[PRE86]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then, we use `find_package` to search for Boost. The dependency on Boost is
    mandatory, hence the `REQUIRED` argument. Since we only need the filesystem component
    in this example, we pass that as an argument after the `COMPONENTS` keyword to
    `find_package`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`find_package`来搜索Boost。对Boost的依赖是强制性的，因此使用了`REQUIRED`参数。由于在本例中我们只需要文件系统组件，因此我们在`COMPONENTS`关键字后传递该组件作为参数给`find_package`：
- en: '[PRE87]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We add an executable target, to compile the example source file:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个可执行目标，用于编译示例源文件：
- en: '[PRE88]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we link the target to the Boost library component. Since the dependency
    is declared `PUBLIC`, targets depending on our target will pick up the dependency
    automatically:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将目标链接到Boost库组件。由于依赖关系被声明为`PUBLIC`，依赖于我们目标的其他目标将自动获取该依赖关系：
- en: '[PRE89]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How it works
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The `FindBoost.cmake` module, which is used in this recipe, will try to locate
    the Boost libraries in standard system installation directories. Since we link
    to the imported `Boost::filesystem` target, CMake will automatically set the include
    directories and adjust the compile and link flags. In case the Boost libraries
    are installed in a non-standard location, one can pass the root of the Boost installation
    at configuration time using the `BOOST_ROOT` variable in order to point CMake
    to also search the non-standard path:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindBoost.cmake`模块，在本例中使用，将尝试在标准系统安装目录中定位Boost库。由于我们链接到导入的`Boost::filesystem`目标，CMake将自动设置包含目录并调整编译和链接标志。如果Boost库安装在非标准位置，可以在配置时使用`BOOST_ROOT`变量传递Boost安装的根目录，以指示CMake也在非标准路径中搜索：'
- en: '[PRE90]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Alternatively, one can pass both the `BOOST_INCLUDEDIR` and `BOOST_LIBRARYDIR`
    variables for the directories containing headers and libraries:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以同时传递`BOOST_INCLUDEDIR`和`BOOST_LIBRARYDIR`变量，以指定包含头文件和库的目录：
- en: '[PRE91]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Detecting external libraries: I. Using pkg-config'
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测外部库：I. 使用pkg-config
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09)
    and has a C example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows (using MSYS Makefiles). In [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09),
    we also provide an example compatible with CMake 3.5.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09)找到，并包含一个C语言示例。本例适用于CMake
    3.6（及以上）版本，并在GNU/Linux、macOS和Windows（使用MSYS Makefiles）上进行了测试。在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09)，我们还提供了一个与CMake
    3.5兼容的示例。
- en: 'We have so far discussed two ways of detecting external dependencies:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了两种检测外部依赖的方法：
- en: Using find-modules shipped with CMake. This is generally reliable and well tested.
    However, not all packages have a find-module in the official release of CMake.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CMake附带的find-modules。这通常是可靠且经过良好测试的。然而，并非所有包在CMake的官方发布版中都有一个find-module。
- en: Using `<package>Config.cmake`, `<package>ConfigVersion.cmake`, and `<package>Targets.cmake` files
    provided by the package vendor and installed alongside the package itself in standard
    locations.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包供应商提供的`<package>Config.cmake`、`<package>ConfigVersion.cmake`和`<package>Targets.cmake`文件，这些文件与包本身一起安装在标准位置。
- en: 'What if a certain dependency provides neither a find-module nor vendor-packaged
    CMake files? In this case, we are left with two options:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个依赖项既不提供find-module也不提供vendor-packaged CMake文件，我们该怎么办？在这种情况下，我们有两个选择：
- en: Rely on the `pkg-config` utility to discover packages on the system. This relies
    on the package vendors distributing metadata about their packages in `.pc` configuration
    files.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖`pkg-config`实用程序来发现系统上的包。这依赖于包供应商在`.pc`配置文件中分发有关其包的元数据。
- en: Write our own find-package module for the dependency.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为依赖项编写我们自己的find-package模块。
- en: 'In this recipe, we will show how to leverage `pkg-config` from within CMake
    to locate the ZeroMQ messaging library. The next recipe, *Detecting external libraries:
    II. Writing a find-module*, will show how to write your own basic find-module
    for ZeroMQ.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将展示如何从CMake内部利用`pkg-config`来定位ZeroMQ消息库。下一个食谱，*检测外部库：II. 编写find-module*，将展示如何为ZeroMQ编写自己的基本find-module。
- en: Getting ready
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code we will build is an example from the ZeroMQ manual at [http://zguide.zeromq.org/page:all](http://zguide.zeromq.org/page:all).
    It consists of two source files, `hwserver.c`, and `hwclient.c`,  which will be
    built into two separate executables. When executed, they will print the familiar
    "Hello, World" message.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的代码是ZeroMQ手册中的一个示例，网址为[http://zguide.zeromq.org/page:all](http://zguide.zeromq.org/page:all)。它由两个源文件`hwserver.c`和`hwclient.c`组成，将构建为两个单独的可执行文件。执行时，它们将打印熟悉的“Hello,
    World”消息。
- en: How to do it
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'This is a C project and we will use the C99 standard. We will build the `CMakeLists.txt`
    file step by step:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个C项目，我们将使用C99标准。我们将逐步构建`CMakeLists.txt`文件：
- en: 'We declare a C project and enforce compliance with the C99 standard:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个C项目并强制执行C99标准：
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We look for `pkg-config`, using its find-module shipped with CMake. Notice
    the `QUIET` argument passed to `find_package`. CMake will print messages only
    if the required `pkg-config` is not found:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们查找`pkg-config`，使用CMake附带的find-module。注意传递给`find_package`的`QUIET`参数。只有当所需的`pkg-config`未找到时，CMake才会打印消息：
- en: '[PRE93]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'When `pkg-config` is found, we will have access to the `pkg_search_module`
    function to search for any library or program that ships a package configuration
    `.pc` file. In our case, we look for the ZeroMQ library:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当找到`pkg-config`时，我们将能够访问`pkg_search_module`函数来搜索任何带有包配置`.pc`文件的库或程序。在我们的例子中，我们查找ZeroMQ库：
- en: '[PRE94]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'A status message is printed, in case the ZeroMQ library was found:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到ZeroMQ库，将打印状态消息：
- en: '[PRE95]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can then add the two executable targets and link against the `IMPORTED`
    target for ZeroMQ. This will set include directories and link libraries automatically:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以添加两个可执行目标，并与ZeroMQ的`IMPORTED`目标链接。这将自动设置包含目录和链接库：
- en: '[PRE96]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we can configure and build the example:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以配置并构建示例：
- en: '[PRE97]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In one terminal, start the server, which will respond with a message similar
    to this example:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个终端中启动服务器，它将响应类似于以下示例的消息：
- en: '[PRE98]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, in another terminal start the client, which will print the following:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在另一个终端启动客户端，它将打印以下内容：
- en: '[PRE99]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How it works
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'Once `pkg-config` is found, CMake will provide two functions to wrap the functionality
    offered by this program:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到`pkg-config`，CMake将提供两个函数来封装这个程序提供的功能：
- en: '`pkg_check_modules`, to find all modules (libraries and/or programs) in the
    passed list'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg_check_modules`，用于在传递的列表中查找所有模块（库和/或程序）'
- en: '`pkg_search_module`, to find the first working module in the passed list'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg_search_module`，用于在传递的列表中查找第一个可用的模块'
- en: 'These functions accept the `REQUIRED` and `QUIET` arguments, as `find_package`
    does. In more detail, our call to `pkg_search_module` is the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数接受`REQUIRED`和`QUIET`参数，就像`find_package`一样。更详细地说，我们对`pkg_search_module`的调用如下：
- en: '[PRE100]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here, the first argument is the prefix that will be used to name the target
    that is storing the result of the search for the ZeroMQ library: `PkgConfig::ZeroMQ`.
    Notice that we need to pass different options for the names of the library on
    the system: `libzeromq`, `libzmq`, and `lib0mq`. This is due to the fact that
    different operating systems and package managers can choose different names for
    the same package.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一个参数是用于命名存储ZeroMQ库搜索结果的目标的前缀：`PkgConfig::ZeroMQ`。注意，我们需要为系统上的库名称传递不同的选项：`libzeromq`、`libzmq`和`lib0mq`。这是因为不同的操作系统和包管理器可能会为同一个包选择不同的名称。
- en: The `pkg_check_modules` and `pkg_search_module` functions gained the `IMPORTED_TARGET`
    option and the functionality to also define an imported target in CMake 3.6\.
    Prior to this version of CMake, only the variables `ZeroMQ_INCLUDE_DIRS`, for
    the include directories, and `ZeroMQ_LIBRARIES`, for the link libraries, would
    have been defined for later use.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg_check_modules`和`pkg_search_module`函数在CMake 3.6中获得了`IMPORTED_TARGET`选项和定义导入目标的功能。在此之前的CMake版本中，只会为稍后使用定义变量`ZeroMQ_INCLUDE_DIRS`（包含目录）和`ZeroMQ_LIBRARIES`（链接库）。'
- en: 'Detecting external libraries: II. Writing a find-module'
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测外部库：II. 编写查找模块
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-10](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-10)
    and has a C example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-10](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-10)获取，并包含一个C示例。本配方适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'This recipe complements the previous recipe, *Detecting external libraries:
    I. Using pkg-config*. We will show how to write a basic find-module to locate
    the ZeroMQ messaging library on your system so that the detection of the library
    can be made to work on non-Unix operating systems. We will reuse the same server-client
    sample code.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方补充了之前的配方，*检测外部库：I. 使用pkg-config*。我们将展示如何编写一个基本的查找模块来定位系统上的ZeroMQ消息库，以便在非Unix操作系统上进行库检测。我们将重用相同的服务器-客户端示例代码。
- en: How to do it
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'This is a C project and we will use the C99 standard. We will build the `CMakeLists.txt`
    file step by step:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个C项目，我们将使用C99标准。我们将逐步构建`CMakeLists.txt`文件：
- en: 'We declare a C project and enforce compliance with the C99 standard:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个C项目并强制执行C99标准：
- en: '[PRE101]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We append the current source directory, `CMAKE_CURRENT_SOURCE_DIR`, to the
    list of paths where CMake will look for modules, `CMAKE_MODULE_PATH`. This is
    where our own `FindZeroMQ.cmake` module is located:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将当前源目录，`CMAKE_CURRENT_SOURCE_DIR`，添加到CMake查找模块的路径列表中，`CMAKE_MODULE_PATH`。这是我们自己的`FindZeroMQ.cmake`模块所在的位置：
- en: '[PRE102]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We will discuss `FindZeroMQ.cmake` later, but now that the `FindZeroMQ.cmake`
    module is available, we search for the library. This is a required dependency
    for our project. Since we did not use the `QUIET` option to `find_package`, status
    messages will be printed automatically when the library is found:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们稍后将讨论`FindZeroMQ.cmake`，但现在`FindZeroMQ.cmake`模块可用，我们搜索库。这是我们项目的必要依赖项。由于我们没有使用`find_package`的`QUIET`选项，当找到库时，将自动打印状态消息：
- en: '[PRE103]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We proceed to add the `hwserver` executable target. The include directories
    and link libraries are specified using the `ZeroMQ_INCLUDE_DIRS` and `ZeroMQ_LIBRARIES`
    variables set by the successful `find_package` command:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续添加`hwserver`可执行目标。使用`ZeroMQ_INCLUDE_DIRS`和`ZeroMQ_LIBRARIES`变量指定包含目录和链接库，这些变量由成功的`find_package`命令设置：
- en: '[PRE104]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Finally, we do the same for the `hwclient` executable target:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们对`hwclient`可执行目标也做同样的事情：
- en: '[PRE105]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The main `CMakeLists.txt` for this recipe differs from the one used in the previous
    recipe in the use of the `FindZeroMQ.cmake` module. This module searches for the
    ZeroMQ header files and libraries using the `find_path` and `find_library` CMake
    built-in commands and sets relevant variables using the `find_package_handle_standard_args`,
    as we did in Recipe 3, *Detecting Python modules and packages*.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的主要`CMakeLists.txt`与之前配方中使用的不同之处在于使用了`FindZeroMQ.cmake`模块。该模块使用`find_path`和`find_library`CMake内置命令搜索ZeroMQ头文件和库，并使用`find_package_handle_standard_args`设置相关变量，正如我们在配方3中所做的，*检测Python模块和包*。
- en: 'In `FindZeroMQ.cmake`, we first check whether the `ZeroMQ_ROOT` CMake variable
    was set by the user. This variable can be used to guide detection of the ZeroMQ
    library to a non-standard installation directory. The user might have set `ZeroMQ_ROOT`
    as an environment variable and we also check for that:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FindZeroMQ.cmake`中，我们首先检查用户是否设置了`ZeroMQ_ROOT` CMake变量。此变量可用于指导检测ZeroMQ库到非标准安装目录。用户可能已经将`ZeroMQ_ROOT`设置为环境变量，我们也检查了这一点：
- en: '[PRE106]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We then search for the location of the `zmq.h` header file on the system. This
    is based on the `_ZeroMQ_ROOT` variable and uses the `find_path` CMake command:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在系统上搜索`zmq.h`头文件的位置。这是基于`_ZeroMQ_ROOT`变量，并使用CMake的`find_path`命令：
- en: '[PRE107]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If the header file was successfully found, `ZeroMQ_INCLUDE_DIRS` is set to
    its location. We proceed to find the version of the ZeroMQ library available,
    using string manipulations and regular expressions:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功找到头文件，则将`ZeroMQ_INCLUDE_DIRS`设置为其位置。我们继续查找可用的ZeroMQ库版本，使用字符串操作和正则表达式：
- en: '[PRE108]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We then prepare the `ZeroMQ_VERSION` variable for the `find_package_handle_standard_args`
    command:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为`find_package_handle_standard_args`命令准备`ZeroMQ_VERSION`变量：
- en: '[PRE109]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We use the `find_library` command to search for the `ZeroMQ` library. Here,
    we need to make a distinction between Unix-based and Windows platforms, since
    the naming conventions for libraries are different:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`find_library`命令来搜索`ZeroMQ`库。在这里，我们需要在Unix基础和Windows平台之间做出区分，因为库的命名约定不同：
- en: '[PRE110]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Finally, we include the standard `FindPackageHandleStandardArgs.cmake` module
    and invoke the corresponding CMake command. If all required variables are found
    and the version matches, then the `ZeroMQ_FOUND` variable is set to `TRUE`:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们包含标准的`FindPackageHandleStandardArgs.cmake`模块并调用相应的CMake命令。如果找到所有必需的变量并且版本匹配，则将`ZeroMQ_FOUND`变量设置为`TRUE`：
- en: '[PRE111]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The `FindZeroMQ.cmake` module we just described has been adapted from [https://github.com/zeromq/azmq/blob/master/config/FindZeroMQ.cmake](https://github.com/zeromq/azmq/blob/master/config/FindZeroMQ.cmake).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的`FindZeroMQ.cmake`模块是从[https://github.com/zeromq/azmq/blob/master/config/FindZeroMQ.cmake](https://github.com/zeromq/azmq/blob/master/config/FindZeroMQ.cmake)改编而来的。
- en: How it works
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Find-modules typically follow a specific pattern:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 查找模块通常遵循特定的模式：
- en: Check whether the user provided a custom location for the desired package.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查用户是否为所需包提供了自定义位置。
- en: 'Use commands from the `find_` family to search for known required components
    of the required package, that is, header files, libraries, executables, and so
    forth. We have used `find_path` to find the full path to a header file and `find_library` to
    find a library. CMake also offers `find_file`, `find_program`, and `find_package`.
    These commands have the following general signature:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`find_`家族的命令来搜索所需包的已知必需组件，即头文件、库、可执行文件等。我们已经使用`find_path`来找到头文件的完整路径，并使用`find_library`来找到一个库。CMake还提供了`find_file`、`find_program`和`find_package`。这些命令具有以下一般签名：
- en: '[PRE113]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Here, `<VAR>` will hold the result of the search, if successful, or `<VAR>-NOTFOUND`
    if unsuccessful. `NAMES` and `PATHS` are names for the file CMake should look
    for and paths where the search should be directed, respectively.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，`<VAR>`将持有搜索的结果，如果成功，或者`<VAR>-NOTFOUND`如果失败。`NAMES`和`PATHS`是CMake应该查找的文件的名称和搜索应该指向的路径，分别。
- en: From the results of this preliminary search, a version number is extracted.
    In our example, the ZeroMQ header file contains the library version, which can
    be extracted with string operations and regular expressions.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这次初步搜索的结果中，提取版本号。在我们的例子中，ZeroMQ头文件包含库版本，可以使用字符串操作和正则表达式提取。
- en: Finally, the `find_package_handle_standard_args` command is invoked. This will
    handle the standard `REQUIRED`, `QUIET`, and version arguments to the `find_package`
    command, additionally setting the `ZeroMQ_FOUND` variable.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`find_package_handle_standard_args`命令。这将处理`find_package`命令的标准`REQUIRED`、`QUIET`和版本参数，此外还设置`ZeroMQ_FOUND`变量。
- en: The full documentation for any CMake command can be obtained from the command
    line. For example, `cmake --help-command find_file` will output the manual page
    for the `find_file` command. For the manual page of CMake standard modules, use
    the `--help-module` CLI switch. For example, `cmake --help-module FindPackageHandleStandardArgs`
    will output to screen the manual page for the `FindPackageHandleStandardArgs.cmake`
    module.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 任何CMake命令的完整文档都可以从命令行获取。例如，`cmake --help-command find_file` 将输出 `find_file`
    命令的手册页。对于CMake标准模块的手册页，使用 `--help-module` CLI开关。例如，`cmake --help-module FindPackageHandleStandardArgs`
    将屏幕输出 `FindPackageHandleStandardArgs.cmake` 模块的手册页。
- en: There is more
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'To summarize, when discovering packages there are four available routes:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在发现软件包时，有四种可用的路线：
- en: Use the CMake files `<package>Config.cmake`, `<package>ConfigVersion.cmake`,
    and `<package>Targets.cmake` provided by the package vendor and installed alongside
    the package itself in standard locations.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用软件包供应商提供的CMake文件 `packageConfig.cmake`、`packageConfigVersion.cmake` 和 `packageTargets.cmake`，并将其安装在与软件包本身一起的标准位置。
- en: Use a find-module for the desired package, whether shipped by CMake or a third
    party.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所需的软件包的find-module，无论是由CMake还是第三方提供的。
- en: Resort to `pkg-config`, as shown in this recipe.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采用本食谱中所示的 `pkg-config` 方法。
- en: If none of these are viable, write your own find-module.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这些都不适用，编写自己的find-module。
- en: The four alternative routes have been ranked by relevance, but each approach
    has its challenges.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 四种替代路线已经按相关性排名，但每种方法都有其挑战。
- en: Not all package vendors provide CMake discovery files, but it is becoming more
    common. This is due to the fact that exporting CMake targets makes it very easy
    for third-party code to consume additional dependencies imposed by libraries and/or
    programs that it depends on.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有软件包供应商都提供CMake发现文件，但这变得越来越普遍。这是因为导出CMake目标使得第三方代码消费库和/或程序所依赖的额外依赖项变得非常容易。
- en: Find-modules have been the workhorse of dependency location in CMake since the
    very beginning. However, most of them still rely on setting variables consumed
    by the dependent, such as `Boost_INCLUDE_DIRS`, `PYTHON_INTERPRETER`, and so forth.
    This approach makes it difficult to redistribute your own package for third-parties
    and ensure that your dependencies are consistently met.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Find-modules自CMake诞生之初就是依赖定位的工作马。然而，它们中的大多数仍然依赖于设置由依赖方消费的变量，例如 `Boost_INCLUDE_DIRS`、`PYTHON_INTERPRETER`
    等。这种方法使得为第三方重新分发自己的软件包并确保依赖项得到一致满足变得困难。
- en: The approach using `pkg-config` can work very well since it has become a *de
    facto* standard for Unix-based systems. For this reason, however, it is not a
    fully cross-platform approach. Moreover, as the CMake documentation states, in
    some cases, the user can accidentally override package detection and lead `pkg-config`
    to supply incorrect information.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pkg-config` 的方法可以很好地工作，因为它已经成为基于Unix的系统的*事实*标准。因此，它不是一个完全跨平台的方法。此外，正如CMake文档所述，在某些情况下，用户可能会意外地覆盖软件包检测，导致
    `pkg-config` 提供错误的信息。
- en: The very last resort is then to write your own find-module CMake script, as
    we have done in this recipe. This is doable and relies on the `FindPackageHandleStandardArgs.cmake`
    module we briefly discussed. However, writing a fully comprehensive find-module
    is far from trivial; there are many corner cases that are hard to discover, and
    we have shown an example of that when looking for the ZeroMQ library files on
    Unix and Windows platforms.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的选择是编写自己的find-module CMake脚本，正如我们在本食谱中所做的那样。这是可行的，并且依赖于我们简要讨论过的 `FindPackageHandleStandardArgs.cmake`
    模块。然而，编写一个完全全面的find-module远非易事；有许多难以发现的边缘情况，我们在寻找Unix和Windows平台上的ZeroMQ库文件时展示了这样一个例子。
- en: 'These concerns and difficulties are very well-known to all software developers,
    as witnessed by the lively discussions on the CMake mailing list: [https://cmake.org/pipermail/cmake/2018-May/067556.html](https://cmake.org/pipermail/cmake/2018-May/067556.html). `pkg-config`
    is accepted among Unix package developers, but it cannot be easily ported to not-Unix
    platforms. CMake configuration files are powerful, but not all software developers
    are familiar with the CMake syntax. The Common Package Specification project is
    a very recent attempt at unifying the `pkg-config` and CMake configuration files
    approaches for package discovery. You can find more information on the project''s
    website: [https://mwoehlke.github.io/cps/](https://mwoehlke.github.io/cps/)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关注点和困难对于所有软件开发者来说都非常熟悉，这一点在CMake邮件列表上的热烈讨论中得到了证明：[https://cmake.org/pipermail/cmake/2018-May/067556.html](https://cmake.org/pipermail/cmake/2018-May/067556.html)。`pkg-config`在Unix软件包开发者中被广泛接受，但它不容易移植到非Unix平台。CMake配置文件功能强大，但并非所有软件开发者都熟悉CMake语法。Common
    Package Specification项目是一个非常新的尝试，旨在统一`pkg-config`和CMake配置文件的软件包发现方法。您可以在项目网站上找到更多信息：[https://mwoehlke.github.io/cps/](https://mwoehlke.github.io/cps/)
- en: 'In [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml), *Writing an Installer*,
    we will discuss how to make your own package discoverable to third-party applications
    by using the first route outlined in the previous discussion: providing your own
    CMake discovery files alongside your project.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml)《编写安装程序》中，我们将讨论如何通过使用前述讨论中概述的第一条路径，即在项目旁边提供自己的CMake发现文件，使您自己的软件包对第三方应用程序可发现。
