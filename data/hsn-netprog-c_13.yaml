- en: Implementing a Secure Web Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现安全Web服务器
- en: In this chapter, we will build a simple HTTPS server program. This serves as
    the counterpart to the HTTPS client we worked on in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个简单的HTTPS服务器程序。这作为我们在上一章中工作的HTTPS客户端的对立面。
- en: HTTPS is powered by **Transport Layer Security** (**TLS**). HTTPS servers, unlike
    HTTPS clients, are expected to identify themselves with certificates. We'll cover
    how to listen for HTTPS connections, provide certificates, and send an HTTP response
    over TLS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS由**传输层安全性**（**TLS**）提供支持。与HTTPS客户端不同，HTTPS服务器预计会使用证书来识别自己。我们将介绍如何监听HTTPS连接、提供证书以及通过TLS发送HTTP响应。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: HTTPS overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS概述
- en: HTTPS certificates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS证书
- en: HTTPS server setup with OpenSSL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenSSL设置HTTPS服务器
- en: Accepting HTTPS connections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受HTTPS连接
- en: Common problems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题
- en: OpenSSL alternatives
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL替代方案
- en: Direct TLS termination alternatives
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接TLS终止替代方案
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter continues where [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml),
    *Loading Secure Web Pages with HTTPS and OpenSSL*, left off. This chapter continues
    to use the OpenSSL library. It is imperative that you have the OpenSSL library
    installed and that you know the basics of programming with OpenSSL. Refer to [Chapter
    9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml), *Loading Secure Web Pages with
    HTTPS and OpenSSL*, for basic information about OpenSSL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从[第9章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)，“使用HTTPS和OpenSSL加载安全Web页面”的结尾继续。本章将继续使用OpenSSL库。您必须安装OpenSSL库，并且需要了解使用OpenSSL编程的基础知识。有关OpenSSL的基本信息，请参阅[第9章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)，“使用HTTPS和OpenSSL加载安全Web页面”。
- en: The example programs from this chapter can be compiled using any modern C compiler.
    We recommend **MinGW** for Windows and **GCC** for Linux and macOS. You also need
    to have the OpenSSL library installed. See [Appendix B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml),
    *Setting Up Your C Compiler on Windows;* [Appendix C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml),
    *Setting Up Your C Compiler on Linux;* and [Appendix D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml),
    *Setting Up Your C Compiler on macOS*, for compiler setup and OpenSSL installation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例程序可以使用任何现代C编译器编译。我们推荐Windows上的**MinGW**和Linux及macOS上的**GCC**。您还需要安装OpenSSL库。有关编译器和OpenSSL安装的说明，请参阅[附录B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，“在Windows上设置您的C编译器”；[附录C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，“在Linux上设置您的C编译器”；以及[附录D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，“在macOS上设置您的C编译器”。
- en: The code for this book can be found at [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可在[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)找到。
- en: 'From the command line, you can download the code for this chapter by using
    the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从命令行使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS. When
    compiling on Windows, each example program requires linking with the **Winsock**
    library. This is accomplished by passing the `-lws2_32` option to `gcc`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都可在Windows、Linux和macOS上运行。在Windows上编译时，每个示例程序都需要与**Winsock**库链接。这可以通过向`gcc`传递`-lws2_32`选项来实现。
- en: Each example also needs to be linked against the OpenSSL libraries, `libssl.a`
    and `libcrypto.a`. This is accomplished by passing  `-lssl -lcrypto` to GCC.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例还需要链接到OpenSSL库，`libssl.a`和`libcrypto.a`。这可以通过向GCC传递`-lssl -lcrypto`来实现。
- en: We provide the exact commands needed to compile each example as it is introduced.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供编译每个示例所需的精确命令。
- en: All of the example programs in this chapter require the same header files and
    C macros that we developed in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*. For brevity, we put these statements in a
    separate header file, `chap10.h`, which we can include in each program. For an
    explanation of these statements, please refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有示例程序都需要与我们在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，“掌握Socket
    API”，中开发的相同头文件和C宏。为了简洁，我们将这些语句放在一个单独的头文件`chap10.h`中，可以在每个程序中包含它。有关这些语句的解释，请参阅[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，“掌握Socket
    API”。
- en: 'The content of `chap10.h` begins by including the required networking header
    files. The code for this is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`chap10.h` 的内容首先包含所需的网络头文件。相应的代码如下：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also define some macros to assist with writing portable code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一些宏来帮助编写可移植的代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, `chap10.h` includes the additional headers required by this chapter''s
    programs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`chap10.h` 包含了这一章程序所需的额外头文件：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: HTTPS and OpenSSL summary
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS 和 OpenSSL 概述
- en: We begin with a quick review of the HTTPS protocol, as covered in [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml),
    *Loading Secure Web Pages with HTTPS and OpenSSL*. However, we do recommend that
    you work through [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml), *Loading
    Secure Web Pages with HTTPS and OpenSSL*, before beginning this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先快速回顾一下 HTTPS 协议，这部分内容在[第 9 章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)中有详细说明，即*使用
    HTTPS 和 OpenSSL 加载安全网页*。然而，我们仍然建议你在开始这一章之前，先阅读[第 9 章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)，*使用
    HTTPS 和 OpenSSL 加载安全网页*。
- en: HTTPS uses TLS to add security to HTTP. You will recall from [Chapter 6](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml),
    *Building a Simple Web Client*, and [Chapter 7](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml),
    *Building a Simple Web Server*, that HTTP is a text-based protocol that works
    over TCP on port `80`. The TLS protocol can be used to add security to any TCP-based
    protocol. Specifically, TLS is used to provide security for HTTPS. So in a nutshell,
    HTTPS is simply HTTP with TLS. The default HTTPS port is `443`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 使用 TLS 为 HTTP 添加安全性。你会记得从[第 6 章](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml)，*构建简单的
    Web 客户端*和[第 7 章](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml)，*构建简单的 Web 服务器*中了解到，HTTP
    是一种基于文本的协议，它在 TCP 的 `80` 端口上工作。TLS 协议可以用于为任何基于 TCP 的协议添加安全性。具体来说，TLS 用于为 HTTPS
    提供安全性。所以简单来说，HTTPS 就是带有 TLS 的 HTTP。默认的 HTTPS 端口是 `443`。
- en: OpenSSL is a popular open source library that provides functionality for TLS/SSL
    and HTTPS. We use it in this book to provide the methods needed to implement HTTPS
    clients and servers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 是一个流行的开源库，它提供了 TLS/SSL 和 HTTPS 的功能。我们在本书中使用它来提供实现 HTTPS 客户端和服务器所需的方法。
- en: Generally, HTTPS connections are first made using TCP sockets. Once the TCP
    connection is established, OpenSSL is used to negotiate a TLS connection over
    the open TCP connection. From that point forward, OpenSSL functions are used to
    send and receive data over the TLS connection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，HTTPS 连接首先使用 TCP 套接字建立。一旦 TCP 连接建立，OpenSSL 就用于在开放的 TCP 连接上协商 TLS 连接。从那时起，OpenSSL
    函数用于通过 TLS 连接发送和接收数据。
- en: An important part of communication security is being able to trust that the
    connection is to the intended party. No amount of data encryption helps if you
    have connected to an impostor. TLS uses certificates to prevent against connecting
    to impostors and man-in-the-middle attacks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通信安全的一个重要部分是能够信任连接是到预期的当事人。如果你连接到了冒名顶替者，那么任何数据加密都无法帮助。TLS 使用证书来防止连接到冒名顶替者和中间人攻击。
- en: We now need to understand certificates in more detail before we can proceed
    with our HTTPS server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行 HTTPS 服务器之前，我们需要更详细地了解证书。
- en: Certificates
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书
- en: '**Certificates** are an important part of the TLS protocol. Although certificates
    can be used on both the client and server side, HTTPS generally only uses server
    certificates. These certificates identify to the client that they are connected
    to a trusted server.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**证书**是 TLS 协议的重要组成部分。尽管证书可以在客户端和服务器端都使用，但 HTTPS 通常只使用服务器证书。这些证书向客户端表明，他们连接到了一个受信任的服务器。'
- en: Without certificates, a client wouldn't be able to tell whether it was connected
    to the intended server or an impostor server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 没有证书，客户端就无法判断自己是否连接到了预期的服务器或冒名顶替的服务器。
- en: Certificates work using a **chain-of-trust** model. Each HTTPS client has a
    few certificate authorities that they explicitly trust, and certificate authorities
    offer services where they digitally sign certificates. This service is usually
    done for a small fee, and usually only after some simple verification of the requester.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 证书使用**信任链**模型工作。每个 HTTPS 客户端都有几个他们明确信任的证书颁发机构，证书颁发机构提供数字签名证书的服务。这项服务通常需要收取少量费用，并且通常在请求者进行一些简单的验证之后才会进行。
- en: When an HTTPS client sees a certificate signed by an authority it trusts, then
    it also trusts that certificate. Indeed, these chains of trust can run deep. For
    example, most certificate authorities also allow resellers. In these cases, the
    certificate authority signs an intermediate certificate to be used by the reseller.
    The reseller then uses this intermediate certificate to sign new certificates.
    Clients trust the intermediate certificates because they are signed by trusted
    certificate authorities, and clients trust the certificates signed by resellers
    because they trust the intermediate certificates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当HTTPS客户端看到一个它信任的权威机构签发的证书时，它也信任该证书。确实，这些信任链可以非常深入。例如，大多数证书颁发机构也允许转售商。在这些情况下，证书颁发机构签发一个中间证书供转售商使用。然后，转售商使用这个中间证书来签发新的证书。客户端信任中间证书，因为它们是由受信任的证书颁发机构签发的，客户端信任转售商签发的证书，因为他们信任中间证书。
- en: Certificate authorities commonly offer two types of validation. **Domain validation**
    is where a signed certificate is issued after simply verifying that the certificate
    recipient can be reached at the given domain. This is usually done by having the
    certificate requester temporarily modify a DNS record, or reply to an email sent
    to their *whois* contact.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构通常提供两种类型的验证。**域名验证**是指仅在验证证书接收者可以在指定的域名下被访问后，就颁发一个已签名的证书。这通常是通过让证书请求者临时修改DNS记录，或回复发送到他们*whois*联系人的电子邮件来完成的。
- en: '**Let''s Encrypt** is a relatively new certificate issuer that issues certificates
    for free. They do this using an automated model. **Domain validation** is done
    by having the certificate requester serve a small file over HTTP or HTTPS.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**Let''s Encrypt**是一个相对较新的证书颁发机构，它免费颁发证书。他们通过自动化模型来完成这项工作。**域名验证**是通过让证书请求者通过HTTP或HTTPS服务一个小文件来完成的。'
- en: Domain validation is the most common type of validation. An HTTPS server using
    domain validation assures an HTTPS client that they are connected to the domain
    that they think they are. It implies that their connection wasn't silently hijacked
    or otherwise intercepted.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 域名验证是最常见的验证类型。使用域名验证的HTTPS服务器向HTTPS客户端保证，他们连接到的域名是他们认为的域名。这意味着他们的连接没有被静默劫持或以其他方式拦截。
- en: Certificate authorities also offer **Extended Validation** (**EV**) certificates.
    EV certificates are only issued after the authority verifies the recipient's identity.
    This is usually done using public records and a phone call.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构还提供**扩展验证**（**EV**）证书。EV证书只有在权威机构验证了接收者的身份后才会颁发。这通常是通过使用公共记录和电话通话来完成的。
- en: For public-facing HTTPS applications, it is important that you obtain a certificate
    from a recognized certificate authority. However, this can sometimes be tedious,
    and it is often much more convenient to obtain a **self-signed** certificate for
    development and testing purposes. Let's do that now.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向公众的HTTPS应用程序，从公认的证书颁发机构获取证书是很重要的。然而，这有时可能会很繁琐，对于开发和测试目的，获取一个**自签名**证书通常要方便得多。我们现在就来做这件事。
- en: Self-signed certificates with OpenSSL
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenSSL的自签名证书
- en: Certificates signed by recognized authorities are essential to establish the
    chain of trust needed for public websites. However, it is much easier to obtain
    a self-signed certificate for testing or development.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由公认的权威机构签发的证书对于建立公共网站所需的信任链至关重要。然而，对于测试或开发来说，获取一个自签名证书要容易得多。
- en: It is also acceptable to use a self-signed certificate for certain private applications
    where the client can be deployed with a copy of the certificate, and trust only
    that certificate. This is called **certificate pinning**. Indeed, when used properly,
    certificate pinning can be more secure than using a certificate authority. However,
    it is not appropriate for public-facing websites.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些私有的应用程序，其中客户端可以部署带有证书的副本，并且只信任该证书，使用自签名证书也是可以接受的。这被称为**证书固定**。确实，当正确使用时，证书固定可能比使用证书颁发机构更安全。然而，它不适合面向公众的网站。
- en: We require a certificate to test our HTTPS server. We use a self-signed certificate
    because they are the easiest to obtain. The downside to this method is that web
    browsers won't trust our server. We can get around this by clicking through a
    few warnings in the web browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个证书来测试我们的HTTPS服务器。我们使用自签名证书，因为它们最容易获得。这种方法的不利之处在于，网络浏览器不会信任我们的服务器。我们可以通过在浏览器中点击几个警告来解决这个问题。
- en: OpenSSL provides tools to make self-signing certificates very easy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL提供了工具，使得自签名证书的签发变得非常简单。
- en: 'The basic command to self-sign a certificate is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书的基本命令如下：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: OpenSSL asks questions about what to put on the certificate, including the subject,
    your name, company, location, and so on. You can use the defaults on all of these
    as this doesn't matter for our testing purposes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL会询问有关证书上应放置的内容，包括主题、您的姓名、公司、位置等。您可以在所有这些方面使用默认值，因为这对我们的测试目的并不重要。
- en: The preceding command places the new certificate in `cert.pem` and the key for
    it in `key.pem`. Our HTTPS server needs both files. `cert.pem` is the certificate
    that gets sent to the connected client, and `key.pem` provides our server with
    the encryption key that proves that it owns the certificate. Keeping this key
    secret is imperative.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将新证书放置在`cert.pem`中，并将对应的密钥放在`key.pem`中。我们的HTTPS服务器需要这两个文件。`cert.pem`是发送给连接客户端的证书，而`key.pem`为我们服务器提供加密密钥，以证明它拥有该证书。保护此密钥的秘密至关重要。
- en: 'Here is a screenshot showing the generation of a new self-signed certificate:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一张显示生成新自签名证书的截图：
- en: '![](img/33777266-b70f-441a-861a-c06e3133a2df.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33777266-b70f-441a-861a-c06e3133a2df.png)'
- en: 'You can also use OpenSSL to view a certificate. The following command does
    this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用OpenSSL查看证书。以下命令可以完成此操作：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you''re on Windows using MSYS, you may get garbled line endings from the
    previous command. If so, try using `unix2dos` to fix it, as shown by the following
    command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上使用MSYS，您可能会从之前的命令中得到乱码的行结束符。如果是这样，请尝试使用`unix2dos`来修复它，如下所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is what a typical self-signed certificate looks like:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的自签名证书的外观：
- en: '![](img/4a937bae-cd76-4e13-9638-84b14a0172ed.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a937bae-cd76-4e13-9638-84b14a0172ed.png)'
- en: Now that we have a usable certificate, we are ready to begin our HTTPS server
    programming.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可用的证书，我们就可以开始我们的HTTPS服务器编程了。
- en: HTTPS server with OpenSSL
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenSSL的HTTPS服务器
- en: Let's go over some basics of using the OpenSSL library in server applications
    before beginning a concrete example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始具体示例之前，让我们先回顾一下在服务器应用程序中使用OpenSSL库的一些基本知识。
- en: 'Before OpenSSL can be used, it must be initialized. The following code initializes
    the OpenSSL library, loads the requisite encryption algorithms, and loads useful
    error strings:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用OpenSSL之前，必须对其进行初始化。以下代码初始化了OpenSSL库，加载必要的加密算法，并加载有用的错误字符串：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Refer to the previous [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml),
    *Loading Secure Web Pages with HTTPS and OpenSSL,* for more information.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考之前的[第9章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)，*使用HTTPS和OpenSSL加载安全网页*，获取更多信息。
- en: Our server also needs to create an SSL context object. This object works as
    a sort of factory from which we can create TLS/SSL connections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器还需要创建一个SSL上下文对象。该对象充当一种工厂，我们可以从中创建TLS/SSL连接。
- en: 'The following code creates the `SSL_CTX` object:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建`SSL_CTX`对象：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you're using an older version of OpenSSL, you may need to replace `TLS_server_method()` with `TLSv1_2_server_method()` in
    the preceding code. However, a better solution is to upgrade to a newer OpenSSL
    version.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用较旧的OpenSSL版本，您可能需要在上述代码中将`TLS_server_method()`替换为`TLSv1_2_server_method()`。然而，更好的解决方案是升级到较新的OpenSSL版本。
- en: 'After the `SSL_CTX` object is created, we can set it to use our self-signed
    certificate and key. The following code does this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`SSL_CTX`对象之后，我们可以将其设置为使用我们的自签名证书和密钥。以下代码执行此操作：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That concludes the minimal OpenSSL setup needed for an HTTPS server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了HTTPS服务器所需的最低限度的OpenSSL设置。
- en: The server should then listen for incoming TCP connections. This was covered
    in detail in [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An In-Depth
    Overview of TCP Connections*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应随后监听传入的TCP连接。这在[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP连接的深入概述*中已有详细说明。
- en: After a new TCP connection is established, we use the socket returned by `accept()`
    to create our TLS/SSL socket.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立新的TCP连接后，我们使用`accept()`返回的套接字创建我们的TLS/SSL套接字。
- en: 'First, a new `SSL` object is created using our SSL context from earlier. The
    following code demonstrates this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用我们之前创建的SSL上下文创建一个新的`SSL`对象。以下代码演示了这一点：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `SSL` object is then linked to our open TCP socket using `SSL_set_fd()`.
    The `SSL_accept()` function is called to establish the TLS/SSL connection. The
    following code demonstrates this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`SSL_set_fd()`将`SSL`对象链接到我们的打开的TCP套接字。调用`SSL_accept()`函数以建立TLS/SSL连接。以下代码演示了这一点：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may notice that this code is very similar to the HTTPS client code from [Chapter
    9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml), L*oading Secure Web Pages with
    HTTPS and OpenSSL*. The only real differences are in the setup of the SSL context
    object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这段代码与第9章中HTTPS客户端代码非常相似，[使用HTTPS和OpenSSL加载安全网页](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)。唯一的真正区别在于SSL上下文对象的设置。
- en: Once the TLS connection is established, data can be sent and received using
    `SSL_write()` and `SSL_read()`. These functions replace the `send()` and `recv()`
    functions used with TCP sockets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了TLS连接，就可以使用`SSL_write()`和`SSL_read()`发送和接收数据。这些函数替换了与TCP套接字一起使用的`send()`和`recv()`函数。
- en: 'When the connection is finished, it is important to free resources, as shown
    by the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 连接完成后，释放资源很重要，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When your program is finished accepting new connections, you should also free
    the SSL context object. The following code shows this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序完成接受新连接后，你也应该释放SSL上下文对象。下面的代码展示了这一点：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With an understanding of the basics out of the way, let's solidify our knowledge
    by implementing a simple example program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了基础知识之后，让我们通过实现一个简单的示例程序来巩固我们的知识。
- en: Time server example
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间服务器示例
- en: 'In this chapter, we develop a simple time server that displays the time to
    an HTTPS client. This program is an adaptation of `time_server.c` from [Chapter
    2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to Grips with Socket
    APIs*, which served the time over plain HTTP. Our program begins by including
    the chapter header, defining `main()`, and initializing Winsock on Windows. The
    code for this is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个简单的显示时间给HTTPS客户端的时间服务器。这个程序是`time_server.c`的改编，来自第2章，*掌握Socket API入门*，它通过纯HTTP提供了时间。我们的程序首先包含章节头文件，定义`main()`，并在Windows上初始化Winsock。代码如下：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The OpenSSL library is then initialized with the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下代码初始化OpenSSL库：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An SSL context object must be created for our server. This is done using a
    call to `SSL_CTX_new()`. The following code shows this call:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 必须为我们的服务器创建一个SSL上下文对象。这是通过调用`SSL_CTX_new()`完成的。下面的代码展示了这个调用：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you're using an older version of OpenSSL, you may need to replace `TLS_server_method()` with `TLSv1_2_server_method()` in
    the preceding code. However, you should probably upgrade to a newer OpenSSL version
    instead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是较旧的OpenSSL版本，你可能需要在前面代码中将`TLS_server_method()`替换为`TLSv1_2_server_method()`。然而，你可能最好升级到较新的OpenSSL版本。
- en: 'Once the SSL context has been created, we can associate our server''s certificate
    with it. The following code sets the SSL context to use our certificate:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了SSL上下文，我们就可以将我们的服务器证书与之关联。下面的代码将SSL上下文设置为使用我们的证书：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Make sure that you've generated a proper certificate and key. Refer to the *Self-signed
    certificate with OpenSSL* section from earlier in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经生成了适当的证书和密钥。请参考本章早些时候的*使用OpenSSL的自签名证书*部分。
- en: 'Once the SSL context is configured with the proper certificate, our program
    creates a listening TCP socket in the normal way. It begins with a call to `getaddrinfo()`
    and `socket()`, as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用适当的证书配置了SSL上下文，我们的程序就会以正常方式创建一个监听TCP套接字。它从调用`getaddrinfo()`和`socket()`开始，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The socket created by the preceding code is bound to the listening address
    with `bind()`. The `listen()` function is used to set the socket in a listening
    state. The following code demonstrates this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码创建的套接字使用`bind()`绑定到监听地址。`listen()`函数用于将套接字设置为监听状态。下面的代码演示了这一点：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the preceding code isn't familiar, please refer to [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP Connections*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的代码不熟悉，请参阅第3章，*TCP连接的深入概述*。
- en: Note that the preceding code sets the listening port number to `8080`. The standard
    port for HTTPS is `443`. It is often more convenient to test with a high port
    number, since low port numbers require special privileges on some operating systems.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码将监听端口号设置为`8080`。HTTPS的标准端口号是`443`。通常使用高端口进行测试会更方便，因为低端口在某些操作系统上需要特殊权限。
- en: Our server uses a `while` loop to accept multiple connections. Note that this
    isn't true multiplexing, as only one connection is handled at a time. However,
    it proves convenient for testing purposes to be able to handle multiple connections
    serially. Our self-signed certificate causes mainstream browsers to reject our
    connection on the first try. The connection only succeeds after an exception is
    added. By having our code loop, it makes adding this exception easier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器使用`while`循环接受多个连接。请注意，这并不是真正的多路复用，因为一次只处理一个连接。然而，对于测试目的来说，能够顺序处理多个连接是方便的。我们的自签名证书导致主流浏览器在第一次尝试时拒绝我们的连接。只有在添加异常之后，连接才能成功。通过让我们的代码循环，这使得添加此异常变得更容易。
- en: 'Our `while` loop begins by using `accept()` to wait for new connections. This
    is done by the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`while`循环首先使用`accept()`等待新的连接。这是通过以下代码完成的：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the connection is accepted, we use `getnameinfo()` to print out the client''s
    address. This is sometimes useful for debugging purposes. The following code does
    this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接被接受，我们使用`getnameinfo()`来打印客户端的地址。这有时对调试很有用。以下代码执行此操作：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the TCP connection is established, an `SSL` object needs to be created.
    This is done with a call to `SSL_new()`, as shown by the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 TCP 连接建立，就需要创建一个 `SSL` 对象。这是通过调用`SSL_new()`完成的，如下所示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The SSL object is associated with the open socket by a call to `SSL_set_fd()`.
    Then, a TLS/SSL connection can be initialized with a call to `SSL_accept()`. The
    following code shows this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`SSL_set_fd()`将 SSL 对象与打开的套接字关联起来。然后，通过调用`SSL_accept()`初始化 TLS/SSL 连接。以下代码显示了这一点：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, the call to the `SSL_accept()` function can fail for
    many reasons. For example, if the connected client doesn't trust our certificate,
    or the client and server can't agree on a cipher suite, then the call to `SSL_accept()` fails.
    When it fails, we just clean up the allocated resources and use `continue` to
    repeat our listening loop.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，调用`SSL_accept()`函数可能会因许多原因失败。例如，如果连接的客户端不相信我们的证书，或者客户端和服务器无法就加密套件达成一致，那么对`SSL_accept()`的调用就会失败。当它失败时，我们只需清理分配的资源并使用`continue`重复我们的监听循环。
- en: Once the TCP and TLS/SSL connections are fully open, we use `SSL_read()` to
    receive the client's request. Our program ignores the content of this request.
    This is because our program only serves the time. It doesn't matter what the client
    has asked for—our server responds with the time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 TCP 和 TLS/SSL 连接完全打开，我们使用`SSL_read()`来接收客户端的请求。我们的程序忽略此请求的内容。这是因为我们的程序只提供时间。客户端请求的内容无关紧要——我们的服务器会以时间响应。
- en: 'The following code uses `SSL_read()` to wait on and read the client''s request:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`SSL_read()`等待并读取客户端的请求：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code uses `SSL_write()` to transmit the HTTP headers to the client:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`SSL_write()`将 HTTP 头部信息传输到客户端：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `time()` and `ctime()` functions are then used to format the current time.
    Once the time is formatted in `time_msg`, it is also sent to the client using
    `SSL_write()`. The following code shows this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`time()`和`ctime()`函数格式化当前时间。一旦时间在`time_msg`中格式化，它也会通过`SSL_write()`发送到客户端。以下代码显示了这一点：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, after the data is transmitted to the client, the connection is closed,
    and the loop repeats. The following code shows this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在数据传输到客户端后，连接被关闭，循环重复。以下代码显示了这一点：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the loop terminates, it would be useful to close the listening socket and
    clean up the SSL context, as demonstrated by the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环终止，关闭监听套接字并清理 SSL 上下文将很有用，如下所示：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, Winsock should be cleaned up if necessary:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果需要，Winsock 应该被清理：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That concludes `tls_time_server.c`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`tls_time_server.c`。
- en: 'You can compile and run the program using the following commands on macOS or
    Linux:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在 macOS 或 Linux 上编译和运行程序：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On Windows, compiling and running the program is done with the following commands:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，编译和运行程序使用以下命令：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you have linker errors, please be sure that the OpenSSL library is installed
    correctly. You may find it helpful to attempt to compile `openssl_version.c` from
    [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml), *Loading Secure Web Pages
    with HTTPS and OpenSSL*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到链接错误，请确保 OpenSSL 库已正确安装。尝试从[第 9 章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)，*使用
    HTTPS 和 OpenSSL 加载安全网页*编译`openssl_version.c`可能会有所帮助。
- en: 'The following screenshot shows what running `tls_time_server` might look like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行`tls_time_server`可能的样子：
- en: '![](img/bb118df5-9e0b-4848-8b77-0b8834503033.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb118df5-9e0b-4848-8b77-0b8834503033.png)'
- en: 'You can connect to the time server by navigating your web browser to `https://127.0.0.1:8080`.
    Upon the first connection, your browser will reject the self-signed certificate.
    The following screenshot shows what this rejection looks like in Firefox:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在网页浏览器中导航到`https://127.0.0.1:8080`来连接到时间服务器。在第一次连接时，你的浏览器将拒绝自签名证书。以下截图显示了在Firefox中这种拒绝的样子：
- en: '![](img/fdfb5821-6712-48de-85c3-4b37b22f8771.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdfb5821-6712-48de-85c3-4b37b22f8771.png)'
- en: To access the time server, you need to add an exception in the browser. The
    method for this is different in each browser, but generally, there is an Advanced button
    that leads to an option to either add a certificate exception or otherwise proceed
    with the insecure connection.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问时间服务器，你需要在浏览器中添加一个异常。每种浏览器的这种方法都不同，但通常有一个高级按钮，可以引导到一个选项，要么添加证书异常，要么继续使用不安全的连接。
- en: 'Once the browser connection is established, you will be able to see the current
    time as given by our `tls_time_server` program:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器连接建立，你将能够看到由我们的`tls_time_server`程序提供的当前时间：
- en: '![](img/f10317c3-ad58-4cd4-86b5-a4c0ad3a66da.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f10317c3-ad58-4cd4-86b5-a4c0ad3a66da.png)'
- en: The `tls_time_server` program proved useful to show how a TLS/SSL server can
    be set up without getting bogged down in the details of actualizing a complete
    HTTPS server. However, this chapter's code repository also includes a more substantial
    HTTPS server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`tls_time_server`程序证明了它在展示如何设置TLS/SSL服务器而无需陷入实现完整HTTPS服务器的细节中非常有用。然而，本章的代码库还包括了一个更完整的HTTPS服务器。'
- en: A full HTTPS server
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的HTTPS服务器
- en: Included in this chapter's code repository is `https_server.c`. This program
    is a modification of `web_server.c` from [Chapter 7](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml),
    *Building a Simple Web Server*. It can be used to serve a simple static website
    over HTTPS.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码库中包含了`https_server.c`。这个程序是对[第7章](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml)中的`web_server.c`进行的修改，*构建一个简单的Web服务器*。它可以用来通过HTTPS提供简单的静态网站。
- en: In the `https_server.c` program, the basic TLS/SSL connection is set up and
    established the same way as shown in `tls_time_server.c`. Once the secure connection
    is established, the connection is simply treated as HTTP.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`https_server.c`程序中，基本的TLS/SSL连接设置和建立方式与`tls_time_server.c`中所示相同。一旦建立了安全连接，连接就简单地被当作HTTP处理。
- en: '`https_server` is compiled using the same technique as for `tls_time_server`.
    The following screenshot shows how to compile and run `https_server`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`https_server`使用与`tls_time_server`相同的技巧进行编译。以下截图显示了如何编译和运行`https_server`：'
- en: '![](img/868a232a-215d-409a-8c9e-8c00f442ab5b.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/868a232a-215d-409a-8c9e-8c00f442ab5b.png)'
- en: Once `https_server` is running, you can connect to it by navigating your web
    browser to `https://127.0.0.1:8080`. You will likely need to add a security exception
    when connecting for the first time. The code is set up to serve the static pages
    from the `chap07` directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`https_server`启动，你可以通过在网页浏览器中导航到`https://127.0.0.1:8080`来连接到它。你可能会在第一次连接时需要添加一个安全异常。代码被设置为从`chap07`目录提供静态页面。
- en: 'The following screenshot was taken of a web browser connected to `https_server`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是网页浏览器连接到`https_server`时的样子：
- en: '![](img/75eb6b72-dd04-495d-9bce-edcb588a7883.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75eb6b72-dd04-495d-9bce-edcb588a7883.png)'
- en: This chapter's example programs illustrate the basics of HTTPS servers. However,
    implementing a genuinely robust HTTPS server does involve additional challenges.
    Let's consider some of these now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例程序展示了HTTPS服务器的基本知识。然而，实现一个真正健壮的HTTPS服务器确实涉及额外的挑战。现在让我们考虑一些这些挑战。
- en: HTTPS server challenges
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS服务器挑战
- en: This chapter should serve only as an introduction to TLS/SSL server programming.
    There is much more to learn about secure network programming. Before deploying
    a secure HTTPS server with OpenSSL, it is essential to review all the OpenSSL
    documentation carefully. Many OpenSSL functions have edge cases that were ignored
    in the illustrative code for this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应仅作为TLS/SSL服务器编程的介绍。关于安全网络编程还有很多东西要学习。在部署使用OpenSSL的HTTPS服务器之前，仔细审查所有OpenSSL文档是至关重要的。许多OpenSSL函数在本章的示例代码中都被忽略了，它们有边缘情况。
- en: Multiplexing can also be complicated with OpenSSL. In typical TCP servers, we
    have been using the `select()` function to indicate when data is available to
    be read. The `select()` function works directly on the TCP socket. Using `select()`
    on a server secured with TLS/SSL can be tricky. This is because `select()` indicates
    when data is available at the TCP level. This usually, but not always, indicates
    that data is available to be read with `SSL_read()`. It is important that you
    carefully consult the OpenSSL documentation for `SSL_read()` if you are going
    to use it with `select()`. The example program in this chapter ignores these possibilities
    for reasons of simplicity.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 多路复用在 OpenSSL 中也可能变得复杂。在典型的 TCP 服务器中，我们一直使用 `select()` 函数来指示数据可读。`select()`
    函数直接作用于 TCP 套接字。在带有 TLS/SSL 的服务器上使用 `select()` 可能很棘手。这是因为 `select()` 指示 TCP 层上的数据是否可用。这通常，但不总是，意味着可以使用
    `SSL_read()` 读取数据。如果你打算与 `select()` 一起使用 `SSL_read()`，那么仔细查阅 OpenSSL 的 `SSL_read()`
    文档是很重要的。本章中的示例程序出于简单起见，忽略了这些可能性。
- en: There are also alternatives to OpenSSL. Let's consider some of them now.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也有 OpenSSL 的替代方案。现在让我们考虑一些替代方案。
- en: OpenSSL alternatives
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenSSL 的替代方案
- en: Although **OpenSSL** is one of the oldest and most widely deployed libraries
    implementing TLS, many alternative libraries have sprung up in recent years. Some
    of these alternatives aim to offer better features, performance, or quality control
    compared to OpenSSL.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 **OpenSSL** 是实现 TLS 的最古老和最广泛部署的库之一，但近年来涌现了许多替代库。其中一些替代方案旨在提供比 OpenSSL 更好的功能、性能或质量控制。
- en: 'The following table contains a number of alternative open source TLS libraries:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下表包含了一些替代的开源 TLS 库：
- en: '| **TLS Library** | **Website** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **TLS 库** | **网站** |'
- en: '| cryptlib | [https://www.cryptlib.com/](https://www.cryptlib.com/) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| cryptlib | [https://www.cryptlib.com/](https://www.cryptlib.com/) |'
- en: '| GnuTLS | [https://www.gnutls.org/](https://www.gnutls.org/) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| GnuTLS | [https://www.gnutls.org/](https://www.gnutls.org/) |'
- en: '| LibreSSL | [https://www.libressl.org/](https://www.libressl.org/) |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| LibreSSL | [https://www.libressl.org/](https://www.libressl.org/) |'
- en: '| mbed TLS | [https://tls.mbed.org/](https://tls.mbed.org/) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| mbed TLS | [https://tls.mbed.org/](https://tls.mbed.org/) |'
- en: '| Network Security Services | [https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS)
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 网络安全服务 | [https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS)
    |'
- en: '| s2n | [https://github.com/awslabs/s2n](https://github.com/awslabs/s2n) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| s2n | [https://github.com/awslabs/s2n](https://github.com/awslabs/s2n) |'
- en: '| wolfSSL | [https://www.wolfssl.com/](https://www.wolfssl.com/) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| wolfSSL | [https://www.wolfssl.com/](https://www.wolfssl.com/) |'
- en: There are also alternatives to doing TLS termination directly in your application,
    and this can simplify program design. Let's consider this next.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也有在应用程序中直接进行 TLS 终止的替代方案，这可以简化程序设计。让我们接下来考虑这一点。
- en: Alternatives to TLS
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS 的替代方案
- en: Getting everything right when implementing an HTTPS server can prove difficult,
    and missing even a minor detail can compromise security entirely.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 HTTPS 服务器时，确保一切正确可能很困难，遗漏任何细节都可能完全损害安全性。
- en: As an alternative to using TLS directly in our server itself, it is sometimes
    a better idea to use a **reverse proxy server**. A reverse proxy server can be
    configured to accept secure connections from clients and then forward these connections
    as plain HTTP to your program.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在服务器本身直接使用 TLS 的替代方案，有时使用 **反向代理服务器** 是更好的选择。反向代理服务器可以被配置为接受来自客户端的安全连接，然后将这些连接作为纯
    HTTP 代理到你的程序。
- en: '**Nginx** and **Apache** are two popular open source servers that can work
    well as HTTPS reverse proxies.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**Nginx** 和 **Apache** 是两个流行的开源服务器，它们可以作为 HTTPS 反向代理很好地工作。'
- en: 'This setup is illustrated by the following diagram:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了这种设置：
- en: '![](img/3102f763-8b15-4623-bdff-b12ea8e8bd88.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3102f763-8b15-4623-bdff-b12ea8e8bd88.png)'
- en: A reverse proxy server configured in this way is also called a **TLS termination
    proxy**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式配置的反向代理服务器也被称为 **TLS 终止代理**。
- en: An even better alternative may be to create your program using the **CGI** or
    **FastCGI** standard. In this case, your program communicates directly with a
    standard web server. The web server handles all of the HTTPS and HTTP details.
    This can greatly simplify program design, and, in some cases, reduce maintenance
    costs too.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的替代方案可能是使用 **CGI** 或 **FastCGI** 标准创建你的程序。在这种情况下，你的程序直接与标准 Web 服务器通信。Web 服务器处理所有的
    HTTPS 和 HTTP 细节。这可以大大简化程序设计，在某些情况下，还可以降低维护成本。
- en: If you do use an off-the-shelf HTTPS server, it is still important to use caution.
    It can be easy to inadvertently compromise security through misconfiguration.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实使用了现成的 HTTPS 服务器，仍然需要谨慎行事。配置不当可能会无意中危及安全性。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we considered the HTTPS protocol from the server's perspective.
    We covered how certificates work, and we showed the method for generating a self-signed
    certificate with OpenSSL.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从服务器的角度考虑了 HTTPS 协议。我们介绍了证书的工作原理，并展示了使用 OpenSSL 生成自签名证书的方法。
- en: Once we had a certificate, we learned how to use the OpenSSL library to listen
    for TLS/SSL connections. We used this knowledge to implement a simple server that
    displays the current time over HTTPS.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了证书，我们就学习了如何使用 OpenSSL 库来监听 TLS/SSL 连接。我们利用这些知识实现了一个简单的服务器，该服务器通过 HTTPS
    显示当前时间。
- en: We also discussed some of the pitfalls and complexity of implementing HTTPS
    servers. Many applications may benefit from side-stepping the implementation of
    HTTPS and relying on a reverse proxy instead.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了实现 HTTPS 服务器的一些陷阱和复杂性。许多应用程序可能从绕过 HTTPS 的实现并依赖反向代理中受益。
- en: In the next chapter, [Chapter 11](c9d0a1dc-878b-4961-825e-65688fac08ae.xhtml),
    *Establishing SSH Connections with libssh*, we will look at another secure protocol, **Secure
    Shell** (**SSH**).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第 11 章](c9d0a1dc-878b-4961-825e-65688fac08ae.xhtml) *使用 libssh 建立 SSH
    连接*，我们将探讨另一个安全协议，**Secure Shell**（**SSH**）。
- en: Questions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test the knowledge you have acquired from this chapter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下问题来测试你从本章获得的知识：
- en: How does a client decide whether it should trust a server's certificate?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端如何决定是否应该信任服务器的证书？
- en: What is the main issue with self-signed certificates?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自签名证书的主要问题是什么？
- en: What can cause `SSL_accept()` to fail?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么可能导致 `SSL_accept()` 失败？
- en: Can `select()` be used to multiplex connections for HTTPS servers?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 `select()` 来多路复用 HTTPS 服务器的连接吗？
- en: The answers to these questions can be found in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案可以在[附录 A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml) *问题解答*中找到。
- en: Further reading
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about HTTPS and OpenSSL, please refer to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 HTTPS 和 OpenSSL 的更多信息，请参阅以下内容：
- en: OpenSSL documentation ([https://www.openssl.org/docs/](https://www.openssl.org/docs/))
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL 文档 ([https://www.openssl.org/docs/](https://www.openssl.org/docs/))
- en: '**RFC 5246**: *The **Transport Layer Security** (**TLS**) Protocol Version
    1.2* ([https://tools.ietf.org/html/rfc5246](https://tools.ietf.org/html/rfc5246))'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 5246**: *传输层安全性协议（**TLS**）版本 1.2* ([https://tools.ietf.org/html/rfc5246](https://tools.ietf.org/html/rfc5246))'
- en: '*Let''s Encrypt* ([https://letsencrypt.org/](https://letsencrypt.org/))'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Let''s Encrypt* ([https://letsencrypt.org/](https://letsencrypt.org/))'
