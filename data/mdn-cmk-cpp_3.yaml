- en: 2 CMake Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 CMake语言
- en: Writing in CMake Language is a bit tricky. When you read a listfile for the
    first time - you may be under the impression that language there is so simple
    that it doesn’t require any special training or preparation. This approach is
    very often turned into a practical attempt to introduce changes and experiment
    with code without thorough understanding how it works. We, programmers are usually
    very busy and are overly keen to tackle these situations by learning in practice,
    guessing and so on. That "technique" of solving technical problems is called *voodoo
    programming*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写CMake语言有点棘手。当你第一次阅读列表文件时——你可能会觉得那里的语言如此简单，以至于不需要任何特殊的培训或准备。这种方法往往转化为实际尝试引入更改和实验代码，而不彻底理解它是如何工作的。我们，程序员通常非常忙碌，并且非常热衷于通过实践学习、猜测等方式来解决这些问题。解决技术问题的这种“技术”被称为*巫毒编程*。
- en: CMake offers this a bit unfortunate simplicity which creates an illusion that
    everything is as it should. After we have completed our small addition, a fix,
    a hack or "a quickie" - we realize that something isn't quite working. Time spent
    on debugging is often longer than actually studying the subject a bit better.
    Luckily this isn't our fate - because the chapter in front of us covers vast majority
    of this critical knowledge.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了这种不幸的简单性，它创造了一种一切都是理所当然的错觉。在我们完成了小的添加、修复、hack或“快速修复”之后——我们意识到有些事情并不完全正常。花在调试上的时间往往比实际更好地研究主题要长。幸运的是，这不是我们的命运——因为在我们面前的章节涵盖了大部分这种关键知识。
- en: 'We''ll not only understand the building blocks of CMake language: comments,
    commands, variables, and control structures, but we''ll also marry all of them
    with some background information on clean, modern CMake. You see: CMake puts you
    in a bit of a unique position: on one hand you perform a role of a build engineer.
    You need to understand all the intricacies of compilers, platforms and everything
    in-between. On the other: you''re a developer - you''re writing code that generates
    a buildsystem. Writing good code is hard and requires thinking on many levels
    at the same time: it should work, be easy to read, easy to reason about, extend
    and maintain. That''s exactly what we''re going to talk about here.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅将理解CMake语言的基本构建块：注释、命令、变量和控制结构，还将结合一些关于干净、现代CMake的背景信息。你会发现：CMake让你处于一个独特的地位：一方面，你扮演着构建工程师的角色。你需要理解编译器、平台以及它们之间的所有复杂性。另一方面：你是一名开发者——你在编写生成构建系统的代码。编写好的代码是困难的，需要在多个层面上同时思考：它应该有效、易于阅读、易于推理、扩展和维护。这正是我们在这里要讨论的内容。
- en: Lastly, we'll introduce some of the most useful and common commands. Ones that
    aren't used that often you'll find in *the Appendix* (complete reference for String,
    List and File manipulation commands).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍一些最有用和最常见的命令。那些不经常使用的命令，你会在*附录*中找到（完整的字符串、列表和文件操作命令参考）。
- en: 'In this chapter we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Basics of CMake Syntax
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake语法基础
- en: Working with Variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Using Lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表
- en: Understanding the Control Structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解控制结构
- en: Useful Commands
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的命令
- en: Technical requirement
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp](https://github.com/PacktPublishing/Modern-CMake-for-Cpp)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中出现的代码文件，地址是[https://github.com/PacktPublishing/Modern-CMake-for-Cpp](https://github.com/PacktPublishing/Modern-CMake-for-Cpp)
- en: Basics of CMake Syntax
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMake语法基础
- en: 'Composing CMake code is very much like writing in any other imperative language:
    lines are executed from top to bottom, from left to right, occasionally stepping
    into an included file or called function. Depending on the mode (See *Chapter
    1 - Command Line*) the execution begins from root file of the source tree (`CMakeLists.txt`)
    or a `.cmake` script file that was passed as an argument to `cmake`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写CMake代码非常类似于编写任何其他命令式语言：从上到下、从左到右执行行，偶尔进入一个包含的文件或调用的函数。根据模式（参见*第1章 - 命令行*），执行从源树的根文件（`CMakeLists.txt`）或作为`cmake`参数传递的`.cmake`脚本文件开始。
- en: 'As we discussed in the previous chapter, scripts support the majority of CMake
    language (with the exclusion of project-related functionality). As such they''re
    great for an early practice of syntax itself and that''s why we''ll be using them
    here. After becoming comfortable writing basic listfiles - we''ll start preparing
    actual project files (in the next chapter). As a reminder - scripts can be run
    with following command line:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，脚本支持大多数CMake语言（项目相关功能除外）。因此，它们非常适合早期练习语法本身，这就是我们在这里使用它们的原因。在熟悉编写基本列表文件后
    - 我们将开始准备实际的项目文件（在下一章）。提醒一下 - 脚本可以通过以下命令行运行：
- en: '`cmake -P script.cmake`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake -P script.cmake`'
- en: '**Note**'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CMake supports 7-bit ASCII text files for portability across all platforms.
    You can use both `\n` or `\r\n` line endings. UTF-8 with optional Byte Order Markers
    is supported in CMake above 3.0 and UTF-16 in CMake above 3.2
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CMake支持7位ASCII文本文件，以便在所有平台上实现可移植性。您可以使用`\n`或`\r\n`行结束符。CMake 3.0以上版本支持带有可选字节顺序标记的UTF-8，CMake
    3.2以上版本支持UTF-16。
- en: Everything in a CMake listfile is either a command invocation or a comment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CMake列表文件中的所有内容要么是命令调用，要么是注释。
- en: Comments
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'There are two kinds of comments: single-line comments, and bracket (multiline)
    comments, just like in C++. But unlike in C++, bracket comments can be nested.
    Let me show you the syntax:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: （注释有两种类型：单行注释和括号（多行）注释，就像在C++中一样。但与C++不同的是，括号注释可以嵌套。让我展示一下语法：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Multiline comments get their name from their symbol, they start with an opening
    square bracket, any number of equal signs and another bracket: `[=[`. To close
    a bracket comment **use the same amount** of equal signs, and reverse the brackets
    like so: `]=]`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释因其符号而得名，它们以一个开方括号、任意数量的等号和另一个括号开始：`[=[`。要关闭方括号注释，**请使用相同数量的**等号，并反向括号，如下所示：`]=]`。
- en: 'Prepending opening bracket tokens with `#` is optional, and allows for quick
    uncommenting multiline comment by adding another `#` to first line of bracket
    comment like so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开方括号标记前加上`#`是可选的，并允许通过在方括号注释的第一行添加另一个`#`来快速取消注释多行注释，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's a nifty trick, but when and how to use comments in our CMake file? Since
    writing listfiles is essentially programming it is a good idea to bring best coding
    practices to them as well. Code following such practices is often called "clean"
    - it's a term coined over the years by software development gurus like Robert
    C. Martin, Martin Fowler and many other authors. What's considered helpful and
    harmful is often heavily disputed and as you guessed - comments come up as a subject
    more than once.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个巧妙的技巧，但在我们的CMake文件中何时以及如何使用注释？由于编写列表文件本质上是在编程，因此将最佳编码实践引入它们也是一个好主意。遵循这些实践的代码通常被称为“干净”
    - 这是多年来由软件开发大师如罗伯特·C·马丁、马丁·福勒和其他许多作者创造的术语。被认为是有帮助和有害的常常存在很大争议，正如你所猜测的 - 注释作为主题出现不止一次。
- en: 'Everything should be judged on a case-by-case basis, but generally agreed upon
    guideline says, that good comments provide at least one of the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都应根据具体情况进行判断，但普遍认同的指导原则是，好的注释至少提供以下一项：
- en: '**Information** untangling complexities like regex patterns or formatting strings'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**，解开复杂性，如正则表达式模式或格式化字符串'
- en: '**Intent**, unobvious from implementation or interface'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意图**，从实现或接口中不明显'
- en: '**Clarification**, explaining concepts that can''t be easily refactored or
    changed'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**澄清**，解释无法轻易重构或更改的概念'
- en: '**Warning of consequences**, especially around code that can break other things'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后果警告**，特别是在可能破坏其他事物的代码周围'
- en: '**Amplification** underlining importance of idea that is hard to express in
    code'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强调**，强调难以用代码表达的想法的重要性'
- en: '**Legal clauses**. A necessary evil, usually not a domain of a programmer'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法律条款**。一种必要的恶，通常不是程序员的领域'
- en: 'If you can, avoid a comment, replace it with better naming, refactor or correct
    your code. If you possibly can, avoid the comments that are:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以，避免注释，用更好的命名、重构或更正代码来代替。如果可能，避免以下类型的注释：
- en: '**Mandated**, added for completeness, but not really important'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制性**，添加以完整性，但不是真正重要'
- en: '**Redundant**, repeating what is already clearly written in code'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余**，重复代码中已经清楚写明的内容'
- en: '**Misleading**, outdated or incorrect, as they didn''t follow code changes'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**误导性**，过时或不正确，因为它们没有跟随代码变化'
- en: '**Journal**, noting what has been changed and when (use VCS for this)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**，记录更改的内容和时间（使用版本控制系统进行此操作）'
- en: '**Dividers**, marking sections or otherwise'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分隔符**，标记部分或以其他方式'
- en: Writing elegant code without comments is hard, but it improves experience of
    the reader. Since we spend more time on reading than writing - we should insist
    on readable code rather than one quick to write. I recommend checking out *further
    reading* section at the end of the chapter for some good references on clean code.
    If you're interested in comments in particular - you'll find a link to one of
    my many YouTube videos touching on this subject in depth.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不带注释编写优雅的代码是困难的，但它能提升读者的体验。由于我们花在阅读上的时间比写作多 - 我们应该坚持编写可读性强的代码，而不是快速编写的代码。我建议查看本章末尾的*进一步阅读*部分，以获取有关清洁代码的一些好参考资料。如果你对注释特别感兴趣
    - 你会在我的许多YouTube视频中找到一个深入探讨这个主题的链接。
- en: Command Invocations
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令调用
- en: Time for some action! Invoking commands is the bread and butter of CMake listfiles.
    To execute a command, you must provide its name and parentheses in which you may
    enclose a whitespace separated list of **command arguments**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候采取行动了！调用命令是CMake listfiles的基础。要执行命令，你必须提供其名称和括号，在其中你可以包含一个空格分隔的**命令参数**列表。
- en: '![Figure 2.1: An example of a command](img/file5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：命令示例](img/file5.png)'
- en: 'Figure 2.1: An example of a command'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：命令示例
- en: Command names aren't case sensitive, but there is a convention in CMake community
    to use `snake_case` in names (lower-case words joined with underscores). You can
    also define your own commands - we'll cover this in the *Control Structures* section
    of this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 命令名称不区分大小写，但CMake社区有一个约定，即在名称中使用`snake_case`（小写字母单词用下划线连接）。你还可以定义自己的命令 - 我们将在本章的*控制结构*部分介绍这一点。
- en: What's especially striking in comparison to C++ is the fact that **command invocations
    in CMake are not expressions**. You can't provide another command as an argument
    to a called command, as *everything* between the parentheses is interpreted as
    an argument for that command.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++相比，特别引人注目的是**CMake中的命令调用不是表达式**。你不能将另一个命令作为参数提供给被调用的命令，因为*所有内容*在括号内都被解释为该命令的参数。
- en: 'Even more outraging is the fact that CMake commands don''t require semicolons
    at the end of invocation. This may be because on each line of source can contain
    up to **one command invocation** followed by an optional single-line comment.
    Alternatively, entire line has to be part of bracket comment. So again, these
    are only allowed formats:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人愤怒的是，CMake命令在调用结束时不需要分号。这可能是因为源文件的每一行可以包含**一个命令调用**，后面可以跟一个可选的单行注释。或者，整行必须是括号注释的一部分。所以，这些是唯一允许的格式：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Putting a command after a bracket comment is not allowed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号注释后放置命令是不允许的：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After removing comments, whitespace and empty lines - we get a list of command
    invocations. This creates an interesting perspective: CMake syntax is really simple,
    but is that enough? How do we even work with variables? Or how to direct the flow
    of the execution?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 删除注释、空格和空行后 - 我们得到一个命令调用列表。这创造了一个有趣的视角：CMake语法真的很简单，但这就足够了吗？我们如何处理变量？或者如何控制执行流程？
- en: 'CMake provides commands for above and much more. To make things easier we''ll
    be introducing the relevant commands as we move through different subjects, they
    can be grouped in three categories:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了上述命令以及更多。为了使事情变得更容易，我们将随着我们通过不同的主题介绍相关的命令，它们可以分为三个类别：
- en: Scripting Commands are available always, they change the state of command processor,
    access variables, affect other commands and environment
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本命令始终可用，它们改变命令处理器的状
- en: Project Commands are available in projects, they manipulate project state and
    build targets
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目命令在项目中可用，它们操作项目状态和构建目标
- en: CTest Commands are available in CTest scripts, they manage testing
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CTest命令在CTest脚本中可用，它们管理测试
- en: We'll cover most useful scripting commands in this chapter (as they are also
    useful in projects). Project and CTest commands will be discussed in following
    chapters, as we introduce concepts of build targets (*Chapter 3,* *Setting up
    your first CMake project* ) and testing frameworks (*Chapter 8,* *Testing Frameworks*).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍最常用的脚本命令（因为它们在项目中也非常有用）。项目和CTest命令将在后续章节中讨论，因为我们将介绍构建目标的概念（*第3章，设置你的第一个CMake项目*）和测试框架（*第8章，测试框架*）。
- en: 'Virtually every command relies on other elements of the language to be useful:
    variables, conditional statements, and first and foremost: the command line arguments.
    Let''s see how we should use them.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个命令都依赖于语言的其他元素来发挥作用：变量、条件语句，最重要的是：命令行参数。让我们看看应该如何使用它们。
- en: Command Arguments
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令参数
- en: Many commands require whitespace-separated arguments to parametrize how they
    behave. As you saw in Figure 2.1 - there's something weird happening with the
    quotes around the arguments. Some arguments have quotes, others don't - what's
    up with that?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令需要以空格分隔的参数来参数化它们的行为。正如您在图2.1中看到的，参数周围的引号有些奇怪。一些参数有引号，而其他参数没有 - 这是怎么回事？
- en: 'Under the hood, the only type recognized by CMake is a string. This is why
    every command expects zero or more strings for its arguments. But plain, static
    strings aren''t very useful, especially when we can''t nest command invocations.
    Here''s where arguments come into play: CMake will evaluate every argument to
    static string and then pass them into the command. Evaluating means string interpolation
    or simply: substituting parts of string with another value. This can mean replacing
    the *escape sequences*, expansion of **variable references** (also called variable
    interpolation) and unpacking of lists.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，CMake唯一识别的类型是字符串。这就是为什么每个命令都期望为其参数提供零个或多个字符串。但是，普通的静态字符串并不是很有用，特别是当我们不能嵌套命令调用时。这就是参数发挥作用的地方：CMake将对每个参数求值为静态字符串，然后将它们传递给命令。求值意味着字符串插值，或者简单地说：用另一个值替换字符串的部分。这可能意味着替换*转义序列*，扩展**变量引用**（也称为变量插值）和解包列表。
- en: 'Depending on the context we might want to enable such evaluation as needed
    and for that reason CMake offers three types of arguments:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，我们可能希望根据需要启用这种求值，为此，CMake提供了三种类型的参数：
- en: Bracket Arguments
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号参数
- en: Quoted Arguments
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引号参数
- en: Unquoted Arguments
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未引用的参数
- en: Each type offers different level of evaluation and has a few small quirks about
    it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型都提供不同级别的求值，并且有一些小的怪癖。
- en: Bracket Arguments
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 括号参数
- en: Bracket arguments aren't evaluated because they are used to **pass multiline
    strings verbatim**, as a single argument to commands. That means it will include
    whitespace like tabs and newlines.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 括号参数不会被求值，因为它们用于**原样传递多行字符串**，作为命令的单个参数。这意味着它将包含制表符和换行符等空白字符。
- en: 'These arguments are structured exactly like comments: opened with `[=[` and
    closed with `]=]` token, where the count of equal signs in tokens has to match
    (skipping equal sign is fine too). The only difference from comments is - that
    you can''t nest bracketed arguments.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数的结构与注释完全相同：以`[=[`打开并以`]=]`闭合，其中等号在标记中的数量必须匹配（跳过等号也可以）。与注释的唯一区别是 - 您不能嵌套括起来的参数。
- en: 'Here''s the exemplary use of such argument with `message()` command, which
    prints all passed arguments on screen:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`message()`命令的此类参数的示例，该命令在屏幕上打印所有传递的参数：
- en: chapter02/01-arguments/bracket.cmake
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter02/01-arguments/bracket.cmake
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In above example we can see different forms of bracket argument. First one
    skips equal sign. Note, how putting closing tags in separate line is visible as
    empty line in the output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们可以看到不同形式的括号参数。第一个跳过等号。请注意，将闭合标签放在单独的行中在输出中显示为空行：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Second form is useful when we're passing a text containing double brackets `]]`(highlighted),
    so they won't be interpreted as a closure of the argument.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式在我们传递包含双括号`]]`（突出显示）的文本时很有用，因此它们不会被解释为参数的闭合。
- en: Such bracket arguments have limited use - typically to contain longer blocks
    of text. In most cases we'll need something more dynamic, like quoted arguments.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种括号参数的使用有限 - 通常用于包含较长的文本块。在大多数情况下，我们需要更动态的内容，如引号参数。
- en: Quoted Arguments
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引号参数
- en: 'Second type of arguments resembles a regular *C++ string*: they group together
    multiple characters including whitespace and they will expand *escape sequences*.
    Like *C++ strings* - they are opened, and closed with a double quote character
    `"`, and to use a literal quote - you have to escape it with a backslash: `\"`.
    Other well-known escape sequences are supported as well: `\\` denotes a literal
    backslash, `\t` is a tab character, `\n` is a newline, `\r` is a carriage return.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种参数类似于常规的*C++字符串*：它们将多个字符（包括空格）组合在一起，并将扩展*转义序列*。与*C++字符串*一样，它们以双引号字符`"`打开和关闭，要使用文字引号，必须用反斜杠转义它：`\"`。其他广为人知的转义序列也得到支持：`\\`表示文字反斜杠，`\t`是制表符，`\n`是换行符，`\r`是回车符。
- en: 'This is where similarities with *C++ strings* end. In contrast, Quoted Arguments
    can span multiple lines and they will interpolate variable references. Think of
    them as having a built-in `sprintf` from *C* or `std::format` from *C++20*. To
    insert a variable reference to your argument, wrap the name of the variable in
    a token like so: `${name}`. We''ll talk more about variable references in the
    *Variables* section.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*C++字符串*的相似之处到此为止。相比之下，加引号的参数可以跨越多行，并且它们会插值变量引用。可以将它们视为内置了*C*中的`sprintf`或*C++20*中的`std::format`。要在参数中插入变量引用，请将变量名包裹在如下标记中：`${name}`。我们将在*变量*部分详细讨论变量引用。
- en: 'Let''s try these arguments in action:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试这些参数的实际应用：
- en: chapter02/01-arguments/quoted.cmake
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二章/01-参数/quoted.cmake
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Can you guess how many lines will be in output of above script?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出上述脚本的输出会有多少行吗？
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's right - we have one escaped quote character, escaped newline and a literal
    newline - all of them will be printed in the output. We also accessed a built-in
    variable `CMAKE_VERSION`, which we can see correctly interpolated at the last
    line.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 没错 - 我们有一个转义的引号字符、转义的换行符和一个文字换行符 - 它们都将被打印在输出中。我们还访问了一个内置变量`CMAKE_VERSION`，我们可以看到它在最后一行正确地插值了。
- en: Unquoted Arguments
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 未加引号的参数
- en: 'The last type of arguments is definitely a bit rare in programming world. We
    got used to the fact that strings have to be delimited in one way or another:
    using single quotes, double quotes or backticks. CMake deviates from this convention
    and introduces unquoted arguments. One might argue that dropping delimiters is
    easier to read, just like skipping semicolons. Is that true? I''ll let you form
    your own opinion.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种参数类型在编程世界中确实有点罕见。我们已经习惯了字符串必须以某种方式分隔：使用单引号、双引号或反引号。CMake偏离了这一惯例，引入了未加引号的参数。有人可能会争辩说，省略定界符更容易阅读，就像跳过分号一样。这是真的吗？我会让你形成自己的观点。
- en: 'Unquoted Arguments are evaluating both *escape sequences* and variable references.
    Be careful with semicolon `;` though: it is treated here as a delimiter. CMake
    will split the argument containing it into multiple arguments. If you need to
    use it - escape it with backslash (`\;`). This is how CMake manages lists. I''ll
    explain that in detail in the *List* section.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 未加引号的参数同时评估*转义序列*和变量引用。但是要小心分号`;`：它在这里被视为分隔符。CMake会将包含它的参数分割成多个参数。如果需要使用它，请用反斜杠转义它（`\;`）。这就是CMake管理列表的方式。我将在*列表*部分详细解释这一点。
- en: 'You may find that these arguments are the most perplexing to work with, so
    here''s visual help to clarify how such arguments are partitioned:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现这些参数是最令人困惑的工作，所以这里有一些视觉帮助来澄清这些参数是如何划分的：
- en: '![Figure 2.2: Escape sequences cause separate tokens to be interpreted as a
    single argument](img/file6.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：转义序列使得单独的标记被解释为单个参数](img/file6.png)'
- en: 'Figure 2.2: Escape sequences cause separate tokens to be interpreted as a single
    argument'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：转义序列使得单独的标记被解释为单个参数
- en: '**Question**'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**问题**'
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does it matter if a value is passed as a single argument or many?
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么一个值作为单个参数传递还是多个参数传递会有所不同？
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some CMake commands will work on arguments consuming them one by one. If your
    arguments get accidentally separated - you'll get hard to debug errors.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些CMake命令会逐个消耗参数。如果你的参数意外地被分隔开，你将会得到难以调试的错误。
- en: 'Unquoted arguments cannot contain unescaped quotes `"`, hashes `#` and backslashes
    `\`. And if that''s not enough rules: parentheses `()` are allowed only if they
    form correct, matching pairs. That is: you''ll start with an opening parenthesis
    and close it before closing the command argument list.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 未加引号的参数不能包含未转义的引号`"`, 井号`#`和反斜杠`\`。如果这些规则还不够：括号`()`只有在其形成正确、匹配的配对时才被允许。也就是说：你必须从一个开括号开始，并在结束命令参数列表之前将其闭合。
- en: 'Let''s look at the examples of all of above rules:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看上述所有规则的示例：
- en: chapter02/01-arguments/unquoted.cmake
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二章/01-参数/unquoted.cmake
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What will be the output of above?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的输出会是什么？
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Even as simple command like `message()` is very particular about separated
    unquoted arguments:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是像`message()`这样简单的命令，对于分隔的未加引号的参数也非常挑剔：
- en: Space in **a single argument** was correctly printed when it was explicitly
    escaped
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**单个参数**中的空格在明确转义时被正确打印
- en: However **twoarguments** and **threeseparatearguments** were "glued" together
    - since `message()` doesn't add any spaces on its own.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而**twoarguments**和**threeseparatearguments**被“粘合”在一起 - 因为`message()`本身不会添加任何空格。
- en: 'Now that we understand how to deal with complexities and peculiarity of CMake
    arguments - we are ready to tackle the next interesting subject: working with
    all kinds of variables in CMake.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们了解了如何处理CMake参数的复杂性和特殊性——我们准备好探讨下一个有趣的课题：在CMake中处理各种变量。
- en: Working with Variables
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理变量
- en: 'Variables in CMake are a surprisingly complex subject. Not only there are three
    categories of variables: normal, cache and environment variables, but they also
    reside on different scopes with specific rules on how one scope affect the other.
    Very often poor understanding of all these rules is a source of bugs and headaches.
    I recommend you study this section with care and make sure you know all concepts
    before moving on.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CMake中的变量是一个出人意料的复杂主题。不仅存在三种类别的变量：普通、缓存和环境变量，而且它们还存在于不同的作用域中，有着特定的规则来决定一个作用域如何影响另一个作用域。对这些规则的糟糕理解往往是错误和头痛的来源。我建议你仔细研究这一部分，并确保在继续之前你已经掌握了所有概念。
- en: 'Let''s start with key facts about variables in CMake:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从关于CMake变量的关键事实开始：
- en: Variable names are case-sensitive and can be built with almost any character.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名是区分大小写的，并且几乎可以使用任何字符构建。
- en: All variables are stored internally as strings, even if some commands can interpret
    them as values of other types (even lists!).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有变量在内部都存储为字符串，即使某些命令可以将它们解释为其他类型的值（甚至是列表！）。
- en: Basic variable manipulation commands are `set()` and `unset()` but there are
    other commands that can affect variables, like `string()` and `list()`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的变量操作命令是`set()`和`unset()`，但还有其他命令可以影响变量，如`string()`和`list()`。
- en: 'To set a variable we simply call `set()` providing its name and the value:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个变量，我们只需调用`set()`，提供其名称和值：
- en: chapter02/02-variables/set.cmake
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter02/02-variables/set.cmake
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you see use of bracket and quoted arguments allows for spaces in variable
    name. However, when referencing later it we have to escape whitespace with backslash
    `\`. For that reason, it is recommended to use only alphanumeric characters, `-`
    and `_` in variable names.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用括号和引号参数允许变量名中包含空格。然而，在引用时，我们必须用反斜杠`\`转义空格。因此，建议在变量名中仅使用字母数字字符、`-`和`_`。
- en: 'Also avoid reserved names (upper, lower, or mixed case) that begin with: `CMAKE_`,
    `_CMAKE_`, underscore `_` followed by name of any CMake Command.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还要避免使用以`CMAKE_`、`_CMAKE_`、下划线`_`开头的保留名称（大写、小写或混合大小写），后跟任何CMake命令的名称。
- en: '**Note**'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`set()` command accepts a plain text name of variable as first argument but
    `message()` uses a variable reference wrapped in `${}` syntax. What would happen
    if we were to provide variable wrapped in `${}` syntax to the `set()` command?
    To answer that we''ll need to understand variable references better.'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`set()`命令接受变量的纯文本名称作为第一个参数，但`message()`使用包裹在`${}`语法中的变量引用。如果我们向`set()`命令提供包裹在`${}`语法中的变量会发生什么？为了回答这个问题，我们需要更好地理解变量引用。'
- en: 'To unset a variable we can use `unset()`, like so: `unset(MyString1)`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消设置一个变量，我们可以使用`unset()`，如下所示：`unset(MyString1)`。
- en: Variable References
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量引用
- en: 'I already mentioned references briefly when in *Command Arguments* section
    - as they''re evaluated for Quoted and Unquoted arguments. And we learned that
    to create a reference to defined variable we need to use the `${}` syntax like
    so: `message(${MyString1})`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在*命令参数*部分，我已简要提及了引用——因为它们对于带引号和不带引号的参数都会被评估。我们了解到，要创建对已定义变量的引用，我们需要使用这样的语法：`message(${MyString1})`。
- en: On evaluation CMake will traverse the scope stack (I'll explain that in a second)
    and replace `${MyString1}` with a value or an empty string if no variable is found
    (no errors are reported). This process is called variable evaluation, expansion
    or interpolation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估时，CMake将遍历作用域栈（我稍后会解释），并用值或空字符串替换`${MyString1}`（如果没有找到变量，则不会报告错误）。这个过程称为变量评估、展开或插值。
- en: 'Such interpolation is done in inside-out fashion, this means two things:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种插值是以由内而外的方式进行的，这意味着两件事：
- en: 'First, if a following reference is encountered: `${MyOuter${MyInner}}`. CMake
    will try to evaluate `MyInner` first, rather than searching for a variable named
    `MyOuter${MyInner}`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，如果遇到这样的引用：`${MyOuter${MyInner}}`，CMake会尝试先评估`MyInner`，而不是寻找名为`MyOuter${MyInner}`的变量。
- en: 'Second: if `MyInner` variable was successfully expanded - CMake will repeat
    expansion process until no further expansion is possible.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次：如果`MyInner`变量成功展开——CMake将重复展开过程，直到没有进一步的展开是可能的。
- en: 'Let''s consider an example with following variables:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下变量的一个例子：
- en: '`MyInner` with a value `Hello`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyInner` 的值为 `Hello`'
- en: '`MyOuter` with a value `${My`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyOuter` 的值为 `${My`'
- en: 'and we call command: `message("${MyOuter}Inner} World")` the output we''ll
    receive will be `Hello World,` and that is because `${MyOuter}` was replaced with
    a literal value `${My`, which combined with top-level `Inner}` creates another
    variable reference: `${MyInner}`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用命令：`message("${MyOuter}Inner} World")`时，我们将收到的输出是`Hello World,`，这是因为`${MyOuter}`被替换为字面值`${My`，它与顶层的`Inner}`结合，创建了另一个变量引用：`${MyInner}`。
- en: CMake will perform this expansion to the full extent, and only then pass resulting
    values as arguments to the command. This is why when we'd call `set(${MyInner}
    "Hi")` - we won't be actually changing the `MyInner` variable, but instead we'll
    change the `Hello` variable. CMake expands `${MyInner}` to `Hello`, and passes
    that string as first argument to the `set()` command along with new value `Hi`.
    Very often this is not what we want.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将完全执行这种扩展，然后将生成的值作为参数传递给命令。这就是为什么当我们调用`set(${MyInner} "Hi")`时，我们实际上并没有改变`MyInner`变量，而是改变了`Hello`变量。CMake将`${MyInner}`扩展为`Hello`，并将该字符串作为第一个参数传递给`set()`命令以及新值`Hi`。这种情况往往不是我们想要的。
- en: 'Variable references are a bit peculiar in how they work when it comes to variable
    categories, but in general:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 变量引用在涉及变量类别时的工作方式有点特殊，但总的来说：
- en: '`${}` syntax is used to reference normal *or cache variables*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${}`语法用于引用普通*或缓存变量*'
- en: '`$ENV{}` syntax is used to reference environment variables'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ENV{}`语法用于引用环境变量'
- en: '`$CACHE{}` syntax is used to reference cache variables'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$CACHE{}`语法用于引用缓存变量'
- en: That's right, with `${}` you might get a value from one category or the other,
    I'll explain that in the *Scope* section. But first let's introduce other categories
    of variables, so we understand clearly what they are.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，使用`${}`你可能从一个类别或另一个类别获取值，我将在*Scope*部分解释这一点。但首先让我们介绍其他类别的变量，这样我们就能清楚地了解它们是什么。
- en: '**Note**'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember that you can pass arguments to scripts through command line after a
    `--` token.
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请记住，你可以通过命令行在`--`标记后传递参数给脚本。
- en: Values will be in `CMAKE_ARGV<n>` and count of passed arguments in `CMAKE_ARGC`.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 值将位于`CMAKE_ARGV<n>`中，传递的参数数量位于`CMAKE_ARGC`中。
- en: Using the Environment Variables
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: This is the least complicated category of variables. CMake makes a copy of variables
    which were in the environment used to start the `cmake` process and makes them
    available in a single, global scope. To reference these variables, use the `$ENV{<name>}`
    syntax.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最不复杂的变量类别。CMake对用于启动`cmake`进程的环境中的变量进行复制，并将它们在一个单一的全局范围内提供。要引用这些变量，请使用`$ENV{<name>}`语法。
- en: CMake also allows you to `set()` and `unset()` these variables, but changes
    will be only made to local copy in the running `cmake` process, not the actual
    system environment and these changes won't be visible to subsequent runs of builds
    or tests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: CMake还允许你`set()`和`unset()`这些变量，但这些更改只会对运行中的`cmake`进程的本地副本生效，而不是实际的系统环境，这些更改对后续的构建或测试运行是不可见的。
- en: 'To modify or create a variable use `set(ENV{<variable>} <value>)` command like
    so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改或创建变量，请使用`set(ENV{<variable>} <value>)`命令，如下所示：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To clear an environment variable use `unset(ENV{<variable>})` like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除环境变量，请使用`unset(ENV{<variable>})`，如下所示：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are a few environment variables that affect CMake behavior, control the
    build and CTest. CXX is one of them - it specifies what executable will be used
    for compiling C++ files. We''ll cover them as they will become relevant. Full
    list is available in the documentation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些环境变量会影响CMake的行为，控制构建和CTest。CXX是其中之一 - 它指定用于编译C++文件的可执行文件。我们将在它们变得相关时介绍它们。完整的列表可在文档中找到：
- en: '[https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html)'
- en: If you use ENV variables as arguments to your commands, the values will be interpolated
    during the generation of buildsystem. This means that they will get baked into
    the build tree and changing the environment for build stage won't have any effect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用环境变量作为命令的参数，这些值将在生成构建系统时被插值。这意味着它们将被烘焙到构建树中，并且在构建阶段更改环境不会有任何影响。
- en: 'Take for example following project file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下项目文件为例：
- en: chapter02/03-environment/CMakeLists.txt
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 章节02/03-环境/CMakeLists.txt
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Above project has two steps: it will print `myenv` environment variable during
    the configuration, and it will add a build step through `add_custom_target()`
    that echoes the same variable as part of the build process. We can test what happens
    with a bash script that uses one value for configuration stage and another for
    build stage:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述项目有两个步骤：它将在配置期间打印`myenv`环境变量，并通过`add_custom_target()`添加一个构建步骤，该步骤在构建过程中回显同一变量。我们可以通过一个使用配置阶段和构建阶段不同值的bash脚本来测试会发生什么：
- en: chapter02/03-environment/build.sh
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第2章/03-环境/build.sh
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running above shows clearly, that value set during the configuration is persisted
    in the generated buildsystem:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令可以清楚地看到，配置期间设置的值在生成的构建系统中得以保留：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the Cache Variables
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用缓存变量
- en: We first mentioned cache variables when discussing command line options for
    `cmake` in *Chapter 1*. Essentially - they're persisted variables stored in `CMakeCache.txt`
    file in your build tree. They contain information gathered during the project
    configuration stage - both from the system (path to compilers, linkers, tools;
    and other), and from the user through GUI. Cache variables are not available in
    scripts (since there's no `CMakeCache.txt`), they only exist in projects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首次提到缓存变量是在讨论`cmake`的命令行选项时，在第1章中。本质上，它们是存储在构建树中的`CMakeCache.txt`文件中的持久化变量。它们包含在项目配置阶段收集的信息——既来自系统（编译器、链接器、工具的路径；以及其他），也来自用户通过GUI。缓存变量在脚本中不可用（因为没有`CMakeCache.txt`），它们只存在于项目中。
- en: Cache variables can be referenced with the `$CACHE{<name>}` syntax.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存变量可以使用`$CACHE{<name>}`语法引用。
- en: 'To set cache variable use `set()` with following syntax:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置缓存变量，请使用带有以下语法的`set()`：
- en: '`set(<variable> <value> CACHE <type> <docstring> [FORCE])`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`set(<variable> <value> CACHE <type> <docstring> [FORCE])`'
- en: 'As you see there are some new required arguments (in comparison to `set()`
    for normal variables) also introduce some first keywords: `CACHE` and `FORCE`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与普通变量的`set()`相比，有一些新的必需参数，还引入了一些第一个关键字：`CACHE`和`FORCE`。
- en: 'Specifying `CACHE` as a `set()` argument means that we intend to change what
    was provided during configuration stage and imposes a requirement to provide variable
    `<type>` and `docstring`. This is because these variables are configurable by
    user and GUI needs to know how to display it. Following types are accepted:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CACHE`指定为`set()`的参数意味着我们打算更改配置阶段提供的内容，并要求提供变量`<type>`和`docstring`。这是因为这些变量可由用户配置，GUI需要知道如何显示它们。接受的类型包括：
- en: '`BOOL` - Boolean ON/OFF value. GUI will show a checkbox.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOL` - 布尔ON/OFF值。GUI将显示一个复选框。'
- en: '`FILEPATH` - Path to a file on disk. GUI will open a file dialog.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILEPATH` - 磁盘上的文件路径。GUI将打开一个文件对话框。'
- en: '`PATH` - Path to a directory on disk. GUI will open a directory dialog.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH` - 磁盘上的目录路径。GUI将打开一个目录对话框。'
- en: '`STRING` - A line of text. GUI offers a text field or a drop-down selection
    if the `STRINGS` cache entry property is set (this can be done with `set_property()`).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STRING` - 一行文本。如果设置了`STRINGS`缓存条目属性（可以使用`set_property()`完成），GUI将提供一个文本字段或一个下拉选择。'
- en: '`INTERNAL` - A line of text. GUI skips internal entries. They may be used to
    store variables persistently across runs. Use of this type implies FORCE.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERNAL` - 一行文本。GUI会跳过内部条目。它们可用于在多次运行之间持久存储变量。使用此类型意味着FORCE。'
- en: '`<doctring>` is simply a label that will be displayed by the GUI next to the
    field to provide more detail about this setting to the user. It is required even
    for `INTERNAL` type.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`<doctring>`只是一个标签，GUI将在字段旁边显示该标签，以向用户提供有关此设置的更多详细信息。即使是`INTERNAL`类型，这也是必需的。'
- en: 'Setting Cache variables follows the rules as environmental variables to some
    extent: values are overwritten only for the current execution of CMake. Take look
    at this example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 设置缓存变量在一定程度上遵循环境变量的规则：值仅在CMake当前执行期间被覆盖。请看这个例子：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Above call has no permanent effect if variable exists in cache. However, if
    value didn''t exist in cache or an optional `FORCE` argument was specified - the
    value will be persisted:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述调用如果没有在缓存中存在变量，则没有永久效果。但是，如果缓存中不存在值或指定了可选的`FORCE`参数，则该值将被持久化：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Setting the cache variables has some unobvious implication. That is: any normal
    variable with the same name will be removed. We''ll find out why in the next section.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 设置缓存变量有一些不明显的含义。即：任何同名的普通变量都将被移除。我们将在下一节中找出原因。
- en: As a reminder - cache variables can be managed from command line as well, check
    the appropriate section in *Chapter 1*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，缓存变量也可以从命令行管理，请查看第1章中的相应部分。
- en: How to correctly use the Variable Scope in CMake
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何在 CMake 中正确使用变量作用域
- en: Variable scope is probably the hardest part of the whole concept. Maybe because
    we're so accustomed how things are done in more advanced languages that support
    namespaces and scope operators. CMake doesn't have those mechanisms so it deals
    with this issue in its own, a bit specific way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 变量作用域可能是整个概念中最难的部分。也许是因为我们习惯了在支持命名空间和作用域操作符的更高级语言中事物是如何完成的。CMake 没有这些机制，所以它以自己有点特定的方式处理这个问题。
- en: 'Just to clarify: variable scopes as a general concept are meant to separate
    different layers of abstraction such that when a user defined function is called
    - variables set in that function are local to it. These local variables aren''t
    affecting the global scope even if the names of local variables are exactly the
    same as global ones. If explicitly needed, function should have read/write access
    to global variables as well. This separation of variables (or scope) has to work
    on many levels - when one function calls another, the same separation rules apply.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清：变量作用域作为一个通用概念，旨在分离不同的抽象层次，以便当用户定义的函数被调用时 - 在该函数中设置的变量是局部的。这些局部变量即使与全局变量名称完全相同，也不会影响全局作用域。如果需要，函数应该具有对全局变量的读/写访问权限。这种变量（或作用域）的分离必须在多个层次上工作
    - 当一个函数调用另一个函数时，适用相同的分离规则。
- en: 'CMake supports two kinds of scope:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 支持两种作用域：
- en: '**Function Scope**: When custom functions defined with `function()` are executed'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数作用域**：当使用 `function()` 定义的自定义函数被执行时'
- en: '**Directory Scope**: When a `CMakeLists.txt` listfile in a nested directory
    is executed from `add_subdirectory()` command'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录作用域**：当从 `add_subdirectory()` 命令执行嵌套目录中的 `CMakeLists.txt` 列表文件时'
- en: We'll cover above commands later in the book, first we need to know how the
    concept of variable scope is implemented. When a nested scope is created, CMake
    simply fills it with copies of all variables from the current scope. Subsequent
    commands will affect these copies. But as soon as the nested scope is completed
    - all copies are deleted and the original, parent scope is restored.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书后面介绍上述命令，首先我们需要了解变量作用域的概念是如何实现的。当创建嵌套作用域时，CMake 只是用当前作用域中所有变量的副本填充它。后续命令将影响这些副本。但是，一旦嵌套作用域完成
    - 所有副本都会被删除，原始的父作用域会被恢复。
- en: 'Let''s consider a following scenario:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下场景：
- en: Parent scope sets variable `VAR` to `ONE`
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父作用域将变量 `VAR` 设置为 `ONE`
- en: Nested scope starts, `VAR` is printed to console
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套作用域开始，`VAR` 被打印到控制台
- en: '`VAR` is set to `TWO`, `VAR` is printed to console'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VAR` 被设置为 `TWO`，`VAR` 被打印到控制台'
- en: Nested scope ends, `VAR` is printed to console
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套作用域结束，`VAR` 被打印到控制台
- en: 'The console''s output will look like this: `ONE`, `TWO`, `ONE`. This is because
    the copied variable `VAR` is discarded after nested scope ends.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台的输出将如下所示：`ONE`，`TWO`，`ONE`。这是因为复制变量 `VAR` 在嵌套作用域结束后被丢弃。
- en: How scope works in CMake has interesting implications that aren't that common
    in other languages. If you `unset()` a variable created in the parent scope while
    executing in a nested scope - it will disappear but only in the nested scope.
    When nested scope is completed - the variable is restored to its previous value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 中作用域的工作方式具有有趣的含义，这在其他语言中并不常见。如果在嵌套作用域中执行时 `unset()` 一个在父作用域中创建的变量 - 它将在嵌套作用域中消失。当嵌套作用域完成时
    - 变量将恢复到其先前的值。
- en: This brings us to behavior of variable referencing, and the `${}` syntax. Whenever
    we try to access the normal variable CMake will reach to the variables of current
    scope and if variable with such name is defined - it will return its value. So
    far so good. However, when CMake can't find a variable with that name (it didn't
    exist, or was `unset()`) **- it will reach to the cache variables and return a
    value from there if a match is found**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们了解了变量引用的行为，以及 `${}` 语法。每当我们尝试访问普通变量时，CMake 将访问当前作用域的变量，如果定义了具有该名称的变量 - 它将返回其值。到目前为止，一切都很好。然而，当
    CMake 找不到具有该名称的变量（它不存在，或者被 `unset()`）** - 它将访问缓存变量并在找到匹配项时返回其值**。
- en: 'That''s a possible gotcha, if we have a nested scope calling `unset()`. Depending
    on where we reference that variable: in the inner or the outer scope we''ll be
    accessing the cache or the original value.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可能的陷阱，如果我们有一个嵌套作用域调用 `unset()`。取决于我们在哪里引用该变量：在内层还是外层作用域，我们将访问缓存或原始值。
- en: 'But what we can do if we really need to change the variable in calling, parent
    scope? CMake has a `PARENT_SCOPE` flag you can add a the end of `set()` and `unset()`
    commands:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们真的需要在调用的父作用域中改变变量，该怎么办？CMake 有一个 `PARENT_SCOPE` 标志，你可以将其添加到 `set()` 和
    `unset()` 命令的末尾：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That workaround is a bit limited, as it doesn't allow accessing variables more
    than one level up. Another thing worth noting is the fact that using `PARENT_SCOPE`
    doesn't change variables in the current scope.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方法有些局限，因为它不允许访问超过一个层级的变量。另一个值得注意的是，使用 `PARENT_SCOPE` 并不会改变当前作用域中的变量。
- en: 'Let''s see how variable scope works in practice and consider the following
    example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看变量作用域在实践中是如何工作的，并考虑以下示例：
- en: chapter02/04-scope/CMakeLists.txt
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter02/04-scope/CMakeLists.txt
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We set global variable `V` to `1` and then call the `Outer` function, set `V`
    to `2`, call the `Inner` function and set `V` to `3`. After every step we print
    the variable to the console:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将全局变量 `V` 设置为 `1`，然后调用 `Outer` 函数，将 `V` 设置为 `2`，调用 `Inner` 函数并将 `V` 设置为 `3`。在每一步之后，我们将变量打印到控制台：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we explained previously: as we go deeper into the functions - the variable
    values are copied to the nested scope, but as we exit the scope - their original
    value is restored.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的：当我们深入函数时——变量值被复制到嵌套的作用域，但当我们退出作用域时——它们的原始值被恢复。
- en: 'What would the output be if we changed `set()` command of `Inner` function
    to operate on parent scope: `set(V 3 PARENT_SCOPE)`?'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变 `Inner` 函数的 `set()` 命令，使其在父作用域中操作：`set(V 3 PARENT_SCOPE)`，输出会是什么？
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We affected the scope of the `Outer` function, but not the `Inner` scope or
    the global scope!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们影响了 `Outer` 函数的作用域，但没有影响 `Inner` 作用域或全局作用域！
- en: CMake documentation also mentions that CMake Scripts bind variables in one directory
    scope (which is a bit redundant, since the command effectively creating a directory
    scope, `add_subdirectory()` isn't allowed in scripts).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 文档还提到，CMake 脚本在单个目录作用域中绑定变量（这有点多余，因为实际上创建目录作用域的命令 `add_subdirectory()`
    不允许在脚本中使用）。
- en: Since all variables are stored as strings, CMake has to use a bit more creative
    approach to more complex data structures like lists.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有变量都存储为字符串，CMake 必须采用更具创意的方法来处理更复杂的数据结构，如列表。
- en: Using Lists
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用列表
- en: 'To store a list CMake concatenates all elements into a string with a semicolon
    as a delimiter as follows: `a;list;of;5;elements`. You can escape a semicolon
    in an element with a backslash like so: `a\;single\;element`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储一个列表，CMake 会将所有元素拼接成一个以分号为分隔符的字符串，如下所示：`a;list;of;5;elements`。你可以在元素中使用反斜杠来转义分号，例如：`a\;single\;element`。
- en: 'To create a list we can use the `set()` command: `set(myList a list of five
    elements)`. Because how lists are stored, the following commands will have exactly
    the same effect:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `set()` 命令创建一个列表：`set(myList a list of five elements)`。由于列表的存储方式，以下命令将产生完全相同的效果：
- en: '`set(myList "a;list;of;five;elements")`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(myList "a;list;of;five;elements")`'
- en: '`set(myList a list "of;five;elements")`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(myList a list "of;five;elements")`'
- en: 'CMake automatically unpacks lists in Unquoted Arguments. Passing an unquoted
    `myList` reference like so: `message("the list is:" ${myList})` would cause the
    `message()` command to receive 6 arguments: `"the list is:", "a", "list", "of",
    "five", "elements"`. The output of course would be printed without any additional
    spaces between arguments:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 自动在未加引号的参数中解包列表。像这样传递一个未加引号的 `myList` 引用：`message("the list is:" ${myList})`
    会导致 `message()` 命令接收 6 个参数：`"the list is:", "a", "list", "of", "five", "elements"`。当然，输出将不会在参数之间打印任何额外的空格：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see - this is a very simple mechanism and should be taken with grain
    of salt.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见——这是一个非常简单的机制，应该谨慎对待。
- en: 'CMake offers a `list()` command that provides multitude of subcommands to read,
    search, modify and order lists. Here''s a short summary:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了一个 `list()` 命令，它提供了多种子命令来读取、搜索、修改和排序列表。这里是一个简短的总结：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Most of the time we don't really need to use lists in our projects. However,
    if you find yourself in that rare case where this concept would be convenient
    - you'll find a more in-depth reference of the `list()` command in the *Appendix*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们在项目中并不真正需要使用列表。然而，如果你发现自己处于那种罕见的情况，这个概念会带来便利——你会在*附录*中找到关于 `list()`
    命令的更深入参考。
- en: Now that we know how to work with lists and variables of all kinds - let's shift
    our focus to control of execution flow and learn about Control Structures available
    in CMake.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何处理各种列表和变量——让我们将注意力转移到执行流程的控制上，并学习CMake中可用的控制结构。
- en: Understanding the Control Structures
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解控制结构
- en: 'CMake language wouldn''t be complete without Control Structures! Like everything
    else - they are provided in form of a command and they come in three categories:
    conditional blocks, loops and command definitions. Control structures are executed
    in scripts and during the build system generation for projects.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: （没有控制结构的CMake语言是不完整的！就像其他一切一样，它们以命令的形式提供，并分为三类：条件块、循环和命令定义。控制结构在脚本中执行，并在项目构建系统生成期间执行。）
- en: Conditional Blocks
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: （条件块）
- en: 'The only conditional block supported in CMake is the humble `if()`. Every such
    block has to be closed with `endif()` command and may have any number of `elseif()`
    commands and one optional `else()` command in this order:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: （CMake中唯一支持的条件块是简单的`if()`。每个这样的块都必须用`endif()`命令关闭，并且可以有任意数量的`elseif()`命令和一个可选的`else()`命令，顺序如下：）
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Exactly like in many other imperative languages, if-block controls which sets
    of commands will be executed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: （就像许多其他命令式语言一样，if-块控制将执行哪些命令集：）
- en: if the `<condition>` specified in arguments to the `if()` command is met - the
    first section will be executed.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （如果`if()`命令中指定的`<条件>`满足，则将执行第一个代码段。）
- en: Otherwise CMake will execute commands in section belonging to the first `elseif()`
    command in this block that has met its `<condition>`.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （否则，CMake将执行属于该块中第一个满足其`<条件>`的`elseif()`命令的代码段中的命令。）
- en: If there are no such commands - CMake will check if `else()` command is provided
    and execute any commands in that section of the code.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （如果没有任何此类命令，CMake将检查是否提供了`else()`命令，并执行该代码段中的任何命令。）
- en: If none of the above conditions is met - execution continues after the `endif()`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （如果上述条件都不满足，执行将继续在`endif()`之后。）
- en: The provided `<condition>` is evaluated according to a very simple syntax.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: （提供的`<条件>`根据非常简单的语法进行评估。）
- en: Condition Syntax
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: （条件语法）
- en: The same syntax is valid for `if()`, `elseif()` and `while()` commands.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`if()`、`elseif()`和`while()`命令同样适用相同的语法。'
- en: Logical operations
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: （逻辑运算）
- en: '`if()` conditions supports `NOT`, `AND` and `OR` logical operators as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: （`if()`条件支持`NOT`、`AND`和`OR`逻辑运算符，如下所示：）
- en: '`NOT <condition>`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （`NOT <条件>`）
- en: '`<condition> AND <condition>`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<条件> AND <条件>`'
- en: '`<condition> OR <condition>`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<条件> OR <条件>`'
- en: 'Also, nesting of the conditions is possible with matching pairs of parentheses
    `()`. Like all decent languages, CMake respects the order of evaluation and starts
    from innermost parenthesis:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: （此外，可以使用匹配的括号对`()`嵌套条件。像所有体面的语言一样，CMake尊重评估顺序，并从最内层的括号开始：）
- en: '`(<condition>) AND (<condition> OR (<condition>))`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(<条件>) AND ((<条件>) OR (<条件>))`'
- en: Evaluation of a string and a variable
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: （字符串和变量的评估）
- en: 'For legacy reasons (because the variable reference `${}` syntax wasn''t always
    around), CMake will try to evaluate unquoted arguments as if they would be variable
    references. In other words: using a plain variable name `VAR` inside a condition
    is equal to writing `${VAR}`. Here''s an example for you to consider, and a gotcha:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: （由于历史原因（因为变量引用`${}`语法并不总是存在），CMake将尝试将未加引号的参数评估为变量引用。换句话说：在条件中使用简单的变量名`VAR`等于写`${VAR}`。这里有一个例子供你考虑，还有一个陷阱：）
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`if()` condition works in a bit convoluted way here: first it will evaluate
    `${VAR2}` to `VAR1`, which is a recognized variable and is in turn evaluated to
    `FALSE` string. **Strings are considered Boolean true only if they equal any of
    following constants** (comparisons are case insensitive):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: （`if()`条件在这里以一种有些复杂的方式工作：首先，它将`${VAR2}`评估为`VAR1`，这是一个已识别的变量，然后又评估为`FALSE`字符串。**只有当字符串等于以下任何常量时，它们才被认为是布尔真**（比较时不区分大小写）：）
- en: '`ON`, `Y`, `YES`, `TRUE`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: （`ON`、`Y`、`YES`、`TRUE`）
- en: a non-zero number
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （非零数字）
- en: This brings us to a conclusion that condition in above example will be evaluated
    to false.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: （这使我们得出结论，上述示例中的条件将被评估为假。）
- en: 'However, here''s another catch: what would be the evaluation of an condition
    with an unquoted argument with a name of variable containing value like `BAR`?'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: （然而，这里有一个问题：对于一个未加引号的参数，其名称是一个包含值如`BAR`的变量，这个条件的评估结果会是什么？）
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'According to all we said so far - it would be false, since the string `BAR`
    doesn''t meet the criteria of Boolean true. That''s unfortunately not the case,
    because **CMake makes an exception when it comes to unquoted variable references**.
    Yes, an explicit `if("BAR")` would be considered a Boolean false, but since that
    same value is stored in a variable. But CMake will only evaluate `if(FOO)` to
    false only if it is any of following constants (comparisons are case insensitive):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们目前所说的，这将是假的，因为字符串`BAR`不符合布尔值真的标准。不幸的是，情况并非如此，因为**CMake在未加引号的变量引用方面做出了例外**。是的，显式的`if("BAR")`将被视为布尔值假，但由于该值存储在变量中。但是，CMake只有在以下常量之一时才会将`if(FOO)`评估为假（比较不区分大小写）：
- en: '`OFF`, `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OFF`, `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`'
- en: string ending with `-NOTFOUND`
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以`-NOTFOUND`结尾的字符串
- en: an empty string
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串
- en: zero
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零
- en: 'So simply asking for an undefined variable will be evaluated to **false**:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简单地询问未定义的变量将被评估为**假**：
- en: '[PRE27]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But defining a variable beforehand changes situation and the condition is evaluated
    to **true**:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，事先定义变量会改变情况，条件将被评估为**真**：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Note**'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you think that behavior of unquoted arguments is confusing - wrap variable
    references in quoted arguments: `if ("${FOO}")`. This will cause argument evaluation
    before it is passed into the `if()` command and behavior will be consistent with
    evaluation of strings.'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你认为未加引号的参数的行为令人困惑，请将变量引用包裹在引号中：`if ("${FOO}")`。这将导致在传递给`if()`命令之前对参数进行评估，行为将与字符串的评估一致。
- en: 'In other words - CMake assumes that user is asking if variable is defined (and
    is not explicitly false). Luckily, we can explicitly check that fact (and not
    worry about value inside):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，CMake假设用户是在询问变量是否已定义（且不是显式假）。幸运的是，我们可以明确检查这一事实（而不必担心内部值）：
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Comparing values
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比较值
- en: 'Comparison operations are supported with following operators:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 比较操作支持以下操作符：
- en: '`EQUAL`, `LESS`, `LESS_EQUAL`, `GREATER`, `GREATER_EQUAL`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`EQUAL`, `LESS`, `LESS_EQUAL`, `GREATER`, `GREATER_EQUAL`'
- en: 'They can be used to compare numeric values like so:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以用来比较数值，如下所示：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Note**'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'CMake''s documentation states that if one of the operands is not a number -
    the value will be false. But practical experiments show that comparison of strings
    starting with a number work correctly: `if (20 EQUALS "20 GB")`'
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CMake的文档指出，如果其中一个操作数不是数字，则值将为假。但实际实验表明，以数字开头的字符串比较可以正确工作：`if (20 EQUALS "20
    GB")`
- en: 'Compare software versions following the `major[.minor[.patch[.tweak]]]` format
    by adding a `VERSION_` prefix to any of the operators:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在任何操作符前添加`VERSION_`前缀，按照`major[.minor[.patch[.tweak]]]`格式比较软件版本：
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Omitted components are treated as zero and non-integer version component truncate
    the compared string at that point.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 省略的组件被视为零，非整数版本组件将比较的字符串截断到该点。
- en: 'For lexicographical string comparisons we need to prepend an operator with
    `STR` prefix (note the lack of the underscore):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字典序字符串比较，我们需要在操作符前加上`STR`前缀（注意没有下划线）：
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we often find out - that simply is not enough, fortunately CMake also supports
    POSIX regex matching (documentation hints at ERE flavor, but no support of character
    classes is mentioned). Use `MATCHES` operator like so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们经常发现的那样，这还不够，幸运的是，CMake还支持POSIX正则表达式匹配（文档暗示ERE风味，但没有提到字符类支持）。使用`MATCHES`操作符，如下所示：
- en: '`<VARIABLE|STRING> MATCHES <regex>`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`<VARIABLE|STRING> MATCHES <regex>`'
- en: Any matched groups are captured in CMAKE_MATCH_<n> variables.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 任何匹配的组都捕获在CMAKE_MATCH_<n>变量中。
- en: Simple checks
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单检查
- en: We already mentioned one simple check `DEFINED` but there are others that simply
    return true if a simple condition is met.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经提到过一种简单的检查`DEFINED`，但还有其他一些检查，如果满足简单条件，则直接返回真。
- en: 'We can check if:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查：
- en: 'a value is in a list: `<VARIABLE|STRING> IN_LIST <VARIABLE>`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值在列表中：`<VARIABLE|STRING> IN_LIST <VARIABLE>`
- en: 'a command is available for invocation: `COMMAND <command-name>`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于调用的命令：`COMMAND <command-name>`
- en: 'a CMake policy exists: `POLICY <policy-id>` (covered in *Chapter 3*)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake政策存在：`POLICY <policy-id>`（在*第3章*中介绍）
- en: 'a CTest test was added with `add_test()`: `TEST <test-name>`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`add_test()`添加了CTest测试：`TEST <test-name>`
- en: 'and if a build target is defined: `TARGET <target-name>`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果构建目标已定义：`TARGET <target-name>`
- en: We'll get to build targets in *Chapter 4, Working with targets*, for now let's
    just say that targets are logical units of build process in project created with
    `add_executable()`, `add_library()`, or `add_custom_target()` command that has
    already been invoked.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '-   我们将在*第4章，使用目标工作*中介绍构建目标，现在我们只能说，目标是在项目中使用`add_executable()`，`add_library()`或`add_custom_target()`命令创建的构建过程的逻辑单元，该命令已经被调用。'
- en: Examining the filesystem
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '-   检查文件系统'
- en: 'CMake provides many ways of working with files. We seldom need to manipulate
    them directly and we''d rather use more of a high-level approach. This book will
    provide a short reference of file-related commands in the *Appendix*. But most
    often only following operators will be needed (behavior is well-defined only for
    full paths):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '-   CMake提供了许多处理文件的方法。我们很少需要直接操作它们，我们更愿意使用更高层次的方法。本书将在*附录*中提供文件相关命令的简短参考。但大多数情况下，只需要以下操作符（只有对于完整路径，行为才是明确定义的）：'
- en: 'Check if file or directory exists: `EXISTS <path-to-file-or-directory>`It resolves
    symbolic links (returns true if the target of the symbolic link exists).'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   检查文件或目录是否存在：`EXISTS <path-to-file-or-directory>`它解析符号链接（如果符号链接的目标存在，则返回true）。'
- en: 'Check which file is newer: `<file1> IS_NEWER_THAN <file2>`True if file1 is
    newer (or equal) than file2 or if one of the two files doesn’t exist.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   检查哪个文件更新：`<file1> IS_NEWER_THAN <file2>`如果file1比file2更新（或相等），或者两个文件中有一个不存在，则返回true。'
- en: 'Check if path is a directory: `IS_DIRECTORY path-to-directory`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   检查路径是否为目录：`IS_DIRECTORY path-to-directory`'
- en: 'Check if path is a symbolic link: `IS_SYMLINK file-name`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '-   检查路径是否为符号链接：`IS_SYMLINK file-name`'
- en: 'Check if path is absolute: `IS_ABSOLUTE path`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 检查路径是否为绝对路径：`IS_ABSOLUTE path`
- en: Loops
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '-   循环'
- en: 'Loops in CMake are fairly straightforward, we can use either `while()` or `foreach()`
    to repeatedly execute the same set of commands. Both of these commands support
    loop control mechanisms:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: CMake中的循环相当直接，我们可以使用`while()`或`foreach()`来重复执行同一组命令。这两个命令都支持循环控制机制：
- en: '`break()` stops the execution of remaining block and breaks from enclosing
    loop.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   `break()`停止执行剩余的块并从封闭的循环中退出。'
- en: '`continue()` stops the execution of current iteration and starts at the top
    of the next one.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue()` 停止当前迭代的执行，并从下一次迭代的顶部开始。'
- en: While
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '-   While'
- en: The loop block is opened with `while()` and closed with `endwhile()` commands.
    Any enclosed commands will be executed as long as the `<condition>` provided in
    `while()` is true. Syntax for phrasing the condition is the same as for the `if()`
    command.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '-   循环块以`while()`命令打开，以`endwhile()`命令关闭。只要`while()`中提供的`<condition>`为true，就会执行任何封闭的命令。表述条件的语法与`if()`命令相同。'
- en: '[PRE33]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You probably guessed that with some additional variables - the while loop can
    replace a for loop. Actually it's way easier to use a `forach()` loop for that
    - let's take a look.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '-   您可能已经猜到，通过一些额外的变量，while循环可以替换for循环。实际上，使用`forach()`循环来做这件事要容易得多 - 让我们来看看。'
- en: Foreach
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '-   Foreach'
- en: 'Foreach block comes in a few variants that execute enclosed commands for each
    value. Like other blocks it has opening and closing commands: `foreach()` and
    `endforeach()`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '-   Foreach块有几种变体，它们为每个值执行封闭的命令。与其他块一样，它有打开和关闭命令：`foreach()`和`endforeach()`。'
- en: 'Simplest form of foreach is meant to provide a C++-style for loop:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '-   最简单的foreach形式旨在提供C++风格的for循环：'
- en: '[PRE34]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: CMake will iterate from 0 to `<max>` (including). If we need more control, we
    can use second variant, providing `<min>`, `<max>` and optionally `<step>`. All
    arguments must be nonnegative integers. Also `<min>` has to be smaller than `<max>`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '-   CMake将从0迭代到`<max>`（包括）。如果我们需要更多控制，我们可以使用第二种变体，提供`<min>`，`<max>`和可选的`<step>`。所有参数必须是正整数。此外，`<min>`必须小于`<max>`。'
- en: '[PRE35]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, `foreach()` shows its true colors when it is working with lists:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '-   然而，`foreach()`在处理列表时才真正展现其能力：'
- en: '[PRE36]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'CMake will take items from all provided `<lists>` followed by all explicitly
    stated `<items>` and store them in `<loop variable>` executing `<commands>` for
    every item one by one. You can choose to provide only lists, only items or both:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '-   CMake将从所有提供的`<lists>`后面跟着所有明确声明的`<items>`中取出项目，并将它们存储在`<loop variable>`中，为每个项目逐一执行`<commands>`。您可以选择只提供列表，只提供项目，或两者都提供：'
- en: chapter02/06-loops/foreach.cmake
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter02/06-loops/foreach.cmake
- en: '[PRE37]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Which will print
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '-   这将打印'
- en: '[PRE38]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or use a short version (skipping the `IN`) for the same result:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '-   或者使用简短版本（跳过`IN`）以获得相同的结果：'
- en: '[PRE39]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Since version 3.17 `foreach()` has learned how to `ZIP_LISTS`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '-   自版本3.17起，`foreach()`已经学会了如何`ZIP_LISTS`：'
- en: '[PRE40]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Zipping lists means simply iterating through multiple lists and working on
    respective items with the same index. Let''s look at example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩列表意味着简单地遍历多个列表并对具有相同索引的相应项进行操作。让我们看一个例子：
- en: chapter02/06-loops/foreach.cmake
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 章节02/06-循环/foreach.cmake
- en: '[PRE41]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'CMake will create `num_<N>` variables, one for each list provided, which it
    will fill with item from each list. You can pass multiple `<loop_var>`s (one for
    every list) - each list will use a separate variable to store its items:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将创建`num_<N>`变量，每个提供的列表一个，它将用每个列表的项填充它们。你可以传递多个`<loop_var>`（每个列表一个） - 每个列表将使用一个单独的变量来存储其项：
- en: '[PRE42]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If count of items differs between lists - CMake won't define variables for shorter
    ones.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表之间的项数不同 - CMake不会为较短的列表定义变量。
- en: That's all when it comes to loops.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于循环的所有内容。
- en: Command Definitions
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令定义
- en: 'There are two ways to define your own command: by using `macro()` or `function()`
    commands. Easiest way to explain the differences between them is comparing them
    to C-style preprocessor macros and actual C++ functions:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自己的命令有两种方法：使用`macro()`或`function()`命令。解释它们之间差异的最简单方法是将它们与C风格的预处理器宏和实际的C++函数进行比较：
- en: '`macro()` works more like a find-and-replace instruction rather than actual
    subroutine call like `function()` with its own entry on a call stack. This means
    that calling `return()` in a macro will return to the calling statement one level
    higher than it would for a function (possibly terminating the execution if we''re
    already in a top scope).'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`macro()`更像是一个查找和替换指令，而不是像`function()`那样具有自己的调用堆栈入口的实际子程序调用。这意味着在宏中调用`return()`将返回到比函数调用高一级的调用语句（如果我们在顶层作用域中，可能会终止执行）。'
- en: Only `function()` creates a separate scope for local variables. `macro()` works
    in the calling scope - which may lead to confusing results. Let's talk about details
    in next section.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有`function()`为局部变量创建一个单独的作用域。`macro()`在调用作用域中工作 - 这可能导致令人困惑的结果。我们将在下一节讨论细节。
- en: 'Both methods accept arguments which you can name and reference inside command
    block. Additionally, CMake allows you to access arguments passed in command call
    with following references:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都接受参数，你可以在命令块内命名和引用这些参数。此外，CMake允许你使用以下引用访问传递给命令调用的参数：
- en: '`${ARGC}` - count of arguments'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGC}` - 参数计数'
- en: '`${ARGV}` - list of all arguments'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGV}` - 所有参数的列表'
- en: '`${ARG0}`, `${ARG1}`, `${ARG2}`… - value of argument at specific index'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARG0}`，`${ARG1}`，`${ARG2}`… - 特定索引处的参数值'
- en: '`${ARGN}` - list of arguments passed past the last expected arguments'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGN}` - 传递给最后一个预期参数之后的参数列表'
- en: Accessing numeric argument with index outside `ARGC` bounds is undefined behavior.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 访问超出`ARGC`边界的数字参数索引是未定义的行为。
- en: If you decide to define a command with named arguments - every call has to pass
    all of them or it will be invalid.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用命名参数定义命令 - 每次调用都必须传递所有参数，否则将无效。
- en: Macro
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 宏
- en: 'Defining a macro is similar to any other block:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 定义宏类似于任何其他块：
- en: '[PRE43]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After such declaration we may execute our macro by calling its name (function
    calls are case-insensitive).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在如此声明之后，我们可以通过调用其名称（函数调用不区分大小写）来执行我们的宏。
- en: 'Following example explains all the problems with variable scope in macros:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例解释了宏中变量作用域的所有问题：
- en: chapter02/08-definitions/macro.cmake
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 章节02/08-定义/macro.cmake
- en: '[PRE44]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here''s the output from this script:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该脚本的输出：
- en: '[PRE45]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'What happened? Despite explicitly setting `myVar` to `new value` - it didn''t
    affect the output for `message("argument: ${myVar}")`! This is because arguments
    passed to macros aren''t treated as real variables but rather as constant find-and-replace
    instructions.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '发生了什么？尽管明确地将`myVar`设置为`new value` - 但它并没有影响`message("argument: ${myVar}")`的输出！这是因为传递给宏的参数不被视为真正的变量，而是被视为常量的查找和替换指令。'
- en: On the other hand - the variable `myVar` in global scope got changed from `first
    value` to `new value`. Such behavior is called a side effect and is considered
    a bad practice, since it's hard to tell which variables might get affected by
    such macro without reading it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面 - 全局作用域中的变量`myVar`从`first value`更改为`new value`。这种行为被称为副作用，被认为是不良实践，因为很难判断哪些变量可能会受到这种宏的影响，而无需阅读它。
- en: I recommend using functions whenever you can. Likely it will save you a lot
    of headaches.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议尽可能使用函数。这很可能会为你节省很多头疼的问题。
- en: Function
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数
- en: 'To declare command as a function, follow this syntax:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明命令作为函数，请遵循此语法：
- en: '[PRE46]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Function requires a name and optionally accepts list of required arguments.
    As mentioned before - functions open their own scope. You can call `set()` providing
    one of named arguments of function and change will be local to the function (unless
    `PARENT_SCOPE` is specified, as we discussed in the *Variables: Scope* section).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 函数需要一个名称，并且可以选择性地接受一组必需的参数。如前所述——函数打开自己的作用域。您可以调用`set()`并提供函数的一个命名参数，更改将是局部的（除非指定了`PARENT_SCOPE`，正如我们在*变量：作用域*部分讨论的那样）。
- en: Functions follow the rules of call stack, enabling returning to calling scope
    with `return()` command.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 函数遵循调用堆栈的规则，允许使用`return()`命令返回到调用作用域。
- en: 'CMake sets following variables for each function (available since version 3.17):'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: CMake为每个函数设置以下变量（自版本3.17起可用）：
- en: '`CMAKE_CURRENT_FUNCTION`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION`'
- en: '`CMAKE_CURRENT_FUNCTION_LIST_DIR`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION_LIST_DIR`'
- en: '`CMAKE_CURRENT_FUNCTION_LIST_FILE`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION_LIST_FILE`'
- en: '`CMAKE_CURRENT_FUNCTION_LIST_LINE`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION_LIST_LINE`'
- en: 'Let''s take a look at functions in practice:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看实际中的函数：
- en: chapter02/08-definitions/function.cmake
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter02/08-definitions/function.cmake
- en: '[PRE47]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Prints this output:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出以下输出：
- en: '[PRE48]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, the general syntax and concept of functions is very similar
    to macros but this time - it actually works.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数的一般语法和概念与宏非常相似，但这次——它确实有效。
- en: Procedural paradigm in CMake
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CMake中的过程范式
- en: Let's imagine for a second that we want to write a CMake code like we would
    write a program in C++. We'll have a `CMakeLists.txt` listfile that will call
    three defined commands which may call defined commands of their own.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，如果我们想像编写C++程序那样编写CMake代码。我们将有一个`CMakeLists.txt`列表文件，它将调用三个已定义的命令，这些命令可能调用它们自己的已定义命令。
- en: '![Figure 2.3: A procedural call graph](img/file7.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：过程调用图](img/file7.png)'
- en: 'Figure 2.3: A procedural call graph'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：过程调用图
- en: 'Writing in such procedural style is a bit of a problem in CMake: you are required
    to provide command definitions you''re planning to use ahead of time. CMake parser
    will not have it any other way. Your code would look something like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake中以这种过程式风格编写代码存在一些问题：您需要提前提供计划使用的命令定义。CMake解析器不会接受其他方式。您的代码可能看起来像这样：
- en: '[PRE49]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: What a nightmare! Everything is reversed! This code is very difficult to read
    as the most miniscule details are at the top of the file. A correctly structured
    code lists the most general steps in first subroutine, and then provides a bit
    more detailed subroutines and pushes the most detailed steps to the very end of
    the file.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 真是噩梦！一切都颠倒了！这段代码非常难以阅读，因为最微小的细节都位于文件的顶部。结构良好的代码首先列出最一般的步骤，然后提供更详细的子程序，并将最详细的步骤推到文件的末尾。
- en: 'There are solutions to this problem: moving command definitions to other files,
    partitioning scope across directories. But there is also one that is simple and
    elegant: declaring an entry-point macro at the top and calling it at the very
    end of the file:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 有解决这个问题的方法：将命令定义移动到其他文件，跨目录划分作用域。但也有一个简单而优雅的方法：在文件顶部声明一个入口点宏，并在文件的最后调用它：
- en: '[PRE50]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With this approach our code is written with gradually narrowing scope and because
    we're not actually calling the `main()` macro until the very end - CMake won't
    complain about execution of undefined commands!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们的代码是按照逐渐缩小的作用域编写的，而且由于我们实际上直到最后才调用`main()`宏——CMake不会抱怨执行未定义的命令！
- en: 'One last question remains: why use macro over a recommended function? In this
    case it''s good to have unrestricted access to global variables and since we''re
    not passing any arguments to main - we don''t need to worry about the usual caveats.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题仍然存在：为什么要使用宏而不是推荐的功能？在这种情况下，拥有对全局变量的不受限制的访问是很好的，而且由于我们没有向主函数传递任何参数——我们不必担心通常的注意事项。
- en: You'll find a simple example of this concept in the `chapter-02/09-procedural/CMakeLists.txt`
    listfile.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter-02/09-procedural/CMakeLists.txt`列表文件中找到这个概念的一个简单示例。
- en: A word on naming
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于命名的一点说明
- en: 'Naming is famously hard in software development but nevertheless very important
    to maintain solution that is easy to read and understand. When it comes to CMake
    scripts and projects all the rules of clean code apply as they would to normal
    software development solution:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 命名在软件开发中是出了名的难，但仍然非常重要，以维护易于阅读和理解的解决方案。当涉及到CMake脚本和项目时，所有干净代码的规则都适用，就像它们适用于正常的软件开发解决方案一样：
- en: Follow consistent naming style (`snake_case` is accepted standard in the CMake
    community).
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循一致的命名风格（`snake_case`是CMake社区接受的规范）。
- en: Use short but meaningful names (avoid `func()`, `f()` and such).
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简短但有意义的名称（避免使用`func()`、`f()`等）。
- en: Avoid puns and cleverness in your naming.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在命名中使用双关语和机智。
- en: Use pronounceable, searchable names that don't require mental mapping.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可发音的、可搜索的名称，不需要心理映射。
- en: Now that we know how to properly invoke the commands with correct syntax, let's
    find which commands will be the most beneficial to begin with.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何正确调用命令并使用正确的语法，那么让我们找出哪些命令将是最有益的开始。
- en: Useful Commands
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的命令
- en: 'CMake offers many, many scripting commands with allow you to work with variables
    and environment. Some of them are covered extensively in the *Appendix*: `list()`,
    `string()`, `file()` (to avoid slowing us down on our road to projects). Others,
    like `find_...()` fit better in chapters that talk about managing dependencies.
    In this section we''ll shortly cover the most useful commands for scripts.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了许多脚本命令，允许你使用变量和环境。其中一些在*附录*中得到了广泛介绍：`list()`、`string()`、`file()`（为了避免在我们通往项目的路上拖慢我们）。其他的，如`find_...()`更适合在讨论管理依赖关系的章节中。在本节中，我们将简要介绍脚本中最有用的命令。
- en: message()
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: message()
- en: 'We already know and love our trusty `message()` command that prints text to
    standard output. However there''s a lot more to it than meets the eye. By providing
    a `MODE` argument you can customize the style of the output and in case of an
    error stop the execution of the code: `message(<MODE> "text")`.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道并喜欢我们可靠的`message()`命令，它将文本打印到标准输出。然而，它远不止于此。通过提供一个`MODE`参数，你可以自定义输出的样式，并且在出现错误时停止代码的执行：`message(<MODE>
    "text")`。
- en: 'Recognized modes:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 识别的模式：
- en: '`FATAL_ERROR` - stops processing and generation.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FATAL_ERROR` - 停止处理和生成。'
- en: '`SEND_ERROR` - continue processing, but skip generation.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEND_ERROR` - 继续处理，但跳过生成。'
- en: '`WARNING` - continue processing'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING` - 继续处理'
- en: '`AUTHOR_WARNING` - CMake Warning (dev), continue processing.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTHOR_WARNING` - CMake警告（开发中），继续处理。'
- en: '`DEPRECATION` - works accordingly if variable `CMAKE_ERROR_DEPRECATED` or `CMAKE_WARN_DEPRECATED`
    is enabled'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEPRECATION` - 如果启用了变量`CMAKE_ERROR_DEPRECATED`或`CMAKE_WARN_DEPRECATED`，则相应地工作。'
- en: '`NOTICE` or (none) - message printed to stderr to attract user’s attention.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOTICE` 或（无）- 消息打印到stderr以吸引用户的注意。'
- en: '`STATUS`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATUS`'
- en: '`VERBOSE`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VERBOSE`'
- en: '`DEBUG`'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG`'
- en: '`TRACE`'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`'
- en: 'Following example stops execution after first message:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在第一个消息后停止执行：
- en: chapter02/10-useful/message_error.cmake
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter02/10-useful/message_error.cmake
- en: '[PRE51]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Messages will be printed depending on current log-level (`STATUS` by default).
    We discussed how to change it previous chapter, in the *Options: Debugging & Tracing*
    section. I have then promised to talk about debugging with `CMAKE_MESSAGE_CONTEXT`
    - let''s get to it. Since then, we acquired three important pieces to this puzzle:
    lists, scope and functions.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 消息将根据当前的日志级别（默认为`STATUS`）打印。我们在上一章的*选项：调试与跟踪*部分讨论了如何更改它。然后我承诺会讨论使用`CMAKE_MESSAGE_CONTEXT`进行调试
    - 让我们开始吧。从那时起，我们获得了这个难题的三个重要部分：列表、作用域和函数。
- en: 'When we enable a command line flag `cmake --log-context`, our messages will
    be decorated with dot-separated context stored in `CMAKE_MESSAGE_CONTEXT` list.
    Consider the following example:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启用命令行标志`cmake --log-context`时，我们的消息将用点分隔的上下文装饰，该上下文存储在`CMAKE_MESSAGE_CONTEXT`列表中。考虑以下示例：
- en: chapter02/10-useful/message_context.cmake
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: chapter02/10-useful/message_context.cmake
- en: '[PRE52]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Output of above script will look like this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本的输出将如下所示：
- en: '[PRE53]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Initial scope of function is copied from the parent scope (which has already
    one item in the list: `top`). First command in `foo` adds new item with function
    name `foo` to `CMAKE_MESSAGE_CONTEXT`. The message is printed and function scope
    ends, discarding the local, copied variables, and previous scope (without `foo`)
    is restored.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的初始作用域是从父作用域复制的（父作用域已经在列表中有一个项：`top`）。`foo`中的第一个命令向`CMAKE_MESSAGE_CONTEXT`添加了一个新项，其名称为`foo`。消息被打印出来，函数作用域结束，丢弃了本地复制的变量，以及之前的（没有`foo`）作用域被恢复。
- en: This approach is useful with many nested functions in very complex projects.
    Hopefully, you won't ever need it but I thought it is a really good example of
    how function scope works in practice.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在非常复杂的项目中，有许多嵌套函数时非常有用。希望你永远不需要它，但我认为这是一个很好的例子，说明了函数作用域在实践中是如何工作的。
- en: 'Another cool trick with `message()` is to add indentation to `CMAKE_MESSAGE_INDENT`
    list (exactly the same way as with `CMAKE_MESSAGE_CONTEXT`):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`message()`的另一个很酷的技巧是向`CMAKE_MESSAGE_INDENT`列表添加缩进（与`CMAKE_MESSAGE_CONTEXT`完全相同）：'
- en: '[PRE54]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Output from our scripts can then look a bit cleaner:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本输出看起来会更清晰一些：
- en: '[PRE55]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since CMake doesn't offer any real debugger with breakpoints or other tools
    - ability to produce clean log messages comes very handy when things don't go
    exactly as planned.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CMake没有提供任何真正的带有断点或其他工具的调试器，因此能够生成清晰的日志消息在事情没有完全按计划进行时非常有用。
- en: include()
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: include()
- en: 'We can partition our CMake code into separate files to keep things ordered
    and… well separate. Then we can reference them from our parent listfile by calling
    `include()` like this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的CMake代码分成单独的文件，以保持事物的有序和…嗯，分开。然后我们可以通过调用`include()`从我们的父列表文件中引用它们，如下所示：
- en: '[PRE56]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If we provide a filename (path with a `.cmake` extension) - CMake will try to
    open and execute it. Note that no nested, separate scope will be created, so any
    changes to variables done in that file will affect the calling scope.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供了一个带有`.cmake`扩展名的文件名（路径），CMake将尝试打开并执行它。请注意，不会创建嵌套的、独立的范围，因此该文件中对变量所做的任何更改都会影响调用范围。
- en: CMake will raise an error if file doesn't exist unless we specify that it is
    `OPTIONAL`. If we need to know if include was successful - we can provide a `RESULT_VARIABLE`
    keyword with a name of variable. It will be filled with a full path to included
    file on success or `NOTFOUND` on failure.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: CMake会在文件不存在的情况下抛出错误，除非我们指定它是`OPTIONAL`。如果我们需要知道包含是否成功，我们可以提供一个`RESULT_VARIABLE`关键字和一个变量名。如果成功，它将被填充为包含文件的完整路径，或者在失败时填充为`NOTFOUND`。
- en: 'When running in script mode any relative paths will be resolved from current
    working directory. To force searching in relation to the script itself provide
    an absolute path:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本模式下运行时，任何相对路径都将从当前工作目录解析。要强制在相对于脚本本身的位置搜索，请提供一个绝对路径：
- en: '[PRE57]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If we don't provide a path but a name of a module (without `.cmake` or otherwise),
    CMake will try to find a module and include it. CMake will search for the file
    with name `<module>.cmake` in `CMAKE_MODULE_PATH` and then in the CMake module
    directory.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不提供路径，而是提供一个模块的名称（不带`.cmake`或其他后缀），CMake将尝试找到该模块并包含它。CMake会在`CMAKE_MODULE_PATH`中搜索名为`<module>.cmake`的文件，然后在CMake模块目录中搜索。
- en: include_guard()
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: include_guard()
- en: When we include files that have side effects, we might want to restrict them
    to only be included once. This is where `include_guard([DIRECTORY|GLOBAL])` comes
    in.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们包含具有副作用的文件时，我们可能希望限制它们只被包含一次。这时`include_guard([DIRECTORY|GLOBAL])`就派上用场了。
- en: Put `include_guard()` at the top of included file. When CMake encounters it
    for the first time - it will make a note of this fact in the current scope. If
    file gets included again (maybe because we don't control all files in our project)
    - it won't be processed any further.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含的文件顶部放置`include_guard()`。当CMake第一次遇到它时，它会在当前范围内记录这一事实。如果文件再次被包含（可能是因为我们不控制项目中的所有文件），它将不会被进一步处理。
- en: If we want to protect against inclusion in scopes that aren’t nested within
    each other - we should provide `DIRECTORY` or `GLOBAL` arguments. As names suggest
    - `DIRECTORY` guard will apply within current directory and below and `GLOBAL`
    applies to the whole build.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想防止在彼此不嵌套的范围内包含，我们应该提供`DIRECTORY`或`GLOBAL`参数。顾名思义，`DIRECTORY`保护将适用于当前目录及其下，而`GLOBAL`适用于整个构建。
- en: file()
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: file()
- en: 'To give you a hint of what you can do with CMake scripts - let''s take a quick
    glance at the most useful variants of file manipulation command:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个关于CMake脚本可以做什么的提示，让我们快速看一下文件操作命令的最有用变体：
- en: '[PRE58]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In short, the `file()` command will let you read, write, transfer files, work
    with the filesystem, file locks, paths and archives; all in a system-independent
    manner. See the *Appendix* for details.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`file()`命令将允许你以系统独立的方式读取、写入、传输文件，处理文件系统、文件锁、路径和存档；所有这些都在系统独立的方式下进行。详情请参阅*附录*。
- en: execute_process()
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: execute_process()
- en: 'Every now and then you''ll need to resort to tools available in the system
    (after all CMake is primarily a buildsystem generator). CMake offers a command
    for this purpose: you can use `execute_process()` to run other processes and collect
    their output. This command is a great fit for scripts, and can also be used in
    projects during the configuration stage. Here''s the general form:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你将需要求助于系统中可用的工具（毕竟CMake主要是一个构建系统生成器）。CMake为此提供了一个命令：你可以使用`execute_process()`来运行其他进程并收集它们的输出。这个命令非常适合脚本，也可以在项目配置阶段使用。这里是一般形式：
- en: '[PRE59]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'CMake will use the API of operating system to create a child process (so shell
    operators like: `&&`, `||`, and `>` won''t work). However, you can still chain
    commands and pass output of one to another simply by providing the `COMMAND <cmd>
    <arguments>` arguments more than once.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将使用操作系统的API来创建一个子进程（因此像`&&`、`||`和`>`这样的shell操作符将不起作用）。然而，你仍然可以通过多次提供`COMMAND
    <cmd> <arguments>`参数来链接命令并将一个命令的输出传递给另一个。
- en: Optionally you may use a `TIMEOUT <seconds>` to terminate process if it hasn't
    finished the task within the limit, and set the `WORKING_DIRECTORY <directory>`
    as you need.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择使用`TIMEOUT <seconds>`来终止进程，如果它在限定时间内未完成任务，并根据需要设置`WORKING_DIRECTORY <directory>`。
- en: 'Exit codes of all tasks can be collected to a list by providing `RESULTS_VARIABLE
    <variable>` arguments. If you''re only interested in result of last executed command
    use the singular form: `RESULT_VARIABLE <variable>`.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 所有任务的退出代码可以通过提供`RESULTS_VARIABLE <variable>`参数来收集到一个列表中。如果你只对最后一个执行的命令的结果感兴趣，请使用单数形式：`RESULT_VARIABLE
    <variable>`。
- en: 'To collect the output CMake provides two arguments: `OUTPUT_VARIABLE` and `ERROR_VARIABLE`,
    used in similar fashion. If you like to merge both `stdout` and `stderr` - use
    the same variable for both arguments.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集输出，CMake提供了两个参数：`OUTPUT_VARIABLE`和`ERROR_VARIABLE`，使用方式类似。如果你想要合并`stdout`和`stderr`，可以使用同一个变量作为这两个参数。
- en: Remember, that when writing projects for other users - you should make sure
    that the command you're planning to use is available on platforms you claim to
    support.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你为其他用户编写项目时，你应该确保你计划使用的命令在你声称支持的平台上可用。
- en: Summary
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter opened the door to actual programming with CMake - you're now able
    to write great, informative comments; invoke built-in commands and you understand
    how to correctly provide all kinds of arguments to them. This knowledge alone
    will help you understand a bit peculiar syntax of CMake listfiles you may have
    seen in other projects.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 本章打开了使用CMake进行实际编程的大门——你现在能够编写出色的、信息丰富的注释；调用内置命令，并理解如何正确地向它们提供各种参数。仅凭这些知识，就能帮助你理解在其他项目中可能见到的CMake
    listfiles的略显奇特的语法。
- en: 'Next, we covered variables in CMake: how to reference, set and unset normal,
    cache and environment variables. We dove deep into how directory and function
    scopes work and what are the issues (and their workarounds) of nested scopes.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了CMake中的变量：如何引用、设置和取消普通、缓存和环境变量。我们深入探讨了目录和函数作用域的工作原理，以及嵌套作用域的问题（及其解决方法）。
- en: We also covered lists and control structures. We discussed syntax of a condition,
    its logical operations, evaluation of unquoted arguments, strings and variables.
    We learned how to compare values, do simple checks and examine the state of the
    files in the system. This allows us to write conditional blocks and while loops.
    And while loops are the subject - we also grasped the syntax of the foreach.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了列表和控制结构。我们讨论了条件的语法、逻辑操作、未加引号的参数的评估、字符串和变量。我们学会了如何比较值、进行简单检查以及检查系统中文件的状态。这使我们能够编写条件块和while循环。说到while循环，我们也掌握了foreach的语法。
- en: I'm sure that knowing how to define your own commands with macro and function
    statements will help you write cleaner code in more procedural style. We also
    shared a few hints how to structure our code better and come up with more readable
    names.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，知道如何使用宏和函数语句定义自己的命令将帮助你编写更简洁的代码，并以更过程化的风格编写。我们还分享了一些关于如何更好地组织我们的代码和想出更具可读性的名称的提示。
- en: Finally - we were formally introduced to message() and its multiple log levels.
    We also studied how to partition and include listfiles and discovered a few other
    useful commands. I feel confident that with this material we are ready to tackle
    next chapter and write our first project in CMake.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们正式介绍了message()及其多个日志级别。我们还研究了如何划分和包含listfiles，并发现了一些其他有用的命令。我确信，有了这些材料，我们已准备好迎接下一章，并编写我们的第一个CMake项目。
- en: Further Reading
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information you can refer to the following:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下内容以获取更多信息：
- en: 'Clean Code: A Handbook of Agile Software Craftsmanship (Robert C. Martin) [https://amzn.to/3cm69DD](https://amzn.to/3cm69DD)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[《代码整洁之道：程序员的敏捷软件工艺手册》](https://amzn.to/3cm69DD)（Robert C. Martin）'
- en: 'Refactoring: Improving the Design of Existing Code (Martin Fowler) [https://amzn.to/3cmWk8o](https://amzn.to/3cmWk8o)'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[重构：改善现有代码的设计](https://amzn.to/3cmWk8o)（Martin Fowler）'
- en: Which comments in your code ARE GOOD? (Rafał Świdzinski) [https://youtu.be/4t9bpo0THb8](https://youtu.be/4t9bpo0THb8)
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[你的代码中哪些注释是好的？](https://youtu.be/4t9bpo0THb8)（Rafał Świdzinski）'
- en: 'StackOverflow - CMake syntax to set and use variables: [https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables](https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StackOverflow - CMake语法设置和使用变量：[https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables](https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables)
