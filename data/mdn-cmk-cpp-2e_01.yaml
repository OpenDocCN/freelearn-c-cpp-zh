- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: First Steps with CMake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMake 入门
- en: There is something magical about software creation. We’re not only creating
    a working mechanism that gets brought to life but we’re also often authoring the
    very idea behind the functionality of the solution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件创建有一种神奇的魅力。我们不仅仅是在创建一个能够被激活的工作机制，而且我们还常常在构思解决方案功能背后的想法。
- en: 'To cast our ideas into existence, we work in the following loop: design, code,
    and test. We invent changes, we phrase them in a language that the compiler understands,
    and we check whether they work as intended. To create proper, high-quality software
    from our source code, we need to meticulously execute repetitive, error-prone
    tasks: invoking the correct commands, checking the syntax, linking binary files,
    running tests, reporting issues, and more.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的想法付诸实践，我们在以下循环中工作：设计、编码和测试。我们发明变更，用编译器理解的语言表达这些变更，并检查它们是否按预期工作。为了从源代码中创建合适的高质量软件，我们需要仔细执行重复且容易出错的任务：调用正确的命令，检查语法，链接二进制文件，运行测试，报告问题等等。
- en: It takes great effort to remember each step every single time. Instead, we want
    to stay focused on the actual coding and delegate everything else to automated
    tooling. Ideally, this process would start with a single button, right after we
    have changed our code. It would be smart, fast, extensible, and work in the same
    way across different OSs and environments. It would be supported by multiple **Integrated
    Development Environments** (**IDEs**). Going even further, we could streamline
    this process into **Continuous Integration** (**CI**) pipelines that build and
    test our software every time a change is submitted to a shared repository.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每次都记住每个步骤是非常费劲的。相反，我们希望专注于实际编码，并将其他所有工作委托给自动化工具。理想情况下，这个过程应该在我们修改代码后，点击一个按钮就开始。它应该是智能的、快速的、可扩展的，并且在不同操作系统和环境中以相同方式工作。它应该得到多个**集成开发环境**（**IDE**）的支持。进一步地，我们可以将这个过程流畅地整合进**持续集成**（**CI**）流水线，每当提交更改到共享仓库时，自动构建和测试我们的软件。
- en: CMake is the answer to many such needs; however, it requires a bit of work to
    configure and use correctly. CMake isn’t the source of the complexity; that stems
    from the subject that we’re dealing with here. Don’t worry, we will go through
    this whole learning process very methodically. Before you know it, you will become
    a software-building guru.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 是许多此类需求的答案；然而，它需要一些工作来正确配置和使用。CMake 不是复杂性的根源；复杂性来自于我们在这里所处理的主题。别担心，我们会非常有条理地逐步学习这一过程。很快，你就会成为一个软件构建高手。
- en: I know you’re eager to rush off to start writing your own CMake projects, and
    this is exactly what we will be doing for most of this book. But since you’ll
    be creating your projects primarily for users (yourself included), it’s important
    for you to understand their perspective first.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你迫不及待地想开始编写自己的 CMake 项目，而这正是我们在本书的大部分内容中要做的事情。但因为你将主要为用户（包括你自己）创建项目，所以首先理解用户的视角是非常重要的。
- en: 'So, let’s start with just that: becoming a *CMake power user*. We’ll go through
    a few basics: what this tool is, how it works in principle, and how to install
    it. Then, we’ll do a deep dive into the command line and modes of operation. Finally,
    we’ll wrap up with the purposes of different files in a project, and we’ll explain
    how to use CMake without creating projects at all.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从这里开始：成为一个*CMake 高级用户*。我们将了解一些基础知识：这个工具是什么，原理上它如何工作，以及如何安装它。然后，我们将深入探讨命令行和操作模式。最后，我们将总结项目中不同文件的用途，并解释如何在不创建项目的情况下使用
    CMake。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Understanding the basics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基础知识
- en: Installing CMake on different platforms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同平台上安装 CMake
- en: Mastering the command line
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精通命令行
- en: Navigating project files
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航项目文件
- en: Discovering scripts and modules
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现脚本和模块
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch01](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch01).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章中提供的代码文件，地址是 [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch01](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch01)。
- en: 'To build the examples provided in this book, always execute all the recommended
    commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书提供的示例，请始终执行所有推荐的命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Be sure to replace the placeholders `<build tree>` and `<source tree>` with
    the appropriate paths. As you will learn in this chapter, **build tree** is the
    path of your output directory, and **source tree** is the path at which your source
    code is located.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要将占位符`<build tree>`和`<source tree>`替换为适当的路径。正如本章所述，**build tree**是输出目录的路径，而**source
    tree**是源代码所在的路径。
- en: To build C++ programs, you also need a compiler appropriate for your platform.
    If you’re familiar with Docker, you can use a fully tooled image introduced in
    the *Installing CMake on different platforms* section. If you’d rather set up
    CMake manually, we’ll explain the installation in the samesection.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建C++程序，你还需要一个适合你平台的编译器。如果你熟悉Docker，你可以使用在*不同平台上安装CMake*一节中介绍的完全集成的镜像。如果你更倾向于手动设置CMake，我们将在同一节中解释安装过程。
- en: Understanding the basics
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基础知识
- en: The compilation of C++ source code appears to be a fairly straightforward process.
    Let’s start with the classic Hello World example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: C++源代码的编译似乎是一个相当简单的过程。让我们从经典的Hello World示例开始。
- en: 'The following code is found in `ch01/01-hello/hello.cpp`, *Hello world in the
    C++ language*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码位于`ch01/01-hello/hello.cpp`中，*C++语言中的Hello World*：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To produce an executable, we of course need a C++ compiler. CMake doesn’t come
    with one, so you’ll need to pick and install one on your own. Popular choices
    include:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成可执行文件，我们当然需要一个C++编译器。CMake本身不附带编译器，因此你需要自行选择并安装一个。常见的选择包括：
- en: Microsoft Visual C++ compiler
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Visual C++ 编译器
- en: The GNU compiler collection
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU编译器集合
- en: Clang/LLVM
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang/LLVM
- en: Most readers are familiar with *a compiler*, as it is indispensable when learning
    C++, so we won’t go into picking one and installation. Examples in this book will
    use GNU GCC as it is a well-established, open-source software compiler available
    for free across many platforms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数读者都对*编译器*非常熟悉，因为它是学习C++时不可或缺的部分，所以我们不会详细介绍如何选择和安装编译器。本书中的示例将使用GNU GCC，因为它是一个成熟的、开源的、可免费在多个平台上使用的软件编译器。
- en: 'Assuming that we have our compiler already installed, running it is similar
    for most vendors and systems. We should call it with the filename as an argument:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经安装了编译器，对于大多数供应商和系统，运行它的方式类似。我们应该将文件名作为参数传递给它：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our code is correct, so the compiler will silently produce an executable binary
    file that our machine can understand. We can run it by calling its name:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是正确的，因此编译器将默默地生成一个可执行的二进制文件，供我们的机器理解。我们可以通过调用文件名来运行它：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running one command to build your program is simple enough; however, as our
    projects grow, you will quickly understand that keeping everything in a single
    file is simply not possible. Clean code practices recommend that source code files
    should be kept small and in well-organized structures. The manual compilation
    of every file can be a tiresome and fragile process. There must be a better way.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个命令来构建程序很简单；然而，随着项目的增长，你会很快明白，所有东西都保存在一个文件中是不可能的。清洁代码实践建议源代码文件应保持简短，并且结构要井井有条。手动编译每个文件可能是一个乏味且容易出错的过程。一定有更好的方法。
- en: What is CMake?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是CMake？
- en: Let’s say we automate building by writing a script that goes through our project
    tree and compiles everything. To avoid any unnecessary compilations, our script
    will detect whether the source has been modified since the last time we ran the
    script. Now, we’d like a convenient way to manage arguments that are passed to
    the compiler for each file – preferably, we’d like to do that based on configurable
    criteria. Additionally, our script should know how to link all of the compiled
    files into a single binary file or, even better, build whole solutions that can
    be reused and incorporated as modules into bigger projects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们通过编写一个脚本来自动化构建，该脚本遍历我们的项目树并编译所有内容。为了避免不必要的编译，脚本将检测自上次运行以来源代码是否已被修改。现在，我们希望有一种方便的方式来管理每个文件传递给编译器的参数——最好是基于可配置的标准来处理。此外，我们的脚本应当知道如何将所有已编译的文件链接成一个单一的二进制文件，或者更好的是，构建可以重用的完整解决方案，并将其作为模块集成到更大的项目中。
- en: 'Building software is a very versatile process and can span multiple different
    aspects:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件是一个非常多样化的过程，涵盖了多个不同的方面：
- en: Compiling executables and libraries
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译可执行文件和库
- en: Managing dependencies
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理依赖关系
- en: Testing
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Installing
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装
- en: Packaging
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包
- en: Producing documentation
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文档
- en: Testing some more
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再做一些测试
- en: It would take a very long time to come up with a truly modular and powerful
    C++ building utility that is fit for every purpose. And it did. Bill Hoffman at
    Kitware implemented the first versions of CMake over 20 years ago. As you might
    have already guessed, it was very successful. Today, it has a lot of features
    and extensive support from the community. CMake is being actively developed and
    has become the industry standard for C and C++ programmers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个真正模块化且强大的 C++ 构建工具以适应所有需求将需要非常长的时间。事实证明，它做到了。Bill Hoffman 在 Kitware 实现了
    CMake 的第一个版本，已经有 20 多年的历史了。正如你可能已经猜到的，它非常成功。如今，它拥有众多功能并得到了社区的广泛支持。CMake 正在积极开发，并已成为
    C 和 C++ 程序员的行业标准。
- en: 'The problem of building code in an automated way is much older than CMake,
    so naturally, there are plenty of options out there: GNU Make, Autotools, SCons,
    Ninja, Premake, and more. But why does CMake have the upper hand?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化构建代码的问题早于 CMake 的诞生，所以自然，市面上有很多选择：GNU Make、Autotools、SCons、Ninja、Premake
    等。但为什么 CMake 却占据优势呢？
- en: 'There are a couple of things about CMake that I find (granted, subjectively)
    important:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 CMake，有几个我认为（当然是主观的）重要的地方：
- en: It stays focused on supporting modern compilers and toolchains.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它始终专注于支持现代编译器和工具链。
- en: CMake is truly cross-platform – it supports building for Windows, Linux, macOS,
    and Cygwin.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 真正跨平台——它支持为 Windows、Linux、macOS 和 Cygwin 构建项目。
- en: 'It generates project files for popular IDEs: Microsoft Visual Studio, Xcode,
    and Eclipse CDT. Additionally, it is a project model for others, like CLion.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为流行的 IDE 生成项目文件：Microsoft Visual Studio、Xcode 和 Eclipse CDT。此外，它也是其他项目模型的基础，如
    CLion。
- en: CMake operates on just the right level of abstraction – it allows you to group
    files in reusable targets and projects.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 操作在恰当的抽象层次上——它允许你将文件分组到可重用的目标和项目中。
- en: There are tons of projects that are built with CMake and offer an easy way to
    plug them into your project.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有大量的项目是用 CMake 构建的，并提供了一种简便的方式将它们集成到你的项目中。
- en: CMake views testing, packaging, and installing as an inherent part of the build
    process.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 将测试、打包和安装视为构建过程的固有部分。
- en: Old, unused features get deprecated to keep CMake lean.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保持 CMake 的精简，过时的、未使用的功能会被弃用。
- en: CMake provides a unified, streamlined experience across the board. It doesn’t
    matter whether you’re building your software in an IDE or directly from the command
    line; what’s really important is that it takes care of post-build stages as well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了一种统一、简化的体验。无论你是在 IDE 中构建软件，还是直接从命令行构建，真正重要的是它也会处理构建后的阶段。
- en: Your CI/CD pipeline can easily use the same CMake configuration and build projects
    using a single standard even if all of the preceding environments differ.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即使所有前面的环境不同，你的 CI/CD 流水线也可以轻松使用相同的 CMake 配置，并通过单一标准构建项目。
- en: How does it work?
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: You might be under the impression that CMake is a tool that reads source code
    on one end and produces binaries on the other – while that’s true in principle,
    it’s not the full picture.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为 CMake 是一个在一端读取源代码并在另一端生成二进制文件的工具——虽然从原则上讲这是真的，但这并不是完整的画面。
- en: 'CMake can’t build anything on its own – it relies on other tools in the system
    to perform the actual compilation, linking, and other tasks. You can think of
    it as the orchestrator of your building process: it knows what steps need to be
    done, what the end goal is, and how to find the right workers and materials for
    the job.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 本身不能独立构建任何东西——它依赖系统中的其他工具来执行实际的编译、链接和其他任务。你可以把它看作是构建过程的指挥者：它知道需要执行哪些步骤，最终目标是什么，以及如何找到合适的工作者和材料来完成任务。
- en: 'This process has three stages:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程有三个阶段：
- en: Configuration
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Generation
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成
- en: Building
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建
- en: Let’s explore them in some detail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探讨一下这些内容。
- en: The configuration stage
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置阶段
- en: This stage is about reading project details stored in a directory, called the
    **source tree**, and preparing an output directory or **build tree** for the generation
    stage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段是关于读取存储在目录中的项目详情，称为 **源树**，并为生成阶段准备一个输出目录或 **构建树**。
- en: 'CMake starts by checking whether the project was configured before and reads
    cached configuration variables from a `CMakeCache.txt` file. On a first run, this
    is not the case, so it creates an empty build tree and collects all of the details
    about the environment it is working in: for example, what the architecture is,
    what compilers are available, and what linkers and archivers are installed. Additionally,
    it checks whether a simple test program can be compiled correctly.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 首先检查项目是否已配置过，并从 `CMakeCache.txt` 文件中读取缓存的配置变量。在第一次运行时，情况并非如此，因此它会创建一个空的构建树，并收集关于它所处环境的所有细节：例如，架构是什么，哪些编译器可用，已安装了哪些链接器和归档工具。此外，它还会检查是否能正确编译一个简单的测试程序。
- en: Next, the `CMakeLists.txt` project configuration file is parsed and executed
    (yes, CMake projects are configured with CMake’s coding language). This file is
    the bare minimum of a CMake project (source files can be added later). It tells
    CMake about the project structure, its targets, and its dependencies (libraries
    and other CMake packages).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，解析并执行 `CMakeLists.txt` 项目配置文件（是的，CMake 项目是用 CMake 的编程语言配置的）。这个文件是一个 CMake
    项目的最基本形式（源文件可以稍后添加）。它告诉 CMake 项目的结构、目标及其依赖项（库和其他 CMake 包）。
- en: During this process, CMake stores collected information in the build tree, such
    as system details, project configurations, logs, and temp files, which are used
    for the next step. Specifically, a `CMakeCache.txt` file is created to store more
    stable information (such as paths to compilers and other tools), which saves time
    when the whole build sequence is executed again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，CMake 将收集的信息存储在构建树中，例如系统细节、项目配置、日志和临时文件，这些信息将在下一步骤中使用。具体来说，CMake 会创建一个
    `CMakeCache.txt` 文件，用于存储更稳定的信息（例如编译器和其他工具的路径），这样当整个构建过程重新执行时，可以节省时间。
- en: The generation stage
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成阶段
- en: After reading the project configuration, CMake will generate a **buildsystem**
    for the exact environment it is working in. Buildsystems are simply cut-to-size
    configuration files for other build tools (for example, Makefiles for GNU Make
    or Ninja and IDE project files for Visual Studio). During this stage, CMake can
    still apply some final touches to the build configuration by evaluating **generator
    expressions**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取项目配置后，CMake 将为其所处的具体环境生成一个 **构建系统**。构建系统实际上就是为其他构建工具（例如，GNU Make 或 Ninja
    的 Makefile，以及 Visual Studio 的 IDE 项目文件）量身定制的配置文件。在这个阶段，CMake 还可以通过评估 **生成器表达式**
    对构建配置进行一些最后的调整。
- en: The generation stage is executed automatically after the configuration stage.
    For this reason, this book and other resources sometimes refer to both of these
    stages interchangeably when mentioning the “configuration” or “generation” of
    a buildsystem. To explicitly run just the configuration stage, you can use the
    `cmake-gui` utility.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 生成阶段会在配置阶段之后自动执行。因此，本书及其他资源有时在提到“构建系统的配置”或“生成”时会将这两个阶段互换使用。要明确仅运行配置阶段，可以使用 `cmake-gui`
    工具。
- en: The building stage
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建阶段
- en: To produce the final artifacts specified in our project (like executables and
    libraries), CMake has to run the appropriate **build tool**. This can be invoked
    directly, through an IDE, or using the appropriate CMake command. In turn, these
    build tools will execute steps to produce **target artifacts** with compilers,
    linkers, static and dynamic analysis tools, test frameworks, reporting tools,
    and anything else you can think of.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成项目中指定的最终产物（如可执行文件和库），CMake 需要运行适当的 **构建工具**。这可以通过直接调用、通过 IDE 或使用适当的 CMake
    命令来实现。这些构建工具将执行步骤，通过编译器、链接器、静态和动态分析工具、测试框架、报告工具以及你能想到的其他任何工具来生成 **目标产物**。
- en: 'The beauty of this solution lies in the ability to produce buildsystems on
    demand for every platform with a single configuration (that is, the same project
    files):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的优势在于，它能够通过单一配置（即相同的项目文件）按需为每个平台生成构建系统：
- en: '![](img/B19844_01_01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_01_01.png)'
- en: 'Figure 1.1: The stages of CMake'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：CMake 的各个阶段
- en: Do you remember our `hello.cpp` application from the *Understanding the basics*
    section? It is really easy to build it with CMake. All we need is the following
    `CMakeLists.txt` file in the same directory as our source.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在 *理解基础* 部分提到的 `hello.cpp` 应用程序吗？用 CMake 构建它非常简单。我们只需要在与源文件相同的目录中放置以下
    `CMakeLists.txt` 文件。
- en: '**ch01/01-hello/CMakeLists.txt**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch01/01-hello/CMakeLists.txt**'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After creating this file, execute the following commands in the same directory:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建该文件后，在相同目录下执行以下命令：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that `<build tree>` is a placeholder that should be replaced with a path
    to a temporary directory that will hold generated files.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`<build tree>`是一个占位符，应该替换为存放生成文件的临时目录的路径。
- en: 'Here is the output from an Ubuntu system running in Docker (Docker is a virtual
    machine that can run within other systems; we’ll discuss it in the *Installing
    CMake on different platforms* section). The first command generates a **buildsystem**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Docker 中运行的 Ubuntu 系统的输出（Docker 是一种可以在其他系统内运行的虚拟机；我们将在*在不同平台上安装 CMake*一节中讨论它）。第一个命令生成一个**构建系统**：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second command actually **builds** the project:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令实际上是**构建**项目：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All that’s left is to run the compiled program:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是运行已编译的程序：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have generated a buildsystem that is stored in the **build tree** directory.
    Following this, we executed the build stage and produced a final binary that we
    were able to run.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经生成了一个存储在**构建树**目录中的构建系统。接下来，我们执行了构建阶段并生成了一个可以运行的最终二进制文件。
- en: 'Now you know what the result looks like, I’m sure you will be full of questions:
    what are the prerequisites to this process? What do these commands mean? Why do
    we need two of them? How do I write my own project files? Don’t worry – these
    questions will be answered in the following sections.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道结果是什么样子了，我相信你一定有很多问题：这个过程的前提条件是什么？这些命令是什么意思？为什么需要两个命令？我该如何编写自己的项目文件？别担心——这些问题将在接下来的章节中得到解答。
- en: This book will provide you with the most important information that is relevant
    to the current version of CMake (at the time of writing, this is 3.26). To provide
    you with the best advice, I have explicitly avoided any deprecated and no longer
    recommended features and I highly recommend using, at the very least, CMake version
    3.15, which is considered *the modern CMake*. If you require more information,
    you can find the latest, complete documentation online at [https://cmake.org/cmake/help/](https://cmake.org/cmake/help/).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将为您提供与当前版本的 CMake 相关的最重要信息（截至写作时，版本为 3.26）。为了给您提供最佳建议，我特别避免了任何已弃用或不再推荐的功能，并且强烈建议至少使用
    CMake 版本 3.15，这被认为是*现代 CMake*。如果您需要更多信息，可以在[https://cmake.org/cmake/help/](https://cmake.org/cmake/help/)在线查看最新的完整文档。
- en: Installing CMake on different platforms
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同平台上安装 CMake
- en: CMake is a cross-platform, open-source software written in C++. That means you
    can, of course, compile it yourself; however, the most likely scenario is that
    you won’t have to. This is because precompiled binaries are available for you
    to download from the official web page at [https://cmake.org/download/](https://cmake.org/download/).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 是一个跨平台的开源软件，用 C++ 编写。这意味着你当然可以自己编译它；然而，最可能的情况是你不需要这么做。因为可以从官方网站下载预编译的二进制文件，[https://cmake.org/download/](https://cmake.org/download/)。
- en: Unix-based systems provide ready-to-install packages directly from the command
    line.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Unix 的系统提供了可以直接从命令行安装的现成包。
- en: Remember that CMake doesn’t come with compilers. If your system doesn’t have
    them installed yet, you’ll need to provide them before using CMake. Make sure
    to add the paths to their executables to the `PATH` environment variable so that
    CMake can find them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，CMake 并不自带编译器。如果您的系统还没有安装编译器，您需要在使用 CMake 之前先安装它们。确保将编译器的可执行文件路径添加到`PATH`环境变量中，以便
    CMake 能找到它们。
- en: 'To avoid facing tooling and dependency problems while learning from this book,
    I recommend practicing by following the first installation method: Docker. In
    a real-world scenario, you will of course want to use a native version, unless
    you’re working in a virtualized environment to begin with.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在学习本书时遇到工具和依赖问题，我建议通过使用第一种安装方法：Docker 进行实践。在真实的工作场景中，除非你本身就处于虚拟化环境中，否则你当然会选择使用本地版本。
- en: Let’s go through some different environments in which CMake can be used.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 CMake 可以使用的不同环境。
- en: Docker
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker
- en: Docker ([https://www.docker.com/](https://www.docker.com/)) is a cross-platform
    tool that provides OS-level virtualization, allowing applications to be shipped
    in well-defined packages called containers. These are self-sufficient bundles
    that contain a piece of software with all of the libraries, dependencies, and
    tools required to run it. Docker executes its containers in lightweight environments
    that are isolated one from another.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Docker（[https://www.docker.com/](https://www.docker.com/)）是一个跨平台工具，提供操作系统级虚拟化，允许应用程序以称为容器的定义良好的包的形式进行交付。这些自给自足的包包含了运行软件所需的所有库、依赖项和工具。Docker
    在轻量级环境中执行其容器，并且这些环境相互隔离。
- en: This concept makes it extremely convenient to share whole toolchains that are
    necessary for a given process, configured and ready to go. I can’t stress enough
    how easy things become when you don’t need to worry about minuscule environmental
    differences.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念使得共享完整的工具链变得极为方便，这些工具链是某一特定过程所必需的，已经配置好并随时可以使用。当你不需要担心微小的环境差异时，一切变得非常简单，我无法强调这点有多么重要。
- en: The Docker platform has a public repository of container images, [https://registry.hub.docker.com/](https://registry.hub.docker.com/),
    that provides millions of ready-to-use images.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 平台有一个公开的容器镜像仓库，[https://registry.hub.docker.com/](https://registry.hub.docker.com/)，提供数百万个现成的镜像。
- en: 'For your convenience, I have published two Docker repositories:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我已经发布了两个 Docker 仓库：
- en: '`swidzinski/cmake2:base`: An Ubuntu-based image that contains the curated tools
    and dependencies that are necessary to build with CMake'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swidzinski/cmake2:base`：一个基于 Ubuntu 的镜像，包含构建 CMake 所需的工具和依赖项'
- en: '`swidzinski/cmake2:examples`: An image based on the preceding toolchain with
    all of the projects and examples from this book'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swidzinski/cmake2:examples`：基于前述工具链的镜像，包含本书中的所有项目和示例'
- en: The first option is for readers who simply want a clean-slate image ready to
    build their own projects, and the second option is for hands-on practice with
    examples as we go through the chapters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项适用于那些仅仅想要一个干净的镜像，准备构建自己项目的读者，第二个选项适用于在我们通过章节时进行动手实践并使用示例的读者。
- en: 'You can install Docker by following the instructions from its official documentation
    (please refer to [docs.docker.com/get-docker](http://docs.docker.com/get-docker)).
    Then, execute the following commands in your terminal to download the image and
    start the container:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照其官方文档中的说明安装 Docker（请参阅 [docs.docker.com/get-docker](http://docs.docker.com/get-docker)）。然后，在终端中执行以下命令来下载镜像并启动容器：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that examples are available in the directories matching this format:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，示例位于匹配此格式的目录中：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `<N>` and `<M>` are zero-padded chapter and example numbers, respectively
    (like `01`, `08`, and `12`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<N>` 和 `<M>` 分别是零填充的章节和示例编号（如 `01`、`08` 和 `12`）。
- en: Windows
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: 'Installing in Windows is straightforward – simply download the version for
    32 or 64 bits from the official website. You can also pick a portable ZIP or MSI
    package for Windows Installer, which will add the CMake `bin` directory to the
    `PATH` environment variable (*Figure 1.2*) so that you can use it in any directory
    without any such errors:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装非常简单——只需从官方网站下载 32 位或 64 位的版本。你也可以选择便携式 ZIP 或 MSI 包，使用 Windows
    安装程序，它将把 CMake 的 `bin` 目录添加到 `PATH` 环境变量中（*图 1.2*），这样你就可以在任何目录中使用它，而不会出现类似的错误：
- en: '`cmake` is not recognized as an internal or external command, operable program,
    or batch file.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake` 未被识别为内部或外部命令、可操作程序或批处理文件。'
- en: 'If you select the ZIP package, you will have to do it manually. The MSI installer
    comes with a convenient GUI:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择 ZIP 包，你需要手动完成安装。MSI 安装程序带有一个方便的图形用户界面：
- en: '![](img/B19844_01_02.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_01_02.png)'
- en: 'Figure 1.2: The installation wizard can set up the PATH environment variable
    for you'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：安装向导可以为你设置 PATH 环境变量
- en: As I mentioned earlier, this is open-source software, so it is possible to build
    CMake yourself. However, on Windows, you will have to get a binary copy of CMake
    on your system first. This scenario is used by CMake contributors to generate
    newer versions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，这是开源软件，因此你可以自行构建 CMake。然而，在 Windows 上，你首先需要在系统上获取 CMake 的二进制版本。这种情况是
    CMake 贡献者用来生成新版本的方式。
- en: 'The Windows platform is no different from others, and it also requires a build
    tool that can finalize the build process started by CMake. A popular choice here
    is the Visual Studio IDE, which comes bundled with a C++ compiler. The Community
    edition is available for free from Microsoft’s website: [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Windows平台与其他平台没有区别，也需要一个可以完成CMake启动的构建工具。一个流行的选择是Visual Studio IDE，它捆绑了一个C++编译器。社区版可以从Microsoft官网免费下载：[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)。
- en: Linux
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux
- en: 'Installing CMake on Linux follows the same process as with any other popular
    package: call your package manager from the command line. Package repositories
    are usually kept up to date with fairly recent versions of CMake, but usually
    not the latest. If you’re fine with this and using a distribution like Debian
    or Ubuntu, it is simplest to just install the appropriate package:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上安装CMake与其他流行软件包的安装过程相同：从命令行调用包管理器。包仓库通常会保持更新，提供相对较新的CMake版本，但通常不会是最新版本。如果您对此没有异议，并且使用的是Debian或Ubuntu等发行版，那么最简单的做法就是直接安装适当的包：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For a Red Hat distribution, use the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Red Hat发行版，请使用以下命令：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that when installing a package, your package manager will fetch the latest
    available version in the repository configured for your OS. In many cases, package
    repositories don’t provide the latest version but, rather, a stable one that has
    been proven over time to work reliably. Pick according to your needs, but be aware
    that older versions won’t have all the features described in this book.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在安装包时，包管理器将从为您的操作系统配置的仓库中获取最新版本。在许多情况下，包仓库并不提供最新版本，而是提供一个经过时间验证的稳定版本，这些版本通常能够可靠地运行。根据您的需求选择，但请注意，旧版本不会具备本书中描述的所有功能。
- en: To get the latest version, reference the download section of the official CMake
    website. If you know the current version number, you can use one of the following
    commands.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取最新版本，请参考CMake官方网站的下载部分。如果您知道当前版本号，可以使用以下命令之一。
- en: 'The command for Linux x86_64 is:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Linux x86_64的命令是：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The command for Linux AArch64 is:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Linux AArch64的命令是：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Alternatively, check out the *Building from the source* section to learn how
    to compile CMake on your platform yourself.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，查看*从源代码构建*部分，学习如何在您的平台上自行编译CMake。
- en: macOS
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: macOS
- en: 'This platform is also strongly supported by CMake developers. The most popular
    choice of installation is through MacPorts with the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平台也得到了CMake开发者的强力支持。最常见的安装选择是通过MacPorts，使用以下命令：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Do note that at the time of writing, the latest version available in MacPorts
    was 3.24.4\. To get the latest version, install the `cmake-devel` package:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在写作时，MacPorts中提供的最新版本是3.24.4。要获取最新版本，请安装`cmake-devel`包：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, you can use the Homebrew package manager:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用Homebrew包管理器：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: macOS package managers will cover all necessary steps, but be mindful that you
    might not get the latest version unless you’re building from the source.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: macOS的包管理器将涵盖所有必要步骤，但请注意，除非您从源代码构建，否则您可能无法获得最新版本。
- en: Building from the source
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源代码构建
- en: 'If you’re using another platform, or just want to experience the latest builds
    that haven’t been promoted to a release (or adopted by your favorite package repository),
    download the source from the official website and compile it yourself:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是其他平台，或者只是想体验尚未发布的最新版本（或未被您喜欢的包仓库采用），请从官方网站下载源代码并自行编译：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Building from the source is relatively slow and requires more steps. However,
    there is no other way to have the freedom of picking any version of CMake. This
    is especially useful when packages that are available in repositories of your
    operating system are stale: the older the version of the system, the fewer updates
    it gets.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建相对较慢，并且需要更多步骤。然而，只有通过这种方式，您才能自由选择任何版本的CMake。这对于操作系统仓库中提供的包过时的情况尤其有用：系统版本越老，更新的频率越低。
- en: Now that we have installed CMake, let’s learn how to use it!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了CMake，接下来让我们学习如何使用它！
- en: Mastering the command line
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精通命令行
- en: The majority of this book will teach you how to prepare CMake projects for your
    users. To cater to their needs, we need to thoroughly understand how users interact
    with CMake in different scenarios. This will allow you to test your project files
    and ensure they’re working correctly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的大部分内容将教你如何为用户准备 CMake 项目。为了满足用户的需求，我们需要深入了解用户在不同场景下如何与 CMake 进行交互。这样，你可以测试你的项目文件，并确保它们正常工作。
- en: 'CMake is a family of tools and consists of five executables:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 是一套工具，包含五个可执行文件：
- en: '`cmake`: The main executable that configures, generates, and builds projects'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake`：配置、生成和构建项目的主要可执行文件'
- en: '`ctest`: The test driver program used to run and report test results'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctest`：用于运行并报告测试结果的测试驱动程序'
- en: '`cpack`: The packaging program used to generate installers and source packages'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpack`：用于生成安装程序和源代码包的打包程序'
- en: '`cmake-gui`: The graphical wrapper around `cmake`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake-gui`：`cmake` 的图形界面包装器'
- en: '`ccmake`: The console-based GUI wrapper around `cmake`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ccmake`：`cmake` 的基于控制台的 GUI 包装器'
- en: Additionally, Kitware, the company behind CMake, offers a separate tool called
    CDash to provide advanced oversight over the health of our projects’ builds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CMake 的背后公司 Kitware 还提供了一个名为 CDash 的独立工具，用于对我们项目的构建健康状态进行高级监控。
- en: CMake command line
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMake 命令行
- en: 'The `cmake` is the main binary of the CMake suite, and provides a few modes
    of operation (also sometimes called actions):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake` 是 CMake 套件的主要二进制文件，并提供几种操作模式（有时也称为动作）：'
- en: Generating a project buildsystem
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成项目构建系统
- en: Building a project
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建项目
- en: Installing a project
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装项目
- en: Running a script
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Running a command-line tool
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行命令行工具
- en: Running a workflow preset
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行工作流预设
- en: Getting help
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取帮助
- en: Let’s see how they work.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们是如何工作的。
- en: Generating a project buildsystem
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成项目构建系统
- en: 'The first step required to build our project is to generate a buildsystem.
    Here are three forms of command to execute the CMake *generating a project buildsystem*
    action:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 构建我们项目所需的第一步是生成构建系统。以下是三种执行 CMake *生成项目构建系统* 操作的命令形式：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ll discuss available `<options>` in the upcoming sections. Right now, let’s
    focus on choosing the right form of the command. One important feature of CMake
    is the support for *out-of-source builds* or the support for storing *build artifacts*
    in a directory different from the source tree. This is a preferred approach to
    keep the source directory clean from any build-related files and avoid polluting
    the **Version Control Systems** (**VCSs**) with accidental files or ignore directives.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论可用的 `<options>`。现在，让我们专注于选择正确的命令形式。CMake 的一个重要特点是支持 *源代码外构建* 或支持将
    *构建产物* 存储在与源代码树不同的目录中。这是一种推荐的做法，可以保持源代码目录的干净，避免将意外的文件或忽略指令污染 **版本控制系统**（**VCSs**）。
- en: 'This is why the first form of command is the most practical. It allows us to
    specify the paths to the source tree and the produced buildsystem specified with
    `-S` and `-B`, respectively:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么第一种命令形式是最实用的原因。它允许我们分别使用 `-S` 和 `-B` 来指定源代码树的路径和生成的构建系统路径：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: CMake will read the project files from the `./project` directory and generate
    a buildsystem in the `./build` directory (creating it beforehand if needed).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 将从 `./project` 目录读取项目文件，并在 `./build` 目录中生成构建系统（如有需要，事先创建该目录）。
- en: We can skip one of the arguments and `cmake` will “guess” that we intended to
    use the current directory for it. Note that skipping both will produce an *in-source
    build* and store the *build artifacts* along with source files, which we don’t
    want.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以省略一个参数，`cmake` 会“猜测”我们打算使用当前目录。注意，省略两个参数将产生 *源代码内构建*，并将 *构建产物* 与源代码文件一起存储，这是我们不希望发生的。
- en: '**BE EXPLICIT WHEN RUNNING CMAKE**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行 CMAKE 时要明确**'
- en: Do not use the second or third form of the `cmake <directory>` command, because
    they can produce a messy *in-source build*. In *Chapter 4*, *Setting Up Your First
    CMake Project*, we’ll learn how to prevent users from doing that.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `cmake <directory>` 命令的第二种或第三种形式，因为它们可能会产生一个杂乱的 *源代码内构建*。在 *第4章*，*设置你的第一个
    CMake 项目* 中，我们将学习如何防止用户这样做。
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Examples
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: 'Generate the build tree in the current directory using the source from one
    directory up:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一级目录中的源代码在当前目录中生成构建树：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Generate the build tree in the `./build` directory using the source from the
    current directory:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前目录中的源代码在 `./build` 目录中生成构建树：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Choosing a generator
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择生成器
- en: As discussed earlier, you can specify a few options during the generation stage.
    Selecting and configuring a generator decides which build tool from our system
    will be used for building in the subsequent *Building a project* section, what
    build files will look like, and what the structure of the build tree will be.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在生成阶段，你可以指定一些选项。选择和配置生成器决定了在后续的*构建项目*部分中，系统将使用哪个构建工具，构建文件的样子，以及构建树的结构。
- en: 'So, should you care? Luckily, the answer is often “no.” CMake does support
    multiple native buildsystems on many platforms; however, unless you have installed
    a few generators at the same time, CMake will correctly select one for you. This
    can be overridden by the `CMAKE_GENERATOR` environment variable or by specifying
    the generator directly on the command line, like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该在意吗？幸运的是，答案通常是“否”。CMake确实支持多个本地构建系统在许多平台上的使用；然而，除非你同时安装了几个生成器，否则CMake会为你正确地选择一个。这个选择可以通过`CMAKE_GENERATOR`环境变量或直接在命令行中指定生成器来覆盖，例如：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Some generators (such as Visual Studio) support a more in-depth specification
    of a toolset (compiler) and platform (compiler or SDK). Additionally, CMake will
    scan environment variables that override the defaults: `CMAKE_GENERATOR_TOOLSET`
    and `CMAKE_GENERATOR_PLATFORM`. Alternatively, the values can be specified directly
    in the command line:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成器（例如Visual Studio）支持对工具集（编译器）和平台（编译器或SDK）进行更深入的指定。此外，CMake会扫描那些覆盖默认值的环境变量：`CMAKE_GENERATOR_TOOLSET`和`CMAKE_GENERATOR_PLATFORM`。另外，这些值也可以在命令行中直接指定：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Windows users usually want to generate a buildsystem for their preferred IDE.
    On Linux and macOS, it’s very common to use the **Unix Makefiles** or **Ninja**
    generators.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户通常希望为他们喜欢的IDE生成构建系统。在Linux和macOS上，使用**Unix Makefiles**或**Ninja**生成器非常常见。
- en: 'To check which generators are available on your system, use the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的系统上可用的生成器，请使用以下命令：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At the end of the `help` printout, you will get a full list of generators,
    like this one produced on Windows 10 (some output was truncated for readability):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`help`输出的末尾，你将得到一个完整的生成器列表，例如在Windows 10上生成的列表（部分输出已被截断以提高可读性）：
- en: 'The following generators are available on this platform:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此平台上可用的生成器如下：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, CMake supports a lot of different generator flavors and IDEs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，CMake支持许多不同的生成器和IDE。
- en: Managing the project cache
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管理项目缓存
- en: CMake queries the system for all kinds of information during the configuration
    stage. Because these operations can take a bit of time, the collected information
    is cached in the `CMakeCache.txt` file in the build tree directory. There are
    a few command-line options that allow you to manage the behavior of the cache
    more conveniently.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: CMake在配置阶段会查询系统的各种信息。由于这些操作可能需要一些时间，因此收集到的信息会缓存到构建树目录中的`CMakeCache.txt`文件中。有一些命令行选项可以更方便地管理缓存的行为。
- en: 'The first option at our disposal is the ability to *prepopulate cached information*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的第一个选项是能够*预填充缓存信息*：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can provide a path to the CMake listfile, which (only) contains a list of
    `set()` commands to specify variables that will be used to initialize an empty
    build tree. We’ll discuss writing the listfiles in the next chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一个CMake列表文件的路径，该文件（仅）包含一个`set()`命令列表，用于指定将用于初始化一个空构建树的变量。我们将在下一章讨论编写列表文件。
- en: 'The *initialization and modification* of existing cache variables can be done
    in another way (for instance, when creating a file is a bit much to only set a
    few variables). You can set them directly in a command line, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*初始化和修改*现有的缓存变量可以通过另一种方式进行（例如，当创建一个文件仅仅是为了设置几个变量时，可能有些过于繁琐）。你可以在命令行中直接设置它们，如下所示：'
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `:<type>` section is optional (it is used by GUIs) and it accepts the following
    types: `BOOL`, `FILEPATH`, `PATH`, `STRING` or `INTERNAL`. If you omit the type,
    CMake will check if the variable exists in the `CMakeCache.txt` file and use its
    type; otherwise, it will be set to `UNINITIALIZED`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`:<type>`部分是可选的（它由GUI使用），并接受以下类型：`BOOL`、`FILEPATH`、`PATH`、`STRING`或`INTERNAL`。如果你省略类型，CMake会检查变量是否存在于`CMakeCache.txt`文件中并使用其类型；否则，它将被设置为`UNINITIALIZED`。'
- en: One particularly important variable that we’ll often set through the command
    line specifies the **build type** (`CMAKE_BUILD_TYPE`). Most CMake projects will
    use it on numerous occasions to decide things such as the verbosity of diagnostic
    messages, the presence of debugging information, and the level of optimization
    for created artifacts.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别重要的变量是我们通常通过命令行设置的，它指定了**构建类型**（`CMAKE_BUILD_TYPE`）。大多数CMake项目将在多个场合使用它来决定诊断信息的详细程度、调试信息的存在与否，以及创建的工件的优化级别。
- en: For single-configuration generators (such as GNU Make and Ninja), you should
    specify the **build type** during the configuration phase and generate a separate
    build tree for each type of config. Values used here are `Debug`, `Release`, `MinSizeRel`,
    or `RelWithDebInfo`. Missing this information may have undefined effects on projects
    that rely on it for configuration.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单配置生成器（如GNU Make和Ninja），你应该在配置阶段指定**构建类型**，并为每种配置类型生成一个单独的构建树。这里使用的值有`Debug`、`Release`、`MinSizeRel`或`RelWithDebInfo`。如果缺少此信息，可能会对依赖它进行配置的项目产生未定义的影响。
- en: 'Here’s an example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that multi-configuration generators are configured during the build stage.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，多配置生成器是在构建阶段配置的。
- en: 'For diagnostic purposes, we can also `list cache` variables with the `-L` option:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 出于诊断目的，我们还可以使用`-L`选项列出缓存变量：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Sometimes, project authors may provide insightful help messages with variables
    – to print them, add the `H` modifier:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，项目作者可能会提供有用的帮助信息与变量一起显示——要打印它们，请添加`H`修饰符：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Surprisingly, custom variables that are added manually with the `-D` option
    won’t be visible in this printout unless you specify one of the supported types.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，手动使用`-D`选项添加的自定义变量，除非你指定支持的类型之一，否则在此打印输出中不可见。
- en: 'The *removal* of one or more variables can be done with the following option:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下选项来*移除*一个或多个变量：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the *globbing expression* supports the `*` (wildcard) and `?` (any character)
    symbols. Be careful when using these, as it is easy to erase more variables than
    intended.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*通配符表达式*支持`*`（通配符）和`?`（任意字符）符号。使用这些符号时要小心，因为很容易删除比预期更多的变量。
- en: Both the `-U` and `-D` options can be repeated multiple times.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`-U`和`-D`选项可以重复使用多次。'
- en: Debugging and tracing
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试和追踪
- en: 'The `cmake` command can be run with a multitude of options that allow you to
    peek under the hood. To get general information about variables, commands, macros,
    and other settings, run the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake`命令可以使用多种选项来让你查看内部信息。要获取关于变量、命令、宏和其他设置的一般信息，可以运行以下命令：'
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The optional file argument allows you to store the output in a file. Running
    it in the **build tree** directory will print additional information about the
    cache variables and build messages from the log files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的文件参数允许你将输出存储到文件中。在**构建树**目录中运行它将打印关于缓存变量和日志文件中构建信息的额外内容。
- en: 'In our projects, we’ll be using `message()` commands to report details of the
    build process. CMake filters the log output of these based on the current log
    level (by default, this is `STATUS`). The following line specifies the log level
    that we’re interested in:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将使用`message()`命令来报告构建过程的详细信息。CMake根据当前的日志级别（默认情况下为`STATUS`）筛选这些日志输出。以下行指定了我们感兴趣的日志级别：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, `level` can be any of the following: `ERROR`, `WARNING`, `NOTICE`, `STATUS`,
    `VERBOSE`, `DEBUG`, or `TRACE`. You can specify this setting permanently in the
    `CMAKE_MESSAGE_LOG_LEVEL` cache variable.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`level`可以是以下任意之一：`ERROR`、`WARNING`、`NOTICE`、`STATUS`、`VERBOSE`、`DEBUG`或`TRACE`。你可以在`CMAKE_MESSAGE_LOG_LEVEL`缓存变量中永久指定此设置。
- en: 'Another interesting option allows you to *display log context* with each `message()`
    call. To debug very complex projects, the `CMAKE_MESSAGE_CONTEXT` variable can
    be used like a stack. Whenever your code enters an interesting context, you can
    name it descriptively. By doing this, our messages will be decorated with the
    current `CMAKE_MESSAGE_CONTEXT` variable, like so:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的选项允许你在每次调用`message()`时*显示日志上下文*。为了调试非常复杂的项目，可以像使用堆栈一样使用`CMAKE_MESSAGE_CONTEXT`变量。每当你的代码进入一个有趣的上下文时，你可以为它起个描述性的名字。通过这种方式，我们的消息将附带当前的`CMAKE_MESSAGE_CONTEXT`变量，如下所示：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The option to enable this kind of log output is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此类日志输出的选项如下：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We’ll discuss naming contexts and logging commands in more detail in *Chapter
    2*, *The CMake Language*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第2章*，《CMake语言》中更详细地讨论命名上下文和日志命令。
- en: 'If all else fails and we need to use the big guns, there is always *trace mode*,
    which will print every executed command with its filename, the line number it
    is called from, and a list of passed arguments. You can enable it as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他方法都失败了，我们需要使用“重磅武器”，那么总有*追踪模式*，它会打印出每个执行的命令，包含文件名、调用所在的行号以及传递的参数列表。你可以通过以下方式启用它：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can imagine, it’s not recommended for everyday use, as the output is
    very long.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，它不推荐用于日常使用，因为输出内容非常长。
- en: Configuring presets
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置预设
- en: There are many, many options that users can specify to generate a **build tree**
    from your project. When dealing with the build tree path, generator, cache, and
    environmental variable, it’s easy to get confused or miss something. Developers
    can simplify how users interact with their projects and provide a `CMakePresets.json`
    file that specifies some defaults.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以指定许多选项来生成项目的**构建树**。在处理构建树路径、生成器、缓存和环境变量时，很容易感到困惑或遗漏某些内容。开发者可以简化用户与项目的交互，并提供一个
    `CMakePresets.json` 文件，指定一些默认设置。
- en: 'To list all of the available presets, execute the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有可用的预设，执行以下命令：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can use one of the available presets as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下提供的预设之一：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To learn more, please refer to the *Navigating the project files* section of
    this chapter and *Chapter 16,* *Writing CMake Presets*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多，请参阅本章的*导航项目文件*部分和*第16章*，*编写 CMake 预设*。
- en: Cleaning the build tree
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理构建树
- en: 'Every now and then, we might need to erase generated files. This may be due
    to some changes in the environment that were made between builds, or just to ensure
    that we are working on a clean slate. We can go ahead and delete the build tree
    directory manually, or just add the `--fresh` parameter to the command line:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要删除生成的文件。这可能是由于构建之间环境发生了变化，或者仅仅是为了确保我们在干净的状态下工作。我们可以手动删除构建树目录，或者仅将 `--fresh`
    参数添加到命令行中：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: CMake will then erase `CMakeCache.txt` and `CMakeFiles/` in a system-agnostic
    way and generate the buildsystem from scratch.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 然后会以系统无关的方式删除 `CMakeCache.txt` 和 `CMakeFiles/`，并从头开始生成构建系统。
- en: Building a project
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个项目
- en: After generating our build tree, we’re ready for the *building a project* action.
    Not only does CMake know how to generate input files for many different builders
    but it can also run them for us providing appropriate arguments, as required by
    our project.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成构建树后，我们可以开始*构建项目*。CMake 不仅知道如何为许多不同的构建器生成输入文件，还可以根据项目的需求为它们运行，并提供适当的参数。
- en: '**AVOID CALLING MAKE DIRECTLY**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免直接调用 MAKE**'
- en: Many online sources recommend running GNU Make directly after the generation
    stage by calling the `make` command directly. Because GNU Make is a default generator
    for Linux and macOS, this recommendation can work. However, use the method described
    in this section instead, as it is generator-independent and is officially supported
    across all platforms. As a result, you won’t need to worry about the exact environment
    of every user of your application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在线资源推荐在生成阶段之后直接通过调用 `make` 命令来运行 GNU Make。因为 GNU Make 是 Linux 和 macOS 的默认生成器，所以这个建议是有效的。然而，建议使用本节中描述的方法，因为它与生成器无关，并且在所有平台上都得到官方支持。因此，你不需要担心每个应用程序用户的确切环境。
- en: 'The syntax of build mode is:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模式的语法是：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the majority of cases, it is enough to simply provide the bare minimum to
    get a successful build:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，只需要提供最低限度的设置即可成功构建：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The only required argument is the path to the generated *build tree*. This is
    the same path that was passed with the `-B` argument in the generation stage.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一必需的参数是生成的*构建树*的路径。这与在生成阶段通过 `-B` 参数传递的路径相同。
- en: 'CMake allows you to specify key build parameters that work for every builder.
    If you need to provide special arguments to your chosen native builder, pass them
    at the end of the command after the `--` token:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 允许你指定适用于所有构建器的关键构建参数。如果你需要向所选的本地构建器传递特殊参数，可以将它们添加到命令末尾，在 `--` 标记之后：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let’s see what other options are available.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看还有哪些其他选项可用。
- en: Running parallel builds
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行并行构建
- en: By default, many build tools will use multiple concurrent processes to leverage
    modern processors and compile your sources in parallel. Builders know the structure
    of project dependencies, so they can simultaneously process steps that have their
    dependencies met to save users’ time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，许多构建工具会使用多个并发进程来利用现代处理器并并行编译源代码。构建工具了解项目依赖关系的结构，因此它们可以同时处理满足依赖关系的步骤，从而节省用户时间。
- en: You might want to override that setting if you’d like to build faster on a multi-core
    machine (or to force a single-threaded build for debugging).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在多核机器上更快地构建（或为了调试强制进行单线程构建），你可能想要覆盖该设置。
- en: 'Simply specify the number of jobs with either of the following options:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 只需通过以下任一选项指定作业的数量：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The alternative is to set it with the `CMAKE_BUILD_PARALLEL_LEVEL` environment
    variable. The command-line option will override this variable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过`CMAKE_BUILD_PARALLEL_LEVEL`环境变量进行设置。命令行选项将覆盖这个变量。
- en: Selecting targets to build and clean
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择构建和清理的目标
- en: 'Every project is made up of one or more parts, called **targets** (we’ll discuss
    these in the second part of the book). Usually, we’ll want to build all available
    targets; however, on occasion, we might be interested in skipping some or explicitly
    building a target that was deliberately excluded from normal builds. We can do
    this as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目由一个或多个部分组成，这些部分被称为**目标**（我们将在本书的第二部分讨论这些）。通常，我们希望构建所有可用的目标；然而，有时我们可能希望跳过某些目标，或者明确构建一个故意排除在正常构建之外的目标。我们可以通过以下方式做到这一点：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can specify multiple targets to build by repeating the `–target` argument.
    Also, there’s a shorthand version, `-t <target>`, that can be used instead.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重复使用`–target`参数来指定多个构建目标。此外，还有一个简写版本`-t <target>`，可以用来代替。
- en: Cleaning the build tree
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理构建树
- en: 'One special target that isn’t normally built is called `clean`. Building it
    has the special effect of removing all artifacts from the build directory, so
    everything can be created from scratch later. You can start this process like
    this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊的目标是`clean`，通常不会被构建。构建它的特殊效果是从构建目录中删除所有产物，这样以后可以重新从头开始创建。你可以通过以下方式开始这个过程：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Additionally, CMake offers a convenient alias if you’d like to clean first
    and then implement a normal build:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望先清理然后再执行正常构建，CMake还提供了一个便捷的别名：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This action is different from cleaning mentioned in the *Cleaning the build
    tree* section, as it only affects target artifacts and nothing else (like the
    cache).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作与*清理构建树*部分中提到的清理不同，它只影响目标产物，而不会影响其他内容（如缓存）。
- en: Configuring the build type for multi-configuration generators
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为多配置生成器配置构建类型
- en: 'So, we already know a bit about generators: they come in different shapes and
    sizes. Some of them offer the ability to build both `Debug` and `Release` build
    types in a single build tree. Generators that support this feature include Ninja
    Multi-Config, Xcode, and Visual Studio. Every other generator is a single-configuration
    generator, and they require a separate build tree for every config type we want
    to build.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经了解了一些关于生成器的信息：它们有不同的形状和大小。其中一些生成器支持在一个构建树中构建`Debug`和`Release`这两种构建类型。支持这一功能的生成器包括Ninja
    Multi-Config、Xcode和Visual Studio。其他生成器都是单配置生成器，它们需要为每个想要构建的配置类型提供单独的构建树。
- en: 'Select `Debug`, `Release`, `MinSizeRel`, or `RelWithDebInfo` and specify it
    as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`Debug`、`Release`、`MinSizeRel`或`RelWithDebInfo`并按以下方式指定：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Otherwise, CMake will use `Debug` as the default.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，CMake将使用`Debug`作为默认设置。
- en: Debugging the build process
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试构建过程
- en: 'When things go bad, the first thing we should do is check the output messages.
    However, veteran developers know that printing all the details all the time is
    confusing, so they often hide them by default. When we need to peek under the
    hood, we can ask for far more detailed logs by telling CMake to be verbose:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时，我们首先应该检查输出信息。然而，经验丰富的开发者知道，始终打印所有细节会让人困惑，所以它们通常默认隐藏这些信息。当我们需要深入查看时，可以通过告诉CMake启用详细模式来获得更详细的日志：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The same effect can be achieved by setting the `CMAKE_VERBOSE_MAKEFILE` cached
    variable.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的效果可以通过设置`CMAKE_VERBOSE_MAKEFILE`缓存变量来实现。
- en: Installing a project
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装项目
- en: When artifacts are built, users can install them on the system. Usually, this
    means copying files into the correct directories, installing libraries, or running
    some custom installation logic from a CMake script.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建产物生成后，用户可以将它们安装到系统中。通常，这意味着将文件复制到正确的目录，安装库，或执行某些来自CMake脚本的自定义安装逻辑。
- en: 'The syntax of installation mode is:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 安装模式的语法是：
- en: '[PRE51]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As with other modes of operation, CMake requires a path to a generated build
    tree:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他操作模式一样，CMake 需要一个生成的构建树的路径：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The install action also has plenty of additional options. Let’s see what they
    can do.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 安装操作还有很多其他附加选项。让我们看看它们能做些什么。
- en: Choosing the installation directory
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择安装目录
- en: We can prepend the installation path with a prefix of our choice (for example,
    when we have limited write access to some directories). The `/usr/local` path
    that is prefixed with `/home/user` becomes `/home/user/usr/local`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加我们选择的前缀来预先添加安装路径（例如，当我们对某些目录的写入权限有限时）。以`/home/user`为前缀的`/usr/local`路径变成`/home/user/usr/local`。
- en: 'The signature for this option is as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项的签名如下：
- en: '[PRE53]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you use CMake 3.21 or older, you’ll have to use a less explicit option:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 CMake 3.21 或更早版本，你将需要使用一个不太明确的选项：
- en: '[PRE54]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that this won’t work on Windows, as paths on this platform usually start
    with the drive letter.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这在 Windows 上无法使用，因为该平台上的路径通常以驱动器字母开头。
- en: Installation for multi-configuration generators
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 针对多配置生成器的安装
- en: 'Just like in the build stage, we can specify which build type we want to use
    for our installation (for more details, please refer to the *Building a project*
    section). The available types include `Debug`, `Release`, `MinSizeRel`, and `RelWithDebInfo`.
    The signature is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在构建阶段一样，我们可以指定要用于安装的构建类型（更多细节请参见*构建项目*部分）。可用的类型包括`Debug`、`Release`、`MinSizeRel`和`RelWithDebInfo`。其签名如下：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Selecting components to install
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择要安装的组件
- en: As a developer, you might choose to split your project into components that
    can be installed independently. We’ll discuss the concept of components in further
    detail in *Chapter 14*, *Installing and Packaging*. For now, let’s just assume
    they represent sets of artifacts that don’t need to be used in every case. This
    might be something like `application`, `docs`, and `extra-tools`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，你可能选择将项目拆分为可以独立安装的组件。我们将在*第14章* *安装和打包*中进一步讨论组件的概念。现在，我们假设它们表示一些不需要在每种情况下都使用的工件集。这可能是像`application`、`docs`和`extra-tools`之类的东西。
- en: 'To install a single component, use the following option:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装单个组件，使用以下选项：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Setting file permissions
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置文件权限
- en: 'If the installation is performed on a Unix-like platform, you can specify default
    permissions for the installed directories with the following option, using the
    format of `u=rwx,g=rx,o=rx`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装是在类似 Unix 的平台上进行的，你可以使用以下选项指定已安装目录的默认权限，格式为`u=rwx,g=rx,o=rx`：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Debugging the installation process
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试安装过程
- en: 'Similarly to the build stage, we can also choose to view a detailed output
    of the installation stage. To do this, use any of the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于构建阶段，我们还可以选择查看安装阶段的详细输出。为此，请使用以下任一方法：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The same effect can be achieved if the `VERBOSE` environment variable is set.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`VERBOSE`环境变量，也可以实现相同的效果。
- en: Running a script
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'CMake projects are configured using CMake’s custom language. It’s cross-platform
    and quite powerful. Since it’s already there, why not make it available for other
    tasks? Sure enough, CMake can run standalone scripts (more on that in the *Discovering
    scripts and modules* section), like so:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 项目使用 CMake 自定义语言进行配置。它是跨平台的，且非常强大。既然它已经存在，为什么不让它用于其他任务呢？果然，CMake 可以运行独立的脚本（更多内容请参见*发现脚本和模块*部分），如下所示：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Running such a script won’t run any *configuration* or *generate* stages, and
    it won’t affect the cache.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这样的脚本不会执行任何*配置*或*生成*阶段，也不会影响缓存。
- en: 'There are two ways you can pass values to this script:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式将值传递给此脚本：
- en: Through variables defined with the `-D` option
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`-D`选项定义的变量
- en: Through arguments that can be passed after a `--` token
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过可以在`--`标记后传递的参数
- en: CMake will create `CMAKE_ARGV<n>` variables for all arguments passed to the
    script with the latter (including the `--` token).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 将为所有传递给脚本的参数（包括`--`标记）创建`CMAKE_ARGV<n>`变量。
- en: Running a command-line tool
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行命令行工具
- en: On rare occasions, we might need to run a single command in a platform-independent
    way – perhaps copy a file or compute a checksum. Not all platforms were created
    equal, so not all commands are available in every system (or they have been named
    differently).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下，我们可能需要以平台无关的方式运行单个命令——比如复制文件或计算校验和。并非所有平台都是一样的，因此并非每个系统都提供所有命令（或者它们的名称不同）。
- en: 'CMake offers a mode in which most common commands can be executed in the same
    way across platforms. Its syntax is:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了一种模式，在这种模式下，大多数常见命令可以跨平台以相同的方式执行。其语法如下：
- en: '[PRE60]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As the use of this particular mode is fairly limited, we won’t cover it in
    depth. However, if you’re interested in the details, I recommend calling `cmake
    -E` to list all the available commands. To simply get a glimpse of what’s on offer,
    CMake 3.26 supports the following commands: `capabilities`, `cat`, `chdir`, `compare_files`,
    `copy`, `copy_directory`, `copy_directory_if_different`, `copy_if_different`,
    `echo`, `echo_append`, `env`, `environment`, `make_directory`, `md5sum`, `sha1sum`,
    `sha224sum`, `sha256sum`, `sha384sum`, `sha512sum`, `remove`, `remove_directory`,
    `rename`, `rm`, `sleep`, `tar`, `time`, `touch`, `touch_nocreate`, `create_symlink`,
    `create_hardlink`, `true`, and `false`.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种模式的使用比较有限，我们不会深入讨论它。不过，如果你对细节感兴趣，我建议运行 `cmake -E` 来列出所有可用命令。为了简单了解可用命令，CMake
    3.26 支持以下命令：`capabilities`，`cat`，`chdir`，`compare_files`，`copy`，`copy_directory`，`copy_directory_if_different`，`copy_if_different`，`echo`，`echo_append`，`env`，`environment`，`make_directory`，`md5sum`，`sha1sum`，`sha224sum`，`sha256sum`，`sha384sum`，`sha512sum`，`remove`，`remove_directory`，`rename`，`rm`，`sleep`，`tar`，`time`，`touch`，`touch_nocreate`，`create_symlink`，`create_hardlink`，`true`
    和 `false`。
- en: If a command you’d like to use is missing or you need a more complex behavior,
    consider wrapping it in a script and running it in `-P` mode.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用的命令缺失，或者你需要更复杂的行为，可以考虑将其包装在脚本中并以 `-P` 模式运行。
- en: Running a workflow preset
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行预设工作流
- en: 'We mentioned in the *How does it work?* section that building with CMake has
    three stages: configure, generate, and build. Additionally, we can also run automated
    tests and even create redistributable packages with CMake. Usually, users need
    to manually execute every such step separately by calling the appropriate `cmake`
    action through the command line. However, advanced projects can specify **workflow
    presets** that bundle multiple steps into a single action that can be executed
    with just one command. For now, we’ll only mention that users can get the list
    of available presets by running:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *它是如何工作的？* 部分中提到，使用 CMake 构建有三个阶段：配置、生成和构建。此外，我们还可以通过 CMake 运行自动化测试，甚至创建可重新分发的包。通常，用户需要通过命令行手动执行每个步骤，通过调用适当的
    `cmake` 操作。然而，高级项目可以指定 **工作流预设**，将多个步骤捆绑为一个操作，只需一个命令就能执行。现在，我们只提到，用户可以通过运行以下命令来获取可用预设的列表：
- en: '[PRE61]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'They can execute a workflow preset with:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以通过以下方式执行预设的工作流：
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will be explained in depth in *Chapter 16*,*Writing CMake Presets*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将在 *第 16 章*，*编写 CMake 预设* 中深入讲解。
- en: Getting help
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取帮助
- en: 'It isn’t a surprise that CMake offers extensive help that is accessible through
    its command line. The syntax of help mode is:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 不足为奇的是，CMake 提供了大量的帮助，可以通过其命令行访问。帮助模式的语法如下：
- en: '[PRE63]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This will print the list of the possible topics to dive deeper into and explain
    which parameters need to be added to the command to get more help.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出可供深入探索的主题列表，并解释需要添加哪些参数才能获得更多帮助。
- en: CTest command line
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CTest 命令行
- en: 'Automated testing is very important in order to produce and maintain high-quality
    code. The CMake suite comes with a dedicated command-line tool for this purpose
    called CTest. It is provided to standardize the way tests are run and reported.
    As a CMake user, you don’t need to know the details of testing this particular
    project: what framework is used or how to run it. CTest provides a convenient
    interface to list, filter, shuffle, retry, and timebox test runs.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试对于生成和维护高质量代码非常重要。CMake 套件带有一个专门的命令行工具，名为 CTest，专门用于此目的。它旨在标准化测试的运行和报告方式。作为
    CMake 用户，你不需要了解测试这个特定项目的细节：使用了什么框架或如何运行它。CTest 提供了一个便捷的界面，可以列出、筛选、打乱、重试和时间限制测试运行。
- en: 'To run tests for a built project, we just need to call `ctest` in the generated
    build tree:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行已构建项目的测试，我们只需在生成的构建树中调用 `ctest`：
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We devoted an entire chapter to this subject: *Chapter 11*, *Testing Frameworks*.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此专门编写了整整一章内容：*第 11 章*，*测试框架*。
- en: CPack command line
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPack 命令行
- en: After we have built and tested our amazing software, we are ready to share it
    with the world. The rare few power users are completely fine with the source code.
    However, the vast majority of the world uses precompiled binaries for convenience
    and time-saving reasons.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建并测试完我们惊人的软件后，我们准备与世界分享它。少数强力用户完全可以使用源代码。然而，绝大多数人为了方便和节省时间，选择使用预编译的二进制文件。
- en: 'CMake doesn’t leave you stranded here; it comes with batteries included. CPack
    is a tool that will create redistributable packages for various platforms: compressed
    archives, executable installers, wizards, NuGet packages, macOS bundles, DMG packages,
    RPMs, and more.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 并不会让你陷入困境，它是自带电池的。CPack 是一个工具，用于为各种平台创建可重新分发的包：压缩归档、可执行安装程序、向导、NuGet 包、macOS
    包、DMG 包、RPM 等。
- en: 'CPack works in a very similar way to CMake: it is configured with the CMake
    language and has many *package generators* to pick from (not to be confused with
    CMake buildsystem generators). We’ll go through all the details in *Chapter 14*,
    *Installing and Packaging*, as this tool is meant to be used by mature CMake projects.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: CPack 的工作方式与 CMake 非常相似：它使用 CMake 语言进行配置，并且有许多 *包生成器* 可供选择（不要与 CMake 构建系统生成器混淆）。我们将在
    *第 14 章*《安装与打包》中详细介绍它，因为这个工具是为成熟的 CMake 项目使用的。
- en: CMake GUI
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMake GUI
- en: CMake for Windows comes with a GUI version to configure the building process
    of previously prepared projects. For Unix-like platforms, there is a version built
    with Qt libraries. Ubuntu provides it in the `cmake-qt-gui` package.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: CMake for Windows 带有一个 GUI 版本，用于配置之前准备好的项目的构建过程。对于类 Unix 平台，它有一个使用 Qt 库构建的版本。Ubuntu
    在 `cmake-qt-gui` 包中提供了它。
- en: 'To access the CMake GUI, run the `cmake-gui` executable:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 CMake GUI，请运行 `cmake-gui` 可执行文件：
- en: '![](img/B19844_01_03.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_01_03.png)'
- en: 'Figure 1.3: The CMake GUI – the configuring stage for a buildsystem using a
    generator for Visual Studio 2019'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：CMake GUI——使用 Visual Studio 2019 生成器的构建系统的配置阶段
- en: 'The GUI application is a convenience for users of your application: it can
    be useful for those who aren’t familiar with the command line and would prefer
    a graphical interface.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 应用程序是为你的应用程序用户提供的便利：对于那些不熟悉命令行并且更喜欢图形界面的用户来说，它非常有用。
- en: '**USE COMMAND-LINE TOOLS INSTEAD**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用命令行工具代替**'
- en: I would definitely recommend the GUI to end users, but for programmers like
    you, I suggest avoiding any manual blocking steps that require clicking on forms
    every time you build your programs. This is especially advantageous in mature
    projects, where entire builds can be fully executed without any user interaction.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我绝对推荐终端用户使用 GUI，但对于像你这样的程序员，我建议避免任何手动阻塞步骤，因为每次构建程序时都需要点击表单。这在成熟的项目中尤其有利，其中整个构建过程可以在没有任何用户交互的情况下完全执行。
- en: CCMake command line
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CCMake 命令行
- en: The `ccmake` executable is an interactive text user interface for CMake on Unix-like
    platforms (it’s unavailable for Windows unless explicitly built). I’m mentioning
    it here so you know what it is when you see it (*Figure 1.4*, but as with the
    GUI, developers will benefit more from editing the `CMakeCache.txt` file directly.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`ccmake` 可执行文件是 CMake 在类 Unix 平台上的交互式文本用户界面（如果没有明确构建，它在 Windows 上不可用）。我在这里提到它是为了让你知道当你看到它时会是什么（*图
    1.4*），但和 GUI 一样，开发人员直接编辑 `CMakeCache.txt` 文件会更有利。'
- en: '![](img/B19844_01_04.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_01_04.png)'
- en: 'Figure 1.4: The configuring stage in ccmake'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：ccmake 中的配置阶段
- en: Having this out of the way, we have concluded the basic introduction to the
    command line of the CMake suite. It’s time to discover the structure of a typical
    CMake project.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 说完这些，我们已经完成了 CMake 套件命令行的基本介绍。现在是时候了解一个典型的 CMake 项目的结构了。
- en: Navigating project directories and files
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航项目目录和文件
- en: 'Quite a lot of files and directories make up CMake projects. Let’s get a general
    idea of what each one does so we can start tinkering with them. There are several
    general categories:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 项目由相当多的文件和目录组成。让我们大致了解每个文件的作用，以便我们可以开始修改它们。它们大致可以分为几类：
- en: Of course, we’ll have project files that we, as developers, prepare and change
    as our project grows.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，我们会有一些项目文件，这些文件是我们作为开发人员在项目发展过程中准备和修改的。
- en: There will be files that CMake generates for itself, and even though they will
    contain CMake language commands, they aren’t meant for developers to edit. Any
    manual changes made there will be overwritten by CMake.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一些文件是 CMake 为自己生成的，尽管它们包含 CMake 语言命令，但并不是供开发人员编辑的。任何手动更改都会被 CMake 覆盖。
- en: 'Some files are meant for advanced users (as in: not project developers) to
    customize how CMake builds the project to their individual needs.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些文件是为高级用户（即：非项目开发人员）设计的，用来根据个人需求定制 CMake 构建项目的方式。
- en: Finally, there are some temporary files that provide valuable information in
    specific contexts.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，还有一些临时文件，在特定上下文中提供有价值的信息。
- en: This section will also suggest which files you can put in the *ignore* file
    of your **Version Control System** (**VCS**).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还将建议你可以将哪些文件放入**版本控制系统**（**VCS**）的*忽略*文件中。
- en: The source tree
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码树
- en: This is the directory where your project will live (it is also called the **project
    root**). It contains all of the C++ sources and CMake project files.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的项目所在的目录（也称为**项目根目录**）。它包含所有C++源代码和CMake项目文件。
- en: 'Here are the most important takeaways from this directory:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该目录中的最重要要点：
- en: It requires a `CMakeLists.txt` configuration file.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要一个`CMakeLists.txt`配置文件。
- en: The path to this directory is given by the user with a `-S` argument of the
    `cmake` command when *generating a buildsystem*.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个目录的路径由用户在使用`cmake`命令*生成构建系统*时通过`-S`参数指定。
- en: Avoid hardcoding any absolute paths to the *source tree* in your CMake code
    – users of your software will store the project in another path.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在CMake代码中硬编码任何指向*源代码树*的绝对路径——你的软件用户会将项目存储在不同的路径中。
- en: It’s a good idea to initialize a repository in this directory, perhaps using
    a VCS like `Git`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中初始化一个版本库是个好主意，可以使用像`Git`这样的VCS。
- en: The build tree
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建树
- en: 'CMake creates this directory in a path specified by the user. It will store
    the buildsystem and everything that gets created during the build: the artifacts
    of the project, the transient configuration, the cache, the build logs, and the
    output of your native build tool (like GNU Make). Alternative names for this directory
    include **build root** and **binary tree**.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: CMake在用户指定的路径中创建此目录。它将存储构建系统和构建过程中创建的所有内容：项目的构建产物、临时配置、缓存、构建日志以及本地构建工具（如GNU
    Make）的输出。此目录的其他名称包括**构建根目录**和**二进制树**。
- en: 'Key things to remember:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 记住的关键点：
- en: Your build configuration (buildsystem) and build artifacts will be created here
    (such as binary files, executables, and libraries, along with *object files* and
    archives used for final linking).
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的构建配置（构建系统）和构建产物将被创建在这里（例如二进制文件、可执行文件、库文件，以及用于最终链接的*目标文件*和归档文件）。
- en: CMake recommends that this directory be placed outside the source tree directory
    (a practice known as **out-of-source builds**). This way, we can prevent the pollution
    of our project (**in-source builds**).
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake建议将该目录放置在源代码树目录之外（这种做法称为**源外构建**）。这样，我们可以防止项目的污染（**源内构建**）。
- en: It is specified with `-B` to the `cmake` command when *generating a buildsystem*.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过`-B`参数在*生成构建系统*时指定给`cmake`命令。
- en: This directory isn’t meant as a final destination for generated files. Rather,
    it’s recommended that your projects include an installation stage that copies
    the final artifacts where they should be in the system and removes all temporary
    files used for building.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个目录并不是生成文件的最终目的地。相反，建议你的项目包含一个安装阶段，将最终的构件复制到系统中应有的位置，并删除所有用于构建的临时文件。
- en: Don’t add this directory to your VCS – every user picks one for themselves.
    If you have a good reason to do an in-source build, make sure to add this directory
    to the VCS ignore file (like `.gitignore`).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这个目录添加到版本控制系统（VCS）中——每个用户会为自己选择一个目录。如果你有充分的理由进行源代码内构建，请确保将这个目录添加到VCS忽略文件中（例如`.gitignore`）。
- en: Listfiles
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表文件
- en: Files that contain the CMake language are called listfiles and can be included
    one in another by calling `include()` and `find_package()`, or indirectly with
    `add_subdirectory()`. CMake doesn’t enforce any naming rules for these files but,
    by convention, they have a `.cmake` extension.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 包含CMake语言的文件称为列表文件，可以通过调用`include()`和`find_package()`来互相包含，或者通过`add_subdirectory()`间接包含。CMake并不强制规定这些文件的命名规则，但根据惯例，它们的扩展名是`.cmake`。
- en: Project file
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目文件
- en: CMake projects are configured with a `CMakeLists.txt` listfile (notice that
    due to historical reasons, this file has an unconventional extension). This file
    is required at the top of the source tree of every project and is the first to
    be executed in the configuration stage.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: CMake项目使用`CMakeLists.txt`列表文件进行配置（注意，由于历史原因，这个文件的扩展名不常见）。该文件是每个项目源代码树顶端必须存在的文件，并且是配置阶段首先执行的文件。
- en: 'A top-level `CMakeLists.txt` should contain at least two commands:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级的`CMakeLists.txt`应该包含至少两个命令：
- en: '`cmake_minimum_required(VERSION <x.xx>)`: Sets an expected version of CMake
    and tells CMake how to handle legacy behaviors with policies'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake_minimum_required(VERSION <x.xx>)`：设置CMake的期望版本，并告诉CMake如何处理与策略相关的遗留行为。'
- en: '`project(<name> <OPTIONS>)`: Names the project (the provided name will be stored
    in the `PROJECT_NAME` variable) and specifies the options to configure it (more
    on this in *Chapter 2*, *The CMake Language*)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project(<name> <OPTIONS>)`：命名项目（提供的名称将存储在`PROJECT_NAME`变量中），并指定配置项目的选项（更多内容请参见*第2章*，*CMake语言*）。'
- en: 'As your software grows, you might want to partition it into smaller units that
    can be configured and reasoned about separately. CMake supports this through the
    notion of subdirectories with their own `CMakeLists.txt` files. Your project structure
    might look similar to the following example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件的成长，你可能希望将其划分为可以单独配置和推理的小单元。CMake通过引入具有独立`CMakeLists.txt`文件的子目录来支持这一点。你的项目结构可能类似于以下示例：
- en: '[PRE65]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A very simple top-level `CMakeLists.txt` file can then be used to bring it
    all together:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的顶层`CMakeLists.txt`文件可以将所有内容整合在一起：
- en: '[PRE66]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The main aspects of the project are covered in the top-level file: managing
    the dependencies, stating the requirements, and detecting the environment. We
    also have an `add_subdirectory(api)` command to include another `CMakeListst.txt`
    file from the `api` subdirectory to perform steps that are specific to the API
    part of our application.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的主要方面在顶层文件中得到涵盖：管理依赖项、声明需求以及检测环境。我们还有一个`add_subdirectory(api)`命令，用来包含`api`子目录中的另一个`CMakeLists.txt`文件，以执行特定于应用程序API部分的步骤。
- en: Cache file
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存文件
- en: 'Cache variables will be generated from the listfiles and stored in `CMakeCache.txt`
    when the configure stage is run for the first time. This file resides in the root
    of the build tree and has a fairly simple format (some lines removed for brevity):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存变量将在配置阶段第一次运行时从列表文件生成，并存储在`CMakeCache.txt`中。该文件位于构建树的根目录，格式非常简单（为了简洁，省略了一些行）：
- en: '[PRE67]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see from the header comments, this format is pretty self-explanatory.
    Cache entries in the `EXTERNAL` section are meant for users to modify, while the
    `INTERNAL` section is managed by CMake.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 从头部注释中可以看到，这种格式非常易于理解。`EXTERNAL`部分的缓存项是供用户修改的，而`INTERNAL`部分则由CMake管理。
- en: 'Here are a couple of key takeaways to bear in mind:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个关键点需要记住：
- en: You can manage this file manually, by calling `cmake` (see *Options for caching*
    in the *Mastering the command line* section of this chapter), or through `ccmake`
    or `cmake-gui`.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过手动管理此文件，调用`cmake`（请参阅本章*命令行精通*部分中的*缓存选项*），或者通过`ccmake`或`cmake-gui`进行管理。
- en: You can reset the project to its default configuration by deleting this file;
    it will be regenerated from the listfiles.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过删除此文件来重置项目为默认配置；它将从列表文件重新生成。
- en: Cache variables can be read and written from the listfiles. Sometimes, variable
    reference evaluation is a bit complicated; we will cover that in more detail in
    *Chapter 2*, *The CMake Language*.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存变量可以从列表文件中读取和写入。有时，变量引用的求值过程会有些复杂；我们将在*第2章*，*CMake语言*中详细讨论这一点。
- en: Package definition file
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包定义文件
- en: A big part of the CMake ecosystem is the external packages that projects can
    depend on. They provide libraries and tools in a seamless, cross-platform way.
    Package authors that want to provide CMake support will ship it with a CMake package
    configuration file.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: CMake生态系统的一个重要组成部分是项目可以依赖的外部包。它们以无缝、跨平台的方式提供库和工具。希望提供CMake支持的包作者会附带一个CMake包配置文件。
- en: 'We’ll learn how to write those files in *Chapter 14*, *Installing and Packaging*.
    Meanwhile, here’s a few interesting details to bear in mind:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第14章*，*安装与打包*中学习如何编写这些文件。与此同时，以下是一些值得注意的细节：
- en: '**Config-files** (original spelling) contain information regarding how to use
    the library binaries, headers, and helper tools. Sometimes, they expose CMake
    macros and functions that can be used in your project.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**（原始拼写）包含有关如何使用库的二进制文件、头文件和辅助工具的信息。有时，它们会公开可以在你的项目中使用的CMake宏和函数。'
- en: '**Config-files** are named `<PackageName>-config.cmake` or `<PackageName>Config.cmake`.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**命名为`<PackageName>-config.cmake`或`<PackageName>Config.cmake`。'
- en: Use the `find_package()` command to include packages.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`find_package()`命令来包含包。
- en: If a specific version of the package is required, CMake will check this against
    the associated `<PackageName>-config-version.cmake` or `<PackageName>ConfigVersion.cmake`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要特定版本的包，CMake将会检查关联的`<PackageName>-config-version.cmake`或`<PackageName>ConfigVersion.cmake`。
- en: If a vendor doesn’t provide a config file for the package, sometimes, the configuration
    is bundled with the CMake itself or can be provided in the project with **Find-module**
    (original spelling).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果供应商没有为包提供配置文件，有时配置会与CMake本身捆绑，或者可以通过项目中的**Find-module**（原始拼写）提供。
- en: Generated files
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成的文件
- en: Many files are generated in the build tree by the `cmake` executable in the
    generation stage. As such, they shouldn’t be edited manually. CMake uses them
    as a configuration for the `cmake` install action, CTest, and CPack.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文件是由`cmake`可执行文件在生成阶段生成的。因此，它们不应手动编辑。CMake将它们用作`cmake`安装操作、CTest和CPack的配置。
- en: 'Files that you may encounter are:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会遇到的文件包括：
- en: '`cmake_install.cmake`'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake_install.cmake`'
- en: '`CTestTestfile.cmake`'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CTestTestfile.cmake`'
- en: '`CPackConfig.cmake`'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPackConfig.cmake`'
- en: If you’re implementing an in-source build, it’s probably a good idea to add
    them to the VCS ignore file.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现源代码构建，最好将它们添加到VCS忽略文件中。
- en: JSON and YAML files
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 和 YAML 文件
- en: Other formats used by CMake are **JavaScript Object Notation** (**JSON**) and
    **Yet Another Markup Language** (**YAML**). These files are introduced as an interface
    to communicate with external tools (like IDEs) or to provide configuration that
    can be easily generated and parsed.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: CMake使用的其他格式包括**JavaScript对象表示法**（**JSON**）和**另一种标记语言**（**YAML**）。这些文件作为与外部工具（如IDE）进行通信的接口，或者提供可以轻松生成和解析的配置。
- en: Preset files
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预设文件
- en: The advanced configuration of the projects can become a relatively busy task
    when we need to be specific about things such as cache variables, chosen generators,
    the path of the build tree, and more – especially when we have more than one way
    of building our project. This is where the presets come in – instead of manually
    configuring these values through the command line, we can just provide a file
    that stores all the details and ship it with the project. Since CMake 3.25, presets
    also allow us to configure **workflows**, which tie stages (configure, build,
    test, and package) into a named list of steps to execute.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的高级配置在需要指定诸如缓存变量、选择的生成器、构建树的路径等事项时，可能变得相对繁琐，特别是当我们有多种方式构建项目时。这时预设（presets）就派上用场了——我们可以通过提供一个存储所有详细信息的文件，而不是通过命令行手动配置这些值，并将其与项目一起发布。自CMake
    3.25起，预设还允许我们配置**工作流**，将各个阶段（配置、构建、测试和打包）绑定为一个命名的执行步骤列表。
- en: As mentioned in the *Mastering the command line* section of this chapter, users
    can choose presets through the GUI or use the command `--list-presets` and select
    a preset for the buildsystem with the `--preset=<preset>` option.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章的*掌握命令行*部分所提到的，用户可以通过GUI选择预设，或者使用命令`--list-presets`并使用`--preset=<preset>`选项为构建系统选择一个预设。
- en: 'Presets are stored in two files:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 预设存储在两个文件中：
- en: '`CMakePresets.json`: This is meant for project authors to provide official
    presets.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakePresets.json`：这是供项目作者提供官方预设的文件。'
- en: '`CMakeUserPresets.json`: This is dedicated to users who want to customize the
    project configuration to their liking (you can add it to your VCS ignore file).'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeUserPresets.json`：这是为那些希望根据自己的喜好自定义项目配置的用户设计的（可以将其添加到VCS忽略文件中）。'
- en: Presets are not required in projects and only become useful in advanced scenarios.
    See *Chapter 16*,*Writing CMake Presets*, for details.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 预设在项目中并非必需，只有在高级场景下才会变得有用。详情请参见*第16章*，*编写CMake预设*。
- en: File-based API
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于文件的API
- en: 'CMake 3.14 introduced an API that allows external tools to query the buildsystem
    information: paths to generated files, cache entries, toolchains, and such. We
    only mention this very advanced topic to avoid confusion if you come across a
    *file-based API* phrase in the documentation. The name suggests how it works:
    a JSON file with a query has to be placed in a special path inside the build tree.
    CMake will read this file during the buildsystem generation and write a response
    to another file, so it can be parsed by external applications.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 3.14引入了一个API，允许外部工具查询构建系统信息：生成文件的路径、缓存条目、工具链等。我们提到这个非常高级的话题，是为了避免在文档中看到*基于文件的API*时产生困惑。该名称暗示了它的工作原理：必须将带有查询的JSON文件放置在构建树中的特定路径下。CMake将在构建系统生成期间读取该文件，并将响应写入另一个文件，以便外部应用程序解析。
- en: The file-based API was introduced to replace a deprecated mechanism called *server
    mode* (or `cmake-server`), which was finally removed in CMake 3.26.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的API是为了替代一个已被弃用的机制——*服务器模式*（或 `cmake-server`），该机制最终在CMake 3.26中被移除。
- en: Configure log
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置日志
- en: 'Since version 3.26, CMake will provide a structured log file for really advanced
    debugging of the *configure stage* at:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 从 3.26 版本开始，CMake 将提供一个结构化的日志文件，用于高级调试 *配置阶段*，文件位于：
- en: '[PRE68]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It’s one of these features that you don’t normally need to pay attention to
    – until you do.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你通常不需要关注的特性——直到你需要的时候。
- en: Ignoring files in Git
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Git 中忽略文件
- en: There are many VCSs; one of the most popular out there is Git. Whenever we start
    a new project, it is good to make sure that we only *add* the necessary files
    to the repository. Project hygiene is easier to maintain if we specify unwanted
    files in the `.gitignore` file. For example, we might exclude files that are generated,
    user-specific, or temporary.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多版本控制系统（VCS）；其中最流行的之一是 Git。每当我们开始一个新项目时，确保只将必要的文件*添加*到仓库中是很重要的。如果我们在 `.gitignore`
    文件中指定不需要的文件，项目的清洁度会更容易维护。例如，我们可以排除一些生成的文件、用户特定的文件或临时文件。
- en: 'Git will automatically skip them when forming new commits. Here’s the file
    that I use in my projects:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Git 在创建新的提交时会自动跳过这些文件。以下是我在项目中使用的文件：
- en: '**ch01/01-hello/.gitignore**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch01/01-hello/.gitignore**'
- en: '[PRE69]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now you hold a map to the sea of project files. Some files are very important
    and you will use them all the time – others, not so much. While it might seem
    like a waste to learn about them, it can be invaluable to know where *not to look*
    for answers. In any case, one last question for this chapter remains: what other
    self-contained units can you create with CMake?'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你持有了一张项目文件的地图。有些文件非常重要，你会经常使用它们，而有些文件则不太重要。虽然了解这些文件可能看起来没什么用，但知道 *不该在哪里寻找*
    答案可能是非常宝贵的。无论如何，本章还有一个最后的问题：你可以使用 CMake 创建哪些其他自包含的单元？
- en: Discovering scripts and modules
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现脚本和模块
- en: 'CMake is primarily focused on projects built to produce artifacts that get
    consumed by other systems (such as CI/CD pipelines and test platforms, or deployed
    to machines or stored in artifact repositories). However, there are two other
    concepts in CMake that use its language: scripts and modules. Let’s explain what
    they are and how they differ.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 主要关注构建产生可以被其他系统使用的工件的项目（例如 CI/CD 管道、测试平台，或者部署到机器或存储在工件仓库中）。然而，CMake 还有两个概念使用其语言：脚本和模块。让我们解释它们是什么，以及它们有什么不同。
- en: Scripts
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本
- en: CMake offers a platform-agnostic programming language, which comes with many
    useful commands. Scripts written in it can be bundled with a bigger project or
    be completely independent.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了一种与平台无关的编程语言，配备了许多有用的命令。用这种语言编写的脚本可以与更大的项目捆绑在一起，或者完全独立。
- en: Think of it as a consistent way to do cross-platform work. Normally, to perform
    a task, you would have to create a separate Bash script for Linux and separate
    batch files or PowerShell scripts for Windows, and so on. CMake abstracts this
    away so you can have one file that works fine on all platforms. Sure, you could
    use external tools such as Python, Perl, or Ruby scripts, but that’s an added
    dependency and will increase the complexity of your C/C++ projects. So why introduce
    another language, when most of the time, you can get the job done with something
    far simpler? Use CMake!
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为一种一致的跨平台工作方式。通常，为了执行一个任务，你需要为 Linux 创建一个单独的 Bash 脚本，为 Windows 创建单独的批处理文件或
    PowerShell 脚本，依此类推。而 CMake 将这一切抽象化，你可以拥有一个在所有平台上都能正常工作的文件。当然，你也可以使用外部工具，如 Python、Perl
    或 Ruby 脚本，但这增加了依赖项，会增加 C/C++ 项目的复杂性。那么，为什么要引入另一种语言呢？大多数情况下，你可以使用更简单的方式来完成任务。使用
    CMake！
- en: 'We have already learned from the *Mastering the command line* section that
    we can execute scripts using the `-P` option: `cmake -P script.cmake`.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从 *掌握命令行* 部分学到，我们可以使用 `-P` 选项来执行脚本：`cmake -P script.cmake`。
- en: 'But what are the actual requirements for the script file that we want to use?
    Not that big: the script can be as complex as you like, or just an empty file.
    It is still recommended to call the `cmake_minimum_required()` command at the
    beginning of every script though. This command tells CMake which policies should
    be applied to subsequent commands in this project (more in *Chapter 4*, *Setting
    Up Your First CMake Project*).'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们希望使用的脚本文件的实际要求是什么呢？其实并不复杂：脚本可以根据需要复杂，也可以只是一个空文件。不过，仍然建议在每个脚本的开头调用 `cmake_minimum_required()`
    命令。该命令告诉 CMake 应该对项目中的后续命令应用哪些策略（详细内容请参见 *第 4 章*，*设置你的第一个 CMake 项目*）。
- en: 'Here’s an example of a simple script:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单脚本的示例：
- en: '**ch01/02-script/script.cmake**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch01/02-script/script.cmake**'
- en: '[PRE70]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When running scripts, CMake won’t execute any of the usual stages (such as configuration
    or generation), and it won’t use the cache, since there is no concept of **source
    tree** or **build tree** in scripts. This means that project-specific CMake commands
    are not available/usable in scripting mode. That’s all. Happy scripting!
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行脚本时，CMake 不会执行任何常规阶段（例如配置或生成），也不会使用缓存，因为在脚本中没有 **源树** 或 **构建树** 的概念。这意味着项目特定的
    CMake 命令在脚本模式下不可用/不可使用。就这些了，祝你脚本编写愉快！
- en: Utility modules
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用模块
- en: CMake projects can use external modules to enhance their functionality. Modules
    are written in the CMake language and contain macro definitions, variables, and
    commands that perform all kinds of functions. They range from quite complex scripts
    (like those provided by `CPack` and `CTest`) to fairly simple ones, such as `AddFileDependencies`
    or `TestBigEndian`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 项目可以使用外部模块来增强其功能。模块是用 CMake 语言编写的，包含宏定义、变量和执行各种功能的命令。它们的复杂程度从非常复杂的脚本（如
    `CPack` 和 `CTest` 提供的脚本）到相对简单的脚本，例如 `AddFileDependencies` 或 `TestBigEndian`。
- en: The CMake distribution comes packed with over 80 different utility modules.
    If that’s not enough, you can download more from the internet by browsing curated
    lists, such as the one found at [https://github.com/onqtam/awesome-cmake](https://github.com/onqtam/awesome-cmake),
    or write your own module from scratch.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 分发版包含了超过 80 个不同的实用模块。如果这些还不够，你可以通过浏览一些策划的列表，如 [https://github.com/onqtam/awesome-cmake](https://github.com/onqtam/awesome-cmake)，从互联网上下载更多，或者从头编写你自己的模块。
- en: 'To use a utility module, we need to call an `include(<MODULE>)` command. Here’s
    a simple project showing this in action:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用实用模块，我们需要调用 `include(<MODULE>)` 命令。以下是一个简单的项目，展示了这一过程：
- en: '**ch01/03-module/CMakeLists.txt**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch01/03-module/CMakeLists.txt**'
- en: '[PRE71]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We’ll learn what modules are available as they become relevant to the subject
    at hand. If you’re curious, a full list of bundled modules can be found at [https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在相关主题时学习哪些模块可用。如果你感兴趣，可以查看包含模块的完整列表，网址为 [https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html)。
- en: Find-modules
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找模块
- en: In the *Package definition File* section, I mentioned that CMake has a mechanism
    to find files belonging to external dependencies that don’t support CMake and
    don’t provide a CMake package config-file. That’s what find-modules are for. CMake
    provides over 150 find-modules that are able to locate those packages if they
    are installed in the system. As was the case with utility modules, there are plenty
    more find-modules available online. As a last resort, you can always write your
    own.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *包定义文件* 部分，我提到 CMake 有一个机制，用来查找不支持 CMake 并且不提供 CMake 包配置文件的外部依赖文件。这就是查找模块的用途。CMake
    提供了超过 150 个查找模块，能够定位这些已安装在系统中的包。就像实用模块一样，网上有更多的查找模块可用。作为最后的手段，你也可以自己编写。
- en: You can use them by calling the `find_package()` command and providing the name
    of the package in question. Such a find-module will then play a little game of
    hide and seek and check all known locations of the software it is looking for.
    If the files are found, variables with their path will be defined (as specified
    in that module’s manual). Now, CMake can build against that dependency.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `find_package()` 命令并提供相关包的名称来使用它们。这样，查找模块会进行一场捉迷藏的游戏，检查所有已知的软件位置。如果找到文件，将定义包含其路径的变量（如该模块手册中所指定）。现在，CMake
    可以基于该依赖关系进行构建。
- en: 'For example, the `FindCURL` module searches for a popular *Client URL* library
    and defines the following variables: `CURL_FOUND`, `CURL_INCLUDE_DIRS`, `CURL_LIBRARIES`,
    and `CURL_VERSION_STRING`.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`FindCURL` 模块搜索一个流行的 *Client URL* 库，并定义以下变量：`CURL_FOUND`、`CURL_INCLUDE_DIRS`、`CURL_LIBRARIES`
    和 `CURL_VERSION_STRING`。
- en: We will cover find-modules in more depth in *Chapter 9*, *Managing Dependencies
    in CMake*.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第9章*《*在 CMake 中管理依赖*》中更深入地讨论查找模块。
- en: Summary
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Now you understand what CMake is and how it works; you learned about the key
    components of the CMake tool family and how it is installed on a variety of systems.
    Like a true power user, you know all the ways in which to run CMake through the
    command line: buildsystem generation, building a project, installing, running
    scripts, command-line tools, and printing help. You are aware of the CTest, CPack,
    and GUI applications. This will help you to create projects with the right perspective
    for users and other developers. Additionally, you learned what makes up a project:
    directories, listfiles, configs, presets, and helper files, along with what to
    ignore in your VCS. Finally, you took a sneak peek at other non-project files:
    standalone scripts and two kinds of modules – utility modules and find-modules.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了 CMake 是什么以及它是如何工作的；您学习了 CMake 工具家族的关键组成部分，并了解了它如何在各种系统上安装。作为一名真正的高级用户，您知道如何通过命令行运行
    CMake 的各种方式：构建系统生成、构建项目、安装、运行脚本、命令行工具和打印帮助信息。您还了解了 CTest、CPack 和 GUI 应用程序。这将帮助您以正确的视角为用户和其他开发者创建项目。此外，您还了解了项目的组成：目录、列表文件、配置、预设和辅助文件，以及如何在版本控制系统中忽略哪些内容。最后，您快速浏览了其他非项目文件：独立脚本和两种类型的模块——实用模块和查找模块。
- en: In the next chapter, we will learn how to use the CMake programming language.
    This will allow you to write your own listfiles and will open the door to your
    first script, project, and module.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 CMake 编程语言。这将使您能够编写自己的列表文件，并为您的第一个脚本、项目和模块打开大门。
- en: Further reading
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information, you can refer to the following resources:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更多信息，您可以参考以下资源：
- en: 'The official CMake web page and documentation: [https://cmake.org/](https://cmake.org/)'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 CMake 网页和文档：[https://cmake.org/](https://cmake.org/)
- en: 'Single-configuration generators: [https://cgold.readthedocs.io/en/latest/glossary/single-config.html](https://cgold.readthedocs.io/en/latest/glossary/single-config.html)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单配置生成器：[https://cgold.readthedocs.io/en/latest/glossary/single-config.html](https://cgold.readthedocs.io/en/latest/glossary/single-config.html)
- en: 'The separation of stages in the CMake GUI: [https://stackoverflow.com/questions/39401003/](https://stackoverflow.com/questions/39401003/)'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake GUI 中阶段的划分：[https://stackoverflow.com/questions/39401003/](https://stackoverflow.com/questions/39401003/)
- en: Leave a review!
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论来帮助像您一样的读者。扫描下面的二维码，获取您选择的免费电子书。
- en: '![](img/Review_Copy.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Review_Copy.png)'
