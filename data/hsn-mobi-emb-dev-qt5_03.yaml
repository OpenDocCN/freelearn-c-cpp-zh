- en: Fluid UI with Qt Quick
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Qt Quick 的流畅 UI
- en: My television uses Qt. My phone uses Qt. I could buy a car that uses Qt. I can
    fly on a plane that uses Qt on its infotainment center. All these things use Qt
    Quick as their UI. Why? Because it provides faster development—no waiting around
    for compiling—and the syntax is easy to use, but complex enough to customize it
    beyond your imagination.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我的电视使用 Qt。我的手机使用 Qt。我可以买一辆使用 Qt 的汽车。我可以在使用 Qt 的信息娱乐中心飞行的飞机上。所有这些事情都使用 Qt Quick
    作为它们的 UI。为什么？因为它提供了更快的开发——无需等待编译——语法易于使用，但复杂到足以超越你的想象。
- en: Qt Quick started out being developed in the Brisbane development office of Trolltech
    as one developer's research project. One of my jobs was to put a demo app of an
    early version of it onto a Nokia N800 tablet, which I had customized to run Qtopia
    instead of Nokia's Maemo interface. This was before Nokia purchased the Trolltech
    company. In my opinion, it was going to become the next generation of Qtopia,
    which had been renamed Qt Extended. Qtopia, by 2006, had been sold on millions
    of phone handsets, including 11 models of phones and 30 various handheld devices. Some
    parts of Qtopia were melded into Qt itself – my favorites, Qt Sensors, and Qt
    Bearer Management, are examples of these. This new XML-like framework became QML
    and Qt Quick.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 最初是在 Trolltech 的布里斯班开发办公室作为一位开发者的研究项目而开发的。我的一个工作是将早期版本的演示应用程序安装到诺基亚
    N800 平板电脑上，我已将其定制为运行 Qtopia 而不是诺基亚的 Maemo 界面。在那之前，诺基亚已经收购了 Trolltech 公司。在我看来，它将成为下一代
    Qtopia，Qtopia 已更名为 Qt Extended。到 2006 年，Qtopia 已经在数百万部手机上销售，包括 11 款手机和 30 种不同的手持设备。Qtopia
    的某些部分被融合到 Qt 本身中——我最喜欢的，Qt Sensors 和 Qt Bearer Management 就是这些例子。这个新的类似 XML 的框架变成了
    QML 和 Qt Quick。
- en: Qt Quick is a really exciting technology and it seems to be taking over the
    world. It is used in laptops, mobile phones such as the Jolla Sailfish, and medical
    devices, among others things.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 是一项真正令人兴奋的技术，它似乎正在接管世界。它被用于笔记本电脑、如 Jolla Sailfish 之类的手机以及医疗设备等。
- en: It allows rapid development, fluid transformations, animations, and special
    effects. Qt Quick allows developers to design customized animated **User Interfaces**
    (**UI**). Along with the related Qt Quick Controls 2 and Qt Charts APIs, anyone
    can create snazzy mobile and embedded apps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许快速开发、流畅的转换、动画和特殊效果。Qt Quick 允许开发者设计定制的动画**用户界面**（**UI**）。结合相关的 Qt Quick Controls
    2 和 Qt Charts API，任何人都可以创建炫酷的移动和嵌入式应用程序。
- en: In this chapter, we will design and construct an animated UI. We will also cover
    basic components, such as `Item`, `Rectangle`, and more advanced elements, such
    as `GraphicsView`. We will look at positioning items with anchors, states, animations,
    and transitions, and we will also cover traditional features, such as buttons,
    sliders, and scrollbars. Advanced components showing data in charts, such as BarChart
    and PieChart, will be shown.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设计和构建一个动画用户界面。我们还将介绍基本组件，如 `项目`、`矩形`，以及更高级的元素，如 `GraphicsView`。我们将探讨使用锚点、状态、动画和过渡来定位项目，并还将介绍传统功能，如按钮、滑块和滚动条。还将展示显示数据的先进组件，如柱状图和饼图。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: Learning Qt Quick basics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Qt Quick 基础
- en: Advanced QML elements in Qt Quick Controls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick Controls 中的高级 QML 元素
- en: Elements for displaying data—Qt Data Visualization and Qt Charts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示数据的元素——Qt 数据可视化和 Qt Charts
- en: Basic animation with Qt Quick
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt Quick 进行基本动画
- en: Qt Quick basics – anything goes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick 基础 – 任何事都可行
- en: 'Qt Quick is unreal. You should be aware that, at its core, it has only a few
    fundamental building blocks, called components. You will undoubtedly be using
    these components quite often:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 是超现实的。你应该知道，在其核心，它只有几个基本构建块，称为组件。你无疑会经常使用这些组件：
- en: '`Item`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`项目`'
- en: '`Rectangle`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`矩形`'
- en: '`Text`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文本`'
- en: '`Image`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图像`'
- en: '`TextInput`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文本输入`'
- en: '`MouseArea`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`鼠标区域`'
- en: Although there are probably hundreds of components and types, these items are
    the most important. There are also several classes of elements for text, positioning,
    states, animation, transitions, and transformations. Views, paths, and data handling
    all have their own elements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能有一百多个组件和类型，但这些项目是最重要的。还有几个用于文本、定位、状态、动画、过渡和转换的元素类别。视图、路径和数据处理都有自己的元素。
- en: With those building blocks, you can create fantastic UIs that are alive with
    animations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些构建块，你可以创建充满动画的精彩用户界面（UI）。
- en: The language to write Qt Quick applications is quite easy to pick up. Let's
    get started.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Qt Quick 应用程序的语言相当容易上手。让我们开始吧。
- en: QML
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML
- en: '**Qt Modeling Language** (**QML**) is the declarative programming language
    that Qt Quick uses. Closely aligned with JavaScript, it is the centerpiece language
    for Qt Quick. You can use JavaScript functions within a QML document, and Qt Quick
    will run it.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt 模型语言**（**QML**）是 Qt Quick 使用的声明性编程语言。与 JavaScript 密切相关，它是 Qt Quick 的核心语言。你可以在
    QML 文档中使用 JavaScript 函数，Qt Quick 将运行它。'
- en: We use Qt Quick 2 for this book, as Qt Quick 1.0 is depreciated.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中使用 Qt Quick 2，因为 Qt Quick 1.0 已被弃用。
- en: All QML documents need to have one or more `import` statements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 QML 文档都需要有一个或多个 `import` 语句。
- en: This is about the same as C and C++'s `#include` statement.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 C 和 C++ 的 `#include` 语句大致相同。
- en: 'The most basic QML will have at least one import statement, such as this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的 QML 至少有一个导入语句，例如这个：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `.12` corresponds with Qt's minor version, which is the lowest version the
    application will support.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`.12` 与 Qt 的次要版本相对应，这是应用程序将支持的最低版本。'
- en: If you are using properties or components that were added in a certain Qt version, you
    will need to specify that version.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用在某个 Qt 版本中添加的属性或组件，你需要指定该版本。
- en: Qt Quick applications are built with building blocks known as elements, or components.
    Some basic types are `Rectangle`, `Item`, and `Text`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 应用程序是用称为元素或组件的构建块构建的。一些基本类型是 `Rectangle`、`Item` 和 `Text`。
- en: Input interaction is supported through `MouseArea` and other items, such as
    `Flickable.`
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输入交互通过 `MouseArea` 和其他项目，如 `Flickable` 来支持。
- en: One way to start developing a Qt Quick app is by using the Qt Quick app wizard
    in Qt Creator. You can also grab your favorite text editor and start coding away!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 开始开发 Qt Quick 应用的一种方式是使用 Qt Creator 中的 Qt Quick 应用向导。你也可以抓取你喜欢的文本编辑器并开始编码！
- en: 'Let''s go though some of the following concepts that are important to be aware
    of as terms that make up the QML language:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下一些重要概念，作为构成 QML 语言的术语来了解：
- en: Components, types, and elements
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件、类型和元素
- en: Dynamic binding
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态绑定
- en: Signal connection
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号连接
- en: Components
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: Components, also known as types or elements, are objects of code and can contain
    both UI and non-UI aspects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 组件，也称为类型或元素，是代码的对象，可以包含 UI 和非 UI 方面。
- en: 'A UI component example would be the `Text` object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 UI 组件的例子是 `Text` 对象：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Component properties can be bound to variables, other properties, and values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 组件属性可以绑定到变量、其他属性和值。
- en: Dynamic binding
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态绑定
- en: 'Dynamic binding is a way to set a property value, which can either be a hardcoded
    static value, or be bound to other dynamic property values. Here, we bind the
    `Text` component''s `id` property to `textLabel`. We can then refer it to this
    element just by using its `id`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定是一种设置属性值的方式，该值可以是硬编码的静态值，也可以绑定到其他动态属性值。在这里，我们将 `Text` 组件的 `id` 属性绑定到 `textLabel`。然后我们可以通过使用它的
    `id` 来引用这个元素：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A component can have none, one, or a few signals that can be utilized.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件可以有零个、一个或几个可以使用的信号。
- en: Signal connections
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号连接
- en: 'There are two ways signals can be handled. The easiest way is by prepending `on`
    and then capitalizing the first letter of the particular signal. For example,
    a `MouseArea` has a signal named `clicked`, which can be connected by declaring
    `onClicked`, and then binding this to a function with curly brackets, `{ }`, or
    even a single line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 处理信号有两种方式。最简单的方式是在前面加上 `on` 并将特定信号的第一个字母大写。例如，`MouseArea` 有一个名为 `clicked` 的信号，可以通过声明
    `onClicked` 并将其绑定到带有花括号 `{ }` 或单行的函数来连接：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use the `Connections` type to target some other component''s signal:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `Connections` 类型来针对其他组件的信号：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The model-view paradigm is not dead with Qt Quick. There are a few elements
    that can show data model views.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图范式在 Qt Quick 中并未过时。有一些元素可以显示数据模型视图。
- en: Model-view programming
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图编程
- en: Qt Quick's views are based on a model, which can be defined either with the
    `model` property or as a list of elements within the component. The view is controlled
    by a delegate, which is any UI element capable of showing the data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 的视图基于一个模型，该模型可以通过 `model` 属性或组件内的元素列表来定义。视图由一个代理控制，该代理是任何能够显示数据的 UI
    元素。
- en: You can refer to properties of the model data in the delegate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代理中引用模型数据的属性。
- en: 'For example, let''s declare a `ListModel`, and fill it with two sets of data.
    `Component` is a generic object that can be declared, and here, I use it to contain
    a `Text` component that will function as the delegate. The model''s data with
    the ID of `carModel` can be referred to in the delegate. Here, there is a binding
    to the `text` property of the `Text` element:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们声明一个 `ListModel`，并用两组数据填充它。`Component` 是一个可以声明的通用对象，在这里，我使用它来包含一个将作为代理的
    `Text` 组件。具有 `carModel` ID 的模型数据可以在代理中引用。在这里，有一个绑定到 `Text` 元素的 `text` 属性：
- en: The source code can be found on the Git repository under the `Chapter02-1b` directory,
    in the `cp2` branch.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-1b` 目录下的 `cp2` 分支中找到。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can then use this model and its delegate in different views. Qt Quick has
    a few different views to choose from:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个模型及其代理在不同视图中。Qt Quick 提供了一些不同的视图供选择：
- en: '`GridView`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridView`'
- en: '`ListView`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView`'
- en: '`PathView`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathView`'
- en: '`TreeView`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TreeView`'
- en: Let's look at how we can use each of these.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这些中的每一个。
- en: GridView
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GridView
- en: The `GridView` type shows model data in a grid, much like a `GridLayout`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridView` 类型在网格中显示模型数据，类似于 `GridLayout`。'
- en: 'The grid''s layout can be contained with the following properties:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的布局可以通过以下属性包含：
- en: '`flow`:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flow`'
- en: '`GridView.FlowLeftToRight`'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridView.FlowLeftToRight`'
- en: '`GridView.FlowTopToBottom`'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridView.FlowTopToBottom`'
- en: '`layoutDirection`:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layoutDirection`'
- en: '`Qt.LeftToRight`'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt.LeftToRight`'
- en: '`Qt.RightToLeft`'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt.RightToLeft`'
- en: '`verticalLayoutDirection`:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verticalLayoutDirection`:'
- en: '`GridView.TopToBottom`'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridView.TopToBottom`'
- en: '`GridView.BottomToTop`'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridView.BottomToTop`'
- en: The `flow` property contains the way the data is presented so it becomes wrapped
    to the next line or column when it is appropriate. It controls the way it overflows
    to the next line or column.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`flow` 属性包含数据展示的方式，当数据适合时，它会自动换行到下一行或列。它控制数据如何溢出到下一行或列。'
- en: The icon for the following example came from [https://icons8.com](https://icons8.com).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例的图标来自 [https://icons8.com](https://icons8.com)。
- en: '`FlowLeftToRight` means the flow is horizontal. Here''s a pictorial representation
    for `FlowLeftToRight`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlowLeftToRight` 意味着流是水平的。以下是 `FlowLeftToRight` 的图示：'
- en: '![](img/487b0a67-225c-4e49-bd0c-39ac5c91d0fc.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/487b0a67-225c-4e49-bd0c-39ac5c91d0fc.png)'
- en: 'For `FlowTopToBottom`, the flow is vertical; here''s a representation of `FlowTopToBottom`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `FlowTopToBottom`，流是垂直的；以下是 `FlowTopToBottom` 的表示：
- en: '![](img/a15cb40a-8dd7-44bb-ab31-55010d39c798.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a15cb40a-8dd7-44bb-ab31-55010d39c798.png)'
- en: When this example gets built and run, you can resize the window by grabbing
    the corner with the mouse. You will get a better idea of how the flow works.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个示例构建并运行时，你可以通过用鼠标抓住角落来调整窗口大小。这将更好地帮助你理解流的工作方式。
- en: 'The `layoutDirection` property indicates which direction the data will be laid
    out. In the following case, this is `RightToLeft`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`layoutDirection` 属性指示数据将如何布局的方向。在以下情况下，这是 `RightToLeft`：'
- en: '![](img/50f2bd00-e771-4d1d-98ad-58e9f28575d5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50f2bd00-e771-4d1d-98ad-58e9f28575d5.png)'
- en: 'The `verticalLayoutDirection` also indicates which direction the data is laid
    out, except this will be vertical. Here''s the `GridView.BottomToTop` representation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`verticalLayoutDirection` 也指示数据将如何布局的方向，但这次将是垂直的。以下是 `GridView.BottomToTop`
    的表示：'
- en: '![](img/e34592be-d6ca-4bf0-9537-52fc184cb427.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e34592be-d6ca-4bf0-9537-52fc184cb427.png)'
- en: ListView
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListView
- en: The QML `Listview` is a type of `Flickable` element, meaning that the user can
    swipe or flick left or right to progress through the difference views. `ListView`
    looks different from the `QListView` desktop, as the items are presented in their
    own page, which is accessible by flicking left or right.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: QML 的 `Listview` 是一种 `Flickable` 元素类型，这意味着用户可以通过左右滑动或轻扫来浏览不同的视图。与桌面上的 `QListView`
    不同，`ListView` 中的项目以自己的页面呈现，可以通过左右轻扫来访问。
- en: 'The layout is handled by these properties:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 布局由以下属性处理：
- en: '`orientation`:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orientation`:'
- en: '`Qt.horizontal`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt.horizontal`'
- en: '`Qt.vertical `'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt.vertical`'
- en: '`layoutDirection`:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layoutDirection`'
- en: '`Qt.LeftToRight`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt.LeftToRight`'
- en: '`Qt.RightToLeft`'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt.RightToLeft`'
- en: '`verticalLayoutDirection`:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verticalLayoutDirection`:'
- en: '`ListView.TopToBottom`'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView.TopToBottom`'
- en: '`ListView.BottonToTop`'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView.BottonToTop`'
- en: PathView
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PathView
- en: '`PathView` shows model data in a `Path`. Its delegate is a view for displaying
    the model data. It could be a simple drawn line, or an image with text. This can
    produce a flowing wheel type of data presentation. A `Path` can be constructed
    by one or more of the following `path` segments:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`PathView` 在 `Path` 中显示模型数据。其代理是一个用于显示模型数据的视图。它可以是简单的线条绘制，也可以是带有文本的图像。这可以产生流动的轮盘式数据展示。`Path`
    可以通过以下一个或多个 `path` 段落构建：'
- en: '`PathAngleArc`: An arc with radii and center'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathAngleArc`: 带有半径和中心的弧'
- en: '`PathArc`: An arc with radius'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathArc`: 带有半径的圆弧'
- en: '`PathCurve`: A path through a set of points'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathCurve`: 通过一系列点绘制路径'
- en: '`PathCubic`: A path on Bézier curve'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathCubic`: 贝塞尔曲线上的路径'
- en: '`PathLine`: A straight line'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathLine`: 一条直线'
- en: '`PathQuad`: A quadratic Bézier curve'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathQuad`: 二次贝塞尔曲线'
- en: 'Here, we use `PathArc` to display a wheel-like item model, using our `carModel`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`PathArc`来显示一个类似轮子的项目模型，使用我们的`carModel`：
- en: The source code can be found on the Git repository under the `Chapter02-1c` directory,
    in the `cp2` branch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter02-1c`目录下的`cp2`分支中找到。
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should now see something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到类似这样的内容：
- en: '![](img/e6b1ded4-1eae-4839-ab66-7217df3d6ff3.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6b1ded4-1eae-4839-ab66-7217df3d6ff3.png)'
- en: 'There are a couple of special `path` segments that augment and change attributes
    of the `path`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个特殊的`path`段可以增强和改变`path`的属性：
- en: '`PathAttribute`: Allows an attribute to be specified at certain points along
    a path'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathAttribute`: 允许在路径的某些点上指定属性'
- en: '`PathMove`: Moves a path to a new position'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathMove`: 将路径移动到新位置'
- en: TreeView
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TreeView
- en: '`TreeView` is perhaps the most recognizable of these views. It looks very similar
    to the desktop variety. It displays a tree structure of its model data. `TreeView`
    has headers, called `TableViewColumn`, which you can use to add a title as well
    as to specify its width. Further customization can be made using `headerDelegate`,
    `itemDelegate`, and `rowDelegate`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeView`可能是这些视图中最容易被识别的。它看起来非常类似于桌面版本。它显示其模型数据的树结构。`TreeView`有标题，称为`TableViewColumn`，你可以用它来添加标题以及指定其宽度。还可以使用`headerDelegate`、`itemDelegate`和`rowDelegate`进行进一步定制。'
- en: 'Sorting is not implemented by default, but can be controlled by a few properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下没有实现排序，但可以通过几个属性来控制：
- en: '`sortIndicatorColumn`: `Int`, indicating the column to be sorted'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortIndicatorColumn`: `Int`，表示要排序的列'
- en: '`sortIndicatorVisible`: `Bool` is used to enable sorting'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortIndicatorVisible`: `Bool`用于启用排序'
- en: '`sortIndicatorOrder`: `Enum` either `Qt.AscendingOrder` or `Qt.DescendingOrder`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortIndicatorOrder`: `Enum`可以是`Qt.AscendingOrder`或`Qt.DescendingOrder`'
- en: Gestures and touch
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手势和触摸
- en: 'Touch gestures can be an innovative way to interact with your application.
    To use the `QtGesture` class in Qt, you will need to implement the handlers in
    C++ by overriding the `QGestureEvent` class and handling the built-in `Qt::GestureType`.
    In this way, the following gestures can be handled:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸手势可以是与你的应用程序交互的创新方式。要在Qt中使用`QtGesture`类，你需要通过重写`QGestureEvent`类并处理内置的`Qt::GestureType`在C++中实现处理程序。这样，以下手势可以被处理：
- en: '`Qt::TapGesture`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::TapGesture`'
- en: '`Qt::TapAndHoldGesture`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::TapAndHoldGesture`'
- en: '`Qt::PanGesture`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::PanGesture`'
- en: '`Qt::PinchGesture`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::PinchGesture`'
- en: '`Qt::SwipeGesture`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::SwipeGesture`'
- en: '`Qt::CustomGesture`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::CustomGesture`'
- en: The `Qt::CustomGesture` flag is a special one that can be used to invent your
    own custom gestures.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt::CustomGesture`标志是一个特殊标志，可以用来发明你自己的自定义手势。'
- en: There is one built-in gesture item in Qt Quick— `PinchArea`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick中有一个内置的手势项目——`PinchArea`。
- en: PinchArea
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PinchArea
- en: '`PinchArea` handles pinch gestures, which are commonly used on mobile phones
    to zoom in on an image from within Qt Quick, so you can use simple QML to implement
    it for any `Item`-based element.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`PinchArea`处理捏合手势，这在Qt Quick中常用于从手机上放大图像，因此你可以使用简单的QML为任何基于`Item`的元素实现它。'
- en: You can use the `onPinchFinished`, `onPinchStarted`, and `onPinchUpdated` signals,
    or set the `pinch.target` property to the target item to handle the pinch gesture.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`onPinchFinished`、`onPinchStarted`和`onPinchUpdated`信号，或将`pinch.target`属性设置为要处理的手势的目标项。
- en: MultiPointTouchArea
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MultiPointTouchArea
- en: The `MultiPointTouchArea` is not a gesture, but rather a way to track multiple
    points of contact of the touchscreen. Not all touchscreens support multi-touch.
    Mobile phones usually support multi-touch, and some embedded devices do as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiPointTouchArea`不是一个手势，而是一种跟踪触摸屏多个接触点的途径。并非所有触摸屏都支持多点触摸。手机通常支持多点触摸，一些嵌入式设备也是如此。'
- en: To use multi-point touchscreens in QML, there is the `MultiPointTouchArea` component,
    which works a bit like `MouseArea`. It can operate alongside `MouseArea` by setting
    its `mouseEnabled` property to `true`**.** This makes the `MultiPointTouchArea` component
    ignore events from the mouse and only respond to touch events.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在QML中使用多点触摸屏，有`MultiPointTouchArea`组件，它的工作方式有点像`MouseArea`。通过将其`mouseEnabled`属性设置为`true`，它可以与`MouseArea`一起操作。这使得`MultiPointTouchArea`组件忽略鼠标事件，只响应触摸事件。
- en: Each `MultiPointTouchArea` takes an array of `TouchPoints`. Note the use of
    square brackets, `[ ]`—this denotes that it is an array. You can define one or
    more of these to handle a certain number of `TouchPoints` or fingers. Here, we
    define and handle only three `TouchPoints`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `MultiPointTouchArea` 都接受一个 `TouchPoints` 数组。注意方括号的使用，`[ ]`——这表示它是一个数组。你可以定义一个或多个这些来处理一定数量的
    `TouchPoints` 或手指。在这里，我们定义并处理了三个 `TouchPoints`。
- en: 'If you try this on a non-touchscreen, only one green dot will track the touch
    point:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个非触摸屏上尝试这个，只有一个绿色点会追踪触摸点：
- en: The source code can be found on the Git repository under the `Chapter02-2a` directory,
    in the `cp2` branch.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-2a` 目录下的 `cp2` 分支中找到。
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see this when you run it on a non-touchscreen:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在非触摸屏上运行它时，你应该看到这个：
- en: '![](img/12f55c55-7461-43af-afd1-543b80a5696c.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12f55c55-7461-43af-afd1-543b80a5696c.png)'
- en: Notice the `PropertyAnimation`? We'll get to that soon; keep reading.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `PropertyAnimation` 吗？我们很快就会涉及到它；继续阅读。
- en: Positioning
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位
- en: With the myriad of different mobile phones and embedded device sizes currently
    available, the dynamic positioning of elements becomes more important. You may
    not necessarily want things placed randomly on the screen. If you have a great-looking
    layout on a high-DPI iPhone, it may look completely different on a small Android
    device, with images covering half of the screen. Automatic layouts in QML are
    called positioners.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 目前可用的各种不同尺寸的手机和嵌入式设备使得元素的动态定位变得更加重要。你可能不希望事物随机地放置在屏幕上。如果你在具有高 DPI 的 iPhone 上有一个看起来很棒的布局，它可能在小型的
    Android 设备上看起来完全不同，图像覆盖了屏幕的一半。QML 中的自动布局被称为定位器。
- en: Mobile and embedded devices come with a variety of screen sizes. We can better
    target the size variance by using dynamic layouts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 移动和嵌入式设备具有各种屏幕尺寸。我们可以通过使用动态布局来更好地针对尺寸变化。
- en: Layouts
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'These are the positioning elements that arrange the layout of the different
    items that you may want to use:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于排列你可能想要使用的不同项目的定位元素：
- en: '`Grid`: Positions items in a grid'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid`：在网格中定位项目'
- en: '`Column`: Positions items vertically'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column`：垂直定位项目'
- en: '`Row`: Positions items horizontally'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Row`：水平定位项目'
- en: '`Flow`: Positions items side by side with wrapping'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flow`：以换行方式横向定位项目'
- en: 'Additionally, there are also the following items:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有以下项目：
- en: '`GridLayout`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridLayout`'
- en: '`ColumnLayout`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColumnLayout`'
- en: '`RowLayout`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RowLayout`'
- en: '`StackLayout`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackLayout`'
- en: The difference between the `Grid` and the `GridLayout` elements are that the
    layouts are more dynamic in terms of resizing. Layouts have attached properties,
    so you can easily specify aspects of the layout, such as `minimumWidth`, the number
    of columns, or the number of rows. The item can be made to fill itself to the
    grid or fixed width.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid` 和 `GridLayout` 元素之间的区别在于，布局在调整大小方面更加动态。布局有附加属性，因此你可以轻松指定布局的各个方面，例如 `minimumWidth`、列数或行数。项目可以被设置为填充到网格或固定宽度。'
- en: You can also use *rigid* layouts which are more like tables. Let's look at using
    layouts that are slight less dynamic and use static sizing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用更像表格的“刚性”布局。让我们看看使用稍微不那么动态的布局和使用静态尺寸。
- en: Rigid layouts
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚性布局
- en: I use the word *rigid* because they are less dynamic than all the layout items.
    The cell sizes are fixed and based on a percentage of the space where they are
    contained. They cannot span across rows or columns to fill the next column or
    row. Take this code, for example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用“刚性”这个词，因为它们比所有布局元素都缺乏动态性。单元格大小是固定的，并且基于它们所包含的空间的百分比。它们不能跨越行或列来填充下一个列或行。以这个代码为例。
- en: 'It has no layouts at all, and, when you run it, all the elements get squished
    together on top of one another:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有任何布局，当你运行它时，所有元素都会挤在一起：
- en: The source code can be found on the Git repository under the `Chapter02-3` directory,
    in the `cp2` branch.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-3` 目录下的 `cp2` 分支中找到。
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see in the following screenshot, all of the elements are bunched
    up on top of each other without positioning:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的屏幕截图中所看到的，所有元素都堆叠在一起，没有进行定位：
- en: '![](img/0464a11d-5686-4af5-9f0a-75419a45019b.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0464a11d-5686-4af5-9f0a-75419a45019b.png)'
- en: This was probably not what the design team had dreamed up. Unless, of course,
    they did, and then wanted to use a `PropertyAnimation` value to animate the elements
    moving to their proper layout positions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是设计团队所梦想的。除非，当然，他们确实这样做了，并且想要使用一个 `PropertyAnimation` 值来动画化元素移动到它们正确的布局位置。
- en: 'What happens when we add a `Column` QML element? Examine the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加一个 `Column` QML 元素时会发生什么？检查以下代码：
- en: The source code can be found on the Git repository under the `Chapter02-3a` directory,
    in the `cp2` branch.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-3a` 目录下的 `cp2` 分支中找到。
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you build this example, the layout looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建此示例时，布局看起来像这样：
- en: '![](img/299cad9c-5b13-4d19-bfc4-651581471b0c.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/299cad9c-5b13-4d19-bfc4-651581471b0c.png)'
- en: That's more like what the designer's mock-ups look like! (I know; cheap designers.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是设计师的草图的样子！（我知道；便宜的设计师。）
- en: '`Flow` is another layout item we can use.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow` 是我们可以使用的另一个布局项。'
- en: The source code can be found on the Git repository under the `Chapter02-3b`directory,
    in the `cp2` branch.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-3b` 目录下的 `cp2` 分支中找到。
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, from our preceding code, change `Column` to `Flow`, add some anchor items,
    and build, then run on a simulator to get a feel for how the `Flow` item works
    on a small screen:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从我们前面的代码中，将 `Column` 改为 `Flow`，添加一些锚定项目，然后在模拟器上构建并运行，以了解 `Flow` 项目在小屏幕上的工作方式：
- en: '![](img/897f3421-5af1-49b5-8b05-eab237eb16a7.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/897f3421-5af1-49b5-8b05-eab237eb16a7.png)'
- en: The `Flow` type will wrap its contents around if needed, and, indeed, it has
    wrapped here on the last `Text` element. If this were to be re-oriented to the
    landscape orientation or on a tablet, there would be no need to wrap, and all
    of these elements would be on one row at the top.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow` 类型在需要时将围绕其内容进行包装，实际上，它已经在最后一个 `Text` 元素上进行了包装。如果将其重新调整为横向或平板电脑方向，则不需要包装，所有这些元素都将位于顶部的一行中。'
- en: Dynamic layout
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态布局
- en: 'Instead of using a `Grid` element to lay out items, there is also `GridLayout`,
    which can be used to customize the layout. In terms of targeting mobile and embedded
    devices that come with different screen sizes and device orientations, it is probably
    better to use `GridLayout`, `RowLayout`, and `ColumnLayout`. Using these, you
    will gain the ability to use its attached properties. Here is a list of attached
    properties you can use:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `Grid` 元素来布局项目外，还有 `GridLayout`，它可以用来自定义布局。在针对具有不同屏幕尺寸和设备方向的移动和嵌入式设备时，可能最好使用
    `GridLayout`、`RowLayout` 和 `ColumnLayout`。使用这些布局，你将能够使用其附加属性。以下是可以使用的附加属性列表：
- en: '| `Layout.alignment`  | A `Qt.Alignment` value specifying alignment of item
    within the cell |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.alignment`  | 一个 `Qt.Alignment` 值，指定单元格内项目的对齐方式 |'
- en: '| `Layout.bottomMargin`  | Bottom margin of space |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.bottomMargin`  | 空间底部边距 |'
- en: '| `Layout.column`  | Specifies column position |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.column`  | 指定列位置 |'
- en: '| `Layout.columnSpan`  | How many columns to spreads out to |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.columnSpan`  | 展开到多少列 |'
- en: '| `Layout.fillHeight`  | If `true`, item fills to the height |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.fillHeight`  | 如果为 `true`，则项目填充到高度 |'
- en: '| `Layout.fillWidth` | If `true`, item fills to the width |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.fillWidth` | 如果为 `true`，则项目填充到宽度 |'
- en: '| `Layout.leftMargin` | Left margin of space |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.leftMargin` | 空间左侧边距 |'
- en: '| `Layout.margins ` | All margins of space |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.margins ` | 空间的所有边距 |'
- en: '| `Layout.maximumHeight ` | Maximum height of item |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.maximumHeight ` | 项目最大高度 |'
- en: '| `Layout.maximumWidth ` | Maximum width of item |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.maximumWidth ` | 项目最大宽度 |'
- en: '| `Layout.minimumHeight` | Minimum height of item |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.minimumHeight` | 项目最小高度 |'
- en: '| `Layout.minimumWidth` | Minimum width of item |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.minimumWidth` | 项目最小宽度 |'
- en: '| `Layout.preferredHeight` | Preferred height of item |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.preferredHeight` | 项目首选高度 |'
- en: '| `Layout.preferredWidth` | Preferred width of item |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.preferredWidth` | 项目首选宽度 |'
- en: '| `Layout.rightMargin`  | Right margin of space |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.rightMargin`  | 空间右侧边距 |'
- en: '| `Layout.row` | Specifies row position |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.row` | 指定行位置 |'
- en: '| `Layout.rowSpan`  | How many rows to spread out to |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.rowSpan`  | 展开到多少行 |'
- en: '| `Layout.topMargin`  | Top margin of space |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `Layout.topMargin`  | 空间顶部边距 |'
- en: 'In this code, we use `GridLayout` to position the three `Text` items. The first
    `Text` item will span, or fill, two rows so that the second `Text` will be in
    the second row:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用 `GridLayout` 来定位三个 `Text` 元素。第一个 `Text` 元素将跨越或填充两行，以便第二个 `Text` 元素位于第二行：
- en: The source code can be found on the Git repository under the `Chapter02-3c` directory,
    in the `cp2` branch.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-3c` 目录下的 `cp2` 分支中找到。
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Positioning is a way to get dynamically changing applications and allow them
    to work on various devices without having to change the code. `GridLayout` works
    much like a layout, but with expanded capabilities.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 定位是一种获取动态变化的应用程序并允许它们在各种设备上工作而不必更改代码的方法。`GridLayout` 工作方式类似于布局，但具有更强大的功能。
- en: Let's take a look at how we can dynamically position these components using
    `Anchors`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`锚点`动态定位这些组件。
- en: Anchors
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锚点
- en: '`Anchors` are related to positioning, and are a way to position elements relative
    to each other. They are a way to dynamically position UI elements and layouts.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`锚点`与定位相关，是相对于彼此定位元素的一种方式。它们是动态定位UI元素和布局的一种方法。'
- en: 'They use the following points of contact:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它们使用以下接触点：
- en: '`left`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`'
- en: '`right`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`'
- en: '`top`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`bottom`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`'
- en: '`horizontalCenter`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`horizontalCenter`'
- en: '`verticalCenter`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verticalCenter`'
- en: 'Take, for example, two images; you can put them together like a puzzle by specifying
    anchor positions:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以两个图像为例；你可以通过指定锚点位置将它们组合在一起，就像拼图一样：
- en: '[PRE12]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will position the left side of `image2` at the right side of `image1`.
    If you were to add `anchors.top: parent.top` to `image1`, both of these items
    would then be positioned relative to the top of the parent position. If the parent
    was a top-level item, they would be placed at the top of the screen.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '这将使`image2`的左侧与`image1`的右侧对齐。如果你给`image1`添加`anchors.top: parent.top`，这两个项目就会相对于父元素的顶部位置进行定位。如果父元素是顶级元素，它们就会被放置在屏幕顶部。'
- en: Anchors are a way to achieve columns, rows, and grids of components that are
    relative to some other component. You can anchor items diagonally and anchor them
    apart from each other, among other things.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点是一种实现相对于其他组件的列、行和网格组件的方式。你可以将项目对角锚定，也可以将它们彼此分开，等等。
- en: For example, the `anchor` property of `Rectangle`, called `fill`, is a special
    term meaning top, bottom, left, and right, and is bound to its parent. This means
    that it will fill itself to the size of its parent.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Rectangle`的`anchor`属性，称为`fill`，是一个特殊术语，表示顶部、底部、左侧和右侧，并且绑定到其父元素上。这意味着它将填充到父元素的大小。
- en: Using `anchors.top` indicates an anchor point for the top of the element, meaning
    that it will be bound to the parent component's top position. For example, a `Text` component
    will sit above of the `Rectangle` component.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`anchors.top`表示元素的顶部锚点，这意味着它将绑定到父组件的顶部位置。例如，一个`Text`组件将位于`Rectangle`组件之上。
- en: To get a component such as `Text` to be centered horizontally, we use the `anchor.horizontal` property
    and bind it with the `parent.horizontalCenter` positional property.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`Text`组件水平居中，我们使用`anchor.horizontal`属性并将其绑定到`parent.horizontalCenter`位置属性。
- en: 'Here, we anchor the `Text` label to the top center of the `Rectangle` label,
    itself anchored to `fill` its parent, which is the `Window`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`Text`标签锚定到`Rectangle`标签的顶部中心，而`Rectangle`标签本身锚定到`fill`其父元素，即`Window`：
- en: '[PRE13]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The source code can be found on the Git repository under the `Chapter02` directory,
    in the `cp2` branch.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter02`目录下的`cp2`分支中找到。
- en: The `Window` component was provided by the Qt Quick app wizard and is not visible
    by default, so the wizard set the `visible` property to `true` as we need see
    it. We will use `Window` as the parent for the `Rectangle` component. Our `Rectangle` component
    will provide an area for our `Text` component, which is a simple label type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window`组件是由Qt Quick应用程序向导提供的，默认情况下不可见，因此向导将`visible`属性设置为`true`，因为我们需要看到它。我们将使用`Window`作为`Rectangle`组件的父元素。我们的`Rectangle`组件将为`Text`组件提供一个区域，这是一个简单的标签类型。'
- en: 'Each component has its own properties to fiddle with. By fiddling, I mean binding.
    For instance, the `color: "purple"` line is binding the color referenced as `"purple"` to
    the `color` property of the `Text` element. These bindings do not have to be static;
    they can be dynamically changed, and the property''s value that they are bound
    to changes as well. This value binding will persist until the property is written
    with another value.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '每个组件都有自己的属性可以进行绑定。这里的绑定指的是将属性绑定到元素上。例如，`color: "purple"`这一行将颜色`"purple"`绑定到了`Text`元素的`color`属性上。这些绑定不必是静态的；它们可以动态更改，并且它们所绑定的属性值也会随之改变。这种值绑定将一直持续到属性被赋予另一个值。'
- en: 'The background of this application is boring. How about we add a gradient there?
    Under the closing bracket for the `Text` component, but still within the `Rectangle`, add
    this gradient. `GradientStop` is a way to specify a color at a certain point in
    the gradient. The `position` property is a percent fraction point from zero to
    one, corresponding to where the color should start. The gradient will fill in
    the gap in between:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的背景很无聊。我们何不在那里添加一个渐变效果？在 `Text` 组件的关闭括号下，但仍在 `Rectangle` 内部，添加这个渐变。`GradientStop`
    是在渐变中指定某个点颜色的方式。`position` 属性是从零到一的百分比分数点，对应于颜色应该开始的位置。渐变将填充中间的空白：
- en: '[PRE14]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The source code can be found on the Git repository under the `Chapter02-1` directory,
    in the `cp2` branch.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-1` 目录下的 `cp2` 分支中找到。
- en: 'As you can see, the gradient starts with the green color at the top, smoothly
    blends to purple, then yellow, and finishes at black:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，渐变从顶部的绿色开始，平滑地过渡到紫色，然后是黄色，最后结束于黑色：
- en: '![](img/4eb99784-f4a0-4648-b9b0-eb9410b832c1.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4eb99784-f4a0-4648-b9b0-eb9410b832c1.png)'
- en: Easy peasy, lemon squeezy!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 简单易行，轻松愉快！
- en: Layouts and anchors are important to be able to control the UIs. They provide
    an easy way to deal with differences in display size and orientation changes on
    hundreds of different devices with different screen sizes. You could have a QML
    file work on all displays, although it is recommended to use different layouts
    for extremely different devices. An application could work fine on a tablet, or
    even a phone, but try to place it on a watch or other embedded device, and you
    will run into trouble accessing many details that your users can use.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 布局和锚点对于能够控制 UI 非常重要。它们提供了一种简单的方法来处理显示尺寸的差异和在不同屏幕尺寸的数百种不同设备上的方向变化。您可以让一个 QML
    文件在所有显示设备上工作，尽管建议为极端不同的设备使用不同的布局。一个应用程序可以在平板电脑上运行良好，甚至可以在手机上运行，但尝试将其放置在手表或其他嵌入式设备上，您将遇到许多用户可以使用但无法访问的细节。
- en: Qt Quick has many building blocks to create useful applications on any device.
    What happens when you don't want to create all the UI elements yourself? That
    is where Qt Quick Controls come into play.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 有许多构建块，可以在任何设备上创建有用的应用程序。当您不想自己创建所有 UI 元素时会发生什么？这就是 Qt Quick Controls
    发挥作用的地方。
- en: Qt Quick Controls 2 button, button, who's got the button?
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick Controls 2 按钮，按钮，谁有按钮？
- en: For a while in the life of Qt Quick, there were only basic components, such
    as `Rectangle` and `Text`. Developers had to create their own implementations
    of buttons, dials, and just about every common UI item. As it matured, it also
    grew elements such as `Window` and even `Sensor` elements. There were always rumblings
    about having a set of common UI elements available. Eventually, common UI elements
    were released.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Quick 生命周期的某个阶段，只有一些基本组件，如 `Rectangle` 和 `Text`。开发者必须创建自己的按钮、旋钮以及几乎所有常见
    UI 元素的实现。随着其成熟，它还增加了 `Window` 和甚至 `Sensor` 元素。一直有关于提供一组常见 UI 元素的讨论。最终，常见的 UI 元素被发布了。
- en: Spotlight on Qt Quick Controls. No more having to create your own buttons and
    other components, yay! And developers rejoiced!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 关注 Qt Quick Controls。不再需要自己创建按钮和其他组件，太好了！开发者们也为此欢呼！
- en: Then, they found a better way to do things and released Qt Quick Controls 2!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，他们找到了更好的做事方式，并发布了 Qt Quick Controls 2！
- en: Qt Quick Controls comes in two versions, Qt Quick Controls and Qt Quick Controls
    2\. Qt Quick Controls (the original one) has been depreciated by Qt Quick Controls
    2\. Any new use of these components should use Qt Quick Controls 2.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick Controls 有两个版本，Qt Quick Controls 和 Qt Quick Controls 2。Qt Quick Controls（原始版本）已被
    Qt Quick Controls 2 弃用。任何新使用这些组件的情况都应该使用 Qt Quick Controls 2。
- en: 'You can access all kinds of common UI elements, including the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问各种常见的 UI 元素，包括以下内容：
- en: '`Buttons`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮`'
- en: '`Containers`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`容器`'
- en: '`Input`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输入`'
- en: '`Menu`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`菜单`'
- en: '`Radio buttons`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`单选按钮`'
- en: '`Progress bar`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`进度条`'
- en: '`Popups`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`弹出窗口`'
- en: Let's examine a simple Qt Quick Controls 2 example.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个简单的 Qt Quick Controls 2 示例。
- en: 'An `ApplicationWindow` has attached `menuBar`, `header`, and `footer` properties
    that you can use to add whatever you need to them. Since an `ApplicationWindow`
    is not visible by default, we almost always need to add `visible: true`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationWindow` 有附加的 `menuBar`、`header` 和 `footer` 属性，您可以使用它们添加所需的内容。由于
    `ApplicationWindow` 默认不可见，我们几乎总是需要添加 `visible: true`。'
- en: Here, we will add a traditional menu with `TextField` in the header.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在页眉中添加一个带有 `TextField` 的传统菜单。
- en: 'The menu has an `onTriggered` signal, which is used here to run the `open()`
    function of `MessageDialog`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单有一个 `onTriggered` 信号，在这里用于运行 `MessageDialog` 的 `open()` 函数：
- en: The source code can be found on the Git repository under the `Chapter02-4` directory,
    in the `cp2` branch.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-4` 目录下找到，位于 `cp2` 分支。
- en: '[PRE15]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s what our code would result in:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的代码将产生的结果：
- en: '![](img/550a8d92-202c-4a7d-a8f6-93b153a008c9.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/550a8d92-202c-4a7d-a8f6-93b153a008c9.png)'
- en: Oooooh – fancy!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦 – 真是太棒了！
- en: Qt Quick Controls 2 has different styles to choose from – `Default`, `Fusion`,
    `Imagine`, `Material`, and `Universal`. This can be set in the C++ backend as `QQuickStyle::setStyle("Fusion");`. I
    presume you do have a C++ backend, right?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick Controls 2 提供了多种样式供选择 – `默认`, `融合`, `想象`, `材料`, 和 `通用`。这可以在 C++ 后端通过
    `QQuickStyle::setStyle("Fusion");` 来设置。我猜你确实有一个 C++ 后端，对吧？
- en: 'Views that can come in handy on mobile and embedded devices are as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在移动和嵌入式设备上可能会很有用的视图：
- en: '`ScrollView`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollView`'
- en: '`StackView`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackView`'
- en: '`SwipeView`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwipeView`'
- en: These can be helpful on small screens, as they provide a way to easily view
    and access several pages without too much hassle. A `Drawer` element is also handy
    and can provide a way to implement a menu or a toolbar that sticks to the side.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在小屏幕上可能很有帮助，因为它们提供了一种轻松查看和访问多个页面的方式，而无需太多麻烦。`Drawer` 元素也很方便，可以提供一种实现侧边菜单或工具栏的方式。
- en: Buttons are awesome, and Qt Quick Controls 2 has buttons. It even has the `RoundButton`
    component, as well as icons for the buttons! Before Qt Quick Controls, we had
    to roll these up ourselves. At the same time, it is nice that we can implement
    these things to do what we need with little effort. And now with even less effort!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮很棒，Qt Quick Controls 2 也有按钮。它甚至有 `RoundButton` 组件，以及按钮的图标！在 Qt Quick Controls
    之前，我们不得不自己实现这些功能。同时，很棒的是我们可以用很少的努力来实现这些功能，现在甚至更少了！
- en: Let's put some of these to the test and expand upon our last example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一些这些功能，并在此基础上扩展我们的上一个示例。
- en: 'I like `SwipeView`, so let''s use that, with two `Page` elements as children
    of `SwipeView`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 `SwipeView`，所以让我们使用它，将两个 `Page` 元素作为 `SwipeView` 的子元素：
- en: The source code can be found on the Git repository under the `Chapter02-5` directory,
    in the `cp2` branch.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-5` 目录下找到，位于 `cp2` 分支。
- en: '[PRE16]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I think that a `PageIndicator` at the bottom to indicate which page we are on
    gives the user some visual feedback for navigation. We tie in `PageIndicator` by
    binding the `count` of `SwipeView` and `currentIndex` properties to its properties
    of the same name. How convenient!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在底部添加一个 `PageIndicator` 来指示我们当前所在的页面，可以为用户导航提供一些视觉反馈。我们通过将 `SwipeView` 的
    `count` 和 `currentIndex` 属性绑定到同名属性上来整合 `PageIndicator`。多么方便啊！
- en: Instead of `PageIndicator`, we could just as easily use `TabBar`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用 `PageIndicator` 一样轻松地使用 `TabBar`。
- en: Customizing
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义
- en: 'You can customize the look and feel of just about every Qt Quick Control 2
    component. You can override different properties of the controls, such as `background`.
    In the previous example code, we customized the `Page` header. Here, we override
    the background to a button, add our own `Rectangle`, color it, give it a border
    with a contrasting color, and make it rounded at the ends by using the `radius`
    property. Here''s how it would work:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以自定义每个 Qt Quick Control 2 组件的外观和感觉。你可以覆盖控件的不同属性，例如 `background`。在前面的示例代码中，我们自定义了
    `Page` 标题。在这里，我们覆盖背景为按钮，添加我们自己的 `Rectangle`，上色，用对比色添加边框，并通过 `radius` 属性使其两端圆润。下面是如何工作的：
- en: The source code can be found on the Git repository under the `Chapter02-5` directory,
    in the `cp2` branch.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-5` 目录下找到，位于 `cp2` 分支。
- en: '[PRE17]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/bc0f81cf-6c19-4d18-acee-a3c87f2f2b67.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc0f81cf-6c19-4d18-acee-a3c87f2f2b67.png)'
- en: Customizing is easy with Qt Quick. It was built with customizing in mind. The
    ways are endless. Nearly all the Qt Quick Controls 2 elements have visual elements
    that can be customized including most of the background and content items, although
    not all.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt Quick 进行自定义非常简单。它是为了自定义而构建的。方法多种多样。几乎所有的 Qt Quick Controls 2 元素都有可自定义的视觉元素，包括大多数背景和内容项，尽管并非全部。
- en: These controls seem to be best on a desktop, but they can be customized to work
    well on mobile and embedded devices. The `ScrollBar` property of `ScrollView` can
    be made larger in width on touchscreens.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控件在桌面电脑上似乎效果最好，但它们可以被自定义以在移动设备和嵌入式设备上良好工作。`ScrollView` 的 `ScrollBar` 属性可以在触摸屏上增加宽度。
- en: Show your data – Qt Data Visualization and Qt Charts
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示你的数据 – Qt 数据可视化和 Qt 图表
- en: Qt Quick has a convenient way to show data of all kinds. The two modules, Qt
    Data Visualization and Qt Charts, can both supply integral UI elements. They are
    similar, except Qt Data Visualization displays data in 3D.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 提供了一种方便的方式来展示各种类型的数据。两个模块，Qt 数据可视化和 Qt Charts，都可以提供完整的 UI 元素。它们很相似，但
    Qt 数据可视化以 3D 形式展示数据。
- en: Qt Charts
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Charts
- en: Qt Charts shows 2D graphs and uses the Graphics View framework.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Charts 展示二维图表并使用图形视图框架。
- en: 'It adds the following chart types:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 它添加了以下图表类型：
- en: Area
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面积图
- en: Bar
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柱状图
- en: Box-and-whiskers
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箱线图
- en: Candlestick
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K线图
- en: 'Line: a simple line chart'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线形图：简单的线形图
- en: 'Pie: pie slices'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼图：饼图切片
- en: 'Polar: a circular line'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极坐标：圆形线
- en: 'Scatter: a collection of points'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图：一组点集
- en: 'Spline: a line chart with curved points'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样条图：带有曲线点的线形图
- en: 'The following example from Qt shows a few different charts that are available:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 Qt 中提供的示例，展示了几个可用的不同图表：
- en: '![](img/386351c0-be88-4103-830c-265c626aafb0.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图表示例](img/386351c0-be88-4103-830c-265c626aafb0.png)'
- en: 'Each graph or chart has at least one axis and can have the following types:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图表或图形至少有一个轴，可以有以下类型：
- en: Bar axis
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柱状图轴
- en: Category
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别
- en: Date-time
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期时间
- en: Logarithmic value
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数值
- en: Value
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值
- en: Qt Charts requires a `QApplication` instance. If you use the Qt Creator wizard
    to create your app, it uses a `QGuiApplication` instance by default. You will
    need to replace the `QGuiApplication` instance in `main.cpp` to `QApplication`,
    and also change the `includes` file.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Charts 需要一个 `QApplication` 实例。如果您使用 Qt Creator 向导创建应用程序，它默认使用 `QGuiApplication`
    实例。您需要将 `main.cpp` 中的 `QGuiApplication` 实例替换为 `QApplication`，并更改 `includes` 文件。
- en: You can use grid lines, shades, and tick marks on the axis, which can also be
    shown in these charts.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在轴上使用网格线、阴影和刻度标记，这些也可以在这些图表中显示。
- en: Let's look at how to create a simple BarChart.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个简单的柱状图。
- en: The source code can be found on the Git repository under the `Chapter02-6` directory,
    in the `cp2` branch.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-6` 目录下的 `cp2` 分支中找到。
- en: '[PRE18]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'See how nice the charts look? Have a look:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这些图表看起来有多棒？来看看：
- en: '![](img/8376dc5b-21cf-4c0d-a654-25cde7f49cda.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图表示例](img/8376dc5b-21cf-4c0d-a654-25cde7f49cda.png)'
- en: Qt Data Visualization
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 数据可视化
- en: Qt Data Visualization is similar to Qt Charts but presents data in 3D form.
    It can be downloaded through Qt Creator's Maintenance Tool app. It is available
    for use with Qt Widget and Qt Quick. We will be working with the Qt Quick version.
    It uses OpenGL to present 3D graphs of data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 数据可视化类似于 Qt Charts，但以 3D 形式展示数据。它可以通过 Qt Creator 的维护工具应用程序下载。它与 Qt Widget
    和 Qt Quick 兼容。我们将使用 Qt Quick 版本。它使用 OpenGL 来展示数据的 3D 图形。
- en: 'Since we are targeting mobile phones and embedded devices, we talk about using
    OpenGL ES2\. There are some features of Qt Data Visualization that do not work
    with OpenGl ES2, which is what you will find on mobile phones:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们针对的是移动电话和嵌入式设备，我们讨论使用 OpenGL ES2。Qt 数据可视化的一些功能与 OpenGl ES2 不兼容，这是您在移动电话上会发现的情况：
- en: Antialiasing
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抗锯齿
- en: Flat shading
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平滑着色
- en: Shadows
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阴影
- en: Volumetric objects that use 3D textures
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 3D 纹理的体积对象
- en: Let's try using a `Bars3D` with data from the total amount of rain in certain
    Australian cities used in the previous example.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用来自之前示例中使用的澳大利亚某些城市总降雨量的 `Bars3D` 数据。
- en: I set the theme to `Theme3D.ThemeQt`, which is a green-based theme. Add a few
    customizations such as font size to be able to see the content better on small
    mobile displays.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我将主题设置为 `Theme3D.ThemeQt`，这是一个基于绿色的主题。添加一些自定义，如字体大小，以便在小型移动显示屏上更好地查看内容。
- en: '`Bar3DSeries` will manage the visual elements such as labels for rows, columns,
    and the data, which here is the total rain amount for that year. `ItemModelBarDataProxy`
    is the proxy for displaying the data. The model data here is a `ListModel` containing
    `ListElements` of cities rainfall data for the previous three years. We will use
    the same data from the previous Qt Charts example so you can compare the differences
    in the way the bar charts display their data:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bar3DSeries` 将管理诸如行、列和数据（此处为该年的总降雨量）的标签等视觉元素。`ItemModelBarDataProxy` 是显示数据的代理。此处模型数据是一个包含前三年城市降雨数据的
    `ListModel`。我们将使用与之前 Qt Charts 示例中相同的数据，以便您可以比较柱状图显示数据的方式的差异：'
- en: The source code can be found on the Git repository under the `Chapter02-7` directory,
    in the `cp2` branch.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter02-7` 目录下的 `cp2` 分支中找到。
- en: '[PRE19]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can run this on a touchscreen device, and then move the chart around in
    3D!:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在触摸屏设备上运行此代码，然后可以在 3D 中移动图表：
- en: '![](img/70a2d639-c4f5-470f-bdd7-58ebf20a5806.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图表示例](img/70a2d639-c4f5-470f-bdd7-58ebf20a5806.png)'
- en: You can grab the graph and spin it around to see the data from different perspectives.
    You can zoom in and back out, as well.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以抓取图表并旋转它以从不同的角度查看数据。你还可以放大和缩小。
- en: The `QtDataVisualization` module also has scatter and surface graphs that show
    data in 3D.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtDataVisualization`模块还具有显示3D数据的散点图和表面图。'
- en: Animate it!
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它动起来！
- en: 'This is where it gets gloriously complicated. There are various types of animations:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它变得复杂的地方。有各种类型的动画：
- en: '`ParallelAnimation`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParallelAnimation`'
- en: '`SmoothedAnimation`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SmoothedAnimation`'
- en: '`PauseAnimation`'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PauseAnimation`'
- en: '`SequentialAnimation`'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SequentialAnimation`'
- en: Additionally, `PropertyAction` and `ScriptAction` can be used. A `PropertyAction` is
    a change to any property that happens without an animation. We learned about `ScriptAction` in
    the last section on *States*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以使用`PropertyAction`和`ScriptAction`。`PropertyAction`是指不涉及动画的任何属性的变化。我们在上一节关于*状态*的部分学习了`ScriptAction`。
- en: 'There are also animation types that operate on various values:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的动画，它们操作各种值：
- en: '`AnchorAnimation`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnchorAnimation`'
- en: '`ColorAnimation`'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorAnimation`'
- en: '`NumberAnimation`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberAnimation`'
- en: '`OpacityAnimator`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpacityAnimator`'
- en: '`PathAnimation`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathAnimation`'
- en: '`ParentAnimation`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParentAnimation`'
- en: '`PropertyAnimation`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PropertyAnimation`'
- en: '`RotationAnimation`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotationAnimation`'
- en: '`SpringAnimation`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpringAnimation`'
- en: '`Vector3DAnimation`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3DAnimation`'
- en: A `Behavior` can be used to specify an animation for a property change.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Behavior`来指定属性变化时的动画。
- en: Let's look at how some of these can be used.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些是如何被使用的。
- en: Transitions
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: Transitions and states are explicitly tied together. A `Transition` animation
    happens when a `State` change occurs.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 转换和状态被明确地联系在一起。当状态发生变化时，会发生`Transition`动画。
- en: 'A `State` change can handle different kinds of changes:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 状态变化可以处理不同类型的更改：
- en: '`AnchorChanges`: Changes to anchor layouts'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnchorChanges`: 锚定布局的变化'
- en: '`ParentChanges`: Changes to parenting (as in reparenting)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParentChanges`: 父亲关系的变化（例如重新分配）'
- en: '`PropertyChanges`: Changes to the target''s properties'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PropertyChanges`: 目标属性的变化'
- en: You can even run JavaScript on `State` changes using `StateChangeScript` and
    `ScriptAction`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用`StateChangeScript`和`ScriptAction`在状态变化上运行JavaScript。
- en: 'To define different `states`, an element has a `states` array of `State` elements
    that can be defined. We will add a `PropertyChanges`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义不同的`states`，一个元素有一个`states`数组，其中可以定义`State`元素。我们将添加一个`PropertyChanges`：
- en: '[PRE20]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Target properties can be just about anything—`opacity`, `position`, `color`,
    `width`, or `height`. If an element has a changeable property, the chances are
    that you can animate it in a `State` change.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 目标属性可以是几乎任何东西——`opacity`、`position`、`color`、`width`或`height`。如果一个元素具有可变属性，那么你很可能可以在状态变化中对其动画化。
- en: 'As I mentioned before, to run a script in a `State` change, you can define
    a `StateChangeScript` in the `State` element that you want it to run in. Here,
    we simply output some logging text:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，要在状态变化中运行脚本，你可以在你想要运行脚本的`State`元素中定义一个`StateChangeScript`。在这里，我们只是输出一些日志文本：
- en: '[PRE21]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Just imagine the possibilities! We haven't even presented animations! We will
    go there next.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下可能性！我们甚至还没有介绍动画！我们将在下一节介绍。
- en: Animation
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: Animation can spice up your apps in wonderful ways. Qt Quick makes it almost
    trivial to animate different aspects of your application. At the same time, it
    allows you to customize them into unique and more complicated animations.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 动画可以用奇妙的方式为你的应用增添色彩。Qt Quick使得几乎可以轻松地动画化应用的不同方面。同时，它允许你将它们定制为独特且更复杂的动画。
- en: PropertyAnimation
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PropertyAnimation
- en: '`PropertyAnimation` animates an item''s changeable property. Typically, this
    is x or y color, or it can be some other property of any item:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyAnimation`动画化一个项目的可变属性。通常，这是x或y颜色，或者可以是任何项目的其他属性：'
- en: '[PRE22]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Behavior` specifier implies that when the `activeFocus` is on `myItem`,
    the `color` will change to `green`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`Behavior`指定器意味着当`activeFocus`在`myItem`上时，颜色将变为绿色。'
- en: NumberAnimation
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumberAnimation
- en: '`NumberAnimation` derives from `PropertyAnimation`, but only works on properties
    that have a `qreal` changeable value:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberAnimation`从`PropertyAnimation`派生，但仅适用于具有可变`qreal`值的属性：'
- en: '[PRE23]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will move the `myOtherItem` element's `y` position to 65 over a 250-microsecond
    period of time.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在250微秒的时间内将`myOtherItem`元素的`y`位置移动到65。
- en: Some of these animation elements control how other animations are played, including `SequentialAnimation` and `ParallelAnimation`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些动画元素控制其他动画的播放方式，包括`SequentialAnimation`和`ParallelAnimation`。
- en: SequentialAnimation
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SequentialAnimation
- en: '`SequentialAnimation` is an animation that runs other animation types consecutively, one
    after the other, like a numbered procedure:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`SequentialAnimation`是一种连续运行其他动画类型的动画，一个接一个，就像编号的程序：'
- en: '[PRE24]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this instance, the animation that would play first is `ColorAnimation`,
    and, once that is finished, it would play `NumberAnimation`. Move the `myOtherItem` element''s
    `x` property to position `35`, and then move its `y` property to position `65`,
    in two steps:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，首先播放的动画是`ColorAnimation`，一旦完成，就会播放`NumberAnimation`。将`myOtherItem`元素的`x`属性移动到位置`35`，然后将其`y`属性移动到位置`65`，分两步进行：
- en: '![](img/f45daa0e-b695-4a4d-a3a2-42e541872458.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f45daa0e-b695-4a4d-a3a2-42e541872458.png)'
- en: You can use either `on <property>` or `properties` to target a property.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`on <属性>`或`properties`来定位一个属性。
- en: 'Also available is the `when` keyword, which denotes when something can take
    place. It can be used with any property if it evaluates to `true` or `false`,
    such as `when: y > 50`. You could use it, for example, on the `running` property.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，还有`when`关键字，表示何时可以发生某事。如果它评估为`true`或`false`，则可以与任何属性一起使用，例如`when: y > 50`。例如，您可以在`running`属性上使用它。'
- en: ParallelAnimation
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ParallelAnimation
- en: '`ParallelAnimation` plays all its defined animations at the same time, asynchronously:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelAnimation`同时异步播放所有定义的动画：'
- en: '[PRE25]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These are the same animations, but this would perform them at the same time.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相同的动画，但它们会同时执行。
- en: 'It is interesting to note that this animation would move `myOtherItem` to position
    `35` and `65` directly from where the current position is, as if it were one step:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这个动画会直接将`myOtherItem`移动到位置`35`和`65`，就像它是一步一样：
- en: '![](img/5dd76d12-c152-4558-bd01-f58932a46035.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dd76d12-c152-4558-bd01-f58932a46035.png)'
- en: SpringAnimation
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpringAnimation
- en: '`SpringAnimation` animates items with a spring-like motion. It has two properties
    to pay attention to—`spring` and `damping`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpringAnimation`通过弹簧运动来动画化项目。有两个需要注意的属性——`spring`和`damping`：'
- en: '`spring`: A `qreal` value that controls how energetic the bounce is'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring`:一个控制弹跳能量的`qreal`值'
- en: '`damping`:How quickly the bouncing stops'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`damping`:弹跳停止的速度'
- en: '`mass`:Adds a weight to the bounce, so it acts as if there is gravity and weight'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mass`:为弹跳添加重量，使其表现得像有重力和重量'
- en: '`velocity`:Specifies the maximum velocity'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`velocity`:指定最大速度'
- en: '`modulus`: The value at which a value will wrap around to zero'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modulus`:值将环绕到零的值'
- en: '`epsilon`: Amount of rounding to zero'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`epsilon`:四舍五入到零的量'
- en: The source code can be found on the Git repository under the `Chapter02-8` directory,
    in the `cp2` branch.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter02-8`目录下的`cp2`分支中找到。
- en: '[PRE26]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, a red square follows the finger or mouse cursor around, bouncing
    up and down as it goes. When the user clicks on the app, the red square will move
    to position `35` and `65`. A `spring` value of `10` makes it very bouncy, but
    the `mass` of `10` on the `y` axis will cause it to bounce like it has more weight.
    The lower the `damping` value is, the more quickly it will come to rest. Here,
    the `damping` value is much greater on the `x` axis, so it will tend to keep bouncing
    up and down more than side to side.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个红色方块跟随手指或鼠标光标移动，上下弹跳。当用户点击应用时，红色方块会移动到位置`35`和`65`。`spring`值为`10`使其非常弹跳，但`y`轴上的`mass`值为`10`会使它像有更多重量一样弹跳。`damping`值越低，它越快停下来。在这里，`x`轴上的`damping`值要大得多，所以它倾向于比侧向弹跳更多上下弹跳。
- en: Easing
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓动
- en: I should mention easing at this point. Every Qt Quick animation has an `easing` property.
    Easing is a way to specify the speed at which the animation progresses. The default
    `easing` value is `Easing.Linear`. There are 40 different `easing` properties,
    which are probably better seen running in an example than seen here demonstrated
    with graphs.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该在这里提到缓动。每个Qt Quick动画都有一个`easing`属性。缓动是一种指定动画进度速度的方式。默认的`easing`值是`Easing.Linear`。有40种不同的`easing`属性，这些属性最好在示例中运行，而不是在这里用图表展示。
- en: You can see a demonstration of this at my GitHub web server by the magic of
    Qt for WebAssembly at
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过Qt for WebAssembly的魔法在我的GitHub网络服务器上看到这个演示。
- en: '[https://lpotter.github.io/easing/easing.html](https://lpotter.github.io/easing/easing.html).'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://lpotter.github.io/easing/easing.html](https://lpotter.github.io/easing/easing.html).'
- en: Qt for WebAssembly brings Qt apps to the web. Firefox has the fastest WebAssembly
    implementation at the time of writing this book. We will discuss Qt for WebAssembly
    in [Chapter 14](04b4eb0e-2f09-4205-9d2f-ac17ff6a958d.xhtml), *Universal Platform
    for Mobiles and Embedded Devices*.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Qt for WebAssembly 将 Qt 应用程序带到了网页上。在撰写本书时，Firefox 拥有最快的 WebAssembly 实现。我们将在
    [第 14 章](04b4eb0e-2f09-4205-9d2f-ac17ff6a958d.xhtml)，*通用移动和嵌入式设备平台*中讨论 Qt for
    WebAssembly。
- en: SceneGraph
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SceneGraph
- en: Scene Graph is based on OpenGL for Qt Quick. On mobile and embedded devices,
    it is usually OpenGL ES2\. As I mentioned before, Scene Graph caters to manage
    a sizable number of graphics. OpenGL is a huge subject worthy of its own book—in
    fact, tons of books—about OpenGL ES2 programming. I won't go into too much detail
    about it here, but will just mention that OpenGL is available for mobile phones
    and embedded devices, depending on the hardware.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图基于 OpenGL 构建 Qt Quick。在移动和嵌入式设备上，通常是 OpenGL ES2。如前所述，场景图旨在管理大量的图形。OpenGL
    是一个庞大的主题，值得有它自己的书籍——实际上，有成吨的关于 OpenGL ES2 编程的书籍。在这里我不会过多地详细介绍它，但只是提到 OpenGL 可用于移动电话和嵌入式设备，具体取决于硬件。
- en: If you are planning to use Scene Graph, most of the heavy lifting will be done
    in C++. You should already be familiar with how to use C++ and QML together, as
    well as OpenGL ES2\. If not, Qt has great documentation on it.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用场景图，大部分繁重的工作将在 C++ 中完成。你应该已经熟悉如何结合使用 C++ 和 QML，以及 OpenGL ES2。如果不熟悉，Qt
    有关于它的优秀文档。
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Qt Quick is ready-made for using on mobile and embedded devices. From the simple
    building blocks of basic Qt Quick items to 3D data charts, you can write complicated
    animated applications using various data sets and presentations in QML.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 为在移动和嵌入式设备上使用而预先准备。从基本 Qt Quick 项的简单构建块到 3D 数据图表，你可以使用各种数据集和 QML 中的展示来编写复杂的动画应用程序。
- en: You should now be able to use basic components such as `Rectangle` or `Text`
    to create Qt Quick applications that use dynamic variable bindings and signals.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够使用基本组件，如 `Rectangle` 或 `Text`，来创建使用动态变量绑定和信号的 Qt Quick 应用程序。
- en: We also covered how to use `anchors` to position the components visually and
    will be able to accept changing orientations and various screen sizes of target
    devices.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何使用 `anchors` 来视觉定位组件，并能够接受目标设备的改变方向和各种屏幕尺寸。
- en: You are now able to use more conventional-looking components such as ready-made
    `Button`, `Menu` and `ProgressBar` instances, as well as more advanced graphical
    elements such as `PieChart` and `BarChart`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用看起来更传统的组件，例如现成的 `Button`、`Menu` 和 `ProgressBar` 实例，以及更高级的图形元素，如 `PieChart`
    和 `BarChart`。
- en: We also examined using different animation methods available in Qt Quick, such
    as `ProperyAnimation` and `NumberAnimation`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查了 Qt Quick 中可用的不同动画方法，例如 `ProperyAnimation` 和 `NumberAnimation`。
- en: In the next chapter, we will learn about using particles and special graphical
    effects.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用粒子和特殊图形效果。
