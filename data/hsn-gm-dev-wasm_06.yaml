- en: Game Objects and the Game Loop
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏对象和游戏循环
- en: In this chapter, we will begin to put the framework of a game into place. All
    games have **game objects** and a **game loop**. A game loop exists in every game
    ever written. Some tools, such as Unity, do their best to abstract away the game
    loop so that the developer does not necessarily need to know it is there, but
    even in these cases it still is. All games must take some control over the rendering
    capabilities of the operating system or hardware it is running on and draw images
    out to the screen while the game is running. All of the work of the game is done
    within a **big loop**. Game objects can be either an instance of classes in the
    case of **Object-Oriented Programming** (**OOP**) languages such as C++, or in
    the case of procedural languages such as C, they could be loose collections of
    variables or structures. In this chapter, we will be learning how to design a
    game loop and some early versions of our game objects from within C++ compiled
    into **WebAssembly**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建游戏的框架。所有游戏都有**游戏对象**和**游戏循环**。游戏循环存在于每个游戏中。一些工具，比如Unity，尽最大努力抽象出游戏循环，以便开发人员不一定需要知道它的存在，但即使在这些情况下，它仍然存在。所有游戏都必须对操作系统或硬件的渲染能力进行一定的控制，并在游戏运行时向屏幕绘制图像。游戏的所有工作都在一个**大循环**中完成。游戏对象可以是**面向对象编程**（**OOP**）语言（如C++）中的类的实例，也可以是过程式语言（如C）中的松散变量或结构的集合。在本章中，我们将学习如何设计游戏循环，并从C++编译成**WebAssembly**中学习我们游戏对象的早期版本。
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter06-game-object/sprites/` folder from
    the project''s GitHub repository. If you haven''t yet downloaded the GitHub project,
    you can get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在构建中包含几个图像才能使此项目工作。确保您包含了项目的GitHub存储库中的`/Chapter06-game-object/sprites/`文件夹。如果您还没有下载GitHub项目，可以在这里在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Game loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏循环
- en: Object pooling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象池
- en: Player game object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家游戏对象
- en: Enemy game object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人游戏对象
- en: Projectiles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛射物
- en: Understanding the game loop
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解游戏循环
- en: 'A key concept in game design is the game loop. In any game, the code must run
    over and over again, performing a series of tasks such as input, AI, physics,
    and rendering. A game loop might look something like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计中的一个关键概念是游戏循环。在任何游戏中，代码必须一遍又一遍地运行，执行一系列任务，如输入、人工智能、物理和渲染。游戏循环可能看起来像这样：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An SDL/C++ game targeting almost any platform except WebAssembly would have
    a `while` loop, probably located within the `main` function of the C++ code, that
    would exit only when the player exits the game. WebAssembly shares its runtime
    with the JavaScript engine inside your web browser. The JavaScript engine runs
    on a single thread, and Emscripten uses JavaScript **glue code** to take what
    you have done inside SDL within WebAssembly and render that to the HTML canvas
    element. Therefore, we need to use an Emscripten-specific piece of code for our
    game loop:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个针对几乎任何平台的SDL/C++游戏会有一个`while`循环，可能位于C++代码的`main`函数中，只有当玩家退出游戏时才会退出。WebAssembly与您的Web浏览器内部的JavaScript引擎共享运行时。JavaScript引擎在单个线程上运行，Emscripten使用JavaScript的**glue
    code**将您在WebAssembly中的SDL内部所做的工作渲染到HTML画布元素上。因此，我们需要使用一个特定于Emscripten的代码片段来实现我们的游戏循环：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the next few chapters, we will be adding some of these functions to our
    game:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将向我们的游戏中添加一些这些函数：
- en: Game object management
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏对象管理
- en: Collision detection between game objects
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏对象之间的碰撞检测
- en: Particle systems
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子系统
- en: Enemy spaceship AI using a **finite state machine** (**FSM**)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**有限状态机**（**FSM**）的敌人飞船AI
- en: Game camera for tracking our player
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于跟踪玩家的游戏摄像机
- en: Play audio and sound effects
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音频和音效
- en: Game physics
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏物理
- en: User interface
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面
- en: These will be functions called from the game loop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将是从游戏循环中调用的函数。
- en: Writing a basic game loop
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基本游戏循环
- en: To some degree, we already have a simple game loop, although we did not create
    a function called `game_loop` explicitly. We are going to modify our code to have
    a more explicit game loop that will separate the `input`, `move`, and `render`
    functions. At this point, our `main` function becomes an initialization function
    that finishes by using Emscripten to set the game loop. The code for this new
    app is larger than earlier apps. Let's first walk through the code at a high level,
    introducing each section. Then we will walk through each of the individual sections
    of code in detail.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，我们已经有了一个简单的游戏循环，尽管我们没有显式地创建一个名为`game_loop`的函数。我们将修改我们的代码，以便有一个更明确的游戏循环，将分离`input`、`move`和`render`函数。此时，我们的`main`函数变成了一个初始化函数，最后使用Emscripten来设置游戏循环。这个新应用的代码比之前的应用要大。让我们首先以高层次的方式浏览代码，介绍每个部分。然后我们将详细介绍代码的每个部分。
- en: 'We begin the code with our `#include` and `#define` preprocessor macros:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`#include`和`#define`预处理宏开始编写代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the preprocessor macros, we have a few global time variables:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在预处理宏之后，我们有一些全局时间变量：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will then define several SDL-related global variables:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将定义几个与SDL相关的全局变量：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After our SDL global variables, we have a block of keyboard flags:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的SDL全局变量之后，我们有一个键盘标志块：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last global variables track player data:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的全局变量跟踪玩家数据：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have all of our global variables defined, we need two functions
    that rotate the player''s spaceship left and right:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有的全局变量，我们需要两个函数来使玩家的飞船向左和向右旋转：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then have three movement-related functions for our player''s ship. We use
    them to accelerate and decelerate our spaceship, and to capp the velocity of our
    spaceship:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有三个与玩家飞船相关的移动函数。我们使用它们来加速和减速我们的飞船，并限制我们飞船的速度：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `move` function performs the high-level movement of the game objects:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: “move”函数执行游戏对象的高级移动：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `input` function determines the keyboard input states and sets our global
    keyboard flags:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: “input”函数确定键盘输入状态并设置我们的全局键盘标志：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `render` function draws the player''s sprite to the canvas:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “render”函数将玩家的精灵绘制到画布上：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `game_loop` function runs all of our high-level game objects in each frame:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: “game_loop”函数在每一帧中运行我们所有的高级游戏对象：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As always, the `main` function does all of our initialization:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，“main”函数执行所有初始化：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may have noticed that in the preceding code we have added a significant
    number of global variables to define player-specific values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可能已经注意到我们添加了大量全局变量来定义特定于玩家的值：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the *Game objects* section, we will begin to create game objects and move
    these values from global definitions into objects, but, for the time being, having
    them as global variables will work. We are adding the ability to move the player's
    ship around in a way that is similar to the classic arcade game *Asteroids*. In
    the final version of our game, we will have two spaceships fighting in a duel.
    To do this, we will need to keep track of the *x* and *y* coordinates of our ship
    and the ship's rotation; `player_dx` and `player_dy` make up a normalized direction
    vector for our spaceship.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在“游戏对象”部分，我们将开始创建游戏对象并将这些值从全局定义移动到对象中，但是目前，将它们作为全局变量将起作用。我们正在添加移动玩家飞船的能力，这与经典街机游戏“Asteroids”类似。在我们游戏的最终版本中，我们将有两艘太空飞船进行决斗。为此，我们需要跟踪飞船的“x”和“y”坐标以及飞船的旋转；“player_dx”和“player_dy”组成了我们太空飞船的归一化方向向量。
- en: The `player_vx` and `player_vy` variables are the player's current `x` and `y`
    velocities respectively.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “player_vx”和“player_vy”变量分别是玩家当前的“x”和“y”速度。
- en: 'Instead of having the left and right keys move the spaceship left or right
    while they are being held down, we are going to have those keys turn the spaceship
    to the left or the right. To do this, we will have our input function call the
    `rotate_left` and `rotate_right` functions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再让左右键在按住时移动飞船向左或向右，而是让这些键将飞船向左或向右转动。为此，我们的输入函数将调用“rotate_left”和“rotate_right”函数：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the player is turning left, we subtract the `delta_time` variable from the
    player rotation, which is the amount of time in seconds since the last frame rendered.
    The `player_rotation` variable is the player's rotation in radians, where 180
    degrees = π (3.14159…). That means that the player can turn 180 degrees by pressing
    and holding the left or right arrows for about three seconds. We also have to
    correct our rotation if the player's rotation goes below 0 or if the player's
    rotation goes above 2π (360 degrees). If you are not familiar with radians, it
    is an alternative to the system of measuring angles in which there are 360 degrees
    in a circle. Using radians, you think of how far you would have to walk around
    the circumference of a unit circle to get to that angle. A circle with a radius
    of 1 is called a **unit circle**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家正在向左转，我们会从玩家旋转中减去“delta_time”变量，这是自上一帧渲染以来的秒数。 “player_rotation”变量是玩家的弧度旋转，其中180度=π（3.14159…）。这意味着玩家可以通过按住左或右箭头约三秒钟来旋转180度。如果玩家的旋转低于0或玩家的旋转超过2π（360度），我们还必须纠正我们的旋转。如果您不熟悉弧度，它是一种替代的角度测量系统，其中一个圆中有360度。使用弧度，您可以考虑您需要绕单位圆的周长走多远才能到达该角度。半径为1的圆称为**单位圆**。
- en: 'The unit circle is on the left:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单位圆在左侧：
- en: '![](img/8a524c84-989f-42ee-a3bb-07d3d95fa6ef.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a524c84-989f-42ee-a3bb-07d3d95fa6ef.png)'
- en: A unit circle and a circle with a radius of 2
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单位圆和半径为2的圆
- en: The formula for the diameter of a circle is 2πr (in our code `2 * PI * radius`).
    So, 2π in radians is the same as saying 360 degrees. Most game engines and math
    libraries use radians instead of degrees, but for some reason SDL uses degrees
    when it rotates sprites, so we will need to change our rotation in radians back
    to degrees when we render our game objects (yuck!).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 圆的直径公式是2πr（在我们的代码中是`2 * PI * radius`）。因此，弧度中的2π等同于360度。大多数游戏引擎和数学库在旋转精灵时使用弧度而不是度，但由于某种原因SDL在旋转精灵时使用度，因此我们需要在渲染游戏对象时将我们的弧度旋转回度（呸！）。
- en: Just to make sure everyone is following me, in our code the `PI` macro holds
    an approximate value for π that is defined as the ratio of a circle's diameter
    to its circumference. A typical approximation for π is 3.14, although we will
    approximate π as 3.14159 in our code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了确保每个人都在跟着我，我们的代码中，“PI”宏保存了一个近似值，即定义为圆的直径与其周长的比值的π。 π的典型近似值为3.14，尽管在我们的代码中，我们将π近似为3.14159。
- en: 'We also need to accelerate or decelerate the spaceship if the player hits the
    up or down keys on the keyboard. To do this, we will create `accelerate` and `decelerate`
    functions that are called when the player holds down the up or down keys:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家按下键盘上的上下键，我们还需要加速或减速飞船。为此，我们将创建“accelerate”和“decelerate”函数，当玩家按住上下键时调用这些函数：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both these functions take the `player_dx` and `player_dy` variables that were
    calculated using `sin` and `-cos` in our rotation functions and use those values
    to add to the player's *x* and *y* velocity stored in the `player_vx` and `player_vy`
    variables. We multiply the value by `delta_time`, which will set our acceleration
    to 1 pixel per second squared. Our decelerate function divides that value by 2,
    which sets our deceleration rate to 0.5 pixels per second squared.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都使用了使用我们的旋转函数中的`sin`和`-cos`计算出的`player_dx`和`player_dy`变量，并使用这些值来添加到存储在`player_vx`和`player_vy`变量中的玩家的*x*和*y*速度。我们将该值乘以`delta_time`，这将使我们的加速度设置为每秒1像素。我们的减速函数将该值除以2，这将使我们的减速率设置为每秒0.5像素。
- en: 'After we define the `accelerate` and `decelerate` functions, we will need to
    create a function that will cap the `x` and `y` velocity of our spaceship to 2.0
    pixels per second:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了“加速”和“减速”函数之后，我们需要创建一个函数，将我们的飞船的“x”和“y”速度限制为每秒2.0像素：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That is not the most efficient way to define this function, but it is the easiest
    to understand. The first line determines the magnitude of our velocity vector.
    If you do not know what that means, let me explain it a little better. We have
    a speed along the *x* axis. We also have a speed along the *y* axis. We want to
    cap the overall speed. If we capped the `x` and `y` velocities individually, we
    would be able to go faster by traveling diagonally. To calculate our total velocity,
    we need to use the Pythagorean theorem (do you remember high-school trigonometry?).
    If you don''t remember, when you have a right triangle, to calculate its hypotenuse
    you take the square root of the sum of the square of the other two sides (remember
    `A² + B² = C²`?):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是定义这个函数的最有效方式，但这是最容易理解的方式。第一行确定了我们速度向量的大小。如果你不知道这意味着什么，让我更好地解释一下。我们有一个沿着*x*轴的速度。我们也有一个沿着*y*轴的速度。我们想要限制总速度。如果我们分别限制`x`和`y`的速度，我们将能够通过对角线行进更快。为了计算我们的总速度，我们需要使用毕达哥拉斯定理（你还记得高中的三角学吗？）。如果你不记得了，当你有一个直角三角形时，要计算它的斜边，你需要取另外两条边的平方和的平方根（记得`A²
    + B² = C²`吗？）：
- en: '![](img/58d0adaf-31a8-45fa-85aa-2ef16b155019.png)[Using the Pythagorean theorem
    to determine the magnitude of the velocity using the x and y velocities]'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/58d0adaf-31a8-45fa-85aa-2ef16b155019.png)[使用毕达哥拉斯定理来确定使用x和y速度的速度大小]'
- en: So, to calculate our velocity overall we need to square the `x` velocity, square
    the `y` velocity, add them together, and then take the square root. At this point,
    we check our velocity against the `MAX_VELOCITY` value, which we have defined
    as `2.0`. If the current velocity is greater than this maximum velocity, we need
    to adjust our `x` and `y` velocities so that we are at a value of `2`. We do this
    by dividing both the `x` and `y` velocities by the overall velocity, then multiplying
    by `MAX_VELOCITY`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了计算我们的总速度，我们需要对`x`速度进行平方，对`y`速度进行平方，然后将它们加在一起，然后取平方根。在这一点上，我们将我们的速度与`MAX_VELOCITY`值进行比较，我们已经将其定义为`2.0`。如果当前速度大于这个最大速度，我们需要调整我们的`x`和`y`速度，使其达到`2`的值。我们通过将`x`和`y`速度都除以总速度，然后乘以`MAX_VELOCITY`来实现这一点。
- en: 'We will eventually need to write a `move` function that will move all of our
    game objects, but for the moment we will only be moving our player''s spaceship:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我们需要编写一个`move`函数，它将移动所有游戏对象，但目前我们只会移动玩家的太空飞船：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first thing we need to do is get the current time for this frame, and then
    use that in combination with our previous frame time to calculate the `delta_time`.
    The `delta_time` variable is the amount of time in seconds since the last frame
    time. We will need to tie much of the movement and animation to this value to
    get a consistent game speed that's independent of the frame rate on any given
    computer. After that, we need to rotate and accelerate or decelerate our spaceship
    based on the flags we set in our `input` function. We then cap our velocity and
    use the `x` and `y` values to modify the *x* and *y* coordinates of the player's
    spaceship.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取这一帧的当前时间，然后将其与我们之前的帧时间结合起来计算`delta_time`。`delta_time`变量是自上一帧时间以来的时间量（以秒为单位）。我们需要将许多移动和动画与这个值联系起来，以获得一个与任何给定计算机的帧速率无关的一致的游戏速度。之后，我们需要根据我们在`input`函数中设置的标志来旋转、加速或减速我们的太空飞船。然后我们限制我们的速度，并使用`x`和`y`值来修改玩家太空飞船的*x*和*y*坐标。
- en: 'There were a series of flags we used in the `move` function that told us whether
    we were currently holding down specific keys on the keyboard. To set those flags,
    we need an `input` function that uses `SDL_PollEvent` to find keyboard events
    and set the flags accordingly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`move`函数中，我们使用了一系列标志，告诉我们当前是否按住了键盘上的特定键。为了设置这些标志，我们需要一个`input`函数，它使用`SDL_PollEvent`来查找键盘事件，并相应地设置标志：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function includes a few `switch` statements that look for the arrow key
    presses and releases. If one of the arrow keys is pressed, we set the appropriate
    flag to `true`; if one is released, we set that flag to `false`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数包括一些`switch`语句，用于查找箭头键的按下和释放。如果按下箭头键之一，我们将相应的标志设置为`true`；如果释放了一个键，我们将该标志设置为`false`。
- en: 'Next, we define the `render` function. This function currently renders our
    spaceship sprite and will eventually render all of our sprites to the HTML canvas:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`render`函数。这个函数目前渲染了我们的太空飞船精灵，并最终会渲染所有精灵到HTML画布上：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function clears the HTML canvas, sets the destination `x` and `y` values
    to `player_x` and `player_y`, calculates the player's rotation in degrees, and
    then renders that sprite to the canvas. We swapped out our previous call to `SDL_RenderCopy`
    with a call to `SDL_RenderCopyEx`. This new function allows us to pass in a value
    that rotates the sprite of our spaceship.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数清除HTML画布，将目的地`x`和`y`值设置为`player_x`和`player_y`，计算玩家的旋转角度，然后将该精灵渲染到画布上。我们用一个调用`SDL_RenderCopyEx`替换了之前的`SDL_RenderCopy`调用。这个新函数允许我们传入一个值，旋转我们的太空飞船的精灵。
- en: 'After we defined our `render` function, we have our new `game_loop` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了`render`函数之后，我们有了新的`game_loop`函数：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function will be called by `emscripten_set_main_loop` from within our `main`
    function. This function runs every frame that is rendered and is responsible for
    managing all the activities that go on within our game. It currently calls the
    `input`, `move`, and `render` functions that we defined earlier in our game code,
    and in the future it will call our AI code, sound effects, physics code, and more.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将被`emscripten_set_main_loop`从我们的`main`函数中调用。这个函数在渲染的每一帧都会运行，并负责管理游戏中发生的所有活动。它目前调用我们在游戏代码中之前定义的`input`、`move`和`render`函数，将来还会调用我们的AI代码、音效、物理代码等。
- en: Compiling gameloop.html
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译gameloop.html
- en: Now that we have written our code, we can go ahead and compile our game loop
    app. Before you run this command, I want to reiterate that you need to have downloaded
    the project from GitHub ([https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly))
    because you will need the PNG files located in the `/Chapter06-game-loop/sprites`
    folder in order to build this project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了我们的代码，可以继续编译我们的游戏循环应用程序。在运行此命令之前，我想重申，您需要从GitHub（[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)）下载项目，因为您需要在`/Chapter06-game-loop/sprites`文件夹中找到PNG文件才能构建此项目。
- en: 'Once you have your folders set up properly, compile the app with the following
    command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您正确设置了文件夹，使用以下命令编译应用程序：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Serve the directory where you compiled it with a web server, or build and run
    it with emrun, and it should look like this when loaded into a web browser:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web服务器提供您编译的目录，或者使用emrun构建和运行它，加载到Web浏览器中时应该是这样的：
- en: '![](img/13918915-c0b6-448b-b3be-996e683d26a9.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13918915-c0b6-448b-b3be-996e683d26a9.png)'
- en: The screenshot gameloop.html
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的屏幕截图
- en: It is important to remember that you must run WebAssembly apps using a web server,
    or with `emrun`. If you would like to run your WebAssembly app using `emrun`,
    you must compile it with the `--emrun` flag. The web browser requires a web server
    to stream the WebAssembly module. If you attempt to open an HTML page that uses
    WebAssembly in a browser directly from your hard drive, that WebAssembly module
    will not load.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，必须使用WebAssembly应用程序使用Web服务器或`emrun`运行。如果您想使用`emrun`运行WebAssembly应用程序，必须使用`--emrun`标志进行编译。Web浏览器需要一个Web服务器来流式传输WebAssembly模块。如果您尝试直接从硬盘驱动器在浏览器中打开使用WebAssembly的HTML页面，那么WebAssembly模块将无法加载。
- en: After the app has compiled, you should be able to move the spaceship around
    the canvas using the arrow keys. Now that we have a basic game loop, in the next
    section, we will be adding some game objects to our app, making it more of a game.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编译完成后，您应该能够使用箭头键在画布上移动太空飞船。现在我们有了一个基本的游戏循环，在下一节中，我们将向我们的应用程序添加一些游戏对象，使其更像一个游戏。
- en: Game objects
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏对象
- en: Our approach so far has been entirely procedural and has been coded so that
    it could have been written in C and not C++. Developers have been writing games
    in C and even assembly language for a long time, so having an object-oriented
    approach to game design is not strictly necessary, but from a code management
    perspective OOP is a great way to design and write your games. Game objects can
    help us manage our allocated memory through object pooling. At this point, it
    will also make sense to begin breaking our program up into multiple files. My
    approach will be to have a single `.hpp` file that defines all of our game objects,
    and one `.cpp` file for each of our objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的方法完全是过程化的，并且编码方式可以用C而不是C++编写。开发人员长期以来一直在用C甚至汇编语言编写游戏，因此从代码管理的角度来看，面向对象的游戏设计并不是绝对必要的，但是从代码管理的角度来看，面向对象编程是设计和编写游戏的一种很好的方式。游戏对象可以帮助我们通过对象池管理我们分配的内存。此时，开始将程序分解成多个文件也是有意义的。我的方法是有一个单独的`.hpp`文件来定义所有的游戏对象，以及一个`.cpp`文件来定义每个对象。
- en: The player's spaceship game object
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家的太空飞船游戏对象
- en: Up to this point, we have been keeping all of the values that track our player's
    ship in global variables. From an organizational perspective, this is less than
    ideal. The first game object we will create will be the player's ship object.
    We will start with a basic class and add more object-oriented features to our
    code later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在全局变量中保存跟踪玩家飞船的所有值。从组织的角度来看，这并不理想。我们将创建的第一个游戏对象将是玩家的飞船对象。我们将从一个基本类开始，稍后再向我们的代码中添加更多面向对象的特性。
- en: 'Here is the code for our new header file, `game.hpp`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们新的头文件`game.hpp`的代码：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'All of our CPP files will include this `game.hpp` header file. The first few
    lines of this file are to make sure we do not include this file more than once.
    We are then defining all of the global variables we had defined in our older C
    files:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的CPP文件都将包括这个`game.hpp`头文件。这个文件的前几行是为了确保我们不会多次包含这个文件。然后我们定义了我们在旧的C文件中定义的所有全局变量：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the header file, we are not allocating space on to the heap. The use of the
    `extern` keyword before our global variable definitions tells the compiler that
    we declared the global variable in one of the `.cpp` files. Right now, we still
    have a lot of global variables. We will be reducing the number of these globals
    as we make modifications to our code in this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，我们不会在堆上分配空间。在全局变量定义之前使用`extern`关键字告诉编译器我们在一个`.cpp`文件中声明了全局变量。现在，我们仍然有很多全局变量。随着我们在本章对代码进行修改，我们将减少这些全局变量的数量。
- en: If this were production code, it would make sense to move all of these values
    into classes, but, for now, we are only creating a `PlayerShip` object. We also
    have our class definition for `PlayerShip`. Developers usually create class definitions
    inside header files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是生产代码，将所有这些值移到类中是有意义的，但是，目前，我们只创建了一个`PlayerShip`对象。我们还为`PlayerShip`定义了我们的类定义。开发人员通常在头文件中创建类定义。
- en: After we define all of our global variables, we will need our class definition.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有全局变量之后，我们将需要我们的类定义。
- en: 'Here is the definition of our `PlayerShip` class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`PlayerShip`类的定义：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this book, we are going to declare all of our attributes `public`. That means
    our code can access them from anywhere, not just from inside this function. If
    you are working on a project with more than one developer, this is not usually
    considered to be a good practice. Preventing other classes from being able to
    directly modify some of our attributes such as `m_DX` and `m_DY` is a good idea
    if you do not want another developer to directly alter specific attributes that
    only functions in a class are meant to modify. For demonstration purposes, however,
    having everything in our class defined as `public` will simplify our design.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将声明所有的属性为`public`。这意味着我们的代码可以从任何地方访问它们，而不仅仅是从这个函数内部。如果你正在与多个开发人员一起开发项目，这通常不被认为是一个好的做法。如果你不希望另一个开发人员直接修改一些只有类中的函数才能修改的特定属性，比如`m_DX`和`m_DY`，那么阻止其他类能够直接修改一些属性是一个好主意。然而，出于演示目的，将我们类中的所有内容定义为`public`将简化我们的设计。
- en: After we define our attributes, we have a series of functions that will be associated
    with this class once defined. The first function, `PlayerShip()`, has the same
    name as our class, which makes it the constructor, that is, the function that
    is called by default when our app creates an object of the `PlayerShip` type.
    If we wished, we could define a destructor function, which would run when the
    object was destroyed, by calling it `~PlayerShip()`. We do not currently need
    a destructor for that object so we will not define it here, which means we will
    rely on C++ to create a *default destructor* for this class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的属性之后，我们有一系列函数，一旦定义，就会与这个类相关联。第一个函数`PlayerShip()`与我们的类同名，这使它成为构造函数，也就是说，当我们的应用程序创建`PlayerShip`类型的对象时，默认情况下会调用该函数。如果我们希望，我们可以定义一个析构函数，当对象被销毁时运行，通过将其命名为`~PlayerShip()`。我们目前不需要该对象的析构函数，因此我们不会在这里定义它，这意味着我们将依赖C++为这个类创建一个*默认析构函数*。
- en: All of the other functions we have defined in this class correspond to functions
    we created in previous C versions of our game. Moving all of these functions to
    a class allows us to organize our code better. Notice that after our class definition,
    we created another global variable that is a `PlayerShip` called `player`. The
    compiler shares this player object in all of the `.cpp` files that include our
    `game.hpp` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类中定义的所有其他函数对应于我们在游戏的先前C版本中创建的函数。将所有这些函数移动到一个类中可以更好地组织我们的代码。请注意，在我们的类定义之后，我们创建了另一个全局变量，一个名为`player`的`PlayerShip`。编译器在包含我们的`game.hpp`文件的所有`.cpp`文件中共享这个玩家对象。
- en: Object pooling
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池
- en: We have defined our first game object, which represents our player's spaceship,
    but all we can do is fly around the game screen. We need to allow our player to
    shoot a projectile. If we created a new projectile object every time a player
    shot a projectile, we would quickly fill up the WASM module's memory. What we
    need to do is create what is known as an **object pool**. Object pools are used
    to create objects with a fixed lifespan. Our projectiles only need to be alive
    long enough to either hit a target or travel a fixed distance before disappearing.
    If we create a set number of projectiles that is a little more than we need on
    the screen at one time, we can keep those objects in a pool in either an active
    or inactive state. When we need to launch a new projectile, we scan our object
    pool for an inactive one, then activate it and place it at the launch point. This
    way, we are not continually allocating and de-allocating memory to create our
    projectiles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的第一个游戏对象，代表了我们玩家的太空飞船，但我们所能做的就是在游戏屏幕上飞行。我们需要允许玩家发射抛射物。如果每次玩家发射抛射物时都创建一个新的抛射物对象，我们很快就会填满WASM模块的内存。我们需要做的是创建所谓的**对象池**。对象池用于创建具有固定寿命的对象。我们的抛射物只需要存活足够长的时间，要么击中目标，要么在消失之前行进一定距离。如果我们创建一定数量的抛射物，略多于我们一次在屏幕上需要的数量，我们可以将这些对象保留在池中，处于活动或非活动状态。当我们需要发射新的抛射物时，我们扫描我们的对象池，找到一个非活动的对象，然后激活它并将其放置在发射点。这样，我们就不会不断地分配和释放内存来创建我们的抛射物。
- en: 'Let''s go back to our `game.hpp` file and add a few class definitions right
    before the `#endif` macro:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`game.hpp`文件，在`#endif`宏之前添加一些类定义。
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, we have defined all of our classes inside the `game.hpp` file. Right now,
    we have three classes: `PlayerShip`, `Projectile`, and `ProjectilePool`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经在`game.hpp`文件中定义了所有的类。现在，我们有三个类：`PlayerShip`，`Projectile`和`ProjectilePool`。
- en: 'The `PlayerShip` class existed before, but we are adding some additional functionality
    to that class to allow us to fire projectiles. To allow for this new functionality,
    we are adding some new public attributes to our class definition:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerShip`类之前就存在，但我们正在为该类添加一些额外的功能，以允许我们发射抛射物。为了允许这种新功能，我们正在向我们的类定义中添加一些新的公共属性：'
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We moved a few of the values we had in `#define` macros directly into the class.
    The `c_SpriteFile` constant is the name of the PNG file we will load to render
    our player's spaceship sprite. The `c_MinLaunchTime` constant is the minimum amount
    of time in milliseconds between two launches of projectiles. We have also defined
    the width and height of our sprite with the `c_Width` and `c_Height` constants.
    This way, we can have different values for different object types. The `m_LastLaunchTime`
    attribute tracks the most recent projectile launch time in milliseconds. The sprite
    texture, which had previously been a global variable, will move into the attributes
    of the player's ship class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一些在`#define`宏中的值直接移到了类中。`c_SpriteFile`常量是我们将加载以渲染玩家太空飞船精灵的PNG文件的名称。`c_MinLaunchTime`常量是两次发射抛射物之间的最小时间间隔（以毫秒为单位）。我们还用`c_Width`和`c_Height`常量定义了精灵的宽度和高度。这样，我们可以为不同的对象类型设置不同的值。`m_LastLaunchTime`属性跟踪了最近的抛射物发射时间（以毫秒为单位）。精灵纹理，之前是一个全局变量，将移动到玩家飞船类的属性中。
- en: 'After making our modifications to the `PlayerShip` class definition, we must
    add a class definition for two new classes. The first of these two classes is
    the `Projectile` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`PlayerShip`类定义进行修改后，我们必须为两个新类添加类定义。这两个类中的第一个是`Projectile`类：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This class represents the projectile game objects that will be shot by the
    player, and later the enemy spaceship. We start with several constants that define
    where we place our sprite in the virtual filesystem, as well as the width and
    height:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表了玩家将射出的projectile游戏对象，以及后来的敌人飞船。我们从几个常量开始，这些常量定义了我们在虚拟文件系统中放置精灵的位置，以及宽度和高度：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The next attribute is `m_SpriteTexture`, which is a pointer to the SDL texture
    used to render our projectiles. We need a variable to tell our object pool that
    this game object is active. We have called that attribute `m_Active`. Next, we
    have a constant that defines how fast our projectile will move in pixels per second,
    called `c_Velocity`, and a constant that indicates how long the projectile will
    stay alive in milliseconds before self-destructing, called `c_AliveTime`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的属性是`m_SpriteTexture`，它是一个指向用于渲染我们的projectiles的SDL纹理的指针。我们需要一个变量来告诉我们的对象池这个游戏对象是活动的。我们称这个属性为`m_Active`。接下来，我们有一个常量，它定义了我们的projectile每秒移动的像素数，称为`c_Velocity`，以及一个常量，表示projectile在自毁之前会在毫秒内保持活动的时间，称为`c_AliveTime`。
- en: The `m_TTL` variable is a **time to live** variable that tracks how many milliseconds
    remain until this projectile will change its `m_Active` variable to `false` and
    recycle itself back into the **projectile pool**. The `m_X`, `m_Y`, `m_VX`, and
    `m_VY` variables are used to track the `x` and `y` position and the `x` and `y`
    velocity of our projectile.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_TTL`变量是一个**生存时间**变量，跟踪着直到这个projectile将其`m_Active`变量更改为`false`并将自己回收到**projectile池**中还有多少毫秒。`m_X`，`m_Y`，`m_VX`和`m_VY`变量用于跟踪我们的projectile的`x`和`y`位置以及`x`和`y`速度。'
- en: 'We then declare four functions for our projectile class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为我们的projectile类声明了四个函数：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Projectile` function is our class constructor. If our projectile is currently
    active, `Move` and `Render` will be called once per frame. The `Move` function
    will manage the movement of an active projectile and `Render` will manage drawing
    the projectile sprite to our HTML canvas element. The `Launch` function will be
    called from our `PlayerShip` class to make our ship launch a projectile in the
    direction the ship is facing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Projectile`函数是我们的类构造函数。如果我们的projectile当前处于活动状态，`Move`和`Render`将在每帧调用一次。`Move`函数将管理活动projectile的移动，`Render`将管理将projectile精灵绘制到我们的HTML画布元素上。`Launch`函数将从我们的`PlayerShip`类中调用，使我们的飞船朝着飞船的方向发射projectile。'
- en: 'The final class definition we must add to our `game.hpp` file is the `ProjectilePool`
    class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加到我们的`game.hpp`文件中的最终类定义是`ProjectilePool`类：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This class manages a **pool** of 10 projectiles stored inside a vector attribute,
    `m_ProjectileList`. The functions for this class include a constructor and destructor,
    `MoveProjectiles`, `RenderProjectils`, and `GetFreeProjectile`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类管理一个包含在向量属性`m_ProjectileList`中的10个projectiles的**池**。这个类的函数包括构造函数和析构函数，`MoveProjectiles`，`RenderProjectils`和`GetFreeProjectile`。
- en: The `MoveProjectiles()` function loops over our projectile list calling the
    `move` function on any active projectile. The `RenderProjectiles()` function loops
    over our projectile list and renders to canvas any active projectile, and `GetFreeProjectile`
    returns the first projectile in our pool that is not active.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveProjectiles()`函数循环遍历我们的projectile列表，调用任何活动projectile上的`move`函数。`RenderProjectiles()`函数循环遍历我们的projectile列表，并在画布上渲染任何活动的projectile，`GetFreeProjectile`返回我们的池中第一个非活动的projectile。'
- en: Pooling the player's projectiles
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池化玩家的projectiles
- en: 'Now that we have looked at the class definitions for our `Projectile` and `ProjectilePool`
    classes, we need to create a `projectile.cpp` file and a `projectile_pool.cpp`
    file to store the function code for those classes. Because this is in [Chapter
    6](ba16e692-1743-4031-bbff-cf2f23ea9a3c.xhtml), *Game Objects and the Game Loop*,
    I would recommend creating a new folder named `Chapter06` to hold these files.
    This code will do the work of pooling our projectiles, requesting an inactive
    projectile when we need one, and moving and rendering our active projectiles.
    First, let''s look at the code we have in `projectile.cpp`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了`Projectile`和`ProjectilePool`类的类定义，我们需要创建一个`projectile.cpp`文件和一个`projectile_pool.cpp`文件来存储这些类的函数代码。因为这是在[第6章](ba16e692-1743-4031-bbff-cf2f23ea9a3c.xhtml)，*游戏对象和游戏循环*，我建议创建一个名为`Chapter06`的新文件夹来保存这些文件。这段代码将完成我们的projectiles的池化工作，在我们需要时请求一个非活动的projectile，并移动和渲染我们的活动projectiles。首先，让我们看看我们在`projectile.cpp`中的代码：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That is the code that deals with moving, rendering, and launching a single
    projectile. The first function declared here is the constructor:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理移动、渲染和发射单个projectile的代码。这里声明的第一个函数是构造函数：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The primary concern of this constructor is to set the projectile to inactive
    and create an SDL texture that we will later use to render our sprite to the canvas
    element. After defining our constructor, we define our `Move` function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数的主要任务是将projectile设置为非活动状态，并创建一个SDL纹理，我们稍后将用它来渲染我们的精灵到画布元素上。在定义了构造函数之后，我们定义了我们的`Move`函数：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This function changes the *x* and *y* position of our projectile based on the
    velocity, and reduces the time to live of our projectile, setting it to inactive
    and recycling it into the projectile pool if it''s time to live is less than or
    equal to zero. The next function we define is our `Render` function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数根据速度改变我们的projectile的*x*和*y*位置，并减少我们的projectile的生存时间，如果它的生存时间小于或等于零，就将其设置为非活动状态并回收到projectile池中。我们定义的下一个函数是我们的`Render`函数：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code is similar to the code we used to render our spaceship, so it should
    look pretty familiar to you. Our final projectile function is the `Launch` function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们用来渲染飞船的代码类似，所以它应该对你来说看起来很熟悉。我们最后的projectile函数是`Launch`函数：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function is called from the `PlayerShip` class whenever the player presses
    the spacebar on the keyboard. The `PlayerShip` object will pass in the *x* and
    *y* coordinates of the player's ship, as well as the direction the ship is facing
    in the `dx` and `dy` parameters. These parameters are used to set the *x* and
    *y* coordinates for the projectile as well as the `x` and `y` velocity of the
    projectile. The game sets the time to live to the default alive time and then
    sets the object to active.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是在玩家在键盘上按下空格键时从“PlayerShip”类中调用的。“PlayerShip”对象将在“dx”和“dy”参数中传入玩家飞船的*x*和*y*坐标，以及飞船面对的方向。这些参数用于设置抛射物的*x*和*y*坐标以及抛射物的*x*和*y*速度。游戏将生存时间设置为默认的存活时间，然后将对象设置为活动状态。
- en: 'Now that we have fully defined our `Projectile` class, let''s set the `ProjectilePool`
    class that will manage those projectiles. The following code will be in our `projectile_pool.cpp`
    file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全定义了我们的“Projectile”类，让我们设置一个管理这些抛射物的“ProjectilePool”类。以下代码将在我们的“projectile_pool.cpp”文件中：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first two functions are the constructor and destructor functions. These
    functions create and destroy the projectiles inside our list. The next function
    is the `MoveProjectiles` function, which loops through our `m_ProjectileList`
    looking for active projectiles and moving them. After that, we have a `RenderProjectiles`
    function, which is quite similar to our `MoveProjectiles` function. This function
    loops through our list calling the `Render` function on all active projectiles.
    The final function is the `GetFreeProjectile` function, which steps through `m_ProjectileList`
    looking for the first projectile that is not active in order to return it. Whenever
    we want to launch a projectile, we will need to call this function to find one
    that is not active.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数是构造函数和析构函数。这些函数在我们的列表内创建和销毁抛射物。接下来的函数是“MoveProjectiles”函数，它循环遍历我们的“m_ProjectileList”寻找活动的抛射物并移动它们。之后，我们有一个“RenderProjectiles”函数，它与我们的“MoveProjectiles”函数非常相似。这个函数循环遍历我们的列表，调用所有活动抛射物的“Render”函数。最后一个函数是“GetFreeProjectile”函数，它通过“m_ProjectileList”寻找第一个不活动的抛射物以返回它。每当我们想要发射一个抛射物时，我们需要调用这个函数来找到一个不活动的抛射物。
- en: Creating an enemy
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个敌人
- en: 'So, now that we have a player ship that is shooting, we can work on adding
    an enemy ship. It will be similar to the `PlayerShip` class. Later, we will get
    into class inheritance so that we will not end up with a copied and pasted version
    of the same code, but for right now we will add a new class definition to our
    `game.hpp` file that is almost identical to our `PlayerShip` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们有了一个射击的玩家飞船，我们可以开始添加一个敌人飞船。它将类似于“PlayerShip”类。稍后，我们将进入类继承，这样我们就不会得到一个复制并粘贴的相同代码版本，但现在我们将在我们的“game.hpp”文件中添加一个几乎与我们的“PlayerShip”类相同的新类定义：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You will notice that before the `EnemyShip` class we defined an `FSM_STUB` enumeration.
    An enumeration is like a new data type that you can define inside your C or C++
    code. We will be discussing **artificial intelligence** and **finite state machines**
    in another chapter, but right now we still want our enemy ship to do something,
    even if that something is not very intelligent. We created an `FSM_STUB` enumeration
    to define the things that our enemy ship can currently do. We have also created
    an `AIStub` inside our `EnemyShip` class that will act as a stand-in for future
    AI logic. The `m_AIStateTTL` integer attribute is a countdown timer to an AI state
    change. There is also a new constant called `c_AIStateTime` that has a value of
    `2000`. That is the number of milliseconds our AI state will persist before it
    changes randomly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在“EnemyShip”类之前，我们定义了一个“FSM_STUB”枚举。枚举就像是您可以在C或C++代码中定义的新数据类型。我们将在另一章中讨论**人工智能**和**有限状态机**，但现在我们仍然希望我们的敌人飞船做一些事情，即使那些事情并不是很聪明。我们创建了一个“FSM_STUB”枚举来定义我们的敌人飞船目前可以做的事情。我们还在我们的“EnemyShip”类中创建了一个“AIStub”，它将作为未来AI逻辑的替身。整数属性“m_AIStateTTL”是一个倒计时计时器，用于AI状态的变化。还有一个名为“c_AIStateTime”的新常量，它的值为“2000”。这是我们的AI状态在随机更改之前将持续的毫秒数。
- en: 'We will create an `enemy_ship.cpp` file and add nine functions to it. The first
    function is our constructor, which is preceded by the `#include` of our `game.hpp`
    file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个“enemy_ship.cpp”文件，并向其中添加九个函数。第一个函数是我们的构造函数，在它之前是我们的“game.hpp”文件的“#include”：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After that, we have the functions `RotateLeft` and `RotateRight` which are
    used to turn the space ship:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有“RotateLeft”和“RotateRight”函数，用于转动太空飞船：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The functions `Accelerate`, `Decelerate` and `CapVelocity` are all used to
    modify the Enemy Ship''s velocity.:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数“Accelerate”、“Decelerate”和“CapVelocity”都用于修改敌舰的速度。
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next thing we add to the file is the `Render` function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们添加到文件中的是“Render”函数：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we add the `Move` and `AIStub` functions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了“Move”和“AIStub”函数：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'These functions are all the same as the functions defined in our `player_ship.cpp`
    file, except for the `Move` function. We have added a new function, `AIStub`.
    Here is the code in the `AIStub` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数都与我们的“player_ship.cpp”文件中定义的函数相同，除了“Move”函数。我们添加了一个新函数，“AIStub”。以下是“AIStub”函数中的代码：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This function is meant to be temporary. We will eventually define a real AI
    for our enemy spaceship. Right now, this function uses `m_AIStateTTL` to count
    down a fixed number of milliseconds until it reaches or goes below `0`. At this
    point, it randomly sets a new AI state based on one of the values in the enumeration
    we defined earlier called `FSM_STUB`. We have also made some modifications to
    the `Move()` function that we created for the player ship:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是暂时的。我们最终将为我们的敌人飞船定义一个真正的AI。现在，这个函数使用“m_AIStateTTL”来倒计时固定数量的毫秒，直到达到或低于“0”。在这一点上，它会基于我们之前定义的枚举“FSM_STUB”中的一个值随机设置一个新的AI状态。我们还对我们为玩家飞船创建的“Move()”函数进行了一些修改：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: I have taken the code from our `PlayerShip::Move` function and made some modifications
    to it. At the beginning of this new function, we have added a call to the `AIStub`
    function. This function is a stand-in for our future AI. Instead of looking at
    our keyboard input as we did for the player ship, the enemy ship will look at
    the AI state and choose to rotate left, rotate right, accelerate, decelerate,
    or shoot. That is not real AI, it is just the ship doing random things, but it
    allows us to get an idea of what the ship will look like when it has real AI,
    and it will allow us to add more functionality later, such as collision detection.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经从我们的`PlayerShip::Move`函数中取出了代码并对其进行了一些修改。在这个新函数的开头，我们添加了对`AIStub`函数的调用。这个函数是我们未来AI的替身。与我们为玩家飞船所做的一样，敌人飞船不会查看我们的键盘输入，而是会查看AI状态并选择左转、右转、加速、减速或射击。这不是真正的AI，只是飞船做一些随机的事情，但它让我们能够想象一下当飞船具有真正的AI时它会是什么样子，并且它将允许我们稍后添加更多功能，比如碰撞检测。
- en: Compiling game_objects.html
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译game_objects.html
- en: 'Now that we have built all of these game objects, we no longer have everything
    inside a single file. We will need to include several CPP files and compile them
    all into a single output file we will call `game_objects.html`. Because we have
    moved from the world of C to C++, we will be using em++ to indicate that the files
    we are compiling are C++ files and not C files. That is not strictly necessary,
    because Emscripten will figure out that we are compiling with C++ when it receives
    files with the `.cpp` extension as input. We are also telling the compiler explicitly
    the version of C++ we are using when we pass in the `-std=c++17` flag. Go ahead
    and compile the `game_objects.html` file with the following em++ command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了所有这些游戏对象，我们不再将所有内容放在一个文件中。我们需要包含几个CPP文件，并将它们全部编译成一个名为`game_objects.html`的输出文件。因为我们已经从C世界转移到了C++世界，所以我们将使用em++来指示我们正在编译的文件是C++文件而不是C文件。这并不是严格必要的，因为当Emscripten接收到扩展名为`.cpp`的文件作为输入时，它会自动判断我们正在使用C++进行编译。当我们传入`-std=c++17`标志时，我们还明确告诉编译器我们正在使用的C++版本。请使用以下em++命令编译`game_objects.html`文件：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that we have our `game_objects.html` file compiled use a web server to
    serve the files and open it in a browser, it should look like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编译了`game_objects.html`文件，请使用Web服务器来提供文件并在浏览器中打开它，它应该看起来像这样：
- en: '![](img/23123d7f-c321-4339-b623-e4be90bc4388.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23123d7f-c321-4339-b623-e4be90bc4388.png)'
- en: A screenshot of game_objects.html
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: game_objects.html的屏幕截图
- en: Do not forget that you must run WebAssembly apps using a web server, or with
    `emrun`. If you would like to run your WebAssembly app using `emrun`, you must
    compile it with the `--emrun` flag. The web browser requires a web server to stream
    the WebAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，您必须使用Web服务器或`emrun`来运行WebAssembly应用程序。如果您想使用`emrun`运行WebAssembly应用程序，您必须使用`--emrun`标志进行编译。Web浏览器需要Web服务器来流式传输WebAssembly模块。如果您尝试直接从硬盘驱动器在浏览器中打开使用WebAssembly的HTML页面，那么WebAssembly模块将无法加载。
- en: You can move your spaceship around the canvas with the arrow keys, and fire
    a projectile with the spacebar. The enemy ship will move around the canvas shooting
    randomly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用箭头键在画布上移动您的飞船，并使用空格键发射抛射物。敌船将在画布上随机移动并射击。
- en: If you are having problems building this app, or any of the other apps in this
    book, please remember you can contact me on Twitter, [https://twitter.com/battagline/](https://twitter.com/battagline/),
    using the Twitter handle `@battagline` to ask questions. I am happy to help.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在构建此应用程序或本书中的任何其他应用程序时遇到问题，请记住您可以在Twitter上联系我，[https://twitter.com/battagline/](https://twitter.com/battagline/)，使用Twitter账号`@battagline`提问。我很乐意帮助。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create a basic game framework. We learned
    what a game loop is and how we create one for WebAssembly using Emscripten. We
    learned about game objects and created classes to define our player's spaceship,
    an enemy spaceship, and projectiles. We learned about object pooling, and how
    we can use an object pool to recycle objects in memory so that we do not need
    to create and destroy new objects in memory continually. We used this knowledge
    to create an object pool for our projectiles. We also created an AI stub for our
    enemy spaceship that gave that object random behavior, and we created functions
    that let our player and enemy shoot at each other while our projectiles pass harmlessly
    through the spaceships.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建一个基本的游戏框架。我们了解了游戏循环是什么，以及如何使用Emscripten为WebAssembly创建游戏循环。我们学习了游戏对象，并创建了用于定义玩家飞船、敌人飞船和抛射物的类。我们学习了对象池，以及如何使用对象池来回收内存中的对象，这样我们就不需要不断地在内存中创建和销毁新对象。我们利用这些知识为我们的抛射物创建了一个对象池。我们还为我们的敌人飞船创建了一个AI存根，使该对象具有随机行为，并创建了让我们的玩家和敌人相互射击的函数，同时我们的抛射物会无害地穿过飞船。
- en: By the end of the next chapter, we will add collision detection; this will allow
    our projectiles to destroy the spaceships they hit, and add an animation sequence
    that will show a ship being destroyed when it is hit by one of the projectiles.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章结束时，我们将添加碰撞检测；这将允许我们的抛射物摧毁它们击中的飞船，并添加一个动画序列，当飞船被抛射物击中时将显示飞船被摧毁的情景。
