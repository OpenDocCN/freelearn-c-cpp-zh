- en: Language-Level Concurrency and Parallelism in C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的语言级并发和并行
- en: C++ has had excellent support for concurrent programming ever since the C++
    11 language standard came out. Until then, threading was an affair that was handled
    by platform-specific libraries. The Microsoft Corporation had its own threading
    libraries, and other platforms (GNU Linux/macOS X) supported the POSIX threading
    model. A threading mechanism as part of the language has helped C++ programmers
    write portable code that runs on multiple platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++ 11语言标准发布以来，C++一直对并发编程提供了出色的支持。在那之前，线程是由特定于平台的库处理的事务。微软公司有自己的线程库，其他平台（GNU
    Linux/macOS X）支持POSIX线程模型。作为语言的一部分的线程机制帮助C++程序员编写可在多个平台上运行的可移植代码。
- en: The original C++ standard was published in 1998, and the language design committee
    firmly believed that threading, filesystems, GUI libraries, and so on are better
    left to the platform-specific libraries. Herb Sutter published an influential
    article in the Dr. Dobbs Journal titled, *The Free Lunch Is Over*, where he advocated
    programming techniques to exploit multiple cores available in the processors of
    those days. While writing parallel code, functional programming models are well-suited
    for the task. Features such as threads, Lambda functions and expressions, move
    semantics, and memory guarantee helps people write concurrent or parallel code
    without much hassle. This chapter aims to enable developers to leverage thread
    libraries and their best practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的C++标准于1998年发布，语言设计委员会坚信线程、文件系统、GUI库等最好留给特定平台的库。Herb Sutter在《Dr. Dobbs Journal》上发表了一篇有影响力的文章，题为《免费午餐结束了》，他在文章中提倡利用多核处理器中的多个核心的编程技术。在编写并行代码时，函数式编程模型非常适合这项任务。线程、Lambda函数和表达式、移动语义和内存保证等特性帮助人们轻松地编写并发或并行代码。本章旨在使开发人员能够利用线程库及其最佳实践。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is concurrency?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是并发？
- en: A characteristic Hello World program using multiple threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个线程的特征Hello World程序
- en: How to manage the lifetime and resources of threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何管理线程的生命周期和资源
- en: Sharing data between threads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程之间共享数据
- en: How to write a thread-safe data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写线程安全的数据结构
- en: What is concurrency?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是并发？
- en: At a basic level, concurrency stands for more than one activity happening at
    the same time. We can correlate concurrency to many of our real-life situations,
    such as eating popcorn while we watch a movie or using two hands for separate
    functions at the same time, and so on. Well then, what is concurrency in a computer?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，并发代表着多个活动同时发生。我们可以将并发与我们的许多现实生活情况联系起来，比如我们一边吃爆米花一边看电影，或者同时用两只手进行不同的功能，等等。那么，在计算机中，并发是什么呢？
- en: Computer systems were enabled to do task switching decades ago, and multitasking
    operating systems have been in existence for a long time. Why is there renewed
    interest in concurrency all of a sudden in the computing realm? The microprocessor
    manufacturers were increasing computing power by cramming more and more silicon
    into a processor. At a certain stage in the process, they could not cram more
    things into the same area as they reached fundamental physical limits. The CPUs
    of those eras had a single path of execution at a time and they were running multiple
    paths of instructions by switching tasks (stream of instructions). At the CPU
    level, only one instruction stream was getting executed, and as things happen
    very fast (compared to human perception), the users felt actions were happening
    at the same time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，计算机系统已经能够进行任务切换，多任务操作系统也存在了很长时间。为什么计算领域突然对并发产生了新的兴趣？微处理器制造商通过将更多的硅片塞入处理器来增加计算能力。在这个过程的某个阶段，由于达到了基本的物理极限，他们无法再将更多的东西塞入相同的区域。那个时代的CPU一次只能执行一条执行路径，并通过切换任务（指令流）来运行多条指令路径。在CPU级别上，只有一个指令流在执行，由于事情发生得非常快（与人类感知相比），用户感觉动作是同时发生的。
- en: Around the year 2005, Intel announced their new multicore processors (which
    support multiple paths of execution at the hardware level), which was a game changer.
    Instead of one processor doing every task by switching between them, multicore
    processors came as a solution to actually perform them in parallel. But this introduced
    another challenge to the programmers; to write their code to leverage hardware-level
    concurrency. Also, the issue of the actual hardware concurrency behaving differently
    compared to the illusion created by the task switches arose. Until the multicore
    processors came to light, the chip manufacturers were in a race to increase their
    computing power, expecting that it might reach 10 GHz before the end of the first
    decade of the 21st century. As Herb Sutter said in *The Free Lunch is Over* ([http://www.gotw.ca/publications/concurrency-ddj.htm](http://www.gotw.ca/publications/concurrency-ddj.htm)),
    "*If software is to take advantage of this increased computing power, it must
    be designed to run multiple tasks concurrently*". Herb warned the programmers
    that those who ignored concurrency must also take that into account while writing
    a program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2005年，英特尔宣布了他们的新多核处理器（支持硬件级别的多条执行路径），这是一个改变游戏规则的事件。多核处理器不再是通过在任务之间切换来执行每个任务的处理器，而是作为一个解决方案来实际并行执行它们。但这给程序员带来了另一个挑战，即编写他们的代码以利用硬件级别的并发性。此外，实际硬件并发行为与任务切换所创建的幻觉之间存在差异的问题也出现了。直到多核处理器出现之前，芯片制造商一直在竞相增加他们的计算能力，期望在21世纪初达到10
    GHz。正如Herb Sutter在《免费午餐结束了》中所说的：“如果软件要利用这种增加的计算能力，它必须设计成能够同时运行多个任务”。Herb警告程序员，那些忽视并发性的人在编写程序时也必须考虑这一点。
- en: The modern C++ standard libraries provide a set of mechanisms to support concurrency
    and parallelism. First and foremost, `std::thread`, along with the synchronization
    objects (such as `std::mutex`, `std::lock_guards`**,** `std::unique_lock`, `std::condition_variables`,
    and so on) empowers the programmers to write a concurrent multithreaded code using
    standard C++. Secondly, to use task-based parallelism (as in .NET and Java), C++
    introduced the classes `std::future` and `std::promise`, which work in pairs to
    separate the function invocation and wait for results.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++标准库提供了一套机制来支持并发和并行。首先，`std::thread`以及同步对象（如`std::mutex`、`std::lock_guards`、`std::unique_lock`、`std::condition_variables`等）使程序员能够使用标准C++编写并发的多线程代码。其次，为了使用基于任务的并行（如.NET和Java），C++引入了`std::future`和`std::promise`类，它们配对工作以分离函数调用和等待结果。
- en: Finally, to avoid the additional overhead of managing threads, C++ introduced
    a class called `std::async`, which will be covered in detail in the following
    chapter where the focus of discussion will be writing lock-free concurrent programs
    (well, at least minimizing locks, wherever possible).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了避免管理线程的额外开销，C++引入了一个名为`std::async`的类，它将在接下来的章节中详细介绍，讨论重点将是编写无锁并发程序（至少在可能的情况下最小化锁定）。
- en: Concurrency is when two or more threads or execution paths can start, run, and
    complete in overlapping time periods (in some kind of interleaved execution).
    Parallelism means two tasks can run at the same time (like you see on a multicore
    CPU). Concurrency is about response time and parallelism is mostly about exploiting
    available resources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是指两个或更多个线程或执行路径可以在重叠的时间段内启动、运行和完成（以某种交错的执行方式）。并行意味着两个任务可以同时运行（就像在多核CPU上看到的那样）。并发是关于响应时间，而并行主要是利用可用资源。
- en: Hello World of concurrency (using std::thread)
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发的Hello World（使用std::thread）
- en: 'Now, let''s get started with our first program using the `std::thread` library.
    You are expected to have C++ 11 or later to compile the programs we are going
    to discuss in this chapter. Let''s take a simple, classic Hello World example
    as a reference before going into a multi-threaded Hello World:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用`std::thread`库编写我们的第一个程序。我们期望您有C++ 11或更高版本来编译我们将在本章讨论的程序。在深入讨论多线程的Hello
    World之前，让我们以一个简单的经典的Hello World示例作为参考：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This program simply writes Hello World into the standard output stream (mainly
    the console). Now, let''s see another example that does the same stuff, but using
    a background thread (often called a worker thread instead):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序简单地将Hello World写入标准输出流（主要是控制台）。现在，让我们看另一个例子，它做同样的事情，但是使用一个后台线程（通常称为工作线程）：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first difference with traditional code is the inclusion of the `<thread>`
    standard header file. All of the multithreading support functions and classes
    are declared in this new header. But to achieve synchronization and shared data
    protection, the supporting classes are available in other headers. If you are
    familiar with platform-level threads in Windows or POSIX systems, all threads
    require an initial function. The same concept is what the standard library is
    also following. In this example, the `thread_proc` function is the initial function
    of a thread that's declared in the main function. The initial function (through
    the function pointer) is specified in the constructor of the `std::thread` object
    `t`, and construction starts the execution of the thread.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统代码的第一个区别是包含了`<thread>`标准头文件。所有的多线程支持函数和类都声明在这个新头文件中。但是为了实现同步和共享数据保护，支持类是在其他头文件中可用的。如果您熟悉Windows或POSIX系统中的平台级线程，所有线程都需要一个初始函数。标准库也遵循相同的概念。在这个例子中，`thread_proc`函数是在主函数中声明的线程的初始函数。初始函数（通过函数指针）在`std::thread`对象`t`的构造函数中指定，并且构造开始执行线程。
- en: The most notable difference is that now the application writes the message into
    a standard output stream from a new thread (background thread), which results
    in having two threads or a path of execution in this application. Once the new
    thread has been launched, the main thread continues its execution. If the main
    thread is not waiting for the newly started thread to finish, the `main()` function
    would end and thus that would be the end of the application—even before the new
    thread has had the chance to finish its execution. This is the reason for calling
    `join()` before the main thread finishes, in order to wait for the new thread, `t`,
    which is started here.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的区别是现在应用程序从一个新线程（后台线程）向标准输出流写入消息，这导致在此应用程序中有两个线程或执行路径。一旦新线程启动，主线程就会继续执行。如果主线程不等待新启动的线程完成，`main()`函数将结束，这样应用程序就会结束——甚至在新线程有机会完成执行之前。这就是在主线程完成之前调用`join()`的原因，以等待新线程`t`的结束。
- en: Managing threads
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理线程
- en: At runtime, the execution starts at the user entry point `main()` (after the
    execution of the start-up code), and it will be executing in a default thread
    that's been created. So, every program will have at least one thread of execution.
    During the execution of the program, an arbitrary number of threads can be created
    through a standard library or platform-specific libraries. These threads can run
    in parallel if the CPU cores are available to execute them. If the number of threads
    are more than the number of CPU cores, even though there is parallelism, we cannot
    run all of the threads simultaneously. So, thread switching happens here as well.
    A program can launch any number of threads from the main thread, and those threads
    run concurrently on the initial thread. As we can see, the initial function for
    a program thread is `main()`, and the program ends when the main returns from
    its execution. This terminates all the parallel threads. Therefore, the main thread
    needs to wait until all the children threads finish execution. So, let's see how
    the launch and join of threads occurs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，执行从用户入口点`main()`开始（在启动代码执行之后），并且将在已创建的默认线程中执行。因此，每个程序都至少有一个执行线程。在程序执行期间，可以通过标准库或特定于平台的库创建任意数量的线程。如果CPU核心可用于执行它们，这些线程可以并行运行。如果线程数多于CPU核心数，即使存在并行性，我们也无法同时运行所有线程。因此，线程切换也在这里发生。程序可以从主线程启动任意数量的线程，并且这些线程在初始线程上同时运行。正如我们所看到的，程序线程的初始函数是`main()`，并且当主线程从其执行返回时程序结束。这将终止所有并行线程。因此，主线程需要等待直到所有子线程完成执行。因此，让我们看看线程的启动和加入是如何发生的。
- en: Thread launch
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程启动
- en: In the previous example, we saw that the initialization function is passed as
    an argument to the `std::thread` constructor, and the thread gets launched. This
    function runs on its own thread. The thread launch happens during the thread object's
    construction, but the initialization functions can have other alternatives as
    well. A function object is another possible argument in a thread class. The C++
    standard library ensures that the `std::thread` works with any callable type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到初始化函数作为参数传递给`std::thread`构造函数，并且线程被启动。此函数在自己的线程上运行。线程启动发生在线程对象的构造期间，但初始化函数也可以有其他替代方案。函数对象是线程类的另一个可能参数。C++标准库确保`std::thread`与任何可调用类型一起工作。
- en: 'The modern C++ standard supports threads to be initialized through:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++标准支持通过以下方式初始化线程：
- en: Function pointers (as in the previous section)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数指针（如前一节中）
- en: An object that implements the call operator
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现调用运算符的对象
- en: Lambdas
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda
- en: 'Any callable entity is a candidate for initializing a thread. This enables
    the `std::thread` to accept a class object with an overloaded function call operator:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可调用实体都可以用于初始化线程。这使得`std::thread`能够接受具有重载函数调用运算符的类对象：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, the newly created thread copies the object into its storage, hence the
    copy behavior must be ensured. Here, we can also use `std::move` to avoid problems
    related to copying:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，新创建的线程将对象复制到其存储中，因此必须确保复制行为。在这里，我们还可以使用`std::move`来避免与复制相关的问题：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you pass temporary (an rvalue) instead of a function object, the syntax
    is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递临时对象（rvalue）而不是函数对象，则语法如下：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code can be interpreted by the compiler as a declaration of a function
    that accepts a function pointer and returns a `std::thread` object. However, we
    can avoid this by using the new uniform initialization syntax, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以将此代码解释为接受函数指针并返回`std::thread`对象的函数声明。但是，我们可以通过使用新的统一初始化语法来避免这种情况，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An extra set of parenthesis, as given in the following code snippet, can also
    avoid the interpretation of `std::thread` object declaration into a function declaration:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中给出的额外一组括号也可以避免将`std::thread`对象声明解释为函数声明：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another interesting way to launch a thread is by giving the C++ Lambdas as an
    argument into a `std::thread` constructor. Lambdas can capture local variables
    and thus avoid unnecessary usage of any arguments. Lambdas are very useful when
    it comes to writing anonymous functions, but that doesn't mean that they should
    be used everywhere.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 启动线程的另一个有趣的方法是通过将C++ Lambda作为参数传递给`std::thread`构造函数。Lambda可以捕获局部变量，从而避免不必要地使用任何参数。当涉及编写匿名函数时，Lambda非常有用，但这并不意味着它们应该随处使用。
- en: 'The Lambda function can be used along with a thread declaration as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数可以与线程声明一起使用，如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Thread join
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程加入
- en: In the Hello World example, you might have noticed the use of `t.join()` at
    the end of `main()` before leaving from the function. The call to `join()` on
    the associated thread instance ensures that the launched function will wait until
    the background thread completes its execution. In the absence of join, the thread
    will be terminated before the thread starts until the current context is finished
    (their child threads will also be terminated).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hello World示例中，您可能已经注意到在`main()`结束之前使用了`t.join()`。在函数离开之前，对关联线程实例的`join()`调用确保启动的函数将等待直到后台线程完成执行。如果没有join，线程将在线程开始之前终止，直到当前上下文完成（它们的子线程也将被终止）。
- en: '`join()` is a direct function, either waiting for the thread to finish or not.
    To get more control over the thread, we have other mechanisms such as mutex, condition
    variables, and futures, and they will be discussed in the later sections of this
    chapter and the next chapter. The call to `join()` cleans up the storage associated
    with the thread, and so it ensures that the object is no longer associated with
    the thread that was launched. This asserts that the `join()` function can only
    be called once per thread; the call to `joinable()` will always return false after
    a call to `join()`. The previous example with a function object can be modified
    as follows to understand `join()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`是一个直接的函数，可以等待线程完成，也可以不等待。为了更好地控制线程，我们还有其他机制，比如互斥锁、条件变量和期物，它们将在本章和下一章的后面部分进行讨论。调用`join()`会清理与线程相关联的存储，因此确保对象不再与启动的线程相关联。这意味着`join()`函数只能每个线程调用一次；在调用`join()`后，调用`joinable()`将始终返回false。前面的使用函数对象的示例可以修改如下以理解`join()`：'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, at the end of the `func()` function, the thread object is verified
    to confirm whether the thread is still in execution. We call `joinable()` to see
    its return value before we place the join call.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在`func()`函数结束时，验证线程对象以确认线程是否仍在执行。在放置join调用之前，我们调用`joinable()`来查看其返回值。
- en: 'To prevent the wait on `func()`, there is a mechanism that was introduced by
    the standard to continue execution, even if the parent function finishes its execution.
    This can be achieved using another standard function, `detach()`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止在`func()`上等待，标准引入了一种机制，即使父函数完成执行，也可以继续执行。这可以通过另一个标准函数`detach()`来实现：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are a couple of things that we need to consider before detaching a thread;
    the `t` thread will probably still be running when `func()` exits. As per the
    implementation given in the preceding example, the thread is using the reference
    of a local variable created in `func()`, which is not a good idea since the old
    stack variables can be overwritten at any time on most architectures. These situations
    must always be addressed while using `detach()` in your code. The most common
    way of handling this situation is making a thread self-contained and copying the
    data into the thread instead of sharing it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在分离线程之前，我们需要考虑几件事情；当`func()`退出时，线程`t`可能仍在运行。根据前面示例中给出的实现，线程使用了在`func()`中创建的局部变量的引用，这不是一个好主意，因为在大多数架构上，旧的堆栈变量随时可能被覆盖。在编写代码时，必须始终解决这些情况。处理这种情况的最常见方法是使线程自包含，并将数据复制到线程中，而不是共享它。
- en: Passing arguments into a thread
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将参数传递给线程
- en: 'So, we have figured out how to launch and wait over a thread. Now, let''s see
    how to pass arguments into a thread initialization function. Let''s look at an
    example to find the factorial of a number:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经找出了如何启动和等待线程。现在，让我们看看如何将参数传递给线程初始化函数。让我们看一个计算阶乘的示例：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From this example, it is clear that passing arguments into a thread function
    or a thread callable object can be achieved by passing additional arguments into
    an `std::thread()` declaration. One thing we must keep in mind; *the arguments
    passed are copied into the thread''s internal storage for further execution*.
    It is important for a thread''s execution to have its own copy of arguments, as
    we have seen the problems associated with local variables going out of scope.
    To discuss passing arguments into a thread further, let''s go back to our first
    Hello World example from this chapter:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，可以清楚地看出，通过向`std::thread()`声明中传递额外的参数，可以实现将参数传递给线程函数或线程可调用对象。我们必须记住一件事；*传递的参数被复制到线程的内部存储以供进一步执行*。对于线程的执行来说，拥有自己的参数副本是很重要的，因为我们已经看到了与局部变量作用域结束相关的问题。要进一步讨论将参数传递给线程，让我们回到本章的第一个Hello
    World示例：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, the `thread_proc()` function takes `std::string` as an argument,
    but we are passing a `const char*` as an argument to the thread function. Only
    in the case of a thread is the argument passed, converted, and copied into the
    thread''s internal storage. Here, `const char*` will be converted to `std::string`.
    The type of argument supplied to a thread must be chosen while keeping this in
    mind. Let''s see what happens if a pointer is supplied to the thread as an argument:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`thread_proc()`函数以`std::string`作为参数，但我们将`const char*`作为参数传递给线程函数。只有在线程的情况下，参数才会被传递、转换并复制到线程的内部存储中。在这里，`const
    char*`将被转换为`std::string`。必须在选择线程提供的参数类型时考虑到这一点。让我们看看如果将指针作为参数提供给线程会发生什么：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, the argument supplied to the thread is a pointer to
    the local variable `buf`. There is a probable chance that the `func()` function
    will exit before the conversion of `buf` to an `std::string` happens on the thread.
    This could lead to an undefined behavior. This problem can be resolved by casting
    the `buf` variable into `std::string` in the declaration itself, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，提供给线程的参数是指向局部变量`buf`的指针。`func()`函数在线程上发生`buf`转换为`std::string`之前可能会退出。这可能导致未定义的行为。可以通过在声明中将`buf`变量转换为`std::string`来解决这个问题，如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s look at the cases where you want a reference to get updated in
    the thread. In a typical scenario, the thread copies the value supplied to the
    thread to ensure a safe execution, but the standard library has also provided
    a means to pass the argument by reference to a thread. In many practical systems,
    you might have seen that a shared data structure is getting updated inside a thread.
    The following example shows how to achieve pass by reference in a thread:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当您希望在线程中更新引用时的情况。在典型情况下，线程会复制传递给线程的值，以确保安全执行，但标准库还提供了一种通过引用传递参数给线程的方法。在许多实际系统中，您可能已经看到在线程内部更新共享数据结构。以下示例展示了如何在线程中实现按引用传递：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, wrapping the arguments passed into the `std::thread`
    constructor with `std::ref` ensures that the variable supplied inside the thread
    is referenced to the actual parameters. You might have noticed that the function
    prototype of the thread initialization function is accepting a reference to the
    `shared_data` object, but why do you still need an `std::ref()` wrapping for thread
    invocation? Consider the following code for thread invocation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用`std::ref`将传递给`std::thread`构造函数的参数包装起来，确保线程内部使用的变量是实际参数的引用。您可能已经注意到，线程初始化函数的函数原型接受了对`shared_data`对象的引用，但为什么在线程调用中仍然需要`std::ref()`包装呢？考虑以下线程调用的代码：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, the `update_data()` function expects the `shared_data` argument
    to be treated as a reference to actual parameters. But when used as a thread initialization
    function, arguments are simply copied internally. When the call to `update_data()`
    happens, it will pass a reference to the internal copies of arguments and not
    a reference to the actual parameters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`update_data()`函数期望`shared_data`参数被视为实际参数的引用。但当用作线程初始化函数时，参数会在内部被简单地复制。当调用`update_data()`时，它将传递给参数的内部副本的引用，而不是实际参数的引用。
- en: Using Lambdas
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda
- en: 'Now, let''s see the usefulness of Lambda expressions for multithreading. In
    the following code, we are going to create five threads and put those into a vector
    container. Each thread will be using a Lambda function as the initialization function.
    The threads initialized in the following code are capturing the loop index by
    value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下Lambda表达式在多线程中的用处。在以下代码中，我们将创建五个线程，并将它们放入一个向量容器中。每个线程将使用Lambda函数作为初始化函数。在以下代码中初始化的线程通过值捕获循环索引：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The vector container threads store five threads that have been created inside
    the loop. They are joined at the end of the `main()` function once the execution
    is over. The output for the preceding code may look as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向量容器线程存储了在循环内创建的五个线程。一旦执行结束，它们将在`main()`函数的末尾被连接。前面代码的输出可能如下所示：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output of the program could be different for each run. This program is a
    good example to showcase the non-determinism associated with concurrent programming.
    In the following section, we will discuss the move properties of a `std::thread`
    object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出可能在每次运行时都不同。这个程序是一个很好的例子，展示了并发编程中的不确定性。在接下来的部分中，我们将讨论`std::thread`对象的移动属性。
- en: Ownership management
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权管理
- en: From the examples discussed so far in this chapter, you might have noticed that
    the function that launches the thread has to wait for the thread to complete its
    execution using the `join()` function, otherwise it will call `detach()` with
    a cost of the program losing control over the thread. In modern C++, many standard
    types are movable, but cannot be copied; `std::thread` is one of them. This means
    that the ownership of a thread's execution can be moved between `std::thread`
    instances with the help of move semantics.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章迄今讨论的示例中，您可能已经注意到启动线程的函数必须使用`join()`函数等待线程完成执行，否则它将以程序失去对线程的控制为代价调用`detach()`。在现代C++中，许多标准类型是可移动的，但不能被复制；`std::thread`就是其中之一。这意味着线程执行的所有权可以在`std::thread`实例之间通过移动语义移动。
- en: There are many situations where we want to move the ownership to another thread,
    for example, if we want the thread to run in the background without waiting for
    it on the function that created the thread. This can be achieved by passing the
    thread ownership to a calling function rather than waiting for it to complete
    in the created function. In another instance, pass the ownership to some other
    function, which will wait for the thread to complete its execution. Both of these
    cases can be achieved by passing the ownership from one thread instance to another.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，我们希望将所有权移交给另一个线程，例如，如果我们希望线程在创建线程的函数上后台运行而不等待它。这可以通过将线程所有权传递给调用函数来实现，而不是在创建的函数中等待它完成。在另一种情况下，将所有权传递给另一个函数，该函数将等待线程完成其执行。这两种情况都可以通过将一个线程实例的所有权传递给另一个线程实例来实现。
- en: 'To explain further, let us define two functions to use as the thread functions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释，让我们定义两个函数来用作线程函数：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s look into the main function that spawns threads from previously declared
    functions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下从先前声明的函数中生成线程的主要函数：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, a new thread started with `t1` in the first line of
    `main()`. Ownership is then transferred to `t2` using the `std::move()` function,
    which is invoking the move constructor of `std::thread`, which is associated with
    `t2`. Now, the t1 instance has no associated thread of execution. The initialization
    function `function1()` is now associated with `t2`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`main()`的第一行启动了一个新的线程`t1`。然后，使用`std::move()`函数将所有权转移到`t2`，该函数调用了与`t2`关联的`std::thread`的移动构造函数。现在，t1实例没有关联的线程执行。初始化函数`function1()`现在与`t2`关联：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, a new thread is started using an rvalue, which invokes the move assignment
    operator of `std::thread`, which is associated with `t1`. Since we are using an
    rvalue, an explicit call to `std::move()` is not required:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用rvalue启动了一个新的线程，这将调用与`t1`关联的`std::thread`的移动赋值运算符。由于我们使用了rvalue，因此不需要显式调用`std::move()`：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`t3` was instantiated without any thread of execution, which means it is invoking
    the default constructor. The ownership currently associated with `t2` is then
    transferred to `t3` by the move assignment operator, by explicitly calling the
    `std::move()` function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`t3`是在没有任何线程执行的情况下实例化的，这意味着它正在调用默认构造函数。然后，通过显式调用`std::move()`函数，通过移动赋值运算符将当前与`t2`关联的所有权转移到`t3`：'
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, the `std::thread` instances with an associated thread of execution
    are joined before the program exits. Here, `t1` and `t3` are the instances with
    an associated thread of execution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与关联执行线程的`std::thread`实例在程序退出之前被连接。在这里，`t1`和`t3`是与关联执行线程的实例。
- en: 'Now, let''s assume that the following code is present before the threads `join()` in
    the preceding example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设在前面示例中的线程`join()`之前存在以下代码：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the instance `t1` is already associated with a running function (`function2`).
    When `std::move()` attempts to transfer the ownership of `function1` back to `t1`,
    `std::terminate()` is called to terminate the program. This guarantees the consistency
    of the `std::thread` destructor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，实例`t1`已经与正在运行的函数(`function2`)相关联。当`std::move()`试图将`function1`的所有权转移回`t1`时，将调用`std::terminate()`来终止程序。这保证了`std::thread`析构函数的一致性。
- en: 'The move support in `std::thread` helps in transferring the ownership of a
    thread out of a function. The following example demonstrates such a scenario:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::thread`中的移动支持有助于将线程的所有权从函数中转移出来。以下示例演示了这样的情况：'
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, the `thread_creator()` function returns the `std::thread` associated with
    the `func()` function. The `thread_wait_func()` function calls `thread_creator()`,
    and then returns the thread object, which is an rvalue that is assigned to an
    `std::thread` object. This transfers the ownership of the thread into the `std::thread`
    object `t`, and object `t` is waiting for the completion of thread execution in
    the transferred function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`thread_creator()`函数返回与`func()`函数相关联的`std::thread`。`thread_wait_func()`函数调用`thread_creator()`，然后返回线程对象，这是一个rvalue，分配给了一个`std::thread`对象。这将线程的所有权转移到`std::thread`对象`t`中，对象`t`正在等待转移函数中线程执行的完成。
- en: Sharing data between threads
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程之间共享数据
- en: We have seen how to start a thread and different methods of managing them. Now,
    let's discuss how to share data between threads. One key feature of concurrency
    is its ability to share data between the threads in action. First, let's see what
    the problems associated with threads accessing common (shared) data are.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何启动线程和管理它们的不同方法。现在，让我们讨论如何在线程之间共享数据。并发的一个关键特性是它能够在活动的线程之间共享数据。首先，让我们看看线程访问共同（共享）数据所带来的问题。
- en: There won't be a problem if the data shared between threads is immutable (read-only),
    because the data read by one thread is unaffected by whether the other threads
    are reading the same data or not. The moment threads start modifying shared data
    is when problems begin to emerge.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在线程之间共享的数据是不可变的（只读），那么就不会有问题，因为一个线程读取的数据不受其他线程是否读取相同数据的影响。当线程开始修改共享数据时，问题就开始出现了。
- en: For example, if the threads are accessing a common data structure, the invariants
    associated with the data structure are broken if an update is happening. In this
    case, the number of elements is stored in the data structure, which usually requires
    the modification of more than one value. Consider the delete operation of a self-balancing
    tree or a doubly linked list. If you don't do anything special to ensure otherwise,
    if one thread is reading the data structure, while another is removing a node,
    it is quite possible for the reading thread to see the data structure with a partially
    removed node, so the invariant is broken. This might end up corrupting the data
    structure permanently and could lead to the program crashing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果线程正在访问一个共同的数据结构，如果正在进行更新，与数据结构相关的不变量将被破坏。在这种情况下，数据结构中存储了元素的数量，通常需要修改多个值。考虑自平衡树或双向链表的删除操作。如果不采取任何特殊措施来确保否则，如果一个线程正在读取数据结构，而另一个正在删除一个节点，很可能会导致读取线程看到具有部分删除节点的数据结构，因此不变量被破坏。这可能最终会永久损坏数据结构，并可能导致程序崩溃。
- en: An invariant is a set of assertions that must always be true during the execution
    of a program or lifetime of an object. Placing proper assertion within the code
    to see whether invariants have been violated will result in robust code. This
    is a great way to document software as well as a good mechanism to prevent regression
    bugs. More can be read about this in the following Wikipedia article: [https://en.wikipedia.org/wiki/Invariant_(computer_science)](https://en.wikipedia.org/wiki/Invariant_(computer_science)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量是一组在程序执行或对象生命周期中始终为真的断言。在代码中放置适当的断言来查看不变量是否被违反将产生健壮的代码。这是一种很好的记录软件的方式，也是防止回归错误的良好机制。关于这一点可以在以下维基百科文章中阅读更多：[https://en.wikipedia.org/wiki/Invariant_(computer_science)](https://en.wikipedia.org/wiki/Invariant_(computer_science))。
- en: This often leads to a situation called *race condition*, which is the most common
    cause of bugs in concurrent programs. In multithreading, race condition means
    that the threads race to perform their respective operations. Here, the outcome
    depends on the relative ordering of the execution of an operation in two or more
    threads. Usually, the term race condition means a problematic race condition;
    normal race conditions don't cause any bugs. Problematic race conditions usually
    occur where the completion of an operation requires modification of two or more
    bits of data, such as deletion of a node in a tree data structure or a doubly
    linked list. Because the modification must access separate pieces of data, these
    must be modified in separate instructions when another thread is trying to access
    the data structure. This occurs when half of the previous modifications have been
    completed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这经常导致一种称为*竞争条件*的情况，这是并发程序中最常见的错误原因。在多线程中，竞争条件意味着线程竞争执行各自的操作。在这里，结果取决于两个或更多线程中操作的执行相对顺序。通常，竞争条件一词指的是问题性的竞争条件；正常的竞争条件不会导致任何错误。问题性的竞争条件通常发生在完成操作需要修改两个或更多位数据的情况下，例如在树数据结构或双向链表中删除节点。因为修改必须访问不同的数据片段，当另一个线程尝试访问数据结构时，这些数据必须在单独的指令中进行修改。这发生在先前修改的一半已经完成时。
- en: Race conditions are often very hard to find and hard to duplicate because they
    occur in a very short window of execution. For software that uses concurrency,
    the major complexity of implementation comes from avoiding problematic race conditions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件通常很难找到，也很难复制，因为它们发生在非常短的执行窗口内。对于使用并发的软件，实现的主要复杂性来自于避免问题性的竞争条件。
- en: There are many ways to deal with problematic race conditions. The common and
    simplest option is to use *synchronization primitives*, which are lock-based protection
    mechanisms. This wraps the data structure by using some locking mechanisms to
    prevent the access of other threads during its execution. We will discuss the
    available synchronization primitives and their uses in detail in this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以处理问题性的竞争条件。常见且最简单的选择是使用*同步原语*，这是基于锁的保护机制。它通过使用一些锁定机制来包装数据结构，以防止其他线程在其执行期间访问。我们将在本章中详细讨论可用的同步原语及其用途。
- en: Another option is to alter the design of your data structure and its invariants
    so that the modification guarantees the sequential consistency of your code, even
    across multiple threads. This is a difficult way of writing programs and is commonly
    referred to as *lock-free programming*. Lock-free programming and the C++ memory
    model will be covered in [Chapter 4](80c4a483-89c7-45fc-a83f-736a1817126e.xhtml), *Asynchronous
    and Lock-Free Programming in C++*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是修改数据结构及其不变量的设计，以确保修改可以保证代码的顺序一致性，即使跨多个线程。这是一种编写程序的困难方式，通常被称为*无锁编程*。无锁编程和C++内存模型将在[第4章](80c4a483-89c7-45fc-a83f-736a1817126e.xhtml)中进行介绍，《C++中的异步和无锁编程》。
- en: Then, there are other mechanisms such as handling the updates to a data structure
    as a transaction, as updates to databases are done within transactions. Currently,
    this topic is not in the scope of this book, and therefore it won't be covered.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有其他机制，比如将对数据结构的更新视为事务，就像对数据库的更新是在事务中完成的一样。目前，这个主题不在本书的范围内，因此不会涉及。
- en: Now, let's consider the most basic mechanism in C++ standard for protecting
    shared data, which is the *mutex*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑C++标准中用于保护共享数据的最基本机制，即*互斥锁*。
- en: Mutexes
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: A mutex is a mechanism used in concurrency control to prevent race conditions.
    The function of a mutex is to prevent a thread of execution to enter its *critical
    section* at the same time another concurrent thread enters its own critical section.
    It is a lockable object designed to signal when the critical sections of code
    need exclusive access, thereby restricting other concurrent threads with the same
    protection in execution as well as memory access. The C++ 11 standard introduced
    an `std::mutex` class into the standard library to achieve data protection across
    concurrent threads.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁是用于并发控制的机制，用于防止竞争条件。互斥锁的功能是防止执行线程在另一个并发线程进入其自己的临界区时进入其*临界区*。它是一个可锁定的对象，设计用于在代码的临界区需要独占访问时发出信号，从而限制其他并发线程在执行和内存访问方面具有相同的保护。C++
    11标准引入了`std::mutex`类到标准库中，以实现跨并发线程的数据保护。
- en: The `std::mutex` class consist of the `lock()` and `unlock()` functions to create
    a critical section in code. One thing to keep in mind while using the member functions
    to create critical sections is that you should never skip an unlock function associated
    with a lock function to mark the critical section in code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mutex`类包括`lock()`和`unlock()`函数，用于在代码中创建临界区。在使用成员函数创建临界区时要记住的一件事是，永远不要跳过与锁定函数相关联的解锁函数，以标记代码中的临界区。'
- en: 'Now, let''s discuss the same code we used for discussing Lambdas with threads.
    There, we observed that the output of the program was scrambled due to a race
    condition with a common resource, `std::cout`, and `std::ostream` operators. That
    code is now being rewritten using `std::mutex` to print the thread index:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论与线程一起使用Lambda时所使用的相同代码。在那里，我们观察到程序的输出由于与共享资源`std::cout`和`std::ostream`操作符的竞争条件而混乱。现在，该代码正在使用`std::mutex`进行重写，以打印线程索引：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output for the preceding code may look as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出可能如下所示：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, the mutex is used to protect the shared resource, which
    is the `std::cout` and cascaded `std::ostream` operators. Unlike the older example,
    the addition of a mutex in the code now avoids the scrambled output, but it will
    appear in a random order. The use of `lock()` and `unlock()` functions in the `std::mutex`
    class guarantees the output is not garbled. However, the practice to call member
    functions directly is not recommended, because you need to call unlock on every
    code path in the function, including the exception scenarios as well. Instead,
    C++ standard introduced a new template class, `std::lock_guard`, which implemented
    the **Resource Acquisition Is Initialization** (**RAII**) idiom for a mutex. It
    locks the supplied mutex in the constructor and unlocks it in the destructor.
    The implementation of this template class is available in the `<mutex>` standard
    header library. The previous example can be rewritten using `std::lock_guard`
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，互斥锁用于保护共享资源，即`std::cout`和级联的`std::ostream`操作符。与旧示例不同，现在代码中添加了互斥锁，避免了混乱的输出，但输出将以随机顺序出现。在`std::mutex`类中使用`lock()`和`unlock()`函数可以保证输出不会混乱。然而，直接调用成员函数的做法并不推荐，因为你需要在函数的每个代码路径上调用解锁，包括异常情况。相反，C++标准引入了一个新的模板类`std::lock_guard`，它为互斥锁实现了**资源获取即初始化**（**RAII**）习惯用法。它在构造函数中锁定提供的互斥锁，并在析构函数中解锁。这个模板类的实现在`<mutex>`标准头文件库中可用。前面的示例可以使用`std::lock_guard`进行重写，如下所示：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, the mutex that protects the critical section is at global
    scope and the `std::lock_guard` object is local to the Lambda each time thread
    execution happens. This way, as soon as the object is constructed, the mutex acquires
    the lock. It unlocks the mutex with the call to destructor when the Lambda execution
    is over.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，保护临界区的互斥锁位于全局范围，而`std::lock_guard`对象在每次线程执行时都是局部的Lambda。这样，一旦对象被构造，互斥锁就会获得锁。当Lambda执行结束时，调用析构函数解锁互斥锁。
- en: RAII is a C++ idiom where the lifetime of entities such as database/file handles,
    socket handles, mutexes, dynamically allocated memory on the heap, and so on are
    bounded to the life cycle of the object holding it. You can read more about RAII
    at the following Wikipedia page: [https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: RAII是C++的一种习惯用法，其中诸如数据库/文件句柄、套接字句柄、互斥锁、堆上动态分配的内存等实体的生命周期都与持有它的对象的生命周期绑定。你可以在以下维基百科页面上阅读更多关于RAII的内容：[https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)。
- en: Avoiding deadlock
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免死锁
- en: While dealing with mutexes, the biggest problem that can arise is a deadlock.
    To understand what deadlock is, just imagine an iPod. For an iPod to achieve its
    purpose, it requires both an iPod as well as an earpiece. If two siblings share
    one iPod, there are situations where both want to listen to music at the same
    time. Imagine one person got their hands on the iPod and the other got the earpiece,
    and neither of them is willing to share the item they possess. Now they are stuck,
    unless one of them tries to be nice and lets the other person listen to music.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理互斥锁时，可能出现的最大问题就是死锁。要理解死锁是什么，想象一下iPod。为了实现iPod的目的，它需要iPod和耳机。如果两个兄弟共享一个iPod，有时候两个人都想同时听音乐。想象一个人拿到了iPod，另一个拿到了耳机，他们都不愿意分享自己拥有的物品。现在他们陷入僵局，除非其中一个人试图友好一点，让另一个人听音乐。
- en: Here, the siblings are arguing over an iPod and an earpiece, but coming back
    to our situation, threads argue over the locks on mutexes. Here, each thread has
    one mutex and is waiting for the other. No mutex can proceed here, because each
    thread is waiting for the other thread to release its mutex. This scenario is
    called **deadlock**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，兄弟们在争夺iPod和耳机，但回到我们的情况，线程在争夺互斥锁上的锁。在这里，每个线程都有一个互斥锁，并且正在等待另一个线程。没有互斥锁可以继续进行，因为每个线程都在等待另一个线程释放其互斥锁。这种情况被称为**死锁**。
- en: Avoiding deadlock is sometimes quite straightforward because different mutexes
    serve different purposes, but there are instances where handling such situations
    is not that obvious. The best advice I can give you to avoid deadlock is to always
    lock multiple mutexes in the same order. Then, you will never get deadlock situations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 避免死锁有时候相当简单，因为不同的互斥锁用于不同的目的，但也有一些情况处理起来并不那么明显。我能给你的最好建议是，为了避免死锁，始终以相同的顺序锁定多个互斥锁。这样，你就永远不会遇到死锁情况。
- en: 'Consider an example of a program with two threads; each thread is intended
    to print odd numbers and even numbers alone. Since the intentions of the two threads
    are different, the program uses two mutexes to control each thread. The shared
    resource between the two threads is `std::cout`. Let''s look at the following
    program with a deadlock situation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有两个线程的程序的例子；每个线程都打算单独打印奇数和偶数。由于两个线程的意图不同，程序使用两个互斥锁来控制每个线程。两个线程之间的共享资源是`std::cout`。让我们看一个具有死锁情况的以下程序：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `printEven()` function is defined to print all the positive even numbers
    into the standard console which are less than the `max` value. Similarly, let
    us define a `printOdd()` function to print all the positive odd numbers less than
    `max`, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`printEven()`函数被定义为将所有小于`max`值的正偶数打印到标准控制台中。同样，让我们定义一个`printOdd()`函数，以打印小于`max`的所有正奇数，如下所示：'
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s write the `main` function to spawn two independent threads to print
    odd and even numbers using the previously defined functions as the thread functions
    for each operation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写`main`函数，生成两个独立的线程，使用先前定义的函数作为每个操作的线程函数来打印奇数和偶数：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, `std::cout` is protected with two mutexes, `printEven` and
    `printOdd`, which perform locking in a different order. With this code, we always
    ends up in deadlock, since each thread is clearly waiting for the mutex locked
    by the other thread. Running this code would result in a hang. As mentioned previously,
    deadlock can be avoided by locking them in the same order, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`std::cout`受到两个互斥锁`printEven`和`printOdd`的保护，它们以不同的顺序进行锁定。使用这段代码，我们总是陷入死锁，因为每个线程明显都在等待另一个线程锁定的互斥锁。运行这段代码将导致程序挂起。如前所述，可以通过以相同的顺序锁定它们来避免死锁，如下所示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But this code is clearly not clean. You already know that using a mutex with
    the RAII idiom makes the code cleaner and safer, but to ensure the order of locking,
    the C++ standard library has introduced a new function, `std::lock`—a function
    that can lock two or more mutexes in one go without deadlock risk. The following
    example shows how to use this for our previous odd-even program:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这段代码显然不够干净。你已经知道使用RAII习惯用法的互斥锁可以使代码更清晰、更安全，但为了确保锁定的顺序，C++标准库引入了一个新函数`std::lock`——一个可以一次锁定两个或更多互斥锁而不会出现死锁风险的函数。以下示例展示了如何在先前的奇偶程序中使用这个函数：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, as soon as the thread execution enters the loop, the call to `std::lock`
    locks the two mutexes. Two `std::lock_guard` instances are constructed for each
    mutex. The `std::adopt_lock` parameter is supplied in addition to the mutex instance
    to `std::lock_guard` to indicate that the mutexes are already locked, and they
    should just adopt the ownership of the existing lock on the mutex rather than
    attempt to lock the mutex in the constructor. This guarantees safe unlocking,
    even in exceptional cases.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一旦线程执行进入循环，对`std::lock`的调用会锁定两个互斥锁。为每个互斥锁构造了两个`std::lock_guard`实例。除了互斥锁实例之外，还提供了`std::adopt_lock`参数给`std::lock_guard`，以指示互斥锁已经被锁定，它们应该只是接管现有锁的所有权，而不是尝试在构造函数中锁定互斥锁。这保证了安全的解锁，即使在异常情况下也是如此。
- en: However, `std::lock` can help you to avoid deadlocks in cases where the program
    demands the locking of two or more mutexes at the same time; it doesn't help if
    they are acquired separately. Deadlocks are one of the hardest problems that can
    occur in a multithreaded program. It ultimately relies on the discipline of a
    programmer to not get into any deadlock situations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`std::lock`可以帮助您避免死锁，因为程序要求同时锁定两个或多个互斥锁时，它并不会帮助您解决问题。死锁是多线程程序中可能发生的最困难的问题之一。它最终依赖于程序员的纪律，不要陷入任何死锁情况。
- en: Locking with std::unique_lock
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::unique_lock进行锁定
- en: Compared to `std::lock_guard`, `std::unique_lock` provides a bit more flexibility
    in operations. An `std::unique_lock` instance doesn't always own a mutex associated
    with it. Firstly, you can pass `std::adopt_lock` as a second argument to the constructor
    to manage a lock on a mutex similar to `std::lock_guard`. Secondly, the mutex
    can remain unlocked during construction by passing `std::defer_lock` as a second
    argument to the constructor. So, later in the code, a lock can be acquired by
    calling `lock()` on the same `std::unique_lock` object. But the flexibility available
    with `std::unique_lock` comes with a price; it is a bit slower than `lock_guard`
    in regards to storing this extra information and is in need of an update. Therefore,
    it is recommended to use `lock_guard` unless there is a real need for the flexibility
    that `std::unique_lock` offers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::lock_guard`相比，`std::unique_lock`在操作上提供了更多的灵活性。`std::unique_lock`实例并不总是拥有与之关联的互斥锁。首先，您可以将`std::adopt_lock`作为第二个参数传递给构造函数，以管理与`std::lock_guard`类似的互斥锁上的锁。其次，通过将`std::defer_lock`作为第二个参数传递给构造函数，在构造期间互斥锁可以保持未锁定状态。因此，稍后在代码中，可以通过在同一`std::unique_lock`对象上调用`lock()`来获取锁。但是，`std::unique_lock`提供的灵活性是有代价的；它在存储额外信息方面比`lock_guard`慢一些，并且需要更新。因此，建议除非确实需要`std::unique_lock`提供的灵活性，否则使用`lock_guard`。
- en: Another interesting feature about `std::unique_lock` is its ability to transfer
    ownership. Since `std::unique_lock` must own its associated mutexes, this results
    in the ownership transfer of mutexes. Similar to `std::thread`, the `std::unique_lock`
    class is also a move only type. All of the move semantic language nuances and
    rvalue reference handling available in the C++ standard library applies to `std::unique_lock`
    as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`std::unique_lock`的另一个有趣特性是其所有权转移的能力。由于`std::unique_lock`必须拥有其关联的互斥锁，这导致互斥锁的所有权转移。与`std::thread`类似，`std::unique_lock`类也是一种只能移动的类型。C++标准库中提供的所有移动语义语言细微差别和右值引用处理都适用于`std::unique_lock`。
- en: 'The availability of member functions such as `lock()` and `unlock()`, similar
    to `std::mutex`, increases the flexibility of its use in code compared to `std::lock_guard`.
    The ability to release the lock before an `std::unique_lock` instance is destroyed,
    meaning that you can optionally release it anywhere in the code if it''s obvious
    that the lock is no longer required. Holding down the lock unnecessarily can drop
    the performance of the application drastically, since the threads waiting for
    locks are prevented from executing for longer than is necessary. Hence, `std::unique_lock`
    is a very handy feature introduced by the C++ standard library, which supports
    RAII idiom, and it can effectively minimize the size of a critical section of
    the applicable code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::mutex`类似，具有`lock()`和`unlock()`等成员函数的可用性增加了它在代码中的灵活性，相对于`std::lock_guard`。在`std::unique_lock`实例被销毁之前释放锁的能力意味着，如果明显不再需要锁，可以在代码的任何地方选择性地释放它。不必要地持有锁会严重降低应用程序的性能，因为等待锁的线程会被阻止执行比必要时间更长的时间。因此，`std::unique_lock`是C++标准库引入的非常方便的功能，支持RAII习惯用法，并且可以有效地最小化适用代码的关键部分的大小：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, you can see the fine-grained locking achieved by leveraging
    the flexibility of `std::unique_lock`. As the function starts its execution, an
    `std::unique_lock` object is constructed with `global_mutex` in an unlocked state.
    Immediately, data is prepared with params, which don't require exclusive access;
    it is executing freely. Before retrieving the prepared data, the `local_lock`
    is marking the beginning of a critical section using the lock member function
    in `std::unique_lock`. As soon as the data retrieval is over, the lock is released,
    marking the end of the critical section. Followed by that, a call to the `process_data()`
    function, which again does not require exclusive access, is getting executed freely.
    Finally, before the execution of the `store_result()` function, the mutex is locked
    to protect the write operation, which updates the processed result. When exiting
    the function, the lock gets released when the local instance of `std::unique_lock`
    is destroyed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到通过利用`std::unique_lock`的灵活性实现的细粒度锁定。当函数开始执行时，使用`global_mutex`构造了一个处于未锁定状态的`std::unique_lock`对象。立即准备了不需要独占访问的参数，它可以自由执行。在检索准备好的数据之前，`local_lock`使用`std::unique_lock`中的lock成员函数标记了关键部分的开始。一旦数据检索完成，锁将被释放，标志着关键部分的结束。在此之后，调用`process_data()`函数，再次不需要独占访问，可以自由执行。最后，在执行`store_result()`函数之前，锁定互斥锁以保护更新处理结果的写操作。在退出函数时，当`std::unique_lock`的局部实例被销毁时，锁将被释放。
- en: Condition variables
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件变量
- en: We already know that mutexes can be used to share common resources and synchronize
    operations between threads. But synchronization using mutexes is a little complex
    and deadlock-prone if you are not careful. In this section, we will discuss how
    to wait for events with condition variables and how to use them for synchronization
    in an easier way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道互斥锁可以用于共享公共资源并在线程之间同步操作。但是，如果不小心使用互斥锁进行同步，会变得有点复杂并容易发生死锁。在本节中，我们将讨论如何使用条件变量等待事件，以及如何以更简单的方式在同步中使用它们。
- en: When it comes to synchronization using mutexes, if the waiting thread has acquired
    a lock over a mutex, it can't be locked by any other thread. Also, waiting for
    one thread to complete its execution by checking on a status flag periodically
    that is protected by a mutex is a waste of CPU resources. This is because these
    resources can be effectively utilized by other threads in the system rather than
    having to wait for a longer time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及使用互斥锁进行同步时，如果等待的线程已经获得了对互斥锁的锁定，那么任何其他线程都无法锁定它。此外，通过定期检查由互斥锁保护的状态标志来等待一个线程完成执行是一种浪费CPU资源。这是因为这些资源可以被系统中的其他线程有效利用，而不必等待更长的时间。
- en: 'To address these problems, the C++ standard library has provided two implementations
    of conditional variables: `std::condition_variable` and `std::condition_variable_any`.
    Both are declared inside the `<condition_variable>` library header, and both the
    implementations need to work with a mutex to synchronize threads. The implementation
    of `std::condition_variable` is limited to working with `std::mutex`. On the other
    hand, `std::condition_variable_any` can work with anything that meets mutex-like
    criteria (mutex-like semantics), hence `suffix _any`. Because of its generic behavior,
    `std::condition_variable_any` ends up consuming more memory and degrades performance.
    It is not recommended unless a real, tailored requirement is in place.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，C++标准库提供了两种条件变量的实现：`std::condition_variable`和`std::condition_variable_any`。两者都声明在`<condition_variable>`库头文件中，两种实现都需要与互斥锁一起工作以同步线程。`std::condition_variable`的实现仅限于与`std::mutex`一起工作。另一方面，`std::condition_variable_any`可以与满足类似互斥锁标准的任何东西一起工作，因此带有`_any`后缀。由于其通用行为，`std::condition_variable_any`最终会消耗更多内存并降低性能。除非有真正的、定制的需求，否则不建议使用它。
- en: 'The following program is an implementation of odd-even threads that we discussed
    when we talked about mutexes, which is now being re-implemented using condition
    variables:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序是我们在讨论互斥锁时讨论过的奇偶线程的实现，现在正在使用条件变量进行重新实现。
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The program starts with the declaration of a mutex, a conditional variable,
    and two Boolean flags globally so that we can synchronize them between two threads.
    The `printEven` function gets executed in a worker thread and prints only even
    numbers starting from 0\. Here, when it enters the loop, the mutex is protected
    with `std::unique_lock` instead of `std::lock_guard`; we will see the reason for
    that in a moment. The thread then calls the `wait()` function in `std::condition_variable`,
    passing the lock object and a Lambda predicate function that expresses the condition
    being waited for. This can be replaced with any callable object that returns bool.
    In this function, the predicate function returns the `bEvenReady` flag, so that
    the function continues execution when it becomes true. If the predicate returns
    false, the `wait()` function will unlock the mutex and wait for another thread
    to notify it, hence the `std::unique_lock` object comes handy here with the provided
    flexibility to lock and unlock.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从全局声明一个互斥锁、一个条件变量和两个布尔标志开始，以便在两个线程之间进行同步。`printEven`函数在一个工作线程中执行，并且只打印从0开始的偶数。在这里，当它进入循环时，互斥锁受到`std::unique_lock`的保护，而不是`std::lock_guard`；我们马上就会看到原因。然后线程调用`std::condition_variable`中的`wait()`函数，传递锁对象和一个Lambda谓词函数，表达了正在等待的条件。这可以用任何返回bool的可调用对象替换。在这个函数中，谓词函数返回`bEvenReady`标志，以便在它变为true时函数继续执行。如果谓词返回false，`wait()`函数将解锁互斥锁并等待另一个线程通知它，因此`std::unique_lock`对象在这里非常方便，提供了锁定和解锁的灵活性。
- en: 'As soon as `std::cout` prints the loop index, the `bEvenReady` flag is raised
    to false and `bOddReady` is raised to true. Then, the call to the `notify_one()`
    function associated with `syncCond` signals the waiting odd thread to write an
    odd number into the standard output stream:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`std::cout`打印循环索引，`bEvenReady`标志就会被设置为false，`bOddReady`标志则会被设置为true。然后，与`syncCond`相关联的`notify_one()`函数的调用会向等待的奇数线程发出信号，要求其将奇数写入标准输出流：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `printOdd` function gets executed in another worker thread and prints only
    odd numbers starting from `1`. Like the `printEven` function, a loop iterates
    and prints the index that is protected by the globally declared conditional variable
    and mutex. Unlike the `printEven` function, the predicate used in the `wait()`
    function of a condition variable returns `bOddReady`, and the `bEvenReady` flag
    is raised to `true` and the `bOddReady` flag is raised to `false`. Followed by
    that, calling the `notify_one()` function associated with `syncCond` signals the
    waiting even thread to write an even number into the standard output stream. This
    interleaved printing of even and odd numbers continues until the max value:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`printOdd`函数在另一个工作线程中执行，并且只打印从`1`开始的奇数。与`printEven`函数不同，循环迭代并打印由全局声明的条件变量和互斥锁保护的索引。在`std::condition_variable`的`wait()`函数中使用的谓词返回`bOddReady`，`bEvenReady`标志被设置为`true`，`bOddReady`标志被设置为`false`。随后，调用与`syncCond`相关联的`notify_one()`函数会向等待的偶数线程发出信号，要求其将偶数写入标准输出流。这种奇偶数交替打印将持续到最大值：'
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The main function launches two background threads, `t1`, which is associated
    with the `printEven` function and `t2`, which is associated with the `printOdd`
    function. The output starts when even parity is confirmed by raising the `bEvenReady`
    flag to true before the threads are launched.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数启动两个后台线程，`t1`与`printEven`函数相关联，`t2`与`printOdd`函数相关联。输出在确认偶数奇数性之前开始，通过将`bEvenReady`标志设置为true。
- en: A thread-safe stack data structure
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程安全的堆栈数据结构
- en: 'So far, we have discussed how to launch and manage a thread, and how to synchronize
    the operations between concurrent threads. But, when it comes to actual systems,
    the data is represented in the form of data structures, which must be chosen appropriately
    for the situation to guarantee the performance of the program. In this section,
    we are going to discuss how to design a concurrent stack using conditional variables
    and mutexes. The following program is a wrapper to `std::stack`, which is declared
    under the library header `<stack>`, and the stack wrapper will be available with
    different overloads for pop and push functionalities (this has been done to keep
    the listing small, and this also demonstrates how we can adapt a sequential data
    structure to work in a concurrent context):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何启动和管理线程，以及如何在并发线程之间同步操作。但是，当涉及到实际系统时，数据以数据结构的形式表示，必须根据情况选择适当的数据结构，以确保程序的性能。在本节中，我们将讨论如何使用条件变量和互斥量设计并发栈。以下程序是
    `std::stack` 的包装器，声明在库头文件 `<stack>` 下，并且栈包装器将提供不同的 pop 和 push 功能的重载（这样做是为了保持清单的简洁，并且还演示了如何将顺序数据结构调整为在并发上下文中工作）：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `Stack` class contains an object to the template class `std::stack`, along
    with member variables for `std::mutex` and `std::condition_variable`. The constructor
    and destructor of the class are marked as default, letting the compiler generate
    a default implementation for those, and the copy assignment operator is marked
    as delete to prevent the invocation of the assignment operator of this class at
    compile time itself. The copy constructor is defined, which copies the `std::stack`
    member object `myData`, by invoking its own copy assignment operator, which is
    protected by the right-hand side object''s mutex:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack` 类包含模板类 `std::stack` 的对象，以及 `std::mutex` 和 `std::condition_variable`
    的成员变量。类的构造函数和析构函数标记为默认，让编译器为其生成默认实现，并且复制赋值运算符标记为删除，以防止在编译时调用此类的赋值运算符。定义了复制构造函数，它通过调用自己的复制赋值运算符来复制
    `std::stack` 成员对象 `myData`，该操作受到右侧对象的互斥量保护：'
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The member function `push()` is wrapping the `push` function of `std::stack
    container`. As you can see, the mutex member variable, `myMutex`, is locked by
    an `std::lock_guard` object to safeguard the `push` operation that follows in
    the next line. Followed by that, the `notify_one()` function is invoked using
    the member `std::condition_variable` object to raise an event to notify the waiting
    threads over this same condition variable. There are two overloads of the `pop`
    operation that you will see in the following code listings, which wait over this
    condition variable to get signaled:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数 `push()` 包装了 `std::stack` 容器的 `push` 函数。可以看到，互斥量成员变量 `myMutex` 被 `std::lock_guard`
    对象锁定，以保护接下来的 `push` 操作。随后，使用成员 `std::condition_variable` 对象调用 `notify_one()` 函数，以通过相同的条件变量引发事件来通知等待的线程。在以下代码清单中，您将看到
    `pop` 操作的两个重载，它们等待在此条件变量上得到信号：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `try_pop()` function takes a template argument as a reference. Since the
    implementation never waits for the stack to fill at least one element, this uses
    the `std::lock_guard` object to protect the thread. The function returns `false`
    if the stack is empty, otherwise it returns `true`. Here, the output is assigned
    to input a reference argument by invoking the `top()` function of `std::stack`,
    which returns the topmost element in the stack, followed by the `pop()` function
    to clear the topmost element from the stack. All overloads for the `pop` function
    invoke the `top()` function followed by a call to the `pop()` function of `std::stack`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_pop()` 函数以模板参数作为引用。由于实现从不等待栈至少填充一个元素，因此使用 `std::lock_guard` 对象来保护线程。如果栈为空，函数返回
    `false`，否则返回 `true`。在这里，输出通过调用 `std::stack` 的 `top()` 函数分配给输入引用参数，该函数返回栈中的顶部元素，然后调用
    `pop()` 函数来清除栈中的顶部元素。所有 `pop` 函数的重载都调用 `top()` 函数，然后调用 `std::stack` 的 `pop()`
    函数：'
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is another overload of the `try_pop()` function, which returns an instance
    of `std::shared_ptr` (smart pointer) of the template type. As you have already
    seen, the `try_pop` function overloads, and never waits for a stack to fill at
    least one element; therefore, this implementation uses `std::lock_guard`. If the
    internal stack is empty, the function returns an instance of `std::shared_ptr`
    and holds no element of the stack. Otherwise, a `std::shared_ptr` instance that
    holds the top element of the stack is returned:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `try_pop()` 函数的另一个重载，它返回模板类型的 `std::shared_ptr`（智能指针）的实例。正如您已经看到的，`try_pop`
    函数有多个重载，并且从不等待栈至少填充一个元素；因此，此实现使用 `std::lock_guard`。如果内部栈为空，函数返回 `std::shared_ptr`
    的实例，并且不包含栈的任何元素。否则，返回包含栈顶元素的 `std::shared_ptr` 实例：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So far, the overloads of the `pop` function are not waiting for the stack to
    fill at least one element if it is empty. To achieve that, two more overloads
    of the `pop` function are added, which uses the wait function associated with
    `std::condition_variable`. The first implementation returns the template value
    as an output argument, and the second one returns an `std::shared_ptr` instance.
    Both functions use `std::unique_lock` to control the mutex in order to supply
    the `wait()` function of `std::condition_variable`. In the `wait` function, the
    `predicate` function is checking whether the stack is empty or not. If the stack
    is empty, then the `wait()` function unlocks the mutex and continues to wait until
    a notification is received from the `push()` function. As soon as the push is
    called, the predicate will return true, and `wait_n_pop` continues its execution.
    The function overload takes the template reference and assigns the top element
    into the input argument, and the latter implementation returns an `std::shared_ptr`
    instance, holding the top element.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`pop`函数的重载不会等待堆栈至少填充一个元素，如果它是空的。为了实现这一点，添加了`pop`函数的另外两个重载，它们使用与`std::condition_variable`相关的等待函数。第一个实现将模板值作为输出参数返回，第二个实现返回一个`std::shared_ptr`实例。这两个函数都使用`std::unique_lock`来控制互斥锁，以便提供`std::condition_variable`的`wait()`函数。在`wait`函数中，`predicate`函数正在检查堆栈是否为空。如果堆栈为空，那么`wait()`函数会解锁互斥锁，并继续等待，直到从`push()`函数接收到通知。一旦调用了push，predicate将返回true，`wait_n_pop`继续执行。函数重载接受模板引用，并将顶部元素分配给输入参数，后一个实现返回一个包含顶部元素的`std::shared_ptr`实例。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the threading library available in C++ standard
    libraries. We saw how to launch and manage a thread, and discussed different aspects
    of the threading library, such as how to pass arguments into a thread, ownership
    management of a thread object, sharing of data between threads, and so on. The
    C++ standard threading library can execute most callable objects as threads! We
    have seen the importance of all the available callable objects in association
    with threads, such as `std::function`, Lambdas, and functors. We discussed the
    synchronization primitives available in the C++ standard library, starting with
    the simple `std::mutex`, the use of the RAII idiom to protect mutexes from unhandled
    exit cases to avoid explicit unlock, and using classes such as `std::lock_guard`
    and `std::unique_lock`. We also discussed condition variables (`std::condition_variable`)
    in the context of thread synchronization. This chapter lays a good foundation
    for concurrency support introduced in modern C++ to kickstart the journey of this
    book into functional idioms.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了C++标准库中可用的线程库。我们看到了如何启动和管理线程，并讨论了线程库的不同方面，比如如何将参数传递给线程，线程对象的所有权管理，线程之间数据的共享等等。C++标准线程库可以执行大多数可调用对象作为线程！我们看到了所有可用的可调用对象与线程的关联的重要性，比如`std::function`，Lambda和函数对象。我们讨论了C++标准库中可用的同步原语，从简单的`std::mutex`开始，使用RAII习惯用法来保护互斥锁免受未处理的退出情况的影响，以避免显式解锁，并使用诸如`std::lock_guard`和`std::unique_lock`之类的类。我们还讨论了条件变量(`std::condition_variable`)在线程同步的上下文中。本章为现代C++引入的并发支持奠定了良好的基础，为本书进入功能习惯打下了基础。
- en: In the following chapter, we will be covering more concurrency library features
    in C++, such as task-based parallelism and lock-free programming.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将涵盖C++中更多的并发库特性，比如基于任务的并行性和无锁编程。
