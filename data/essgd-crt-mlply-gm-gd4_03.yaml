- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Making a Lobby to Gather Players Together
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个大厅以聚集玩家
- en: In the previous chapter, we discussed how to use UDP packets to exchange data
    between multiple players in a game. While this approach is highly efficient, it
    requires a lot of manual work to ensure that data is sent and received correctly.
    In this chapter, we will explore the high-level network API of the Godot Engine,
    which simplifies the networking process by providing a set of built-in tools and
    functions that can handle common network tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何使用UDP数据包在游戏中的多个玩家之间交换数据。虽然这种方法非常高效，但需要大量手动工作来确保数据能够正确发送和接收。在本章中，我们将探讨Godot引擎的高级网络API，它通过提供一组内置工具和函数来简化网络过程，从而简化了网络操作。
- en: Specifically, we will focus on the **ENetMultiplayerPeer API**, which is the
    Godot Engine’s wrapper class for its ENet library implementation, and **Remote
    Procedure Call** (**RPC**), a communication protocol that allows us to make calls
    to functions and methods on remote computers as if we were making them locally.
    We will use these tools to create a lobby, authenticate players, retrieve player
    avatar data from a fake JSON database, and synchronize all players when a player
    enters the lobby. We will explore the benefits of using RPCs instead of exchanging
    UDP packets, and how this approach can simplify the process of synchronizing game
    states between multiple players.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将重点关注**ENetMultiplayerPeer API**，这是Godot引擎为其ENet库实现提供的包装类，以及**远程过程调用**（**RPC**），这是一种通信协议，允许我们像在本地调用一样对远程计算机上的函数和方法进行调用。我们将使用这些工具来创建大厅，验证玩家身份，从伪造的JSON数据库中检索玩家头像数据，并在玩家进入大厅时同步所有玩家。我们将探讨使用RPC而不是交换UDP数据包的好处，以及这种方法如何简化在多个玩家之间同步游戏状态的过程。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Calling functions remotely with RPCs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RPC远程调用函数
- en: Understanding the multiplayer authority
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多人游戏权限
- en: Comparing UDP and ENet approaches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较UDP和ENet方法
- en: Remaking the login screen with RPCs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RPC重新制作登录界面
- en: Adding the player’s avatar
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加玩家的头像
- en: Retrieving players’ avatars
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索玩家头像
- en: Testing the lobby
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试大厅
- en: By the end of this chapter, you will have a solid understanding of how to use
    the Godot Engine’s high-level network API and RPCs to create a robust multiplayer
    lobby for your game.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将牢固地理解如何使用Godot引擎的高级网络API和RPC来创建一个健壮的多玩家大厅。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will build yet another project using the Godot Engine. Remember,
    throughout this book, we are using Godot Engine version 4.0, so this is also a
    requirement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Godot引擎构建另一个项目。记住，在整个本书中，我们使用的是Godot引擎版本4.0，这也是一个要求。
- en: 'This time around, we are going to use the files provided in the `res://03.making-lobby-to-gather-players`
    folder. So, if you don’t have the project repository yet, download it through
    this link:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用`res://03.making-lobby-to-gather-players`文件夹中提供的文件。所以，如果你还没有项目仓库，可以通过这个链接下载它：
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
- en: Then, with the project added to your Godot Engine’s project manager, open the
    project and proceed to the `res://03.making-lobby-to-gather-players` folder.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将项目添加到Godot引擎的项目管理器中，打开项目并进入`res://03.making-lobby-to-gather-players`文件夹。
- en: Calling functions remotely with RPCs
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RPC远程调用函数
- en: In a network context, **RPC** stands for **remote procedure call**, which is
    a protocol that allows one program to call a function or procedure on another
    program running on a different machine or over a network. In the context of the
    Godot Engine, RPCs allow objects to exchange data between each other over the
    network, which is a key feature in creating multiplayer games.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络环境中，**RPC**代表**远程过程调用**，这是一种协议，允许一个程序在另一台机器或网络上运行的程序上调用函数或过程。在Godot引擎的上下文中，RPC允许对象在网络之间交换数据，这是创建多人游戏的关键特性。
- en: To use RPCs in the Godot Engine, we need to use the `ENetMultiplayerPeer` API,
    which provides a high-level network interface for handling network connections
    and sending and receiving data, as well as managing RPCs. By using `ENetMultiplayerPeer`,
    we can easily send and receive RPCs and handle network communication more straightforwardly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Godot 引擎中使用 RPCs，我们需要使用 `ENetMultiplayerPeer` API，它提供了一个高级网络接口，用于处理网络连接、发送和接收数据，以及管理
    RPCs。通过使用 `ENetMultiplayerPeer`，我们可以轻松发送和接收 RPCs，并更直接地处理网络通信。
- en: When exchanging data with RPCs, objects can exchange data through functions,
    which makes the process more straightforward compared to exchanging data using
    UDP packets. With UDP packets, we need to send packets requesting procedures and
    wait for a response, and only then can we get the data. This process can be complex
    and difficult to manage, as we saw in the previous chapter, especially in large
    games with many objects exchanging data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 RPCs 交换数据时，对象可以通过函数交换数据，这使得过程比使用 UDP 数据包交换数据更直接。使用 UDP 数据包时，我们需要发送请求程序的包并等待响应，然后才能获取数据。这个过程可能很复杂且难以管理，正如我们在上一章中看到的，尤其是在有大量对象交换数据的大型游戏中。
- en: One limitation of RPCs is that they don’t allow the transmission of objects,
    such as nodes or resources, through the network. This can be a challenge in games
    that require the exchange of complex objects between different machines. However,
    there are workarounds to this limitation, such as sending serialized data or using
    custom serialization methods. We learned how to do that in [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037),
    *Sending and Receiving Data*, so this won’t be a problem to us.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: RPCs 的一项限制是它们不允许通过网络传输对象，如节点或资源。这对于需要在不同机器之间交换复杂对象的游戏来说可能是一个挑战。然而，有几种方法可以解决这个问题，例如发送序列化数据或使用自定义序列化方法。我们在[*第
    2 章*](B18527_02.xhtml#_idTextAnchor037)，“发送和接收数据”中学习了如何做到这一点，所以这对我们来说不会是问题。
- en: RPCs are a powerful tool for creating multiplayer games, and using the `ENetMultiplayerPeer`
    API in the Godot Engine makes it easy to use them. Although there are limitations
    to RPCs, such as the inability to transmit objects over the network, they are
    still a crucial part of creating a robust and seamless multiplayer experience.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: RPCs 是创建多人游戏的有力工具，在 Godot 引擎中使用 `ENetMultiplayerPeer` API 可以轻松使用它们。尽管 RPCs 有局限性，例如无法通过网络传输对象，但它们仍然是创建强大且无缝多人体验的关键部分。
- en: Introducing the @rpc annotation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 @rpc 注解
- en: Godot Engine 4.0 introduces a new feature called `@rpc` function annotation.
    An `@rpc`, this annotation is used to mark functions that can be called remotely
    over the network in a multiplayer game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 引擎 4.0 引入了一个名为 `@rpc` 函数注解的新功能。`@rpc` 注解用于标记在多人游戏中可以通过网络远程调用的函数。
- en: There are several options that we can add to the `@rpc` annotation, which control
    how the function is called and executed over the network.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 `@rpc` 注解添加几个选项，这些选项控制了函数在网络上的调用和执行方式。
- en: 'Let’s take a closer look at each option:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每个选项：
- en: 'We have the calling options, meaning what should happen when we make an RPC
    to this function:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有调用选项，这意味着当我们对这个函数进行远程过程调用（RPC）时会发生什么：
- en: '`call_remote`: This option indicates that the function should only be called
    remotely on instances of the node in other peers’ machines but not on the node’s
    local instance.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call_remote`: 这个选项表示该函数应该只在其他节点的节点实例上远程调用，而不是在节点的本地实例上调用。'
- en: '`call_local`: This option indicates that the function should also be called
    locally on the current peer’s instance of the node as well. This is useful when
    we need to sync all peers in the network, including the caller.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call_local`: 这个选项表示该函数也应该在当前节点的本地实例上调用。这在我们需要同步网络中的所有节点，包括调用者时非常有用。'
- en: 'Then, we have the caller option, meaning who can call this function remotely:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有调用者选项，意味着谁可以远程调用这个函数：
- en: '`authority`: This option indicates that the function should only be called
    by the multiplayer authority. We’ll see more about that soon.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authority`: 这个选项表示该函数只能由多人游戏管理权限调用。我们很快就会看到更多关于它的内容。'
- en: '`any_peer`: This option indicates that the function can be called by any peer
    in the network. This is useful for functions that can be executed by multiple
    peers in a multiplayer game and not only the multiplayer authority.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any_peer`: 这个选项表示该函数可以被网络中的任何节点调用。这对于那些可以被多个节点在多人游戏中执行，而不仅仅是多人游戏管理权限的函数来说非常有用。'
- en: 'We also have options regarding the reliability of the remote data exchange
    when we make an RPC to this function:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们向此函数发出RPC时，我们还有关于远程数据交换可靠性的选项：
- en: '`reliable`: This option indicates that the function should be executed reliably
    over the network, which means that the function call will be guaranteed to arrive
    at its destination. This is useful for functions that need to be executed without
    the risk of losing data.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reliable`: 此选项表示函数应在网络上可靠地执行，这意味着函数调用将保证到达其目的地。这对于需要无数据丢失风险执行的函数是有用的。'
- en: '`unreliable`: This option indicates that the function should be executed with
    low reliability, which means that there is a chance that some data may be lost
    or delayed over the network. This is useful for functions that can tolerate some
    loss of data.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unreliable`: 此选项表示函数应以低可靠性执行，这意味着在网络中可能有一些数据可能会丢失或延迟。这对于可以容忍一些数据丢失的函数是有用的。'
- en: '`unreliable_ordered`: This option is similar to `unreliable` but ensures that
    function calls are executed in order over the network. This is useful for functions
    that need to be executed in a specific order but can tolerate some data loss.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unreliable_ordered`: 此选项与`unreliable`类似，但确保函数调用在网络中按顺序执行。这对于需要按特定顺序执行但可以容忍一些数据丢失的函数是有用的。'
- en: We can also specify which connection channel the RPC should use to transmit
    its data. This is useful to prevent bottlenecking or to dedicate some channels
    for specific functions. For instance, we can pick a channel that uses `reliable`
    data, such as the transmission of a message between players. Then, we can have
    another channel that uses `unreliable_ordered` data, such as updating peers about
    their avatars’ current position.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定RPC应该使用哪个连接通道来传输其数据。这有助于防止瓶颈或为特定功能保留一些通道。例如，我们可以选择使用`reliable`数据的通道，例如玩家之间消息的传输。然后，我们可以有另一个使用`unreliable_ordered`数据的通道，例如更新玩家关于他们头像当前位置的信息。
- en: In that sense, we just need the most recent position to arrive; every other
    call with previous positions is irrelevant. So, while one channel waits for messages
    to arrive, the other is constantly receiving new updates about avatars’ positions
    and neither of them blocks the other.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种意义上，我们只需要最新的位置信息到达；其他任何带有先前位置的调用都是无关紧要的。因此，当一个通道等待消息到达时，另一个通道会持续接收关于头像位置的新更新，并且它们都不会阻塞对方。
- en: 'The order in which we pass these options doesn’t matter for the Godot Engine
    itself. The only exception is the channel, which should always be the *last option*
    passed. Take the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递这些选项的顺序对于Godot引擎本身来说并不重要。唯一的例外是通道，它应该是传递的*最后一个选项*。以下是一个例子：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These two ways of establishing the RPC options are the same and both will work.
    Now, the following annotation has an issue:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 建立RPC选项的这两种方式是相同的，并且都会生效。现在，以下注释存在一个问题：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Only the second RPC annotation will work, because we are passing the channel
    as the last argument of the annotation. In the first RPC annotation example, we
    are passing the channel as the first argument, so it won’t work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 只有第二个RPC注释会生效，因为我们把通道作为注释的最后一个参数传递。在第一个RPC注释示例中，我们把通道作为第一个参数传递，所以它不会生效。
- en: Now that we understand how we can mark a function as an `rpc` function and what
    options we can use to fine-tune it and achieve what we need in our game, let’s
    see what we need to be able to call such functions and propagate them across the
    network.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何将一个函数标记为`rpc`函数以及我们可以使用哪些选项来微调它并实现我们在游戏中的需求，让我们看看我们需要什么才能调用这样的函数并将它们在网络中传播。
- en: What’s necessary for an RPC?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RPC需要什么？
- en: To make RPCs in the Godot Engine, first, we must set up an `ENetMultiplayerPeer`
    connection, which manages the network connection and handles the transmission
    of data between nodes. We did that in the first chapter, but we will also go through
    the process here as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Godot引擎中实现RPC，首先，我们必须设置一个`ENetMultiplayerPeer`连接，它管理网络连接并处理节点之间的数据传输。我们在第一章中已经做到了这一点，但我们也会在这里介绍这个过程。
- en: Once the `ENetMultiplayerPeer` connection is set up, we must ensure that the
    `NodePath` to the nodes receiving the RPC is exact. This means that the `NodePath`
    to the target node must be identical on all peers in the network. If the `NodePath`
    is not exact, the RPC may not be sent to the correct node or may not be sent at
    all.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了 `ENetMultiplayerPeer` 连接，我们必须确保接收 RPC 的节点的 `NodePath` 是精确的。这意味着目标节点的 `NodePath`
    必须在网络中的所有玩家上完全相同。如果 `NodePath` 不精确，RPC 可能不会被发送到正确的节点，或者根本不会发送。
- en: We can establish a default name for our root nodes to avoid issues. We chose
    the root node to facilitate the logic afterward as it is the first node in the
    hierarchy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的根节点设置一个默认名称以避免问题。我们选择根节点来方便之后的逻辑，因为它是在层次结构中的第一个节点。
- en: 'For instance, in our upcoming `Main`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的即将到来的 `Main` 中：
- en: '![Figure 3.1 – The ServerLobby, LoginScreen, and ClientLobby scenes with their
    root node named Main](img/Figure_03.01_B18527.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – ServerLobby、LoginScreen 和 ClientLobby 场景及其根节点命名为 Main](img/Figure_03.01_B18527.jpg)'
- en: Figure 3.1 – The ServerLobby, LoginScreen, and ClientLobby scenes with their
    root node named Main
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – ServerLobby、LoginScreen 和 ClientLobby 场景及其根节点命名为 Main
- en: It’s also important to note that every node in the network should share all
    the methods marked with `@rpc`, even if they are not called or used by anyone.
    This is because the Godot Engine requires all nodes to have access to the same
    set of methods to function properly. This can be a minor inconvenience for developers
    as it may bloat some classes with unnecessary methods, but it is necessary for
    Godot’s networking system to work effectively.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，网络中的每个节点都应该共享所有标记为 `@rpc` 的方法，即使它们没有被任何人调用或使用。这是因为 Godot 引擎要求所有节点都能访问相同的方法集以正常工作。这可能对开发者来说是一个小的不便，因为它可能会使一些类膨胀，包含不必要的函数，但对于
    Godot 的网络系统有效地工作来说是必要的。
- en: 'For instance, these are the methods found in each of the scenes that compose
    our upcoming **Lobby** project. Note that they all share the highlighted methods
    on top of their non-RPC methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这些是我们即将到来的 **大厅** 项目中每个场景中找到的方法。请注意，它们都在其非 RPC 方法之上共享突出显示的方法：
- en: '![Figure 3.2 – The Server.gd, LoginScreen.gd, and Client.gd scripts share functions
    marked with the @rpc annotation](img/Figure_03.02_B18527.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – Server.gd、LoginScreen.gd 和 Client.gd 脚本共享带有 @rpc 注解的函数](img/Figure_03.02_B18527.jpg)'
- en: Figure 3.2 – The Server.gd, LoginScreen.gd, and Client.gd scripts share functions
    marked with the @rpc annotation
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – Server.gd、LoginScreen.gd 和 Client.gd 脚本共享带有 @rpc 注解的函数
- en: Making RPCs in the Godot Engine requires setting up `ENetMultiplayerPeer` connections,
    ensuring that the `NodePath` to the target node is exact, and ensuring that all
    nodes in the network share all the methods marked as RPC. While this may require
    some additional setup and minor inconvenience, it enables developers to create
    multiplayer games easily and efficiently.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Godot 引擎中制作 RPC 需要设置 `ENetMultiplayerPeer` 连接，确保目标节点的 `NodePath` 是精确的，并确保网络中的所有节点共享所有标记为
    RPC 的方法。虽然这可能需要一些额外的设置和轻微的不便，但它使开发者能够轻松高效地创建多人游戏。
- en: With that, we understand the core of RPCs in the Godot Engine. We saw what we
    need to set our game to support RPCs, how the `@rpc` annotation works, and how
    we can tweak it to match our design. In one of those tweaking options, we saw
    that it’s possible to only allow the multiplayer authority to call a given RPC
    function. Let’s see what the multiplayer authority is and what we can do with
    it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们理解了 Godot 引擎中 RPC 的核心。我们看到了我们需要设置我们的游戏以支持 RPC，`@rpc` 注解是如何工作的，以及我们如何调整它以匹配我们的设计。在这些调整选项之一中，我们看到了只允许多人权限调用特定的
    RPC 函数是可能的。让我们看看多人权限是什么，以及我们可以用它做什么。
- en: Understanding the multiplayer authority
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多人权限
- en: In Godot Engine’s high-level network API, the **multiplayer authority** is a
    concept that refers to the node that has the authority to make decisions about
    a node state in a multiplayer game. When two or more peers are connected in a
    multiplayer game, it is important to have a centralized peer that decides what
    changes are valid and should be synchronized across all connected clients.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Godot 引擎的高级网络 API 中，**多人权限**是一个概念，指的是在多人游戏中有权决定节点状态的节点。当两个或更多玩家在多人游戏中连接时，拥有一个集中式的玩家来决定哪些更改是有效的并且应该同步到所有连接的客户端是非常重要的。
- en: The multiplayer authority is assigned to a specific peer in the game, usually
    the server or host, and this peer has the power to decide which changes from a
    given node should be accepted and synchronized across all connected clients. This
    is important because in a multiplayer game, multiple players may try to make changes
    to the game state at the same time, and it is the responsibility of the multiplayer
    authority to manage, verify, and synchronize these changes correctly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，多人权限被分配给特定的对等节点，通常是服务器或主机，这个节点有权决定哪些来自特定节点的更改应该被接受并在所有连接的客户端之间同步。这一点很重要，因为在多人游戏中，多个玩家可能会同时尝试更改游戏状态，而多人权限负责正确管理、验证和同步这些更改。
- en: Each connected client in a multiplayer game is assigned a unique peer ID, which
    is a number that identifies the client within the game’s network. Peer IDs are
    managed by the `Node.multiplayer.multiplayer_peer` object, which is a reference
    to the `ENetMultiplayerPeer` object, which handles the game’s network connection.
    The `multiplayer_peer` object can be used to send and receive data between connected
    clients, as well as to manage the state of the game’s network connection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏中，每个连接的客户端都会分配一个唯一的对等节点 ID，这是一个在游戏网络中识别客户端的数字。对等节点 ID 由 `Node.multiplayer.multiplayer_peer`
    对象管理，它是 `ENetMultiplayerPeer` 对象的引用，该对象处理游戏的网络连接。`multiplayer_peer` 对象可以用来在连接的客户端之间发送和接收数据，以及管理游戏网络连接的状态。
- en: We can use the `Node.get_multiplayer_authority()` method to retrieve the node’s
    current multiplayer authority, as well as set a different one using `Node.set_multiplayer_authority(),`
    passing the peer ID as an argument. Changing a node’s multiplayer authority will
    allow the new peer to make and sync changes to this node across the network, and
    this can be quite dangerous.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Node.get_multiplayer_authority()` 方法检索节点的当前多人权限，也可以使用 `Node.set_multiplayer_authority()`
    方法设置不同的权限，将节点 ID 作为参数传递。更改节点的多人权限将允许新的节点在网络上对节点进行更改和同步，这可能会相当危险。
- en: For instance, if a player is responsible for a node that contains its health,
    the player may somehow hack it and be able to self-manage their health, ultimately
    becoming immortal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个玩家负责包含其生命值的节点，玩家可能会以某种方式黑客攻击它，并能够自我管理他们的生命值，最终变得不朽。
- en: Comparing UDP and ENet approaches
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较UDP和ENet方法
- en: The `UDPServer` and `PacketPeerUDP` classes are lower-level networking tools
    that allow for the exchange of data through UDP packets. This approach requires
    more work from us, as we must manage the sending and receiving of packets ourselves.
    For example, to create a login system using `UDPServer` and `PacketPeerUDP`, we
    would need to create a packet that contains the user’s login information, send
    it to the server, and then wait for a response.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`UDPServer` 和 `PacketPeerUDP` 类是低级别的网络工具，允许通过 UDP 数据包交换数据。这种方法需要我们做更多的工作，因为我们必须自己管理数据包的发送和接收。例如，要使用
    `UDPServer` 和 `PacketPeerUDP` 创建登录系统，我们需要创建一个包含用户登录信息的数据包，将其发送到服务器，然后等待响应。'
- en: In [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037), *Sending and Receiving Data*
    project, we saw how to use `UDPServer` and `PacketPeerUDP` to pass data around.
    We saw that using these classes, we can serialize data and deserialize it on each
    end of the system, both client and server. Using this approach, we need to poll
    packets and wait for requests and responses to arrive. It does the trick, but
    you saw it can get a bit complicated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B18527_02.xhtml#_idTextAnchor037)的*发送和接收数据*项目中，我们看到了如何使用 `UDPServer`
    和 `PacketPeerUDP` 来传递数据。我们看到了使用这些类，我们可以在系统的每个端点（客户端和服务器）序列化和反序列化数据。使用这种方法，我们需要轮询数据包并等待请求和响应的到来。这确实有效，但你看到了它可能会变得有点复杂。
- en: One advantage of using the `UDPServer` and `PacketPeerUDP` classes is that they
    provide more control over the networking process, which can be useful for more
    complex games that require fine-tuned networking. However, this approach is also
    more error-prone, as we must handle the sending and receiving of packets ourselves,
    which can lead to issues such as packet loss or out-of-order packets.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UDPServer` 和 `PacketPeerUDP` 类的一个优点是它们提供了对网络过程的更多控制，这对于需要精细调整网络的高级游戏非常有用。然而，这种方法也更容易出现错误，因为我们必须自己处理数据包的发送和接收，这可能导致数据包丢失或数据包顺序错误等问题。
- en: On the other hand, using `ENetMultiplayerPeer` and RPCs provides a higher-level
    networking solution that simplifies the process of creating a login system. With
    this approach, developers can use the `@rpc` function annotation to mark a method
    as an RPC, which allows it to be called from any node in the network.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用`ENetMultiplayerPeer`和RPCs提供了一种更高级别的网络解决方案，简化了创建登录系统的过程。使用这种方法，开发者可以使用`@rpc`函数注释标记一个方法为RPC，这使得它可以从网络中的任何节点调用。
- en: For example, to create a login system using `ENetMultiplayerPeer` and RPCs,
    we can mark the method that handles the login process as an RPC, and then call
    it from the client nodes. We are going to see that in a moment, and you will understand
    how powerful and simple the Godot Engine’s high-level network API is.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用`ENetMultiplayerPeer`和RPCs创建登录系统，我们可以将处理登录过程的方法标记为RPC，然后从客户端节点调用它。我们将在稍后看到这一点，你将了解Godot引擎的高级网络API是多么强大和简单。
- en: Using `ENetMultiplayerPeer` and RPCs simplifies the networking process and makes
    it easier to create multiplayer games. The built-in features of `ENetMultiplayerPeer`,
    such as automatic packet ordering and error correction, make it easier to create
    a stable network connection. On top of that, the `@rpc` annotation makes it easy
    to call methods from any node in the network, simplifying the development process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ENetMultiplayerPeer`和RPCs简化了网络过程，并使创建多人游戏变得更加容易。`ENetMultiplayerPeer`的内置功能，如自动数据包排序和错误纠正，使得创建稳定的网络连接更加容易。此外，`@rpc`注释使得从网络中的任何节点调用方法变得简单，简化了开发过程。
- en: While the `UDPServer` and `PacketPeerUDP` classes provide more control over
    the networking process, using `ENetMultiplayerPeer` and RPCs offers a simpler
    and more streamlined approach to creating multiplayer games. The choice ultimately
    depends on the specific needs of the game you are making, but in most cases, using
    the higher-level tools provided by the Godot Engine will lead to a faster and
    more efficient development process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`UDPServer`和`PacketPeerUDP`类提供了对网络过程的更多控制，但使用`ENetMultiplayerPeer`和RPCs提供了创建多人游戏的更简单、更流畅的方法。最终的选择取决于你正在制作的游戏的具体需求，但在大多数情况下，使用Godot引擎提供的更高级别的工具将导致更快速、更高效的开发过程。
- en: Now that we understand how the Godot Engine’s high-level network API solves
    a lot of issues through the `ENetMultiplayerPeer` class and how it compares to
    the UDP approach, with major advantages, such as its ability to easily allow the
    RPC features we need to make our game easier, let’s remake the login screen we
    made in [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037), *Sending and Receiving
    Data*, using these new tools. This will allow us to use the high-level API while
    understanding the low-level approach and the advantages of using the high-level
    approach instead.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Godot引擎的高级网络API如何通过`ENetMultiplayerPeer`类解决许多问题，以及它与UDP方法相比的优势，比如它能够轻松地允许我们需要的RPC功能，使我们的游戏更容易，让我们重新制作在[*第二章*](B18527_02.xhtml#_idTextAnchor037)“发送和接收数据”中制作的登录界面，使用这些新工具。这将使我们能够在理解底层方法的同时，了解使用高级方法的优势。
- en: Remaking the login screen with RPCs
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RPCs重新制作登录界面
- en: Welcome back to our studio, fellow network engineer! In [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037),
    *Sending and Receiving Data*, we learned how to create a basic login system using
    the Godot Engine’s `UDPServer` and `PacketPeerUDP` classes. While this approach
    was perfect for our small-scale project, we need to level our game as we move
    forward and create a lobby!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎回到我们的工作室，亲爱的网络工程师！在[*第二章*](B18527_02.xhtml#_idTextAnchor037)“发送和接收数据”中，我们学习了如何使用Godot引擎的`UDPServer`和`PacketPeerUDP`类创建一个基本的登录系统。虽然这种方法非常适合我们的小型项目，但随着我们向前发展，我们需要提升游戏级别并创建一个大厅！
- en: Fear not, for we have the perfect solution for you – the Godot Engine’s `ENetMultiplayerPeer`
    and RPCs! These two powerful tools will help us build a robust and efficient system
    that can easily scale up to support multiple connected clients – as far as we
    researched, up to 4,095 simultaneously connected players!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，我们为你找到了完美的解决方案——Godot引擎的`ENetMultiplayerPeer`和RPCs！这两个强大的工具将帮助我们构建一个强大且高效的系统，可以轻松扩展以支持多个连接的客户端——根据我们的研究，最多可以支持4,095个同时连接的玩家！
- en: With the Godot Engine’s `ENetMultiplayerPeer`, we can easily manage multiple
    connections and synchronize game data across all connected clients. This means
    that our login system will be able to handle more connections, and our game will
    run smoother than ever before!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Godot引擎的`ENetMultiplayerPeer`，我们可以轻松管理多个连接并在所有连接的客户端之间同步游戏数据。这意味着我们的登录系统将能够处理更多的连接，我们的游戏将比以往任何时候都运行得更顺畅！
- en: With that, we will also be able to make RPCs! RPCs are an essential part of
    networking in the Godot Engine. They allow us to call functions on other nodes
    in the network as if they were local functions. With RPCs, we can easily share
    data and perform actions across all connected clients, making our login system
    even more robust and efficient.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们也将能够进行RPCs！RPCs是Godot引擎网络中的关键部分。它们允许我们在网络中的其他节点上调用函数，就像它们是本地函数一样。有了RPCs，我们可以轻松地在所有连接的客户端之间共享数据和执行操作，使我们的登录系统更加健壮和高效。
- en: So, get ready to level up our game, network engineer! In the upcoming sections,
    we’ll dive into implementing the new login system using `ENetMultiplayerPeer`
    and RPCs and synchronizing players’ avatars into a lobby.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，准备好提升我们的游戏，网络工程师！在接下来的章节中，我们将深入探讨使用`ENetMultiplayerPeer`和RPCs实现新登录系统，并将玩家头像同步到大厅。
- en: We’ll also cover some best practices and tips for working with `ENetMultiplayerPeer`
    and RPCs to ensure our multiplayer game runs smoothly and efficiently. With these
    powerful tools at our disposal, we’ll be able to create a multiplayer game that
    will wow players and leave them wanting more.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍一些使用`ENetMultiplayerPeer`和RPCs的最佳实践和技巧，以确保我们的多人游戏运行得既顺畅又高效。有了这些强大的工具，我们将能够创建一个令人惊叹的多人游戏，让玩家们欲罢不能。
- en: Let’s start by establishing connections between our players and the server using
    the `ENetMultiplayerPeer` API.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`ENetMultiplayerPeer`API在玩家和服务器之间建立连接开始。
- en: Establishing an ENetMultiplayerPeer connection
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立ENetMultiplayerPeer连接
- en: Let’s recap from the first chapter how to establish a connection using the high-level
    `ENetMultiplayerPeer` class. We’ll start with the server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一章回顾一下如何使用高级`ENetMultiplayerPeer`类建立连接。我们将从服务器开始。
- en: This time, we will also add elements such as the fake database and the logged
    users from our project from [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037), *Sending
    and Receiving Data*. This will allow us to authenticate players and keep track
    of who’s connected and their session tokens. Well, without further ado, let’s
    dive into it!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们还将添加来自[*第二章*](B18527_02.xhtml#_idTextAnchor037)“发送和接收数据”的元素，例如伪造的数据库和登录用户。这将使我们能够验证玩家并跟踪谁已连接以及他们的会话令牌。好的，无需多言，让我们深入探讨吧！
- en: 'We’ll start by setting up an ENet multiplayer server on port `9999`, loading
    our fake JSON database file, and assigning the `peer` instance to the `multiplayer_peer`
    property of the node’s `multiplayer` object so we can make RPCs. Remember, we
    can only carry out RPCs within an established ENet connection:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在端口`9999`上设置ENet多玩家服务器，加载我们的伪造JSON数据库文件，并将`peer`实例分配给节点的`multiplayer`对象的`multiplayer_peer`属性，以便我们可以进行RPCs。记住，我们只能在建立的ENet连接内执行RPCs：
- en: Open the `res://03.making-lobby-to-gather-players/LobbyServer.tscn` scene, and
    then open the **Main** node’s script.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res://03.making-lobby-to-gather-players/LobbyServer.tscn`场景，然后打开**主**节点的脚本。
- en: 'Declare a constant variable, `PORT`, and assign our default value of `9999`.
    This variable will be used later to specify the port number on which the server
    will listen for incoming connections:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个常量变量`PORT`，并分配我们的默认值`9999`。这个变量将用于稍后指定服务器监听传入连接的端口号：
- en: '[PRE2]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the `@export` decorator to create a new variable, `database_file_path`,
    which can be edited from the **Inspector** panel. This variable will store the
    path to the JSON file that contains our fake user database. We are using the same
    file from the previous chapter:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@export`装饰器创建一个新的变量`database_file_path`，它可以从**检查器**面板中进行编辑。这个变量将存储包含我们伪造用户数据库的JSON文件的路径。我们正在使用与上一章相同的文件：
- en: '[PRE3]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a new `ENetMultiplayerPeer` instance and assign it to the `peer` variable.
    This will be our high-level network interface for sending and receiving data between
    clients and the server and making RPCs:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`ENetMultiplayerPeer`实例，并将其分配给`peer`变量。这将是我们用于在客户端和服务器之间发送和接收数据以及进行RPCs的高级网络接口：
- en: '[PRE4]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create an empty dictionary called `database` and an empty dictionary called
    `logged_users`. These variables will be used to store our fake user data and keep
    track of which users are currently logged in, respectively:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `database` 的空字典和一个名为 `logged_users` 的空字典。这些变量将用于存储我们的假用户数据，并分别跟踪哪些用户当前已登录：
- en: '[PRE5]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `_ready()` callback, call `peer.create_server(PORT)` to create a new
    multiplayer server that listens for incoming connections on the port number specified
    by the `PORT` variable:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_ready()` 回调中，调用 `peer.create_server(PORT)` 创建一个新的多玩家服务器，该服务器在由 `PORT` 变量指定的端口号上监听传入的连接：
- en: '[PRE6]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Still in the `_ready()` callback, assign the `peer` to `multiplayer.multiplayer_peer`.
    This variable makes our `peer` object the default network interface for all nodes
    in the game:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `_ready()` 回调中，将 `peer` 分配给 `multiplayer.multiplayer_peer`。这个变量使我们的 `peer`
    对象成为游戏中所有节点的默认网络接口：
- en: '[PRE7]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, still in the `_ready()` callback, make a call to the `load_database()`
    method. We are going to create this in a moment. We do that to have the database
    in memory from the start, as soon as the server is ready:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，仍然在 `_ready()` 回调中，调用 `load_database()` 方法。我们将在稍后创建它。我们这样做是为了让数据库从服务器准备好开始就在内存中：
- en: '[PRE8]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, define a new function, `load_database()`, that takes an optional argument,
    `path_to_database_file`. This function will be used to load the user data from
    the JSON file into our `database` dictionary:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个新的函数 `load_database()`，它接受一个可选参数 `path_to_database_file`。此函数将用于将用户数据从
    JSON 文件加载到我们的 `database` 字典中：
- en: '[PRE9]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside `load_database()`, open the file specified by `path_to_database_file`
    using `FileAccess.open()` and assign it to the `file` variable:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `load_database()` 内部，使用 `FileAccess.open()` 打开由 `path_to_database_file` 指定的文件，并将其分配给
    `file` 变量：
- en: '[PRE10]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Get the contents of the file as text using `file.get_as_text()` and assign
    it to the `file_content` variable:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `file.get_as_text()` 获取文件的文本内容，并将其分配给 `file_content` 变量：
- en: '[PRE11]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Parse the contents of `file_content` as JSON using `JSON.parse_string()` and
    assign the resulting dictionary to `database`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `JSON.parse_string()` 将 `file_content` 的内容解析为 JSON，并将结果字典分配给 `database`：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, this is how our `LobbyServer.gd` should look like this:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，这是我们的 `LobbyServer.gd` 应该看起来像这样：
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With that, it’s time to get our hands dirty with the fun part and the core of
    this chapter. Up next, we are going to finally create the `@rpc` methods that
    we’ll use across our upcoming classes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就到了动手实践有趣部分和本章核心的时候了。接下来，我们将最终创建将在我们即将到来的类中使用的 `@rpc` 方法。
- en: Creating the RPC functions template
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 RPC 函数模板
- en: With that, we can start to define our `@rpc` methods so when we move on to `LobbyLogin`,
    we already know what we’ll call and how it works. So, still in `LobbyServer`,
    let’s create some RPC methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以开始定义我们的 `@rpc` 方法，这样当我们转到 `LobbyLogin` 时，我们就已经知道我们将调用什么以及它是如何工作的。所以，仍然在
    `LobbyServer` 中，让我们创建一些 RPC 方法。
- en: These methods are going to be used on `LobbyLogin` and `LobbyClient` as well.
    Remember, all classes that make RPCs should share the same RPC methods even if
    they don’t use them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法也将用于 `LobbyLogin` 和 `LobbyClient`。记住，所有执行 RPC 的类应该共享相同的 RPC 方法，即使它们没有使用它们。
- en: 'So, let’s create this interface:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建这个接口：
- en: 'The `@rpc` annotation on this line is an RPC annotation that tells Godot that
    this function is called remotely only by the multiplayer authority, which is the
    server itself. A remote call means that when `LobbyServer` makes an RPC to this
    function, it won’t execute it on itself locally. We will use the `add_avatar()`
    method to add a new avatar to the game’s lobby, and we will implement it on `LobbyClient`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这行代码上的 `@rpc` 注解是一个 RPC 注解，它告诉 Godot 这个函数只能由多玩家权限（即服务器本身）远程调用。远程调用意味着当 `LobbyServer`
    对此函数进行 RPC 调用时，它不会在本地执行。我们将使用 `add_avatar()` 方法向游戏大厅添加新头像，并在 `LobbyClient` 上实现它：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `clear_avatars()` function will remove all avatars from the lobby. We use
    this function to clear all avatars from the game so we can sync with newer players.
    This is also a method that we’ll implement on `LobbyClient`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clear_avatars()` 函数将删除大厅中的所有头像。我们使用此函数从游戏中清除所有头像，以便与新玩家同步。这也是一个我们将在 `LobbyClient`
    上实现的方法：'
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This `@rpc("any_peer", "call_remote")` annotation tells Godot any peer can
    remotely call this function. We’ll use the `retrieve_avatar()` method to retrieve
    the texture path for a specific player’s avatar. We’ll implement this method in
    `LobbyServer` soon, and the `LobbyClient` is the one that’s going to remotely
    call it:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 `@rpc("any_peer", "call_remote")` 注解告诉 Godot 任何节点都可以远程调用这个函数。我们将使用 `retrieve_avatar()`
    方法来检索特定玩家的头像纹理路径。我们将在 `LobbyServer` 中很快实现这个方法，而 `LobbyClient` 将会远程调用它：
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `authenticate_player()` method will authenticate a player using a username
    and password. We use this function to authenticate players’ credentials and pair
    them with a session token on the `logged_users` dictionary. This is also a method
    from `LobbyServer`, but now it’s `LobbyLogin` that’s going to remotely call it:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`authenticate_player()` 方法将使用用户名和密码验证玩家。我们使用这个函数来验证玩家的凭证，并在 `logged_users`
    字典中将它们与一个会话令牌配对。这也是 `LobbyServer` 中的一个方法，但现在 `LobbyLogin` 将会远程调用它：'
- en: '[PRE17]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, we use the `authentication_failed()` method to notify a player that their
    authentication failed. We will call this from `LobbyServer` on `LobbyClient` when
    the server can’t authenticate the credentials the player sent.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `authentication_failed()` 方法来通知玩家他们的身份验证失败。当服务器无法验证玩家发送的凭证时，我们将从 `LobbyServer`
    在 `LobbyClient` 上调用这个方法。
- en: 'Note that while every function marked with an `@rpc` annotation should be on
    all other classes it interacts with, those classes don’t need to have the same
    options for their `@rpc`. You will understand this better when we jump into `LobbyLogin`
    and `LobbyClient`:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，虽然带有 `@rpc` 注解的每个函数都应该在所有与之交互的其他类中都有，但这些类不需要有相同的 `@rpc` 选项。当我们跳转到 `LobbyLogin`
    和 `LobbyClient` 时，你会更好地理解这一点：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also have `authentication_succeed()`. We call this function from `LobbsyServer`
    on the player’s `LobbyClient` to tell them that their authentication succeeded,
    providing them with their session token:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有 `authentication_succeed()`。我们从 `LobbsyServer` 在玩家的 `LobbyClient` 上调用这个函数，告诉他们他们的身份验证成功，并为他们提供会话令牌：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With that, we have all the RPC functions we are going to use in our lobby system.
    `LobbyServer`’s RPCs section should look like this:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们就有了在大厅系统中将要使用的所有 RPC 函数。`LobbyServer` 的 RPC 部分应该看起来像这样：
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our template is ready. It has the `@rpc` methods that the classes that comprise
    our lobby need to share to communicate in our network. Remember, this is a necessary
    step; even if some of the classes don’t implement the method, they should at least
    share this interface. For instance, coming next, we are going to implement the
    authentication logic in the lobby server, but other classes only need the method
    signature for that to work. Let’s see how this goes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板已经准备好了。它包含了组成我们大厅的类之间需要共享的 `@rpc` 方法，以便在我们的网络中进行通信。记住，这是一个必要的步骤；即使某些类没有实现该方法，它们也应该至少共享这个接口。例如，接下来，我们将在大厅服务器中实现身份验证逻辑，但其他类只需要该方法的签名即可工作。让我们看看这个过程会如何进行。
- en: Authenticating the player
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家身份验证
- en: In this section, we will focus on authenticating the player in the lobby server.
    We will use the `authenticate_player()` RPC method that we previously defined
    in our server script to verify the player’s identity and grant access to the lobby.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部分，我们将专注于在大厅服务器中验证玩家。我们将使用之前在服务器脚本中定义的 `authenticate_player()` RPC 方法来验证玩家的身份并授予大厅的访问权限。
- en: The `authenticate_player()` method will take a username and a password as arguments
    and will return either an error message or a session token. If the credentials
    are invalid, the method will make a remote call to the `authentication_failed()`
    method with an error message explaining the reason for the failure.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate_player()` 方法将接受一个用户名和一个密码作为参数，并返回一个错误消息或会话令牌。如果凭证无效，该方法将向 `authentication_failed()`
    方法发出远程调用，并带有一个错误消息来解释失败的原因。'
- en: If the credentials are valid, the method will make a remote call to the `authentication_succeed()`
    method, passing a session token and returning it to the player’s `LobbyClient`.
    The session token is a unique integer number that identifies the player and is
    used to authenticate the player in subsequent RPCs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果凭证有效，该方法将向 `authentication_succeed()` 方法发出远程调用，传递一个会话令牌并将其返回给玩家的 `LobbyClient`。会话令牌是一个唯一的整数，用于标识玩家，并在后续的
    RPC 中用于验证玩家。
- en: 'Let’s see how we can implement this logic using the tools we have at our disposal
    in the Godot Engine:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用 Godot 引擎中可用的工具来实现这个逻辑：
- en: 'Inside `LobbyServer`’s `authenticate_player()` method, get the `peer_id` of
    the player who sent the authentication request using the `multiplayer.get_remote_sender_id()`
    method. This is how we identify who sent the request so we can properly respond
    to the request:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LobbyServer` 的 `authenticate_player()` 方法内部，使用 `multiplayer.get_remote_sender_id()`
    方法获取发送认证请求的玩家的 `peer_id`。这是我们识别谁发送了请求，以便我们可以正确地响应请求的方式：
- en: '[PRE21]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Check whether the user exists in the `database` dictionary. If they don’t exist,
    call the `authentication_failed` RPC method on the `peer_id` with the message
    `"User doesn''t exist"`. For that, we can use the `rpc_id()` method, which makes
    an RPC directly to the peer with the given ID:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查用户是否存在于 `database` 字典中。如果不存在，使用 `rpc_id()` 方法在 `peer_id` 上调用 `authentication_failed`
    RPC 方法，消息为 `"User doesn't exist"`。为此，我们可以使用 `rpc_id()` 方法，它直接向给定 ID 的对等方发起 RPC：
- en: '[PRE22]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the user exists in the database, check whether the password matches the
    password associated with the user. If it does, generate a random token using the
    `randi()` built-in method:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户存在于数据库中，检查密码是否与用户关联的密码匹配。如果匹配，使用 `randi()` 内置方法生成一个随机令牌：
- en: '[PRE23]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, add the authenticated user to the `logged_users` dictionary and call
    the `authentication_succeed` RPC method on the `peer_id` passing the token as
    an argument:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将认证过的用户添加到 `logged_users` 字典中，并在 `peer_id` 上调用 `authentication_succeed` RPC
    方法，传递令牌作为参数：
- en: '[PRE24]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is what this method should look like:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个方法应该看起来是这样的：
- en: '[PRE25]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note how useful making RPCs is. We don’t need to poll or wait for packets to
    arrive at the destination or be concerned with serializing function arguments.
    We don’t even have to create a *request* API to detect what the requester is trying
    to achieve as we did previously. It’s very straightforward, almost like making
    a local application where you have direct access to the objects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 RPC 的便利性。我们不需要轮询或等待数据包到达目的地，也不必担心序列化函数参数。我们甚至不需要创建一个 *请求* API 来检测请求者试图实现什么，就像我们之前所做的那样。它非常直接，几乎就像创建一个本地应用程序，你直接访问对象。
- en: Now, let’s see how we call this function on `LobbyLogin`. I’ll assume that you
    already understand how it connects to the server using the `ENetMultiplayerPeer.create_client()`
    method. If you have any doubts about that, refer to the first chapter; the procedure
    is the same.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在 `LobbyLogin` 上调用这个函数。我将假设你已经理解了如何使用 `ENetMultiplayerPeer.create_client()`
    方法连接到服务器。如果你对此有任何疑问，请参考第一章；程序是相同的。
- en: '`LobbyLogin` resembles the login from the previous chapter, so let’s skip directly
    to the `send_credentials()` method, where it communicates with `LobbyServer`.
    You’ll notice it also has the RPC methods we saw in `LobbyServer`. In this case,
    they all have the default options since the server is the only one that should
    call these methods on it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`LobbyLogin` 与上一章的登录方式相似，所以我们可以直接跳到 `send_credentials()` 方法，在这里它与 `LobbyServer`
    进行通信。你会注意到它也有我们在 `LobbyServer` 中看到的 RPC 方法。在这种情况下，它们都使用了默认选项，因为服务器是唯一应该调用这些方法的对象：'
- en: 'In the `send_credentials()` method, retrieve the `text` String property from
    the `user_line_edit` node and store it in the `user` variable:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `send_credentials()` 方法中，从 `user_line_edit` 节点检索 `text` 字符串属性，并将其存储在 `user`
    变量中：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, do the same but with `password_line_edit` and store it in the `password`
    variable:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用 `password_line_edit` 做同样的操作，并将其存储在 `password` 变量中：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, make an RPC to the multiplayer authority calling the `authenticate_player()`
    method with the `user` and `password` arguments. This will make this call only
    on `LobbyServer`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向多玩家权限发起 RPC 调用，调用 `authenticate_player()` 方法，并传递 `user` 和 `password` 参数。这将仅在
    `LobbyServer` 上执行此调用：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is what the `LobbyLogin.send_credentials()` method will look like in the
    end:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终，`LobbyLogin.send_credentials()` 方法将看起来是这样的：
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s take a look at the `authentication_failed()` and `authentication_succeed()`
    methods just so we understand how they work and how we keep the players’ authenticated
    credentials across the scenes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `authentication_failed()` 和 `authentication_succeed()` 方法，以便我们了解它们是如何工作的，以及我们如何跨场景保持玩家的认证凭据。
- en: '`authentication_succeed()` takes one argument called `session_token`, which
    is passed by the server when it authenticates the player’s credentials, as we
    saw previously.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`authentication_succeed()` 接收一个名为 `session_token` 的参数，这是服务器在验证玩家的凭据时传递的，正如我们之前所看到的。'
- en: Then, we update the `AuthenticationCredentials.user` and `AuthenticationCredentials.session_token`
    values using `user_line_edit.text` and the `session_token` argument. Just like
    in the previous chapter, `AuthenticationCredentials` is a singleton autoload that
    stores the player’s username and session token so we can use it in further scenes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `user_line_edit.text` 和 `session_token` 参数更新 `AuthenticationCredentials.user`
    和 `AuthenticationCredentials.session_token` 的值。就像在上一章中一样，`AuthenticationCredentials`
    是一个单例自动加载，用于存储玩家的用户名和会话令牌，以便我们可以在后续场景中使用它。
- en: 'Talking about further scenes, after updating the `AuthenticationCredentials`
    singleton, we change the scene to `lobby_screen_scene` using `get_tree().change_scene_to_file(lobby_screen_scene)`.
    That means the player has successfully logged in and we can take them to the game
    lobby:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到后续场景，在更新 `AuthenticationCredentials` 单例之后，我们使用 `get_tree().change_scene_to_file(lobby_screen_scene)`
    将场景更改为 `lobby_screen_scene`。这意味着玩家已成功登录，我们可以将他们带到游戏大厅：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As for `authentication_failed()`, we set `error_label.text` to the error message
    received from `LobbyServer`. This will display the error to the player:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `authentication_failed()`，我们将 `error_label.text` 设置为从 `LobbyServer` 收到的错误消息。这将向玩家显示错误：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that we understand how both sides of this relationship communicate and what
    they do with the data they pass around and get from each other, it’s time to move
    on and see how the game resolves this data and displays the players’ avatars to
    each other, synchronizing new players across the network every time they join
    the session.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了双方如何进行通信以及他们如何处理他们传递和从对方那里获得的数据，是时候继续前进，看看游戏如何处理这些数据，并将玩家的头像显示给彼此，每次有新玩家加入会话时都在网络上同步新玩家。
- en: In the upcoming section, we will see what the lobby screen looks like on the
    player’s end and how we load, display, and sync players’ avatars across the network.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到玩家端的大厅屏幕看起来是什么样子，以及我们如何在网络上加载、显示和同步玩家的头像。
- en: Adding the player’s avatar
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加玩家的头像
- en: In any online game, the player’s avatar is a crucial element that represents
    them in the virtual world. In the previous section, we successfully authenticated
    the player and saved their session token and username in our `AuthenticationCredentials`
    autoload. Now, it’s time to use that information to display the player’s avatar
    in the lobby.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何在线游戏中，玩家的头像都是代表他们在虚拟世界中的关键元素。在上一节中，我们成功验证了玩家，并将他们的会话令牌和用户名保存在我们的 `AuthenticationCredentials`
    自动加载中。现在，是时候使用这些信息在大厅中显示玩家的头像了。
- en: To achieve this, we will retrieve the player’s avatar information from our fake
    database and create a new `AvatarCard`, a custom scene with a `TextureRect` node
    to display the avatar’s image and a label to show its name. This way, players
    will be able to easily identify each other and feel more connected to the game
    world.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将从我们的模拟数据库中检索玩家的头像信息，并创建一个新的 `AvatarCard`，这是一个包含 `TextureRect` 节点以显示头像图片和标签以显示其名称的自定义场景。这样，玩家将能够轻松地识别彼此，并感觉与游戏世界更加紧密相连。
- en: 'For that, let’s open the `LobbyClient.gd` script. Here, we are going to do
    three major things:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们打开 `LobbyClient.gd` 脚本。在这里，我们将做三件主要事情：
- en: Retrieve the avatar information from the server by making an RPC to the `retrieve_avatar()`
    method.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对 `retrieve_avatar()` 方法进行 RPC 调用来从服务器检索头像信息。
- en: Implement the `add_avatar()` method that `LobbyServer` calls after retrieving
    the avatar data.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `LobbyServer` 在检索头像数据后调用的 `add_avatar()` 方法。
- en: Implement the `clear_avatars()` method that `LobbyServer` calls before adding
    a new avatar to the lobby.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `LobbyServer` 在向大厅添加新头像之前调用的 `clear_avatars()` 方法。
- en: 'We are going to start with the latter two, then we can move on to the `LobbyServer.gd`
    file again to implement the `retrieve_avatar()` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从后两个开始，然后我们可以再次转向 `LobbyServer.gd` 文件以实现 `retrieve_avatar()` 方法：
- en: 'In the `add_avatar()` method, create a new instance of `avatar_card_scene`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `add_avatar()` 方法中，创建一个新的 `avatar_card_scene` 实例：
- en: '[PRE32]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the newly created instance of `avatar_card` to `avatar_card_container`.
    This is an `HBoxContainer` node inside a `ScrollContainer` node:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的 `avatar_card` 实例添加到 `avatar_card_container`。这是一个位于 `ScrollContainer` 节点内的
    `HBoxContainer` 节点：
- en: '[PRE33]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Wait for the next frame to process before continuing the execution of the code.
    We do that because `AvatarCard` needs to be ready before we update its data:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续执行代码之前，等待下一帧进行处理。我们这样做是因为在更新数据之前，`AvatarCard` 需要准备好：
- en: '[PRE34]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Call the `update_data()` method on the `avatar_card` instance to update its
    data using the arguments passed to the `add_avatar()` method. With that, the lobby
    will use `avatar_name` to display the player’s avatar name and will load the image
    stored in the `texture_path` to display their avatar’s image:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `avatar_card` 实例上调用 `update_data()` 方法，使用传递给 `add_avatar()` 方法的参数来更新其数据。这样，大厅将使用
    `avatar_name` 来显示玩家的头像名称，并将加载存储在 `texture_path` 中的图像来显示他们的头像图像：
- en: '[PRE35]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The whole `add_avatar()` method should look like this:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个 `add_avatar()` 方法应该看起来像这样：
- en: '[PRE36]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using the `@rpc` annotation, we created a method that the game’s server can
    call on clients to add a new player avatar to all players’ lobby screens, but
    this causes a small issue. As it is, this method may add the avatars that were
    already in the lobby before the newer player joined it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@rpc` 注解，我们创建了一个方法，游戏服务器可以在客户端上调用，以将新的玩家头像添加到所有玩家的大厅屏幕上，但这会导致一个小问题。实际上，此方法可能会添加在较新玩家加入之前已经在大厅中的头像。
- en: So, we need to first clear all previous avatars and then add all currently logged
    players’ avatars again. This ensures the lobby has only the correct avatars.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先需要清除所有之前的头像，然后再次添加所有当前登录玩家的头像。这确保了大厅中只有正确的头像。
- en: In the coming section, we are going to create a method that will run through
    all current avatars and remove them to have an empty `HBoxContainer`that we can
    use to add new avatars.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将创建一个方法，该方法将遍历所有当前头像并将它们移除，以便我们使用一个空的 `HBoxContainer` 来添加新的头像。
- en: Cleaning AvatarCards
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理头像卡
- en: As mentioned before, whenever the server adds a new avatar to the lobby, it
    first cleans the lobby and recreates all avatars from scratch. We are going to
    see that in detail when we implement the `retrieve_avatar()` method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每当服务器向大厅添加新的头像时，它首先清理大厅并从头开始重新创建所有头像。我们将详细说明这一点，当我们实现 `retrieve_avatar()`
    方法时。
- en: The `clear_avatars()` method frees all existing avatars from the `avatar_card_container`
    node. It iterates over all children of `avatar_card_container` and calls `queue_free()`
    on each of them. After this function is executed, all avatars previously displayed
    in the lobby are removed from the container.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear_avatars()` 方法释放了 `avatar_card_container` 节点上的所有现有头像。它遍历 `avatar_card_container`
    的所有子节点，并对每个子节点调用 `queue_free()`。在此函数执行后，之前在大厅中显示的所有头像都将从容器中移除。'
- en: 'In the `clear_avatars()` method, iterate over each child node in `avatar_card_container`
    using a `for` loop and call the `queue_free()` method on each child node to remove
    it from `SceneTree` and free its resources:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `clear_avatars()` 方法中，使用 `for` 循环遍历 `avatar_card_container` 中的每个子节点，并对每个子节点调用
    `queue_free()` 方法，将其从 `SceneTree` 中移除并释放其资源：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That’s it; pretty simple, right?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；很简单，对吧？
- en: 'Now, before we move back to `LobbyServer.gd`, let’s make an RPC to the multiplayer
    authority so it retrieves the current player’s avatar. We do that in the `_ready()`
    method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回到 `LobbyServer.gd` 之前，让我们向多玩家权限发出一个 RPC，以便它检索当前玩家的头像。我们在 `_ready()` 方法中这样做：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We use the `rpc_id()` method to call the `retrieve_avatar()` RPC method on the
    multiplayer authority, which is `LobbyServer` in this case. We pass the player’s
    `username` and `session_token`, which are stored in the `AuthenticationCredentials`
    singleton autoload, as arguments to the `retrieve_avatar()` method. Now, it’s
    time to move back to `LobbyServer.gd`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `rpc_id()` 方法在多玩家权限上调用 `retrieve_avatar()` RPC 方法，在这种情况下是 `LobbyServer`。我们将玩家的
    `username` 和 `session_token` 作为参数传递给 `retrieve_avatar()` 方法，这些参数存储在 `AuthenticationCredentials`
    单例自动加载中。现在，是时候回到 `LobbyServer.gd` 了。
- en: Retrieving players’ avatars
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取玩家头像
- en: In this section, we will implement the `retrieve_avatar()` method on the `LobbyServer.gd`
    script, which will allow players to request their avatar data from the server.
    The avatar data is stored in the fake database. The server will respond with some
    RPCs to update all players with the appropriate data, displaying their avatars
    in the shared lobby.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现 `LobbyServer.gd` 脚本上的 `retrieve_avatar()` 方法，这将允许玩家从服务器请求他们的头像数据。头像数据存储在模拟数据库中。服务器将通过一些
    RPC 响应来更新所有玩家，以显示他们的头像在共享大厅中。
- en: With this method in place, we will complete the functionality of our **Lobby**
    project. Players will be able to authenticate themselves and display their avatars
    in the lobby. This will provide a solid foundation for building more complex multiplayer
    games in the upcoming chapter, as the basics of networking have been covered.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们将完成**大厅**项目的功能。玩家将能够进行身份验证并在大厅中显示他们的头像。这将为在下一章中构建更复杂的多人游戏提供一个坚实的基础，因为已经涵盖了网络的基本知识。
- en: Let’s do it!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'In the `retrieve_avatar()` method, check whether the user is logged in by verifying
    that the user exists in the `logged_users` dictionary. If the user is not logged
    in, exit the function:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`retrieve_avatar()`方法中，通过验证用户是否存在于`logged_users`字典中来检查用户是否已登录。如果用户未登录，则退出函数：
- en: '[PRE39]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, check whether the session token provided by the remote peer matches the
    session token stored in the `logged_users` dictionary for the user:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，检查远程对等节点提供的会话令牌是否与存储在`logged_users`字典中用户的会话令牌匹配：
- en: '[PRE40]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the tokens match, call the `clear_avatars()` function on all connected peers
    to clear any existing avatars from their lobby screen:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果令牌匹配，则在所有已连接的对等节点上调用`clear_avatars()`函数以清除其大厅屏幕上的任何现有头像：
- en: '[PRE41]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Loop through all the logged-in users stored in the `logged_users` dictionary:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历存储在`logged_users`字典中的所有已登录用户：
- en: '[PRE42]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Retrieve the avatar name and texture path for the current `logged_user` from
    the `database` dictionary:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`database`字典中检索当前`logged_user`的头像名称和纹理路径：
- en: '[PRE43]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Call the `add_avatar()` method on all connected peers and pass in `avatar_name`
    and `avatar_texture_path` as arguments to display the avatar in the lobby:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有已连接的对等节点上调用`add_avatar()`方法，并传入`avatar_name`和`avatar_texture_path`作为参数以在大厅中显示头像：
- en: '[PRE44]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is how the `retrieve_avatar()` method should look after all these steps:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是经过所有这些步骤后的`retrieve_avatar()`方法应该看起来像：
- en: '[PRE45]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Pay attention to its `@rpc` annotation options. Notice that any peer can call
    it remotely. This is how we make an RPC API for our online multiplayer games in
    the Godot Engine.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意其`@rpc`注解选项。注意，任何对等节点都可以远程调用它。这就是我们在Godot引擎中为我们的在线多人游戏创建RPC API的方式。
- en: Some methods should be called remotely only by the multiplayer authority, some
    should be called locally as well, and some can be called by any peer on the network.
    It is up to us to decide and manage how peers interact with each other.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法应该只由多人游戏管理员远程调用，一些应该在本地调用，还有一些可以被网络上的任何对等节点调用。决定和管理对等节点如何相互交互的责任在我们。
- en: With all that in place, it’s time to test out our game using multiple instances
    to simulate a server and multiple players connected to our network. Let’s do this
    in the next section!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪后，是时候使用多个实例来测试我们的游戏了，以模拟服务器和连接到我们网络的多个玩家。让我们在下一节中这样做！
- en: Testing the lobby
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试大厅
- en: 'To test this out, we are going to run three instances of the game:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们将运行三个游戏实例：
- en: Go to **Debug** | **Run Multiple Instances** and select **Run** **3 Instances**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**调试** | **运行多个实例**并选择**运行** **3 个实例**。
- en: "![Figure 3.3 – Choosing to run three instances in the Run Multiple Instance\uFEFF\
    s menu](img/Figure_3.03_B18527.jpg)"
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 在“运行多个实例”菜单中选择运行三个实例](img/Figure_3.03_B18527.jpg)'
- en: Figure 3.3 – Choosing to run three instances in the Run Multiple Instances menu
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 在“运行多个实例”菜单中选择运行三个实例
- en: Then, open the `res://03.making-lobby-to-gather-players/MainMenu.tscn` scene
    and hit the **Play** button.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`res://03.making-lobby-to-gather-players/MainMenu.tscn`场景并按下**播放**按钮。
- en: Pick one of the instances to be the game’s server. To do that, just click on
    the **Server** button.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个实例作为游戏的服务器。为此，只需点击**服务器**按钮。
- en: '![Figure 3.4 – Pressing the Server button on the MainMenu screen](img/Figure_03.04_B18527.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 在主菜单屏幕上按下“服务器”按钮](img/Figure_03.04_B18527.jpg)'
- en: Figure 3.4 – Pressing the Server button on the MainMenu screen
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 在主菜单屏幕上按下“服务器”按钮
- en: Now, pick another instance and click on the `LobbyLogin` screen, where you can
    enter the first fake player’s credentials.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择另一个实例并点击`LobbyLogin`屏幕，在那里您可以输入第一个假玩家的凭据。
- en: Insert `user1` in the username field and `test` in the password field. These
    are the credentials we added to `FakeDatabase.json` for our first user. Then,
    press the `LobbyClient` screen with a single avatar.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户名字段中输入`user1`，在密码字段中输入`test`。这是我们为第一个用户添加到`FakeDatabase.json`中的凭据。然后，按下带有单个头像的`LobbyClient`屏幕。
- en: '![Figure 3.5 – The LobbyLogin screen with the player’s credentials](img/Figure_3.05_B18527.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 带有玩家凭据的大厅登录屏幕](img/Figure_3.05_B18527.jpg)'
- en: Figure 3.5 – The LobbyLogin screen with the player’s credentials
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 显示玩家凭证的 LobbyLogin 屏幕图
- en: With that, the server will authenticate the player’s credentials and will allow
    the player to move on to the next screen, displaying the player’s character’s
    avatar and name based on the data it matched in the database file. In the following
    screenshot, we can see the next screen after a successful login.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，服务器将验证玩家的凭证，并允许玩家进入下一个屏幕，显示基于数据库文件中匹配的数据的玩家角色的头像和名称。在下面的屏幕截图中，我们可以看到成功登录后的下一个屏幕。
- en: '![Figure 3.6 – LobbyClient displaying the player’s avatar after login](img/Figure_03.06_B18527.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 登录后 LobbyClient 显示玩家的头像](img/Figure_03.06_B18527.jpg)'
- en: Figure 3.6 – LobbyClient displaying the player’s avatar after login
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 登录后 LobbyClient 显示玩家的头像
- en: Then, select the last instance and click on the `LobbyLogin` screen, use the
    second player’s credentials. In the first field, insert `user2`, and then, in
    the second field, `test`. It will take you to the `LobbyClient` screen, where
    there should be two avatars now. You can check the other client instance and they
    will both have the same avatars in order.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择最后一个实例，点击 `LobbyLogin` 屏幕图，使用第二位玩家的凭证。在第一个字段中，输入 `user2`，然后在第二个字段中，输入 `test`。这将带您进入
    `LobbyClient` 屏幕图，现在应该有两个头像。您可以检查其他客户端实例，它们将具有相同的头像。
- en: '![Figure 3.7 – The game displaying both players’ avatars after the second player
    is logged in](img/Figure_3.07_B18527.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 第二位玩家登录后显示两位玩家头像的游戏](img/Figure_3.07_B18527.jpg)'
- en: Figure 3.7 – The game displaying both players’ avatars after the second player
    is logged in
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 第二位玩家登录后显示两位玩家头像的游戏
- en: We can see that everything is working as we want! The players can insert their
    credentials and the server authenticates them and provides a session token to
    keep them logged in after their validation. When logged in, they can see their
    avatar. Not only that, but our game also syncs players’ avatars when a new player
    joins the session.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一切都在按我们的预期工作！玩家可以输入他们的凭证，服务器验证它们，并在验证后提供会话令牌以保持他们登录。登录后，他们可以看到他们的头像。不仅如此，我们的游戏还能在新的玩家加入会话时同步玩家的头像。
- en: We did all that using the powerful `@rpc` annotation, which is possible to use
    when peers connect using the `ENetMultiplayerPeer` API.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用强大的 `@rpc` 注解完成了所有这些工作，当使用 `ENetMultiplayerPeer` API 连接对等节点时，可以使用此注解。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about RPCs and their importance in multiplayer game
    architectures. We saw how RPCs can be used to exchange data between nodes in the
    Godot Engine. We also saw what a multiplayer authority node is and how to set
    one up that manages all the game states between network peers. On top of that,
    we saw that by using the multiplayer API and `ENetMultiplayerPeer`, we can easily
    handle the communication between nodes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 RPC 及其在多玩家游戏架构中的重要性。我们看到了如何使用 RPC 在 Godot 引擎中的节点之间交换数据。我们还看到了多玩家权限节点是什么，以及如何设置一个管理网络对等体之间所有游戏状态的节点。除此之外，我们还看到，通过使用多玩家
    API 和 `ENetMultiplayerPeer`，我们可以轻松处理节点之间的通信。
- en: Throughout the chapter, we created a lobby, which is a multiplayer game that
    features a lobby where players can join together. We saw how to create a client-server
    architecture, authenticate users, and exchange data between the server and the
    clients using RPCs. We also learned how to use the multiplayer API and `ENetMultiplayerPeer`
    to create a connection between the client and the server.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个大厅，这是一个具有大厅的多玩家游戏，玩家可以在其中一起加入。我们看到了如何创建客户端-服务器架构，使用 RPC 验证用户，并在服务器和客户端之间交换数据。我们还学习了如何使用多玩家
    API 和 `ENetMultiplayerPeer` 在客户端和服务器之间建立连接。
- en: One of the essential concepts we learned is how `ENetMultiplayerPeer` simplifies
    the whole process of creating a multiplayer game compared to the low-level UDP
    approach. It abstracts away the complexity of low-level network programming, such
    as sending and receiving data packets, managing connections, and handling errors.
    This makes it easier for us to focus on implementing the gameplay mechanics of
    the game rather than worrying about the low-level details of the network communication.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到的基本概念之一是 `ENetMultiplayerPeer` 如何简化与低级 UDP 方法相比的多玩家游戏创建过程。它抽象掉了低级网络编程的复杂性，例如发送和接收数据包、管理连接和处理错误。这使得我们更容易专注于实现游戏的游戏机制，而不是担心网络通信的低级细节。
- en: Overall, this chapter has provided a solid foundation for developing multiplayer
    games in the Godot Engine. By following the steps outlined in this chapter, developers
    can create a simple lobby-based multiplayer game that utilizes RPCs, authentication,
    and the multiplayer API.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章为在 Godot 引擎中开发多人游戏提供了一个坚实的基础。通过遵循本章中概述的步骤，开发者可以创建一个基于大厅的简单多人游戏，该游戏利用
    RPC、身份验证和多人 API。
- en: In the upcoming chapter, we are going to test the `ENetMultiplayerPeer` capabilities
    to exchange, update, and sync players. For that, we will create a chat room where
    players can communicate with each other and finally create a shared experience
    and a sense of community.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将测试 `ENetMultiplayerPeer` 的能力，以交换、更新和同步玩家。为此，我们将创建一个聊天室，玩家可以在其中相互交流，并最终创造一个共享体验和社区感。
