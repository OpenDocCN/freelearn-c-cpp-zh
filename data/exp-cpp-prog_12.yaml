- en: C++ Multithreading APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++多线程API
- en: While C++ has a native multithreading implementation in the **Standard Template
    Library** (**STL**), OS-level and framework-based multithreading APIs are still
    very common. Examples of these APIs include Windows and **POSIX** (**Portable
    Operating System Interface**) threads, and those provided by the `Qt`, `Boost`,
    and `POCO` libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++在标准模板库（STL）中有本地的多线程实现，但基于操作系统和框架的多线程API仍然非常常见。这些API的示例包括Windows和POSIX（可移植操作系统接口）线程，以及由Qt、Boost和POCO库提供的线程。
- en: This chapter takes a detailed look at the features provided by each of these
    APIs, as well as the similarities and differences between each of them. Finally,
    we'll look at common usage scenarios using example code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍每个API提供的功能，以及它们之间的相似之处和不同之处。最后，我们将使用示例代码来查看常见的使用场景。
- en: 'Topics covered by this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: A comparison of the available multithreading APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用多线程API的比较
- en: Examples of the usage of each of these APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个API的使用示例
- en: API overview
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API概述
- en: Before the **C++ 2011** (**C++11**) standard, many different threading implementations
    were developed, many of which are limited to a specific software platform. Some
    of these are still relevant today, such as Windows threads. Others have been superseded
    by standards, of which **POSIX Threads** (**Pthreads**) has become the de facto
    standard on UNIX-like OSes. This includes Linux-based and BSD-based OS, as well
    as OS X (macOS) and Solaris.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++ 2011（C++11）标准之前，开发了许多不同的线程实现，其中许多限于特定的软件平台。其中一些至今仍然相关，例如Windows线程。其他已被标准取代，其中POSIX线程（Pthreads）已成为类UNIX操作系统的事实标准。这包括基于Linux和BSD的操作系统，以及OS
    X（macOS）和Solaris。
- en: Many libraries were developed to make cross-platform development easier. Although
    Pthreads helps to make UNIX-like OS more or less compatible one of the prerequisites
    to make software portable across all major operating systems, a generic threading
    API is needed. This is why libraries such as Boost, POCO, and Qt were created.
    Applications can use these and rely on the library to handle any differences between
    platforms.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多库被开发出来，以使跨平台开发更容易。尽管Pthreads有助于使类UNIX操作系统更或多或少兼容，但要使软件在所有主要操作系统上可移植，需要一个通用的线程API。这就是为什么创建了Boost、POCO和Qt等库。应用程序可以使用这些库，并依赖于库来处理平台之间的任何差异。
- en: POSIX threads
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX线程
- en: Pthreads were first defined in the `POSIX.1c` standard (*Threads extensions*,
    IEEE Std 1003.1c-1995) from 1995 as an extension to the POSIX standard. At the
    time, UNIX had been chosen as a manufacturer-neutral interface, with POSIX unifying
    the various APIs among them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Pthreads最初是在1995年的POSIX.1c标准（线程扩展，IEEE Std 1003.1c-1995）中定义的，作为POSIX标准的扩展。当时，UNIX被选择为制造商中立的接口，POSIX统一了它们之间的各种API。
- en: Despite this standardization effort, differences still exist in Pthread implementations
    between OS's which implement it (for example, between Linux and OS X), courtesy
    of non-portable extensions (marked with `_np` in the method name).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这种标准化的努力，Pthread在实现它的操作系统之间仍然存在差异（例如，在Linux和OS X之间），这是由于不可移植的扩展（在方法名称中标有_np）。
- en: For the `pthread_setname_np` method, the Linux implementation takes two parameters,
    allowing one to set the name of a thread other than the current thread. On OS
    X (since 10.6), this method only takes one parameter, allowing one to set the
    name of the current thread only. If portability is a concern, one has to be mindful
    of such differences.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于pthread_setname_np方法，Linux实现需要两个参数，允许设置除当前线程以外的线程名称。在OS X（自10.6起），此方法只需要一个参数，允许设置当前线程的名称。如果可移植性是一个问题，就必须注意这样的差异。
- en: After 1997, the POSIX standard revisions were managed by the Austin Joint Working
    Group. These revisions merge the threads extension into the main standard. The
    current revision is 7, also known as POSIX.1-2008 and IEEE Std 1003.1, 2013 edition--with
    a free copy of the standard available online.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 1997年后，POSIX标准修订由Austin联合工作组管理。这些修订将线程扩展合并到主标准中。当前的修订是7，也称为POSIX.1-2008和IEEE
    Std 1003.1，2013版--标准的免费副本可在线获得。
- en: 'OS''s can be certified to conform to the POSIX standard. Currently, these are
    as mentioned in this table:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统可以获得符合POSIX标准的认证。目前，这些如下表所述：
- en: '| **Name** | **Developer** | **Since version** | **Architecture(s) (current)**
    | **Notes** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **开发者** | **自版本** | **架构（当前）** | **备注** |'
- en: '| AIX | IBM | 5L | POWER | Server OS |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| AIX | IBM | 5L | POWER | 服务器操作系统 |'
- en: '| HP-UX | Hewlett-Packard | 11i v3 | PA-RISC, IA-64 (Itanium) | Server OS |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| HP-UX | Hewlett-Packard | 11i v3 | PA-RISC, IA-64 (Itanium) | 服务器操作系统 |'
- en: '| IRIX | Silicon Graphics (SGI) | 6 | MIPS | Discontinued |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| IRIX | Silicon Graphics (SGI) | 6 | MIPS | 已停产 |'
- en: '| Inspur K-UX | Inspur | 2 | X86_64, | Linux based |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Inspur K-UX | Inspur | 2 | X86_64, | 基于Linux |'
- en: '| Integrity | Green Hills Software | 5 | ARM, XScale, Blackfin, Freescale Coldfire,
    MIPS, PowerPC, x86. | Real-time OS |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Integrity | Green Hills Software | 5 | ARM, XScale, Blackfin, Freescale Coldfire,
    MIPS, PowerPC, x86。 | 实时操作系统 |'
- en: '| OS X/MacOS | Apple | 10.5 (Leopard) | X86_64 | Desktop OS |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| OS X/MacOS | Apple | 10.5 (Leopard) | X86_64 | 桌面操作系统 |'
- en: '| QNX Neutrino | BlackBerry | 1 | Intel 8088, x86, MIPS, PowerPC, SH-4, ARM,
    StrongARM, XScale | Real-time, embedded OS |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| QNX Neutrino | BlackBerry | 1 | Intel 8088, x86, MIPS, PowerPC, SH-4, ARM,
    StrongARM, XScale | 实时，嵌入式操作系统 |'
- en: '| Solaris | Sun/Oracle | 2.5 | SPARC, IA-32 (<11), x86_64, PowerPC (2.5.1)
    | Server OS |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Solaris | Sun/Oracle | 2.5 | SPARC, IA-32 (<11), x86_64, PowerPC (2.5.1)
    | 服务器操作系统 |'
- en: '| Tru64 | DEC, HP, IBM, Compaq | 5.1B-4 | Alpha | Discontinued |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Tru64 | DEC, HP, IBM, Compaq | 5.1B-4 | Alpha | 已停产 |'
- en: '| UnixWare | Novell, SCO, Xinuos | 7.1.3 | x86 | Server OS |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| UnixWare | Novell, SCO, Xinuos | 7.1.3 | x86 | 服务器操作系统 |'
- en: 'Other operating systems are mostly compliant. The following are examples of
    the same:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作系统大多是兼容的。以下是相同的示例：
- en: '| **Name** | **Platform** | **Notes** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **平台** | **备注** |'
- en: '| Android | ARM, x86, MIPS | Linux based. Bionic C-library. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Android | ARM, x86, MIPS | 基于Linux。Bionic C库。 |'
- en: '| BeOS (Haiku) | IA-32, ARM, x64_64 | Limited to GCC 2.x for x86. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| BeOS (Haiku) | IA-32, ARM, x64_64 | 限于x86的GCC 2.x。 |'
- en: '| Darwin | PowerPC, x86, ARM | Uses the open source components on which macOS
    is based. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| Darwin | PowerPC，x86，ARM | 使用macOS基于的开源组件。 |'
- en: '| FreeBSD | IA-32, x86_64, sparc64, PowerPC, ARM, MIPS, and so on | Essentially
    POSIX compliant. One can rely on documented POSIX behavior. More strict on compliance
    than Linux, in general. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| FreeBSD | IA-32，x86_64，sparc64，PowerPC，ARM，MIPS等 | 基本上符合POSIX。可以依赖已记录的POSIX行为。一般来说，比Linux更严格地遵守规范。
    |'
- en: '| Linux | Alpha, ARC, ARM, AVR32, Blackfin, H8/300, Itanium, m68k, Microblaze,
    MIPS, Nios II, OpenRISC, PA-RISC, PowerPC, s390, S+core, SuperH, SPARC, x86, Xtensa,
    and so on | Some Linux distributions (see previous table) are certified as being
    POSIX compliant. This does not imply that every Linux distribution is POSIX compliant.
    Some tools and libraries may differ from the standard.For Pthreads, this may mean
    that the behavior is sometimes different between Linux distributions (different
    scheduler, and so on) as well as compared to other OS''s implementing Pthreads.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Linux | Alpha，ARC，ARM，AVR32，Blackfin，H8/300，Itanium，m68k，Microblaze，MIPS，Nios
    II，OpenRISC，PA-RISC，PowerPC，s390，S+core，SuperH，SPARC，x86，Xtensa等 | 一些Linux发行版（见前表）被认证为符合POSIX。这并不意味着每个Linux发行版都符合POSIX。一些工具和库可能与标准不同。对于Pthreads，这可能意味着在Linux发行版之间（不同的调度程序等）以及与实现Pthreads的其他操作系统之间的行为有时会有所不同。
    |'
- en: '| MINIX 3 | IA-32, ARM | Conforms to POSIX specification standard 3 (SUSv3,
    2004). |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| MINIX 3 | IA-32，ARM | 符合POSIX规范标准3（SUSv3，2004年）。 |'
- en: '| NetBSD | Alpha, ARM, PA-RISC, 68k, MIPS, PowerPC, SH3, SPARC, RISC-V, VAX,
    x86, and so on | Almost fully compatible with POSX.1 (1990), and mostly compliant
    with POSIX.2 (1992). |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| NetBSD | Alpha，ARM，PA-RISC，68k，MIPS，PowerPC，SH3，SPARC，RISC-V，VAX，x86等 | 几乎完全兼容POSX.1（1990），并且大部分符合POSIX.2（1992）。
    |'
- en: '| Nuclear RTOS | ARM, MIPS, PowerPC, Nios II, MicroBlaze, SuperH, and so on
    | Proprietary RTOS from Mentor Graphics aimed at embedded applications. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 核心RTOS | ARM，MIPS，PowerPC，Nios II，MicroBlaze，SuperH等 | Mentor Graphics的专有RTOS，旨在嵌入式应用。
    |'
- en: '| NuttX | ARM, AVR, AVR32, HCS12, SuperH, Z80, and so on | Light-weight RTOS,
    scalable from 8 to 32-bit systems with strong focus on POSIX compliance. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| NuttX | ARM，AVR，AVR32，HCS12，SuperH，Z80等 | 轻量级RTOS，可在8到32位系统上扩展，专注于POSIX兼容性。
    |'
- en: '| OpenBSD | Alpha, x86_64, ARM, PA-RISC, IA-32, MIPS, PowerPC, SPARC, and so
    on | Forked from NetBSD in 1995\. Similar POSIX support. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| OpenBSD | Alpha，x86_64，ARM，PA-RISC，IA-32，MIPS，PowerPC，SPARC等 | 1995年从NetBSD分叉出来。类似的POSIX支持。
    |'
- en: '| OpenSolaris/illumos | IA-32, x86_64, SPARC, ARM | Compliant with the commercial
    Solaris releases being certified compatible. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| OpenSolaris/illumos | IA-32，x86_64，SPARC，ARM | 与商业Solaris发行版兼容认证。 |'
- en: '| VxWorks | ARM, SH-4, x86, x86_64, MIPS, PowerPC | POSIX compliant, with certification
    for user-mode execution environment. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| VxWorks | ARM，SH-4，x86，x86_64，MIPS，PowerPC | 符合POSIX，并获得用户模式执行环境的认证。 |'
- en: From this it should be obvious that it's not a clear matter of following the
    POSIX specification, and being able to count on one's code compiling on each of
    these platforms. Each platform will also have its own set of extensions to the
    standard for features which were omitted in the standard, but are still desirable.
    Pthreads are, however, widely used by Linux, BSD, and similar software.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，遵循POSIX规范并不是一件明显的事情，也不能指望自己的代码在每个平台上都能编译。每个平台还将有其自己的标准扩展，用于标准中省略的但仍然有用的功能。然而，Pthreads在Linux、BSD和类似软件中被广泛使用。
- en: Windows support
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows支持
- en: 'It''s also possible to use the POSIX APIs in a limited fashion using, for example,
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用POSIX API，例如以下方式：
- en: '| **Name** | **Compliance** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **兼容性** |'
- en: '| Cygwin | Mostly complete. Provides a full runtime environment for a POSIX
    application, which can be distributed as a normal Windows application. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Cygwin | 大部分完整。为POSIX应用程序提供完整的运行时环境，可以作为普通的Windows应用程序分发。 |'
- en: '| MinGW | With MinGW-w64 (a redevelopment of MinGW), Pthreads support is fairly
    complete, though some functionality may be absent. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| MinGW | 使用MinGW-w64（MinGW的重新开发），Pthreads支持相当完整，尽管可能会缺少一些功能。 |'
- en: '| Windows Subsystem for Linux | WSL is a Windows 10 feature, which allows a
    Ubuntu Linux 14.04 (64-bit) image''s tools and utilities to run natively on top
    of it though not those using GUI features or missing kernel features. Otherwise,
    it offers similar compliance as Linux.This feature currently requires that one
    runs the Windows 10 Anniversary Update and install WSL by hand using instructions
    provided by Microsoft. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Windows Subsystem for Linux | WSL是Windows 10的一个功能，允许Ubuntu Linux 14.04（64位）镜像的工具和实用程序在其上本地运行，尽管不能使用GUI功能或缺少内核功能。否则，它提供与Linux类似的兼容性。此功能目前要求运行Windows
    10周年更新，并按照微软提供的说明手动安装WSL。 |'
- en: POSIX on Windows is generally not recommended. Unless there are good reasons
    to use POSIX (large existing code base, for example), it's far easier to use one
    of the cross-platform APIs (covered later in this chapter), which smooth away
    any platform issues.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一般不建议在Windows上使用POSIX。除非有充分的理由使用POSIX（例如，大量现有的代码库），否则最好使用其中一个跨平台API（本章后面将介绍），这样可以消除任何平台问题。
- en: In the following sections, we'll look at the features offered by the Pthreads
    API.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看一下Pthreads API提供的功能。
- en: PThreads thread management
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PThreads线程管理
- en: These are all the functions which start with either `pthread_` or `pthread_attr_`.
    These functions all apply to threads themselves and their attribute objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是以`pthread_`或`pthread_attr_`开头的函数。这些函数都适用于线程本身及其属性对象。
- en: 'The basic use of threads with Pthreads looks like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pthreads的基本方法如下：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The main Pthreads header is `pthread.h`. This gives access to everything but
    semaphores (covered later in this section). We also define a constant for the
    number of threads we wish to start here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的Pthreads头文件是`pthread.h`。这提供了对除了信号量（稍后在本节中讨论）之外的所有内容的访问。我们还在这里定义了一个希望启动的线程数的常量：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We define a simple `Worker` function, which we'll pass to the new thread in
    a moment. For demonstration and debugging purposes one could first add a simple
    `cout` or `printf`-based bit of business logic to print out the value sent to
    the new thread.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个简单的`Worker`函数，稍后将把它传递给新线程。为了演示和调试目的，可以首先添加一个简单的基于`cout`或`printf`的业务逻辑，以打印发送到新线程的值。
- en: 'Next, we define the `main` function as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`main`函数如下：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create all of the threads in a loop in the preceding function. Each thread
    instance gets a thread ID assigned (first argument) when created in addition to
    a result code (zero on success) returned by the `pthread_create()` function. The
    thread ID is the handle to reference the thread in future calls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上述函数中的循环中创建所有线程。每个线程实例在创建时被分配一个线程ID（第一个参数），并且`pthread_create()`函数返回一个结果代码（成功时为零）。线程ID是在将来的调用中引用线程的句柄。
- en: The second argument to the function is a `pthread_attr_t` structure instance,
    or 0 if none. This allows for configuration characteristics of the new thread,
    such as the initial stack size. When zero is passed, default parameters are used,
    which differ per platform and configuration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二个参数是`pthread_attr_t`结构实例，如果没有则为0。这允许配置新线程的特性，例如初始堆栈大小。当传递零时，将使用默认参数，这些参数因平台和配置而异。
- en: 'The third parameter is a pointer to the function which the new thread will
    start with. This function pointer is defined as a function which returns a pointer
    to void data (that is, custom data), and accepts a pointer to void data. Here,
    the data being passed to the new thread as an argument is the thread ID:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个指向新线程将启动的函数的指针。此函数指针被定义为一个返回指向void数据的指针的函数（即自定义数据），并接受指向void数据的指针。在这里，作为参数传递给新线程的数据是线程ID：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we wait for each worker thread to finish using the `pthread_join()` function.
    This function takes two parameters, the ID of the thread to wait for, and a buffer
    for the return value of the `Worker` function (or zero).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`pthread_join()`函数等待每个工作线程完成。此函数接受两个参数，要等待的线程的ID，以及`Worker`函数的返回值的缓冲区（或零）。
- en: 'Other functions to manage threads are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 管理线程的其他函数如下：
- en: '`void pthread_exit`(`void *value_ptr`):'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void pthread_exit`(`void *value_ptr`)：'
- en: This function terminates the thread calling it, making the provided argument's
    value available to any thread calling `pthread_join()` on it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数终止调用它的线程，使提供的参数值可用于调用`pthread_join()`的任何线程。
- en: '`int pthread_cancel`(`pthread_t` thread):'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int pthread_cancel`(`pthread_t` thread)：'
- en: This function requests that the specified thread will be canceled. Depending
    on the state of the target thread, this will invoke its cancellation handlers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数请求取消指定的线程。根据目标线程的状态，这将调用其取消处理程序。
- en: Beyond this, there are the `pthread_attr_*` functions to manipulate and obtain
    information about a `pthread_attr_t` structure.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有`pthread_attr_*`函数来操作和获取有关`pthread_attr_t`结构的信息。
- en: Mutexes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: These are functions prefixed with either `pthread_mutex_` or `pthread_mutexattr_`.
    They apply to mutexes and their attribute objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的前缀为`pthread_mutex_`或`pthread_mutexattr_`。它们适用于互斥锁及其属性对象。
- en: Mutexes in Pthreads can be initialized, destroyed, locked, and unlocked. They
    can also have their behavior customized using a `pthread_mutexattr_t` structure,
    which has its corresponding `pthread_mutexattr_*` functions for initializing and
    destroying an attribute on it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Pthreads中的互斥锁可以被初始化、销毁、锁定和解锁。它们还可以使用`pthread_mutexattr_t`结构自定义其行为，该结构具有相应的`pthread_mutexattr_*`函数用于初始化和销毁其属性。
- en: 'A basic use of a Pthread mutex using static initialization looks as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态初始化的Pthread互斥锁的基本用法如下：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this last bit of code, we use the `PTHREAD_MUTEX_INITIALIZER` macro, which
    initializes the mutex for us without having to type out the code for it every
    time. In comparison to other APIs, one has to manually initialize and destroy
    mutexes, though the use of macros helps somewhat.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码的最后，我们使用了`PTHREAD_MUTEX_INITIALIZER`宏，它为我们初始化了互斥锁，而无需每次都输入代码。与其他API相比，人们必须手动初始化和销毁互斥锁，尽管使用宏在某种程度上有所帮助。
- en: After this, we lock and unlock the mutex. There's also the `pthread_mutex_trylock()`
    function, which is like the regular lock version, but which will return immediately
    if the referenced mutex is already locked instead of waiting for it to be unlocked.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们锁定和解锁互斥锁。还有`pthread_mutex_trylock()`函数，它类似于常规锁定版本，但如果引用的互斥锁已经被锁定，它将立即返回而不是等待它被解锁。
- en: In this example, the mutex is not explicitly destroyed. This is, however, a
    part of normal memory management in a Pthreads-based application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，互斥锁没有被显式销毁。然而，这是Pthreads应用程序中正常内存管理的一部分。
- en: Condition variables
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件变量
- en: These are functions which are prefixed with either `pthread_cond_` or `pthread_condattr_`.
    They apply to condition variables and their attribute objects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的前缀为`pthread_cond_`或`pthread_condattr_`。它们适用于条件变量及其属性对象。
- en: Condition variables in Pthreads follow the same pattern of having an initialization
    and a `destroy` function in addition to having the same for managing a `pthread_condattr_t`
    attribution structure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Pthreads中的条件变量遵循相同的模式，除了具有相同的`pthread_condattr_t`属性结构管理外，还有初始化和`destroy`函数。
- en: 'This example covers basic usage of Pthreads condition variables:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例涵盖了Pthreads条件变量的基本用法：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we get the standard headers, and define a count trigger
    and limit, whose purpose will become clear in a moment. We also define a few global
    variables: a count variable, the IDs for the threads we wish to create, as well
    as a mutex and condition variable:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们获取标准头文件，并定义一个计数触发器和限制，其目的将很快变得清楚。我们还定义了一些全局变量：计数变量，我们希望创建的线程的ID，以及互斥锁和条件变量：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This preceding function, essentially, just adds to the global counter variable
    after obtaining exclusive access to it with the `count_mutex`. It also checks
    whether the count trigger value has been reached. If it has, it will signal the
    condition variable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取`count_mutex`的独占访问权限后，前面的函数本质上只是将全局计数器变量增加。它还检查计数触发值是否已达到。如果是，它将发出条件变量的信号。
- en: 'To give the second thread, which also runs this function, a chance to get the
    mutex, we sleep for 1 second in each cycle of the loop:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让也运行此函数的第二个线程有机会获得互斥锁，我们在循环的每个周期中睡眠1秒：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this second function, we lock the global mutex before checking whether we
    have reached the count limit yet. This is our insurance in case the thread running
    this function does not get called before the count reaches the limit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个函数中，在检查是否已经达到计数限制之前，我们先锁定全局互斥锁。这是我们的保险，以防此函数运行的线程在计数达到限制之前没有被调用。
- en: Otherwise, we wait on the condition variable providing the condition variable
    and locked mutex. Once signaled, we unlock the global mutex, and exit the thread.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们等待条件变量提供条件变量和锁定的互斥锁。一旦发出信号，我们解锁全局互斥锁，并退出线程。
- en: 'A point to note here is that this example does not account for spurious wake-ups.
    Pthreads condition variables are susceptible to such wake-ups which necessitate
    one to use a loop and check whether some kind of condition has been met:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，此示例未考虑虚假唤醒。Pthreads条件变量容易受到这种唤醒的影响，这需要使用循环并检查是否已满足某种条件：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, in the `main` function, we create the three threads, with two running
    the function which adds to the counter, and the third running the function which
    waits to have its condition variable signaled.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main`函数中，我们创建三个线程，其中两个运行将计数器增加的函数，第三个运行等待其条件变量被发出信号的函数。
- en: In this method, we also initialize the global mutex and condition variable.
    The threads we create further have the "joinable" attribute explicitly set.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们还初始化全局互斥锁和条件变量。我们创建的线程还明确设置了“可连接”属性。
- en: Finally, we wait for each thread to finish, after which we clean up, destroying
    the attribute structure instance, mutex, and condition variable before exiting.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们等待每个线程完成，然后进行清理，在退出之前销毁属性结构实例、互斥锁和条件变量。
- en: Using the `pthread_cond_broadcast()` function, it's further possible to signal
    all threads which are waiting for a condition variable instead of merely the first
    one in the queue. This enables one to use condition variables more elegantly with
    some applications, such as where one has a lot of worker threads waiting for new
    dataset to arrive without having to notify every thread individually.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pthread_cond_broadcast()`函数，还可以向等待条件变量的所有线程发出信号，而不仅仅是队列中的第一个线程。这使得可以更优雅地使用条件变量，例如，当有很多工作线程等待新数据集到达时，无需单独通知每个线程。
- en: Synchronization
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: Functions which implement synchronization are prefixed with `pthread_rwlock_`
    or `pthread_barrier_`. These implement read/write locks and synchronization barriers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实现同步的函数以`pthread_rwlock_`或`pthread_barrier_`为前缀。这些实现读/写锁和同步屏障。
- en: A **read/write lock** (**rwlock**) is very similar to a mutex, except that it
    has the additional feature of allowing infinite threads to read simultaneously,
    while only restricting write access to a singular thread.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**读/写锁**（**rwlock**）与互斥锁非常相似，只是它具有额外的功能，允许无限线程同时读取，而只限制写入访问一个线程。'
- en: 'Using `rwlock` is very similar to using a mutex:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rwlock`与使用互斥锁非常相似：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the last code, we include the same general header, and either use the initialization
    function, or the generic macro. The interesting part is when we lock `rwlock`,
    which can be done for just read-only access:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的代码中，我们包含相同的通用头文件，并使用初始化函数或通用宏。有趣的部分是当我们锁定`rwlock`时，可以仅进行只读访问：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, the second variation returns immediately if the lock has been locked
    already. One can also lock it for write access as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，如果锁已经被锁定，第二种变体会立即返回。也可以按以下方式锁定它以进行写访问：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These functions work basically the same, except that only one writer is allowed
    at any given time, whereas multiple readers can obtain a read-only lock.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数基本上是相同的，唯一的区别是在任何给定时间只允许一个写入者，而多个读取者可以获得只读锁定。
- en: Barriers are another concept with Pthreads. These are synchronization objects
    which act like a barrier for a number of threads. All of these have to reach the
    barrier before any of them can proceed past it. In the barrier initialization
    function, the thread count is specified. Only once all of these threads have called
    the `barrier` object using the `pthread_barrier_wait()` function will they continue
    executing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 屏障是Pthreads的另一个概念。这些是类似于一组线程的屏障的同步对象。在这些线程中的所有线程都必须在任何一个线程可以继续执行之前到达屏障。在屏障初始化函数中，指定了线程计数。只有当所有这些线程都使用`pthread_barrier_wait()`函数调用`barrier`对象后，它们才会继续执行。
- en: Semaphores
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: Semaphores were, as mentioned earlier, not part of the original Pthreads extension
    to the POSIX specification. They are declared in the `semaphore.h` header for
    this reason.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，信号量不是原始Pthreads扩展的一部分。出于这个原因，它们在`semaphore.h`头文件中声明。
- en: In essence, semaphores are simple integers, generally used as a resource count.
    To make them thread-safe, atomic operations (check and lock) are used. POSIX semaphores
    support the initializing, destroying, incrementing and decrementing of a semaphore
    as well as waiting for the semaphore to reach a non-zero value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，信号量是简单的整数，通常用作资源计数。为了使它们线程安全，使用原子操作（检查和锁定）。POSIX信号量支持初始化、销毁、增加和减少信号量以及等待信号量达到非零值的操作。
- en: Thread local storage (TLC)
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程本地存储（TLC）
- en: 'With Pthreads, TLS is accomplished using keys and methods to set thread-specific
    data:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pthreads，TLS是通过键和设置线程特定数据的方法来实现的：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the worker thread, we allocate a new integer on the heap, and set the global
    key to its own value. After increasing the global variable by 1, its value will
    be 2, regardless of what the other threads do. We can set the global variable
    to 0 once we''re done with it for this thread, and delete the allocated value:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作线程中，我们在堆上分配一个新的整数，并将全局密钥设置为其自己的值。将全局变量增加1后，其值将为2，而不管其他线程做什么。我们可以在此线程完成后将全局变量设置为0，并删除分配的值：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A global key is set and used to reference the TLS variable, yet each of the
    threads we create can set its own value for this key.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设置并使用全局密钥来引用TLS变量，但我们创建的每个线程都可以为该密钥设置自己的值。
- en: While a thread can create its own keys, this method of handling TLS is fairly
    involved compared to the other APIs we're looking at in this chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然线程可以创建自己的密钥，但与本章中正在查看的其他API相比，处理TLS的这种方法相当复杂。
- en: Windows threads
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows线程
- en: Relative to Pthreads, Windows threads are limited to Windows operating systems
    and similar (for example ReactOS, and other OS's using Wine). This provides a
    fairly consistent implementation, easily defined by the Windows version that the
    support corresponds to.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于Pthreads，Windows线程仅限于Windows操作系统和类似系统（例如ReactOS和其他使用Wine的操作系统）。这提供了一个相当一致的实现，可以轻松地由支持对应的Windows版本来定义。
- en: Prior to Windows Vista, threading support missed features such as condition
    variables, while having features not found in Pthreads. Depending on one's perspective,
    having to use the countless "type def" types defined by the Windows headers can
    be a bother as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Vista之前，线程支持缺少诸如条件变量之类的功能，同时具有Pthreads中找不到的功能。根据一个人的观点，使用Windows头文件定义的无数“类型定义”类型可能也会让人感到烦扰。
- en: Thread management
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程管理
- en: 'A basic example of using Windows threads, as adapted from the official MSDN
    documentation sample code, looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用Windows线程的基本示例，从官方MSDN文档示例代码中改编而来，看起来像这样：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After including a series of Windows-specific headers for the thread functions,
    character strings, and more, we define the number of threads we wish to create
    as well as the size of the message buffer in the `Worker` function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含一系列Windows特定的头文件（用于线程函数、字符字符串等）之后，我们定义了要创建的线程数以及`Worker`函数中消息缓冲区的大小。
- en: 'We also define a struct type (passed by `void pointer: LPVOID`) to contain
    the sample data we pass to each worker thread:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还定义了一个结构类型（通过`void pointer: LPVOID`传递），用于包含我们传递给每个工作线程的示例数据：'
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `Worker` function, we cast the provided parameter to our custom struct
    type before using it to print its values to a string, which we output on the console.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Worker`函数中，我们将提供的参数转换为我们自定义的结构类型，然后使用它将其值打印到字符串上，然后输出到控制台。
- en: We also validate that there's an active standard output (console or similar).
    The functions used to print the string are all thread safe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还验证是否有活动的标准输出（控制台或类似）。用于打印字符串的函数都是线程安全的。
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, an error handler function is defined, which obtains the system error message
    for the last error code. After obtaining the code for the last error, the error
    message to be output is formatted, and shown in a message box. Finally, the allocated
    memory buffers are freed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定义了一个错误处理程序函数，该函数获取最后一个错误代码的系统错误消息。获取最后一个错误的代码后，将格式化要输出的错误消息，并显示在消息框中。最后，释放分配的内存缓冲区。
- en: 'Finally, the `main` function is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main`函数如下：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `main` function, we create our threads in a loop, allocate memory for
    thread data, and generate unique data for each thread before starting the thread.
    Each thread instance is passed its own unique parameters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们在循环中创建我们的线程，为线程数据分配内存，并在启动线程之前为每个线程生成唯一数据。每个线程实例都传递了自己的唯一参数。
- en: After this, we wait for the threads to finish and rejoin. This is essentially
    the same as calling the `join` function on singular threads with Pthreads--only
    here, a single function call suffices.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们等待线程完成并重新加入。这本质上与在Pthreads上调用`join`函数相同——只是这里，一个函数调用就足够了。
- en: Finally, each thread handle is closed, and we clean up the memory we allocated
    earlier.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关闭每个线程句柄，并清理之前分配的内存。
- en: Advanced management
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级管理
- en: Advanced thread management with Windows threads includes jobs, fibers, and thread
    pools. Jobs essentially allow one to link multiple threads together into a singular
    unit, enabling one to change properties and the status of all these threads in
    one go.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Windows线程进行高级线程管理包括作业、纤程和线程池。作业基本上允许将多个线程链接在一起成为一个单一单元，从而可以一次性更改所有这些线程的属性和状态。
- en: Fibers are light-weight threads, which run within the context of the thread
    which creates them. The creating thread is expected to schedule these fibers itself.
    Fibers also have **Fiber Local Storage** (**FLS**) akin to TLS.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 纤程是轻量级线程，运行在创建它们的线程的上下文中。创建线程预期自己调度这些纤程。纤程还有类似TLS的**纤程本地存储**（**FLS**）。
- en: Finally, the Windows threads API provides a Thread Pool API, allowing one to
    easily use such a thread pool in one's application. Each process is also provided
    with a default thread pool.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Windows线程API提供了一个线程池API，允许在应用程序中轻松使用这样的线程池。每个进程也提供了一个默认的线程池。
- en: Synchronization
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: With Windows threads, mutual exclusion and synchronization can be accomplished
    using critical sections, mutexes, semaphores, **slim reader/writer** (**SRW**)
    locks, barriers, and variations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Windows线程，可以使用临界区、互斥锁、信号量、**轻量级读写器**（**SRW**）锁、屏障和变体来实现互斥和同步。
- en: 'Synchronization objects include the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同步对象包括以下内容：
- en: '| **Name** | **Description** |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| Event | Allows for signaling of events between threads and processes using
    named objects. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 允许使用命名对象在线程和进程之间进行事件信号传递。|'
- en: '| Mutex | Used for inter-thread and process synchronization to coordinate access
    to shared resources. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 互斥锁 | 用于线程间和进程同步，协调对共享资源的访问。|'
- en: '| Semaphore | Standard semaphore counter object, used for inter-thread and
    process synchronization. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|信号量|标准信号量计数对象，用于线程间和进程同步。|'
- en: '| Waitable timer | Timer object usable by multiple processes with multiple
    usage modes. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|可等待定时器|可由多个进程使用的定时器对象，具有多种使用模式。|'
- en: '| Critical section | Critical sections are essentially mutexes which are limited
    to a single process, which makes them faster than using a mutex due to lack of
    kernel space calls. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|临界区|临界区本质上是互斥锁，限于单个进程，这使得它们比使用互斥锁更快，因为缺少内核空间调用。|'
- en: '| Slim reader/writer lock | SRWs are akin to read/write locks in Pthreads,
    allowing multiple readers or a single writer thread to access a shared resource.
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|轻量级读写锁|SRW类似于Pthreads中的读/写锁，允许多个读取者或单个写入者线程访问共享资源。|'
- en: '| Interlocked variable access | Allows for atomic access to a range of variables
    which are otherwise not guaranteed to be atomic. This enables threads to share
    a variable without having to use mutexes. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|交错变量访问|允许对一系列变量进行原子访问，否则不能保证原子性。这使得线程可以共享变量，而无需使用互斥锁。|'
- en: Condition variables
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件变量
- en: The implementation of condition variables with Windows threads is fairly straightforward.
    It uses a critical section (`CRITICAL_SECTION`) and condition variable (`CONDITION_VARIABLE`)
    along with the condition variable functions to wait for a specific condition variable,
    or to signal it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Windows线程实现条件变量是非常简单的。它使用临界区（`CRITICAL_SECTION`）和条件变量（`CONDITION_VARIABLE`）以及条件变量函数来等待特定的条件变量，或者发出信号。
- en: Thread local storage
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程本地存储
- en: '**Thread local storage** (**TLS**) with Windows threads is similar to Pthreads
    in that a central key (TLS index) has to be created first after which individual
    threads can use that global index to store and retrieve local values.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程本地存储**（**TLS**）与Windows线程类似于Pthreads，首先必须创建一个中央键（TLS索引），然后各个线程可以使用该全局索引来存储和检索本地值。'
- en: Like with Pthreads, this involves a similar amount of manual memory management,
    as the TLS value has to be allocated and deleted by hand.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与Pthreads一样，这涉及相似数量的手动内存管理，因为TLS值必须手动分配和删除。
- en: Boost
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost
- en: Boost threads is a relatively small part of the Boost collection of libraries.
    It was, however, used as the basis for what became the multithreading implementation
    in C++11, similar to how other Boost libraries ultimately made it, fully or partially,
    into new C++ standards. Refer to the C++ threads section in this chapter for details
    on the multithreading API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Boost线程是Boost库集合中相对较小的一部分。然而，它被用作成为C++11中多线程实现基础的基础，类似于其他Boost库最终完全或部分地成为新的C++标准。有关多线程API的详细信息，请参阅本章中的C++线程部分。
- en: 'Features missing in the C++11 standard, which are available in Boost threads,
    include the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准中缺少的功能，在Boost线程中是可用的，包括以下内容：
- en: Thread groups (like Windows jobs)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程组（类似于Windows作业）
- en: Thread interruption (cancellation)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程中断（取消）
- en: Thread join with timeout
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带超时的线程加入
- en: Additional mutual exclusion lock types (improved with C++14)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的互斥锁类型（在C++14中改进）
- en: Unless one absolutely needs such features, or if one cannot use a compiler which
    supports the C++11 standard (including STL threads), there is little reason to
    use Boost threads over the C++11 implementation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除非绝对需要这些功能，或者无法使用支持C++11标准（包括STL线程）的编译器，否则没有理由使用Boost线程而不是C++11实现。
- en: Since Boost provides wrappers around native OS features, using native C++ threads
    would likely reduce overhead depending on the quality of the STL implementation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Boost提供了对本机操作系统功能的包装，使用本机C++线程可能会减少开销，具体取决于STL实现的质量。
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The POCO library is a fairly lightweight wrapper around operating system functionality.
    It does not require a C++11 compatible compiler or any kind of pre-compiling or
    meta-compiling.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: POCO库是对操作系统功能的相当轻量级的包装。它不需要兼容C++11的编译器或任何类型的预编译或元编译。
- en: Thread class
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程类
- en: 'The `Thread` class is a simple wrapper around an OS-level thread. It takes
    `Worker` class instances which inherit from the `Runnable` class. The official
    documentation provides a basic example of this as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类是对OS级别线程的简单包装。它接受从`Runnable`类继承的`Worker`类实例。官方文档提供了一个基本示例，如下所示：'
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This preceding code is a very simple "Hello world" example with a worker which
    only outputs a string via the standard output. The thread instance is allocated
    on the stack, and kept within the scope of the entry function waiting for the
    worker to finish using the `join()` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个非常简单的“Hello world”示例，其中一个工作线程仅通过标准输出输出一个字符串。线程实例分配在堆栈上，并在入口函数的范围内等待工作线程完成，使用`join()`函数。
- en: With many of its thread functions, POCO is quite reminiscent of Pthreads, though
    it does deviate significantly on points such as configuring a thread and other
    objects. Being a C++ library, it sets properties using class methods rather than
    filling in a struct and passing it as a parameter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: POCO的许多线程功能与Pthreads非常相似，尽管在配置线程和其他对象等方面有明显的偏差。作为一个C++库，它使用类方法来设置属性，而不是填充结构并将其作为参数传递。
- en: Thread pool
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池
- en: 'POCO provides a default thread pool with 16 threads. This number can be changed
    dynamically. Like with regular threads, a thread pool requires one to pass a `Worker`
    class instance which inherits from the `Runnable` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: POCO提供了一个默认的线程池，有16个线程。这个数字可以动态改变。与常规线程一样，线程池需要传递一个从`Runnable`类继承的`Worker`类实例：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The worker instance is added to the thread pool, which runs it. The thread pool
    cleans up threads which have been idle for a certain time when we add another
    worker instance, change the capacity, or call `joinAll()`. As a result, the single
    worker thread will join, and with no active threads left, the application exits.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程实例被添加到线程池中，并运行它。当我们添加另一个工作线程实例，更改容量或调用`joinAll()`时，线程池会清理空闲一定时间的线程。结果，单个工作线程将加入，并且没有活动线程，应用程序退出。
- en: Thread local storage (TLS)
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程本地存储（TLS）
- en: With POCO, TLS is implemented as a class template, allowing one to use it with
    almost any type.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在POCO中，TLS被实现为一个类模板，允许人们将其用于几乎任何类型。
- en: 'As detailed by the official documentation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如官方文档所述：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this preceding worker example, we create a static TLS variable using the
    `ThreadLocal` class template, and define it to contain an integer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的worker示例中，我们使用`ThreadLocal`类模板创建了一个静态TLS变量，并定义它包含一个整数。
- en: Because we define it as static, it will only be created once per thread. In
    order to use our TLS variable, we can use either the arrow (`->`) or asterisk
    (`*`) operator to access its value. In this example, we increase the TLS value
    once per cycle of the `for` loop until the limit has been reached.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将它定义为静态的，所以每个线程只会创建一次。为了使用我们的TLS变量，我们可以使用箭头(`->`)或星号(`*`)运算符来访问它的值。在这个例子中，我们在`for`循环的每个周期增加TLS值，直到达到限制为止。
- en: This example demonstrates that both threads will generate their own series of
    10 integers, counting through the same numbers without affecting each other.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，两个线程将生成自己的一系列10个整数，计数相同的数字而互不影响。
- en: Synchronization
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: 'The synchronization primitives offered by POCO are listed as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: POCO提供的同步原语如下：
- en: Mutex
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥量
- en: FastMutex
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastMutex
- en: Event
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Condition
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件
- en: Semaphore
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号量
- en: RWLock
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RWLock
- en: Noticeable here is the `FastMutex` class. This is generally a non-recursive
    mutex type, except on Windows, where it is recursive. This means one should generally
    assume either type to be recursive in the sense that the same mutex can be locked
    multiple times by the same thread.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是`FastMutex`类。这通常是一种非递归的互斥类型，只是在Windows上是递归的。这意味着人们通常应该假设任一类型在同一线程中可以多次锁定同一互斥量。
- en: One can also use mutexes with the `ScopedLock` class, which ensures that a mutex
    which it encapsulates is released at the end of the current scope.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 人们还可以使用`ScopedLock`类与互斥量一起使用，确保它封装的互斥量在当前作用域结束时被释放。
- en: Events are akin to Windows events, except that they are limited to a single
    process. They form the basis of condition variables in POCO.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类似于Windows事件，只是它们限于单个进程。它们构成了POCO中条件变量的基础。
- en: POCO condition variables function much in the same way as they do with Pthreads
    and others, except that they are not subject to spurious wake-ups. Normally condition
    variables are subject to these random wake-ups for optimization reasons. By not
    having to deal with explicitly having to check whether its condition was met or
    not upon a condition variable wait returning less burden is placed on the developer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: POCO条件变量的功能与Pthreads等方式基本相同，只是它们不会出现虚假唤醒。通常情况下，条件变量会因为优化原因而出现这些随机唤醒。通过不需要显式检查条件变量等待返回时是否满足条件，减轻了开发者的负担。
- en: C++ threads
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++线程
- en: The native multithreading support in C++ is covered extensively in [Chapter
    12](f7ad9241-820d-465f-b20c-065efd0bde07.xhtml), *Native C++ Threads and Primitives*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的本地多线程支持在[第12章](f7ad9241-820d-465f-b20c-065efd0bde07.xhtml)中有详细介绍，*本地C++线程和原语*。
- en: As mentioned earlier in the Boost section of this chapter, the C++ multithreading
    support is heavily based on the Boost threads API, using virtually the same headers
    and names. The API itself is again reminiscent of Pthreads, though with significant
    differences when it comes to, for example, condition variables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章中Boost部分提到的，C++多线程支持在很大程度上基于Boost线程API，使用几乎相同的头文件和名称。API本身再次让人联想到Pthreads，尽管在某些方面有显著的不同，比如条件变量。
- en: Upcoming chapters will use the C++ threading support exclusively for examples.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将专门使用C++线程支持进行示例。
- en: Putting it together
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将它们组合在一起
- en: Of the APIs covered in this chapter, only the Qt multithreading API can be considered
    to be truly high level. Although the other APIs (including C++11) have some higher-level
    concepts including thread pools and asynchronous runners which do not require
    one to use threads directly, Qt offers a full-blown signal-slot architecture,
    which makes inter-thread communication exceptionally easy.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章涵盖的API中，只有Qt多线程API可以被认为是真正高级的。尽管其他API（包括C++11）包含一些更高级的概念，包括线程池和异步运行器，不需要直接使用线程，但Qt提供了一个完整的信号-槽架构，使得线程间通信异常容易。
- en: As covered in this chapter, this ease also comes with a cost, namely, that of
    having to develop one's application to fit the Qt framework. This may not be acceptable
    depending on the project.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章所介绍的，这种便利也伴随着一个代价，即需要开发应用程序以适应Qt框架。这可能在项目中是不可接受的。
- en: Which of these APIs is the right one depends on one's requirements. It is, however,
    relatively fair to say that using straight Pthreads, Windows threads, and kin
    does not make a lot of sense when one can use APIs such as C++11 threads, POCO,
    and so on, which ease the development process with no significant reduction in
    performance while also gaining extensive portability across platforms.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种API是正确的取决于个人的需求。然而，可以相对公平地说，当可以使用C++11线程、POCO等API时，使用直接的Pthreads、Windows线程等并没有太多意义，这些API可以在不显著降低性能的情况下轻松地实现跨平台。
- en: All the APIs are at least somewhat comparable at their core in what they offer
    in features.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些API在核心功能上至少在某种程度上是可比较的。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked in some detail at a number of the more popular multithreading
    APIs and frameworks, putting them next to each other to get an idea of their strengths
    and weaknesses. We went through a number of examples showing how to implement
    basic functionality using each of these APIs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了一些较流行的多线程API和框架，将它们并列在一起，以了解它们的优势和劣势。我们通过一些示例展示了如何使用这些API来实现基本功能。
- en: In the next chapter, we will look in detail at how to synchronize threads and
    communicate between them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细介绍如何同步线程并在它们之间进行通信。
