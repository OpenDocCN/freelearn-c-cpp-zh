- en: Debugging and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和测试
- en: Debugging and testing take an extremely important role in the pipeline of the
    software development process. Testing helps us to find problems while debugging
    fixes them. However, if we follow certain rules during the implementation stage,
    lots of potential defects can be prevented. Additionally, since a test process
    is very costly, it would be great if we could automatically analyze software by
    using certain tools before human testing is required. Moreover, when, how, and
    what we should test regarding software is also important.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和测试在软件开发过程的流水线中扮演着极其重要的角色。测试帮助我们发现问题，而调试修复问题。然而，如果我们在实施阶段遵循一定的规则，就可以预防许多潜在的缺陷。此外，由于测试过程非常昂贵，如果我们能在需要人工测试之前使用某些工具自动分析软件，那将是非常好的。此外，关于软件何时、如何以及应该测试什么也是很重要的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the root cause of an issue
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解问题的根本原因
- en: Debugging C++ programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试C++程序
- en: Understanding static and dynamic analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解静态和动态分析
- en: Exploring unit testing, TDD, and BDD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索单元测试、TDD和BDD
- en: Throughout this chapter, we will learn how to analyze a software defect, how
    to use a **GNU Debugger** (**GDB**) tool to debug a program, and how to use tools
    to automatically analyze software. We will also learn about the concepts of **unit
    testing**, **test-driven development** (**TDD**), and **behavior-driven development**
    (**BDD**), as well as how to practice using them during the software engineering
    development process.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何分析软件缺陷，如何使用GNU调试器（GDB）工具来调试程序，以及如何使用工具自动分析软件。我们还将学习单元测试、测试驱动开发（TDD）和行为驱动开发（BDD）的概念，以及如何在软件工程开发过程中进行实践。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)。
- en: Understanding the root cause of an issue
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解问题的根本原因
- en: In medicine, a good doctor needs to understand the difference between treating
    the symptoms and curing the condition. For example, giving painkillers to a patient
    with a broken arm will only take away the symptoms; surgery is probably the right
    way to help bones heal gradually.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在医学中，一个好的医生需要理解治疗症状和治愈疾病之间的区别。例如，给一个断臂的病人止痛药只会消除症状；手术可能是帮助骨骼逐渐愈合的正确方式。
- en: '**Root Cause Analysis** (**RCA**) is a systematic process that''s used to identify
    the fundamental cause of a problem. With the help of associated proper tools,
    it tries to identify the origin of the primary cause of the problem using a specific
    set of steps. By doing so, we can determine the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根本原因分析（RCA）是一种系统性的过程，用于确定问题的根本原因。借助适当的工具，它试图使用一组特定的步骤来确定问题的根本原因的起源。通过这样做，我们可以确定以下内容：
- en: What happened?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: How did it happen?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是如何发生的？
- en: Why did it happen?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么会发生？
- en: What proper approach would be used to prevent or reduce it so that it never
    happens again?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该采用什么适当的方法来防止或减少它，使其永远不再发生？
- en: RCA assumes that an action in one place triggers another action in another place,
    and so on. By tracing the action chain back to the beginning, we can discover
    the source of the problem and how it grows into the symptom we have. Aha! This
    is exactly the process we should follow to fix or reduce software defects. In
    the following subsections, we will learn about the basic RCA steps, how to apply
    the RCA process to detect software defects, and what certain rules a C++ developer
    should follow to prevent such defects from occurring in software.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: RCA假设一个地方的行动会触发另一个地方的行动，依此类推。通过追溯行动链到开始，我们可以发现问题的根源以及它如何演变成我们所拥有的症状。啊哈！这正是我们应该遵循的修复或减少软件缺陷的过程。在接下来的小节中，我们将学习基本的RCA步骤，如何应用RCA过程来检测软件缺陷，以及C++开发人员应该遵循哪些规则来防止软件中出现这样的缺陷。
- en: The RCA overview
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RCA概述
- en: 'Typically, an RCA process contains the following five steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RCA过程包括以下五个步骤：
- en: '**Define the problem**: In this stage, we may find answers to the following
    questions: what is happening? What are the symptoms of the problem? In what environment
    or conditions is the problem happening in/under?'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义问题：在这个阶段，我们可能会找到以下问题的答案：发生了什么？问题的症状是什么？问题发生在什么环境或条件下？
- en: '**Collect data**: To make a cause factor chart, we need to collect enough data.
    This step may be expensive and time-consuming.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集数据：为了制作因果因素图，我们需要收集足够的数据。这一步可能既昂贵又耗时。
- en: '**Make a causal factor chart**: A causal factor chart provides a visualization
    structure that we can use to organize and analyze the collected data. The causal
    factor chart is nothing but a sequence diagram with logic tests that explains
    the events leading up to the occurrence of a symptom. This charting process should
    drive the data collection process until the investigators are satisfied with the
    thoroughness of the chart.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作因果因素图：因果因素图提供了一个可视化结构，我们可以用它来组织和分析收集到的数据。因果因素图只是一个带有逻辑测试的序列图，解释了导致症状发生的事件。这个图表过程应该驱动数据收集过程，直到调查人员对图表的彻底性感到满意。
- en: '**Identify the root causes**: By examining the causal factor chart, we can
    make a decision diagram known as the **root cause map** to identify the cause
    or causes of the root.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定根本原因：通过检查因果因素图，我们可以制作一个决策图，称为根本原因图，以确定根本原因或原因。
- en: '**Recommend and implement solutions**: Once a root cause or multi-causes have
    been identified, the answers to the following questions can help us to find a
    solution: What can we do to prevent the problem from happening again? How will
    a solution be implemented? Who will be responsible for it? What are the costs
    or risks of implementing the solution?'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**推荐和实施解决方案**：一旦确定了根本原因或多个原因，以下问题的答案可以帮助我们找到解决方案：我们可以采取什么措施防止问题再次发生？解决方案将如何实施？谁将负责？实施解决方案的成本或风险是什么？'
- en: 'An RCA tree diagram is one of the most popular factor diagrams used in the
    software engineering industry. The following is an example structure of it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RCA树图是软件工程行业中最流行的因素图之一。以下是一个示例结构：
- en: '![](img/e9263dd4-03a3-4449-90b4-6e7d6d187b5d.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9263dd4-03a3-4449-90b4-6e7d6d187b5d.png)'
- en: Let's assume we have a problem that has **A**, **B**, and **C** symptoms. Symptom
    **A** can be caused by events **A1** or **A2**, symptom **B** can be caused by
    either event **B1** and **B2** or **B3** and **B4**, and symptom **C** is caused
    by events **C1** and **C2**. After data collection, we found that symptoms **A**
    and **C** never appeared and that we only have symptom **B**. Further analysis
    shows that events **B1** and **B2** are not involved when the problem occurs,
    so we can identify that the root cause of this problem is happening because of
    events **B3** or **B4**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个问题，它有**A**、**B**和**C**三种症状。症状**A**可能是由事件**A1**或**A2**引起的，症状**B**可能是由事件**B1**和**B2**或**B3**和**B4**引起的，而症状**C**是由事件**C1**和**C2**引起的。在收集数据后，我们发现症状**A**和**C**从未出现，而我们只有症状**B**。进一步的分析显示，在问题发生时，事件**B1**和**B2**并未涉及，因此我们可以确定这个问题的根本原因是由于事件**B3**或**B4**的发生。
- en: If the software has a defect, instead of just fixing it at the failing point,
    we should apply RCA to it and investigate the original fundamental root cause(s)
    of the problem. Then, the root cause(s) of the problem can be traced back to the
    requirements, the design, the implementation, the verification, and/or the test
    planning and input data. When the issues at the root are found and fixed, the
    quality of the software can be improved and hence the maintenance expenses will
    be drastically reduced.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件存在缺陷，我们应该对其应用RCA，并调查问题的原始根本原因。然后，问题的根本原因可以追溯到需求、设计、实施、验证和/或测试规划和输入数据。当找到并修复了根本原因时，软件的质量可以得到改善，因此维护费用将大大降低。
- en: We have just learned how to find the root cause of a problem, but remember that
    *the best defense is a good offense*. So, instead of analyzing and fixing a problem,
    what if we can prevent it from happening?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学会了如何找到问题的根本原因，但请记住，“最好的防御是进攻”。因此，我们可以预防问题的发生，而不是分析和修复问题。
- en: Prevention is better than the cure – a good coding behavior
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防胜于治疗——良好的编码行为
- en: From a cost point of view, an IBM study has shown that assuming the overall
    cost of the requirements and design is 1X, then the implementation and coding
    process will take 5X, the unit and integration tests will take about 10X, comprehensive
    customer beta test costs will take about ~15X, and the costs to fix bugs in post-product
    release occupies about 30X! Therefore, minimizing code defects is one of the most
    effective ways to keep production costs down.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从成本的角度来看，IBM的一项研究表明，假设需求和设计的总成本为1X，那么实施和编码过程将需要5X，单元和集成测试将需要约10X，全面的客户测试成本将需要约15X，而在产品发布后修复错误的成本将占约30X！因此，最小化代码缺陷是降低生产成本的最有效方法之一。
- en: 'Although the generic methodology of finding the root causes of software defects
    is very important, it would be even better if we could prevent some defects at
    the implementation stage. To do that, we need to have good coding behavior, which
    means that certain rules must be followed.  These rules can be classified at low
    and high levels. The low-level rules may include the following items:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管找到软件缺陷的根本原因的通用方法非常重要，但如果我们能在实施阶段预防一些缺陷，那将更好。为此，我们需要有良好的编码行为，这意味着必须遵循某些规则。这些规则可以分为低级和高级。低级规则可能包括以下内容：
- en: Uninitialized variables
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化变量
- en: Integer divisions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数除法
- en: Mistakenly using  `=`  instead of  `==`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误地使用`=`而不是`==`
- en: Potentially assign a signed variable to an unsigned variable
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能将有符号变量分配给无符号变量
- en: Missing `break` in `switch` statements
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`switch`语句中缺少`break`
- en: Side effects in compound expressions or function calls
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合表达式或函数调用中的副作用
- en: 'When it comes to the high-level rules, we have topics related to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 至于高级规则，我们有以下相关主题：
- en: Interfaces
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Resource management
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理
- en: Memory management
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理
- en: Concurrency
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: B. Stroustrup and H. Sutter have suggested following these rules in their live
    document, *C++ Core Guidelines (Release 0.8)*, where static type safety and resource
    safety are emphasized. They also emphasize the possibilities of range checking
    in order to avoid dereferencing null-ptr, dangling pointers, and the systematic
    use of exceptions. If a developer follows such rules, it will lead to his/her
    code being statically type-safe without any resource leaks. Additionally, it will
    not only catch many more programming logic errors, but it will also run faster.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: B. Stroustrup和H. Sutter在他们的实时文档*C++ Core Guidelines (Release 0.8)*中建议遵循这些规则，其中强调了静态类型安全和资源安全。他们还强调了范围检查的可能性，以避免解引用空指针、悬空指针和异常的系统使用。如果开发人员遵循这些规则，它将使他/她的代码在静态类型上是安全的，没有任何资源泄漏。此外，它不仅可以捕获更多的编程逻辑错误，而且还可以运行得更快。
- en: Because of page limitations, we will only look at a few examples of this in
    this subsection. If you want to look at more examples, please go to [https://isocpp.github.io/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页面限制，本小节只会介绍一些示例。如果您想查看更多示例，请访问[https://isocpp.github.io/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines)。
- en: Uninitialized variable problem
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未初始化变量问题
- en: 'An uninitialized variable is one of the most common mistakes a programmer can
    make. When we declare a variable, a certain amount of continuous memory will be
    allocated to it. If it is not initialized, it still has some value, but there
    is no deterministic way of predicting it. Consequently, unpredictable behavior
    shows up when we execute the program:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化的变量是程序员可能犯的最常见的错误之一。当我们声明一个变量时，将为其分配一定数量的连续内存。如果未初始化，它仍然具有一些值，但没有确定性地预测它的方法。因此，当我们执行程序时，会出现不可预测的行为：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, when `x` is declared, the OS will assign 4 bytes of unused
    memory to it, which means that the value of `x` is whatever value was residing
    in that memory. Each time we run this program, both the address and value of `x`
    might be different. Additionally, some compilers, such as Visual Studio, will
    initialize the value of `x` as `0` in the debug version but keep it uninitialized
    in the release version. In that case, we have a totally different output in the
    debug and release versions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，当声明`x`时，操作系统将为其分配4个字节的未使用内存，这意味着`x`的值是驻留在该内存中的任何值。每次运行此程序时，`x`的地址和值可能都不同。此外，一些编译器（如Visual
    Studio）将在调试版本中将`x`的值初始化为`0`，但在发布版本中将其保持未初始化。在这种情况下，调试版本和发布版本的输出完全不同。
- en: Side effects in compound expressions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合表达式中的副作用
- en: 'When an operator, expression, statement, or function has finished being evaluated,
    it may be prolonged or may continuously exist inside its compound. This continuous
    existence has some side effects that may lead to some undefined behaviors. Let''s
    have a look at the following code to understand this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当运算符、表达式、语句或函数完成评估后，它可能会被延长或者可能会持续存在于其复合体内。这种持续存在会产生一些副作用，可能导致一些未定义的行为。让我们看一下以下代码来理解这一点：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because of the undefined behavior of the evaluation order of operands, the result
    of the preceding code could be either 16 or 12.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作数的评估顺序的未定义行为，上述代码的结果可能是16或12。
- en: Mixing signed and unsigned problems
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合有符号和无符号问题
- en: 'Typically, binary operators (`+`,`-`, `*`, `/`, `%`, `<`, `<=`,`>`, `>=`, `==`,
    `!=`, `&&`, `||`, `!`,  `&`, `|`, `<<`, `>>`, `~`, `^`, `=`, `+=`, `-=`, `*=`,
    `/=`, and `%=`) require both side operands to be of the same type. If the two
    operands are of different types, one will be promoted to the same type as the
    other. Roughly speaking, there are three C standard conversion rules given in
    subclause 6.3.1.1 [ISO/IEC 9899:2011]:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，二进制运算符（`+`，`-`，`*`，`/`，`%`，`<`，`<=`，`>`，`>=`，`==`，`!=`，`&&`，`||`，`!`，`&`，`|`，`<<`，`>>`，`~`，`^`，`=`，`+=`，`-=`，`*=`，`/=`，和`%=`）要求两个操作数具有相同的类型。如果两个操作数的类型不同，则一个将被提升为与另一个相同的类型。粗略地说，C标准转换规则在子条款6.3.1.1
    [ISO/IEC 9899:2011]中给出。
- en: When we mix types of the same rank, the signed one will be promoted to an unsigned
    type.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们混合相同等级的类型时，有符号的类型将被提升为无符号类型。
- en: When we mix types of a different rank, the lower-ranked one will be promoted
    to the higher-ranked type if all the values of the lower-ranked side can be represented
    by the higher-ranked side.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们混合不同等级的类型时，如果较低等级的一方的所有值都可以由较高等级的一方表示，那么较低等级的一方将被提升为较高等级的类型。
- en: If all the values of the lower-ranked type cannot be represented by the higher-ranked
    type in the preceding case , then the unsigned version of the higher-ranked type
    will be used.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在上述情况下较低等级类型的所有值都不能由较高等级类型表示，则将使用较高等级类型的无符号版本。
- en: 'Now, let''s take a look at the traditional signed integer minus unsigned integer
    problem:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下传统的有符号整数减去无符号整数的问题：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, the signed `int` will be automatically converted into
    an unsigned `int` and the result will be `uint32_t z` = `-10`. On the other hand,
    because `−10` cannot be represented as an unsigned `int` value, its hexadecimal
    value, `0xFFFFFFF6`, will be interpreted as `UINT_MAX - 9` ( that is, `4294967286`)
    on two's complement machines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，有符号的`int`将自动转换为无符号的`int`，结果将是`uint32_t z` = `-10`。另一方面，因为`−10`不能表示为无符号的`int`值，它的十六进制值`0xFFFFFFF6`将被解释为`UINT_MAX
    - 9`（即`4294967286`）在补码机器上。
- en: Order of evaluation problem
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估顺序问题
- en: 'The following example is concerned with the initialization order of class members
    in a constructor. Since the initialization order is the order the class members
    appear in the class definition, it''s good practice to separate the declaration
    of each member into different lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例涉及构造函数中类成员的初始化顺序。由于初始化顺序是类成员在类定义中出现的顺序，因此将每个成员的声明分开到不同的行是一个好的做法：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In class `A`, although the declaring order is `v1 -> v2`,  putting them in one
    line confuses other developers. In the first constructor of class `B`, `v1` will
    be initialized as `x`, then `v2` will be initialized as `v1` because its declaration
    order is `v1->v2`. However, in its second constructor, `v1` will be initialized
    as `v2` first (at this point, `v2` is not initialized yet!), then `v2` will be
    initialized by `x`. This causes the different output values of `v1` in debug and
    release versions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在类`A`中，尽管声明顺序是`v1 -> v2`，但将它们放在一行中会使其他开发人员感到困惑。在类`B`的第一个构造函数中，`v1`将被初始化为`x`，然后`v2`将被初始化为`v1`，因为其声明顺序是`v1->v2`。然而，在其第二个构造函数中，`v1`将首先被初始化为`v2`（此时，`v2`尚未初始化！），然后`v2`将被`x`初始化。这导致调试版本和发布版本中`v1`的不同输出值。
- en: Compile-time checking versus runtime checking
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时检查与运行时检查
- en: 'The following example shows that runtime checking (number of bits for an integer
    type variable cloud) can be replaced by compile-time checking:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示，运行时检查（整数类型变量云的位数）可以被编译时检查替换：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since `int` can be either 16 or 32 bits, depending on the operating system,
    this example fails to achieve what it is trying to achieve. We should use `int32_t`
    or just replace it with the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`int`可以是16位或32位，这个例子取决于操作系统，无法实现其目标。我们应该使用`int32_t`或者用以下内容替换它：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another example is concerned with reading the max number of `n` integers into
    a one-dimensional array:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子涉及将n个整数的最大数量读入一维数组中：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This can be fixed using `span<int>`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使用`span<int>`来修复：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The general rule here is to do the analysis at compile-time as much as possible
    and to not postpone it until runtime.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一般规则是尽可能在编译时进行分析，而不要推迟到运行时。
- en: Avoiding memory leaks
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免内存泄漏
- en: A memory leak means that the allocated dynamic memory can never be freed. In
    C, we use `malloc()` and/or `calloc()`  to allocate memory and `free()` to release
    it. In C++, the `new` operator and the `delete` or `delete []` operators are used
    to manage memory dynamically. Although the risks of memory leak can be reduced
    with the help of smart pointers and **Resource Acquisition Is Initialization**
    (**RAII**), there are still some rules we need to follow if we wish to build high-quality
    code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏意味着分配的动态内存永远无法释放。在C中，我们使用`malloc()`和/或`calloc()`来分配内存，使用`free()`来释放它。在C++中，使用`new`运算符和`delete`或`delete[]`运算符来动态管理内存。尽管智能指针和RAII的帮助可以减少内存泄漏的风险，但如果我们希望构建高质量的代码，仍然有一些规则需要遵循。
- en: First, the easiest memory management way is the memory you never allocated by
    your own code. For example, whenever you can write `T x;`, don't write `T* x =
    new T();` or `shared_ptr<T> x(new T() );`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最简单的内存管理方式是你的代码从未分配的内存。例如，每当你可以写`T x;`时，不要写`T* x = new T();`或`shared_ptr<T>
    x(new T());`。
- en: 'Next, do not manage the memory using your own code, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，不要使用自己的代码管理内存，如下所示：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead, try to use RAII, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，尝试使用RAII，如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, use `unique_ptr` to replace `shared_ptr` unless you need to share its
    ownership, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`unique_ptr`替换`shared_ptr`，除非你需要共享它的所有权，如下所示：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since `b` is locally used without copying it, its `refcount` will be always
    `1`. This means we can use a `unique_ptr` to replace it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`b`在本地使用而没有复制它，它的`refcount`将始终为`1`。这意味着我们可以使用`unique_ptr`来替换它：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, even if you really need to dynamically manage the memory by yourself,
    don't manually allocate the memory if there is an `std container` library class
    available.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，即使你真的需要自己动态管理内存，如果有`std container`库类可用，不要手动分配内存。
- en: In this section, we learned how to locate a problem using RCA and how to prevent
    a problem by coding best practices. Next, we'll learn how to use a debugger tool
    to control the line-by-line execution of a program and examine the values of variables
    and expressions during its running time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用RCA定位问题以及如何通过编码最佳实践来预防问题。接下来，我们将学习如何使用调试器工具来控制程序的逐行执行，并在运行时检查变量和表达式的值。
- en: Debugging C++ programs
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试C++程序
- en: Debugging is the process of finding and resolving the problems or defects of
    a program. This may include interactive debugging, data/control flow analysis,
    and unit and integration testing. In this section, we will only focus on interactive
    debugging, which is the process of executing your source code line-by-line with
    breakpoints, all while showing the values of the variables being used and their
    corresponding memory addresses.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是找到并解决程序问题或缺陷的过程。这可能包括交互式调试、数据/控制流分析以及单元和集成测试。在本节中，我们只关注交互式调试，这是逐行执行源代码并显示正在使用的变量的值及其相应内存地址的过程。
- en: Tools to debug a C/C++ program
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试C/C++程序的工具
- en: Depending on your development environment, there are lots of tools available
    in the C++ community. The following list shows the most popular ones on different
    platforms.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的开发环境，在C++社区中有很多可用的工具。以下列表显示了不同平台上最受欢迎的工具。
- en: 'Linux/Unix:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux/Unix：
- en: '**GDB**: A free open source **Command-Line Interface** (**CLI**) debugger.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB：一个免费的开源命令行界面（CLI）调试器。
- en: '**Eclipse**: A free open source **Integrated Development Environment** (**IDE**).
    It supports not only debugging but also compiling, profiling, and smart editing.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse：一个免费的开源集成开发环境（IDE）。它不仅支持调试，还支持编译、性能分析和智能编辑。
- en: '**Valgrind**: Another open source dynamic analysis tool; it is good for debugging
    memory leaks and threading bugs.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Valgrind：另一个开源的动态分析工具；它适用于调试内存泄漏和线程错误。
- en: '**Affinic**: A commercial **Graphic User Interface** (**GUI**) tool built for
    the **GDB**,  **LLDB**, and **LLVM debugger**.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Affinic：一个商业的图形用户界面（GUI）工具，专为GDB、LLDB和LLVM调试器构建。
- en: '**DDD** : An open source data display debugger for **GDB**, **DBX**, **JDB**,
    **XDB,** and **Python**, it displays data structures as graphs.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDD：一个用于GDB、DBX、JDB、XDB和Python的开源数据显示调试器，它将数据结构显示为图形。
- en: '**GDB in Emacs mode**: An open source GUI tool that uses GNU Emacs to view
    and edit source code when debugging with GDB.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emacs模式下的GDB：一个使用GNU Emacs查看和编辑源代码的开源GUI工具，用于与GDB一起调试。
- en: '**KDevelop**: A free and open source IDE and debugger tool for programming
    languages such as C/C++, Objective-, and so on.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KDevelop：一个用于C/C++、Objective-等编程语言的免费开源IDE和调试器工具。
- en: '**Nemiver**: An open source tool that works well in the **GNOME** desktop environment.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nemiver：一个在GNOME桌面环境中运行良好的开源工具。
- en: '**SlickEdit**: A good tool for debugging multithreaded and multiprocessor code.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SlickEdit：一个用于调试多线程和多处理器代码的好工具。
- en: 'Windows:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：
- en: '**Visual Studio**: A commercial tool with GUI that''s free for community versions.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio：一个商业工具，社区版本免费提供GUI。
- en: '**GDB**: This can run in Windows as well with the help of **Cygwin** or **MinGW**.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB：这也可以在Windows上运行，借助Cygwin或MinGW的帮助。
- en: '**Eclipse**: Its **C++ Development Tooling** (**CDT**) can be installed on
    Windows with the MinGW GCC compiler in the toolchains.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse：它的C++开发工具（CDT）可以在Windows上使用MinGW GCC编译器的工具链进行安装。
- en: 'macOS:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS：
- en: '**LLDB**: This is the default debugger in **Xcode** on macOS and supports C/C++
    and Objective-C on desktop and iOS devices and their simulators.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLDB：这是macOS上Xcode的默认调试器，支持桌面和iOS设备及其模拟器上的C/C++和Objective-C。
- en: '**GDB**: This CLI debugger is also used on macOS and iOS systems.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB：这个CLI调试器也被用于macOS和iOS系统。
- en: '**Eclipse**: This free IDE using GCC works for macOS.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse**：这个使用GCC的免费IDE适用于macOS。'
- en: Since GDB can be run on all platforms, we will show you how to use GDB in the
    following subsections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GDB可以在所有平台上运行，我们将在以下子节中向您展示如何使用GDB。
- en: GDB overview
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GDB概述
- en: 'GDB stands for GNU debugger, which allows a developer to see *what is going
    on inside another program while it executes, or what another program was doing
    at the moment it crashed*. GDB can do the following four main things:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: GDB代表GNU调试器，允许开发人员在另一个程序执行时看到*内部发生了什么，或者在另一个程序崩溃时它正在做什么*。GDB可以做以下四件事情：
- en: Start a program and specify anything that might affect its behavior.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动程序并指定可能影响其行为的任何内容。
- en: Make a program stop on given conditions.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使程序在给定条件下停止。
- en: Examine what happened when a program stopped.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查程序停止时发生了什么。
- en: Change the values of variables while running a program. This means we can experiment
    with something to correct the effects of one bug and/or go on to learn the side
    effects of another.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行程序时更改变量的值。这意味着我们可以尝试纠正一个bug的影响和/或继续学习另一个bug的副作用。
- en: 'Note that two programs or executable files are involved: one is GDB, while
    the other is the program to be debugged. Since these two programs can run either
    on the same machine or different ones, we may have three categories of debugging,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，涉及两个程序或可执行文件：一个是GDB，另一个是要调试的程序。由于这两个程序可以在同一台机器上或不同的机器上运行，因此我们可能有三种调试类别，如下所示：
- en: '**Native debugging**: Both programs run on the same machine.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地调试**：两个程序在同一台机器上运行。'
- en: '**Remote debugging**: GDB  runs on a host machine, while the debugged program
    runs on a remote machine.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程调试**：GDB在主机上运行，而调试的程序在远程机器上运行。'
- en: '**Simulator debugging**: GDB runs on a host machine, while the debugged program
    runs on a simulator.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟器调试**：GDB在主机上运行，而调试的程序在模拟器上运行。'
- en: Based on the latest release (GDB v8.3) at the time of writing this book, the
    languages supported by GDB including C, C++, Objective-C, Ada, Assembly, D, Fortran,
    Go, OpenCL, Modula-2, Pascal, and Rust.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 根据撰写本书时的最新版本（GDB v8.3），GDB支持的语言包括C、C++、Objective-C、Ada、Assembly、D、Fortran、Go、OpenCL、Modula-2、Pascal和Rust。
- en: Since GDB is a state-of-the-art tool in the debugging industry and is complex
    and has lots of functions, it won't be possible to learn about all its features
    in this section. Instead, we will study the most useful features by looking at
    examples.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GDB是调试行业中的一种先进工具，功能复杂且功能丰富，因此在本节中不可能学习所有其功能。相反，我们将通过示例来学习最有用的功能。
- en: Examples of GDB
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GDB示例
- en: 'Before practicing these examples, we need to check if `gdb` has been installed
    on our system by running the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习这些示例之前，我们需要通过运行以下代码来检查系统上是否已安装`gdb`：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the following kind of information is displayed,  we will be ready to start:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显示以下类型的信息，我们将准备好开始：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Otherwise, we need to install it. Let''s go over how we can install it on the
    different operating systems:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们需要安装它。让我们看看如何在不同的操作系统上安装它：
- en: 'For Debian-based Linux:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于Debian的Linux：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For Redhat-based Linux:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于Redhat的Linux：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For macOS:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于macOS：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Windows users can install GDB through MinGW distributes. macOS will need a taskgated
    configuration.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户可以通过MinGW发行版安装GDB。macOS将需要taskgated配置。
- en: Then, type `gdb --help` again to check if it was successfully installed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次输入`gdb --help`来检查是否成功安装。
- en: Setting breakpoints and inspection variable values
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置断点和检查变量值
- en: 'In the following example, we will learn how to set breakpoints, continue, step
    into or step over a function, print values of variables, and how to use help in
    `gdb`. The source code is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将学习如何设置断点，继续，步入或跳过函数，打印变量的值，以及如何在`gdb`中使用帮助。源代码如下：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we mentioned in [Chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml),
    *Details of Object-Oriented Programming, *let''s build this program in debug mode,
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml)中提到的*面向对象编程的细节*，让我们以调试模式构建此程序，如下所示：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that for g++, the `-g` option means the debugging information will be
    included in the output binary file. If we run this program, it will show the following
    output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于g++，`-g`选项意味着调试信息将包含在输出的二进制文件中。如果我们运行此程序，它将显示以下输出：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s use `gdb` to see where the bug is. To do that, we need to execute
    the following command line:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`gdb`来查看bug在哪里。为此，我们需要执行以下命令行：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By doing this, we will see the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将看到以下输出：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s have a look at the various commands in detail:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解各种命令：
- en: '`break` and `run`: If we type `b main` or `break main` and press *Enter*, a
    `breakpoint` will be inserted at the main function. Then, we can type `run` or
    `r` to start debugging the program. The following information will be shown in
    a Terminal window. Here, we can see that our first `breakpoint` is at the sixth
    line in the source code and that the debugged program has been paused in order
    to wait for a new command:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`和`run`：如果我们输入`b main`或`break main`并按*Enter*，则会在主函数中插入一个`breakpoint`。然后，我们可以输入`run`或`r`来开始调试程序。在终端窗口中将显示以下信息。在这里，我们可以看到我们的第一个`breakpoint`在源代码的第六行，调试程序已经暂停以等待新命令：'
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`next`, `print`, and `quit`:The `n` or`next`commandwill go to the next line
    of the code. If the line calls a subroutine, it does not enter the subroutine;
    instead, it steps over the call and treats it as a single source line. If we want
    to show the value of a variable, we can use the `p` or `print` command, followed
    by the variable''s name.  Finally, if we want to exit from `gdb`, the `q` or `quit` command
    can be used. Here is the output from the Terminal window after running these operations:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`，`print`和`quit`：`n`或`next`命令将转到代码的下一行。如果该行调用子例程，则不会进入子例程；相反，它会跳过调用并将其视为单个源行。如果我们想显示变量的值，我们可以使用`p`或`print`命令，后跟变量的名称。最后，如果我们想退出`gdb`，可以使用`q`或`quit`命令。运行这些操作后，以下是终端窗口的输出：'
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`step`: Now let''s learn how to step into the `multiple()` function and find
    the bug. To do that, we need to start over by using the `b`, `r`, and `n` command
    to reach line 7 first. Then, we can use the `s` or `step` command to step into
    the `multiple()` function. Next, we use the `n` command to reach line 14 and `p`
    to print the value of the `ret` variable, which is 30\. At this point, we''ve
    figured out that by using `ahha the bug is at line 14!:`, instead of `x*y`, we
    have a typo, that is, `x+y`. The following code block is the corresponding outputs
    from these commands:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`：现在让我们学习如何进入`multiple()`函数并找到错误。为此，我们需要使用`b`、`r`和`n`命令首先到达第7行。然后，我们可以使用`s`或`step`命令进入`multiple()`函数。接下来，我们使用`n`命令到达第14行，使用`p`打印`ret`变量的值，即30。到目前为止，我们已经发现，通过使用`ahha
    the bug is at line 14!:`，而不是`x*y`，我们有一个拼写错误，即`x+y`。以下代码块是这些命令的相应输出：'
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`help`: Lastly, let''s learn about the `help` command to end this small example.
    When `gdb` is launched, we can use the `help` or `h` command to get the usage
    information of a particular command in its command input line. For instance, the
    following Terminal window summarizes what have we learned so far:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help`：最后，让我们学习如何使用`help`命令来结束这个小例子。当启动`gdb`时，我们可以使用`help`或`h`命令来获取特定命令的使用信息。例如，以下终端窗口总结了我们到目前为止学到的内容：'
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At this point, we have learned about a few basic commands we can use to debug
    a program. These commands are `break`, `run`, `next`, `print`, `quit`, `step`,
    and `help`. We will learn about function and conditional breakpoints, watchpoint,
    and the `continue` and `finish` commands in the next subsection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了一些基本命令，可以用来调试程序。这些命令是`break`、`run`、`next`、`print`、`quit`、`step`和`help`。我们将在下一小节学习函数和条件断点、观察点，以及`continue`和`finish`命令。
- en: Function breakpoints, conditional breakpoints,  watchpoint, and the continue
    and finish commands
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数断点、条件断点、观察点，以及继续和完成命令
- en: 'In this example, we will learn how to set function breakpoints, conditional
    breakpoints, and use the `continue` command. Then, we will learn how to finish
    a function call without the need to execute all the code lines in a step by step
    format. The source code is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何设置函数断点、条件断点，并使用`continue`命令。然后，我们将学习如何在不需要逐步执行所有代码行的情况下完成函数调用。源代码如下：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Again, after building and running `ch13_gdb_2.cpp`, we get the following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，构建并运行`ch13_gdb_2.cpp`后，我们得到以下输出：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since both `dot(x,x)` and `dot(x,y)` give us the same results, something must
    be wrong here. Now, let''s debug it by learning how to set a breakpoint in the `dot()` function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`dot(x,x)`和`dot(x,y)`都给我们相同的结果，这里一定有问题。现在，让我们通过学习如何在`dot()`函数中设置断点来调试它：
- en: '**Function breakpoint**: To set a breakpoint at the beginning of a function,
    we can use the `b function_name` command. As always, we can use tab completion
    during input. For instance, let''s say we type the following:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数断点**：要在函数的开头设置断点，我们可以使用`b function_name`命令。和往常一样，在输入时可以使用制表符补全。例如，假设我们输入以下内容：'
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following command line will automatically pop up if we do this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，以下命令行将自动弹出：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If it is a member function of a class, its class name should be included, as
    follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个类的成员函数，它的类名应该包括在内，如下所示：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Conditional breakpoint**: There are several ways to set a conditional breakpoint:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件断点**：有几种设置条件断点的方法：'
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**List and delete breakpoints**: Once we''ve set a few breakpoints, we can
    list or delete them, as follows:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列出和删除断点**：一旦我们设置了几个断点，我们可以列出或删除它们，如下所示：'
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Remove make** **a breakpoint** **unconditional**: Since each breakpoint has
    a number, we can remove a condition from a breakpoint, like so:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除使断点无条件**：由于每个断点都有一个编号，我们可以删除断点的条件，如下所示：'
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Watchpoint**: A watchpoint can stop execution when the value of an expression
    changes, without having to predict where (in which line) it may happen. There
    are three kinds of watchpoints:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察点**：观察点可以在表达式的值发生变化时停止执行，而不必预测它可能发生的位置（在哪一行）。有三种观察点：'
- en: '`watch`: `gdb` will break when a write occurs'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watch`：当写入发生时，`gdb`将中断。'
- en: '`rwatch`: `gdb` will break when a read occurs'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwatch`：当读取发生时，`gdb`将中断。'
- en: '`awatch`: `gdb` will break when either a write or a read happens'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awatch`：当发生写入或读取时，`gdb`将中断。'
- en: 'The following code shows an example of this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个例子：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**continue**: When we''ve finished examining the values of variables at a breakpoint,
    we can use the `continue` or `c` command to continue program execution until the
    debugger encounters a breakpoint, a signal, an error, or normal process termination.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继续**：当我们在断点处检查变量的值后，我们可以使用`continue`或`c`命令来继续程序执行，直到调试器遇到断点、信号、错误或正常进程终止。'
- en: '**finish**: Once we go inside a function, we may want to execute it continuously
    until it returns to its caller line. This can be done using the `finish` command.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成**：一旦我们进入一个函数，我们可能希望连续执行它，直到返回到其调用行。这可以使用`finish`命令来完成。'
- en: 'Now, let''s put these commands together to debug `ch13_gdb_2.cpp`.The following
    is the output from our Terminal window. For your convenience, we''ve separated
    it into three parts:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些命令组合在一起来调试`ch13_gdb_2.cpp`。以下是我们终端窗口的输出。为了方便起见，我们将其分为三部分：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In part one, we have the following six commands:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分，我们有以下六个命令：
- en: '`cmd 1`: We start `gdb` with the parameter of the built executable file, `ch13_gdb_2.out`.
    This briefly shows us its version and document and usage information, and then
    tells us that the reading symbols process has been completed and is waiting for
    the next command.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 1`：我们使用构建的可执行文件`ch13_gdb_2.out`启动`gdb`。这简要显示了它的版本和文档和使用信息，然后告诉我们读取符号的过程已经完成，并且正在等待下一个命令。'
- en: '`cmd 2`:  We set a `breakpoint` function (at `dotproduct()`).'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 2`：我们设置了一个`断点`函数（在`dotproduct()`处）。'
- en: '`cmd 3`: A conditional `breakpoint` is set.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 3`：设置了一个条件`断点`。'
- en: '`cmd 4`: It lists information about the breakpoints and tells us that we have
    two of them.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 4`: 它列出了关于断点的信息，并告诉我们有两个断点。'
- en: '`cmd 5`: We set `breakpoint 2` as `unconditional`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 5`: 我们将`breakpoint 2`设置为`无条件的`。'
- en: '`cmd 6`: We list the breakpoint information again. At this point, we can see
    two breakpoints. These are located at lines 20 and 24 in the `ch13_gdb_2.cp` file,
    respectively.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 6`: 再次列出断点信息。此时，我们可以看到两个断点。它们分别位于`ch13_gdb_2.cp`文件的第20行和第24行。'
- en: 'Next, let''s look at the `gdb` output in part two:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看第二部分的`gdb`输出：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Part two has the following cmds:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分有以下命令：
- en: '`cmd 7`: By giving the `run` command, the program starts running and stops
    at the first breakpoint in line 20.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 7`: 通过给出`run`命令，程序开始运行，并在第20行的第一个断点处停止。'
- en: '`cmd 8`: We print the value of `x`, whichshows its address.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 8`: 我们打印`x`的值，显示其地址。'
- en: '`cmd 9`: We continue the program.  Once it''s been continued, it stops at the
    second breakpoint in line 24.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 9`: 我们继续程序。一旦继续，它会在第24行的第二个断点处停止。'
- en: '`cmd 10`: The value of `i` is printed, which is `0`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 10`: 打印`i`的值，为`0`。'
- en: '`cmd 11-12`: We use the `next` command twice. At this point, the `s += (*p) 
    *  (*q)` statement is executed.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 11-12`: 我们两次使用`next`命令。在这一点上，执行`s += (*p) * (*q)`语句。'
- en: '`cmd 13`:  The value of `s` is printed, which is `1`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 13`: 打印`s`的值，为`1`。'
- en: '`cmd 14`:  We print the value of `s` .'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 14`: 我们打印`s`的值。'
- en: 'Finally, part three is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三部分如下：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this part, we have the following commands:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们有以下命令：
- en: '`cmd 15`: We use the `next` command to see what the value of `s` is if the
    next iteration is executed. It shows that the old value of`s` is `1` (s = 1*1)
    and that the new value is `5` (s=1*1+2*2). So far, so good!'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 15`: 我们使用`next`命令来查看如果执行下一次迭代时`s`的值是多少。它显示旧值为`s`为`1`（s = 1*1），新值为`5`（s=1*1+2*2）。到目前为止，一切顺利！'
- en: '`cmd 16`: A `finish` command is used to continue running the program until
    it exits from the function.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 16`: 使用`finish`命令继续运行程序，直到退出函数。'
- en: '`cmd 17`:  We delete breakpoints 1  to 3.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 17`: 删除断点1到3。'
- en: '`cmd 18`: A `continue` command is used.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 18`: 使用`continue`命令。'
- en: '`cmd 19`: We quit `gdb` and go back to the Terminal window.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 19`: 我们退出`gdb`，回到终端窗口。'
- en: Logging gdb into a text file
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将gdb记录到文本文件中
- en: 'When dealing with a long stack trace or multi-thread stack trace, viewing and
    analyzing `gdb` output from a Terminal window can be inconvenient. However, we
    can log either an entire session or specific output into a text file first, then
    browse it offline later using other text editor tools. To do this, we need to
    use the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 处理长堆栈跟踪或多线程堆栈跟踪时，从终端窗口查看和分析`gdb`输出可能会不方便。然而，我们可以先将整个会话或特定输出记录到文本文件中，然后稍后离线使用其他文本编辑工具进行浏览。为此，我们需要使用以下命令：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When we execute this command, `gdb` will save all the Terminal window outputs
    into a text file named `gdb.txt` in the currently running `gdb` folder.  If we
    want to stop logging, we can just type the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此命令时，`gdb`将把所有终端窗口输出保存到名为`gdb.txt`的文本文件中，该文件位于当前运行的`gdb`文件夹中。如果我们想停止记录，只需输入以下内容：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: One great thing about GDB is that we can turn set logging commands on and off
    as many times as we want, without worrying about the dumped file names. This is
    because all the outputs are concatenated into the `gdb.txt` file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GDB的一大好处是，我们可以随意多次打开和关闭日志记录命令，而不必担心转储文件名。这是因为所有输出都被连接到`gdb.txt`文件中。
- en: 'Here is an example of returning `ch13_gdb_2.out` with the `gdb` output being
    dumped:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是返回`ch13_gdb_2.out`并将`gdb`输出转储的示例：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The commands that were used in the preceding code are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中使用的命令如下：
- en: '`cmd 1`:  `gdb` is launched.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 1`: 启动`gdb`。'
- en: '`cmd 2`:  We set the logging flag to on. At this point, `gdb` says the output
    will be copied into the `gdb.txt` file.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 2`: 我们将日志标志设置为打开。此时，`gdb`表示输出将被复制到`gdb.txt`文件中。'
- en: '`cmd 3`:  A conditional `break point` is set.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 3`: 设置条件`断点`。'
- en: '`cmd 4`: We run the program, and it stops when it reaches the conditional `breakpoint`
    at line 24.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 4`: 我们运行程序，当它到达第24行的条件`断点`时停止。'
- en: '`cmd 5`and `cmd 6`: We print the values of `i` and `s`, receptively.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 5`和`cmd 6`: 我们分别打印`i`和`s`的值。'
- en: '`cmd 7`: By executing the step out of the function command, it shows that `sxx`
    is `55` (after calling `sxx=dotproduct( x, x, 5))`) and that the program stops
    at line `sxy *=* dotproduct( x, y, 5).`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 7`: 通过执行函数步出命令，显示`sxx`为`55`（在调用`sxx=dotproduct(x, x, 5))`后），程序停在`sxy *=*
    dotproduct(x, y, 5)`行。'
- en: '`cmd 8`: We delete `breakpoint 1`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 8`: 我们删除`breakpoint 1`。'
- en: '`cmd 9`: We set the logging flag to off.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 9`: 我们将日志标志设置为关闭。'
- en: '`cmd 10`: Once a continue instruction is given, it runs out of the `main` function
    and `gdb` waits for a new command.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 10`: 一旦给出继续指令，它就会从`main`函数中运行出来，`gdb`等待新命令。'
- en: '`cmd 11`:  We input `q ` to quit `gdb`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 11`: 我们输入`q`退出`gdb`。'
- en: '`cmd 12`: When it goes back to the Terminal window, we print the content of
    the logged `gdb.txt` file by running the `cat` command in the OS.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd 12`: 当返回到终端窗口时，通过在操作系统中运行`cat`命令打印已记录的`gdb.txt`文件的内容。'
- en: So far, we have learned enough GDB commands to debug a program. As you may have
    noticed, it's time-consuming and thus very costly. Sometimes, it becomes even
    worse because of debugging in the wrong places. To debug efficiently, we need
    to follow the right strategies. We will cover this in the following subsection.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了足够的GDB命令来调试程序。正如你可能已经注意到的，这是耗时的，因此非常昂贵。有时，由于在错误的地方调试，情况变得更糟。为了高效地调试，我们需要遵循正确的策略。我们将在下一小节中介绍这一点。
- en: Practical debugging strategies
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用调试策略
- en: 'Since debugging is the costliest stage in the software development life cycle,
    finding bugs and fixing them isn''t feasible, especially for large, complex systems.
    However, there are certain strategies that can be used in practical processes,
    some of which are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调试是软件开发生命周期中成本最高的阶段，发现错误并修复它们是不可行的，特别是对于大型复杂系统。然而，有一些策略可以在实际过程中使用，其中一些如下：
- en: '**Use printf() or std::cout**: This is the old-fashioned way of doing things.
    By printing some information to the Terminal, we can check the values of variables
    and perform where and when kinds of log profiles for further analysis.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用printf()或std::cout**：这是一种老式的做法。通过将一些信息打印到终端，我们可以检查变量的值，并执行进一步分析的位置和时间种类的日志配置文件。'
- en: '**Use a debugger**: Although learning to use a GDB kind of debugger tool is
    not an overnight thing, it can save lots of time. So, try to become familiar with
    it step by step and gradually.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用调试器**：虽然学习使用GDB这类调试器工具不是一蹴而就的事情，但它可以节省大量时间。因此，逐步熟悉它，并逐渐掌握。'
- en: '**Reproduce bugs**: Whenever a bug is reported in the field, make a record
    of the running environment and input data.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重现错误**：每当在现场报告错误时，记录运行环境和输入数据。'
- en: '**Dump log files**: An application program should dump log messages into a
    text file.  When a crash happens, we should check the log files as the first step
    to see if an abnormal event occurred.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转储日志文件**：应用程序应将日志消息转储到文本文件中。发生崩溃时，我们应首先检查日志文件，以查看是否发生异常事件。'
- en: '**Have a guess**: Roughly guess a bug''s location and then prove whether it
    was right or wrong.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**猜测**：粗略猜测错误的位置，然后证明它是对还是错。'
- en: '**Divide and conquer**: Even in the worst scenario that we do not have any
    idea of what bugs there are, we still can use **the binary search** strategy to
    set breakpoints and then narrow down and eventually locate them.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分而治之**：即使在最糟糕的情况下，我们对存在什么错误一无所知，我们仍然可以使用**二分搜索**策略设置断点，然后缩小范围，最终定位它们。'
- en: '**Simplify**: Always start from the most simplified scenario and gradually
    add peripherals, input modules, and so on until the bug can be reproduced.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化**：始终从最简化的情景开始，逐渐添加外围设备、输入模块等，直到可以重现错误。'
- en: '**Source code version controlled**: If a bug has suddenly appeared on a release
    but it had run fine previously, do a source code tree check first. Someone may
    have made a change!'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码版本控制**：如果一个错误突然出现在一个发布版上，但之前运行正常，首先检查源代码树。可能有人做了改变！'
- en: '**Don''t give up**: Some bugs are really hard to locate and/or fix, especially
    for complex and multi-team involved systems. Put them aside for a while and rethink
    it on your way home – the *aha moment* may reveal itself eventually.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要放弃**：有些错误真的很难定位和/或修复，特别是对于复杂和多团队参与的系统。暂时搁置它们，回家的路上重新思考一下，也许会有*灵光一现*。'
- en: So far, we have learned about macro-level problem localization using RCA and
    the good coding practices we can follow to prevent problems from occurring. Furthermore,
    by using a state-of-the-art debugger tool such as GDB, we can control the execution
    of a program line by line so that we can analyze and fix the problem at the micro
    level. All these activities are programmer centralized and manual.  Can any automatic
    tools help us diagnose the potential defects of a program? We'll take a look at
    static and dynamic analysis in the next section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用RCA进行宏观问题定位，以及我们可以遵循的良好编码实践，以防止问题发生。此外，通过使用诸如GDB之类的最先进的调试器工具，我们可以逐行控制程序的执行，以便我们可以在微观级别分析和解决问题。所有这些活动都是程序员集中和手动的。是否有任何自动工具可以帮助我们诊断程序的潜在缺陷？我们将在下一节中看一下静态和动态分析。
- en: Understanding static and dynamic analysis
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解静态和动态分析
- en: In the previous sections, we learned about the root cause analysis process and
    how to use GDB to debug a defect. This section will discuss how to analyze a program
    with and without executing it. The former is called dynamic analysis, while the
    latter is called static analysis.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们学习了根本原因分析过程以及如何使用GDB调试缺陷。本节将讨论如何分析程序，无论是否执行。前者称为动态分析，而后者称为静态分析。
- en: Static analysis
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析
- en: Static analysis evaluates the quality of a computer program without executing
    it. Although this can usually be done by examining source code via automatic tools
    and code reviews/inspections, we will only focus on automatic tools in this section.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析评估计算机程序的质量，而无需执行它。虽然通常可以通过自动工具和代码审查/检查来完成，但本节我们只关注自动工具。
- en: 'The automatic static code analysis tools are designed to analyze a set of code
    against one or multiple sets of coding rules or guidelines. Normally, people use
    static code analysis*,* static analysis, or source code analysis interchangeably.
    By scanning the entire code base with every possible code execution path, we can
    find lots of potential bugs before the testing phases. However, it also has several
    limitations, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 自动静态代码分析工具旨在分析一组代码与一个或多个编码规则或指南。通常，人们可以互换使用静态代码分析、静态分析或源代码分析。通过扫描每个可能的代码执行路径的整个代码库，我们可以在测试阶段之前找到许多潜在的错误。然而，它也有一些限制，如下所示：
- en: It can produce false positive and false negative alarms.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会产生错误的阳性和阴性警报。
- en: It only applies the rules that were implemented inside the scanning algorithm,
    and some of them may be subjectively interpreted.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只应用于扫描算法内部实施的规则，其中一些可能会被主观解释。
- en: It cannot find vulnerabilities that were introduced in a runtime environment.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它无法找到在运行时环境中引入的漏洞。
- en: It can provide a false sense of security that everything is being addressed.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会产生一种虚假的安全感，认为一切都在得到解决。
- en: 'There are about 30 automatic C/C++ code analysis tools [9] under both commercial
    and free open source categories. The names of these tools include Clang, Clion,
    CppCheck, Eclipse, Visual Studio, and GNU g++, just to name a few. As examples,
    we would like to introduce the `**-**Wall`,  `-Weffcc++`, and `-Wextra` options,
    which are built into GNU compiler g++[10]:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业和免费开源类别下，有大约30个自动C/C++代码分析工具[9]。这些工具的名称包括Clang、Clion、CppCheck、Eclipse、Visual
    Studio和GNU g++等。作为示例，我们想介绍内置于GNU编译器g++[10]中的`**-**Wall`、`-Weffcc++`和`-Wextra`选项：
- en: '`-Wall`: This enables all construction warnings, which are questionable for
    some users. These warnings are easy to avoid or modify, even in conjunction with
    macros. It also enables some language-specific warnings described in C ++ Dialect
    Options and Objective-C/C ++ Dialect Options.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wall`：启用所有构造警告，对于某些用户来说是有问题的。这些警告很容易避免或修改，即使与宏一起使用。它还启用了一些在C++方言选项和Objective-C/C++方言选项中描述的特定于语言的警告。'
- en: '`-Wextra`: As its name implies, it examines certain extra warning flags that
    are not checked by `-Wall`. Warning messages for any of the following cases will
    be printed:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wextra`：正如其名称所示，它检查一些`-Wall`未检查的额外警告标志。将打印以下任何情况的警告消息：'
- en: A pointer is compared against integer zero with the `<`, `<=`, `>`, or `>=`
    operands.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将指针与整数零使用`<`、`<=`、`>`或`>=`操作数进行比较。
- en: A non-enumerator and an enumerator show up in a conditional expression.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非枚举和枚举在条件表达式中出现。
- en: Ambiguous virtual bases.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟基类不明确。
- en: Subscripting a `register` type array.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`register`类型数组进行下标操作。
- en: Using the address of a `register` type variable.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`register`类型变量的地址。
- en: A derived class' copy constructor does not initialize its base class. Note that
    (b)-(f) are C++ only.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类的复制构造函数未初始化其基类。注意（b）-（f）仅适用于C++。
- en: '`-Weffc++`:  It checks the violations of some guidelines suggested in *Effective
    and More Effective C++*, written by Scott Meyers.  These guidelines include the
    following:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Weffc++`：它检查了Scott Meyers所著的*Effective and More Effective C++*中建议的一些准则的违反。这些准则包括以下内容：'
- en: Define a copy constructor and an assignment operator for classes with dynamically
    allocated memory.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为具有动态分配内存的类定义复制构造函数和赋值运算符。
- en: Prefer initialization over assignment in constructors.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数中，优先使用初始化而不是赋值。
- en: Make destructors virtual in base classes.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类中使析构函数虚拟。
- en: Have the `=` operator return a reference to `*this`.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`=`运算符返回对`*this`的引用。
- en: Don't try to return a reference when you must return an object.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当必须返回对象时，不要尝试返回引用。
- en: Distinguish between prefix and postfix forms of increment and decrement operators.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分增量和减量运算符的前缀和后缀形式。
- en: Never overload `&&`, `||`, or `,`.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要重载`&&`、`||`或`,`。
- en: 'To explore these three options, let''s look at the following example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这三个选项，让我们看下面的例子：
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'First, let''s build this without any options:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们不使用任何选项来构建它：
- en: '[PRE42]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This can be built successfully, but if we run it, as expected, it will crash
    with a **segmentation fault** (**core dumped**) message.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以成功构建，但是如果我们运行它，预期会出现**段错误**（**核心已转储**）消息。
- en: 'Next, let''s add the `-Wall`,`-Weffc++`,and`-Wextra`options and rebuild it:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加`-Wall`、`-Weffc++`和`-Wextra`选项并重新构建它：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Both `-Wall` and `-Weffc++` give us the following message:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Wall`和`-Weffc++`都给出了以下消息：'
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, it's complaining that, in the `int & getVal()` function (line 9 of the
    `cpp` file), a reference to a local variable is returned. This will not work because
    once the program goes out of the function, `x` is garbage (The lifetime of `x` is
    only limited in the scope of the function). It does not make any sense to reference
    a dead variable.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它抱怨在`int & getVal()`函数（`cpp`文件的第9行）中返回了对局部变量的引用。这不起作用，因为一旦程序退出函数，`x`就是垃圾（`x`的生命周期仅限于函数的范围内）。引用一个已经失效的变量是没有意义的。
- en: '`-Wextra` gives us the following message:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Wextra`给出了以下消息：'
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding output shows that `*-*Wextra` not only gives us the warning from
    `-Wall` but also checks the six things we mentioned earlier. In this example,
    it warns us that there is a comparison between a pointer and integer zero in line
    16 of the code.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，`*-*Wextra`不仅给出了`-Wall`的警告，还检查了我们之前提到的六件事。在这个例子中，它警告我们代码的第16行存在指针和整数零的比较。
- en: Now that we know about how to use the static analysis options during compile
    time, we'll take a look at dynamic analysis by executing a program.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在编译时使用静态分析选项，我们将通过执行程序来了解动态分析。
- en: Dynamic analysis
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态分析
- en: '*Dynamic analysis* is a short version of *dynamic program analysis*, which
    analyzes the performance of a software program by executing it either on a real
    or virtual processor. Similar to static analysis, dynamic analysis can also be
    done automatically or manually. For instance, unit tests, integration tests, system
    tests, and acceptance tests are typically human-involved dynamic analysis processes.
    On the other hand, memory debugging, memory leak detection, and profiling tools
    such as IBM purify, Valgrind, and Clang sanitizers are automatic dynamic analysis
    tools. We will focus on automatic dynamic analysis tools in this subsection.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态分析*是*动态程序分析*的简称，它通过在真实或虚拟处理器上执行软件程序来分析软件程序的性能。与静态分析类似，动态分析也可以自动或手动完成。例如，单元测试、集成测试、系统测试和验收测试通常是人为参与的动态分析过程。另一方面，内存调试、内存泄漏检测和IBM
    purify、Valgrind和Clang sanitizers等性能分析工具是自动动态分析工具。在本小节中，我们将重点关注自动动态分析工具。'
- en: 'A  dynamic analysis process contains steps such as preparing the input data,
    launching a test program, gathering the necessary parameters, and analyzing its
    output. Roughly speaking, the mechanism of dynamic analysis tools is that they
    use code instrumentation and/or a simulation environment to perform checks on
    the analyzed code as it executes. We can interact with a program in the following
    ways:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析过程包括准备输入数据、启动测试程序、收集必要的参数和分析其输出等步骤。粗略地说，动态分析工具的机制是它们使用代码插装和/或模拟环境来对分析的代码进行检查。我们可以通过以下方式与程序交互：
- en: '**Source code instrumentation**: A special code segment is inserted into the
    original source code before compilation.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码插装：在编译之前，将特殊的代码段插入原始源代码中。
- en: '**Object code instrumentation**: A special binary code is added directly into
    the executable file.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标代码插装**：将特殊的二进制代码直接添加到可执行文件中。'
- en: '**Compilation stage instrumentation**: A checking code is added through special
    compiler switches.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译阶段插装**：通过特殊的编译器开关添加检查代码。'
- en: It doesn't change the source code. Instead, it uses special execution stage
    libraries to detect errors.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会改变源代码。相反，它使用特殊的执行阶段库来检测错误。
- en: 'Dynamic analysis has the following pros:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析有以下优点：
- en: There are no false positive or false negative results because an error will
    be detected that isn't predicted from a model.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有错误预测的模型，因此不会出现假阳性或假阴性结果。
- en: It does not need source code, which means the proprietary code can be tested
    by a third-party organization.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不需要源代码，这意味着专有代码可以由第三方组织进行测试。
- en: 'The cons of dynamic analysis are as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析的缺点如下：
- en: It only detects defects on the routes related to the input data. Other defects
    may not be found.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只能检测与输入数据相关的路径上的缺陷。其他缺陷可能无法被发现。
- en: It can only check one execution path at a time. To obtain a complete picture,
    we need to run the test as many times as possible. This requires a significant
    amount of computational resources.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它一次只能检查一个执行路径。为了获得完整的图片，我们需要尽可能多地运行测试。这需要大量的计算资源。
- en: It cannot check the correctness of the code. It is possible to get the correct
    result from the wrong operation.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它无法检查代码的正确性。可能会从错误的操作中得到正确的结果。
- en: Executing incorrect code on a real processor may have unanticipated results.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在真实处理器上执行不正确的代码可能会产生意想不到的结果。
- en: 'Now, let''s use Valgrind to find the memory leak and out-of-boundary problems
    given in the following example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Valgrind来找出以下示例中给出的内存泄漏和越界问题：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To use Valgrind for dynamic analysis, the following steps need to be performed:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Valgrind进行动态分析，需要执行以下步骤：
- en: 'First, we need to install `valgrind`. We can do this using the following command:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装`valgrind`。我们可以使用以下命令来完成：
- en: '[PRE47]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once it has been installed successfully, we can run `valgrind` by passing the
    executable as an argument, along with other parameters, as follows:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装成功后，我们可以通过传递可执行文件作为参数以及其他参数来运行`valgrind`，如下所示：
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, let''s build this program, as follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们构建这个程序，如下所示：
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we run `valgrind`, like so:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们运行`valgrind`，如下所示：
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we can check the contents of `log.txt`. The bold and italic lines
    indicate the memory leak''s location and size. By checking the address (`0x4844BFC`)
    and its corresponding function name (`main()`), we can see that this `malloc`
    is in the `main()` function:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以检查`log.txt`的内容。粗体和斜体行表示内存泄漏的位置和大小。通过检查地址（`0x4844BFC`）及其对应的函数名（`main()`），我们可以看到这个`malloc`在`main()`函数中：
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we can see that `malloc()` is called to allocate some memory at address
    `0x4844BFC`. The heap summary section indicates that we have 40 bytes of memory
    loss at `0x4844BFC`. Finally, the leak summary section shows that there is definitely
    one block of 40 bytes memory loss. By searching the address value of `0x4844BFC`
    in the `log.txt` file, we eventually figured out that there is no `free(p)` line
    being called in the original code. After uncommenting this line, we redo the `valgrind`
    analysis so that the leakage problem is now out of the report.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`malloc()`被调用来在地址`0x4844BFC`分配一些内存。堆摘要部分表明我们在`0x4844BFC`处有40字节的内存泄漏。最后，泄漏摘要部分显示肯定有一个40字节的内存泄漏。通过在`log.txt`文件中搜索`0x4844BFC`的地址值，我们最终发现原始代码中没有调用`free(p)`行。取消注释此行后，我们重新进行`valgrind`分析，以便泄漏问题现在已经不在报告中。
- en: In conclusion, with the help of static and dynamic analysis tools, the potential
    defects of a program can be greatly reduced automatically. However, to ensure
    the quality of software, humans must be in the loop for final tests and evaluations.
    Now, we're going to explore the unit testing, test-driven development, and behavior-driven
    development concepts in software engineering.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，借助静态和动态分析工具，程序的潜在缺陷可以自动大大减少。然而，为了确保软件的质量，人类必须参与最终的测试和评估。现在，我们将探讨软件工程中的单元测试、测试驱动开发和行为驱动开发概念。
- en: Exploring unit testing, TDD, and BDD
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索单元测试、TDD和BDD
- en: We learned about automatic static and dynamic program analysis in the previous
    section. This section will focus on human-involved (preparing test code) tests,
    which are another part of dynamic analysis. These are unit testing, test-driven
    development, and behavior-driven development.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解了自动静态和动态程序分析。本节将重点介绍人为参与（准备测试代码）的测试，这是动态分析的另一部分。这些是单元测试、测试驱动开发和行为驱动开发。
- en: Unit testing assumes that if we already have a single unit of code, then we
    need to write a test driver and prepare input data to check if its output is correct.
    After that, we perform integration tests to test multiple units together, and
    then the acceptance tests, which test the entire application. Since the integration
    and acceptance tests are more difficult to maintain and more project-related than
    unit tests, it is very challenging to cover them in this book. Those of you who
    are interested can find out more by going to [https://www.iso.org/standard/45142.html](https://www.iso.org/standard/45142.html).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试假设如果我们已经有了单个代码单元，那么我们需要编写一个测试驱动程序并准备输入数据来检查其输出是否正确。之后，我们进行集成测试来测试多个单元一起，然后进行验收测试，测试整个应用程序。由于集成和验收测试比单元测试更难维护且与项目更相关，因此在本书中很难覆盖它们。有兴趣的人可以通过访问[https://www.iso.org/standard/45142.html](https://www.iso.org/standard/45142.html)了解更多信息。
- en: In contrast to unit tests, TDD believes that we should have test code and data
    first, develop some code and make it pass quickly, and finally refactor until
    the customer is happy. On the other hand, BDD has the philosophy that we should
    not test the implementation of a program and instead test its desired behavior.
    To this end, BDD emphasizes that a communication platform and language among people
    involved in software production should be set up as well.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试相比，TDD认为我们应该先有测试代码和数据，快速开发一些代码并使其通过，最后进行重构，直到客户满意。另一方面，BDD认为我们不应该测试程序的实现，而是测试其期望的行为。为此，BDD强调应该建立一个软件生产相关人员之间的沟通平台和语言。
- en: We'll discuss each of these methodologies in detail in the following subsections.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下小节中详细讨论这些方法。
- en: Unit testing
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'A unit is an individual component in a larger or more complex application.
    Typically, a unit has its own user interface, such as a function, a class, or
    an entire module. Unit testing is a software testing method that''s used to determine
    whether a unit of code behaves as expected in terms of its design requirements.
    The main features of unit testing are as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 单元是更大或更复杂应用程序中的一个单独组件。通常，一个单元有自己的用户界面，例如函数、类或整个模块。单元测试是一种软件测试方法，用于确定代码单元是否按照其设计要求的预期行为。单元测试的主要特点如下：
- en: It is small and simple, quick to write and run, and, as a result, it finds problems
    in the early development cycle and hence the problems can be fixed easily.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它小巧简单，编写和运行速度快，因此可以在早期开发周期中发现问题，因此问题可以很容易地修复。
- en: Since it is isolated from dependencies, each test case can be run in parallel.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它与依赖项隔离，因此每个测试用例都可以并行运行。
- en: Unit test drivers help us understand the unit interface.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试驱动程序帮助我们理解单元接口。
- en: It greatly helps integration and acceptance tests when tested units are integrated
    later.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试单元后集成时，它极大地帮助集成和验收测试。
- en: It is normally prepared and performed by developers.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常由开发人员准备和执行。
- en: 'While we can write a unit test package from scratch, there are a lot of **Unit
    Test Frameworks** (**UTFs**) already being developed in the community. Boost.Test,
    CppUnit, GoogleTest, Unit++, and CxxTest are the most popular ones. These UTFs
    typically offer the following features:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以从头开始编写一个单元测试包，但社区中已经开发了许多**单元测试框架**（**UTFs**）。Boost.Test、CppUnit、GoogleTest、Unit++和CxxTest是最受欢迎的。这些UTF通常提供以下功能：
- en: They only require a minimal amount of work for setting up a new test.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需要最少的工作来设置一个新的测试。
- en: They depend on standard libraries and supports cross-platform, which means they
    are easy to port and modify.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们依赖于标准库并支持跨平台，这意味着它们易于移植和修改。
- en: They support test fixtures, which allow us to reuse the same configuration for
    objects for several different tests.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持测试固定装置，允许我们为多个不同的测试重用相同的对象配置。
- en: They handle exceptions and crashes well. This means that a UTF can report exceptions
    but not crashes.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们很好地处理异常和崩溃。这意味着UTF可以报告异常，但不能崩溃。
- en: They have good assert functionalities. Whenever an assertion fails, its source
    code location and the values of the variables should be printed.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有良好的断言功能。每当断言失败时，应打印其源代码位置和变量的值。
- en: They support different outputs and these outputs can be conveniently analyzed
    either by humans or other tools.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持不同的输出，这些输出可以方便地由人类或其他工具进行分析。
- en: They support test suites, and each suite may contain several test cases.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持测试套件，每个套件可能包含多个测试用例。
- en: 'Now, let''s take a look at an example of Boost UTF (since v1.59.0).  It supports
    three different usage variants: the single-header only variant, the static library
    variant, and the shared library variant. It includes four types of test cases:
    test cases without parameters, data-driven test cases, template test cases, and
    parameterized test cases.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个Boost UTF的例子（自v1.59.0起）。它支持三种不同的使用变体：仅单头文件变体、静态库变体和共享库变体。它包括四种类型的测试用例：无参数的测试用例、数据驱动的测试用例、模板测试用例和参数化的测试用例。
- en: 'It also has seven types of check tools: `BOOST_TEST()`, `BOOST_CHECK()`, `BOOST_REQUIRE(`),
    `BOOST_ERROR()`, `BOOST_FAIL()`, `BOOST_CHECK_MESSAGE( )`, and `BOOST_CHECK_EQUAL()`.
    It supports fixtures and controls the test output in many ways as well. When writing
    a test module, we need to follow these steps:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有七种检查工具：`BOOST_TEST()`、`BOOST_CHECK()`、`BOOST_REQUIRE(`)、`BOOST_ERROR()`、`BOOST_FAIL()`、`BOOST_CHECK_MESSAGE(
    )`和`BOOST_CHECK_EQUAL()`。它还支持固定装置，并以多种方式控制测试输出。编写测试模块时，我们需要遵循以下步骤：
- en: Define the name of our test program. This will be used in output messages.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的测试程序的名称。这将在输出消息中使用。
- en: 'Choose a usage variant: header-only, link with a static, or as a shared library.'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个使用变体：仅头文件、链接静态文件或作为共享库。
- en: Choose and add a test case to a test suite.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择并添加一个测试用例到测试套件中。
- en: Perform correctness checks on the tested code.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对被测试代码执行正确性检查。
- en: Initialize the code under test before each test case.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个测试用例之前初始化被测试的代码。
- en: Customize the ways in which test failures are reported.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义测试失败报告的方式。
- en: Control the runtime behavior of the built test module, which is also called
    runtime configuration.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制构建测试模块的运行时行为，也称为运行时配置。
- en: 'For example, the following example  covers *steps 1-4*. If you are interested,
    you can get examples of *steps 5-7* at [https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下示例涵盖了*步骤1-4*。如果您感兴趣，可以在[https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html)获取*步骤5-7*的示例：
- en: '[PRE52]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To build this, we may need to install boost, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个，我们可能需要安装boost，如下所示：
- en: '[PRE53]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we can build and run it, as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以构建并运行它，如下所示：
- en: '[PRE54]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding code results in the following output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we can see that there are failures in `test_case1`  and `test_case3`.
    In particular, in `test_case1`, the value of `x` is not equal to `b`, and obviously
    a false check cannot pass the test in `test_case3`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`test_case1`和`test_case3`中存在失败。特别是在`test_case1`中，`x`的值不等于`b`，显然在`test_case3`中，一个错误的检查无法通过测试。
- en: TDD
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD
- en: 'As shown in the following diagram, a TDD process starts by writing failing
    test code and then adds/modifies the code to let the test pass. After that, we
    refactorize the test plan and code until all the requirements are satisfied [16,17].
    Let''s have a look at the following diagram:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，TDD流程从编写失败的测试代码开始，然后添加/修改代码使测试通过。之后，我们对测试计划和代码进行重构，直到满足所有要求[16,17]。让我们看看下面的图表：
- en: '![](img/48d849fe-1729-4c98-8497-c0500b7f3080.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48d849fe-1729-4c98-8497-c0500b7f3080.png)'
- en: '*Step 1* is to write a failing test. Instead of developing code first, TDD
    starts to write test code initially. Because we do not have code yet, we know
    that, if we run the test, it will fail. During this stage, the test data format
    and interface is defined, and the code implementation details are imagined.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*是编写一个失败的测试。TDD不是先开发代码，而是开始编写测试代码。因为我们还没有代码，所以我们知道，如果我们运行测试，它会失败。在这个阶段，定义测试数据格式和接口，并想象代码实现细节。'
- en: The goal of *step 2* is to make the test pass as quickly as possible with minimal
    development effort. We don't want to implement everything perfectly; we only want
    it to pass the test. Once it goes green, we will have something to show and tell
    to the customer, at which point the customer may refine the requirement after
    seeing the initial product. Then, we move on to the next phase.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*的目标是尽快使测试通过，开发工作量最小。我们不想完美地实现一切；我们只希望它通过测试。一旦测试通过，我们就有东西可以展示给客户，并告诉客户，此时客户可能在看到初始产品后完善需求。然后，我们进入下一个阶段。'
- en: The third phase is refactoring. During this stage, we may go in, look at, and
    see what we would like to change and how to change it.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段是重构。在这个阶段，我们可能会进去，看看，看看我们想要改变什么以及如何改变它。
- en: 'To traditional developers, the most difficult thing about TDD is the mindset
    change from the coding -> testing pattern to the testing -> coding pattern. To
    get a vague idea of a test suite, J. Hartikainen suggested that a developer considers
    the following five steps[18] to start:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统的开发人员来说，TDD最困难的地方是从编码->测试模式转变为测试->编码模式的心态变化。为了对测试套件有一个模糊的概念，J. Hartikainen建议开发人员考虑以下五个步骤[18]来开始：
- en: Decide the inputs and outputs first.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先确定输入和输出。
- en: Choose class/function signatures.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择类/函数签名。
- en: Decide only one tiny aspect of the functionality to test.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只决定功能的一个小方面进行测试。
- en: Implement the test.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现测试。
- en: Implement the code.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现代码。
- en: Once we've finished this iteration, we can gradually refactor it until the overall
    comprehensive goal is achieved.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个迭代，我们可以逐渐重构它，直到实现整体的综合目标。
- en: Example of TDD
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的例子
- en: Next, we will demonstrate the TDD process through the implementation of a case
    study. In this study, we will develop a Mat class to perform 2D matrix algebra,
    just like we do in the Matlab. This is a class template that can hold an m-by-n
    matrix for all data types. The matrix algebra includes adding, subtracting, multiplying,
    and dividing matrices, and it also has element operation abilities.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过实施一个案例研究来演示TDD过程。在这个研究中，我们将开发一个Mat类来执行2D矩阵代数，就像我们在Matlab中所做的那样。这是一个类模板，可以容纳所有数据类型的m×n矩阵。矩阵代数包括矩阵的加法、减法、乘法和除法，它还具有元素操作能力。
- en: Let's get started.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Step 1 – writing a failing test
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤1 - 编写一个失败的测试
- en: 'To begin, we will only need the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只需要以下内容：
- en: Create a `Mat` object from a given a number of rows and cols (the default should
    be 0-by-0, which is an empty matrix).
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从给定的行数和列数创建一个`Mat`对象（默认应为0×0，即空矩阵）。
- en: Print its elements row by row.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按行打印其元素。
- en: Get the matrix size from `rows()` and `cols()`.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`rows()`和`cols()`获取矩阵大小。
- en: 'Based on these requirements, we can have failing unit testing code to boost
    UTF, as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些要求，我们可以有失败的单元测试代码来提升UTF，如下所示：
- en: '[PRE56]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that our testing code is ready, we are ready to develop the code.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试代码准备好了，我们准备开发代码。
- en: Step 2 – developing code to let the test pass
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤2 - 开发代码使测试通过
- en: 'One way to implement a minimal code segment is to pass the preceding test,
    as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个最小的代码段来通过前面的测试，如下所示：
- en: '[PRE57]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once we have the preceding header file, we can develop its corresponding `cpp`
    file, as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了前面的头文件，我们就可以开发其相应的`cpp`文件，如下所示：
- en: '[PRE58]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s say we build and execute it using g++, which supports `-std=c++11` or
    higher:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用支持`-std=c++11`或更高版本的g++进行构建和执行：
- en: '[PRE59]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This will result in the following output:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE60]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In `test_case1`, we created three matrices and tested the `rows()`, `cols()`,
    and `print()` functions. The first one is a 2x3 `int` type matrix. Since it is
    not initialized, the values of its elements are unpredictable, which is why we
    can see these random numbers from `print()`. We also passed the `rows()` and `cols()`
    test at this point (no errors from the two `BOOST_TEST() calls`). The second one
    is an empty float type matrix; its `print()` function gives nothing, and both
    its `cols()` and `rows()` are zeros. Finally, the third one is a 1x10 `char` type
    uninitialized matrix. Again, all the outputs of the three functions are as expected.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test_case1`中，我们创建了三个矩阵并测试了`rows()`，`cols()`和`print()`函数。第一个是一个2x3的`int`类型矩阵。由于它没有初始化，其元素的值是不可预测的，这就是为什么我们可以从`print()`中看到这些随机数。在这一点上，我们也通过了`rows()`和`cols()`的测试（两个`BOOST_TEST()`调用没有错误）。第二个是一个空的浮点类型矩阵；它的`print()`函数什么也不输出，它的`cols()`和`rows()`都是零。最后，第三个是一个1x10的`char`类型未初始化矩阵。同样，这三个函数的所有输出都是预期的。
- en: Step 3 – refactoring
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤3 - 重构
- en: 'So far, so good – we passed the test!  However, after showing the preceding
    result to our customer, he/she may ask us to add two more interfaces, such as
    the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利 - 我们通过了测试！然而，在向客户展示前面的结果后，他/她可能会要求我们添加另外两个接口，如下所示：
- en: Create an m x n matrix with a given initial value for all elements.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有元素创建一个给定初始值的m x n矩阵。
- en: Add `numel()` to return the total number of elements of the matrix.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`numel()`以返回矩阵的总元素数。
- en: Add `empty()`, which returns true if the matrix either has zero rows or zero
    columns and false otherwise.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`empty()`，如果矩阵既有零行又有零列，则返回true，否则返回false。
- en: 'Once we''ve added the second test case to our test suite,  the overall refactorized
    test code will be as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们向测试套件添加了第二个测试用例，整体重构后的测试代码将如下所示：
- en: '[PRE61]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The next step is to modify the code to pass this new test plan. For brevity,
    we won''t print the `ch13_tdd_v2.h` and `ch13_tdd_v2.cpp` files here. You can
    download them from this book''s [GitHub](https://github.com/PacktPublishing/Expert-CPP) repository. After
    building and executing `ch13_tdd_Boost_UTF2.cpp`, we get the following output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修改代码以通过这个新的测试计划。为了简洁起见，我们不会在这里打印`ch13_tdd_v2.h`和`ch13_tdd_v2.cpp`文件。您可以从本书的[GitHub](https://github.com/PacktPublishing/Expert-CPP)存储库中下载它们。构建并执行`ch13_tdd_Boost_UTF2.cpp`后，我们得到以下输出：
- en: '[PRE62]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the first output, since we just defined a 2x3 integer matrix and did not
    initialize it in `test_case1`, the undefined behavior – that is, six random numbers
    – is printed out. The second output comes from `test_case2`, where all six elements
    of `x` are initialized to `10`. After we've done a show and tell of the preceding
    result, our customer may ask us to add other new features or modify the currently
    existing ones. But, after a few iterations, eventually, we will reach the *happy
    point* and stop factorizing.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个输出中，由于我们只定义了一个2x3的整数矩阵，并且没有在`test_case1`中初始化它，所以会打印出未定义的行为 - 也就是六个随机数。第二个输出来自`test_case2`，其中`x`的所有六个元素都初始化为`10`。在我们展示了前面的结果之后，我们的客户可能会要求我们添加其他新功能或修改当前存在的功能。但是，经过几次迭代，最终我们会达到*快乐点*并停止因式分解。
- en: Now that we've learned about TDD, we will discuss BDD.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了TDD，我们将讨论BDD。
- en: BDD
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BDD
- en: The most difficult part of software development is communicating with business
    participants, developers, and the quality analysis team. A project can easily
    exceed its budget, miss deadlines, or fail completely because of misunderstood
    or vague requirements, technical arguments, and slow feedback cycles.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发最困难的部分是与业务参与者、开发人员和质量分析团队进行沟通。由于误解或模糊的需求、技术争论和缓慢的反馈周期，项目很容易超出预算、错过截止日期或完全失败。
- en: (BDD) [20] is an agile development process with a set of practices that aim
    to reduce communication gaps/barriers and other wasteful activities. It also encourages
    team members to continuously communicate with real-world examples during the production
    life cycle.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: (BDD) [20]是一种敏捷开发过程，具有一套旨在减少沟通障碍和其他浪费活动的实践。它还鼓励团队成员在生产生命周期中不断地使用真实世界的例子进行沟通。
- en: 'BDD contains two main parts: deliberate discovery and TDD. To let people in
    different organizations and teams understand the right behavior of the developed
    software,  the deliberate discovery phase introduces an *example mapping* technique
    to make people in different roles have conversations through concrete examples.
    These examples will become automated tests and living documentation of how the
    system behaves later. In its TDD phase, BDD specifies that the tests for any software
    unit should be specified in terms of the desired behavior of the unit.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: BDD包含两个主要部分：故意发现和TDD。为了让不同组织和团队的人了解开发软件的正确行为，故意发现阶段引入了*示例映射*技术，通过具体的例子让不同角色的人进行对话。这些例子将成为系统行为的自动化测试和实时文档。在其TDD阶段，BDD规定任何软件单元的测试应该以该单元的期望行为为基础。
- en: 'There are several BDD framework tools (JBehave, RBehave, Fitnesse, Cucumber
    [21], and so on) for different platforms and programming languages. Generally
    speaking, these frameworks perform the following steps:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种BDD框架工具（JBehave、RBehave、Fitnesse、Cucumber [21]等）适用于不同的平台和编程语言。一般来说，这些框架执行以下步骤：
- en: Read a specification format document that's been prepared by a business analyst
    during the deliberate discovery phase.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在故意发现阶段，阅读由业务分析师准备的规范格式文档。
- en: Transform the document into meaningful clauses. Each individual clause is capable
    of being set into test cases for QA. Developers can implement source code from
    the clause as well.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文档转换为有意义的条款。每个单独的条款都可以被设置为质量保证的测试用例。开发人员也可以根据条款实现源代码。
- en: Execute the test for each clause scenario automatically.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动执行每个条款场景的测试。
- en: 'In summary, we have learned about the strategies regarding what, when, and
    how, and a testing process should be involved in an application development pipeline. As
    shown in the following diagram, the traditional V-shape[2] model emphasizes the
    pattern of requirement -> design -> coding -> testing. TDD believes a development
    process should be driven by test, while BDD adds communication between people
    from different backgrounds and roles into the TDD framework and focuses on behavior
    testing:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经了解了关于应用开发流程中什么、何时以及如何进行测试的策略。如下图所示，传统的V形[2]模型强调需求->设计->编码->测试的模式。TDD认为开发过程应该由测试驱动，而BDD将来自不同背景和角色的人之间的沟通加入到TDD框架中，并侧重于行为测试：
- en: '![](img/fcf1a324-da5d-4573-9146-c831408113a7.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcf1a324-da5d-4573-9146-c831408113a7.png)'
- en: Moreover, unit testing emphasizes testing individual components when coding
    is complete. TDD focuses more on how to write tests before writing code, and then
    add/modify code through next-level test plans. BDD encourages collaborations between
    customers, business analysts, developers, and quality assurance analysts. Although
    we can use each one individually, we really should combine them for the best results
    in this agile software development era.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单元测试强调在编码完成后测试单个组件。TDD更注重如何在编写代码之前编写测试，然后通过下一级测试计划添加/修改代码。BDD鼓励客户、业务分析师、开发人员和质量保证分析师之间的合作。虽然我们可以单独使用每一个，但在这个敏捷软件开发时代，我们真的应该将它们结合起来以获得最佳结果。
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we briefly introduced testing and debugging-related topics
    in the software development process. Testing finds problems, and root cause analysis
    helps in locating a problem at the macro level. However, good programming practices
    can prevent software defects in the early stages. Additionally, the command-line
    interface debugging tool known as GDB can help us set breakpoints and execute
    a program line by line while printing the values of variables during the runtime
    of a program.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了软件开发过程中与测试和调试相关的主题。测试可以发现问题，根本原因分析有助于在宏观层面上定位问题。然而，良好的编程实践可以在早期阶段防止软件缺陷。此外，命令行界面调试工具GDB可以帮助我们设置断点，并在程序运行时逐行执行程序并打印变量的值。
- en: We also discussed the automatic analyzing tools and human-involved testing processes. Static
    analysis evaluates the performance of a program without executing it. On the other
    hand, dynamic analysis tools can find defects by executing the program.  Finally,
    we learned about the strategies of what, when, and how, a testing process should
    be involved in a software development pipeline. Unit testing emphasizes testing
    individual components when coding is complete. TDD focuses more on how to write
    tests before developing code and then reiterates this process through a next-level
    test plan. BDD encourages collaborations between customers, business analysts,
    developers, and quality assurance analysts.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了自动分析工具和人工测试过程。静态分析评估程序的性能而不执行它。另一方面，动态分析工具可以通过执行程序来发现缺陷。最后，我们了解了测试过程在软件开发流程中应该如何、何时以及如何参与的策略。单元测试强调在编码完成后测试单个组件。TDD更注重如何在开发代码之前编写测试，然后通过下一级测试计划重复这个过程。BDD鼓励客户、业务分析师、开发人员和质量保证分析师之间的合作。
- en: In the next chapter, we will learn how to use Qt to create **Graphic User Interface**
    (**GUI**) programs for cross-platform applications that run on Linux, Windows,
    iOS, and Android systems. First, we will dive into the fundamental concepts of
    cross-platform GUI programming. Then we will introduce an overview of Qt and its
    widgets. Finally, using a case study example, we will learn how to design and
    implement a network application using Qt.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Qt创建跨平台应用程序的图形用户界面（GUI）程序，这些程序可以在Linux、Windows、iOS和Android系统上运行。首先，我们将深入了解跨平台GUI编程的基本概念。然后我们将介绍Qt及其小部件的概述。最后，通过一个案例研究示例，我们将学习如何使用Qt设计和实现网络应用程序。
- en: Further reading
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: J.  Rooney and L. Vanden Heuvel, *[Root Cause Analysis For Beginners](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.618.8544&rep=rep1&type=pdf),*  Quality
    Progress,  July 2004, p.45-53.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: J. Rooney和L. Vanden Heuvel，《初学者的根本原因分析》，Quality Progress，2004年7月，第45-53页。
- en: T. Kataoka, K. Furuto and T. Matsumoto, *[The Analyzing Method of Root Causes
    for Software Problem](https://global-sei.com/technology/tr/bn73/pdf/73-13.pdf)s*,
    SEI Tech. Rev., no. 73, p. 81, 2011.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T. Kataoka，K. Furuto和T. Matsumoto，《软件问题根本原因分析方法》，SEI Tech. Rev.，第73期，2011年第81页。
- en: K. A. Briski, et al. *[Minimizing code defects to improve software quality and
    lower development costs](ftp://ftp.software.ibm.com/software/rational/info/do-more/RAW14109USEN.pdf),*
    IBM Rational Software Analyzer and IBM Rational PurifyPlus software.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K. A. Briski等，《减少代码缺陷以提高软件质量和降低开发成本》，IBM Rational Software Analyzer和IBM Rational
    PurifyPlus软件。
- en: '[https://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch](https://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch).'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch](https://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch)。'
- en: B. Stroustrup and  H. Sutter,  *C++ Core Guidelines*: [https://isocpp.github.io/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines).
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B. Stroustrup和H. Sutter，《C++核心指南》：[https://isocpp.github.io/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines)。
- en: '[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/).'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)。'
- en: '[https://www.fayewilliams.com/2014/02/21/debugging-for-beginners/](https://www.fayewilliams.com/2014/02/21/debugging-for-beginners/).'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.fayewilliams.com/2014/02/21/debugging-for-beginners/](https://www.fayewilliams.com/2014/02/21/debugging-for-beginners/)。'
- en: '[https://www.perforce.com/blog/qac/what-static-code-analysis](https://www.perforce.com/blog/qac/what-static-code-analysis).'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.perforce.com/blog/qac/what-static-code-analysis](https://www.perforce.com/blog/qac/what-static-code-analysis)。'
- en: '[https://linux.die.net/man/1/g++](https://linux.die.net/man/1/g++).'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linux.die.net/man/1/g++](https://linux.die.net/man/1/g++)。'
- en: '[https://www.embedded.com/static-vs-dynamic-analysis-for-secure-code-development-part-2/](https://www.embedded.com/static-vs-dynamic-analysis-for-secure-code-development-part-2/).'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.embedded.com/static-vs-dynamic-analysis-for-secure-code-development-part-2/](https://www.embedded.com/static-vs-dynamic-analysis-for-secure-code-development-part-2/)。'
- en: ISO/IEC/IEEE 29119-1:2013 [*SOFTWARE AND SYSTEMS ENGINEERING – SOFTWARE TESTING*](https://www.iso.org/standard/45142.html).
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO/IEC/IEEE 29119-1:2013《软件和系统工程-软件测试》[https://www.iso.org/standard/45142.html](https://www.iso.org/standard/45142.html)。
- en: '[http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle](http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle).'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle](http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle)。'
- en: '[https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html).'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html)。'
- en: K. Beck, *[Test-Driven Development by Example](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530),*
    published by Addison Wesley, ISBN 978-0321146533.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K. Beck，《通过示例进行测试驱动开发》, Addison Wesley出版，ISBN 978-0321146533。
- en: H. Erdogmus,  T. Morisio, [*On the Effectiveness of Test-first Approach to Programming*](https://ieeexplore.ieee.org/document/1423994),
    Proc. of the IEEE Trans. on Software Engineering, 31(1). January 2005.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H. Erdogmus,  T. Morisio, [*关于编程的测试优先方法的有效性*](https://ieeexplore.ieee.org/document/1423994),
    IEEE软件工程交易会议录, 31(1). 2005年1月。
- en: '[https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd](https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd).'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd](https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd).'
- en: '[https://cucumber.io/blog/intro-to-bdd-and-tdd/](https://cucumber.io/blog/intro-to-bdd-and-tdd/).'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cucumber.io/blog/intro-to-bdd-and-tdd/](https://cucumber.io/blog/intro-to-bdd-and-tdd/).'
- en: D. North,  Introducing BDD,  [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)  (March
    2006).
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D. North,  Introducing BDD,  [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)  (2006年3月)。
- en: D. North, E. Keogh, et. al, "[jbehave.org/team-list](https://jbehave.org/)", 
    May 2019.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D. North, E. Keogh, et. al, "[jbehave.org/team-list](https://jbehave.org/)", 
    May 2019.
- en: 'Apart from these, you can have a look at the following sources (these are not
    directly mentioned in this chapter):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你还可以查看以下来源（这些在本章中没有直接提到）：
- en: 'B. Stroustrup and H. Sutter, *C++ Core Guidelines*: [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)[.](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'B. Stroustrup 和 H. Sutter, *C++ 核心指南*: [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)[.](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)'
- en: 'G. Rozental and R. Enficiaud, *Boost.Test*: [https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'G. Rozental 和 R. Enficiaud, *Boost.Test*: [https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html)'
- en: D. North,* Introducing BDD*: [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D. North,* Introducing BDD*: [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)
- en: Exercises and questions
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和问题
- en: Using `gdb` function breakpoints, conditional breakpoints and the `watchpoint`,
    `continue`, and `finish` commands, debug `ch13_gdb_2.cpp`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `gdb` 函数断点、条件断点和 `watchpoint`、`continue`、`finish` 命令，调试 `ch13_gdb_2.cpp`。
- en: Use `g++ -c -Wall -Weffc++ -Wextra  x.cpp -o x.out` to build out `cpp files
    ch13_rca*.cpp`. What do you see from their warning outputs?
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `g++ -c -Wall -Weffc++ -Wextra  x.cpp -o x.out` 来构建 `cpp` 文件 `ch13_rca*.cpp`。你从他们的警告输出中看到了什么？
- en: Why does static analysis produce false alarms, but dynamic analysis does not?
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么静态分析会产生误报，而动态分析不会呢？
- en: 'Download `ch13_tdd_v2.h/.cpp`  and perform next phase refactoring. In this
    phase, we will add a copy constructor, assignment operator, and element-wise operation
    operators such as `+`, `-`, `*`, `/`, and more. More specifically, we need to
    do the following things:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 `ch13_tdd_v2.h/.cpp` 并执行下一阶段的重构。在这个阶段，我们将添加一个拷贝构造函数、赋值运算符，以及诸如 `+`、`-`、`*`、`/`
    等的逐元素操作运算符。更具体地，我们需要做以下事情：
- en: Add the third test case to our test suite, that is, `ch13_tdd_Boost_UTF2.cpp`.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第三个测试用例添加到我们的测试套件中，即 `ch13_tdd_Boost_UTF2.cpp`。
- en: Add the implementations of these functions to files; for example, `ch13_tdd_v2.h/.cpp`.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些函数的实现添加到文件中；例如，`ch13_tdd_v2.h/.cpp`。
- en: Run the test suite to test them.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试套件来测试它们。
