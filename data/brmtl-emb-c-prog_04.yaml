- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Developing the Linker Script and Startup File
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发链接脚本和启动文件
- en: 'In this chapter, we undertake an in-depth exploration of the core components
    of embedded **bare-metal programming**, focusing on three critical areas: the
    microcontroller memory model, the writing of the linker script, and the startup
    file.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了嵌入式**裸机编程**的核心组件，重点关注三个关键领域：微控制器内存模型、链接脚本的编写和启动文件。
- en: First, we’ll explore the microcontroller memory model to understand how memory
    is organized and utilized. This knowledge is important for accurately allocating
    program code and data sections within the microcontroller memory. Next, we’ll
    go through the intricacies of writing linker scripts. These scripts are essential
    for correctly mapping our program to the appropriate sections of the microcontroller’s
    memory, ensuring that the executable runs as intended.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨微控制器内存模型，以了解内存是如何组织和使用的。这些知识对于在微控制器内存中准确分配程序代码和数据部分非常重要。接下来，我们将深入了解编写链接脚本的技术细节。这些脚本对于正确地将我们的程序映射到微控制器内存的适当部分至关重要，确保可执行程序按预期运行。
- en: Finally, we will learn about the startup file and then proceed to write our
    own, focusing on initializing the vector table and configuring `Reset_Handler`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习启动文件，然后编写我们自己的启动文件，重点关注初始化向量表和配置`Reset_Handler`。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding the memory model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内存模型
- en: The linker scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接脚本
- en: Writing the linker script and startup file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写链接脚本和启动文件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到：[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Understanding the STM32 memory model
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解STM32内存模型
- en: 'While the STM32 memory map consists of various memory areas, our primary focus
    in developing the linker script and startup file revolves around two critical
    areas: **flash memory** and **static random access memory** (**SRAM**). These
    areas are of utmost importance because they are directly involved in program storage.
    In the initial parts of this section, we will learn about the characteristics
    of these memory areas and the distinct roles they play.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然STM32内存映射包括多个内存区域，但我们在开发链接脚本和启动文件时的主要焦点是两个关键区域：**闪存**和**静态随机存取存储器**（**SRAM**）。这些区域至关重要，因为它们直接参与程序存储。在本节的开头部分，我们将了解这些内存区域的特点以及它们所扮演的独特角色。
- en: '*Figure 4**.1* shows a section of the stm32f411 memory map, highlighting the
    flash memory and SRAM.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4**.1*显示了stm32f411内存映射的一部分，突出显示了闪存和SRAM。'
- en: '![Figure 4.1: A section of the STM32F11 memory map, highlighting the flash
    memory and SRAM areas](img/B21914_04_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：STM32F11内存映射的一部分，突出显示闪存和SRAM区域](img/B21914_04_1.jpg)'
- en: 'Figure 4.1: A section of the STM32F11 memory map, highlighting the flash memory
    and SRAM areas'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：STM32F11内存映射的一部分，突出显示闪存和SRAM区域
- en: Let’s start with flash memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从闪存内存开始。
- en: Flash memory
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闪存内存
- en: One of the primary advantages of flash memory is its non-volatile nature. This
    means that data stored in flash memory remains intact even when the power supply
    is disconnected. In STM32 microcontrollers (as well as other microcontrollers),
    flash memory is typically where the executable code is stored and is read-only
    during normal operation. Flash memory starts at the `0x08000000` address. However,
    its size varies depending on the specific STM32 microcontroller model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存内存的一个主要优点是其非易失性。这意味着即使断开电源，存储在闪存内存中的数据也会保持完整。在STM32微控制器（以及其他微控制器）中，闪存内存通常是存储可执行代码的地方，在正常操作期间是只读的。闪存内存从`0x08000000`地址开始。然而，其大小取决于具体的STM32微控制器型号。
- en: STM32 microcontrollers come in various series and models, offering a range of
    flash memory densities to accommodate different application requirements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: STM32微控制器有多种系列和型号，提供不同密度的闪存内存，以满足不同的应用需求。
- en: What is memory density?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是内存密度？
- en: '**Memory density** refers to the concentration of memory storage within a given
    physical space or component. Memory density is often expressed in terms of bits
    or bytes stored per unit of physical area, such as bits per square millimeter
    or bytes per square centimeter. It measures how densely or compactly data can
    be stored within that space. Higher memory density means that we can store more
    data than we can in a smaller physical space.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存密度**指的是在给定的物理空间或组件内存储内存的集中度。内存密度通常以每单位物理面积存储的位数或字节来表示，例如每平方毫米的位数或每平方厘米的字节。它衡量了数据在该空间内可以存储的密集程度或紧凑程度。更高的内存密度意味着我们可以在较小的物理空间内存储更多的数据。'
- en: Memory size, on the other hand, refers to the total amount of memory (storage
    capacity) available in a given storage device. It is typically measured in units
    such as bytes, **kilobytes** (**KB**), **megabytes** (**MB**), **gigabytes** (**GB**),
    etc.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，内存大小指的是给定存储设备中可用的总内存（存储容量）。它通常以字节、**千字节（KB**）、**兆字节（MB**）、**吉字节（GB**）等单位来衡量。
- en: Now, let’s talk about some operational nuances of flash memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈闪存的某些操作细节。
- en: Flash memory, including STM32 flash memory, has a limited number of program
    and erase cycles. Each time we write (program) or erase, it consumes one of these
    cycles. It is important to consider these limitations when designing applications
    that frequently write to or erase data from flash memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存，包括STM32闪存，具有有限的程序和擦除周期。每次我们写入（编程）或擦除时，都会消耗这些周期中的一个。在设计频繁写入或从闪存中擦除数据的应用程序时，考虑这些限制非常重要。
- en: STM32 microcontrollers are known for their low power consumption, and this extends
    to their flash memory operations. Efficient power management ensures that the
    microcontroller can operate on minimal power while reading from or writing to
    flash memory, making STM32 devices suitable for battery-powered applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: STM32微控制器以其低功耗而闻名，这种特性也扩展到了它们的闪存操作。高效的电源管理确保微控制器在读取或写入闪存时能够以最小的功耗运行，这使得STM32设备非常适合电池供电的应用。
- en: To ensure data integrity, STM32 flash memory often includes built-in error correction
    mechanisms. These mechanisms help identify and correct errors that may occur during
    data storage and retrieval, enhancing the reliability of the stored firmware.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保数据完整性，STM32闪存通常包括内置的错误纠正机制。这些机制有助于识别和纠正数据存储和检索过程中可能发生的错误，从而提高了存储固件的可靠性。
- en: 'The following are some key attributes of the STM32 flash memory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些STM32闪存的关键属性：
- en: '**Read-only nature**: Primarily used for storing program code'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只读特性**：主要用于存储程序代码'
- en: '`0x08000000`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x08000000`'
- en: '**Variable size**: Dependent on the specific STM32 microcontroller model'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量大小**：取决于具体的STM32微控制器型号'
- en: '`0x08000004`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x08000004`'
- en: Let’s take a look at the other primary memory areas relevant to writing our
    linker script and startup file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看与编写链接脚本和启动文件相关的其他主要内存区域。
- en: SRAM
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SRAM
- en: '**SRAM** is a type of volatile memory, meaning it loses its contents when the
    power supply is disconnected. It is used in STM32 microcontrollers for temporary
    data storage during program execution. Unlike flash memory, which is used for
    long-term storage of program code, SRAM is designed for high-speed access and
    low latency, making it ideal for storing variables, intermediate data, and managing
    the stack during runtime.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**SRAM**是一种易失性内存，意味着当电源断开时，它会丢失其内容。在STM32微控制器中，SRAM用于程序执行期间的临时数据存储。与用于长期存储程序代码的闪存不同，SRAM旨在实现高速访问和低延迟，使其非常适合存储变量、中间数据和运行时管理堆栈。'
- en: Like flash memory, the STM32 microcontrollers feature varying sizes of SRAM,
    tailored to the needs of different applications. The size of the SRAM determines
    the amount of runtime data that can be handled and affects the overall performance
    of the microcontroller in handling complex tasks or multitasking. The SRAM in
    STM32 microcontrollers starts at the `0x20000000` address. Like flash memory,
    its size varies depending on the specific STM32 microcontroller model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与闪存一样，STM32微控制器具有不同大小的SRAM，以满足不同应用的需求。SRAM的大小决定了可以处理的运行时数据量，并影响微控制器在处理复杂任务或多任务处理时的整体性能。STM32微控制器中的SRAM从`0x20000000`地址开始。与闪存一样，其大小取决于具体的STM32微控制器型号。
- en: 'The following are the key attributes of the STM32 SRAM:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些STM32 SRAM的关键属性：
- en: '**Read and write**: Variables and the stack are stored here'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读写**：变量和堆栈存储在这里'
- en: '`0x20000000`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x20000000`'
- en: '**Variable size**: Dependent on the specific STM32 microcontroller model'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量大小**：取决于特定的STM32微控制器型号'
- en: Before moving on to introduce the linker script, let’s touch on one other memory
    area that is not relevant to the linker script, but is still relevant to our understanding
    of the memory layout of our microcontroller.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍链接脚本之前，让我们简要提及一个与链接脚本不相关，但对我们理解微控制器内存布局仍有意义的内存区域。
- en: Peripheral memory
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外围内存
- en: '**Peripheral memory** is dedicated to managing and interfacing with the microcontroller’s
    onboard peripherals. These peripherals include components such as timers, communication
    interfaces (UART, SPI, I2C), and **analog-to-digital converters** (**ADCs**).
    Peripheral memory is made up of registers that are used to configure and manage
    these peripherals.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**外围内存**专门用于管理和与微控制器板载外围设备接口。这些外围设备包括定时器、通信接口（UART、SPI、I2C）和**模数转换器**（**ADCs**）。外围内存由用于配置和管理这些外围设备的寄存器组成。'
- en: An important aspect of microcontroller architecture is the use of **memory-mapped
    input/output** (**I/O**). Memory-mapped I/O is a technique where peripheral registers
    are assigned specific addresses in the system’s memory space. This approach allows
    firmware to interact with hardware peripherals by reading from or writing to these
    memory addresses, just as it would with regular memory. The peripheral memory
    area of the STM32 memory map is the memory-mapped area for the peripheral registers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器架构的一个重要方面是使用**内存映射输入/输出**（**I/O**）。内存映射I/O是一种技术，其中外围寄存器被分配到系统内存空间中的特定地址。这种方法允许固件通过从或向这些内存地址读取或写入来与硬件外围设备交互，就像它与常规内存交互一样。STM32内存映射的外围内存区域是外围寄存器的内存映射区域。
- en: Now that we are familiar with the major memory areas, we are ready to learn
    about the linker script.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了主要内存区域，我们准备学习链接脚本。
- en: The linker script
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接脚本
- en: Linker scripts play an important role in the build process, especially in defining
    the memory layout and allocating various memory sections used by the firmware.
    They specify where different sections of the firmware, such as code, data, and
    uninitialized data, are to be placed in the microcontroller’s memory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 链接脚本在构建过程中扮演着重要的角色，尤其是在定义内存布局和分配固件使用的各种内存部分。它们指定固件的各个部分，如代码、数据和未初始化数据，应在微控制器内存中的位置。
- en: While linker scripts set up the structure and boundaries for these sections,
    it is important to note that they do not populate these sections with data. The
    actual process of initializing data with specific values is handled by the startup
    code, which runs when the microcontroller boots up. We provide these linker scripts
    to the linker to effectively guide the organization of memory during the linking
    phase.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然链接脚本设置了这些部分的架构和边界，但重要的是要注意，它们并不填充这些部分的数据。实际使用特定值初始化数据的处理由启动代码负责，该代码在微控制器启动时运行。我们向链接器提供这些链接脚本，以有效地指导链接阶段的内存组织。
- en: '![Figure 4.2: The build process with the linker highlighted](img/B21914_04_2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：带有链接器高亮的构建过程](img/B21914_04_2.jpg)'
- en: 'Figure 4.2: The build process with the linker highlighted'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：带有链接器高亮的构建过程
- en: Understanding the linking process
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解链接过程
- en: In the build process, the linking of object files is an important step that
    transforms individual pieces of code into functional firmware. The assembler generates
    object files from source code, each containing code and data sections necessary
    for the firmware. However, these object files often have unresolved internal references
    to variables and functions, making them incomplete on their own. For instance,
    an object file may contain a reference to an `adc_value` variable that is defined
    elsewhere. It is the linker’s job to amalgamate these object files, systematically
    resolving all such unresolved symbols to create a cohesive output file. To fully
    appreciate the meticulous work of the linker, we have to understand the attributes
    assigned to each section by the linker.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，链接对象文件是一个重要的步骤，它将单个代码片段转换为功能固件。汇编器从源代码生成对象文件，每个对象文件都包含固件所需的代码和数据部分。然而，这些对象文件通常包含对变量和函数的未解决内部引用，使它们本身不完整。例如，一个对象文件可能包含对定义在其他地方的`adc_value`变量的引用。链接器的任务是合并这些对象文件，系统地解决所有这些未解决符号，以创建一个统一的输出文件。要完全欣赏链接器的细致工作，我们必须了解链接器为每个部分分配的属性。
- en: Section attributes and their implications
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分属性及其影响
- en: 'Each section within an object file is identified by a unique name and size,
    with specific attributes that dictate how they should be treated:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对象文件中的每个部分都通过一个唯一的名称和大小来识别，具有特定的属性，这些属性规定了应该如何处理它们：
- en: '**Loadable sections**: These sections contain content that must be loaded into
    memory at runtime. They are essential for the execution of the program and include
    executable code and initialized data.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可加载部分**：这些部分包含在运行时必须加载到内存中的内容。它们对于程序的执行至关重要，包括可执行代码和初始化数据。'
- en: '**Allocatable sections**: These sections do not carry content by themselves.
    Instead, they signal that a certain area of memory should be reserved, typically
    for uninitialized data that will be defined at runtime.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可分配部分**：这些部分本身不携带内容。相反，它们指示应该保留内存的某个区域，通常是为在运行时定义的未初始化数据。'
- en: '**Non-loadable, non-allocatable sections**: Often, a section that is neither
    loadable nor allocatable contains debugging information or metadata that helps
    in the development process but is not required for the program’s execution.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可加载、不可分配的部分**：通常，既不可加载也不可分配的部分包含调试信息或元数据，这些信息有助于开发过程，但不是程序执行所必需的。'
- en: 'A crucial aspect of the linking process is the determination of two types of
    addresses for each allocatable and loadable output section: the **virtual memory
    address** (**VMA**) and the **load memory** **address** (**LMA**).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 链接过程的一个关键方面是为每个可分配和可加载的输出部分确定两种类型的地址：**虚拟内存地址**（**VMA**）和**加载内存地址**（**LMA**）。
- en: 'These are the roles of these two addresses:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是这两个地址的作用：
- en: '**VMA**: This address represents where the section will reside in memory during
    the execution of the output file. It is the runtime address used by the system
    to access the section’s data or instructions.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VMA**：此地址表示在输出文件执行期间部分将在内存中的位置。它是系统用于访问部分数据或指令的运行时地址。'
- en: '**LMA**: Conversely, the LMA is the address where the section is physically
    loaded into memory.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LMA**：相反，LMA是部分在内存中物理加载的地址。'
- en: In most scenarios, the VMA and LMA are identical
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，VMA和LMA是相同的
- en: A notable exception occurs when a data section is initially loaded into flash
    memory but then copied to SRAM upon startup.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据部分最初被加载到闪存中，但在启动时被复制到SRAM时，会出现一个显著的例外。
- en: 'To provide a clearer and more comprehensive understanding of the latter stages
    of the build process, it’s essential to delve into another fundamental aspect
    of our discussion: the specific responsibilities and contributions of the locator
    within the build process.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地全面理解构建过程的后期阶段，深入探讨我们讨论的另一个基本方面是至关重要的：定位器在构建过程中的具体职责和贡献。
- en: Address relocation and the locator
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地址重定位和定位器
- en: The output file produced by the linker is not immediately suitable for use on
    a target microcontroller. This is because the addresses assigned to different
    sections during the linking process do not necessarily correspond to the actual
    memory layout of the target device. Therefore, these addresses must be relocated
    to match the target’s memory space accurately. This is the job of the locator.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器生成的输出文件并不立即适用于目标微控制器。这是因为链接过程中分配给不同部分的地址不一定与目标设备的实际内存布局相对应。因此，这些地址必须重新定位以准确匹配目标内存空间。这就是定位器的工作。
- en: '![Figure 4.3: The build process, highlighting the relationship between the
    relocatable file, the locator, and the final executable output](img/B21914_04_3.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：构建过程，突出可重定位文件、定位器和最终可执行输出之间的关系](img/B21914_04_3.jpg)'
- en: 'Figure 4.3: The build process, highlighting the relationship between the relocatable
    file, the locator, and the final executable output'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：构建过程，突出可重定位文件、定位器和最终可执行输出之间的关系
- en: In the GNU toolchain, the locator functionality is integrated into the linker,
    streamlining the process of address relocation. This capability ensures that the
    final executable is correctly mapped to the microcontroller’s memory, making it
    ready for execution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU工具链中，定位器功能集成到链接器中，简化了地址重定位的过程。这种能力确保最终的可执行文件正确映射到微控制器的内存中，使其准备好执行。
- en: In this section, we examined the build process. From this, we observed that
    the process of linking object files in embedded systems development involves meticulous
    organization of code and data sections, symbol resolution, and address relocation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们考察了构建过程。从这一点来看，我们观察到嵌入式系统开发中链接对象文件的过程涉及对代码和数据部分的细致组织、符号解析和地址重定位。
- en: In the next section, we shall explore the key components of the linker script
    in detail. This exploration will offer additional insights and deepen our understanding
    of the core elements discussed in this section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细探讨链接脚本的关键组件。这次探索将提供额外的见解，并加深我们对本节讨论的核心元素的理解。
- en: Key components of the linker script
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接脚本的关键组件
- en: The key components of a linker script include the **memory layout**, **section****definitions**,
    **options**, and **symbols**, each playing a unique role in ensuring that the
    firmware is correctly placed and executed within the microcontroller’s memory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 链接脚本的关键组件包括**内存布局**、**部分定义**、**选项**和**符号**，每个都在确保固件正确放置和执行在微控制器内存中发挥独特的作用。
- en: Memory layout
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存布局
- en: This part of the linker script specifies the various memory types available
    in the microcontroller, such as flash memory and SRAM. It includes their start
    addresses and sizes, for instance, flash starting at `0x08000000` or SRAM at `0x20000000`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分链接脚本指定了微控制器中可用的各种内存类型，例如闪存和SRAM。它包括它们的起始地址和大小，例如闪存从`0x08000000`开始或SRAM从`0x20000000`开始。
- en: Section definitions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分定义
- en: 'A critical aspect of the linker script is defining how and where different
    sections of the program are placed. The `.text` section, containing the program
    code, is usually positioned at the beginning of flash memory. Following this,
    the `.bss`) and `.data` sections are allocated in SRAM. The linker script also
    ensures proper alignment of these sections for efficient memory access and program
    execution:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 链接脚本的一个关键方面是定义如何以及在哪里放置程序的不同部分。包含程序代码的`.text`部分通常位于闪存的开始处。随后，`.bss`和`.data`部分在SRAM中分配。链接脚本还确保这些部分的正确对齐，以实现高效的内存访问和程序执行：
- en: '`.``text`:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`:'
- en: '`.text` section holds the executable instructions of our program. It’s where
    the actual code that the processor executes resides.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`部分包含我们程序的执行指令。这是处理器实际执行的代码所在的位置。'
- en: '`.text` section varies based on the amount of code in your program. In STM32
    microcontrollers, it generally starts at a predefined memory address, often in
    the lower region of the flash memory. For example, `0x00000000` and then relocated
    to `0x08000000`.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`部分的大小取决于你的程序中的代码量。在STM32微控制器中，它通常从一个预定义的内存地址开始，通常在闪存的较低区域。例如，`0x00000000`然后重定位到`0x08000000`。'
- en: '`.``bss`:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bss`:'
- en: '`.bss` section is used for uninitialized global and static variables. Variables
    in this section don’t have initial values when the program starts.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bss`部分用于未初始化的全局和静态变量。当程序启动时，这部分变量没有初始值。'
- en: '`0`.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`.'
- en: '`.``data`:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`:'
- en: '`.data` section contains initialized global and static variables. Unlike variables
    in `.bss`, these variables have initial values specified in our code.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`部分包含初始化的全局和静态变量。与`.bss`中的变量不同，这些变量在我们的代码中指定了初始值。'
- en: '`.data` section are typically copied from flash memory to SRAM to allow faster
    access and modification.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`部分通常从闪存复制到SRAM，以允许更快的访问和修改。'
- en: '**Management**: The process of copying these values from flash memory to SRAM
    is handled by the startup code, executed before the main function of our program.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理**：将这些值从闪存复制到SRAM的过程由启动代码处理，该代码在我们程序的main函数之前执行。'
- en: '`.rodata`: This section is used for constant data, such as string literals
    and constant arrays. It’s read-only and usually stored in flash memory.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rodata`: 这个部分用于常量数据，例如字符串字面量和常量数组。它是只读的，通常存储在闪存中。'
- en: '`.heap` and `.stack` are sections used for dynamic memory allocation (`malloc`,
    `free`) and function call stacks, respectively. They are part of SRAM and are
    crucial for runtime memory management.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.heap`和`.stack`是用于动态内存分配（`malloc`、`free`）和函数调用栈的部分。它们是SRAM的一部分，对于运行时内存管理至关重要。'
- en: The following table summarizes the key sections and their placement in memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了关键部分及其在内存中的位置。
- en: '| **Section** | **Purpose** | **Placed in** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **部分** | **目的** | **放置在** |'
- en: '| --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `.``text` | Holds executable program instructions. | `FLASH` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `.text` | 包含可执行程序指令。 | `FLASH` |'
- en: '| `.``bss` | Holds uninitialized global/static variables. | `SRAM` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `.bss` | 存储未初始化的全局/静态变量。 | `SRAM` |'
- en: '| `.``data` | Holds initialized global/static variables with initial values.
    | `FLASH` (`SRAM` at runtime) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `.data` | 存储带有初始值的初始化全局/静态变量。 | `FLASH` (`SRAM` 在运行时）|'
- en: '| `.``rodata` | Holds constant data (string literals, constant arrays). | `FLASH`
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `.rodata` | 存储常量数据（字符串字面量、常量数组）。 | `FLASH` |'
- en: 'Table 4.1: Linker script sections and their placement in memory'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1：链接脚本节区和它们在内存中的位置
- en: Understanding the characteristics of these sections is important for having
    a properly functioning executable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些节区的特性对于确保可执行文件正常工作非常重要。
- en: Options and symbols
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项和符号
- en: '**Options** in linker scripts are commands or directives that influence the
    behavior of the linker. A typical linker script includes directives for setting
    the entry point of the program and directives for defining the memory layout.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项**在链接脚本中是影响链接器行为的命令或指令。一个典型的链接脚本包括设置程序入口点和定义内存布局的指令。'
- en: Symbols in linker scripts are identifiers that act as placeholders or references
    to specific memory locations, values, or addresses within the microcontroller’s
    memory space. Symbols can be used to represent the start or end addresses of memory
    sections or specific variables in the program. For example, a symbol might be
    defined to represent the beginning of the flash memory or the start of the SRAM
    region. We can also use symbols to define important constants or values that are
    used throughout the firmware (such as source code files). These might include
    hardware addresses, configuration values, or size limits. By using symbols, the
    code becomes more readable and maintainable, as these values can be changed in
    one place (the linker script), rather than in multiple locations throughout the
    code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 链接脚本中的符号是作为占位符或对微控制器内存空间中特定内存位置、值或地址的引用的标识符。符号可以用来表示内存节区的起始或结束地址或程序中的特定变量。例如，可以定义一个符号来表示闪存开始或
    SRAM 区域的起始。我们还可以使用符号来定义在整个固件（如源代码文件）中使用的 重要常量或值。这些可能包括硬件地址、配置值或大小限制。通过使用符号，代码变得更加可读和可维护，因为这些值可以在一个地方（链接脚本）更改，而不是在代码的多个位置更改。
- en: Now that we are familiar with the key components of linker scripts, we will
    proceed to learn about some of the essential directives within these scripts.
    Each directive in a linker script instructs the linker on how to process and organize
    the input object files into the final executable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了链接脚本的关键组件，我们将继续学习这些脚本中的一些基本指令。链接脚本中的每个指令都指导链接器如何处理和组织输入目标文件到最终的可执行文件中。
- en: Linker script directives
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接脚本指令
- en: In this section, we learn about the essential directives of linker scripts.
    These directives dictate the memory layout and how various sections—code, data,
    and others—are allocated within the target microcontroller’s memory. We will explore
    the key directives, their functionality, and how they influence the overall structure
    and efficiency of the compiled firmware. Let’s start with the `MEMORY` directive.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习链接脚本的基本指令。这些指令决定了内存布局以及各种节区（代码、数据等）如何在目标微控制器的内存中分配。我们将探讨关键指令、它们的功能以及它们如何影响编译固件的总体结构和效率。让我们从
    `MEMORY` 指令开始。
- en: Memory directive (MEMORY)
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存指令（MEMORY）
- en: The `MEMORY` directive delineates the microcontroller’s memory regions. Each
    defined block within the `MEMORY` section represents a distinct area of memory,
    characterized by its name, start address, and size. This directive allows us to
    define the memory layout of the target device, specifying different memory regions
    and their attributes. It plays an important role in guiding the linker on how
    to allocate sections of the program (code, data, etc.) across the microcontroller’s
    physical memory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEMORY` 指令界定了微控制器的内存区域。`MEMORY` 节区中定义的每个块代表一个独立的内存区域，其特征在于其名称、起始地址和大小。此指令允许我们定义目标设备的内存布局，指定不同的内存区域及其属性。它在指导链接器如何将程序的节区（代码、数据等）分配到微控制器的物理内存中起着重要作用。'
- en: Usage template
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用模板
- en: 'The general syntax for the `MEMORY` directive is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEMORY` 指令的一般语法如下：'
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`name`: An identifier we give to the memory region'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 我们赋予内存区域的标识符'
- en: '`attributes`: This specifies the access permissions for the region, such as
    read, write, and execute permissions'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes`: 这指定了区域的访问权限，例如读、写和执行权限'
- en: '`ORIGIN`: This defines the start address of the memory region'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORIGIN`: 这定义了内存区域的起始地址'
- en: '`LENGTH`: This specifies the size of the memory region'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LENGTH`: 这指定内存区域的大小'
- en: Usage example
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'Consider a microcontroller with flash memory for storing executable code and
    SRAM for data storage. A linker script might define these memory regions as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个微控制器，它使用闪存来存储可执行代码，使用SRAM来存储数据。链接脚本可能如下定义这些内存区域：
- en: '[PRE1]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, two memory regions are defined: `FLASH` and `SRAM`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，定义了两个内存区域：`FLASH` 和 `SRAM`：
- en: '`FLASH` is marked with read (`r`) and execute (`x`) permissions (`rx`), indicating
    that this region can store executable code but is not writable during program
    execution. It starts at the `0x08000000` address and extends for `256K` bytes.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLASH` 被标记为读取（`r`）和执行（`x`）权限（`rx`），表示此区域可以存储可执行代码，但在程序执行期间不可写。它从 `0x08000000`
    地址开始，扩展 `256K` 字节。'
- en: '`SRAM` is given read (`r`), write (`w`), and execute (`x`) permissions (`rwx`),
    allowing it to store data and executable code that can be modified during runtime.
    It begins at the `0x20000000` address and extends for `64K` bytes.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRAM` 被授予读取（`r`）、写入（`w`）和执行（`x`）权限（`rwx`），允许它在运行时存储和修改数据和可执行代码。它从 `0x20000000`
    地址开始，扩展 `64K` 字节。'
- en: 'The `MEMORY` directive, with its comprehensive definition of memory regions
    and attributes, lays the foundation for efficient and effective memory management
    in firmware development. Before moving on to the next directive, let’s examine
    all the attributes that can be specified to detail the characteristics and permissions
    of the memory sections:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEMORY` 指令，通过其综合定义内存区域和属性，为固件开发中的高效和有效内存管理奠定了基础。在继续到下一个指令之前，让我们检查所有可以指定的属性，以详细说明内存部分的特性和权限：'
- en: '`r`: This attribute allows memory to be read. It is important for sections
    of memory containing executable code or constants that the program needs to read
    during execution.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`: 此属性允许读取内存。这对于包含程序在执行期间需要读取的可执行代码或常量的内存部分非常重要。'
- en: '`w`: This attribute permits data to be written to the memory. It is important
    for memory areas where the program stores data dynamically during execution.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`: 此属性允许将数据写入内存。这对于程序在执行期间动态存储数据的内存区域非常重要。'
- en: '`x`: This attribute allows the execution of code from the specified memory
    region. It is typically assigned to flash memory where the program code resides.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`: 此属性允许从指定的内存区域执行代码。它通常分配给包含程序代码的闪存。'
- en: '`rw`: This is a combination of read and write permissions, allowing both operations
    in the specified memory region. It’s commonly used for sections such as SRAM where
    temporary data and variables are stored and modified.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw`: 这是读取和写入权限的组合，允许在指定的内存区域进行这两种操作。它通常用于如SRAM这样的部分，其中存储和修改临时数据和变量。'
- en: '`rx`: This combines read and execute permissions. It’s often used for flash
    memory to indicate that the region contains executable code that the processor
    can read and execute.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rx`: 这表示读取和执行权限的组合。它通常用于闪存，以指示该区域包含处理器可以读取和执行的执行代码。'
- en: '`rwx`: This attribute combines all three permissions, making the memory region
    fully accessible for reading, writing, and executing. This is less commonly used
    due to security and system stability considerations but might be applicable in
    certain development or debug scenarios.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx`: 此属性组合了所有三种权限，使内存区域完全可读、可写和可执行。这由于安全和系统稳定性考虑而较少使用，但在某些开发或调试场景中可能适用。'
- en: '`empty`: If no attribute is specified, the memory region does not grant any
    access permissions by default. This might be used in special cases where permissions
    are controlled or modified by other means within the firmware.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty`: 如果没有指定属性，则默认情况下内存区域不授予任何访问权限。这可能在权限由固件中的其他方式控制或修改的特殊情况下使用。'
- en: Now, let’s examine the `ENTRY` directive.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查 `ENTRY` 指令。
- en: The entry directive (ENTRY)
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入口指令（ENTRY）
- en: This directive specifies the entry point of the program, which is the first
    piece of code to execute upon reset.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令指定程序的入口点，即复位后首先执行的代码片段。
- en: 'Here is the usage template:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用模板：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is a usage example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用示例：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, `Reset_Handler` is designated as the entry point of the program,
    meaning, the first function to execute. In firmware development, `Reset_Handler`
    takes care of initializing the system and jumping to the main program.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`Reset_Handler`被指定为程序的入口点，这意味着第一个要执行的功能。在固件开发中，`Reset_Handler`负责初始化系统并跳转到主程序。
- en: Next, we have the `SECTIONS` directive.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍`SECTIONS`指令。
- en: The sections directive (SECTIONS)
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分指令（SECTIONS）
- en: This directive defines the mapping and ordering of sections from input files
    into the output file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令定义了从输入文件到输出文件的映射和排序。
- en: Usage example
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'Let’s see a template of it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的模板：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The parameters are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`output_section_name`: This is the name given to the output section being defined.
    Common names include `.text` for executable code, `.data` for initialized data,
    and `.bss` for uninitialized data.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output_section_name`：这是为定义的输出部分给出的名称。常见的名称包括`.text`用于可执行代码，`.data`用于初始化数据，以及`.bss`用于未初始化数据。'
- en: '`address`: This is optional and specifies the start address of the section
    in memory. This is often left to the linker to determine, based on the order of
    sections and memory regions defined in the script.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`：这是可选的，并指定了部分在内存中的起始地址。这通常留给链接器根据脚本中定义的部分和内存区域的顺序来确定。'
- en: '`input_section_information`: This determines which input sections (from the
    compiled object files) should be included in this output section. Wildcards such
    as `*(.text)` can be used to include all `.text` sections from all input files.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input_section_information`：这决定了哪些输入部分（来自编译后的目标文件）应该包含在这个输出部分中。可以使用通配符，如`*(.text)`，来包含所有输入文件中的`.text`部分。'
- en: '`>memory_region`: This assigns the section to a specific memory region defined
    in the `MEMORY` block of the linker script. We use this to tell the linker where
    in the target’s memory map this section should reside, for example, `FLASH` or
    `SRAM`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>memory_region`：这会将部分分配给在链接脚本`MEMORY`块中定义的特定内存区域。我们使用这个指令来告诉链接器这个部分应该在目标内存映射中的哪个位置，例如`FLASH`或`SRAM`。'
- en: '`[AT>load_address]`: This is optional and specifies the load address of the
    section. This is used in scenarios where the execution address differs from the
    load address.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[AT>load_address]`：这是可选的，并指定了部分加载地址。这在执行地址与加载地址不同的场景中使用。'
- en: '`[ALIGN(expression)]`: This is optional and aligns the start of the section
    to an address that is a multiple of the value specified by `expression`. This
    is particularly useful for ensuring that sections begin at addresses that meet
    specific alignment requirements, which can enhance access speed and compatibility.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ALIGN(expression)]`：这是可选的，并将部分的开头对齐到由`expression`指定的值的倍数地址。这对于确保部分从满足特定对齐要求的地址开始特别有用，这可以提高访问速度和兼容性。'
- en: '`[:phdr_expression]`: This is optional and associates the section with a program
    header. Program headers are part of the **Executable and Linkable Format** (**ELF**)
    file structure; they provide the system loader with information about how to load
    and run different segments of a program.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:phdr_expression]`：这是可选的，并将部分与程序头关联。程序头是**可执行和链接格式**（**ELF**）文件结构的一部分；它们为系统加载器提供有关如何加载和运行程序不同段的信息。'
- en: '`[=fill_expression]`: This is optional and specifies a byte value to fill gaps
    between sections or at the end of sections to reach a certain alignment. This
    can be useful for initializing memory regions to a known state.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[=fill_expression]`：这是可选的，并指定一个字节值来填充部分之间的间隙或填充到部分末尾以达到一定的对齐。这可以用于初始化内存区域到已知状态。'
- en: Usage example
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'Let’s see an example of the `SECTIONS` directive in action:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`SECTIONS`指令的实际应用示例：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we have the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们有以下内容：
- en: '`SECTIONS`: This keyword begins the section of the linker script where output
    sections are defined. Output sections are areas of memory that hold the code and
    data from the input files being linked.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECTIONS`：这个关键字标志着链接脚本中定义输出部分的开始。输出部分是内存区域，用于存放被链接的输入文件的代码和数据。'
- en: '`.text 0x08000000`: This line defines an output section named `.text` and sets
    its starting address to `0x08000000`. The `.text` section typically contains executable
    code.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text 0x08000000`：这一行定义了一个名为`.text`的输出部分，并将其起始地址设置为`0x08000000`。`.text`部分通常包含可执行代码。'
- en: '`{ *(.text) }`: This line specifies what goes into the `.text` output section.
    The `*(.text)` syntax means all `.text` sections from all input files.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ *(.text) }`：这一行指定了要放入`.text`输出部分的内容。`*(.text)`语法意味着所有输入文件中的`.text`部分。'
- en: '`>FLASH`: This directive tells the linker to place the `.text` section in a
    memory region named `FLASH`. The `FLASH` region will be defined in the `MEMORY`
    directive block.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>FLASH`：此指令告诉链接器将`.text`部分放置在名为`FLASH`的内存区域中。`FLASH`区域将在`MEMORY`指令块中定义。'
- en: To understand the importance of the `*(.text)` syntax, let’s examine the process
    of merging sections.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`*(.text)`语法的意义，让我们检查合并部分的过程。
- en: Sections merging
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分合并
- en: As we learned earlier, the assembler generates an object file for each source
    file, with each containing its `.text`, `.data`, `.bss`, and other sections. These
    sections from all object files are then merged by the linker into unified `.text`,
    `.data`, and `.bss` sections for the final executable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，汇编器为每个源文件生成一个目标文件，每个文件都包含其`.text`、`.data`、`.bss`和其他部分。然后，链接器将这些部分合并到最终可执行文件的统一`.text`、`.data`和`.bss`部分中。
- en: Consider a firmware project with two source files, `main.c` and `delay.c`. The
    assembly process yields `main.o` and `delay.o`, each with its own sections. The
    linker’s task is to consolidate these into a single set of sections for the final
    executable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含两个源文件（`main.c`和`delay.c`）的固件项目。汇编过程产生`main.o`和`delay.o`，每个都有自己的部分。链接器的任务是将这些部分合并成最终可执行文件的单一代码集合。
- en: The following figure depicts this process. Note that merging is *not* performed
    through an addition process; this is merely a visual aid to enhance your understanding.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这一过程。请注意，合并不是通过加法过程完成的；这只是一个视觉辅助工具，以增强你的理解。
- en: '![Figure 4.4: The merging process involving two source files: main.c and delay.c,
    resulting in the production of the final executable, final.elf](img/B21914_04_4.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：涉及两个源文件（main.c和delay.c）的合并过程，结果生成最终的可执行文件final.elf](img/B21914_04_4.jpg)'
- en: 'Figure 4.4: The merging process involving two source files: main.c and delay.c,
    resulting in the production of the final executable, final.elf'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：涉及两个源文件（main.c和delay.c）的合并过程，结果生成最终的可执行文件final.elf
- en: Now, let’s explore the purpose of the `AT >` directive. To do this, it is essential
    to revisit the concepts of the LMA and VMA.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨`AT >`指令的目的。为了做到这一点，我们必须重新审视LMA和VMA的概念。
- en: A closer look at the LMA and VMA
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仔细观察LMA和VMA
- en: 'As we learned earlier, each allocatable and loadable output section in a binary
    output file is associated with two types of addresses: the LMA and the VMA. These
    addresses are crucial for defining how and where a section of the binary is processed
    during the system’s startup and its subsequent runtime operations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，二进制输出文件中的每个可分配和可加载输出部分都与两种类型的地址相关联：LMA（加载地址）和VMA（虚拟地址）。这些地址对于定义在系统启动及其后续运行操作期间如何以及在哪里处理二进制文件的某个部分至关重要：
- en: '**LMA**: This is the physical address in the binary image where the section
    is stored before program execution begins. It determines from where the system
    will load the section into memory when the program starts.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LMA**：这是在程序执行开始之前，该部分在二进制映像中的物理地址。它决定了系统在程序启动时将从哪里将部分加载到内存中。'
- en: '**VMA**: In contrast, the VMA is the address where the section is intended
    to be accessed during the program’s execution. This is the “runtime” address used
    by the system to refer to data or instructions in that section. For systems, particularly
    microcontrollers, that do not employ a **memory management unit** (**MMU**), the
    VMA usually matches the section’s physical memory address directly.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VMA**：相反，VMA是程序执行期间该部分打算被访问的地址。这是系统在引用该部分中的数据或指令时使用的“运行时”地址。对于不使用**内存管理单元**（MMU）的系统，尤其是微控制器，VMA通常直接匹配该部分的物理内存地址。'
- en: Why are LMA and VMA important?
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么LMA和VMA很重要？
- en: The distinction between LMA and VMA allows for a flexible memory management
    approach where data can be stored in one location (such as flash memory) but run
    from another (such as SRAM). For example, initialized global and static variables
    (typically placed in the `.data` section) can be stored in flash memory but need
    to be copied to SRAM for faster access and to allow modification at runtime.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: LMA和VMA之间的区别允许采用灵活的内存管理方法，其中数据可以存储在一个位置（如闪存），但运行在另一个位置（如SRAM）。例如，初始化的全局和静态变量（通常放置在`.data`部分）可以存储在闪存中，但需要复制到SRAM以实现更快的访问并允许在运行时进行修改。
- en: 'To fully understand this, let’s consider the following snippet from a linker
    script generated by the STM32CubeIDE:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解这一点，让我们考虑以下由STM32CubeIDE生成的链接脚本片段：
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this script, the last line, `>SRAM AT> FLASH`, incorporates two important
    directives:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，最后一行 `>SRAM AT> FLASH` 包含了两个重要的指令：
- en: '`>SRAM` indicates that the output `.data` section is placed in the `SRAM` section
    of the memory during program execution (VMA).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>SRAM` 表示在程序执行期间（VMA），输出 `.data` 部分被放置在内存的 `SRAM` 区域。'
- en: '`AT> FLASH` specifies that although the section resides in SRAM when executed,
    it should initially be loaded into memory (`FLASH`. This is common for initialized
    data, which is stored in flash memory and then copied to SRAM at startup by the
    microcontroller’s initialization code.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AT> FLASH` 指定尽管在执行时部分位于 SRAM 中，但它应该最初被加载到内存中（`FLASH`）。这对于初始化数据很常见，这些数据存储在闪存中，然后在微控制器初始化代码启动时被复制到
    SRAM。'
- en: This detailed management of memory addresses highlights the critical role of
    LMA and VMA in maximizing the efficiency of resource-constrained microcontrollers.
    Through the effective use of LMA and VMA, we can ensure that even with limited
    memory resources, our microcontrollers operate reliably and efficiently, optimizing
    both storage and execution efficiency.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对内存地址的详细管理突出了 LMA 和 VMA 在最大化资源受限微控制器效率中的关键作用。通过有效使用 LMA 和 VMA，我们可以确保即使在有限的内存资源下，我们的微控制器也能可靠高效地运行，优化存储和执行效率。
- en: Before moving to explore the other features of the linker script, let’s familiarize
    ourselves with some other commonly used directives.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索链接器脚本的其他功能之前，让我们熟悉一些其他常用的指令。
- en: Other commonly used directives
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常用指令
- en: Some other commonly used directives include the `KEEP`, `ALIGN`, `PROVIDE`,
    `>region`, and `AT` directives. Let’s examine them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他常用的指令包括 `KEEP`、`ALIGN`、`PROVIDE`、`>region` 和 `AT` 指令。让我们来检查它们。
- en: The KEEP directive
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`KEEP` 指令'
- en: The `KEEP` directive ensures that specified sections or symbols are not eliminated
    by the linker during the optimization process, even if they appear unused. This
    is crucial for interrupt vector tables and initialization functions that must
    be present in the final binary.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`KEEP` 指令确保在优化过程中，指定的部分或符号不会被链接器删除，即使它们看起来没有被使用。这对于必须存在于最终二进制文件中的中断向量表和初始化函数至关重要。'
- en: 'Here is the usage template:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用模板：
- en: '[PRE7]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is a usage example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用示例：
- en: '[PRE8]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we are *keeping* the interrupt vector section. Next, let’s
    see the region placement directive.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在保留中断向量部分。接下来，让我们看看区域放置指令。
- en: The >region directive
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`>region` 指令'
- en: The `(>region)` region placement directive tells the linker to place a particular
    section into a specific memory region. The available memory regions must be defined
    in the `MEMORY` directive block of the linker script.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`(>region)` 区域放置指令告诉链接器将特定的部分放置在特定的内存区域中。可用的内存区域必须在链接器脚本中的 `MEMORY` 指令块中定义。'
- en: 'Here is the usage template:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用模板：
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is a usage example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用示例：
- en: '[PRE10]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we are placing the `.data` section in the `SRAM` memory region.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将 `.data` 部分放置在 `SRAM` 内存区域。
- en: The ALIGN directive
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`ALIGN` 指令'
- en: The `ALIGN` directive plays a crucial role in the linker script by adjusting
    the location counter to align with specified memory boundaries. **The location
    counter** tracks the current memory address allocated by the linker for placing
    sections or parts of the output file during linking.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALIGN` 指令在链接器脚本中起着至关重要的作用，通过调整位置计数器以与指定的内存边界对齐。**位置计数器**跟踪链接器在链接过程中为放置部分或输出文件的某部分分配的当前内存地址。'
- en: '`.`) in linker scripts.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`) 在链接器脚本中。'
- en: As the linker processes the script, it assigns memory addresses to code and
    data sections according to the script’s directives, with the location counter
    monitoring the progress. To ensure efficient memory access and adherence to hardware
    architecture requirements, sections and variables often need to be aligned to
    specific boundaries. The `ALIGN` directive allows us to achieve this by rounding
    up the location counter to the nearest address that matches the specified alignment,
    which must be a power of two.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器在处理脚本时，根据脚本中的指令为代码和数据部分分配内存地址，同时位置计数器监控进度。为了确保高效的内存访问并遵守硬件架构要求，部分和变量通常需要对齐到特定的边界。`ALIGN`
    指令通过将位置计数器向上舍入到最接近的符合指定对齐的地址来实现这一点，该对齐必须是2的幂。
- en: 'Here is the usage template:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用模板：
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is a usage example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用示例：
- en: '[PRE12]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we are aligning the current location to a `4`-byte boundary.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将当前位置对齐到 `4` 字节边界。
- en: Next, let’s see the `PROVIDE` directive.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `PROVIDE` 指令。
- en: The PROVIDE directive
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PROVIDE 指令
- en: The `PROVIDE` directive allows us to define symbols that the linker will include
    in the output file if they are not already defined. This can be used to set default
    values for symbols that may be optionally overridden by other modules.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`PROVIDE` 指令允许我们定义符号，如果它们尚未定义，链接器将包括这些符号在输出文件中。这可以用来设置可能被其他模块可选覆盖的符号的默认值。'
- en: 'Here is the usage template:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用模板：
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is a usage example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用示例：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we are *providing* a default stack end address.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在 *提供* 一个默认的栈结束地址。
- en: Next, we have the `AT` directive.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `AT` 指令。
- en: AT Directive
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AT 指令
- en: The `AT` directive specifies LMA for a section when it needs to be different
    from the section’s VMA. This is commonly used for sections that need to be loaded
    into a different memory area during initialization before being moved to their
    runtime location.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将一个段的 LMA 与其 VMA 区分开来时，`AT` 指令指定了该段的 LMA。这通常用于需要在初始化期间加载到不同内存区域，然后再移动到其运行时位置的段。
- en: 'Here is the usage template:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用模板：
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is a usage example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用示例：
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, the `.data` section is intended to reside in SRAM during the
    program’s execution. However, it is initially loaded from `FLASH`, as indicated
    by `AT> FLASH`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`.data` 段在程序执行期间应驻留在 SRAM 中。然而，它最初是从 `FLASH` 加载的，如 `AT> FLASH` 所示。
- en: 'In the next section, we will explore another key aspect of linker scripts:
    the expression of numerical constants.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨链接脚本的关键方面：数值常量的表达。
- en: Understanding constants in linker scripts
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解链接脚本中的常量
- en: When writing our linker script, we must keep in mind the interpretation of numerical
    prefixes and suffixes by the linker.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的链接脚本时，我们必须牢记链接器对数值前缀和后缀的解释。
- en: Firstly, let’s clarify how the linker perceives integers with specific prefixes.
    An integer prefixed with `0` is read as an octal number by the linker. On the
    other hand, an integer starting with `0x` is recognized as a hexadecimal value.
    This distinction is important for accurately defining memory addresses and sizes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们澄清链接器如何识别具有特定前缀的整数。以 `0` 开头的整数被链接器读取为八进制数。另一方面，以 `0x` 开头的整数被识别为十六进制值。这种区别对于准确定义内存地址和大小很重要。
- en: The use of the `K` and `M` suffixes introduces another layer of convenience,
    allowing us to denote large numbers succinctly. The `K` suffix multiplies the
    preceding number by `1024`, while `M` expands the number by 1,024 twice over.
    Therefore, `4K` translates to 4 times 1024, and `4M` expands to 4 times 1,024
    squared.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `K` 和 `M` 后缀引入了另一层便利性，允许我们简洁地表示大数字。`K` 后缀将前面的数字乘以 `1024`，而 `M` 将数字扩展为 1,024
    的平方。因此，`4K` 等于 4 乘以 1024，而 `4M` 扩展为 4 乘以 1,024 的平方。
- en: To put these principles into practice, let’s explore an example that showcases
    the versatility of these notations. Imagine you need to specify a memory size
    of 4K. You could straightforwardly use `4K`, or opt for its decimal equivalent,
    `4096`, which results from multiplying 1,024 by 4\. Alternatively, this quantity
    can be expressed in hexadecimal form as `0x1000`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些原则付诸实践，让我们探索一个示例，展示这些符号的多样性。想象你需要指定 4K 的内存大小。你可以直接使用 `4K`，或者选择其十进制等价物，`4096`，这是通过将
    1,024 乘以 4 得到的。或者，这个数量可以用十六进制形式表示为 `0x1000`。
- en: '*Table 4.2* summarizes the key points to remember about using constants in
    linker scripts. It highlights the prefixes and suffixes that modify the base value,
    which offers a clear reference for interpreting and using these notations effectively
    in your linker script.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 4.2* 总结了在使用链接脚本中的常量时需要记住的关键点。它突出了修改基本值的前缀和后缀，这为在链接脚本中有效地解释和使用这些符号提供了清晰的参考。'
- en: '| **Notation** | **Meaning** | **Example** | **Equivalent** **Decimal** | **Hexadecimal**
    **Notation** |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **含义** | **示例** | **等效** **十进制** | **十六进制** **符号** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | Octal prefix | `010` | 8 | - |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 八进制前缀 | `010` | 8 | - |'
- en: '| `0x` | Hexadecimal prefix | `0x10` | 16 | - |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `0x` | 十六进制前缀 | `0x10` | 16 | - |'
- en: '| `K` | Multiplies by 1,024 | `4K` | 4096 | `0x1000` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `K` | 乘以 1,024 | `4K` | 4096 | `0x1000` |'
- en: '| `M` | Multiplies by 1,024 twice (squared) | `4M` | 4194304 | `0x400000` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `M` | 乘以 1,024 两次（平方） | `4M` | 4194304 | `0x400000` |'
- en: 'Table 4.2: Examples of linker script numerical prefixes and suffixes'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2：链接脚本数值前缀和后缀的示例
- en: In the next section, we shall learn about linker script symbols, further enhancing
    our understanding of linker scripts.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于链接脚本符号的内容，进一步加深我们对链接脚本的理解。
- en: Linker script symbols
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接脚本符号
- en: 'Linker symbols, also known simply as **symbols**, are fundamental elements
    in the process of converting source code into executable programs. At its core,
    a linker symbol comprises two essential components: a name and a value. These
    symbols are assigned integer values, representing memory addresses where variables,
    functions, or other program elements are stored in the microcontroller’s memory.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 链接符号，也简称为**符号**，是将源代码转换为可执行程序过程中的基本元素。在核心上，一个链接符号包含两个基本组件：一个名称和一个值。这些符号被分配整数值，代表变量、函数或其他程序元素在微控制器内存中的存储地址。
- en: Previously, we learned that after the assembly stage, the source code is transformed
    into object files. These object files contain machine code and unresolved references
    to variables and functions. The linker’s primary task is to merge these object
    files, resolve these unresolved symbols, and generate a complete executable file
    ready for execution.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们了解到在汇编阶段之后，源代码被转换成目标文件。这些目标文件包含机器代码以及变量和函数的未解决引用。链接器的主要任务是合并这些目标文件，解决这些未解决符号，并生成一个准备执行的可执行文件。
- en: In the context of linker symbols, the value assigned to a symbol represents
    the memory address where the corresponding variable or function resides.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接符号的上下文中，分配给符号的值代表相应的变量或函数所在的内存地址。
- en: 'For example: X = 3500 means the memory address of X is 3500'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：X = 3500 表示 X 的内存地址是 3500
- en: A symbol named `X` might be assigned a value of `3500`, indicating its memory
    address. It’s crucial to note that in contrast to the variable’s value in the
    source code, the `X` linker symbol represents its memory address.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `X` 的符号可能被分配一个值为 `3500`，表示其内存地址。重要的是要注意，与源代码中变量的值不同，`X` 链接符号代表其内存地址。
- en: '| **Name** | **Type** | **Value (Memory** **Address)** | **Description** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型** | **值（内存地址**） | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `X` | Symbol | `3500` | Represents the memory address where an `X` variable
    is stored. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 符号 | `3500` | 表示存储 `X` 变量的内存地址。|'
- en: '| `Y` | Symbol | `0x3000` | Represents the memory address where a `Y` variable
    is stored. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `Y` | 符号 | `0x3000` | 表示存储 `Y` 变量的内存地址。|'
- en: '| `foo()` | Symbol | `0x4000` | Represents the memory address where a `foo()`
    function is located. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `foo()` | 符号 | `0x4000` | 表示 `foo()` 函数所在的内存地址。|'
- en: '| `bar()` | Symbol | `0x5000` | Represents the memory address where a `bar()`
    function is located. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `bar()` | 符号 | `0x5000` | 表示 `bar()` 函数所在的内存地址。|'
- en: '| `x` | Variable | `3500` | Represents the value of a C variable named `x`.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 变量 | `3500` | 表示名为 `x` 的 C 变量的值。|'
- en: '| `y` | Variable | `4500` | Represents the value of a C variable named `y`.
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `y` | 变量 | `4500` | 表示名为 `y` 的 C 变量的值。|'
- en: 'Table 4.3: Comparison of linker symbols and C source code variables assignments'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3：链接符号与 C 源代码变量赋值的比较
- en: Linker symbols can undergo various operations, such as those we use in C assignments.
    These operations include straightforward assignment (`=`), addition (`+=`), and
    subtraction (`-=`), among others.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 链接符号可以执行各种操作，例如我们在 C 赋值中使用的那些操作。这些操作包括简单的赋值（`=`）、加法（`+=`）和减法（`-=`）等。
- en: '![Figure 4.5: Examples of linker symbol operations](img/B21914_04_5.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5：链接符号操作示例](img/B21914_04_5.jpg)'
- en: 'Figure 4.5: Examples of linker symbol operations'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：链接符号操作示例
- en: During the linking process, a symbol table is created, mapping each symbol to
    its corresponding address in memory. This table serves as a crucial reference
    for the linker to resolve symbol references and ensure proper linking of program
    components.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接过程中，会创建一个符号表，将每个符号映射到内存中的相应地址。这个表作为链接器解决符号引用和确保程序组件正确链接的关键参考。
- en: Let’s consider a scenario where we have a `main.c` file and at the top of this
    file; we declare a variable named `X`, assigning it a value of `568`. Additionally,
    within this file, there’s a function named `blink`. Inside the `blink` function,
    there are operations to turn on an LED, wait, and then turn it off. This is depicted
    in *Figure 4**.6*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，我们有一个 `main.c` 文件，在这个文件的顶部声明了一个名为 `X` 的变量，并给它分配了一个值为 `568`。此外，在这个文件中，有一个名为
    `blink` 的函数。在 `blink` 函数内部，有操作来打开 LED，等待，然后关闭它。这如图 *4.6* 所示。
- en: Now, let’s take this `main.c` file and pass it through the build process to
    generate the `main.o` object file. During this process, a symbol table is generated.
    Each symbol in this table is associated with an address.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个 `main.c` 文件通过构建过程传递，以生成 `main.o` 目标文件。在这个过程中，会生成一个符号表。表中的每个符号都与一个地址相关联。
- en: For instance, the `X` symbol would be assigned an address of `0x20000000`, and
    similarly, the `blink` function would also be assigned its address. In the following
    figure, the `blink` function is assigned the `0x08000000` address.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`X` 符号会被分配地址 `0x20000000`，同样，`blink` 函数也会被分配其地址。在下面的图中，`blink` 函数被分配地址 `0x08000000`。
- en: Essentially, just like in the C programming language, each variable has its
    value. In the object file, each symbol has its value, which essentially represents
    the address of the corresponding variable or function in C.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，就像在 C 编程语言中一样，每个变量都有自己的值。在目标文件中，每个符号都有自己的值，这本质上代表了 C 中相应变量或函数的地址。
- en: So, when referring to `X` in the object file, it wouldn’t give us `568`; rather,
    it would provide the address of `X`. This process of assigning values to symbols
    and associating them with addresses constructs the symbol table.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当在目标文件中引用 `X` 时，它不会给出 `568`，而是会提供 `X` 的地址。这个过程将值分配给符号并将它们与地址关联起来，从而构建符号表。
- en: '![Figure 4.6: Representation of functions and variables from the source file
    in the symbol table of the output object file](img/B21914_04_6.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6：源文件中的函数和变量在输出目标文件符号表中的表示](img/B21914_04_6.jpg)'
- en: 'Figure 4.6: Representation of functions and variables from the source file
    in the symbol table of the output object file'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：源文件中的函数和变量在输出目标文件符号表中的表示
- en: In this section, we delved deep into linker scripts, highlighting key components
    and directives. We carefully explored each directive, providing practical usage
    examples. Additionally, we distinguished between the LMA and VMA and also emphasized
    their important roles in guiding the linker on how to place sections. In the next
    section, we will learn how to write our own linker script and startup file from
    scratch, equipping you with another important skill in bare-metal firmware development.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了链接脚本，强调了关键组件和指令。我们仔细探讨了每个指令，提供了实际使用示例。此外，我们还区分了 LMA 和 VMA，并强调了它们在指导链接器如何放置部分中的重要作用。在下一节中，我们将学习如何从头开始编写自己的链接脚本和启动文件，为您在裸机固件开发中提供另一项重要技能。
- en: Writing the linker script and startup file
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写链接脚本和启动文件
- en: Now that we have a good understanding of linker scripts and their essential
    components, we’re prepared to write our own. However, before diving into writing
    the script, it’s crucial to revisit the memory map of the microcontroller and
    gain insight into the `positions` load memory for various sections within the
    object file.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经很好地理解了链接脚本及其基本组件，我们就准备编写自己的脚本。然而，在深入编写脚本之前，重新审视微控制器的内存映射并深入了解对象文件中各个部分的
    `positions` 加载内存是非常重要的。
- en: Understanding the load memory of different sections
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解不同部分的加载内存
- en: As discussed earlier in this chapter, the output object file is structured into
    sections such as `.data`, `.rodata`, `.text`, and `.bss`. Together with the sections
    created by the assembler, we must define our own section to accommodate the vector
    table for `.isr_vector_tbl`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，输出目标文件被结构化为如 `.data`、`.rodata`、`.text` 和 `.bss` 等部分。除了汇编器创建的部分外，我们还必须定义自己的部分来容纳
    `.isr_vector_tbl` 的向量表。
- en: Each of these sections plays an important role in organizing the memory layout
    of the microcontroller, contributing to the functionality and efficiency of the
    final executable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分中的每一个都在组织微控制器的内存布局中发挥着重要作用，有助于最终可执行文件的功能性和效率。
- en: '*Figure* *4**.7* shows a zoomed-in view of the flash memory area, showing the
    required order for placing the different sections within the flash memory. Each
    section represents the combination of identical sections from all input files.
    For instance, the `.text` section depicted is a unified `.text` section, formed
    by merging all `.text` sections from the input files.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图* *4**.7* 展示了闪存区域的放大视图，显示了在闪存内存中放置不同部分的所需顺序。每个部分代表所有输入文件中相同部分的组合。例如，图中描述的
    `.text` 部分是一个统一的 `.text` 部分，由合并所有输入文件中的 `.text` 部分形成。'
- en: The diagram indicates that the placement must start with the `.isr_vector_tbl`
    section at the beginning of the flash memory. Following this, we must place the
    `.text` section, then the `.rodata` section, and finally, the `.data` section.
    The diagram does not show the placement of the `.bss` section, as we will place
    the `.bss` section directly in the SRAM. Additionally, during the startup code
    implementation, we must copy the content of the `.data` section from the flash
    memory to the SRAM.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表明，放置必须从闪存开始的`.isr_vector_tbl`部分开始。随后，我们必须放置`.text`部分，然后是`.rodata`部分，最后是`.data`部分。该图没有显示`.bss`部分的放置，因为我们将在SRAM中直接放置`.bss`部分。此外，在启动代码实现过程中，我们必须将`.data`部分的内容从闪存复制到SRAM。
- en: '![Figure 4.7: The flash memory area showing the order in which sections should
    be placed](img/B21914_04_7.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：显示各部分放置顺序的闪存区域](img/B21914_04_7.jpg)'
- en: 'Figure 4.7: The flash memory area showing the order in which sections should
    be placed'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：显示各部分放置顺序的闪存区域
- en: Before we proceed, however, let’s understand the concept of interrupts and the
    vector table.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们先了解中断和中断向量表的概念。
- en: Interrupts and the vector table
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断和中断向量表
- en: Interrupts are a fundamental concept in computing. They act as a powerful mechanism
    for managing how a computer or a microcontroller handles tasks and responds to
    external and internal events.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 中断是计算中的基本概念。它们作为管理计算机或微控制器如何处理任务以及如何响应外部和内部事件的一种强大机制。
- en: At its core, an **interrupt** is a signal to the processor from a hardware device
    or an internal software condition that temporarily halts the current operations.
    This signal indicates that immediate attention is required. When the processor
    receives an interrupt, it pauses its current tasks, saves its state, and executes
    a function known as an ISR to address the interrupt. Upon completing the ISR,
    the processor resumes its previous tasks, ensuring that critical signals receive
    prompt and efficient handling.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，**中断**是硬件设备或内部软件条件向处理器发出的信号，该信号暂时中止当前操作。此信号表明需要立即关注。当处理器收到中断时，它会暂停当前任务，保存其状态，并执行一个称为ISR（中断服务例程）的功能来处理中断。完成ISR后，处理器恢复其先前任务，确保关键信号得到及时和有效的处理。
- en: '*What are the types* *of interrupts?*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*中断有哪些类型*？'
- en: 'We can broadly classify interrupts into two categories: hardware interrupts
    and software interrupts:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将中断大致分为两类：硬件中断和软件中断：
- en: '**Hardware interrupts**: These originate from external devices, such as switches,
    network adapters, or any peripheral that needs to communicate with the processor.
    For example, pressing a push button may trigger a hardware interrupt that informs
    the processor to start a motor.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件中断**：这些中断来源于外部设备，例如开关、网络适配器或任何需要与处理器通信的外围设备。例如，按下按钮可能会触发一个硬件中断，通知处理器启动电机。'
- en: '**Software interrupts**: Unlike hardware interrupts, software interrupts are
    triggered by software instructions. These are used by programs to interrupt the
    current process flow and execute a specific routine.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件中断**：与硬件中断不同，软件中断是由软件指令触发的。这些中断被程序用来中断当前进程流程并执行特定的例程。'
- en: '*What is the role of the interrupt* *vector table?*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*中断向量表的作用是什么*？'
- en: The interrupt vector table serves as an essential lookup table, guiding the
    processor to the correct ISR for each interrupt. An ISR is simply a function designed
    to address and manage the specific needs triggered by an interrupt. The table
    itself is **organized as an array of pointers**, with each pointer directing the
    system to the designated ISR for a given interrupt. Upon the occurrence of an
    interrupt, the system references this table to locate the exact memory address
    of the ISR required for handling the interrupt. This efficient mechanism enables
    the system to promptly respond to various events, such as external inputs, timer
    expirations, and changes in the internal state.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 中断向量表作为一个基本查找表，指导处理器找到每个中断的正确ISR。ISR只是一个设计用来处理和管理由中断触发的特定需求的函数。该表本身**组织为一个指针数组**，每个指针将系统指向给定中断的指定ISR。当发生中断时，系统引用此表以定位处理中断所需的ISR的确切内存地址。这种高效机制使系统能够迅速响应各种事件，例如外部输入、计时器超时和内部状态的变化。
- en: With this in mind, we are finally ready to write our linker script.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们终于准备好编写链接脚本了。
- en: Writing the linker script
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写链接脚本
- en: In our workspace folder, let’s make a new folder named `3_LinkerscriptAndStartup`.
    In this folder, create a file called `stm32_ls.ld` and make sure its extension
    is `.ld`. If you’re using Windows and it asks if you really want to change the
    file extension, click **Yes**. Then, right-click the file and open it with a basic
    text editor such as Notepad++.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工作区文件夹中，让我们创建一个名为 `3_LinkerscriptAndStartup` 的新文件夹。在这个文件夹中，创建一个名为 `stm32_ls.ld`
    的文件，并确保其扩展名为 `.ld`。如果你使用的是 Windows，并且它询问你是否真的想要更改文件扩展名，请点击 **是**。然后，右键单击文件，使用基本文本编辑器（如
    Notepad++）打开它。
- en: 'Our objectives with the linker script can be summarized as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用链接脚本的目标可以总结如下：
- en: Specifying the firmware’s entry point
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定固件的入口点
- en: Detailing the available memory
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细说明可用内存
- en: Specifying the necessary heap and stack sizes
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定必要的堆和栈大小
- en: Defining output sections
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义输出部分
- en: 'This is our complete linker script, the contents of the `stm32_ls.ld` file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的完整链接脚本，`stm32_ls.ld` 文件的内容：
- en: '[PRE17]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s break it down.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解。
- en: Specifying the firmware’s entry point
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定固件的入口点
- en: '[PRE18]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we learned earlier, the `ENTRY` directive specifies the entry point of the
    firmware, which is the first piece of code that gets executed when the firmware
    starts. In this case, the entry point is the function named `Reset_Handler`. We
    shall implement this function in the startup file.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，`ENTRY` 指令指定了固件的入口点，这是当固件启动时首先执行的代码片段。在这种情况下，入口点是名为 `Reset_Handler`
    的函数。我们将在启动文件中实现此函数。
- en: Detailing the available memory
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详细说明可用内存
- en: '[PRE19]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our script specifies two memory regions: `FLASH` and `SRAM`. The `FLASH` memory,
    with read and execute permissions (`rx`), starts at the `0x08000000` address and
    has a length of `512K`. The SRAM memory, with read, write, and execute permissions
    (`rwx`), starts at the `0x20000000` address and has a length of `128K`.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本指定了两个内存区域：`FLASH` 和 `SRAM`。具有读和执行权限 (`rx`) 的 `FLASH` 内存从 `0x08000000` 地址开始，长度为
    `512K`。具有读、写和执行权限 (`rwx`) 的 `SRAM` 内存从 `0x20000000` 地址开始，长度为 `128K`。
- en: Symbol creation
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号创建
- en: '[PRE20]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Over here, we create a symbol called `_estack` and we set it to the end of the
    `SRAM` memory region. We will use this symbol to initialize the stack pointer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个名为 `_estack` 的符号，并将其设置为 `SRAM` 内存区域的末尾。我们将使用此符号来初始化栈指针。
- en: The `SRAM` ensures that it starts at the maximum available address, utilizing
    the `SRAM` space efficiently for stack operations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`SRAM` 确保它从最大可用地址开始，有效地利用 `SRAM` 空间进行栈操作。'
- en: The next lines of code in our linker script specify the heap and stack sizes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链接脚本中的下一行代码指定了堆和栈的大小。
- en: Specifying the necessary heap and stack sizes
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定必要的堆和栈大小
- en: '[PRE21]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These lines define the maximum sizes for the heap (`0x200` bytes) and stack
    (`0x400` bytes). These sizes are important for dynamic memory allocation and function
    call management, respectively.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行定义了堆的最大大小（`0x200` 字节）和栈的大小（`0x400` 字节）。这些大小对于动态内存分配和函数调用管理分别很重要。
- en: The next segment defines the output sections.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分定义了输出部分。
- en: Defining output sections
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义输出部分
- en: In this section, we will go through the output sections.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍输出部分。
- en: The .text output section
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`.text` 输出部分'
- en: 'This segment of our linker script shows the `.text` output section:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链接脚本中的这一部分显示了 `.text` 输出部分：
- en: '[PRE22]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s break it down:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解：
- en: '`. =` `ALIGN(4);`:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`. =` `ALIGN(4);`:'
- en: This directive aligns the start of the `.text` section on a `4`-byte boundary.
    This enhances memory access efficiency, which is a critical consideration for
    processors fetching instructions in word-sized chunks.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此指令将 `.text` 部分的起始位置对齐到 `4` 字节边界。这提高了内存访问效率，这对于以字大小块获取指令的处理器来说是一个关键考虑因素。
- en: '`*(.``isr_vector_tbl)` :'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*(.``isr_vector_tbl)` :'
- en: This directive pulls in all sections named `.isr_vector_tbl` from the input
    files into the current location in the `.``text` section.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此指令将输入文件中所有名为 `.isr_vector_tbl` 的部分拉入当前 `.text` 部分的当前位置。
- en: '`*(.``text)`:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*(.``text)`:'
- en: This directive pulls in all sections named `.text` from the input files into
    the current location in the `.``text` section.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此指令将输入文件中所有名为 `.text` 的部分拉入当前 `.text` 部分的当前位置。
- en: '`*(.``rodata)`:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*(.``rodata)`:'
- en: This directive pulls in all sections named `.rodata` from the input files into
    the current location in the `.``text` section.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此指令将输入文件中所有名为 `.rodata` 的部分拉入当前 `.text` 部分的当前位置。
- en: '`. =` `ALIGN(4);`:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`. =` `ALIGN(4);`:'
- en: Again, this line ensures that the end of the section is aligned to a `4`-byte
    boundary. Over here, we use it to align the end of a section, ensuring that the
    next section starts on an aligned boundary.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，这行代码确保了段的末尾对齐到 `4` 字节边界。在这里，我们使用它来对齐段的末尾，确保下一个段从对齐的边界开始。
- en: '`_etext = .;`:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_etext = .;`:'
- en: Over here, we define a symbol called `_etext` at the current location. This
    symbol marks the end of the `.text` section. We will use this symbol as a pointer
    to the end of the `.text` section in our startup file.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们在当前位置定义了一个名为 `_etext` 的符号。这个符号标记了 `.text` 段的结束。我们将在启动文件中将此符号用作 `.text`
    段结束的指针。
- en: '`}>``FLASH`:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`}>``FLASH`:'
- en: This directive specifies that the `.text` section should be placed in the `FLASH`
    memory segment as defined earlier in the `MEMORY` block of the linker script.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个指令指定 `.text` 段应放置在之前在链接脚本的 `MEMORY` 块中定义的 `FLASH` 内存段中。
- en: 'This segment shows the `.data` output section:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分显示了 `.data` 输出段：
- en: '[PRE23]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s break it down:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`=` `ALIGN(4);`:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=` `ALIGN(4);`:'
- en: This directive aligns the start of the `.data` section on a `4`-byte boundary.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个指令将 `.data` 段的开始对齐到 `4` 字节边界。
- en: '`_sdata = .;`:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_sdata = .;`:'
- en: Over here, we create a symbol named `_sdata` to represent the start of the `.data`
    section by setting it to the current location counter. We will use this symbol
    as a pointer to the start of the `.data` section in our startup file.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个名为 `_sdata` 的符号来表示 `.data` 段的开始，通过将其设置为当前位置计数器。我们将在启动文件中将此符号用作 `.data`
    段开始的指针。
- en: '`*(.``data)`:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*(.``data)`:'
- en: This directive pulls in all sections named `.data` from the input files into
    the current location in the `.``data` section.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个指令将所有名为 `.data` 的段从输入文件中拉入当前 `.data` 段的位置。
- en: '`. =` `ALIGN(4);`:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`. =` `ALIGN(4);`:'
- en: This line ensures that the end of the section is aligned to a `4`-byte boundary.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码确保了段的末尾对齐到 `4` 字节边界。
- en: '`_edata= .;`:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_edata= .;`:'
- en: Similar to what we have done previously, we create a symbol named `_edata` to
    represent the end of the `.data` section by setting it to the current location
    counter. We will use this symbol in our startup file.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与我们之前所做的一样，我们创建一个名为 `_edata` 的符号来表示 `.data` 段的末尾，通过将其设置为当前位置计数器。我们将在启动文件中使用此符号。
- en: '`> SRAM` `AT> FLASH`:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`> SRAM` `AT> FLASH`:'
- en: This directive specifies the LMA and the VMA of the `.``data` section.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个指令指定 `.data` 段的 LMA 和 VMA。
- en: '`> SRAM` indicates that the section should be located in SRAM, allowing read
    and write access at runtime.'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`> SRAM` 表示该段应位于 SRAM 中，允许在运行时进行读写访问。'
- en: '`AT> FLASH` tells the linker that although the section is placed in `SRAM`
    for execution, its initial values should be stored in `FLASH`.'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AT> FLASH` 告诉链接器，尽管该段放置在 `SRAM` 中以执行，但其初始值应存储在 `FLASH` 中。'
- en: 'This segment shows the `.bss` output section:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分显示了 `.bss` 输出段：
- en: '[PRE24]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the final output section of our linker script.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的链接脚本的最终输出段。
- en: As we learned earlier, the `.bss` section holds uninitialized global and static
    variables that we will be initialized to zero in our startup file. This zero-initialization
    ensures that all variables in this section begin with a known state, contributing
    to our firmware’s stability and predictability.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，`.bss` 段包含未初始化的全局和静态变量，这些变量将在我们的启动文件中初始化为零。这种零初始化确保了本节中所有变量都以已知状态开始，有助于提高我们固件的稳定性和可预测性。
- en: Similar to other sections, we begin by aligning the section to a `4`-byte boundary
    for efficient memory access, and then we define the `_sbss` and `_ebss` symbols
    to mark the start and end of the section, respectively. These symbols facilitate
    the calculation of the section’s size and its initialization process. Finally,
    we place the section in the SRAM, emphasizing that, although it doesn’t occupy
    space in the binary file on disk, it requires runtime allocation in memory.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他段类似，我们首先将段对齐到 `4` 字节边界以提高内存访问效率，然后定义 `_sbss` 和 `_ebss` 符号分别标记段的开始和结束。这些符号有助于计算段的大小及其初始化过程。最后，我们将段放置在
    SRAM 中，强调虽然它不会在磁盘上的二进制文件中占用空间，但在运行时需要内存分配。
- en: With our linker script finalized, we’ll move on to implementing the startup
    file. This shall be the focus of the next section.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的链接脚本最终确定后，我们将继续实现启动文件。这将是下一节的重点。
- en: Writing the startup file
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写启动文件
- en: The startup file is essential for initializing the firmware and it performs
    several critical tasks to ensure the system operates correctly from the moment
    it is powered on.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 启动文件对于初始化固件至关重要，它执行了几个关键任务以确保系统从上电的那一刻起就能正确运行。
- en: 'These tasks include the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务包括以下内容：
- en: '**Implementing the vector table**: This involves defining the vector table
    that maps interrupts to their handlers, ensuring the system can respond to various
    events efficiently.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现向量表**：这涉及到定义将中断映射到其处理程序的向量表，确保系统可以高效地响应各种事件。'
- en: '**Creating interrupt handlers**: For each interrupt listed in the vector table,
    an interrupt handler must be implemented to define how the system responds to
    that particular event.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建中断处理程序**：对于向量表中列出的每个中断，必须实现一个中断处理程序来定义系统如何响应该特定事件。'
- en: '`Reset_Handler`, as specified in the linker script, which acts as the initial
    entry point of the firmware. This function is executed immediately after reset
    and is responsible for setting up the environment for the main application.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reset_Handler`，如链接脚本中指定的，作为固件的初始入口点。这个函数在复位后立即执行，并负责为主应用程序设置环境。'
- en: '`.data` section from `FLASH` to `SRAM`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`.data`部分从`FLASH`复制到`SRAM`。
- en: '`.bss` section to zero, ensuring that all uninitialized global and static variables
    start with a known state for reliable operation.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`.bss`部分清零，确保所有未初始化的全局和静态变量都以已知状态开始，以保证可靠的运行。
- en: In the current folder containing the linker script, create a file called `stm32f411_startup.c`
    and make sure its extension is `.c`. If you’re using Windows and it asks if you
    really want to change the file extension, click **Yes**. Then, right-click the
    file and open it with a basic text editor such as Notepad++.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含链接脚本的当前文件夹中，创建一个名为`stm32f411_startup.c`的文件，并确保其扩展名为`.c`。如果您使用Windows并且它询问您是否真的想要更改文件扩展名，请点击**是**。然后，右键单击文件，使用基本文本编辑器（如Notepad++）打开它。
- en: Let’s analyze the complete startup code.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析完整的启动代码。
- en: 'The following is our complete startup code written in C, the contents of the
    `stm32f411_startup.c` file. In the following snippet, we are not showing all the
    function prototypes of all the interrupts in the vector table. The complete source
    code can be found in the resources accompanying the book:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们用C语言编写的完整启动代码，`stm32f411_startup.c`文件的内容。在以下代码片段中，我们没有显示向量表中所有中断的所有函数原型。完整的源代码可以在本书的资源中找到：
- en: '[PRE25]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s break it down.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解。
- en: We start by declaring external symbols.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明外部符号。
- en: External symbol declarations
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部符号声明
- en: '[PRE26]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These lines declare the external symbols that we defined in the linker script.
    Each symbol represents an important memory address used during the startup process:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行声明了我们在链接脚本中定义的外部符号。每个符号代表在启动过程中使用的具有重要内存地址：
- en: '`_estack`: This is the initial top of the stack. This value is loaded into
    the main stack pointer register early in the startup process.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_estack`：这是堆栈的初始顶部。这个值在启动过程中早期被加载到主堆栈指针寄存器中。'
- en: '`_etext:` This marks the end of the executable code section and the beginning
    of the data sections stored in flash memory. We use this as a reference point
    for copying initialized data from `FLASH` to `SRAM`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_etext`：这标志着可执行代码部分的结束和存储在闪存中的数据部分的开始。我们使用这个作为从`FLASH`到`SRAM`复制初始化数据的参考点。'
- en: '`_sdata` and `_edata` represent the start and end addresses of the initialized
    data section in SRAM, respectively. We use them to determine the size and destination
    for data copying from `FLASH` to `RAM`.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_sdata`和`_edata`分别代表SRAM中初始化数据段的起始和结束地址。我们使用它们来确定从`FLASH`到`RAM`的数据复制的尺寸和目的地。'
- en: '`_sbss` and `_ebss` mark the start and end of the uninitialized data section
    (BSS section) in SRAM. We use these symbols to clear this section, setting it
    to zero.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_sbss`和`_ebss`标记SRAM中未初始化数据段（BSS段）的起始和结束。我们使用这些符号来清除此部分，将其设置为零。'
- en: Next in our snippet, we have the function prototypes and their attributes.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码片段中接下来，我们有函数原型及其属性。
- en: Function prototypes and attributes
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数原型和属性
- en: '[PRE27]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At this part of the startup file, we declare the prototype for the `Reset_Handler`
    function, the application’s `main` function, and several interrupt handlers with
    specific attributes:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动文件的这部分，我们声明了`Reset_Handler`函数的原型、应用程序的`main`函数以及具有特定属性的几个中断处理程序：
- en: '`__attribute__((weak, alias("Default_Handler"))):` This attribute makes each
    handler weakly linked and aliases it to a function named `Default_Handler`. It
    allows these handlers to be overridden by explicitly defined handlers with the
    same name elsewhere in the application.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`__attribute__((weak, alias("Default_Handler"))):` 这个属性使得每个处理程序具有弱链接，并将其别名为名为
    `Default_Handler` 的函数。它允许这些处理程序被显式定义的其他地方具有相同名称的处理程序覆盖。'
- en: 'Let’s break down the statement further to understand its significance:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步分解这个语句以了解其重要性：
- en: '`__attribute__`:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__attribute__`:'
- en: We use this keyword to tell the compiler that the declaration it’s applied to
    has certain properties that affect how it’s treated by the linker and, potentially,
    at runtime. Attributes can be used to control optimizations, code generation,
    alignment, and, relevant to our discussion, linkage characteristics.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用这个关键字来告诉编译器，它应用到的声明具有某些属性，这些属性会影响链接器以及可能运行时对其的处理。属性可以用来控制优化、代码生成、对齐，以及与我们讨论相关，链接特性。
- en: '`weak`:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weak`:'
- en: Declaring a function or variable as `weak` means that it does not prevent the
    linker from using another symbol of the same name with a stronger linkage. We
    use this to specify default implementations that can be overridden.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将函数或变量声明为 `weak` 意味着它不会阻止链接器使用具有相同名称的具有更强链接的另一个符号。我们使用此来指定可以覆盖的默认实现。
- en: In the context of our interrupt handlers, marking them as `weak` allows us to
    define default handlers in our startup file, which application-specific handlers
    can override without modifying the startup file.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的中断处理程序上下文中，将它们标记为 `weak` 允许我们在启动文件中定义默认处理程序，而应用特定的处理程序可以在不修改启动文件的情况下覆盖这些默认处理程序。
- en: '`alias("Default_Handler")`:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alias("Default_Handler")`:'
- en: This part of the attribute creates an alias for another symbol, in this case,
    `Default_Handler`. It means that the symbol (e.g., `NMI_Handler`) is not just
    weak, but it is also an alias for the `Default_Handler` function.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这部分属性为另一个符号创建了一个别名，在本例中为 `Default_Handler`。这意味着符号（例如，`NMI_Handler`）不仅具有弱链接，而且它也是
    `Default_Handler` 函数的别名。
- en: This means that when an interrupt occurs, and a specific handler (such as `NMI_Handler`)
    has not been defined elsewhere in the application with stronger linkage (non-weak),
    the program will use `Default_Handler` in its place. This ensures that all interrupts
    have a handler, preventing the system from crashing due to unhandled events.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着当发生中断，并且没有在其他地方（例如，`NMI_Handler`）定义具有更强链接（非弱链接）的特定处理程序时，程序将使用 `Default_Handler`
    来代替。这确保了所有中断都有一个处理程序，防止系统因未处理的事件而崩溃。
- en: Next, we have the vector table array.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有向量表数组。
- en: Vector table definition
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量表定义
- en: '[PRE28]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This array defines the microcontroller’s interrupt vector table, placed in the
    `.isr_vector_tbl` section we defined in the linker script.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组定义了微控制器的中断向量表，放置在我们定义在链接脚本中的 `.isr_vector_tbl` 部分。
- en: We set the `&_estack` symbol as the first element of the vector table to define
    the initial top of the stack in memory. In ARM Cortex microcontrollers, such as
    our STM32F411, the first word (32 bits) of the vector table must contain the initial
    value of the **main stack pointer** (**MSP**). Upon reset, the processor loads
    this value into the MSP register to set up the stack pointer correctly before
    executing any code.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `_estack` 符号设置为向量表的第一个元素，以定义内存中堆栈的初始顶部。在 ARM Cortex 微控制器中，例如我们的 STM32F411，向量表的第一字（32位）必须包含
    **主堆栈指针**（**MSP**）的初始值。在复位时，处理器将此值加载到 MSP 寄存器中，以便在执行任何代码之前正确设置堆栈指针。
- en: Following this, we specify the address of `Reset_Handler`, then we proceed to
    list the addresses for `NMI_Handler` and other subsequent interrupt handlers in
    sequence. The precise placement of these handlers is crucial, as each must reside
    in a specific memory location to ensure correct functionality. This arrangement
    is detailed on *page 201* of the RM0383 document. Within the fully defined vector
    table in our `stm32f411_startup.c` file, you’ll notice that there are zeros strategically
    placed among the interrupt handler addresses. These zeros act as placeholders
    for the positions corresponding to interrupts not supported by our specific microcontroller
    variant (STM32F411). The ARM Cortex-M core architecture is designed to support
    a comprehensive set of interrupts, yet not all interrupts are implemented across
    every microcontroller variant. By inserting zeros for these unsupported interrupts
    in the vector table, we maintain the required alignment with the architecture’s
    specifications, ensuring the system operates correctly.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定 `Reset_Handler` 的地址，然后我们继续按顺序列出 `NMI_Handler` 和其他后续中断处理程序的地址。这些处理程序的精确放置至关重要，因为每个处理程序都必须位于特定的内存位置，以确保正确功能。这种安排在
    RM0383 文档的第 *201* 页上有详细说明。在我们的 `stm32f411_startup.c` 文件中定义的完整向量表中，您会注意到在中断处理程序地址之间有策略地放置了零。这些零作为不支持我们特定微控制器变体（STM32F411）的中断位置的占位符。ARM
    Cortex-M 内核架构旨在支持一套全面的中断，但并非所有中断都在每个微控制器变体中实现。通过在向量表中插入这些不支持的中断的零，我们保持与架构规范的必要对齐，确保系统正确运行。
- en: 'Let’s take a closer look at the array declaration:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看数组声明：
- en: '[PRE29]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`uint32_t vector_tbl[]`:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint32_t vector_tbl[]`：'
- en: This specifies that each element of the `vector_tbl` array is an unsigned 32-bit
    integer. We chose this type because addresses in ARM Cortex-M microcontrollers
    are 32 bits in length, and the vector table consists of memory addresses pointing
    to the start of ISR handlers.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这指定了 `vector_tbl` 数组的每个元素都是一个无符号 32 位整数。我们选择此类型是因为 ARM Cortex-M 微控制器的地址长度为 32
    位，而向量表由指向 ISR 处理程序起始地址的内存地址组成。
- en: '`__attribute__((section(".isr_vector_tbl")))`:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__attribute__((section(".isr_vector_tbl")))`：'
- en: This attribute instructs the linker to place the `vector_tbl` array in a specific
    section of the output file named `.isr_vector_tbl`.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此属性指示链接器将 `vector_tbl` 数组放置在名为 `.isr_vector_tbl` 的输出文件特定部分。
- en: Next, we have our default handler function.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的默认处理程序函数。
- en: Default dandler
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认处理程序
- en: '[PRE30]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function serves as a universal fallback for any interrupt request for which
    a specific handler has not been implemented. Engaging in an infinite loop effectively
    prevents the program from proceeding into an undefined state following such an
    event.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数作为任何未实现特定处理程序的中断请求的通用回退。在无限循环中操作实际上防止了程序在发生此类事件后进入未定义状态。
- en: It is linked to all interrupt handlers marked as `weak` and aliased to `Default_Handler`
    within the application. This strategy ensures a uniform and secure response throughout
    the system to any interrupt requests that lack a dedicated handler, thus upholding
    system stability and integrity.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 它链接到所有标记为 `weak` 的中断处理程序，并在应用程序中别名 `Default_Handler`。此策略确保系统对任何缺乏专用处理程序的中断请求做出统一和安全的响应，从而维护系统稳定性和完整性。
- en: Finally, we have our `Reset_Handler` function.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们的 `Reset_Handler` 函数。
- en: Reset handler implementation
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置处理程序实现
- en: '[PRE31]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The job of `Reset_Handler` is to prepare the system before executing the main
    application.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reset_Handler` 的任务是准备系统，以便执行主应用程序。'
- en: 'In the function, we start by calculating the sizes of the `.data` and `.``bss`
    sections:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，我们首先计算 `.data` 和 `.bss` 部分的大小：
- en: '[PRE32]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is a breakdown:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是分解：
- en: Calculate the size of the `.data` section by subtracting the address of the
    start of the section (`_sdata`) from the address of the end (`_edata`). This size
    is used to copy initialized data from `FLASH` to `SRAM`.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从 `.data` 部分的起始地址 (`_sdata`) 减去结束地址 (`_edata`) 来计算 `.data` 部分的大小。此大小用于将初始化数据从
    `FLASH` 复制到 `SRAM`。
- en: Calculate the size of the `.bss` section in a similar manner, using the start
    (`_sbss`) and end (`_ebss`) addresses. This size is used to zero out the `.bss`
    section in SRAM.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以类似的方式计算 `.bss` 部分的大小，使用起始地址 (`_sbss`) 和结束地址 (`_ebss`)。此大小用于在 SRAM 中清除 `.bss`
    部分。
- en: 'Next, in the function, we initialize pointers for copying the `.``data` section:'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，在函数中，我们初始化指针以复制 `.data` 部分：
- en: '[PRE33]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the breakdown:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是分解：
- en: Initialize a source pointer (`p_src_mem`) to the address where initialized data
    is stored in flash memory, marked by `_etext`.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源指针 (`p_src_mem`) 初始化为存储在闪存中初始化数据的地址，标记为 `_etext`。
- en: Initialize a destination pointer (`p_dest_mem`) to the start of the `.data`
    section in SRAM (`_sdata`).
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将目标指针 (`p_dest_mem`) 初始化为 SRAM 中 `.data` 部分的开始 (`_sdata`)。
- en: 'Then, we copy the `.data` section from `FLASH` to `SRAM`:'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们复制 `FLASH` 中的 `.data` 部分到 `SRAM`：
- en: '[PRE34]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The breakdown:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 分解：
- en: Copy the `.data` section from `FLASH` to `SRAM` word (32-bit) by word. For each
    iteration, the content pointed to by `p_src_mem` is copied to the location pointed
    to by `p_dest_mem`, and then both pointers are incremented to the next word.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过字（32 位）将 `.data` 部分从 `FLASH` 复制到 `SRAM`。对于每次迭代，`p_src_mem` 指向的内容被复制到 `p_dest_mem`
    指向的位置，然后两个指针都增加到下一个字。
- en: 'Next, we initialize the pointer for the `.bss` section zeroing:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化 `.bss` 部分的指针为零：
- en: '[PRE35]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We simply reset the destination pointer (`p_dest_mem`) to the start of the `.bss`
    section in SRAM (`_sbss`), preparing it for zeroing.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地重置目标指针 (`p_dest_mem`) 到 SRAM 中 `.bss` 部分的开始 (`_sbss`），为清零做准备。
- en: 'We then zero out the `.``bss` section:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将 `.bss` 部分清零：
- en: '[PRE36]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This block zeroes out the `.bss` section in `SRAM` word by word. For each iteration,
    the location pointed to by `p_dest_mem` is set to `0`, and then `p_dest_mem` is
    incremented to the next word.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 此块逐字将 `.bss` 部分在 `SRAM` 中清零。对于每次迭代，`p_dest_mem` 指向的位置被设置为 `0`，然后 `p_dest_mem`
    增加到下一个字。
- en: 'Finally, we call the `main()` function located in the `main.c` file of our
    source code:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用位于源代码 `main.c` 文件中的 `main()` 函数：
- en: '[PRE37]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After initializing the `.data` and `.bss` sections, this line calls the `main`
    function, transferring control to the main application code. This marks the end
    of the system initialization process and the beginning of the application execution.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 `.data` 和 `.bss` 部分后，此行调用 `main` 函数，将控制权转移到主应用程序代码。这标志着系统初始化过程的结束和应用程序执行的开始。
- en: Now that we have completed both our linker script and startup file, it is time
    to test our implementation by building the firmware using just our `main.c` source
    file, the `stm32_ls.ld` linker script, and the `stm32f411_startup.c` startup file.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的链接脚本和启动文件，是时候通过仅使用我们的 `main.c` 源文件、`stm32_ls.ld` 链接脚本和 `stm32f411_startup.c`
    启动文件来构建固件，以测试我们的实现了。
- en: Testing our linker script and startup file
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的链接脚本和启动文件
- en: 'Before diving into the command line, it’s important to ensure that our linker
    script and startup file are correctly placed. Let’s set up our project directory
    and add some modification to our `main.c` file:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入命令行之前，确保我们的链接脚本和启动文件放置正确非常重要。让我们设置我们的项目目录并对我们的 `main.c` 文件进行一些修改：
- en: '`3_LinkerAndStartup` in your workspace.'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的工作空间中找到 `3_LinkerAndStartup`。
- en: '`main.c` file from the previous project (`2_RegisterManipulation`), which includes
    the foundational application code.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个项目（`2_RegisterManipulation`）的 `main.c` 文件，其中包含基础应用程序代码。
- en: Additionally, locate `stm32_ls.ld` (linker script) and `stm32f411_startup.c`
    (startup file).
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，找到 `stm32_ls.ld`（链接脚本）和 `stm32f411_startup.c`（启动文件）。
- en: Copy and paste these files (`stm32_ls.ld, stm32f411_startup.c`, and `main.c`)
    into the `3_LinkerAndStartup` folder.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些文件（`stm32_ls.ld`、`stm32f411_startup.c` 和 `main.c`）复制粘贴到 `3_LinkerAndStartup`
    文件夹中。
- en: '`main.c` file from fast to slow:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从快到慢地查看 `main.c` 文件：
- en: '`main.c` file within the `3_LinkerAndStartup` folder and select the option
    to open it with a simple text editor, such as Notepad++.'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `3_LinkerAndStartup` 文件夹中找到 `main.c` 文件并选择使用简单的文本编辑器，如 Notepad++ 打开它。
- en: '`LED_PIN`). Adjust the delay intervals within this section to change the LED’s
    blink rate from its current rapid pace to a slower one. The current one should
    look like this:'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （LED_PIN）。调整此部分中的延迟间隔以改变 LED 的闪烁速率，从当前的快速速度变为较慢的速度。当前的一个应该看起来像这样：
- en: '[PRE38]'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Replace the current code with the following snippet to toggle the state of
    PA5 at a slower rate:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将当前代码替换为以下片段以以较慢的速度切换 PA5 的状态：
- en: '[PRE39]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let’s access our new folder through the Command Prompt following the steps
    we learned in [*Chapter 3*](B21914_03.xhtml#_idTextAnchor080). My favorite method
    for Windows users is the context menu method:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过我们学到的步骤使用命令提示符访问我们的新文件夹[*第 3 章*](B21914_03.xhtml#_idTextAnchor080)。Windows
    用户最喜欢的方 法是上下文菜单方法：
- en: Navigate to the `3_LinkerAndStartup` folder in Windows Explorer. Once there,
    hold down the *Shift* key, *right-click* in a space within the folder, and select
    `3_LinkerAndStartup` folder.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 资源管理器中导航到 `3_LinkerAndStartup` 文件夹。一旦到达那里，按住 *Shift* 键，在文件夹内的空白处 *右键单击*，然后选择
    `3_LinkerAndStartup` 文件夹。
- en: 'In the Command Prompt, we start by compiling the `main.c` file, and we do this
    by executing the following:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符中，我们首先编译 `main.c` 文件，我们通过执行以下命令来完成：
- en: '[PRE40]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we execute our startup file:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行启动文件：
- en: '[PRE41]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once our `main.o` and `stm32f411_startup.o` object files are ready, we go ahead
    and link all object files (`*.o`) using our linker script:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的 `main.o` 和 `stm32f411_startup.o` 对象文件准备就绪，我们就使用我们的链接脚本链接所有对象文件 (`*.o`)：
- en: '[PRE42]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This process produces the `3_LinkerAndStartup.elf` executable.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程生成了 `3_LinkerAndStartup.elf` 可执行文件。
- en: 'Next, we launch `openocd` to begin the uploading process:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动 `openocd` 以开始上传过程：
- en: '[PRE43]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With OpenOCD running, the next step involves using the **GNU Debugger** (**GDB**)
    to upload the firmware to the microcontroller. Let’s access another Command Prompt
    window (as OpenOCD should keep running in the first one) and enter the following
    command to start the GDB:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 OpenOCD 的运行，下一步涉及使用 **GNU 调试器** (**GDB**) 将固件上传到微控制器。让我们打开另一个命令提示符窗口（因为 OpenOCD
    应该在第一个窗口中继续运行）并输入以下命令以启动 GDB：
- en: '[PRE44]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once GDB is open, we establish a connection to our microcontroller by running:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 GDB 打开，我们通过运行以下命令来与我们的微控制器建立连接：
- en: '[PRE45]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s reset and initialize the board as we learned in [*Chapter 3*](B21914_03.xhtml#_idTextAnchor080)
    using the following command:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令重置和初始化板子，就像我们在 [*第 3 章*](B21914_03.xhtml#_idTextAnchor080) 中学习的那样：
- en: '[PRE46]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we load the firmware onto the microcontroller using the following command:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下命令将固件加载到微控制器上：
- en: '[PRE47]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After successfully loading the firmware, we reset the board again with the
    same reset command:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 成功加载固件后，我们再次使用相同的复位命令来重置板子：
- en: '[PRE48]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we resume the execution of the firmware on the microcontroller with
    the following:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令在微控制器上恢复固件的执行：
- en: '[PRE49]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There you have it; you should see the LED blinking at a slower rate, indicating
    the successful upload and execution of our new firmware.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；你应该会看到 LED 以较慢的速度闪烁，这表明新固件的成功上传和执行。
- en: Summary
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we deeply explored the core components of embedded bare-metal
    programming, focusing on the microcontroller’s memory model, writing linker scripts,
    and startup files. We began by exploring the STM32 microcontroller’s memory layout,
    emphasizing the importance of flash memory and SRAM for storing executable code
    and runtime data.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了嵌入式裸机编程的核心组件，重点关注微控制器的内存模型、编写链接脚本和启动文件。我们首先探索了 STM32 微控制器的内存布局，强调了闪存和
    SRAM 在存储可执行代码和运行时数据方面的重要性。
- en: We then dedicated a significant portion of the chapter to constructing and understanding
    linker scripts. Through this, we understood these scripts’ critical role in the
    firmware build process by mapping the compiled firmware sections to the microcontroller’s
    specific memory regions to ensure the executable operates correctly. We learned
    about the various directives within a linker script, such as `MEMORY` and `SECTIONS`.
    These directives are crucial for defining the memory layout and specifying where
    and how program sections are placed in memory.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节中投入了相当大的篇幅来构建和理解链接脚本。通过这个过程，我们理解了这些脚本在固件构建过程中的关键作用，通过将编译后的固件部分映射到微控制器的特定内存区域，以确保可执行程序正确运行。我们学习了链接脚本中的各种指令，例如
    `MEMORY` 和 `SECTIONS`。这些指令对于定义内存布局和指定程序部分在内存中的放置位置和方式至关重要。
- en: Our discussion on linker scripts extended to the practicalities of defining
    memory regions, aligning sections, and managing section attributes for optimal
    memory utilization. We gave special attention to the LMA and VMA, which are essential
    for efficient program loading and execution.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于链接脚本的讨论扩展到了定义内存区域、对齐部分和管理部分属性以实现最佳内存利用的实际问题。我们特别关注 LMA 和 VMA，这对于高效的程序加载和执行至关重要。
- en: Transitioning to the startup file, we meticulously outlined the startup file’s
    role, covering the initialization of the vector table, setting up `Reset_Handler`,
    and preparing the system for the execution of the main application. We learned
    the procedures for copying the `.data` section from `FLASH` to `SRAM` and zeroing
    the `.bss` section, ensuring a predictable start for our firmware.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 转到启动文件部分，我们详细阐述了启动文件的作用，包括初始化向量表、设置`Reset_Handler`以及为主应用程序的执行准备系统。我们学习了将`.data`部分从`FLASH`复制到`SRAM`以及清零`.bss`部分的步骤，确保我们的固件有一个可预测的启动。
- en: In the next chapter, we will explore build systems, highlighting the essential
    role of the `Make` tool. This knowledge will enable us to streamline our build
    process by automating it, instead of manually entering each command in the command
    line.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨构建系统，突出`Make`工具的至关重要作用。这一知识将使我们能够通过自动化构建过程来简化我们的构建流程，而不是手动在命令行中输入每个命令。
