- en: Atomic Operations - Working with the Hardware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作-与硬件交互
- en: 'A lot of optimization and thread-safety depends on one''s understanding of
    the underlying hardware: from aligned memory access on some architectures, to
    knowing which data sizes and thus C++ types can be safely addressed without performance
    penalties or the need for mutexes and similar.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很多优化和线程安全取决于对底层硬件的理解：从某些架构上的对齐内存访问，到知道哪些数据大小和因此C++类型可以安全地访问而不会有性能惩罚或需要互斥锁等。
- en: This chapter looks at how one can make use of the characteristics of a number
    of processor architectures in order to, for example, prevent the use of mutexes
    where atomic operations would prevent any access conflicts regardless. Compiler-specific
    extensions such as those in GCC are also examined.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了如何利用多种处理器架构的特性，例如，防止使用互斥锁，而原子操作可以防止任何访问冲突。还考察了诸如GCC中的特定于编译器的扩展。
- en: 'Topics in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主题包括：
- en: The types of atomic operations and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子操作的类型以及如何使用它们
- en: How to target a specific processor architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何针对特定处理器架构进行优化
- en: Compiler-based atomic operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于编译器的原子操作
- en: Atomic operations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作
- en: Briefly put, an atomic operation is an operation which the processor can execute
    with a single instruction. This makes it atomic in the sense that nothing (barring
    interrupts) can interfere with it, or change any variables or data it may be using.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，原子操作是处理器可以用单条指令执行的操作。这使得它在某种意义上是原子的，即除了中断外，没有任何干扰，也不会改变任何变量或数据。
- en: Applications include guaranteeing the order of instruction execution, lock-free
    implementations, and related uses where instruction execution order and memory
    access guarantees are important.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用包括保证指令执行顺序，无锁实现以及指令执行顺序和内存访问保证重要的相关用途。
- en: Before the 2011 C++ standard, the access to such atomic operations as provided
    by the processor was only provided by the compiler, using extensions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在2011年C++标准之前，处理器提供的原子操作的访问仅由编译器使用扩展提供。
- en: Visual C++
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual C++
- en: 'For Microsoft''s MSVC compiler there are the interlocked functions, as summarized
    from the MSDN documentation, starting with the adding features:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微软的MSVC编译器，有原子函数，从MSDN文档总结而来，首先是添加功能：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **原子函数** | **描述** |'
- en: '| `InterlockedAdd` | Performs an atomic addition operation on the specified
    `LONG` values. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedAdd` | 对指定的`LONG`值执行原子加法操作。 |'
- en: '| `InterlockedAddAcquire` | Performs an atomic addition operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedAddAcquire` | 对指定的`LONG`值执行原子加法操作。该操作使用获取内存排序语义执行。 |'
- en: '| `InterlockedAddRelease` | Performs an atomic addition operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedAddRelease` | 对指定的`LONG`值执行原子加法操作。该操作使用释放内存排序语义执行。 |'
- en: '| `InterlockedAddNoFence` | Performs an atomic addition operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers (covered in this chapter). |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedAddNoFence` | 对指定的`LONG`值执行原子加法操作。该操作是原子执行的，但不使用内存屏障（在本章中介绍）。'
- en: These are the 32-bit versions of this feature. There are also 64-bit versions
    of this and other methods in the API. Atomic functions tend to be focused on a
    specific variable type, but variations in this API have been left out of this
    summary to keep it brief.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是该功能的32位版本。API中还有其他方法的64位版本。原子函数往往专注于特定的变量类型，但本摘要中省略了此API的变体，以保持简洁。
- en: We can also see the acquire and release variations. These provide the guarantee
    that the respective read or write access will be protected from memory reordering
    (on a hardware level) with any subsequent read or write operation. Finally, the
    no fence variation (also known as a memory barrier) performs the operation without
    the use of any memory barriers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到获取和释放的变体。这些保证了相应的读取或写入访问将受到内存重排序（在硬件级别）的保护，并且任何后续的读取或写入操作都会受到保护。最后，无屏障变体（也称为内存屏障）在不使用任何内存屏障的情况下执行操作。
- en: Normally CPUs perform instructions (including memory reads and writes) out of
    order to optimize performance. Since this type of behavior is not always desirable,
    memory barriers were added to prevent this instruction reordering.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常CPU执行指令（包括内存读写）是为了优化性能而无序执行的。由于这种行为并不总是理想的，因此添加了内存屏障以防止指令重排序。
- en: 'Next is the atomic `AND` feature:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是原子`AND`功能：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **原子函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `InterlockedAnd` | Performs an atomic `AND` operation on the specified `LONG`
    values. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedAnd` | 对指定的`LONG`值执行原子`AND`操作。 |'
- en: '| `InterlockedAndAcquire` | Performs an atomic `AND` operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedAndAcquire` | 对指定的`LONG`值执行原子`AND`操作。该操作使用获取内存排序语义执行。 |'
- en: '| `InterlockedAndRelease` | Performs an atomic `AND` operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedAndRelease` | 对指定的`LONG`值执行原子`AND`操作。该操作使用释放内存排序语义执行。 |'
- en: '| `InterlockedAndNoFence` | Performs an atomic `AND` operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedAndNoFence` | 对指定的`LONG`值执行原子`AND`操作。该操作是原子执行的，但不使用内存屏障。 |'
- en: 'The bit-test features are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 位测试功能如下：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **原子函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `InterlockedBitTestAndComplement` | Tests the specified bit of the specified
    `LONG` value and complements it. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedBitTestAndComplement` | 测试指定的`LONG`值的指定位并对其进行补码。 |'
- en: '| `InterlockedBitTestAndResetAcquire` | Tests the specified bit of the specified
    `LONG` value and sets it to `0`. The operation is `atomic`, and it is performed
    with acquire memory ordering semantics. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedBitTestAndResetAcquire` | 测试指定`LONG`值的指定位，并将其设置为`0`。该操作是`原子`的，并且使用获取内存排序语义执行。
    |'
- en: '| `InterlockedBitTestAndResetRelease` | Tests the specified bit of the specified
    `LONG` value and sets it to `0`. The operation is `atomic`, and it is performed
    using memory release semantics. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedBitTestAndResetRelease` | 测试指定`LONG`值的指定位，并将其设置为`0`。该操作是`原子`的，并且使用内存释放语义执行。
    |'
- en: '| `InterlockedBitTestAndSetAcquire` | Tests the specified bit of the specified
    `LONG` value and sets it to `1`. The operation is `atomic`, and it is performed
    with acquire memory ordering semantics. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedBitTestAndSetAcquire` | 测试指定`LONG`值的指定位，并将其设置为`1`。该操作是`原子`的，并且使用获取内存排序语义执行。
    |'
- en: '| `InterlockedBitTestAndSetRelease` | Tests the specified bit of the specified
    `LONG` value and sets it to `1`. The operation is `atomic`, and it is performed
    with release memory ordering semantics. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedBitTestAndSetRelease` | 测试指定`LONG`值的指定位，并将其设置为`1`。该操作是`原子`的，并且使用释放内存排序语义执行。
    |'
- en: '| `InterlockedBitTestAndReset` | Tests the specified bit of the specified `LONG`
    value and sets it to `0`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedBitTestAndReset` | 测试指定`LONG`值的指定位，并将其设置为`0`。 |'
- en: '| `InterlockedBitTestAndSet` | Tests the specified bit of the specified `LONG`
    value and sets it to `1`. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedBitTestAndSet` | 测试指定`LONG`值的指定位，并将其设置为`1`。 |'
- en: 'The comparison features can be listed as shown:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 比较特性可以列举如下：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **Interlocked function** | **描述** |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `InterlockedCompareExchange` | Performs an atomic compare-and-exchange operation
    on the specified values. The function compares two specified 32-bit values and
    exchanges with another 32-bit value based on the outcome of the comparison. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedCompareExchange` | 对指定数值执行原子比较和交换操作。该函数比较两个指定的32位数值，并根据比较结果与另一个32位数值进行交换。
    |'
- en: '| `InterlockedCompareExchangeAcquire` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified 32-bit
    values and exchanges with another 32-bit value based on the outcome of the comparison.
    The operation is performed with acquire memory ordering semantics. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedCompareExchangeAcquire` | 对指定数值执行原子比较和交换操作。该函数比较两个指定的32位数值，并根据比较结果与另一个32位数值进行交换。该操作使用获取内存排序语义执行。
    |'
- en: '| `InterlockedCompareExchangeRelease` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified 32-bit
    values and exchanges with another 32-bit value based on the outcome of the comparison.
    The exchange is performed with release memory ordering semantics. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedCompareExchangeRelease` | 对指定数值执行原子比较和交换操作。该函数比较两个指定的32位数值，并根据比较结果与另一个32位数值进行交换。交换是使用释放内存排序语义执行的。
    |'
- en: '| `InterlockedCompareExchangeNoFence` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified 32-bit
    values and exchanges with another 32-bit value based on the outcome of the comparison.
    The operation is performed atomically, but without using memory barriers. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedCompareExchangeNoFence` | 对指定数值执行原子比较和交换操作。该函数比较两个指定的32位数值，并根据比较结果与另一个32位数值进行交换。该操作是原子性的，但不使用内存屏障。
    |'
- en: '| `InterlockedCompareExchangePointer` | Performs an atomic compare-and-exchange
    operation on the specified pointer values. The function compares two specified
    pointer values and exchanges with another pointer value based on the outcome of
    the comparison. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedCompareExchangePointer` | 对指定指针数值执行原子比较和交换操作。该函数比较两个指定的指针数值，并根据比较结果与另一个指针数值进行交换。
    |'
- en: '| `InterlockedCompareExchangePointerAcquire` | Performs an atomic compare-and-exchange
    operation on the specified pointer values. The function compares two specified
    pointer values and exchanges with another pointer value based on the outcome of
    the comparison. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedCompareExchangePointerAcquire` | 对指定指针数值执行原子比较和交换操作。该函数比较两个指定的指针数值，并根据比较结果与另一个指针数值进行交换。该操作使用获取内存排序语义执行。
    |'
- en: '| `InterlockedCompareExchangePointerRelease` | Performs an atomic compare-and-exchange
    operation on the specified pointer values. The function compares two specified
    pointer values and exchanges with another pointer value based on the outcome of
    the comparison. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedCompareExchangePointerRelease` | 对指定指针数值执行原子比较和交换操作。该函数比较两个指定的指针数值，并根据比较结果与另一个指针数值进行交换。该操作使用释放内存排序语义执行。
    |'
- en: '| `InterlockedCompareExchangePointerNoFence` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified pointer
    values and exchanges with another pointer value based on the outcome of the comparison.
    The operation is performed atomically, but without using memory barriers |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedCompareExchangePointerNoFence` | 对指定数值执行原子比较和交换操作。该函数比较两个指定的指针数值，并根据比较结果与另一个指针数值进行交换。该操作是原子性的，但不使用内存屏障。
    |'
- en: 'The decrement features are:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '| 减量特性如下：'
- en: '| **Interlocked function** | **Description** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **Interlocked function** | **描述** |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `InterlockedDecrement` | Decrements (decreases by one) the value of the specified
    32-bit variable as an `atomic` operation. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedDecrement` | 以`原子`操作的方式将指定32位变量的值减少1。 |'
- en: '| `InterlockedDecrementAcquire` | Decrements (decreases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    with acquire memory ordering semantics. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedDecrementAcquire` | 以`原子`操作的方式将指定32位变量的值减少1。该操作使用获取内存排序语义执行。
    |'
- en: '| `InterlockedDecrementRelease` | Decrements (decreases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    with release memory ordering semantics. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedDecrementRelease` | 对指定的32位变量的值进行递减（减少一），作为原子操作。该操作使用释放内存排序语义。
    |'
- en: '| `InterlockedDecrementNoFence` | Decrements (decreases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    atomically, but without using memory barriers. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedDecrementNoFence` | 对指定的32位变量的值进行递减（减少一），作为原子操作。该操作是原子的，但不使用内存屏障。
    |'
- en: 'The exchange (swap) features are:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 交换（交换）功能包括：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **Interlocked function** | **Description** |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `InterlockedExchange` | Sets a 32-bit variable to the specified value as
    an `atomic` operation. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchange` | 将32位变量设置为指定值，作为原子操作。 |'
- en: '| `InterlockedExchangeAcquire` | Sets a 32-bit variable to the specified value
    as an `atomic` operation. The operation is performed with acquire memory ordering
    semantics. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangeAcquire` | 将32位变量设置为指定值，作为原子操作。该操作使用获取内存排序语义。 |'
- en: '| `InterlockedExchangeNoFence` | Sets a 32-bit variable to the specified value
    as an `atomic` operation. The operation is performed atomically, but without using
    memory barriers. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangeNoFence` | 将32位变量设置为指定值，作为原子操作。该操作是原子的，但不使用内存屏障。 |'
- en: '| `InterlockedExchangePointer` | Atomically exchanges a pair of pointer values.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangePointer` | 原子交换一对指针值。 |'
- en: '| `InterlockedExchangePointerAcquire` | Atomically exchanges a pair of pointer
    values. The operation is performed with acquire memory ordering semantics. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangePointerAcquire` | 原子交换一对指针值。该操作使用获取内存排序语义。 |'
- en: '| `InterlockedExchangePointerNoFence` | Atomically exchanges a pair of addresses.
    The operation is performed atomically, but without using memory barriers. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangePointerNoFence` | 原子交换一对地址。该操作是原子的，但不使用内存屏障。 |'
- en: '| `InterlockedExchangeSubtract` | Performs an atomic subtraction of two values.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangeSubtract` | 执行两个值的原子减法。 |'
- en: '| `InterlockedExchangeAdd` | Performs an atomic addition of two 32-bit values.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangeAdd` | 执行两个32位值的原子加法。 |'
- en: '| `InterlockedExchangeAddAcquire` | Performs an atomic addition of two 32-bit
    values. The operation is performed with acquire memory ordering semantics. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangeAddAcquire` | 执行两个32位值的原子加法。该操作使用获取内存排序语义。 |'
- en: '| `InterlockedExchangeAddRelease` | Performs an atomic addition of two 32-bit
    values. The operation is performed with release memory ordering semantics. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangeAddRelease` | 执行两个32位值的原子加法。该操作使用释放内存排序语义。 |'
- en: '| `InterlockedExchangeAddNoFence` | Performs an atomic addition of two 32-bit
    values. The operation is performed atomically, but without using memory barriers.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedExchangeAddNoFence` | 执行两个32位值的原子加法。该操作是原子的，但不使用内存屏障。 |'
- en: 'The increment features are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 增量功能包括：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **Interlocked function** | **Description** |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `InterlockedIncrement` | Increments (increases by one) the value of the specified
    32-bit variable as an `atomic` operation. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedIncrement` | 对指定的32位变量的值进行递增（增加一），作为原子操作。 |'
- en: '| `InterlockedIncrementAcquire` | Increments (increases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    using acquire memory ordering semantics. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedIncrementAcquire` | 使用获取内存排序语义，作为原子操作增加指定32位变量的值（增加一）。 |'
- en: '| `InterlockedIncrementRelease` | Increments (increases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    using release memory ordering semantics. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedIncrementRelease` | 对指定的32位变量的值进行递增（增加一），作为原子操作。该操作使用释放内存排序语义。
    |'
- en: '| `InterlockedIncrementNoFence` | Increments (increases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    atomically, but without using memory barriers. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedIncrementNoFence` | 对指定的32位变量的值进行递增（增加一），作为原子操作。该操作是原子的，但不使用内存屏障。
    |'
- en: 'The `OR` feature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`OR`功能：'
- en: '| **Interlocked function** | **Description** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **Interlocked function** | **Description** |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `InterlockedOr` | Performs an atomic `OR` operation on the specified `LONG`
    values. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedOr` | 对指定的`LONG`值执行原子`OR`操作。 |'
- en: '| `InterlockedOrAcquire` | Performs an atomic `OR` operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedOrAcquire` | 对指定的`LONG`值执行原子`OR`操作。该操作使用获取内存排序语义。 |'
- en: '| `InterlockedOrRelease` | Performs an atomic `OR` operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedOrRelease` | 对指定的`LONG`值执行原子`OR`操作。该操作使用释放内存排序语义。 |'
- en: '| `InterlockedOrNoFence` | Performs an atomic `OR` operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedOrNoFence` | 对指定的`LONG`值执行原子`OR`操作。该操作是原子的，但不使用内存屏障。 |'
- en: 'Finally, the exclusive `OR` (`XOR`) features are:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，独占`OR`（`XOR`）功能包括：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **Interlocked function** | **Description** |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `InterlockedXor` | Performs an atomic `XOR` operation on the specified `LONG`
    values. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedXor` | 对指定的`LONG`值执行原子`XOR`操作。 |'
- en: '| `InterlockedXorAcquire` | Performs an atomic `XOR` operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedXorAcquire` | 对指定的`LONG`值执行原子`XOR`操作。该操作使用获取内存排序语义。 |'
- en: '| `InterlockedXorRelease` | Performs an atomic `XOR` operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedXorRelease` | 对指定的`LONG`值执行原子`XOR`操作。该操作使用释放内存排序语义执行。'
- en: '| `InterlockedXorNoFence` | Performs an atomic `XOR` operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `InterlockedXorNoFence` | 对指定的`LONG`值执行原子`XOR`操作。该操作是原子执行的，但不使用内存屏障。'
- en: GCC
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCC
- en: Like Visual C++, GCC also comes with a set of built-in atomic functions. These
    differ based on the underlying architecture that the GCC version and the standard
    library one uses. Since GCC is used on a considerably larger number of platforms
    and operating systems than VC++, this is definitely a big factor when considering
    portability.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与Visual C++一样，GCC也配备了一组内置的原子函数。这些函数根据所使用的GCC版本和标准库的底层架构而异。由于GCC在比VC++更多的平台和操作系统上使用，这在考虑可移植性时绝对是一个重要因素。
- en: For example, not every built-in atomic function provided on the x86 platform
    will be available on ARM, partially due to architectural differences, including
    variations of the specific ARM architecture. For example, ARMv6, ARMv7, or the
    current ARMv8, along with the Thumb instruction set, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在x86平台上提供的并非每个内置的原子函数都在ARM上可用，部分原因是由于架构差异，包括特定ARM架构的变化。例如，ARMv6、ARMv7或当前的ARMv8，以及Thumb指令集等。
- en: 'Before the C++11 standard, GCC used `__sync-prefixed` extensions for atomics:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11标准之前，GCC使用了`__sync-prefixed`扩展来进行原子操作：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These operations fetch a value from memory and perform the specified operation
    on it, returning the value that was in memory. These all use a memory barrier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作从内存中获取一个值，并对其执行指定的操作，返回内存中的值。这些都使用内存屏障。
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These operations are similar to the first set, except they return the new value
    after the specified operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作与第一组类似，只是它们在指定操作后返回新值。
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These comparison operations will write the new value if the old value matches
    the provided value. The Boolean variation returns true if the new value has been
    written.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比较操作将在旧值匹配提供的值时写入新值。布尔变体在写入新值时返回true。
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function creates a full memory barrier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数创建一个完整的内存屏障。
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method is actually an exchange operation unlike what the name suggests.
    It updates the pointer value and returns the previous value. This uses not a full
    memory barrier, but an acquire barrier, meaning that it does not release the barrier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法实际上是一个交换操作，与名称所示不同。它更新指针值并返回先前的值。这不使用完整的内存屏障，而是使用获取屏障，这意味着它不会释放屏障。
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function releases the barrier obtained by the previous method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数释放前一方法获得的屏障。
- en: 'To adapt to the C++11 memory model, GCC added the `__atomic` built-in methods,
    which also changes the API considerably:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应C++11内存模型，GCC添加了`__atomic`内置方法，这也大大改变了API：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First are the generic load, store, and exchange functions. They are fairly self-explanatory.
    Load functions read a value in memory, store functions store a value in memory,
    and exchange functions swap the existing value with a new value. Compare and exchange
    functions make the swapping conditional.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是通用的加载、存储和交换函数。它们相当容易理解。加载函数读取内存中的值，存储函数将值存储在内存中，交换函数交换现有值和新值。比较和交换函数使交换有条件。
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These functions are essentially the same as in the old API, returning the result
    of the specific operation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数本质上与旧API中的函数相同，返回特定操作的结果。
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And again, the same functions, updated for the new API. These return the original
    value (fetch before operation).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的函数，针对新API进行了更新。这些函数返回操作前的原始值。
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unlike the similarly named function in the old API, this function performs a
    real test and set operation instead of the exchange operation of the old API's
    function, which still requires one to release the memory barrier afterwards. The
    test is for some defined value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与旧API中同名函数不同，该函数执行真正的测试和设置操作，而不是旧API函数的交换操作，后者仍然需要在之后释放内存屏障。测试是针对某个定义的值。
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function clears the pointer address, setting it to `0`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数清除指针地址，将其设置为`0`。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A synchronization memory barrier (fence) between threads can be created using
    this function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该函数可以在线程之间创建同步内存屏障（fence）。
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function creates a memory barrier between a thread and signal handlers
    within that same thread.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在线程和同一线程内的信号处理程序之间创建内存屏障。
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function checks whether objects of the specified size will always create
    lock-free atomic instructions for the current processor architecture.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数检查指定大小的对象是否总是为当前处理器架构创建无锁原子指令。
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is essentially the same as the previous function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上与之前的函数相同。
- en: Memory order
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存顺序
- en: 'Memory barriers (fences) are not always used in the C++11 memory model for
    atomic operations. In the GCC built-in atomics API, this is reflected in the `memorder`
    parameter in its functions. The possible values for this map directly to the values
    in the C++11 atomics API:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11内存模型中，并非总是使用内存屏障（fences）进行原子操作。在GCC内置原子API中，这在其函数的`memorder`参数中反映出来。该参数的可能值直接映射到C++11原子API中的值：
- en: '`__ATOMIC_RELAXED`: Implies no inter-thread ordering constraints.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ATOMIC_RELAXED`：意味着没有线程间排序约束。'
- en: '`__ATOMIC_CONSUME`: This is currently implemented using the stronger `__ATOMIC_ACQUIRE`
    memory order because of a deficiency in C++11''s semantics for `memory_order_consume`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ATOMIC_CONSUME`：由于C++11对`memory_order_consume`的语义存在缺陷，目前使用更强的`__ATOMIC_ACQUIRE`内存顺序来实现。'
- en: '`__ATOMIC_ACQUIRE`: Creates an inter-thread happens-before constraint from
    the release (or stronger) semantic store to this acquire load'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ATOMIC_ACQUIRE`：从释放（或更强）语义存储到此获取加载创建一个线程间happens-before约束'
- en: '`__ATOMIC_RELEASE`: Creates an inter-thread happens-before constraint to acquire
    (or stronger) semantic loads that read from this release store'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ATOMIC_RELEASE`: 创建一个跨线程happens-before约束，以获取（或更强）语义加载以从此释放存储中读取。'
- en: '`__ATOMIC_ACQ_REL`: Combines the effects of both `__ATOMIC_ACQUIRE` and `__ATOMIC_RELEASE`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ATOMIC_ACQ_REL`: 结合了`__ATOMIC_ACQUIRE`和`__ATOMIC_RELEASE`的效果。'
- en: '`__ATOMIC_SEQ_CST`: Enforces total ordering with all other `__ATOMIC_SEQ_CST`
    operations.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ATOMIC_SEQ_CST`: 强制与所有其他`__ATOMIC_SEQ_CST`操作进行完全排序。'
- en: The preceding list was copied from the GCC manual's chapter on atomics for GCC
    7.1\. Along with the comments in that chapter, it makes it quite clear that trade-offs
    were made when implementing both the C++11 atomics support within its memory model
    and in the compiler's implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表是从GCC手册的GCC 7.1原子章节中复制的。连同该章节中的注释，这清楚地表明在实现C++11原子支持以及编译器实现中都做出了权衡。
- en: Since atomics rely on the underlying hardware support, there will never be a
    single piece of code using atomics that will work across a wide variety of architectures.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原子依赖于底层硬件支持，永远不会有一个使用原子的代码能够在各种不同的架构上运行。
- en: Other compilers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他编译器
- en: There are many more compiler toolchains for C/C++ than just VC++ and GCC, of
    course, including the Intel Compiler Collection (ICC) and other, usually proprietary
    tools.. These all have their own collection of built-in atomic functions. Fortunately,
    thanks to the C++11 standard, we now have a fully portable standard for atomics
    between compilers. Generally, this means that outside of very specific use cases
    (or maintenance of existing code), one would use the C++ standard over compiler-specific
    extensions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，C/C++有许多不同于VC++和GCC的编译器工具链，包括英特尔编译器集合（ICC）和其他通常是专有工具。所有这些都有自己的内置原子函数集。幸运的是，由于C++11标准，我们现在在编译器之间有了一个完全可移植的原子标准。一般来说，这意味着除了非常特定的用例（或者维护现有代码），人们会使用C++标准而不是特定于编译器的扩展。
- en: C++11 atomics
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++11原子
- en: 'In order to use the native C++11 atomics features, all one has to do is include
    the `<atomic>` header. This makes available the `atomic` class, which uses templates
    to adapt itself to the required type, with a large number of predefined typedefs:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用本地C++11原子特性，我们只需要包含`<atomic>`头文件。这将使`atomic`类可用，该类使用模板来使自己适应所需的类型，并具有大量预定义的typedef：
- en: '| **Typedef name** | **Full specialization** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '**Typedef name** | **Full specialization** |'
- en: '| `std::atomic_bool` | `std::atomic<bool>` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_bool` | `std::atomic<bool>` |'
- en: '| `std::atomic_char` | `std::atomic<char>` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_char` | `std::atomic<char>` |'
- en: '| `std::atomic_schar` | `std::atomic<signed char>` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_schar` | `std::atomic<signed char>` |'
- en: '| `std::atomic_uchar` | `std::atomic<unsigned char>` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uchar` | `std::atomic<unsigned char>` |'
- en: '| `std::atomic_short` | `std::atomic<short>` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_short` | `std::atomic<short>` |'
- en: '| `std::atomic_ushort` | `std::atomic<unsigned short>` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_ushort` | `std::atomic<unsigned short>` |'
- en: '| `std::atomic_int` | `std::atomic<int>` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int` | `std::atomic<int>` |'
- en: '| `std::atomic_uint` | `std::atomic<unsigned int>` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint` | `std::atomic<unsigned int>` |'
- en: '| `std::atomic_long` | `std::atomic<long>` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_long` | `std::atomic<long>` |'
- en: '| `std::atomic_ulong` | `std::atomic<unsigned long>` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_ulong` | `std::atomic<unsigned long>` |'
- en: '| `std::atomic_llong` | `std::atomic<long long>` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_llong` | `std::atomic<long long>` |'
- en: '| `std::atomic_ullong` | `std::atomic<unsigned long long>` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_ullong` | `std::atomic<unsigned long long>` |'
- en: '| `std::atomic_char16_t` | `std::atomic<char16_t>` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_char16_t` | `std::atomic<char16_t>` |'
- en: '| `std::atomic_char32_t` | `std::atomic<char32_t>` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_char32_t` | `std::atomic<char32_t>` |'
- en: '| `std::atomic_wchar_t` | `std::atomic<wchar_t>` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_wchar_t` | `std::atomic<wchar_t>` |'
- en: '| `std::atomic_int8_t` | `std::atomic<std::int8_t>` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int8_t` | `std::atomic<std::int8_t>` |'
- en: '| `std::atomic_uint8_t` | `std::atomic<std::uint8_t>` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint8_t` | `std::atomic<std::uint8_t>` |'
- en: '| `std::atomic_int16_t` | `std::atomic<std::int16_t>` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int16_t` | `std::atomic<std::int16_t>` |'
- en: '| `std::atomic_uint16_t` | `std::atomic<std::uint16_t>` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint16_t` | `std::atomic<std::uint16_t>` |'
- en: '| `std::atomic_int32_t` | `std::atomic<std::int32_t>` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int32_t` | `std::atomic<std::int32_t>` |'
- en: '| `std::atomic_uint32_t` | `std::atomic<std::uint32_t>` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint32_t` | `std::atomic<std::uint32_t>` |'
- en: '| `std::atomic_int64_t` | `std::atomic<std::int64_t>` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int64_t` | `std::atomic<std::int64_t>` |'
- en: '| `std::atomic_uint64_t` | `std::atomic<std::uint64_t>` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint64_t` | `std::atomic<std::uint64_t>` |'
- en: '| `std::atomic_int_least8_t` | `std::atomic<std::int_least8_t>` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int_least8_t` | `std::atomic<std::int_least8_t>` |'
- en: '| `std::atomic_uint_least8_t` | `std::atomic<std::uint_least8_t>` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint_least8_t` | `std::atomic<std::uint_least8_t>` |'
- en: '| `std::atomic_int_least16_t` | `std::atomic<std::int_least16_t>` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int_least16_t` | `std::atomic<std::int_least16_t>` |'
- en: '| `std::atomic_uint_least16_t` | `std::atomic<std::uint_least16_t>` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint_least16_t` | `std::atomic<std::uint_least16_t>` |'
- en: '| `std::atomic_int_least32_t` | `std::atomic<std::int_least32_t>` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int_least32_t` | `std::atomic<std::int_least32_t>` |'
- en: '| `std::atomic_uint_least32_t` | `std::atomic<std::uint_least32_t>` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint_least32_t` | `std::atomic<std::uint_least32_t>` |'
- en: '| `std::atomic_int_least64_t` | `std::atomic<std::int_least64_t>` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int_least64_t` | `std::atomic<std::int_least64_t>` |'
- en: '| `std::atomic_uint_least64_t` | `std::atomic<std::uint_least64_t>` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint_least64_t` | `std::atomic<std::uint_least64_t>` |'
- en: '| `std::atomic_int_fast8_t` | `std::atomic<std::int_fast8_t>` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int_fast8_t` | `std::atomic<std::int_fast8_t>` |'
- en: '| `std::atomic_uint_fast8_t` | `std::atomic<std::uint_fast8_t>` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint_fast8_t` | `std::atomic<std::uint_fast8_t>` |'
- en: '| `std::atomic_int_fast16_t` | `std::atomic<std::int_fast16_t>` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int_fast16_t` | `std::atomic<std::int_fast16_t>` |'
- en: '| `std::atomic_uint_fast16_t` | `std::atomic<std::uint_fast16_t>` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint_fast16_t` | `std::atomic<std::uint_fast16_t>` |'
- en: '| `std::atomic_int_fast32_t` | `std::atomic<std::int_fast32_t>` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int_fast32_t` | `std::atomic<std::int_fast32_t>` |'
- en: '| `std::atomic_uint_fast32_t` | `std::atomic<std::uint_fast32_t>` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint_fast32_t` | `std::atomic<std::uint_fast32_t>` |'
- en: '| `std::atomic_int_fast64_t` | `std::atomic<std::int_fast64_t>` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_int_fast64_t` | `std::atomic<std::int_fast64_t>` |'
- en: '| `std::atomic_uint_fast64_t` | `std::atomic<std::uint_fast64_t>` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_uint_fast64_t` | `std::atomic<std::uint_fast64_t>` |'
- en: '| `std::atomic_intptr_t` | `std::atomic<std::intptr_t>` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '`std::atomic_intptr_t` | `std::atomic<std::intptr_t>` |'
- en: '| `std::atomic_uintptr_t` | `std::atomic<std::uintptr_t>` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic_uintptr_t` | `std::atomic<std::uintptr_t>` |'
- en: '| `std::atomic_size_t` | `std::atomic<std::size_t>` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic_size_t` | `std::atomic<std::size_t>` |'
- en: '| `std::atomic_ptrdiff_t` | `std::atomic<std::ptrdiff_t>` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic_ptrdiff_t` | `std::atomic<std::ptrdiff_t>` |'
- en: '| `std::atomic_intmax_t` | `std::atomic<std::intmax_t>` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic_intmax_t` | `std::atomic<std::intmax_t>` |'
- en: '| `std::atomic_uintmax_t` | `std::atomic<std::uintmax_t>` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic_uintmax_t` | `std::atomic<std::uintmax_t>` |'
- en: 'This `atomic` class defines the following generic functions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`atomic`类定义了以下通用函数：
- en: '| **Function** | **Description** |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `operator=` | Assigns a value to an atomic object. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `operator=` | 为原子对象赋值。 |'
- en: '| `is_lock_free` | Returns true if the atomic object is lock-free. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `is_lock_free` | 如果原子对象是无锁的，则返回true。 |'
- en: '| `store` | Replaces the value of the atomic object with a non-atomic argument,
    atomically. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `store` | 用非原子参数原子地替换原子对象的值。 |'
- en: '| `load` | Atomically obtains the value of the atomic object. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `load` | 原子地获取原子对象的值。 |'
- en: '| `operator T` | Loads a value from an atomic object. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `operator T` | 从原子对象中加载一个值。 |'
- en: '| `exchange` | Atomically replaces the value of the object with the new value
    and returns the old value. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `exchange` | 原子地用新值替换对象的值并返回旧值。 |'
- en: '| `compare_exchange_weak``compare_exchange_strong` | Atomically compares the
    value of the object and swaps values if equal, or else returns the current value.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `compare_exchange_weak``compare_exchange_strong` | 原子地比较对象的值，如果相等则交换值，否则返回当前值。
    |'
- en: With the C++17 update, the `is_always_lock_free` constant is added. This allows
    one to inquire whether the type is always lock-free.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C++17的更新，添加了`is_always_lock_free`常量。这允许我们查询类型是否总是无锁。
- en: 'Finally, we have the specialized `atomic` functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有专门的`atomic`函数：
- en: '| **Function** | **Description** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `fetch_add` | Atomically adds the argument to the value stored in the `atomic`
    object and returns the old value. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `fetch_add` | 原子地将参数添加到`atomic`对象中存储的值并返回旧值。 |'
- en: '| `fetch_sub` | Atomically subtracts the argument from the value stored in
    the `atomic` object and returns the old value. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `fetch_sub` | 原子地从`atomic`对象中减去参数并返回旧值。 |'
- en: '| `fetch_and` | Atomically performs bitwise `AND` between the argument and
    the value of the `atomic` object and returns the old value. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `fetch_and` | 在参数和`atomic`对象的值之间原子地执行位`AND`并返回旧值。 |'
- en: '| `fetch_or` | Atomically performs bitwise `OR` between the argument and the
    value of the `atomic` object and returns the old value. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `fetch_or` | 在参数和`atomic`对象的值之间原子地执行位`OR`并返回旧值。 |'
- en: '| `fetch_xor` | Atomically performs bitwise `XOR` between the argument and
    the value of the `atomic` object and returns the old value. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `fetch_xor` | 在参数和`atomic`对象的值之间原子地执行位`XOR`并返回旧值。 |'
- en: '| `operator++``operator++(int)``operator--``operator--(int)` | Increments or
    decrements the atomic value by one. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `operator++``operator++(int)``operator--``operator--(int)` | 将原子值增加或减少一。
    |'
- en: '| `operator+=``operator-=``operator&=``operator&#124;=``operator^=` | Adds,
    subtracts, or performs a bitwise `AND`, `OR`, `XOR` operation with the atomic
    value. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `operator+=``operator-=``operator&=``operator&#124;=``operator^=` | 添加、减去或执行位`AND`、`OR`、`XOR`操作。
    |'
- en: Example
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'A basic example using `fetch_add` would look like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fetch_add`的基本示例如下：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result of this example code would be `5`. As we can see here, we can implement
    a basic counter this way with atomics, instead of having to use any mutexes or
    similar in order to provide thread synchronization.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码的结果将是`5`。正如我们在这里看到的，我们可以用原子操作来实现一个基本的计数器，而不必使用任何互斥锁或类似的东西来提供线程同步。
- en: Non-class functions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非类函数
- en: 'In addition to the `atomic` class, there are also a number of template-based
    functions defined in the `<atomic>` header which we can use in a manner more akin
    to the compiler''s built-in atomic functions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`atomic`类之外，`<atomic>`头文件中还定义了一些基于模板的函数，我们可以以更类似于编译器内置的原子函数的方式使用：
- en: '| **Function** | **Description** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `atomic_is_lock_free` | Checks whether the atomic type''s operations are
    lock-free. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_is_lock_free` | 检查原子类型的操作是否是无锁的。 |'
- en: '| `atomic_storeatomic_store_explicit` | Atomically replaces the value of the
    `atomic` object with a non-atomic argument. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_storeatomic_store_explicit` | 原子地用非原子参数替换`atomic`对象的值。 |'
- en: '| `atomic_load``atomic_load_explicit` | Atomically obtains the value stored
    in an `atomic` object. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_load``atomic_load_explicit` | 原子地获取存储在`atomic`对象中的值。 |'
- en: '| `atomic_exchange``atomic_exchange_explicit` | Atomically replaces the value
    of the `atomic` object with a non-atomic argument and returns the old value of
    `atomic`. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_exchange``atomic_exchange_explicit` | 原子地用非原子参数替换`atomic`对象的值并返回`atomic`的旧值。
    |'
- en: '| `atomic_compare_exchange_weak``atomic_compare_exchange_weak_explicit``atomic_compare_exchange_strong``atomic_compare_exchange_strong_explicit`
    | Atomically compares the value of the `atomic` object with a non-atomic argument
    and performs an atomic exchange if equal or `atomic` load if not. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_compare_exchange_weak``atomic_compare_exchange_weak_explicit``atomic_compare_exchange_strong``atomic_compare_exchange_strong_explicit`
    | 原子地比较`atomic`对象的值和非原子参数，并在相等时执行原子交换，否则执行原子加载。 |'
- en: '| `atomic_fetch_add``atomic_fetch_add_explicit` | Adds a non-atomic value to
    an `atomic` object and obtains the previous value of `atomic`. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_fetch_add``atomic_fetch_add_explicit` | 将非原子值添加到`atomic`对象中并获取`atomic`的先前值。
    |'
- en: '| `atomic_fetch_sub``atomic_fetch_sub_explicit` | Subtracts a non-atomic value
    from an `atomic` object and obtains the previous value of `atomic`. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_fetch_sub``atomic_fetch_sub_explicit` | 从`atomic`对象中减去非原子值并获取`atomic`的先前值。
    |'
- en: '| `atomic_fetch_and``atomic_fetch_and_explicit` | Replaces the `atomic` object
    with the result of logical `AND` with a non-atomic argument and obtains the previous
    value of the atomic. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_fetch_and``atomic_fetch_and_explicit` | 用非原子参数的逻辑`AND`结果替换`atomic`对象并获取原子的先前值。
    |'
- en: '| `atomic_fetch_or``atomic_fetch_or_explicit` | Replaces the `atomic` object
    with the result of logical `OR` with a non-atomic argument and obtains the previous
    value of `atomic`. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_fetch_or``atomic_fetch_or_explicit` | 用非原子参数的逻辑`OR`结果替换`atomic`对象，并获取`atomic`的先前值。
    |'
- en: '| `atomic_fetch_xor``atomic_fetch_xor_explicit` | Replaces the `atomic` object
    with the result of logical `XOR` with a non-atomic argument and obtains the previous
    value of `atomic`. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_fetch_xor``atomic_fetch_xor_explicit` | 用非原子参数的逻辑`XOR`结果替换`atomic`对象，并获取`atomic`的先前值。
    |'
- en: '| `atomic_flag_test_and_set``atomic_flag_test_and_set_explicit` | Atomically
    sets the flag to `true` and returns its previous value. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_flag_test_and_set``atomic_flag_test_and_set_explicit` | 原子地将标志设置为`true`并返回其先前的值。
    |'
- en: '| `atomic_flag_clear``atomic_flag_clear_explicit` | Atomically sets the value
    of the flag to `false`. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_flag_clear``atomic_flag_clear_explicit` | 原子地将标志的值设置为`false`。 |'
- en: '| `atomic_init` | Non-atomic initialization of a default-constructed `atomic`
    object. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_init` | 默认构造的`atomic`对象的非原子初始化。 |'
- en: '| `kill_dependency` | Removes the specified object from the `std::memory_order_consume`
    dependency tree. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `kill_dependency` | 从`std::memory_order_consume`依赖树中移除指定的对象。 |'
- en: '| `atomic_thread_fence` | Generic memory order-dependent fence synchronization
    primitive. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_thread_fence` | 通用的内存顺序相关的栅栏同步原语。 |'
- en: '| `atomic_signal_fence` | Fence between a thread and a signal handler executed
    in the same thread. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_signal_fence` | 在同一线程中的线程和信号处理程序之间设置栅栏。 |'
- en: The difference between the regular and explicit functions is that the latter
    allows one to actually set the memory order to use. The former always uses `memory_order_seq_cst`
    as the memory order.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 常规和显式函数之间的区别在于后者允许实际设置要使用的内存顺序。前者总是使用`memory_order_seq_cst`作为内存顺序。
- en: Example
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'In this example using `atomic_fetch_sub`, an indexed container is processed
    by multiple threads concurrently, without the use of locks:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个使用`atomic_fetch_sub`的示例中，一个带索引的容器被多个线程同时处理，而不使用锁：
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example code uses a vector filled with integers of size *N* as the data
    source, filling it with 1s. The atomic counter object is set to the size of the
    data vector. After this, 10 threads are created (initialized in place using the
    vector's `emplace_back` C++11 feature), which run the `reader` function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码使用了一个大小为*N*的整数向量作为数据源，用1填充它。原子计数器对象设置为数据向量的大小。之后，创建了10个线程（使用向量的`emplace_back`
    C++11特性就地初始化），运行`reader`函数。
- en: In that function, we read the current value of the index counter from memory
    using the `atomic_fetch_sub_explicit` function, which allows us to use the `memory_order_relaxed`
    memory order. This function also subtracts the value we pass from this old value,
    counting the index down by 1.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数中，我们使用`atomic_fetch_sub_explicit`函数从内存中读取索引计数器的当前值，这使我们能够使用`memory_order_relaxed`内存顺序。该函数还从这个旧值中减去我们传递的值，将索引减少1。
- en: So long as the index number we obtain this way is higher or equal to zero, the
    function continues, otherwise it will quit. Once all the threads have finished,
    the application exits.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们以这种方式获得的索引号大于或等于零，函数就会继续，否则它将退出。一旦所有线程都完成了，应用程序就会退出。
- en: Atomic flag
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子标志
- en: '`std::atomic_flag` is an atomic Boolean type. Unlike the other specializations
    of the `atomic` class, it is guaranteed to be lock-free. It does not however,
    offer any load or store operations.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic_flag`是一个原子布尔类型。与`atomic`类的其他特化不同，它保证是无锁的。然而，它不提供任何加载或存储操作。'
- en: Instead, it offers the assignment operator, and functions to either clear, or
    `test_and_set` the flag. The former thereby sets the flag to `false`, and the
    latter will test and set it to `true`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，它提供了赋值运算符，以及清除或`test_and_set`标志的函数。前者将标志设置为`false`，后者将测试并将其设置为`true`。
- en: Memory order
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存顺序
- en: 'This property is defined as an enumeration in the `<atomic>` header:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性在`<atomic>`头文件中被定义为一个枚举：
- en: '[PRE17]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the GCC section, we already touched briefly on the topic of memory order.
    As mentioned there, this is one of the parts where the characteristics of the
    underlying hardware architecture surface somewhat.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCC部分，我们已经简要涉及了内存顺序的话题。如前所述，这是底层硬件架构特征的一部分。
- en: 'Basically, memory order determines how non-atomic memory accesses are to be
    ordered (memory access order) around an atomic operation. What this affects is
    how different threads will see the data in memory as they''re executing their
    instructions:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，内存顺序决定了非原子内存访问在原子操作周围的顺序（内存访问顺序）。这会影响不同线程在执行指令时如何看到内存中的数据：
- en: '| **Enum** | **Description** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **枚举** | **描述** |'
- en: '| `memory_order_relaxed` | Relaxed operation: there are no synchronization
    or ordering constraints imposed on other reads or writes, only this operation''s
    atomicity is guaranteed. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_relaxed` | 松散操作：对其他读取或写入没有同步或排序约束，只有这个操作的原子性是有保证的。 |'
- en: '| `memory_order_consume` | A load operation with this memory order performs
    a *consume operation* on the affected memory location: no reads or writes in the
    current thread dependent on the value currently loaded can be reordered before
    this load. Writes to data-dependent variables in other threads that release the
    same atomic variable are visible in the current thread. On most platforms, this
    affects compiler optimizations only. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_consume` | 具有这种内存顺序的加载操作在受影响的内存位置上执行*consume操作*：当前加载之前的当前线程中对当前加载的值的依赖变量的读取或写入不能被重新排序。在其他释放相同原子变量的数据依赖变量的写入对当前线程可见。在大多数平台上，这只影响编译器优化。
    |'
- en: '| `memory_order_acquire` | A load operation with this memory order performs
    the *acquire operation* on the affected memory location: no reads or writes in
    the current thread can be reordered before this load. All writes in other threads
    that release the same atomic variable are visible in the current thread. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_acquire` | 具有此内存顺序的加载操作在受影响的内存位置上执行*获取操作*：在此加载之前，当前线程中的任何读取或写入都不能被重新排序。释放相同原子变量的其他线程中的所有写入对于当前线程都是可见的。|'
- en: '| `memory_order_release` | A store operation with this memory order performs
    the *release operation*: no reads or writes in the current thread can be reordered
    after this store. All writes in the current thread are visible in other threads
    that acquire the same atomic variable and writes that carry a dependency into
    the atomic variable become visible in other threads that consume the same atomic.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_release` | 具有此内存顺序的存储操作执行*释放操作*：在此存储之后，当前线程中的任何读取或写入都不能被重新排序。当前线程中的所有写入对于获取相同原子变量的其他线程都是可见的，并且对原子变量进行依赖的写入也对于消费相同原子的其他线程是可见的。|'
- en: '| `memory_order_acq_rel` | A read-modify-write operation with this memory order
    is both an *acquire operation* and a *release operation*. No memory reads or writes
    in the current thread can be reordered before or after this store. All writes
    in other threads that release the same atomic variable are visible before the
    modification and the modification is visible in other threads that acquire the
    same atomic variable. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_acq_rel` | 具有此内存顺序的读-修改-写操作既是*获取操作*又是*释放操作*。当前线程中的任何内存读取或写入都不能在此存储之前或之后被重新排序。释放相同原子变量的其他线程中的所有写入在修改之前是可见的，并且对于获取相同原子变量的其他线程来说，修改是可见的。|'
- en: '| `memory_order_seq_cst` | Any operation with this memory order is both an
    *acquire operation* and a *release operation*, plus a single total order exists
    in which all threads observe all modifications in the same order. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `memory_order_seq_cst` | 具有此内存顺序的任何操作既是*获取操作*又是*释放操作*，并且存在一个单一的总顺序，所有线程都以相同的顺序观察到所有修改。|'
- en: Relaxed ordering
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散排序
- en: With relaxed memory ordering, no order is enforced among concurrent memory accesses.
    All that this type of ordering guarantees is atomicity and modification order.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散内存排序中，并没有对并发内存访问之间的顺序进行强制。这种类型的排序只保证了原子性和修改顺序。
- en: A typical use for this type of ordering is for counters, whether incrementing--or
    decrementing, as we saw earlier in the example code in the previous section.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的排序的典型用途是用于计数器，无论是增加还是减少，就像我们在上一节的示例代码中看到的那样。
- en: Release-acquire ordering
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放-获取排序
- en: If an atomic store in thread A is tagged `memory_order_release` and an atomic
    load in thread B from the same variable is tagged `memory_order_acquire`, all
    memory writes (non-atomic and relaxed atomic) that happened *before* the atomic
    store from the point of view of thread A, become *visible side-effects* in thread
    B. That is, once the atomic load has been completed, thread B is guaranteed to
    see everything thread A wrote to memory.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程A中的原子存储标记为`memory_order_release`，并且线程B中从相同变量进行的原子加载标记为`memory_order_acquire`，则所有内存写入（非原子和松散原子）在线程A的视角中发生在原子存储之前，都会成为线程B中的*可见副作用*。也就是说，一旦原子加载完成，线程B就能够看到线程A写入内存的所有内容。
- en: This type of operation is automatic on so-called strongly ordered architectures,
    including x86, SPARC, and POWER. Weakly-ordered architectures, such as ARM, PowerPC,
    and Itanium, will require the use of memory barriers here.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的操作在所谓的强顺序架构上是自动的，包括x86、SPARC和POWER。弱顺序架构，如ARM、PowerPC和Itanium，将需要在这里使用内存屏障。
- en: Typical applications of this type of memory ordering include mutual exclusion
    mechanisms, such as a mutex or atomic spinlock.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的内存排序的典型应用包括互斥机制，比如互斥锁或原子自旋锁。
- en: Release-consume ordering
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放-消费排序
- en: If an atomic store in thread A is tagged `memory_order_release` and an atomic
    load in thread B from the same variable is tagged `memory_order_consume`, all
    memory writes (non-atomic and relaxed atomic) that are *dependency-ordered* before
    the atomic store from the point of view of thread A, become *visible side-effects*
    within those operations in thread B into which the load operation *carries dependency.*
    That is, once the atomic load has been completed, those operators and functions
    in thread B that use the value obtained from the load are guaranteed to see what
    thread A wrote to memory.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程A中的原子存储标记为`memory_order_release`，并且线程B中从相同变量进行的原子加载标记为`memory_order_consume`，则所有内存写入（非原子和松散原子）在线程A的视角中在原子存储之前是*依赖排序*的，这些操作在线程B中成为*可见副作用*，并且加载操作*携带依赖性*。也就是说，一旦原子加载完成，线程B中使用从加载中获得的值的那些运算符和函数都能够看到线程A写入内存的内容。
- en: This type of ordering is automatic on virtually all architectures. The only
    major exception is the (obsolete) Alpha architecture. A typical use case for this
    type of ordering would be read access to data that rarely gets changed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的排序在几乎所有架构上都是自动的。唯一的主要例外是（已过时的）Alpha架构。这种类型排序的典型用例是对很少被更改的数据进行读取访问。
- en: As of C++17, this type of memory ordering is being revised, and the use of `memory_order_consume`
    is temporarily discouraged.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 截至C++17，这种类型的内存排序正在进行修订，暂时不建议使用`memory_order_consume`。
- en: Sequentially-consistent ordering
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序一致排序
- en: Atomic operations tagged `memory_order_seq_cst` not only order memory the same
    way as release/acquire ordering (everything that happened before a store in one
    thread becomes a *visible side effect* in the thread that did a load), but also
    establishes a *single total modification order* of all atomic operations that
    are so tagged.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`memory_order_seq_cst`的原子操作不仅对内存进行排序（在一个线程中存储之前发生的所有事情都成为了加载线程中的*可见副作用*），而且还建立了所有被标记的原子操作的*单一总修改顺序*。
- en: This type of ordering may be necessary for situations where all consumers must
    observe the changes being made by other threads in exactly the same order. It
    requires full memory barriers as a consequence on multi-core or multi-CPU systems.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这种排序可能在所有消费者必须以完全相同的顺序观察其他线程所做的更改的情况下是必要的。这在多核或多CPU系统上需要完整的内存屏障。
- en: As a result of such a complex setup, this type of ordering is significantly
    slower than the other types. It also requires that every single atomic operation
    has to be tagged with this type of memory ordering, or the sequential ordering
    will be lost.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种复杂的设置，这种排序比其他类型要慢得多。它还要求每个原子操作都必须带有这种类型的内存排序标记，否则顺序排序将丢失。
- en: Volatile keyword
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: volatile关键字
- en: The `volatile` keyword is probably quite familiar to anyone who has ever written
    complex multithreaded code. Its basic use is to tell the compiler that the relevant
    variable should always be loaded from memory, never making assumptions about its
    value. It also ensures that the compiler will not make any aggressive optimizations
    to the variable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: “volatile”关键字对于编写复杂的多线程代码的人来说可能非常熟悉。它的基本用途是告诉编译器相关变量应始终从内存中加载，永远不要对其值进行假设。它还确保编译器不会对变量进行任何激进的优化。
- en: For multithreaded applications, it is generally ineffective, however, its use
    is discouraged. The main issue with the volatile specification is that it does
    not define a multithreaded memory model, meaning that the result of this keyword
    may not be deterministic across platforms, CPUs and even toolchains.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多线程应用程序，它通常是无效的，但不鼓励使用。volatile规范的主要问题是它没有定义多线程内存模型，这意味着这个关键字的结果可能在不同平台、CPU甚至工具链上都不是确定的。
- en: Within the area of atomics, this keyword is not required, and in fact is unlikely
    to be helpful. To guarantee that one obtains the current version of a variable
    that is shared between multiple CPU cores and their caches, one would have to
    use an operation like `atomic_compare_exchange_strong`, `atomic_fetch_add`, or
    `atomic_exchange` to let the hardware fetch the correct and current value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在原子操作领域，不需要使用这个关键字，实际上使用它可能不会有帮助。为了确保获得在多个CPU核心和它们的缓存之间共享的变量的当前版本，人们必须使用像“atomic_compare_exchange_strong”、“atomic_fetch_add”或“atomic_exchange”这样的操作来让硬件获取正确和当前的值。
- en: For multithreaded code, it is recommended to not use the volatile keyword and
    use atomics instead, to guarantee proper behavior.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多线程代码，建议不要使用volatile关键字，而是使用原子操作，以确保正确的行为。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at atomic operations and exactly how they are integrated
    into compilers to allow one's code to work as closely with the underlying hardware
    as possible. The reader will now be familiar with the types of atomic operations,
    the use of a memory barrier (fencing), as well as the various types of memory
    ordering and their implications.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了原子操作以及它们如何集成到编译器中，以使代码尽可能与底层硬件紧密配合。读者现在将熟悉原子操作的类型，内存屏障（围栏）的使用，以及内存排序的各种类型及其影响。
- en: The reader is now capable of using atomic operations in their own code to accomplish
    lock-free designs and to make proper use of the C++11 memory model.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 读者现在可以在自己的代码中使用原子操作来实现无锁设计，并正确使用C++11内存模型。
- en: In the next chapter, we will take everything we have learned so far and move
    away from CPUs, instead taking a look at GPGPU, the general-purpose processing
    of data on video cards (GPUs).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将总结到目前为止学到的一切，摆脱CPU，转而看看GPGPU，即在视频卡（GPU）上对数据进行通用处理。
