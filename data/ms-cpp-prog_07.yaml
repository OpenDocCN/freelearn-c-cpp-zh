- en: Test-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: 'This chapter will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: A brief overview of test-driven development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发的简要概述
- en: Common myths and questions around TDD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于TDD的常见神话和疑问
- en: Whether it takes more efforts for a developer to write unit tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员编写单元测试是否需要更多的工作
- en: Whether code coverage metrics is good or bad
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率指标是好还是坏
- en: Whether TDD would work for complex legacy projects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD是否适用于复杂的遗留项目
- en: Whether TDD is even applicable for embedded products or products that involve
    hardware
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD是否适用于嵌入式产品或涉及硬件的产品
- en: Unit test frameworks for C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++的单元测试框架
- en: Google test framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google测试框架
- en: Installing Google test framework on Ubuntu
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装Google测试框架
- en: The process to build a Google test and mock together as one single static library
    without installing them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Google测试和模拟一起构建为一个单一的静态库的过程，而无需安装它们
- en: Writing our first test case using Google test framework
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google测试框架编写我们的第一个测试用例
- en: Using Google test framework in Visual Studio IDE
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio IDE中使用Google测试框架
- en: TDD in action
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD的实践
- en: Testing legacy code that has dependency
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试具有依赖关系的遗留代码
- en: Let's deep dive into these TDD topics.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些TDD主题。
- en: TDD
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD
- en: '**Test-driven development** (**TDD**) is an extreme programming practice. In
    TDD, we start with a test case and incrementally write the production code that
    is required to make the test case succeed. The idea is that one should focus on
    one test case or scenario at a time and once the test case passes, they can then
    move on to the next scenario. In this process, if the new test case passes, we
    shouldn''t modify the production code. In other words, in the process of developing
    a new feature or while fixing a bug, we can modify the production code only for
    two reasons: either to ensure the test case passes or to refactor the code. The
    primary focus of TDD is unit testing; however, it can be extended to integration
    and interaction testing to some extent.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种极限编程实践。在TDD中，我们从一个测试用例开始，逐步编写必要的生产代码，以使测试用例成功。这个想法是，我们应该一次专注于一个测试用例或场景，一旦测试用例通过，就可以转移到下一个场景。在这个过程中，如果新的测试用例通过，我们不应该修改生产代码。换句话说，在开发新功能或修复错误的过程中，我们只能修改生产代码的两个原因：要么确保测试用例通过，要么重构代码。TDD的主要重点是单元测试；然而，它可以在一定程度上扩展到集成和交互测试。'
- en: 'The following figure demonstrates the TDD process visually:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了TDD过程的可视化：
- en: '![](img/d95cc185-e449-42cf-ac2d-4bb5cfd65492.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d95cc185-e449-42cf-ac2d-4bb5cfd65492.png)'
- en: When TDD is followed religiously, one can achieve both functional and structural
    quality of the code. It is very crucial that you write the test case first before
    writing the production code as opposed to writing test cases at the end of the
    development phase. This makes quite a lot of difference. For instance, when a
    developer writes unit test cases at the end of development, it is very unlikely
    that the test cases will find any defect in the code. The reason is that the developers
    will unconsciously be inclined to prove their code is doing the right thing when
    the test case is written at the end of development. Whereas, when developers write
    test cases upfront, as no code is written yet, they start thinking from the end
    user's point of view, which would encourage them to come up with numerous scenarios
    from the requirement specification point of view.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当TDD被严格遵循时，开发人员可以实现代码的功能和结构质量。非常重要的是，在编写生产代码之前先编写测试用例，而不是在开发阶段结束时编写测试用例。这会产生很大的区别。例如，当开发人员在开发结束时编写单元测试用例时，测试用例很难发现代码中的任何缺陷。原因是开发人员会下意识地倾向于证明他们的代码是正确的，当测试用例在开发结束时编写时。而当开发人员提前编写测试用例时，由于尚未编写代码，他们会从最终用户的角度开始思考，这会鼓励他们从需求规范的角度提出许多场景。
- en: In other words, test cases written against code that is already written will
    generally not find any bug as it tends to prove the code written is correct, instead
    of testing it against the requirement. As developers think of various scenarios
    before writing code, it helps them write better code incrementally, ensuring that
    the code does take care of those scenarios. However, when the code has loopholes,
    it is the test case that helps them find issues, as test cases will fail if they
    don't meet the requirements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，针对已经编写的代码编写的测试用例通常不会发现任何错误，因为它倾向于证明编写的代码是正确的，而不是根据需求进行测试。当开发人员在编写代码之前考虑各种场景时，这有助于他们逐步编写更好的代码，确保代码确实考虑到这些场景。然而，当代码存在漏洞时，测试用例将帮助他们发现问题，因为如果不满足要求，测试用例将失败。
- en: TDD is not just about using some unit test framework. It requires cultural and
    mindset change while developing or fixing defects in the code. Developers' focus
    should be to make the code functionally correct. Once the code is developed in
    this fashion, it is highly recommended that the developers should also focus on
    removing any code smells by refactoring the code; this will ensure the structural
    quality of the code would be good as well. In the long run, it is the structural
    quality of the code that would make the team deliver features faster.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TDD不仅仅是使用一些单元测试框架。在开发或修复代码时，它需要文化和心态的改变。开发人员的重点应该是使代码在功能上正确。一旦以这种方式开发了代码，强烈建议开发人员还应专注于通过重构代码来消除任何代码异味；这将确保代码的结构质量也很好。从长远来看，代码的结构质量将使团队更快地交付功能。
- en: Common myths and questions around TDD
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于TDD的常见神话和疑问
- en: There are lots of myths and common doubts about TDD that crosses everyone's mind
    when they are about to start their TDD journey. Let me clarify most of them that
    I came across, for while I consulted many product giants around the globe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们开始他们的TDD之旅时，关于TDD有很多神话和常见疑问。让我澄清我遇到的大部分问题，因为我咨询了全球许多产品巨头。
- en: Does it take more efforts for a developer to write a unit test?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发人员编写单元测试是否需要更多的工作
- en: One of the common doubts that arises in the minds of most developers is, "How
    am I supposed to estimate my effort when we adapt to TDD?" As developers are supposed
    to write unit and integration test cases as part of TDD, it is no wonder you are
    concerned about how to negotiate with the customer or management for the additional
    effort required to write test cases in addition to writing code. No worries, you
    aren't alone; as a freelance software consultant myself, many developers have
    asked me this question.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员心中常常会产生一个疑问：“当我们采用TDD时，我应该如何估算我的工作量？”由于开发人员需要作为TDD的一部分编写单元和集成测试用例，您对如何与客户或管理层协商额外编写测试用例所需的工作量感到担忧，这并不奇怪。别担心，您并不孤单；作为一名自由软件顾问，许多开发人员向我提出了这个问题。
- en: As a developer, you test your code manually; instead, write automated test cases
    now. The good news is that it is a one-time effort that is guaranteed to help
    you in the long run. While a developer requires repeated manual effort to test
    their code, every time they change the code, the already existing automated test
    cases will help the developer by giving them immediate feedback when they integrate
    a new piece of code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您手动测试您的代码；相反，现在编写自动化测试用例。好消息是，这是一次性的努力，保证能够在长期内帮助您。虽然开发人员需要反复手动测试他们的代码，但每次他们更改代码时，已经存在的自动化测试用例将通过在集成新代码时立即给予开发人员反馈来帮助他们。
- en: The bottom line is that it requires some additional effort, but in the long
    run, it helps reduce the effort required.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，这需要额外的努力，但从长远来看，它有助于减少所需的努力。
- en: Is code coverage metrics good or bad?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率指标是好还是坏？
- en: Code coverage tools help developers identify gaps in their automated test cases.
    No doubt, many times it will give a clue about missing test scenarios, which would
    eventually further strengthen the automated test cases. But when an organization
    starts enforcing code coverage as a measure to check the effectiveness of test
    coverage, it sometimes drives the developers in the wrong direction. From my practical
    consulting experience, what I have learned is that many developers start writing
    test cases for constructors and private and protected functions to show higher
    code coverage. In this process, developers start chasing numbers and lose the
    ultimate goal of TDD.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖工具帮助开发人员识别其自动化测试用例中的空白。毫无疑问，很多时候它会提供有关缺失测试场景的线索，这最终会进一步加强自动化测试用例。但当一个组织开始将代码覆盖率作为检查测试覆盖率有效性的指标时，有时会导致开发人员走向错误的方向。根据我的实际咨询经验，我所学到的是，许多开发人员开始为构造函数和私有和受保护的函数编写测试用例，以展示更高的代码覆盖率。在这个过程中，开发人员开始追求数字，失去了TDD的最终目标。
- en: In a particular source with a class that has 20 methods, it is possible that
    only 10 methods qualify for unit testing while the other methods are complex functionality.
    In such a case, the code coverage tools will show only 50 percent code coverage,
    which is absolutely fine as per the TDD philosophy. However, if the organization
    policy enforces a minimum 75 percent code coverage, then the developers will have
    no choice other than testing the constructor, destructor, private, protected,
    and complex functions for the sake of showing good code coverage.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个具有20个方法的类的特定源代码中，可能只有10个方法符合单元测试的条件，而其他方法是复杂的功能。在这种情况下，代码覆盖工具将只显示50%的代码覆盖率，这完全符合TDD哲学。然而，如果组织政策强制要求最低75%的代码覆盖率，那么开发人员将别无选择，只能测试构造函数、析构函数、私有、受保护和复杂功能，以展示良好的代码覆盖率。
- en: The trouble with testing private and protected methods is that they tend to
    change more often as they are marked as implementation details. When private and
    protected methods change badly, that calls for modifying test cases, which makes
    the developer's life harder in terms of maintaining the test cases.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 测试私有和受保护方法的麻烦在于它们往往会更改，因为它们被标记为实现细节。当私有和受保护方法发生严重变化时，就需要修改测试用例，这使得开发人员在维护测试用例方面的生活更加艰难。
- en: Hence, code coverage tools are very good developer tools to find test scenario
    gaps, but it should be left to a developer to make a wise choice of whether to
    write a test case or ignore writing test cases for certain methods, depending
    on the complexity of the methods. However, if code coverage is used as project
    metrics, it more often tends to drive developers to find wrong ways to show better
    coverage, leading to bad test case practices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码覆盖工具是非常好的开发人员工具，可以找到测试场景的空白，但是否编写测试用例或忽略编写某些方法的测试用例，取决于方法的复杂性，应该由开发人员做出明智的选择。然而，如果代码覆盖率被用作项目指标，它往往会驱使开发人员找到展示更好覆盖率的错误方法，导致糟糕的测试用例实践。
- en: Does TDD work for complex legacy projects?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD适用于复杂的遗留项目吗？
- en: Certainly! TDD works for any type of software project or products. TDD isn't
    meant just for new products or projects; it is also proven to be more effective
    with complex legacy projects or products. In a maintenance project, the vast majority
    of the time one has to fix defects and very rarely one has to support a new feature.
    Even in such legacy code, one can follow TDD while fixing defects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然！TDD适用于任何类型的软件项目或产品。TDD不仅适用于新产品或项目；它在复杂的遗留项目或产品中也被证明更有效。在维护项目中，绝大多数时间都是修复缺陷，很少需要支持新功能。即使在这样的遗留代码中，修复缺陷时也可以遵循TDD。
- en: As a developer, you would readily agree with me that once you are able to reproduce
    the issue, almost half of the problem can be considered fixed from the developer's
    point of view. Hence, you can start with a test case that reproduces the issue
    and then debug and fix the issue. When you fix the issue, the test case will start
    passing; now it's time to think of another possible test case that may reproduce
    the same defect and repeat the process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您肯定会同意，一旦您能够重现问题，从开发人员的角度来看，问题几乎有一半可以被认为已经解决了。因此，您可以从能够重现问题的测试用例开始，然后调试和修复问题。当您修复问题时，测试用例将开始通过；现在是时候考虑可能会重现相同缺陷的另一个可能的测试用例，并重复这个过程。
- en: Is TDD even applicable for embedded or products that involve hardware?
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD是否适用于嵌入式或涉及硬件的产品？
- en: Just like application software can benefit from TDD, embedded projects or projects
    that involve hardware interactions can also benefit from the TDD approach. Interestingly,
    embedded projects or products that involve hardware benefit more from TDD as they
    can test most part of their code without the hardware by isolating the hardware
    dependency. TDD helps reduce time to market as most part of the software can be
    tested by the team without waiting for the hardware. As most part of the code
    is already tested thoroughly without hardware, it helps avoid last-minute surprises
    or firefighting when the board bring-up happens. This is because most of the scenarios
    would have been tested thoroughly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像应用软件可以从TDD中受益一样，嵌入式项目或涉及硬件交互的项目也可以从TDD方法中受益。有趣的是，嵌入式项目或涉及硬件的产品更多地受益于TDD，因为它们可以通过隔离硬件依赖性来测试大部分代码，而无需硬件。TDD有助于减少上市时间，因为团队可以在不等待硬件的情况下测试大部分软件。由于大部分代码已经在没有硬件的情况下得到了充分的测试，这有助于避免在板卡启动时出现最后一刻的惊喜或应急情况。这是因为大部分情况已经得到了充分的测试。
- en: As per software engineering best practices, a good design is loosely coupled
    and strongly cohesive in nature. Though we all strive to write code that is loosely
    coupled, it isn't possible to write code that is absolutely independent all the
    time. Most times, the code has some type of dependency. In the case of application
    software, the dependency could be a database or a web server; in the case of embedded
    products, the dependency could be a piece of hardware. But using dependency inversion,
    **code under test** (**CUT**) can be isolated from its dependency, enabling us
    to test the code without its dependency, which is a powerful technique. So as
    long as we are open to refactoring the code to make it more modular and atomic,
    any type of code and project or product will benefit from the TDD approach.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据软件工程的最佳实践，一个良好的设计是松散耦合和高内聚的。虽然我们都努力编写松散耦合的代码，但并不总是可能编写绝对独立的代码。大多数情况下，代码都有某种类型的依赖。在应用软件的情况下，依赖可能是数据库或Web服务器；在嵌入式产品的情况下，依赖可能是一块硬件。但是使用依赖反转，**被测试的代码**（**CUT**）可以与其依赖隔离，使我们能够在没有依赖的情况下测试代码，这是一种强大的技术。只要我们愿意重构代码使其更模块化和原子化，任何类型的代码和项目或产品都将受益于TDD方法。
- en: Unit testing frameworks for C++
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++的单元测试框架
- en: 'As a C++ developer, you have quite a lot of options when choosing between unit
    testing frameworks. While there are many more frameworks, these are some of the
    popular ones: CppUnit, CppUnitLite, Boost, MSTest, Visual Studio unit test, and
    Google test framework.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为C++开发人员，在选择单元测试框架时，你有很多选择。虽然还有许多其他框架，但这些是一些流行的框架：CppUnit，CppUnitLite，Boost，MSTest，Visual
    Studio单元测试和谷歌测试框架。
- en: Though older articles, I recommend you to take a look at [http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle](http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle)
    and [https://accu.org/index.php/journals/](https://accu.org/index.php/journals/).
    They might give you some insight into this topic.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些是较旧的文章，我建议你看一下[http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle](http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle)和[https://accu.org/index.php/journals/](https://accu.org/index.php/journals/)。它们可能会给你一些关于这个主题的见解。
- en: Without any second thought, Google test framework is one of the most popular
    testing frameworks for C++ as it is supported on a wide variety of platforms,
    actively developed, and above all, backed by Google.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，谷歌测试框架是C++中最受欢迎的测试框架之一，因为它在各种平台上都得到支持，积极开发，并且最重要的是得到了谷歌的支持。
- en: Throughout this chapter, we will use the Google test and Google mock frameworks.
    However, the concepts discussed in this chapter are applicable to all unit test
    frameworks. We'll deep dive into Google test framework and its installation procedure
    in the next sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用谷歌测试和谷歌模拟框架。然而，本章讨论的概念适用于所有单元测试框架。我们将深入研究谷歌测试框架及其安装过程。
- en: Google test framework
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌测试框架
- en: Google test framework is an open source testing framework that works on quite
    a lot of platforms. TDD only focuses on unit testing and to some extent integration
    testing, but the Google test framework can be used for a wide variety of testing.
    It classifies test cases as small, medium, large, fidelity, resilience, precision,
    and other types of test cases. Unit test cases fall in small, integration test
    cases fall in medium, and complex functionalities and acceptance test cases fall
    in the large category.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌测试框架是一个在许多平台上都可以使用的开源测试框架。TDD只关注单元测试和在一定程度上的集成测试，但谷歌测试框架可以用于各种测试。它将测试用例分类为小型、中型、大型、忠诚度、弹性、精度和其他类型的测试用例。单元测试用例属于小型，集成测试用例属于中型，而复杂功能和验收测试用例属于大型。
- en: It also bundles the Google mock framework as part of it. As they are technically
    from the same team, they play with each other seamlessly. However, the Google
    mock framework can be used with other testing frameworks, such as CppUnit.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将谷歌模拟框架作为其一部分捆绑在一起。由于它们在技术上来自同一个团队，它们可以无缝地相互配合。然而，谷歌模拟框架也可以与其他测试框架一起使用，比如CppUnit。
- en: Installing Google test framework on Ubuntu
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装谷歌测试框架
- en: 'You can download the Google test framework from [https://github.com/google/googletest](https://github.com/google/googletest)
    as source code. However, the best way to download it is via the Git clone from
    the terminal command line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://github.com/google/googletest](https://github.com/google/googletest)下载谷歌测试框架的源代码。然而，最好的下载方式是通过终端命令行进行Git克隆：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Git is an open source **distributed version control system** (**DVCS**). If
    you haven't installed it on your system, you will find more information on why
    you should, at [https://git-scm.com/](https://git-scm.com/). However, in Ubuntu,
    it can be easily installed with the `sudo apt-get install git` command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Git是一个开源的**分布式版本控制系统**（**DVCS**）。如果您还没有在系统上安装它，您可以在[https://git-scm.com/](https://git-scm.com/)上找到更多关于为什么应该安装它的信息。但是，在Ubuntu中，可以使用`sudo
    apt-get install git`命令轻松安装它。
- en: 'Once the code is downloaded as shown in *Figure 7.1*,you''ll be able to locate
    the Google test framework source code in the `googletest` folder:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码下载完成，如*图7.1*所示，您将能够在`googletest`文件夹中找到Google测试框架的源代码：
- en: '![](img/43ea535a-e0d9-44b8-b18c-2c82d511f092.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43ea535a-e0d9-44b8-b18c-2c82d511f092.png)'
- en: Figure 7.1
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1
- en: 'The `googletest` folder has both the `googletest` and `googlemock` frameworks
    in separate folders. Now we can invoke the `cmake` utility to configure our build
    and autogenerate `Makefile`, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`googletest`文件夹中有两个分开的文件夹，分别包含`googletest`和`googlemock`框架。现在我们可以调用`cmake`实用程序来配置我们的构建并自动生成`Makefile`，如下所示：'
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/a469ad65-a7fe-4efa-9849-eb9d38f8484b.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a469ad65-a7fe-4efa-9849-eb9d38f8484b.png)'
- en: Figure 7.2
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2
- en: 'When the `cmake` utility is invoked, it detects the C/C++ header''s files and
    its path that are necessary to build the Google test framework from the source
    code. Also, it will try to locate the tools required to build the source code.
    Once all the necessary headers and tools are located, it will autogenerate the
    `Makefile`. Once you have `Makefile` in place, you can use it to compile and install
    Google test and Google mock on your system:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`cmake`实用程序时，它会检测构建Google测试框架所需的C/C++头文件及其路径。此外，它还会尝试定位构建源代码所需的工具。一旦找到所有必要的头文件和工具，它将自动生成`Makefile`。一旦有了`Makefile`，您就可以使用它来编译和安装Google测试和Google模拟到您的系统上：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot demonstrates how you can install google test on your
    system:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了如何在系统上安装google测试：
- en: '![](img/068d26e0-a29d-4c43-9721-331927b1cabe.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/068d26e0-a29d-4c43-9721-331927b1cabe.png)'
- en: Figure 7.3
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3
- en: In the preceding image, the make install command has compiled and installed
    `libgmock.a` and `libgtest.a` static library files in the `/usr/local/lib` folder.
    Since the `/usr/local/lib` folder path is generally in the system's PATH environment
    variable, it can be accessed from any project within the system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，`make install`命令已经在`/usr/local/lib`文件夹中编译和安装了`libgmock.a`和`libgtest.a`静态库文件。由于`/usr/local/lib`文件夹路径通常在系统的PATH环境变量中，因此可以从系统中的任何项目中访问它。
- en: How to build google test and mock together as one single static library without
    installing?
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何构建google测试和模拟一起作为一个单一的静态库而不安装？
- en: In case you don't prefer installing the `libgmock.a` and `libgtest.a` static
    library files and the respective header files on common system folders, then there
    is yet another way to build the Google test framework.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢在常用系统文件夹上安装`libgmock.a`和`libgtest.a`静态库文件以及相应的头文件，那么构建Google测试框架还有另一种方法。
- en: 'The following command will create three object files, as shown in *Figure 7.4*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将创建三个目标文件，如*图7.4*所示：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/7b46440b-d9e3-48d7-8604-9d1291689366.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b46440b-d9e3-48d7-8604-9d1291689366.png)'
- en: Figure 7.4
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4
- en: 'The next step is to combine all the object files into a single static library
    with the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用以下命令将所有目标文件组合成一个单一的静态库：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If all goes well, your folder should have the brand new `libgtest.a` static
    library, as shown in *Figure 7.5*. Let''s understand the following command instructions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您的文件夹应该有全新的`libgtest.a`静态库，如*图7.5*所示。让我们理解以下命令说明：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding command will help us create three object files: **gtest-all.o**, **gmock-all.o**,
    and **gmock_main.o**. The `googletest` framework makes use of some C++11 features,
    and I have purposefully used c++14 to be on the safer side. The `gmock_main.cc`
    source file has a main function that will initialize the Google mock framework,
    which in turn will internally initialize the Google test framework. The best part
    about this approach is that we don''t have to supply the main function for our
    unit test application. Please note the compilation command includes the following
    `include` paths to help the g++ compiler locate the necessary header files in
    the Google test and Google mock frameworks:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将帮助我们创建三个目标文件：**gtest-all.o**，**gmock-all.o**和**gmock_main.o**。`googletest`框架使用了一些C++11特性，我故意使用了c++14以确保安全。`gmock_main.cc`源文件有一个main函数，它将初始化Google模拟框架，而后者将在内部初始化Google测试框架。这种方法的最大优点是我们不必为我们的单元测试应用程序提供main函数。请注意，编译命令包括以下`include`路径，以帮助g++编译器定位Google测试和Google模拟框架中必要的头文件：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now the next step is to create our `libgtest.a` static library that will bundle
    both gtest and gmock frameworks into one single static library. As the Google
    test framework makes use of multiple threads, it is mandatory to link the `pthread`
    library as part of our static library:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在下一步是创建我们的`libgtest.a`静态库，将gtest和gmock框架捆绑成一个单一的静态库。由于Google测试框架使用了多线程，因此必须将`pthread`库链接为我们静态库的一部分：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ar` archive command helps combine all the object files into a single static
    library.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ar`存档命令有助于将所有目标文件组合成一个静态库。'
- en: 'The following image demonstrates the discussed procedure practically in a terminal:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像在终端中实际演示了所讨论的过程：
- en: '![](img/23ae3d8d-2856-41dd-8e85-0bac6528f156.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23ae3d8d-2856-41dd-8e85-0bac6528f156.png)'
- en: Figure 7.5
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5
- en: Writing our first test case using the Google test framework
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Google测试框架编写我们的第一个测试用例
- en: 'Learning the Google test framework is pretty easy. Let''s create two folders:
    one for production code and the other for test code. The idea is to separate the
    production code from the test code. Once you have created both the folders, start
    with the `Math.h` header, as shown in *Figure 7.6*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Google测试框架非常容易。让我们创建两个文件夹：一个用于生产代码，另一个用于测试代码。这样做的想法是将生产代码与测试代码分开。一旦您创建了这两个文件夹，就可以从`Math.h`头文件开始，如*图7.6*所示：
- en: '![](img/81e2b47e-6cf2-4f3b-a03f-1ca002f7fe06.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81e2b47e-6cf2-4f3b-a03f-1ca002f7fe06.png)'
- en: Figure 7.6
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6
- en: The `Math` class has just one function to demonstrate the usage of the unit
    test framework. To begin with, our `Math` class has a simple add function that
    is good enough to understand the basic usage of the Google test framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`类只有一个函数，用于演示单元测试框架的用法。首先，我们的`Math`类有一个简单的add函数，足以理解Google测试框架的基本用法。'
- en: In the place of the Google test framework, you could use CppUnit as well and
    integrate mocking frameworks such as the Google mock framework, mockpp, or opmock.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google测试框架的位置，您也可以使用CppUnit，并集成模拟框架，如Google模拟框架、mockpp或opmock。
- en: 'Let''s implement our simple `Math` class in the following `Math.cpp` source
    file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下`Math.cpp`源文件中实现我们简单的`Math`类：
- en: '![](img/663dba83-afac-496d-9099-216be0d78ddc.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/663dba83-afac-496d-9099-216be0d78ddc.png)'
- en: Figure 7.7
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7
- en: The preceding two files are supposed to be in the `src` folder, as shown in
    *Figure 7.8*. All of the production code gets into the `src` folder, and any number
    of files can be part of the `src` folder.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个文件应该在`src`文件夹中，如*图7.8*所示。所有的生产代码都放在`src`文件夹中，`src`文件夹可以包含任意数量的文件。
- en: '![](img/2b5b3f21-af90-42df-a626-47a2aca9f1df.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b5b3f21-af90-42df-a626-47a2aca9f1df.png)'
- en: Figure 7.8
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8
- en: As we have written some production code, let's see how to write some basic test
    cases for the preceding production code. As a general best practice, it is recommended
    to name the test case file as either `MobileTest` or `TestMobile` so that it is
    easy for anyone to predict the purpose of the file. In C++ or in the Google test
    framework, it isn't mandatory to maintain the filename and class name as the same,
    but it is generally considered a best practice as it helps anyone locate a particular
    class just by looking at the filenames.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经编写了一些生产代码，现在让我们看看如何为前面的生产代码编写一些基本的测试用例。作为一般的最佳实践，建议将测试用例文件命名为`MobileTest`或`TestMobile`，以便任何人都能轻松预测文件的目的。在C++或Google测试框架中，不强制将文件名和类名保持一致，但通常被认为是最佳实践，因为它可以帮助任何人通过查看文件名来定位特定的类。
- en: Both the Google test framework and Google mock framework go hand in hand as
    they are from the same team, hence this combination works pretty well in the majority
    of the platforms, including embedded platforms.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Google测试框架和Google模拟框架都是同一个团队的产品，因此这种组合在大多数平台上都非常有效，包括嵌入式平台。
- en: 'As we have already compiled our Google test framework as a static library,
    let''s begin with the `MathTest.cpp` source file straight away:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将Google测试框架编译为静态库，让我们直接开始`MathTest.cpp`源文件：
- en: '![](img/18006d24-fd2d-4063-87c6-eced0305f9a7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18006d24-fd2d-4063-87c6-eced0305f9a7.png)'
- en: Figure 7.9
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9
- en: In *Figure 7.9***,** at line number 18,we included the gtest header file from
    the Google test framework. In the Google test framework, test cases are written
    using a `TEST` macro that takes two parameters. The first parameter, namely `MathTest`,
    represents the test module name and the second parameter is the name of the test
    case. Test modules help us group a bunch of related test cases under a module.
    Hence, it is very important to name the test module and test case aptly to improve
    the readability of the test report.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.9*中，我们在第18行包含了来自Google测试框架的gtest头文件。在Google测试框架中，测试用例使用`TEST`宏编写，该宏接受两个参数。第一个参数，即`MathTest`，表示测试模块名称，第二个参数是测试用例的名称。测试模块帮助我们将一组相关的测试用例分组到一个模块下。因此，为测试模块和测试用例命名非常重要，以提高测试报告的可读性。
- en: As you are aware, `Math` is the class we are intending to test; we have instantiated
    an object of the `Math` object at *line 22*. In *line 25*, we invoked the add
    function on the math object, which is supposed to return the actual result. Finally,
    at *line 27*, we checked whether the expected result matches the actual result.
    The Google test macro `EXPECT_EQ` will mark the test case as passed if the expected
    and actual result match; otherwise, the framework will mark the test case outcome
    as failed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，`Math`是我们打算测试的类；我们在*第22行*实例化了`Math`对象。在*第25行*，我们调用了数学对象的add函数，这应该返回实际结果。最后，在*第27行*，我们检查预期结果是否与实际结果匹配。如果预期和实际结果匹配，Google测试宏`EXPECT_EQ`将标记测试用例为通过；否则，框架将标记测试用例的结果为失败。
- en: 'Cool, we are all set now. Let''s see how to compile and run our test case now.
    The following command should help you compile the test case:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经准备好了。现在让我们看看如何编译和运行我们的测试用例。以下命令应该帮助您编译测试用例：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that the compilation command includes the following include path:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，编译命令包括以下包含路径：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Also, it is important to note that we also linked our Google test static library
    `libgtest.a` and the POSIX pthreads library as the Google test framework makes
    use of multiple .
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，重要的是要注意，我们还链接了我们的Google测试静态库`libgtest.a`和POSIX pthreads库，因为Google测试框架使用了多个。
- en: '![](img/1a036f74-590c-4bc1-877f-b13b846c4538.png)**Figure 7.10**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/1a036f74-590c-4bc1-877f-b13b846c4538.png)**图7.10**'
- en: Congrats! We have compiled and executed our first test case successfully.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经成功编译并执行了我们的第一个测试用例。
- en: Using Google test framework in Visual Studio IDE
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Visual Studio IDE中使用Google测试框架
- en: 'First, we need to download the Google test framework `.zip` file from [https://github.com/google/googletest/archive/master.zip](https://github.com/google/googletest/archive/master.zip).
    The next step is to extract the `.zip` file in some directory. In my case, I have
    extracted it into the `googletest` folder and copied all the contents of `googletest
    googletest-master\googletest-master` to the `googletest` folder, as shown in *Figure
    7.11*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从[https://github.com/google/googletest/archive/master.zip](https://github.com/google/googletest/archive/master.zip)下载Google测试框架的`.zip`文件。下一步是在某个目录中解压`.zip`文件。在我的情况下，我已经将其解压到`googletest`文件夹，并将`googletest
    googletest-master\googletest-master`的所有内容复制到`googletest`文件夹中，如*图7.11*所示：
- en: '![](img/5dfd0ab3-e8a1-434b-bc0b-72badd7486e7.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dfd0ab3-e8a1-434b-bc0b-72badd7486e7.png)'
- en: Figure 7.11
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11
- en: It is time to create a simple project in Visual Studio. I have used Microsoft
    Visual Studio Community 2015\. However, the procedure followed here should pretty
    much remain the same for other versions of Visual Studio, except that the options
    might be available in different menus.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在Visual Studio中创建一个简单的项目了。我使用的是Microsoft Visual Studio Community 2015。但是，这里遵循的程序应该对Visual
    Studio的其他版本基本保持一致，只是选项可能在不同的菜单中可用。
- en: You need to create a new project named `MathApp` by navigating to New Project
    | Visual Studio | Windows | Win32 | Win32 Console Application, as shown in *Figure
    7.12*. This project is going to be the production code to be tested.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要通过导航到新建项目| Visual Studio | Windows | Win32 | Win32控制台应用程序来创建一个名为`MathApp`的新项目，如*图7.12*所示。该项目将成为要测试的生产代码。
- en: '![](img/b707e56c-2110-4992-b811-eb1877d09571.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b707e56c-2110-4992-b811-eb1877d09571.png)'
- en: Figure 7.12
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12
- en: Let's add the `MyMath` class to the `MathApp` project. The `MyMath` class is
    the production code that will be declared in `MyMath.h` and defined in `MyMath.cpp`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`MyMath`类添加到`MathApp`项目中。`MyMath`类是将在`MyMath.h`中声明并在`MyMath.cpp`中定义的生产代码。
- en: 'Let''s take a look at the `MyMath.h` header file shown in *Figure 7.13*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下*图7.13*中显示的`MyMath.h`头文件：
- en: '![](img/c55972d8-0721-4b52-bf6c-cb4d28c0b94f.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c55972d8-0721-4b52-bf6c-cb4d28c0b94f.png)'
- en: Figure 7.13
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13
- en: 'The definition of the `MyMath` class looks as shown in *Figure 7.14*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyMath`类的定义如*图7.14*所示：'
- en: '![](img/cca9e18a-37ce-42ac-889e-7b7fb40943f2.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cca9e18a-37ce-42ac-889e-7b7fb40943f2.png)'
- en: Figure 7.14
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14
- en: 'As it is a console application, it is mandatory to supply the main function,
    as shown in *Figure 7.15*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个控制台应用程序，因此必须提供主函数，如*图7.15*所示：
- en: '![](img/0fb3b3f4-2f2e-49ab-95d4-d23925575a26.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fb3b3f4-2f2e-49ab-95d4-d23925575a26.png)'
- en: Figure 7.15
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15
- en: 'Next, we are going to add a static library project named `GoogleTestLib` to
    the same `MathApp` project solution, as shown in *Figure 7.16*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在相同的`MathApp`项目解决方案中添加一个名为`GoogleTestLib`的静态库项目，如*图7.16*所示：
- en: '![](img/02e32c32-faaa-473f-8b74-3e394f782223.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02e32c32-faaa-473f-8b74-3e394f782223.png)'
- en: Figure 7.16
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16
- en: 'Next, we need to add the following source files from the Google test framework
    to our static library project:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将来自Google测试框架的以下源文件添加到我们的静态库项目中：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to compile the static library, we need to include the following header
    file paths in `GoogleTestLib/Properties/VC++ Directories/Include` directories:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译静态库，我们需要在`GoogleTestLib/Properties/VC++ Directories/Include`目录中包含以下头文件路径：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may have to customize the paths based on where you have copied/installed
    the Google test framework in your system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要根据在系统中复制/安装Google测试框架的位置来自定义路径。
- en: Now it's time to add the `MathTestApp` Win32 console application to the `MathApp`
    solution. We need to make `MathTestApp` as a `StartUp` project so that we can
    directly execute this application. Let's ensure there are no source files in the
    `MathTestApp` project before we add a new source file named `MathTest.cpp` to
    the `MathTestApp` project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将`MathTestApp` Win32控制台应用程序添加到`MathApp`解决方案中了。我们需要将`MathTestApp`设置为`StartUp`项目，以便可以直接执行此应用程序。在添加名为`MathTest.cpp`的新源文件到`MathTestApp`项目之前，请确保`MathTestApp`项目中没有源文件。
- en: 'We need to configure the same set of Google test framework include paths we
    added to the `GoogleTestLib` static library. In addition to this, we must also
    add the `MathApp` project directory as the test project will refer to the header
    file in the `MathApp` project, as follows. However, customize the paths as per
    the directory structure you follow for this project in your system:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置与`GoogleTestLib`静态库中添加的相同一组Google测试框架包含路径。除此之外，我们还必须将`MathApp`项目目录添加为测试项目将引用的头文件，如下所示。但是，根据您在系统中为此项目遵循的目录结构，自定义路径：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `MathAppTest` project, make sure you have added references to `MathApp`
    and `GoogleTestLib` so that the `MathAppTest` project will compile the other two
    projects when it senses changes in them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MathAppTest`项目中，确保您已经添加了对`MathApp`和`GoogleTestLib`的引用，以便在它们发生更改时，`MathAppTest`项目将编译其他两个项目。
- en: 'Great! We are almost done. Now let''s implement `MathTest.cpp`, as shown in
    *Figure 7.17*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们快要完成了。现在让我们实现`MathTest.cpp`，如*图7.17*所示：
- en: '![](img/426f9b27-1907-472a-b0a3-c28e496f1112.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/426f9b27-1907-472a-b0a3-c28e496f1112.png)'
- en: Figure 7.17
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17
- en: 'Everything is ready now; let''s run the test cases and check the result:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，让我们运行测试用例并检查结果：
- en: '![](img/d100a0ee-81f9-41f7-91a3-0c7de0c1908d.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d100a0ee-81f9-41f7-91a3-0c7de0c1908d.png)'
- en: Figure 7.18
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18
- en: TDD in action
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD实践
- en: Let's see how to develop an **Reverse Polish Notation** (**RPN**) calculator
    application that follows the TDD approach. RPN is also known as the postfix notation.
    The expectation from the RPN Calculator application is to accept a postfix math
    expression as an input and return the evaluated result as the output.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何开发一个遵循TDD方法的**逆波兰表达式**（**RPN**）计算器应用程序。RPN也被称为后缀表示法。RPN计算器应用程序的期望是接受后缀数学表达式作为输入，并将计算结果作为输出返回。
- en: 'Step by step, I would like to demonstrate how one can follow the TDD approach
    while developing an application. As the first step, I would like to explain the
    project directory structure, then we''ll move forward. Let''s create a folder
    named `Ex2` with the following structure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我想逐步演示如何在开发应用程序时遵循TDD方法。作为第一步，我想解释项目目录结构，然后我们将继续。让我们创建一个名为`Ex2`的文件夹，其结构如下：
- en: '![](img/9a15c754-3b1f-428e-813f-4f2a87fe7258.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a15c754-3b1f-428e-813f-4f2a87fe7258.png)'
- en: Figure 7.19
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19
- en: The `googletest` folder is the gtest test library that has the necessary `gtest`
    and `gmock` header files. Now `libgtest.a` is the Google test static library that
    we created in the previous exercise. We are going to use the `make` utility to
    build our project, hence I have placed a `Makefile` in the project `home` directory.
    The `src` directory will hold the production code, while the test directory will
    hold all the test cases that we are going to write.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`googletest`文件夹是具有必要的`gtest`和`gmock`头文件的gtest测试库。现在`libgtest.a`是我们在上一个练习中创建的Google测试静态库。我们将使用`make`实用程序来构建我们的项目，因此我已经将`Makefile`放在项目`home`目录中。`src`目录将保存生产代码，而测试目录将保存我们将要编写的所有测试用例。'
- en: 'Before we start writing test cases, let''s take a postfix math *"2  5  *  4
     +  3  3  *  1  +  /"* and understand the standard postfix algorithm that we are
    going to apply to evaluate the RPN math expression. As per the postfix algorithm,
    we are going to parse the RPN math expression one token at a time. Whenever we
    encounter an operand (number), we are going to push that into the stack. Whenever
    we encounter an operator, we are going to pop out two values from the stack, apply
    the math operation, push back the intermediate result into the stack, and repeat
    the procedure until all the tokens are evaluated in the RPN expression. At the
    end, when no more tokens are left in the input string, we will pop out the value
    and print it as the result. The procedure is demonstrated step by step in the
    following figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试用例之前，让我们来看一个后缀数学表达式“2 5 * 4 + 3 3 * 1 + /”，并了解我们将应用于评估逆波兰数学表达式的标准后缀算法。根据后缀算法，我们将逐个标记地解析逆波兰数学表达式。每当我们遇到一个操作数（数字）时，我们将把它推入栈中。每当我们遇到一个运算符时，我们将从栈中弹出两个值，应用数学运算，将中间结果推回栈中，并重复该过程，直到在逆波兰表达式中评估所有标记。最后，当输入字符串中没有更多的标记时，我们将弹出该值并将其打印为结果。该过程在下图中逐步演示：
- en: '![](img/057ac184-3b3e-4fcf-9617-9c3ddf84c354.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/057ac184-3b3e-4fcf-9617-9c3ddf84c354.png)'
- en: Figure 7.20
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20
- en: 'To start with, let''s take a simple postfix math expression and translate the
    scenario into a test case:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们以一个简单的后缀数学表达式开始，并将情景转化为一个测试用例：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s translate the preceding test case as a Google test in the test folder,
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的测试用例翻译为测试文件夹中的Google测试，如下所示：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to compile the preceding test case, let''s write the minimal production
    code that is required in the `src` folder, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译前面的测试用例，让我们在`src`文件夹中编写所需的最小生产代码，如下所示：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As the RPN math expression will be supplied as a space-separated string, the
    evaluate method will take a string input argument:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RPN数学表达式将作为以空格分隔的字符串提供，因此评估方法将接受一个字符串输入参数：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following `Makefile` class helps run the test cases every time we compile
    the production code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`Makefile`类帮助每次编译生产代码时运行测试用例：
- en: '![](img/7f46e005-c5c5-40d0-bded-77c7d0005b7b.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f46e005-c5c5-40d0-bded-77c7d0005b7b.png)'
- en: Figure 7.21
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21
- en: 'Now let''s build and run the test case and check the test case''s outcome:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建并运行测试用例，并检查测试用例的结果：
- en: '![](img/dc5b5ecf-28fb-423d-abdc-f98ba1516cce.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc5b5ecf-28fb-423d-abdc-f98ba1516cce.png)'
- en: Figure 7.22
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22
- en: In TDD, we always start with a failing test case. The root cause of the failure
    is that the expected result is 25, while the actual result is 0\. The reason is
    that we haven't implemented the evaluate method, hence we have hardcoded to return
    0, irrespective of any input. So let's implement the evaluate method in order
    to make the test case pass.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，我们总是从一个失败的测试用例开始。失败的原因是期望的结果是25，而实际结果是0。原因是我们还没有实现评估方法，因此我们已经硬编码为返回0，而不管任何输入。因此，让我们实现评估方法以使测试用例通过。
- en: 'We need to modify `src/RPNCalculator.h` and `src/RPNCalculator.cpp` as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`src/RPNCalculator.h`和`src/RPNCalculator.cpp`如下：
- en: '![](img/df9a2b2e-f7b8-44f0-a857-5f608e71284c.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df9a2b2e-f7b8-44f0-a857-5f608e71284c.png)'
- en: Figure 7.23
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23
- en: 'In the RPNCalculator.h header file, observe the new header files that are included
    to handle string tokenizing and string double conversion and copy the RPN tokens
    to the vector:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在RPNCalculator.h头文件中，注意包含的新头文件，用于处理字符串标记化和字符串双精度转换，并将RPN标记复制到向量中：
- en: '![](img/1d6680ea-c84b-4cec-9970-a8f634e11907.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d6680ea-c84b-4cec-9970-a8f634e11907.png)'
- en: Figure 7.24
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24
- en: As per the standard postfix algorithm, we are using a stack to hold all the
    numbers that we find in the RPN expression. Anytime we encounter the `+` math
    operator, we pop out two values from the stack and add them and push back the
    results into the stack. If the token isn't a `+` operator, we can safely assume
    that it would be a number, so we just push the value to the stack.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据标准的后缀算法，我们使用一个栈来保存在逆波兰表达式中找到的所有数字。每当我们遇到`+`数学运算符时，我们从栈中弹出两个值相加，然后将结果推回栈中。如果标记不是`+`运算符，我们可以安全地假定它是一个数字，所以我们只需将该值推送到栈中。
- en: 'With the preceding implementation in place, let''s try the test case and check
    whether the test case passes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前面的实现，让我们尝试测试用例，并检查测试用例是否通过：
- en: '![](img/ecb11d2d-abab-4ed2-b958-26dd5f060d72.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecb11d2d-abab-4ed2-b958-26dd5f060d72.png)'
- en: Figure 7.25
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25
- en: 'Cool, our first test case has passed as expected. It''s time to think of another
    test case. This time, let''s add a test case for subtraction:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们的第一个测试用例如预期地通过了。现在是时候考虑另一个测试用例了。这次，让我们添加一个减法的测试用例：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s translate the preceding test case as a Google test in the test folder,
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的测试用例翻译为测试文件夹中的Google测试，如下所示：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the preceding test case added to `test/RPNCalculatorTest`, it should now
    look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将前面的测试用例添加到`test/RPNCalculatorTest`中，现在应该如下所示：
- en: '![](img/1fff5058-d457-471b-802c-a5f8ff001a5f.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fff5058-d457-471b-802c-a5f8ff001a5f.png)'
- en: Figure 7.26
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26
- en: 'Let''s execute the test cases and check whether our new test case passes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行测试用例并检查我们的新测试用例是否通过：
- en: '![](img/0a6c83e3-7724-40f5-bb08-847a7e1baea0.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a6c83e3-7724-40f5-bb08-847a7e1baea0.png)'
- en: Figure 7.27
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27
- en: 'As expected, the new test fails as we haven''t added support for subtraction
    in our application yet. This is very evident, based on the C++ exception, as the
    code attempts to convert the subtraction `-` operator into a number. Let''s add
    support for subtraction logic in our evaluate method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，新的测试失败了，因为我们还没有在应用程序中添加对减法的支持。这是非常明显的，根据C++异常，因为代码试图将减法`-`操作符转换为一个数字。让我们在我们的evaluate方法中添加对减法逻辑的支持：
- en: '![](img/619fc762-2234-42e5-bfc5-30d0134c4691.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/619fc762-2234-42e5-bfc5-30d0134c4691.png)'
- en: Figure 7.28
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28
- en: 'It''s time to test. Let''s execute the test case and check whether things are
    working:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试了。让我们执行测试案例，检查事情是否正常：
- en: '![](img/919d804c-5617-4f91-8c5a-1fc00f59d9a8.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/919d804c-5617-4f91-8c5a-1fc00f59d9a8.png)'
- en: Figure 7.29
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29
- en: Cool! Did you notice that our test case failed in this instance? Wait a minute.
    Why are we excited if the test case failed? The reason we should be happy is that
    our test case found a bug; after all, that is the main intent of TDD, isn't?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 酷！你注意到我们的测试案例在这种情况下失败了吗？等一下。如果测试案例失败了，为什么我们会兴奋呢？我们应该高兴的原因是我们的测试案例发现了一个bug；毕竟，这是TDD的主要目的，不是吗？
- en: '![](img/f356de93-2fab-434b-acf8-cacf1af1f182.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f356de93-2fab-434b-acf8-cacf1af1f182.png)'
- en: Figure 7.30
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30
- en: The root cause of the failure is that the Stack operates on the basis of **Last
    In First Out** (**LIFO**) whereas our code assumes FIFO. Did you notice that our
    code assumes that it will pop out the first number first while the reality is
    that it is supposed to pop out the second number first? Interesting, this bug
    was there in the addition operation too; however, since addition is associative,
    the bug was kind of suppressed but the subtraction test case detected it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的根本原因是栈是基于**后进先出**（**LIFO**）操作，而我们的代码假设是先进先出。你注意到我们的代码假设它会先弹出第一个数字，而实际上它应该先弹出第二个数字吗？有趣的是，这个bug在加法操作中也存在；然而，由于加法是可结合的，这个bug被抑制了，但减法测试案例检测到了它。
- en: '![](img/bcd7edd0-6555-4706-8943-673796f00748.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcd7edd0-6555-4706-8943-673796f00748.png)'
- en: Figure 7.31
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.31
- en: 'Let''s fix the bug as shown in the preceding screenshot and check whether the
    test cases will pass:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照前面的截图修复bug，并检查测试案例是否通过：
- en: '![](img/b5f684c5-bd45-4f42-b96a-083351d8f5ba.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5f684c5-bd45-4f42-b96a-083351d8f5ba.png)'
- en: Figure 7.32
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.32
- en: 'Awesome! We fixed the bug and our test case seems to certify they are fixed.
    Let''s add more test cases. This time, let''s add a test case to verify multiplication:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们修复了bug，我们的测试案例似乎证明它们已经修复了。让我们添加更多的测试案例。这一次，让我们添加一个测试案例来验证乘法：
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s translate the preceding test case as a google test in the test folder,
    as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的测试案例翻译成测试文件中的谷歌测试，如下所示：
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We know this time the test case is going to fail, so let''s fast forward and
    take a look at the division test case:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这次测试案例将会失败，所以让我们快进并看一下除法测试案例：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s translate the preceding test case as a google test in the test folder,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的测试案例翻译成测试文件中的谷歌测试，如下所示：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s skip the test result and move forward with a final complex expression
    test case that involves many operations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过测试结果，继续进行一个涉及许多操作的最终复杂表达式测试案例：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s translate the preceding test case as a google test in the test folder,
    as shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的测试案例翻译成测试文件中的谷歌测试，如下所示：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s check whether our RPNCalculator application is able to evaluate a complex
    RPN expression that involves addition, subtraction, multiplication, and division
    in a single expression with the following test case:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们的RPNCalculator应用程序是否能够评估一个涉及加法、减法、乘法和除法的复杂逆波兰表达式，这是一个测试案例：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding test case, we are checking whether the expected result matches
    the actual result to the approximation of up to four decimal places. If the values
    are different beyond this approximation, then the test case is supposed to fail.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试案例中，我们正在检查预期结果是否与实际结果匹配，精确到小数点后四位。如果超出这个近似值，那么测试案例应该失败。
- en: 'Let''s check the test case output now:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查测试案例的输出：
- en: '![](img/35093b62-507c-4bf7-a875-a9d88c32fb1d.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35093b62-507c-4bf7-a875-a9d88c32fb1d.png)'
- en: Figure 7.33
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.33
- en: Great! All the test cases are green.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！所有的测试案例都是绿色的。
- en: 'Now let''s take a look at our production code and check whether there is any
    room for improvement:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的生产代码，检查是否有改进的空间：
- en: '![](img/15296ad3-a773-4988-a0e3-dee2bc67b4cf.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15296ad3-a773-4988-a0e3-dee2bc67b4cf.png)'
- en: Figure 7.34
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.34
- en: The code is functionally good but has many code smells. It is a long method
    with the nested `if-else` condition and duplicate code. TDD is not just about
    test automation; it is also about writing good code without code smells. Hence,
    we must refactor code and make it more modular and reduce the code complexity.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在功能上是好的，但有很多代码异味。这是一个长方法，有嵌套的`if-else`条件和重复的代码。TDD不仅仅是关于测试自动化；它也是关于编写没有代码异味的好代码。因此，我们必须重构代码，使其更模块化，减少代码复杂性。
- en: We can apply polymorphism or the strategy design pattern here instead of the
    nested `if-else` conditions. Also, we can use the factory method design pattern
    to create various subtypes. There is also scope to use the Null Object Design
    Pattern.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以应用多态性或策略设计模式，而不是嵌套的`if-else`条件。此外，我们可以使用工厂方法设计模式来创建各种子类型。还有使用空对象设计模式的空间。
- en: The best part is we don't have to worry about the risk of breaking our code
    in the process of refactoring as we have a sufficient number of test cases to
    give us feedback in case we break our code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是，我们不必担心在重构过程中破坏我们的代码的风险，因为我们有足够多的测试案例来在我们破坏代码时给我们反馈。
- en: 'First, let''s understand how we could refactor the RPNCalculator design shown
    in *Figure 7.35*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解如何重构*图7.35*中所示的RPNCalculator设计：
- en: '![](img/637663f8-f8fd-4341-9d18-370b9aa67b57.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/637663f8-f8fd-4341-9d18-370b9aa67b57.png)'
- en: Figure 7.35
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.35
- en: 'Based on the preceding design refactoring approach, we can refactor RPNCalculator
    as shown in *Figure 7.36*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的设计重构方法，我们可以将RPNCalculator重构如*图7.36*所示：
- en: '![](img/a294fac9-1525-4ee7-8d24-5d4783067e3c.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a294fac9-1525-4ee7-8d24-5d4783067e3c.png)'
- en: Figure 7.36
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.36
- en: If you compare the `RPNCalculator` code before and after refactoring, you'll
    find that code complexity has reduced to a decent amount after refactoring.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您比较重构前后的`RPNCalculator`代码，您会发现重构后代码的复杂性大大减少。
- en: 'The `MathFactory` class can be implemented as shown in *Figure 7.37*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`MathFactory`类可以按*图7.37*所示实现：'
- en: '![](img/2e3ef9c1-c5bf-4cab-b5da-08654b08f7b8.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e3ef9c1-c5bf-4cab-b5da-08654b08f7b8.png)'
- en: Figure 7.37
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.37
- en: As much as possible, we must strive to avoid `if-else` conditions, or in general,
    we must try to avoid code branching when possible. Hence, STL map is used to avoid
    if-else conditions. This also promotes the reuse of the same Math objects, irrespective
    of the complexity of the RPN expression.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地，我们必须努力避免`if-else`条件，或者一般来说，我们必须尽量避免代码分支。因此，STL map用于避免if-else条件。这也促进了相同的Math对象的重复使用，无论RPN表达式的复杂性如何。
- en: 'You will get an idea of how the `MathOperator Add` class is implemented if
    you refer to *Figure 7.38*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您参考*图7.38*，您将了解`MathOperator Add`类的实现方式：
- en: '![](img/e1833a0f-7900-4459-b0da-3de4d0e80a6b.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1833a0f-7900-4459-b0da-3de4d0e80a6b.png)'
- en: Figure 7.38
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.38
- en: 'The `Add` class definition looks as shown in *Figure 7.39*:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`类的定义如*图7.39*所示：'
- en: '![](img/5ece59b7-4372-4c3e-b0be-cdd4c1653775.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ece59b7-4372-4c3e-b0be-cdd4c1653775.png)'
- en: Figure 7.39
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.39
- en: The subtract, multiplication, and division classes can be implemented in the
    similar fashion, as an `Add` class. The bottom line is that after refactoring,
    we can refactor a single `RPNCalculator` class into smaller and maintainable classes
    that can be tested individually.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 减法、乘法和除法类可以以类似的方式实现，作为`Add`类。重点是，在重构后，我们可以将单个`RPNCalculator`类重构为更小且易于维护的类，可以单独进行测试。
- en: 'Let''s take a look at the refactored `Makefile` class in *Figure 7.40* and
    test our code after the refactoring process is complete:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下重构后的`Makefile`类，如*图7.40*所示，并在重构过程完成后测试我们的代码：
- en: '![](img/6c0b43af-ea8c-4227-aa23-028c1974a486.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c0b43af-ea8c-4227-aa23-028c1974a486.png)'
- en: Figure 7.40
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.40
- en: 'If all goes well, we should see all the test cases pass after refactoring if
    no functionalities are broken, as shown in *Figure 7.41*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，重构后我们应该看到所有测试用例通过，如果没有功能被破坏，如*图7.41*所示：
- en: '![](img/e22788c8-417b-48aa-9d8a-6bc44f7c0682.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e22788c8-417b-48aa-9d8a-6bc44f7c0682.png)'
- en: Figure 7.41
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.41
- en: Cool! All the test cases have passed, hence it is guaranteed that we haven't
    broken the functionality in the process of refactoring. The main intent of TDD
    is to write testable code that is both functionally and structurally clean.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！所有测试用例都通过了，因此可以保证我们在重构过程中没有破坏功能。TDD的主要目的是编写既具有功能性又结构清晰的可测试代码。
- en: Testing a piece of legacy code that has dependency
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试具有依赖关系的遗留代码
- en: 'In the previous section, the CUT was independent with no dependency, hence
    the way it tested the code was straightforward. However, let''s discuss how we
    can unit test the CUT that has dependencies. For this, refer to the following
    image:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，CUT是独立的，没有依赖，因此它测试代码的方式是直接的。然而，让我们讨论一下如何对具有依赖关系的CUT进行单元测试。为此，请参考以下图片：
- en: '![](img/da8d052b-b313-4595-bb57-c348f0ea2b2c.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8d052b-b313-4595-bb57-c348f0ea2b2c.png)'
- en: Figure 7.42
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.42
- en: 'In *Figure 7.42*, it is apparent that **Mobile** has a dependency on **Camera**
    and the association between **Mobile** and **Camera** is *composition*. Let''s
    see how the `Camera.h` header file is implemented in a legacy application:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.42*中，显然**Mobile**依赖于**Camera**，而**Mobile**和**Camera**之间的关联是*组合*。让我们看看遗留应用程序中`Camera.h`头文件的实现：
- en: '![](img/389f8f60-fd8d-4d57-bc86-4ec5f5d8bb10.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/389f8f60-fd8d-4d57-bc86-4ec5f5d8bb10.png)'
- en: Figure 7.43
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.43
- en: 'For demonstration purposes, let''s take this simple `Camera` class that has
    `ON()` and `OFF()` functionalities. Let''s assume that the ON/OFF functionality
    will interact with the camera hardware internally. Check out the `Camera.cpp`
    source file in *Figure 7.44*:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，让我们来看一个简单的`Camera`类，具有`ON()`和`OFF()`功能。让我们假设ON/OFF功能将在内部与相机硬件交互。查看*图7.44*中的`Camera.cpp`源文件：
- en: '![](img/a7dfb6d6-4c79-4c8f-ad10-84eca6e307c1.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7dfb6d6-4c79-4c8f-ad10-84eca6e307c1.png)'
- en: Figure 7.44
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.44
- en: 'For debugging purposes, I have added some print statements that will come in
    handy when we test the `powerOn()` and `powerOff()` functionalities of mobile.
    Now let''s check the `Mobile` class header file in *Figure 7.45*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 出于调试目的，我添加了一些打印语句，这在我们测试移动的`powerOn()`和`powerOff()`功能时会很有用。现在让我们检查*图7.45*中的`Mobile`类头文件：
- en: '![](img/015a0d92-6d60-4517-bc9e-e894070568e5.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/015a0d92-6d60-4517-bc9e-e894070568e5.png)'
- en: Figure 7.45
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.45
- en: 'We move on to the mobile implementation, as illustrated in *Figure 7.46*:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续移动实现，如*图7.46*所示：
- en: '![](img/5f737e0c-f513-4c71-b6ed-8863bf39e57d.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f737e0c-f513-4c71-b6ed-8863bf39e57d.png)'
- en: Figure 7.46
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.46
- en: From the `Mobile` constructor implementation, it is evident that mobile has
    a camera or to be precise composition relationship. In other words, the `Mobile`
    class is the one that constructs the `Camera` object, as shown in *Figure 7.46*,*line
    21*, in the constructor. Let's try to see the complexity involved in testing the
    `powerOn()` functionality of Mobile; the dependency has a composition relationship
    with the CUT of Mobile.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Mobile`构造函数的实现中，可以明显看出移动设备具有相机，或者更确切地说是组合关系。换句话说，`Mobile`类是构造`Camera`对象的类，如*图7.46*，*第21行*在构造函数中显示。让我们尝试看一下测试`Mobile`的`powerOn()`功能所涉及的复杂性；依赖关系与Mobile的CUT具有组合关系。
- en: 'Let''s write the `powerOn()` test case assuming camera On has succeeded, as
    follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`powerOn()`测试用例，假设相机已成功打开，如下所示：
- en: '[PRE26]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s try to run the `Mobile` test case and check the test outcome, as
    illustrated in *Figure 7.47*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试运行`Mobile`测试用例并检查测试结果，如*图7.47*所示：
- en: '![](img/60469fae-b843-4209-80bc-bfe82d8a56f8.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60469fae-b843-4209-80bc-bfe82d8a56f8.png)'
- en: Figure 7.47
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.47
- en: From *Figure 7.47*, we can understand that the `powerOn()` test case of `Mobile` has
    passed. However, we also understand that the real `ON()` method of the `Camera`
    class also got invoked. This, in turn, will interact with the camera hardware.
    At the end of the day, it is not a unit test as the test outcome isn't completely
    dependent on the CUT. If the test case had failed, we wouldn't have been able
    to pinpoint whether the failure was due to the code in the `powerOn()` logic of
    mobile or the code in the `ON()` logic of camera, which would have defeated the
    purpose of our test case. An ideal unit test should isolate the CUT from its dependencies
    using dependency injection and test the code. This approach will help us identify
    the behavior of the CUT in normal or abnormal scenarios. Ideally, when a unit
    test case fails, we should be able to guess the root cause of the failure without
    debugging the code; this is only possible when we manage to isolate the dependencies
    of our CUT.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图7.47*中，我们可以理解`Mobile`的`powerOn()`测试用例已经通过。但是，我们也了解到`Camera`类的真正`ON()`方法也被调用了。这反过来将与相机硬件进行交互。归根结底，这不是一个单元测试，因为测试结果并不完全取决于CUT。如果测试用例失败，我们将无法确定失败是由于移动设备`powerOn()`逻辑中的代码还是相机`ON()`逻辑中的代码，这将违背我们测试用例的目的。理想的单元测试应该使用依赖注入隔离CUT与其依赖项，并测试代码。这种方法将帮助我们识别CUT在正常或异常情况下的行为。理想情况下，当单元测试用例失败时，我们应该能够猜测失败的根本原因，而无需调试代码；只有当我们设法隔离CUT的依赖项时，才有可能做到这一点。
- en: The key benefit of this approach is that the CUT can be tested even before the
    dependency is implemented, which helps test 60~70 percent of the code without
    the dependencies. This naturally reduces the time to market the software product.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的关键好处是，即使在实现依赖项之前，也可以测试CUT，这有助于在没有依赖项的情况下测试60~70％的代码。这自然减少了软件产品上市的时间。
- en: 'This is where the Google mock or gmock comes in handy. Let''s check how we
    can refactor our code to enable dependency injection. Though it sounds very complex,
    the effort required to refactor code isn''t that complex. In reality, the effort
    required to refactor your production code could be more complex, but it is worth
    the effort. Let''s take a look at the refactored `Mobile` class shown in *Figure
    7.48*:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Google模拟或gmock派上用场的地方。让我们看看如何重构我们的代码以实现依赖注入。虽然听起来非常复杂，但重构代码所需的工作并不复杂。实际上，重构生产代码所需的工作可能更复杂，但这是值得的。让我们来看一下重构后的`Mobile`类，如*图7.48*所示：
- en: '![](img/21ef199b-01fe-4269-a5d5-7cfdfddeac7d.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21ef199b-01fe-4269-a5d5-7cfdfddeac7d.png)'
- en: Figure 7.48
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.48
- en: In the `Mobile` class, I have added an overloaded constructor that takes camera
    as an argument. This technique is called **constructor dependency injection**.
    Let's see how this simple yet powerful technique could help us isolate the camera
    dependency while testing the `powerOn()` functionality of Mobile.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Mobile`类中，我添加了一个接受相机作为参数的重载构造函数。这种技术称为**构造函数依赖注入**。让我们看看这种简单而强大的技术如何在测试`Mobile`的`powerOn()`功能时帮助我们隔离相机依赖。
- en: 'Also, we must refactor the `Camera.h` header file and declare the `ON()` and
    `OFF()` methods as virtual in order for the gmock framework to help us stub these
    methods, as shown in *Figure 7.49*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须重构`Camera.h`头文件，并将`ON()`和`OFF()`方法声明为虚拟方法，以便gmock框架帮助我们存根这些方法，如*图7.49*所示：
- en: '![](img/41a26e55-9c5b-4460-8b24-719aa14ddc46.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41a26e55-9c5b-4460-8b24-719aa14ddc46.png)'
- en: Figure 7.49
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.49
- en: 'Now let''s refactor our test case as shown in *Figure 7.50*:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们根据*图7.50*进行重构我们的测试用例：
- en: '![](img/e5a68754-6e5b-438f-b371-d436b14839ee.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5a68754-6e5b-438f-b371-d436b14839ee.png)'
- en: Figure 7.50
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.50
- en: 'We are all set to build and execute the test cases. The test outcome is expected
    as shown in *Figure 7.51*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好构建和执行测试用例。测试结果如*图7.51*所示：
- en: '![](img/891b46ea-a0ee-4c8d-aa74-61e529188708.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/891b46ea-a0ee-4c8d-aa74-61e529188708.png)'
- en: Figure 7.51
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.51
- en: Cool! Not only has our test case passed, but we have also isolated our CUT from
    its camera dependency, which is evident as we don't see the print statements from
    the `ON()` method of camera. The bottom line is you have now learned how to unit
    test code by isolating its dependencies.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的测试用例不仅通过了，而且我们还将我们的CUT与其相机依赖隔离开来，这很明显，因为我们没有看到相机的`ON()`方法的打印语句。最重要的是，您现在已经学会了如何通过隔离其依赖项来对代码进行单元测试。
- en: Happy TDD!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 快乐的TDD！
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned quite a lot about TDD, and the following is the
    summary of the key takeaway points:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了很多关于TDD的知识，以下是关键要点的总结：
- en: TDD is an Extreme Programming (XP) practice
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD是一种极限编程（XP）实践
- en: TDD is a bottom-up approach that encourages us to start with a test case, hence
    it is commonly referred to as LowercaseTest-First Development
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD是一种自下而上的方法，鼓励我们从测试用例开始，因此通常被称为小写测试优先开发
- en: You learned how to write test cases using Google Test and Google Mock Frameworks
    in Linux and Windows
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了如何在Linux和Windows中使用Google Test和Google Mock框架编写测试用例
- en: You also learned how to write an application that follows TDD in Linux and Visual
    Studio on the Windows platform
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还学会了如何在Linux和Windows平台上的Visual Studio中编写遵循TDD的应用程序
- en: You learned about the Dependency Inversion technique and how to unit test a
    code by isolating its dependency using the Google Mock Framework
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了依赖反转技术以及如何使用Google Mock框架隔离其依赖项对代码进行单元测试
- en: The Google Test Framework supports Unit Testing, Integration Testing, Regression
    Testing, Performance Testing, Functional Testing, and so on
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Test框架支持单元测试、集成测试、回归测试、性能测试、功能测试等
- en: TDD mainly insists on Unit Testing, Integration Testing, and Interaction Testing
    while complex functional testing must be done with Behavior-Driven Development
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD主要坚持单元测试、集成测试和交互测试，而复杂的功能测试必须使用行为驱动开发来完成
- en: You learned how to refactor code smells into clean code while the unit test
    cases that you wrote give continuous feedback
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了如何将代码异味重构为干净的代码，同时您编写的单元测试用例会给出持续的反馈
- en: You have learned TDD and how to automate Unit Test Cases, Integration Test Cases,
    and Interaction Test cases in a bottom-up approach. With BDD, you will learn the
    top-down development approach, writing end-to-end functionalities and test cases
    and other complex test scenarios that we did not cover while discussing TDD.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了TDD以及如何以自下而上的方式自动化单元测试用例、集成测试用例和交互测试用例。有了BDD，你将学会自上而下的开发方法，编写端到端的功能和测试用例，以及我们在讨论TDD时没有涵盖的其他复杂测试场景。
- en: In the next chapter, you will learn about Behavior-Driven Development.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习行为驱动开发。
