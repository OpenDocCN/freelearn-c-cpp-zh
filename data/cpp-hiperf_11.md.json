["```cpp\nint main() { \n  std::cout << \"Thread ID: \" <<  std::this_thread::get_id() << '\\n'; \n} \n```", "```cpp\n Thread ID: 0x1001553c0 \n```", "```cpp\nstd::this_thread::sleep_for(std::chrono::seconds{1}); \n```", "```cpp\nvoid print() { \n  std::this_thread::sleep_for(std::chrono::seconds{1}); \n  std::cout << \"Thread ID: \"<<  std::this_thread::get_id() << '\\n'; \n} \n\nint main() { \n  auto t1 = std::thread{print}; \n  t1.join(); \n  std::cout << \"Thread ID: \"<<  std::this_thread::get_id() << '\\n'; \n} \n```", "```cpp\nt1.join(); \n```", "```cpp\nt1.detach(); \n```", "```cpp\nThread ID: Thread ID: 0x1003a93400x700004fd4000 \n```", "```cpp\n std::cout << std::thread::hardware_concurrency() << '\\n';\n  // Possible output: 4 \n```", "```cpp\nvoid print() {\n  std::this_thread::sleep_for(std::chrono::seconds{1});\n  std::cout << \"Thread ID: \"<<  std::this_thread::get_id() << '\\n';\n} \n```", "```cpp\nint main() {\n  std::cout << \"main begin\\n\"; \n  auto joinable_thread = std::jthread{print};  \n  std::cout << \"main end\\n\";\n} // OK: jthread will join automatically \n```", "```cpp\nmain begin\nmain end\nThread ID: 0x1004553c0 \n```", "```cpp\nvoid print(std::stop_token stoken) {\n  while (!stoken.stop_requested()) { \n    std::cout << std::this_thread::get_id() << '\\n';\n    std::this_thread::sleep_for(std::chrono::seconds{1});\n  }\n  std::cout << \"Stop requested\\n\";\n} \n```", "```cpp\nint main() {\n  auto joinable_thread = std::jthread(print);\n  std::cout << \"main: goes to sleep\\n\";\n  std::this_thread::sleep_for(std::chrono::seconds{3});\n  std::cout << \"main: request jthread to stop\\n\";\n  joinable_thread.request_stop();\n} \n```", "```cpp\nmain: goes to sleep\nThread ID: 0x70000f7e1000\nThread ID: 0x70000f7e1000\nThread ID: 0x70000f7e1000\nmain: request jthread to stop\nStop requested \n```", "```cpp\nauto counter = 0; // Warning! Global mutable variable\nvoid increment_counter(int n) {\n  for (int i = 0; i < n; ++i)\n    ++counter;\n} \n```", "```cpp\nint main() {\n  constexpr auto n = int{100'000'000};\n  {\n    auto t1 = std::jthread{increment_counter, n};\n    auto t2 = std::jthread{increment_counter, n};\n  }\n  std::cout << counter << '\\n';\n  // If we don't have a data race, this assert should hold:\n  assert(counter == (n * 2));\n} \n```", "```cpp\nauto counter = 0; // Counter will be protected by counter_mutex\nauto counter_mutex = std::mutex{}; \n```", "```cpp\nvoid increment_counter(int n) {\n  for (int i = 0; i < n; ++i) {\n    auto lock = std::scoped_lock{counter_mutex};\n    ++counter;\n  }\n} \n```", "```cpp\nstruct Account { \n  Account() {} \n  int balance_{0}; \n  std::mutex m_{}; \n}; \n\nvoid transfer_money(Account& from, Account& to, int amount) { \n   auto lock1 = std::unique_lock<std::mutex>{from.m_, std::defer_lock}; \n   auto lock2 = std::unique_lock<std::mutex>{to.m_, std::defer_lock}; \n\n   // Lock both unique_locks at the same time \n   std::lock(lock1, lock2); \n\n   from.balance_ -= amount; \n   to.balance_ += amount; \n} \n```", "```cpp\nauto cv = std::condition_variable{}; \nauto q = std::queue<int>{}; \nauto mtx = std::mutex{};     // Protects the shared queue \nconstexpr int sentinel = -1; // Value to signal that we are done \n\nvoid print_ints() { \n  auto i = 0; \n  while (i != sentinel) { \n    { \n      auto lock = std::unique_lock<std::mutex>{mtx}; \n      while (q.empty()) {\n        cv.wait(lock); // The lock is released while waiting \n      }\n      i = q.front(); \n      q.pop(); \n    } \n    if (i != sentinel) { \n      std::cout << \"Got: \" << i << '\\n'; \n    } \n  } \n} \n\nauto generate_ints() { \n  for (auto i : {1, 2, 3, sentinel}) { \n    std::this_thread::sleep_for(std::chrono::seconds(1)); \n    { \n      auto lock = std::scoped_lock{mtx}; \n      q.push(i); \n    } \n    cv.notify_one(); \n  } \n} \n\nint main() { \n   auto producer = std::jthread{generate_ints}; \n   auto consumer = std::jthread{print_ints}; \n} \n```", "```cpp\n// ...\nauto lock = std::unique_lock<std::mutex>{mtx}; \ncv.wait(lock, [] { return !q.empty(); });\n// ... \n```", "```cpp\nauto divide(int a, int b, std::promise<int>& p) { \n  if (b == 0) { \n    auto e = std::runtime_error{\"Divide by zero exception\"}; \n    p.set_exception(std::make_exception_ptr(e)); \n  } \n  else { \n    const auto result = a / b; \n    p.set_value(result); \n  } \n} \n\nint main() { \n   auto p = std::promise<int>{}; \n   std::thread(divide, 45, 5, std::ref(p)).detach(); \n\n   auto f = p.get_future(); \n   try { \n     const auto& result = f.get(); // Blocks until ready \n     std::cout << \"Result: \" << result << '\\n'; \n   } \n   catch (const std::exception& e) { \n     std::cout << \"Caught exception: \" << e.what() << '\\n'; \n   } \n} \n```", "```cpp\nint divide(int a, int b) { // No need to pass a promise ref here! \n  if (b == 0) { \n    throw std::runtime_error{\"Divide by zero exception\"}; \n  } \n  return a / b; \n} \n\nint main() { \n  auto task = std::packaged_task<decltype(divide)>{divide}; \n  auto f = task.get_future(); \n  std::thread{std::move(task), 45, 5}.detach(); \n\n  // The code below is unchanged from the previous example \n  try { \n    const auto& result = f.get(); // Blocks until ready \n    std::cout << \"Result: \" << result << '\\n'; \n  } \n  catch (const std::exception& e) { \n    std::cout << \"Caught exception: \" << e.what() << '\\n'; \n  } \n  return 0; \n} \n```", "```cpp\n auto f = std::async(divide, 45, 5); \n```", "```cpp\nint divide(int a, int b) { \n  if (b == 0) { \n    throw std::runtime_error{\"Divide by zero exception\"}; \n  } \n  return a / b; \n} \n\nint main() { \n  auto future = std::async(divide, 45, 5); \n  try { \n    const auto& result = future.get(); \n    std::cout << \"Result: \" << result << '\\n'; \n  } \n  catch (const std::exception& e) { \n    std::cout << \"Caught exception: \" << e.what() << '\\n'; \n  } \n} \n```", "```cpp\nauto lat = std::latch{8}; // Construct a latch initialized with 8 \n```", "```cpp\nlat.count_down(); // Decrement but don't wait \n```", "```cpp\nlat.wait(); // Block until zero \n```", "```cpp\nif (lat.try_wait()) { \n  // All threads have arrived ...\n} \n```", "```cpp\nlat.count_down();\nlat.wait(); \n```", "```cpp\nlat.arrive_and_wait(); // Decrement and block while not zero \n```", "```cpp\nvoid prefault_stack() {\n  // We don't know the size of the stack\n  constexpr auto stack_size = 500u * 1024u; \n  // Make volatile to avoid optimization\n  volatile unsigned char mem[stack_size]; \n  std::fill(std::begin(mem), std::end(mem), 0);\n} \n```", "```cpp\nauto do_work() { /* ... */ }\nint main() {\n  constexpr auto n_threads = 2;\n  auto initialized = std::latch{n_threads};\n  auto threads = std::vector<std::thread>{};\n  for (auto i = 0; i < n_threads; ++i) {\n    threads.emplace_back([&] {\n      prefault_stack();\n      initialized.arrive_and_wait(); \n      do_work();\n    });\n  }\n  initialized.wait();\n  std::cout << \"Initialized, starting to work\\n\";\n  for (auto&& t : threads) {\n    t.join();\n  }\n} \n```", "```cpp\nauto bar = std::barrier{8, [] {\n  // Completion function\n  std::cout \"All threads arrived at barrier\\n\";\n}}; \n```", "```cpp\nbar.arrive_and_wait(); // Decrement but don't wait \n```", "```cpp\nauto engine = \n  std::default_random_engine{std::random_device{}()};\nauto dist = std::uniform_int_distribution<>{1, 6};\nauto result = dist(engine); \n```", "```cpp\nauto random_int(int min, int max) {\n  // One engine instance per thread\n  static thread_local auto engine = \n    std::default_random_engine{std::random_device{}()};\n  auto dist = std::uniform_int_distribution<>{min, max};\n  return dist(engine);\n} \n```", "```cpp\nint main() {\n  constexpr auto n = 5; // Number of dice\n  auto done = false;\n  auto dice = std::array<int, n>{};\n  auto threads = std::vector<std::thread>{};\n  auto n_turns = 0;\n  auto check_result = [&] { // Completion function\n    ++n_turns;\n    auto is_six = [](auto i) { return i == 6; };\n    done = std::all_of(dice.begin(), dice.end(), is_six); \n  };\n  auto bar = std::barrier{n, check_result}; \n  for (int i = 0; i < n; ++i) {\n    threads.emplace_back([&, i] {\n      while (!done) {\n        dice [i] = random_int(1, 6); // Roll dice        \n        bar.arrive_and_wait();       // Join\n      }});\n  }\n  for (auto&& t : threads) { \n    t.join();\n  }\n  std::cout << n_turns << '\\n';\n} \n```", "```cpp\nclass Server {\npublic:\n  void handle(const Request& req) {\n    sem_.acquire();\n    // Restricted section begins here.\n    // Handle at most 4 requests concurrently.\n    do_handle(req);\n    sem_.release();\n  }\nprivate:\n  void do_handle(const Request& req) { /* ... */ }\n  std::counting_semaphore<4> sem_{4};\n}; \n```", "```cpp\nstd::binary_semaphore = std::counting_semaphore<1>; \n```", "```cpp\ntemplate <class T, int N> \nclass BoundedBuffer {\n  std::array<T, N> buf_;\n  std::size_t read_pos_{};\n  std::size_t write_pos_{};\n  std::mutex m_;\n  void do_push(auto&& item) {\n    /* Missing: Should block if buffer is full */\n    auto lock = std::unique_lock{m_};\n    buf_[write_pos_] = std::forward<decltype(item)>(item);\n    write_pos_ = (write_pos_ + 1) % N;\n  }\npublic:\n  void push(const T& item) { do_push(item); }\n  void push(T&& item) { do_push(std::move(item)); }\n  auto pop() {\n    /* Missing: Should block if buffer is empty */\n    auto item = std::optional<T>{};\n    {\n      auto lock = std::unique_lock{m_};\n      item = std::move(buf_[read_pos_]);\n      read_pos_ = (read_pos_ + 1) % N;\n    }\n    return std::move(*item);\n  }\n}; \n```", "```cpp\ntemplate <class T, int N> \nclass BoundedBuffer {\n  std::array<T, N> buf_;\n  std::size_t read_pos_{};\n  std::size_t write_pos_{};\n  std::mutex m_;\n  std::counting_semaphore<N> n_empty_slots_{N}; // New\n  std::counting_semaphore<N> n_full_slots_{0};  // New\n  void do_push(auto&& item) {\n    // Take one of the empty slots (might block)\n    n_empty_slots_.acquire();                   // New\n    try {\n      auto lock = std::unique_lock{m_};\n      buf_[write_pos_] = std::forward<decltype(item)>(item);\n      write_pos_ = (write_pos_ + 1) % N;\n    } catch (...) {\n      n_empty_slots_.release();                 // New\n      throw;\n    }\n    // Increment and signal that there is one more full slot\n    n_full_slots_.release();                    // New\n  }\npublic:\n  void push(const T& item) { do_push(item); }\n  void push(T&& item) { do_push(std::move(item)); }\n  auto pop() {\n    // Take one of the full slots (might block)\n    n_full_slots_.acquire();                // New\n    auto item = std::optional<T>{};\n    try {\n      auto lock = std::unique_lock{m_};\n      item = std::move(buf_[read_pos_]);\n      read_pos_ = (read_pos_ + 1) % N;\n    } catch (...) {\n      n_full_slots_.release();             // New\n      throw;\n    }\n    // Increment and signal that there is one more empty slot\n    n_empty_slots_.release();              // New\n    return std::move(*item);\n  }\n}; \n```", "```cpp\nstd::atomic<int> counter; \n\nauto increment_counter(int n) { \n  for (int i = 0; i < n; ++i) \n    ++counter; // Safe, counter is now an atomic<int> \n} \n```", "```cpp\nstruct Point { \n  int x_{}; \n  int y_{}; \n}; \n\nauto p = std::atomic<Point>{};       // OK: Point is trivially copyable \nauto s = std::atomic<std::string>{}; // Error: Not trivially copyable \n```", "```cpp\nauto variable = std::atomic<int>{1};\nassert(variable.is_lock_free());          // Runtime assert \n```", "```cpp\nstatic_assert(std::atomic<int>::is_always_lock_free); \n```", "```cpp\nclass SimpleMutex {       \n  std::atomic_flag is_locked_{};           // Cleared by default\npublic:\n  auto lock() noexcept {\n    while (is_locked_.test_and_set()) {\n      while (is_locked_.test());           // Spin here\n    }\n  } \n  auto unlock() noexcept {\n    is_locked_.clear();\n  }\n}; \n```", "```cpp\nclass SimpleMutex {       \n  std::atomic_flag is_locked_{}; \npublic:\n  auto lock() noexcept {\n    while (is_locked_.test_and_set())\n      is_locked_.wait(true);    // Don't spin, wait\n  } \n  auto unlock() noexcept {\n    is_locked_.clear();\n    is_locked_.notify_one();   // Notify blocked thread\n  }\n}; \n```", "```cpp\n// Thread 1 \nauto p1 = std::make_shared<int>(42); \n```", "```cpp\n// Thread 2 \nauto p2 = p1; \n```", "```cpp\n// Global, how to protect? \nauto p = std::shared_ptr<int>{}; \n```", "```cpp\n// Global, protect using atomic\nauto p = std::atomic<std::shared_ptr<int>>{}; \n```", "```cpp\n// Thread T1 calls this function\nauto f1() { \n  auto new_p = std::make_shared<int>(std::rand());  // ... \n  p.store(new_p);\n} \n\n// Thread T2 calls this function\nauto f2() { \n  auto local_p = p.load(); \n  // Use local_p... \n} \n```", "```cpp\nvoid flip_coin(std::size_t n, Stats& outcomes); \n```", "```cpp\nstruct Stats {\n  int heads_{};\n  int tails_{};\n};\nstd::ostream& operator<<(std::ostream& os, const Stats &s) {\n  os << \"heads: \" << s.heads_ << \", tails: \" << s.tails_;\n  return os;\n} \n```", "```cpp\nauto outcomes = Stats{};\nflip_coin(30, outcomes); \nflip_coin(10, outcomes); \n```", "```cpp\nint random_int(int min, int max); // See implementation above \n```", "```cpp\nvoid flip_coin(std::size_t n, Stats &outcomes) {\n  auto flip = [&outcomes](auto n) {\n    auto heads = std::atomic_ref<int>{outcomes.heads_};\n    auto tails = std::atomic_ref<int>{outcomes.tails_};\n    for (auto i = 0u; i < n; ++i) {\n      random_int(0, 1) == 0 ? ++heads : ++tails;\n    }\n  };\n  auto t1 = std::jthread{flip, n / 2};       // First half\n  auto t2 = std::jthread{flip, n - (n / 2)}; // The rest\n} \n```", "```cpp\nint main() {\n  auto stats = Stats{};\n  flip_coin(5000, stats);       // Flip 5000 times\n  std::cout << stats << '\\n';\n  assert((stats.tails_ + stats.heads_) == 5000);\n} \n```", "```cpp\nheads: 2592, tails: 2408 \n```", "```cpp\nint a = 10;      // 1 \nstd::cout << a;  // 2 \nint b = a;       // 3 \nstd::cout << b;  // 4 \n// Observed output: 1010 \n```", "```cpp\nint a = 10;      // 1 \nint b = a;       // 3 This line moved up  \nstd::cout << a;  // 2 This line moved down \nstd::cout << b;  // 4 \n// Observed output: 1010 \n```", "```cpp\nconstexpr auto ksize = size_t{100}; \nusing MatrixType = std::array<std::array<int, ksize>, ksize>; \n\nauto cache_thrashing(MatrixType& matrix, int v) { // 1 \n  for (size_t i = 0; i < ksize; ++i)              // 2 \n    for (size_t j = 0; j < ksize; ++j)            // 3 \n      matrix[j][i] = v;                           // 4 \n} \n```", "```cpp\nauto cache_thrashing(MatrixType& matrix, int v) { // 1 \n  for (size_t j = 0; j < ksize; ++j)              // 3 Line moved up \n    for (size_t i = 0; i < ksize; ++i)            // 2 Line moved down \n      matrix[j][i] = v;                           // 4  \n} \n```", "```cpp\ntemplate <class T, size_t N>\nclass LockFreeQueue {\n  std::array<T, N> buffer_{};   // Used by both threads\n  std::atomic<size_t> size_{0}; // Used by both threads\n  size_t read_pos_{0};          // Used by reader thread\n  size_t write_pos_{0};         // Used by writer thread\n  static_assert(std::atomic<size_t>::is_always_lock_free);\n  bool do_push(auto&& t) {      // Helper function\n    if (size_.load() == N) { \n      return false; \n    }\n    buffer_[write_pos_] = std::forward<decltype(t)>(t);\n    write_pos_ = (write_pos_ + 1) % N;\n    size_.fetch_add(1);\n    return true;\n  }\npublic:\n  // Writer thread\n  bool push(T&& t) { return do_push(std::move(t)); }\n  bool push(const T& t) { return do_push(t); }\n  // Reader thread\n  auto pop() -> std::optional<T> {\n    auto val = std::optional<T>{};    \n    if (size_.load() > 0) {\n      val = std::move(buffer_[read_pos_]);\n      read_pos_ = (read_pos_ + 1) % N;\n      size_.fetch_sub(1);\n    }\n    return val;\n  }\n  // Both threads can call size()\n  auto size() const noexcept { return size_.load(); }\n}; \n```", "```cpp\n#include <pthreads> // Non-portable header \nauto set_affinity(const std::thread& t, int cpu) {\n  cpu_set_t cpuset;\n  CPU_ZERO(&cpuset);\n  CPU_SET(cpu, &cpuset);\n  pthread_t native_thread = t.native_handle(); \n  pthread_set_affinity(native_thread, sizeof(cpu_set_t), &cpuset); \n} \n```", "```cpp\nstruct alignas(std::hardware_destructive_interference_size) Element {\n   int counter_{};\n}; \n\nauto elements = std::vector<Element>(num_threads); \n```"]