- en: Error Handling and Fault Tolerance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和容错
- en: It is hard to overestimate the importance of error handling in regards to embedded
    software. Embedded systems should work without supervision in varying physical
    conditions, such as controlling external peripheral devices that may fail over
    or not always provide reliable communication lines. And in many cases, a failure
    of the system is either expensive or plain unsafe.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 难以高估嵌入式软件中错误处理的重要性。嵌入式系统应该在各种物理条件下无需监督地工作，例如控制可能故障或不总是提供可靠通信线路的外部外围设备。在许多情况下，系统的故障要么很昂贵，要么很不安全。
- en: In this chapter, we will learn about common strategies and best practices that
    will help you write reliable and fault-tolerant embedded applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习有助于编写可靠和容错的嵌入式应用程序的常见策略和最佳实践。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下食谱：
- en: Working with error codes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误代码
- en: Using exceptions for error handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异常处理错误
- en: Using constant references when catching exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在捕获异常时使用常量引用
- en: Tackling static objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决静态对象
- en: Working with watchdogs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理看门狗
- en: Exploring heartbeats for highly available systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索高可用系统的心跳
- en: Implementing software debouncing logic
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现软件去抖动逻辑
- en: These recipes will help you understand the importance of error handling design,
    learn best practices, and avoid pitfalls in this domain.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些食谱将帮助您了解错误处理设计的重要性，学习最佳实践，并避免在此领域出现问题。
- en: Working with error codes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误代码
- en: When designing a new function, developers often need a mechanism to indicate
    that the function can't accomplish its work because of some kind of error. It
    might be invalid, an unexpected result being received from a peripheral device,
    or a resource allocation issue.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计新函数时，开发人员经常需要一种机制来指示函数无法完成其工作，因为出现了某种错误。这可能是无效的，从外围设备接收到意外结果，或者是资源分配问题。
- en: One of the most traditional and widespread ways to report an error condition
    is through error codes. This is an efficient and ubiquitous mechanism that does
    not depend on the programming language or the operating system. Due to its efficiency,
    versatility, and ability to cross various platform boundaries, it is highly used
    in embedded software development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 报告错误条件的最传统和广泛使用的方法之一是通过错误代码。这是一种高效且无处不在的机制，不依赖于编程语言或操作系统。由于其效率、多功能性和跨各种平台边界的能力，它在嵌入式软件开发中被广泛使用。
- en: Designing a function interface that returns either a value or an error code
    may be tricky, especially if the value and the error code have different types. In
    this recipe, we will explore several approaches to designing such types of function
    interfaces.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个既返回值又返回错误代码的函数接口可能会很棘手，特别是如果值和错误代码具有不同的类型。在这个食谱中，我们将探讨设计这种类型的函数接口的几种方法。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'We are going to create a simple program with three implementations of a function
    called `Receive`. All three implementations have identical behavior but a different
    interface. Follow these steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的程序，其中包含一个名为`Receive`的函数的三个实现。所有三个实现都具有相同的行为，但接口不同。按照以下步骤进行：
- en: In your working directory, that is, `~/test`, create a subdirectory called `errcode`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录`~/test`中，创建一个名为`errcode`的子目录。
- en: Use your favorite text editor to create a file called `errcode.cpp` in the `errcode` subdirectory.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`errcode`子目录中创建一个名为`errcode.cpp`的文件。
- en: 'Add the implementation of the first function to the `errcode.cpp` file:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个函数的实现添加到`errcode.cpp`文件中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we add the second implementation:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加第二个实现：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The third implementation of the `Receive` function is as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Receive`函数的第三个实现如下：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we define a helper function called `Display` to display a result:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个名为`Display`的辅助函数来显示结果：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we add a function called `Test` that invokes all three implementations:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个名为`Test`的函数，调用所有三个实现：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `main` function ties everything together:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`函数将所有内容联系在一起：'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we create a `CMakeLists.txt` file containing the build rules for our
    program:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个包含程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can now build and run the application.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以构建和运行应用程序了。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In our application, we defined three different implementations of a function
    that receives data from some device. It should return the received data as a string,
    but in the case of an error, it should return an integer error code representing
    the reason for the error.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们定义了一个从某个设备接收数据的函数的三种不同实现。它应该将接收到的数据作为字符串返回，但在出现错误时，应返回表示错误原因的整数错误代码。
- en: Since the result and the error code have different types, we can't reuse the
    same value for both. To return multiple values in C++, we either need to use output
    parameters or create a compound data type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结果和错误代码具有不同的类型，我们无法重用相同的值。要在C++中返回多个值，我们需要使用输出参数或创建一个复合数据类型。
- en: Our implementations explore both these strategies. We use C++ function overloading
    to define the `Receive` function with the same name, but different types of arguments
    and return values.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现同时探索了这两种策略。我们使用C++函数重载来定义`Receive`函数，它具有相同的名称，但不同类型的参数和返回值。
- en: 'The first implementation returns an error code and stores the result in an
    output parameter result:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实现返回一个错误代码，并将结果存储在输出参数中：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output parameter is a string passed by reference to let the function modify
    its content. The second implementation flips the parameters around. It returns
    a received string as a result and accepts an error code as an output parameter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出参数是一个通过引用传递的字符串，让函数修改其内容。第二个实现颠倒了参数。它将接收到的字符串作为结果返回，并接受错误代码作为输出参数：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since we want the error code to be set from within the function, we also pass
    it by reference. Finally, the third implementation combines and returns both the
    result and the error code in a C++ `pair`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望错误代码由函数内部设置，因此我们也通过引用传递它。最后，第三种实现将结果和错误代码组合并返回一个C++ `pair`：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function always creates an `std::pair<int, std::string>` instance. Since
    we do not pass any values to its constructor, the object is default-initialized.
    The integer element is set to `0`, and the string element is set to an empty string.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数总是创建一个`std::pair<int, std::string>`实例。由于我们没有向其构造函数传递任何值，因此对象是默认初始化的。整数元素设置为`0`，字符串元素设置为空字符串。
- en: This approach does not require an `output` parameter and is more readable, but
    has a slightly higher overhead to construct and then destroy a `pair` object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不需要`output`参数，更易读，但构造和销毁`pair`对象的开销略高。
- en: When all three implementations are defined, we test all of them in the `Test` function.
    We pass the same parameter to each of the implementations and display the result.
    We expect each of them to generate the same result.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有三种实现都被定义后，我们在`Test`函数中测试它们。我们将相同的参数传递给每个实现并显示结果。我们期望它们每个都生成相同的结果。
- en: 'There are two invocations of `Test`. First, we pass `-1` as a parameter, which
    should trigger an error path, and then we pass `1`, which activates a normal operation
    path:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有两次调用`Test`。首先，我们将`-1`作为参数传递，这应该触发错误路径，然后我们传递`1`，这将激活正常操作路径：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we run our program, we see the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的程序时，我们会看到以下输出：
- en: '![](img/4e6428d7-7667-4b9f-8b0c-bc17d09787d0.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e6428d7-7667-4b9f-8b0c-bc17d09787d0.png)'
- en: All three implementations correctly return either the result or error code based
    on the input parameters. You can use any of the approaches in your applications
    based on the overall design guidelines or your personal preferences.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种实现都根据输入参数正确返回结果或错误代码。您可以根据整体设计准则或个人偏好在应用程序中使用任何方法。
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As part of the C++17 standard, a template called `std::optional` was added to
    the standard library. It can represent an optional value that may be missing.
    It can be used as a return value from a function that may fail. However, it can't
    represent a reason for failure, only a Boolean value indicating whether the value
    is valid or not. For more information, please check the `std::optional` reference
    at [https://en.cppreference.com/w/cpp/utility/optional](https://en.cppreference.com/w/cpp/utility/optional).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为C++17标准的一部分，标准库中添加了一个名为`std::optional`的模板。它可以表示可能丢失的可选值。它可以用作可能失败的函数的返回值。但是，它不能表示失败的原因，只能表示一个布尔值，指示该值是否有效。有关更多信息，请查看[https://en.cppreference.com/w/cpp/utility/optional](https://en.cppreference.com/w/cpp/utility/optional)上的`std::optional`参考。
- en: Using exceptions for error handling
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异常进行错误处理
- en: While the error codes remain the most widespread technique of error handling
    in embedded programming, C++ offers another mechanism for this purpose, called
    exceptions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然错误代码仍然是嵌入式编程中最常见的错误处理技术，但C++提供了另一种称为异常的机制。
- en: Exceptions aim to simplify error handling and make it more reliable. When using
    error codes, developers have to check the result of each function for errors and
    propagate the result to the calling functions. This clutters the code with lots
    of if-else constructs, making the function logic more obscure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 异常旨在简化错误处理并使其更可靠。当使用错误代码时，开发人员必须检查每个函数的结果是否有错误，并将结果传播到调用函数。这会使代码充斥着大量的if-else结构，使函数逻辑更加晦涩。
- en: When using exceptions, developers do not need to check for errors after every
    function invocation. Exceptions propagate through the call stack automatically,
    until they reach the code that can handle it properly by logging, retrying, or
    terminating the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用异常时，开发人员无需在每个函数调用后检查错误。异常会自动通过调用堆栈传播，直到达到可以通过记录、重试或终止应用程序来正确处理它的代码。
- en: While exceptions are the default error handling mechanism of the C++ standard
    library, communicating with peripheral devices or the underlying operating system
    layer still involves error codes. In this recipe, we will learn how to bridge
    the low-level error handling to the C++ exceptions using the `std::system_error` exception
    class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然异常是C++标准库的默认错误处理机制，但与外围设备或底层操作系统层通信仍涉及错误代码。在本教程中，我们将学习如何使用`std::system_error`异常类将低级错误处理与C++异常进行桥接。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to create a simple application that communicates to a device over
    a serial link. Follow these steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用程序，通过串行链路与设备通信。请按照以下步骤操作：
- en: In your working directory, that is, `~/test`, create a subdirectory called `except`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录中，即`~/test`，创建一个名为`except`的子目录。
- en: Use your favorite text editor to create a file called `except.cpp` in the `ex``cept` subdirectory.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`except`子目录中创建一个名为`except.cpp`的文件。
- en: 'Put the required includes in the `except.cpp` file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的包含放入`except.cpp`文件中：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we define a `Device` class that abstracts the communication to the device.
    We start with the constructor and the destructor:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个抽象通信设备的`Device`类。我们从构造函数和析构函数开始：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we add a method that sends data to the device, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个发送数据到设备的方法，如下所示：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After our class has been defined, we add the `main` function, which uses it:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的类被定义后，我们添加`main`函数来使用它：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we create a `CMakeLists.txt` file containing the build rules for our
    program:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`CMakeLists.txt`文件，其中包含程序的构建规则：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can now build and run the application.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以构建和运行应用程序。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our application communicates with an external device connected over a serial
    link. In POSIX operating systems, communication to devices is similar to operations
    with regular files and uses the same API; that is, the `open`, `close`, `read`,
    and `write` functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序与通过串行连接的外部设备通信。在POSIX操作系统中，与设备通信类似于对常规文件的操作，并使用相同的API；即`open`、`close`、`read`和`write`函数。
- en: All these functions return error codes to indicate various error conditions.
    Instead of using them directly, we wrap the communication in a class called `Device`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数返回错误代码，指示各种错误条件。我们将通信包装在一个名为`Device`的类中，而不是直接使用它们。
- en: 'Its constructor tries to open a file referred to by the `deviceName` constructor
    parameter. The constructor checks for the error code and, if it indicates an error,
    creates and throws an `std::system_error` exception:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它的构造函数尝试打开由`deviceName`构造函数参数引用的文件。构造函数检查错误代码，如果指示出现错误，则创建并抛出`std::system_error`异常：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We construct the `std::system_error` instance using three parameters. The first
    one is an error code we want to wrap in an exception. We use the value of the `errno`
    variable that's set by the `open` function when it returns an error. The second
    parameter is an error category. Since we use an error code specific to the operating
    system, we use an instance of `std::system_category`. The first parameter is a
    message we want to associate with the exception. It can be anything that helps
    us identify the error if it occurs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用三个参数构造`std::system_error`实例。第一个是我们想要包装在异常中的错误代码。我们使用`open`函数在返回错误时设置的`errno`变量的值。第二个参数是错误类别。由于我们使用特定于操作系统的错误代码，我们使用`std::system_category`的实例。第一个参数是我们想要与异常关联的消息。它可以是任何有助于我们在发生错误时识别错误的内容。
- en: 'In a similar way, we define the `Send` function, which sends data to the device.
    It is a wrapper around the `write` system function, and if `write` returns an
    error, we create and throw an `std::system_error` instance. The only difference
    is the message string since we want to differentiate between these two cases in
    our logs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们定义了`Send`函数，它向设备发送数据。它是`write`系统函数的包装器，如果`write`返回错误，我们创建并抛出`std::system_error`实例。唯一的区别是消息字符串，因为我们希望在日志中区分这两种情况：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the `Device` class has been defined, we can use it. Instead of opening
    a device and checking for errors, and then writing to the device and checking
    for errors again, we just create an instance of the `Device` class and send data
    to it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`Device`类之后，我们可以使用它。我们只需创建`Device`类的一个实例并向其发送数据，而不是打开设备并检查错误，然后再次写入设备并再次检查错误：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All error handling lies in the `catch` block after the main logic. If a system
    error is thrown, we log it to the standard output. Additionally, we print information
    about the error code, embedded in the exception:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有错误处理都在主逻辑之后的`catch`块中。如果抛出系统错误，我们将其记录到标准输出。此外，我们打印嵌入在异常中的错误代码的信息。
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we build and run the application, it shows the following output, if no
    device is connected as `/dev/ttyUSB0`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建和运行应用程序时，如果没有设备连接为`/dev/ttyUSB0`，它将显示以下输出：
- en: '![](img/e6da888b-864b-412d-8c25-e35b1e4323e1.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6da888b-864b-412d-8c25-e35b1e4323e1.png)'
- en: As expected, the error condition was detected and we can see all the required
    details, including the underlying operating system error code and its description.
    Note that the code that communicates with the device using the wrapper class is
    uncluttered and readable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，检测到了错误条件，我们可以看到所有必需的细节，包括底层操作系统错误代码及其描述。请注意，使用包装类与设备通信的代码是简洁易读的。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The C++ standard library comes with a number of predefined exceptions and error
    categories. For more details, check the C++ error handling reference at [https://en.cppreference.com/w/cpp/error](https://en.cppreference.com/w/cpp/error).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了许多预定义的异常和错误类别。有关更多详细信息，请查看C++错误处理参考[https://en.cppreference.com/w/cpp/error](https://en.cppreference.com/w/cpp/error)。
- en: Using constant references when catching exceptions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在捕获异常时使用常量引用
- en: C++ exceptions provide a powerful foundation for exception handling design.
    They are flexible and may be used in multiple different ways. You can throw exceptions
    of any type, including pointers and integers. You can catch exceptions by value
    or by reference. A wrong choice when it comes to selecting a data type may lead
    to performance hits or resource leaks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: C++异常为异常处理设计提供了强大的基础。它们灵活多样，可以以多种不同的方式使用。您可以抛出任何类型的异常，包括指针和整数。您可以通过值或引用捕获异常。在选择数据类型时做出错误选择可能会导致性能损失或资源泄漏。
- en: In this recipe, we will analyze potential pitfalls and learn how to use constant
    references in catch blocks for efficient and safe error handling.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将分析潜在的陷阱，并学习如何在catch块中使用常量引用来进行高效和安全的错误处理。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to create a sample application that throws and catches a custom
    exception and analyze how the data type choice affects efficiency. Follow these
    steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个样本应用程序，抛出并捕获自定义异常，并分析数据类型选择如何影响效率。按照以下步骤进行：
- en: In your working directory, that is, `~/test`, create a subdirectory called `catch`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录中，即`~/test`，创建一个名为`catch`的子目录。
- en: Use your favorite text editor to create a file called `catch.cpp` in the `catch` subdirectory.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`catch`子目录中创建一个名为`catch.cpp`的文件。
- en: 'Put the definition of the `Error` class in the `catch.cpp` file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Error`类的定义放在`catch.cpp`文件中：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we add helper functions to test three different ways of throwing and
    handling errors. We start with the function that catches exceptions by value:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加辅助函数来测试三种不同的抛出和处理错误的方式。我们从通过值捕获异常的函数开始：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we add a function that throws a pointer and catches the exception by
    pointer, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个抛出指针并通过指针捕获异常的函数，如下所示：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we add a function that uses a `const` reference to catch exceptions:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个使用`const`引用来捕获异常的函数：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After all the helper functions have been defined, we add the `main` function
    to tie everything together:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了所有辅助函数之后，我们添加`main`函数来将所有内容联系在一起：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We put the build rules for our application into a `CMakeLists.txt` file:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将应用程序的构建规则放入`CMakeLists.txt`文件中：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can now build and run the application.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以构建和运行应用程序了。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In our application, we defined a custom class called `Error` that we are going
    to use when throwing and catching exceptions. This class provides a constructor,
    a copy constructor, and a destructor that only logs information to the console.
    We need it to evaluate the efficiency of different exception catching approaches.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们定义了一个名为`Error`的自定义类，当抛出和捕获异常时将使用该类。该类提供了一个构造函数、一个复制构造函数和一个仅将信息记录到控制台的析构函数。我们需要它来评估不同异常捕获方法的效率。
- en: 'The `Error` class only contains the `code` data field, which is used to differentiate
    between instances of the class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error`类只包含`code`数据字段，用于区分类的实例：'
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We evaluate three approaches for exception handling. The first one, `CatchByValue`,
    is the most straightforward. We create and throw an instance of the `Error` class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们评估了三种异常处理方法。第一种`CatchByValue`是最直接的。我们创建并抛出`Error`类的一个实例：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we catch it by value:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过值捕获它：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second implementation, `CatchByPointer`, creates an instance of `Error`
    dynamically using the `new` operator:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种实现`CatchByPointer`，使用`new`运算符动态创建`Error`的实例：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We use a pointer to catch the exception:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用指针来捕获异常：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, `CatchByReference` throws an exception similar to `CatchByValue`,
    but it uses a `const` reference to `Error` when catching it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`CatchByReference`引发类似于`CatchByValue`的异常，但在捕获时使用`Error`的`const`引用：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Does it make any difference? When we run our program, we get the following
    output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么区别吗？当我们运行程序时，我们会得到以下输出：
- en: '![](img/0f5b8cf3-a4d9-4337-972f-32d2fdc7772c.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f5b8cf3-a4d9-4337-972f-32d2fdc7772c.png)'
- en: As you can see, when catching an object by value, a copy of the exception object
    was created. Though not critical in a sample application, this inefficiency can
    cause performance issues in a high-load application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过值捕获对象时，会创建异常对象的副本。虽然在示例应用程序中不是关键问题，但这种效率低下可能会导致高负载应用程序的性能问题。
- en: There is no inefficiency when catching exceptions by pointer, but we can see
    that the object destructor was not invoked, causing a memory leak. This can be
    avoided by calling `delete` from the `catch` block, but this is error-prone since
    it is not always clear who is responsible for destroying an object referenced
    by a pointer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指针捕获异常时不会出现效率低下，但我们可以看到对象的析构函数没有被调用，导致内存泄漏。可以通过在`catch`块中调用`delete`来避免这种情况，但这很容易出错，因为并不总是清楚谁负责销毁指针引用的对象。
- en: The reference approach is the safest and most efficient one. There is no memory
    leak and unnecessary copying. Also, making the reference constant gives the compiler
    a hint that it is not going to be changed and thus can be better optimized under
    the hood.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 引用方法是最安全和最有效的方法。没有内存泄漏和不必要的复制。同时，使引用为常量会给编译器一个提示，表明它不会被更改，因此可以在底层更好地进行优化。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Error handling is a complex area with a number of best practices, hints, and
    recommendations. Consider reading the C++ exceptions and error handling FAQ at
    [https://isocpp.org/wiki/faq/exceptions](https://isocpp.org/wiki/faq/exceptions)
    to master your exception handling skills.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是一个复杂的领域，有许多最佳实践、提示和建议。考虑阅读C++异常和错误处理FAQ [https://isocpp.org/wiki/faq/exceptions](https://isocpp.org/wiki/faq/exceptions)
    来掌握异常处理技能。
- en: Tackling static objects
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决静态对象问题
- en: In C++, object constructors throw exceptions if an object can't be instantiated
    properly. Normally, this does not cause any issues. An exception originating from
    an object constructed on the stack, or an object created dynamically using the
    `new` keyword, can be handled by the try-catch block around the code where the
    object was created.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，如果对象无法正确实例化，对象构造函数会抛出异常。通常，这不会引起任何问题。在堆栈上构造的对象或使用`new`关键字动态创建的对象引发的异常可以通过try-catch块处理，该块位于创建对象的代码周围。
- en: It gets more complicated for static objects, though. Such objects are instantiated
    before the execution enters the `main` function, so they cannot be wrapped in
    a try-catch block of the program. The C++ compiler handles this situation by calling
    the `std::terminate` function, which prints an error message and terminates the
    program. Even if the exception is non-fatal, there is no way to recover.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态对象来说，情况会变得更加复杂。这些对象在执行进入`main`函数之前就被实例化，因此它们无法被程序的try-catch块包裹。C++编译器通过调用`std::terminate`函数来处理这种情况，该函数打印错误消息并终止程序。即使异常是非致命的，也没有办法恢复。
- en: There are several ways to not get into this pitfall. As a general rule, only
    simple, integral data types should be allocated statically. If you still need
    to have a complex static object, make sure its constructor does not throw exceptions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以避免陷阱。作为一般规则，只应静态分配简单的整数数据类型。如果仍然需要具有复杂静态对象，请确保其构造函数不会引发异常。
- en: In this recipe, we will learn how to implement a constructor for static objects.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何为静态对象实现构造函数。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create a custom class that allocates a specified amount of memory and
    statically allocates two instances of the class. Follow these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个自定义类，该类分配指定数量的内存并静态分配两个类的实例。按照以下步骤进行：
- en: In your working directory, that is, `~/test`, create a subdirectory called `static`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录中，即`〜/test`，创建一个名为`static`的子目录。
- en: Use your favorite text editor to create a file called `static.cpp` in the `static` subdirectory.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`static`子目录中创建一个名为`static.cpp`的文件。
- en: 'Let''s define a class named `Complex`. Put its private field and the constructor
    in the `static.cpp` file:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`Complex`的类。将其私有字段和构造函数放在`static.cpp`文件中：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, define a destructor and the `IsValid` method:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个析构函数和`IsValid`方法：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After the class has been defined, we define two global objects, `small` and
    `large`, and the `main` function, which uses them:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类定义后，我们定义了两个全局对象`small`和`large`，以及使用它们的`main`函数：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we create a `CMakeLists.txt` file containing the build rules for our
    program:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`CMakeLists.txt`文件，其中包含我们程序的构建规则：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can now build and run the application.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以构建和运行应用程序。
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here, we defined the `Complex` class, and we intend to allocate instances of
    this class statically. To be safe, we need to make sure that neither the constructor
    nor the destructor of this class can throw exceptions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`Complex`类，并且我们打算静态分配此类的实例。为了安全起见，我们需要确保此类的构造函数和析构函数都不会引发异常。
- en: However, both the constructor and the destructor invoke operations that may
    potentially throw exceptions. The constructor performs memory allocation, while
    the destructor writes logs to standard output.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，构造函数和析构函数都调用可能引发异常的操作。构造函数执行内存分配，而析构函数将日志写入标准输出。
- en: 'The constructor allocates memory using the `new` operator, which throws an
    `std::bad_alloc` exception if memory can''t be allocated. We use an `std::nothrow`
    constant to select a non-throwing implementation of `new`. Instead of throwing
    an exception, `new` will return `nullptr` if it can''t allocate any memory:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数使用`new`运算符分配内存，如果无法分配内存，则会引发`std::bad_alloc`异常。我们使用`std::nothrow`常量来选择`new`的不抛出实现。`new`将返回`nullptr`而不是引发异常，如果它无法分配任何内存：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We wrap the body of the constructor in the `try` block to catch all exceptions.
    The `catch` block is empty – if the constructor fails, we can''t do much:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构造函数的主体放在`try`块中以捕获所有异常。`catch`块为空-如果构造函数失败，我们无能为力：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since we do not allow any exceptions to propagate to the upper level, we mark
    our constructor as non-throwing using a C++ keyword, that is, `noexcept`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不允许任何异常传播到上一级，因此我们使用C++关键字`noexcept`将我们的构造函数标记为不抛出异常：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, we need to know whether an object was created properly. For this purpose,
    we define a method called `IsValid`. It returns `true` if the memory was allocated,
    or `false` otherwise:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要知道对象是否被正确创建。为此，我们定义了一个名为`IsValid`的方法。如果内存已分配，则返回`true`，否则返回`false`：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The destructor does the reverse. It deallocates the memory and logs the status
    of deallocation to the console. As for the constructor, we do not want any exceptions
    to be propagated to the upper level, so we wrap the destructor body in a try-catch
    block:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数则相反。它释放内存并将释放状态记录到控制台。对于构造函数，我们不希望任何异常传播到上一级，因此我们将析构函数主体包装在try-catch块中：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we declare two global objects, `small` and `large`. Global objects are
    allocated statically. The size of the objects is artificially selected in a way
    that the `small` object will be allocated properly, but the allocation of the
    `large` object should fail:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们声明了两个全局对象`small`和`large`。全局对象是静态分配的。对象的大小是人为选择的，`small`对象将被正确分配，但`large`对象的分配应该失败：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In our `main` function, we check and print whether the objects are valid or
    not:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，检查并打印对象是否有效：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When we run our program, we see the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，我们会看到以下输出：
- en: '![](img/33ae692c-8dd9-4803-b71e-6bdfd2d91a90.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33ae692c-8dd9-4803-b71e-6bdfd2d91a90.png)'
- en: As we can see, the small object was allocated and deallocated properly. Initialization
    of the large object failed, but since it was designed to not throw any exceptions,
    it did not cause the abnormal termination of our application. You can use a similar
    technique for statically allocated objects to write robust and safe applications.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，小对象被正确分配和释放。大对象的初始化失败，但由于它被设计为不引发任何异常，因此并未导致我们应用程序的异常终止。您可以使用类似的技术来为静态分配的对象编写健壮且安全的应用程序。
- en: Working with watchdogs
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用看门狗
- en: Embedded applications are built to work without supervision. This includes the
    ability to recover from errors. If an application crashes, it can be restarted
    automatically. But what should we do if an application hangs by entering an endless
    loop or due to a deadlock?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式应用程序被设计为无需监督即可运行。这包括从错误中恢复的能力。如果应用程序崩溃，可以自动重新启动。但是，如果应用程序由于进入无限循环或由于死锁而挂起，我们该怎么办呢？
- en: Hardware or software watchdogs are used to prevent such situations. Applications
    should periodically notify or *feed* them to indicate that they keep operating
    normally. If a watchdog is not fed within a specific time interval, it terminates
    an application or restarts the system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件或软件看门狗用于防止这种情况发生。应用程序应定期通知或*喂养*它们，以指示它们保持正常运行。如果在特定时间间隔内未喂养看门狗，则它将终止应用程序或重新启动系统。
- en: Many different implementations of watchdogs exist, but their interfaces are
    essentially the same. They provide a function that applications can use to reset
    the watchdog timer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多不同的看门狗实现，但它们的接口本质上是相同的。它们提供一个函数，应用程序可以使用该函数重置看门狗定时器。
- en: In this recipe, we will learn how to create a simple software watchdog on top
    of POSIX signals subsystems. The same technique can be used to work with hardware
    watchdog timers or more sophisticated software watchdog services.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何在POSIX信号子系统之上创建一个简单的软件看门狗。相同的技术可以用于处理硬件看门狗定时器或更复杂的软件看门狗服务。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create an application that will define the `Watchdog` class and provide
    an example of its usage. Follow these steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，定义`Watchdog`类并提供其用法示例。按照以下步骤进行：
- en: In your working directory, that is, `~/test`, create a subdirectory called `watchdog`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录中，即`~/test`，创建一个名为`watchdog`的子目录。
- en: Use your favorite text editor to create a file called `watchdog.cpp` in the `watchdog` subdirectory.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`watchdog`子目录中创建一个名为`watchdog.cpp`的文件。
- en: 'Put the required includes in the `watchdog.cpp` file:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的包含放在`watchdog.cpp`文件中：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we define the `Watchdog` class itself:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`Watchdog`类本身：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the `main` function, which serves as a usage example for our watchdog:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`main`函数，作为我们看门狗的用法示例：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a `CMakeLists.txt` file containing the build rules for our program:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个包含程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can now build and run the application.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以构建并运行应用程序。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We need a mechanism to terminate our application when it hangs. Though we could
    spawn a special monitoring thread or process, there is another, simpler way to
    do this—POSIX signals.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种机制来在应用程序挂起时终止它。虽然我们可以生成一个特殊的监控线程或进程，但还有另一种更简单的方法——POSIX信号。
- en: Any process running in a POSIX operating system can receive a number of signals.
    To deliver a signal to the process, the operating system stops the normal execution
    of the process and invokes a corresponding signal handler.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在POSIX操作系统中运行的任何进程都可以接收多个信号。为了向进程传递信号，操作系统会停止进程的正常执行并调用相应的信号处理程序。
- en: One of the signals that can be delivered to the process is called `alarm` and,
    by default, its handler just terminates the application. This is exactly what
    we need to implement a watchdog.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可以传递给进程的信号之一称为`alarm`，默认情况下，它的处理程序会终止应用程序。这正是我们需要实现看门狗的地方。
- en: 'The constructor of our `Watchdog` class accepts one parameter, `seconds`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Watchdog`类的构造函数接受一个参数`seconds`：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It is a time interval for our watchdog and it is immediately passed into the
    `feed` method to activate the watchdog timer:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的看门狗的时间间隔，它立即传递到`feed`方法中以激活看门狗定时器：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `feed` method invokes a POSIX function `alarm` that sets the timer. If
    the timer is already set, it updates it with a new value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`feed`方法调用了一个POSIX函数`alarm`来设置计时器。如果计时器已经设置，它会用新值更新它：'
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we invoke the same `alarm` function in the destructor to disable the
    timer by passing a value of `0`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在析构函数中调用相同的`alarm`函数来通过传递值`0`来禁用计时器：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, each time we invoke the `feed` function, we shift the time when the process
    will receive the `alarm` signal. If, however, we do not invoke this function before
    the timer expires, it triggers the `alarm` handler, which terminates our process.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们调用`feed`函数时，都会改变进程接收`alarm`信号的时间。然而，如果在计时器到期之前我们没有调用这个函数，它就会触发`alarm`处理程序，终止我们的进程。
- en: 'To check it out, we''ve created a simple example. It is a loop that has 10
    iterations. On each iteration, we display a message and sleep for a specific interval.
    The interval is initially 700 ms and on each iteration, it increases by 300 ms;
    for example, 700 ms, 1,000 ms, 1,300 ms, and so on:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查它，我们创建了一个简单的示例。这是一个有10次迭代的循环。在每次迭代中，我们显示一条消息并休眠一段特定的时间间隔。初始间隔为700毫秒，每次迭代增加300毫秒；例如，700毫秒，1,000毫秒，1,300毫秒等等：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Our watchdog is set to a 2-second interval:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的看门狗设置为2秒的间隔：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s run the application and check how it works. It produces the following
    output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行应用程序并检查它的工作原理。它产生以下输出：
- en: '![](img/b755a216-3c0d-4381-9129-554f07f472ba.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b755a216-3c0d-4381-9129-554f07f472ba.png)'
- en: As we can see, the application was terminated after the sixth iteration, after
    the delay exceeded the watchdog interval. Moreover, since it was terminated abnormally,
    its return code is non-zero. If the application is spawned by another application
    or script, this is an indicator that the application needs to be restarted.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，应用程序在第六次迭代后被终止，因为延迟超过了看门狗的间隔。此外，由于它是异常终止的，它的返回代码是非零的。如果应用程序是由另一个应用程序或脚本生成的，这表明应用程序需要重新启动。
- en: The watchdog technique is a simple and efficient way to build robust embedded
    applications.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 看门狗技术是构建健壮嵌入式应用程序的一种简单有效的方法。
- en: Exploring heartbeats for highly available systems
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索高可用系统的心跳。
- en: In the preceding recipe, we learned how to prevent software from hanging using
    watchdog timers. A similar technique can be used to implement a highly available
    system, which consists of one or more software or hardware components that can
    perform the same function. If one of the components fails, another one can take
    over.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们学习了如何使用看门狗定时器来防止软件挂起。类似的技术可以用来实现高可用系统，它由一个或多个软件或硬件组件组成，可以执行相同的功能。如果其中一个组件失败，另一个组件可以接管。
- en: The component that is currently active should periodically advertise its health
    status to other, passive components using messages that are called **heartbeats**.
    When it reports an unhealthy status or doesn't report it within a specific amount
    of time, a passive component detects it and activates itself. When the failed
    component recovers, it can either transition into passive mode, monitoring the
    now active component for failures, or initiate a failback procedure to claim the
    active status back.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当前活动的组件应定期向其他被动组件广告其健康状态，使用称为**心跳**的消息。当它报告不健康状态或在特定时间内没有报告时，被动组件会检测到并激活自己。当失败的组件恢复时，它可以转换为被动模式，监视现在活动的组件是否失败，或者启动故障恢复过程来重新获得活动状态。
- en: In this recipe, we will learn how to implement a simple heartbeat monitor in
    our application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在我们的应用程序中实现一个简单的心跳监视器。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create an application that defines a `Watchdog` class and provide an
    example of its usage. Follow these steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个定义了`Watchdog`类并提供其用法示例的应用程序。按照以下步骤进行：
- en: In your working directory, that is, `~/test`, create a subdirectory called `heartbeat`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的工作目录中，即`~/test`，创建一个名为`heartbeat`的子目录。
- en: Use your favorite text editor to create a file called `heartbeat.cpp` in the `heartbeat` subdirectory.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器在`heartbeat`子目录中创建一个名为`heartbeat.cpp`的文件。
- en: 'Put the required includes in the `heatbeat.cpp` file:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`heatbeat.cpp`文件中放入所需的包含文件：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we define an `enum` to report the health status of the active worker:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`enum`来报告活动工作者的健康状态：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s create a class that encapsulates the heartbeat reporting and monitoring.
    We start with the class definition, its private fields, and its constructor:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个封装心跳报告和监控的类。我们从类定义、私有字段和构造函数开始：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we add a method to report the health status:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个报告健康状态的方法：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is followed by a health monitoring method:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是健康监控方法：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once the heartbeat logic has been defined, we create some functions so that
    we can use it in our test application:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦心跳逻辑被定义，我们创建一些函数，以便在我们的测试应用程序中使用它：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we add a `CMakeLists.txt` file containing the build rules for our program:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个包含程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can now build and run the application.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以构建和运行应用程序了。
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The heartbeats mechanism needs some kind of communication channel to let one
    component report its status to other components. In a system that is built around
    multiple processing units, the best choice would be network-based communication
    over sockets. Our application is running on a single node, and we can use one
    of the local IPC mechanisms instead.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 心跳机制需要某种通信渠道，让一个组件向其他组件报告其状态。在一个围绕多个处理单元构建的系统中，最好的选择是基于网络的套接字通信。我们的应用程序在单个节点上运行，因此我们可以使用本地IPC机制之一。
- en: We are going to use POSIX pipes mechanisms for our heartbeat transport. When
    a pipe is created, it provides two file descriptors for communication—one is used
    to read data, while the other is used to write data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用POSIX管道机制进行心跳传输。创建管道时，它提供两个文件描述符进行通信——一个用于读取数据，另一个用于写入数据。
- en: Besides the communication transport, we need to choose the time interval for
    taking over. If a monitoring process does not receive a heartbeat message within
    this interval, it should consider another component as unhealthy or failed, and
    perform some takeover action.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通信传输，我们还需要选择接管的时间间隔。如果监控过程在此间隔内未收到心跳消息，则应将另一个组件视为不健康或失败，并执行一些接管操作。
- en: 'We start by defining the possible health statuses of our applications. We use
    the C++ `enum class` to make the stats strictly typed, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义应用程序可能的健康状态。我们使用C++的`enum class`使状态严格类型化，如下所示：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Our application is simple and has only three statuses: `Ok`, `Unhealthy`, and
    `ShutDown`. The `ShutDown` status is an indicator that the active process is going
    to shut down normally and that no takeover action is needed.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序很简单，只有三种状态：`Ok`、`Unhealthy`和`ShutDown`。`ShutDown`状态表示活动进程将正常关闭，不需要接管操作。
- en: Then, we define the `Heartbeat` class, which encapsulates all message exchange,
    health reporting, and monitoring functions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义`Heartbeat`类，它封装了所有消息交换、健康报告和监控功能。
- en: 'It has two data fields that represent the monitoring time interval and the
    POSIX pipe that''s being used for message exchange:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个数据字段，表示监控时间间隔和用于消息交换的POSIX管道：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The constructor creates the pipe and throws an exception in the event of a
    failure:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数创建管道，并在失败时抛出异常：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The health reporting method is a simple wrapper around the `write` function.
    It writes the status, represented as an unsigned 8-bit integer value, to the `write`
    file descriptor of the pipe:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 健康报告方法是`write`函数的简单包装。它将状态以无符号8位整数值的形式写入管道的`write`文件描述符：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The monitoring method is more complex. It uses the POSIX `poll` function to
    wait for data in one or more file descriptors. In our case, we are interested
    in data from only one file descriptor—the read side of the pipe. We fill the `fds` structure
    used by `pol` with file descriptors and the types of events we are interested
    in:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 监控方法更复杂。它使用POSIX的`poll`函数等待一个或多个文件描述符中的数据。在我们的情况下，我们只对一个文件描述符中的数据感兴趣——管道的读端。我们填充`poll`使用的`fds`结构，其中包括文件描述符和我们感兴趣的事件类型：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Two Boolean flags control the polling loop. The `takeover` flag indicates whether
    the takeover action should be performed when we exit the loop, while the `polling`
    flag indicates whether the loop should exist or not:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 两个布尔标志控制轮询循环。`takeover`标志指示我们退出循环时是否应执行接管操作，而`polling`标志指示循环是否应该存在：
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'On each iteration of the loop, we poll for new data in the socket using the
    `poll` function. We use a monitoring interval passed into the constructor as a
    polling timeout:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，我们使用`poll`函数在套接字中轮询新数据。我们使用传入构造函数的监控间隔作为轮询超时：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The result of the `poll` function indicates one of three possible outcomes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll`函数的结果指示三种可能的结果之一：'
- en: If it is greater than zero, we have new data available to read from the communication
    pipe. We read the status from the communication channel and analyze it.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果大于零，我们可以从通信管道中读取新数据。我们从通信通道中读取状态并进行分析。
- en: If the status is `Ok`, we log it and go to the next iteration of polling.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态是`Ok`，我们记录下来并进入下一个轮询迭代。
- en: 'If the status is `ShutDown`, we need to exit the polling loop, but also prevent
    the `takeover` action. To do this, we set our Boolean flags accordingly:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态是`ShutDown`，我们需要退出轮询循环，但也要阻止`takeover`操作。为此，我们相应地设置我们的布尔标志：
- en: '[PRE67]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For any other health status, we break from the loop with the `takeover` flag
    set to `true`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何其他健康状态，我们会以`takeover`标志设置为`true`退出循环：
- en: '[PRE68]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`poll` returns zero in the case of a timeout. Similar to the `Unhealthy` status,
    we need to break from the loop and perform the `takeover` action:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在超时的情况下，`poll`返回零。与`Unhealthy`状态类似，我们需要从循环中退出并执行`takeover`操作：
- en: '[PRE69]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Finally, if the value returned by `poll` is less than zero, it indicates an
    error. There are several reasons why a system call can fail, with a very common
    one being when it is interrupted by a signal. This is not a real error; we only
    need to call `poll` again. For all other cases, we write a log message and keep
    polling.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`poll`返回的值小于零，表示出现错误。系统调用失败有几种原因，其中一个非常常见的原因是被信号中断。这不是真正的错误；我们只需要再次调用`poll`。对于所有其他情况，我们会写入日志消息并继续轮询。
- en: 'The monitoring method blocks while the monitoring loop is running, and it returns
    a Boolean value to let the caller know whether the takeover action should be performed
    or not:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 监控方法在监控循环运行时会阻塞，并返回一个布尔值，让调用者知道是否应执行`takeover`操作：
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, let''s try to use this class in a toy example. We''ll define a `Worker` function
    that accepts a reference to the `Heartbeat` instance and represents the job to
    be done:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在一个玩具示例中使用这个类。我们将定义一个接受`Heartbeat`实例引用并表示要完成的工作的`Worker`函数：
- en: '[PRE71]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'On each iteration of the inner loop, the `Worker` reports its health status:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部循环的每次迭代中，`Worker`报告其健康状态：
- en: '[PRE72]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'At some point, it reports its status as `Unhealthy`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，它报告其状态为`Unhealthy`：
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the `main` function, we create an instance of the `Heartbeat` class with
    a 200 ms polling interval:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们使用200毫秒的轮询间隔创建了一个`Heartbeat`类的实例：
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, we spawn two independent processes. A parent process starts monitoring
    and, if a takeover is needed, runs the `Worker` method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们生成两个独立的进程。父进程开始监视，并且如果需要接管，运行`Worker`方法：
- en: '[PRE75]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The child simply runs the `Worker` method. Let''s run the application and check
    how it works. It produces the following output:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 子类只是运行`Worker`方法。让我们运行应用程序并检查它的工作原理。它产生以下输出：
- en: '![](img/d55f961e-37da-4689-8aa0-f0d9f2e9a02a.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d55f961e-37da-4689-8aa0-f0d9f2e9a02a.png)'
- en: As we can see, the `Worker` method reports that it processes data, and the monitor
    detects its status as healthy. However, after the `Worker` method reports its
    status as `Unhealthy`, the monitor detects it immediately and reruns the worker
    again to keep processing. This strategy can be used to build a more elaborate
    health monitoring and failure recovery logic to implement high availability in
    a system you have designed and developed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`Worker`方法报告它正在处理数据，监视器检测到它的状态是健康的。然而，在`Worker`方法报告其状态为`Unhealthy`后，监视器立即检测到并重新运行工作程序，以继续处理。这种策略可以用于构建更复杂的健康监控和故障恢复逻辑，以实现您设计和开发的系统的高可用性。
- en: There's more...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In our example, we used two identical components that run simultaneously and
    monitor each other. However, if one of the components contains a software bug
    that, under certain conditions, causes the component to malfunction, there's a
    high chance that another identical component could suffer from this issue too.
    In safety-critical systems, you may need to develop two completely different implementations.
    This approach increases the cost and development time but results in the higher
    reliability of the system.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了两个同时运行并相互监视的相同组件。但是，如果其中一个组件包含软件错误，在某些条件下导致组件发生故障，那么另一个相同的组件也很可能受到这个问题的影响。在安全关键系统中，您可能需要开发两个完全不同的实现。这种方法会增加成本和开发时间，但会提高系统的可靠性。
- en: Implementing software debouncing logic
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现软件去抖动逻辑
- en: One of the common tasks of embedded applications is interacting with external
    physical controls such as buttons or switches. Though such objects have only two
    states – on and off – detecting the moment a button or switch changes state is
    not as simple as it may look.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式应用的常见任务之一是与外部物理控件（如按钮或开关）进行交互。尽管这些对象只有两种状态 - 开和关 - 但检测按钮或开关改变状态的时刻并不像看起来那么简单。
- en: When a physical button is pressed, it takes some time before the contact is
    established firmly. During this time, spurious interrupts can be triggered as
    if the button is bouncing between on and off states. Instead of reacting to every
    interrupt, an application should be able to filter out the spurious transitions.
    This is called **debouncing**.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理按钮被按下时，需要一些时间才能建立联系。在此期间，可能会触发虚假中断，就好像按钮在开和关状态之间跳动。应用程序不应该对每个中断做出反应，而应该能够过滤掉虚假的转换。这就是**去抖动**。
- en: Though it can be implemented at the hardware level, the most common approach
    is to do this through software. In this recipe, we will learn how to implement
    a simple and generic debouncing function that can be used with any type of input.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它可以在硬件级别实现，但最常见的方法是通过软件来实现。在本教程中，我们将学习如何实现一个简单通用的去抖动函数，可以用于任何类型的输入。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create an application that defines a generic debouncing function along
    with a test input. This function can be used for any practical purpose by replacing
    the test input with real input. Follow these steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，定义一个通用的去抖动函数以及一个测试输入。通过用真实输入替换测试输入，可以将此函数用于任何实际目的。按照以下步骤进行：
- en: In your working directory, that is, `~/test`, create a subdirectory called `debounce`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录中，即`~/test`，创建一个名为`debounce`的子目录。
- en: Use your favorite text editor to create a file called `debounce.cpp` in the `debounce` subdirectory.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`debounce`子目录中创建一个名为`debounce.cpp`的文件。
- en: 'Let''s add includes and a function called `debounce` to the `debounce.cpp`
    file:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`debounce.cpp`文件中添加包含和一个名为`debounce`的函数：
- en: '[PRE76]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, we add the `main` function, which shows how to use it:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加`main`函数，展示如何使用它：
- en: '[PRE77]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Add a `CMakeLists.txt` file containing the build rules for our program:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个包含程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can now build and run the application.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以构建和运行应用程序了。
- en: How it works...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our goal is to detect when a button has stopped bouncing between on and off
    states. We assume that if all consecutive attempts to read the button state return
    the same value (either on or off) within a specific interval of time, we can tell
    whether the button is really on or off.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是检测按钮在开和关状态之间停止跳动的时刻。我们假设如果所有连续尝试读取按钮状态在特定时间间隔内返回相同的值（开或关），我们就可以知道按钮是真正开着还是关着。
- en: 'We use this logic to implement the `debounce` function. Since we want to make
    the debouncing logic as generic as possible, the function should not know how
    to read the state of a button. That is why the function accepts two arguments:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个逻辑来实现`debounce`函数。由于我们希望去抖动逻辑尽可能通用，函数不应该知道如何读取按钮的状态。这就是为什么函数接受两个参数的原因：
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The first argument, `timeout`, defines that specific interval of time we need
    to wait to report a state change. The second argument, `handler`, is a function
    or a function-like object that knows how to read the state of the button. It is
    defined as a pointer to a Boolean function without arguments.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`timeout`定义了我们需要等待报告状态变化的特定时间间隔。第二个参数`handler`是一个函数或类似函数的对象，它知道如何读取按钮的状态。它被定义为指向没有参数的布尔函数的指针。
- en: 'The `debounce` function runs a loop. On each iteration, it calls the handler
    to read the state of the button and compares it with the previous value. If the
    values are equal, we check the time since the most recent state change. If it
    exceeds the timeout, we exit the loop and return:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`debounce`函数运行一个循环。在每次迭代中，它调用处理程序来读取按钮的状态并将其与先前的值进行比较。如果值相等，我们检查自最近状态变化以来的时间。如果超过超时时间，我们退出循环并返回：'
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If the values are not equal, we reset the time for the most recent state change
    and keep waiting:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值不相等，我们会重置最近状态变化的时间并继续等待：
- en: '[PRE81]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To minimize the CPU load and let other processes do some work, we add a 1-millisecond
    delay between reads. If the function is intended to be used on a microcontroller
    that does not run a multitasking operating system, this delay is not needed:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化CPU负载并让其他进程做一些工作，我们在读取之间添加了1毫秒的延迟。如果函数打算用于不运行多任务操作系统的微控制器上，则不需要这个延迟：
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Our `main` function contains a usage example for the `debounce` function. We
    use the C++ lambda to define a simple rule to read the button. It always returns
    `true`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`函数包含了对`debounce`函数的使用示例。我们使用C++ lambda来定义一个简单的规则来读取按钮。它总是返回`true`：
- en: '[PRE83]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We pass `10ms` as a `debounce` timeout. If we run our program, we will see
    the following output:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`10ms`作为`debounce`超时传递。如果我们运行我们的程序，我们将看到以下输出：
- en: '![](img/15406ee1-e262-4eca-b5d6-f744a0738e85.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15406ee1-e262-4eca-b5d6-f744a0738e85.png)'
- en: The `debounce` function works for 10 ms and returns `true` since there were
    no spurious state changes in the test input. In the case of real input, it may
    take more time until the button state stabilizes. This simple yet efficient debouncing
    function can be applied to a variety of real inputs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`debounce`函数工作了10毫秒并返回`true`，因为测试输入中没有出现意外的状态变化。在实际输入的情况下，可能需要更多的时间才能使按钮状态稳定下来。这个简单而高效的去抖动函数可以应用于各种真实的输入。'
