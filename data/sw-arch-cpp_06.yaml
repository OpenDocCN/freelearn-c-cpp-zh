- en: Architectural and System Design
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 架构和系统设计
- en: 'Patterns help us deal with complexity. At the level of a single software component,
    you can use software patterns such as the ones described by the four authors of
    the book (better known as the *Gang of Four*) *Design Patterns: Elements of Reusable
    Object-Oriented Software*. When we move higher up and start looking at the architecture
    between different components, knowing when and how to apply architectural patterns
    can go a long way.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模式帮助我们处理复杂性。在单个软件组件的级别上，您可以使用软件模式，例如由该书的四位作者描述的模式（更为人所知的是*四人帮*）*设计模式：可重用面向对象软件的元素*。当我们向上移动并开始查看不同组件之间的架构时，知道何时以及如何应用架构模式可以大有裨益。
- en: There are countless such patterns that are useful for different scenarios. In
    fact, to even get to know all of them, you would need to read more than just one
    book. That being said, we selected several patterns for this book, suited for
    achieving various architectural goals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有无数这样的模式适用于不同的场景。实际上，要了解所有这些模式，您需要阅读不止一本书。话虽如此，我们为本书选择了几种模式，适用于实现各种架构目标。
- en: In this chapter, we'll introduce you to a few concepts and fallacies related
    to architectural design; we'll show when to use the aforementioned patterns and
    how to design high-quality components that are easy to deploy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍与架构设计相关的一些概念和谬论；我们将展示何时使用上述模式以及如何设计易于部署的高质量组件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The different service models and when to use each of them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的服务模型以及何时使用它们
- en: How to avoid the fallacies of distributed computing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免分布式计算的谬论
- en: The outcomes of the CAP theorem and how to achieve eventual consistency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CAP定理的结果以及如何实现最终一致性
- en: Making your system fault-tolerant and available
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的系统具有容错性和可用性
- en: Integrating your system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成您的系统
- en: Achieving performance at scale
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现规模的性能
- en: Deploying your system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署您的系统
- en: Managing your APIs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理您的API
- en: By the end of this chapter, you'll know how to design your architecture to provide
    several important qualities, such as fault tolerance, scalability, and deployability.
    Before that, let's first learn about two inherent aspects of distributed architectures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将了解如何设计您的架构以提供几个重要的特性，例如容错性、可伸缩性和可部署性。在那之前，让我们首先了解分布式架构的两个固有方面。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code from this chapter requires the following tools to build and run:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码需要以下工具来构建和运行：
- en: Docker
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Docker Compose
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: The source code snippets from the chapter can be found at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter04](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter04).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码片段可以在[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter04](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter04)找到。
- en: Understanding the peculiarities of distributed systems
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解分布式系统的特殊性
- en: There are many types of different software systems, each of them suited for
    different scenarios, built for different needs, and using different sets of assumptions.
    Writing and deploying a classical, standalone desktop application is nothing like
    writing and deploying a microservice that needs to communicate with many others
    over a network.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的软件系统，每种系统都适用于不同的场景，为不同的需求构建，并使用不同的假设集。编写和部署经典的独立桌面应用程序与编写和部署需要通过网络与许多其他应用程序通信的微服务完全不同。
- en: In this section, we'll go through the various models that you can use to deploy
    your software, the common mistakes that people should avoid when creating distributed
    systems, and some of the compromises people need to make to create such systems
    successfully.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍您可以用来部署软件的各种模型，人们在创建分布式系统时应避免的常见错误，以及人们需要做出的一些妥协，以成功创建这样的系统。
- en: Different service models and when to use them
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的服务模型以及何时使用它们
- en: Let's first start with service models. When designing a bigger system, you need
    to decide how much of the infrastructure you will manage versus how much you can
    build upon existing building blocks. Sometimes, you might want to leverage existing
    software without the need to manually deploy an app or back up data, for example,
    by using Google Drive through its API as storage for your app. Other times, you
    can rely on an existing cloud platform such as Google's App Engine to deploy your
    solution without the need to worry about providing a language runtime or databases.
    If you can decide to deploy everything in your own way, you can either leverage
    an infrastructure from a cloud provider or use your company's one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从服务模型开始。在设计一个更大的系统时，您需要决定您将管理多少基础设施，而不是您可以建立在现有构建块之上。有时，您可能希望利用现有软件，而无需手动部署应用程序或备份数据，例如，通过其API使用Google
    Drive作为应用程序的存储。其他时候，您可以依赖于现有的云平台，例如Google的App Engine，以部署您的解决方案，而无需担心提供语言运行时或数据库。如果您可以决定以自己的方式部署所有内容，您可以利用云提供商的基础设施，或者使用您公司的基础设施。
- en: Let's discuss the different models and where each can be useful.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论不同的模型以及每种模型在哪里可以有用。
- en: On-premises model
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地模型
- en: The classical way, and the only way available in the pre-cloud era, is to just
    deploy everything on your own premises. You need to buy all the hardware and software
    required and make sure it will provide enough capacity for your needs. If you're
    working for a start-up company, this may be a big upfront cost. Along with the
    growth of your userbase, you need to buy and set up more resources so that your
    service can deal even with the occasional spikes in load. All this means you need
    to predict the growth of your solution and act proactively, as there's no way
    you could just automatically scale depending on the current load.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的方式，也是在云之前唯一可用的方式，就是在自己的场地部署一切。您需要购买所有所需的硬件和软件，并确保它能够满足您的需求。如果您在一家初创公司工作，这可能是一个很大的前期成本。随着用户群的增长，您需要购买和设置更多的资源，以便您的服务甚至可以处理偶尔的负载峰值。所有这些意味着您需要预测解决方案的增长并积极行动，因为没有办法根据当前负载自动扩展。
- en: Even in the cloud era, deploying on-premises is still useful and often spotted
    in the wild. Sometimes you're dealing with data that shouldn't, or even can't,
    leave your company's premises, either due to data privacy issues or compliance
    ones. Other times, you need to have as little latency as possible and you need
    your own data center to do so. Sometimes you may calculate the costs and decide
    that in your case, on-premises will be cheaper than a cloud solution. Last, but
    not least, your company might just already have an existing data center that you
    can use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在云时代，本地部署仍然是有用的，并且经常在实际中发现。有时您处理的数据不应该，甚至不能离开公司的场地，要么是由于数据隐私问题，要么是合规问题。其他时候，您需要尽可能少的延迟，并且您需要自己的数据中心来实现。有时您可能会计算成本并决定在您的情况下，本地部署将比云解决方案更便宜。最后，但同样重要的是，您的公司可能已经拥有现有的数据中心，您可以使用。
- en: Deploying on-premises doesn't mean you need to have a monolith system. Often,
    companies have their own private clouds deployed on-premises. This helps to cut
    costs by better utilization of the available infrastructure. You can also mix
    a private cloud solution with one of the other service models, which can be useful
    when you need that extra capacity from time to time. This is called a **hybrid
    deployment** and is offered by all major cloud providers as well as provided by
    OpenStack's Omni project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地部署并不意味着您需要拥有一个单体系统。通常，公司在本地部署自己的私有云。这有助于通过更好地利用可用基础设施来降低成本。您还可以将私有云解决方案与其他服务模型相结合，这在您需要不时的额外容量时可能很有用。这被称为混合部署，并且所有主要的云提供商都提供了这种服务，同时OpenStack的Omni项目也提供了这种服务。
- en: Infrastructure as a Service (IaaS) model
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础设施即服务（IaaS）模型
- en: 'Speaking of other models, the most basic cloud service model is called **Infrastructure
    as a Service** (**IaaS**). It''s also the most similar to on-premises: you can
    think of IaaS as a way to have a virtual data center. As the name suggests, the
    cloud provider offers you a slice of the infrastructure they host, which consists
    of three types of resources:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 说到其他模型，最基本的云服务模型被称为基础设施即服务（IaaS）。它也与本地部署最相似：你可以将IaaS看作是虚拟数据中心的一种方式。正如其名称所示，云提供商为您提供了他们托管的基础设施的一部分，其中包括三种类型的资源：
- en: Compute, such as virtual machines, containers, or bare-metal machines (excluding
    operating systems)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算，例如虚拟机、容器或裸金属机器（不包括操作系统）
- en: Networking, which aside from the network itself includes DNS servers, routing,
    and firewalls
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络，除了网络本身外，还包括DNS服务器、路由和防火墙
- en: Storage, including backup and recovery capabilities
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储，包括备份和恢复功能
- en: 'It''s still up to you to provide all the software: operating systems, middleware,
    and your applications.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然需要提供所有软件：操作系统、中间件和您的应用程序。
- en: IaaS can be used in scenarios ranging from hosting websites (might be cheaper
    than traditional web hosting), through storage (for example, Amazon's S3 and Glacier
    services), to high-performance computing and big data analysis (requires huge
    computing power). Some companies use it to quickly set up and purge test and development
    environments when needed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: IaaS可用于从托管网站（可能比传统的网站托管更便宜）到存储（例如，亚马逊的S3和Glacier服务），再到高性能计算和大数据分析（需要大量计算能力）的场景。一些公司使用它来快速建立和清除测试和开发环境。
- en: Using IaaS instead of on-premises infrastructure can be a cheap way to test
    new ideas while saving you the time needed for configuration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IaaS而不是本地基础设施可以是测试新想法的廉价方式，同时节省配置所需的时间。
- en: 'If your service observes spikes in usage, for example, during the weekends,
    you might want to leverage your cloud''s automatic scaling capabilities: scale
    up when needed and scale back down later to save money.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的服务观察到使用量的增加，例如在周末，您可能希望利用云的自动扩展能力：在需要时扩展，稍后缩小规模以节省资金。
- en: IaaS solutions are offered by all the popular cloud service providers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有流行的云服务提供商都提供IaaS解决方案。
- en: A similar concept, sometimes thought of as a subset of IaaS, is **Containers
    as a Service** (**CaaS**). In CaaS, instead of bare-metal systems and virtual
    machines, the service provides you with containers and orchestration capabilities
    that you can use to build your own container clusters. CaaS offerings can be found
    with Google Cloud Platform and AWS, among others.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的概念，有时被认为是IaaS的子集，是容器即服务（CaaS）。在CaaS中，服务不是提供裸金属系统和虚拟机，而是提供容器和编排功能，您可以使用它们构建自己的容器集群。CaaS的服务可以在谷歌云平台和AWS等地方找到。
- en: Platform as a Service (PaaS) model
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平台即服务（PaaS）模型
- en: If the infrastructure itself is not enough for your needs, you can use the **Platform
    as a Service** (**PaaS**) model instead. In this model, the cloud service provider
    manages not only the infrastructure (just like in IaaS), but also the operating
    systems, any required middleware, and the runtime – the platform that you will
    deploy your software on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基础设施本身不足以满足您的需求，您可以使用平台即服务（PaaS）模型。在这种模型中，云服务提供商不仅管理基础设施（就像在IaaS中一样），还管理操作系统、任何所需的中间件和运行时
    - 您将在其上部署软件的平台。
- en: Often a PaaS solution will provide you with app versioning capabilities, service
    monitoring and discovery, database management, business intelligence, and even
    development tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，PaaS解决方案将为您提供应用程序版本控制功能、服务监控和发现、数据库管理、业务智能，甚至开发工具。
- en: 'With PaaS, you''re covered throughout the whole development pipeline: from
    building and testing to deploying, updating, and managing your service. However,
    PaaS solutions are more costly than IaaS offerings. On the other hand, with the
    whole platform provided, you can cut the costs and time to develop parts of your
    software and easily provide the same setup for development teams scattered around
    the globe.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PaaS，您可以在整个开发流程中得到覆盖：从构建和测试到部署、更新和管理您的服务。然而，PaaS解决方案比IaaS提供的更昂贵。另一方面，由于整个平台已经提供，您可以削减成本和时间来开发软件的部分，并且可以轻松为遍布全球的开发团队提供相同的设置。
- en: All main cloud providers have their own offerings, for example, Google App Engine
    or Azure App Service. There are also independent ones, such as Heroku.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的云提供商都有自己的产品，例如Google App Engine或Azure App Service。还有一些独立的产品，比如Heroku。
- en: Aside from the more generic PaaS, there's also **Communications Platform as
    a Service** (**CPaaS**), in which you're provided with the whole communications
    backend, including audio and video, which you can integrate into your solution.
    This technology allows you to easily provide video-enabled help desks or just
    integrate live chats into your apps.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更通用的PaaS之外，还有**通信平台即服务**（CPaaS），其中您将获得整个通信后端，包括音频和视频，您可以将其集成到您的解决方案中。这项技术使您能够轻松提供支持视频的帮助台，或者只是将实时聊天集成到您的应用程序中。
- en: Software as a Service (SaaS) model
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件即服务（SaaS）模型
- en: Sometimes you might not want to develop a software component on your own and
    just want to use an existing one. **Software as a Service** (**SaaS**) basically
    gives you a hosted application. With SaaS, you don't need to worry about either
    the infrastructure or the platform built upon it, and not even about the software
    itself. The provider is responsible for installing, running, updating, and maintaining
    the whole software stack, as well as backups, licensing, and scaling.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能不想自己开发软件组件，只想使用现有的组件。**软件即服务**（SaaS）基本上为您提供了托管的应用程序。使用SaaS，您无需担心基础架构或基于其上构建的平台，甚至不用担心软件本身。提供者负责安装、运行、更新和维护整个软件堆栈，以及备份、许可和扩展。
- en: There's quite a variety to what software you can get in the SaaS model. Examples
    vary from office suites such as Office 365 and Google Docs to messaging software
    such as Slack, through **Customer Relationship Management** (**CRM**) systems,
    and span even to gaming solutions such as cloud gaming services, allowing you
    to play resource-hungry video games hosted on the cloud.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在SaaS模型中，您可以获得各种各样的软件。示例包括办公套件，如Office 365和Google Docs，以及消息软件，如Slack，还有**客户关系管理**（CRM）系统，甚至涵盖云游戏服务，允许您在云上玩耗费大量资源的视频游戏。
- en: Usually, to access such services, all you need is a browser, so this can be
    a great step in providing remote work capabilities for your employees.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要访问这些服务，您只需要一个浏览器，因此这可以是为您的员工提供远程工作能力的重要一步。
- en: You can create your own SaaS applications and provide them to users either by
    deploying them however you like, or through means such as AWS Marketplace.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建自己的SaaS应用程序，并通过部署它们的方式或通过AWS Marketplace等方式向用户提供。
- en: '**Function as a Service (**FaaS) model and serverless architecture'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数即服务（FaaS）模型和无服务器架构'
- en: With the advent of cloud-native, another model that is growing in popularity
    is **Function as a Service** (**FaaS**). It can be helpful if you want to achieve
    a serverless architecture. With FaaS, you get a platform (similarly to PaaS) on
    which you can run short-lived applications, or functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云原生的出现，另一种日益流行的模型是**函数即服务**（FaaS）。如果您想实现无服务器架构，这可能会有所帮助。使用FaaS，您可以获得一个平台（类似于PaaS），在该平台上可以运行短暂的应用程序或函数。
- en: With PaaS, you typically always need to have at least one instance of your service
    running, while in FaaS you can run them only when they're actually needed. Running
    your function can make the time to handle requests longer (measured in seconds;
    you need to launch the function after all). However, some of those requests can
    be cached to reduce both the latency and costs. Speaking about costs, FaaS can
    get way more expensive than PaaS if you run the functions for a long time, so
    you must do the math when designing your system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PaaS，通常您始终需要至少运行一个实例的服务，而在FaaS中，您只能在实际需要时运行它们。运行您的函数可能会使处理请求的时间变长（以秒为单位；毕竟您需要启动函数）。然而，一些请求可以被缓存以减少延迟和成本。说到成本，如果您长时间运行函数，FaaS可能会比PaaS更昂贵，因此在设计系统时必须进行计算。
- en: If used correctly, FaaS abstracts away the servers from the developers, can
    reduce your costs, and can provide you with better scalability, as it can be based
    on events, not resources. This model is commonly used for running prescheduled
    or manually triggered tasks, processing batches or streams of data, and handling
    incoming, not-so-urgent requests. A few popular providers of FaaS are AWS Lambda,
    Azure Functions, and Google Cloud Functions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用正确，FaaS可以将服务器从开发人员那里抽象出来，可以降低成本，并且可以提供更好的可伸缩性，因为它可以基于事件而不是资源。这种模型通常用于运行预定或手动触发的任务，处理批处理或数据流，以及处理不太紧急的请求。一些流行的FaaS提供者包括AWS
    Lambda、Azure Functions和Google Cloud Functions。
- en: Now that we've covered the common service models in the cloud, let's discuss
    some of the wrong assumptions people make when designing distributed systems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了云中常见的服务模型，让我们讨论一些人们在设计分布式系统时常犯的错误假设。
- en: Avoiding the fallacies of distributed computing
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免分布式计算的谬论
- en: When people new to distributed computing begin their journey with designing
    such systems, they tend to forget or ignore a few aspects of such systems. Although
    they were first noticed back in the 90s, they remain current today.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当刚接触分布式计算的人开始设计这样的系统时，他们往往会忘记或忽视这些系统的一些方面。尽管这些问题在90年代就被注意到，但它们至今仍然存在。
- en: The fallacies are discussed in the following sub-sections. Let's have a quick
    rundown on each of them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些谬误将在以下子部分中讨论。让我们快速浏览一下每个谬误。
- en: The network is reliable
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络是可靠的
- en: Networking equipment is designed for long years of flawless operation. Despite
    that, many things can still cause packet loss, ranging from power outages through
    poor wireless networking signal, configuration errors, someone tripping over a
    cable, or even animals biting through wires. For instance, Google had to protect
    their underwater cables with Kevlar because they were being bitten by sharks (yes,
    really). You should always assume that data can get lost somewhere over the network.
    Even if that doesn't happen, software issues can still occur on the other side
    of the wire.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备设计用于长时间无故障运行。尽管如此，许多事情仍然可能导致数据包丢失，从停电到无线网络信号差，配置错误，有人绊倒电缆，甚至动物咬断电线。例如，谷歌不得不用凯夫拉保护他们的水下电缆，因为它们被鲨鱼咬断（是的，真的）。您应该始终假设数据可能在网络中的某个地方丢失。即使这种情况没有发生，软件问题仍可能发生在电线的另一端。
- en: To fend off such issues, be sure you have a policy for automatically retrying
    failed network requests and a way to handle common networking issues. When retrying,
    try to not overload the other party and not commit the same transaction multiple
    times. You can use a message queue to store and retry sending for you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抵御这些问题，请确保您有一个自动重试失败的网络请求的策略，并且有一种处理常见网络问题的方法。在重试时，尽量不要过载对方，并且不要多次提交相同的事务。您可以使用消息队列来存储和重试发送。
- en: Patterns such as circuit breaker, which we'll show later in this chapter, can
    also help. Oh, and be sure to not just wait infinitely, hogging up resources with
    each failed request.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如断路器之类的模式，我们稍后将在本章中展示，也可以帮助。哦，并且请确保不要无限等待，每次失败的请求都会占用资源。
- en: Latency is zero
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟为零
- en: Both the network and the services you're running have to take some time to respond
    even under normal conditions. Occasionally they'll have to take longer, especially
    when being under a bigger-than-average load. Sometimes instead of a few milliseconds,
    your requests can take seconds to complete.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和您运行的服务在正常情况下都需要一些时间来响应。偶尔它们可能需要更长的时间，特别是在承受比平均负载更大的情况下。有时，您的请求完成可能需要几秒钟，而不是几毫秒。
- en: Try to design your system so it doesn't wait on too many fine-grained remote
    calls, as each such call can add to your total processing time. Even in a local
    network, 10,000 requests for 1 record will be much slower than 1 request for 10,000
    records. To reduce network latency, consider sending and handling requests in
    bulk. You can also try to hide the cost of small calls by doing other processing
    tasks while waiting for their results.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量设计系统，使其不要等待太多细粒度的远程调用，因为每个这样的调用都会增加总处理时间。即使在本地网络中，1条记录的10,000个请求也比10,000条记录的1个请求慢得多。为了减少网络延迟，考虑批量发送和处理请求。您还可以尝试在等待其结果时执行其他处理任务，以隐藏小调用的成本。
- en: Other ways to deal with latency are to introduce caches, push the data in a
    publisher-subscriber model instead of waiting for requests, or deploy closer to
    the customers, for example, by using **Content Delivery Networks** (**CDN**s).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 处理延迟的其他方法是引入缓存，以发布者-订阅者模型推送数据，而不是等待请求，或者部署更接近客户，例如使用内容传送网络（CDN）。
- en: Bandwidth is infinite
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带宽是无限的
- en: When adding a new service to your architecture, make sure you take note of how
    much traffic it's going to use. Sometimes you might want to reduce the bandwidth
    by compressing the data or by introducing a throttling policy.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在向架构中添加新服务时，请确保注意它将使用多少流量。有时，您可能希望通过压缩数据或引入限流策略来减少带宽。
- en: This fallacy also has to do with mobile devices. If the signal is weak, often
    the network will become the bottleneck. This means the amount of data a mobile
    app uses should generally be kept low. Using the *Backends for Frontends* pattern
    described in [Chapter 2](6fbde08c-f8a2-475d-9984-2a9882a761b4.xhtml)*, Architectural
    Styles,* can often help save precious bandwidth.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谬误也与移动设备有关。如果信号弱，网络通常会成为瓶颈。这意味着移动应用程序使用的数据量通常应保持较低。使用本章中描述的“用于前端的后端”模式，通常可以帮助节省宝贵的带宽。
- en: 'If your backend needs to transfer lots of data between some components, try
    to make sure such components are close together: don''t run them in separate data
    centers. With databases, this often boils down to better replication. Patterns
    such as CQRS (discussed later in this chapter) are also handy.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的后端需要在某些组件之间传输大量数据，请确保这些组件彼此靠近：不要将它们运行在不同的数据中心。对于数据库来说，这通常归结为更好的复制。诸如CQRS（本章后面将讨论）之类的模式也很有用。
- en: The network is secure
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络是安全的
- en: 'This is a dangerous fallacy. A chain is only as strong as its weakest link,
    and unfortunately, there are many links in distributed systems. Here are a few
    ways to make those links stronger:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个危险的谬误。一条链只有其最薄弱的一环那么强大，不幸的是，分布式系统中有许多环节。以下是使这些环节更强大的一些方法：
- en: Be sure to always apply security patches to every component that you use, to
    your infrastructure, operating systems, and other components.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请务必始终对您使用的每个组件，您的基础设施，操作系统和其他组件应用安全补丁。
- en: Train your personnel and try to protect your system from the human factor; sometimes
    it's a rogue employee that compromises a system.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 培训您的人员，并尽量保护系统免受人为因素的影响；有时候是一个流氓员工危害了系统。
- en: If your system will be online, it will get attacked, and it's possible that
    a breach will happen at one point. Be sure to have a written plan on how to react
    to such events.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的系统在线，它将受到攻击，并且可能会发生一次违规事件。请确保制定如何应对此类事件的书面计划。
- en: You might have heard about the defense in depth principle. It boils down to
    having different checks for different parts of your system (your infrastructure,
    your applications, and so on) so that when a breach happens, its range, and the
    associated damage, will be limited.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能听说过深度防御原则。它归结为对系统的不同部分（基础设施、应用程序等）进行不同的检查，以便在发生违规时，其范围和相关损害将受到限制。
- en: Use firewalls, certificates, encryption, and proper authentication.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用防火墙、证书、加密和适当的身份验证。
- en: For more on security, refer to [Chapter 10](7b56cb2d-e7f9-4cba-b24b-4a875cf8d520.xhtml),
    *Security in Code and Deployment*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安全性的更多信息，请参阅[第10章](7b56cb2d-e7f9-4cba-b24b-4a875cf8d520.xhtml)，*代码和部署中的安全性*。
- en: Topology doesn't change
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拓扑结构不会改变
- en: This one became especially true in the microservices era. Autoscaling and the
    emergence of the *cattle, not pets* approach to managing infrastructure mean that
    the topology will constantly change. This can affect latency and bandwidth, so
    some of this fallacy's outcomes are the same as the ones described earlier.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这在微服务时代尤为真实。自动扩展和管理基础设施的*牛群而非宠物*方法的出现意味着拓扑结构将不断变化。这可能会影响延迟和带宽，因此这种谬误的一些结果与前面描述的结果相同。
- en: Fortunately, the mentioned approach also comes with guidelines on how to effectively
    manage your *herd* of servers. Relying on hostnames and DNS instead of hardcoding
    IPs is a step in the right direction, and service discovery, described later in
    this book, is another one. A third, even bigger, step is to always assume your
    instances can fail and automate reacting to such scenarios. Netflix's *Chaos Monkey
    tool* can also help you test your preparedness.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，上述方法还附带了如何有效管理*服务器群*的指南。依赖主机名和DNS而不是硬编码IP是朝着正确方向迈出的一步，而服务发现，本书后面描述的另一步。第三步，甚至更大的一步，是始终假设你的实例可能会失败并自动应对这种情况。Netflix的*混沌猴工具*也可以帮助你测试你的准备情况。
- en: There is one administrator
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有一个管理员
- en: The knowledge about distributed systems, due to their nature, is often distributed
    itself. Different people are responsible for the development, configuration, deployment,
    and administration of such systems and their infrastructure. Different components
    are often upgraded by different people, not necessarily in sync. There's also
    the so-called bus factor, which in short is the risk factor for a key project
    member being hit by a bus.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分布式系统的性质，对分布式系统的知识通常也是分布的。不同的人负责开发、配置、部署和管理这些系统及其基础设施。不同的组件通常由不同的人升级，不一定同步进行。还有所谓的公交因素，简而言之，就是关键项目成员被公交车撞击的风险因素。
- en: How do we deal with all of this? The answer consists of a few parts. One of
    them is the DevOps culture. By facilitating close collaboration between development
    and operations, people share the knowledge about the system, thus reducing the
    bus factor. Introducing continuous delivery can help with upgrading the project
    and keeping it always up.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何应对所有这些？答案包括几个部分。其中之一是DevOps文化。通过促进开发和运营之间的紧密合作，人们分享关于系统的知识，从而减少公交因素。引入持续交付可以帮助升级项目并使其始终保持更新。
- en: Try to model your system to be loosely coupled and backward compatible, so upgrades
    of components don't require other components to be upgraded too. An easy way to
    decouple is by introducing messaging between them, so consider adding a queue
    or two. It will help you with downtime during upgrades as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量将系统模块化并且向后兼容，这样组件的升级不需要其他组件也进行升级。一种简单的解耦方法是在它们之间引入消息传递，因此考虑添加一个或两个队列。这也将有助于在升级期间减少停机时间。
- en: Finally, try to monitor your system and gather logs in a centralized place.
    Decentralization of your system shouldn't mean you now need to manually look at
    logs at a dozen different machines. The **ELK** (**Elasticsearch, Logstash, Kibana**)
    stack is invaluable for this. Grafana, Prometheus, Loki, and Jaeger are also very
    popular, especially with Kubernetes. If you're looking for something more lightweight
    than Logstash, consider Fluentd and Filebeat, especially if you're dealing with
    containers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽量监控系统并将日志收集到一个集中的位置。系统的去中心化不应意味着你现在需要手动查看十几台不同的机器上的日志。**ELK**（**Elasticsearch，Logstash，Kibana**）堆栈对此非常宝贵。Grafana、Prometheus、Loki和Jaeger也非常受欢迎，特别是在Kubernetes中。如果你正在寻找比Logstash更轻量级的东西，可以考虑Fluentd和Filebeat，特别是如果你正在处理容器。
- en: Transport cost is zero
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输成本为零
- en: This fallacy is important for planning your project and its budget. Building
    and maintaining a network for a distributed system costs both time and money,
    regardless of whether you deploy on-premises or in the cloud – it's just a matter
    of when you pay the cost. Try to estimate the costs of the equipment, the data
    to be transferred (cloud providers charge for this), and the required manpower.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种谬误对规划项目和预算很重要。为分布式系统构建和维护网络无论是在本地部署还是在云端部署，都需要时间和金钱成本，只是支付成本的时间不同。尽量估算设备成本、数据传输成本（云提供商会收费）和所需的人力成本。
- en: If you're relying on compression, be wary that while this reduces networking
    costs, it can increase the price for your compute. In general, using binary APIs
    such as gRPC-based will be cheaper (and faster) than JSON-based ones, and those
    are still cheaper than XML. If you send images, audio, or video, it's a must to
    estimate how much this will cost you.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你依赖压缩，请注意，虽然这可以减少网络成本，但可能会增加计算成本。一般来说，使用基于gRPC的二进制API会比基于JSON的API更便宜（而且更快），而这些又比XML更便宜。如果你发送图像、音频或视频，估算一下这将给你带来多少成本是必要的。
- en: The network is homogeneous
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络是同质的
- en: Even if you plan what hardware to have and what software to run on your network,
    it's easy to end up with at least some heterogeneity. A slightly different configuration
    on some of the machines, a different communication protocol used by that legacy
    system that you need to integrate with, or different mobile phones sending requests
    to your system are just a few examples of this. Another one is extending your
    on-premises solution by using additional workers in the cloud.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您计划在网络上运行什么硬件和软件，也很容易最终出现至少一些异构性。一些机器上略有不同的配置，需要与之集成的传统系统使用不同的通信协议，或者不同的手机向您的系统发送请求，这些都是其中的一些例子。另一个例子是通过使用云中的额外工作人员来扩展您的本地解决方案。
- en: Try to limit the number of protocols and formats used, strive to use standard
    ones, and avoid vendor lock-in to ensure your system can still communicate properly
    in such heterogeneous environments. Heterogeneity can also mean differences in
    resiliency. Try to use the circuit breaker pattern along with retries to handle
    this.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量限制使用的协议和格式的数量，努力使用标准的协议，并避免供应商锁定，以确保您的系统在这种异构环境中仍然可以正常通信。异构性也可能意味着弹性上的差异。尝试使用断路器模式以及重试来处理这个问题。
- en: Now that we've discussed all the fallacies, let's discuss yet another pretty
    important aspect of distributed architectures.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了所有的谬误，让我们讨论一下分布式架构的另一个非常重要的方面。
- en: CAP theorem and eventual consistency
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CAP定理和最终一致性
- en: 'To design successful systems that spread across more than one node, you need
    to know and use certain principles. One of them is the **CAP theorem**. It''s
    about one of the most important choices you need to make when designing a distributed
    system and owes its name to the three properties a distributed system can have.
    They are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要设计成功的跨多个节点的系统，您需要了解并使用某些原则。其中之一就是**CAP定理**。它涉及到设计分布式系统时需要做出的最重要选择之一，并且得名于分布式系统可以具有的三个属性。它们如下：
- en: '**Consistency**: Every read would get you the data after the most recent write
    (or an error).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：每次读取都会得到最近一次写入之后的数据（或错误）。'
- en: '**Availability**: Every request will get a non-error response (without the
    guarantee that you''ll get the most recent data).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：每个请求都将获得非错误响应（但不能保证您将获得最新数据）。'
- en: '**Partition tolerance**: Even if a network failure occurs between two nodes,
    the system as a whole will continue working.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容忍性**：即使两个节点之间发生网络故障，整个系统仍将继续工作。'
- en: In essence, the theorem states that you can pick at most two of those three
    properties for a distributed system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，该定理表明您可以选择分布式系统的这三个属性中的最多两个。
- en: As long as the system operates properly, it looks like all three of the properties
    can be satisfied. However, as we know from looking at the fallacies, the network
    is unreliable, so partitions will occur. In such cases, a distributed system should
    still operate properly. This means the theorem actually makes you choose between
    delivering partition tolerance and consistency (that is CP), or partition tolerance
    and availability (that is AP). Usually, the latter is the better choice. If you
    want to choose CA, you have to remove the network entirely and be left with a
    single-node system.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 只要系统正常运行，看起来所有三个属性都可以得到满足。然而，正如我们从谬误中所知道的，网络是不可靠的，因此会发生分区。在这种情况下，分布式系统应该仍然可以正常运行。这意味着定理实际上让您在提供分区容忍性和一致性（即CP）之间做出选择，或者提供分区容忍性和可用性（即AP）之间做出选择。通常，后者是更好的选择。如果您想选择CA，您必须完全删除网络，并留下一个单节点系统。
- en: If under a partition, you decide to deliver consistency, you will have to either
    return an error or risk timeouts when waiting for the data to be consistent. If
    you choose availability over consistency, you risk returning stale data – the
    latest writes might be unable to propagate across the partition.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在分区下，您决定提供一致性，您将不得不返回错误或者在等待数据一致性时冒风险超时。如果您选择可用性而不是一致性，您将面临返回陈旧数据的风险-最新的写入可能无法在分区间传播。
- en: Both those approaches are suited for different needs. If your system requires
    atomic reads and writes, for instance, because a customer could lose their money,
    go with CP. If your system must continue operating under partitions, or you can
    allow eventual consistency, go with AP.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都适用于不同的需求。例如，如果您的系统需要原子读写，因为客户可能会丢失他们的钱，那么选择CP。如果您的系统必须在分区下继续运行，或者可以允许最终一致性，那么选择AP。
- en: Okay, but what is eventual consistency? Let's discuss the different levels of
    consistency to understand this.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但是什么是最终一致性？让我们讨论一下不同的一致性级别来理解这一点。
- en: In a system offering strong consistency, each write is synchronously propagated.
    This means all reads will always see the latest writes, even at the cost of higher
    latency or lower availability. This is the type that relational DBMSes offer (based
    on ACID guarantees) and is best suited for systems that require transactions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供强一致性的系统中，每次写入都是同步传播的。这意味着所有读取将始终看到最新的写入，即使以更高的延迟或更低的可用性为代价。这是关系型数据库管理系统提供的类型（基于ACID保证），最适合需要事务的系统。
- en: In a system offering eventual consistency, on the other hand, you only guarantee
    that after a write, reads will eventually see the change. Usually, *eventually*
    means in a couple of milliseconds. This is due to the asynchronous nature of data
    replication in such systems, as opposed to the synchronous propagation from the
    previous paragraph. Instead of providing ACID guarantees, for example, using an
    RDBMS, here we have BASE semantics, often provided by NoSQL databases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在提供最终一致性的系统中，您只保证在写入后，读取最终会看到更改。通常，“最终”意味着在几毫秒内。这是由于这些系统中数据复制的异步性质，与前一段中的同步传播相反。与提供ACID保证的关系型数据库管理系统不同，这里我们有BASE语义，通常由NoSQL数据库提供。
- en: For a system to be asynchronous and eventually consistent (as AP systems often
    are), it's needed to have a way to solve state conflicts. A common way to do so
    is to exchange updates between instances and choose either the first or the last
    write as the accepted one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步和最终一致的系统（通常是AP系统），需要有一种解决状态冲突的方法。解决这个问题的常见方法是在实例之间交换更新，并选择第一个或最后一个写入作为接受的写入。
- en: Let's now discuss two related patterns that can help in achieving eventual consistency.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论两种相关模式，可以帮助实现最终一致性。
- en: Sagas and compensating transactions
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sagas和补偿事务
- en: The saga pattern is useful when you need to perform distributed transactions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要执行分布式事务时，saga模式非常有用。
- en: Before the microservice era, if you had one host with one database, you could
    rely on the database engine to do the transaction for you. With multiple databases
    on one host, you could use **Two-Phase Commits** (**2PCs**) to do so. With 2PCs,
    you would have a coordinator, who would first tell all the databases to prepare,
    and once they all report being ready, it would tell them all to commit the transaction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务时代之前，如果您有一个主机和一个数据库，您可以依赖数据库引擎为您执行事务。在一个主机上有多个数据库时，您可以使用**两阶段提交**（**2PCs**）来执行。使用2PCs，您将有一个协调者，它首先会告诉所有数据库准备好，一旦它们都报告准备就绪，它会告诉它们所有提交事务。
- en: Now, as each microservice likely has its own database (and it should if you
    want scalability), and they're spanned all over your infrastructure, you can no
    longer rely on simple transactions and 2PCs (losing this ability often means you
    no longer want an RDBMS, as NoSQL databases can be much faster).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于每个微服务可能都有自己的数据库（如果您想要可伸缩性，它应该有），并且它们遍布在整个基础设施上，您不能再依赖简单的事务和2PCs（失去这种能力通常意味着您不再需要关系型数据库，因为NoSQL数据库可能会快得多）。
- en: Instead, you can use the saga pattern. Let's demonstrate it in an example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以使用saga模式。让我们通过一个例子来演示。
- en: 'Imagine you want to create an online warehouse that tracks how much supply
    it has and allows payment by credit cards. To process an order, above all other
    services, you need three: one for processing the order, one for reserving the
    supplies, and one for charging the card.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您想创建一个在线仓库，跟踪其供应量并允许使用信用卡付款。为了处理订单，除了其他服务，您需要三个：一个用于处理订单，一个用于预留供应，一个用于刷卡。
- en: 'Now, there are two ways the saga pattern can be implemented: **choreography-based**
    (also called **event-based**) and **orchestration-based** (also called **command-based**).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，saga模式可以通过两种方式实现：**编排式**（也称为**基于事件**）和**指挥式**（也称为**基于命令**）。
- en: Choreography-based sagas
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于编排的saga
- en: In the first case, the first part of the saga would be the order processing
    service sending an event to the supply service. This one would do its part and
    send another event to the payment service. The payment service would then send
    yet another event back to the order service. This would complete the transaction
    (the saga), and the order could now be happily shipped.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，saga的第一部分将是订单处理服务向供应服务发送一个事件。供应服务将完成其部分并向支付服务发送另一个事件。然后支付服务将向订单服务发送另一个事件。这将完成事务（saga），订单现在可以愉快地发货了。
- en: If the order service would want to track the state of the transaction, it would
    simply need to listen to all those events as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果订单服务想要跟踪事务的状态，它只需要监听所有这些事件即可。
- en: Of course, sometimes the order would be impossible to complete, and a rollback
    would need to happen. In this case, each step of the saga would need to be rolled
    back separately and carefully, as other transactions could run in parallel, for
    example, modifying the supply state. Such rollbacks are called **compensating
    transactions**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时订单可能无法完成，需要进行回滚。在这种情况下，saga的每个步骤都需要单独和谨慎地回滚，因为其他事务可能会并行运行，例如修改供应状态。这样的回滚被称为**补偿事务**。
- en: This way of implementing the saga pattern is pretty straightforward, but if
    there any many dependencies between the involved services it might be better to
    use the *orchestration* approach. Speaking of which, let's now say a few words
    about this second approach to sagas.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实现saga模式的这种方式非常直接，但如果涉及服务之间有很多依赖关系，最好使用*编排*方法。说到这一点，现在让我们谈谈saga的第二种方法。
- en: Orchestration-based sagas
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于编排的saga
- en: In this case, we'll need a message broker to handle communication between our
    services, and an orchestrator that would coordinate the saga. Our order service
    would send a request to the orchestrator, which would then send commands to both
    the supply and payment services. Each of those would then do their part and send
    replies back to the orchestrator, through a reply channel available at the broker.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将需要一个消息代理来处理我们服务之间的通信，并且需要一个编排者来协调saga。我们的订单服务将向编排者发送一个请求，然后编排者将向供应和支付服务发送命令。每个服务然后会完成其部分并通过代理的回复通道将回复发送回编排者。
- en: In this scenario, the orchestrator has all the logic needed to, well, orchestrate
    the transaction, and the services themselves don't need to be aware of any other
    services taking part in the saga.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编排者拥有所有必要的逻辑来，嗯，编排事务，而服务本身不需要知道参与saga的任何其他服务。
- en: If the orchestrator is sent a message that one of the services failed, for example,
    if the credit card has expired, it would then need to start the rollback. In our
    case, it would again use the broker to send an appropriate rollback command to
    specific services.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编排者收到消息表明其中一个服务失败，例如，如果信用卡已过期，那么它将需要开始回滚。在我们的情况下，它将再次使用代理向特定服务发送适当的回滚命令。
- en: Okay, that's enough about eventual consistency for now. Let's now switch to
    other topics related to availability.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在关于最终一致性的内容就说到这里。现在让我们转到与可用性相关的其他主题。
- en: Making your system fault tolerant and available
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使系统容错和可用
- en: Availability and fault tolerance are software qualities that are at least somewhat
    important for every architecture. What's the point of creating a software system
    if the system can't be reached? In this section, we'll learn what exactly those
    terms mean and a few techniques to provide them in your solutions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性和容错能力是每种架构至少有些重要的软件质量。如果系统无法访问，那么创建软件系统有什么意义呢？在本节中，我们将了解这些术语的确切含义以及提供解决方案的一些技术。
- en: Calculating your system's availability
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算系统的可用性
- en: Availability is the percentage of the time that a system is up, functional,
    and reachable. Crashes, network failures, or extremely high load (for example,
    from a DDoS attack) that prevents the system from responding can all affect its
    availability.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性是系统正常运行、功能正常且可访问的时间百分比。崩溃、网络故障或极高的负载（例如来自DDoS攻击）都可能影响其可用性。
- en: 'Usually, it''s a good idea to strive for as high a level of availability as
    possible. You may stumble upon the term *counting the nines*, as availability
    is often specified as 99% (two nines), 99.9% (three), and so on. Each additional
    nine is much harder to obtain, so be careful when making promises. Take a look
    at the following table to see how much downtime you could afford if you specified
    it on a monthly basis:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，努力实现尽可能高的可用性是一个好主意。您可能会遇到术语*计算九*，因为可用性通常被规定为99%（两个九）、99.9%（三个九）等。每增加一个九都更难获得，因此在做出承诺时要小心。看一下下表，看看如果您以每月的方式指定它，您可以承受多少停机时间：
- en: '| Downtime/month | Uptime |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 每月停机时间 | 正常运行时间 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 7 hours 18 minutes | 99% (“two nines”) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 7小时18分钟 | 99%（“两个九”）|'
- en: '| 43 minutes 48 seconds | 99.9% (“three nines”) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 43分钟48秒 | 99.9%（“三个九”）|'
- en: '| 4 minutes 22.8 seconds | 99.99% (“four nines”) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 4分钟22.8秒 | 99.99%（“四个九”）|'
- en: '| 26.28 seconds | 99.999% (“five nines”) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 26.28秒 | 99.999%（“五个九”）|'
- en: '| 2.628 seconds | 99.9999% (“six nines”) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 2.628秒 | 99.9999%（“六个九”）|'
- en: '| 262.8 ms | 99.99999% (“seven nines”) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 262.8毫秒 | 99.99999%（“七个九”）|'
- en: '| 26.28 ms | 99.999999% (“eight nines”) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 26.28毫秒 | 99.999999%（“八个九”）|'
- en: '| 2.628 ms | 99.9999999% (“nine nines”) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 2.628毫秒 | 99.9999999%（“九个九”）|'
- en: A common practice for cloud applications is to provide a **Service-Level Agreement**
    (**SLA**), which specifies how much downtime can occur per a given period of time
    (for example, a year). An SLA for your cloud service will strongly depend on the
    SLAs of the cloud services you build upon.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 云应用的常见做法是提供**服务级别协议**（**SLA**），它规定了在一定时间内（例如一年）可以发生多少停机时间。您的云服务的SLA将严重依赖于您构建的云服务的SLA。
- en: To calculate a compound availability between two services that need to cooperate,
    you should just multiply their uptimes. This means if you have two services with
    99.99% availability, their compound availability will be 99.99% * 99.99% = 99.98%.
    To calculate the availability of redundant services (such as two independent regions),
    you should multiply their unavailability. For instance, if two regions have 99.99%
    availability, their total unavailability will be (100% – 99.99%) * (100% – 99.99%)
    = 0.01% * 0.01% = 0.0001%, so their compound availability is 99.9999%.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算两个需要合作的服务之间的复合可用性，您只需将它们的正常运行时间相乘。这意味着如果您有两个可用性为99.99%的服务，它们的复合可用性将是99.99%
    * 99.99% = 99.98%。要计算冗余服务（例如两个独立区域）的可用性，您应该将它们的不可用性相乘。例如，如果两个区域的可用性为99.99%，它们的总不可用性将是（100%
    - 99.99%）*（100% - 99.99%）= 0.01% * 0.01% = 0.0001%，因此它们的复合可用性为99.9999%。
- en: Unfortunately, it's impossible to provide 100% availability. Failures do occur
    from time to time, so let's learn how to make your system tolerate them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，提供100%的可用性是不可能的。故障偶尔会发生，因此让我们学习如何使您的系统能够容忍它们。
- en: Building fault-tolerant systems
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建容错系统
- en: Fault tolerance is a system's ability to detect such failures and to handle
    them gracefully. It's essential that your cloud-based services are resilient,
    as due to the nature of the cloud, many different things can suddenly go south.
    Good fault tolerance can help your service's availability.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 容错能力是系统检测此类故障并优雅处理它们的能力。您的基于云的服务具有弹性是至关重要的，因为由于云的性质，许多不同的事情可能会突然出现问题。良好的容错能力可以帮助您的服务可用性。
- en: 'Different types of issues require different handling: from prevention, through
    detection, to minimizing the impact. Let''s start with common ways to avoid having
    a single point of failure.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的问题需要不同的处理：从预防、检测到最小化影响。让我们从避免单点故障的常见方法开始。
- en: Redundancy
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冗余
- en: One of the most basic preventions is introducing **redundancy**. Similar to
    how you can have a spare tire for your car, you can have a backup service that
    takes over when your primary server goes down. This stepping-in is also known
    as **failover**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的预防措施之一是引入**冗余**。类似于您可以为汽车备用轮胎一样，您可以有一个备用服务，在主服务器宕机时接管。这种接管也被称为**故障转移**。
- en: How does the backup server know when to step in? One way to implement this is
    by using the heartbeat mechanism described in the *Detecting faults* section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 备用服务器如何知道何时接管？实现这一点的一种方法是使用*检测故障*部分中描述的心跳机制。
- en: To make the switch faster, you can send all the messages that are going into
    the primary server also to the backup one. This is called a **hot standby**, as
    opposed to a cold one – initializing from zero. A good idea in such a case is
    to stay one message behind, so if a *poisoned* message kills the primary server,
    the backup one can simply reject it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快切换速度，您可以将所有进入主服务器的消息也发送到备用服务器。这被称为**热备用**，与冷备用（从零开始初始化）相对。在这种情况下的一个好主意是保持一条消息落后，因此如果一条*有毒*消息使主服务器崩溃，备用服务器可以简单地拒绝它。
- en: The preceding mechanism is called an **active-passive** (or **master-slave**)
    failover, as the backup server doesn't handle incoming traffic. If it did, we
    would have an **active-active** (or **master-master**) failover. For more on active-active
    architectures, refer to the last link in the *Further reading* section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述机制称为**主-被动**（或**主-从**）故障切换，因为备份服务器不处理传入流量。如果处理了传入流量，我们将有**主-主**（或**主-主**）故障切换。有关主-主架构的更多信息，请参阅*进一步阅读*部分中的最后一个链接。
- en: Be sure you don't lose any data when the failover happens. Using a message queue
    with backing storage may help with this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 确保故障切换发生时不会丢失任何数据。使用具有后备存储的消息队列可能有助于解决这个问题。
- en: Leader election
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 领导者选举
- en: It's also important for both the servers to know which one is which – if both
    start behaving as primary instances, you'll likely be in trouble. Choosing the
    primary server is called the leader election pattern. There are a few ways to
    do so, for example, by introducing a third-party arbiter, by racing to take exclusive
    ownership of a shared resource, by choosing the instance with the lowest rank,
    or by using algorithms such as bully election or token ring election.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两台服务器来说，它们知道自己是哪一个也很重要-如果两者都开始表现为主要实例，您可能会遇到麻烦。选择主服务器称为领导者选举模式。有几种方法可以做到这一点，例如通过引入第三方仲裁者，通过竞争独占共享资源的所有权，通过选择排名最低的实例，或者使用算法，如霸凌选举或令牌环选举。
- en: 'Leader election is also an essential part of the next related concept: achieving
    consensus.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者选举也是下一个相关概念的重要部分：实现共识。
- en: Consensus
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共识
- en: If you want your system to operate even when network partitions happen or some
    instances of your service experience faults, you need a way for your instances
    to reach consensus. They must agree what values to commit and often in what order.
    A simple approach is by allowing each instance to vote on the correct state. However,
    in some cases this is not enough to reach a consensus correctly or at all. Another
    approach would be to elect a leader and let it propagate its value. Because it's
    not easy to implement such algorithms by hand, we'd recommend using popular industry-proven
    consensus protocols such as Paxos and Raft. The latter is growing in popularity
    as it is simpler and easier to understand.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望系统即使在发生网络分区或服务的某些实例出现故障时也能运行，您需要让实例达成共识的方法。它们必须就要提交的值以及通常的顺序达成一致意见。一个简单的方法是允许每个实例对正确的状态进行投票。然而，在某些情况下，这并不足以正确或根本达成共识。另一种方法是选举一个领导者并让其传播其值。由于手动实现这样的算法并不容易，我们建议使用经过行业验证的共识协议，如Paxos和Raft。后者因为更简单和更容易理解而日益受到欢迎。
- en: Let's now discuss another way to prevent your system from faulting.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论另一种防止系统故障的方法。
- en: Replication
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制
- en: This one is especially popular with databases, and it helps with scaling them,
    too. **Replication** means you will run a few instances of your service in parallel
    with duplicated data, all handling incoming traffic.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在数据库中特别受欢迎，并且也有助于扩展它们。**复制**意味着您将并行运行几个实例的服务，并且处理传入流量的所有重复数据。
- en: Don't confuse replication with sharding. The latter doesn't require any data
    redundancy, but can often bring you great performance at scale. If you're using
    Postgres, we recommend you try out Citus ([https://www.citusdata.com](https://www.citusdata.com)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将复制与分片混淆。后者不需要任何数据冗余，但通常可以在规模上带来很好的性能。如果您使用的是Postgres，我们建议您尝试Citus ([https://www.citusdata.com](https://www.citusdata.com))。
- en: In terms of databases, there are two ways you can replicate.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库方面，您可以有两种复制方式。
- en: Master-slave replication
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主-从复制
- en: In this scenario, all the servers are able to perform read-only operations,
    but there's only one master server that can also write. The data is replicated
    from the master, through the slaves, either in a one-to-many topology or using
    a tree topology. If the master fails, the system can still operate in read-only
    mode until this fault is remediated.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有服务器都能执行只读操作，但只有一个主服务器可以进行写入。数据从主服务器通过从服务器复制，可以采用一对多拓扑结构或使用树拓扑结构。如果主服务器失败，系统可以继续以只读模式运行，直到此故障得到纠正。
- en: Multi-master replication
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多主复制
- en: You can also have a system with multiple master servers. If there are two servers,
    you have a *master-master replication* scheme. If one of the servers dies, the
    others can still operate normally. However, now you either need to synchronize
    the writes or provide looser consistency guarantees. Also, you need to provide
    a **load balancer**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以拥有多个主服务器的系统。如果有两台服务器，您将拥有*主-主复制*方案。如果其中一台服务器死机，其他服务器仍然可以正常运行。但是，现在您需要同步写入或提供更宽松的一致性保证。此外，您需要提供**负载均衡器**。
- en: Examples of such replication include Microsoft's Active Directory, OpenLDAP,
    Apache's CouchDB, or Postgres-XL.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此类复制的示例包括Microsoft的Active Directory，OpenLDAP，Apache的CouchDB或Postgres-XL。
- en: Let's now discuss two ways to prevent faults caused by too high a load.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论两种防止由负载过高引起的故障的方法。
- en: Queue-based load leveling
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于队列的负载平衡
- en: This tactic is aimed at reducing the impact of sudden spikes in your system's
    load. Flooding a service with requests can cause performance issues, reliability
    ones, and even dropping valid requests. Once again, queues are there to save the
    day.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略旨在减少系统负载突然增加的影响。向服务发送大量请求可能会导致性能问题，可靠性问题，甚至丢弃有效请求。再次，队列可以拯救一天。
- en: To implement this pattern, we just need to introduce a queue for the incoming
    requests to be added asynchronously. You can use Amazon's SQS, Azure's Service
    Bus, Apache Kafka, ZeroMQ, or other queues to achieve that.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种模式，我们只需要为传入的请求引入一个队列，以异步方式添加。您可以使用亚马逊的SQS，Azure的Service Bus，Apache Kafka，ZeroMQ或其他队列来实现。
- en: Now, instead of having spikes in incoming requests, the load will get averaged.
    Our service can grab the requests from the said queue and process them without
    even knowing that the load was increased. Simple as that.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再有传入请求的高峰，负载将得到平均。我们的服务可以从该队列中获取请求并处理它们，甚至不知道负载已经增加。就是这么简单。
- en: If your queue is performant and your tasks can be parallelized, a side benefit
    of this pattern would be better scalability.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的队列性能良好，并且您的任务可以并行处理，那么这种模式的一个附加好处将是更好的可扩展性。
- en: Also, if your service isn't available, the requests will still get added into
    the queue for said service to process when it recovers, so this may be a way to
    help with bumping the availability.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您的服务不可用，请求仍将被添加到队列中，以便在其恢复时处理，因此这可能是帮助提高可用性的一种方式。
- en: If the requests come infrequently, consider implementing your service as a function
    that runs only when there are items in the queue to save costs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求不频繁，请考虑将您的服务实现为仅在队列中有项目时才运行的函数，以节省成本。
- en: Keep in mind that when using this pattern, the overall latency will increase
    by the addition of the queue. Apache Kafka and ZeroMQ should yield low latency,
    but if that's a deal-breaker, there's yet another way to deal with increased load.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用这种模式时，由于队列的添加，总体延迟会增加。Apache Kafka和ZeroMQ应该具有低延迟，但如果这是一个无法接受的问题，还有另一种处理增加负载的方法。
- en: Back pressure
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背压
- en: If the load remains high, chances are you'll have more tasks than you're able
    to handle. This can cause cache misses and swapping if the requests will no longer
    fit into memory, as well as dropping requests and other nasty things. If you expect
    a heavy load, applying back pressure might be a great way to deal with it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果负载保持高水平，很可能您将有更多的任务而无法处理。这可能会导致缓存未命中和交换，如果请求不再适合内存，则会丢弃请求和其他不好的事情。如果您预计会有大量负载，施加背压可能是处理它的一个很好的方法。
- en: In essence, back pressure means that instead of putting more pressure on our
    service with each incoming request, we push back into the caller so it needs to
    handle the situation. There are a few different ways to do so.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，背压意味着我们不会在每个传入请求中给我们的服务增加更多的压力，而是将压力推回给调用者，因此需要处理这种情况。有几种不同的方法可以做到这一点。
- en: For instance, we can block our thread that receives network packets. The caller
    will then see that it is unable to push the request to our service – instead,
    we push the pressure up the stream.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以阻塞接收网络数据包的线程。调用者将看到无法将请求推送到我们的服务 - 相反，我们将压力推向上游。
- en: Another way is to recognize greater load and simply return an error code, for
    example, 503\. You can model your architecture so that this is done for you by
    another service. One such service is the Envoy Proxy ([https://envoyproxy.io](https://envoyproxy.io)),
    which can come in handy on many other occasions too.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是识别更大的负载并简单地返回一个错误代码，例如503。您可以设计您的架构，让另一个服务为您完成这项工作。Envoy代理（[https://envoyproxy.io](https://envoyproxy.io)）就是这样的服务，它在许多其他场合也非常有用。
- en: Envoy can apply back pressure based on predefined quotas, so your service will
    actually never get overloaded. It can also measure the time it takes to process
    requests and apply back pressure only if it goes above a certain threshold. There
    are many other cases for which a variety of error codes will get returned. Hopefully,
    the caller has a plan on what to do if the pressure goes back on them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy可以根据预定义的配额施加背压，因此您的服务实际上永远不会过载。它还可以测量处理请求所需的时间，并且仅在超过某个阈值时施加背压。还有许多其他情况，其中将返回各种错误代码。希望调用者有计划对付压力回到他们身上时该怎么办。
- en: Now that we know how to prevent faults, let's learn how to detect them once
    they occur.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何预防故障，现在让我们学习一下一旦发生故障如何检测它们。
- en: Detecting faults
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测故障
- en: Proper and fast fault detection can save you a lot of trouble, and often money.
    There are many ways to detect faults tailored to different needs. Let's go over
    a selection of them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正确和快速的故障检测可以为您节省很多麻烦，通常也可以节省金钱。有许多针对不同需求量身定制的故障检测方法。让我们来看看其中的一些。
- en: Sidecar design pattern
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边车设计模式
- en: Since we were discussing Envoy, it might be worth saying that it's an example
    of the **sidecar design pattern**. This pattern is useful in many more cases than
    just error prevention and detection, and Envoy is a great example of this.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论Envoy，值得一提的是它是“边车设计模式”的一个例子。这种模式不仅在错误预防和检测方面非常有用，Envoy也是这方面的一个很好的例子。
- en: In general, sidecars allow you to add a number of capabilities to your services
    without the need to write additional code. Similarly, as a physical sidecar can
    be attached to a motorcycle, a software sidecar can be attached to your service
    – in both cases extending the offered functionality.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，边车允许您为您的服务添加许多功能，而无需编写额外的代码。同样，就像物理边车可以连接到摩托车上一样，软件边车也可以连接到您的服务上 - 在这两种情况下都扩展了提供的功能。
- en: How can a sidecar be helpful in detecting faults? First of all, by providing
    health checking capabilities. When it comes to passive health checking, Envoy
    can detect whether any instance in a service cluster has started behaving badly.
    This is called **outlier detection**. Envoy can look for consecutive 5XX error
    codes, gateway failures, and so on. Aside from detecting such faulty instances,
    it can eject them so the overall cluster remains healthy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 边车如何帮助检测故障？首先，通过提供健康检查功能。当涉及到被动健康检查时，Envoy可以检测服务集群中的任何实例是否开始表现不佳。这被称为“异常检测”。Envoy可以寻找连续的5XX错误代码，网关故障等。除了检测此类故障实例，它还可以将它们排除，以便整个集群保持健康。
- en: Envoy also offers active health checking, meaning it can probe the service itself
    instead of just observing its reactions to incoming traffic.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy还提供主动健康检查，这意味着它可以探测服务本身，而不仅仅是观察其对传入流量的反应。
- en: Throughout this chapter, we'll show a few other usages for the sidecar pattern
    in general, and Envoy in particular. Let's now discuss the next mechanism of fault
    detection.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示边车模式在一般情况下以及Envoy在特定情况下的一些其他用途。现在让我们讨论下一个故障检测机制。
- en: Heartbeat mechanism
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 心跳机制
- en: One of the most common ways of fault detection is through the **heartbeat mechanism**.
    A **heartbeat** is a signal or a message that is sent on regular intervals (usually
    a few seconds) between two services.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 故障检测最常见的方式之一是通过“心跳机制”。 “心跳”是在两个服务之间定期发送的信号或消息（通常是几秒钟）。
- en: If a few consecutive heartbeats are missing, the receiving service can consider
    the sending service *dead*. In the case of our primary-backup service pair from
    a few sections previously, this can cause a failover to happen.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连续几个心跳丢失，接收服务可以认为发送服务已经“死亡”。在之前的几个部分中，我们的主备服务对可能导致故障转移。
- en: When implementing a heartbeat mechanism, be sure that it's reliable. False alarms
    can be troublesome, as the services may get confused, for example, about which
    one should be the new master. A good idea might be to provide a separate endpoint
    just for heartbeats, so it won't be as easily affected by the traffic on the regular
    endpoints.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现心跳机制时，请确保它是可靠的。虚假警报可能会带来麻烦，因为服务可能会感到困惑，例如，不知道哪一个应该成为新的主服务。一个好主意可能是为心跳提供一个单独的端点，这样它就不会受到常规端点上的流量的影响。
- en: Leaky bucket counter
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漏桶计数器
- en: Another way to detect faults is by adding a so-called **leaky bucket** counter.
    With each error, the counter would get incremented, and after a certain threshold
    is reached (the bucket is full), a fault would get signaled and handled. In regular
    time intervals, the counter would get decreased (hence, leaky bucket). This way,
    the situation would only be considered a fault if many errors occurred in a short
    time period.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种检测故障的方法是添加所谓的“漏桶”计数器。每次出现错误，计数器都会增加，当达到一定阈值时（桶满了），就会发出故障信号并进行处理。在规则的时间间隔内，计数器会减少（因此是漏桶）。这样，只有在短时间内发生许多错误时，才会被认为是故障。
- en: This pattern can be useful if in your case it's normal to sometimes have errors,
    for instance, if you're dealing with networking.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您的情况下有时出现错误是正常的，那么这种模式可能会很有用，例如，如果您正在处理网络问题。
- en: Now that we know how to detect faults, let's learn what to do once they happen.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何检测故障，让我们学习一旦发生故障该怎么办。
- en: Minimizing the impact of faults
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少故障的影响
- en: It takes time to detect an ongoing fault, and it takes even more of this precious
    resource to resolve it. This is why you should strive to minimize the impact of
    faults. Here are a few ways that can help.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 检测正在发生的故障需要时间，解决它需要更多的宝贵资源。这就是为什么您应该努力减少故障的影响。以下是一些可以帮助的方法。
- en: Retrying the call
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重试调用
- en: When your application calls another service, sometimes the call will fail. The
    simplest remedy for such a case is to just retry the call. If the fault was transient
    and you don't retry, that fault will likely get propagated through your system,
    making more damage than it should. Implementing an automated way to retry such
    calls can save you a lot of hassle.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序调用另一个服务时，有时调用会失败。对于这种情况最简单的补救方法就是重试调用。如果故障是瞬时的，而您不重试，那么故障很可能会通过您的系统传播，造成比应有的更多的损害。实现自动重试此类调用可以为您节省大量麻烦。
- en: Remember our sidecar proxy, Envoy? Turns out it can perform the automatic retries
    on your behalf, saving you from doing any changes to your sources.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们的边车代理Envoy吗？事实证明它可以代表您执行自动重试，使您免于对源代码进行任何更改。
- en: 'For instance, see this example configuration of a retry policy that can be
    added to a route in Envoy:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看这个可以添加到Envoy路由中的重试策略的示例配置：
- en: '[PRE0]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will make Envoy retry calls if they return errors such as the 503 HTTP
    code or gRPC errors that map to 5XX codes. There will be three retries, each considered
    failed if not finished within 2 seconds.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使Envoy在返回诸如503 HTTP代码或映射到5XX代码的gRPC错误等错误时重试调用。将进行三次重试，如果在2秒内未完成则被视为失败。
- en: Avoiding cascading failures
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免级联故障
- en: We mentioned that without retries the error will get propagated, causing a cascade
    of failures throughout the system. Let's now show more ways to prevent this from
    happening.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，如果没有重试，错误将会传播，导致整个系统中出现一系列故障。现在让我们展示更多的方法来防止这种情况发生。
- en: Circuit breaker
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断路器
- en: 'The **circuit breaker pattern** is a very useful tool for this. It allows us
    to quickly notice that a service is unable to process requests, so the calls to
    it can be short-circuited. This can happen both close to the callee (Envoy provides
    such a capability), or on the caller side (with the additional benefit of shaving
    off time from the calls). In Envoy''s case, it can be as simple as adding the
    following to your config:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**断路器模式**对此非常有用。它允许我们快速发现服务无法处理请求，因此可以将对其的调用短路。这既可以发生在被调用方附近（Envoy提供了这样的功能），也可以发生在调用方（还可以从调用中节省时间）。在Envoy的情况下，只需将以下内容添加到您的配置中即可：'
- en: '[PRE1]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In both cases, the load caused by the calls to the service may drop, which in
    some cases can help the service return to normal operation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，对服务调用造成的负载可能会下降，在某些情况下可以帮助服务恢复正常运行。
- en: How do we implement a circuit breaker on the caller side? Once you've made a
    few calls, and, say, your leaky bucket overflows, you can just stop making new
    calls for a specified period of time (for example, until the bucket no longer
    overflows). Simple and effective.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在调用方实现断路器？一旦您进行了几次调用，并且，比如说，您的漏桶溢出了，您可以停止在指定的时间段内进行新的调用（例如，直到漏桶不再溢出）。简单而有效。
- en: Bulkhead
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 隔离
- en: Another way to limit fault from spreading is taken straight from the stockyards.
    When building ships, you usually don't want the ship to get full of water if a
    hole breaks in the hull. To limit the damage of such holes, you would partition
    the hull into bulkheads, each of which would be easy to isolate. In this case,
    only the damaged bulkhead would get filled with water.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种限制故障传播的方法直接来自肉类加工厂。在建造船只时，通常不希望船只在船体破裂时充满水。为了限制这种破洞的损害，您可以将船体分成隔舱，每个隔舱都很容易隔离。在这种情况下，只有受损的隔舱会充满水。
- en: The same principle applies to limiting the fault impact in software architecture.
    You can partition your instances into groups, and you can assign the resources
    they use into groups as well. Setting quotas can also be considered an example
    of this pattern.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的原则适用于限制软件架构中的故障影响。您可以将实例分成组，也可以将它们使用的资源分配到组中。设置配额也可以被视为这种模式的一个例子。
- en: Separate bulkheads can be created for different groups of users, which can be
    useful if you need to prioritize them or provide a different level of service
    to your critical consumers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为不同用户组创建单独的隔离舱，如果您需要对它们进行优先处理或为您的关键消费者提供不同级别的服务，则这可能很有用。
- en: Geodes
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地理节点
- en: The last way we'll show is called **Geodes**. The name comes from geographical
    nodes. It can be used when your service is deployed in multiple regions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示的最后一种方式称为**地理节点**。这个名字来自地理节点。当您的服务部署在多个地区时，可以使用它。
- en: If a fault occurs in one region, you can just redirect the traffic to other,
    unaffected regions. This will of course make the latency much higher than if you'd
    made calls to other nodes in the same data center, but usually redirecting less
    critical users to remote regions is a much better choice than just failing their
    calls entirely.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个地区发生故障，您可以将流量重定向到其他未受影响的地区。当然，这将使延迟比如果您在同一数据中心的其他节点上进行调用要高得多，但通常将不太关键的用户重定向到远程地区比完全失败他们的调用要好得多。
- en: Now that you know how to provide availability and fault tolerance through your
    system's architecture, let's discuss how to integrate its components together.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何通过系统架构提供可用性和容错性，让我们讨论如何将其组件集成在一起。
- en: Integrating your system
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成您的系统
- en: A distributed system is not just isolated instances of your applications running
    unaware of the existing world. They constantly communicate with each other and
    have to be properly integrated together to provide the most value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统不仅仅是您的应用程序的孤立实例，它们不知道现有的世界。它们不断地相互通信，并且必须被适当地集成在一起，以提供最大的价值。
- en: Much was already said on the topic of integration, so in this section, we'll
    try to showcase just a handful of patterns for effective integration of both entirely
    new systems, as well as new parts of the system that needs to coexist with other
    existing parts, often legacy ones.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关于集成的话题已经说了很多，因此在本节中，我们将尝试展示一些有效集成全新系统以及需要与其他现有部分共存的新系统部分的模式。
- en: To not make this chapter be a whole book on its own, let's start this section
    with a recommendation of an existing one. If you're interested in integration
    patterns, especially focused on messaging, then Gregor Hohpe and Bobby Woolf's
    *Enterprise Integration Patterns* book is a must-read for you.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不让这一章成为一本独立的书，让我们从推荐一本现有的书开始这一部分。如果您对集成模式感兴趣，特别是专注于消息传递，那么Gregor Hohpe和Bobby
    Woolf的《企业集成模式》是您必读的书籍。
- en: Let's take a brief look at two patterns covered by this book.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要介绍一下本书涵盖的两种模式。
- en: Pipes and filters pattern
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道和过滤器模式
- en: The first integration pattern that we'll discuss is called **pipes and filters**.
    Its purpose is to decompose a big processing task into a series of smaller, independent
    ones (called **filters**), which you can then connect together (using pipes, such
    as message queues). This approach gives you scalability, performance, and reusability.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的第一个集成模式称为**管道和过滤器**。它的目的是将一个大的处理任务分解为一系列较小、独立的任务（称为**过滤器**），然后您可以将它们连接在一起（使用管道，如消息队列）。这种方法可以为您提供可伸缩性、性能和可重用性。
- en: Assume you need to receive and process an incoming order. You can do it in one
    big module, so you don't need extra communication, but the different functions
    of such a module would be hard to test and it would be harder to scale them well.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要接收和处理一个传入的订单。您可以在一个大模块中完成，这样您就不需要额外的通信，但是这样一个模块的不同功能将很难测试，并且很难很好地扩展它们。
- en: 'Instead, you can split the order processing into separate steps, each handled
    by a distinct component: one for decoding, one for validating, another one for
    the actual processing of the order, and then yet another one for storing it somewhere.
    With this approach, you can now independently perform each of those steps, easily
    replace or disable them if needed, and reuse them for processing different types
    of input messages.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以将订单处理分为单独的步骤，每个步骤由不同的组件处理：一个用于解码，一个用于验证，另一个用于实际处理订单，然后另一个用于将其存储在某个地方。通过这种方法，您现在可以独立执行每个步骤，根据需要轻松替换或禁用它们，并重用它们来处理不同类型的输入消息。
- en: 'If you want to process multiple orders at the same time, you can also pipeline
    your processing: while one thread validates a message, another thread decodes
    the next one, and so on.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想同时处理多个订单，还可以对处理进行流水线处理：一个线程验证一个消息，另一个线程解码下一个消息，依此类推。
- en: The downside is that you need to use synchronized queues as your pipes, which
    introduces some overhead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是您需要使用同步队列作为管道，这会引入一些开销。
- en: To scale one step of your processing, you might want to use this pattern along
    with the next one on our list.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展处理的一步，您可能希望将此模式与我们列表中的下一个模式一起使用。
- en: Competing consumers
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞争消费者
- en: 'The idea of competing consumers is simple: you have an input queue (or a messaging
    channel) and a few instances of consumers that fetch and process items from the
    queue concurrently. Each of the consumers can process the message, so they compete
    with each other to be the receiver.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争消费者的想法很简单：您有一个输入队列（或消息通道）和几个消费者实例，它们同时从队列中获取和处理项目。每个消费者都可以处理消息，因此它们彼此竞争成为接收者。
- en: This way, you get scalability, free load balancing, and resilience. With the
    addition of the queue, you now also have the **queue-based load leveling pattern**
    in place.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您就可以获得可伸缩性、免费负载平衡和弹性。通过添加队列，您现在还可以使用**基于队列的负载平衡模式**。
- en: This pattern integrates effortlessly with priority queues if you need to shave
    latency from a request or just want a specific task submitted to your queue to
    be performed in a more urgent manner.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以轻松地与优先队列集成，如果您需要从请求中削减延迟，或者只是希望将提交到队列的特定任务以更紧急的方式执行。
- en: This pattern can get tricky to use if the ordering is important. The order in
    which your consumers receive and finish to process messages may vary, so make
    sure that either this doesn't impact your system, or you find a way to reorder
    the results later on. If you need to process messages in sequence, you might not
    be able to use this pattern.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果顺序很重要，这种模式可能会变得棘手。您的消费者接收和完成处理消息的顺序可能会有所不同，因此请确保这不会影响您的系统，或者找到一种方法以后重新排序结果。如果需要按顺序处理消息，则可能无法使用此模式。
- en: Let's now see a few more patterns, this time to help us integrate with existing
    systems.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看更多的模式，这次是为了帮助我们与现有系统集成。
- en: Transitioning from legacy systems
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从传统系统过渡
- en: Developing a system from scratch can be a blissful experience. Development instead
    of maintenance and a possibility to use a bleeding-edge technology stack – what's
    not to like? Unfortunately, that bliss often ends when integrating with an existing,
    legacy system starts. Fortunately, though, there are some ways to ease that pain.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始开发系统可能是一种愉快的体验。开发而不是维护以及使用尖端技术堆栈的可能性 - 有什么不喜欢的呢？不幸的是，当开始与现有的传统系统集成时，这种幸福往往会结束。幸运的是，有一些方法可以缓解这种痛苦。
- en: Anti-corruption layer
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反腐层
- en: Introducing an **anti-corruption layer** can help your solution in painless
    integration with a legacy system that has different semantics. This additional
    layer is responsible for communication between those two sides.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 引入**反腐层**可以帮助您的解决方案与具有不同语义的传统系统无痛集成。这个额外的层负责这两个方面之间的通信。
- en: Such a component allows your solution to be designed with more flexibility –
    without the need to compromise your technology stack nor architectural decisions.
    To achieve that requires only a minimal set of changes in the legacy system (or
    none, if the legacy system doesn't need to make calls to the new system).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的组件可以使您的解决方案更灵活地设计 - 而无需 compromis您的技术堆栈或架构决策。要实现这一点，只需要对传统系统进行一组最小的更改（或者如果传统系统不需要调用新系统，则不需要进行任何更改）。
- en: For instance, if your solution is based on microservices, the legacy system
    can just communicate with the anti-corruption layer instead of locating and reaching
    each microservice directly. Any translations (for example, due to outdated protocol
    versions) are also done in the additional layer.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的解决方案基于微服务，传统系统可以直接与反腐层通信，而不是直接定位和到达每个微服务。任何翻译（例如，由于过时的协议版本）也在附加层中完成。
- en: Keep in mind that adding such a layer can introduce latency and has to satisfy
    quality attributes for your solution, for example, scalability.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，添加这样的层可能会引入延迟，并且必须满足解决方案的质量属性，例如可伸缩性。
- en: Strangler pattern
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窒息模式
- en: The **strangler pattern** allows the gradual migration from a legacy system
    to a new one. While the anti-corruption layer we just looked at is useful for
    communication between the two systems, the strangler pattern is meant for providing
    services from both to the outside world.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**窒息模式**允许逐步从传统系统迁移到新系统。虽然我们刚刚看到的反腐层对于两个系统之间的通信很有用，但窒息模式旨在为两个系统向外界提供服务。'
- en: 'Early in the migration process, the strangler facade will route most of the
    requests into the legacy system. During the migration, more and more calls can
    be forwarded into the new one, while *strangling* the legacy system more and more,
    limiting the functionality it offers. As the final step of the migration, the
    strangler, along with the legacy system, can be retired – the new system will
    now provide all the functionality:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移过程的早期，窒息外观将大部分请求路由到传统系统中。在迁移过程中，越来越多的调用可以转发到新系统中，同时越来越多地*窒息*传统系统，限制其提供的功能。作为迁移的最后一步，窒息器以及传统系统可以被淘汰
    - 新系统现在将提供所有功能：
- en: '![](img/7b429547-5775-483d-9f3d-c8d57ae2828d.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b429547-5775-483d-9f3d-c8d57ae2828d.png)'
- en: Figure 4.1 – The strangling of a monolith. After the migration, the strangler
    can still be used as an entry point, or adapter, for legacy requests
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - 单体的窒息。在迁移后，窒息仍然可以用作传统请求的入口点或适配器
- en: This pattern can be overkill for small systems and can get tricky if the datastore
    should be shared or is for event-sourced systems. When adding it to your solution,
    be sure to plan for achieving the proper performance and scalability.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对于小型系统来说可能过于复杂，如果数据存储应该是共享的或者用于事件源系统，则可能会变得棘手。在将其添加到您的解决方案时，请确保计划实现适当的性能和可伸缩性。
- en: Speaking of those two attributes, let's now discuss a few things that help achieve
    them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这两个属性，现在让我们讨论一些有助于实现它们的事情。
- en: Achieving performance at scale
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现规模的性能
- en: When designing C++ applications, performance is usually a key factor. While
    using the language can go a long way in the scope of a single application, the
    proper high-level design is also essential to achieving optimal latency and throughput.
    Let's discuss a few crucial patterns and aspects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计C++应用程序时，性能通常是一个关键因素。虽然使用该语言可以在单个应用程序的范围内走得更远，但适当的高级设计对于实现最佳的延迟和吞吐量也是至关重要的。让我们讨论一些关键的模式和方面。
- en: CQRS and event sourcing
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQRS和事件源
- en: There are many ways to scale compute but scaling data access can be tricky.
    However, it's often necessary when your userbase grows. **Command-query responsibility
    segregation** (**CQRS**) is a pattern that can help here.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的扩展方式有很多种，但访问数据的扩展可能会很棘手。但是，当您的用户群增长时，通常是必要的。**命令查询职责分离**（**CQRS**）是一种可以在这里帮助的模式。
- en: Command-query responsibility segregation
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令查询职责分离
- en: In traditional CRUD systems, both reads and writes are performed using the same
    data model and the data flows the same way. The titular segregation basically
    means to treat queries (reads) and commands (writes) in two separate ways.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的CRUD系统中，读取和写入都是使用相同的数据模型进行的，并且数据流程也是相同的。标题上的分离基本上意味着以两种不同的方式处理查询（读取）和命令（写入）。
- en: 'Many applications have a strongly biased ratio of reads to writes – there''s
    usually a lot more reading from the database than updating it in a typical app.
    This means making the reads as fast as possible can yield better performance:
    reads and writes can now be optimized and scaled separately. Other than that,
    introducing CQRS can help if many writes are competing with each other, or if
    a track of all the writes needs to be maintained, or if a set of your API users
    should have read-only access.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序的读取与写入的比例非常偏向读取 - 在典型的应用程序中，通常从数据库中读取的次数要比更新它多得多。这意味着尽可能快地进行读取可以提高性能：现在可以分别优化和扩展读取和写入。除此之外，引入CQRS可以帮助解决许多写入相互竞争的问题，或者需要维护所有写入的轨迹，或者您的API用户组中的一部分需要只读访问。
- en: Having separate models for reads and writes can allow having different teams
    to work on both sides. The developers working on the read side of things don't
    need to have a deep understanding of the domain, which is required to perform
    updates properly. When they make a request, they get a **data transfer object**
    (**DTO**) from a thin read layer in just one simple call instead of going through
    the domain model.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为读取和写入操作使用不同的模型可以允许不同的团队在两侧工作。在读取方面工作的开发人员不需要对领域有深入的了解，这是执行更新所需的。当他们发出请求时，他们可以从一个薄的读取层中以一个简单的调用获取**数据传输对象**（**DTO**），而不是通过领域模型。
- en: If you're not aware of what a DTO is, think of returning item data from the
    database. If the caller asks for a list of items, you could provide them with
    an `ItemOverview` object containing just the names and thumbnails of items. On
    the other hand, if they want items for a specific store, you could also provide
    a `StoreItem` object containing a name, more pictures, a description, and a price.
    Both `ItemOverview` and `StoreItem` are DTOs, grabbing data from the same `Item`
    objects in the database.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道DTO是什么，请想象一下从数据库返回物品数据。如果调用者要求列出物品，您可以提供一个`ItemOverview`对象，其中只包含物品的名称和缩略图。另一方面，如果他们想要特定商店的物品，您还可以提供一个`StoreItem`对象，其中包含名称、更多图片、描述和价格。`ItemOverview`和`StoreItem`都是DTO，从数据库中的相同`Item`对象中获取数据。
- en: 'The read layer can reside either on top of the data storage used for writes,
    or it can be a different data storage that gets updated via events as you can
    see in the following figure:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 读取层可以位于用于写入的数据存储的顶部，也可以是通过事件更新的不同数据存储，如下图所示：
- en: '![](img/d9046486-c262-4786-a378-2ca8c579546e.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9046486-c262-4786-a378-2ca8c579546e.png)'
- en: Figure 4.2 – CQRS with event sourcing
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - 带事件源的CQRS
- en: Using the approach pictured here, you can create as many different commands
    as you like, each having its own handler. Usually, the commands are asynchronous
    and don't return any values to the caller. Each handler uses domain objects and
    persists the changes done. After doing that, events are published, which event
    handlers can use to update the storage used by read operations. Continuing our
    last example, item data queries would grab information from a database updated
    by events such as `ItemAdded` or `ItemPriceChanged`, which could be triggered
    by commands such as `AddItem` or `ModifyItem`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这里展示的方法，您可以创建任意数量的不同命令，每个命令都有自己的处理程序。通常，命令是异步的，并且不会向调用者返回任何值。每个处理程序都使用领域对象并持久化所做的更改。在这样做之后，会发布事件，事件处理程序可以使用这些事件来更新读取操作使用的存储。继续我们的最后一个例子，物品数据查询将从由`ItemAdded`或`ItemPriceChanged`等事件更新的数据库中获取信息，这些事件可以由`AddItem`或`ModifyItem`等命令触发。
- en: 'Using CQRS allows us to have different data models for read and write operations.
    For instance, you can create stored procedures and materialized views to speed
    up reads. Using different types of storage (SQL and NoSQL) for the read and domain
    stores can also be beneficial: one efficient way to persist data is to use an
    Apache Cassandra cluster while using Elasticsearch is a great way to search through
    the stored data quickly.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CQRS允许我们为读取和写入操作拥有不同的数据模型。例如，您可以创建存储过程和物化视图来加速读取。对读取和领域存储使用不同类型的存储（SQL和NoSQL）也可能是有益的：持久化数据的一种有效方式是使用Apache
    Cassandra集群，而使用Elasticsearch是快速搜索存储数据的好方法。
- en: Aside from the preceding pros, CQRS also has its cons. Due to the complexity
    it introduces, it's usually not a good fit for small or less requiring architectures.
    It's often useful to apply it only to the parts of your system where it would
    bring the biggest benefits. You should also notice that updating the read store
    after the domain store means that now we have eventual consistency instead of
    strong consistency.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的优点，CQRS也有其缺点。由于它引入的复杂性，通常不适合小型或需求较少的架构。通常只有在系统的部分中应用它会带来最大的好处。您还应该注意，在更新领域存储后更新读取存储意味着现在我们有了最终一致性，而不是强一致性。
- en: Command-query separation
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令查询分离
- en: CQRS is actually based on a simpler idea introduced long ago in the Eiffel programming
    language (the same one that introduced contracts). **Command-query separation**
    (**CQS**) is a principle that devises to separate API calls into, well, commands
    and queries – just like in CQRS, but regardless of the scale. It plays really
    well with objective programming and imperative programming in general.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS实际上是基于Eiffel编程语言（引入合同的同一个语言）很久以前引入的一个更简单的概念。**命令查询分离**（**CQS**）是一个原则，旨在将API调用分为命令和查询
    - 就像在CQRS中一样，但不考虑规模。它在面向对象编程和一般命令式编程中表现得非常好。
- en: 'If your function''s name starts with a *has*, *is*, *can,* or a similar word,
    it should be just a query and not modify the underlying state or have any side
    effects. This brings two great benefits:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的函数名称以*has*、*is*、*can*或类似的单词开头，它应该只是一个查询，而不修改底层状态或具有任何副作用。这带来了两个巨大的好处：
- en: '**Much easier reasoning about the code**: It''s clear that such functions are
    semantically just *reads*, never *writes*. This can make looking for a change
    of state much easier when debugging.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易推理代码**：很明显，这样的函数在语义上只是*读取*，从不*写入*。这在调试时可以更容易地查找状态变化。'
- en: '**Reduce heisenbugs**: If you have ever had to debug an error that manifested
    in a release build, but not in the debug one (or the other way around), you have
    dealt with a heisenbug. It''s rarely something pleasurable. Many such errors can
    be caused by assert calls that modify the state. Following CQS eliminates such
    bugs.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少Heisenbugs：如果您曾经不得不调试一个在发布版本中出现的错误，但在调试版本中没有出现（或者反过来），那么您已经处理过Heisenbug。这很少令人愉快。许多此类错误可能是由修改状态的断言调用引起的。遵循CQS可以消除这样的错误。
- en: Similarly to asserts, if you want to have contracts (pre- and post-conditions),
    it's super important to only use queries in them. Otherwise disabling some contract
    checks could also lead to heisenbugs, not to mention how counterintuitive it would
    be.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与断言类似，如果您想要有合同（前置条件和后置条件），只使用查询是非常重要的。否则，禁用某些合同检查也可能导致Heisenbugs，更不用说这将是多么令人费解了。
- en: Let's now say a few more words about event sourcing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再多说几句关于事件溯源。
- en: Event sourcing
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件溯源
- en: As introduced in [Chapter 2](6fbde08c-f8a2-475d-9984-2a9882a761b4.xhtml), *Architectural
    Styles*, event sourcing means that instead of always storing the whole state of
    your application, possibly dealing with conflicts during updates, you can just
    store the changes that happened to your application's state. Using event sourcing
    can boost your app's performance by eliminating concurrent updates and allowing
    all interested parties to perform gradual changes to their state. Saving the history
    of the operations done (for example, market transactions) can allow easier debugging
    (by replaying them later) and auditing. This also brings more flexibility and
    extensibility to the table. Some domain models can get much simpler when event
    sourcing is introduced.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](6fbde08c-f8a2-475d-9984-2a9882a761b4.xhtml)中介绍的，*架构风格*，事件溯源意味着，与始终存储应用程序的整个状态并可能在更新期间处理冲突相比，您可以只存储应用程序状态发生的更改。使用事件溯源可以通过消除并发更新并允许所有相关方逐渐更改其状态来提高应用程序的性能。保存已执行的操作的历史记录（例如，市场交易）可以使调试更容易（稍后重放它们）和审计。这也为灵活性和可扩展性带来了更多的可能性。一些领域模型在引入事件溯源后可能变得简单得多。
- en: One cost of event sourcing is being eventually consistent. Another one is slowing
    down the startup of your application – unless you make periodic snapshots of the
    state or can use the read-only store as in CQRS, discussed in the previous section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源的一个成本是最终一致性。另一个是减慢应用程序的启动速度-除非您定期对状态进行快照，或者可以像在前一节中讨论的CQRS中使用只读存储。
- en: 'Okay, enough of CQRS and related patterns. Let''s now move on to another hot
    topic when it comes to performance (no pun intended): caching.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，够了关于CQRS和相关模式的内容。现在让我们转向另一个热门话题，即性能方面的缓存。
- en: Caching
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: Proper usage of caches can yield better performance, lower latency, reduce the
    server load (and thus, costs of running in the cloud), and help with scalability
    concerns (fewer servers required) – what's not to like?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用缓存可以提高性能，降低延迟，减少服务器负载（从而降低在云中运行的成本），并有助于可伸缩性问题（需要更少的服务器）-有什么不喜欢的呢？
- en: If you're here for tips on CPU caches, you can find them in [Chapter 11](9d4b9eb1-c0cc-4fdb-b0e2-db0a401405ac.xhtml),
    *Performance*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关CPU缓存的技巧，可以在[第11章](9d4b9eb1-c0cc-4fdb-b0e2-db0a401405ac.xhtml)中找到，*性能*。
- en: Caching is a big topic, so we'll only cover a few aspects of it here.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一个大话题，所以我们在这里只涵盖了一些方面。
- en: 'Caching works by simply storing the data that is read most often in non-persistent
    storage with fast access times. There are many different types of caches:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的工作原理很简单，只需将最常读取的数据存储在非持久性存储中，以实现快速访问。有许多不同类型的缓存：
- en: '**Client-side caches**: For storing data specifically for a given customer,
    often placed on the client''s machine or browser.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端缓存：用于专门为特定客户存储数据，通常放置在客户端的机器或浏览器上。
- en: '**Web server caches**: For speeding up reading from web pages, for instance,
    through HTTP accelerators such as Varnish that can cache the web server responses.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器缓存：用于加快从网页读取的速度，例如通过HTTP加速器（如Varnish）可以缓存Web服务器响应。
- en: '**Database caches**: Many database engines have built-in, tunable caching.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库缓存：许多数据库引擎都具有内置的可调整缓存。
- en: '**Application caches**: For speeding up your application, which can now read
    data from a cache instead of reaching out to its database.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序缓存：用于加快应用程序的速度，现在可以从缓存中读取数据，而不是直接访问数据库。
- en: '**CDNs can be treated as caches too**: For serving content from a location
    close to the user in order to reduce latency.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDN也可以被视为缓存：用于从靠近用户的位置提供内容，以减少延迟。
- en: 'Some types of caches can be replicated or deployed in clusters to provide performance
    at scale. An alternative can also be to shard them: similarly to as you would
    shard databases, you can use different instances of your caches for distinct parts
    of your data.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 某些类型的缓存可以被复制或部署在集群中，以提供规模化的性能。另一种选择也可以是对它们进行分片：类似于您对数据库进行分片的方式，您可以为数据的不同部分使用不同的缓存实例。
- en: Let's now go through the different approaches to updating the data in the cache.
    After all, no one likes to be served stale data.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看更新缓存中数据的不同方法。毕竟，没有人喜欢被提供陈旧的数据。
- en: Updating caches
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新缓存
- en: There are a few approaches to keeping the cached data fresh. Whether it's you
    who decided how to update cached items or another company, it's worth knowing
    them. In this section, we'll discuss their pros and cons.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以保持缓存数据的新鲜。无论是您决定如何更新缓存项，还是其他公司，了解它们都是值得的。在本节中，我们将讨论它们的优缺点。
- en: Write-through approach
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 写入缓存的方法
- en: 'If you require strong consistency, synchronously updating both the database
    and the cache is the valid approach for you. This approach protects you from data
    loss: if data became visible to a user, it means it is already written to the
    database. A downside of write-through caches is that the latency to perform the
    update is bigger than in other approaches.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要强一致性，同步更新数据库和缓存是有效的方法。这种方法可以保护您免受数据丢失的影响：如果数据对用户可见，这意味着它已经写入数据库。写入缓存的一个缺点是更新的延迟比其他方法更大。
- en: Write-behind approach
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 写后方式
- en: An alternative approach, also known as **write-back**, is to provide the user
    with just access to the cache. When the user performs an update, the cache will
    then queue the incoming update, which will then be asynchronously executed, thus
    updating the database. The obvious downside here is that if something goes wrong,
    the data can never be written. It's also not as easy to implement as the other
    approaches. The upside, however, is the lowest latency as seen by the user.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种替代方法，也称为**写回**，是为用户提供对缓存的访问。当用户执行更新时，缓存将排队接收传入的更新，然后异步执行，从而更新数据库。显而易见的缺点是，如果出现问题，数据将无法写入。它也不像其他方法那样容易实现。然而，优点是用户看到的最低延迟。
- en: Cache-aside
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存旁路
- en: 'This last approach, also called **lazy loading**, is about filling the cache
    on-demand. In this case, data access looks as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最后一种方法，也称为**惰性加载**，是按需填充缓存。在这种情况下，数据访问如下所示：
- en: A call to the cache is made to check whether the value is already there. If
    so, just return it.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用缓存以检查值是否已存在。如果是，就返回它。
- en: Reach the main data store or service that provides the value.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到达提供价值的主数据存储或服务。
- en: Store the value in the cache and return it to the user.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值存储在缓存中并返回给用户。
- en: This type of caching is often done using Memcached or Redis. It can be really
    fast and efficient – the cache only contains data that was requested.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的缓存通常使用Memcached或Redis进行。它可以非常快速和高效 - 缓存只包含被请求的数据。
- en: However, if data that is not in the cache is often requested, the preceding
    three calls can increase the latency noticeably. To mitigate this for cache restarts,
    the cache can be primed (initialized) with selected data from the persistent store.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果经常请求缓存中不存在的数据，前面三个调用可能会显着增加延迟。为了减轻这种情况，可以在缓存重新启动时，使用持久存储中的选定数据来初始化缓存。
- en: The items in the cache can also become stale, so it's best to set a time-to-live
    for each entry. If the data is to be updated, it can happen in a write-through
    manner by removing the record from the cache and updating it in the database.
    Take care when using multi-level caches with just a time-based update policy (for
    instance, as in DNS caches). This may lead to using stale data for long periods
    of time.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存中的项目也可能变得过时，因此最好为每个条目设置生存时间。如果数据需要更新，可以通过以写入方式删除缓存中的记录并更新数据库来进行。在使用仅基于时间的更新策略（例如DNS缓存）的多级缓存时要小心。这可能导致长时间使用过时数据。
- en: We've discussed the types of caches and strategies to update them, so that's
    enough about caches for now. Let's move on to a different aspect of providing
    scalable architectures.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了缓存的类型和更新策略，所以现在关于缓存的内容就足够了。让我们继续讨论提供可扩展架构的不同方面。
- en: Deploying your system
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署您的系统
- en: Even though deploying services sounds easy, there's a lot of things to think
    about if you take a closer look. This section will describe how to perform efficient
    deployments, configure your services after installing them, check that they stay
    healthy after being deployed, and how to do it all while minimizing downtime.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管部署服务听起来很容易，但如果仔细看，有很多事情需要考虑。本节将描述如何执行高效的部署，安装后配置您的服务，检查它们在部署后保持健康，并在最小化停机时间的同时执行所有这些操作。
- en: The sidecar pattern
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边车模式
- en: Remember Envoy from earlier in this chapter? It's a very useful tool for efficient
    application development. Instead of embedding infrastructure services such as
    logging, monitoring, or networking into your application, you can deploy the Envoy
    proxy along with your app, just like a sidecar would be *deployed* next to a motorbike.
    Together, they can do much more than the app without the sidekick (another name
    for this pattern).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得本章前面提到的Envoy吗？它是一种非常有用的工具，用于高效的应用程序开发。您可以将Envoy代理与您的应用程序一起部署，而不是将基础设施服务（如日志记录、监视或网络）嵌入到您的应用程序中，就像边车会*部署*在摩托车旁边一样。它们一起可以比没有这种模式的应用程序做得更多。
- en: Using a sidecar can speed up development, as many of the functionality it brings
    would need to be developed independently by each of your microservices. Because
    it's separate from your application, a sidecar can be developed using any programming
    language you find best for the job. The sidecar, along with all the functionality
    it provides, can be maintained by an independent team of developers and updated
    independently from your main service.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用边车可以加快开发速度，因为它带来的许多功能需要独立开发每个微服务。由于它与您的应用程序分开，边车可以使用您认为最适合工作的任何编程语言进行开发。边车及其提供的所有功能可以由独立的开发团队维护，并可以独立于您的主服务进行更新。
- en: Because sidecars reside right next to the app they enhance, they can use local
    means of inter-process communication. Usually, it's fast enough and much faster
    than communicating from another host, but remember that it can sometimes be too
    big a burden.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因为边车就在它增强的应用程序旁边，它们可以使用本地的进程间通信手段。通常，这足够快，比从另一个主机通信要快得多，但请记住，有时它可能是一个太大的负担。
- en: 'Even if you deploy a third-party service, deploying your selected sidecar next
    to it can still provide value: you can monitor the resource usage and the condition
    of both the host and the service, as well as tracing requests throughout your
    distributed system. Sometimes it''s also possible to reconfigure the service dynamically
    based on its condition, via editing the config file or a web interface.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您部署了第三方服务，将您选择的边车部署在其旁边仍然可以提供价值：您可以监视主机和服务的资源使用情况和状态，以及跟踪分布式系统中的请求。有时还可以根据其状态动态重新配置服务，通过编辑配置文件或Web界面。
- en: Deploying a service with tracing and a reverse proxy using Envoy
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Envoy部署具有跟踪和反向代理的服务
- en: 'Let''s now use Envoy as a front proxy for our deployment. Start by creating
    Envoy''s configuration file, in our case named `envoy-front_proxy.yaml`, with
    the address of our proxy:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将Envoy用作部署的前置代理。首先创建Envoy的配置文件，在我们的情况下命名为`envoy-front_proxy.yaml`，并设置代理的地址：
- en: '[PRE2]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ve specified that Envoy is going to listen for incoming traffic on port
    `8080`. Later in the config, we''ll route it to our service. Now, let''s specify
    that we''d like to handle HTTP requests using our set of service instances and
    adding some tracing capabilities on top. First, let''s add an HTTP endpoint:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定Envoy将在端口`8080`上监听传入流量。稍后在配置中，我们将将其路由到我们的服务。现在，让我们指定我们希望使用我们的一组服务实例处理HTTP请求，并在其上添加一些跟踪功能。首先，让我们添加一个HTTP端点：
- en: '[PRE3]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s specify that requests should have IDs assigned and be traced by
    a distributed tracing system, Jaeger:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们指定请求应该被分配ID，并由分布式跟踪系统Jaeger跟踪：
- en: '[PRE4]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll create IDs for requests and use the OpenTracing standard (`DynamicOtConfig`)
    with the native Jaeger plugin. The plugin will report to a Jaeger instance running
    under the specified address and add the specified headers.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为请求创建ID，并使用OpenTracing标准（`DynamicOtConfig`）与本机Jaeger插件。该插件将报告给在指定地址下运行的Jaeger实例，并添加指定的标头。
- en: 'We also need to specify that all traffic (see the `match` section) from all
    domains shall be routed into our service cluster:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要指定所有流量（参见`match`部分）从所有域都应该路由到我们的服务集群中：
- en: '[PRE5]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll define our `example_service` cluster in a second. Note that each request
    coming to the cluster will be marked by a predefined operation decorator. We also
    need to specify what router address to use:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一步中定义我们的`example_service`集群。请注意，来到集群的每个请求都将由预定义的操作装饰器标记。我们还需要指定要使用的路由器地址：
- en: '[PRE6]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we know how to handle and trace the requests, so what''s left is to define
    the clusters we used. Let''s start with our service''s cluster:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何处理和跟踪请求，剩下的就是定义我们使用的集群。让我们从我们服务的集群开始：
- en: '[PRE7]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each cluster can have multiple instances (endpoints) of our service. Here, if
    we decide to add more endpoints, the incoming requests will be load-balanced using
    the round-robin strategy.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集群可以有多个我们服务的实例（端点）。在这里，如果我们决定添加更多端点，传入的请求将使用轮询策略进行负载平衡。
- en: 'Let''s also add an admin interface:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也添加一个管理界面：
- en: '[PRE8]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s now place the config inside a container that will run Envoy using a
    Dockerfile, which we named `Dockerfile-front_proxy`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将配置放在一个容器中，该容器将使用一个名为`Dockerfile-front_proxy`的Dockerfile运行Envoy：
- en: '[PRE9]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We also downloaded the Jaeger native plugin that we used in our Envoy config.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还下载了我们在Envoy配置中使用的Jaeger本机插件。
- en: 'Now let''s specify how to run our code in several containers using Docker Compose.
    Create a `docker-compose.yaml` file, starting with the front proxy service definition:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们指定如何在使用Docker Compose运行我们的代码时在多个容器中运行。创建一个`docker-compose.yaml`文件，从前置代理服务定义开始：
- en: '[PRE10]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use our Dockerfile here, a simple network, and we expose two ports from
    the container on the host: our service and the admin interface. Let''s now add
    the service our proxy will direct to:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用我们的Dockerfile，一个简单的网络，并且我们从容器中向主机公开了两个端口：我们的服务和管理界面。现在让我们添加我们的代理将要指向的服务：
- en: '[PRE11]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In our case, the service will just display a predefined string in a simple web
    server.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，服务将在一个简单的Web服务器中显示预定义的字符串。
- en: 'Now, let''s run Jaeger in another container, exposing its port to the outside
    world:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在另一个容器中运行Jaeger，并将其端口暴露给外部世界：
- en: '[PRE12]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last step will be to define our network:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是定义我们的网络：
- en: '[PRE13]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And we're done. You can now run the service using `docker-compose up --build`
    and point your browser to the endpoints we specified.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就完成了。您现在可以使用`docker-compose up --build`运行服务，并将浏览器指向我们指定的端点。
- en: 'Using a sidecar proxy has one more benefit: even if your service will die,
    the sidecar is usually still alive and can respond to external requests while
    the main service is down. The same applies when your service is redeployed, for
    example, because of an update. Speaking of which, let''s learn how to minimize
    the related downtime.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用边车代理还有一个好处：即使您的服务将停止，边车通常仍然存活，并且可以在主服务停止时响应外部请求。当您的服务重新部署时，例如因为更新，也是一样。说到这一点，让我们学习如何最小化相关的停机时间。
- en: Zero-downtime deployments
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零停机部署
- en: 'There are two common ways to minimize the risk of downtime during deployments:
    **blue-green deployments** and **canary releases**. You can use the Envoy sidecar
    when introducing any of those two.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署过程中，有两种常见的方式可以最小化停机风险：**蓝绿部署**和**金丝雀发布**。在引入这两种方式时，您可以使用Envoy边车。
- en: Blue-green deployments
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: '**Blue-green deployments** can help you minimize both the downtime and the
    risk related to deploying your app. To do so, you''ll need two identical production
    environments, called *blue* and *green*. While green serves the customers, you
    can perform the update in the blue one. Once the update was made, the services
    were tested, and all looks stable, you can switch the traffic so it now flows
    to the updated (blue) environment.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝绿部署**可以帮助您最小化部署应用程序时的停机时间和风险。为此，您需要两个相同的生产环境，称为*蓝色*和*绿色*。当绿色为客户提供服务时，您可以在蓝色环境中执行更新。一旦更新完成，服务经过测试，一切看起来稳定，您可以切换流量，使其现在流向更新的（蓝色）环境。'
- en: If any issues are spotted in the blue environment after the switch, the green
    one is still there – you can just switch them back. The users probably won't even
    notice any changes, and because both the environments are up and running, no downtime
    should be visible during the switch. Just make sure you won't lose any data during
    the switch (for example, transactions made in the new environment).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在切换后在蓝色环境中发现任何问题，绿色环境仍然存在-您可以将它们切换回来。用户可能甚至不会注意到任何变化，因为两个环境都在运行，切换期间不应该出现任何停机时间。只需确保在切换期间不会丢失任何数据（例如，在新环境中进行的交易）。
- en: Canary releases
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: The simplest way to not have all your service instances fail after an update
    is often, well, not updating all of them at once. That's the key idea behind the
    incremental variant of blue-green deployments, also called a **canary release**.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，避免在更新后所有服务实例都失败的最简单方法是，嗯，不要一次更新所有服务实例。这就是增量蓝绿部署的关键思想，也称为**金丝雀发布**。
- en: 'In Envoy, you could put the following in the `routes` section of your config:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在Envoy中，您可以将以下内容放入配置的`routes`部分：
- en: '[PRE14]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should also remember to define the two clusters from the preceding snippet,
    the first one with the old version of your service:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该记住从前面的片段中定义的两个集群，第一个集群使用旧版本的服务：
- en: '[PRE15]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second cluster will run the new version:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个集群将运行新版本：
- en: '[PRE16]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When an update gets deployed, the new version of a service will only be seen
    and used by a small fraction (here: 5%) of your users. If the updated instances
    remain stable and no checks and verifications fail, you can gradually update more
    and more hosts in several steps, until all of them are switched to a new version.
    You can do it either by updating the config files by hand or by using the admin
    endpoint. Voila!'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新部署时，服务的新版本只会被一小部分用户（这里是5%）看到和使用。如果更新的实例保持稳定，没有检查和验证失败，您可以逐步在几个步骤中更新更多主机，直到所有主机都切换到新版本。您可以通过手动更新配置文件或使用管理端点来完成。大功告成！
- en: Let's now move on to the last deployment pattern that we'll cover here.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向我们将在这里介绍的最后一个部署模式。
- en: External configuration store
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部配置存储
- en: If you're deploying a simple application, it can be okay to just deploy its
    configuration along with it. However, when you want to have a more complex deployment
    with many application instances, it can quickly become a burden to redeploy a
    new version of the app just to reconfigure it. At the same time, manual configuration
    changes are a no-go if you want to treat your services like cattle, not pets.
    Introducing an external configuration store can be an elegant way to overcome
    such hurdles.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您部署的是一个简单的应用程序，将其配置与应用程序一起部署可能是可以接受的。然而，当您希望进行更复杂的部署，并拥有许多应用程序实例时，重新部署应用程序的新版本以重新配置它可能很快就会成为一个负担。同时，如果您希望将服务视为牲畜而不是宠物，手动配置更改是不可取的。引入外部配置存储可以是克服这些障碍的一种优雅方式。
- en: In essence, your apps can grab their configuration from said store instead of
    just relying on their local config files. This allows you to provide common settings
    for multiple instances and tune parameters for some of them, while having an easy
    and centralized way to monitor all your configs. If you want an arbiter to decide
    which nodes will be master nodes and which will serve as backup ones, an external
    config store can provide the instances with such information. It's also useful
    to implement a configuration update procedure so that your instances can be easily
    reconfigured during operation. You can use ready solutions such as Firebase Remote
    Config, leverage the Java-based Netflix Archaius, or write a configuration store
    on your own leveraging cloud storage and change notifications.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，您的应用程序可以从该存储中获取其配置，而不仅仅依赖于其本地配置文件。这使您可以为多个实例提供共同的设置，并为其中一些实例调整参数，同时可以轻松集中地监视所有配置。如果您希望仲裁者决定哪些节点将成为主节点，哪些将作为备份节点，外部配置存储可以为实例提供此类信息。实施配置更新过程也很有用，以便在操作期间可以轻松重新配置您的实例。您可以使用诸如Firebase
    Remote Config之类的现成解决方案，利用基于Java的Netflix Archaius，或者编写自己的配置存储，利用云存储和更改通知。
- en: 'Now that we''ve learned some useful deployment patterns, let''s move to another
    important topic when it comes to high-level design: APIs.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了一些有用的部署模式，让我们转向另一个重要的主题，当涉及到高级设计时：API。
- en: Managing your APIs
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理您的API
- en: 'Proper APIs are essential for the success of your development team and product.
    We can divide this topic into two smaller ones: system-level APIs and component-level
    APIs. In this section, we''ll discuss handling APIs on the first of those levels,
    while the next chapter will present you with tips on the second.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的API对于您的开发团队和产品的成功至关重要。我们可以将这个主题分为两个较小的主题：系统级API和组件级API。在本节中，我们将讨论如何处理第一级别的API，而下一章将为您提供有关第二级别的提示。
- en: Aside from managing objects, you'll also want to manage your whole API. If you
    want to introduce policies regarding API usage, control access to said API, gather
    performance metrics and other analytical data, or just charge your customers based
    on their use of your interfaces, **API management** (**APIM**) is the solution
    you're looking for.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 除了管理对象，您还希望管理整个API。如果您想要引入关于API使用的策略，控制对该API的访问，收集性能指标和其他分析数据，或者根据客户对接口的使用收费，**API管理**（**APIM**）是您正在寻找的解决方案。
- en: 'Typically a set of APIM tools consists of these components:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的APIM工具集由以下组件组成：
- en: '**An API gateway**: A single entry point for all users of an API. More on this
    in the next section.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API网关**：API所有用户的单一入口点。在下一节中详细介绍。'
- en: '**Reporting and analytics**: To monitor the performance and latency of your
    APIs, resources consumed, or data sent. Such tools can be leveraged to detect
    trends in usage, know which parts of the API and which components behind them
    are performance bottlenecks, or what SLAs are reasonable to offer and how to improve
    them.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告和分析**：监视API的性能和延迟，消耗的资源或发送的数据。这些工具可以用于检测使用趋势，了解API的哪些部分以及其背后的哪些组件是性能瓶颈，或者可以提供合理的SLA以及如何改进它们。'
- en: '**A portal for developers**: To help them get up to speed with your API quickly,
    and to subscribe to your APIs at all.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者门户**：帮助他们快速了解您的API，并随时订阅您的API。'
- en: '**A portal for administrators**: To manage policies, users, and package APIs
    into sellable products.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员门户**：用于管理策略、用户，并将API打包成可销售的产品。'
- en: '**Monetization**: To charge your customers based on how they use your APIs
    and to aid related business processes.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**货币化**：根据客户对API的使用收费，并帮助相关的业务流程。'
- en: APIM tools are provided both by cloud providers and independent parties, for
    example, NGINX's Controller or Tyk.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: APIM工具由云提供商和独立方提供，例如，NGINX的Controller或Tyk。
- en: When designing APIs for a given cloud, get to know the good practices the cloud
    provider usually documents. For instance, you can find common design patterns
    for Google Cloud Platform in the *Further reading* section. In their case, lots
    of the practices revolve around using Protobufs.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在为特定云设计API时，了解云提供商通常记录的良好实践。例如，您可以在*进一步阅读*部分中找到Google Cloud Platform的常见设计模式。在他们的情况下，许多实践都围绕使用Protobufs。
- en: Choosing the right way to consume APIs can take you a long way. The most simple
    way to file requests to your servers is by connecting to the services directly.
    While easy to set up and okay for small apps, it can lead to performance issues
    down the road. An API consumer will likely need to call a few different services,
    leading to high latency. Proper scalability is also impossible to achieve using
    this approach.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的方式来使用API可以让您走得更远。向服务器发送请求的最简单方式是直接连接到服务。虽然易于设置并且对于小型应用程序来说还可以，但是这样做可能会导致性能问题。API使用者可能需要调用几个不同的服务，导致高延迟。使用这种方法也无法实现适当的可扩展性。
- en: A better approach is to use an API gateway. Such gateways are often an essential
    part of an APIM solution, but can also be used on their own.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API网关是一个更好的方法。这样的网关通常是APIM解决方案的一个重要部分，但也可以单独使用。
- en: API gateways
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API网关
- en: An API gateway is an entry point for clients who want to use your API. It can
    then route the incoming requests into a specific instance or cluster of services.
    This can simplify your client code, as it no longer needs to know all the backend
    nodes, or how they cooperate with each other. All a client needs to know is the
    address of an API gateway — the gateway will handle the rest. Thanks to hiding
    the backend architecture from the client, it can be easily remodeled without even
    touching the client's code.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: API网关是客户端想要使用您的API的入口点。然后，它可以将传入的请求路由到特定的服务实例或集群。这可以简化您的客户端代码，因为它不再需要知道所有的后端节点，或者它们如何相互合作。客户端需要知道的只是API网关的地址——网关将处理其余的事情。通过隐藏客户端的后端架构，可以轻松地重新设计它，甚至不用触及客户端的代码。
- en: The gateway can aggregate multiple parts of your system's API into one, and
    then use **layer-7 routing** (for example, based on the URL) to a proper part
    of your system. Layer-7 routing is offered by both cloud providers themselves,
    as well as tools such as Envoy.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 网关可以将系统API的多个部分聚合成一个，并使用**层7路由**（例如，基于URL）到系统的适当部分。层7路由由云提供商自己提供，以及诸如Envoy之类的工具也提供。
- en: As with many patterns described in this chapter, always consider whether it's
    worth it to add more complexity by introducing another pattern to your architecture.
    Think about how adding it will affect your availability, fault tolerance, and
    performance if they matter to you. After all, a gateway usually is just a single
    node, so try to not make it a bottleneck or a single point of failure.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中描述的许多模式一样，始终要考虑是否值得通过引入另一种模式来增加更多的复杂性来添加到您的架构中。考虑一下如果添加它会如何影响您的可用性、容错性和性能。毕竟，网关通常只是一个单一节点，所以尽量不要让它成为瓶颈或单点故障。
- en: The Backends for Frontends pattern we mentioned a few chapters earlier can be
    thought of as a variant of the API gateway pattern. In the Backends for Frontends
    case, each frontend connects to its own gateway.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的几章中提到的前端后端模式可以被认为是API网关模式的一种变体。在前端后端的情况下，每个前端都连接到自己的网关。
- en: Now that you know how system design relates to API design, let's summarize what
    we've discussed in the last sections.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您知道系统设计与API设计的关系，让我们总结一下我们在最后几节中讨论的内容。
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've learned quite a lot of stuff. You now know when to apply
    which service model and how to avoid the common pitfalls of designing distributed
    systems. You've learned about the CAP theorem and what practical outcomes it has
    for distributed architectures. You can now run transactions in such systems successfully,
    reduce their downtime, prevent issues, and gracefully recover from errors. Dealing
    with unusually high load is no longer black magic. Integrating parts of your system,
    even legacy ones, with your newly designed parts is also something you're able
    to perform. You now also have some tricks up your sleeve to increase the performance
    and scalability of your system. Deploying and load balancing your system are also
    demystified, so you can now perform them efficiently. Last but not least, discovering
    services and designing and managing their APIs are all things that you have now
    learned to perform. Nice!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多东西。您现在知道何时应用哪种服务模型，以及如何避免设计分布式系统的常见陷阱。您已经了解了CAP定理以及它对分布式架构的实际影响。您现在可以成功地在这样的系统中运行事务，减少它们的停机时间，预防问题，并从错误中优雅地恢复。处理异常高负载不再是黑魔法。甚至将系统的部分，甚至是传统的部分，与您新设计的部分集成起来，也是您能够执行的。您现在也有一些诀窍来提高系统的性能和可扩展性。部署和负载平衡您的系统也已经被揭秘，所以您现在可以有效地执行它们。最后但同样重要的是，发现服务、设计和管理它们的API都是您现在已经学会的事情。不错！
- en: In the next chapter, we'll learn how you can use specific C++ features to travel
    on the road to excellent architecture in a more pleasant and efficient way.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用特定的C++特性以更愉快和高效的方式走上卓越架构之路。
- en: Questions
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is event sourcing?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事件溯源？
- en: What are the practical consequences of the CAP theorem?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAP定理的实际后果是什么？
- en: What can you use Netflix's Chaos Monkey for?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用Netflix的Chaos Monkey做什么？
- en: Where can caching be applied?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存可以应用在哪里？
- en: How do you prevent your app from going down when a whole data center does?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当整个数据中心宕机时，如何防止您的应用程序崩溃？
- en: Why use an API Gateway?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要使用API网关？
- en: How can Envoy help you to achieve various architectural goals?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Envoy如何帮助您实现各种架构目标？
- en: Further reading
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Microsoft Azure cloud design patterns: [https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure云设计模式：[https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)
- en: 'Common design patterns for cloud APIs by Google: [https://cloud.google.com/apis/design/design_patterns](https://cloud.google.com/apis/design/design_patterns)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌云API的常见设计模式：[https://cloud.google.com/apis/design/design_patterns](https://cloud.google.com/apis/design/design_patterns)
- en: 'Microsoft REST API guidelines: [https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软REST API指南：[https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md)
- en: 'Envoy Proxy''s *Getting Started* page: [https://www.envoyproxy.io/docs/envoy/latest/start/start](https://www.envoyproxy.io/docs/envoy/latest/start/start)'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Envoy代理的*入门*页面：[https://www.envoyproxy.io/docs/envoy/latest/start/start](https://www.envoyproxy.io/docs/envoy/latest/start/start)
- en: 'Active-active application architectures with MongoDB: [https://developer.mongodb.com/article/active-active-application-architectures](https://developer.mongodb.com/article/active-active-application-architectures)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB的主动-主动应用架构：[https://developer.mongodb.com/article/active-active-application-architectures](https://developer.mongodb.com/article/active-active-application-architectures)
