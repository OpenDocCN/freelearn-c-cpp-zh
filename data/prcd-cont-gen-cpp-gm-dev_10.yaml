- en: Chapter 10. Component-Based Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。基于组件的架构
- en: Procedural game systems are incredibly versatile by nature. Therefore, the frameworks
    and infrastructures that they're implemented into need to share the same properties.
    Component-based systems, such as the Unity game engine, excel at this, and typically
    offer more versatility over traditional inheritance-based systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 过程化游戏系统本质上非常灵活。因此，它们所实现的框架和基础设施需要具有相同的特性。基于组件的系统，如Unity游戏引擎，在这方面表现出色，并且通常比传统的基于继承的系统提供更多的灵活性。
- en: When building a large, dynamic system such as a game engine, a tradition inheritance-based
    approach will present problems. Inheritance structures become messy and objects
    become larger as they are required to do more. As a result, behavior becomes less
    encapsulated. A component-based approach solves these issues, so to finish our
    work we'll branch off a little to take a look at what a component-based system
    is, why it works hand in hand with procedural generation, and how we can improve
    the existing engine to benefit from it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建像游戏引擎这样的大型动态系统时，传统的基于继承的方法会带来问题。继承结构变得混乱，对象变得越来越大，因为它们需要做更多的事情。结果，行为变得不够封装。基于组件的方法解决了这些问题，因此为了完成我们的工作，我们将稍微分支一下，看看基于组件的系统是什么，为什么它与过程生成相辅相成，以及我们如何改进现有的引擎以从中受益。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Problems with a traditional inheritance approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统继承方法的问题
- en: The pros and cons of a component-based approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于组件的方法的利弊
- en: Understanding component-based architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基于组件的架构
- en: Implementing a component-based system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施基于组件的系统
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are unfamiliar with the Unity engine, head to [https://unity3d.com/](https://unity3d.com/)
    and check it out. It's one of the industry's leading game engines and uses a component-based
    approach. The best part is that it's completely free!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Unity引擎不熟悉，请访问[https://unity3d.com/](https://unity3d.com/)并了解一下。它是行业领先的游戏引擎之一，采用了基于组件的方法。最好的部分是它完全免费！
- en: Understanding component-based architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基于组件的架构
- en: Component-based architecture, also known as component-based design and modular
    programming, is an approach to software design that aims to break down behavior
    into succinct, reusable components. We already do this to a certain extent with
    object-orientated design, but component-based architecture takes this further.
    For example, if an object such as a sprite or a 3D model needs a certain behavior,
    it will be defined through a component that the object will own, as opposed to
    being inherited from a `base` class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的架构，也称为基于组件的设计和模块化编程，是一种旨在将行为分解为简洁、可重用组件的软件设计方法。我们在一定程度上已经在面向对象的设计中做到了这一点，但基于组件的架构将其推向了更深的层次。例如，如果一个对象，如精灵或3D模型需要某种行为，它将通过对象拥有的组件来定义，而不是从“基础”类继承而来。
- en: Problems with a traditional inheritance-based approach
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统基于继承的方法的问题
- en: Before we get into the pros and cons of a component-based approach, let's look
    at the problems that a traditional inheritance-based approach brings. It's these
    problems that we'll aim to fix.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论基于组件的方法的利弊之前，让我们先看看传统的基于继承的方法带来的问题。正是这些问题我们将要解决。
- en: Convoluted inheritance structures
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂的继承结构
- en: 'Let''s suppose that we have a simple `player` object that requires a 3D model
    and to be effected by our game physics. Let''s look at an inheritance structure
    that may be needed to create this object:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的“玩家”对象，需要一个3D模型，并受到游戏物理的影响。让我们看看可能需要创建这个对象的继承结构：
- en: '![Convoluted inheritance structures](img/B04920_10_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![复杂继承结构](img/B04920_10_02.jpg)'
- en: You can see from this diagram that even this simple scenario can result in a
    complex inheritance structure. If you now replace this simple example with an
    entire game engine, you can imagine how complex and unmanageable the inheritance
    structure would be.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图表中可以看出，即使是这个简单的场景也可能导致复杂的继承结构。如果你现在用整个游戏引擎来替换这个简单的例子，你可以想象继承结构会变得多么复杂和难以管理。
- en: This is a major downfall of traditional inheritance-based design; as your system
    grows larger, objects get more convoluted and entangled in the inheritance tree.
    This complexity does not help us when we're trying to create a procedural system.
    We want a system that is as flexible as possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传统继承设计的一个主要缺陷；随着系统变得越来越大，对象在继承树中变得越来越复杂和纠缠不清。当我们试图创建一个过程化系统时，这种复杂性并不会帮助我们。我们希望一个尽可能灵活的系统。
- en: Circular dependencies
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环依赖
- en: 'Another problem that can arise with complex inheritance structures is that
    of circular dependencies. This is where class `A` depends on class `B`, which
    in turn depends on class `A`, and so on. The following diagram should make this
    clearer:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂继承结构可能出现的另一个问题是循环依赖。这是指类A依赖于类B，而类B又依赖于类A，依此类推。下面的图表应该能更清楚地说明这一点：
- en: '![Circular dependencies](img/B04920_10_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![循环依赖](img/B04920_10_03.jpg)'
- en: While circular dependencies can be avoided through proper program structure,
    it becomes increasingly harder as the system grows larger. As the inheritance
    tree grows, so do the dependencies, and it can cause real problems within a system.
    By removing complex inheritance, we also remove the risk of messy dependencies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然循环依赖可以通过适当的程序结构来避免，但随着系统变得越来越大，这变得越来越困难。随着继承树的增长，依赖关系也会增加，并且可能在系统内部造成真正的问题。通过消除复杂的继承，我们也消除了混乱依赖的风险。
- en: Benefits of component-based architecture
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于组件的架构的好处
- en: As developers, we're always making trade-offs. It's imperative to know both
    the pros and cons of an approach so that we can make informed decisions regarding
    whether it belongs in a solution. Since we've identified some flaws with an inheritance-based
    approach, and aim to solve them with a component-based approach, let's familiarize
    ourselves with a few of its pros and cons.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们总是在权衡利弊。了解一种方法的优缺点是至关重要的，这样我们才能做出关于它是否适合解决方案的知情决定。由于我们已经确定了基于继承的方法存在一些缺陷，并且希望通过基于组件的方法来解决这些问题，让我们熟悉一下它的一些优缺点。
- en: Avoiding complex inheritance structures
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免复杂的继承结构
- en: 'We identified a hypothetical game situation earlier and looked at what a typical
    inheritance-based approach might look like. Let''s take a look at the same example
    if we take a component-based approach:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前确定了一个假设的游戏情况，并看了一下典型的基于继承的方法可能是什么样子。让我们看看如果采用基于组件的方法，同样的例子会是什么样子：
- en: '![Avoiding complex inheritance structures](img/B04920_10_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![避免复杂的继承结构](img/B04920_10_01.jpg)'
- en: It's clear that this solution is much simpler and neater than its inheritance-based
    equivalent. Instead of obtaining its behavior from parents and thus creating a
    chain of dependencies, it's instead broken into succinct components that can simply
    be attached to an object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这个解决方案比基于继承的等价物要简单得多，也更整洁。它不是从父级获取其行为，从而创建一系列依赖关系，而是被分解成简洁的组件，可以简单地附加到一个对象上。
- en: Code is broken into highly reusable chunks
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码被分解成高度可重用的块
- en: Another benefit of component-based architecture is the high reuse value of code
    once it's encapsulated in a component. Once encapsulated, behavior can be easily
    given to objects by simply attaching the component. This not only avoids duplicate
    code, but also makes it easy to build complex objects by combining multiple components.
    This is where it lends itself to procedural generation. We can procedurally put
    objects together like Lego with these reusable components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的架构的另一个好处是一旦代码封装在组件中，代码的高重用价值。一旦封装，行为可以通过简单地附加组件来轻松赋予对象。这不仅避免了重复的代码，还使得通过组合多个组件轻松构建复杂对象变得容易。这就是它适用于过程生成的地方。我们可以像乐高一样用这些可重用的组件程序地组装对象。
- en: Highly maintainable and scalable
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 易维护和可扩展
- en: As a result of the code being reusable, it also makes it very easy to maintain.
    If a set of objects all obtain their behavior from a single source, then only
    one edit is needed and it will affect them all.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码是可重用的，这也使得维护变得非常容易。如果一组对象都从同一个源获取它们的行为，那么只需要进行一次编辑，就会影响它们所有。
- en: Component-based systems are also easier to scale. Since our components are succinct
    individual modules and don't have complex dependencies, we can add them at will.
    If we want new behavior, we don't have to worry about questions such as *Where
    it will go?*, *What will it depend on?*, *What will it inherit from?*, and so
    on. We simply build the new component and use it where we need to.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的系统也更容易扩展。由于我们的组件是简洁的单独模块，没有复杂的依赖关系，我们可以随意添加它们。如果我们想要新的行为，我们不必担心诸如“它将放在哪里？”，“它将依赖于什么？”，“它将继承自什么？”等问题。我们只需构建新组件并在需要时使用它。
- en: The disadvantages of component-based architecture
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于组件的架构的缺点
- en: Now it's time to have a look at the opposing side of the argument. Although
    component-based design does bring with it a range of great benefits, there are
    things that you need to consider.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看争论的对立面了。尽管基于组件的设计确实带来了一系列巨大的好处，但也有一些需要考虑的事情。
- en: Code can become too fragmented
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码可能变得过于分散
- en: 'To a certain extent this is the goal of component-based design: to break code
    into manageable chunks. But this can be taken too far. If objects and functionality
    are broken down too far, then we end up with the code base scattered into hundreds
    of tiny components, making it a mess. Always keep this in mind. Yes, we do want
    to break our code into manageable and reusable components; just don''t go crazy
    with it!'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上，这就是基于组件的设计的目标：将代码分解成可管理的块。但这可能走得太远了。如果对象和功能被分解得太细，那么我们最终会发现代码库散布在数百个小组件中，变得一团糟。永远记住这一点。是的，我们确实希望将我们的代码分解成可管理和可重用的组件；只是不要过度使用！
- en: Unnecessary overhead
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不必要的开销
- en: Expanding on the previous point, if code is broken down into too many small
    components, then we'll see an increase in useless overhead. If a project contains
    many components, we'll frequently find ourselves dipping in and out of them to
    perform tasks. While adding a component might make code easier to manage and maintain,
    it also introduces overhead when it's used.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的基础上，如果代码被分解成太多小组件，那么我们将看到无用的开销增加。如果一个项目包含许多组件，我们将经常发现自己在其中来回进行任务。虽然添加一个组件可能会使代码更易于管理和维护，但在使用时也会引入开销。
- en: Complex to use
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用复杂
- en: The final disadvantage of components is simply their use, as it can be more
    complex than a traditional object model. Instead of accessing a member function
    directly, we have to go through the component that they belong to. If we have
    20 components in an object, then we have to remember where the variables are and
    which component we need to use. While it's not rocket science, it's certainly
    more complex than having a single object that directly owns all the behavior and
    data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的最终缺点就是它们的使用，因为它可能比传统的对象模型更复杂。我们不是直接访问成员函数，而是必须通过它们所属的组件。如果一个对象中有20个组件，那么我们必须记住变量在哪里，需要使用哪个组件。虽然这并不是什么高深的科学，但肯定比拥有直接拥有所有行为和数据的单个对象更复杂。
- en: An overview
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Hopefully, it's now clear how component-based design aids procedural design
    more than a traditional inheritance-based approach. Procedural generation is all
    about flexibility, and when systems grow to a certain size an inheritance-based
    system can struggle to provide that. By allowing us to break code into reusable
    objects, component-based design keeps code flexible and without dependencies so
    that we can move components wherever we want.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在清楚了基于组件的设计如何比传统的基于继承的方法更有利于过程化设计。过程生成的关键在于灵活性，当系统增长到一定规模时，基于继承的系统可能无法提供这种灵活性。通过允许我们将代码分解为可重用的对象，基于组件的设计保持了代码的灵活性，并且没有依赖性，这样我们就可以随意移动组件。
- en: Designing the component system
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计组件系统
- en: A component-based system can be implemented in many ways. So, before we write
    any code, let's look at some possibilities. The goal is to break reusable behavior
    into succinct components and be able to add and remove them from the existing
    objects with ease. All objects share a common base class named object so we'll
    add the facility to add components to and remove them from this class. We can
    then ensure that it will be propagated to all the subsequent classes in the project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的系统可以以多种方式实现。因此，在编写任何代码之前，让我们看看一些可能性。目标是将可重用的行为分解为简洁的组件，并能够轻松地向现有对象添加和删除它们。所有对象共享一个名为对象的公共基类，因此我们将为该类添加向其添加组件和从中删除组件的功能。然后我们可以确保它将传播到项目中所有后续的类中。
- en: 'There are a number of ways to implement a component-based approach, and there
    is no single right answer. For example, we could create a function to add or remove
    each component individually. Here''s an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多实现基于组件的方法的方式，没有单一的正确答案。例如，我们可以创建一个函数来单独添加或删除每个组件。下面是一个例子：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While this will make things straightforward, we will have a lot of duplicate
    code in the class. Also, every time we add a component, we will have to create
    two matching functions: one to get the component and one to set it. That''s a
    bit cumbersome!'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这将使事情变得简单，但是在类中会有很多重复的代码。而且，每次添加一个组件，我们都需要创建两个匹配的函数：一个用于获取组件，一个用于设置组件。这有点麻烦！
- en: 'Another approach involves simply making the component values public. So, instead
    of interacting with the components through functions, we can directly access them
    through the object that they belong to:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是简单地将组件值公开。因此，我们可以直接通过它们所属的对象访问组件，而不是通过函数与组件交互：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though this is an attractive option, as it would make life a thousand times
    simpler for us, it's almost never a good idea to make variables public like this.
    Having to make variables public to make code work usually indicates a flaw in
    the architecture of the system. If you ever find that this is the case, the cause
    of the problem should be sorted.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个吸引人的选择，因为这会让我们的生活变得简单千百倍，但是公开变量通常不是一个好主意。通常需要将变量公开以使代码工作，这通常表明系统架构存在缺陷。如果你发现这种情况，问题的原因应该得到解决。
- en: 'If we look at an existing component-based game engine such as Unity, we can
    see how they approach this problem. The following code demonstrates how to get
    a component from an object in Unity. This is taken directly from the Unity documentation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一个现有的基于组件的游戏引擎，比如Unity，我们可以看到他们是如何解决这个问题的。以下代码演示了如何从Unity对象中获取一个组件。这是直接从Unity文档中摘取的：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see that a single function named `GetComponent` is defined, and a type
    is supplied to return the corresponding component. We could create a similar system
    using enumerators to denote the type, allowing users to specify a component type
    via a parameter and then using that in a `switch` statement to return the correct
    variable.Let''s assume that we created an `AttachComponent` function to add a
    component to an object using the following declaration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到定义了一个名为`GetComponent`的函数，并提供了一个类型来返回相应的组件。我们可以使用枚举器创建一个类似的系统，以表示类型，允许用户通过参数指定组件类型，然后在`switch`语句中使用它来返回正确的变量。假设我们创建了一个`AttachComponent`函数，用以下声明来向对象添加一个组件：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the function definition, we have something that looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，我们有类似于这样的东西：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would work fine if the user passed a matching type and component, but there's
    nothing about this that will guarantee that. For example, a user can specify a
    movement component but actually pass an audio component, and that would be bad!
    We'll actually solve this through the use of templates!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户传递了匹配的类型和组件，这种方法就可以正常工作，但是这并不能保证。例如，用户可以指定一个移动组件，但实际上传递了一个音频组件，这将是不好的！我们将通过模板来解决这个问题！
- en: C++ templates
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++模板
- en: C++ templates allow us to define functions and classes that work with generic
    types. This allows a function or a class to accept any type, and it only has to
    be written once. This is what we want. We want to define a single get/set function
    for components, and we'll template them to make them generic and flexible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: C++模板允许我们定义与通用类型一起工作的函数和类。这允许函数或类接受任何类型，而且只需要编写一次。这正是我们想要的。我们希望为组件定义一个单一的获取/设置函数，并使用模板使其通用和灵活。
- en: Let's take a look at a practical example of templates to get a better idea of
    how they actually work.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个模板的实际例子，以更好地了解它们是如何工作的。
- en: Using templates
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板
- en: 'Let''s suppose that we require a function to add two numbers, and we want to
    support a range of types. To achieve this, we could declare a function for each
    type that we want to support, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一个函数来添加两个数字，并且我们希望支持一系列类型。为了实现这一点，我们可以为我们想要支持的每种类型声明一个函数，如下所示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Looking at these two functions, the only thing that is different about them
    is their return and parameter types. How great would it be if we could say "Don't
    worry about the type, I'll give you it later" and just have one function? Enter
    templates!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这两个函数，它们唯一不同的是它们的返回和参数类型。如果我们能够说“不用担心类型，我会在后面给你”，然后只有一个函数，那该有多好呀？这就是模板的作用！
- en: Template declarations
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板声明
- en: 'C++ templates allow us to define functions with generic types and specify the
    type later as we call the function. It''s an incredibly useful feature that creates
    flexible and reusable code instead of having multiple function definitions that
    are almost identical. If you use templates, the previous example requires only
    one function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: C++模板允许我们定义具有通用类型的函数，并在调用函数时指定类型。这是一个非常有用的功能，可以创建灵活和可重用的代码，而不是有多个几乎相同的函数定义。如果使用模板，前面的例子只需要一个函数：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Template parameters can use either the **typename** or the **class** keywords.
    Both of these keywords are entirely interchangeable and do the same thing. However,
    they can be used as a hint to denote the parameter type. Use **class** if a parameter
    is a class, and use **typename** with all the other types (int, char*, and so
    on).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数可以使用**typename**或**class**关键字。这两个关键字完全可以互换使用并起到相同的作用。但是，它们可以用作提示来表示参数类型。如果参数是类，则使用**class**，对于所有其他类型（int、char*等），使用**typename**。
- en: 'The following syntax is used to declare a template:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法用于声明模板：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the declaration, we create a template parameter named `T`. This gives us
    an ambiguous data type that can be used within the function declaration until
    an actual type is set later when the template is called. The generic `T` type
    can be used just like normal types: specifying the return types, creating variables,
    and setting the parameter types.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明中，我们创建了一个名为`T`的模板参数。这给了我们一个模糊的数据类型，可以在函数声明中使用，直到稍后在调用模板时设置实际类型。通用的`T`类型可以像普通类型一样使用：指定返回类型、创建变量和设置参数类型。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The name of your template parameters can be anything that you like, although
    it's most commonly **TYPE** or **T**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数的名称可以是任何你喜欢的，尽管最常见的是**TYPE**或**T**。
- en: 'Templates can also have multiple types defined. For example, let''s say that
    a function needs to take two different data types. We can use the following template:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 模板还可以定义多个类型。例如，假设一个函数需要使用两种不同的数据类型。我们可以使用以下模板：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, templates can also be used with normal data types and they don''t
    have to be ambiguous:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模板也可以与普通数据类型一起使用，它们不必是模糊的：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using templates
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板
- en: 'With the templates defined, let''s have a look at how to use them. We''ve given
    the templates ambiguous types, so one way to call them is to explicitly tell the
    template what type we want to work with. This is done by passing a type in the
    <> brackets after the function/class call:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有了定义的模板，让我们看看如何使用它们。我们给模板指定了模糊的类型，因此调用它们的一种方式是明确告诉模板我们想要使用的类型。这是通过在函数/类调用后的<>括号中传递类型来完成的：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first two are straightforward; we assigned a type for each template parameter.
    However, the last one is slightly different. Since the second type is fixed, there''s
    no need to specify it in angle brackets. Instead, we can use it like a normal
    parameter, passing the value that we want to use. This leaves us with just one
    parameter in the parentheses: the generic type value.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个是直接的；我们为每个模板参数分配了一个类型。然而，最后一个略有不同。由于第二个类型是固定的，所以不需要在尖括号中指定它。相反，我们可以像普通参数一样使用它，传递我们想要使用的值。这样，括号中只剩下一个参数：通用类型值。
- en: Something important that needs to be noted is that the value of template parameters
    is determined at compile time. This means that for each different instantiation
    of a template, a unique function is created. In the last example, the value of
    the **int** is passed as a template function, which means that a function that
    is hard-coded to multiply by the value 2 is created.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事情是，模板参数的值是在编译时确定的。这意味着对于模板的每个不同实例化，都会创建一个唯一的函数。在最后的例子中，**int**的值被传递为模板函数，这意味着创建了一个硬编码为乘以值2的函数。
- en: 'Let''s suppose that we called `IntegerMultiple` twice:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们调用了`IntegerMultiple`两次：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Even though we''ve called the same template, the complier will create two different
    versions of `IntegerMultiply`. One version will always multiply by 2, and the
    other version will always multiply by 10\. For this reason, the second template''s
    parameters, the integers, have to be constant expressions. The following code
    will result in a compilation error:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们调用了相同的模板，编译器将创建两个不同版本的`IntegerMultiply`。一个版本将始终乘以2，另一个版本将始终乘以10。因此，第二个模板的参数，整数，必须是常量表达式。以下代码将导致编译错误：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These functions can also be called without the type being explicitly denoted
    in angle brackets when the type can be resolved by the compiler. For this to happen
    there needs to be no ambiguity regarding the type. For example, the following
    calls are fine:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器可以解析类型时，这些函数也可以在尖括号中不明确表示类型的情况下调用。为了发生这种情况，关于类型的歧义必须不存在。例如，以下调用是可以的：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In these calls, each ambiguous type in the template is given a single type.
    The compiler can therefore deduce the type of **T** automatically. However, consider
    a scenario where different parameters are passed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些调用中，模板中的每个模糊类型都被赋予一个单一类型。因此，编译器可以自动推断**T**的类型。然而，考虑一种不同的参数传递的情况：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**T** now has two possible values, which means that the compiler cannot deduce
    the type and will result in an error.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**T**现在有两个可能的值，这意味着编译器无法推断类型，将导致错误。'
- en: Template specialization
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板特化
- en: Now that we have an understanding of how templates work in general, let's have
    a look at template specialization. We already know that we can define a template
    with generic types and define them later when we call the function. That's fine
    if all the possible implementations share the same behavior, but what if we want
    different behavior depending on the type?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对模板的一般工作原理有了了解，让我们来看看模板特化。我们已经知道可以使用通用类型定义模板，并在调用函数时稍后定义它们。如果所有可能的实现共享相同的行为，那就没问题，但如果我们想要根据类型的不同行为呢？
- en: 'Let''s suppose that we want to use the `Add` function with a string type. We
    want to pass in two words, but we want to put in a space between them when this
    is the case. The default template function doesn''t facilitate this so we have
    to specialize it for this case. To specialize a template we simply create a declaration
    where we replace the ambiguous type with a fixed one, which is `std::string` in
    our case:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使用`Add`函数与字符串类型。我们想要传入两个单词，但当这种情况发生时，我们想要在它们之间放一个空格。默认的模板函数无法实现这一点，因此我们必须为这种情况专门设置。要为模板设置专门的内容，我们只需创建一个声明，其中用固定的类型替换模糊的类型，这在我们的情况下是`std::string`：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, when the `template` function is called and the `std::string` type is specified,
    it will use this definition and not the generic one. With this, we can still use
    templates but provide specific implementations for certain types. Very handy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当调用`template`函数并指定`std::string`类型时，它将使用这个定义而不是通用的定义。有了这个，我们仍然可以使用模板，但为某些类型提供特定的实现。非常方便。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you wish to learn more about C++ templates, visit [http://www.cplusplus.com/doc/tutorial/templates/](http://www.cplusplus.com/doc/tutorial/templates/).
    This is a great site in general, and it has some awesome information on this topic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于C++模板的知识，请访问[http://www.cplusplus.com/doc/tutorial/templates/](http://www.cplusplus.com/doc/tutorial/templates/)。这是一个很棒的网站，它对这个主题有一些很棒的信息。
- en: Function overloading
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数重载
- en: Somewhat similar to templates, function overloading is another way in which
    we can make code and classes more versatile. We've already used overloaded functions
    during the course of the book, but they were provided with the code base. So,
    let's take a quick look at them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与模板有些相似，函数重载是我们可以使代码和类更加灵活的另一种方式。在本书的过程中，我们已经使用了重载函数，但它们是由代码库提供的。因此，让我们快速看一下它们。
- en: 'When we define functions, we set fixed parameter types. Here''s an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义函数时，我们设置了固定的参数类型。这里有一个例子：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this definition, we can only pass a parameter of the `T` type. What if
    we want a choice of parameters? What if we want to be able to pass parameters
    of type `T` or type `Y`. Well, we can redefine the function, setting the same
    return type and name, but with unique parameters:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定义，我们只能传递`T`类型的参数。如果我们想要选择参数呢？如果我们想要能够传递`T`类型或`Y`类型的参数呢。好吧，我们可以重新定义函数，设置相同的返回类型和名称，但使用唯一的参数：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now have two function declarations with different parameters. When we call
    `DoStuff`, we'll have the option of which parameter to pass. Also, with function
    overloading, each declaration gets its own body, just like with template specialization.
    While similar on the surface, function overloads and template specializations
    work in different ways, though that's beyond the scope of this book. For now,
    all that we need is a basic understanding of them and we can get started!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个具有不同参数的函数声明。当我们调用`DoStuff`时，我们可以选择传递哪个参数。另外，使用函数重载，每个声明都有自己的函数体，就像模板特化一样。虽然在表面上相似，但函数重载和模板特化的工作方式不同，不过这超出了本书的范围。目前，我们只需要对它们有一个基本的理解，就可以开始了！
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As with templates, for further reading on function overloading, visit [http://www.cplusplus.com/doc/tutorial/functions2/](http://www.cplusplus.com/doc/tutorial/functions2/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与模板一样，要了解更多关于函数重载的内容，请访问[http://www.cplusplus.com/doc/tutorial/functions2/](http://www.cplusplus.com/doc/tutorial/functions2/)。
- en: Creating a base component
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基础组件
- en: With the theory covered, let's implement this into our project. The overwhelming
    message of this chapter has so far has been to use components to avoid messy inheritance,
    but we still need *some* inheritance as we need to use polymorphism!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经讲解完毕，让我们将其实现到我们的项目中。本章的主要信息迄今为止一直是使用组件来避免混乱的继承，但我们仍然需要*一些*继承，因为我们需要使用多态！
- en: Each object will be able to hold a range of components so we'll store them in
    a single `generic` container. In order for us to do this we need to make use of
    polymorphism, ensuring that all components inherit from a common base class. That
    base class is what we're going to implement now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都能够持有一系列组件，因此我们将它们存储在一个单一的`generic`容器中。为了做到这一点，我们需要利用多态性，确保所有组件都继承自一个共同的基类。现在我们要实现这个基类。
- en: 'Let''s add a new class to the project and call it `Component`. We''ll leave
    it to you to implement the `.cpp`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向项目中添加一个新的类，并将其命名为`Component`。我们将把实现留给你来完成`.cpp`：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we've added a `virtual update` function here as a class must have
    at least one `virtual` function in order to be polymorphic. With the `Component`
    base class created, we can now add the functions to `get` and `set` components,
    and they will reside in the base `Object` class so that they are available to
    all objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里添加了一个`virtual update`函数，因为一个类必须至少有一个`virtual`函数才能是多态的。有了`Component`基类创建后，我们现在可以添加`get`和`set`组件的函数，它们将驻留在基础`Object`类中，以便所有对象都可以使用它们。
- en: Component functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件函数
- en: If we think about the behavior that we want, we need to be able to give an object
    a component of any given type. We also need to be able to fetch that same component
    later. We'll call these functions `AttachComponent` and `GetComponent`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑我们想要的行为，我们需要能够给一个对象赋予任何给定类型的组件。我们还需要能够稍后获取相同的组件。我们将称这些函数为`AttachComponent`和`GetComponent`。
- en: Earlier in the chapter, we identified how we can use templates to create a function
    with generic types and give them real values when we need them. We'll use templates
    and polymorphism to create these two functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们确定了如何使用模板来创建具有通用类型的函数，并在需要时给它们提供真实值。我们将使用模板和多态性来创建这两个函数。
- en: Attaching a component
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加组件
- en: The first function that we're going to write will be used to attach a component
    of a given type to the `Object` class. Since we've already identified that we're
    going to store all components in a single generic container, this function will
    be a relatively simple template. The only thing that we need to be aware of is
    that we should not add the same component twice!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要编写的第一个函数将用于将给定类型的组件附加到“Object”类。由于我们已经确定要将所有组件存储在单个通用容器中，因此这个函数将是一个相对简单的模板。我们唯一需要注意的是我们不应该添加相同的组件两次！
- en: Let's start by defining the container, as that's where we'll store the objects.
    Since we need to take advantage of polymorphism, we can't store actual objects.
    So instead, we're going to use shared pointers so that we can pass them around
    with ease.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义容器，因为那是我们将存储对象的地方。由于我们需要利用多态性，我们不能存储实际对象。因此，我们将使用共享指针，以便我们可以轻松地传递它们。
- en: 'Let''s start by defining the generic container in `Object.h`. Don''t forget
    to `#include` our new Component class so that Object can see it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在“Object.h”中定义通用容器。不要忘记“#include”我们的新组件类，以便Object可以看到它：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now it's time for the actual `AttachComponent` method. We could take a naïve
    approach and just append the new component to the `generic` container. The problem
    here is that we could add multiples of the same component type, and that's not
    something that we want. Before we add the component to the collection, we'll first
    check whether a component of the same type already exists, and for that, we'll
    use the `std::dynamic_pointer_cast` function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实际的“AttachComponent”方法的时候了。我们可以采取一个天真的方法，只是将新组件附加到“通用”容器。问题在于我们可能会添加多个相同类型的组件，这不是我们想要的。在将组件添加到集合之前，我们将首先检查是否已经存在相同类型的组件，为此，我们将使用“std::dynamic_pointer_cast”函数。
- en: 'This function lets us cast between pointers and returns a null pointer if it
    fails. It''s very handy, and when combined with templates, we can create a single
    function that will accept any component type, create one, check whether one of
    the same type already exists, and if it does, it will overwrite it. We''ll define
    this template function inline in the header. Let''s add the following code to
    `Object.h`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数让我们在指针之间进行转换，并在失败时返回空指针。这非常方便，当与模板结合使用时，我们可以创建一个单一的函数，它将接受任何组件类型，创建一个组件，检查是否已经存在相同类型的组件，如果存在，它将覆盖它。我们将在头文件中内联定义这个模板函数。让我们将以下代码添加到“Object.h”中：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using templates, we can operate with the generic `T` type, which allows us to
    perform the cast to check whether the types match. If they do match, we overwrite
    the old component with the new one; if not, we simply add it to our collection.
    We also return the new component when we're done in case the user wants it straightaway.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板，我们可以操作通用的“T”类型，这允许我们执行转换以检查类型是否匹配。如果它们匹配，我们用新的组件覆盖旧的组件；如果不匹配，我们只是将其添加到我们的集合中。完成后，如果用户想要，我们还会返回新的组件。
- en: That's all there is to it, and the beauty of using templates like this is how
    scalable the system is. It doesn't matter if we add 1,000 components; this function
    will be able to attach them to any object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，使用这种模板的美妙之处在于系统的可扩展性。无论我们添加了1000个组件，这个函数都能够将它们附加到任何对象。
- en: Retuning a component
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回一个组件
- en: The next template that we need to create is for a function that's used to return
    a given component. Again, let's think about where we'll need the generic type.
    The function will need to return the component type, so that needs to be generic,
    and we also need to find the correct component type. So, we'll use the generic
    type in the pointer cast like we did with the previous function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的下一个模板是用于返回给定组件的函数。同样，让我们考虑一下我们将在何处需要通用类型。该函数将需要返回组件类型，因此需要是通用的，并且我们还需要找到正确的组件类型。因此，我们将像上一个函数一样在指针转换中使用通用类型。
- en: 'Let''s get this template defined in the header of `Object`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在“Object”的头文件中定义这个模板：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this, we have the ability to add any component to any object and return
    the correct type. The best part is that two simple functions provide all this
    functionality! How awesome are templates!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以将任何组件添加到任何对象并返回正确的类型。最棒的部分是两个简单的函数提供了所有这些功能！模板是多么棒！
- en: 'If you want to test this code before we move on you can do. At the end of the
    `Game::Initialize` function, add the following lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在我们继续之前测试这段代码，你可以这样做。在“Game::Initialize”函数的末尾，添加以下行：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you use **breakpoints** and look at the values at runtime, you''ll see that
    this code does the following things:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用**断点**并在运行时查看值，您会发现这段代码做了以下几件事情：
- en: It adds a new `Component` object to the generic container
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它向通用容器添加一个新的“Component”对象
- en: It tries to add a second `Component` object; so it instead overwrites the current
    one
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它试图添加第二个“Component”对象；所以它代替了当前的
- en: It realizes that we want the component with the type `Component`; so it returns
    it
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它意识到我们想要类型为“Component”的组件；所以它返回它
- en: Creating a transform component
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个变换组件
- en: With the ability to attach and return components, let's get our first component
    built and added. We'll start with a simple one first. Currently, all objects have
    a position by default that's provided by the `Object` base class. Let's break
    this behavior into its own component.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有了附加和返回组件的能力，让我们构建并添加我们的第一个组件。我们先从一个简单的开始。目前，所有对象默认都有一个由“Object”基类提供的位置。让我们将这个行为分解成自己的组件。
- en: Encapsulating transform behavior
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装变换行为
- en: Since we're converting an inheritance-based approach to a component-based one,
    the first task is to take the transform behavior out of the `Object` class. Currently,
    that consists of a `single` position variable and a function to both `get` and
    `set` that value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将基于继承的方法转换为基于组件的方法，第一项任务是将“Object”类中的变换行为取出来。目前，这包括一个“单一”的位置变量和一个既“获取”又“设置”该值的函数。
- en: 'Let''s create a new class named `TransformComponent` and move this behavior
    into it, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为“TransformComponent”的新类，并将这个行为移到其中，如下所示：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll also take the function definitions from `Object.cpp` file and place
    them in `TransformComponent.cpp`, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将从`Object.cpp`文件中获取函数定义，并将它们放在`TransformComponent.cpp`中，如下所示：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We now have a component that will provide a position to an object. The last
    thing that we need to do is include the header for this component in the `Object`
    class so that all the extending classes can see it. Let''s add the following code
    to `Object.h`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个组件，它将为对象提供一个位置。我们需要做的最后一件事是在`Object`类中包含这个组件的头文件，以便所有扩展类都可以看到它。让我们在`Object.h`中添加以下代码：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's time to add this component to the objects! This is a large task, and it's
    one that will be left for you to complete in your own time, but to demonstrate
    how it's done, we'll quickly add the component to the `player` class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将这个组件添加到对象中了！这是一个庞大的任务，留给你自己在空闲时间完成，但为了演示如何完成，我们将快速地将组件添加到`player`类中。
- en: Adding a transform component to the player
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向玩家添加一个transform组件
- en: 'Since we placed the two functions to attach and get components in the base
    `Object` class, we can call `AttachComponent` directly from within the player.
    We''ll do this in the constructor as we''ll need the component set up before we
    get to any logic. Let''s head to `Player::Player` and add the following code to
    it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将附加和获取组件的两个函数放在了基类`Object`中，我们可以直接从player中调用`AttachComponent`。我们将在构造函数中执行此操作，因为我们需要在逻辑之前设置好组件。让我们前往`Player::Player`并将以下代码添加到其中：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's all there is to it! The `player` now has all the data and functionality
    that we added to the transform component, and when we want to use it, we can simply
    go through this new component. You may remember that we identified overhead as
    one of the potential downsides of component-based design. We can see now how moving
    the behavior into a component has introduced overhead.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！`player`现在拥有我们添加到transform组件的所有数据和功能，当我们想要使用它时，我们可以简单地通过这个新组件进行。你可能记得我们曾经将开销标识为基于组件的设计的潜在缺点之一。现在我们可以看到，将行为移入组件中引入了开销。
- en: Using the transform component
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用transform组件
- en: 'The final part to this puzzle will be looking at how we use the new component.
    Previously, if we wanted to get the position of the player, all we had to do was
    use the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的最后一部分将是看看我们如何使用新的组件。以前，如果我们想要获取玩家的位置，我们只需要使用以下代码：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since these values now belong to the `transform` component, we need to make
    a slight change and access those values through the `component` instead, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些值现在属于`transform`组件，我们需要做一个小改变，并通过`component`来访问这些值，如下所示：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since these functions are public, we can call them anywhere. For example, if
    we were in the game class and wanted the position of the player object, we would
    do something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些函数是公共的，我们可以在任何地方调用它们。例如，如果我们在游戏类中想要获取玩家对象的位置，我们会这样做：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Updating the game code
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新游戏代码
- en: With the architecture in place, and an understanding of how the `transform`
    component works, it's time to update the game code to make use of the new component.
    This will require a number of changes. For this reason, we won't be running through
    them in the chapter; it's left as a task for you!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个架构，并且了解了`transform`组件的工作原理，现在是时候更新游戏代码，以利用新的组件。这将需要一些改变。因此，我们不会在本章中详细介绍它们；这留给你来完成！
- en: 'Every object that has a position will need a `transform` component adding,
    and the places where these position variables are used will now need to be accessed
    via the component. If at any point you get stuck, refer to the previous code examples.
    If you do run through the project and make these changes yourself, make sure that
    you give the project a run once you''re done to ensure that everything is still
    running smoothly:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个具有位置的对象都需要添加一个`transform`组件，并且现在需要通过组件访问这些位置变量的地方。如果你在任何时候遇到困难，请参考之前的代码示例。如果你自己运行项目并进行这些更改，请确保在完成后运行项目，以确保一切仍然正常运行：
- en: '![Updating the game code](img/B04920_10_04.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![更新游戏代码](img/B04920_10_04.jpg)'
- en: Although things may look the same, we know that the underlying system is now
    much more flexible, maintainable, and saleable. Let's create more components!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管外表看起来可能相同，但我们知道底层系统现在更加灵活、可维护和可扩展。让我们创建更多的组件！
- en: Creating a SpriteComponent
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个SpriteComponent
- en: The next component that we're going to make is a `SpriteComponent`. This will
    provide an `object` with either a `static` or an `animated` sprite. It's a behavior
    that is commonly reused through many objects so is a great candidate to be moved
    into a component.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的是一个`SpriteComponent`。这将为`object`提供一个`static`或`animated`的精灵。这是一个经常被许多对象重复使用的行为，因此是一个很好的候选项，可以移入一个组件中。
- en: Encapsulating sprite behavior
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装精灵行为
- en: 'Currently, all the animation-related behavior is inherited from the base `Object`
    class. The following code consists of all the sprite- and animation-related functions
    and variables that we''ll pull from `Object` into its own class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有与动画相关的行为都是从基类`Object`继承的。以下代码包括了我们将从`Object`中提取出来的所有与精灵和动画相关的函数和变量，放入它自己的类中：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Currently, every object that we create has these variables and functions but
    doesn't necessarily need them which is a waste. With our `component`, we can give
    an object this behavior without worrying about inheritance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们创建的每个对象都具有这些变量和函数，但并不一定需要它们，这是一种浪费。有了我们的`component`，我们可以给一个对象赋予这种行为，而不必担心继承。
- en: Let's start by creating a new class in the project and call it `SpriteComponent`,
    ensuring that it extends the base `Component` class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从项目中创建一个新的类，并将其命名为`SpriteComponent`，确保它扩展了基类`Component`。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keeping a clean project is important. Create folders and organize your classes
    into logical groups!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 保持一个清晰的项目很重要。创建文件夹，并将你的类组织成逻辑组！
- en: 'Now, we can add all the functions and variables that we pulled out of `Object`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加所有从`Object`中提取出来的函数和变量：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've made some slight changes here regarding the `public`/`protected`/`private`
    modifiers that we use. Previously, with things being inheritance-based, a number
    of functions and variables were given the `protected` keyword, exposing them to
    child classes. Since we're moving away from inheritance, all of these have now
    been moved to `private`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对我们使用的`public`/`protected`/`private`修饰符进行了一些微小的更改。以前，由于继承关系，许多函数和变量都被赋予了`protected`关键字，暴露给子类。由于我们正在摆脱继承，所有这些现在都被移动到`private`中。
- en: 'We now just need to initialize the variables in the initializer list of the
    constructor, and add the function''s definitions in `SpriteComponenet.cpp`. Again,
    these can just be picked up from the `Object` class and moved over. Also, don''t
    forget to include the class in `Object.h`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在构造函数的初始化列表中初始化变量，并在`SpriteComponenet.cpp`中添加函数的定义。同样，这些可以直接从`Object`类中提取并移植过来。还要记得在`Object.h`中包含这个类：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With the class complete and the header included, we can now implement the component!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类完成并包含了头文件，我们现在可以实现这个组件了！
- en: Adding a sprite component to the player class
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向玩家类添加精灵组件
- en: 'Let''s continue using the player class to demonstrate, giving the class a `sprite`
    component. We decided earlier that the best place for this is within the constructor.
    So, let''s add the following code to `Player::Player` right after we create the
    `transform` component:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用玩家类来演示，给这个类添加一个`sprite`组件。我们之前决定最好的地方是在构造函数中。所以，在我们创建`transform`组件之后，让我们在`Player::Player`中添加以下代码：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The updated drawing pipeline
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新后的绘图管道
- en: 'Now that our `objects` are able to receive `sprite` components, we need to
    update the drawing pipeline so that they can be used. Currently, we loop through
    all the objects in the main game loop, drawing each in turn. However, the object
    itself isn''t responsible for drawing now, the `sprite` component is (if it has
    one, that is). In the `main draw` loop, instead of iterating over all the objects
    and calling their `Draw` function directly, we need to check whether they have
    a sprite component attached, and if they do, call the `Draw` function of the component.
    The `GetComponent` function returns a `nullprt` if no component is found making
    this easy to check:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`objects`能够接收`sprite`组件，我们需要更新绘图管道以便能够使用它们。目前，我们在主游戏循环中循环遍历所有对象，依次绘制每个对象。然而，现在对象本身不再负责绘制，`sprite`组件负责（如果有的话）。在`main
    draw`循环中，我们需要检查它们是否附加了sprite组件，如果有，就调用组件的`Draw`函数。`GetComponent`函数如果没有找到组件则返回`nullprt`，这样很容易检查：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With the drawing pipeline updated, let's quickly look at how to use the `component`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 随着绘图管道的更新，让我们快速看一下如何使用`component`。
- en: Updating the game code
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新游戏代码
- en: Here comes the big job again! On every occasion where a sprite is used, we need
    to update the code to go through the `sprite` component instead. As with the last
    component, this brings many changes to the code so is another task for you to
    complete in your own time.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 再次来了大工程！在每个使用精灵的场合，我们需要更新代码以通过`sprite`组件进行。与上一个组件一样，这会给代码带来许多变化，因此这是另一个需要您自行完成的任务。
- en: 'It''s is also suggested at the end of the chapter that you try to split this
    component into multiple types: one for `static` sprites and another for `animated`
    sprites. This will keep the code even more encapsulated and efficient as currently
    this component provides animation even if it isn''t needed.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章末尾还建议您尝试将这个组件分成多种类型：一种用于`static`精灵，另一种用于`animated`精灵。这将使代码更加封装和高效，因为当前这个组件即使不需要动画也提供了动画。
- en: If you do undertake this, hopefully nothing has imploded and you still are able
    to compile without issues. If all is well, we will see nothing new, but that's
    a good thing!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试了这个，希望没有发生什么灾难，您仍然能够编译没有问题。如果一切顺利，我们将看不到任何新东西，但这是件好事！
- en: '![Updating the game code](img/B04920_10_05.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![更新游戏代码](img/B04920_10_05.jpg)'
- en: Creating an audio component
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建音频组件
- en: The final component that we're going to create is an `audio` component. Now,
    this is the first component that we'll create from scratch. However, our experience
    with the two previous components should make this one easy to implement.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的最后一个组件是一个`audio`组件。现在，这是我们将从头开始创建的第一个组件。然而，我们之前对前两个组件的经验应该使得这个组件很容易实现。
- en: Defining the behavior of an audio component
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义音频组件的行为
- en: This is slightly different from our past components. Instead of encapsulating
    existing behavior, we need to define it. We're going to create a simple `audio`
    component, and the only behavior that we're going to have is the ability to play
    a single sound effect. For this, we'll require a single variable to hold the sound
    object, a function to set a sound buffer, and a function to play the sound.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们过去的组件略有不同。我们不是封装现有的行为，而是需要定义它。我们将创建一个简单的`audio`组件，我们唯一的行为是能够播放一个音效。为此，我们需要一个变量来保存音频对象，一个设置音频缓冲区的函数，以及一个播放音频的函数。
- en: In the function that will be used to set the sound buffer, we're going to make
    use of function overloading. If we think about how we may want to use this function,
    we might either want to pass an already created sound buffer into the component
    or pass a path to one and create it before we use it. We covered function overloading
    earlier in the chapter, and this is a textbook case of its use. We define the
    same function name and return type but varying parameter types.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在用于设置音频缓冲区的函数中，我们将使用函数重载。如果我们考虑如何使用这个函数，我们可能要么传递一个已经创建的音频缓冲区到组件中，要么传递一个路径并在使用之前创建它。我们在本章前面讨论过函数重载，这是一个典型的使用案例。我们定义相同的函数名和返回类型，但参数类型不同。
- en: 'Let''s add this new `AudioComponent` class to the project, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个新的`AudioComponent`类添加到项目中，如下所示：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Again, we''ll leave it as an exercise for you to complete this class and provide
    definitions for the functions. With the class complete let''s not forget that
    we have to include the class in the `Object.h` file so that all the objects can
    see and use it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将把这个类作为一个练习留给你来完成，并为这些函数提供定义。完成这个类之后，我们不要忘记把这个类包含在`Object.h`文件中，这样所有的对象都可以看到并使用它。
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Adding an audio component to the player class
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向玩家类添加音频组件
- en: 'The final step is to actually hook up our components to the object. We''ve
    covered doing this before and it''s simply a case of adding a call to the `AttachComponent`
    function, specifying `AudioComponent` as the type. To demonstrate this on the
    player, let''s add an audio component along with the sprite and transform components:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是实际将我们的组件连接到对象上。我们之前已经介绍过这个过程，只需要在`AttachComponent`函数中添加一个调用，指定`AudioComponent`作为类型。为了演示这一点，让我们在玩家身上添加一个音频组件，以及精灵和变换组件：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using the audio component
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用音频组件
- en: 'Using the `audio` component is very simple. We give it a sound buffer, which
    is either a pre-constructed one, or the path to a file that needs to be loaded,
    and then call the `AudioComponent::Play` function. Let''s give the player their
    own attack sound instead of it been held in the `main` game class. After we give
    the player the `audio` component, let''s set up the sound that it will use:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`音频`组件非常简单。我们给它一个声音缓冲区，这可以是一个预先构建的，也可以是需要加载的文件路径，然后调用`AudioComponent::Play`函数。让我们给玩家他们自己的攻击声音，而不是将其保存在`main`游戏类中。在给玩家添加`音频`组件之后，让我们设置它将使用的声音：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `main` class, where we detect the collision with the player, we now
    play the sound via this component instead directly:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`类中，当我们检测到与玩家的碰撞时，我们现在通过这个组件播放声音，而不是直接播放：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can see just how easy it was to add this behavior to an object, and it's
    not much work to add it to as many objects as we want! If we want to make a change,
    we just need to change the `component` class, and it affects all the child classes.
    Brilliant!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到将这个行为添加到对象中是多么容易，而且将它添加到尽可能多的对象中也不需要太多工作！如果我们想要做出改变，我们只需要改变`组件`类，它就会影响所有的子类。太棒了！
- en: Exercises
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work on. They are not imperative to the rest of the
    book, but working on them will help you assess your strengths and weaknesses in
    the material covered:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你测试本章内容的知识，这里有一些练习题供你练习。它们对于本书的其余部分并不是必须的，但是练习它们会帮助你评估你在所学内容中的优势和劣势。
- en: Move the game input from a fixed, `static` class to a component.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏输入从一个固定的`static`类移动到一个组件中。
- en: Split `SpriteComponent` into two individual components; one that provides a
    static sprite, and one that provides an animated sprite.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SpriteComponent`分成两个单独的组件；一个提供静态精灵，一个提供动画精灵。
- en: Create a `component` that encapsulates a certain behavior and use it in your
    game.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个封装特定行为的`组件`并在游戏中使用它。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we took a good look at component-based architecture, including
    the major benefits that it brings when creating procedural systems and how it
    can be achieved through the use of templates. The approach outlined in this chapter
    is just one of many possible implementations so I encourage you to experiment
    with different methods. Its plug-and-play nature makes it very flexible, which
    is an important trait that we look for when creating procedural systems.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了基于组件的架构，包括在创建过程系统时带来的主要优势，以及如何通过模板的使用来实现它。本章概述的方法只是许多可能实现之一，因此我鼓励您尝试不同的方法。它的即插即用性使其非常灵活，这是在创建过程系统时我们寻求的一个重要特征。
- en: In the next chapter, we're going to take a retrospective look at the project
    and the topics that we covered as we reach the end of the book. For each area
    of procedural generation that we've used, we'll also identify some jumping-off
    points should you wish to explore the topic in more depth.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾项目和我们所涵盖的主题，因为我们即将结束本书。对于我们使用的每个过程生成领域，我们还将确定一些跳跃点，以便您希望更深入地探索该主题。
