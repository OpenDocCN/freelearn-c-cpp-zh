- en: Chapter 2. Creating Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。创建类
- en: This chapter focuses on how to create C++ classes and structs that integrate
    well with the UE4 Blueprints editor. These classes are graduated versions of the
    regular C++ classes, and are called `UCLASS`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍如何创建与UE4蓝图编辑器良好集成的C++类和结构。这些类是常规C++类的毕业版本，称为`UCLASS`。
- en: Tip
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A `UCLASS` is just a C++ class with a whole lot of UE4 macro decoration on top.
    The macros generate additional C++ header code that enables integration with the
    UE4 Editor itself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`UCLASS`只是一个带有大量UE4宏装饰的C++类。这些宏生成额外的C++头文件代码，使其能够与UE4编辑器本身集成。'
- en: 'Using `UCLASS` is a great practice. The `UCLASS` macro, if configured correctly,
    can possibly make your `UCLASS` Blueprintable. The advantage of making your `UCLASS`
    Blueprintable is that it can enable your custom C++ objects to have Blueprints
    visually editable properties (`UPROPERTY`) with handy UI widgets such as text
    fields, sliders, and model selection boxes. You can also have functions (`UFUNCTION`)
    that are callable from within a Blueprints diagram. Both of these are shown in
    the following screenshots:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UCLASS`是一个很好的实践。如果配置正确，`UCLASS`宏可能会使你的`UCLASS`可蓝图化。使你的`UCLASS`可蓝图化的优势在于，它可以使你的自定义C++对象具有蓝图可视编辑属性（`UPROPERTY`），并带有方便的UI小部件，如文本字段、滑块和模型选择框。你还可以在蓝图图表中调用函数（`UFUNCTION`）。这两者都显示在以下截图中：
- en: '![Creating Classes](img/00052.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![创建类](img/00052.jpeg)'
- en: On the left, two `UPROPERTY` decorated class members (a `UTexture` reference
    and an `FColor`) show up for editing in a C++ class's Blueprint. On the right,
    a C++ function `GetName` marked as `BlueprintCallable` `UFUNCTION` shows up as
    callable from a Blueprints diagram.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边，两个装饰为`UPROPERTY`的类成员（一个`UTexture`引用和一个`FColor`）显示在C++类的蓝图中进行编辑。在右边，一个标记为`BlueprintCallable`的C++函数`GetName`显示为可以从蓝图图表中调用的`UFUNCTION`。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Code generated by the `UCLASS` macro will be located in a `ClassName.generated.h`
    file, which will be the last `#include` required in your `UCLASS` header file,
    `ClassName.h`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`UCLASS`宏生成的代码将位于`ClassName.generated.h`文件中，这将是你的`UCLASS`头文件`ClassName.h`中所需的最后一个`#include`。'
- en: 'The following are the topics that we will cover in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的主题：
- en: Making a `UCLASS` – deriving from `UObject`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作`UCLASS`-派生自`UObject`
- en: Creating a user-editable `UPROPERTY`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可编辑的`UPROPERTY`
- en: Accessing a `UPROPERTY` from Blueprints
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从蓝图中访问`UPROPERTY`
- en: Specifying a `UCLASS` as the type of a `UPROPERTY`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定`UCLASS`作为`UPROPERTY`的类型
- en: Creating a Blueprint from your custom `UCLASS`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从你的自定义`UCLASS`创建蓝图
- en: Instantiating `UObject`-derived classes (`ConstructObject <>` and `NewObject
    <>`)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化`UObject`派生类（`ConstructObject <>`和`NewObject <>`）
- en: Destroying `UObject`-derived classes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁`UObject`派生类
- en: Creating a `USTRUCT`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`USTRUCT`
- en: Creating a `UENUM()`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`UENUM()`
- en: Creating a `UFUNCTION`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`UFUNCTION`
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You will notice that the sample objects we create in this class, even when Blueprintable,
    will not be placed in levels. That is because in order to be placed in levels,
    your C++ class must derive from the `Actor` base class, or below it. See [Chapter
    4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121 "Chapter 4. Actors
    and Components"), *Actors and Components* for further details.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，即使我们在这个类中创建的示例对象是可蓝图化的，它们也不会被放置在关卡中。这是因为为了放置在关卡中，你的C++类必须派生自`Actor`基类，或者在其下。有关更多详细信息，请参见[第4章](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "第4章。演员和组件")，*演员和组件*。
- en: Introduction
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The UE4 code is, typically, very easy to write and manage once you know the
    patterns. The code we write to derive from another `UCLASS`, or to create a `UPROPERTY`
    or `UFUNCTION,` is very consistent. This chapter provides recipes for common UE4
    coding tasks revolving around basic `UCLASS` derivation, property and reference
    declaration, construction, destruction, and general functionality.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了模式，UE4代码通常非常容易编写和管理。我们编写的代码用于从另一个`UCLASS`派生，或者创建`UPROPERTY`或`UFUNCTION`非常一致。本章提供了围绕基本`UCLASS`派生、属性和引用声明、构造、销毁和一般功能的常见UE4编码任务的示例。
- en: Making a UCLASS – deriving from UObject
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作`UCLASS`-派生自UObject
- en: When coding with C++, you can have your own code that compiles and runs as native
    C++ code, with appropriate calls to `new` and `delete` to create and destroy your
    custom objects. Native C++ code is perfectly acceptable in your UE4 project as
    long as your `new` and `delete` calls are appropriately paired so that no leaks
    are present in your C++ code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++编码时，你可以拥有自己的代码，编译并运行为本机C++代码，适当调用`new`和`delete`来创建和销毁你的自定义对象。只要你的`new`和`delete`调用适当配对，以便在你的C++代码中没有泄漏，本机C++代码在你的UE4项目中是完全可接受的。
- en: You can, however, also declare custom C++ classes, which behave like UE4 classes,
    by declaring your custom C++ objects as `UCLASS`. `UCLASS` use UE4's Smart Pointers
    and memory management routines for allocation and deallocation according to Smart
    Pointer rules, can be loaded and read by the UE4 Editor, and can optionally be
    accessed from Blueprints.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也可以声明自定义的C++类，它们的行为类似于UE4类，通过将你的自定义C++对象声明为`UCLASS`。`UCLASS`使用UE4的智能指针和内存管理例程进行分配和释放，根据智能指针规则进行加载和读取，可以从蓝图中访问。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that when you use the `UCLASS` macro, your `UCLASS` object''s creation
    and destruction must be completely managed by UE4: you must use `ConstructObject`
    to create an instance of your object (not the C++ native keyword `new`), and call
    `UObject::ConditionalBeginDestroy()` to destroy the object (not the C++ native
    keyword `delete`). How to create and destroy your `UObject`-derivative classes
    is outlined in the *Instantiating UObject-derived classes (ConstructObject <>
    and NewObject <>)* and *Destroying UObject-derived classes* sections later in
    this chapter.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您使用`UCLASS`宏时，您的`UCLASS`对象的创建和销毁必须完全由UE4管理：您必须使用`ConstructObject`来创建对象的实例（而不是C++本机关键字`new`），并调用`UObject::ConditionalBeginDestroy()`来销毁对象（而不是C++本机关键字`delete`）。如何创建和销毁您的`UObject`派生类在本章后面的*实例化UObject派生类（ConstructObject
    <>和NewObject <>）*和*销毁UObject派生类*部分中有详细说明。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will outline how to write a C++ class that uses the `UCLASS`
    macro to enable managed memory allocation and deallocation as well as to permit
    access from the UE4 Editor and Blueprints. You need a UE4 project into which you
    can add new code to use this recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将概述如何编写一个使用`UCLASS`宏的C++类，以启用托管内存分配和释放，并允许从UE4编辑器和蓝图中访问。您需要一个UE4项目，可以在其中添加新代码以使用此配方。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create your own `UObject` derivative class, follow the steps below:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的`UObject`派生类，请按照以下步骤进行：
- en: From your running project, select **File** | **Add C++ Class** inside the UE4
    Editor.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从正在运行的项目中，在UE4编辑器中选择**文件** | **添加C++类**。
- en: In the **Add C++ Class** dialog that appears, go to the upper-right side of
    the window, and tick the **Show All Classes** checkbox:![How to do it...](img/00053.jpeg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**添加C++类**对话框中，转到窗口的右上方，选中**显示所有类**复选框：![如何做...](img/00053.jpeg)
- en: Create a `UCLASS` by choosing to derive from the `Object` parent class. `UObject`
    is the root of the UE4 hierarchy. You must tick the **Show All Classes** checkbox
    in the upper-right corner of this dialog for the `Object` class to appear in the
    list view.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择从`Object`父类派生来创建`UCLASS`。`UObject`是UE4层次结构的根。您必须选中此对话框右上角的**显示所有类**复选框，才能在列表视图中看到`Object`类。
- en: Select `Object` (top of the hierarchy) as the parent class to inherit from,
    and then click on **Next**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Object`（层次结构顶部）作为要继承的父类，然后单击**下一步**。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that although `Object` will be written in the dialog box, in your C++
    code, the C++ class you will deriving from is actually `UObject` with a leading
    uppercase `U`. This is the naming convention of UE4:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然对话框中将写入`Object`，但在您的C++代码中，您将从实际上以大写`U`开头的`UObject`派生的C++类。这是UE4的命名约定：
- en: '`UCLASS` deriving from `UObject` (on a branch other than `Actor`) must be named
    with a leading `U`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从`UObject`（不在`Actor`分支上）派生的`UCLASS`必须以`U`开头命名。
- en: '`UCLASS` deriving from `Actor` must be named with a leading `A` ([Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components*).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Actor`派生的`UCLASS`必须以`A`开头命名（[第4章](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "第4章。演员和组件")，“演员和组件”）。
- en: C++ classes (that are not `UCLASS`) deriving from nothing do not have a naming
    convention, but can be named with a leading `F` (for example, `FAssetData`), if
    preferred.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不派生自`UCLASS`的C++类（不具有命名约定），但可以以`F`开头命名（例如`FAssetData`）。
- en: Direct derivatives of `UObject` will not be level placeable, even if they contain
    visual representation elements such as `UStaticMeshes`. If you want to place your
    object inside a UE4 level, you must at least derive from the `Actor` class or
    beneath it in the inheritance hierarchy. See [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components* for how to derive
    from the `Actor` class for a level-placeable object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 直接派生自`UObject`的派生类将无法放置在级别中，即使它们包含`UStaticMeshes`等可视表示元素。如果要将对象放置在UE4级别中，您至少必须从`Actor`类或其下的继承层次结构中派生。请参阅[第4章](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "第4章。演员和组件")，“演员和组件”了解如何从`Actor`类派生可放置在级别中的对象。
- en: This chapter's example code will not be placeable in the level, but you can
    create and use Blueprints based on the C++ classes that we write in this chapter
    in the UE4 Editor.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码将无法放置在级别中，但您可以在UE4编辑器中基于本章中编写的C++类创建和使用蓝图。
- en: Name your new `Object` derivative something appropriate for the object type
    that you are creating. I call mine `UserProfile`. This comes off as `UUserObject`
    in the naming of the class in the C++ file that UE4 generates to ensure that the
    UE4 conventions are followed (C++ `UCLASS` preceded with a leading `U`).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的新的`Object`派生类命名，以适合您正在创建的对象类型。我称我的为`UserProfile`。在UE4生成的C++文件中，这将显示为`UUserObject`，以确保遵循UE4的约定（C++
    `UCLASS`前面加上`U`）。
- en: 'Go to Visual Studio, and ensure your class file has the following form:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Visual Studio，并确保您的类文件具有以下形式：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile and run your project. You can now use your custom `UCLASS` object inside
    Visual Studio, and inside the UE4 Editor. See the following recipes for more details
    on what you can do with it.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行您的项目。现在，您可以在Visual Studio和UE4编辑器中使用自定义的`UCLASS`对象。有关您可以使用它做什么的更多详细信息，请参阅以下配方。
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'UE4 generates and manages a significant amount of code for your custom `UCLASS`.
    This code is generated as a result of the use of the UE4 macros such as `UPROPERTY`,
    `UFUNCTION`, and the `UCLASS` macro itself. The generated code is put into `UserProfile.generated.h`.
    You must `#include` the `UCLASSNAME.generated.h` file with the `UCLASSNAME.h`
    file for compilation to succeed. Without including the `UCLASSNAME.generated.h`
    file, compilation would fail. The `UCLASSNAME.generated.h` file must be included
    as the last `#include` in the list of `#include` in `UCLASSNAME.h`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: UE4为你的自定义`UCLASS`生成和管理大量的代码。这些代码是由UE4宏（如`UPROPERTY`、`UFUNCTION`和`UCLASS`宏本身）的使用而生成的。生成的代码被放入`UserProfile.generated.h`中。你必须为了编译成功，将`UCLASSNAME.generated.h`文件与`UCLASSNAME.h`文件一起`#include`进来。如果不包含`UCLASSNAME.generated.h`文件，编译将失败。`UCLASSNAME.generated.h`文件必须作为`UCLASSNAME.h`中`#include`列表中的最后一个`#include`包含进来：
- en: '| Right | Wrong |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 正确 | 错误 |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The error that occurs when a `UCLASSNAME.generated.h` file is not included
    last in a list of includes is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当`UCLASSNAME.generated.h`文件不是最后一个包含在包含列表中时，会出现错误：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's more…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a bunch of keywords that we want to discuss here, which modify the
    way a `UCLASS` behaves. A `UCLASS` can be marked as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一堆关键字，我们想在这里讨论，它们修改了`UCLASS`的行为方式。`UCLASS`可以标记如下：
- en: '`Blueprintable`: This means that you want to be able to construct a Blueprint
    from the **Class Viewer** inside the UE4 Editor (when you right-click, **Create
    Blueprint Class…** becomes available). Without the `Blueprintable` keyword, the
    **Create Blueprint Class…** option will not be available for your `UCLASS`, even
    if you can find it from within the **Class Viewer** and right-click on it:![There''s
    more…](img/00054.jpeg)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blueprintable`：这意味着你希望能够在UE4编辑器内的**Class Viewer**中构建一个蓝图（右键单击时，**创建蓝图类...**变为可用）。如果没有`Blueprintable`关键字，即使你可以在**Class
    Viewer**中找到它并右键单击，**创建蓝图类...**选项也不会对你的`UCLASS`可用：![还有更多...](img/00054.jpeg)'
- en: The **Create Blueprint Class…** option is only available if you specify `Blueprintable`
    in your `UCLASS` macro definition. If you do not specify `Blueprintable`, then
    the resultant `UCLASS` will not be `Blueprintable`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当你在`UCLASS`宏定义中指定了`Blueprintable`时，**创建蓝图类...**选项才可用。如果不指定`Blueprintable`，那么生成的`UCLASS`将不可用于蓝图。
- en: '`BlueprintType`: Using this keyword implies that the `UCLASS` is usable as
    a variable from another Blueprint. You can create Blueprint variables from the
    **Variables** group in the left-hand panel of any Blueprint''s **EventGraph**.
    If `NotBlueprintType` is specified, then you cannot use this Blueprint variable
    type as a variable in a Blueprints diagram. Right-clicking the `UCLASS` name in
    the **Class Viewer** will not show **Create Blueprint Class…** in its context
    menu:![There''s more…](img/00055.jpeg)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintType`：使用这个关键字意味着`UCLASS`可以作为另一个蓝图中的变量使用。你可以在任何蓝图的**EventGraph**的左侧面板的**Variables**组中创建蓝图变量。如果指定了`NotBlueprintType`，那么你不能将这个蓝图变量类型用作蓝图图表中的变量。在**Class
    Viewer**中右键单击`UCLASS`名称将不会显示**创建蓝图类...**：![还有更多...](img/00055.jpeg)'
- en: Any `UCLASS` that have `BlueprintType` specified can be added as variables to
    your Blueprint class diagram's list of variables.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 任何指定了`BlueprintType`的`UCLASS`都可以添加为蓝图类图表的变量列表。
- en: You may be unsure whether to declare your C++ class as a `UCLASS` or not. It
    is really up to you. If you like Smart Pointers, you may find that `UCLASS` not
    only make for safer code, but also make the entire code base more coherent and
    more consistent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不确定是否将你的C++类声明为`UCLASS`。这真的取决于你。如果你喜欢智能指针，你可能会发现`UCLASS`不仅可以使代码更安全，还可以使整个代码库更连贯和更一致。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: To add additional programmable `UPROPERTY` to the Blueprints diagrams, see the
    *Creating a user-editable UPROPERTY* section below. For details on referring to
    instances of your `UCLASS` using appropriate Smart Pointers, refer to [Chapter
    3](part0043_split_000.html#190861-c0ca69a0411046888a488e5085138121 "Chapter 3. Memory
    Management and Smart Pointers"), *Memory Management and Smart Pointers*.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向蓝图图表添加可编程的`UPROPERTY`，请参阅下面的*创建可编辑的UPROPERTY*部分。有关使用适当的智能指针引用`UCLASS`实例的详细信息，请参阅[第3章](part0043_split_000.html#190861-c0ca69a0411046888a488e5085138121
    "第3章。内存管理和智能指针")，*内存管理和智能指针*。
- en: Creating a user-editable UPROPERTY
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可编辑的UPROPERTY
- en: Each `UCLASS` that you declare can have any number of `UPROPERTY` declared for
    it within it. Each `UPROPERTY` can be a visually editable field, or some Blueprints
    accessible data member of the `UCLASS`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明的每个`UCLASS`可以在其中声明任意数量的`UPROPERTY`。每个`UPROPERTY`可以是一个可视可编辑的字段，或者是`UCLASS`的蓝图可访问的数据成员。
- en: There are a number of qualifiers that we can add to each `UPROPERTY`, which
    change the way it behaves from within the UE4 Editor, such as `EditAnywhere` (screens
    from which the `UPROPERTY` can be changed), and `BlueprintReadWrite` (specifying
    that Blueprints can both read and write the variable at any time in addition to
    the C++ code being allowed to do so).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个`UPROPERTY`添加一些限定符，这些限定符会改变它在UE4编辑器中的行为，比如`EditAnywhere`（可以更改`UPROPERTY`的屏幕）和`BlueprintReadWrite`（指定蓝图可以随时读写变量，而C++代码也被允许这样做）。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use this recipe, you should have a C++ project into which you can add C++
    code. In addition, you should have completed the preceding recipe, *Making a UCLASS
    – deriving from UObject*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个方法，你应该有一个可以添加C++代码的C++项目。此外，你还应该完成前面的方法，*制作一个UCLASS - 派生自UObject*。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add members to your `UCLASS` declaration as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`UCLASS`声明中添加成员如下：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Create a Blueprint of your `UObject` class derivative, and open the Blueprint
    in the UE4 editor by double-clicking it from the object browser.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的`UObject`类派生的蓝图，并通过从对象浏览器中双击打开UE4编辑器中的蓝图。
- en: You can now specify values in Blueprints for the default values of these new
    `UPROPERTY` fields:![How to do it...](img/00056.jpeg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以在蓝图中为这些新的`UPROPERTY`字段的默认值指定值：![如何做...](img/00056.jpeg)
- en: Specify per-instance values by dragging and dropping a few instances of the
    Blueprint class into your level, and editing the values on the object placed (by
    double-clicking on them).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将蓝图类的几个实例拖放到您的级别中，并编辑放置的对象上的值（双击它们）来指定每个实例的值。
- en: How it works…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The parameters passed to the `UPROPERTY()` macro specify a couple of important
    pieces of information regarding the variable. In the preceding example, we specified
    the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`UPROPERTY()`宏的参数指定了关于变量的一些重要信息。在前面的示例中，我们指定了以下内容：
- en: '`EditAnywhere`: This means that the `UPROPERTY()` macro can be edited either
    directly from the Blueprint, or on each instance of the `UClass` object as placed
    in the game level. Contrast this with the following:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditAnywhere`：这意味着`UPROPERTY()`宏可以直接从蓝图中编辑，或者在游戏级别中放置的每个`UClass`对象的每个实例上进行编辑。与以下进行对比：'
- en: '`EditDefaultsOnly`: The Blueprint''s value is editable, but it is not editable
    on a per-instance basis'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditDefaultsOnly`：蓝图的值是可编辑的，但不能在每个实例上进行编辑'
- en: '`EditInstanceOnly`: This would allow editing of the `UPROPERTY()` macro in
    the game-level instances of the `UClass` object, and not on the base blueprint
    itself'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditInstanceOnly`：这将允许在`UClass`对象的游戏级实例中编辑`UPROPERTY()`宏，而不是在基蓝图本身上进行编辑'
- en: '`BlueprintReadWrite`: This indicates that the property is both readable and
    writeable from Blueprints diagrams. `UPROPERTY()` with `BlueprintReadWrite` must
    be public members, otherwise compilation will fail. Contrast this with the following:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintReadWrite`：这表示属性可以从蓝图图中读取和写入。带有`BlueprintReadWrite`的`UPROPERTY()`必须是公共成员，否则编译将失败。与以下进行对比：'
- en: '`BlueprintReadOnly`: The property must be set from C++ and cannot be changed
    from Blueprints'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintReadOnly`：属性必须从C++中设置，不能从蓝图中更改'
- en: '`Category`: You should always specify a `Category` for your `UPROPERTY()`.
    The `Category` determines which submenu the `UPROPERTY()` will appear under in
    the property editor. All `UPROPERTY()` specified under `Category=Stats` will appear
    in the same `Stats` area in the Blueprints editor.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类别`：您应该始终为您的`UPROPERTY()`指定一个`类别`。`类别`确定了`UPROPERTY()`将出现在属性编辑器中的哪个子菜单下。在`类别=Stats`下指定的所有`UPROPERTY()`将出现在蓝图编辑器中的相同`Stats`区域中。'
- en: See also
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A complete `UPROPERTY` listing is located at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html).
    Give it a browse.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的`UPROPERTY`列表位于[https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html)。浏览一下。
- en: Accessing a UPROPERTY from Blueprints
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从蓝图中访问UPROPERTY
- en: Accessing a `UPROPERTY` from Blueprints is fairly simple. The member must be
    exposed as a `UPROPERTY` on the member variable that you want to access from your
    Blueprints diagram. You must qualify the `UPROPERTY` in your macro declaration
    as being either `BlueprintReadOnly` or `BlueprintReadWrite` to specify whether
    you want the variable to be either readable (only) from Blueprints, or even writeable
    from Blueprints.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从蓝图中访问`UPROPERTY`非常简单。成员必须作为`UPROPERTY`公开在您的蓝图图中要访问的成员变量上。您必须在宏声明中限定`UPROPERTY`，指定它是`BlueprintReadOnly`还是`BlueprintReadWrite`，以指定您是否希望变量从蓝图中只读取（仅）或甚至可以从蓝图中写入。
- en: You can also use the special value `BlueprintDefaultsOnly` to indicate that
    you only want the default value (before the game starts) to be editable from the
    Blueprints editor. `BlueprintDefaultsOnly` indicates the data member cannot be
    edited from Blueprints at runtime.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用特殊值`BlueprintDefaultsOnly`来指示您只希望默认值（在游戏开始之前）可以从蓝图编辑器中进行编辑。`BlueprintDefaultsOnly`表示数据成员不能在运行时从蓝图中编辑。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create some `UObject`-derivative class, specifying both `Blueprintable` and
    `BlueprintType`, such as the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些`UObject`派生类，指定`Blueprintable`和`BlueprintType`，例如以下内容：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `BlueprintType` declaration in the `UCLASS` macro is required to use the
    `UCLASS` as a type within a Blueprints diagram.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UCLASS`宏中的`BlueprintType`声明是使用`UCLASS`作为蓝图图中的类型所必需的。
- en: Within the UE4 Editor, derive a Blueprint class from the C++ class, as shown
    in *Creating a Blueprint from your custom UCLASS*.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4编辑器中，从C++类派生一个蓝图类，如*从自定义UCLASS创建蓝图*中所示。
- en: Create an instance of your Blueprint-derived class in the UE4 Editor by dragging
    an instance from the **Content Browser** into the main game world area. It should
    appear as a round white sphere in the game world unless you've specified a model
    mesh for it.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将实例从**内容浏览器**拖放到主游戏世界区域中，在UE4编辑器中创建您的蓝图派生类的实例。它应该出现为游戏世界中的一个圆形白色球，除非您已为其指定了模型网格。
- en: In a Blueprints diagram which allows function calls (such as the **Level Blueprint**,
    accessible via **Blueprints** | **Open Level Blueprint**), try printing the **Name**
    property of your Warrior instance, as seen in the following screenshot:![How to
    do it...](img/00057.jpeg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在允许函数调用的蓝图图中（例如**级别蓝图**，通过**蓝图** | **打开级别蓝图**访问），尝试打印您的Warrior实例的**Name**属性，如下截图所示：![如何做到...](img/00057.jpeg)
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Navigating Blueprints diagrams is easy. Right-click and drag to pan a Blueprints
    diagram; *Alt* + Right-Click + Drag to zoom.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 导航蓝图图很容易。右键单击并拖动以平移蓝图图；*Alt* +右键单击+拖动以缩放。
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`UPROPERTY` are automatically written `Get`/`Set` methods for UE4 classes.
    They must not be declared as `private` variables within the `UCLASS`, however.
    If they are not declared as `public` or `protected` members, you will get a compiler
    error of the form:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPROPERTY`会自动为UE4类编写`Get`/`Set`方法。但是，它们不能在`UCLASS`中声明为`private`变量。如果它们没有声明为`public`或`protected`成员，您将收到形式为的编译器错误：'
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Specifying a UCLASS as the type of a UPROPERTY
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定UCLASS作为UPROPERTY的类型
- en: So, you've constructed some custom `UCLASS` intended for use inside UE4\. But
    how do you instantiate them? Objects in UE4 are reference-counted and memory-managed,
    so you should not allocate them directly using the C++ keyword `new`. Instead,
    you'll have to use a function called `ConstructObject` to instantiate your `UObject`
    derivative. `ConstructObject` doesn't just take the C++ class of the object you
    are creating, it also requires a Blueprint class derivative of the C++ class (a
    `UClass*` reference). A `UClass*` reference is just a pointer to a Blueprint.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您已经构建了一些用于在UE4中使用的自定义`UCLASS`。但是如何实例化它们呢？UE4中的对象是引用计数和内存管理的，因此您不应该直接使用C++关键字`new`来分配它们。相反，您将不得不使用一个名为`ConstructObject`的函数来实例化您的`UObject`派生类。`ConstructObject`不仅需要您创建对象的C++类，还需要一个C++类的蓝图类派生（`UClass*`引用）。`UClass*`引用只是指向蓝图的指针。
- en: How do we instantiate an instance of a particular Blueprint from C++ code? C++
    code does not, and should not, know concrete `UCLASS` names, since these names
    are created and edited in the UE4 Editor, which you can only access after compilation.
    We need a way to somehow hand back the Blueprint class name to instantiate to
    the C++ code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在C++代码中实例化特定蓝图的实例？C++代码不应该知道具体的`UCLASS`名称，因为这些名称是在UE4编辑器中创建和编辑的，您只能在编译后访问。我们需要以某种方式将蓝图类名称传递给C++代码以实例化。
- en: The way we do this is by having the UE4 programmer select the `UClass` that
    the C++ code is to use from a simple drop-down menu listing all the Blueprints
    available (derived from a particular C++ class) inside the UE4 Editor. To do this,
    we simply have to provide a user-editable `UPROPERTY` with a `TSubclassOf<C++ClassName>`-typed
    variable. Alternatively, you can use `FStringClassReference` to achieve the same
    objective.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过让UE4程序员从UE4编辑器中列出的所有可用蓝图（从特定C++类派生）的简单下拉菜单中选择C++代码要使用的`UClass`来实现这一点。为此，我们只需提供一个可编辑的`UPROPERTY`，其中包含一个`TSubclassOf<C++ClassName>`类型的变量。或者，您可以使用`FStringClassReference`来实现相同的目标。
- en: This makes selecting the `UCLASS` in the C++ code is exactly like selecting
    a texture to use. `UCLASS` should be considered as resources to the C++ code,
    and their names should never be hardcoded into the code base.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在C++代码中选择`UCLASS`就像选择要使用的纹理一样。`UCLASS`应该被视为C++代码的资源，它们的名称不应该硬编码到代码库中。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In your UE4 code, you're often going to need to refer to different `UCLASS`
    in the project. For example, say you need to know the `UCLASS` of the player object
    so that you can use `SpawnObject` in your code on it. Specifying a `UCLASS` from
    C++ code is extremely awkward, because the C++ code is not supposed to know about
    the concrete instances of the derived `UCLASS` that were created in the Blueprints
    editor at all. Just as we don't want to bake specific asset names into the C++
    code, we don't want to hardcode derived Blueprints class names into the C++ code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的UE4代码中，您经常需要引用项目中的不同`UCLASS`。例如，假设您需要知道玩家对象的`UCLASS`，以便在代码中使用`SpawnObject`。从C++代码中指定`UCLASS`非常麻烦，因为C++代码根本不应该知道在蓝图编辑器中创建的派生`UCLASS`的具体实例。就像我们不希望将特定资产名称嵌入C++代码中一样，我们也不希望将派生的蓝图类名称硬编码到C++代码中。
- en: 'So, we use a C++ variable (for example, `UClassOfPlayer`), and select that
    from a Blueprints dialog in the UE4 editor. You can do so using a `TSubclassOf`
    member or an `FStringClassReference` member, as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在UE4编辑器中使用C++变量（例如`UClassOfPlayer`），并从蓝图对话框中进行选择。您可以使用`TSubclassOf`成员或`FStringClassReference`成员来实现，如下面的屏幕截图所示：
- en: '![Getting ready](img/00058.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/00058.jpeg)'
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Navigate to the C++ class that you'd like to add the `UCLASS` reference member
    to. For example, decking out a class derivative with the `UCLASS` of the player
    is fairly easy.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您想要向其添加`UCLASS`引用成员的C++类。例如，装饰一个类派生的`UCLASS`玩家相当容易。
- en: 'From inside a `UCLASS`, use code of the following form to declare a `UPROPERTY`
    that allows selection of a `UClass` (Blueprint class) that derives from `UObject`
    in the hierarchy:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UCLASS`内部，使用以下形式的代码声明`UPROPERTY`，允许选择从层次结构中派生的`UObject`的`UClass`（蓝图类）：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Blueprint the C++ class, and then open that Blueprint. Click on the drop-down
    menu beside your `UClassOfPlayer` menu.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将C++类制作成蓝图，然后打开该蓝图。单击`UClassOfPlayer`菜单旁边的下拉菜单。
- en: Select the appropriate `UClassOfPlayer` member from the drop-down menu of the
    listed `UClass`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列出的`UClass`的下拉菜单中选择适当的`UClassOfPlayer`成员。
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: TSubclassOf
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TSubclassOf
- en: The `TSubclassOf< >` member will allow you to specify a `UClass` name using
    a drop-down menu inside the UE4 editor when editing any Blueprints that have `TSubclassOf<
    >` members.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`TSubclassOf< >`成员将允许您在UE4编辑器内编辑具有`TSubclassOf< >`成员的任何蓝图时，使用下拉菜单指定`UClass`名称。'
- en: FStringClassReference
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FStringClassReference
- en: The `MetaClass` tag refers to the base C++ class from which you expect the `UClassName`
    to derive. This limits the drop-down menu's contents to only the Blueprints derived
    from that C++ class. You can leave the `MetaClass` tag out if you wish to display
    all the Blueprints in the project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaClass`标签是指您期望`UClassName`派生自哪个基本C++类。这将限制下拉菜单的内容仅显示从该C++类派生的蓝图。如果您希望显示项目中的所有蓝图，可以省略`MetaClass`标签。'
- en: Creating a Blueprint from your custom UCLASS
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从您的自定义UCLASS创建蓝图
- en: Blueprinting is just the process of deriving a Blueprint class for your C++
    object. Creating Blueprint-derived classes from your UE4 objects allows you to
    edit the custom `UPROPERTY` visually inside the editor. This avoids hardcoding
    any resources into your C++ code. In addition, in order for your C++ class to
    be placeable within the level, it must be Blueprinted first. But this is only
    possible if the C++ class underlying the Blueprint is an `Actor` class-derivative.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 制作蓝图只是从您的C++对象派生蓝图类的过程。从您的UE4对象创建蓝图派生类允许您在编辑器中可视化编辑自定义`UPROPERTY`。这避免了将任何资源硬编码到您的C++代码中。此外，为了使您的C++类能够放置在关卡中，必须首先制作成蓝图。但是，只有在蓝图下面的C++类是`Actor`类派生类时才可能。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a way to load resources (such as textures) using `FStringAssetReferences`
    and `StaticLoadObject`. These pathways to loading resources (by hardcoding path
    strings into your C++ code) are generally discouraged, however. Providing an editable
    value in a `UPROPERTY()`, and loading from a proper concretely typed asset reference
    is a much better practice.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以使用`FStringAssetReferences`和`StaticLoadObject`来加载资源（例如纹理）。然而，通常不鼓励通过将路径字符串硬编码到您的C++代码中来加载资源。在`UPROPERTY()`中提供可编辑的值，并从正确的具体类型的资产引用中加载是一个更好的做法。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have a constructed `UCLASS` that you'd like to derive a Blueprint
    class from (see the *Making a UCLASS – deriving from UObject* section earlier
    in this chapter) in order to follow this recipe. You must have also marked your
    `UCLASS` as `Blueprintable` in the `UCLASS` macro for Blueprinting to be possible
    inside the engine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照此步骤进行操作，您需要有一个构建好的`UCLASS`，您希望从中派生一个蓝图类（请参阅本章前面的*制作UCLASS-从UObject派生*部分）。您还必须在`UCLASS`宏中将您的`UCLASS`标记为`Blueprintable`，以便在引擎内部进行蓝图制作。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Any `UObject`-derived class with the meta keyword `Blueprintable` in the `UCLASS`
    macro declaration will be `Blueprintable`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在`UCLASS`宏声明中具有`Blueprintable`元关键字的`UObject`派生类都可以制作成蓝图。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To Blueprint your `UserProfile` class, first ensure that `UCLASS` has the `Blueprintable`
    tag in the `UCLASS` macro. This should look as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将您的`UserProfile`类制作成蓝图，首先确保`UCLASS`在`UCLASS`宏中具有`Blueprintable`标记。应如下所示：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compile and run your code.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行您的代码。
- en: Find the `UserProfile` C++ class in the **Class Viewer** (**Window** | **Developer
    Tools** | **Class Viewer**). Since the previously created `UCLASS` does not derive
    from `Actor`, to find your custom `UCLASS`, you must turn off **Filters** | **Actors
    Only** in the **Class Viewer** (which is checked by default):![How to do it…](img/00059.jpeg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类查看器**中找到`UserProfile` C++类（**窗口** | **开发人员工具** | **类查看器**）。由于先前创建的`UCLASS`不是从`Actor`派生的，因此要找到您的自定义`UCLASS`，您必须在**类查看器**中关闭**筛选器**
    | **仅显示角色**（默认已选中）：![如何操作…](img/00059.jpeg)
- en: Turn off the **Actors Only** check mark to display all the classes in the **Class
    Viewer**. If you don't do this, then your custom C++ class may not show!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭**仅显示角色**复选标记，以显示**类查看器**中的所有类。如果不这样做，那么您的自定义C++类可能不会显示！
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Keep in mind that you can use the small search box inside the **Class Viewer**
    to easily find the `UserProfile` class by starting to type it in:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以使用**类查看器**中的小搜索框轻松找到`UserProfile`类，只需开始输入即可：
- en: '![How to do it…](img/00060.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/00060.jpeg)'
- en: Find your `UserProfile` class in the **Class Viewer**, right-click on it, and
    create a Blueprint from it by selecting **Create Blueprint…**
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类查看器**中找到您的`UserProfile`类，右键单击它，并通过选择**创建蓝图…**从中创建一个蓝图。
- en: Name your Blueprint. Some prefer to prefix the Blueprint class name with `BP_`.
    You may choose to follow this convention or not, just be sure to be consistent.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给您的蓝图命名。有些人喜欢在蓝图类名之前加上`BP_`。您可以选择遵循这个惯例，也可以不遵循，只要确保保持一致即可。
- en: Double-click on your new Blueprint as it appears in the **Content Browser**,
    and take a look at it. You will be able to edit the **Name** and **Email** fields
    for each `UserProfile` Blueprint instance you create.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**内容浏览器**中出现的新蓝图，看一看。您将能够为创建的每个`UserProfile`蓝图实例编辑**名称**和**电子邮件**字段。
- en: How it works…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Any C++ class you create that has the `Blueprintable` tag in its `UCLASS` macro
    can be Blueprinted within the UE4 editor. A Blueprint allows you to customize
    properties on the C++ class in the visual GUI interface of UE4.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4编辑器中，您创建的任何具有`Blueprintable`标记的C++类都可以在蓝图中使用。蓝图允许您在UE4的可视GUI界面中自定义C++类的属性。
- en: Instantiating UObject-derived classes (ConstructObject < > and NewObject < >)
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化`UObject`派生类（ConstructObject <>和NewObject <>）
- en: Creating class instances in C++ is traditionally done using the keyword `new`.
    However, UE4 actually creates instances of its classes internally, and requires
    you to call special factory functions to produce copies of any `UCLASS` that you
    want to instantiate. You produce instances of the UE4 Blueprints classes, not
    the C++ class alone. When you create `UObject`-derived classes, you will need
    to instantiate them using special UE4 Engine functions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中创建类实例通常使用关键字`new`。但是，UE4实际上在内部创建其类的实例，并要求您调用特殊的工厂函数来生成任何要实例化的`UCLASS`的副本。您创建的是UE4蓝图类的实例，而不仅仅是C++类。当您创建`UObject`派生类时，您将需要使用特殊的UE4引擎函数来实例化它们。
- en: The factory method allows UE4 to exercise some memory management on the object,
    controlling what happens to the object when it is deleted. This method allows
    UE4 to track all references to an object so that on object destruction, all references
    to the object can be easily unlinked. This ensures that no dangling pointers with
    references to invalidated memory exist in the program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法允许UE4在对象上进行一些内存管理，控制对象在删除时的行为。该方法允许UE4跟踪对象的所有引用，以便在对象销毁时轻松取消所有对对象的引用。这确保了程序中不存在指向无效内存的悬空指针。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Instantiating `UObject`-derived classes that are not `AActor` class derivatives
    does not use `UWorld::SpawnActor< >`. Instead, we have to use special global functions
    named `ConstructObject< >`, or `NewObject< >`. Note that you should not use the
    bare C++ keyword `new` to allocate new instances of your UE4 `UObject` class derivatives.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化不是`AActor`类派生类的`UObject`派生类不使用`UWorld::SpawnActor< >`。相反，我们必须使用名为`ConstructObject<
    >`或`NewObject< >`的特殊全局函数。请注意，您不应该使用裸的C++关键字`new`来分配您的UE4 `UObject`类派生的新实例。
- en: 'You will need at least two pieces of information to properly instantiate your
    `UCLASS` instance:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您至少需要两个信息来正确实例化您的`UCLASS`实例：
- en: A C++ typed `UClass` reference to the class type that you would like to instantiate
    (Blueprint class)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向您想要实例化的类类型（蓝图类）的C++类型的`UClass`引用。
- en: The original C++ base class from which the Blueprint class derives
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图类派生的原始C++基类
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In a globally accessible object (like your `GameMode` object), add a `TSubclassOf<
    YourC++ClassName > UPROPERTY()` to specify and supply the `UCLASS` name to your
    C++ code. For example, we add the following two lines to our `GameMode` object:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在全局可访问的对象（如您的`GameMode`对象）中，添加一个`TSubclassOf< YourC++ClassName > UPROPERTY()`来指定并提供`UCLASS`名称给您的C++代码。例如，我们在我们的`GameMode`对象中添加以下两行：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Enter the UE4 editor, and select your `UClass` name from the drop-down menu
    so that you can see what it does. Save, and exit the editor.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入UE4编辑器，并从下拉菜单中选择您的`UClass`名称，以便您可以看到它的作用。保存并退出编辑器。
- en: In your C++ code, find the section where you want to instantiate the `UCLASS`
    instance.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的C++代码中，找到您想要实例化`UCLASS`实例的部分。
- en: 'Instantiate the object using `ConstructObject< >` with the following formula:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下公式使用`ConstructObject< >`实例化对象：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, using the `UserProfile` object that we specified in the last recipe,
    we would get code like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用我们在上一个示例中指定的`UserProfile`对象，我们将得到如下代码：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you prefer, you can also use the `NewObject` function as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您也可以使用`NewObject`函数如下：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Instantiating a `UObject` class using `ConstructObject` or `NewObject` is simple.
    `NewObject` and `ConstructObject` do nearly the same thing: instantiate an object
    of Blueprint class type, and return a C++ pointer of the correct type.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ConstructObject`或`NewObject`实例化`UObject`类很简单。`NewObject`和`ConstructObject`几乎做同样的事情：实例化一个蓝图类类型的对象，并返回正确类型的C++指针。
- en: Unfortunately, `NewObject` has a nasty first parameter which requires you to
    pass `GetTransientPackage()` with each call. `ConstructObject` does not require
    this parameter with each call. In addition, `ConstructObject` provides you with
    more construction options.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`NewObject`有一个讨厌的第一个参数，它要求您在每次调用时传递`GetTransientPackage()`。`ConstructObject`在每次调用时不需要此参数。此外，`ConstructObject`为您提供了更多的构造选项。
- en: Do not use the keyword `new` when constructing your UE4 `UObject` derivative!
    It will not be properly memory-managed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造您的UE4 `UObject`派生类时不要使用关键字`new`！它将无法得到正确的内存管理。
- en: There's more…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`NewObject` and `ConstructObject` are what the OOP world calls factories. You
    ask the factory to make you the object—you don''t go about constructing it by
    yourself. Using a factory pattern enables the engine to easily track objects as
    they are created.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewObject`和`ConstructObject`是面向对象编程世界所谓的工厂。您要求工厂为您制造对象-您不会自己构造它。使用工厂模式使引擎能够轻松跟踪对象的创建过程。'
- en: Destroying UObject-derived classes
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁UObject派生类
- en: Removing any `UObject` derivative is simple in UE4\. When you are ready to delete
    your `UObject`-derived class, we will simply call a single function (`ConditionalBeginDestroy()`)
    on it to begin teardown. We do not use the native C++ `delete` command on `UObject`
    derivatives. We show this in the following recipe.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中删除任何`UObject`派生类都很简单。当您准备删除您的`UObject`派生类时，我们只需在其上调用一个函数（`ConditionalBeginDestroy()`）来开始拆卸。我们不使用本机C++
    `delete`命令来删除`UObject`派生类。我们将在下面的示例中展示这一点。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to call `ConditionalBeginDestroy()` on any unused `UObject`-derived
    classes so that they get removed from memory. Do not call `delete` on a `UObject`-derived
    class to recoup the system memory. You must use the internal engine-provided memory
    management functions instead. The way to do this is shown next.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在任何未使用的`UObject`派生类上调用`ConditionalBeginDestroy()`，以便将其从内存中删除。不要调用`delete`来回收系统内存中的`UObject`派生类。您必须使用内部引擎提供的内存管理函数。下面将展示如何做到这一点。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Call `objectInstance->ConditionalBeginDestroy()` on your object instance.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的对象实例上调用`objectInstance->ConditionalBeginDestroy()`。
- en: Null all your references to `objectInstance` in your client code, and do not
    use `objectInstance` again after `ConditionalBeginDestroy()` has been called on
    it.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在您的客户端代码中将所有对`objectInstance`的引用设置为null，并且在对其调用`ConditionalBeginDestroy()`之后不再使用`objectInstance`。 '
- en: How it works…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ConditionalBeginDestroy()` function begins the destruction process by removing
    all internal engine linkages to it. This marks the object for destruction as far
    as the engine is concerned. The object is then destroyed some time later by destroying
    its internal properties, followed by actual destruction of the object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConditionalBeginDestroy()`函数通过删除所有内部引擎链接来开始销毁过程。这标记了引擎认为的对象销毁。然后，对象稍后通过销毁其内部属性，随后实际销毁对象来销毁。'
- en: After `ConditionalBeginDestroy()` has been called on an object, your (client)
    code must consider the object to be destroyed, and must no longer use it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象上调用了`ConditionalBeginDestroy()`之后，您（客户端）的代码必须考虑对象已被销毁，并且不能再使用它。
- en: 'Actual memory recovery happens some time later than when `ConditionalBeginDestroy()`
    has been called on an object. There is a garbage collection routine that finishes
    clearing the memory of objects that are no longer referenced by the game program
    at fixed time intervals. The time interval between garbage collector calls is
    listed in `C:\Program Files (x86)\Epic Games\4.11\Engine\Config \BaseEngine.ini`,
    and defaults to one collection every 60 seconds:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的内存恢复发生在`ConditionalBeginDestroy()`在对象上调用后的一段时间。有一个垃圾收集例程，它在固定时间间隔内完成清除游戏程序不再引用的对象的内存。垃圾收集器调用之间的时间间隔列在`C:\Program
    Files (x86)\Epic Games\4.11\Engine\Config \BaseEngine.ini`中，默认为每60秒进行一次收集：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If memory seems low after several `ConditionalBeginDestroy()` calls, you can
    trigger memory cleanup by calling `GetWorld()->ForceGarbageCollection(true)` to
    force an internal memory cleanup.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在多次`ConditionalBeginDestroy()`调用后内存似乎不足，您可以通过调用`GetWorld()->ForceGarbageCollection(true)`来触发内存清理，以强制进行内部内存清理。
- en: Usually, you do not need to worry about garbage collection or the interval unless
    you urgently need memory cleared. Do not call garbage collection routines too
    often, as this may cause unnecessary lag in the game.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，除非您急需清除内存，否则无需担心垃圾收集或间隔。不要过于频繁地调用垃圾收集例程，因为这可能会导致游戏不必要的延迟。
- en: Creating a USTRUCT
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个USTRUCT
- en: 'You may want to construct a Blueprints editable property in UE4 that contains
    multiple members. The `FColoredTexture` struct that we will create in this chapter
    will allow you to group together a texture and its color inside the same structure
    for inclusion and specification in any other `UObject` derivative, `Blueprintable`
    class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望在UE4中构造一个蓝图可编辑的属性，其中包含多个成员。我们将在本章中创建的`FColoredTexture`结构将允许您将纹理和其颜色组合在同一结构中，以便在任何其他`UObject`衍生的`Blueprintable`类中进行包含和指定：
- en: '![Creating a USTRUCT](img/00061.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个USTRUCT](img/00061.jpeg)'
- en: The `FColoredTexture` structure does have the visual within Blueprints appearance
    as shown in the figure above.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`FColoredTexture`结构确实在蓝图中具有上述图中显示的外观。'
- en: This is for good organization and convenience of your other `UCLASS` `UPROPERTIES()`.
    You may want to construct a C++ structure in your game using the keyword `struct`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了良好的组织和方便您的其他`UCLASS``UPROPERTIES()`。您可能希望在游戏中使用关键字`struct`构造一个C++结构。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A `UObject` is the base class of all UE4 class objects, while an `FStruct` is
    just any plain old C++ style struct. All objects that use the automatic memory
    management features within the engine must derive from this class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`UObject`是所有UE4类对象的基类，而`FStruct`只是任何普通的C++风格结构。所有使用引擎内的自动内存管理功能的对象必须从此类派生。'
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you' recall from the C++ language, the only difference between a C++ class
    and a C++ struct is that C++ classes have default `private` members, while structs
    default to `public` members. In languages like C#, this isn't the case. In C#,
    a struct is value-typed, while a class is reference-typed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得C++语言，C++类和C++结构之间唯一的区别是C++类具有默认的`private`成员，而结构默认为`public`成员。在C#等语言中，情况并非如此。在C#中，结构是值类型，而类是引用类型。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll create a structure `FColoredTexture` in C++ code to contain a texture
    and a modulating color:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在C++代码中创建一个名为`FColoredTexture`的结构，其中包含一个纹理和一个调制颜色：
- en: Create a file `ColoredTexture.h` in your project folder (not `FColoredTexture`).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中创建一个名为`ColoredTexture.h`的文件（而不是`FColoredTexture`）。
- en: '`ColoredTexture.h` contains the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ColoredTexture.h`包含以下代码：'
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use `ColoredTexture.h` as a `UPROPERTY()` in some Blueprintable `UCLASS()`,
    using a `UPROPERTY()` declaration like this:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一些可蓝图化的`UCLASS()`中，使用`ColoredTexture.h`作为`UPROPERTY()`，使用如下的`UPROPERTY()`声明：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UPROPERTY()` specified for the `FColoredTexture` will show up in the editor
    as editable fields when included as `UPROPERTY()` fields inside another class,
    as shown in step 3.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为`FColoredTexture`指定的`UPROPERTY()`将显示为可编辑字段，当作为`UPROPERTY()`字段包含在另一个类中时，如步骤3所示。
- en: There's more…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The main reason for making a struct a `USTRUCT()` instead of just a plain old
    C++ struct is to interface with the UE4 Engine functionality. You can use plain
    C++ code (without creating `USTRUCT()` objects) for quick small structures that
    don't ask the engine to use them directly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将结构标记为`USTRUCT()`而不仅仅是普通的C++结构的主要原因是与UE4引擎功能进行接口。您可以使用纯C++代码（而不创建`USTRUCT()`对象）快速创建小型结构，而不要求引擎直接使用它们。
- en: Creating a UENUM( )
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个UENUM()
- en: C++ `enum` are very useful in typical C++ code. UE4 has a custom type of enumeration
    called `UENUM()`, which allows you to create an `enum` that will show up in a
    drop-down menu inside a Blueprint that you are editing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: C++的`enum`在典型的C++代码中非常有用。UE4有一种称为`UENUM()`的自定义枚举类型，它允许您创建一个将显示在正在编辑的蓝图内的下拉菜单中的`enum`。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Go to the header file that will use the `UENUM()` you are specifying, or create
    a file `EnumName.h`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到将使用您指定的`UENUM()`的头文件，或创建一个名为`EnumName.h`的文件。
- en: 'Use code of the form:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下形式的代码：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use your `UENUM()` in a `UCLASS()` as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UCLASS()`中使用您的`UENUM()`如下：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`UENUM()` show up nicely in the code editor as drop-down menus in the Blueprints
    editor from which you can only select one of a few values.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`UENUM()`在代码编辑器中显示为蓝图编辑器中的下拉菜单，您只能从中选择几个值。'
- en: Creating a UFUNCTION
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个UFUNCTION
- en: '`UFUNCTION()` are useful because they are C++ functions that can be called
    from both your C++ client code as well as Blueprints diagrams. Any C++ function
    can be marked as a `UFUNCTION()`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`UFUNCTION()`很有用，因为它们是可以从您的C++客户端代码以及蓝图图表中调用的C++函数。任何C++函数都可以标记为`UFUNCTION()`。'
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Construct a `UClass` with a member function that you''d like to expose to Blueprints.
    Decorate that member function with `UFUNCTION( BlueprintCallable, Category=SomeCategory)`
    to make it callable from Blueprints. For example, the following is the `Warrior`
    class again:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个`UClass`，其中包含您想要暴露给蓝图的成员函数。用`UFUNCTION( BlueprintCallable, Category=SomeCategory)`装饰该成员函数，以使其可以从蓝图中调用。例如，以下是再次提到的“战士”类：
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create an instance of your `Warrior` class by dragging an instance on to your
    game world.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将实例拖放到游戏世界上来创建您的“战士”类的实例。
- en: From Blueprints, call the `ToString()` function on that `Warrior` instance by
    clicking on your `Warrior` instance. Then, in a Blueprints diagram, type in `ToString()`.
    It should look like in the following screenshot:![How to do it...](img/00062.jpeg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从蓝图中，点击您的“战士”实例，调用`ToString()`函数。然后，在蓝图图表中，输入`ToString()`。它应该看起来像下面的截图：![如何做...](img/00062.jpeg)
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In order to call a function on an instance, the instance must be selected in
    the **World Outliner** when you start to type into the autocomplete menu in the
    Blueprints diagram, as shown in the following screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实例上调用函数，在蓝图图表中开始输入自动完成菜单时，实例必须在**世界大纲**中被选中，如下面的截图所示：
- en: '![How to do it...](img/00063.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00063.jpeg)'
- en: How it works…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: '`UFUNCTION()` are really C++ functions, but with additional metadata that make
    them accessible to Blueprints.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`UFUNCTION()`实际上是C++函数，但具有额外的元数据，使它们可以被蓝图访问。'
