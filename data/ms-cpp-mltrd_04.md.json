["```cpp\n#include \"dispatcher.h\"\n#include \"request.h\"\n\n#include <iostream>\n#include <string>\n#include <csignal>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\nsig_atomic_t signal_caught = 0;\nmutex logMutex; \n\n```", "```cpp\nvoid sigint_handler(int sig) {\n    signal_caught = 1;\n} \n\n```", "```cpp\nvoid logFnc(string text) {\n    logMutex.lock();\n    cout << text << \"\\n\";\n    logMutex.unlock();\n} \n\n```", "```cpp\nint main() {\n    signal(SIGINT, &sigint_handler);\n    Dispatcher::init(10); \n\n```", "```cpp\n    cout << \"Initialised.\\n\";\n        int cycles = 0;\n    Request* rq = 0;\n    while (!signal_caught && cycles < 50) {\n        rq = new Request();\n        rq->setValue(cycles);\n        rq->setOutput(&logFnc);\n        Dispatcher::addRequest(rq);\n        cycles++;\n    } \n\n```", "```cpp\n        this_thread::sleep_for(chrono::seconds(5));\n        Dispatcher::stop();\n    cout << \"Clean-up done.\\n\";\n    return 0; \n} \n\n```", "```cpp\n#pragma once\n#ifndef ABSTRACT_REQUEST_H\n#define ABSTRACT_REQUEST_H\n\nclass AbstractRequest {\n    //\n    public:\n    virtual void setValue(int value) = 0;\n    virtual void process() = 0;\n    virtual void finish() = 0;\n};\n#endif \n\n```", "```cpp\n#pragma once\n#ifndef REQUEST_H\n#define REQUEST_H\n\n#include \"abstract_request.h\"\n\n#include <string>\n\nusing namespace std;\n\ntypedef void (*logFunction)(string text);\n\nclass Request : public AbstractRequest {\n    int value;\n    logFunction outFnc;\n    public:    void setValue(int value) { this->value = value; }\n    void setOutput(logFunction fnc) { outFnc = fnc; }\n    void process();\n    void finish();\n};\n#endif \n\n```", "```cpp\n#include \"request.h\"\nvoid Request::process() {\n    outFnc(\"Starting processing request \" + std::to_string(value) + \"...\");\n    //\n}\nvoid Request::finish() {\n    outFnc(\"Finished request \" + std::to_string(value));\n} \n\n```", "```cpp\n#pragma once\n#ifndef WORKER_H\n#define WORKER_H\n\n#include \"abstract_request.h\"\n\n#include <condition_variable>\n#include <mutex>\n\nusing namespace std;\n\nclass Worker {\n    condition_variable cv;\n    mutex mtx;\n    unique_lock<mutex> ulock;\n    AbstractRequest* request;\n    bool running;\n    bool ready;\n    public:\n    Worker() { running = true; ready = false; ulock = unique_lock<mutex>(mtx); }\n    void run();\n    void stop() { running = false; }\n    void setRequest(AbstractRequest* request) { this->request = request; ready = true; }\n    void getCondition(condition_variable* &cv);\n};\n#endif \n\n```", "```cpp\n#include \"worker.h\"\n#include \"dispatcher.h\"\n\n#include <chrono>\n\nusing namespace std;\n\nvoid Worker::getCondition(condition_variable* &cv) {\n    cv = &(this)->cv;\n}\n\nvoid Worker::run() {\n    while (running) {\n        if (ready) {\n            ready = false;\n            request->process();\n            request->finish();\n        }\n        if (Dispatcher::addWorker(this)) {\n            // Use the ready loop to deal with spurious wake-ups.\n            while (!ready && running) {\n                if (cv.wait_for(ulock, chrono::seconds(1)) == cv_status::timeout) {\n                    // We timed out, but we keep waiting unless  \n                    // the worker is \n                    // stopped by the dispatcher. \n                }\n            }\n        }\n    }\n} \n\n```", "```cpp\n    #pragma once\n    #ifndef DISPATCHER_H\n    #define DISPATCHER_H\n\n    #include \"abstract_request.h\"\n    #include \"worker.h\"\n\n    #include <queue>\n    #include <mutex>\n    #include <thread>\n    #include <vector>\n\n    using namespace std;\n\n    class Dispatcher {\n        static queue<AbstractRequest*> requests;\n        static queue<Worker*> workers;\n        static mutex requestsMutex;\n        static mutex workersMutex;\n        static vector<Worker*> allWorkers;\n        static vector<thread*> threads;\n        public:\n        static bool init(int workers);\n        static bool stop();\n        static void addRequest(AbstractRequest* request);\n        static bool addWorker(Worker* worker);\n     };\n     #endif \n\n```", "```cpp\n    #include \"dispatcher.h\"\n\n    #include <iostream>\n    using namespace std;\n\n    queue<AbstractRequest*> Dispatcher::requests;\n    queue<Worker*> Dispatcher::workers;\n    mutex Dispatcher::requestsMutex;\n    mutex Dispatcher::workersMutex;\n    vector<Worker*> Dispatcher::allWorkers;\n    vector<thread*> Dispatcher::threads; \n\n    bool Dispatcher::init(int workers) {\n        thread* t = 0;\n        Worker* w = 0;\n        for (int i = 0; i < workers; ++i) {\n            w = new Worker;\n            allWorkers.push_back(w);\n            t = new thread(&Worker::run, w);\n            threads.push_back(t);\n        }\n   return true;\n } \n\n```", "```cpp\n    bool Dispatcher::stop() {\n        for (int i = 0; i < allWorkers.size(); ++i) {\n            allWorkers[i]->stop();\n        }\n            cout << \"Stopped workers.\\n\";\n            for (int j = 0; j < threads.size(); ++j) {\n            threads[j]->join();\n                    cout << \"Joined threads.\\n\";\n        }\n    }\n\n```", "```cpp\n    void Dispatcher::addRequest(AbstractRequest* request) {\n        workersMutex.lock();\n        if (!workers.empty()) {\n            Worker* worker = workers.front();\n            worker->setRequest(request);\n            condition_variable* cv;\n            worker->getCondition(cv);\n            cv->notify_one();\n            workers.pop();\n            workersMutex.unlock();\n        }\n        else {\n            workersMutex.unlock();\n            requestsMutex.lock();\n            requests.push(request);\n            requestsMutex.unlock();\n        }\n    } \n\n```", "```cpp\n    bool Dispatcher::addWorker(Worker* worker) {\n        bool wait = true;\n        requestsMutex.lock();\n        if (!requests.empty()) {\n            AbstractRequest* request = requests.front();\n            worker->setRequest(request);\n            requests.pop();\n            wait = false;\n            requestsMutex.unlock();\n        }\n        else {\n            requestsMutex.unlock();\n            workersMutex.lock();\n            workers.push(worker);\n            workersMutex.unlock();\n        }\n            return wait;\n    } \n\n```", "```cpp\n    GCC := g++\n\n    OUTPUT := dispatcher_demo\n    SOURCES := $(wildcard *.cpp)\n    CCFLAGS := -std=c++11 -g3\n\n    all: $(OUTPUT)\n        $(OUTPUT):\n        $(GCC) -o $(OUTPUT) $(CCFLAGS) $(SOURCES)\n        clean:\n        rm $(OUTPUT)\n        .PHONY: all\n\n```", "```cpp\n    $ ./dispatcher_demo.exe\n    Initialised.\n    Starting processing request 1...\n    Starting processing request 2...\n    Finished request 1\n    Starting processing request 3...\n    Finished request 3\n    Starting processing request 6...\n    Finished request 6\n    Starting processing request 8...\n    Finished request 8\n    Starting processing request 9...\n    Finished request 9\n    Finished request 2\n    Starting processing request 11...\n    Finished request 11\n    Starting processing request 12...\n    Finished request 12\n    Starting processing request 13...\n    Finished request 13\n    Starting processing request 14...\n    Finished request 14\n    Starting processing request 7...\n    Starting processing request 10...\n    Starting processing request 15...\n    Finished request 7\n    Finished request 15\n    Finished request 10\n    Starting processing request 16...\n    Finished request 16\n    Starting processing request 17...\n    Starting processing request 18...\n    Starting processing request 0...\n\n```", "```cpp\n    Starting processing request 5...\n    Finished request 5\n    Starting processing request 20...\n    Finished request 18\n    Finished request 20\n    Starting processing request 21...\n    Starting processing request 4...\n    Finished request 21\n    Finished request 4   \n\n```", "```cpp\n\n    Starting processing request 23...\n    Starting processing request 24...\n    Starting processing request 22...\n    Finished request 24\n    Finished request 23\n    Finished request 22\n    Starting processing request 26...\n    Starting processing request 25...\n    Starting processing request 28...\n    Finished request 26\n    Starting processing request 27...\n    Finished request 28\n    Finished request 27\n    Starting processing request 29...\n    Starting processing request 30...\n    Finished request 30\n    Finished request 29\n    Finished request 17\n    Finished request 25\n    Starting processing request 19...\n    Finished request 0\n\n```", "```cpp\n    Starting processing request 33...\n    Starting processing request 35...\n    Finished request 33\n    Finished request 35\n    Starting processing request 37...\n    Starting processing request 38...\n    Finished request 37\n    Finished request 38\n    Starting processing request 39...\n    Starting processing request 40...\n    Starting processing request 36...\n    Starting processing request 31...\n    Finished request 40\n    Finished request 39\n    Starting processing request 32...\n    Starting processing request 41...\n    Finished request 32\n    Finished request 41\n    Starting processing request 42...\n    Finished request 31\n    Starting processing request 44...\n    Finished request 36\n    Finished request 42\n    Starting processing request 45...\n    Finished request 44\n    Starting processing request 47...\n    Starting processing request 48...\n    Finished request 48\n    Starting processing request 43...\n    Finished request 47\n    Finished request 43\n    Finished request 19\n    Starting processing request 34...\n    Finished request 34\n    Starting processing request 46...\n    Starting processing request 49...\n    Finished request 46\n    Finished request 49\n    Finished request 45\n\n```", "```cpp\n    Stopped workers.\n    Joined threads.\n    Joined threads.\n    Joined threads.\n    Joined threads.\n    Joined threads.\n    Joined threads.\n    Joined threads.\n    Joined threads.\n    Joined threads.\n    Joined threads.\n    Clean-up done.\n\n```"]