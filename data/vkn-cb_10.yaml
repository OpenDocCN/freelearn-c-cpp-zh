- en: Helper Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助菜谱
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Preparing a translation matrix
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备平移矩阵
- en: Preparing a rotation matrix
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备旋转矩阵
- en: Preparing a scaling matrix
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备缩放矩阵
- en: Preparing a perspective projection matrix
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备透视投影矩阵
- en: Preparing an orthographic projection matrix
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备正交投影矩阵
- en: Loading texture data from a file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件加载纹理数据
- en: Loading a 3D model from an OBJ file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从OBJ文件加载3D模型
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In previous chapters, we have learned about the various aspects of the Vulkan
    API. We now know how to use the graphics library and how to create applications
    that render 3D images and perform mathematical calculations. But the sole knowledge
    about the Vulkan API may not be enough to generate more complicated scenes and
    to implement various rendering algorithms. There are several very useful operations
    that can aid us in creating, manipulating, and displaying 3D objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了Vulkan API的各个方面。我们现在知道如何使用图形库以及如何创建渲染3D图像和执行数学计算的应用程序。但是，仅了解Vulkan
    API可能不足以生成更复杂的场景和实现各种渲染算法。有几个非常有用的操作可以帮助我们创建、操作和显示3D对象。
- en: In this chapter, we will learn how to prepare transformation matrices that are
    used to move, rotate, and scale 3D meshes. We will also see how to generate projection
    matrices. Finally, we will use simple yet very powerful single-header libraries
    to load images and 3D models stored in files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何准备用于移动、旋转和缩放3D网格的变换矩阵。我们还将了解如何生成投影矩阵。最后，我们将使用简单但非常强大的单头库来加载存储在文件中的图像和3D模型。
- en: Preparing a translation matrix
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备平移矩阵
- en: Basic operations that can be performed on 3D models include moving the objects
    in a desired direction for a selected distance (number of units).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D模型上可以执行的基本操作包括将对象移动到选定的方向上，移动的距离为选定的单位数。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Prepare three variables of type `float` named `x`, `y`, and `z`, and initialize
    them with the amount of translation (movement distance) applied to the object
    along the `x` (right/left), `y` (up/down), and `z` (near/far) directions respectively.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备三个名为`x`、`y`和`z`的`float`类型变量，并将它们初始化为沿`x`（右/左）、`y`（上/下）和`z`（近/远）方向应用于对象的平移（移动距离）量。
- en: 'Create a variable of type `std::array<float, 16>` named `translation_matrix`
    that will hold a matrix representing the desired operation. Initialize elements
    of the `translation_matrix` array with the following values:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`translation_matrix`的`std::array<float, 16>`类型的变量，它将保存表示所需操作的矩阵。用以下值初始化`translation_matrix`数组的元素：
- en: All elements initialize with a `0.0f` value
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有元素都初始化为`0.0f`值
- en: 0^(th), 5^(th), 10^(th,) and 15^(th) elements (main diagonal) with a `1.0f`
    value
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0个、第5个、第10个和第15个元素（主对角线）具有`1.0f`值
- en: 12^(th) element with a value stored in the `x` variable
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在`x`变量中的第12个元素
- en: 13^(th) element with a value stored in the `y` variable
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在`y`变量中的第13个元素
- en: 14^(th) element with a value stored in the `z` variable
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在`z`变量中的第14个元素
- en: Provide values of all elements of the `translation_matrix` variable to shaders
    (possibly via a uniform buffer or a push constant) or multiply it by another matrix
    to accumulate multiple operations in one matrix.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`translation_matrix`变量的所有元素传递给着色器（可能通过统一缓冲区或推送常量），或者将其与另一个矩阵相乘以在一个矩阵中累积多个操作。
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Translation is one of three basic transformations that can be applied to an
    object (the rest are rotation and scaling). It allows us to move a 3D model in
    a desired direction for a desired distance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 平移是可应用于对象的三种基本变换之一（其余的是旋转和缩放）。它允许我们将3D模型移动到选定的方向上，移动的距离为选定的距离：
- en: '![](img/image_10_001.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_10_001.png)'
- en: Movement can also be applied to the camera, thus changing the point from which
    we observe a whole rendered scene.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 平移也可以应用于相机，从而改变我们观察整个渲染场景的视角。
- en: 'Creating a translation matrix is a simple process. We need an identity 4x4
    matrix--all its elements must be initialized with zeros (`0.0f`) except for the
    elements on the main diagonal, which must be initialized with ones (`1.0f`). Now
    we initialize the first three elements of the fourth column with the distance
    we want to apply in the `x`, `y`, and `z` axes respectively, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建平移矩阵是一个简单的过程。我们需要一个单位4x4矩阵--除了主对角线上的元素外，所有元素都必须初始化为零（`0.0f`），主对角线上的元素必须初始化为一（`1.0f`）。现在我们将第四列的前三个元素初始化为我们想要在`x`、`y`和`z`轴上应用的距离，如下所示：
- en: '![](img/image_10_002.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_10_002.png)'
- en: 'The following code creates a translation matrix:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个平移矩阵：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we assume the matrix has a `column_major` order (first
    four elements compose a first column of the matrix, next four elements compose
    a second column, and so on), so it is transposed compared to the preceding figure.
    But the order of elements of the matrix provided to the shaders depends on a `row_major`
    or `column_major` **layout qualifier** specified in the shaders' source code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们假设矩阵具有 `column_major` 顺序（前四个元素组成矩阵的第一列，接下来的四个元素组成第二列，依此类推），因此它与前面的图相比是转置的。但提供给着色器的矩阵元素的顺序取决于在着色器源代码中指定的
    `row_major` 或 `column_major` **布局限定符**。
- en: Keep in mind the order of elements of matrix defined in the shaders. It is specified
    through a `row_major` or `column_major` layout qualifier.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住在着色器中定义的矩阵元素的顺序。它通过 `row_major` 或 `column_major` 布局限定符来指定。
- en: See also
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipe:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*，参见以下配方：
- en: '*Creating a uniform buffer*'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建统一缓冲区*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*，参见以下配方：
- en: '*Writing a vertex shader that multiplies vertex position by a projection matrix*'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写乘以投影矩阵的顶点着色器*'
- en: '*Using push constants in shaders*'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在着色器中使用推送常量*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘图*，参见以下配方：
- en: '*Providing data to shaders through push constants*'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: 'The following recipes in this chapter:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Preparing a scaling matrix*'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备缩放矩阵*'
- en: '*Preparing a rotation matrix*'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备旋转矩阵*'
- en: Preparing a rotation matrix
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备旋转矩阵
- en: When we create a 3D scene and manipulate its objects, we usually need to rotate
    them in order to properly place and orient them among other objects. Rotating
    an object is achieved with a rotation matrix. For it, we need to specify a vector,
    around which rotation will be performed, and an angle--how much rotation we want
    to apply.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个3D场景并操作其对象时，我们通常需要旋转它们，以便正确地将它们放置和定位在其他对象之间。旋转对象是通过旋转矩阵实现的。为此，我们需要指定一个旋转将围绕进行的向量以及一个角度——我们想要应用多少旋转。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Prepare three variables of type `float` named `x`, `y`, and `z`. Initialize
    them with values that define an arbitrary vector, around which rotation should
    be performed. Make sure the vector is normalized (has a length equal to `1.0f`).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备三个名为 `x`、`y` 和 `z` 的 `float` 类型的变量。用定义任意向量的值初始化它们，该向量是旋转应围绕进行的。确保该向量是归一化的（长度等于
    `1.0f`）。
- en: Prepare a variable of type `float` named `angle` and store an angle of the rotation
    (in radians) in it.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `angle` 的 `float` 类型的变量，并将旋转角度（以弧度为单位）存储在其中。
- en: Create a variable of type `float` named `c`. Store a cosine of the angle in
    it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `c` 的 `float` 类型的变量。将角度的余弦值存储在其中。
- en: Create a variable of type `float` named `s`. Store a sine of the angle in it.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `s` 的 `float` 类型的变量。将角度的正弦值存储在其中。
- en: 'Create a variable of type `std::array<float, 16>` named `rotation_matrix` that
    will hold a matrix representing the desired operation. Initialize elements of
    the `rotation_matrix` array with the following values:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `rotation_matrix` 的 `std::array<float, 16>` 类型的变量，它将保存表示所需操作的矩阵。用以下值初始化
    `rotation_matrix` 数组的元素：
- en: 0^(th) element with a `x * x * (1.0f - c) + c`
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0个元素使用公式 `x * x * (1.0f - c) + c`
- en: 1^(st) element with a `y * x * (1.0f - c) - z * s`
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1个元素使用公式 `y * x * (1.0f - c) - z * s`
- en: 2^(nd) element with a `z * x * (1.0f - c) + y * s`
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2个元素使用公式 `z * x * (1.0f - c) + y * s`
- en: 4^(th) element with a `x * y * (1.0f - c) + z * s`
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4个元素使用公式 `x * y * (1.0f - c) + z * s`
- en: 5^(th) element with a `y * y * (1.0f - c) + c`
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5个元素使用公式 `y * y * (1.0f - c) + c`
- en: 6^(th) element with a `z * y * (1.0f - c) - x * s`
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6个元素使用公式 `z * y * (1.0f - c) - x * s`
- en: 8^(th) element with a `x * z * (1.0f - c) - y * s`
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第8个元素使用公式 `x * z * (1.0f - c) - y * s`
- en: 9^(th) element with a `y * z * (1.0f - c) + x * s`
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第9个元素使用公式 `y * z * (1.0f - c) + x * s`
- en: 10^(th) element with a `z * z * (1.0f - c) + c`
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第10个元素使用公式 `z * z * (1.0f - c) + c`
- en: The rest of the elements initialize with a `0.0f` value
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余元素使用 `0.0f` 值初始化
- en: Except for the 15^(th) element, which should contain a `1.0f` value
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了第15个元素应包含 `1.0f` 值外
- en: Provide values of all elements of the `rotation_matrix` variable to shaders
    (possibly via a uniform buffer or a push constant) or multiply it by another matrix
    to accumulate multiple operations in one matrix.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向着色器提供`rotation_matrix`变量所有元素的价值（可能通过统一缓冲区或推送常量）或者乘以另一个矩阵以在一个矩阵中累积多个操作。
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Preparing a matrix that represents a general rotation transformation is quite
    complicated. It can be divided into three separate matrices--representing rotations
    around each of the `x`, `y`, and `z` axis--that are later multiplied to generate
    the same result. Each such rotation is much simpler to prepare, but all in all
    it requires more operations to be performed, thus it may have a worse performance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 准备表示一般旋转变换的矩阵相当复杂。它可以分为三个独立的矩阵——分别表示围绕每个`x`、`y`和`z`轴的旋转——稍后相乘以生成相同的结果。每个这样的旋转都更容易准备，但总的来说，它需要执行更多的操作，因此可能性能较差。
- en: That's why it is better to prepare a matrix that represents a rotation around
    a selected (arbitrary) vector. For this we need to specify an angle, which defines
    the amount of rotation to apply, and a vector. This vector should be normalized,
    or the amount of the applied rotation will be scaled proportionally to the length
    of the vector.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，最好准备一个表示围绕所选（任意）向量旋转的矩阵。为此，我们需要指定一个角度，它定义了要应用的旋转量，以及一个向量。这个向量应该是归一化的，否则应用旋转的量将按比例缩放向量的长度。
- en: Vector, around which rotation is performed, should be normalized.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行旋转的向量应该被归一化。
- en: 'The following figure shows a rotation matrix. Data needed to perform rotation
    transformation is placed in the upper-left 3x3 matrix. Each column of such matrix
    defines the directions of `x`, `y`, and `z` axes respectively after the rotation
    is performed. What''s more, a transposed rotation matrix defines exactly the opposite
    transformation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了旋转矩阵。执行旋转变换所需的数据放置在上左边的3x3矩阵中。该矩阵的每一列分别定义了旋转后`x`、`y`和`z`轴的方向。更重要的是，转置的旋转矩阵定义了完全相反的变换：
- en: '![](img/image_10_003.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_003.png)'
- en: 'For example, if we want to rotate a camera to simulate that the character we
    control looks around left and right, or if we want to display a car that is turning
    left or right, we should specify a vector that points upwards (`0.0f, 1.0f, 0.0f`).
    We can also specify a vector that points downwards (`0.0f, -1.0f, 0.0f`). In this
    case, the object will be rotated for the same angle, but in the opposite direction.
    We need to choose which option is more convenient for us:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想旋转摄像机以模拟我们控制的角色左右环顾，或者如果我们想显示一辆正在左转或右转的汽车，我们应该指定一个向上指的向量(`0.0f, 1.0f,
    0.0f`)。我们也可以指定一个向下指的向量(`0.0f, -1.0f, 0.0f`)。在这种情况下，对象将以相同的角度旋转，但方向相反。我们需要选择对我们来说更方便的选项：
- en: '![](img/image_10_004.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_004.png)'
- en: 'The following is the code that creates a rotation matrix. It first checks if
    we want to normalize the vector and modifies its components accordingly. Next,
    helper variables are prepared that store temporary results. Finally, all elements
    of the rotation matrix are initialized:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为创建旋转矩阵的代码。它首先检查我们是否想要归一化向量，并相应地修改其分量。接下来，准备辅助变量以存储临时结果。最后，初始化旋转矩阵的所有元素：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to remember the order of elements in an array (application) and in the
    matrix defined in a shaders source code. Inside shaders, we control it with `row_major`
    or `column_major` layout qualifiers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住数组（应用程序）中元素和着色器源代码中定义的矩阵中元素的顺序。在着色器内部，我们通过`row_major`或`column_major`布局限定符来控制它。
- en: See also
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipe:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)的*描述符集*中，查看以下配方：
- en: '*Creating a uniform buffer*'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建统一缓冲区*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)的*着色器*中，查看以下配方：
- en: '*Writing a vertex shader that multiplies vertex position by a projection matrix*'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写乘以投影矩阵的顶点着色器*'
- en: '*Using push constants in shaders*'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在着色器中使用推送常量*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)的*命令记录和绘制*中，查看以下配方：
- en: '*Providing data to shaders through push constants*'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: 'The following recipe in this chapter:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Preparing a translation matrix*'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备平移矩阵*'
- en: '*Preparing a scaling matrix*'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备缩放矩阵*'
- en: Preparing a scaling matrix
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备缩放矩阵
- en: The third transformation that can be performed on a 3D model is scaling. This
    allows us to change an object's size.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D模型上可以执行的第三个变换是缩放。这允许我们改变对象的大小。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Prepare three variables of type `float` named `x`, `y,` and `z` that will hold
    the scaling factor applied to a model in x (width), y (height), and z (depth)
    dimensions, respectively.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备三个名为`x`、`y`和`z`的类型为`float`的变量，它们将分别存储应用于模型在x（宽度）、y（高度）和z（深度）维度上的缩放因子。
- en: 'Create a variable of type `std::array<float, 16>` named `scaling_matrix`, in
    which a matrix representing the desired operation will be stored. Initialize elements
    of the `scaling_matrix` array with the following values:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`scaling_matrix`的类型为`std::array<float, 16>`的变量，其中将存储表示所需操作的矩阵。使用以下值初始化`scaling_matrix`数组的元素：
- en: All elements initialize with a `0.0f` value
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有元素都初始化为`0.0f`值
- en: 0th element with a value stored in the `x` variable
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0个元素存储在`x`变量中的值
- en: 5^(th) element with a value stored in the `y` variable
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5个元素存储在`y`变量中的值
- en: 10^(th) element with a value stored in the `z` variable
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第10个元素存储在`z`变量中的值
- en: 15^(th) element with a `1.0f` value
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第15个元素具有`1.0f`值
- en: Provide values of all elements of the `scaling_matrix` variable to shaders (possibly
    via a uniform buffer or a push constant) or multiply it by another matrix to accumulate
    multiple operations in one matrix.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`scaling_matrix`变量的所有元素值提供给着色器（可能通过统一缓冲区或推送常量）或将其与另一个矩阵相乘以在一个矩阵中累积多个操作。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Sometimes we need to change an object''s size (compared to other objects in
    the scene). For example, due to the effect of a magical incantation, our character
    shrinks to fit into a very small hole. This transformation is achieved with a
    scaling matrix that looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要改变对象的大小（与其他场景中的对象相比）。例如，由于魔法咒语的效果，我们的角色缩小以适应一个非常小的洞。这种变换是通过以下这样的缩放矩阵实现的：
- en: '![](img/image_10_005.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_005.png)'
- en: 'Using the scaling matrix, we can resize the model differently in each dimension:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缩放矩阵，我们可以在每个维度上以不同的方式调整模型的大小：
- en: '![](img/image_10_006.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_006.png)'
- en: We must be cautious if we don't scale an object uniformly. Usually, to simplify
    the code and improve the performance, we provide a combined transformation matrix
    to a shader and use the same matrix to transform not only vertices, but also normal
    vectors. When we scale an object uniformly, we just need to normalize the normal
    vector in the shader after the transformation. But when we use a transformation
    that scales an object differently in each dimension, we cannot apply it to a normal
    vector, because lighting calculations will be incorrect (direction represented
    by the normal vector will be changed). If we really need to perform such scaling,
    we need to use an inverse transpose matrix for the normal vector transformation.
    We must prepare it separately and provide it to a shader.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不均匀地缩放对象，我们必须谨慎行事。通常，为了简化代码并提高性能，我们向着色器提供一个组合变换矩阵，并使用相同的矩阵来变换不仅顶点，还有法向量。当我们均匀缩放对象时，我们只需在变换后对着色器中的法向量进行归一化。但是，当我们使用在每个维度上以不同方式缩放对象的变换时，我们不能将其应用于法向量，因为光照计算将不正确（由法向量表示的方向将改变）。如果我们确实需要执行此类缩放，我们需要使用法向量变换的逆转置矩阵。我们必须单独准备它并将其提供给着色器。
- en: When an object is scaled differently in each dimension, a normal vector must
    be transformed by an inverse transformation matrix.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象在每个维度上以不同的方式缩放时，必须使用逆变换矩阵变换法向量。
- en: 'Preparing a scaling matrix can be performed with the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 准备缩放矩阵可以通过以下代码执行：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As with all other matrices, we need to remember about the order of elements
    defined in our application (CPU) and order of elements of the matrices defined
    in the shader source code (`column_major` versus `row_major` order).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他矩阵一样，我们需要记住在我们应用程序（CPU）中定义的元素顺序以及着色器源代码中矩阵元素的顺序（`column_major`与`row_major`顺序）。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipe:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中，查看以下食谱：
- en: '*Creating a uniform buffer*'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建统一缓冲区*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，查看以下食谱：
- en: '*Writing a vertex shader that multiplies vertex position by a projection matrix*'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写乘以投影矩阵的顶点着色器*'
- en: '*Using push constants in shaders*'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在着色器中使用推送常量*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)的*命令录制和绘图*部分，查看以下配方：
- en: '*Providing data to shaders through push constants*'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: 'The following recipes in this chapter:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Preparing a translation matrix*'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备平移矩阵*'
- en: '*Preparing a rotation matrix*'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备旋转矩阵*'
- en: Preparing a perspective projection matrix
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备透视投影矩阵
- en: 3D applications usually try to simulate the effect of how we perceive the world
    around us--objects in the distance seem smaller than the objects that are closer
    to us. To achieve this effect, we need to use a perspective projection matrix.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 3D应用程序通常试图模拟我们感知周围世界的效果——远处的物体看起来比靠近我们的物体小。为了实现这种效果，我们需要使用透视投影矩阵。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Prepare a variable of type `float` named `aspect_ratio` that will hold an aspect
    ratio of a renderable area (image's width divided by its height).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `aspect_ratio` 的 `float` 类型的变量，它将保存可渲染区域的纵横比（图像宽度除以高度）。
- en: Create a variable of type `float` named `field_of_view`. Initialize it with
    an angle (in radians) of a vertical field of view of a camera.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `field_of_view` 的 `float` 类型的变量。用相机垂直视场角（以弧度为单位）初始化它。
- en: Create a variable of type `float` named `near_plane` and initialize it with
    the distance from the camera's position to the near clipping plane.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `near_plane` 的 `float` 类型的变量，并用相机位置到近裁剪平面的距离初始化它。
- en: Create a variable of type `float` named `far_plane`. Store the distance between
    a camera and the far clipping plane in the variable.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `far_plane` 的 `float` 类型的变量。将相机与远裁剪平面之间的距离存储在该变量中。
- en: Calculate a value of `1.0f` divided by a tangent of the half of the `field_of_view`
    (`1.0f / tan(Deg2Rad(0.5f * field_of_view))`) and store the result in a variable
    of type `float` named `f`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一个值，即 `1.0f` 除以 `field_of_view` 半部的正切（`1.0f / tan(Deg2Rad(0.5f * field_of_view))`），并将结果存储在名为
    `f` 的 `float` 类型的变量中。
- en: 'Create a variable of type `std::array<float, 16>` named `perspective_projection_matrix`
    that will hold a matrix representing the desired projection. Initialize elements
    of the `perspective_projection_matrix` array with the following values:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `perspective_projection_matrix` 的 `std::array<float, 16>` 类型的变量，它将保存表示所需投影的矩阵。用以下值初始化
    `perspective_projection_matrix` 数组的元素：
- en: 0^(th) element with a `f / aspect_ratio`
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0个元素具有 `f / aspect_ratio`
- en: 5^(th) element with a `-f`
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5个元素具有 `-f`
- en: 10^(th) element with a `far_plane / (near_plane - far_plane)`
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第10个元素具有 `far_plane / (near_plane - far_plane)`
- en: 11^(th) element with a `-1.0f` value
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第11个元素具有 `-1.0f` 值
- en: 14^(th) element with a `(near_plane * far_plane) / (near_plane - far_plane)`
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第14个元素具有 `(near_plane * far_plane) / (near_plane - far_plane)`
- en: The rest of the elements initialize with a `0.0f` value
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余元素使用 `0.0f` 值初始化
- en: Provide values of all elements of the `perspective_projection_matrix` variable
    to shaders (possibly via a uniform buffer or a push constant) or multiply it by
    another matrix to accumulate multiple operations in one matrix.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向着色器提供 `perspective_projection_matrix` 变量的所有元素（可能通过统一缓冲区或推送常量）或将其乘以另一个矩阵以在一个矩阵中累积多个操作。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A graphics pipeline operates on vertex positions defined in a so-called clip
    space. Usually, we specify vertices in a local (model) coordinate system and provide
    them directly to a vertex shader. That''s why we need to transform provided vertex
    positions from their local space to a clip space in one of the vertex processing
    stages (vertex, tessellation control, tessellation evaluation, or a geometry shader).
    This transformation is performed with a projection matrix. If we want to simulate
    the effect of a perspective division, we need to use a perspective projection
    matrix and multiply it by a vertex position:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管线在所谓的裁剪空间中操作顶点位置。通常，我们在局部（模型）坐标系中指定顶点，并直接将它们提供给顶点着色器。这就是为什么我们需要在某个顶点处理阶段（顶点、细分控制、细分评估或几何着色器）中将提供的顶点位置从其局部空间转换为裁剪空间。这种转换是通过投影矩阵完成的。如果我们想模拟透视除法的效果，我们需要使用透视投影矩阵并将其乘以顶点位置：
- en: '![](img/image_10_007.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_007.png)'
- en: 'To create a perspective projection matrix, we need to know the dimensions of
    a renderable area, to calculate its aspect ratio (width divided by height). We
    also need to specify a (vertical) field of view, which we can think of as a zoom
    of a virtual camera:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个透视投影矩阵，我们需要知道可渲染区域的尺寸，以计算其纵横比（宽度除以高度）。我们还需要指定一个（垂直）视野，我们可以将其视为虚拟相机的缩放：
- en: '![](img/image_10_008.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_008.png)'
- en: One last thing required to create a perspective projection matrix are two distances
    to near and far clipping planes. As they impact the depth calculations, they should
    be specified as close to the objects on the scene as possible. If we specify a
    large value for a near plane, and a small value for a far plane, our scene will
    be (in general) clipped--we will see how objects are popping in and out of the
    scene. On the other hand, if the near distance is too small, and the distance
    to the far plane is too big, we will lose the precision of a depth buffer and
    depth calculations may be incorrect.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建透视投影矩阵所需的一个最后要素是近裁剪面和远裁剪面的两个距离。由于它们影响深度计算，它们应尽可能接近场景中的对象。如果我们为近裁剪面指定一个大的值，而远裁剪面指定一个小的值，那么我们的场景（通常）将被裁剪——我们将看到对象如何从场景中弹出和消失。另一方面，如果近距离太小，而远裁剪面的距离太大，我们将失去深度缓冲区的精度，深度计算可能是不正确的。
- en: Near and far clipping planes should correspond to the scene being displayed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 近裁剪面和远裁剪面应与显示的场景相对应。
- en: 'Using the preceding described data, we can create a perspective projection
    matrix using the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面描述的数据，我们可以使用以下代码创建一个透视投影矩阵：
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See also
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipe:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中，查看以下配方：
- en: '*Creating a uniform buffer*'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建统一缓冲区*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，查看以下配方：
- en: '*Writing a vertex shader that multiplies vertex position by a projection matrix*'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写乘以投影矩阵的顶点着色器*'
- en: '*Using push constants in shaders*'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在着色器中使用推送常量*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中，查看以下配方：
- en: '*Providing data to shaders through push constants*'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: 'The following recipe in this chapter:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Preparing an orthographic projection matrix*'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备正交投影矩阵*'
- en: Preparing an orthographic projection matrix
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备正交投影矩阵
- en: Orthographic projection is another type of operation that transforms vertices
    from their local coordinate system to a clip space. But opposed to a perspective
    projection, it doesn't take a perspective division into account (doesn't simulate
    the way we perceive our surroundings). But similarly to a perspective projection,
    it is also represented by a 4x4 matrix, which we need to create in order to use
    this type of projection.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正交投影是另一种将顶点从其局部坐标系转换到裁剪空间的操作。但与透视投影相反，它不考虑透视除法（不模拟我们感知周围环境的方式）。但与透视投影类似，它也由一个4x4矩阵表示，我们需要创建这个矩阵才能使用这种类型的投影。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create two variables of type `float` named `left_plane` and `right_plane`, and
    initialize them with the positions (on the `x` axis) of left and right clipping
    planes, respectively.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个类型为`float`的变量，分别命名为`left_plane`和`right_plane`，并将它们初始化为左裁剪面和右裁剪面在`x`轴上的位置。
- en: Prepare two variables of type `float` named `bottom_plane` and `top_plane`.
    Initialize them with positions of (on the `y` axis) of the bottom and top clipping
    planes, respectively.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备两个类型为`float`的变量，分别命名为`bottom_plane`和`top_plane`。将它们初始化为底部和顶部裁剪面在`y`轴上的位置。
- en: Create two variables of type `float` named `near_plane` and `far_plane`. Use
    them to hold distances from the camera to the near and far clipping planes, respectively.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个类型为`float`的变量，分别命名为`near_plane`和`far_plane`。使用它们来存储从相机到近裁剪面和远裁剪面的距离。
- en: 'Create a variable of type `std::array<float, 16>` named `orthographic_projection_matrix`.
    It will hold a matrix representing the desired projection. Initialize elements
    of the `orthographic_projection_matrix` array with the following values:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为`std::array<float, 16>`的变量，命名为`orthographic_projection_matrix`。它将存储表示所需投影的矩阵。使用以下值初始化`orthographic_projection_matrix`数组的元素：
- en: All elements of the matrix initialize with a `0.0f` value
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的所有元素都初始化为`0.0f`值
- en: 0^(th) element with a `2.0f / (right_plane - left_plane)`
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0个元素使用`2.0f / (right_plane - left_plane)`
- en: 5^(th) element with a `2.0f / (bottom_plane - top_plane)`
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5个元素使用`2.0f / (bottom_plane - top_plane)`
- en: 10th element with a `1.0f / (near_plane - far_plane)`
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第10个元素使用`1.0f / (near_plane - far_plane)`
- en: 12^(th) element with a `-(right_plane + left_plane) / (right_plane - left_plane)`
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第12个元素使用`-(right_plane + left_plane) / (right_plane - left_plane)`
- en: 13^(th) element with a `-(bottom_plane + top_plane) / (bottom_plane - top_plane)`
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第13个元素使用`-(bottom_plane + top_plane) / (bottom_plane - top_plane)`
- en: 14th element with a `near_plane / (near_plane - far_plane)`
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第14个元素使用`near_plane / (near_plane - far_plane)`
- en: 15^(th) element with a `1.0f` value
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第15个元素使用`1.0f`值
- en: Provide values of all elements of the `orthographic_projection_matrix` variable
    to shaders (possibly via a uniform buffer or a push constant) or multiply it by
    another matrix to accumulate multiple operations in one matrix.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向着色器提供`orthographic_projection_matrix`变量的所有元素的值（可能通过统一缓冲区或推送常量），或者将其乘以另一个矩阵以在一个矩阵中累积多个操作。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we use orthographic projection, all objects in the scene maintain their
    size and screen position no matter how far from the camera they are. That's why
    orthographic projection is very useful for drawing all kinds of **UIs** (**user
    interfaces**). We can define our virtual screen, we know all its sides (planes
    defined for the projection), and we can easily place and manipulate interface
    elements on screen. We can also use depth tests if needed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用正交投影时，场景中的所有对象无论离相机有多远都保持其大小和屏幕位置。这就是为什么正交投影对于绘制各种**UI**（**用户界面**）非常有用。我们可以定义我们的虚拟屏幕，我们知道它的所有边（为投影定义的平面），并且我们可以轻松地在屏幕上放置和操作界面元素。如果需要，我们还可以使用深度测试。
- en: Orthographic projection is also widely used in **CAD** programs (**Computer
    Aided Design**). These tools are used for designing buildings, ships, electronic
    circuits, or mechanical devices. In such situations, all sizes of all objects
    in the scene must be exactly the ones as defined by the designers and all directions
    must keep their relations (that is, all parallel lines must always stay parallel),
    no matter how far from the camera objects are and from which angle they are viewed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正交投影在**CAD**程序（**计算机辅助设计**）中也广泛使用。这些工具用于设计建筑、船舶、电子电路或机械装置。在这种情况下，场景中所有对象的尺寸都必须与设计师定义的尺寸完全一致，所有方向都必须保持其关系（即所有平行线必须始终保持平行），无论对象离相机有多远，以及从哪个角度观察。
- en: 'The following code is used to create a matrix that represents an orthographic
    projection:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于创建表示正交投影的矩阵：
- en: '[PRE4]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See also
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipe:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*部分，查看以下配方：
- en: '*Creating a uniform buffer*'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个统一缓冲区*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*部分，查看以下配方：
- en: '*Writing a vertex shader that multiplies vertex position by a projection matrix*'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写一个将顶点位置乘以投影矩阵的顶点着色器*'
- en: '*Using push constants in shaders*'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在着色器中使用推送常量*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令录制和绘制*部分，查看以下配方：
- en: '*Providing data to shaders through push constants*'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: The *Preparing a perspective projection matrix* recipe in this chapter
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*准备透视投影矩阵*配方
- en: Loading texture data from a file
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中加载纹理数据
- en: Texturing is a commonly used technique. It allows us to place an image on the
    surface of an object in a similar way to how we put wallpaper on walls. This way
    we don't need to increase the geometric complexity of a mesh, which would be both
    too complex for the hardware to process it, and would use too much memory. Texturing
    is simpler to handle and allows us to achieve better, more convincing results.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理化是一种常用的技术。它允许我们以类似我们在墙上贴壁纸的方式将图像放置在物体的表面上。这样我们就不需要增加网格的几何复杂性，这会使硬件处理变得过于复杂，并且会消耗过多的内存。纹理化更容易处理，并允许我们实现更好、更令人信服的结果。
- en: Textures can be generated procedurally (dynamically in code), but usually their
    contents are read from images or photos.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理可以通过程序（在代码中动态生成），但通常它们的内 容是从图像或照片中读取的。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are many different libraries allowing us to load contents of images. All
    of them have their own specific behaviors, usages, and licenses. In this recipe,
    we will use a `stb_image` library created by *Sean T. Barrett*. It is very simple
    to use, yet supports enough image formats to start developing a Vulkan application.
    And one of its main strengths is that it is a single header library, all its code
    is placed in just one header file. It doesn't depend on any other libraries, files,
    or resources. Another advantage is that we can use it in whatever way we want.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的库允许我们加载图像的内容。它们各自都有特定的行为、用法和许可证。在这个菜谱中，我们将使用由*Sean T. Barrett*创建的`stb_image`库。它非常易于使用，同时支持足够多的图像格式，可以开始开发Vulkan应用程序。它的主要优势之一是它是一个单头文件库，所有代码都放在一个头文件中。它不依赖于任何其他库、文件或资源。另一个优点是我们可以根据需要使用它。
- en: The `stb_image.h` file is available at [https://github.com/nothings/stb](https://github.com/nothings/stb).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`stb_image.h`文件可在[https://github.com/nothings/stb](https://github.com/nothings/stb)找到。'
- en: 'To use the `stb_image` library in our application, we need to download a `stb_image.h`
    file from [https://github.com/nothings/stb](https://github.com/nothings/stb) and
    include it in our project. This file can be included at many places in our code,
    but to create the library''s implementation in only one of the source files we
    need to include the file and precede it with a `#define STB_IMAGE_IMPLEMENTATION`
    definition like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用`stb_image`库，我们需要从[https://github.com/nothings/stb](https://github.com/nothings/stb)下载`stb_image.h`文件并将其包含在我们的项目中。此文件可以在我们的代码中的许多地方包含，但为了在单个源文件中创建库的实现，我们需要包含该文件并在其前面加上一个`#define
    STB_IMAGE_IMPLEMENTATION`定义，如下所示：
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Store the name of a file, from which the texture image should be loaded, in
    a variable of type `char const *` named `filename`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从其中加载纹理图像的文件名存储在一个名为`filename`的`char const *`类型的变量中。
- en: Create a variable of type `int` named `num_requested_components`. Initialize
    it with the desired number of components to be loaded from a file (a value from
    `1` to `4`) or with a `0` value to load all available components.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`num_requested_components`的`int`类型的变量，并使用从文件中加载所需组件数量的值（`1`到`4`之间的值）或使用`0`值来加载所有可用组件初始化它。
- en: Create three variables of type `int` named `width`, `height`, and `num_components`,
    and initialize all of them with a `0` value.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个名为`width`、`height`和`num_components`的`int`类型的变量，并将它们全部初始化为`0`值。
- en: Create a variable of type `unsigned char *` named `stbi_data`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`stbi_data`的`unsigned char *`类型的变量。
- en: Call `stbi_load( filename, &width, &height, &num_components, num_requested_components
    )` and provide the `filename` variable, pointers to the `width`, `height`, and
    `num_components` variables, and the `num_requested_components` variable. Store
    the result of the function call in the `stbi_data` variable.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`stbi_load( filename, &width, &height, &num_components, num_requested_components
    )`并提供`filename`变量、指向`width`、`height`和`num_components`变量的指针以及`num_requested_components`变量。将函数调用的结果存储在`stbi_data`变量中。
- en: Make sure the call successfully loaded the contents of the specified file by
    checking if a value stored in the `stbi_data` variable is not equal to a `nullptr`
    value and if the values stored in the `width`, `height`, and `num_components`
    variables are greater than `0`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用成功加载了指定文件的内容，通过检查存储在`stbi_data`变量中的值是否不等于`nullptr`值，以及存储在`width`、`height`和`num_components`变量中的值是否大于`0`。
- en: 'Create a variable of type `int` named `data_size` and initialize it with a
    value calculated using the following formulae:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`data_size`的`int`类型的变量，并使用以下公式计算其值初始化：
- en: '*width * height * (0 < num_requested_components ? num_requested_components
    : num_components)*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`*width * height * (0 < num_requested_components ? num_requested_components
    : num_components)*`'
- en: Create a variable of type `std::vector<unsigned char>` named `image_data`. Resize
    it to hold the `data_size` number of elements.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_data`的`std::vector<unsigned char>`类型的变量。将其大小调整为容纳`data_size`个元素。
- en: 'Copy `data_size` number of bytes from the `stbi_data` to a memory starting
    at the first element of the `image_data` vector using the following call:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下调用将`stbi_data`中的`data_size`个字节复制到从`image_data`向量的第一个元素开始的内存中：
- en: '[PRE6]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Call `stbi_image_free( stbi_data )`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`stbi_image_free( stbi_data )`。
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the `stb_image` library comes down to calling the `stbi_load()` function.
    It takes the name of a file, the selected number of components to be loaded from
    the file, and returns a pointer to the memory containing the loaded data. The
    library always converts an image's contents to 8 bits per channel. The width and
    height of the image and the real number of components available in the image are
    stored in optional variables.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stb_image`库归结为调用`stbi_load()`函数。它接受文件名，从文件中加载的选定组件数量，并返回包含加载数据的内存指针。该库总是将图像内容转换为每通道8位。图像的宽度和高度以及图像中实际可用的组件数量存储在可选变量中。
- en: 'The code loading an image is presented as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像的代码如下所示：
- en: '[PRE7]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The pointer returned by the `stbi_load()` function must be released by calling
    the `stbi_image_free()` function with a value returned by the former function
    provided as its only parameter. That''s why it is good to copy loaded data to
    our own variable (that is, a vector) or directly to one of the Vulkan resources
    (image), so there are no memory leaks. This is presented as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`stbi_load()`函数返回的指针必须通过调用`stbi_image_free()`函数并使用前一个函数返回的值作为其唯一参数来释放。这就是为什么将加载的数据复制到我们自己的变量（即向量）或直接到Vulkan资源（图像）中是好的，这样就不会有内存泄漏。这如下所示：'
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, the memory pointer returned by the `stbi_load()` function
    is released automatically, because we are storing it in a smart pointer of type
    `std::unique_ptr`. In the example, we copy the image's contents to a vector. This
    vector can be used later in our application as a source of texture data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`stbi_load()`函数返回的内存指针会自动释放，因为我们将其存储在`std::unique_ptr`类型的智能指针中。在示例中，我们将图像内容复制到一个向量中。这个向量可以在我们的应用程序中作为纹理数据的来源使用。
- en: See also
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中，查看以下配方：
- en: '*Creating an image*'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像*'
- en: '*Allocating and binding memory object to an image*'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将内存对象分配和绑定到图像*'
- en: '*Creating an image view*'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图像视图*'
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中，查看以下配方：
- en: '*Creating a sampled image*'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建采样图像*'
- en: '*Creating a combined image sampler*'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建组合图像采样器*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipe:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，查看以下配方：
- en: '*Writing a texturing vertex and fragment shaders*'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写纹理顶点和片段着色器*'
- en: Loading a 3D model from an OBJ file
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从OBJ文件加载3D模型
- en: Rendering 3D scenes requires us to draw objects, which are also called models
    or meshes. A mesh is a collection of vertices (points) with information about
    how these vertices form surfaces or faces (usually triangles).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染3D场景需要我们绘制物体，这些物体也被称为模型或网格。网格是一组顶点（点）的集合，这些顶点包含了如何形成表面或面的信息（通常是三角形）。
- en: Objects are prepared in modeling software or CAD programs. They can be stored
    in many various formats, which are later loaded in 3D applications, provided to
    graphics hardware, and then rendered. One of the simpler file types, which holds
    mesh data, is a **Wavefront OBJ**. We will learn how to load models stored in
    this format.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 物体在建模软件或CAD程序中准备。它们可以存储在许多不同的格式中，之后在3D应用程序中加载，提供给图形硬件，然后进行渲染。一种较简单的文件类型，用于存储网格数据的是**Wavefront
    OBJ**。我们将学习如何加载存储在此格式的模型。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are multiple libraries that allow us to load OBJ files (or other file
    types). One of the simpler, yet very fast and still being improved, libraries
    is a **tinyobjloader** developed by *Syoyo Fujita*. It is a single header library,
    so we don't need to include any other files or reference any other libraries.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个库允许我们加载OBJ文件（或其他文件类型）。其中之一是一个简单但非常快速且仍在改进的库，由*Syoyo Fujita*开发的**tinyobjloader**。这是一个单头库，因此我们不需要包含任何其他文件或引用任何其他库。
- en: The tinyobjloader library can be downloaded from [https://github.com/syoyo/tinyobjloader](https://github.com/syoyo/tinyobjloader).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: tinyobjloader库可以从[https://github.com/syoyo/tinyobjloader](https://github.com/syoyo/tinyobjloader)下载。
- en: 'To use the library, we need to download a `tiny_obj_loader.h` file from [https://github.com/syoyo/tinyobjloader](https://github.com/syoyo/tinyobjloader).
    We can include it at many places in our code, but to generate its implementation,
    we need to include it in one of our source files and precede the inclusion with
    a `#define TINYOBJLOADER_IMPLEMENTATION` definition like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用库，我们需要从 [https://github.com/syoyo/tinyobjloader](https://github.com/syoyo/tinyobjloader)
    下载一个 `tiny_obj_loader.h` 文件。我们可以在代码的许多地方包含它，但为了生成其实现，我们需要在源文件中包含它，并在包含之前添加一个类似于
    `#define TINYOBJLOADER_IMPLEMENTATION` 的定义：
- en: '[PRE9]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the purpose of this recipe, we will also use a custom `Mesh` type that
    will hold the loaded data in a form that can be easily used with a Vulkan API.
    This type has the following definition:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本菜谱的目的，我们还将使用一个自定义的 `Mesh` 类型，该类型将以易于与 Vulkan API 一起使用的形式存储加载的数据。此类型具有以下定义：
- en: '[PRE10]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Data` member stores vertex attributes--positions, normals, and texture
    coordinates (normal vectors and texcoords are optional). Next there is a vector
    member named `Parts`, which defines separate parts of the model. Each such part
    needs to be drawn with a separate API call (such as the `vkCmdDraw()` function).
    The model part is defined by two parameters. `VertexOffset` defines where the
    given part starts (what is its offset in an array of vertex data). `VertexCount`
    defines the number of vertices the given part is composed of.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data` 成员存储顶点属性——位置、法线和纹理坐标（法线向量和纹理坐标是可选的）。接下来是一个名为 `Parts` 的向量成员，它定义了模型的单独部分。每个这样的部分都需要通过单独的
    API 调用（如 `vkCmdDraw()` 函数）来绘制。模型部分由两个参数定义。`VertexOffset` 定义了给定部分开始的位置（在顶点数据数组中的偏移量）。`VertexCount`
    定义了给定部分由多少个顶点组成。'
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Prepare a variable of type `char const *` named `filename` and store a name
    of the file, from which model data will be loaded, in the variable.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个类型为 `char const *` 的变量名为 `filename` 并将文件名存储在该变量中，该文件将从中加载模型数据。
- en: 'Create the following variables:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下变量：
- en: Of type `tinyobj::attrib_t` named `attribs`
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为 `tinyobj::attrib_t` 的变量名为 `attribs`
- en: Of type `std::vector<tinyobj::shape_t>` named `shapes`
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为 `std::vector<tinyobj::shape_t>` 的变量名为 `shapes`
- en: Of type `std::vector<tinyobj::material_t>` named `materials`
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为 `std::vector<tinyobj::material_t>` 的变量名为 `materials`
- en: Of type `std::string` named `error`
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为 `std::string` 的变量名为 `error`
- en: Call `tinyobj::LoadObj( &attribs, &shapes, &materials, &error, filename )`,
    for which provide pointers to the `attribs`, `shapes`, `materials`, and `error`
    variables, and also the `filename` variable as the last parameter.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `tinyobj::LoadObj( &attribs, &shapes, &materials, &error, filename )`，为 `attribs`、`shapes`、`materials`
    和 `error` 变量提供指针，并将 `filename` 变量作为最后一个参数。
- en: Make sure the call successfully loaded the model data from file by checking
    if the function call returned a `true` value.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保函数调用成功从文件中加载了模型数据，通过检查函数调用是否返回了 `true` 值。
- en: Create a variable of type `Mesh` named `mesh` that will hold model data in a
    form suitable for a Vulkan API.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `Mesh` 的变量名为 `mesh`，该变量将以适合 Vulkan API 的形式存储模型数据。
- en: Create a variable of type `uint32_t` named `offset` and initialize it with a
    `0` value.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `uint32_t` 的变量名为 `offset` 并将其初始化为 `0` 值。
- en: 'Iterate over all elements of the `shapes` vector. Assuming that the current
    element is stored in a variable of type `tinyobj::shape_t` named `shape`, do the
    following operations for each element:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 `shapes` 向量的所有元素。假设当前元素存储在一个类型为 `tinyobj::shape_t` 的变量 `shape` 中，对每个元素执行以下操作：
- en: Create a variable of type `uint32_t` named `part_offset`. Initialize it with
    a value stored in the `offset` variable.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `uint32_t` 的变量名为 `part_offset`。将其初始化为存储在 `offset` 变量中的值。
- en: 'Iterate over all elements of the `shape.mesh.indices` vector, store currently
    processed elements in a variable of type `tinyobj::index_t` named `index`, and
    do the following operations for each element:'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 `shape.mesh.indices` 向量的所有元素，将当前处理的元素存储在一个类型为 `tinyobj::index_t` 的变量 `index`
    中，并对每个元素执行以下操作：
- en: Copy three elements of an `attribs.vertices` vector, available at indices equal
    to (`3 * index.vertex_index`), (`3 * index.vertex_index + 1`), and (`3 * index.vertex_index
    + 2`), as new elements of the `mesh.Data` vector
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `attribs.vertices` 向量中的三个元素（索引分别为 `3 * index.vertex_index`、`3 * index.vertex_index
    + 1` 和 `3 * index.vertex_index + 2`）复制为 `mesh.Data` 向量的新元素
- en: If normal vectors should be loaded, copy three elements of an `attribs.normals`
    vector, which are indicated by indices equal to (`3 * index.normal_index`), (`3
    * index.normal_index + 1`), and (`3 * index.normal_index + 2`), to the `mesh.Data`
    vector
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应该加载法向量，则将`attribs.normals`向量的三个元素复制到`mesh.Data`向量中，这些元素由等于(`3 * index.normal_index`)、(`3
    * index.normal_index + 1`)和(`3 * index.normal_index + 2`)的索引指示
- en: If texture coordinates should also be loaded, add two elements to the `mesh.Data`
    vector and initialize them with values stored in an `attribs.texcoords` vector
    at positions (`2 * index.texcoord_index`) and (`2 * index.texcoord_index + 1`)
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果还应加载纹理坐标，则向`mesh.Data`向量添加两个元素，并将它们初始化为存储在`attribs.texcoords`向量中的值，位置为(`2
    * index.texcoord_index`)和(`2 * index.texcoord_index + 1`)
- en: Increase the value of the `offset` variable by one
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`offset`变量的值增加一
- en: Store a calculated value of `offset - part_offset` in a variable of type `uint32_t`
    named `part_vertex_count`.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`offset - part_offset`的计算值存储在名为`part_vertex_count`的`uint32_t`类型变量中。
- en: 'If the value of the `part_vertex_count` variable is greater than zero (a `0`
    value), add a new element to the `mesh.Parts` vector. Initialize its contents
    with the following values:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`part_vertex_count`变量的值大于零（`0`值），则向`mesh.Parts`向量添加一个新元素。用以下值初始化其内容：
- en: The `part_offset` variable for `VertexOffset`
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VertexOffset`的`part_offset`变量'
- en: The `part_vertex_count` variable for `VertexCount`
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VertexCount`的`part_vertex_count`变量'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 3D models should be as small as possible to speed the loading process and lower
    the disk space required to store them. Usually, when we think about creating games,
    we should choose one of the binary formats, because most of them meet the mentioned
    requirements.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 3D模型应该尽可能小，以加快加载过程并降低存储它们所需的磁盘空间。通常，当我们考虑创建游戏时，我们应该选择二进制格式之一，因为它们中的大多数都满足上述要求。
- en: But when we start learning new APIs, it is good to choose a simpler format.
    OBJ files contain data stored in a text form, so we can easily view it or even
    modify it by ourselves. Most (if not all) commonly used modeling programs allow
    generated models to be exported to OBJ files. So it is a good format to get started
    with.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们开始学习新的API时，选择一个更简单的格式是好的。OBJ文件包含以文本形式存储的数据，因此我们可以轻松地查看它，甚至可以自行修改它。大多数（如果不是所有）常用的建模程序都允许将生成的模型导出为OBJ文件。因此，这是一个很好的入门格式。
- en: 'Here we will focus on loading only the vertex data. First we need to prepare
    storage for a model. After that we can load the model using the tinyobjloader
    library. If anything goes wrong, we check the error message and display it to
    a user:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将专注于仅加载顶点数据。首先，我们需要为模型准备存储空间。之后，我们可以使用tinyobjloader库来加载模型。如果出现任何问题，我们将检查错误信息并将其显示给用户：
- en: '[PRE11]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Theoretically, we could end our model-loading code here, but this data structure
    is not well suited for the Vulkan API. Though the normal vector and texture coordinates
    of a single vertex may be placed in separate arrays, they should be placed at
    the same index. Unfortunately, this may not be the case when it comes to an OBJ
    file format, which reuses the same values for multiple vertices. Because of that,
    we need to convert loaded data to a format that can be easily used by a graphics
    hardware:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以在这里结束我们的模型加载代码，但这个数据结构并不适合Vulkan API。尽管单个顶点的法向量和纹理坐标可能放置在单独的数组中，但它们应该放置在相同的索引位置。不幸的是，当涉及到OBJ文件格式时，它可能会重复使用多个顶点的相同值。因此，我们需要将加载的数据转换为一种可以轻松由图形硬件使用的格式：
- en: '[PRE12]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After the preceding conversion, data stored in the `Data` member of the `mesh`
    variable can be directly copied to a vertex buffer. On the other hand, `VertexOffset`
    and `VertexCount` members of each part of the model are used during drawing--we
    can provide them to a `vkCmdDraw()` function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的转换之后，存储在`mesh`变量的`Data`成员中的数据可以直接复制到顶点缓冲区。另一方面，在绘制过程中使用模型的每个部分的`VertexOffset`和`VertexCount`成员--我们可以将它们提供给`vkCmdDraw()`函数。
- en: When we create a graphics pipeline, which will be used to draw models loaded
    with the tinyobjloader library and stored in variables of a custom type `Mesh`,
    we need to specify a `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST` topology for an input
    assembly state (refer to the *Specifying pipeline input assembly state* recipe
    from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*). We also need to remember that each vertex is composed of three floating
    point values defining its position. When vertex normals are also loaded, they
    are also described by three floating point values. Texture coordinates, which
    are also optional, contain two floating point values. Each of the position, normal,
    and texcoord attributes are placed one after another for the first vertex, and
    then there are the position, normal, and texcoord attributes of the second vertex,
    and so on. The preceding information is required to properly set up vertex binding
    and attribute descriptions specified during graphics pipeline creation (refer
    to the *Specifying pipeline vertex binding description, attribute description
    and input state* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个图形管线，该管线将用于绘制使用 tinyobjloader 库加载并存储在自定义类型 `Mesh` 变量中的模型时，我们需要为输入装配状态指定一个
    `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST` 顶点拓扑（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线输入装配状态*食谱）。我们还需要记住，每个顶点由定义其位置的三个浮点值组成。当加载顶点法线时，它们也由三个浮点值描述。可选的纹理坐标包含两个浮点值。位置、法线和
    texcoord 属性依次放置在第一个顶点之后，然后是第二个顶点的位置、法线和 texcoord 属性，依此类推。上述信息是正确设置在创建图形管线期间指定的顶点绑定和属性描述所必需的（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线顶点绑定描述、属性描述和输入状态*食谱）。
- en: See also
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中，查看以下食谱：
- en: '*Creating a buffer*'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding memory object to a buffer*'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到缓冲区*'
- en: '*Using staging buffer to update a buffer with a device-local memory bound*'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新绑定设备本地内存的缓冲区*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipe:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，查看以下食谱：
- en: '*Writing vertex shaders*'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写顶点着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下食谱：
- en: '*Specifying pipeline vertex binding description, attribute description and
    input state*'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线顶点绑定描述、属性描述和输入状态*'
- en: '*Specifying pipeline input assembly state*'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线输入装配状态*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipes:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令录制和绘制*中，查看以下食谱：
- en: '*Binding vertex buffers*'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定顶点缓冲区*'
- en: '*Drawing a geometry*'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制几何体*'
