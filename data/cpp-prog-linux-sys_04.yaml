- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Diving Deep into the C++ Object
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探索 C++ 对象
- en: In this chapter, we will pay special attention to the object in the C++ language.
    But what makes the object in C++ so special that we should pay so much attention
    to it? Well, considering the fact that C++ supports the object-oriented programming
    paradigm, it is assumed that the object itself takes a central position in the
    structure of the language. You will see that there are many specifics around objects
    in C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将特别关注 C++ 语言中的对象。但是什么让 C++ 中的对象如此特别，以至于我们应该如此关注它呢？好吧，考虑到 C++ 支持面向对象编程范式，我们可以假设对象本身在语言结构中占据中心位置。你将看到围绕
    C++ 中的对象有很多具体细节。
- en: In this chapter, we will delve into the fundamental aspects of objects in C++.
    We will start by examining how the C++ standard specifies the definition of an
    object. Moving on from there, we will take a closer look at the different types
    of object initializations, such as aggregate, direct, and copy initialization,
    and their use cases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究 C++ 中对象的基本方面。我们将首先检查 C++ 标准如何指定对象的定义。在此基础上，我们将更详细地研究不同类型的对象初始化，例如聚合、直接和复制初始化，以及它们的使用场景。
- en: We will also explore the concept of storage duration for objects. Additionally,
    we will take a look at the scope and lifetime of objects in C++. We will also
    see what references are and how they correlate to objects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨对象的存储持续时间概念。此外，我们将查看 C++ 中对象的范围和生存期。我们还将了解引用是什么以及它们如何与对象相关联。
- en: As we progress further, we will learn about temporary objects and why it is
    important to handle them with care, and the concept of function objects and lambdas
    in C++. We will explore an example of how to use lambdas with a **Standard Template
    Library** (**STL**) algorithm, which will help us gain a comprehensive understanding
    of how to leverage these powerful features to create more efficient and optimized
    code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步学习，我们将了解临时对象及其为何需要小心处理的原因，以及 C++ 中函数对象和 lambda 表达式的概念。我们将探讨如何使用 lambda
    表达式与 **标准模板库**（**STL**）算法结合的示例，这将帮助我们全面理解如何利用这些强大的功能来创建更高效和优化的代码。
- en: By the end of this chapter, you will have a clear understanding of the fundamental
    concepts of objects in C++, and you will be familiar with some techniques you
    can use to create more robust and efficient code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将清楚地理解 C++ 中对象的基本概念，并且将熟悉一些你可以用来创建更健壮和高效代码的技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The C++ object model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 对象模型
- en: Scope, storage duration, and lifetimes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围、存储持续时间和生存期
- en: Functors and lambdas in C++
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 中的函数式对象和 lambda 表达式
- en: Alright, it’s time to begin!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是开始的时候了！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All examples in this chapter have been tested in an environment with the following
    configuration:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都在以下配置的环境中进行了测试：
- en: Linux Mint 21 Cinnamon edition
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux Mint 21 Cinnamon 版本
- en: GCC 12.2 with compiler flags – `-``std=c++20`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 12.2 与编译器标志 `-std=c++20`
- en: A stable internet connection
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定的互联网连接
- en: Please make sure your environment uses these versions or later. For all the
    examples you can alternatively use [https://godbolt.org/](https://godbolt.org/).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请确保你的环境使用这些版本或更高版本。对于所有示例，你也可以选择使用 [https://godbolt.org/](https://godbolt.org/)。
- en: All code examples in this chapter are available for download from [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中所有的代码示例都可以从 [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%204)
    下载。
- en: Understanding the C++ object model
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 C++ 对象模型
- en: C++ programs involve the creation, manipulation, and destruction of various
    entities known as *objects*. An object in C++ possesses several attributes such
    as *type*, *size*, *storage duration*, *lifetime*, *alignment requirements*, and
    *value*. The *name* of the object is *optional*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 程序涉及创建、操作和销毁各种称为 *对象* 的实体。C++ 中的对象具有多个属性，如 *类型*、*大小*、*存储持续时间*、*生存期*、*对齐要求*
    和 *值*。对象的 *名称* 是 *可选的*。
- en: The lifetime of the named object is bounded by its storage duration, and if
    the object doesn’t have a name, it is considered a *temporary* object. However,
    not all entities in C++ are considered objects. For example, the reference is
    one such non-object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 命名对象的生存期受其存储持续时间的限制，如果没有名称，则被视为*临时*对象。然而，C++ 中的并非所有实体都被视为对象。例如，引用就是这样一种非对象。
- en: First, let’s take a brief look at the terminology because it is important to
    be aware of it, as it will help us in our daily work with the C++ language.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们简要地了解一下术语，因为了解它们很重要，因为这将有助于我们在日常使用 C++ 语言的工作中。
- en: Declaration versus definition
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明与定义
- en: 'In C++, the terms *declaration* and *definition* are often used to refer to
    different aspects of a variable, function, or class. Here’s what each term means:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，变量、函数或类的术语*声明*和*定义*经常用来指代变量、函数或类的不同方面。以下是每个术语的含义：
- en: '**Declaration**: A declaration introduces a name into a program and specifies
    the type of the variable, function, or class, such as the following:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明**：声明将名称引入程序并指定变量的类型、函数或类，例如以下内容：'
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, `x`, `foo`, and `Point` are all *declared* but not
    defined. The `extern` keyword in the variable declaration indicates that `x` is
    defined elsewhere in the program. In declaration, no memory is allocated.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，`x`、`foo` 和 `Point` 都被*声明*但没有定义。变量声明中的 `extern` 关键字表示 `x` 在程序的另一部分被定义。在声明中，不分配内存。
- en: '**Definition**: A definition provides the actual implementation for a name
    that has been declared. It reserves memory for variables, allocates code space
    for functions, and defines the layout of classes, such as the following:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义**：定义提供了已声明的名称的实际实现。为变量保留内存，为函数分配代码空间，并定义类的布局，例如以下内容：'
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, `x`, `foo`, and `Point` are all *defined*.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，`x`、`foo` 和 `Point` 都被*定义*。
- en: So, the *declaration* introduces a name and specifies its type, while the *definition*
    provides the actual implementation and allocates memory for the object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*声明*引入了一个名称并指定了其类型，而*定义*提供了实际的实现并为对象分配内存。
- en: Now that we are familiar with the terminology, let’s dive deep into the specifics
    of the objects in C++.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了这些术语，让我们深入探讨 C++ 中对象的具体细节。
- en: Scope, storage duration, and lifetimes
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围、存储持续时间和生存期
- en: Each object or reference in a C++ program has a specific region in the program
    where it is visible and accessible, a specific lifetime, and a specific type of
    memory it occupies. Let’s take a closer look at each of them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 程序中的每个对象或引用都有一个特定的程序区域，在该区域中它是可见和可访问的，有一个特定的生存期，以及它占据的特定类型的内存。让我们更详细地看看它们中的每一个。
- en: Scope
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围
- en: 'In C++, the scope of a variable, function, or class refers to the region of
    the program where the name of the entity is visible and can be accessed without
    qualification. The scope rules determine which identifiers are visible and accessible
    in different parts of the program. The standard defines several types of scopes
    in C++. Some of them are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，变量、函数或类的作用域指的是程序中实体名称可见并可无限制访问的区域。作用域规则决定了在不同程序部分中哪些标识符是可见和可访问的。标准定义了
    C++ 中的几种作用域类型。其中一些如下：
- en: '**Global**: Variables, functions, and classes declared outside any function
    or class have global scope. They can be accessed from any part of the program,
    such as the following:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局**：在函数或类外部声明的变量、函数和类具有全局作用域。它们可以从程序的任何部分访问，例如以下内容：'
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Function**: Variables declared inside a function have function scope. They
    can be accessed only within the function where they are declared, such as the
    following:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：在函数内部声明的变量具有函数作用域。它们只能在声明它们的函数内部访问，例如以下内容：'
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`{}`), have block scope. They can be accessed only within the block where they
    are declared, or in inner blocks if there are any, such as the following:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`)，具有块作用域。它们只能在声明它们的块内部访问，或者在存在内部块的情况下，例如以下内容：'
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These are some of the scopes we use in C++. Now, let’s see what storage duration
    means in C++.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们使用的 C++ 中的一些作用域。现在，让我们看看在 C++ 中存储持续时间意味着什么。
- en: Storage duration
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储持续时间
- en: 'In C++, *storage duration* refers to the lifetime of an object, or how long
    it exists in memory. There are four types of storage duration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，*存储持续时间*指的是对象的生存期，即它在内存中存在的时间。有四种存储持续时间类型：
- en: '`static` keyword and function parameters.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 关键字和函数参数。'
- en: '`static` keyword inside a function.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数内的 `static` 关键字。
- en: '`new` operator and destroyed with the `delete` operator. They exist on the
    heap and can be accessed by multiple parts of a program.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `new` 操作符创建，并使用 `delete` 操作符销毁。它们存在于堆上，并且可以被程序的多部分访问。
- en: '**Thread-local**: These objects are created when a thread is created and destroyed
    when the thread terminates. They are like objects with static storage duration,
    but they are specific to a particular thread.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程局部**：这些对象在创建线程时创建，在线程终止时销毁。它们类似于具有静态存储期的对象，但它们特定于某个特定的线程。'
- en: 'Here is an example that illustrates the different types of storage duration:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个说明不同存储期的类型的例子：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, `global_var` has static storage duration because it is a global
    variable. `automatic_var` has automatic storage duration because it is declared
    inside the `foo` function. `static_var` also has static storage duration, but
    it retains its value between calls to `foo` because of the `static` keyword. `dynamic_var`
    itself has an automatic storage duration, but the allocated memory that it points
    to has dynamic storage duration because it is allocated with the `new` operator.
    When `foo` returns, `automatic_var` is automatically destroyed, `dynamic_var`
    is destroyed with the help of the `delete` operator, while `static_var` and `global_var`
    persist throughout a program’s lifetime.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`global_var` 具有静态存储期，因为它是一个全局变量。`automatic_var` 具有自动存储期，因为它是在 `foo` 函数内部声明的。`static_var`
    也具有静态存储期，但由于 `static` 关键字的存在，它在 `foo` 函数调用之间保留其值。`dynamic_var` 本身具有自动存储期，但它指向的分配的内存具有动态存储期，因为它是用
    `new` 操作符分配的。当 `foo` 返回时，`automatic_var` 会自动销毁，`dynamic_var` 会通过 `delete` 操作符销毁，而
    `static_var` 和 `global_var` 则在整个程序的生命周期内持续存在。
- en: Lifetime
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期
- en: The term *lifetime* refers to the duration of the existence of an object or
    a reference within a program. Every object and reference in C++ has a specific
    lifetime. The lifetime of an object begins when memory is allocated for it, and
    it is initialized. If the object’s type has a constructor, then the lifetime begins
    when the constructor is successfully completed. The lifetime of an object ends
    either when its destructor is called or, if no destructor exists, when it is destroyed.
    Thus, an object’s lifetime is equivalent to or smaller than the duration of its
    storage. Similarly, the lifetime of a reference begins when its initialization
    is completed and ends up like a scalar object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *生命周期* 指的是对象或引用在程序中存在的时间长度。在 C++ 中，每个对象和引用都有一个特定的生命周期。对象的生命周期从为其分配内存并初始化时开始。如果对象的类型具有构造函数，则生命周期从构造函数成功完成时开始。对象的生命周期在调用其析构函数时结束，如果没有析构函数，则在销毁时结束。因此，对象的生命周期等同于或小于其存储的持续时间。同样，引用的生命周期从其初始化完成时开始，最终像标量对象一样结束。
- en: The object
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: Each object is created by a definition statement that introduces, creates, and
    optionally initializes a *variable*. A variable is an *object* or a *reference*
    that is not a non-static data member, and it is introduced by a declaration (Object
    - [cppreference.com](http://cppreference.com)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都是由一个定义语句创建的，该语句引入、创建并可选地初始化一个 *变量*。变量是一个 *对象* 或 *引用*，它不是非静态数据成员，并且通过声明引入（对象
    - [cppreference.com](http://cppreference.com)）。
- en: 'Let’s define a simple variable and create an object from it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的变量并从中创建一个对象：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have defined and, at the same time, instantiated an object from an integer
    type on the stack of the `foo()` function. Each object in C++ occupies a certain
    amount of memory at a specific memory region. Being on the stack, this object
    has an automatic storage duration. In our example, it means that the object will
    be created when the function starts and will be automatically destroyed when the
    function ends. When it is instantiated, it uses some amount of memory. This amount
    is a compile-time known value, and it can be acquired with the `sizeof` operator.
    Keep in mind that the size of some types can vary depending on the underlying
    hardware where your program runs, so if you need to be sure of the size, always
    use the operator to calculate it. Such an example is the fundamental `int` type.
    The standard says that the size of the `int` type can’t be less than 16 bits.
    For Linux Mint 21 with GCC 12.2, in which the examples of this chapter are run,
    the used underlying data model is LP64\. This means that `int` is 4 bytes, and
    `long` and `pointer` are 8 bytes. In the next example, we demonstrate the size
    of the types mentioned earlier. In order to compile and run this code, you have
    to pass it in a function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个对象，并且同时从`foo()`函数的栈上实例化了一个整型对象。在C++中，每个对象在特定的内存区域中占用一定量的内存。由于它位于栈上，这个对象具有自动存储持续时间。在我们的例子中，这意味着对象将在函数开始时创建，并在函数结束时自动销毁。当它被实例化时，它会使用一些内存。这个数量是一个编译时已知的值，可以使用`sizeof`运算符来获取。请注意，某些类型的大小可能会根据程序运行的底层硬件而变化，所以如果您需要确保大小，请始终使用运算符来计算它。这样的例子是基本的`int`类型。标准规定`int`类型的大小不能小于16位。对于运行本章示例的Linux
    Mint 21和GCC 12.2，使用的底层数据模型是LP64。这意味着`int`是4字节，`long`和指针是8字节。在下一个示例中，我们将演示前面提到的类型的大小。为了编译和运行此代码，您必须将其传递到一个函数中：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the output of the example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例的输出：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Nothing surprising so far. `int` is 4 bytes, but the pointer, no matter which
    type it points to, is 8 bytes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么令人惊讶的。`int`类型是4字节，但指针，无论它指向哪种类型，都是8字节。
- en: 'Now, let’s define several structures and check their memory footprint:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义几个结构并检查它们的内存占用：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have defined three structures – `Empty`, `Padding`, and `Virt`. The `Empty`
    structure, as the name suggests, is just an empty structure without any members
    in it. The `Padding` structure contains two members – `long` and `char`. As we
    saw from the previous example, in my testing environment, `long` is 8 bytes and
    `char` is 1 byte. Finally, the `Virt` structure has only one member of type `char`
    and one virtual method. Structure and class methods are not part of the object
    itself. They reside in the text segment rather than in the memory occupied by
    the object. Let’s execute the earlier code and see the result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个结构——`Empty`、`Padding`和`Virt`。正如其名所示，`Empty`结构只是一个没有任何成员的空结构。`Padding`结构包含两个成员——`long`和`char`。正如我们从上一个示例中看到的，在我的测试环境中，`long`是8字节，`char`是1字节。最后，`Virt`结构只有一个`char`类型的成员和一个虚方法。结构和类方法不是对象本身的一部分。它们位于文本段而不是对象占用的内存中。让我们执行前面的代码并查看结果：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that all the objects occupy memory. Even the empty one! This is guaranteed
    by the standard because any object in the system has to have an address on which
    it resides. If it doesn’t occupy any memory, then no address can be assigned to
    it. Therefore, at least 1 byte is reserved for every object in the program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有对象都占用内存。即使是空的！这是由标准保证的，因为系统中的任何对象都必须有一个地址，它位于该地址上。如果没有占用任何内存，则无法为其分配地址。因此，程序中的每个对象至少保留1字节。
- en: The `Padding` structure occupies more memory than the sum of its members’ memory.
    This is because the compilers are free to place the objects on an address, which
    requires less instruction arithmetic in order to be accessed faster. Therefore,
    they add padding bytes to the size of the type if this is required.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Padding`结构占用的内存比其成员内存总和还要多。这是因为编译器可以自由地将对象放置在地址上，这样可以减少指令运算，以便更快地访问。因此，如果需要，它们会在类型的大小上添加填充字节。'
- en: Finally, the `Virt` structure contains only one member, which has type `char`.
    However, the structure occupies the same amount of memory as the `Padding` structure.
    This is a result of how the mechanics of the polymorphism are implemented in C++.
    The structure contains a virtual method that notifies the compiler that this user-defined
    type will be used polymorphically. As a result, the compiler injects in every
    instantiated object from this type a pointer to a table, with the addresses of
    all the virtual methods of the class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Virt` 结构体只包含一个成员，其类型为 `char`。然而，这个结构体占用的内存量与 `Padding` 结构体相同。这是由于 C++ 中实现多态机制的方式所导致的。该结构体包含一个虚拟方法，它通知编译器这个用户定义的类型将被多态地使用。因此，编译器在从该类型实例化的每个对象中注入一个指向表的指针，其中包含类中所有虚拟方法的地址。
- en: As a result of all these examples, we can conclude that each object occupies
    memory once it is instantiated, and the size of the memory can vary depending
    on the underlying system and the definition of the type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些示例，我们可以得出结论：一旦对象被实例化，它就会占用内存，而内存的大小可能取决于底层系统和类型的定义。
- en: Next, we will get familiar with references in C++ and how they differ from objects
    in the language.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将熟悉 C++ 中的引用以及它们与语言中的对象有何不同。
- en: The reference
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用
- en: 'In the previous section, we found out that we can declare a variable not only
    from an object but also from a reference. But what is a *reference* in terms of
    C++? According to the standard, a reference variable is an *alias* to an already-existing
    object or function. This means that we can use aliases to work with objects without
    having a difference in the syntax, rather than working with pointers to objects
    where the syntax is quite different. Let’s have a look in the following example.
    In order to compile and run it, you need to invoke it from a function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们发现我们可以从对象声明一个变量，也可以从引用声明。但就 C++ 而言，*引用* 是什么？根据标准，引用变量是已存在对象或函数的*别名*。这意味着我们可以使用别名来处理对象，而不需要在语法上有差异，而不是处理对象的指针，其语法相当不同。让我们看一下以下示例。为了编译和运行它，你需要从函数中调用它：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we declare three variables – a character, a reference to a
    character, and a pointer to a character. An important detail when working with
    reference variables is that at the point of its declaration, we must also initialize
    it with the object it will refer to. From this moment on, every operation invoked
    on the reference variable is actually invoked on the aliased object. But what
    indeed is an alias? Does it occupy memory just like the pointer does? Well, this
    is a gray area. The standard says that the references, unlike objects, do not
    always occupy storage. However, the compiler may allocate storage if required
    to implement the intended semantics. As a result of this, you *can’t use* the
    `sizeof` operator to get the size of a reference:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明了三个变量——一个字符、一个字符的引用和一个字符的指针。在处理引用变量时，一个重要的细节是在其声明点，我们必须用它将引用到的对象初始化。从这一刻起，对引用变量的每个操作实际上都是在别名对象上执行的。但别名究竟是什么？它是否像指针一样占用内存？嗯，这是一个灰色地带。标准指出，与对象不同，引用并不总是占用存储。然而，如果需要实现预期的语义，编译器可能会分配存储。因此，你*不能使用*
    `sizeof` 运算符来获取引用的大小：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see that the pointer size matches the expectation rather than the size
    of the reference type, where it matches the size of the type to which it has an
    alias.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，指针的大小与预期相符，而不是引用类型的大小，它与其别名类型的大小相匹配。
- en: Understanding why initialization matters
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解初始化的重要性
- en: '*Initialization* is the process of setting the initial value of an object during
    its construction. In C++, there are several types of initializations depending
    mostly on the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*初始化* 是在对象构造期间设置其初始值的过程。在 C++ 中，根据以下内容，存在多种初始化类型：'
- en: The storage duration which the object belongs to
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象所属的存储持续时间
- en: The definition of the object
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的定义
- en: Knowing the different types of initializations and exactly when they happen
    will certainly make you more confident in writing predictable code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 了解不同类型的初始化以及它们确切发生的时间，无疑会增强你在编写可预测代码时的信心。
- en: Let’s look at a few examples of various types of initializations that the C++
    language supports. This will make it clearer when initialization occurs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 C++ 语言支持的几种不同类型的初始化的例子。这将使初始化发生的时间更加清晰。
- en: Default initialization
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认初始化
- en: 'In the next example, you can see a *default initialization*. In order to run
    and test this code, you have to invoke the `foo()` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，你可以看到一个 *默认初始化*。为了运行和测试这段代码，你必须调用 `foo()` 方法：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In marker `{1}`, we have declared a stack variable from type `long`. The type
    of initialization that will apply on an object depends mainly on the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记 `{1}` 中，我们声明了一个 `long` 类型的栈变量。对象将应用哪种初始化类型主要取决于以下因素：
- en: '**The storage duration it occupies**: This means that different initialization
    policies may apply, depending on whether the object lives on the stack, in the
    global space, and so on'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它占用的存储持续时间**：这意味着不同的初始化策略可能适用，这取决于对象是位于栈上、全局空间中等。'
- en: '`init` value, how exactly we have passed that `init` value, and so on'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` 值，我们是如何传递那个 `init` 值的，等等。'
- en: The `long a;` variable in our example has automatic storage duration, meaning
    it lives on the function’s stack. In its declaration, we haven’t specified any
    initialization value. For such objects, we will apply *default initialization*.
    When an object is default-initialized, the C++ compiler will generate code that
    calls the default constructor of the object’s type if one exists. However, since
    `long` is a fundamental C++ type that lacks a default constructor, the C++ runtime
    *does not perform any initialization on it*, resulting in an *unpredictable value*.
    This means that the value that will be used for initialization is not specified
    and could be literally any. This is also the case with the `Point p1;` object,
    which is a user-defined type, but we did not specify a default constructor for
    it. The `Point` structure is a so-called **Plain Old Data** (**POD**) type because
    it is fully compatible with the structures from the C language. For such types,
    the compiler will generate a *trivial default constructor* for you, which effectively
    does nothing when called.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`long a;` 变量具有自动存储持续时间，这意味着它位于函数的栈上。在其声明中，我们没有指定任何初始化值。对于这样的对象，我们将应用
    *默认初始化*。当一个对象被默认初始化时，C++ 编译器将生成调用对象类型默认构造函数的代码（如果存在）。然而，由于 `long` 是一个缺乏默认构造函数的基本
    C++ 类型，C++ 运行时 *不会对其进行任何初始化*，结果得到的是一个 *不可预测的值*。这意味着用于初始化的值没有指定，可能是任何值。这也适用于 `Point
    p1;` 对象，它是一个用户定义的类型，但我们没有为它指定默认构造函数。`Point` 结构是一个所谓的 **原始数据** (**POD**) 类型，因为它与
    C 语言的结构的完全兼容。对于这样的类型，编译器将为你生成一个 *平凡的默认构造函数*，当被调用时实际上什么也不做。
- en: 'The output of the earlier example will look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 早期例子的输出将看起来像这样：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In my environment, the `a` and `p1` objects both have indeterministic values.
    If you run the example of your own, you will possibly get different values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的环境中，`a` 和 `p1` 对象都有不确定的值。如果你运行你自己的例子，你可能会得到不同的值。
- en: Direct initialization
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接初始化
- en: 'In our next example, we will learn about C++ *direct initialization*. In order
    to run and test this code, you have to invoke the `foo()` method again. Bear in
    mind that the `int c_warn{2.2};` `// {4.2}` statement from this example should
    be commented out in order to compile successfully:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个例子中，我们将学习 C++ 的 *直接初始化*。为了运行和测试这段代码，你必须再次调用 `foo()` 方法。请注意，为了成功编译，这个例子中的
    `int c_warn{2.2};` `// {4.2}` 语句应该被注释掉：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first statement from the example, `int b(1);`, we have defined a variable
    of type `int`, and we have explicitly initialized it with a value of `1`. This
    is the *direct initialization* that we have known since the dawn of the C++ language.
    In order to invoke it, you have to specify the initialization value in parentheses,
    and that value has to match some of the conversion constructors of the object’s
    type. These conversion constructors can be compiler-generated. In our example,
    we use `int`, which is a fundamental C++ type and supports direct initialization
    with integer values. As a result, the `b` object will be initialized with a value
    of `1`, so nothing new so far.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在例子中的第一个语句 `int b(1);`，我们定义了一个 `int` 类型的变量，并且我们显式地用值 `1` 初始化了它。这是我们自 C++ 语言诞生以来所知道的
    *直接初始化*。为了调用它，你必须指定括号中的初始化值，并且该值必须与对象的类型的一些转换构造函数相匹配。这些转换构造函数可以是编译器生成的。在我们的例子中，我们使用
    `int`，这是一个基本的 C++ 类型，支持使用整数值进行直接初始化。因此，`b` 对象将被初始化为 `1`，到目前为止没有什么新的。
- en: With the next statement, we declare an `int b_trunc(1.2);` variable, but this
    time, we initialize it with a floating-point value of `1.2`. This statement works
    fine and declares a variable of type `int` and initializes it with a value of…
    `1`! Yes, according to the C++ standard, which tries to be as compatible as possible
    with the C language for features that are present in both languages, the value
    is *truncated down* to its mantissa. In some cases, it could be useful to initialize
    an integer object with a floating-point value, but in others, this could be an
    inadvertent error. In such a case, we will expect the compiler to warn us that
    we are potentially doing something wrong. Therefore, C++11 introduced the so-called
    *uniform initialization*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个语句中，我们声明了一个`int b_trunc(1.2);`变量，但这次我们用浮点值`1.2`来初始化它。这个语句运行正常，并声明了一个`int`类型的变量，并用一个值初始化它……`1`！是的，根据C++标准，它试图尽可能与C语言兼容，对于两种语言都存在的特性，值会被*截断*到其尾数部分。在某些情况下，用浮点值初始化整数对象可能是有用的，但在其他情况下，这可能是无意中的错误。在这种情况下，我们期望编译器警告我们我们可能正在做错误的事情。因此，C++11引入了所谓的*统一初始化*。
- en: In the next statement from the example, `int c{2};`, we again declare a variable
    of type `int`, but we initialize it using curly braces rather than parentheses.
    This notifies the compiler to invoke *direct list initialization*, which is a
    kind of uniform initialization. It is a named list initialization because it can
    be used as an initialization list of values of different types to initialize complex
    objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中的下一个语句`int c{2};`中，我们再次声明了一个`int`类型的变量，但这次我们用花括号而不是括号来初始化它。这通知编译器调用*直接列表初始化*，这是一种统一初始化。它是一个命名列表初始化，因为它可以用作不同类型值的初始化列表，以初始化复杂对象。
- en: 'One reason to prefer using uniform initialization wherever this is possible
    is visible in the next statement from the example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下优先使用统一初始化的一个原因是体现在示例中的下一个语句：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we just saw, using direct initialization to initialize an object of a specific
    type with a value of a wider type leads to a silently truncated initialized value.
    In some situations, this can lead to bugs. One way to avoid this potential side
    effect is to use uniform initialization instead. In our example, we defined a
    variable of type `int` and again initialized it with a floating-point value. However,
    this time, the compiler will not silently initialize `c_warn` with a value of
    `2`, but it will generate an error similar to this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，使用直接初始化将一个特定类型的对象用更宽类型的值初始化会导致初始化值被静默截断。在某些情况下，这可能会导致错误。避免这种潜在副作用的一种方法是用统一初始化代替。在我们的例子中，我们定义了一个`int`类型的变量，并且再次用浮点值初始化它。然而，这次编译器不会静默地将`c_warn`初始化为`2`，而是会生成一个类似于下面的错误：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The error is produced because we try to perform a narrowing conversion in the
    initialization of an `int` variable with a `double` value. Therefore, it is safer
    to use uniform initialization over a direct one because it protects you from narrowing
    conversions during initialization.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 错误产生是因为我们试图在用`double`值初始化`int`变量时执行缩窄转换。因此，使用统一初始化而不是直接初始化更安全，因为它在初始化过程中保护你免受缩窄转换。
- en: Zero and aggregate initialization
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零和聚合初始化
- en: 'Let’s see another initialization example. We will initialize an object that
    holds the personal data for `Person` and a few integer objects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看另一个初始化的例子。我们将初始化一个包含`Person`个人数据和几个整数对象的对象：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we already explained, the objects with automatic storage duration and without
    explicit initialization get random initialization values. In this example, from
    markers `{1}` to `{3}`, we have initialized the objects using *zero initialization*,
    which effectively sets their values to zero. Zero initialization happens for non-class,
    built-in types and for the members of user-defined types that have no constructors.
    Preferably use curly brace notation and uniform initialization, such as marker
    `{1}`, when you need to zero-initialize your objects, rather than copying zero
    initialization, such as markers `{2}` and `{3}`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，具有自动存储持续时间且没有显式初始化的对象会得到随机初始化值。在这个例子中，从标记`{1}`到`{3}`，我们使用*零初始化*来初始化对象，这实际上将它们的值设置为0。对于非类、内置类型以及没有构造函数的用户定义类型的成员，都会发生零初始化。当你需要将对象零初始化时，最好使用花括号表示法和统一初始化，例如标记`{1}`，而不是复制零初始化，例如标记`{2}`和`{3}`。
- en: Statement `{4}` demonstrates another method of initialization called *aggregate
    initialization*. It allows us to initialize an aggregate object using uniform
    initialization notation. An aggregate is considered any object that is an array
    or a class type that has no user-declared or inherited constructors; all of its
    non-static members are publicly visible, and it has no virtual base classes and
    no virtual methods. Statement `{5}` performs another way of *aggregate initialization*
    but using *designators*. The designators explicitly specify the members being
    initialized, and the order of the designators in the initialization should follow
    the order of the declaration of the members in the structure.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`{4}`展示了另一种初始化方法，称为*聚合初始化*。它允许我们使用统一初始化符号初始化聚合对象。聚合被认为是指任何数组或没有用户声明的或继承的构造函数的类类型对象；它的所有非静态成员都是公开可见的，并且它没有虚拟基类和虚拟方法。语句`{5}`执行了另一种*聚合初始化*的方式，但使用了*设计符*。设计符明确指定了正在初始化的成员，并且初始化中设计符的顺序应该遵循结构中成员声明的顺序。
- en: Copy initialization
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制初始化
- en: 'Copy initialization occurs when an object of a specific type is initialized
    by another object of the same type. Let’s look at the following examples of syntax
    that triggers copy initialization. In order to run and test this code, you have
    to invoke the `foo()` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 复制初始化发生在特定类型的对象被同类型的另一个对象初始化时。让我们看看以下触发复制初始化的语法示例。为了运行和测试此代码，你必须调用`foo()`方法：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Markers `{1}` and `{3}` from this example demonstrate the well-known copy initialization
    present in the language even before C++11\. An object of type `int` is initialized
    by another object of the same type. As we already saw, this kind of initialization
    doesn’t give any protection against types narrowing. This means that our `int`
    objects can be silently initialized by `double` objects, which will lead to narrowing.
    Fortunately, this is not the case with markers `{2}` and `{4}`. They use uniform
    copy initialization, which forces the compiler to verify that the initialization
    object is from the same type as the object being initialized.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的标记`{1}`和`{3}`展示了即使在C++11之前，语言中也存在的知名复制初始化。一个`int`类型的对象被同类型的另一个对象初始化。正如我们之前看到的，这种初始化不会提供任何针对类型缩窄的保护。这意味着我们的`int`对象可以被`double`对象无声地初始化，这会导致缩窄。幸运的是，标记`{2}`和`{4}`的情况并非如此。它们使用统一的复制初始化，这迫使编译器验证初始化对象与被初始化的对象类型相同。
- en: Now, let’s look at several scenarios of copy initialization for user-defined
    types. We have defined two classes – `Person` and `Employee`. The `Person` class
    has one user-defined constructor that receives a reference to the `std::string`
    parameter, used to initialize the name of the person. The constructor is marked
    as `explicit`. This means that it will be used only as a non-converting constructor.
    The *converting constructor* is a constructor that makes an implicit conversion
    from its argument types to its class types.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看用户定义类型的一些复制初始化场景。我们定义了两个类——`Person`和`Employee`。`Person`类有一个用户定义的构造函数，它接收一个指向`std::string`参数的引用，用于初始化人的名字。构造函数被标记为`explicit`。这意味着它只能作为非转换构造函数使用。*转换构造函数*是一种将它的参数类型隐式转换为它的类类型的构造函数。
- en: 'The other class, `Employee`, has two constructors, one of which gets a reference
    to a `Person` object, while the other is a copy constructor. The copy constructor
    is also marked as `explicit`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类`Employee`有两个构造函数，其中一个获取一个`Person`对象的引用，而另一个是复制构造函数。复制构造函数也被标记为`explicit`：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s use these two classes in different initialization scenarios. In order
    to run and test this code, you have to rework and invoke the `foo()` method again:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这两个类在不同的初始化场景中。为了运行和测试此代码，你必须重新修改并再次调用`foo()`方法：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We first defined a `Person` object named `john`, and in marker `{1}`, we initialize
    an `Employee` object using `john`. This is actually valid because the `Employee`
    class has a constructor that accepts the `Person` objects. The next statement,
    marker `{2}`, which is commented out, gets as an argument an object of type `std::string`,
    but the compiler will generate an error. This is because the `Employee` class
    doesn’t have a constructor that gets a string object. It has a converting constructor
    from the `Person` object. However, the `Person` constructor is marked as `explicit`,
    and it is not allowed to be used in implicit type conversions, so the compilation
    will fail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个名为`john`的`Person`对象，并在标记 `{1}` 中使用`john`初始化了一个`Employee`对象。这实际上是有效的，因为`Employee`类有一个接受`Person`对象的构造函数。下一个语句，标记
    `{2}`，被注释掉了，它接受一个`std::string`类型的对象，但编译器会生成一个错误。这是因为`Employee`类没有接受字符串对象的构造函数。它有一个从`Person`对象转换而来的构造函数。然而，`Person`构造函数被标记为`explicit`，不允许在隐式类型转换中使用，因此编译会失败。
- en: The next statement, marker `{3}`, will compile successfully because `Employee`
    is copy-constructed and initialized by another `Employee` object without any implicit
    type conversions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个语句，标记 `{3}`，将成功编译，因为`Employee`是通过另一个`Employee`对象复制构造和初始化的，没有进行任何隐式类型转换。
- en: The final two statements from the example – markers `{4}` and `{5}` – are also
    commented out to avoid compilation errors. The reason for the compiler error is
    that the copy constructor of the `Employee` class is also marked as `explicit`.
    This means that copy construction and initialization using equal `"="` sign is
    not allowed for explicit copy constructors. Only direct copy initialization is
    permitted.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的最后两个语句 – 标记 `{4}` 和 `{5}` – 也被注释掉了，以避免编译错误。编译错误的原因是`Employee`类的复制构造函数也被标记为`explicit`。这意味着不允许使用等号
    `"="` 进行复制构造和初始化，对于显式复制构造函数来说，只有直接复制初始化是被允许的。
- en: Now that we are familiar with what the scope, storage duration, and lifetime
    of the object are, we can have a look at some slightly different kinds of objects,
    which behave more like functions rather than objects – functors and lambdas.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了对象的作用域、存储持续时间和生命周期，我们可以看看一些稍微不同类型的对象，它们的行为更像是函数而不是对象 – 函子和lambda表达式。
- en: Functors and lambdas
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子和lambda表达式
- en: This section will delve into functional objects – their definition, usefulness,
    and proper usage. We’ll begin by examining an example of a functional object used
    with an STL algorithm and discuss potential issues, such as the creation of temporary
    objects and dangling references. After that, we’ll move on to exploring lambda
    expressions – what they are, how to use them, and specific situations where they
    can be especially advantageous.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将深入探讨函数对象 – 它们的定义、有用性和正确使用。我们将从检查一个与STL算法一起使用的函数对象示例开始，并讨论潜在问题，如临时对象的创建和悬垂引用。之后，我们将继续探讨lambda表达式
    – 它是什么，如何使用它们，以及它们在特定情况下可以特别有利的情况。
- en: Exploring functional objects
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索函数对象
- en: 'In the *Scope, storage duration, and lifetimes* section, we looked at various
    types of object initialization in C++, but our focus was mostly on objects that
    represent data, such as integers or coordinates. In this section, we’ll shift
    our attention to another type of object – those designed to be *callable*, such
    as a function, but with a crucial difference: they can maintain a state between
    different function calls. These objects are known as *functional objects* or *functors*.
    We’ll start by defining a functor and then use it to compute the mean value of
    a vector containing floating-point numbers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在*作用域、存储持续时间和生命周期*部分，我们探讨了C++中各种类型的对象初始化，但我们的重点主要是在表示数据的对象上，例如整数或坐标。在本节中，我们将把注意力转向另一种类型的对象
    – 那些被设计为*可调用*的对象，例如函数，但有一个关键的区别：它们可以在不同的函数调用之间保持状态。这些对象被称为*函数对象*或*函子*。我们将首先定义一个函子，然后使用它来计算包含浮点数的向量的平均值：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The functor is an object like any other. It has a type, storage duration, and
    scope. In order to define a functor, you have to either define a struct or class
    of a user-defined type, and this type must have implemented a *function* *call
    operator*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 函子是一个像其他任何对象一样的对象。它有一个类型、存储持续时间和作用域。为了定义一个函子，你必须定义一个用户自定义类型的结构体或类，并且这个类型必须实现了*函数*
    *调用操作符*：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In our example, we defined `struct Mean` with two members in it, which are zero-initialized.
    The first one, `sum`, will be used to accumulate the input data that this object
    receives during the function call operator invocations, preserving it between
    different invocations. And the other member, `count`, will be used to count the
    number of invocations of the function call operator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们定义了一个包含两个成员的 `struct Mean`，这两个成员都是零初始化的。第一个成员 `sum` 将用于在函数调用操作符调用期间累积该对象接收到的输入数据，并在不同的调用之间保持它。另一个成员
    `count` 将用于计算函数调用操作符的调用次数。
- en: The definition of the function call operator gets one parameter of a `double`
    type, and then the method prints its name and adds the input value to the already
    accumulated value from the previous invocations. Finally, it increments the invocation
    counter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用操作符的定义接受一个 `double` 类型的参数，然后该方法打印其名称并将输入值添加到之前调用中已经累积的值。最后，它增加调用计数器。
- en: 'The function call operator doesn’t return any type and is not defined as a
    `const` method because it mutates the state of the `Mean` object. We also overloaded
    the stream extraction operator, which will be used to report the calculated mean
    value to the standard output. If there is no accumulated value, then `nan` (“not
    a number”) will be printed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用操作符不返回任何类型，并且没有定义为 `const` 方法，因为它会改变 `Mean` 对象的状态。我们还重载了流提取操作符，它将用于将计算出的平均值报告到标准输出。如果没有累积值，则打印
    `nan`（“不是一个数字”）：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Please keep in mind that the operator is overloaded outside of the `Mean` structure,
    and it is declared as a *friend* method to it. This is because it needs to get
    `std::ostream` as a left-hand argument and the `Mean` parameter as the right argument,
    and therefore, it can’t be implemented as a member method. It’s defined as *friend*
    because it has to have access to the *private* members of the `Mean` structure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，操作符在 `Mean` 结构外部重载，并且它被声明为该结构的 *friend* 方法。这是因为它需要将 `std::ostream` 作为左操作数，将
    `Mean` 参数作为右操作数，因此不能实现为成员方法。它被定义为 *friend* 是因为它必须能够访问 `Mean` 结构的 *private* 成员。
- en: In order to calculate the mean value, our algorithm iterates over all values
    in the vector using the `std::for_each` STL algorithm. `std::for_each` expects
    to receive a container on which to operate and function, which will be invoked
    with each of the elements from the container; therefore, this function must accept
    one parameter as an input argument.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算平均值，我们的算法使用 `std::for_each` STL 算法遍历向量中的所有值。`std::for_each` 预期接收一个容器来操作，以及一个函数，该函数将使用容器中的每个元素调用；因此，此函数必须接受一个参数作为输入参数。
- en: In the main method, we define an object of type `Mean calc_mean;`, which will
    be used to calculate the mean value of `std::vector v1{1.0, 2.5, 4.0, 5.5};`.
    As you can see, we don’t need to explicitly specify the template argument type
    of the `std::vector` class because it is automatically deduced by the type of
    the initializer list values it is initialized with. In our case, these are `double`
    values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在主方法中，我们定义了一个类型为 `Mean calc_mean;` 的对象，该对象将用于计算 `std::vector v1{1.0, 2.5, 4.0,
    5.5};` 的平均值。正如您所看到的，我们不需要显式指定 `std::vector` 类的模板参数类型，因为它会根据其初始化列表值的类型自动推导。在我们的例子中，这些是
    `double` 类型的值。
- en: Important note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please note that since C++17, the automatic class template argument deduction
    is already supported, based on the type of its initializer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，自 C++17 以来，基于其初始化的类型，已经支持自动类模板参数推导。
- en: 'We expect that the program will invoke the function operator of the `Mean`
    object for each element in the vector. The function operator will accumulate all
    values, and when the result is printed out, it will be `3.25`. Let’s see the output
    of the program:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望程序将为向量中的每个元素调用 `Mean` 对象的函数操作符。函数操作符将累积所有值，当结果打印出来时，它将是 `3.25`。让我们看看程序的输出：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we expected, the operator function call is invoked for each of the elements
    from the vector, but surprisingly, there is no calculated mean value. In order
    to get a better understanding of what went wrong with the calculation, we need
    to see what has happened with the `calc_mean` object, which has been used by the
    `std::for_each` algorithm.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，操作符函数调用为向量中的每个元素调用一次，但令人惊讶的是，没有计算出的平均值。为了更好地理解计算中出了什么问题，我们需要查看 `calc_mean`
    对象的情况，该对象已被 `std::for_each` 算法使用。
- en: Beware of temporaries
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小心临时变量
- en: 'For the sake of investigation, in the `Mean` structure, we need to define the
    `copy` and `move` constructors, the `move` operator, and a destructor, whose only
    goal will be to print whether they are invoked and the address of the object that
    they belong to. We also need to add markers for when the calculation starts and
    when it finishes. Let’s see the reworked example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行调查，在`Mean`结构中，我们需要定义`copy`和`move`构造函数、移动操作符和一个析构函数，它们的唯一目标将是打印它们是否被调用以及它们所属的对象的地址。我们还需要添加计算开始和结束时的时间标记。让我们看看修改后的示例：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need to slightly change the `main()` method implementation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要稍微修改`main()`方法的实现：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we re-execute the already reworked program, we get the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新执行已经修改过的程序时，我们得到以下输出：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we expected, the program starts with the construction of the object with
    the address `0x7ffef7956c50`, then the calculation is started, and we can see
    that a copy constructor is invoked. This is because `std::for_each`, like many
    other algorithms in the standard library, is a template method that gets its functor
    by value. Here is what the standard says about its prototype:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，程序从创建地址为`0x7ffef7956c50`的对象开始，然后开始计算，我们可以看到调用了复制构造函数。这是因为`std::for_each`，就像标准库中的许多其他算法一样，是一个模板方法，它通过值获取其函数对象。以下是标准关于其原型的说明：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This means that no matter what calculation it does, all the accumulated values
    will be stored in the copied object rather than the original. Actually, the object
    created by this copy constructor is just a *temporary object*. Temporary objects
    are unnamed objects that are automatically created and destroyed by the compiler.
    They often lead to side effects that are not trivially recognizable by the developers.
    Temporary objects are most frequently created as a result of implicit conversions
    of arguments and functions’ returned values. They frequently have a limited lifetime,
    till the end of the statement they are created by, if they are not bound to some
    named reference. So, be careful with them because they can impact the performance
    of your program, but more importantly, they can lead to unexpected behavior, as
    in our example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论它执行什么计算，所有累积的值都将存储在复制的对象中，而不是原始对象中。实际上，由这个复制构造函数创建的对象只是一个*临时对象*。临时对象是没有名称的对象，它们由编译器自动创建和销毁。它们经常导致开发者难以识别的副作用。临时对象通常是在参数和函数返回值的隐式转换的结果中创建的。如果它们没有绑定到某个命名引用，它们通常具有有限的生存期，直到它们被创建的语句结束。因此，要小心它们，因为它们可能会影响程序的性能，但更重要的是，它们可能导致意外的行为，就像我们的例子中那样。
- en: 'From the preceding code, we can see that all the accumulations are done in
    the newly created temporary object. Once the `std::for_each` method finishes its
    execution, a move constructor of a new temporary object is invoked. This happens
    because, according to the definition of `std::for_each`, the passed-by value input
    functor is returned back as a result of the operation. So, if we need to get the
    accumulated value back to the original object, we need to assign the return value
    of `std::for_each` back to the original object – `calc_mean`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到所有的累积都是在新创建的临时对象中完成的。一旦`std::for_each`方法完成执行，就会调用一个新的临时对象的移动构造函数。这是因为根据`std::for_each`的定义，通过值传递的输入函数对象作为操作的结果返回。因此，如果我们需要将累积的值返回到原始对象，我们需要将`std::for_each`的返回值赋给原始对象`calc_mean`：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, the result is what we expected but at the price of creating several
    temporary objects:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，结果是我们所预期的，但代价是创建了几个临时对象：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In our example, this is not a problem, but for really complex objects where
    temporary object creation involves expensive and potentially slow operations,
    such as resource acquisition, this could be problematic.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这并不是问题，但对于涉及昂贵且可能缓慢的操作的复杂对象，例如资源获取，这可能会成为问题。
- en: Next, let’s have a look at how we can improve our example by avoiding unnecessary
    copy operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何通过避免不必要的复制操作来改进我们的示例。
- en: Passing by reference
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过引用传递
- en: 'One way to improve the earlier example is to pass the functor not by value
    but by reference. This will avoid the creation of unnecessary temporary objects:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 改进早期示例的一种方法是将函数对象不是通过值而是通过引用传递。这将避免创建不必要的临时对象：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to pass by reference the `Mean` object, you have to explicitly state
    your intention to the compiler by explicitly specifying that the `Mean` template
    parameter is a reference. Otherwise, the automatic template argument deduction
    will deduce that you are passing by value. As a result, this forces you to avoid
    using automatic class template argument deduction and makes your code harder to
    read. Fortunately, the standard provides a solution for this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过引用传递`Mean`对象，你必须显式地告诉编译器`Mean`模板参数是引用类型。否则，自动模板参数推导将推导出你是通过值传递。结果，这迫使你避免使用自动类模板参数推导，使得你的代码更难阅读。幸运的是，标准为此提供了一个解决方案：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to use the factory method, `std::ref`, for the creation of the `std::reference_wrapper`
    objects. `std::reference_wrapper` is a class template that wraps a reference inside
    an assignable, copyable object. It’s commonly used to store references within
    standard containers that can’t typically hold them. The usage of `std::ref`, in
    our example, eliminates the need to explicitly specify that the functor template
    parameter of `std::for_each` is a reference type rather than a value. Here is
    the result of our refactoring:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用工厂方法，`std::ref`，来创建`std::reference_wrapper`对象。`std::reference_wrapper`是一个模板类，它将一个引用封装在一个可赋值、可复制的对象中。它通常用于存储标准容器中通常无法容纳的引用。在我们的例子中，`std::ref`的使用消除了显式指定`std::for_each`的函数模板参数是引用类型而不是值的必要性。以下是我们的重构结果：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, there is no additional creation and destruction of temporary
    objects because the algorithm works directly with the reference of the `calc_mean`
    object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有额外的临时对象的创建和销毁，因为算法直接与`calc_mean`对象的引用一起工作。
- en: Beware of dangling references
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 小心悬垂引用
- en: Always make sure that the references you pass across the program will refer
    to live objects until they are in use!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要确保你传递的程序中的引用将指向活动对象，直到它们被使用！
- en: Functors are just one option that we can use in our example. There is also another
    approach here that can make our code even more expressive. These are lambda expressions.
    Let’s have a look at them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象只是我们可以在例子中使用的一个选项。这里还有另一种方法可以使我们的代码更具表现力。这些是lambda表达式。让我们看看它们。
- en: Lambda expressions
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: The *lambda expression*, or just *lambda* in C++, is a concise way to define
    an *anonymous function* or *functor* inline, which can be used immediately or
    assigned to a variable for later use. It allows programmers to write small, throwaway
    functions on the fly without having to define a named function or a `functor`
    class. Lambdas are commonly used with algorithms and containers from the standard
    library, allowing for more concise and expressive code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，*lambda表达式*或简称为*lambda*，是一种简洁的方式来定义一个*匿名函数*或*函数对象*，它可以立即使用或赋值给变量以供以后使用。它允许程序员在不定义命名函数或`functor`类的情况下，即时编写小型、一次性函数。Lambdas通常与标准库中的算法和容器一起使用，从而允许编写更简洁、更具表现力的代码。
- en: 'Let’s define a simple lambda that just prints to the standard output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的lambda，它只是打印到标准输出：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Each lambda expression is an *object*, which means that it has a lifetime and
    occupies memory. Every defined lambda is a de facto functor class definition,
    and as such, it has a *unique type*. There can’t be two or more lambdas with the
    same *type* in a program. This *type* name is platform-specific, and therefore,
    if you need to assign a lambda to a variable, you have to define this variable
    with the `auto` specifier.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每个lambda表达式都是一个*对象*，这意味着它有一个生命周期并占用内存。每个定义的lambda实际上是一个隐式functor类定义，因此它有一个*唯一类型*。一个程序中不能有两个或更多具有相同*类型*的lambda。这个*类型*名称是平台特定的，因此，如果你需要将lambda赋值给变量，你必须使用`auto`指定符定义这个变量。
- en: The syntax of a lambda consists of the `[ ]` symbol, which is followed by an
    optional capture list, an optional parameter list, an optional return type, an
    optional *mutable* specifier, and a function body. Lambdas can capture variables
    from the outer scope by value or by reference, and they can also have a return
    type deduction or an explicit return type, which we will see next.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda的语法由`[ ]`符号组成，其后跟一个可选的捕获列表、一个可选的参数列表、一个可选的返回类型、一个可选的*mutable*指定符和一个函数体。Lambdas可以通过值或引用从外部作用域捕获变量，并且它们还可以有返回类型推导或显式返回类型，我们将在下面看到。
- en: Capturing the outer scope
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获外部作用域
- en: Lambdas can gain access to other objects in the scope where they’re defined
    by utilizing a *capture list*. If the capture list is empty, then no objects are
    captured. Global objects are always visible in lambdas without needing to be explicitly
    captured. When defining the capture list, you can choose to capture objects by
    *value* or by *reference*, or even a mixture of both.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 可以通过使用 *捕获列表* 来访问它们定义的作用域中的其他对象。如果捕获列表为空，则不会捕获任何对象。全局对象在 lambda 中始终可见，无需显式捕获。在定义捕获列表时，你可以选择通过
    *值* 或通过 *引用* 来捕获对象，甚至两者混合使用。
- en: When capturing variables by value in a lambda expression, the variables are
    *copied* into the lambda object at the *moment of its definition*. Any modifications
    made to the original variables after the lambda is defined won’t affect the copies
    stored inside it. All captured objects are, by default, *read-only*, and to modify
    them, you must explicitly specify the lambda as *mutable*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 lambda 表达式中通过值捕获变量时，变量会在其 *定义时刻* 被复制到 lambda 对象中。在 lambda 定义之后对原始变量所做的任何修改都不会影响其内部的副本。默认情况下，所有捕获的对象都是
    *只读的*，要修改它们，你必须显式指定 lambda 为 *可变的*。
- en: Another option to capture variables is by reference, which creates a reference
    to every captured object inside the lambda. This allows the lambda to communicate
    with the outer scope, but it’s crucial to ensure that the lifetime of all captured
    objects by reference exceeds the lifetime of the lambda to prevent *dangling references*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种捕获变量的方法是通过引用，这会在 lambda 内部创建每个捕获对象的引用。这允许 lambda 与外部作用域进行通信，但确保所有通过引用捕获的对象的生存期都超过
    lambda 的生存期，以防止 *悬垂引用*。
- en: 'Now, let’s refactor the example from the previous section to calculate the
    mean value of a vector with floating-point numbers, using a lambda instead of
    a functor. In order to run the following code, you have to invoke the `foo()`
    method from your program:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构上一节中的示例，使用 lambda 而不是泛型来计算包含浮点数的向量的平均值。为了运行以下代码，你必须从你的程序中调用 `foo()`
    方法：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: One of the key advantages of lambdas compared to named functions and functors
    is that they can be inlined in the place of their invocation. In our example,
    we have defined the lambda directly inside the `std::for_each` invocation statement.
    This approach explicitly highlights that this lambda has no other reason to exist
    except to serve the preceding case.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与命名函数和泛型相比，lambda 表达式的一个关键优势是它们可以被内联到它们的调用位置。在我们的例子中，我们直接在 `std::for_each` 调用语句中定义了
    lambda。这种方法明确指出，这个 lambda 存在的唯一原因就是为前面的情况提供服务。
- en: 'Let’s get a closer look at the lambda prototype:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 lambda 原型：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the capture list, we have captured four objects. The first one, `mean`, is
    captured by reference. Putting `&` before the variable name specifies that it
    is captured by reference. We will use `mean` to report outside of the lambda the
    calculated mean value. The next two variables in the capture list, `sum` and `count`,
    are captured by value. If `&` doesn’t precede the name of the variable, it means
    that it is captured by value. The only exception to this rule is when capturing
    the `this` pointer of a class, which will be captured by value, but the access
    to the class members will be by reference. As you can see, the captures, `sum`
    and `count`, are not defined in the outer scope; they are defined only in the
    scope of the lambda for the purpose of our example. Just like the functor example,
    they are used to store the accumulated sum and the count of the iterations. This
    is a convenient way to explicitly add state into your lambda for use in further
    calculations. Of course, you need to initialize them by passing initializers to
    the captures for two reasons – in order to allow the compiler to deduce their
    type and to get the expected result in the calculations. The implementation logic
    will update the values of `sum` and `count` during its execution, but as stated
    previously, these captures are read-only in the context of the lambda. Therefore,
    we cannot just mutate them without explicitly stating our intention during the
    lambda definition. This is done by appending the `mutable` keyword after the argument
    list and before the body of the lambda.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获列表中，我们捕获了四个对象。第一个对象，`mean`，是通过引用捕获的。在变量名前放置 `&` 指定它是通过引用捕获的。我们将使用 `mean`
    在 lambda 外部报告计算出的平均值。捕获列表中的下一个两个变量，`sum` 和 `count`，是通过值捕获的。如果 `&` 不在变量名前，则表示它是通过值捕获的。这个规则的唯一例外是在捕获类的
    `this` 指针时，它将通过值捕获，但访问类成员将通过引用。正如你所看到的，捕获的 `sum` 和 `count` 并不在外部作用域中定义；它们只在 lambda
    的作用域内定义，目的是为了我们的示例。就像函数对象示例一样，它们被用来存储累积的总和和迭代的计数。这是一种将状态显式添加到 lambda 中以供进一步计算使用的便捷方式。当然，你需要通过向捕获传递初始化器来初始化它们，原因有两个——为了允许编译器推断它们的类型，并在计算中获得预期的结果。实现逻辑将在其执行过程中更新
    `sum` 和 `count` 的值，但如前所述，这些捕获在 lambda 的上下文中是只读的。因此，我们不能在不明确声明我们的意图的情况下修改它们。这是通过在参数列表之后和
    lambda 体之前附加 `mutable` 关键字来完成的。
- en: The last captured object is `text`. It is also captured by value, but this time,
    it is captured from the outer scope in the `foo()` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后捕获的对象是 `text`。它也是通过值捕获的，但这次它是从 `foo()` 方法的外部作用域中捕获的。
- en: 'Once the program is executed, we have the following output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序执行完毕，我们将得到以下输出：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we expected, our lambda has been called four times, and the calculated mean
    value is exactly the same as the value calculated by the functor in the previous
    section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，我们的 lambda 被调用了四次，计算出的平均值与上一节中函数对象计算出的值完全相同。
- en: 'There are many ways to capture objects in the capture list. The following list
    shows some rules that apply:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获列表中捕获对象有许多方法。以下列表显示了一些适用的规则：
- en: '![Figure 4.1 – Ways to capture objects in a capture list](img/Figure_4.1_B20833.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 在捕获列表中捕获对象的方法](img/Figure_4.1_B20833.jpg)'
- en: Figure 4.1 – Ways to capture objects in a capture list
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 在捕获列表中捕获对象的方法
- en: Now that we know how to properly capture the outer scope, let’s get familiar
    with a lambda’s parameter list.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何正确捕获外部作用域，让我们熟悉一下 lambda 的参数列表。
- en: Parameter list
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数列表
- en: The parameter list of a lambda is just like any other function parameter list.
    This is because the lambda’s parameter list is effectively the parameter list
    of the function call operator in a functor class. You can define your lambda to
    accept an arbitrary list of parameters, depending on the use case you have.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 的参数列表就像任何其他函数参数列表一样。这是因为 lambda 的参数列表实际上是函数调用操作符在函数对象类中的参数列表。你可以定义你的
    lambda 接受任意数量的参数，具体取决于你的用例。
- en: 'Using the `auto` specifier as a parameter type of one or more of the parameters
    in the lambda parameter lists makes it a *generic lambda*. A generic lambda acts
    as a template function call operator:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `auto` 指示符作为 lambda 参数列表中一个或多个参数的类型，使其成为一个 *泛型 lambda*。泛型 lambda 行为类似于模板函数调用操作符：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This effectively acts as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上作用如下：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the C++20 release, if you wish you can explicitly specify the template
    parameters that your lambda can get. The preceding example could be rewritten
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++20 的发布，如果你愿意，你可以显式指定 lambda 可以获取的模板参数。前面的例子可以重写如下：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Another important characteristic of lambdas is the return type. Let’s see its
    specifics.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 的另一个重要特性是返回类型。让我们看看它的具体细节。
- en: The return type
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回类型
- en: Specifying the return type of the lambda is *optional*. If you don’t explicitly
    specify it, the compiler will try to deduce it for you. If it doesn’t succeed,
    then a compiler error in type deduction will be generated. Then, you have to either
    change your code to allow automatic return type deduction or explicitly specify
    the return type of the lambda.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 指定 lambda 的返回类型是**可选的**。如果你没有显式指定它，编译器会尝试为你推断它。如果它没有成功，那么将生成一个类型推断的编译器错误。然后，你必须要么更改你的代码以允许自动返回类型推断，要么显式指定
    lambda 的返回类型。
- en: 'Here is a compiler error in return type deduction:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个关于返回类型推断的编译器错误：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code will not compile because the compiler will fail to automatically deduce
    the return type of the lambda. It’s implementation logic has two execution branches.
    The first one returns an `integer` literal, `0`, but the other one returns the
    result of a division, the quotient, which is a `double` number.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码无法编译，因为编译器将无法自动推断 lambda 的返回类型。它的实现逻辑有两个执行分支。第一个分支返回一个整型字面量，`0`，但另一个分支返回除法的结果，即商，它是一个双精度浮点数。
- en: In order to fix this, we need to explicitly specify that the return type of
    the lambda is `double`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们需要显式指定 lambda 的返回类型为 `double`。
- en: 'Here is an explicitly specified return type:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个显式指定的返回类型：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, for the compiler, it is clear that the return result is always converted
    to `double`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于编译器来说，很清楚返回结果总是被转换为 `double`。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored various aspects of objects in C++, including storage
    duration, scope, and lifetimes. We distinguished between objects and references
    and discussed different ways of initializing objects and when these initializations
    occur. Additionally, we delved into the world of functors, gaining an understanding
    of what they are and how to use them effectively. Building on that knowledge,
    we also learned about lambda expressions and their advantages over functors. We
    covered how to properly use both lambdas and functors with STL algorithms. Armed
    with this knowledge of object specifics, we can now move on to discussing error
    handling in C++ in the next chapter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 C++ 中对象的各种方面，包括存储持续时间、作用域和生命周期。我们区分了对象和引用，并讨论了初始化对象的不同方式以及这些初始化何时发生。此外，我们还深入了解了函数对象的世界，了解了它们是什么以及如何有效地使用它们。基于这些知识，我们还学习了
    lambda 表达式及其相对于函数对象的优点。我们介绍了如何正确使用 lambda 和函数对象与 STL 算法。掌握了这些关于对象特性的知识后，我们接下来可以讨论
    C++ 中的错误处理。
