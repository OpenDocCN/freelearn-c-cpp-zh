- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Compiling C++ Sources with CMake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CMake 编译 C++ 源码
- en: Simple compilation scenarios are usually handled by a default configuration
    of a toolchain or just provided out of the box by an **integrated development
    environment** (**IDE**). However, in a professional setting, business needs often
    call for something more advanced. It could be a requirement for higher performance,
    smaller binaries, more portability, automated testing, or extensive debugging
    capabilities – you name it. Managing all of these in a coherent, future-proof
    way quickly becomes a complex, tangled mess (especially when there are multiple
    platforms to support).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的编译场景通常由工具链的默认配置或者集成开发环境（**IDE**）提供。然而，在专业环境中，业务需求经常需要更高级的功能。可能需要更高的性能、更小的二进制文件、更强的可移植性、自动化测试或者更多的调试能力
    – 不胜枚举。在一个一致、未来可靠的方式中管理所有这些很快就变成了一个复杂、纠结的问题（尤其是在需要支持多个平台时）。
- en: 'The process of compilation is often not explained well enough in books on C++
    (in-depth subjects such as virtual base classes seem to be more interesting).
    In this chapter, we’ll fix that by going through different aspects of compilation:
    we’ll discover how compilation works, what its internal stages are, and how they
    affect the binary output.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编译的过程通常在 C++ 的书籍中解释得不够详细（像虚拟基类这样的深入主题似乎更有趣）。在本章中，我们将通过讨论编译的不同方面来解决这个问题：我们将了解编译的工作原理、它的内部阶段以及它们如何影响二进制输出。
- en: After that, we will focus on the prerequisites – we’ll discuss what commands
    we can use to fine-tune the compilation process, how to require specific features
    from a compiler, and how to correctly instruct the compiler on which input files
    to process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将专注于先决条件 – 我们将讨论可以用于微调编译过程的命令，如何从编译器要求特定功能，以及如何正确地告知编译器处理哪些输入文件。
- en: Then, we’ll focus on the first stage of compilation – the preprocessor. We’ll
    be providing paths for included headers, and we’ll study how to plug in variables
    from CMake and the build environment with preprocessor definitions. We’ll cover
    the most interesting use cases and learn how to expose CMake variables so they
    can be accessed from C++ code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将专注于编译的第一阶段 – 预处理器。我们将提供包含头文件的路径，并学习如何通过预处理器定义从 CMake 和构建环境中插入变量。我们将涵盖最有趣的用例，并学习如何公开
    CMake 变量以便从 C++ 代码中访问。
- en: Right after that, we’ll talk about the optimizer and how different flags can
    affect performance. We’ll also discuss the costs of optimization, specifically
    how it affects the debuggability of produced binaries, and what to do if that
    isn’t desired.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将讨论优化器及其如何通过不同的标志影响性能。我们还将讨论优化的成本，特别是它如何影响生成的二进制文件的调试能力，以及如果不需要这些影响时应该怎么做。
- en: Lastly, we’ll explain how to manage the compilation process in terms of reducing
    the compilation time by using precompiled headers and unity builds. We’ll learn
    how to debug the build process and find any mistakes we might’ve made.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将解释如何通过使用预编译头文件和统一构建来管理编译过程，以减少编译时间。我们将学习如何调试构建过程并找出可能存在的任何错误。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The basics of compilation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译的基础知识
- en: Configuring the preprocessor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器的配置
- en: Configuring the optimizer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置优化器
- en: Managing the process of compilation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理编译过程
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch07](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch07).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章节中存在的代码文件，链接在[https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch07](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch07)。
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书提供的示例，请始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace the `<build tree>` and `<source tree>` placeholders with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保用适当的路径替换 `<build tree>` 和 `<source tree>` 占位符。作为提醒：**build tree** 是指目标/输出目录的路径，**source
    tree** 是指源代码所在的路径。
- en: The basics of compilation
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译的基础知识
- en: Compilation can be roughly described as a process of translating instructions
    written in a high-level programming language into low-level machine code. This
    allows us to create our applications using abstract concepts such as classes and
    objects and sparing us the tedious intricacies of processor-specific assembly
    languages. We don’t need to work directly with CPU registers, think about short
    or long jumps, or manage stack frames. Compiled languages are more expressive,
    readable, and secure, and they encourage the creation of maintainable code, all
    while delivering as much performance as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编译可以大致描述为将用高级编程语言编写的指令转换为低级机器码的过程。这使我们能够使用诸如类和对象等抽象概念来创建应用程序，而不必费力处理处理器特定的汇编语言。我们不需要直接操作CPU寄存器，考虑短跳或长跳，或管理堆栈帧。编译型语言更具表现力、可读性和安全性，并鼓励编写可维护的代码，同时尽可能提供最佳性能。
- en: In C++, we use static compilation – meaning an entire program must be translated
    into native code before it can be executed. This is a different approach compared
    to languages such as Java or Python, which interpret and compile the program on
    the fly each time a user runs it. Each method has its own unique advantages. C++
    aims to offer a multitude of high-level tools, while simultaneously delivering
    native performance. A C++ compiler can produce a self-contained application for
    almost every architecture out there.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们使用静态编译——这意味着整个程序必须在执行之前先被翻译成本地代码。这与像Java或Python这样的语言不同，后者每次用户运行程序时都会即时解释和编译程序。每种方法都有其独特的优点。C++旨在提供多种高级工具，同时提供本地性能。C++编译器可以为几乎所有架构生成一个自包含的应用程序。
- en: 'Creating and running a C++ program involves several steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并运行C++程序涉及多个步骤：
- en: '**Design your application**: This includes planning the application’s functionality,
    structure, and behavior. Once your design is finalized, carefully write the source
    code following best practices for code readability and maintainability.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计你的应用程序**：这包括规划应用程序的功能、结构和行为。一旦设计完成，按照代码可读性和可维护性的最佳实践，仔细编写源代码。'
- en: '**Compile individual .cpp implementation files, also known as translation units,
    into object files**: This step involves converting the high-level language code
    that you’ve written into low-level machine code.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译单个.cpp实现文件，也称为翻译单元，成目标文件**：这一步涉及将您编写的高级语言代码转换为低级机器码。'
- en: '**Link** **object files together into a single executable**: During this step,
    all other dependencies, including dynamic and static libraries, are also linked.
    This process creates an executable that can be run on the intended platform.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将链接** **目标文件合并成单个可执行文件**：在此步骤中，所有其他依赖项，包括动态库和静态库，也会被链接。这一过程创建了一个可以在预定平台上运行的可执行文件。'
- en: To run the program, the **operating system** (**OS**) will use a tool called
    **loader** to map the program’s machine code and all required dynamic libraries
    into virtual memory. The loader then reads the program headers to determine where
    execution should start and begins running the instructions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，**操作系统**（**OS**）将使用一种名为**加载器**的工具，将程序的机器码和所有所需的动态库映射到虚拟内存中。加载器随后读取程序头部，以确定执行应从哪里开始，并开始运行指令。
- en: At this stage, the program’s start-up code comes into play. A special function
    called `_start`, provided by the system’s C library, is invoked. The `_start`
    function collects command-line arguments and environment variables, initiates
    threading, initializes static symbols, and registers cleanup callbacks. Only after
    this will it call `main()`, the function that programmers fill with their own
    code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，程序的启动代码开始发挥作用。系统C库提供的一个特殊函数`_start`被调用。`_start`函数收集命令行参数和环境变量，启动线程，初始化静态符号，并注册清理回调函数。只有在此之后，它才会调用`main()`，这是程序员填入自己代码的函数。
- en: As you can see, a considerable amount of work takes place behind the scenes.
    This chapter focuses on the second step from the earlier list. By considering
    the bigger picture, we can better understand where potential issues might originate.
    There’s no such thing as magic in software development, despite the seeming impenetrability
    of the complexity involved. Everything has an explanation and a reason. We need
    to understand that things can go wrong during the runtime of a program due to
    how we compiled it, even if the compilation step itself appeared to be successful.
    It’s simply not possible for a compiler to check all edge cases during its operation.
    So, let’s find out what actually happens when the compiler does its job.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在幕后发生了大量工作。本章重点讲解早期列表中的第二步。通过考虑整体情况，我们可以更好地理解潜在问题可能来自哪里。尽管软件开发中的复杂性看起来似乎无法逾越，但开发中并不存在“魔法”。一切都有解释和原因。我们需要理解，由于我们如何编译程序，程序在运行时可能会出现问题，即使编译步骤本身看似成功。编译器不可能在其操作过程中检查所有边界情况。因此，让我们深入了解当编译器执行其工作时，实际发生了什么。
- en: How compilation works
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译如何工作
- en: As mentioned before, compilation is the process of translating a high-level
    language into a low-level language. Specifically, this involves generating machine
    code, which are instructions that a specific processor can directly execute, in
    a binary **object file** format unique to a given platform. On Linux, the most
    commonly used format is the **Executable and Linkable Format** (**ELF**). Windows
    uses a PE/COFF format specification, and on macOS, we’ll encounter Mach objects
    (the Mach-O format).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编译是将高级语言翻译成低级语言的过程。具体来说，这涉及生成机器代码，这些机器代码是特定处理器可以直接执行的指令，格式为平台独有的二进制**目标文件**。在Linux上，最常用的格式是**可执行与可链接格式**（**ELF**）。Windows使用PE/COFF格式规范，而在macOS上，我们会遇到Mach对象（Mach-O格式）。
- en: '**Object files** are the direct translation of individual source files. Each
    of these files must be compiled separately and subsequently combined by a linker
    into a single executable or library. This modular process can significantly save
    time when modifying code, as only the files updated by the programmer need to
    be recompiled.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标文件**是单个源文件的直接翻译。每个文件必须单独编译，然后由链接器将其合并成一个可执行文件或库。这个模块化过程在修改代码时可以显著节省时间，因为只有程序员更新的文件需要重新编译。'
- en: The compiler has to execute the following stages to create an **object file:**
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器必须执行以下阶段才能创建**目标文件**：
- en: Preprocessing
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理
- en: Linguistic analysis
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言分析
- en: Assembly
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇编
- en: Optimization
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化
- en: Code emission
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码生成
- en: Let’s explain them in more detail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下它们。
- en: '**Preprocessing**, although automatically invoked by most compilers, is considered
    a preparatory step prior to actual compilation. Its role is to perform rudimentary
    manipulations on the source code; it executes `#include` directives, substitutes
    identifiers with defined values through `#define` directives and `-D` flags, invokes
    simple macros, and conditionally includes or excludes parts of code based on the
    `#if`, `#elif`, and `#endif` directives. The preprocessor remains blissfully unaware
    of the actual C++ code. In essence, it functions as an advanced find-and-replace
    tool.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**预处理**，虽然大多数编译器自动调用，但被视为实际编译之前的准备步骤。它的作用是对源代码进行基本的操作；执行`#include`指令、通过`#define`指令和`-D`标志替换标识符为已定义的值、调用简单的宏，并根据`#if`、`#elif`和`#endif`指令有条件地包含或排除部分代码。预处理器对实际的C++代码毫不知情。从本质上讲，它充当一个高级的查找和替换工具。'
- en: Nevertheless, the role of the preprocessor is vital for building advanced programs.
    The ability to divide code into parts and share declarations across multiple translation
    units is the foundation of code reusability.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，预处理器在构建高级程序中的作用至关重要。将代码分割成多个部分并在多个翻译单元之间共享声明的能力是代码可重用性的基础。
- en: Next up is **linguistic analysis**, where the compiler conducts more intricate
    operations. It scans the preprocessed file (which now includes all the headers
    inserted by the preprocessor) character by character. Through a process known
    as lexical analysis, it groups characters into meaningful tokens – these could
    be keywords, operators, variable names, and more.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**语言分析**，在这一阶段，编译器进行更复杂的操作。它逐字符扫描预处理后的文件（现在已包含由预处理器插入的所有头文件）。通过一种称为词法分析的过程，它将字符分组为有意义的记号——这些记号可能是关键字、运算符、变量名等。
- en: The tokens are then assembled into chains and examined to verify whether their
    order and presence adhere to the syntax rules of C++ – a process called syntax
    analysis or parsing. This is typically the stage where most of the error messages
    are generated, as it identifies syntactical issues.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，令牌会被组装成链并进行检查，以验证它们的顺序和存在是否符合C++的语法规则——这一过程称为语法分析或解析。通常，这是生成大多数错误信息的阶段，因为它识别了语法问题。
- en: Lastly, the compiler carries out semantic analysis. In this phase, the compiler
    checks whether the statements in the file are logically sound. For instance, it
    ensures that all type correctness checks are met (you cannot assign an integer
    to a string variable). This analysis makes sure the program makes sense within
    the rules of the programming language.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编译器进行语义分析。在这个阶段，编译器检查文件中的语句是否在逻辑上是合理的。例如，它确保所有类型正确性检查都已满足（你不能将整数赋值给字符串变量）。这一分析确保程序在编程语言的规则范围内是合乎逻辑的。
- en: The **assembly** phase is essentially a translation of these tokens into CPU-specific
    instructions based on the available instruction set for the platform. Some compilers
    actually generate an assembly output file, which is subsequently passed to a dedicated
    assembler program. This program produces the machine code that the CPU can execute.
    Other compilers produce this machine code directly in memory. Typically, such
    compilers also provide an option to generate a textual output of human-readable
    assembly code. However, just because this code can be read doesn’t necessarily
    mean it’s easy to understand or beneficial to do so.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编**阶段本质上是将这些令牌翻译成基于平台可用指令集的CPU特定指令。有些编译器实际上生成汇出文件，然后传递给专门的汇编程序。该程序生成CPU可以执行的机器代码。其他编译器直接在内存中生成机器代码。通常，这些编译器还提供生成可供人类阅读的汇编代码的选项。然而，尽管这些代码是可以阅读的，但并不意味着它们容易理解或值得这么做。'
- en: '**Optimization** is not confined to a single step in the compilation process
    but occurs incrementally at each stage. There is, however, a distinct phase after
    the initial assembly is produced, which focuses on minimizing register usage and
    eliminating redundant code.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化**并不仅仅局限于编译过程中的某一个步骤，而是在每个阶段逐步进行的。然而，在初步汇编生成后，有一个独立的阶段，专注于最小化寄存器使用并消除冗余代码。'
- en: An interesting and noteworthy optimization technique is inline expansion or
    *inlining*. In this process, the compiler effectively “cuts” the body of a function
    and “pastes” it in place of its call. The C++ standard doesn’t explicitly define
    the circumstances under which this occurs – it is implementation dependent. Inline
    expansion can enhance execution speed and reduce memory usage, but it also poses
    significant drawbacks for debugging, as the executed code no longer corresponds
    to the original line in the source code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣且值得注意的优化技术是内联展开或*内联*。在这个过程中，编译器有效地将函数体“剪切”并将其“粘贴”到函数调用的位置。C++标准并没有明确定义何时进行这种操作——它是依赖于实现的。内联展开可以提高执行速度并减少内存使用，但它也会对调试产生重大影响，因为执行的代码不再与源代码中的原始行对应。
- en: The **code emission** phase involves writing the optimized machine code into
    an *object file* in a format that aligns with the target platform’s specifications.
    However, this *object file* isn’t ready for execution just yet – it needs to be
    passed to the next tool in the chain, the linker. The linker’s job is to appropriately
    relocate the sections of our *object file* and resolve references to external
    symbols, effectively preparing the file for execution. This step marks the transformation
    from the **American Standard Code for Information Interchange** (**ASCII**) source
    code into *binary executable files* that can be directly processed by a CPU.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码生成**阶段涉及将优化后的机器代码写入一个与目标平台规范对齐的*目标文件*中。然而，这个*目标文件*尚未准备好执行——它需要传递给链中的下一个工具：链接器。链接器的工作是适当地重新定位我们的*目标文件*的各个部分，并解决对外部符号的引用，有效地为文件的执行做准备。此步骤标志着**美国信息交换标准代码**（**ASCII**）源代码转化为*二进制可执行文件*，这些文件可以直接由CPU处理。'
- en: Each of these stages is significant and can be configured to meet our specific
    needs. Let’s look at how we can manage this process with CMake.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些阶段每个都非常重要，并且可以配置以满足我们的特定需求。让我们看看如何使用CMake来管理这个过程。
- en: Initial configuration
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始配置
- en: 'CMake provides several commands that can affect each stage of the compilation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了多个命令，可以影响编译过程中的每个阶段。
- en: '`target_compile_features()`: This requires a compiler with specific features
    to compile this target.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_compile_features()`: 这需要一个具有特定功能的编译器来编译此目标。'
- en: '`target_sources()`: This adds sources to an already defined target.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_sources()`: 该命令将源文件添加到已定义的目标中。'
- en: '`target_include_directories()`: This sets up the preprocessor *include paths*.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_include_directories()`: 该命令设置预处理器 *包含路径*。'
- en: '`target_compile_definitions()`: The sets up preprocessor definitions.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_compile_definitions()`: 该命令设置预处理器定义。'
- en: '`target_compile_options()`: This sets compiler-specific command-line options.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_compile_options()`: 该命令设置编译器特定的命令行选项。'
- en: '`target_precompile_headers()`: This sets external header files to be optimized
    with precompilation.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_precompile_headers()`: 该命令设置外部头文件以便进行预编译优化。'
- en: 'Each of these commands accepts similar arguments in the following format:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令接受类似格式的参数：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means that properties set with this command propagate through transitive
    usage requirements, as discussed in *Chapter 5*, *Working with Targets,* in the
    *What are transitive usage requirements?* section and can be utilized for both
    executables and libraries. Also, it’s worth noting that all these commands support
    generator expressions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着使用该命令设置的属性通过传递的使用要求传播，如 *第5章*，*与目标一起工作* 中的 *什么是传递使用要求？* 部分所讨论的，可以用于可执行文件和库。另外，值得注意的是，所有这些命令都支持生成器表达式。
- en: Requiring specific features from the compiler
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要从编译器中获取特定的功能
- en: As discussed in the *Checking for supported compiler features* section in *Chapter
    4*, *Setting Up Your First CMake Project*, it’s crucial to anticipate issues and
    aim to provide your software’s users with a clear message when something goes
    wrong – for instance, when an available compiler, X, doesn’t provide a required
    feature, Y. This approach is far more user friendly than having users decipher
    the errors produced by an incompatible toolchain they might be using. We don’t
    want users to misattribute the incompatibility issues to our code instead of their
    outdated environment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *第4章*，*设置你的第一个 CMake 项目* 中的 *检查支持的编译器功能* 部分所述，预见问题并确保在出现错误时给用户清晰的信息至关重要——例如，当一个可用的编译器
    X 不提供所需的功能 Y 时。这种方法比让用户解读不兼容工具链所产生的错误更为友好。我们不希望用户将不兼容问题归咎于我们的代码，而是他们过时的环境。
- en: 'You can use the following command to specify all the features that your target
    needs to build:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来指定目标构建所需的所有功能：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'CMake understands C++ standards and supported compiler features for these `compiler_ids`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 支持以下 `compiler_ids` 的 C++ 标准和编译器功能：
- en: '`AppleClang`: Apple Clang for Xcode versions 4.4+'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppleClang`: 用于 Xcode 版本 4.4+ 的 Apple Clang'
- en: '`Clang`: Clang Compiler versions 2.9+'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clang`: Clang 编译器版本 2.9+'
- en: '`GNU`: GNU Compiler versions 4.4+'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GNU`: GNU 编译器版本 4.4+'
- en: '`MSVC`: Microsoft Visual Studio versions 2010+'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSVC`: Microsoft Visual Studio 版本 2010+'
- en: '`SunPro`: Oracle Solaris Studio versions 12.4+'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SunPro`: Oracle Solaris Studio 版本 12.4+'
- en: '`Intel`: Intel Compiler versions 12.1+'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intel`: Intel 编译器版本 12.1+'
- en: 'There are over 60 features supported by CMake, and you’ll find a full list
    in the official documentation, on the page explaining the `CMAKE_CXX_KNOWN_FEATURES`
    variable. However, unless you’re after something very specific, I recommend picking
    a high-level meta feature indicating the general C++ standard:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 支持超过 60 个功能，你可以在官方文档中找到完整列表，详见解释 `CMAKE_CXX_KNOWN_FEATURES` 变量的页面。不过，除非你在寻找某个非常具体的功能，否则我建议选择一个表示一般
    C++ 标准的高级元功能：
- en: '`cxx_std_14`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cxx_std_14`'
- en: '`cxx_std_17`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cxx_std_17`'
- en: '`cxx_std_20`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cxx_std_20`'
- en: '`cxx_std_23`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cxx_std_23`'
- en: '`cxx_std_26`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cxx_std_26`'
- en: 'Look at the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下示例：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is essentially equal to `set(CMAKE_CXX_STANDARD 26)` with `set(CMAKE_CXX_STANDARD_REQUIRED
    ON)` introduced in *Chapter 4*, *Setting Up Your First CMake Project*. However,
    the difference is that `target_compile_features()` works on a per-target basis
    and not globally for the project, which may be cumbersome if you need to add it
    for all targets in the project.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上等同于在 *第4章*，*设置你的第一个 CMake 项目* 中引入的 `set(CMAKE_CXX_STANDARD 26)` 和 `set(CMAKE_CXX_STANDARD_REQUIRED
    ON)`。然而，区别在于 `target_compile_features()` 是按目标处理的，而不是为整个项目全局处理，这在你需要为项目中的所有目标添加时可能会显得麻烦。
- en: Find more details on CMake’s *supported compilers* in the official manual (See
    the *Further reading* section for the URL).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方手册中查看 CMake 的 *支持的编译器* 的更多详细信息（请参见 *进一步阅读* 部分获取网址）。
- en: Managing sources for targets
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理目标的源文件
- en: We already know how to tell CMake which source files constitute a single target,
    whether it’s an executable or a library. We do this by supplying a list of files
    when using the `add_executable()` or `add_library()` commands.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何告诉CMake哪些源文件构成一个目标，无论它是可执行文件还是库。我们通过在使用`add_executable()`或`add_library()`命令时提供一个文件列表来做到这一点。
- en: 'As your solution expands, the list of files for each target also grows. This
    can lead to some rather lengthy `add_...()` commands. How do we deal with that?
    A tempting approach might be to utilize the `file()` command in `GLOB` mode, which
    can gather all files from subdirectories and store them in a variable. We could
    pass it as an argument to the target declaration and not bother with the file
    list again:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的解决方案扩展，每个目标的文件列表也在增长。这可能会导致一些相当冗长的`add_...()`命令。我们该如何处理呢？一种诱人的方法可能是使用`file()`命令的`GLOB`模式，这样可以从子目录中收集所有文件并将它们存储在一个变量中。我们可以将其作为参数传递给目标声明，再也不需要关心文件列表了：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, this method is not recommended. Let’s understand why. CMake generates
    buildsystems based on the changes in the listfiles. So, if no changes are detected,
    your builds might fail without any warning (a developer’s nightmare). Besides,
    omitting all sources in the target declaration can disrupt code inspection in
    IDEs like CLion, which knows how to parse certain CMake commands to understand
    your project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法并不推荐。让我们理解一下为什么。CMake根据列表文件中的更改生成构建系统。所以，如果没有检测到任何更改，您的构建可能会在没有任何警告的情况下失败（这是开发者的噩梦）。此外，省略目标声明中的所有源代码可能会破坏像CLion这样的IDE中的代码检查，因为它知道如何解析某些CMake命令来理解您的项目。
- en: 'Using variables in target declarations is not advisable for another reason:
    it creates a layer of indirection, causing the developers to have to unpack the
    target definition when reading the project. To follow this advice, we’re faced
    with another question: how do we conditionally add source files? This is a common
    scenario when dealing with platform-specific implementation files, such as `gui_linux.cpp`
    and `gui_windows.cpp`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标声明中使用变量是不建议的，原因是：它会创建一个间接层，导致开发者在阅读项目时必须解包目标定义。为了遵循这个建议，我们又面临另一个问题：如何有条件地添加源文件？这在处理特定平台的实现文件时是一个常见场景，例如`gui_linux.cpp`和`gui_windows.cpp`。
- en: 'The `target_sources()` command allows us to append source files to a previously
    created target:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_sources()`命令允许我们将源文件附加到之前创建的目标：'
- en: '**ch07/01-sources/CMakeLists.txt**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/01-sources/CMakeLists.txt**'
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This way, each platform gets its own set of compatible files. That’s great,
    but what about long lists of sources? Well, we’ll just have to accept that some
    things aren’t perfect just yet and keep adding them manually. If you are struggling
    with a really long list, you’re probably doing something wrong with the structure
    of your project: perhaps it could use partitioning sources into libraries.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个平台都会得到一组兼容的文件。这很好，但如果源文件列表很长怎么办？嗯，我们只能接受某些事情尚不完美，并继续手动添加它们。如果您正在与一个非常长的列表作斗争，那么您很可能在项目结构上做错了什么：也许可以考虑将源文件划分为库。
- en: Now that we’ve covered the essentials of compilation, let’s delve into the first
    step – preprocessing. Like all things in computer science, the devil is in the
    details.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了编译的基本知识，让我们深入了解第一步——预处理。像所有计算机科学的事物一样，细节决定成败。
- en: Configuring the preprocessor
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置预处理器
- en: The preprocessor plays a huge role in the process of building. Maybe this is
    a little surprising, considering its functionality appears rather straightforward
    and limited. In the following sections, we’ll cover providing paths to included
    files and using the preprocessor definitions. We’ll also explain how we can use
    CMake to configure included headers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器在构建过程中扮演着巨大的角色。也许这有点令人惊讶，因为它的功能看起来相当直接和有限。在接下来的章节中，我们将介绍如何提供包含文件的路径和使用预处理器定义。我们还将解释如何使用CMake配置包含的头文件。
- en: Providing paths to included files
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供包含文件的路径
- en: 'The most basic feature of the preprocessor is the ability to include `.h` and
    `.hpp` header files with the `#include` directive, which exists in two forms:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器的最基本功能是能够使用`#include`指令包含`.h`和`.hpp`头文件，这有两种形式：
- en: 'Angle-bracket form: `#include <path-spec>`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尖括号形式：`#include <path-spec>`
- en: 'Quoted form: `#include "path-spec"`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引号形式：`#include "path-spec"`
- en: As we know, the preprocessor will replace these directives with the contents
    of the file specified in `path-spec`. Finding these files may be a challenge.
    Which directories should be searched, and in what order? Unfortunately, the C++
    standard doesn’t specify that exactly. We have to check the manual for the compiler
    in use.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，预处理器将把这些指令替换为 `path-spec` 中指定文件的内容。查找这些文件可能会很有挑战性。应该搜索哪些目录，以及按什么顺序搜索？不幸的是，C++
    标准并未明确规定这一点。我们必须查看所使用编译器的手册。
- en: Typically, the angle-bracket form will check standard *include directories*,
    which include the directories where standard C++ library and standard C library
    header files are stored in the system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，尖括号形式将检查标准的 *包含目录*，这些目录包括系统中存储标准 C++ 库和标准 C 库头文件的目录。
- en: The quoted form starts by searching for the included file in the directory of
    the current file and then checks the directories for the angle-bracket form.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 引号形式首先会在当前文件的目录中搜索被包含的文件，然后再检查尖括号形式的目录。
- en: 'CMake provides a command to manipulate paths being searched for the included
    files:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了一条命令来操作搜索包含文件的路径：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This allows us to add custom paths that we want the compiler to scan. CMake
    will add them to compiler invocations in the generated buildsystem. They will
    be provided with a flag appropriate for the specific compiler (usually, it’s `-I`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够添加希望编译器扫描的自定义路径。CMake 将在生成的构建系统中将它们添加到编译器调用中，并为特定编译器提供适当的标志（通常是 `-I`）。
- en: The `target_include_directories()` command modifies the target’s `INCLUDE_DIRECTORIES`
    property by appending or prepending directories to it, based on whether the `AFTER`
    or `BEFORE` keyword is used. However, it’s still up to the compiler to decide
    whether the directories provided here will be checked before or after the default
    ones (usually, it’s before).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_include_directories()` 命令通过在目标的 `INCLUDE_DIRECTORIES` 属性中附加或预附加目录来修改它，具体取决于是否使用
    `AFTER` 或 `BEFORE` 关键字。然而，是否在默认目录之前或之后检查这些目录，仍然由编译器决定（通常是在之前）。'
- en: The `SYSTEM` keyword signifies to the compiler that the given directories should
    be treated as standard system directories (to be used with the angle-bracket form).
    For many compilers, these directories are passed with the `-isystem` flag.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYSTEM` 关键字表示编译器应将给定的目录视为标准系统目录（用于尖括号形式）。对于许多编译器，这些目录是通过 `-isystem` 标志传递的。'
- en: Preprocessor definitions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理器定义
- en: 'Recall the preprocessor’s `#define` and `#if`, `#elif`, and `#endif` directives
    mentioned earlier when discussing the stages of compilation. Let’s examine the
    following example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下之前讨论的编译阶段中的预处理器 `#define` 和 `#if`、`#elif` 以及 `#endif` 指令。让我们看一下以下示例：
- en: '**ch07/02-definitions/definitions.cpp**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/02-definitions/definitions.cpp**'
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As it stands, this example accomplishes nothing, as neither `ABC` nor `DEF`
    is defined (`DEF` would default to `0` in this example). We can easily change
    that by adding two lines at the top of this code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，这个例子没有任何效果，因为 `ABC` 和 `DEF` 都没有被定义（在这个例子中，`DEF` 会默认为 `0`）。我们可以通过在代码的顶部添加两行来轻松改变这一点：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After compiling and executing this code, we can see both messages in the console:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行此代码后，我们可以在控制台中看到两条消息：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This might seem simple enough, but what if we want to condition these sections
    based on external factors, such as an OS, architecture, or something else? The
    good news is that you can pass values from CMake to a C++ compiler, and it’s not
    complicated at all.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎足够简单，但如果我们想根据外部因素（如操作系统、架构或其他因素）来条件化这些部分怎么办？好消息是，你可以将值从 CMake 传递给 C++
    编译器，而且这并不复杂。
- en: 'The `target_compile_definitions()` command will suffice:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_compile_definitions()` 命令就足够了：'
- en: '**ch07/02-definitions/CMakeLists.txt**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/02-definitions/CMakeLists.txt**'
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code will behave exactly like the two `#define` statements, but
    we have the flexibility to use CMake’s variables and generator expressions, and
    we can place the command in a conditional block.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将与两个 `#define` 语句的行为完全相同，但我们有灵活性使用 CMake 的变量和生成器表达式，并且可以将命令放入条件块中。
- en: 'Traditionally, these definitions are passed to the compiler with the `-D` flag
    (for example, `-DFOO=1`) and some programmers continue to use this flag in this
    command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，这些定义通过 `-D` 标志传递给编译器（例如，`-DFOO=1`），有些程序员仍然在这个命令中继续使用这个标志：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'CMake recognizes this and will automatically remove any leading `-D` flags.
    It will also disregard empty strings, so the following command is perfectly valid:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 能识别这一点，并会自动移除任何前导的 `-D` 标志。它还会忽略空字符串，因此以下命令是完全有效的：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, `-D` is a separate argument that becomes an empty string after
    removal and is subsequently ignored, thereby ensuring correct behavior.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`-D` 是一个独立的参数，移除后会变成空字符串，并随后被忽略，从而确保行为正确。
- en: Avoid accessing private class fields in your unit tests
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免在单元测试中访问私有类字段
- en: 'Some online resources recommend using a combination of specific `-D` definitions
    with `#ifdef/ifndef` directives for the purposes of unit testing. The most straightforward
    application of this approach is to enclose the `public` access specifier in conditional
    inclusions, effectively making all fields public when `UNIT_TEST` is defined (class
    fields are private by default):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在线资源建议结合使用特定的 `-D` 定义与 `#ifdef/ifndef` 指令，用于单元测试。此方法最直接的应用是将 `public` 访问控制符包含在条件包含中，当
    `UNIT_TEST` 被定义时，使所有字段都变为公共（默认情况下，类字段是私有的）：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While this technique offers convenience (allowing tests to directly access private
    members), it does not result in clean code. Ideally, unit tests should focus on
    verifying the functionality of methods within the public interface, treating the
    underlying implementation as a black box. Consequently, I suggest using this approach
    only as a last resort.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技术提供了便利（允许测试直接访问私有成员），但它并不会产生干净的代码。理想情况下，单元测试应该专注于验证公共接口内方法的功能，将底层实现视为黑盒。因此，我建议仅在不得已时使用这种方法。
- en: Using git commit to track a compiled version
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Git 提交跟踪已编译版本
- en: 'Let’s think about use cases that benefit from knowing details about the environment
    or filesystem. A prime example in professional settings might involve passing
    the revision or commit `SHA` used to build the binary. This could be achieved
    like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一些可以从了解环境或文件系统细节中受益的用例。一个典型的例子可能是在专业环境中，传递用于构建二进制文件的修订或提交 `SHA`。可以通过以下方式实现：
- en: '**ch07/03-git/CMakeLists.txt**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/03-git/CMakeLists.txt**'
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The SHA could then be utilized in our application as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，SHA 可以在我们的应用中按如下方式使用：
- en: '**ch07/03-git/print_commit.cpp**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/03-git/print_commit.cpp**'
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Of course, the preceding code requires the user to have Git installed and accessible
    in their `PATH`. This feature is particularly useful when the programs running
    on production servers are the result of a continuous integration/deployment pipeline.
    If there’s an issue with our software, we can quickly check which exact Git commit
    was used to build the faulty product.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的代码要求用户安装并在其 `PATH` 中能够访问 Git。这个功能在生产服务器上运行的程序是通过持续集成/部署流水线构建的情况下特别有用。如果我们的软件出现问题，可以迅速检查到底是哪个
    Git 提交被用来构建有问题的产品。
- en: Keeping track of an exact commit is extremely beneficial for debugging purposes.
    It’s straightforward to pass a single variable to C++ code, but how would we handle
    the scenario where dozens of variables need to be passed to our headers?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪确切的提交对于调试非常有帮助。将单个变量传递给 C++ 代码非常简单，但当需要将几十个变量传递给头文件时，我们该如何处理呢？
- en: Configuring the headers
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置头文件
- en: Passing definitions through `target_compile_definitions()` can become tedious
    with numerous variables. Wouldn’t it be easier to provide a header file with placeholders
    referencing these variables, and allow CMake to fill them in? Absolutely!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `target_compile_definitions()` 传递定义可能会变得繁琐，尤其是当变量众多时。难道提供一个带有占位符的头文件，引用这些变量，并让
    CMake 来填充它们，不更简单吗？绝对可以！
- en: 'CMake’s `configure_file(<input> <output>)` command enables you to generate
    new files from templates, like the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 的 `configure_file(<input> <output>)` 命令允许你从模板生成新文件，示例如下：
- en: '**ch07/04-configure/configure.h.in**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/04-configure/configure.h.in**'
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can utilize this command as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式使用此命令：
- en: '**ch07/04-configure/CMakeLists.txt**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/04-configure/CMakeLists.txt**'
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'CMake then generates an output file like so:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 然后会生成一个类似以下的输出文件：
- en: '**ch07/04-configure/<build_tree>/configured/configure.h**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/04-configure/<build_tree>/configured/configure.h**'
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the `@VAR@` and `${VAR}` variable placeholders were substituted
    with the values from the CMake listfile. Additionally, `#cmakedefine` was replaced
    with `#define` for defined variables and `/* #undef VAR */` for undefined ones.
    If you require an explicit `#define 1` or `#define 0` for `#if` blocks, use `#cmakedefine01`
    instead.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，`@VAR@` 和 `${VAR}` 变量占位符已被 CMake 列表文件中的值替换。此外，`#cmakedefine` 被已定义变量的 `#define`
    和未定义变量的 `/* #undef VAR */` 所取代。如果你需要显式的 `#define 1` 或 `#define 0` 用于 `#if` 块，请改用
    `#cmakedefine01`。'
- en: 'You can incorporate this configured header in your application by simply including
    it in your implementation file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地在实现文件中包含这个配置好的头文件，将其集成到你的应用程序中：
- en: '**ch07/04-configure/configure.cpp**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/04-configure/configure.cpp**'
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By adding the binary tree to our *include paths* with the `target_include_directories()`
    command, we can compile the example and receive output populated from CMake:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将二叉树添加到我们的*包含路径*中，并使用 `target_include_directories()` 命令，我们可以编译示例，并接收来自 CMake
    的输出：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `configure_file()` command also includes a range of formatting and file-permission
    options, which we won’t delve into here due to length constraints. If you’re interested,
    you can refer to the online documentation for further details (see the *Further
    reading* section in this chapter).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure_file()` 命令还包括一系列格式化和文件权限选项，由于篇幅限制，我们不会在此深入探讨。如果你感兴趣，可以参考在线文档获取更多细节（请参阅本章的
    *进一步阅读* 部分）。'
- en: Having prepared a complete compilation of our headers and source files, let’s
    discuss how the output code is shaped during the subsequent steps. While we don’t
    have direct influence over the linguistic analysis or assembling (as these steps
    adhere to strict standards), we can manipulate the configuration of the optimizer.
    Let’s explore how this can impact the end result.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好完整的头文件和源文件编译后，让我们讨论在后续步骤中输出代码是如何形成的。尽管我们无法直接影响语言分析或汇编（因为这些步骤遵循严格的标准），但我们可以调整优化器的配置。让我们来探索一下这种配置如何影响最终结果。
- en: Configuring the optimizer
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置优化器
- en: The optimizer will analyze the output of previous stages and use a multitude
    of tactics, which programmers wouldn’t use directly, as they don’t adhere to clean-code
    principles. But that’s fine – the optimizer’s essential role is to enhance code
    performance, striving for low CPU usage, minimal register usage, and reduced memory
    footprint. As the optimizer traverses the source code, it heavily morphs it into
    an almost unrecognizable form, tailored specifically to the target CPU.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器将分析前一阶段的输出，并使用多种策略，程序员通常不会直接使用这些策略，因为它们不符合干净代码原则。但这没关系——优化器的核心作用是提高代码性能，追求低
    CPU 使用率、最小化寄存器使用和减少内存占用。当优化器遍历源代码时，它会将代码重构为几乎无法辨认的形式，专门为目标 CPU 量身定制。
- en: The optimizer will not only decide which functions could be removed or compacted;
    it will also move code around or even significantly duplicate it! If it can definitively
    ascertain that certain lines of code are redundant, it will wipe them out from
    the middle of an important function (and you won’t even notice). It recycles memory
    so that numerous variables can inhabit the same slot at different times. It can
    even remodel your control structures into something entirely different if that
    translates into shaving off a few cycles here and there.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器不仅会决定哪些函数可以删除或压缩，它还会重新排列代码，甚至大规模复制代码！如果它能够确定某些代码行是多余的，它会将这些行从重要函数中间删除（你甚至不会注意到）。它会回收内存，让多个变量在不同时间占用相同的位置。它甚至可以将你的控制结构重塑成完全不同的形式，如果这样做能节省几次
    CPU 周期的话。
- en: 'If a programmer were to manually apply the aforementioned techniques to source
    code, it would transmogrify it into an awful, unreadable mess, difficult to write
    and reason about. However, when applied by compilers, these techniques are advantageous
    as compilers strictly follow the provided instructions. The optimizer is a relentless
    beast that serves one purpose: to accelerate execution speed, regardless of how
    distorted the output becomes. Such output may contain some debugging information
    if we are running it in our test environment, or it may not, in order to make
    it difficult for unauthorized people to tamper with it.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员手动将上述技术应用到源代码中，它将把代码变成一团糟，既难写又难理解。然而，当编译器应用这些技术时，它们是有益的，因为编译器严格遵循给定的指令。优化器是一只无情的野兽，服务的唯一目的就是加速执行速度，无论输出变得多么扭曲。这样的输出可能包含一些调试信息，如果我们在测试环境中运行它，或者可能不包含调试信息，以防止未授权的人篡改。
- en: Every compiler has its own unique tricks up its sleeve, consistent with the
    platform it supports and the philosophy it follows. We’ll take a look at the most
    common ones, available in GNU GCC and LLVM Clang, to gain an understanding of
    what is practical and achievable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编译器都有自己独特的技巧，这与它支持的平台和所遵循的哲学一致。我们将查看 GNU GCC 和 LLVM Clang 中最常见的一些，以便了解哪些是实际可行的。
- en: Here’s the thing – many compilers won’t enable any optimization by default (GCC
    included). This is okay in some cases but not so much in others. Why go slow when
    you can go fast? To amend this, we can use the `target_compile_options()` command
    and explicitly state our expectations from the compiler.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 事情是这样的——许多编译器默认不会启用任何优化（包括 GCC）。在某些情况下这样没问题，但在其他情况下就不行了。为什么要慢呢，当你可以更快？为了解决这个问题，我们可以使用
    `target_compile_options()` 命令，明确表达我们对编译器的期望。
- en: 'The syntax of this command mirrors others in this chapter:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的语法与本章中的其他命令类似：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We provide command-line options to use while building the target and we also
    specify the propagation keyword. When executed, CMake appends the given options
    to the appropriate `COMPILE_OPTIONS` variable of the target. The optional `BEFORE`
    keyword may be used if we want to prepend them instead. The order can be significant
    in some scenarios, so it’s beneficial to have a choice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供命令行选项，在构建目标时使用，并且还指定了传播关键字。当执行时，CMake 会将给定的选项附加到目标的适当 `COMPILE_OPTIONS`
    变量中。如果我们希望将它们放在前面，可以使用可选的 `BEFORE` 关键字。在某些场景中，顺序可能很重要，因此能够选择顺序是有益的。
- en: Note that `target_compile_options()` is a general command. It can also be used
    to provide other arguments to compiler-like `-D` definitions, for which CMake
    offers the `target_compile_definition()` command as well. It is always advisable
    to use the most specialized CMake commands wherever possible, as they are guaranteed
    to work the same way across all the supported compilers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`target_compile_options()` 是一个通用命令。它也可以用于为编译器提供其他参数，例如 `-D` 定义，CMake 还提供了
    `target_compile_definition()` 命令。建议尽可能使用最专业的 CMake 命令，因为它们在所有支持的编译器中保证以相同的方式工作。
- en: Time to discuss the details. The subsequent sections will introduce various
    kinds of optimizations that you can enable in most compilers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论细节的时候了。接下来的部分将介绍可以在大多数编译器中启用的各种优化。
- en: General level
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般级别
- en: All the different behaviors of the optimizer can be configured in depth by specific
    flags that we can pass as *compile options*. Getting to know all of them is time
    consuming and requires a lot of knowledge about the internal workings of compilers,
    processors, and memory. What can we do if we just want the best possible scenario
    that works well in most cases? We can aim for a general solution – an optimization-level
    specifier.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器的所有不同行为可以通过特定的标志来深入配置，这些标志我们可以作为 *编译选项* 传递。如果我们只是想要一个在大多数情况下都能很好工作的最佳解决方案，该怎么办？我们可以选择一个通用的解决方案——一个优化级别说明符。
- en: Most compilers offer four basic levels of optimization, from `0` to `3`. We
    specify them with the `-O<level>` option. `-O0` means *no optimization* and, usually,
    it’s the default level for compilers. On the other hand, `-O2` is considered a
    *full optimization*, one that generates highly optimized code but at the cost
    of the slowest compilation time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译器提供四个基本的优化级别，从 `0` 到 `3`。我们通过 `-O<level>` 选项来指定它们。`-O0` 意味着 *没有优化*，通常这是编译器的默认级别。另一方面，`-O2`
    被认为是 *完全优化*，它生成高度优化的代码，但代价是最慢的编译时间。
- en: There’s an in-between `-O1` level, which (depending on your needs) can be a
    good compromise – it enables a reasonable amount of optimization mechanisms without
    slowing the compilation too much.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个中间的 `-O1` 级别，这个级别（根据你的需求）可能是一个不错的折衷——它启用了合理的优化机制，同时不会过多地减慢编译速度。
- en: Finally, we can reach for `-O3`, which is *full optimization*, like `-O2`, but
    with a more aggressive approach to subprogram inlining and loop vectorization.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以选择 `-O3`，这是*完全优化*，类似于 `-O2`，但采用更激进的子程序内联和循环向量化方法。
- en: There are also some variants of the optimization that will optimize for the
    size (not necessarily the speed) of the produced file – `-Os`. There is a super-aggressive
    optimization, `-Ofast`, which is an `-O3` optimization that doesn’t strictly comply
    with C++ standards. The most obvious difference is the usage of `-ffast-math`
    and `-ffinite-math` flags, meaning that if your program is about precise calculations
    (as most are), you might want to avoid it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些优化的变体，它们优化的是生成文件的大小（不一定是速度）——`-Os`。有一种超激进的优化 `-Ofast`，它是 `-O3` 优化，但不严格遵守
    C++ 标准。最明显的区别是使用了 `-ffast-math` 和 `-ffinite-math` 标志，这意味着如果你的程序涉及精确计算（大多数程序都是），你可能希望避免使用它。
- en: 'CMake knows that not all compilers are made equal, and for that reason, it
    standardizes the experience for developers by providing some default flags for
    compilers. They are stored in system-wide (not target-specific) variables for
    the language used (`CXX` for C++) and the build configuration (`DEBUG` or `RELEASE`):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 知道并非所有编译器都是一样的，因此它通过为编译器提供一些默认标志来标准化开发者的体验。这些标志存储在系统范围内（而非特定目标）的变量中，用于所使用的语言（`CXX`
    用于 C++）和构建配置（`DEBUG` 或 `RELEASE`）：
- en: '`CMAKE_CXX_FLAGS_DEBUG` equals `-g`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CXX_FLAGS_DEBUG` 等于 `-g`'
- en: '`CMAKE_CXX_FLAGS_RELEASE` equals `-O3 -DNDEBUG`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CXX_FLAGS_RELEASE` 等于 `-O3 -DNDEBUG`'
- en: As you can see, the debug configuration doesn’t enable any optimizations and
    the release configuration goes straight for `O3`. If you like, you can change
    them directly with the `set()` command or just add a target compilation option,
    which will override this default behavior. The other two flags (`-g,` `-DNDEBUG`)
    are related to debugging – we’ll discuss them in the *Providing information for
    the debugger* section of this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调试配置不会启用任何优化，而发布配置则直接使用 `O3`。如果你愿意，你可以通过 `set()` 命令直接更改它们，或者只需添加目标编译选项，这将覆盖默认行为。另两个标志（`-g,`
    `-DNDEBUG`）与调试相关——我们将在本章的 *为调试器提供信息* 部分讨论它们。
- en: Variables such as `CMAKE_<LANG>_FLAGS_<CONFIG>` are global – they apply to all
    targets. It is recommended to configure your targets through properties and commands,
    such as `target_compile_options()`, rather than relying on global variables. This
    way, you can control your targets at higher granularity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `CMAKE_<LANG>_FLAGS_<CONFIG>` 这样的变量是全局的——它们适用于所有目标。建议通过属性和命令（如 `target_compile_options()`）来配置目标，而不是依赖于全局变量。这样，你可以更细粒度地控制你的目标。
- en: 'By choosing an optimization level with `-O<level>`, we indirectly set a long
    list of flags, each controlling a specific optimization behavior. We can then
    fine-tune the optimization by appending more flags, like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择优化级别 `-O<level>`，我们间接设置了一长串标志，每个标志控制着特定的优化行为。然后，我们可以通过追加更多标志来微调优化，如下所示：
- en: 'Enable them with an `-f` option: `-finline-functions`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-f` 选项启用它们：`-finline-functions`。
- en: 'Disable them with an `-fno` option: `-fno-inline-functions`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-fno` 选项禁用它们：`-fno-inline-functions`。
- en: Some of these flags are worth understanding better as they will often impact
    how your program works and how you can debug it. Let’s have a look.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志中的一些值得更好地理解，因为它们会影响你的程序的运行方式以及你如何调试它。让我们来看看。
- en: Function inlining
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数内联
- en: 'As you might recall, compilers can be encouraged to inline some functions,
    either by *defining* a function inside a class *declaration* block or by explicitly
    using the `inline` keyword:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的那样，编译器可以通过*在类的*声明*块中定义*一个函数，或通过显式使用 `inline` 关键字来鼓励内联一些函数：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The decision to inline a function ultimately rests with the compiler. If inlining
    is enabled and the function is used in a singular place (or a relatively small
    function used in a few places), inlining will most likely occur.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 内联一个函数的决定最终由编译器做出。如果启用了内联，并且该函数仅在一个位置使用（或是一个在少数地方使用的相对较小的函数），那么内联很可能会发生。
- en: Function inlining is an intriguing optimization technique. It operates by extracting
    the code from the targeted function and embedding it in all the locations where
    the function was called. This process replaces the original call and conserves
    precious CPU cycles.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内联是一种有趣的优化技术。它通过将目标函数的代码提取出来并嵌入到所有调用该函数的位置来工作。这个过程替换了原始的调用，并节省了宝贵的 CPU 周期。
- en: 'Let’s consider the following example using the class we just defined:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下使用我们刚刚定义的类的示例：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Without inlining, the code would execute in the `main()` frame until a method
    call. Then, it would create a new frame for `im_inlined()`, execute in a separate
    scope, and return to the `main()` frame. The same would happen for the `me_too()`
    method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有内联，代码将在`main()`框架中执行，直到方法调用为止。然后，它会为`im_inlined()`创建一个新框架，在一个单独的作用域中执行，并返回到`main()`框架。`me_too()`方法也会发生同样的情况。
- en: 'However, when inlining takes place, the compiler will replace the calls, like
    so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当发生内联时，编译器会替换调用，类似这样：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This isn’t an exact representation because inlining happens at the level of
    assembly or machine code (and not the source code), but it does provide a general
    idea.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是精确的表示，因为内联发生在汇编或机器代码的层面（而非源代码层面），但它提供了一个大致的概念。
- en: The compiler employs inlining to conserve time. It bypasses the creation and
    teardown of a new call frame and the need to look up the address of the next instruction
    to execute (and return to) and enhances instruction caching as they are in close
    proximity.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用内联来节省时间。它跳过了创建和销毁新调用框架的过程，避免了查找下一个要执行的指令地址（并返回）的需求，并且增强了指令缓存，因为它们彼此非常接近。
- en: However, inlining does come with some significant side effects. If a function
    is used more than once, it must be copied to all locations, resulting in a larger
    file size and increased memory usage. While this may not be as critical today
    as it once was, it remains relevant, especially when developing software for low-end
    devices with limited RAM.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内联确实带来了一些显著的副作用。如果一个函数被多次使用，它必须复制到所有调用位置，从而导致文件大小增大和内存使用增加。尽管今天这可能不像以前那么关键，但它仍然相关，尤其是在为低端设备（内存有限）开发软件时。
- en: Moreover, inlining critically impacts debugging. Inlined code is no longer at
    the original line number, making tracking more difficult, or sometimes impossible.
    This is why a debugger breakpoint placed in a function that was inlined, never
    gets hit (even though the code is still executed somehow). To circumvent this
    problem, you need to disable inlining for debug builds (at the cost of not testing
    the exact release build version).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，内联对调试产生了重大影响。内联代码不再出现在原始的行号位置，这使得追踪变得更加困难，有时甚至变得不可能。这就是为什么在内联的函数上设置调试断点时，永远不会被触发（即使代码仍然以某种方式被执行）。为了解决这个问题，你需要在调试版本中禁用内联（这意味着无法测试完全相同的发布版本）。
- en: 'We can do that by specifying the `-O0` (o-zero) level for the target or directly
    addressing the flags responsible for inlining:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为目标指定`-O0`（o-zero）级别，或直接修改负责内联的标志来实现：
- en: '`-finline-functions-called-once`: This is only for GCC.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-finline-functions-called-once`：仅适用于 GCC。'
- en: '`-finline-functions`: This is for both Clang and GCC.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-finline-functions`：适用于 Clang 和 GCC。'
- en: '`-finline-hint-functions`: This is only for Clang.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-finline-hint-functions`：仅适用于 Clang。'
- en: Inlining can be explicitly disabled with `-fno-inline-...`, however, for detailed
    information, it’s advisable to refer to the documentation of your specific compiler
    version.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 内联可以通过`-fno-inline-...`显式禁用，但是，若要了解详细信息，建议查阅特定编译器版本的文档。
- en: Loop unrolling
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环展开
- en: Loop unrolling, also known as loop unwinding, is an optimization technique.
    This strategy aims to transform loops into a series of statements that accomplish
    the same result. Consequently, this approach exchanges the small size of the program
    for execution speed, as it eliminates the loop control instruction, pointer arithmetic,
    and end-of-loop checks.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 循环展开，也称为循环解开，是一种优化技术。该策略旨在将循环转换为一系列实现相同结果的语句。因此，这种方法将程序的小体积换成了执行速度，因为它消除了循环控制指令、指针运算和循环结束检查。
- en: 'Consider the following example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The previous code will be transformed into something like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将被转换为类似如下内容：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The outcome will be the same, but we no longer have to allocate the `i` variable,
    increment it, or compare it three times with a value of `3`. If we call `func()`
    enough times in the lifetime of the program, unrolling even such a short and small
    function will make a significant difference.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一样的，但我们不再需要分配 `i` 变量、递增它或将其与值 `3` 比较三次。如果在程序的生命周期内多次调用 `func()`，即使是展开如此短小的函数，也会产生显著的差异。
- en: However, it is important to understand two limiting factors. Firstly, loop unrolling
    is only effective if the compiler knows or can accurately estimate the number
    of iterations. Secondly, loop unrolling can lead to undesired consequences on
    modern CPUs, as an increased code size might hamper effective caching.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，理解两个限制因素是很重要的。首先，循环展开只有在编译器知道或能够准确估计迭代次数时才有效。其次，循环展开可能会对现代 CPU 产生不良影响，因为增加的代码大小可能会妨碍有效的缓存。
- en: 'Each compiler provides a slightly different version of this flag:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编译器提供的此标志的版本略有不同：
- en: '`-floop-unroll`: This is for GCC.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-floop-unroll`：这是用于 GCC 的选项。'
- en: '`-funroll-loops`: This is for Clang.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-funroll-loops`：这是用于 Clang 的选项。'
- en: If you’re uncertain, test extensively whether this flag is affecting your particular
    program and explicitly enable or disable it. Do note that on GCC, it is implicitly
    enabled with `-O3` as part of the implicitly enabled `-floop-unroll-and-jam` flag.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定，广泛测试此标志是否影响你特定的程序，并显式地启用或禁用它。请注意，在 GCC 中，它在 `-O3` 下隐式启用，作为隐式启用的 `-floop-unroll-and-jam`
    标志的一部分。
- en: Loop vectorization
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环向量化
- en: 'The mechanism known as **single instruction, multiple data** (**SIMD**) was
    developed in the early 1960s to achieve parallelism. As the name suggests, it
    is designed to carry out the same operation on multiple data simultaneously. Let’s
    look at this in practice through the following example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为**单指令多数据**（**SIMD**）的机制是在 1960 年代初期开发的，目的是实现并行性。顾名思义，它旨在同时对多个数据执行相同的操作。让我们通过以下示例来实际了解这一点：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Normally, such code would loop 128 times, but with a capable CPU, the code’s
    execution can be significantly accelerated by simultaneously calculating two or
    more array elements. This is possible due to the absence of dependency between
    consecutive elements and data overlap between arrays. Clever compilers can transform
    the preceding loop into something like this (which happens at the assembly level):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这样的代码会循环 128 次，但在具备能力的 CPU 上，通过同时计算两个或更多的数组元素，代码的执行可以显著加速。这是因为连续元素之间没有依赖关系，且数组之间的数据没有重叠。聪明的编译器可以将前面的循环转换为如下形式（这发生在汇编级别）：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'GCC will enable such automatic vectorization of loops at `-O3`. Clang enables
    it by default. Both compilers offer different flags to enable/disable vectorization
    in particular:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 在 `-O3` 下会启用这种自动循环向量化。Clang 默认启用它。两种编译器都提供不同的标志来启用/禁用特定的向量化：
- en: '`-ftree-vectorize -ftree-slp-vectorize`: This is for enabling vectorization
    in GCC.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ftree-vectorize -ftree-slp-vectorize`：这是用于启用 GCC 中向量化的选项。'
- en: '`-fno-vectorize -fno-slp-vectorize`: This is for disabling vectorization in
    Clang.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fno-vectorize -fno-slp-vectorize`：这是用于在 Clang 中禁用向量化的选项。'
- en: The efficiency of vectorization stems from the utilization of special instructions
    offered by CPU manufacturers, rather than merely substituting the original form
    of the loop with an unrolled version. Hence, it’s not feasible to achieve the
    same performance level manually (additionally, it doesn’t result in *clean code*).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化的效率源于利用 CPU 制造商提供的特殊指令，而不仅仅是将原始的循环形式替换为展开的版本。因此，手动实现相同的性能水平是不可行的（此外，这也不会导致*简洁的代码*）。
- en: The optimizer plays a vital role in enhancing a program’s runtime performance.
    By employing its strategies effectively, we’ll get more bang for our buck. Efficiency
    matters not only after coding completion but also during the software development
    process. If compilation times are lengthy, we can improve them by better managing
    the process.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器在提高程序运行时性能方面发挥着至关重要的作用。通过有效地利用其策略，我们可以获得更多的效益。效率不仅在编码完成后很重要，在软件开发过程中同样如此。如果编译时间过长，我们可以通过更好地管理过程来改进它。
- en: Managing the process of compilation
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理编译过程
- en: As programmers and build engineers, we must also consider other aspects of compilation
    such as the time it takes to complete and the ease with which we can identify
    and rectify mistakes made during the solution-building process.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员和构建工程师，我们还必须考虑编译过程中的其他方面，例如完成时间以及在解决方案构建过程中识别和修正错误的便捷性。
- en: Reducing compilation time
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低编译时间
- en: In busy projects that require frequent recompilations (possibly several times
    an hour), it’s paramount to ensure the compilation process is as quick as possible.
    This not only affects the efficiency of your code-compile-test loop but also your
    concentration and workflow.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要频繁重新编译的繁忙项目中（可能每小时多次），确保编译过程尽可能快速是至关重要的。这不仅影响你的代码编译测试循环的效率，还会影响你的专注力和工作流程。
- en: 'Luckily, C++ is already pretty good at managing compilation time, thanks to
    separate translation units. CMake will take care to only recompile sources that
    were impacted by recent changes. However, if we need to improve things even more,
    there are a couple of techniques we can use: header precompilation and unity builds.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C++已经相当擅长管理编译时间，这要归功于分离的翻译单元。CMake会确保只重新编译受到最近更改影响的源文件。然而，如果我们需要进一步改善，有几种技术可以使用：头文件预编译和统一构建。
- en: Precompilation of headers
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头文件的预编译
- en: Header files (`.h`) are included in the translation unit by the preprocessor
    before the actual compilation begins. This means they must be recompiled every
    time the `.cpp` implementation files change. Moreover, if multiple translation
    files are using the same shared header, it has to be compiled every time it’s
    included. This is inefficient, but it has been the standard for a long time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件（`.h`）由预处理器在实际编译开始之前包含到翻译单元中。这意味着每当`.cpp`实现文件发生变化时，它们必须重新编译。此外，如果多个翻译单元使用相同的共享头文件，每次包含时都必须编译一次。这是低效的，但它已经是长期以来的标准做法。
- en: 'Luckily, since version 3.16, CMake offers a command to enable header precompilation.
    This allows the compiler to process headers separately from the implementation
    file, thereby speeding up the compilation process. This is the syntax for the
    provided command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，从CMake 3.16版本开始，CMake提供了一个命令来启用头文件预编译。这使得编译器可以将头文件与实现文件分开处理，从而加速编译过程。以下是该命令的语法：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The list of added headers is stored in the `PRECOMPILE_HEADERS` target property.
    As we discussed in *Chapter 5*, *Working with Targets*,in the *What are transitive
    usage requirements?* section, we can use the propagated properties to share the
    headers with any depending targets by choosing the `PUBLIC` or `INTERFACE` keyword;
    however, this shouldn’t be done for targets exported with the `install()` command.
    Other projects shouldn’t be forced to consume our precompiled headers as this
    is not a conventional practice.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的头文件列表存储在`PRECOMPILE_HEADERS`目标属性中。正如我们在*第5章*、*与目标的协作*中讨论的，在*什么是传递的使用要求？*部分，我们可以使用传播的属性，通过选择`PUBLIC`或`INTERFACE`关键字，将头文件与任何依赖目标共享；然而，对于使用`install()`命令导出的目标，不应这样做。其他项目不应被强迫使用我们的预编译头文件，因为这并不是一种常规做法。
- en: Use the `$<BUILD_INTERFACE:...>` generator expression described in *Chapter
    6*, *Using Generator Expressions*, to prevent precompiled headers from appearing
    in the usage requirements of targets when they’re installed. However, they will
    still be added to targets exported from the build tree with the `export()` command.
    Don’t worry if this seems confusing right now – it will be fully explained in
    *Chapter 14*, *Installing and Packaging*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在*第6章*、*使用生成器表达式*中描述的`$<BUILD_INTERFACE:...>`生成器表达式，防止预编译头文件出现在目标的使用要求中，尤其是在它们被安装时。然而，它们仍会被添加到通过`export()`命令从构建树中导出的目标中。如果现在这看起来有点困惑，不用担心——在*第14章*、*安装与打包*中会做详细说明。
- en: CMake will put all headers’ names in a `cmake_pch.h` or `cmake_pch.hxx` file,
    which will then be precompiled to a compiler-specific binary file with a `.pch`,
    `.gch`, or `.pchi` extension.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: CMake会将所有头文件的名称放入一个`cmake_pch.h`或`cmake_pch.hxx`文件中，然后将该文件预编译为一个特定于编译器的二进制文件，扩展名为`.pch`、`.gch`或`.pchi`。
- en: 'We can use it in our listfile like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的列表文件中像这样使用它：
- en: '**ch07/06-precompile/CMakeLists.txt**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/06-precompile/CMakeLists.txt**'
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also use it in the corresponding source file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在对应的源文件中使用它：
- en: '**ch07/06-precompile/hello.cpp**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/06-precompile/hello.cpp**'
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that in our `main.cpp` file, we don’t need to include `cmake_pch.h` or
    any other header – it will be included by CMake with compiler-specific command-line
    options.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的`main.cpp`文件中，我们不需要包含`cmake_pch.h`或任何其他头文件——它将由CMake使用特定于编译器的命令行选项包含进来。
- en: 'In the previous example, I used a built-in header; however, you can easily
    add your own headers with class or function definitions. Use one of the two forms
    to reference the header:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我使用了一个内置头文件；然而，你可以轻松地添加自己的包含类或函数定义的头文件。可以使用两种形式之一来引用头文件：
- en: '`header.h` (a direct path) is interpreted as relative to the current source
    directory and will be included with an absolute path.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header.h`（直接路径）被解释为相对于当前源目录的路径，并将以绝对路径包含。'
- en: The `[["header.h"]]` (double brackets and quotes) path will be scanned according
    to the target’s `INCLUDE_DIRECTORIES` property, which can be configured with `target_include_directiories()`.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[["header.h"]]`（双括号和引号）的路径将根据目标的 `INCLUDE_DIRECTORIES` 属性进行扫描，该属性可以通过 `target_include_directiories()`
    配置。'
- en: Some online references may discourage precompiling headers that aren’t part
    of a standard library, such as `<iostream>`, or using precompiled headers altogether.
    This is because changing the list or editing a custom header will cause recompilation
    of all translation units in the target. With CMake, this concern is not as significant,
    especially if you structure your project correctly (with relatively small targets
    focused on a narrow domain). Each target has a separate precompiled header file,
    which limits the impact of the header changes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在线参考资料可能会建议避免预编译那些不是标准库的一部分的头文件，比如 `<iostream>`，或者完全不使用预编译头文件。这是因为修改列表或编辑自定义头文件将导致目标中的所有翻译单元重新编译。使用
    CMake 时，这个问题就没有那么严重，尤其是当你正确地组织项目（将项目结构划分为相对较小、聚焦于特定领域的目标）时。每个目标都有一个独立的预编译头文件，这样可以限制头文件更改的影响。
- en: 'If your headers are considered relatively stable, you might decide to reuse
    precompiled headers in your targets. For this purpose, CMake provides a convenient
    command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的头文件被认为相对稳定，你可以决定在目标中重用预编译头文件。为此，CMake 提供了一个方便的命令：
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This sets the `PRECOMPILE_HEADERS_REUSE_FROM` property of the target reusing
    the headers and creates a dependency between these targets. Using this method,
    the consuming target can no longer specify its own precompiled headers. Additionally,
    all *compile options*, *compile flags*, and *compile definitions* must match between
    targets.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这会设置目标的 `PRECOMPILE_HEADERS_REUSE_FROM` 属性，重用头文件，并在这些目标之间创建依赖关系。使用这种方法，消费目标将无法再指定自己的预编译头文件。此外，所有的*编译选项*、*编译标志*和*编译定义*必须在目标之间匹配。
- en: Pay attention to requirements, especially if you have any headers that use the
    double bracket format (`[["header.h"]]`). Both targets need to set their *include
    paths* appropriately to make sure those headers are found by the compiler.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意要求，尤其是如果你有任何使用双括号格式（`[["header.h"]]`）的头文件。两个目标都需要适当设置它们的*包含路径*，以确保编译器能够找到这些头文件。
- en: Unity builds
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unity 构建
- en: CMake 3.16 introduced another compilation time optimization feature – unity
    builds, also known as *unified builds* or *jumbo builds*. Unity builds work by
    combining multiple implementation source files by utilizing the `#include` directive.
    This has some interesting implications, some of which are beneficial, while others
    could be potentially harmful.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 3.16 引入了另一种编译时间优化功能——Unity 构建，也被称为*统一构建*或*超大构建*。Unity 构建通过利用 `#include`
    指令将多个实现源文件合并。这有一些有趣的影响，其中一些是有利的，而另一些可能是有害的。
- en: 'The most obvious advantage is avoiding the recompilation of headers in different
    translation units when CMake creates a unified build file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的优势是，当 CMake 创建统一构建文件时，避免了不同翻译单元中头文件的重新编译：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When both sources contain a `#include "header.h"` line, the referenced file
    will be parsed only once, thanks to *include guards* (assuming they have been
    properly added). While not as refined as precompiled headers, it is an alternative.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个源文件中都有 `#include "header.h"` 行时，参考的文件只会被解析一次，得益于*包含保护*（假设它们已正确添加）。虽然不如预编译头文件精细，但这也是一种替代方案。
- en: The second benefit of this type of build is the fact that the optimizer may
    now act on a greater scale and optimize interprocedural calls across all bundled
    sources. This is similar to link-time optimization, which we discussed in *Chapter
    4*, *Setting Up Your First CMake Project*, in the *Interprocedural optimization*
    section.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构建方式的第二个好处是，优化器现在可以在更大的范围内工作，优化所有捆绑源代码之间的过程间调用。这类似于我们在*第 4 章*、*设置你的第一个 CMake
    项目*中的*过程间优化*部分讨论的链接时间优化。
- en: However, these benefits come with trade-offs. As we reduced the number of *object
    files* and processing steps, we also increased the amount of memory needed to
    process larger files. Additionally, we reduced the amount of parallelizable work.
    Compilers aren’t exceptionally good at multithreaded compiling, as they don’t
    typically need to be – the buildsystem will usually start many compilation tasks
    to execute all the files simultaneously on different threads. Grouping all files
    together complicates this, as CMake now has fewer files to compile in parallel.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些好处是有权衡的。由于我们减少了*目标文件*和处理步骤的数量，我们也增加了处理较大文件所需的内存量。此外，我们减少了可并行工作的数量。编译器在多线程编译方面并不特别擅长，因为它们通常不需要这样做——构建系统通常会启动许多编译任务，以便在不同的线程上同时执行所有文件。将所有文件分组在一起会使这一过程变得复杂，因为
    CMake 现在需要并行编译的文件变少了。
- en: With unity builds, you also need to consider some C++ semantic implications
    that might not be so obvious to catch – anonymous namespaces hiding symbols across
    files are now scoped to the unity file, rather than to an individual translation
    unit. The same thing happens with static global variables, functions, and macro
    definitions. This may cause name collisions, or incorrect function overloads to
    be executed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Unity 构建时，你还需要考虑一些可能不容易察觉的 C++ 语义影响——匿名命名空间隐藏跨文件的符号，现在这些符号的作用域局限于 Unity 文件，而不是单独的翻译单元。静态全局变量、函数和宏定义也会发生同样的情况。这可能会导致名称冲突，或执行错误的函数重载。
- en: Jumbo builds are suboptimal when recompiling, as they will compile many more
    files than needed. They work best when the code is meant to compile all files
    as fast as possible. Tests done on Qt Creator (a popular GUI library) show that
    you can expect an improvement anywhere between 20% to 50% (depending on the compiler
    used).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Jumbo 构建在重新编译时表现不佳，因为它们会编译比实际需要的更多文件。它们最适合用于代码需要尽可能快地编译所有文件的情况。在 Qt Creator（一个流行的
    GUI 库）上进行的测试表明，你可以期望性能提高20%到50%之间（具体取决于使用的编译器）。
- en: 'To enable unity builds, we have two options:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 Unity 构建，我们有两个选择：
- en: Set the `CMAKE_UNITY_BUILD` variable to `true` – it will initialize the `UNITY_BUILD`
    property on every target defined thereafter.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`CMAKE_UNITY_BUILD`变量设置为`true`——它将初始化随后定义的每个目标上的`UNITY_BUILD`属性。
- en: Manually set the `UNITY_BUILD` target property to `true` on every target that
    should use unity builds.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动将`UNITY_BUILD`目标属性设置为`true`，用于所有应使用 Unity 构建的目标。
- en: 'The second option is achieved by calling the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择通过调用以下内容来实现：
- en: '[PRE34]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Manually setting these properties on many targets is of course more work and
    increases the cost of maintenance, but you may need to do so to control this setting
    on a finer level.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多目标上手动设置这些属性当然需要更多的工作，并增加了维护成本，但你可能需要这样做，以便更精细地控制这一设置。
- en: By default, CMake will create builds containing eight source files, as specified
    by the `UNITY_BUILD_BATCH_SIZE` property of a target (copied at the creation of
    a target from the `CMAKE_UNITY_BUILD_BATCH_SIZE` variable). You can change the
    target property or default variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CMake 会创建包含八个源文件的构建，这些源文件由目标的`UNITY_BUILD_BATCH_SIZE`属性指定（该属性在目标创建时从`CMAKE_UNITY_BUILD_BATCH_SIZE`变量复制）。你可以更改目标属性或默认变量。
- en: 'Starting from version 3.18, you can explicitly define how files should be bundled
    with named groups. To do so, change the target’s `UNITY_BUILD_MODE` property to
    `GROUP` (the default is `BATCH`). Then, assign your source files to groups by
    setting their `UNITY_GROUP` property to the name of your choosing:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.18 开始，你可以明确地定义文件应如何与命名组捆绑。为此，请将目标的`UNITY_BUILD_MODE`属性更改为`GROUP`（默认值是`BATCH`）。然后，通过将源文件的`UNITY_GROUP`属性设置为你选择的名称来将它们分配到组中：
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: CMake will then disregard `UNITY_BUILD_BATCH_SIZE` and add all files from the
    group to a single unity build.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，CMake 将忽略`UNITY_BUILD_BATCH_SIZE`并将该组中的所有文件添加到一个 Unity 构建中。
- en: CMake’s documentation advises against enabling unity builds for public projects
    by default. It is recommended that the end user of your application should be
    able to decide whether they want jumbo builds or not by providing the -`DCMAKE_UNITY_BUILD`
    command-line argument. If unity builds cause issues due to the way your code is
    written, you should explicitly set the target’s property to false. However, you
    are free to enable this feature for code that will be used internally, such as
    within a company or for your private project.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 的文档建议默认情况下不要为公共项目启用统一构建。推荐的做法是，应用程序的最终用户应该能够决定是否希望使用 jumbo 构建，可以通过提供`-DCMAKE_UNITY_BUILD`命令行参数来实现。如果统一构建由于代码编写方式引发问题，你应该明确地将目标的属性设置为
    false。然而，你可以自由地为内部使用的代码启用此功能，例如公司内部的代码或你自己的私人项目。
- en: These are the most important aspects of reducing compilation time with CMake.
    There are other aspects of programming that often cost us a lot of time – one
    of the most notorious is debugging. Let’s see how we can improve things there.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用 CMake 减少编译时间的最重要方面。编程中还有其他常常让我们浪费大量时间的因素——其中最臭名昭著的就是调试。让我们看看如何在这方面改进。
- en: Finding mistakes
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找错误
- en: As programmers, we spend a substantial amount of time hunting for bugs. This,
    sadly, is a fact of our profession. The process of identifying errors and rectifying
    them can often get under our skin, especially when it requires long hours. The
    difficulty is amplified when we’re left flying blind, without the necessary tools
    to help us navigate through these challenging situations. For this reason, it
    is crucial that we pay great attention to setting up our environment in a way
    that simplifies this process, making it as easy and bearable as possible. One
    way we can achieve this is by configuring the compiler with `target_compile_options()`.
    So, which *compile options* could assist us in this endeavor?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们花费大量时间在寻找 bug 上。不幸的是，这是我们职业的一个事实。识别错误并修复它们的过程常常让人焦躁不安，尤其是当修复需要长时间工作时。当我们缺乏必要的工具来帮助我们在这些困难的情况下航行时，这个难度会大大增加。正因如此，我们必须特别注意如何配置环境，使得这一过程变得更加简化，尽可能轻松和耐受。一种实现这一目标的方法是通过`target_compile_options()`配置编译器。那么，哪些*编译选项*可以帮助我们实现这一目标呢？
- en: Configuring errors and warnings
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置错误和警告
- en: There are many stressful things about software development – fixing critical
    bugs in the middle of the night, working on high-visibility, costly failures in
    large systems, and dealing with annoying compilation errors. Some errors are hard
    to understand, while others are tediously challenging to fix. In your quest to
    simplify your work and reduce the chance of failure, you’ll find many recommendations
    on how to configure your compiler’s warnings.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中有很多令人头疼的事情——在深夜修复关键性 bug，处理大型系统中的高可见度和高成本故障，或者面对恼人的编译错误。一些错误难以理解，而另一些则是繁琐且具有挑战性的修复任务。在你努力简化工作并减少失败的机会时，你会发现很多关于如何配置编译器警告的建议。
- en: One such fine piece of advice is to enable the `-Werror` flag as default for
    all builds. On the surface, this flag’s function is deceptively simple – it treats
    all the warnings as errors, preventing the code from compiling until you resolve
    each one. While it may seem like a beneficial approach, it seldom is.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个值得注意的建议是默认启用`-Werror`标志进行所有构建。从表面上看，这个标志的功能看起来很简单——它将所有警告视为错误，直到你解决每个警告，代码才会继续编译。虽然看起来似乎是一种有益的方法，但它通常并非如此。
- en: 'You see, warnings are not classified as errors for a reason: they’re designed
    to caution you. It’s up to you to decide how to address these warnings. Having
    the liberty to overlook a warning, particularly when you’re experimenting or prototyping
    your solution, is often invaluable.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，警告之所以不被归类为错误，是有原因的：它们的设计目的是提醒你。如何处理这些警告由你自己决定。特别是在你进行实验或原型开发时，能够忽视某些警告往往是非常宝贵的。
- en: On the other hand, if you have a perfect, no-warnings, all-shiny piece of code,
    it seems a shame to allow future modifications to tarnish this pristine state.
    What harm could come from enabling it and just keeping it there? Seemingly none,
    at least until your compiler gets upgraded, that is. New compiler versions tend
    to be stricter about deprecated features or more adept at offering improvement
    suggestions. While this is beneficial when warnings remain as warnings, it can
    lead to unexpected build failures with unchanged code or, even more frustratingly,
    when you need to quickly rectify a problem unrelated to the new warning.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你有一段完美的、没有警告的、无懈可击的代码，似乎不应该让将来的修改破坏这种完美的状态。启用它并保持在那里，似乎也没有什么坏处，至少在你的编译器没有升级之前是这样。新版本的编译器通常对已弃用的特性更加严格，或者在提供改进建议方面更加高效。虽然这在警告仍然是警告时有益，但它可能导致在代码没有更改的情况下出现意外的构建失败，或者更让人沮丧的是，当你需要快速修复与新警告无关的问题时。
- en: So, when is it acceptable to enable all possible warnings? The short answer
    is when you’re creating a public library. In these cases, you’ll want to preempt
    issue tickets that fault your code for misbehavior in stricter environments than
    yours. If you opt to enable this setting, ensure you stay updated with the new
    compiler versions and the warnings they introduce. It’s also important to explicitly
    manage this update process, separately from making any code changes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候启用所有可能的警告是可以接受的呢？简短的答案是，当你在创建一个公共库时。在这种情况下，你会希望预防那些因环境比你严格而导致的代码问题的工单。如果你选择启用这个设置，请确保及时更新新的编译器版本及其引入的警告。还需要特别管理这个更新过程，与代码变更的管理分开进行。
- en: Otherwise, let warnings be what they are, and concentrate on errors. If you
    feel compelled to be pedantic, use the `-Wpedantic` flag. This particular flag
    enables all warnings demanded by strict ISO C and ISO C++ standards. However,
    bear in mind that this flag doesn’t confirm conformance with the standard; it
    only identifies non-ISO practices that require a diagnostic message.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，让警告保持原样，集中精力处理错误。如果你觉得有必要强求严格，可以使用`-Wpedantic`标志。这个特定的标志会启用严格的ISO C和ISO C++标准要求的所有警告。然而，请记住，这个标志并不能确认标准的符合性；它只是标识出那些需要诊断消息的非ISO做法。
- en: More lenient and down-to-earth coders will be satisfied with `-Wall`, optionally
    coupled with `-Wextra` for an extra touch of sophistication, which should suffice.
    These warnings are considered genuinely useful, and you should address them in
    your code when time allows.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 更宽容且脚踏实地的程序员将会满足于`-Wall`，可以选择与`-Wextra`搭配使用，增加一些精致的警告，这样就足够了。这些警告被认为是真正有用的，当有时间时，你应该在代码中处理这些警告。
- en: There are plenty of other warning flags that may be useful depending on your
    project type. I recommend that you read the manual for your chosen compiler to
    see what options are available.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的项目类型，还有许多其他警告标志可能会有用。我建议你阅读所选编译器的手册，看看有哪些可用的选项。
- en: Debugging the build
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试构建
- en: Occasionally, the compilation will break. This usually happens when we try to
    refactor a significant amount of code or clean up our buildsystem. At times, issues
    can be resolved easily; however, there are more complex problems that require
    a thorough investigation into the configuration steps. We already know how to
    print more verbose CMake outputs (as discussed in *Chapter 1*, *First Steps with
    CMake*), but how do we analyze what actually happens under the hood at each stage?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，编译会失败。这通常发生在我们尝试重构大量代码或清理我们的构建系统时。有时问题可以很容易解决；然而，也有一些复杂的问题需要深入调查配置步骤。我们已经知道如何打印更详细的CMake输出（如在*第一章*中讨论的《CMake的第一步》），但我们如何分析每个阶段实际上发生了什么？
- en: Debugging individual stages
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试各个阶段
- en: The `-save-temps`, which can be passed to both GCC and Clang compilers, allows
    us to debug individual stages of compilation. This flag will instruct the compilers
    to store the output of certain compilation stages in files, rather than in memory.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`-save-temps`，可以传递给GCC和Clang编译器，允许我们调试编译的各个阶段。这个标志会指示编译器将某些编译阶段的输出存储在文件中，而不是存储在内存中。'
- en: '**ch07/07-debug/CMakeLists.txt**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/07-debug/CMakeLists.txt**'
- en: '[PRE36]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Enabling this option will produce two extra files (`.ii` and `.s`) per translation
    unit.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此选项将在每个翻译单元中生成两个额外的文件（`.ii` 和 `.s`）。
- en: 'The first one, `<build-tree>/CMakeFiles/<target>.dir/<source>.ii`, stores the
    output of the preprocessing stage, with comments explaining where each part of
    the source code comes from:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件，`<build-tree>/CMakeFiles/<target>.dir/<source>.ii`，存储预处理阶段的输出，并附有注释，解释每部分源代码的来源：
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The second one, `<build-tree>/CMakeFiles/<target>.dir/<source>.s`, contains
    the output of the linguistic analysis stage, ready for the assembler stage:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件，`<build-tree>/CMakeFiles/<target>.dir/<source>.s`，包含语言分析阶段的输出，已准备好进入汇编阶段：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Depending on the type of problem, we can often uncover the actual issue. For
    instance, the preprocessor’s output can help us identify bugs, such as incorrect
    *include paths* (which may provide the wrong version of libraries), or mistakes
    in definitions that lead to erroneous `#ifdef` evaluations.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 根据问题的类型，我们通常可以揭示实际问题。例如，预处理器的输出可以帮助我们识别错误，如错误的*包含路径*（可能提供错误版本的库），或定义中的错误导致的`#ifdef`评估错误。
- en: Meanwhile, the output of the linguistic analysis is particularly beneficial
    for targeting specific processors and resolving critical optimization problems.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，语言分析的输出对于针对特定处理器和解决关键优化问题尤其有益。
- en: Debugging issues with header file inclusion
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试头文件包含问题
- en: 'Debugging incorrectly included files can be a challenging task. I should know
    – in my first corporate job, I had to port an entire code base from one buildsystem
    to another. If you ever find yourself in a situation that requires a precise understanding
    of the paths used to include a requested header, consider using the `-H` compile
    option:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 调试错误的包含文件可能是一个具有挑战性的任务。我应该知道——在我第一份公司工作时，我曾经需要将整个代码库从一个构建系统迁移到另一个。如果你发现自己处于一个需要精确理解用于包含所请求头文件的路径的情况，可以考虑使用`-H`编译选项：
- en: '**ch07/07-debug/CMakeLists.txt**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch07/07-debug/CMakeLists.txt**'
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The produced output will look similar to this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的输出将类似于以下内容：
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: After the name of the *object file*, each row in the output contains a path
    to a header. In this example, a single dot at the beginning of the line indicates
    a top-level inclusion (where the `#include` directive is in `hello.cpp`). Two
    dots signify that this file is included by the subsequent file (`<iostream>)`.
    Each additional dot denotes another level of nesting.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在*目标文件*的名称后，每一行输出都包含一个头文件路径。在这个例子中，行首的单个点表示顶级包含（`#include`指令位于`hello.cpp`中）。两个点表示此文件由后续文件（`<iostream>`）包含。每增加一个点，表示嵌套的层级增加。
- en: 'At the end of this output, you may also find suggestions for possible improvements
    to your code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出的末尾，你还可能会看到一些关于如何改进代码的建议：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: While you’re not required to address issues in the standard library, you may
    see some of your own headers listed. In such cases, you might want to consider
    making corrections.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不需要解决标准库中的问题，但你可能会看到一些你自己编写的头文件被列出。在这种情况下，你可能需要考虑进行修正。
- en: Providing information for the debugger
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为调试器提供信息
- en: Machine code is a cryptic list of instructions and data, encoded in a binary
    format. It doesn’t convey any greater meaning or objective. This is because the
    CPU doesn’t care what the goal of the program is or what the sense of all of the
    instructions is. The only requirement is the correctness of the code. The compiler
    will translate all of the preceding into numeric identifiers of CPU instructions,
    store data to initialize memory where needed, and provide tens of thousands of
    memory addresses. In other words, the final binary doesn’t need to contain the
    actual source code, variable names, signatures of functions, or any other details
    that programmers care about. That’s the default output of the compiler – raw and
    bare.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 机器代码是一组神秘的指令和数据，以二进制格式编码。它并没有传达更深层次的意义或目标。这是因为CPU并不关心程序的目标是什么，或者所有指令的含义。唯一的要求是代码的正确性。编译器会将上述所有内容翻译成CPU指令的数字标识符，存储数据以初始化所需的内存，并提供成千上万的内存地址。换句话说，最终的二进制文件不需要包含实际的源代码、变量名、函数签名或程序员关心的任何其他细节。这就是编译器的默认输出——原始且裸露。
- en: This is done primarily to save space and execute without too much overhead.
    Coincidentally, we are also somewhat protecting our application from reverse engineering.
    Yes, you can understand what each CPU instruction does without the source code
    (for example, copy this value to that register). But even basic programs contain
    too many of these instructions to make sense of them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做主要是为了节省空间并减少过多的开销。巧合的是，我们也在一定程度上保护了我们的应用程序免受逆向工程的攻击。是的，即使没有源代码，你也可以理解每个CPU指令的作用（例如，将这个值复制到那个寄存器）。但是，即使是最基础的程序也包含太多这样的指令，难以理清它们的逻辑。
- en: If you’re a particularly driven individual, you can use a tool called a **disassembler**,
    and with a lot of knowledge (and a bit of luck), you’ll be able to decipher what
    might be happening. However, this approach isn’t very practical, as disassembled
    code doesn’t have original symbols, making it incredibly hard and slow to untangle
    what goes where.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个特别有动力的人，你可以使用一个叫做**反汇编器**的工具，通过大量的知识（和一点运气），你将能够解读可能发生的事情。然而，这种方法并不太实际，因为反汇编的代码没有原始符号，这使得解读程序的逻辑变得非常困难且缓慢。
- en: Instead, we can ask the compiler to store the source code in the produced binary
    along with the map of references between compiled and original code. Then, we
    can attach a debugger to a running program and see which source line is being
    executed at any given moment. This is indispensable when we’re working on code,
    such as writing new functionality or correcting errors.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以要求编译器将源代码与编译后代码与原始代码之间的引用映射一起存储到生成的二进制文件中。然后，我们可以将调试器附加到正在运行的程序上，并查看在任何时刻正在执行哪个源代码行。当我们在编写新功能或修复错误等代码时，这一点是不可或缺的。
- en: 'These two use cases are the reason for two build configs: `Debug` and `Release`.
    As we’ve seen earlier, CMake will provide some flags to the compiler by default
    to manage this process, storing them first in global variables:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个用例是两个构建配置的原因：`Debug` 和 `Release`。正如我们之前所看到的，CMake 默认会向编译器提供一些标志来管理此过程，并首先将它们存储在全局变量中：
- en: '`CMAKE_CXX_FLAGS_DEBUG` contains `-g`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CXX_FLAGS_DEBUG` 包含 `-g`'
- en: '`CMAKE_CXX_FLAGS_RELEASE` contains `-DNDEBUG`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CXX_FLAGS_RELEASE`包含 `-DNDEBUG`'
- en: 'The `-g` flag simply means “add debugging information.” It’s provided in the
    OS’s native format: stabs, COFF, XCOFF, or DWARF. These formats can then be accessed
    by debuggers such as `gdb` (the GNU debugger). Usually, this is sufficient for
    IDEs such as CLion (as they use `gdb` under the hood). In other cases, refer to
    the manual of the provided debugger and check what the appropriate flag is for
    the compiler of your choice.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g`标志的意思是“添加调试信息”。它以操作系统的本地格式提供：stabs、COFF、XCOFF 或 DWARF。这些格式可以被像 `gdb`（GNU
    调试器）这样的调试器访问。通常，这对于像 CLion 这样的集成开发环境（IDE）来说是足够的，因为它们在后台使用 `gdb`。在其他情况下，请参考所提供调试器的手册，检查适用于您所选择编译器的正确标志。'
- en: 'For the `Release` configuration, CMake will add the `-DNDEBUG` flag. It’s a
    preprocessor definition, which simply means “not a debug build.” Some debug-oriented
    macros will be deliberately disabled by this option. One of them is `assert`,
    available in the `<assert.h>` header file. If you decide to use assertions in
    your production code, they simply won’t work:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Release` 配置，CMake 会添加 `-DNDEBUG` 标志。这是一个预处理器定义，简单来说就是“不是调试构建”。一些面向调试的宏将被故意禁用，其中之一就是在
    `<assert.h>` 头文件中可用的 `assert`。如果你决定在生产代码中使用断言，它们将不起作用：
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `assert(false)` call won’t have any effect in the `Release` configuration,
    but it will stop the execution just fine in `Debug`. What do you do if you’re
    practicing assertive programming and still need to use `assert()` for release
    builds? Either change the defaults that are provided by CMake (remove `NDEBUG`
    from `CMAKE_CXX_FLAGS_RELEASE`) or implement a hardcoded override by undefining
    the macro before the header inclusion:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Release` 配置中，`assert(false)` 调用不会产生任何效果，但在 `Debug` 配置中，它会正常停止执行。如果你正在实践断言编程，并且仍然需要在发布版本中使用
    `assert()`，你可以选择更改 CMake 提供的默认设置（从 `CMAKE_CXX_FLAGS_RELEASE` 中移除 `NDEBUG`），或者在包含头文件之前实现硬编码的覆盖，方法是取消定义该宏：
- en: '[PRE43]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Refer to the assert reference for more information: [https://en.cppreference.com/w/c/error/assert](https://en.cppreference.com/w/c/error/assert).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参见断言参考：[https://en.cppreference.com/w/c/error/assert](https://en.cppreference.com/w/c/error/assert)。
- en: You can consider replacing `assert()` with `static_assert()`, which was introduced
    in C++11, if your assertions can be done during compilation time, as this function
    isn’t protected with the `#ifndef(NDEBUG)` preprocessor directive like `assert()`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的断言可以在编译时完成，您可以考虑用 C++11 中引入的 `static_assert()` 替代 `assert()`，因为该函数不像 `assert()`
    那样被 `#ifndef(NDEBUG)` 预处理器指令保护。
- en: With this, we have learned how to manage the process of compilation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们已经学会了如何管理编译过程。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have completed yet another chapter! Undoubtedly, compilation is a complex
    process. With all its edge cases and specific requirements, it can be difficult
    to manage without a robust tool. Thankfully, CMake does an excellent job supporting
    us here.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又完成了一个章节！毫无疑问，编译是一个复杂的过程。由于它的各种边界情况和特定要求，在没有强大工具的支持下很难管理。幸运的是，CMake 在这方面做得非常出色。
- en: So, what have we learned so far? We began by discussing what compilation is
    and where it fits into the broader narrative of building and running applications
    in the OS. We then examined the stages of compilation and the internal tools that
    manage them. This understanding is invaluable for resolving complex issues that
    we might encounter in the future.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，到目前为止我们学到了什么呢？我们从讨论编译是什么以及它在构建和运行操作系统中的应用程序这一更广泛叙述中所处的位置开始。然后，我们检查了编译的各个阶段以及管理这些阶段的内部工具。这种理解对于解决我们未来可能遇到的复杂问题是非常宝贵的。
- en: Next, we explored how to use CMake to verify whether the compiler available
    on the host meets all the necessary requirements for our code to build. As we
    have already established, it’s a significantly better experience for users of
    our solution to see a friendly message asking them to upgrade rather than an arcane
    error printed by an outdated compiler that can’t handle the new features of the
    language.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探索了如何使用 CMake 来验证主机上可用的编译器是否满足构建我们代码所需的所有必要要求。正如我们已经确立的那样，对于我们的解决方案的用户来说，看到一条友好的消息，提示他们升级编译器，远比看到由无法处理新语言特性的过时编译器打印出来的晦涩错误信息要好得多。
- en: We briefly discussed how to add sources to already defined targets, then moved
    on to the configuration of the preprocessor. This was quite a substantial subject,
    as this stage brings all the bits of code together and determines which parts
    will be ignored. We talked about providing paths to files and adding custom definitions
    both individually and in bulk (along with some use cases). Then, we discussed
    the optimizer; we explored all the general levels of optimization and what flags
    they implicitly add. We also went into detail about a few of them – `finline`,
    `floop-unroll`, and `ftree-vectorize`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了如何将源文件添加到已经定义的目标中，然后继续讲解了预处理器的配置。这是一个相当重要的主题，因为这一阶段将所有代码片段汇集在一起，并决定哪些部分会被忽略。我们谈到了如何提供文件路径并单独或批量添加自定义定义（以及一些用例）。接着，我们讨论了优化器；我们探讨了所有常见的优化级别以及它们隐式添加的标志。我们还详细讲解了一些标志——`finline`、`floop-unroll`
    和 `ftree-vectorize`。
- en: Finally, it was time to revisit the bigger picture and study how to manage the
    viability of compilation. We tackled two main aspects here – reducing the compilation
    time (which, by extension, helps maintain the programmer’s focus) and finding
    mistakes. The latter is extremely important for identifying what is broken and
    why. Setting the tools correctly and understanding why things happen greatly contributes
    to ensuring the quality of the code (and preserving our mental health).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候回顾更大的图景，并研究如何管理编译的可行性了。我们在这里解决了两个主要方面——减少编译时间（从而帮助保持程序员的专注力）和发现错误。后者对于识别哪些地方出了问题以及为什么会出问题至关重要。正确配置工具并理解事情发生的原因，有助于确保代码的质量（也有助于维护我们的心理健康）。
- en: In the next chapter, we’ll learn about linking and everything we need to consider
    in order to build libraries and use them in our projects.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习链接以及在构建库并在项目中使用它们时需要考虑的所有事项。
- en: Further reading
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following resources:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，您可以参考以下资源：
- en: 'CMake-supported compile features and compilers: [https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers](https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 支持的编译特性和编译器：[https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers](https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers)
- en: 'Managing sources for targets: [https://stackoverflow.com/questions/32411963/why-is-cmake-file-glob-evil](https://stackoverflow.com/questions/32411963/why-is-cmake-file-glob-evil),
    [https://cmake.org/cmake/help/latest/command/target_sources.html](https://cmake.org/cmake/help/latest/command/target_sources.html)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '管理目标的源文件: [https://stackoverflow.com/questions/32411963/why-is-cmake-file-glob-evil](https://stackoverflow.com/questions/32411963/why-is-cmake-file-glob-evil),
    [https://cmake.org/cmake/help/latest/command/target_sources.html](https://cmake.org/cmake/help/latest/command/target_sources.html)'
- en: 'The include keyword: [https://en.cppreference.com/w/cpp/preprocessor/include](https://en.cppreference.com/w/cpp/preprocessor/include)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include` 关键字: [https://en.cppreference.com/w/cpp/preprocessor/include](https://en.cppreference.com/w/cpp/preprocessor/include)'
- en: 'Providing paths to included files: [https://cmake.org/cmake/help/latest/command/target_include_directories.html](https://cmake.org/cmake/help/latest/command/target_include_directories.html)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '提供包含文件的路径: [https://cmake.org/cmake/help/latest/command/target_include_directories.html](https://cmake.org/cmake/help/latest/command/target_include_directories.html)'
- en: 'Configuring headers: [https://cmake.org/cmake/help/latest/command/configure_file.html](https://cmake.org/cmake/help/latest/command/configure_file.html)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '配置头文件: [https://cmake.org/cmake/help/latest/command/configure_file.html](https://cmake.org/cmake/help/latest/command/configure_file.html)'
- en: 'Pre-compilation of headers: [https://cmake.org/cmake/help/latest/command/target_precompile_headers.html](https://cmake.org/cmake/help/latest/command/target_precompile_headers.html)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '头文件预编译: [https://cmake.org/cmake/help/latest/command/target_precompile_headers.html](https://cmake.org/cmake/help/latest/command/target_precompile_headers.html)'
- en: 'Unity builds: [https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html](https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Unity 构建: [https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html](https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html)'
- en: Precompiled headers unity builds:[https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake](https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '预编译头文件和 Unity 构建: [https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake](https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake)'
- en: 'Finding mistakes – compiler flags: [https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags](https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '查找错误 – 编译器标志: [https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags](https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags)'
- en: Why use libraries and not object files:[https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why](https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why)
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '为什么使用库而不是目标文件: [https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why](https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why)'
- en: Separation of concerns[:https://nalexn.github.io/separation-of-concerns/](https://nalexn.github.io/separation-of-concerns/
    )
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 职责分离[:https://nalexn.github.io/separation-of-concerns/](https://nalexn.github.io/separation-of-concerns/)
- en: Join our community on Discord
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
- en: '![](img/QR_Code94081075213645359.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code94081075213645359.png)'
