- en: Chapter 1. Simplifying Your Network Programming in C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。简化C++中的网络编程
- en: 'There are several C++ compilers that we can choose from the Web. To make it
    easier for you to follow all the code in this book, I have chosen a compiler that
    will make the programming process simpler—definitely the easiest one. In this
    chapter, you will discover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从网络上选择几个C++编译器。为了让您更容易地跟随本书中的所有代码，我选择了一个可以使编程过程更简单的编译器——绝对是最简单的一个。在本章中，您将发现以下主题：
- en: Setting up the MinGW compiler
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置MinGW编译器
- en: Compiling in C++
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中编译
- en: Troubleshooting in GCC C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC C++中的故障排除
- en: Setting up the MinGW compiler and Text Editor
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置MinGW编译器和文本编辑器
- en: This is the hardest part—where we have to choose one compiler over the others.
    Even though I realize that every compiler has its own strength and weakness, I
    want to make it easier for you to go through all the code in this chapter. So,
    I suggest that you apply the same environment that we have, including the compiler
    that we use.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最难的部分——我们必须在其他编译器中选择一个。尽管我意识到每个编译器都有其优势和劣势，但我想让你更容易地浏览本章中的所有代码。因此，我建议您应用与我们相同的环境，包括我们使用的编译器。
- en: I am going to use **GCC**, the GNU Compiler Collection, because of its widely
    used open source. Since my environment includes Microsoft Windows as the operating
    system, I am going to use **Minimalistic GCC for Windows** (**MinGW**) as my C++
    compiler. For those of you who have not heard about GCC, it is a C/C++ compiler
    that you can find in a Linux operating system and it is included in a Linux distribution
    as well. MinGW is a port of GCC to a Windows environment. Therefore, the entire
    code and examples in this book are applicable to any other GCC flavor.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用**GCC**，GNU编译器集合，因为它被广泛使用的开源。由于我的环境包括Microsoft Windows作为操作系统，我将使用**Windows的Minimalistic
    GCC**（**MinGW**）作为我的C++编译器。对于那些没有听说过GCC的人，它是一个可以在Linux操作系统中找到的C/C++编译器，也包含在Linux发行版中。MinGW是GCC在Windows环境中的一个移植。因此，本书中的整个代码和示例都适用于任何其他GCC版本。
- en: Installing MinGW-w64
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装MinGW-w64
- en: 'For your convenience, and since we use a 64-bit Windows operating system, we
    chose MinGW-w64 because it can be used for Windows 32-bits and 64-bits architecture.
    To install it, simply open your Internet browser and navigate to [http://sourceforge.net/projects/mingw-w64/](http://sourceforge.net/projects/mingw-w64/)
    to go to the download page, and click on the **Download** button. Wait for a moment
    until the `mingw-w64-install.exe` file is completely downloaded. Refer to the
    following screenshot to locate the **Download** button:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的方便，由于我们使用64位Windows操作系统，我们选择了MinGW-w64，因为它可以用于Windows 32位和64位架构。要安装它，只需打开您的互联网浏览器，导航到[http://sourceforge.net/projects/mingw-w64/](http://sourceforge.net/projects/mingw-w64/)，转到下载页面，然后点击**下载**按钮。等待片刻，直到`mingw-w64-install.exe`文件完全下载。请参考以下屏幕截图以找到**下载**按钮：
- en: '![Installing MinGW-w64](img/00002.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![安装MinGW-w64](img/00002.jpeg)'
- en: 'Now, execute the installer file. You will be greeted by a **Welcoming** dialog
    box. Just press the **Next** button to go to the **Setup Setting** dialog box.
    In this dialog box, choose the latest GCC version (at the writing time this, it
    is **4.9.2**), and the rest of the options are to be chosen, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行安装程序文件。您将会看到一个**欢迎**对话框。只需按**下一步**按钮，进入**设置设置**对话框。在此对话框中，选择最新的GCC版本（在撰写本文时，是**4.9.2**），其余选项选择如下：
- en: '![Installing MinGW-w64](img/00003.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![安装MinGW-w64](img/00003.jpeg)'
- en: Click on the **Next** button to continue and go to the installation location
    option. Here, you can change the default installation location. I am going to
    change the installation location to `C:\MinGW-w64` in order to make our next setting
    easier, but you can keep this default location if you want.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**按钮继续并进入安装位置选项。在这里，您可以更改默认安装位置。我将更改安装位置为`C:\MinGW-w64`，以便使我们的下一个设置更容易，但如果您愿意，也可以保留此默认位置。
- en: '![Installing MinGW-w64](img/00004.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![安装MinGW-w64](img/00004.jpeg)'
- en: Click on the **Next** button to go to the next step and wait for a moment until
    the files are downloaded and the installation process is complete.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**按钮，进入下一步，并等待片刻，直到文件下载和安装过程完成。
- en: Setting up the Path environment
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置路径环境
- en: 'Now you have the C++ compiler installed on your machine, but you can only access
    it from its installed directory. In order to access the compiler from any directory
    in your system, you have to set the **PATH environment** by performing the following
    steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在计算机上安装了C++编译器，但只能从其安装目录访问它。为了从系统中的任何目录访问编译器，您必须通过执行以下步骤设置**PATH环境**：
- en: 'Run Command Prompt as an administrator by pressing the *Windows* + *R* key.
    Type `cmd` in the text box and, instead of pressing the *Enter* key, press *Ctrl*
    + *Shift* + *Enter* to run the command prompt in Administrator mode. The **User
    Account Control** dialog box will then appear. Choose **YES** to confirm that
    you intend to run Command Prompt in Administrator mode. If you do this correctly,
    you will get a title bar labeled **Administrator: Command Prompt**. If you do
    not get it, you might not have the administrator privilege. In this case, you
    have to contact the administrator of your computer.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Windows* + *R*键以管理员身份运行命令提示符。在文本框中键入`cmd`，而不是按*Enter*键，按*Ctrl* + *Shift*
    + *Enter*以以管理员模式运行命令提示符。然后将出现**用户账户控制**对话框。选择**是**以确认您打算以管理员模式运行命令提示符。如果您正确执行此操作，您将获得一个标有**管理员：命令提示符**的标题栏。如果您没有获得它，您可能没有管理员权限。在这种情况下，您必须联系计算机的管理员。
- en: 'Type the following command in Command Prompt in Administrator mode:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管理员模式下的命令提示符中键入以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Press the *Enter* key and the command prompt will immediately run the **Environment
    Variables** window. Afterwards, go to **System variables**, select the variable
    named **Path**, click on the **Edit** button to open the **Edit System Variable**
    dialog box, and then append the last **Variable value** parameter with the following
    string:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Enter*键，命令提示符将立即运行**环境变量**窗口。然后，转到**系统变量**，选择名为**Path**的变量，单击**编辑**按钮打开**编辑系统变量**对话框，然后在最后的**变量值**参数中添加以下字符串：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (Otherwise, you will have to adjust the path of the installation directory if
    you use the default location the installation wizard is given in the previous
    step)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: （否则，如果您使用默认位置，安装向导中给出的安装目录路径将需要进行调整）
- en: Click on the **OK** button on the **Edit System Variable** dialog box, and click
    on the **OK** button again in the **Environment Variables** dialog box to save
    these changes.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**编辑系统变量**对话框中的**确定**按钮，然后在**环境变量**对话框中再次单击**确定**按钮以保存这些更改。
- en: 'It is time to try our Environment Variable setting. Open a new Command Prompt
    window, either in Administrator or non-Administrator mode, in any active directory
    except `C:\MinGW-w64` and type the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试我们的环境变量设置了。在任何活动目录中打开一个新的命令提示符窗口，可以是管理员模式或非管理员模式，但不能是`C:\MinGW-w64`，然后输入以下命令：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You have configured the proper settings if you see the output informing you
    the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到输出通知您以下信息，那么您已经配置了正确的设置：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you are showed a different version number, you might have another GCC compiler
    on your computer. To solve this problem, you can modify **Environment Variable**
    and remove all path environment settings associated with the other GCC compiler,
    for instance, `C:\StrawberryPerl\c\bin`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显示的是不同的版本号，您的计算机上可能有另一个GCC编译器。为了解决这个问题，您可以修改**环境变量**并删除与其他GCC编译器相关的所有路径环境设置，例如`C:\StrawberryPerl\c\bin`。
- en: 'However, if you do believe that you have followed all the steps correctly,
    but you still get an error message, as shown in the following snippet, you might
    have to restart your machine for your new system settings to be set:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您确信已经正确地按照所有步骤操作，但仍然收到错误消息，如下面的片段所示，您可能需要重新启动计算机以设置新的系统设置：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Choosing and installing the Text Editor
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择和安装文本编辑器
- en: 'Microsoft Windows has been equipped with **Notepad**, a simple text editor
    to create plain text files. You can use Notepad to create a C++ file, where the
    file must contain only plain text formatting. You can also turn to a heavy **Integrated
    Development Environments** (**IDE**) when you want to edit your code, but I prefer
    a simple, lightweight, and extensible programming plain-text editor, so I choose
    to use a text editor instead of IDE. Since I will need syntax highlighting when
    writing code to make it easier to read and understand, I pick **Notepad++** as
    our text editor. You can choose your favorite text editor as long as you save
    the output file as plain text. Here is the sample of syntax highlighting in Notepad++:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Windows已经配备了**Notepad**，一个简单的文本编辑器，用于创建纯文本文件。您可以使用Notepad创建一个C++文件，其中文件必须只包含纯文本格式。当您想要编辑代码时，您也可以转向重量级的**集成开发环境**（**IDE**），但我更喜欢一个简单、轻量级和可扩展的编程纯文本编辑器，因此我选择使用文本编辑器而不是IDE。由于在编写代码时我需要语法高亮以使其更易于阅读和理解，我选择了**Notepad++**作为我们的文本编辑器。您可以选择您喜欢的文本编辑器，只要将输出文件保存为纯文本即可。以下是Notepad++中语法高亮的示例：
- en: '![Choosing and installing the Text Editor](img/00005.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![选择和安装文本编辑器](img/00005.jpeg)'
- en: If you decide to use Notepad++ as I did, you can go to [http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)
    to grab the latest version of Notepad++. Find the **Download** menu on the main
    page and select the current version link. There, you will find a link to download
    the installer file. Use the **Notepad++ Installer** file instead of the package
    file to get the easiest way to set it up on your machine by following all the
    instructions on the installer wizard.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定像我一样使用Notepad++，您可以访问[http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)获取最新版本的Notepad++。在主页上找到**下载**菜单，选择当前版本链接。在那里，您将找到下载安装程序文件的链接。使用**Notepad++安装程序**文件而不是包文件，按照安装向导上的所有说明来设置它在您的计算机上的安装方式。
- en: '![Choosing and installing the Text Editor](img/00006.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![选择和安装文本编辑器](img/00006.jpeg)'
- en: Using the GCC C++ compiler
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GCC C++编译器
- en: Now that we have our development ready, we can write our first C++ program.
    To keep it clean, create a `CPP` folder in the C drive (`C:\CPP`) to store our
    sample code. You can have the same directory location on your system in order
    to follow all the steps more conveniently. Otherwise, you will have to make a
    little bit of modification if you decide to use a different directory location.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的开发准备好了，我们可以编写我们的第一个C++程序。为了保持清洁，创建一个`CPP`文件夹在C盘（`C:\CPP`）中存储我们的示例代码。您可以在您的系统上具有相同的目录位置，以便更方便地按照所有步骤进行。否则，如果您决定使用不同的目录位置，您将需要进行一点修改。
- en: Compiling a C++ program
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译C++程序
- en: 'We won''t create the Hello World! program for our first example code. It is
    boring in my opinion and, by now, you should already know how to code the Hello
    World! program. We are going to create a simple random number generator. You can
    use this program to play with your friends. They have to guess which number will
    be displayed by the program. If the answer is incorrect, you can cross out his/her
    face with a marker and continue playing until you are not able to recognize your
    friend''s face anymore. Here is the code to create this generator:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为我们的第一个示例代码创建Hello World!程序。在我看来，这很无聊，而且到目前为止，您应该已经知道如何编写Hello World!程序了。我们将创建一个简单的随机数生成器。您可以使用这个程序和朋友一起玩。他们必须猜测程序将显示哪个数字。如果答案不正确，您可以用记号划掉他/她的脸，并继续玩下去，直到您无法再认出您朋友的脸为止。以下是创建此生成器的代码：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Type the code in your text editor and save it with the name of the file `rangen.cpp`
    in the `C:\CPP` location. Then, open Command Prompt and point the active directory
    to the `C:\CPP` location by typing the following command in Command Prompt:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中输入代码，并将其保存为文件名为`rangen.cpp`的文件，保存在`C:\CPP`位置。然后，打开命令提示符，并通过在命令提示符中输入以下命令将活动目录指向`C:\CPP`位置：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, type the following command in the console to compile the code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在控制台中输入以下命令来编译代码：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding command compiles the `rangen.cpp` file with an executable file
    named `rangen.exe`, which contains a bunch of machine code (the `exe` extension
    is automatically added to indicate that this file is an executable file in Microsoft
    Windows). The output file for the machine code is specified using the `-o` option.
    If you use this option, you have to specify the name of the output file as well;
    otherwise, the compiler will give you an error of a missing filename. If you omit
    both the `-o` option and the output's filename, the output is written to a default
    file called `a.exe`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用可执行文件`rangen.exe`编译`rangen.cpp`文件，其中包含一堆机器代码（`exe`扩展名会自动添加以指示该文件是Microsoft
    Windows中的可执行文件）。使用`-o`选项指定机器代码的输出文件。如果使用此选项，必须同时指定输出文件的名称；否则，编译器将报告缺少文件名的错误。如果省略`-o`选项和输出文件的文件名，输出将写入默认文件`a.exe`。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The existing executable file that has the same name as the compiled source file
    in the current directory will be overwritten.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当前目录中具有与已编译源文件相同名称的可执行文件将被覆盖。
- en: I recommend that you use the `-Wall` option and make it a habit since this option
    will turn on all the most commonly used compiler warnings. If the option is disabled,
    GCC will not give you any warning. Because our Random Number Generator code is
    completely valid, GCC will not give out any warnings while it is compiled. This
    is why we depend on the compiler warnings to make sure that our code is valid
    and is compiled cleanly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您使用`-Wall`选项并养成习惯，因为此选项将打开所有最常用的编译器警告。如果禁用此选项，GCC将不会给出任何警告。因为我们的随机数生成器代码是完全有效的，所以在编译时GCC不会给出任何警告。这就是为什么我们依赖于编译器警告来确保我们的代码是有效的并且编译干净的原因。
- en: 'To run the program, type `rangen` in the console with the `C:\CPP` location
    as the active directory, and you will be showed a welcoming word: **Select number
    among 0 to 10**. Do what it instructs you to and choose a number between `0` to
    `10`. Then, press *Enter* and the program will give out a number. Compare it with
    your own. If both the numbers are same, you will be congratulated. However, if
    your chosen number is different from the number the code generated, you will be
    informed the same. The output of the program will look as shown in the following
    screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，在控制台中输入`rangen`，并将`C:\CPP`位置作为活动目录，将显示欢迎词：**在0到10之间选择数字**。按照指示选择`0`到`10`之间的数字。然后，按下*Enter*，程序将输出一个数字。将其与你自己的数字进行比较。如果两个数字相同，你将受到祝贺。然而，如果你选择的数字与代码生成的数字不同，你将得到相同的通知。程序的输出将如下截图所示：
- en: '![Compiling a C++ program](img/00007.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![编译C++程序](img/00007.jpeg)'
- en: 'Unfortunately, I never guessed the correct number in the three times that I
    tried. Indeed, it is not easy to guess which number the `rand()` function has
    generated, even if you use a new seed every time the number is generated. In order
    to minimize confusion, I am going to dissect the `rangen.cpp` code, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我在三次尝试中从未猜对正确的数字。事实上，即使每次生成数字时都使用新的种子，也很难猜到`rand()`函数生成了哪个数字。为了减少混乱，我将会解析`rangen.cpp`代码，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I reserved a variable called `guessNumber` to store the integer number from
    the user and used the `std::cin` command to obtain the number that was input from
    the console.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我保留了一个名为`guessNumber`的变量来存储用户输入的整数，并使用`std::cin`命令从控制台获取输入的数字。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the user gives an out-of-range number, notify the operating system that there
    is an error that has occurred in the program—I sent Error 1, but in practice,
    you can send any number—and let it take care of the error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户给出超出范围的数字，通知操作系统程序中发生了错误——我发送了错误1，但实际上，你可以发送任何数字——并让它处理错误。
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `std::srand` function is used to initialize the seed, and in order to generate
    a different random number every time the `std::rand()` function is invoked, we
    use the `std::time(0)` function from the header `ctime`. To generate a range of
    random numbers, we use the `modulo` method that will generate a random number
    from 0 to (n-1) if you invoke a function like `std::rand() % n`. If you want to
    include the number *n* as well, simply add *n* with `1`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::srand`函数用于初始化种子，为了在每次调用`std::rand()`函数时生成不同的随机数，我们使用`ctime`头文件中的`std::time(0)`函数。为了生成一系列随机数，我们使用`模数`方法，如果调用`std::rand()
    % n`这样的函数，将生成一个从0到(n-1)的随机数。如果要包括数字*n*，只需将*n*与`1`相加。'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the fun part, the program compares the user''s guessed number with
    the generated random number. Whatever happens, the user will be informed of the
    result by the program. Let''s take a look at the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有趣的部分，程序将用户猜测的数字与生成的随机数字进行比较。无论发生什么，用户都将通过程序得到结果的通知。让我们看看以下代码：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A `0` return tells the operating system that the program has been terminated
    normally and that there is no need to worry about it. Let''s take a look at the
    following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`0`告诉操作系统程序已正常终止，无需担心。让我们看看以下代码：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Do not forget to include the first three headers in the preceding code since
    they contain the function that we used in this program, such as the `time()` function
    is defined in the `<ctime>` header, the `srand()` function and the `rand()` function
    are defined in the `<cstdlib>` header, and the `cout()` and `cin()` functions
    are defined in the `<iostream>` header.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在上述代码中包含前三个头文件，因为它们包含了我们在此程序中使用的函数，例如`time()`函数在`<ctime>`头文件中定义，`srand()`函数和`rand()`函数在`<cstdlib>`头文件中定义，`cout()`和`cin()`函数在`<iostream>`头文件中定义。
- en: 'If you find that it is hard to guess a number that the program has generated,
    this is because we use the current time as the random generator seed, and the
    consequence of this is that the generated number will always be different in every
    invocation of the program. Here is the screenshot of when I could guess the generated
    random number correctly after about six to seven attempts (for all the program
    invocations, we guessed the number incorrectly except for the last attempt):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现很难猜出程序生成的数字，那是因为我们使用当前时间作为随机生成器种子，这样做的结果是每次调用程序时生成的数字都会不同。以下是我在大约六到七次尝试后成功猜出生成的随机数的屏幕截图（对于所有程序调用，我们都猜错了数字，除了最后一次尝试）：
- en: '![Compiling a C++ program](img/00008.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![编译C++程序](img/00008.jpeg)'
- en: Compiling multiple source files
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译多个源文件
- en: Sometimes, we have to modify our code when it has bugs or errors. If we just
    make a single file that contains all the lines of code, we will be confused when
    we want to modify the source or it will be hard for us to understand the flow
    of the program. To solve the problem, we can split up our code into multiple files
    where every file contains only two to three functions so that it is easy to understand
    and maintain them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当代码存在错误或bug时，我们必须修改我们的代码。如果我们只制作一个包含所有代码行的单个文件，当我们想要修改源代码时，我们会感到困惑，或者我们很难理解程序的流程。为了解决这个问题，我们可以将代码拆分成多个文件，每个文件只包含两到三个函数，这样就容易理解和维护了。
- en: 'We have already been able to generate random numbers, so now, let''s take a
    look at the password generator program. We are going to use it to try compiling
    multiple source files. I will create three files to demonstrate how to compile
    multiple source files, which are `pwgen_fn.h`, `pwgen_fn.cpp`, and `passgen.cpp`.
    We will start from the `pwgen_fn.h` file whose code is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经能够生成随机数，现在，让我们来看一下密码生成器程序。我们将使用它来尝试编译多个源文件。我将创建三个文件来演示如何编译多个源文件，它们是`pwgen_fn.h`、`pwgen_fn.cpp`和`passgen.cpp`。我们将从`pwgen_fn.h`文件开始，其代码如下：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code is used to declare the class name. In this example, the
    class name is `PasswordGenerator`, and what it will do in this case is generate
    the password while the implementation is stored in the `.cpp` file. The following
    is a listing of the `pwgen_fn.cpp` file, which contains the implementation of
    the `Generate()` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码用于声明类名。在本例中，类名为`PasswordGenerator`，在这种情况下，它将生成密码，而实现存储在`.cpp`文件中。以下是`pwgen_fn.cpp`文件的清单，其中包含`Generate()`函数的实现：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The main entry file, `passgen.cpp`, contains a program that uses the `PasswordGenerator`
    class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 主入口文件`passgen.cpp`包含使用`PasswordGenerator`类的程序：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From the preceding three source files, we will produce a single executable
    file. To do so, go to Command Prompt and type the following command in it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的三个源文件中，我们将生成一个单独的可执行文件。为此，请转到命令提示符并在其中输入以下命令：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I did not get any warning or error, so even you should not. The preceding command
    compiles the `passgen.cpp` and `pwgen_fn.cpp` files and then links them together
    to a single executable file named `passgen.exe`. The `pwgen_fn.h` file, since
    it is the header file that has same name as the source file, does not need to
    state the same in the command.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有收到任何警告或错误，所以你也不应该收到。前面的命令编译了`passgen.cpp`和`pwgen_fn.cpp`文件，然后将它们链接到一个名为`passgen.exe`的单个可执行文件中。`pwgen_fn.h`文件，因为它是与源文件同名的头文件，所以在命令中不需要声明相同的名称。
- en: 'Here is what you will get if you run the program by typing the `passgen` command
    in the console window; you will get a different password every time the program
    is run:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在控制台窗口中键入`passgen`命令运行程序，您将每次运行程序时都会得到不同的密码。
- en: '![Compiling multiple source files](img/00009.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![编译多个源文件](img/00009.jpeg)'
- en: 'Now, it is time for us to dissect the preceding source code. We will start
    from the `pwgen_fn.h` file, which only contains the function declaration, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候我们来剖析前面的源代码了。我们将从`pwgen_fn.h`文件开始，该文件仅包含函数声明，如下所示：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see from the declaration, the `Generate()` function will have a parameter
    with the `int` type and will return the `std::string` function. We do not define
    a name for the parameter in the header file since it will be matched with the
    source file automatically.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从声明中可以看出，`Generate()`函数将具有`int`类型的参数，并将返回`std::string`函数。由于参数将自动与源文件匹配，因此在头文件中我们不定义参数的名称。
- en: 'Open the `pwgen_fn.cpp` file, to see the following statement:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`pwgen_fn.cpp`文件，看以下语句：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we can specify the parameter name, which is `passwordLength`. In this
    case, we can have two or more functions with the same name as long as they are
    in different classes. Let''s take a look at the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以指定参数名称，即`passwordLength`。在这种情况下，只要它们位于不同的类中，我们可以拥有两个或更多具有相同名称的函数。让我们看一下以下代码：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I reserved the variable named `randomNumber` to store random numbers generated
    by the `rand()` function and the `password` parameter to store the ASCII converted
    from the random number. Let''s take a look at the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我保留了名为`randomNumber`的变量来存储由`rand()`函数生成的随机数，以及`password`参数来存储从随机数转换的ASCII。让我们看一下以下代码：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The seed random `srand()` function is the same as what we used in our previous
    code to generate a random seed. We used it in order to produce a different number
    every time the `rand()` function is invoked. Let''s take a look at the following
    code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 种子随机`srand()`函数与我们在先前的代码中使用的相同，用于生成随机种子。我们使用它是为了在每次调用`rand()`函数时产生不同的数字。让我们看一下以下代码：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `for` iteration depends on the `passwordLength` parameter that the user
    has defined. With the random number generator statement `std::rand() % 94 + 33`,
    we can generate the number that represents the ASCII printable character based
    on its code from 33 to 126\. For more detailed information about the ASCII code
    table, you can go to [http://en.wikipedia.org/wiki/ASCII](http://en.wikipedia.org/wiki/ASCII).
    Let''s take a look at the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`迭代取决于用户定义的`passwordLength`参数。通过随机数生成器语句`std::rand() % 94 + 33`，我们可以生成表示ASCII可打印字符的数字，其代码范围从33到126。有关ASCII代码表的更详细信息，您可以访问[http://en.wikipedia.org/wiki/ASCII](http://en.wikipedia.org/wiki/ASCII)。让我们看一下以下代码：'
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `#include` header''s single line will call all headers included in the
    `pwgen_fn.h` file, so we do not need to declare the included header in this source
    file as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include`头文件的单行将调用`pwgen_fn.h`文件中包含的所有头文件，因此我们不需要在此源文件中声明包含的头文件。'
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we move to our main entry code, which is stored in the `passgen.cpp` file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们转到我们的主要入口代码，存储在`passgen.cpp`文件中：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, the user decides how long a password he/she wants to have, and the program
    stores it in the `passLen` variable:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户决定要拥有多长的密码，并且程序将其存储在`passLen`变量中：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, the program instantiates the `PasswordGenerator` class and invokes the
    `Generate()` function to produce a password with the length that the user has
    defined before.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，程序实例化`PasswordGenerator`类并调用`Generate()`函数来生成用户之前定义的长度的密码。
- en: If you look at the `passgen.cpp` file again, you will find that there is a difference
    between the two forms of the include statement `#include <iostream>` (with angle
    brackets) and `#include "pwgen_fn.h"` (with quotation marks). By using angle brackets
    in the `#include` header statement, the compiler will look for the system header
    file directories, but does not look inside the current directory by default. With
    the quotation marks in the `#include` header statement, the compiler will search
    for the header files in the current directory before looking in the system header
    file directories.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次查看`passgen.cpp`文件，您会发现`#include <iostream>`（带有尖括号）和`#include "pwgen_fn.h"`（带有引号）两种形式的包含语句之间存在差异。通过在`#include`头语句中使用尖括号，编译器将查找系统头文件目录，但默认情况下不会查找当前目录。通过在`#include`头语句中使用引号，编译器将在查找系统头文件目录之前在当前目录中搜索头文件。
- en: Compiling and linking a program separately
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分别编译和链接程序
- en: We can split up a large program into a set of source files and compile them
    separately. Suppose we have many tiny files and we just want to edit a single
    line in one of the files, it will be very time consuming if we compile all the
    files while we just need to modify a single file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个大型程序分解为一组源文件并分别编译它们。假设我们有许多小文件，我们只想编辑其中一个文件中的一行，如果我们编译所有文件，而我们只需要修改一个文件，那将是非常耗时的。
- en: 'By using the `-c` option, we can compile the individual source code to produce
    an object file that has the `.o` extension. In this first stage, a file is compiled
    without creating an executable file. Then, in the second stage, the object files
    are linked together by a separate program called the linker. The linker combines
    all the object files together to create a single executable file. Using the previous
    `passgen.cpp`, `pwgen_fn.cpp`, and `pwgen_fn.h` source files, we will try to create
    two object files and then link them together to produce a single executable file.
    Use the following two commands to do the same:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`-c`选项，我们可以编译单独的源代码以生成具有`.o`扩展名的目标文件。在第一阶段，文件被编译而不创建可执行文件。然后，在第二阶段，目标文件由一个名为链接器的单独程序链接在一起。链接器将所有目标文件组合在一起，创建一个单一的可执行文件。使用之前的`passgen.cpp`，`pwgen_fn.cpp`和`pwgen_fn.h`源文件，我们将尝试创建两个目标文件，然后将它们链接在一起以生成一个单一的可执行文件。使用以下两个命令来执行相同的操作：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first command, using the `-c` option, will create two object files that
    have the same name as the source file name, but with different extensions. The
    second command will link them together and produce the output executable file
    that has the name stated after the `-o` option, which is the `passgen.exe` file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令使用`-c`选项将创建两个具有与源文件名相同但具有不同扩展名的目标文件。第二个命令将将它们链接在一起，并生成具有在`-o`选项之后指定的名称的输出可执行文件，即`passgen.exe`文件。
- en: 'In case you need to edit the `passgen.cpp` file without touching the two other
    files, you just require to compile the `passgen.cpp` file, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要编辑`passgen.cpp`文件而不触及其他两个文件，您只需要编译`passgen.cpp`文件，如下所示：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then, you need to run the linking command like the preceding second command.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要像前面的第二个命令一样运行链接命令。
- en: Detecting a warning in the C++ program
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测C++程序中的警告
- en: 'As we discussed previously, a compiler warning is an essential aid to be sure
    of the code''s validity. Now, we will try to find the error from the code that
    we created. Here is a C++ code that contains an uninitialized variable, which
    will give us an unpredictable result:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，编译器警告是确保代码有效性的重要辅助工具。现在，我们将尝试从我们创建的代码中找到错误。这是一个包含未初始化变量的C++代码，这将给我们一个不可预测的结果：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we will run the following command to compile the preceding `warning.cpp`
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将运行以下命令来编译前面的`warning.cpp`代码：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Sometimes, we are unable to detect this error since it is not obvious at the
    first sight. However, by enabling the `-Wall` option, we can prevent the error
    because if we compile the preceding code with the warning option enabled, the
    compiler will produce a warning message, as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们无法检测到这个错误，因为一开始并不明显。但是，通过启用`-Wall`选项，我们可以防止错误，因为如果我们使用警告选项编译前面的代码，编译器将产生警告消息，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The warning message says that the `age` variable is not initialized in the `warning.cpp`
    file on the line 7, column 52\. The messages produced by GCC always have the **file:line-number:column-number:error-type:message**
    form. The error type distinguishes between the error messages, which prevent the
    successful compilation, and warning messages, which indicate the possible problems
    (but do not stop the program from compiling).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 警告消息说`age`变量在`warning.cpp`文件的第7行，第52列未初始化。GCC生成的消息始终具有**file:line-number:column-number:error-type:message**的形式。错误类型区分了阻止成功编译的错误消息和指示可能问题的警告消息（但不会阻止程序编译）。
- en: Clearly, it is very dangerous to develop a program without checking for compiler
    warnings. If there are any functions that are not used correctly, they can cause
    the program to crash or produce incorrect results. After turning the compiler
    warning option on, the `-Wall` option catches many of the common errors that occur
    in C++ programming.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，开发程序而不检查编译器警告是非常危险的。如果有任何未正确使用的函数，它们可能会导致程序崩溃或产生不正确的结果。打开编译器警告选项后，`-Wall`选项会捕获C++编程中发生的许多常见错误。
- en: Knowing other important options in the GCC C++ compiler
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GCC C++编译器中了解其他重要选项
- en: 'GCC supports **ISO C++ 1998**, **C++ 2003**, and also **C++ 2011** standard
    in version 4.9.2\. Selecting this standard in GCC is done using one of these options:
    `-ansi`, `-std=c++98`, `-std=c++03`, or `–std=c++11`. Let''s look at the following
    code and give it the name `hash.cpp`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: GCC在4.9.2版本中支持**ISO C++ 1998**、**C++ 2003**和**C++ 2011**标准。在GCC中选择此标准是使用以下选项之一：`-ansi`、`-std=c++98`、`-std=c++03`或`–std=c++11`。让我们看看以下代码，并将其命名为`hash.cpp`：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you compile and run the program, it will give you a hash number for every
    plain text user input. However, it is little tricky to compile the preceding code.
    We have to define which ISO standard we want to use. Let''s take a look at the
    following five compilation commands and try them one by one in our Command Prompt
    window:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译并运行程序，它将为每个纯文本用户输入给出一个哈希数。然而，编译上述代码有点棘手。我们必须定义要使用的ISO标准。让我们看看以下五个编译命令，并在命令提示符窗口中逐个尝试它们：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we run the first four preceding compilation commands, we should get the
    following error message:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的四个编译命令时，应该会得到以下错误消息：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It says that there is no `hash` in the `std` class. Actually, this is not true
    as a hash has been defined in the header `<string>` since C++ 2011\. To solve
    this problem, we can run the last preceding compilation command, and if it does
    not throw an error anymore, then we can run the program by typing `hash` in the
    console window.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它说`std`类中没有`hash`。实际上，自C++ 2011以来，头文件`<string>`中已经定义了哈希。为了解决这个问题，我们可以运行上述最后一个编译命令，如果不再抛出错误，那么我们可以在控制台窗口中输入`hash`来运行程序。
- en: '![Knowing other important options in the GCC C++ compiler](img/00010.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![在GCC C++编译器中了解其他重要选项](img/00010.jpeg)'
- en: As you can see in the preceding screenshot, I invoked the program twice and
    gave **Packt** and **packt** as the input. Although I just changed a character,
    the entire hash changed dramatically. This is why hashing is used to detect any
    change in data or a file if they are transferred, just to make sure the data is
    not altered.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，我调用了程序两次，并将**Packt**和**packt**作为输入。尽管我只改变了一个字符，但整个哈希值发生了巨大变化。这就是为什么哈希用于检测数据或文件的任何更改，以确保数据没有被更改。
- en: For more information about ISO C++11 features available in GCC, go to [http://gcc.gnu.org/projects/cxx0x.html](http://gcc.gnu.org/projects/cxx0x.html).
    To obtain all the diagnostics required by the standard, you should also specify
    the `-pedantic` option (or the `-pedantic-errors` option if you want to handle
    warnings as errors).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有关GCC中可用的ISO C++11功能的更多信息，请访问[http://gcc.gnu.org/projects/cxx0x.html](http://gcc.gnu.org/projects/cxx0x.html)。要获得标准所需的所有诊断，还应指定`-pedantic`选项（或`-pedantic-errors`选项，如果您希望将警告作为错误处理）。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `-ansi` option alone does not cause non-ISO programs to be rejected gratuitously.
    For that, the `-pedantic` option or the `-pedantic-errors` option is required
    in addition with the `-ansi` option.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`-ansi`选项本身不会导致非ISO程序被毫无根据地拒绝。为此，还需要`-ansi`选项以及`-pedantic`选项或`-pedantic-errors`选项。'
- en: Troubleshooting in the GCC C++ compiler
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCC C++编译器中的故障排除
- en: GCC provides several help and diagnostic options to assist in troubleshooting
    problems with the compilation process. The options that you can use to ease your
    troubleshooting process are explained in the upcoming sections.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: GCC提供了几个帮助和诊断选项，以帮助解决编译过程中的问题。您可以使用的选项来简化故障排除过程在接下来的部分中进行了解。
- en: Help for command-line options
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行选项的帮助
- en: 'Use the `help` options to get a summary of the top-level GCC command-line options.
    The command for this is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`help`选项获取GCC命令行选项的摘要。命令如下：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To display a complete list of the options for GCC and its associated programs,
    such as the GNU Linker and GNU Assembler, use the preceding `help` option with
    the verbose (`-v`) option:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示GCC及其关联程序（如GNU链接器和GNU汇编器）的完整选项列表，请使用前面的`help`选项和详细（`-v`）选项：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The complete list of options produced by the preceding command is extremely
    long—you may wish to go through it using the `more` command or redirect the output
    to a file for reference, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由上述命令生成的选项的完整列表非常长-您可能希望使用`more`命令查看它，或将输出重定向到文件以供参考，如下所示：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Version numbers
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本号
- en: 'You can find the version number of your installed GCC installation using the
    `version` option, as shown in the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`version`选项找到已安装的GCC版本号，如下所示：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In my system, if I run the preceding command, I will get an output like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统中，如果运行上述命令，将会得到如下输出：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This depends on your setting that you adjust at the installation process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于您在安装过程中调整的设置。
- en: The version number is important when investigating compilation problems, since
    older versions of GCC may be missing some features that a program uses. The version
    number has the `major-version.minor-version` or `major-version.minor-version.micro-version`
    form, where the additional third "micro" version number (as shown in the preceding
    command) is used for subsequent bug fix releases in a release series.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号在调查编译问题时非常重要，因为较旧版本的GCC可能缺少程序使用的某些功能。版本号采用`major-version.minor-version`或`major-version.minor-version.micro-version`的形式，其中额外的第三个“micro”版本号（如前述命令中所示）用于发布系列中随后的错误修复版本。
- en: The verbose compilation
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细编译
- en: 'The `-v` option can also be used to display detailed information about the
    exact sequence of commands that are used to compile and link a program. Here is
    an example that shows you the verbose compilation of the `hello.cpp` program:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`选项还可以用于显示关于用于编译和链接程序的确切命令序列的详细信息。以下是一个示例，展示了`hello.cpp`程序的详细编译过程：'
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After this, you will get something like this in the console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在控制台中会得到类似以下内容：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The output produced by the `-v` option can be useful whenever there is a problem
    with the compilation process itself. It displays the full directory paths used
    to search for header files and libraries, the predefined preprocessor symbols,
    and the object files and libraries used for linking.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-v`选项生成的输出在编译过程中出现问题时非常有用。它显示用于搜索头文件和库的完整目录路径，预定义的预处理器符号，以及用于链接的目标文件和库。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We successfully prepared the C++ compiler and you learned how to compile the
    source code file you created using the compiler. Do not forget to use the `-Wall`
    (Warning All) option every time you compile the source code because it is important
    to avoid a warning and subtle error. Also, it is important to use the `-ansi`
    and `-pedantic` options so that your source code is able to be compiled in any
    compiler, as it will check the ANSI standard and reject non-ISO programs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功准备了C++编译器，并且您学会了如何使用编译器编译您创建的源代码文件。在编译源代码时，请不要忘记每次都使用`-Wall`（警告所有）选项，因为避免警告和细微错误非常重要。此外，使用`-ansi`和`-pedantic`选项也很重要，这样您的源代码就能够在任何编译器中编译，因为它将检查ANSI标准并拒绝非ISO程序。
- en: Now, we can go to the next chapter to learn the networking concept so that you
    can understand network architecture in order to ease your network application
    programming process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进入下一章学习网络概念，以便您能够理解网络架构，从而简化您的网络应用程序编程过程。
