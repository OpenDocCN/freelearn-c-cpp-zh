- en: 4\. Data Structures and LINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 数据结构和 LINQ
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn about the main collections and their primary
    usage in C#. You will then see how Language-Integrated Query (LINQ) can be used
    to query collections in memory using code that is efficient and succinct. By the
    end of this chapter, you will be well versed in using LINQ for operations such
    as sorting, filtering, and aggregating data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 C# 中主要集合及其主要用法。然后，您将看到如何使用语言集成查询（LINQ）来查询内存中的集合，使用高效且简洁的代码。通过本章结束时，您将熟练掌握使用
    LINQ 进行排序、过滤和聚合数据等操作。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Throughout the previous chapters, you have used variables that refer to a single
    value, such as the `string` and `double` system types, system `class` instances,
    and your own class instances. .NET has a variety of data structures that can be
    used to store multiple values. These structures are generally referred to as collections.
    This chapter builds on this concept by introducing collection types from the `System.Collections.Generic`
    namespace.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，您已经使用了引用单个值的变量，例如 `string` 和 `double` 系统类型，系统 `class` 实例以及您自己的类实例。.NET
    有各种数据结构，可以用来存储多个值。这些结构通常被称为集合。本章将在此概念的基础上介绍来自 `System.Collections.Generic` 命名空间的集合类型。
- en: You can create variables that can store multiple object references using collection
    types. Such collections include lists that resize to accommodate the number of
    elements and dictionaries that offer access to the elements using a unique key
    as an identifier. For example, you may need to store a list of international dialing
    codes using the codes as unique identifiers. In this case, you need to be certain
    that the same dialing code is not added to the collection twice.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用集合类型创建可以存储多个对象引用的变量。这些集合包括根据元素数量调整大小的列表和使用唯一键作为标识符访问元素的字典。例如，您可能需要存储一组国际电话区号，并使用区号作为唯一标识符。在这种情况下，您需要确保不会将相同的电话区号添加到集合中两次。
- en: These collections are instantiated like any other classes and are used extensively
    in most applications. Choosing the correct type of collection depends primarily
    on how you intend to add items and the way you would like to access such items
    once they are in a collection. The commonly used collection types include `List`,
    `Set`, and `HashSet`, which you will cover in detail shortly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些集合与其他类一样实例化，并且在大多数应用程序中被广泛使用。选择正确类型的集合主要取决于您打算如何添加项目以及一旦项目在集合中后您希望如何访问这些项目。常用的集合类型包括
    `List`、`Set` 和 `HashSet`，您将很快详细介绍它们。
- en: LINQ is a technology that offers an expressive and concise syntax for querying
    objects. Much of the complexities around filtering, sorting, and grouping objects
    can be removed using the SQL-like language, or if you prefer, a set of extension
    methods that can be chained together to produce collections that can be enumerated
    with ease.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 是一种技术，它提供了一种用于查询对象的表达性和简洁的语法。使用类似 SQL 的语言或者一组可以链接在一起产生可以轻松枚举的集合的扩展方法，可以消除大部分围绕过滤、排序和分组对象的复杂性。
- en: Data Structures
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: .NET provides various types of in-built data structures, such as the `Array`,
    `List`, and `Dictionary` types. At the heart of all data structures are the `IEnumerable`
    and `ICollection` interfaces. Classes that implement these interfaces offer a
    way to enumerate through the individual elements and to manipulate their items.
    There is rarely a need to create your own classes that derive directly from these
    interfaces, as all the required functionality is covered by the built-in collection
    types, but it is worth knowing the key properties as they are heavily used throughout
    .NET.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了各种内置数据结构类型，例如 `Array`、`List` 和 `Dictionary` 类型。所有数据结构的核心都是 `IEnumerable`
    和 `ICollection` 接口。实现这些接口的类提供了枚举各个元素和操作它们的方法。很少需要创建直接从这些接口派生的自定义类，因为内置的集合类型已经涵盖了所有所需的功能，但了解关键属性是值得的，因为它们在整个
    .NET 中被广泛使用。
- en: The generic version of each collection type requires a single type parameter,
    which defines the type of elements that can be added to a collection, using the
    standard `<T>` syntax of the generic types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每种集合类型的泛型版本都需要一个类型参数，该参数定义了可以添加到集合中的元素类型，使用泛型类型的标准 `<T>` 语法。
- en: The `IEnumerable` interface has a single property, that is, `IEnumerator<T>
    GetEnumerator()`. This property returns a type that provides methods that allow
    the caller to iterate through the elements in the collection. You do not need
    to call the `GetEnumerator()` method directly, as the compiler will call it whenever
    you use a `foreach` statement, such as `foreach(var book in books)`. You will
    learn more about using this in the upcoming sections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable` 接口具有一个属性，即 `IEnumerator<T> GetEnumerator()`。此属性返回一个类型，该类型提供允许调用者遍历集合中元素的方法。您不需要直接调用
    `GetEnumerator()` 方法，因为编译器会在您使用 `foreach` 语句时调用它，例如 `foreach(var book in books)`。您将在接下来的章节中了解更多关于如何使用它的内容。'
- en: 'The `ICollection` interface has the following properties:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICollection` 接口具有以下属性：'
- en: '`int Count { get; }`: Returns the number of items in the collection.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int Count { get; }`: 返回集合中的项数。'
- en: '`bool IsReadOnly { get; }`: Indicates if the collection is read-only. Certain
    collections can be marked as read-only to prevent callers from adding, deleting,
    or moving elements in the collection. C# will not prevent you from amending the
    properties of individual items in a read-only collection.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool IsReadOnly { get; }`: 指示集合是否为只读。某些集合可以标记为只读，以防止调用者向集合中添加、删除或移动元素。C# 不会阻止您修改只读集合中各个项的属性。'
- en: '`void Add(T item)`: Adds an item of type `<T>` to the collection.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Add(T item)`: 向集合中添加类型 `<T>` 的项。'
- en: '`void Clear()`: Removes all items from the collection.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Clear()`: 从集合中移除所有项。'
- en: '`bool Contains(T item)`: Returns `true` if the collection contains a certain value.
    Depending on the type of item in the collection, this can be value-equality, where
    an object is similarly based on its members, or reference-equality, where the
    object points to the same memory location.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool Contains(T item)`: 如果集合包含特定值，则返回`true`。根据集合中项目的类型，这可以是值相等，其中对象基于其成员相似，或引用相等，其中对象指向相同的内存位置。'
- en: '`void CopyTo(T[] array, int arrayIndex)`: Copies each element from the collection
    into the target array, starting with the first element at a specified index position.
    This can be useful if you need to skip a specific number of elements from the
    beginning of the collection.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void CopyTo(T[] array, int arrayIndex)`: 将集合中的每个元素复制到目标数组中，从指定索引位置的第一个元素开始。如果您需要跳过集合开头的特定数量的元素，这可能很有用。'
- en: '`bool Remove(T item)`: Removes the specified item from the collection. If there
    are multiple occurrences of the instance, then only the first instance is removed.
    This returns `true` if an item was successfully removed.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool Remove(T item)`: 从集合中移除指定的项目。如果实例有多个出现，则只移除第一个实例。如果成功移除项目，则返回`true`。'
- en: '`IEnumerable` and `ICollection` are interfaces that all collections implement:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable`和`ICollection`是所有集合实现的接口：'
- en: '![Figure 4.1: ICollection and IEnumerable class diagram'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：ICollection和IEnumerable类图'
- en: '](img/B16835_04_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_04_01.jpg)'
- en: 'Figure 4.1: ICollection and IEnumerable class diagram'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：ICollection和IEnumerable类图
- en: There are further interfaces that some collections implement, depending on how
    elements are accessed within a collection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有进一步的接口，一些集合实现，取决于如何在集合中访问元素。
- en: The `IList` interface is used for collections that can be accessed by index
    position, starting from zero. So, for a list that contains two items, `Red` and
    `Blue`, the element at index zero is `Red` and the element at index one is `Blue`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`IList`接口用于可以根据索引位置访问的集合，从零开始。因此，对于包含两个项目`Red`和`Blue`的列表，索引零处的元素是`Red`，索引一处的元素是`Blue`。'
- en: '![Figure 4.2: IList class diagram'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：IList类图'
- en: '](img/B16835_04_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_04_02.jpg)'
- en: 'Figure 4.2: IList class diagram'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：IList类图
- en: 'The `IList` interface has the following properties:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`IList`接口具有以下属性：'
- en: '`T this[int index] { get; set; }`: Gets or sets the element at the specified
    index position.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T this[int index] { get; set; }`: 获取或设置指定索引位置的元素。'
- en: '`int Add(T item)`: Adds the specified item and returns the index position of
    that item in the list.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int Add(T item)`: 添加指定的项目并返回该项目在列表中的索引位置。'
- en: '`void Clear()`: Removes all items from the list.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Clear()`: 从列表中移除所有项目。'
- en: '`bool Contains(T item)`: Returns `true` if the list contains the specified item.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool Contains(T item)`: 如果列表包含指定的项目，则返回`true`。'
- en: '`int IndexOf(T item)`: Returns the index position of the item, or `-1` if not found.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int IndexOf(T item)`: 返回项目的索引位置，如果未找到则返回`-1`。'
- en: '`void Insert(int index, T item)`: Inserts the item at the index position specified.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Insert(int index, T item)`: 在指定的索引位置插入项目。'
- en: '`void Remove(T item)`: Removes the item if it exists within the list.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Remove(T item)`: 如果存在于列表中，则移除项目。'
- en: '`void RemoveAt(int index)`: Removes the item at the specified index position.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void RemoveAt(int index)`: 移除指定索引位置的项目。'
- en: You have now seen the primary interfaces common to collections. So, now you
    will now take a look at the main collection types that are available and how they
    are used.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了集合常见的主要接口。所以，现在您将看一下可用的主要集合类型以及它们的使用方式。
- en: Lists
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'The `List<T>` type is one of the most extensively used collections in C#. It
    is used where you have a collection of items and want to control the order of
    items using their index position. It implements the `IList` interface, which allows
    items to be inserted, accessed, or removed using an index position:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`类型是C#中最广泛使用的集合之一。它用于具有项目集合并希望使用它们的索引位置控制项目顺序的情况。它实现了`IList`接口，允许使用索引位置插入、访问或移除项目：'
- en: '![Figure 4.3: List class diagram'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：List类图'
- en: '](img/B16835_04_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_04_03.jpg)'
- en: 'Figure 4.3: List class diagram'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：List类图
- en: 'Lists have the following behavior:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表具有以下行为：
- en: Items can be inserted at any position within the collection. Any trailing items
    will have their index position incremented.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目可以在集合中的任何位置插入。任何尾随项目的索引位置将被递增。
- en: Items can be removed, either by index or value. This will also cause trailing
    items to have their index position updated.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目可以通过索引或值来移除。这也会导致尾随项目的索引位置更新。
- en: Items can be set using their index value.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用它们的索引值设置项目。
- en: Items can be added to the end of the collection.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目可以添加到集合的末尾。
- en: Items can be duplicated within the collection.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目可以在集合中复制。
- en: The position of items can be sorted using the various `Sort` methods.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用各种`Sort`方法对项目的位置进行排序。
- en: One example of a list might be the tabs in a web browser application. Typically,
    a user may want to drag a browser tab amongst other tabs, open new tabs at the
    end, or close tabs anywhere in a list of tabs. The code to control these actions
    can be implemented using `List`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的一个例子可能是Web浏览器应用程序中的选项卡。通常，用户可能希望在其他选项卡之间拖动浏览器选项卡，在末尾打开新选项卡，或在选项卡列表中的任何位置关闭选项卡。可以使用`List`来实现控制这些操作的代码。
- en: Internally, `List` maintains an array to store its objects. This can be efficient
    when adding items to the end, but it may be inefficient when inserting items,
    particularly near the beginning of the list, as the index position of items will
    need to be recalculated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`List`维护一个数组来存储其对象。当添加项目到末尾时，这可能是有效的，但在插入项目时可能是低效的，特别是在列表开头附近，因为项目的索引位置将需要重新计算。
- en: The following example shows how the generic `List` class is used. The code uses
    the `List<string>` type parameter, which allows `string` types to be added to
    the list. Attempts to add any other type will result in a compiler error. This
    will show the various commonly used methods of the `List` class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用通用的`List`类。代码使用了`List<string>`类型参数，允许将`string`类型添加到列表中。尝试添加任何其他类型将导致编译器错误。这将展示`List`类的各种常用方法。
- en: Create a new folder called `Chapter04` in your source code folder.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源代码文件夹中创建一个名为`Chapter04`的新文件夹。
- en: 'Change to the `Chapter04` folder and create a new console app, called `Chapter04`,
    using the following .NET command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Chapter04`文件夹并使用以下.NET命令创建一个新的控制台应用程序，名为`Chapter04`：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Delete the `Class1.cs` file.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`Class1.cs`文件。
- en: Add a new folder called `Examples`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Examples`的新文件夹。
- en: Add a new class file called `ListExamples.cs`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ListExamples.cs`的新类文件。
- en: 'Add the `System.Collections.Generic` namespace to access the `List<T>` class
    and declare a new variable called `colors`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`System.Collections.Generic`命名空间以访问`List<T>`类，并声明一个名为`colors`的新变量：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code declares the new `colors` variable, which can store multiple color
    names as `strings`. Here, the collection initialization syntax is used so that
    `red` and `green` are added as part of the initialization of the variable. The
    `Add` method is called, adding `orange` to the list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了新的`colors`变量，可以将多个颜色名称存储为`strings`。在这里，使用集合初始化语法，以便在变量的初始化中添加`red`和`green`。调用`Add`方法，将`orange`添加到列表中。
- en: 'Similarly, `AddRange` adds `yellow` and `pink` to the end of the list:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`AddRange`将`yellow`和`pink`添加到列表的末尾：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, there are five colors in the list, with `red` at index position
    `0` and `green` at position `1`. You can verify this using the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，列表中有五种颜色，`red`位于索引位置`0`，`green`位于位置`1`。您可以使用以下代码验证这一点：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running the code produces the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using `Insert`, `blue` can be inserted at the beginning of the list, that is,
    at index `0`, as shown in the following code. Note that this moves `red` from
    index `0` to `1` and all other colors will have their index incremented by one:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Insert`，可以将`blue`插入到列表的开头，即索引`0`处，如下面的代码所示。请注意，这将`red`从索引`0`移动到`1`，并且所有其他颜色的索引都将增加一个：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following output on running this code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，您应该看到以下输出：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using `foreach` you can iterate through the strings in the list, writing each
    string to the console, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`foreach`，您可以遍历列表中的字符串，将每个字符串写入控制台，如下所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should get the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, add the following code to reverse the array. Here, each `color` string
    is converted into an array of `char` type using `ToCharArray`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下代码来反转数组。在这里，每个`color`字符串都使用`ToCharArray`转换为`char`类型的数组：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This does not affect any of the values in the `colors` List, as `characters`
    refers to a different object. Note that `foreach` iterates through each string,
    whereas `ForEach` defines an Action delegate to be invoked using each string (recall
    that in *Chapter 3*, *Delegates, Events, and Lambdas*, you saw how lambda statements
    can be used to create `Action` delegates).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会影响`colors`列表中的任何值，因为`characters`指的是一个不同的对象。请注意，`foreach`会遍历每个字符串，而`ForEach`则定义了一个Action委托，用于使用每个字符串进行调用（回想一下，在*第3章*，*委托、事件和Lambda*中，您看到了如何使用lambda语句来创建`Action`委托）。
- en: 'Running the code leads to this output:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码会产生这个输出：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the next snippet, the `List` constructor accepts a source collection. This
    creates a new list containing a copy of the `colors` strings in this case, which
    is sorted using the default `Sort` implementation:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个片段中，`List`构造函数接受一个源集合。这将创建一个新列表，其中包含`colors`字符串的副本，在这种情况下，使用默认的`Sort`实现进行排序：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The string type uses value-type semantics, which means that the `backupColors`
    list is populated with a **copy** of each source string value. Updating a string
    in one list will **not** affect the other list. Conversely, classes are defined
    as reference-types so passing a list of class instances to the constructor will
    still create a new list, with independent element indexes, but each element will
    point to the same shared reference in memory rather than an independent copy.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串类型使用值类型语义，这意味着`backupColors`列表中填充了每个源字符串值的**副本**。更新一个列表中的字符串**不会**影响另一个列表。相反，类被定义为引用类型，因此将类实例列表传递给构造函数仍将创建一个新列表，具有独立的元素索引，但每个元素将指向内存中相同的共享引用，而不是独立的副本。
- en: 'In the following snippet, prior to removing all colors (using `colors.Clear`),
    each value is written to the console (the list will be repopulated shortly):'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在删除所有颜色之前（使用`colors.Clear`），在以下片段中将每个值写入控制台（列表将很快重新填充）：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the code produces this output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生这个输出：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, `AddRange` is used again, to add the full list of colors back to the
    `colors` list, using the sorted `backupColors` items as a source:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次使用`AddRange`，将颜色的完整列表添加回`colors`列表，使用排序后的`backupColors`项目作为源：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ConvertAll` method is passed a delegate that can be used to return a new
    list of any type:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConvertAll`方法传递了一个委托，该委托可用于返回任何类型的新列表：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, a new `List<string>` is returned with each item being formatted using
    its value and the item''s index in the list. As expected, running the code produces
    this output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，返回一个新的`List<string>`，其中每个项目都使用其值和列表中的索引进行格式化。预期地，运行代码会产生这个输出：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the next snippet, two `Contains()` methods are used to show string value-equality
    in action:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个片段中，使用两个`Contains()`方法来展示字符串值相等的情况：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that the uppercase `RED` is `red` will be. Running the code produces this
    output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大写的`RED`是`red`。运行代码会产生这个输出：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, add the following snippet:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下片段：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the `Exists` method is passed a Predicate delegate, which returns `True`
    or `False` if the test condition is met. Predicate is an inbuilt delegate, which
    returns a boolean value. In this case, `True` will be returned if any item exists
    where the string value ends with the letters `ink` (`pink`, for example).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Exists`方法传递了一个Predicate委托，如果测试条件满足，则返回`True`或`False`。Predicate是一个内置的委托，它返回一个布尔值。在这种情况下，如果存在任何以字母`ink`结尾的字符串值（例如`pink`），则将返回`True`。
- en: 'You should see the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You know there is already a `red` color, but it will be interesting to see
    what happens if you insert `red` again, twice, at the very beginning of the list:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您知道已经有一个`red`颜色，但如果您再次在列表的开头插入`red`两次，会很有趣看看会发生什么：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will get the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This shows that it is possible to insert the same item more than once into a
    list.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明可以将相同的项目多次插入到列表中。
- en: 'The next snippet shows you how to use the `FindAll` method. `FindAll` is similar
    to the `Exists` method, in that it is passed a `Predicate` condition. All items
    that match that rule will be returned. Add the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个片段向您展示了如何使用`FindAll`方法。`FindAll`类似于`Exists`方法，因为它传递了一个`Predicate`条件。所有符合该规则的项目都将被返回。添加以下代码：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should get an output as follows. As expected, there are three `red` items returned:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出。预期地，返回了三个`red`项：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finishing the example, the `Remove` method is used to remove the first `red`
    from the list. There are still two `FindLastIndex` to get the index of the last
    `red` item:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成示例后，使用`Remove`方法从列表中删除第一个`red`。仍然有两个`FindLastIndex`来获取最后一个`red`项的索引：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running the code produces this output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/dLbK6](https://packt.link/dLbK6).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/dLbK6](https://packt.link/dLbK6)找到此示例使用的代码。
- en: With the knowledge of how the generic `List` class is used, it is time for you
    to work on an exercise.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解泛型`List`类的使用方式，现在是时候开始练习了。
- en: 'Exercise 4.01: Maintaining Order within a List'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.01：在列表中保持顺序
- en: At the beginning of the chapter, web browser tabs were described as an ideal
    example of lists. In this exercise, you will put this idea into action, and create
    a class that controls the navigation of the tabs within an app that mimics a web
    browser.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，Web浏览器选项卡被描述为列表的理想示例。在这个练习中，您将把这个想法付诸实践，并创建一个控制选项卡导航的类，该类模拟了Web浏览器的应用程序。
- en: 'For this, you will create a `Tab` class and a `TabController` app that allows
    new tabs to be opened and existing tabs to be closed or moved. The following steps
    will help you complete this exercise:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您将创建一个`Tab`类和一个`TabController`应用程序，允许打开新选项卡并关闭或移动现有选项卡。以下步骤将帮助您完成此练习：
- en: In VSCode, select your `Chapter04` project.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VSCode中，选择您的`Chapter04`项目。
- en: Add a new folder called `Exercises`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Exercises`的新文件夹。
- en: Inside the `Exercises` folder, add a folder called `Exercise01` and add a file
    called `Exercise01.cs`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exercises`文件夹中，添加一个名为`Exercise01`的文件夹，并添加一个名为`Exercise01.cs`的文件。
- en: 'Open `Exercise01.cs` and define a `Tab` class with a string URL constructor
    parameter as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise01.cs`，并定义一个带有字符串URL构造函数参数的`Tab`类，如下所示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the `ToString` method has been overridden to return the current URL to
    help when logging details to the console.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ToString`方法已被重写以返回当前的URL，以帮助在控制台中记录详细信息。
- en: 'Create the `TabController` class as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`TabController`类如下：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `TabController` class contains a List of tabs. Notice how the class inherits
    from the `IEnumerable` interface. This interface is used so that the class provides
    a way to iterate through its items, using a `foreach` statement. You will provide
    methods to open, move, and close tabs, which will directly control the order of
    items in the `_tabs` list, in the next steps. Note that you could have exposed
    the `_tabs` list directly to callers, but it would be preferable to limit access
    to the tabs through your own methods. Hence, it is defined as a `readonly` list.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabController`类包含一个选项卡列表。请注意类如何从`IEnumerable`接口继承。此接口用于使类提供一种通过`foreach`语句迭代其项目的方法。您将提供打开、移动和关闭选项卡的方法，这些方法将直接控制`_tabs`列表中项目的顺序，在接下来的步骤中。请注意，您可以直接向调用者公开`_tabs`列表的，但最好通过自己的方法限制对选项卡的访问。因此，它被定义为`readonly`列表。'
- en: 'Next, define the `OpenNew` method, which adds a new tab to the end of the list:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义`OpenNew`方法，将新选项卡添加到列表的末尾：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define another method, `Close`, which removes the tab from the list if it exists.
    Add the following code for this:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个方法`Close`，如果存在，则从列表中删除选项卡。添加以下代码：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To move a tab to the start of the list, add the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将选项卡移动到列表的开头，请添加以下代码：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, `MoveToStart` will try to remove the tab and then insert it at index `0`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MoveToStart`将尝试删除选项卡，然后将其插入到索引`0`。
- en: 'Similarly, add the following code to move a tab to the end:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，添加以下代码将选项卡移动到末尾：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, calling `MoveToEnd` removes the tab first, and then adds it to the end,
    logging the new index position to the console.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用`MoveToEnd`首先删除选项卡，然后将其添加到末尾，并将新的索引位置记录到控制台。
- en: Finally, the `IEnumerable` interface requires that you implement two methods,
    `IEnumerator<Tab> GetEnumerator()` and `IEnumerable.GetEnumerator()`. These allow
    the caller to iterate through a collection using either a generic of type `Tab`
    or using the second method to iterate via an object-based type. The second method
    is a throwback to earlier versions of C# but is needed for compatibility.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`IEnumerable`接口要求您实现两种方法，`IEnumerator<Tab> GetEnumerator()`和`IEnumerable.GetEnumerator()`。这允许调用者使用`Tab`类型的泛型或使用第二种方法通过基于对象的类型进行迭代。第二种方法是对C#早期版本的回溯，但是需要兼容性。
- en: 'For the actual results for both methods, you can use the `GetEnumerator` method
    of the `_tab` list, as that contains the tabs in list form. Add the following
    code to do so:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这两种方法的实际结果，可以使用`_tab`列表的`GetEnumerator`方法，因为它包含列表形式的选项卡。添加以下代码来执行此操作：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can now create a console app that tests the controller''s behavior. Start
    by opening three new tabs and logging the tab details via `LogTabs` (this will
    be defined shortly):'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以创建一个控制台应用程序来测试控制器的行为。首先打开三个新选项卡，并通过`LogTabs`记录选项卡的详细信息（稍后将定义）：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, move `amazon` to the start and `packt` to the end, and log the tab details:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`amazon`移到开头，将`packt`移到末尾，并记录选项卡的详细信息：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Close the `msoft` tab and log details once more:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`msoft`选项卡并再次记录详细信息：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, add an extension method that helps log the URL of each tab in `TabController`.
    Define this as an extension method for `IEnumerable<Tab>`, rather than `TabController`,
    as you simply need an iterator to iterate through the tabs using a `foreach` loop.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个扩展方法，帮助记录`TabController`中每个选项卡的URL。将其定义为`IEnumerable<Tab>`的扩展方法，而不是`TabController`，因为您只需要一个迭代器来使用`foreach`循环遍历选项卡。
- en: 'Use `PadRight` to left-align each URL, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PadRight`将每个URL左对齐，如下所示：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running the code produces the following output:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes Visual Studio might report a non-nullable property error the first
    time you execute the program. This is a helpful reminder that you are attempting
    to use a string value that may have a null value at runtime.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有时Visual Studio在第一次执行程序时可能会报告非空属性错误。这是一个有用的提醒，说明您正在尝试在运行时使用可能具有空值的字符串值。
- en: The three tabs are opened. `amazon.com` and `packtpub.com` are then moved before
    `microsoft.com` is finally closed and removed from the tab list.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 打开了三个选项卡。然后将`amazon.com`和`packtpub.com`移动到`microsoft.com`之前，最后关闭并从选项卡列表中移除`microsoft.com`。
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/iUcIs](https://packt.link/iUcIs).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/iUcIs](https://packt.link/iUcIs)找到此练习使用的代码。
- en: In this exercise, you have seen how lists can be used to store multiple items
    of the same type while maintaining the order of items. The next section covers
    the `Queue` and `Stack` classes, which allow items to be added and removed in
    a predefined sequence.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已经看到了如何使用列表来存储相同类型的多个项目，并保持项目的顺序。下一节将介绍`Queue`和`Stack`类，这些类允许按照预定义的顺序添加和移除项目。
- en: Queues
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列
- en: The Queue class provides a first-in, first-out mechanism. Items are added to
    the end of the queue using the `Enqueue` method and are removed from the front
    of the queue using the `Dequeue` method. Items in the queue cannot be accessed
    via an index element.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 队列类提供了先进先出的机制。项目使用`Enqueue`方法添加到队列的末尾，并使用`Dequeue`方法从队列的前面移除。队列中的项目不能通过索引元素访问。
- en: Queues are typically used when you need a workflow that ensures items are processed
    in the order in which they are added to the queue. A typical example might be
    a busy online ticketing system selling a limited number of concert tickets to
    customers. To ensure fairness, customers are added to a queuing system as soon
    as they log on. The system would then dequeue each customer and process each order,
    in full, either until all tickets have been sold or the customer queue is empty.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在需要确保项目按照添加到队列中的顺序进行处理的工作流程中使用队列。一个典型的例子可能是一个繁忙的在线售票系统，向顾客出售有限数量的音乐会门票。为了确保公平，顾客在登录后立即被添加到排队系统中。然后系统将出队每个顾客并处理每个订单，直到所有门票售完或顾客队列为空为止。
- en: The following example creates a queue containing five `CustomerOrder` records.
    When it is time to process the orders, each order is dequeued using the `TryDequeue`
    method, which will return `true` until all orders have been processed. The customer
    orders are processed in the order that they were added. If the number of tickets
    requested is more than or equal to the tickets remaining, then the customer is
    shown a success message. An apology message is shown if the number of tickets
    remaining is less than the requested amount.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建一个包含五个`CustomerOrder`记录的队列。当需要处理订单时，每个订单都将使用`TryDequeue`方法出队，直到所有订单都被处理。顾客订单按照添加的顺序进行处理。如果请求的门票数量大于或等于剩余的门票数量，则向顾客显示成功消息。如果剩余的门票数量少于请求的数量，则显示道歉消息。
- en: '![Figure 4.4: The Queue''s Enqueue() and Dequeue() workflow'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：队列的Enqueue()和Dequeue()工作流'
- en: '](img/B16835_04_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_04_04.jpg)'
- en: 'Figure 4.4: The Queue''s Enqueue() and Dequeue() workflow'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：队列的Enqueue()和Dequeue()工作流
- en: 'Perform the following steps to complete this example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此示例：
- en: 'In the `Examples` folder of your `Chapter04` source folder, add a new class
    called `QueueExamples.cs` and edit it as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter04`源文件夹的`Examples`文件夹中，添加一个名为`QueueExamples.cs`的新类，并编辑如下：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add five orders to the queue using the `Enqueue` method as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Enqueue`方法将五个订单添加到队列中，如下所示：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, use a `while` loop that repeats until `TryDequeue` returns `false`, meaning
    all current orders have been processed:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`while`循环，直到`TryDequeue`返回`false`，表示所有当前订单都已处理：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running the example code produces the following output:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例代码会产生以下输出：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The first time you run this program, Visual Studio might show a non-nullable
    type error. This error is a reminder that you are using a variable that could
    be a null value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此程序时，Visual Studio可能会显示非空类型错误。这个错误是一个提醒，说明您正在使用一个可能是空值的变量。
- en: The output shows that `Dave` requested two tickets. As there are two or more
    tickets available, he was successful. Both `Siva` and `Julien` were also successful,
    but by the time `Kane` placed his order of two tickets, there was only one ticket
    available, so he was shown the apology message. Finally, `Ann` requested one ticket
    and was successful in her order.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`Dave`请求了两张门票。由于有两张或更多的门票可用，他成功了。`Siva`和`Julien`也成功了，但当`Kane`下订单两张门票时，只剩下一张票了，所以他看到了道歉消息。最后，`Ann`请求了一张门票，并成功了。
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/Zb524](https://packt.link/Zb524).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/Zb524](https://packt.link/Zb524)找到此示例使用的代码。
- en: Stacks
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈
- en: The `Stack` class provides the opposite mechanism to the `Queue` class; items
    are processed in last-in, first-out order. As with the `Queue` class, you cannot
    access elements via their index position. Items are added to the stack using the
    `Push` method and removed using the `Pop` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack` 类提供了与 `Queue` 类相反的机制；项目按后进先出的顺序进行处理。与 `Queue` 类一样，你不能通过它们的索引位置访问元素。使用
    `Push` 方法将项目添加到堆栈中，并使用 `Pop` 方法将其移除。'
- en: An application's `Undo` menu can be implemented using a stack. For example,
    in a word processor, as the user edits a document, an `Action` delegate is created,
    which can reverse the most recent change whenever the user presses `Ctrl` + `Z`.
    The most recent action is popped off the stack and the change is undone. This
    allows multiple steps to be undone.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的 `Undo` 菜单可以使用堆栈来实现。例如，在文字处理器中，当用户编辑文档时，会创建一个 `Action` 委托，每当用户按下 `Ctrl`
    + `Z` 时，可以撤消最近的更改。最近的操作会从堆栈中弹出，然后更改会被撤消。这允许多个步骤被撤消。
- en: '![Figure 4.5: The Stack''s Push() and Pop() workflow'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5：堆栈的Push()和Pop()工作流'
- en: '](img/B16835_04_05.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_04_05.jpg)'
- en: 'Figure 4.5: The Stack''s Push() and Pop() workflow'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：堆栈的Push()和Pop()工作流
- en: The following example shows this in practice.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这一点。
- en: You will start by creating an `UndoStack` class that supports multiple undo
    operations. The caller decides what action should run each time the `Undo` request
    is called.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个支持多次撤消操作的 `UndoStack` 类。调用者决定每次调用 `Undo` 请求时应运行什么操作。
- en: 'A typical undoable operation would be storing a copy of text prior to the user
    adding a word. Another undoable operation would be storing a copy of the current
    font prior to a new font being applied. You can start by adding the following
    code, where you are creating the `UndoStack` class and defining a `readonly Stack
    of Action` delegates, named `_undoStack`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的可撤消操作是在用户添加单词之前存储文本的副本。另一个可撤消操作是在应用新字体之前存储当前字体的副本。你可以从以下代码开始，其中你正在创建 `UndoStack`
    类并定义了一个名为 `_undoStack` 的 `readonly Stack of Action` 委托：
- en: 'In your `Chapter04\Examples` folder, add a new class called `StackExamples.cs`
    and edit it as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Chapter04\Examples` 文件夹中，添加一个名为 `StackExamples.cs` 的新类，并编辑如下：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When the user has done something, the same action can be undone. So push an
    `Action` to the front of `_undoStack`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户完成某些操作时，可以撤消相同的操作。因此，将一个 `Action` 推送到 `_undoStack` 的前面：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Undo` method checks to see if there are any items to undo, then calls
    `Pop` to remove the most recent `Action` and invoke it, thus undoing the change
    that was just applied. The code for this can be added as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Undo` 方法检查是否有任何要撤消的项目，然后调用 `Pop` 来移除最近的 `Action` 并调用它，从而撤消刚刚应用的更改。可以将此代码添加如下：'
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you can create a `TextEditor` class that allows edits to be added to `UndoStack`.
    This constructor is passed `UndoStack` as there could be multiple editors that
    need to add various `Action` delegates to the stack:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以创建一个 `TextEditor` 类，允许编辑添加到 `UndoStack`。这个构造函数传递了 `UndoStack`，因为可能有多个编辑器需要将各种
    `Action` 委托添加到堆栈中：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, add the `EditText` command, which takes a copy of the `previousText`
    value and creates an `Action` delegate that can revert the text to its previous
    value, if invoked:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `EditText` 命令，它获取 `previousText` 值的副本，并创建一个 `Action` 委托，如果调用，可以将文本恢复到其先前的值：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, the `newText` value should be appended to the `Text` property, using the
    `+=` operator. The details for this are logged to the console, using `PadRight`
    to improve the format:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，应该使用 `+=` 运算符将 `newText` 值附加到 `Text` 属性。使用 `PadRight` 将此详细信息记录到控制台，以改善格式：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, it is time to create a console app that tests `TextEditor` and `UndoStack`.
    Four edits are initially made, followed by two **undo operations**, and finally
    two more text edits:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候创建一个测试 `TextEditor` 和 `UndoStack` 的控制台应用程序。首先进行四次编辑，然后进行两次**撤消操作**，最后进行两次文本编辑：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running the console app produces the following output:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生以下输出：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Visual Studio may show non-nullable property error the first time the code is
    executed. This is because Visual Studio notices that the `Text` property can be
    a null value at runtime so offers a suggestion to improve the code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行代码时，Visual Studio 可能会显示非空属性错误。这是因为 Visual Studio 注意到 `Text` 属性在运行时可能是一个空值，因此提供了改进代码的建议。
- en: The left-hand output shows the text edits and undoes operations as they are
    applied and the resulting `Text` value on the right-hand side. The two `Undo`
    calls result in `near by` and `city` being removed from the `Text` value, before
    `land` and `far far away` are finally added to the `Text` value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧输出显示了文本编辑和撤消操作的应用，右侧显示了结果的 `Text` 值。两次 `Undo` 调用导致 `Text` 值中的 `near by` 和
    `city` 被移除，最后将 `land` 和 `far far away` 添加到 `Text` 值中。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/tLVyf](https://packt.link/tLVyf).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/tLVyf](https://packt.link/tLVyf)找到此示例使用的代码。
- en: HashSets
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希集
- en: The `HashSet` class provides mathematical set operations with collections of
    objects in an efficient and highly performant manner. `HashSet` does not allow
    duplicate elements and items are not stored in any particular order. Using the
    `HashSet` class is ideal for high-performance operations, such as needing to quickly
    find where two collections of objects overlap.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet` 类以高效和高性能的方式提供了对象集合的数学集合操作。`HashSet` 不允许重复元素，并且项目不以任何特定顺序存储。使用 `HashSet`
    类非常适合高性能操作，例如需要快速找到两个对象集合重叠的位置。'
- en: 'Typically, `HashSet` is used with the following operations:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`HashSet` 与以下操作一起使用：
- en: '`public void UnionWith(IEnumerable<T> other)`: Produces a set union. This modifies
    `HashSet` to include the items present in the current `HashSet` instance, the
    other collection, or both.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void UnionWith(IEnumerable<T> other)`: 生成一个集合并。这会修改 `HashSet`，以包括当前
    `HashSet` 实例中存在的项目、其他集合中的项目，或两者都包括。'
- en: '`public void IntersectWith(IEnumerable<T> other)`: Produces a set intersect.
    This modifies `HashSet` to include items present in the current `HashSet` instance
    and the other collection.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void IntersectWith(IEnumerable<T> other)`: 生成一个集合交集。这将修改`HashSet`以包含当前`HashSet`实例和其他集合中存在的项。'
- en: '`public void ExceptWith(IEnumerable<T> other)`: Produces a set subtraction.
    This removes items from the `HashSet` that are present in the current `HashSet`
    instance and the other collection.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void ExceptWith(IEnumerable<T> other)`: 生成一个集合减法。这将从当前`HashSet`实例和其他集合中删除`HashSet`中存在的项。'
- en: '`HashSet` is useful when you need to include or exclude certain elements from
    **collections**. As an example, consider that an agent manages various celebrities
    and has been asked to find three sets of stars:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要从**集合**中包含或排除某些元素时，`HashSet`是很有用的。例如，考虑一个代理管理各种名人并被要求找到三组明星的情况：
- en: Those that can act **or** sing.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些可以扮演**或者**唱歌的人。
- en: Those that can act **and** sing.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些既可以扮演**又**可以唱歌的人。
- en: Those that can act **only** (no singers allowed).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些只能扮演**而不能**唱歌的人。
- en: 'In the following snippet, a list of actors'' and singers'' names is created:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中，创建了一个演员和歌手姓名的列表：
- en: 'In your `Chapter04\Examples` folder, add a new class called `HashSetExamples.cs`
    and edit it as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`HashSetExamples.cs`的新类，并编辑如下：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, create a new `HashSet` instance that initially contains singers only and
    then use `UnionWith` to modify the set to contain a distinct set of those that
    can act **or** sing:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个最初只包含歌手的新`HashSet`实例，然后使用`UnionWith`修改集合以包含那些可以扮演**或者**唱歌的不同集合：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For those that can act `HashSet` instance of singers, and modify the `HashSet`
    instance using `IntersectWith` to contain a distinct list of those that are in
    both collections:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于那些可以扮演`singers`的`HashSet`实例，并使用`IntersectWith`修改`HashSet`实例以包含两个集合中都存在的不同列表：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, for those that can `ExceptWith` to remove those from the `HashSet`
    instance that can also sing:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于那些可以使用`ExceptWith`从`HashSet`实例中移除那些也可以唱歌的人：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Running the console app produces the following output:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生以下输出：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: From the output, you can see that out of the given list of actors and singers,
    only `Will Smith` can act and sing.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，您可以看到在给定的演员和歌手名单中，只有`Will Smith`既可以扮演又可以唱歌。
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ZdNbS](https://packt.link/ZdNbS).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/ZdNbS](https://packt.link/ZdNbS)找到此示例使用的代码。
- en: Dictionaries
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: Another commonly used collection type is the generic `Dictionary<TK, TV>`. This allows
    multiple items to be added, but a unique **key** is needed to identify an item instance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的集合类型是通用的`Dictionary<TK, TV>`。这允许添加多个项，但需要一个唯一的**键**来标识一个项实例。
- en: Dictionaries are commonly used to look up values using known keys. The key and
    value type parameters can be of any type. A value can exist in a `Dictionary`
    more than once, provided that its key is **unique**. Attempting to add a key that
    already exists will result in a runtime exception being thrown.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 字典通常用于使用已知键查找值。键和值类型参数可以是任何类型。一个值可以在`Dictionary`中存在多次，只要它的键是**唯一**的。尝试添加已经存在的键将导致运行时异常被抛出。
- en: A common example of a `Dictionary` might be a registry of known countries that
    are keyed by their ISO country code. A customer service application may load customer
    details from a database and then use the ISO code to look up the customer's country
    from the country list, rather than having the extra overhead of creating a new
    country instance for each customer.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary`的一个常见示例可能是由其ISO国家代码作为键的已知国家的注册表。客户服务应用程序可以从数据库加载客户详细信息，然后使用ISO代码从国家列表中查找客户的国家，而不是为每个客户创建一个新的国家实例，从而产生额外的开销。'
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on standard ISO country codes at [https://www.iso.org/iso-3166-country-codes.html](https://www.iso.org/iso-3166-country-codes.html).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.iso.org/iso-3166-country-codes.html](https://www.iso.org/iso-3166-country-codes.html)找到有关标准ISO国家代码的更多信息。
- en: 'The main methods used in the `Dictionary` class are as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary`类中使用的主要方法如下：'
- en: '`public TValue this[TKey key] {get; set;}`: Gets or sets a value associated
    with the key. An exception is thrown if the key does not exist.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public TValue this[TKey key] {get; set;}`: 获取或设置与键关联的值。如果键不存在，则会抛出异常。'
- en: '`Dictionary<TKey, TValue>.KeyCollection Keys { get; }`: Returns a `KeyCollection`
    dictionary instance that contains all keys.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>.KeyCollection Keys { get; }`: 返回一个包含所有键的`KeyCollection`字典实例。'
- en: '`Dictionary<TKey, TValue>.ValueCollection Values { get; }`: Returns a `ValueCollection`
    dictionary instance that contains all values.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>.ValueCollection Values { get; }`: 返回一个包含所有值的`ValueCollection`字典实例。'
- en: '`public int Count { get; }`: Returns the number of elements in the `Dictionary`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public int Count { get; }`: 返回`Dictionary`中的元素数量。'
- en: '`void Add(TKey key, TValue value)`: Adds the key and associated value. If the
    key already exists, an exception is thrown.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Add(TKey key, TValue value)`: 添加键和相关值。如果键已经存在，则会抛出异常。'
- en: '`void Clear()`: Clears all keys and values from the `Dictionary`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Clear()`: 从`Dictionary`中清除所有键和值。'
- en: '`bool ContainsKey(TKey key)`: Returns `true` if the specified key exists.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool ContainsKey(TKey key)`: 如果指定的键存在，则返回`true`。'
- en: '`bool ContainsValue(TValue value)`: Returns `true` if the specified value exists.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool ContainsValue(TValue value)`: 如果指定的值存在，则返回`true`。'
- en: '`bool Remove(TKey key)`: Removes a value with the associated key.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool Remove(TKey key)`: 移除与关联键的值。'
- en: '`bool TryAdd(TKey key, TValue value)`: Attempts to add the key and value. If
    the key already exists, an exception is "not" thrown. Returns `true` if the value
    was added.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool TryAdd(TKey key, TValue value)`: 尝试添加键和值。如果键已经存在，则不会抛出异常。如果添加了值，则返回`true`。'
- en: '`bool TryGetValue(TKey key, out TValue value)`: Gets the value associated with
    the key, if it is available. Returns `true` if it was found.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool TryGetValue(TKey key, out TValue value)`: 获取与键关联的值（如果可用）。如果找到了值，则返回`true`。'
- en: 'The following code shows how a `Dictionary` can be used to add and navigate
    `Country` records:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何使用`Dictionary`添加和导航`Country`记录：
- en: In your `Chapter04\Examples` folder, add a new class called `DictionaryExamples.cs`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`DictionaryExamples.cs`的新类。
- en: 'Start by defining a `Country` record, which is passed a `Name` parameter:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义一个`Country`记录，该记录传入一个`Name`参数：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use the `Dictionary` initialization syntax to create a `Dictionary` with five
    countries, as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Dictionary`初始化语法创建一个包含五个国家的`Dictionary`，如下所示：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the next code snippet, `Dictionary` implements the `IEnumerable` interface,
    which allows you to retrieve a key-value pair representing the key and value items
    in the `Dictionary`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，`Dictionary`实现了`IEnumerable`接口，这允许您检索表示`Dictionary`中的键和值项的键值对：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Running the example code produces the following output. By iterating through
    each item in `countries`, you can see the five country codes and their names:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例代码会产生以下输出。通过迭代`countries`中的每个项目，您可以看到五个国家代码及其名称：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There is an entry with the `AFG` key, so using the `set indexer` passing in
    `AFG` as a key allows a new `Country` record to be set that replaces the previous
    item with the `AGF` key. You can add the following code for this:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个带有`AFG`键的条目，因此使用`set索引器`传入`AFG`作为键允许设置一个新的`Country`记录，该记录将替换具有`AGF`键的先前项目。您可以添加以下代码来实现这一点：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When you run the code, adding a key for `AFG` allows you to get a value using
    that key:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行代码时，添加一个`AFG`键可以让您使用该键获取一个值：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Key comparisons are case-sensitive with string keys, so `AGO` is present but
    `and` is not as the corresponding country (`Andorra`) is defined with the uppercase
    `AND` key. You can add the following code to check this:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串键的键比较是区分大小写的，所以`AGO`是存在的，但`and`不是，因为相应的国家（`Andorra`）是用大写的`AND`键定义的。您可以添加以下代码来检查这一点：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Using `Add` to add a new entry will throw an exception if the key already exists.
    This can be seen by adding the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Add`添加新条目时，如果键已经存在，将会抛出异常。可以通过添加以下代码来看到这一点：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Conversely, `TryAdd` does `AIA` key, so using `TryAdd` simply returns a `false`
    value rather than throwing an exception:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，`TryAdd`执行`AIA`键，因此使用`TryAdd`只会返回一个`false`值，而不是抛出异常：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As the following output shows, adding `Anguilla` once using the `AIA` key is
    valid but attempting to add it again using the `AIA` key results in an exception
    being caught:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下输出所示，使用`AIA`键一次添加`Anguilla`是有效的，但尝试再次使用`AIA`键添加会导致捕获异常：
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`TryGetValue`, as the name suggests, allows you to try to get a value by key.
    You pass in a key that may be missing from the `Dictionary`. Requesting an object
    whose key is missing from the `Dictionary` will ensure that an exception is not
    thrown. This is useful if you are unsure whether a value has been added for the
    specified key:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TryGetValue`允许您尝试通过键获取值。您传入一个可能在`Dictionary`中缺失的键。请求一个其键在`Dictionary`中缺失的对象将确保不会抛出异常。如果您不确定是否已为指定的键添加了值，则这很有用：'
- en: '[PRE67]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You should see the following output upon running this code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码后，您应该看到以下输出：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visual Studio might report the following warning: `Warning CS8600: Converting
    null literal or possible null value to non-nullable type`. This is a reminder
    from Visual Studio that a variable may have a null value at runtime.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'Visual Studio可能会报告以下警告：`Warning CS8600: Converting null literal or possible
    null value to non-nullable type`。这是Visual Studio提醒您，在运行时变量可能具有空值的提醒。'
- en: You have seen how the `Dictionary` class is used to ensure that only unique
    identities are associated with values. Even if you do not know which keys are
    in the `Dictionary` until runtime, you can use the `TryGetValue` and `TryAdd`
    methods to prevent runtime exceptions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了`Dictionary`类是如何用来确保只有唯一的标识与值相关联的。即使您在运行时不知道`Dictionary`中有哪些键，也可以使用`TryGetValue`和`TryAdd`方法来防止运行时异常。
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/vzHUb](https://packt.link/vzHUb).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/vzHUb](https://packt.link/vzHUb)找到此示例的代码。
- en: In this example, a string key was used for the `Dictionary`. However, any type
    can be used as a key. You will often find that an integer value is used as a key
    when source data is retrieved from relational databases, as integers can often
    be more efficient in memory than strings. Now it is time to use this feature through
    an exercise.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`Dictionary`使用了字符串键。但是，任何类型都可以用作键。当源数据从关系数据库中检索时，通常会发现整数值被用作键，因为整数在内存中通常比字符串更有效。现在是时候通过一个练习来使用这个特性了。
- en: 'Exercise 4.02: Using a Dictionary to Count the Words in a Sentence'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02：使用字典来计算句子中的单词
- en: You have been asked to create a console app that asks the user to enter a sentence.
    The console should then split the input into individual words (using a space character
    as a word delimiter) and count the number of times that each word occurs. If possible,
    simple forms of punctuation should be removed from the output, and you are to
    ignore capitalized words so that, for example, `Apple` and `apple` both appear
    as a single word.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您被要求创建一个控制台应用程序，要求用户输入一个句子。然后控制台应将输入拆分为单个单词（使用空格字符作为单词分隔符），并计算每个单词出现的次数。如果可能，输出中应删除简单形式的标点符号，并且您应忽略大写单词，以便例如`Apple`和`apple`都出现为一个单词。
- en: This is an ideal use of a `Dictionary`. The `Dictionary` will use a string as
    the key (a unique entry for each word) with an `int` value to count the words.
    You will use `string.Split()` to split a sentence into words, and `char.IsPunctuation`
    to remove any trailing punctuation marks.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Dictionary`的一个理想用法。`Dictionary`将使用字符串作为键（每个单词的唯一条目）并使用`int`值来计算单词的数量。您将使用`string.Split()`将句子拆分为单词，并使用`char.IsPunctuation`来删除任何尾随标点符号。
- en: 'Perform the following steps to do so:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这些操作：
- en: In your `Chapter04\Exercises` folder, create a new folder called `Exercise02`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Exercises`文件夹中，创建一个名为`Exercise02`的新文件夹。
- en: Inside the `Exercise02` folder, add a new class called `Program.cs`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exercise02`文件夹中，添加一个名为`Program.cs`的新类。
- en: 'Start by defining a new class called `WordCounter`. This can be marked as `static`
    so that it can be used without needing to create an instance:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义一个名为`WordCounter`的新类。这可以标记为`static`，以便无需创建实例即可使用：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Define a `static` method called `Process`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`Process`的`static`方法：
- en: '[PRE70]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is passed a phrase and returns `IEnumerable<KeyValuePair>`, which allows
    the caller to enumerate through a `Dictionary` of results. After this definition,
    the `Dictionary` of `wordCounts` is keyed using a `string` (each word found) and
    an `int` (the number of times that a word occurs).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传递一个短语并返回`IEnumerable<KeyValuePair>`的方法，允许调用者枚举结果的`Dictionary`。在此定义之后，使用`string`（找到的每个单词）和`int`（单词出现的次数）对`wordCounts`的`Dictionary`进行键控。
- en: You are to ignore the case of words with capital letters, so convert the string
    into its lowercase equivalent before using the `string.Split` method to split
    the phrase.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`string.Split`方法拆分短语之前，您需要忽略具有大写字母的单词的大小写，因此将字符串转换为其小写等效形式。
- en: 'Then you can use the `RemoveEmptyEntries` option to remove any empty string
    values. Add the following code for this:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以使用`RemoveEmptyEntries`选项来删除任何空字符串值。添加以下代码：
- en: '[PRE71]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use a simple `foreach` loop to iterate through the individual words found in
    the phrase:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简单的`foreach`循环来遍历短语中找到的单词：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `char.IsPunctuation` method is used to remove punctuation marks from the
    end of the word.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`char.IsPunctuation`方法从单词的末尾删除标点符号。
- en: 'Use the `TryGetValue` method to check if there is a `Dictionary` entry with
    the current word. If so, update the `count` by one:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TryGetValue`方法检查当前单词是否有`Dictionary`条目。如果有，将`count`更新为1：
- en: '[PRE73]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If the word does not exist, add a new word key with a starting value of `1`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单词不存在，则添加一个新的单词键，其起始值为`1`。
- en: 'Once all the words in the phrase have been processed, return the `wordCounts Dictionary`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦短语中的所有单词都被处理，返回`wordCounts Dictionary`：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, write the console app that allows the user to enter a phrase:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写控制台应用程序，允许用户输入短语：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `do` loop will end once the user enters an empty string; you will add the
    code for this in an upcoming step.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户输入空字符串，`do`循环将结束；您将在即将到来的步骤中添加此代码。
- en: Call the `WordCounter.Process` method to return a key-value pair that can be
    enumerated through.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`WordCounter.Process`方法返回一个可以枚举的键值对。
- en: 'For each `key` and `value`, write the word and its count, padding each word
    to the right:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个`key`和`value`，写入单词及其计数，将每个单词向右填充：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: A new line is started after every third word (using `i % 3 = 0`) for improved
    output formatting.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在每第三个单词之后（使用`i % 3 = 0`）开始新的一行，以改善输出格式。
- en: 'Finish off the `do-while` loop:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`do-while`循环：
- en: '[PRE77]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Running the console using the opening text from *The Gettysburg Address* of
    1863 produces this output:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用1863年《葛底斯堡演说》的开场文本运行控制台会产生以下输出：
- en: '[PRE78]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can search online for The Gettysburg Address or visit [https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm](https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网上搜索葛底斯堡演说或访问[https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm](https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm)。
- en: From the results, you can see that each word is displayed only once and that
    certain words, such as `and` and `that`, appear more than once in the speech.
    The words are listed in the order they appear in the text, but this is not always
    the case with the `Dictionary` class. It should be assumed that the order will
    **not** remain fixed this way; dictionaries' values should be accessed using a
    key.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，您可以看到每个单词只显示一次，并且某些单词，例如`and`和`that`，在演讲中出现了多次。单词按其在文本中出现的顺序列出，但这在`Dictionary`类中并不总是如此。应该假定顺序**不会**始终保持不变；应使用键访问字典的值。
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/Dnw4a](https://packt.link/Dnw4a).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/Dnw4a](https://packt.link/Dnw4a)找到此练习中使用的代码。
- en: So far, you have learned about the main collections commonly used in .NET. It
    is now time to look at LINQ, which makes extensive use of collections based on
    the `IEnumerable` interface.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了.NET中常用的主要集合。现在是时候看看LINQ了，它广泛使用基于`IEnumerable`接口的集合。
- en: LINQ
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ
- en: LINQ (pronounced **link**) is short for Language Integrated Query. LINQ is a
    general-purpose language that can be used to query objects in memory by using
    a syntax that is similar to Structured Query Language (SQL), that is, it is used
    to query databases. It is an enhancement of the C# language that makes it easier
    to interact with objects in memory using SQL-like Query Expressions or Query Operators
    (implemented through a series of extension methods).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ（发音为**link**）是语言集成查询的缩写。LINQ是一种通用语言，可通过类似于结构化查询语言（SQL）的语法来查询内存中的对象，即用于查询数据库。它是C#语言的增强，使得使用类似SQL的查询表达式或查询运算符（通过一系列扩展方法实现）更容易与内存中的对象交互。
- en: 'Microsoft''s original idea for LINQ was to bridge the gap between .NET code
    and data sources, such as relational databases and XML, using LINQ providers.
    LINQ providers form a set of building blocks that can be used to query various
    sources of data, using a similar set of Query Operators, without the caller needing
    to know the intricacies of how each data source works. The following is a list
    of providers and how they are used:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 微软最初的想法是使用LINQ提供程序来弥合.NET代码和数据源（如关系数据库和XML）之间的差距。LINQ提供程序形成了一组构建块，可以用于查询各种数据源，使用类似的查询运算符，而不需要调用者了解每个数据源的复杂性。以下是提供程序的列表以及它们的使用方式：
- en: 'LINQ to Objects: Queries applied to objects in memory, such as those defined
    in a list.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ到对象：应用于内存中的对象的查询，例如列表中定义的对象。
- en: 'LINQ to SQL: Queries applied to relational databases such as SQL Server, Sybase,
    or Oracle.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ到SQL：应用于关系数据库，如SQL Server、Sybase或Oracle。
- en: 'LINQ to XML: Queries applied to XML documents.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ到XML：应用于XML文档的查询。
- en: This chapter will cover LINQ to Objects. This is, by far, the most common use
    of LINQ providers and offers a flexible way to query collections in memory. In
    fact, when talking about LINQ, most people refer to LINQ to Objects, mainly due
    to its ubiquitous use throughout C# applications.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍LINQ到对象。这是LINQ提供程序最常见的用法，它提供了一种灵活的方式来查询内存中的集合。事实上，当谈论LINQ时，大多数人指的是LINQ到对象，主要是因为它在C#应用程序中的普遍使用。
- en: 'At the heart of LINQ is the way that collections can be converted, filtered,
    and aggregated into new forms using a concise and easy-to-use syntax. LINQ can
    be used in two interchangeable styles:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ的核心是使用简洁且易于使用的语法将集合转换、过滤和聚合成新形式。LINQ可以以两种可互换的风格使用：
- en: Query Operators
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询运算符
- en: Query Expressions
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询表达式
- en: Each style offers a different syntax to achieve the same result, and which one
    you use often comes down to personal preference. Each style can be interwoven
    in code easily.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 每种风格都提供了不同的语法来实现相同的结果，你通常会根据个人偏好来选择使用哪种。每种风格都可以轻松地编织在代码中。
- en: Query Operators
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询运算符
- en: These are based on a series of core extension methods. The results from one
    method can be chained together into a programming style, which can often be easier
    to grasp than their expression-based counterparts.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则基于一系列核心扩展方法。一个方法的结果可以链接成一种编程风格，这种风格通常比基于表达式的风格更容易理解。
- en: The extension methods typically take an `IEnumerable<T>` or `IQueryable<T>`
    input source, such as a list, and allow a `Func<T>` predicate to be applied to
    that source. The source is generic-based, so Query Operators work with all types.
    It is just as easy to work with `List<string>` as it is with `List<Customer>`,
    for example.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法通常接受`IEnumerable<T>`或`IQueryable<T>`输入源，例如列表，并允许将`Func<T>`谓词应用于该源。源是基于泛型的，因此查询运算符适用于所有类型。例如，与`List<Customer>`一样，与`List<string>`一样容易。
- en: 'In the following snippet, `.Where`, `.OrderBy`, and `.Select` are the extension
    methods being called:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`.Where`、`.OrderBy`和`.Select`是被调用的扩展方法：
- en: '[PRE79]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, you are taking the results from a `.Where` extension method to find all
    books with a unit price greater than `10`, which is then sorted using the `.OrderBy`
    extension method. Finally, the name of each book is extracted using the `.Select`
    method. These methods could have been declared as single lines of code, but chaining
    in this way provides a more intuitive syntax. This will be covered in more detail
    in the upcoming sections.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在使用`.Where`扩展方法的结果来查找所有单位价格大于`10`的书籍，然后使用`.OrderBy`扩展方法对其进行排序。最后，使用`.Select`方法提取每本书的名称。这些方法可以声明为单行代码，但以这种方式链接提供了更直观的语法。这将在即将到来的章节中详细介绍。
- en: Query Expressions
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询表达式
- en: Query Expressions are an enhancement of the C# language and resemble SQL syntax.
    The C# compiler compiles Query Expressions into a sequence of Query Operator extension
    method calls. Note that not all Query Operators are available with an equivalent
    Query Expression implementation.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式是C#语言的增强，类似于SQL语法。C#编译器将查询表达式编译成一系列查询运算符扩展方法调用。请注意，并非所有查询运算符都有等效的查询表达式实现。
- en: 'Query Expressions have the following rules:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式有以下规则：
- en: They start with a `from` clause.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们以`from`子句开始。
- en: They can contain at least one or more optional `where`, `orderby`, `join`, `let`,
    and additional `from` clauses.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以包含至少一个或多个可选的`where`、`orderby`、`join`、`let`和额外的`from`子句。
- en: They end with either a `select` or a `group` clause.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们以`select`或`group`子句结束。
- en: 'The following snippet is functionally equivalent to the Query Operator style
    defined in the previous section:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段在功能上等同于前一节中定义的查询运算符风格：
- en: '[PRE80]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You will take a more in-depth look at both styles as you learn about the standard
    Query Operators shortly.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 不久之后，您将更深入地了解这两种风格。
- en: Deferred Execution
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟执行
- en: Whether you choose to use Query Operators, Query Expressions, or a mixture of
    the two, it is important to remember that for many operators, the query that you
    define is not executed when it is defined, but only when it is enumerated over.
    This means that it is not until a `foreach` statement or a `ToList`, `ToArray`,
    `ToDictionary`, `ToLookup`, or `ToHashSet` method is called that the actual query
    is executed.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择使用查询运算符、查询表达式还是两者的混合，重要的是要记住，对于许多运算符，您定义的查询在定义时不会执行，而只有在枚举时才会执行。这意味着直到调用`foreach`语句或`ToList`、`ToArray`、`ToDictionary`、`ToLookup`或`ToHashSet`方法时，实际的查询才会执行。
- en: This allows queries to be constructed elsewhere in code with additional criteria
    included, and then used or even reused with a different collection of data. Recall
    that in *Chapter 3*, *Delegates, Lambdas, and Events*, you saw similar behavior
    with delegates. Delegates are not executed where they are defined, but only when
    they are invoked.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在代码的其他地方构建查询，并包含额外的条件，然后使用甚至重新使用不同的数据集。回想一下，在*第3章*，*委托、Lambda和事件*中，您看到了委托的类似行为。委托不是在定义它们的地方执行，而是在调用它们时执行。
- en: 'In the following short Query Operator example, the output will be `abz` even
    though `z` is added **after** the query is defined but **before** it is enumerated
    through. This demonstrates that LINQ queries are evaluated on demand, rather than
    at the point where they are declared:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的简短查询运算符示例中，输出将是`abz`，即使在定义查询之后但在枚举之前添加了`z`。这表明LINQ查询是按需评估的，而不是在声明它们的地方。
- en: '[PRE81]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Standard Query Operators
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准查询运算符
- en: LINQ is driven by a core set of extension methods, referred to as standard Query
    Operators. These are grouped into operations based on their functionality. There
    are many standard Query Operators available, so for this introduction, you will
    explore all the main operators that you are likely to use regularly.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ由一组核心扩展方法驱动，称为标准查询运算符。这些运算符根据其功能分为操作组。有许多标准查询运算符可用，因此在本介绍中，您将探索您可能经常使用的所有主要运算符。
- en: Projection Operations
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影操作
- en: 'Projection operations allow you to convert an object into a new structure using
    only the properties that you need. You can create a new type, apply mathematical
    operations, or return the original object:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 投影操作允许您仅使用您需要的属性将对象转换为新结构。您可以创建一个新类型，应用数学运算，或返回原始对象：
- en: '`Select`: Projects each item in the source into a new form.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select`：将源中的每个项目投影到新形式中。'
- en: '`SelectMany`: Projects all items in the source, flattens the result, and optionally
    projects them to a new form. There is no Query Expression equivalent for `SelectMany`.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectMany`：对源中的所有项目进行投影，展平结果，并可选择将它们投影到新形式。对于`SelectMany`，没有查询表达式的等价物。'
- en: Select
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Select
- en: Consider the following snippet, which iterates through a `List<string>` containing
    the values `Mon`, `Tues`, and `Wednes`, outputting each with the word day appended.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下片段，它遍历包含值`Mon`、`Tues`和`Wednes`的`List<string>`，并输出每个值附加了单词day。
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqSelectExamples.cs`
    and edit it as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqSelectExamples.cs`的新文件，并编辑如下：
- en: '[PRE82]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Looking at the Query Operator syntax first, you can see that `query1` uses
    the `Select` extension method and defines a `Func<T>` like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看一下查询运算符语法，您会看到`query1`使用`Select`扩展方法并定义了一个像这样的`Func<T>`：
- en: '[PRE83]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'When executed, the variable `d` is passed to the lambda statement, which appends
    the word `day` to each string in the `days` list: `"Mon"`, `"Tues"`, `"Wednes"`.
    This returns a new `IEnumerable<string>` instance, with the original values inside
    the source variable, `days`, remaining unchanged.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，变量`d`被传递给lambda语句，该语句将单词`day`附加到`days`列表中的每个字符串："Mon"，"Tues"，"Wednes"。这将返回一个新的`IEnumerable<string>`实例，源变量`days`中的原始值保持不变。
- en: 'You can now enumerate through the new `IEnumerable` instance using `foreach`,
    as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`foreach`枚举新的`IEnumerable`实例，如下所示：
- en: '[PRE84]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Note that the `Select` method has another overload that allows the index position
    in the source and value to be accessed, rather than just the value itself. Here,
    `d` (the string value) and `i` (its index) are passed, using the `( d , i ) =>`
    syntax and joined into a new string. The output will be displayed as `0 : Monday`,
    `1 : Tuesday`, and so on.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Select`方法还有另一个重载，允许访问源中的索引位置和值，而不仅仅是值本身。在这里，使用`(d，i)=>`语法传递了`d`（字符串值）和`i`（其索引），并将它们连接成一个新的字符串。输出将显示为`0：Monday`，`1：Tuesday`，依此类推。
- en: Anonymous Types
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匿名类型
- en: Before you continue looking at `Select` projections, it is worth noting that
    C# does not limit you to just creating new strings from existing strings. You
    can project into any type.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续查看`Select`投影之前，值得注意的是，C#不仅限于仅从现有字符串创建新字符串。您可以投影到任何类型。
- en: 'You can also create anonymous types, which are types created by the compiler
    from the properties that you name and specify. For example, consider the following
    example, which results in a new type being created that represents the results
    of the `Select` method:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建匿名类型，这些类型是编译器根据您指定的属性创建的类型。例如，考虑以下示例，该示例会创建一个新类型，该类型表示`Select`方法的结果：
- en: '[PRE85]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, `query3` results in a new type that has an Index and `UpperCaseName` property;
    the values are assigned using `Index = i` and `UpperCaseName = $"{d.ToUpper()}DAY"`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`query3`会产生一个具有`Index`和`UpperCaseName`属性的新类型；这些值是使用`Index = i`和`UpperCaseName
    = $"{d.ToUpper()}DAY"`分配的。
- en: These types are scoped to be available within your local method and can then
    be used in any local statements, such as in the previous `foreach` block. This
    saves you from having to create classes to temporarily store values from a `Select`
    method.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的作用域仅限于在您的本地方法中可用，然后可以在任何本地语句中使用，例如在先前的`foreach`块中。这样可以避免您必须创建类来临时存储`Select`方法的值。
- en: 'Running the code produces output in this format:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会以此格式产生输出：
- en: '[PRE86]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As an alternative, consider how the equivalent Query Expression looks. In the
    following example, you start with the from `day in days` expression. This assigns
    the name `day` to the string values in the `days` list. You then use `select`
    to project that to a new string, appending `"day"` to each.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，请考虑等效的查询表达式。在以下示例中，您从`days`表达式开始。这将为`days`列表中的字符串值分配名称`day`。然后，您使用`select`将其投影到一个新字符串，每个字符串后附加`"day"`。
- en: 'This is functionally equivalent to the example in `query1`. The only difference
    is the code readability:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这在功能上等同于`query1`中的示例。唯一的区别是代码的可读性：
- en: '[PRE87]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The following example snippet mixes a Query Operator and Query Expressions.
    The `select` Query Expression cannot be used to select a value and index, so the
    `Select` extension method is used to create an anonymous type with a `Name` and
    `Index` property:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例片段混合了查询运算符和查询表达式。`select`查询表达式无法用于选择值和索引，因此使用`Select`扩展方法创建一个具有`Name`和`Index`属性的匿名类型：
- en: '[PRE88]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Running the full example produces this output:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完整示例会产生此输出：
- en: '[PRE89]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Again, it largely comes down to personal choice as to which you prefer using.
    As queries become longer, one form may require less code than the other.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，大部分取决于个人选择。随着查询变得更长，一种形式可能需要比另一种形式更少的代码。
- en: Note
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/wKye0](https://packt.link/wKye0).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/wKye0](https://packt.link/wKye0)找到此示例的代码。
- en: SelectMany
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SelectMany
- en: You have seen how `Select` can be used to project values from each item in a
    source collection. In the case of a source that has enumerable properties, the
    `SelectMany` extension method can extract the multiple items into a single list,
    which can then be optionally projected into a new form.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何使用`Select`从源集合中的每个项目中投影值。对于具有可枚举属性的源，`SelectMany`扩展方法可以将多个项目提取到单个列表中，然后可以选择将其投影到新形式。
- en: 'The following example creates two `City` records, each with multiple `Station`
    names, and uses `SelectMany` to extract all stations from both cities:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了两个`City`记录，每个记录都有多个`Station`名称，并使用`SelectMany`从两个城市中提取所有车站：
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqSelectManyExamples.cs`
    and edit it as follows:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqSelectManyExamples.cs`的新文件，并编辑如下：
- en: '[PRE90]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `Func` parameter, which is passed to `SelectMany`, requires you to specify
    an enumerable property, in this case, the `City` class's `Stations` property,
    which contains a list of string names (see the highlighted code).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`SelectMany`的`Func`参数需要您指定一个可枚举的属性，即`City`类的`Stations`属性，其中包含一个字符串名称列表（请参阅突出显示的代码）。
- en: Notice how a shortcut is used here, by directly integrating the query into a
    `foreach` statement. You are not altering or reusing the query variable, so there is
    no benefit in defining it separately, as done earlier.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里使用了一种快捷方式，通过直接将查询集成到`foreach`语句中。您没有更改或重用查询变量，因此与之前的做法相比，单独定义它没有好处。
- en: '`SelectMany` extracts all the station names from all of the items in the `List<City>`
    variable. Starting with the `City` class at element `0`, which has the name `London`,
    it will extract the three station names `("Kings Cross KGX"`, `"Liverpool Street
    LVS"`, and `"Euston EUS"`). It will then move on to the second `City` element,
    named `Birmingham`, and extract the single station, named `"New Street NST"`.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectMany`从`List<City>`变量中的所有项目中提取所有站点名称。从元素`0`开始，即`City`类的`London`，它将提取三个站点名称`("Kings
    Cross KGX"`、`"Liverpool Street LVS"`和`"Euston EUS"`)。然后，它将移动到第二个名为`Birmingham`的`City`元素，并提取名为`"New
    Street NST"`的单个站点。'
- en: 'Running the example produces the following output:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例会产生以下输出：
- en: '[PRE91]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'As an alternative, consider the following snippet. Here, you revert to using
    a query variable, `stations`, to make the code easier to follow:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为替代方案，请考虑以下代码片段。在这里，您可以重新使用查询变量`stations`，以使代码更易于理解：
- en: '[PRE92]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Rather than just returning each `Station` string, this example uses a nested
    `Select` method and a `Range` operator to extract the last three characters from
    the station name using `s[^3..]`, where `s` is a string for each station name
    and `^3` indicates that the `Range` operator should extract a string that starts
    at the last three characters in the string.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 与其只返回每个`Station`字符串，此示例使用了嵌套的`Select`方法和`Range`运算符，使用`s[^3..]`从站点名称中提取最后三个字符，其中`s`是每个站点名称的字符串，`^3`表示`Range`运算符应该提取从字符串中的最后三个字符开始的字符串。
- en: 'Running the example produces the following output:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例会产生以下输出：
- en: '[PRE93]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You can see the last three characters of each station name are shown in the output.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到每个站点名称的最后三个字符显示在输出中。
- en: Note
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/g8dXZ](https://packt.link/g8dXZ).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/g8dXZ](https://packt.link/g8dXZ)找到本示例使用的代码。
- en: In the next section you will read about the filtering operations that filter
    a result as per a condition.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解过滤操作，该操作根据条件过滤结果。
- en: Filtering Operations
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤操作
- en: 'Filtering operations allow you to filter a result to return only those items
    that match a condition. For example, consider the following snippet, which contains
    a list of orders:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤操作允许您过滤结果，仅返回符合条件的项目。例如，考虑以下代码片段，其中包含一系列订单：
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqWhereExample.cs`
    and edit it as follows:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqWhereExample.cs`的新文件，并编辑如下：
- en: '[PRE94]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, some order items are defined for various stationery products. Suppose
    you want to output all orders that have a quantity greater than five (this should
    output the `Ruler` and `USB Memory Stick` orders from the source).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这里为各种文具产品定义了一些订单项目。假设您想要输出所有数量大于五的订单（这应该输出源中的`Ruler`和`USB Memory Stick`订单）。
- en: 'For this, you can add the following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，您可以添加以下代码：
- en: '[PRE96]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, suppose you extend the criteria to find all products where the product
    is `Pen` or `Pencil`. You can chain that result into a `Select` method, which
    will return each order''s total value; remember that `Select` can return anything
    from a source, even a simple extra calculation like this:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设您扩展条件以查找产品为`Pen`或`Pencil`的所有产品。您可以将该结果链接到`Select`方法中，该方法将返回每个订单的总价值；请记住，`Select`可以从源返回任何东西，甚至是像这样的简单额外计算：
- en: '[PRE97]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Next, the Query Expression in the following snippet uses a `where` clause to
    find the orders with a price less than or equal to `3.99`. This projects them
    into an anonymous type that has `Name` and `Value` properties, which you enumerate
    through using a `foreach` statement:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，以下代码片段中的查询表达式使用`where`子句来查找价格小于或等于`3.99`的订单。它将它们投影到一个具有`Name`和`Value`属性的匿名类型中，然后您可以使用`foreach`语句对其进行枚举：
- en: '[PRE98]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Running the full example produces this result:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行完整示例会产生以下结果：
- en: '[PRE99]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Now you have seen Query Operators in action, it is worth returning to deferred
    execution to see how this affects a query that is enumerated multiple times over.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到查询运算符的作用，值得回顾延迟执行，看看这如何影响多次枚举的查询。
- en: 'In this next example, you have a collection of journeys made by a vehicle,
    which are populated via a `TravelLog` record. The `TravelLog` class contains an
    `AverageSpeed` method that logs a console message each time it is executed, and,
    as the name suggests, returns the average speed of the vehicle during that journey:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，您有一个由车辆进行的旅程集合，这些旅程是通过`TravelLog`记录填充的。`TravelLog`类包含一个`AverageSpeed`方法，每次执行时都会记录控制台消息，并且根据名称返回车辆在该旅程期间的平均速度：
- en: 'In your Chapter04\Examples folder, add a new file called `LinqMultipleEnumerationExample.cs`
    and edit it as follows:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqMultipleEnumerationExample.cs`的新文件，并编辑如下：
- en: '[PRE100]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Next, define the console app''s `Main` method, which populates a `travelLogs`
    list with four `TravelLog` records. You will add the following code for this:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义控制台应用程序的`Main`方法，该方法使用四个`TravelLog`记录填充了一个`travelLogs`列表。您将为此添加以下代码：
- en: '[PRE101]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You will now create a `fastestJourneys` query variable, which includes a `Where`
    clause. This `Where` clause will call each journey's `AverageSpeed` method when
    enumerated.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将创建一个`fastestJourneys`查询变量，其中包括一个`Where`子句。当枚举时，此`Where`子句将调用每个旅程的`AverageSpeed`方法。
- en: 'Then, using a `foreach` loop, you enumerate through the items in `fastestJourneys`
    and write the name and distance to the console (note that you do `AverageSpeed`
    method inside the `foreach` loop):'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`foreach`循环，枚举`fastestJourneys`中的项目，并将名称和距离写入控制台（注意，在`foreach`循环中执行`AverageSpeed`方法）：
- en: '[PRE102]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Running the code block will produce the following output, the `Name` and `Distance`
    for each journey:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码块将产生以下输出，每次旅程的`Name`和`Distance`：
- en: '[PRE103]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You can see that `AverageSpeed` was called `Where` condition. This is as expected
    so far, but now, you can reuse the same query to output the `Name` and, alternatively,
    the `Duration`:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到`AverageSpeed`被称为`Where`条件。到目前为止，这是预期的，但现在，您可以重用相同的查询来输出`Name`和/或`Duration`：
- en: '[PRE104]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Running this block produces the same `AverageSpeed` method:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此块将产生相同的`AverageSpeed`方法：
- en: '[PRE105]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This shows that whenever a query is enumerated, the full query is `AverageSpeed`,
    but what if a method needs to access a database to extract some data? That would
    result in multiple database calls and, possibly, a very slow application.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明每当查询被枚举时，完整的查询都是`AverageSpeed`，但是如果一个方法需要访问数据库来提取一些数据呢？这将导致多次数据库调用，可能会导致应用程序运行非常缓慢。
- en: 'You can use methods such as `ToList`, `ToArray`, `ToDictionary`, `ToLookup`,
    or `ToHashSet` to ensure that a query that could be enumerated many times is `Where`
    clause but includes an extra `ToList` call to immediately execute the query and
    ensure it is not re-evaluated:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`ToList`、`ToArray`、`ToDictionary`、`ToLookup`或`ToHashSet`等方法，以确保可以多次枚举的查询是`Where`子句，但包括额外的`ToList`调用以立即执行查询并确保它不会被重新评估：
- en: '[PRE106]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Running the block produces the following output. Notice how `AverageSpeed`
    is called `Fastest Duration Multiple loop iteration` messages:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行该块将产生以下输出。请注意`AverageSpeed`被称为`Fastest Duration Multiple loop iteration`消息：
- en: '[PRE107]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Notice that from the collection of journeys made by a vehicle, the code returns
    the average speed of the vehicle during the journeys.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从车辆进行的旅程集合中，代码返回了车辆在旅程中的平均速度。
- en: Note
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/CIZJE](https://packt.link/CIZJE).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/CIZJE](https://packt.link/CIZJE)找到此示例使用的代码。
- en: Sorting Operations
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序操作
- en: 'There are five operations to sort items in a source. Items are primarily sorted
    and that can be followed by an optional secondary sort, which sorts the items
    within their primary group. For example, you can use a primary sort to sort a
    list of people firstly by the `City` property and then use a secondary sort to
    further sort them by the `Surname` property:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种操作可以对源中的项目进行排序。项目首先进行排序，然后可以进行可选的次要排序，该排序将对其主要组内的项目进行排序。例如，您可以使用主要排序首先按`City`属性对人员名单进行排序，然后使用次要排序进一步按`Surname`属性对其进行排序：
- en: '`OrderBy`: Sorts values into ascending order.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderBy`：将值按升序排序。'
- en: '`OrderByDescending`: Sorts values into descending order.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderByDescending`：将值按降序排序。'
- en: '`ThenBy`: Sorts values that have been primarily sorted into a secondary ascending
    order.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThenBy`：将首先排序的值按次要升序排序。'
- en: '`ThenByDescending`: Sorts values that have been primarily sorted into a secondary
    descending order.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThenByDescending`：将首先排序的值按次要降序排序。'
- en: '`Reverse`: Simply returns a collection where the order of elements in the source
    is reversed. There is no expression equivalent.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reverse`：简单地返回源中元素的顺序被颠倒的集合。没有表达式等价物。'
- en: OrderBy and OrderByDescending
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OrderBy和OrderByDescending
- en: In this example, you will use the `System.IO` namespace to query files in the
    host machine's `temp` folder, rather than creating small objects from lists.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您将使用`System.IO`命名空间来查询主机机器的`temp`文件夹中的文件，而不是从列表中创建小对象。
- en: 'The static `Directory` class offers methods that can query the filesystem.
    `FileInfo` retrieves details about a specific file, such as its size or creation
    date. The `Path.GetTempPath` method returns the system''s `temp` folder. To illustrate
    the point, in the Windows operating system, this can typically be found at `C:\Users\username\AppData\Local\Temp`,
    where `username` is a specific Windows login name. This will be different for
    other users and other systems:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 静态`Directory`类提供了可以查询文件系统的方法。`FileInfo`检索有关特定文件的详细信息，例如其大小或创建日期。`Path.GetTempPath`方法返回系统的`temp`文件夹。为了说明这一点，在Windows操作系统中，这通常可以在`C:\Users\username\AppData\Local\Temp`找到，其中`username`是特定的Windows登录名。对于其他用户和其他系统，情况将有所不同：
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqOrderByExamples.cs`
    and edit it as follows:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqOrderByExamples.cs`的新文件，并编辑如下：
- en: '[PRE108]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Use the `Directory.EnumerateFiles` method to find all filenames with the `.tmp`
    extension in the `temp` folder:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Directory.EnumerateFiles`方法在`temp`文件夹中查找所有带有`.tmp`扩展名的文件名：
- en: '[PRE109]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, each filename is projected into a `FileInfo` instance and chained into
    a populated collection using `ToList`, which allows you to further query the resulting
    `fileInfos` details.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个文件名都被投影到一个`FileInfo`实例中，并使用`ToList`链接到一个填充的集合中，这允许您进一步查询生成的`fileInfos`的详细信息。
- en: 'Next, the `OrderBy` method is used to sort the earliest files by comparing
    the `CreationTime` property of the file:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`OrderBy`方法来通过比较文件的`CreationTime`属性对最早的文件进行排序：
- en: '[PRE110]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'To find the largest files, re-query `fileInfos` and sort each file by its `Length`
    property using `OrderByDescending`:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查找最大的文件，请重新查询`fileInfos`并使用`OrderByDescending`按其`Length`属性对每个文件进行排序：
- en: '[PRE111]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Finally, use `where` and `orderby` descending expressions to find the largest
    files that are less than `1,000` bytes in length:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`where`和`orderby`降序表达式来查找长度小于`1,000`字节的最大文件：
- en: '[PRE112]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Depending on the files in your `temp` folder, you should see an output like
    this:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的`temp`文件夹中的文件，您应该看到类似于这样的输出：
- en: '[PRE113]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: With this example, you have queried files in the host machine's `temp` folder,
    rather than creating small objects from lists.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个例子，你已经查询了主机机器的`temp`文件夹中的文件，而不是从列表中创建小对象。
- en: Note
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/mWeVC](https://packt.link/mWeVC).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/mWeVC](https://packt.link/mWeVC)找到此示例使用的代码。
- en: ThenBy and ThenByDescending
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ThenBy和ThenByDescending
- en: The following example sorts popular quotes, based on the number of words found
    in each.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例根据每个引语中的单词数对流行引语进行了排序。
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqThenByExamples.cs`
    and edit it as follows:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqThenByExamples.cs`的新文件，并编辑如下：
- en: '[PRE114]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'You start by declaring a string array of quotes as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 首先声明一个引号的字符串数组，如下所示：
- en: '[PRE115]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'In the next snippet, each of these string quotes is projected into a new anonymous
    type based on the number of words in the quote (found using `String.Split()`).
    The items are first sorted in descending order to show those with the most words
    and then sorted in alphabetical order:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，每个字符串引号都被投影到一个新的匿名类型中，该类型基于引号中的单词数（使用`String.Split()`找到）。首先按降序排序项目，以显示具有最多单词的项目，然后按字母顺序排序：
- en: '[PRE116]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Running the code lists the quotes in word count order as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码按单词计数顺序列出引语如下：
- en: '[PRE117]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Note how the quotes with six words are shown alphabetically.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 注意六个单词的引号是按字母顺序显示的。
- en: 'The following (highlighted code) is the equivalent Query Expression with `orderby
    quote.Words descending` followed by the `quote.Words` ascending clause:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 以下（突出显示的代码）是等效的查询表达式，其中包括`orderby quote.Words descending`，然后是`quote.Words`升序子句：
- en: '[PRE118]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Note
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/YWJRz](https://packt.link/YWJRz).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/YWJRz](https://packt.link/YWJRz)找到此示例中使用的代码。
- en: Now you have sorted popular quotes based on the number of words found in each.
    It is time to apply the skills learnt in the next exercise.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经根据每个引号中的单词数对流行引语进行了排序。现在是时候应用在下一个练习中学到的技能了。
- en: 'Exercise 4.03: Filtering a List of Countries by Continent and Sorting by Area'
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03：按大陆过滤国家列表并按面积排序
- en: In the preceding examples, you have looked at code that can select, filter,
    and sort a collection source. You will now combine these into an exercise that
    filters a small list of countries for two continents (South America and Africa)
    and sorts the results by geographical size.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您已经看到了可以选择、过滤和排序集合源的代码。现在，您将把这些组合到一个练习中，该练习将为两个大陆（南美洲和非洲）过滤一个小的国家列表，并按地理大小对结果进行排序。
- en: 'Perform the following steps to do so:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: In your `Chapter04\Exercises` folder, create a new `Exercise03` folder.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Exercises`文件夹中，创建一个新的`Exercise03`文件夹。
- en: Add a new class called `Program.cs` in the `Exercise03` folder.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exercise03`文件夹中添加一个名为`Program.cs`的新类。
- en: 'Start by adding a `Country` record that will be passed the `Name` of a country,
    the `Continent` to which it belongs, and its `Area` in square miles:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一个`Country`记录，该记录将传递国家的`Name`，它所属的`Continent`，以及它的`Area`（以平方英里计）：
- en: '[PRE119]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now create a small subset of country data defined in an array, as follows:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个由数组定义的国家数据的小子集，如下所示：
- en: '[PRE120]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The array contains the name of a country, the continent it belongs to, and its
    geographical size in square miles.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 数组包含一个国家的名称，它所属的大陆，以及它的地理面积（以平方英里计）。
- en: 'Your search criteria must include `South America` or `Africa`. So define them
    in an array rather than hardcoding the `where` clause with two specific strings:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的搜索条件必须包括`南美洲`或`非洲`。因此，将它们定义为一个数组，而不是在`where`子句中硬编码两个特定的字符串：
- en: '[PRE121]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This offers extra code flexibility should you need to alter it.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以提供额外的代码灵活性，以便在需要时进行更改。
- en: 'Build up a query by filtering and sorting by continent, sorting by area, and
    using the `.Select` extension method, which returns the `Index` and `item` value:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过过滤和按大陆排序，按面积排序，并使用`.Select`扩展方法来构建查询，该方法返回`Index`和`item`值：
- en: '[PRE122]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: You finally project each into a new anonymous type to be written to the console.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将每个项目投影到一个新的匿名类型中，以便写入控制台。
- en: 'Running the code block produces the following result:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码块会产生以下结果：
- en: '[PRE123]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Notice that `Algeria` has the largest area in `Africa`, and `Brazil` has the
    largest area in `South America` (based on this small subset of data). Notice how
    you add `1` to each `Index` for readability (since starting at zero is less user-friendly).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`阿尔及利亚`在`非洲`拥有最大的面积，`巴西`在`南美洲`拥有最大的面积（基于这个小数据子集）。注意如何为可读性向每个`Index`添加`1`（因为从零开始不够用户友好）。
- en: Note
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/Djddw](https://packt.link/Djddw).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/Djddw](https://packt.link/Djddw)找到此练习中使用的代码。
- en: You have seen how LINQ extension methods can be used to access items in a data
    source. Now, you will learn about partitioning data, which can be used to extract
    subsets of items.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了LINQ扩展方法如何用于访问数据源中的项目。现在，您将学习关于分区数据的知识，这可以用于提取项目的子集。
- en: Partitioning Operations
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区操作
- en: So far, you have looked at filtering the items in a data source that match a
    defined condition. Partitioning is used when you need to divide a data source
    into two distinct sections and return either of those two sections for subsequent
    processing.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了过滤数据源中与定义条件匹配的项目的代码。分区用于在需要将数据源分成两个不同部分并返回其中一个部分进行后续处理时使用。
- en: For example, consider that you have a list of vehicles sorted by value and want
    to process the five least expensive vehicles using some method. If the list is
    sorted in ascending order, then you could partition the data using the `Take(5)`
    method (defined in the following paragraphs), which will extract the first five
    items and discard the remaining.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个按价值排序的车辆列表，并且想要使用某种方法处理五辆最便宜的车辆。如果列表按升序排序，那么您可以使用`Take(5)`方法（在下面的段落中定义），该方法将提取前五个项目并丢弃其余的项目。
- en: 'There are six partitioning operations that are used to split a source, with
    either of the two sections being returned. There are no partitioning Query Expressions:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个分区操作，用于将源拆分为两个部分中的一个部分。没有分区查询表达式：
- en: '`Skip`: Returns a collection that skips items up to a specified numeric position
    in the source sequence. Used when you need to skip the first N items in a source collection.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Skip`：返回一个集合，该集合跳过源序列中指定数值位置的项目。当您需要跳过源集合中的前N个项目时使用。'
- en: '`SkipLast`: Returns a collection that skips the last N items in the source sequence.'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipLast`：返回一个跳过源序列中最后N个项的集合。'
- en: '`SkipWhile`: Returns a collection that skips items in the source sequence that
    match a specified condition.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipWhile`：返回一个跳过源序列中与指定条件匹配的项的集合。'
- en: '`Take`: Returns a collection that contains the first N items in the sequence.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Take`：返回一个包含序列中前N个项的集合。'
- en: '`TakeLast`: Returns a collection that contains the last N items in the sequence.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TakeLast`：返回一个包含序列中最后N个项的集合。'
- en: '`TakeWhile`: Returns a collection that contains only those items that match
    the condition specified.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TakeWhile`：返回一个仅包含与指定条件匹配的项的集合。'
- en: The following example demonstrates various `Skip` and `Take` operations on an
    unsorted list of exam grades. Here, you use `Skip(1)` to ignore the highest grade
    in a sorted list.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了对未排序的考试成绩列表进行各种`Skip`和`Take`操作。在这里，您使用`Skip(1)`来忽略排序列表中的最高成绩。
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqSkipTakeExamples.cs`
    and edit it as follows:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqSkipTakeExamples.cs`的新文件，并编辑如下：
- en: '[PRE124]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Next, the relational `is` operator is used to exclude those less than `25`
    or greater than `75`:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，关系`is`运算符用于排除小于`25`或大于`75`的值：
- en: '[PRE125]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'By using `SkipLast`, you can show the bottom half of the results. Add the code
    for this as follows:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`SkipLast`，您可以显示结果的后一半。添加以下代码：
- en: '[PRE126]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Finally, `Take(2)` is used here to show the two highest grades:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这里使用`Take(2)`来显示最高的两个成绩：
- en: '[PRE127]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Running the example produces this output, which is as expected:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例会产生预期的输出：
- en: '[PRE128]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This example demonstrated the various `Skip` and `Take` operations on an unsorted
    list of exam grades.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了对未排序的考试成绩列表进行各种`Skip`和`Take`操作。
- en: Note
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/TsDFk](https://packt.link/TsDFk).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/TsDFk](https://packt.link/TsDFk)找到此示例使用的代码。
- en: Grouping Operations
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组操作
- en: '`GroupBy` groups elements that share the same attribute. It is often used to
    group data or provide a count of items grouped by a common attribute. The result
    is an enumerable `IGrouping<K, V>` type collection, where `K` is the key type
    and `V` is the value type specified. `IGrouping` itself is enumerable as it contains
    all items that match the specified key.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy`将共享相同属性的元素分组。它通常用于对数据进行分组或提供按共同属性分组的项目计数。结果是一个可枚举的`IGrouping<K, V>`类型集合，其中`K`是键类型，`V`是指定的值类型。`IGrouping`本身是可枚举的，因为它包含所有与指定键匹配的项。'
- en: 'For example, consider the next snippet, which groups a `List` of customer orders
    by name. In your `Chapter04\Examples` folder, add a new file called `LinqGroupByExamples.cs`
    and edit it as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑下一个代码片段，它通过名称对客户订单的`List`进行分组。在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqGroupByExamples.cs`的新文件，并编辑如下：
- en: '[PRE129]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In this example, you have a list of `CustomerOrder` objects and want to group
    them by the `Name` property. For this, the `GroupBy` method is passed a `Func`
    delegate, which selects the `Name` property from each `CustomerOrder` instance.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您有一个`CustomerOrder`对象列表，并希望按`Name`属性对其进行分组。为此，`GroupBy`方法传递了一个`Func`委托，该委托从每个`CustomerOrder`实例中选择`Name`属性。
- en: 'Each item in the `GroupBy` result contains a `Key` (in this case, the customer''s
    `Name`). You can then sort the grouping item to show the `CustomerOrders` items
    sorted by `Quantity`, as follows:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy`结果中的每个项都包含一个`Key`（在本例中是客户的`Name`）。然后，您可以对分组项进行排序，以显示按`Quantity`排序的`CustomerOrders`项，如下所示：'
- en: '[PRE130]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Running the code produces the following output:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE131]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'You can see the data is first grouped by customer `Name` and then ordered by
    order `Quantity` within each customer grouping. The equivalent Query Expression
    is written like this:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到数据首先按客户“名称”分组，然后在每个客户分组内按订单“数量”排序。等效的查询表达式写成这样：
- en: '[PRE132]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You have now seen some of the commonly used LINQ operators. You will now bring
    them together in an exercise.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了一些常用的LINQ操作符。现在，您将在一个练习中将它们结合起来。
- en: 'Exercise 4.04: Finding the Most Commonly Used Words in a Book'
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.04：查找书中最常用的单词
- en: In *Chapter 3*, *Delegates, Events, and Lambdas*, you used the `WebClient` class
    to download data from a website. In this exercise, you will use data downloaded
    from *Project Gutenberg*.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*委托、事件和Lambda*中，您使用了`WebClient`类从网站下载数据。在这个练习中，您将使用从*Project Gutenberg*下载的数据。
- en: Note
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Project Gutenberg is a library of 60,000 free eBooks. You can search online
    for Project Gutenberg or visit [https://www.gutenberg.org/](https://www.gutenberg.org/).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: Project Gutenberg是一个拥有6万本免费电子书的图书馆。您可以在线搜索Project Gutenberg或访问[https://www.gutenberg.org/](https://www.gutenberg.org/)。
- en: You will create a console app that allows the user to enter a URL. Then, you
    will download the book's text from the Project Gutenberg URL and use various LINQ
    statements to find the most frequent words in the book's text.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建一个控制台应用程序，允许用户输入URL。然后，您将从Project Gutenberg URL下载书籍文本，并使用各种LINQ语句查找书籍文本中最常见的单词。
- en: 'Additionally, you want to exclude some common stop-words; these are words such
    as `and`, `or`, and `the` that appear regularly in English, but add little to
    the meaning of a sentence. You will use the `Regex.Split` method to help split
    words more accurately than a simple space delimiter. Perform the following steps
    to do so:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您希望排除一些常见的停用词；这些词如`and`、`or`和`the`在英语中经常出现，但对句子的意义贡献不大。您将使用`Regex.Split`方法来帮助更准确地分割单词，而不是简单的空格分隔符。执行以下步骤来实现：
- en: Note
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on Regex can be found at [https://packt.link/v4hGN](https://packt.link/v4hGN).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/v4hGN](https://packt.link/v4hGN)找到有关Regex的更多信息。
- en: In your `Chapter04\Exercises` folder, create a new `Exercise04` folder.
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Exercises`文件夹中，创建一个新的`Exercise04`文件夹。
- en: Add a new class called `Program.cs` in the `Exercise04` folder.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exercise04`文件夹中添加一个名为`Program.cs`的新类。
- en: 'First, define the `TextCounter` class. This will be passed the path to a file,
    which you will add shortly. This should contain common English stop-words:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义`TextCounter`类。这将传递文件路径，稍后将添加文件。这应该包含常见的英语停用词：
- en: '[PRE133]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Using `File.ReadAllLines`, add each word into the `_stopWords` `HashSet`.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`File.ReadAllLines`，将每个单词添加到`_stopWords`的`HashSet`中。
- en: '[PRE134]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: You have used a `HashSet`, as each stop-word is unique.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用了`HashSet`，因为每个停用词都是唯一的。
- en: Next, the `Process` method is passed a string that contains the book's text
    and the maximum number of words to show.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`Process`方法会传入一个包含书籍文本和要显示的最大单词数的字符串。
- en: 'Return the result as a `Tuple<string, int>` collection, which saves you from
    having to create a class or record to hold the results:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果作为`Tuple<string, int>`集合返回，这样您就不必创建一个类或记录来保存结果：
- en: '[PRE135]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Now perform the query part. Use `Regex.Split` with the pattern `@"\s+"` to split
    all the words.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在执行查询部分。使用模式`@"\s+"`和`Regex.Split`来拆分所有单词。
- en: In its simplest form, this pattern splits a string into a list of words, typically
    using a space or punctuation marks to identify word boundaries. For example, the
    string `Hello Goodbye` would be split into an array that contains two elements,
    `Hello` and `Goodbye`. The returned string items are filtered via `where` to ensure
    all stop-words are ignored using the `Contains` method. The words are then grouped
    by value, `GroupBy(t=>t)`, projected to a `Tuple` using the word as a `Key`, and
    the number of times it occurs using `grp.Count`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，此模式将字符串拆分为单词列表，通常使用空格或标点符号来识别单词边界。例如，字符串`Hello Goodbye`将被拆分为包含两个元素`Hello`和`Goodbye`的数组。返回的字符串项通过`where`进行过滤，以确保所有停用词都被`Contains`方法忽略。然后，通过值进行分组，`GroupBy(t=>t)`，使用单词作为`Key`，使用`grp.Count`来投影到一个`Tuple`中，表示它出现的次数。
- en: 'Finally, you sort by `Item2`, which for this `Tuple` is the word count, and
    then take only the required number of words:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按`Item2`排序，对于这个`Tuple`来说，它是单词计数，然后只取所需数量的单词：
- en: '[PRE136]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Now start creating the main console app:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在开始创建主控制台应用程序：
- en: '[PRE137]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Include a text file called `StopWords.txt` in the `Chapter04` source folder:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter04`源文件夹中包含一个名为`StopWords.txt`的文本文件：
- en: '[PRE138]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Note
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find `StopWords.txt` on GitHub at [https://packt.link/Vi8JH](https://packt.link/Vi8JH),
    or you can download any standard stop-word file, such as NLTK's [https://packt.link/ZF1Tf](https://packt.link/ZF1Tf).
    This file should be saved in the `Chapter04\Exercises` folder.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到`StopWords.txt`，网址为[https://packt.link/Vi8JH](https://packt.link/Vi8JH)，或者您可以下载任何标准的停用词文件，比如NLTK的[https://packt.link/ZF1Tf](https://packt.link/ZF1Tf)。该文件应保存在`Chapter04\Exercises`文件夹中。
- en: 'Once `TextCounter` has been created, prompt the user for a URL:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了`TextCounter`，就提示用户输入URL：
- en: '[PRE139]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Enter a valid address and create a new `WebClient` instance and download the
    data file into a temporary file.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入有效地址并创建一个新的`WebClient`实例，将数据文件下载到临时文件中。
- en: 'Perform extra processing to the text file before passing its contents to `TextCounter`:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将其内容传递给`TextCounter`之前，对文本文件进行额外处理：
- en: '[PRE140]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The Gutenberg text files contain extra details such as the author and title.
    These can be read by reading each line in the file. The actual text of the book
    doesn''t begin until finding a line that starts `*** START OF THE PROJECT GUTENBERG
    EBOOK`, so you need to read each line looking for this start message too:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 古腾堡文本文件包含额外的细节，比如作者和标题。这些可以通过读取文件中的每一行来读取。直到找到以`*** START OF THE PROJECT GUTENBERG
    EBOOK`开头的行为止，书籍的实际文本才开始，因此您需要读取每一行以寻找这个开始消息：
- en: '[PRE141]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Next, append each line read into a `StringBuilder` instance, which is efficient
    for such string operations:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将每一行读取到一个`StringBuilder`实例中，这对于这样的字符串操作非常高效：
- en: '[PRE142]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Now parse each line inside `tempFile`, looking for the `Author`, `Title`, or
    the `StartIndicator`:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tempFile`中解析每一行，寻找`Author`、`Title`或`StartIndicator`：
- en: '[PRE143]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'If the book text is found, provide a summary of lines and characters read before
    calling the `counter.Process` method. Here, you want the top `50` words:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到书籍文本，提供在调用`counter.Process`方法之前读取的行数和字符数的摘要。在这里，您需要前50个单词：
- en: '[PRE144]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Once you have the results, use a `foreach` loop to output the word count details,
    adding a blank line to the output after every third word:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得结果后，使用`foreach`循环输出单词计数的详细信息，在每三个单词后添加一个空行：
- en: '[PRE145]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Running the console app, using `https://www.gutenberg.org/files/64333/64333-0.txt`
    as an example URL produces the following output:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，使用`https://www.gutenberg.org/files/64333/64333-0.txt`作为示例URL，会产生以下输出：
- en: '[PRE146]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Note
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visual Studio might show the following when the code is run for the first time:
    `warning SYSLIB0014: ''WebClient.WebClient()'' is obsolete: ''WebRequest, HttpWebRequest,
    ServicePoint, and WebClient are obsolete. Use HttpClient instead.`'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '当首次运行代码时，Visual Studio可能会显示以下内容：`warning SYSLIB0014: ''WebClient.WebClient()''
    is obsolete: ''WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete.
    Use HttpClient instead.''`'
- en: This is a recommendation to use the newer `HttpClient` class instead of the
    `WebClient` class. Both are, however, functionally equivalent.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个建议，使用新的`HttpClient`类代替`WebClient`类。但两者在功能上是等效的。
- en: The output shows a list of words found amongst the `4,063` lines of text downloaded.
    The counter shows that `one`, `new`, and `project` are the most popular words.
    Notice how `mr.`, `gutenberg-tm`, `it.`, and `_the` appear as words. This shows
    that the Regex expression used is not completely accurate when splitting words.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了在下载的4063行文本中找到的单词列表。计数器显示`one`、`new`和`project`是最常见的单词。请注意`mr.`、`gutenberg-tm`、`it.`和`_the`等单词的出现。这表明使用的正则表达式在拆分单词时并不完全准确。
- en: Note
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/Q7Pf8](https://packt.link/Q7Pf8).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/Q7Pf8](https://packt.link/Q7Pf8)找到此练习中使用的代码。
- en: An interesting enhancement to this exercise would be to sort the words by count,
    include a count of the stop words found, or find the average word length.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个练习的一个有趣的增强是按计数对单词进行排序，包括找到的停用词的计数，或者找到平均单词长度。
- en: Aggregation Operations
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合操作
- en: 'Aggregation operations are used to compute a single value from a collection
    of values in a data source. An example could be the maximum, minimum, and average
    rainfall from data collected over a month:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合操作用于从数据源中的值集合计算单个值。例如，可以从一个月的数据中计算最大、最小和平均降雨量：
- en: '`Average`: Calculates the average value in a collection.'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Average`：计算集合中的平均值。'
- en: '`Count`: Counts the items that match a predicate.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count`：计算与谓词匹配的项目数。'
- en: '`Max`: Calculates the maximum value.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Max`：计算最大值。'
- en: '`Min`: Calculates the minimum value.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Min`：计算最小值。'
- en: '`Sum`: Calculates the sum of values.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sum`：计算值的总和。'
- en: 'The following example uses the `Process.GetProcess` method from the `System.Diagnostics`
    namespace to retrieve a list of processes currently running on the system:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`System.Diagnostics`命名空间中的`Process.GetProcess`方法来检索当前在系统上运行的进程列表：
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqAggregationExamples.cs`
    and edit it as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqAggregationExamples.cs`的新文件，并编辑如下：
- en: '[PRE147]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'First, `Process.GetProcesses().ToList()` is called to retrieve a list of the
    active processes running on the system:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 首先调用`Process.GetProcesses().ToList()`来检索系统上正在运行的活动进程列表：
- en: '[PRE148]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Then, the `Count` extension method obtains a count of the items returned. Count
    has an additional overload, which accepts a `Func` delegate used to filter each
    of the items to be counted. The `Process` class has a `PrivateMemorySize64` property,
    which returns the number of bytes of memory the process is currently consuming,
    so you can use that to count the `1,000,000` bytes of memory:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Count`扩展方法获取返回的项目数。Count还有一个额外的重载，它接受一个`Func`委托，用于过滤要计数的每个项目。`Process`类有一个`PrivateMemorySize64`属性，它返回进程当前消耗的内存字节数，因此您可以使用它来计算`1,000,000`字节的内存：
- en: '[PRE149]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Next, the `Average` extension method returns the overall average of a specific
    value for all items in the `processes` list. In this case, you use it to calculate
    the average memory consumption, using the `PrivateMemorySize64` property again:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Average`扩展方法返回`processes`列表中所有项目特定值的总体平均值。在这种情况下，您可以使用它来计算平均内存消耗，再次使用`PrivateMemorySize64`属性：
- en: '[PRE150]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The `PrivateMemorySize64` property is also used to calculate the maximum and
    minimum memory used for all processes, along with the total memory, as follows:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrivateMemorySize64`属性还用于计算所有进程使用的最大和最小内存，以及总内存，如下所示：'
- en: '[PRE151]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Once you have calculated the statistics, each value is written to the console:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 计算完统计数据后，每个值都写入控制台：
- en: '[PRE152]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: In the preceding snippet, the `Count` method returns the number of all processes
    and, using the `Predicate` overload, you `Count` those where the memory is less
    than 1,000,000 bytes (by examining the `process.PrivateMemorySize64` property).
    You can also see that `Average`, `Max`, `Min`, and `Sum` are used to calculate
    statistics for process memory usage on the system.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，`Count`方法返回所有进程的数量，并使用`Predicate`重载，您可以计算出内存小于1,000,000字节的进程数（通过检查`process.PrivateMemorySize64`属性）。您还可以看到`Average`、`Max`、`Min`和`Sum`被用来计算系统上进程内存使用的统计数据。
- en: Note
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The aggregate operators will throw `InvalidOperationException` with the error
    `Sequence contains no elements` if you attempt to calculate using a source collection
    that contains no elements. You should check the `Count` or `Any` methods prior
    to calling any aggregate operators.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试使用包含零个元素的源集合进行计算，聚合运算符将抛出`InvalidOperationException`错误，错误为`Sequence contains
    no elements`。在调用任何聚合运算符之前，应该检查`Count`或`Any`方法。
- en: 'Finally, `FormatBytes` formats the amounts of memory into their megabyte equivalents:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`FormatBytes`将内存量格式化为它们的兆字节等效值：
- en: '[PRE153]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Running the example produces results similar to this:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生类似于这样的结果：
- en: '[PRE154]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: From the output you will observe how the program retrieves a list of processes
    currently running on the system.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，您将观察到程序如何检索当前在系统上运行的进程列表。
- en: Note
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/HI2eV](https://packt.link/HI2eV).
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/HI2eV](https://packt.link/HI2eV)找到此示例使用的代码。
- en: Quantifier Operations
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量词操作
- en: Quantifier operations return a `bool` that indicates whether `Predicate` condition.
    This is often used to verify any elements in a collection match some criteria,
    rather than relying on `Count`, which enumerates **all** items in the collection,
    even if you need just one result.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 量词操作返回一个指示`Predicate`条件是否的`bool`值。这通常用于验证集合中的任何元素是否符合某些标准，而不是依赖于`Count`，后者枚举集合中的**所有**项目，即使您只需要一个结果。
- en: 'Quantifier operations are accessed using the following extension methods:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 量词操作使用以下扩展方法访问：
- en: '`All`: Returns `true` if **all** elements in the source sequence match a condition.'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`All`：如果源序列中**所有**元素都匹配条件，则返回`true`。'
- en: '`Any`: Returns `true` if **any** element in the source sequence matches a condition.'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any`：如果源序列中**任何**元素匹配条件，则返回`true`。'
- en: '`Contains`: Returns `true` if the source sequence contains the specified item.'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains`：如果源序列包含指定的项目，则返回`true`。'
- en: 'The following card-dealing example selects three cards at random and returns
    a summary of those selected. The summary uses the `All` and `Any` extension methods
    to determine whether any of the cards were clubs or red and whether all cards
    were diamonds or an even number:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 以下发牌示例随机选择三张牌，并返回这些选定牌的摘要。摘要使用`All`和`Any`扩展方法来确定任何一张牌是否为梅花或红色，以及所有牌是否为方块或偶数：
- en: In your `Chapter04\Examples` folder, add a new file called `LinqAllAnyExamples.cs`.
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqAllAnyExamples.cs`的新文件。
- en: 'Start by declaring an `enum` that represents each of the four suits in a pack
    of playing cards and a `record` class that defines a playing card:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明一个`enum`，代表一副扑克牌中的四种花色，以及定义一张扑克牌的`record`类：
- en: '[PRE155]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'It is common practice to override the `ToString` method to provide a user-friendly
    way to describe an object''s state at runtime. Here, the card''s number and suit
    are returned as a string:'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`ToString`方法以提供一种用户友好的方式来描述对象在运行时的状态是一种常见做法。在这里，卡的号码和花色以字符串形式返回：
- en: '[PRE156]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Now create a class to represent a deck of cards (for ease, only create cards
    numbered one to 10). The deck''s constructor will populate the `_cards` collection
    with `10` cards for each of the suits:'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个代表一副牌的类（为了方便，只创建编号为1到10的牌）。该牌的构造函数将使用`10`张牌填充`_cards`集合，每种花色都有`10`张牌：
- en: '[PRE157]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Next, the `Draw` method randomly selects a card from the `_cards` List, which
    it removes before returning to the caller:'
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`Draw`方法从`_cards`列表中随机选择一张卡，并在返回给调用者之前将其移除：
- en: '[PRE158]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The console app selects three cards using the deck''s `Draw` method. Add the
    code for this as follows:'
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台应用程序使用牌组的`Draw`方法选择三张牌。将代码添加如下：
- en: '[PRE159]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To show a summary, use the `OrderByDescending` and `Select` operations to extract
    the user-friendly `ToString` description for each `PlayingCard`. This is then
    joined into a single delimited string as follows:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示摘要，使用`OrderByDescending`和`Select`操作提取每个`PlayingCard`的用户友好的`ToString`描述。然后将其连接成一个单个的分隔字符串，如下所示：
- en: '[PRE160]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Using `All` or `Any`, you can provide an overview of the cards and their score
    using the `Sum` of the card numbers. By using `Any`, you determine whether `PlayingCardSuit.Clubs`):'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`All`或`Any`，您可以使用卡片号码的`Sum`来提供卡片及其得分的概述。通过使用`Any`，您可以确定是否`PlayingCardSuit.Clubs`：
- en: '[PRE161]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Similarly, `Any` is used to see if `Hearts` or `Diamonds` suits, and therefore,
    are `Red`:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`Any`用于查看`Hearts`或`Diamonds`花色，因此是`Red`：
- en: '[PRE162]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'In the next snippet, the `All` extension looks at every item in the collection
    and returns `true`, in this case, if `Diamonds`:'
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个片段中，`All`扩展查看集合中的每个项目，并在这种情况下返回`true`，如果是`Diamonds`：
- en: '[PRE163]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'All is used again to see if all card numbers can be divided by two without
    a remainder, that is, whether they are even:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`All`来查看所有卡片号码是否可以被2整除，即它们是否是偶数：
- en: '[PRE164]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Conclude by using the `Sum` aggregation method to calculate the value of the
    cards in the hand:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`Sum`聚合方法来计算手中卡片的价值：
- en: '[PRE165]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Running the console app produces output like this:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生如下输出：
- en: '[PRE166]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The cards are randomly selected so you will have different hands each time you
    run the program. In this example, the score was `21`, which is often a winning
    hand in card games.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片是随机选择的，因此每次运行程序时都会有不同的手牌。在这个例子中，得分是`21`，这在纸牌游戏中通常是一手赢牌。
- en: Note
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/xPuTc](https://packt.link/xPuTc).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/xPuTc](https://packt.link/xPuTc)找到此示例使用的代码。
- en: Join Operations
  id: totrans-666
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接操作
- en: Join operations are used to join two sources based on the association of objects
    in one data source with those that share a common attribute in a second data source.
    If you are familiar with database design, this can be thought of as a primary
    and foreign key relationship between tables.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 连接操作用于基于一个数据源中的对象与第二个数据源中具有共同属性的对象的关联来连接两个源。如果您熟悉数据库设计，可以将其视为表之间的主键和外键关系。
- en: A common example of a join is one where you have a one-way relationship, such
    as `Orders`, which has a property of type `Products`, but the `Products` class
    does not have a collection property that represents a backward relationship to
    a collection of `Orders`. By using a `Join` operator, you can create a backward
    relationship to show `Orders` for `Products`.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的连接示例是单向关系，例如`Orders`，它具有`Products`类型的属性，但`Products`类没有表示向后关系到`Orders`集合的属性。通过使用`Join`运算符，您可以创建一个向后关系来显示`Products`的`Orders`。
- en: 'The two join extension methods are the following:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 两个连接扩展方法如下：
- en: '`Join`: Joins two sequences using a key selector to extract pairs of values.'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Join`：使用键选择器连接两个序列以提取值对。'
- en: '`GroupJoin`: Joins two sequences using a key selector and groups the resulting items.'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupJoin`：使用键选择器连接两个序列，并对结果项进行分组。'
- en: 'The following example contains three `Manufacturer` records, each with a unique
    `ManufacturerId`. These numeric IDs are used to define various `Car` records,
    but to save memory, you will not have a direct memory reference from `Manufacturer`
    back to `Car`. You will use the `Join` method to create an association between
    the `Manufacturer` and `Car` instances:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例包含三个`Manufacturer`记录，每个记录都有一个唯一的`ManufacturerId`。这些数字ID用于定义各种`Car`记录，但为了节省内存，您将不会直接从`Manufacturer`返回到`Car`的内存引用。您将使用`Join`方法来创建`Manufacturer`和`Car`实例之间的关联：
- en: In your `Chapter04\Examples` folder, add a new file called `LinqJoinExamples.cs`.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Chapter04\Examples`文件夹中，添加一个名为`LinqJoinExamples.cs`的新文件。
- en: 'First, declare the `Manufacturer` and `Car` records as follows:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明`Manufacturer`和`Car`记录如下：
- en: '[PRE167]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Inside the `Main` entry point, create two lists, one for the manufacturers
    and the other to represent the `cars`:'
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`入口点内，创建两个列表，一个用于制造商，另一个用于代表`cars`：
- en: '[PRE168]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'At this point, there is no direct reference, but as you know, you can use `ManufacturerId`
    to link the two together using the `int` IDs. You can add the following code for
    this:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，没有直接的引用，但是您可以使用`ManufacturerId`来使用`int`ID将两者连接起来。您可以为此添加以下代码：
- en: '[PRE170]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: In the preceding snippet, the `Join` operation has various parameters. You pass
    in the `cars` list and define which properties in the `manufacturer` and `car`
    classes should be used to create the join. In this case, `manufacturer.ManufacturerId
    = car.ManufacturerId` determines the correct join.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，`Join`操作有各种参数。您传入`cars`列表，并定义`manufacturer`和`car`类中应该用于创建连接的属性。在这种情况下，`manufacturer.ManufacturerId
    = car.ManufacturerId`确定了正确的连接。
- en: Finally, the `manufacturer` and `car` arguments return a new anonymous type
    that contains the `manufacturer.Name` and `car.Name` properties.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`manufacturer`和`car`参数返回一个包含`manufacturer.Name`和`car.Name`属性的新匿名类型。
- en: 'Running the console app produces the following output:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生以下输出：
- en: '[PRE171]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: As you can see, each of the `Car` and `Manufacturer` instances has been joined
    correctly using `ManufacturerId`.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个`Car`和`Manufacturer`实例都已经使用`ManufacturerId`正确连接。
- en: 'The equivalent Query Expression would be as follows (note that in this case,
    it is a more concise format than the Query Operator syntax):'
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等效的查询表达式如下（请注意，在这种情况下，它比查询运算符语法更简洁）：
- en: '[PRE172]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Note
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [http://packt.link/Wh8jK](http://packt.link/Wh8jK).
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://packt.link/Wh8jK](http://packt.link/Wh8jK)找到此示例使用的代码。
- en: Before you finish exploring LINQ, there is one more area related to LINQ Query
    Expressions—the `let` clause.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成探索LINQ之前，还有一个与LINQ查询表达式相关的领域——`let`子句。
- en: Using a let Clause in Query Expressions
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在查询表达式中使用let子句
- en: 'In earlier Query Expressions, you are often required to repeat similar-looking
    code in various clauses. Using a `let` clause, you can introduce new variables
    inside an Expression Query and reuse the variable''s value throughout the rest
    of the query. For example, consider the following query:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的查询表达式中，您经常需要在各种子句中重复类似的代码。使用`let`子句，您可以在表达式查询中引入新变量，并在查询的其余部分重复使用变量的值。例如，考虑以下查询：
- en: '[PRE173]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Here, you are searching for a station with the `LVS` or `EUS` code or a name
    ending in `CROSS`. To do this, you must extract the last three characters using
    a range, `station[^3..]`, but you have duplicated that in two `where` clauses
    and the final projection.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在搜索具有`LVS`或`EUS`代码或以`CROSS`结尾的名称的车站。为此，您必须使用一个范围，`station[^3..]`来提取最后三个字符，但您在两个`where`子句和最终的投影中重复了这个操作。
- en: 'The station code and station names could both be converted into local variables
    using the `let` clause:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 车站代码和车站名称都可以使用`let`子句转换为本地变量：
- en: '[PRE174]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Here, you have defined `code` and `name` using a `let` clause and reused them
    throughout the query. This code looks much neater and is also easier to follow
    and maintain.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用`let`子句定义了`code`和`name`，并在整个查询中重复使用它们。这段代码看起来更整洁，也更容易理解和维护。
- en: 'Running the code produces the following output:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE175]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Note
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/b2KiG](https://packt.link/b2KiG).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/b2KiG](https://packt.link/b2KiG)找到此示例使用的代码。
- en: By now you have seen the main parts of LINQ. Now you will now bring these together
    into an activity that filters a set of flight records based on a user's criteria
    and provides various statistics on the subset of flights found.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了LINQ的主要部分。现在，您将把这些部分结合起来，进行一项活动，根据用户的标准对一组航班记录进行筛选，并对找到的航班子集提供各种统计信息。
- en: 'Activity 4.01: Treasury Flight Data Analysis'
  id: totrans-703
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：财政部航班数据分析
- en: You have been asked to create a console app that allows the user to download
    publicly available flight data files and apply statistical analysis to the files.
    This analysis should be used to calculate a count of the total records found,
    along with the average, minimum, and maximum fare paid within that subset.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 您被要求创建一个控制台应用程序，允许用户下载公开可用的航班数据文件，并对文件应用统计分析。这些分析应用于计算找到的总记录数，以及该子集中的平均、最低和最高票价。
- en: The user should be able to enter a number of commands and each command should
    add a specific filter based on the flight's class, origin, or destination properties.
    Once the user has entered the required criteria, the `go` command must be entered,
    and the console should run a query and output the results.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应能够输入多个命令，每个命令应基于航班的类别、起点或目的地属性添加特定的筛选条件。一旦用户输入所需的条件，必须输入`go`命令，控制台应运行查询并输出结果。
- en: 'The data file you will use for this activity contains details of flights made
    by the UK''s HM Treasury department between January 1 to December 31, 2011 (there
    are 714 records.) You will need to use `WebClient.DownloadFile` to download the
    data from the following URL: [https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv](https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv)'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 您将用于此活动的数据文件包含了英国财政部在2011年1月1日至12月31日之间进行的航班的详细信息（共有714条记录）。您需要使用`WebClient.DownloadFile`从以下URL下载数据：[https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv](https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv)
- en: Note
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The website might open differently for Internet Explorer or Google Chrome. This
    depends on how IE or Chrome are configured on your machine. Using `WebClient.DownloadFile`,
    you can download the data as suggested.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站在Internet Explorer或Google Chrome中可能会以不同方式打开。这取决于您的计算机上如何配置IE或Chrome。使用`WebClient.DownloadFile`，您可以按照建议下载数据。
- en: Ideally, the program should download data once and then reread it from the local
    filesystem each time it is started.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，程序应该下载数据一次，然后在每次启动时从本地文件系统中重新读取数据。
- en: '![Figure 4.6: Preview of HM Treasury traffic data in Excel'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：Excel中英国财政部交通数据的预览'
- en: '](img/B16835_04_06.jpg)'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_04_06.jpg)'
- en: 'Figure 4.6: Preview of HM Treasury traffic data in Excel'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：Excel中英国财政部交通数据的预览
- en: 'Once downloaded, the data should then be read into a suitable record structure
    before being added to a collection, which allows various queries to be applied.
    The output should show the following aggregate values for all rows that match
    the user''s criteria:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，数据应被读入适当的记录结构，然后添加到一个允许应用各种查询的集合中。输出应显示符合用户标准的所有行的以下聚合值：
- en: Record count
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录计数
- en: Average fare
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均票价
- en: Minimum fare
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低票价
- en: Maximum fare
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高票价
- en: 'The user should be able to enter the following console commands:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应能够输入以下控制台命令：
- en: '`Class c`: Adds a class filter, where `c` is a flight class to search for,
    such as `economy` or `Business class`.'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Class c`：添加一个类别筛选条件，其中`c`是要搜索的航班类别，如`经济舱`或`商务舱`。'
- en: '`Origin o`: Adds an `origin` filter, where o is the flight origin, such as
    `dublin`, `london`, or `basel`.'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Origin o`：添加一个`起点`筛选条件，其中o是航班起点，如`都柏林`、`伦敦`或`巴塞尔`。'
- en: '`Destination d`: Adds a destination filter, where `d` is the flight destination,
    such as `delhi`.'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Destination d`：添加一个目的地筛选条件，其中`d`是航班目的地，如`德里`。'
- en: '`Clear`: Clears all filters.'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear`：清除所有筛选条件。'
- en: '`go`: Applies the current filters.'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go`：应用当前筛选条件。'
- en: If a user enters multiple filters of the same type, then these should be treated
    as an `OR` filter.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入多个相同类型的筛选条件，则应将其视为`OR`筛选条件。
- en: 'An `enum` can be used to identify the filter criteria type entered, as shown
    in the following line of code:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`enum`来标识输入的筛选条件类型，如下代码所示：
- en: '[PRE176]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Similarly, a record can be used to store each filter type and comparison operand,
    as follows:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以使用记录来存储每种过滤类型和比较操作数，如下所示：
- en: '[PRE177]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Each filter specified should be added to a `List<FilterCriteria>` instance.
    For example, if the user enters two origin filters, one for `dublin` and another
    for `london`, then the list should contain two objects, each representing an origin
    type filter.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 应将指定的每个过滤器添加到一个`List<FilterCriteria>`实例中。例如，如果用户输入了两个起始点过滤器，一个是`dublin`，另一个是`london`，那么列表应该包含两个对象，每个对象代表一个起始点类型的过滤器。
- en: 'When the user enters the `go` command, a query should be built that performs
    the following steps:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入`go`命令时，应构建一个查询，执行以下步骤：
- en: Extracts all `class` filter values into a list of strings (`List<string>`).
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有`class`过滤值提取到字符串列表（`List<string>`）中。
- en: Extracts all `origin` filter values into `List<string>`.
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有`origin`过滤值提取到`List<string>`中。
- en: Extracts all `destination` filter values into `List<string>`.
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有`destination`过滤值提取到`List<string>`中。
- en: Uses a `where` extension method to filter the fight records for each criteria
    type specified using the `List<string>`. It contains a method to perform a case-insensitive
    search.
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`where`扩展方法来过滤使用`List<string>`指定的每个条件类型的战斗记录。它包含一个执行不区分大小写搜索的方法。
- en: 'The following steps will help you complete this activity:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Create a new folder called `Activities` in the `Chapter04` folder.
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter04`文件夹中创建一个名为`Activities`的新文件夹。
- en: Add a new folder called `Activity01` to that new folder.
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该新文件夹中添加一个名为`Activity01`的文件夹。
- en: Add a new class file called `Flight.cs`. This will be a `Record` class with
    fields that match those in the flight data. A `Record` class should be used as
    it offers a simple type purely to hold data rather than any form of behavior.
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Flight.cs`的新类文件。这将是一个与航班数据中的字段匹配的`Record`类。应该使用`Record`类，因为它提供了一个简单的类型，纯粹用于保存数据，而不是任何形式的行为。
- en: 'Add a new class file called `FlightLoader.cs`. This class will be used for
    downloading or importing data. `FlightLoader` should include a list of the field
    index positions within the data file, to be used when reading each line of data
    and splitting the contents into a string array, for example:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`FlightLoader.cs`的新类文件。这个类将用于下载或导入数据。`FlightLoader`应该包括一个字段索引位置的列表，用于在读取每行数据并将内容拆分为字符串数组时使用，例如：
- en: '[PRE178]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Now for the `FlightLoader` implementation, use a `static` class to define the
    index of known field positions in the data file. This will make it easier to handle
    any future changes in the layout of the data.
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在对于`FlightLoader`的实现，使用一个`static`类来定义数据文件中已知字段位置的索引。这将使处理数据布局的任何未来更改变得更容易。
- en: Next, a `Download` method should be passed a URL and destination file. Use `WebClient.DownloadFile`
    to download the data file and then defer to `Import` to process the downloaded
    file.
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，应该传递一个URL和目标文件给`Download`方法。使用`WebClient.DownloadFile`下载数据文件，然后推迟到`Import`来处理下载的文件。
- en: An `Import` method is to be added. This is passed the name of the local file
    to import (downloaded using the `Import` method) and will return a list of `Flight` records.
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应添加一个`Import`方法。这个方法将传递要导入的本地文件的名称（使用`Import`方法下载），并将返回一个`Flight`记录的列表。
- en: Add a class file called `FilterCriteria.cs`. This should contain a `FilterCriteriaType`
    `enum` definition. You will offer filters based on the flight's class, origin,
    and destination properties, so `FilterCriteriaType` should represent each of these.
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`FilterCriteria.cs`的类文件。这应该包含一个`FilterCriteriaType`的`enum`定义。您将基于航班的类、起始点和目的地属性提供过滤器，因此`FilterCriteriaType`应该代表这三者中的每一个。
- en: Now, for the main filtering class, add a new class file called `FlightQuery.cs`.
    The constructor will be passed a `FlightLoader` instance. Within it, create a
    list named `_flights` to contain the data imported via `FlightLoader`. Create
    a `List<FilterCriteria>` instance named `_filters` that represent each of the
    criteria items that are added, each time the user specifies a new filter condition.
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于主过滤类，添加一个名为`FlightQuery.cs`的新类文件。构造函数将传递一个`FlightLoader`实例。在其中，创建一个名为`_flights`的列表，用于包含通过`FlightLoader`导入的数据。创建一个名为`_filters`的`List<FilterCriteria>`实例，表示每次用户指定新的过滤条件时添加的每个条件项。
- en: The `Import` and `Download` methods of `FlightLoader` should be called by the
    console at startup, allowing previously downloaded data to be processed, via the
    `_loader` instance.
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台在启动时应调用`FlightLoader`的`Import`和`Download`方法，允许通过`_loader`实例处理先前下载的数据。
- en: Create a `Count` variable that returns the number of flight records that have
    been imported.
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回已导入的航班记录数量的`Count`变量。
- en: When the user specifies a filter to add, the console will call `AddFilter`,
    passing an `enum` to define the criteria type and the string value being filtered
    for.
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户指定要添加的过滤器时，控制台将调用`AddFilter`，传递一个`enum`来定义条件类型和被过滤的字符串值。
- en: '`RunQuery` is the main method that returns those flights that match the user''s
    criteria. You need to use the built-in `StringComparer.InvariantCultureIgnoreCase`
    comparer to ensure string comparison ignores any case differences. You define
    a query variable that calls `Select` on the flights; at the moment, this would
    result in a filtered result set.'
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RunQuery`是返回与用户条件匹配的航班的主要方法。您需要使用内置的`StringComparer.InvariantCultureIgnoreCase`比较器来确保字符串比较忽略任何大小写差异。您定义一个调用`Select`的查询变量，目前这将导致一个经过过滤的结果集。'
- en: Each of the types of filter available is string-based, so you need to extract
    all the string items. If there are any items to filter, you add an extra `Where`
    call to the query for each type (`Class`, `Destination`, or `Origin`). Each `Where`
    clause uses a `Contains` predicate, which examines the associated property.
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每种可用的过滤类型都是基于字符串的，因此您需要提取所有字符串项。如果有任何要过滤的项，您需要为每种类型（`Class`、`Destination`或`Origin`）的查询添加额外的`Where`调用。每个`Where`子句都使用`Contains`谓词，检查关联的属性。
- en: Next, add the two helper methods used by `RunQuery`. `GetFiltersByType` is passed
    each of the `FilterCriteriaType` enums that represent a known type of criteria
    type and finds any of these in the list of filters using the `.Where` method.
    For example, if the user added two `Destination` criteria such as India and Germany,
    this would result in the two strings `India` and `Germany` being returned.
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加两个由 `RunQuery` 使用的辅助方法。`GetFiltersByType` 被传入表示已知类型的条件类型的每个 `FilterCriteriaType`
    枚举，并使用 `.Where` 方法在过滤器列表中找到任何这些枚举。例如，如果用户添加了两个 `Destination` 条件，如印度和德国，这将导致返回两个字符串
    `India` 和 `Germany`。
- en: '`FormatFilters` simply joins a list of `filterValues` strings into a user-friendly
    string with the word `OR` between each item, such as `London OR Dublin`.'
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FormatFilters` 只是将 `filterValues` 字符串列表连接成一个用户友好的字符串，每个项目之间用 `OR` 连接，例如 `London
    OR Dublin`。'
- en: Now create the main console app. Add a new class called `Program.cs`, which
    will allow the user to input requests and process their commands.
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建主控制台应用程序。添加一个名为 `Program.cs` 的新类，允许用户输入请求并处理其命令。
- en: Hardcode the download URL and destination filename.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬编码下载 URL 和目标文件名。
- en: Create the main `FlightQuery` class, passing in a `FlightLoader` instance. If
    the app has been run before, you can `Import` the local flight data, or use `Download`
    if not.
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建主 `FlightQuery` 类，传入一个 `FlightLoader` 实例。如果应用程序之前已运行，您可以导入本地航班数据，或者如果没有，则使用
    `Download`。
- en: Show a summary of the records imported and the available commands.
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示导入的记录摘要和可用命令。
- en: When the user enters a command, there might also be an argument, such as `destination
    united kingdom`, where `destination` is the command and `united kingdom` is the
    argument. To determine this, use the `IndexOf` method to find the location of
    the first space character in the input, if any.
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户输入命令时，可能还会有参数，例如 `destination united kingdom`，其中 `destination` 是命令，`united
    kingdom` 是参数。要确定这一点，使用 `IndexOf` 方法找到输入中第一个空格字符的位置（如果有）。
- en: For the `go` command, call `RunQuery` and use various aggregation operators
    on the results returned.
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `go` 命令，调用 `RunQuery` 并在返回的结果上使用各种聚合运算符。
- en: For the remaining commands, clear or add filters as requested. If the `Clear`
    command is specified, call the query's `ClearFilters` method, which will clear
    the list of criteria items.
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于剩余的命令，根据请求清除或添加过滤器。如果指定了 `Clear` 命令，则调用查询的 `ClearFilters` 方法，该方法将清除条件项列表。
- en: If a `class` filter command is specified, call `AddFilter` specifying the `FilterCriteriaType.Class
    enum` and the string `Argument`.
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指定了 `class` 过滤器命令，请调用 `AddFilter`，指定 `FilterCriteriaType.Class enum` 和字符串
    `Argument`。
- en: The same pattern should be used for `Origin` and `Destination` commands. Call
    `AddFilter`, passing in the required `enum` value and the argument.
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Origin` 和 `Destination` 命令应使用相同的模式。调用 `AddFilter`，传入所需的 `enum` 值和参数。'
- en: 'The console output should be similar to the following, here listing the commands
    available to the user:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出应类似于以下内容，列出了用户可用的命令：
- en: '[PRE179]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The user should be able to add two class filters, for `economy` or `Business
    Class` (all string comparisons should be case-insensitive), as shown in the following
    snippet:'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户应能够添加两个类过滤器，用于 `economy` 或 `商务舱`（所有字符串比较应不区分大小写），如下段代码所示：
- en: '[PRE180]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Similarly, the user should be able to add an origin filter as follows (this
    example is for `london`):'
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，用户应能够添加原始过滤器，如下所示（此示例是为 `london`）：
- en: '[PRE181]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Adding the destination filter should look like this (this example is for `zurich`):'
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加目的地过滤器应如下所示（此示例是为 `zurich`）：
- en: '[PRE182]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Entering `go` should show a summary of all filters specified, followed by the
    results for flights that match the filters:'
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `go` 应显示指定的所有过滤器摘要，然后显示与过滤器匹配的航班结果：
- en: '[PRE183]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Note
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在 [https://packt.link/qclbF](https://packt.link/qclbF) 找到。
- en: Summary
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw how the `IEnumerable` and `ICollection` interfaces
    form the basis of .NET data structures, and how they can be used to store multiple
    items. You created different types of collections depending on how each collection
    is meant to be used. You learned that the `List` collection is most extensively
    used to store collections of items, particularly if the number of elements is
    not known at compile time. You saw that the `Stack` and `Queue` types allow the
    order of items to be handled in a controlled manner, and how the `HashSet` offers
    set-based processing, while the `Dictionary` stores unique values using a key
    identifier.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了 `IEnumerable` 和 `ICollection` 接口如何构成 .NET 数据结构的基础，以及它们如何用于存储多个项。您根据每个集合的用途创建了不同类型的集合。您了解到
    `List` 集合最广泛用于存储项的集合，特别是如果元素数量在编译时未知。您看到 `Stack` 和 `Queue` 类型允许以受控方式处理项目的顺序，以及
    `HashSet` 提供基于集合的处理，而 `Dictionary` 使用键标识符存储唯一值。
- en: You then further explored data structures by using LINQ Query Expressions and
    Query Operators to apply queries to data, showing how queries can be altered at
    runtime depending on filtering requirements. You sorted and partitioned data and
    saw how similar operations can be achieved using both Query Operators and Query
    Expressions, each offering a preference and flexibility based on context.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过使用 LINQ 查询表达式和查询运算符来进一步探索数据结构，应用查询到数据，展示了如何根据过滤要求在运行时修改查询。您对数据进行了排序和分区，并了解了如何使用查询运算符和查询表达式实现类似的操作，每种方法都根据上下文提供了偏好和灵活性。
- en: In the next chapter, you will see how parallel and asynchronous code can be
    used to run complex or long-running operations together.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将看到如何使用并行和异步代码来同时运行复杂或长时间运行的操作。
