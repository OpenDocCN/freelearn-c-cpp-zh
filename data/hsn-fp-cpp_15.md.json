["```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint main(){\n    string id;\n    string employee_id;\n    string first_name;\n    string last_name;\n    string seniority_level;\n    string position;\n    string years_worked_continuously;\n    string special_bonus_level;\n\n    ifstream employeesFile(\"./Employees.csv\");\n    while (getline(employeesFile, id, ',')) {\n        getline(employeesFile, employee_id, ',') ;\n        getline(employeesFile, first_name, ',') ;\n        getline(employeesFile, last_name, ',') ;\n        getline(employeesFile, seniority_level, ',') ;\n        getline(employeesFile, position, ',') ;\n        getline(employeesFile, years_worked_continuously, ',') ;\n        getline(employeesFile, special_bonus_level);\n        if(id == \"id\") continue;\n\n        int baseSalary;\n        if(position == \"Tester\") baseSalary= 1500;\n        if(position == \"Analyst\") baseSalary = 1600;\n        if(position == \"Developer\") baseSalary = 2000;\n        if(position == \"Team Leader\") baseSalary = 3000;\n        if(position == \"Manager\") baseSalary = 4000;\n\n        double factor;\n        if(seniority_level == \"Entry\") factor = 1;\n        if(seniority_level == \"Junior\") factor = 1.2;\n        if(seniority_level == \"Senior\") factor = 1.5;\n\n        double continuityFactor;\n        int continuity = stoi(years_worked_continuously);\n        if(continuity < 3) continuityFactor = 1;\n        if(continuity >= 3 && continuity < 5) continuityFactor = 1.2;\n        if(continuity >= 5 && continuity < 10) continuityFactor = 1.5;\n        if(continuity >=10 && continuity <= 20) continuityFactor = 1.7;\n        if(continuity > 20) continuityFactor = 2;\n\n        int specialBonusLevel = stoi(special_bonus_level);\n        double specialBonusFactor = specialBonusLevel * 0.03;\n\n        double currentSalary = baseSalary * factor * continuityFactor;\n        double salary = currentSalary + specialBonusFactor * \n            currentSalary;\n\n        int roundedSalary = ceil(salary);\n\n        cout  << seniority_level << position << \" \" << first_name << \" \n            \" << last_name << \" (\" << years_worked_continuously << \n            \"yrs)\" <<  \", \" << employee_id << \", has salary (bonus                 \n            level  \" << special_bonus_level << \") \" << roundedSalary << \n            endl;\n    }\n}\n```", "```cpp\nid,employee_id,First_name,Last_name,Seniority_level,Position,Years_worked_continuously,Special_bonus_level\n1,51ef10eb-8c3b-4129-b844-542afaba7eeb,Carmine,De Vuyst,Junior,Manager,4,3\n2,171338c8-2377-4c70-bb66-9ad669319831,Gasper,Feast,Entry,Team Leader,10,5\n3,807e1bc7-00db-494b-8f92-44acf141908b,Lin,Sunley,Medium,Manager,23,3\n4,c9f18741-cd6c-4dee-a243-00c1f55fde3e,Leeland,Geraghty,Medium,Team Leader,7,4\n5,5722a380-f869-400d-9a6a-918beb4acbe0,Wash,Van der Kruys,Junior,Developer,7,1\n6,f26e94c5-1ced-467b-ac83-a94544735e27,Marjie,True,Senior,Tester,28,1\n\n```", "```cpp\nJuniorManager Carmine De Vuyst (4yrs), 51ef10eb-8c3b-4129-b844-542afaba7eeb, has salary (bonus level  3) 6279\nEntryTeam Leader Gasper Feast (10yrs), 171338c8-2377-4c70-bb66-9ad669319831, has salary (bonus level  5) 5865\nMediumManager Lin Sunley (23yrs), 807e1bc7-00db-494b-8f92-44acf141908b, has salary (bonus level  3) 8720\nMediumTeam Leader Leeland Geraghty (7yrs), c9f18741-cd6c-4dee-a243-00c1f55fde3e, has salary (bonus level  4) 5040\nJuniorDeveloper Wash Van der Kruys (7yrs), 5722a380-f869-400d-9a6a-918beb4acbe0, has salary (bonus level  1) 3708\nSeniorTester Marjie True (28yrs), f26e94c5-1ced-467b-ac83-a94544735e27, has salary (bonus level  1) 4635\nEntryAnalyst Muriel Dorken (10yrs), f4934e00-9c01-45f9-bddc-2366e6ea070e, has salary (bonus level  8) 3373\nSeniorTester Harrison Mawditt (17yrs), 66da352a-100c-4209-a13e-00ec12aa167e, has salary (bonus level  10) 4973\n```", "```cpp\nifstream employeesFile(\"./Employees.csv\")\ncout  << seniority_level << position << \" \" << first_name << \" \" << \n    last_name << \" (\" << years_worked_continuously << \"yrs)\" <<  \", \" \n    << employee_id << \", has salary (bonus level  \" << \n    special_bonus_level << \") \" << roundedSalary << endl;\n```", "```cpp\nvoid printEmployee(const Employee& employee, ostream& stream, int \n    roundedSalary){\n        stream << employee.seniority_level << employee.position << \n        \" \" << employee.first_name << \" \" << employee.last_name << \n        \" (\" << employee.years_worked_continuously << \"yrs)\" <<  \",             \n        \" << employee.employee_id << \", has salary (bonus level  \" << \n        employee.special_bonus_level << \") \" << roundedSalary << endl;\n    }\n```", "```cpp\n        printEmployee(employee, cout, roundedSalary);\n```", "```cpp\n        int baseSalary;\n        if(position == \"Tester\") baseSalary = 1500;\n        if(position == \"Analyst\") baseSalary = 1600;\n        if(position == \"Developer\") baseSalary = 2000;\n        if(position == \"Team Leader\") baseSalary = 3000;\n        if(position == \"Manager\") baseSalary = 4000;\n```", "```cpp\nauto doesSomething = [](){\n        int baseSalary;\n        if(position == \"Tester\") baseSalary = 1500;\n        if(position == \"Analyst\") baseSalary = 1600;\n        if(position == \"Developer\") baseSalary = 2000;\n        if(position == \"Team Leader\") baseSalary = 3000;\n        if(position == \"Manager\") baseSalary = 4000;\n};\n```", "```cpp\nauto doesSomething = [](const string& position){\n        int baseSalary;\n        if(position == \"Tester\") baseSalary = 1500;\n        if(position == \"Analyst\") baseSalary = 1600;\n        if(position == \"Developer\") baseSalary = 2000;\n        if(position == \"Team Leader\") baseSalary = 3000;\n        if(position == \"Manager\") baseSalary = 4000;\n};\n```", "```cpp\nauto doesSomething = [](const string& position){\n        int baseSalary;\n        if(position == \"Tester\") baseSalary = 1500;\n        if(position == \"Analyst\") baseSalary = 1600;\n        if(position == \"Developer\") baseSalary = 2000;\n        if(position == \"Team Leader\") baseSalary = 3000;\n        if(position == \"Manager\") baseSalary = 4000;\n        return baseSalary;\n};\n```", "```cpp\nTEST_CASE(\"Base salary\"){\n    CHECK_EQ(1500, baseSalaryForPosition(\"Tester\"));\n    CHECK_EQ(1600, baseSalaryForPosition(\"Analyst\"));\n    CHECK_EQ(2000, baseSalaryForPosition(\"Developer\"));\n    CHECK_EQ(3000, baseSalaryForPosition(\"Team Leader\"));\n    CHECK_EQ(4000, baseSalaryForPosition(\"Manager\"));\n    CHECK_EQ(0, baseSalaryForPosition(\"asdfasdfs\"));\n}\n```", "```cpp\n    while (getline(employeesFile, id, ',')) {\n        getline(employeesFile, employee_id, ',') ;\n        getline(employeesFile, first_name, ',') ;\n        getline(employeesFile, last_name, ',') ;\n        getline(employeesFile, seniority_level, ',') ;\n        getline(employeesFile, position, ',') ;\n        getline(employeesFile, years_worked_continuously, ',') ;\n        getline(employeesFile, special_bonus_level);\n        if(id == \"id\") continue;\n\n int baseSalary = baseSalaryForPosition(position);\n        double factor;\n        if(seniority_level == \"Entry\") factor = 1;\n        if(seniority_level == \"Junior\") factor = 1.2;\n        if(seniority_level == \"Senior\") factor = 1.5;\n        ...\n}\n\n```", "```cpp\nauto factorForSeniority = [](const string& seniority_level){\n    double factor;\n    if(seniority_level == \"Entry\") factor = 1;\n    if(seniority_level == \"Junior\") factor = 1.2;\n    if(seniority_level == \"Senior\") factor = 1.5;\n    return factor;\n};\n```", "```cpp\nauto factorForContinuity = [](const string& years_worked_continuously){\n    double continuityFactor;\n    int continuity = stoi(years_worked_continuously);\n    if(continuity < 3) continuityFactor = 1;\n    if(continuity >= 3 && continuity < 5) continuityFactor = 1.2;\n    if(continuity >= 5 && continuity < 10) continuityFactor = 1.5;\n    if(continuity >=10 && continuity <= 20) continuityFactor = 1.7;\n    if(continuity > 20) continuityFactor = 2;\n    return continuityFactor;\n};\n\n```", "```cpp\nauto bonusLevel = [](const string& special_bonus_level){\n    return stoi(special_bonus_level);\n};\n```", "```cpp\nint main(){\n...\n    ifstream employeesFile(\"./Employees.csv\");\n    while (getline(employeesFile, id, ',')) {\n        getline(employeesFile, employee_id, ',') ;\n...\n        getline(employeesFile, special_bonus_level);\n        if(id == \"id\") continue;\n\n int baseSalary = baseSalaryForPosition(position);\n double factor = factorForSeniority(seniority_level);\n\n double continuityFactor = \n            factorForContinuity(years_worked_continuously);\n\n int specialBonusLevel =  bonusLevel(special_bonus_level);\n        double specialBonusFactor = specialBonusLevel * 0.03;\n\n        double currentSalary = baseSalary * factor * continuityFactor;\n        double salary = currentSalary + specialBonusFactor * \n            currentSalary;\n\n        int roundedSalary = ceil(salary);\n\n        cout  << seniority_level << position << \" \" << first_name << \"           \n          \" << last_name << \" (\" << years_worked_continuously << \"yrs)\"     \n          <<  \", \" << employee_id << \", has salary (bonus level  \" << \n          special_bonus_level << \") \" << roundedSalary << endl;\n    }\n```", "```cpp\n...        \n        int baseSalary = baseSalaryForPosition(position);\n        double factor = factorForSeniority(seniority_level);\n\n        double continuityFactor = \n            factorForContinuity(years_worked_continuously);\n\n        int specialBonusLevel =  bonusLevel(special_bonus_level);\n        double specialBonusFactor = specialBonusLevel * 0.03;\n\n        double currentSalary = baseSalary * factor * continuityFactor;\n        double salary = currentSalary + specialBonusFactor * \n            currentSalary;\n\n        int roundedSalary = ceil(salary);\n...\n```", "```cpp\nauto computeSalary = [](const string& position, const string seniority_level, const string& years_worked_continuously, const string& special_bonus_level){\n    int baseSalary = baseSalaryForPosition(position);\n    double factor = factorForSeniority(seniority_level);\n\n    double continuityFactor = \n        factorForContinuity(years_worked_continuously);\n\n    int specialBonusLevel =  bonusLevel(special_bonus_level);\n    double specialBonusFactor = specialBonusLevel * 0.03;\n\n    double currentSalary = baseSalary * factor * continuityFactor;\n    double salary = currentSalary + specialBonusFactor * currentSalary;\n\n    int roundedSalary = ceil(salary);\n    return roundedSalary;\n};\n```", "```cpp\nauto computeSalary = [](auto baseSalaryForPosition, auto factorForSeniority, auto factorForContinuity, auto bonusLevel){\n    int baseSalary = baseSalaryForPosition();\n    double factor = factorForSeniority();\n    double continuityFactor = factorForContinuity();\n    int specialBonusLevel =  bonusLevel();\n\n    double specialBonusFactor = specialBonusLevel * 0.03;\n\n    double currentSalary = baseSalary * factor * continuityFactor;\n    double salary = currentSalary + specialBonusFactor * currentSalary;\n\n    int roundedSalary = ceil(salary);\n    return roundedSalary;\n};\n```", "```cpp\n        auto roundedSalary = computeSalary(\n                bind(baseSalaryForPosition, position), \n                bind(factorForSeniority, seniority_level),\n        bind(factorForContinuity, years_worked_continuously),\n        bind(bonusLevel, special_bonus_level));\n\n        cout  << seniority_level << position << \" \" << first_name << \" \n          \" << last_name << \" (\" << years_worked_continuously << \"yrs)\"           \n          <<  \", \" << employee_id << \", has salary (bonus level  \" <<              \n          special_bonus_level << \") \" << roundedSalary << endl;\n```", "```cpp\nauto computeSalary = [](auto baseSalaryForPosition, auto \n    factorForSeniority, auto factorForContinuity, auto bonusLevel){\n        int baseSalary = baseSalaryForPosition();\n        double factor = factorForSeniority();\n        double continuityFactor = factorForContinuity();\n        int specialBonusLevel =  bonusLevel();\n\n        double specialBonusFactor = specialBonusLevel * 0.03;\n\n        double currentSalary = baseSalary * factor * continuityFactor;\n        double salary = currentSalary + specialBonusFactor * \n            currentSalary;\n\n        int roundedSalary = ceil(salary);\n         return roundedSalary;\n};\n```", "```cpp\nauto specialBonusFactor = [](auto bonusLevel){\n    return bonusLevel() * 0.03;\n};\nauto computeSalary = [](auto baseSalaryForPosition, auto     \nfactorForSeniority, auto factorForContinuity, auto bonusLevel){\n    int baseSalary = baseSalaryForPosition();\n    double factor = factorForSeniority();\n    double continuityFactor = factorForContinuity();\n\n    double currentSalary = baseSalary * factor * continuityFactor;\n    double salary = currentSalary + specialBonusFactor() * \n        currentSalary;\n\n    int roundedSalary = ceil(salary);\n    return roundedSalary;\n};\n```", "```cpp\nint main(){\n        ...\n  auto bonusFactor = bind(specialBonusFactor, [&](){ return \n    bonusLevel(special_bonus_level); } );\n  auto roundedSalary = computeSalary(\n      bind(baseSalaryForPosition, position), \n      bind(factorForSeniority, seniority_level),\n      bind(factorForContinuity, years_worked_continuously),\n      bonusFactor\n     );\n ...\n}\n\nauto computeSalary = [](auto baseSalaryForPosition, auto factorForSeniority, auto factorForContinuity, auto bonusFactor){\n    int baseSalary = baseSalaryForPosition();\n    double factor = factorForSeniority();\n    double continuityFactor = factorForContinuity();\n\n    double currentSalary = baseSalary * factor * continuityFactor;\n    double salary = currentSalary + bonusFactor() * currentSalary;\n\n    int roundedSalary = ceil(salary);\n    return roundedSalary;\n};\n```", "```cpp\nauto computeSalary = [](auto baseSalaryForPosition, auto \n    factorForSeniority, auto factorForContinuity, auto bonusFactor){\n        double currentSalary = baseSalaryForPosition() * \n            factorForSeniority() * factorForContinuity();\n    double salary = currentSalary + bonusFactor() * currentSalary;\n    return ceil(salary);\n};\n```", "```cpp\nauto computeSalary = [](auto baseSalaryForPosition, auto \n    factorForSeniority, auto factorForContinuity, auto bonusFactor){\n        double currentSalary = baseSalaryForPosition() * \n            factorForSeniority() * factorForContinuity();\n double salary = (1 + bonusFactor()) * currentSalary;\n    return ceil(salary);\n};\n```", "```cpp\nauto computeSalary = [](auto baseSalaryForPosition, auto \n    factorForSeniority, auto factorForContinuity, auto bonusFactor){\n        return ceil (\n                (1 + bonusFactor()) * baseSalaryForPosition() *                             \n                    factorForSeniority() * factorForContinuity()\n    );\n};\n```", "```cpp\nauto baseSalaryForPosition = [](const string& position){\n    int baseSalary;\n    if(position == \"Tester\") baseSalary = 1500;\n    if(position == \"Analyst\") baseSalary = 1600;\n    if(position == \"Developer\") baseSalary = 2000;\n    if(position == \"Team Leader\") baseSalary = 3000;\n    if(position == \"Manager\") baseSalary = 4000;\n    return baseSalary;\n};\n```", "```cpp\n        auto roundedSalary = computeSalary(\n bind(baseSalaryForPosition, position), \n                bind(factorForSeniority, seniority_level),\n                bind(factorForContinuity, years_worked_continuously),\n                bonusFactor\n            );\n```", "```cpp\nclass BaseSalaryForPosition{\n    private:\n        const string& position;\n\n    public:\n        BaseSalaryForPosition(const string& position) : \n            position(position){};\n\n        int baseSalaryForPosition() const{\n            int baseSalary;\n            if(position == \"Tester\") baseSalary = 1500;\n            if(position == \"Analyst\") baseSalary = 1600;\n            if(position == \"Developer\") baseSalary = 2000;\n            if(position == \"Team Leader\") baseSalary = 3000;\n            if(position == \"Manager\") baseSalary = 4000;\n            return baseSalary;\n        }\n};\n```", "```cpp\n auto bonusFactor = bind(specialBonusFactor, [&](){ return \n            bonusLevel(special_bonus_level); } );\n            auto roundedSalary = computeSalary(\n                theBaseSalaryForPosition,\n                bind(factorForSeniority, seniority_level),\n                bind(factorForContinuity, years_worked_continuously),\n                bonusFactor\n            );\n```", "```cpp\nauto computeSalary = [](const BaseSalaryForPosition& \n    baseSalaryForPosition, auto factorForSeniority, auto     \n        factorForContinuity, auto bonusFactor){\n            return ceil (\n                (1 + bonusFactor()) * \n                    baseSalaryForPosition.baseSalaryForPosition() *                             \n                        factorForSeniority() * factorForContinuity()\n            );\n};\n```", "```cpp\nclass Comparator{\n    public: \n        bool operator() (int first, int second) { return (first < second);}\n};\n\nTEST_CASE(\"Strategy\"){\n    Comparator comparator;\n    vector<int> values {23, 1, 42, 83, 52, 5, 72, 11};\n    vector<int> expected {1, 5, 11, 23, 42, 52, 72, 83};\n\n    sort(values.begin(), values.end(), comparator);\n\n    CHECK_EQ(values, expected);\n}\n```", "```cpp\nauto compare = [](auto first, auto second) { return first < second;};\n\nTEST_CASE(\"Strategy\"){\n    vector<int> values {23, 1, 42, 83, 52, 5, 72, 11};\n    vector<int> expected {1, 5, 11, 23, 42, 52, 72, 83};\n\n    sort(values.begin(), values.end(), compare);\n\n    CHECK_EQ(values, expected);\n}\n```", "```cpp\nmap<string, double> drinkPrices = {\n    {\"Westmalle Tripel\", 15.50},\n    {\"Lagavulin 18y\", 25.20},\n};\n\nauto happyHourBilling = [](auto price){\n    return price / 2;\n};\n\nauto normalBilling = [](auto price){\n    return price;\n};\n\nauto computeBill = [](auto drinks, auto billingStrategy){\n    auto prices = transformAll<vector<double>>(drinks, [](auto drink){ \n    return drinkPrices[drink]; });\n    auto sum = accumulateAll(prices, 0.0, std::plus<double>());\n    return billingStrategy(sum);\n};\n\nTEST_CASE(\"Compute total bill from list of drinks, normal billing\"){\n   vector<string> drinks; \n   double expectedBill;\n\n   SUBCASE(\"no drinks\"){\n       drinks = {};\n       expectedBill = 0;\n   };\n\n   SUBCASE(\"one drink no discount\"){\n       drinks = {\"Westmalle Tripel\"};\n       expectedBill = 15.50;\n   };\n\n   SUBCASE(\"one another drink no discount\"){\n       drinks = {\"Lagavulin 18y\"};\n       expectedBill = 25.20;\n   };\n\n  double actualBill = computeBill(drinks, normalBilling);\n\n   CHECK_EQ(expectedBill, actualBill);\n}\n\nTEST_CASE(\"Compute total bill from list of drinks, happy hour\"){\n   vector<string> drinks; \n   double expectedBill;\n\n   SUBCASE(\"no drinks\"){\n       drinks = {};\n       expectedBill = 0;\n   };\n\n   SUBCASE(\"one drink happy hour\"){\n       drinks = {\"Lagavulin 18y\"};\n       expectedBill = 12.60;\n   };\n\n   double actualBill = computeBill(drinks, happyHourBilling);\n\n   CHECK_EQ(expectedBill, actualBill);\n}\n```", "```cpp\nclass MoveUpCommand{\n    public:\n        MoveUpCommand(/*parameters*/){}\n        void execute(){ /* implementation of the command */}\n}\n```", "```cpp\nauto moveUpCommand = [](/*parameters*/{\n/* implementation */\n};\n```", "```cpp\nauto readFromFileAndAddTwoNumbers = [](){\n    int first;\n    int second;\n    ifstream numbersFile(\"numbers.txt\");\n    numbersFile >> first;\n    numbersFile >> second;\n    numbersFile.close();\n    return first + second;\n};\n\nTEST_CASE(\"Reads from file\"){\n    CHECK_EQ(30, readFromFileAndAddTwoNumbers());\n}\n```", "```cpp\nauto readFromConsoleAndAddTwoNumbers = [](){\n    int first;\n    int second;\n    cout << \"Input first number: \";\n    cin >> first;\n    cout << \"Input second number: \";\n    cin >> second;\n    return first + second;\n};\n\nTEST_CASE(\"Reads from console\"){\n    CHECK_EQ(30, readFromConsoleAndAddTwoNumbers());\n}\n```", "```cpp\nauto readAndAddTwoNumbers = [](auto firstNumberReader, auto \n    secondNumberReader){\n        int first = firstNumberReader();\n        int second = secondNumberReader();\n        return first + second;\n};\n```", "```cpp\n\nauto readFirstFromFile = [](){\n    int number;\n    ifstream numbersFile(\"numbers.txt\");\n    numbersFile >> number;\n    numbersFile.close();\n    return number;\n};\n\nauto readSecondFromFile = [](){\n    int number;\n    ifstream numbersFile(\"numbers.txt\");\n    numbersFile >> number;\n    numbersFile >> number;\n    numbersFile.close();\n    return number;\n};\n```", "```cpp\n\nauto readFirstFromConsole = [](){\n    int number;\n    cout << \"Input first number: \";\n    cin >> number;\n    return number;\n};\n\nauto readSecondFromConsole = [](){\n    int number;\n    cout << \"Input second number: \";\n    cin >> number;\n    return number;\n};\n```", "```cpp\nTEST_CASE(\"Reads using dependency injection and adds two numbers\"){\n    CHECK_EQ(30, readAndAddTwoNumbers(readFirstFromFile, \n        readSecondFromFile));\n    CHECK_EQ(30, readAndAddTwoNumbers(readFirstFromConsole, \n        readSecondFromConsole));\n    CHECK_EQ(30, readAndAddTwoNumbers(readFirstFromFile, \n        readSecondFromConsole));\n}\n```", "```cpp\nAlex wants to put the hat on\nInitial state: [InitialHandPosition, MovementFunction (HandPosition -> next HandPosition)]\nState1 = [MovementFunction(InitialHandPosition), MovementFunction]\nState2 = [MovementFunction(HandPosition at State1),MovementFunction]...\nStaten = [MovementFunction(HandPosition at Staten-1), MovementFunction]\nuntil Alex has hat on\n```", "```cpp\nTEST_CASE(\"Id\"){\n    const auto autoIncrementIndex = initAutoIncrement(1);\n    CHECK_EQ(1, value(autoIncrementIndex)); \n}\n```", "```cpp\nauto initAutoIncrement = [](const int initialId){\n    function<int(const int)> nextId = [](const int lastId){\n        return lastId + 1;\n    };\n\n    return make_pair(initialId, nextId);\n};\n```", "```cpp\nauto value = [](const auto previous){\n    return previous.first;\n};\n```", "```cpp\nTEST_CASE(\"Compute next auto increment index\"){\n    const auto autoIncrementIndex = initAutoIncrement(1);\n\n    const auto nextAutoIncrementIndex = \n        computeNextAutoIncrement(autoIncrementIndex);\n\n    CHECK_EQ(2, value(nextAutoIncrementIndex)); \n}\n```", "```cpp\nauto computeNextAutoIncrement = [](pair<const int, function<int(const \n    int)>> current){\n        const auto currentValue = value(current);\n        const auto functionToApply = lambda(current);\n        const int newValue = functionToApply(currentValue);\n        return make_pair(newValue, functionToApply);\n};\n```", "```cpp\nauto lambda = [](const auto previous){\n    return previous.second;\n};\n```", "```cpp\nTEST_CASE(\"Compute next auto increment index\"){\n    const auto autoIncrementIndex = initAutoIncrement(1);\n    const auto nextAutoIncrementIndex = \n        computeNextAutoIncrement(autoIncrementIndex);\n    CHECK_EQ(2, value(nextAutoIncrementIndex)); \n\n const auto newAutoIncrementIndex = \n        computeNextAutoIncrement(nextAutoIncrementIndex);\n CHECK_EQ(3, value(newAutoIncrementIndex));\n}\n```", "```cpp\nstruct State{\n    const int value;\n    const function<int(const int)> computeNext;\n};\n```", "```cpp\ntemplate<typename ValueType>\nstruct State{\n    const ValueType value;\n    const function<ValueType(const ValueType)> computeNext;\n};\n```", "```cpp\nauto increment = [](const int current){\n    return current + 1;\n};\n\nTEST_CASE(\"Initialize auto increment\"){\n    const auto autoIncrementIndex = State<int>{1, increment};\n\n    CHECK_EQ(1, autoIncrementIndex.value); \n}\n```", "```cpp\ntemplate<typename ValueType>\nstruct State{\n    const ValueType value;\n    const function<ValueType(const ValueType)> computeNext;\n\n State<ValueType> nextState() const{\n return State<ValueType>{computeNext(value), computeNext};\n };\n};\n\n```", "```cpp\nTEST_CASE(\"Compute next auto increment index\"){\n    const auto autoIncrementIndex = State<int>{1, increment};\n\n    const auto nextAutoIncrementIndex = autoIncrementIndex.nextState();\n\n    CHECK_EQ(2, nextAutoIncrementIndex.value); \n\n    const auto newAutoIncrementIndex = \n        nextAutoIncrementIndex.nextState();\n    CHECK_EQ(3, newAutoIncrementIndex.value);\n}\n```", "```cpp\nenum Token {Blank, X, O};\ntypedef vector<vector<Token>> TicTacToeBoard;\n```", "```cpp\nstruct Move{\n    const Token token;\n    const int xCoord;\n    const int yCoord;\n};\n```", "```cpp\nauto makeMove = [](const TicTacToeBoard board, const Move move) -> \n    TicTacToeBoard {\n        TicTacToeBoard nextBoard(board);\n        nextBoard[move.xCoord][move.yCoord] = move.token;\n         return nextBoard;\n};\n```", "```cpp\nconst TicTacToeBoard EmptyBoard{\n    {Token::Blank,Token::Blank, Token::Blank},\n    {Token::Blank,Token::Blank, Token::Blank},\n    {Token::Blank,Token::Blank, Token::Blank}\n};\n```", "```cpp\nTEST_CASE(\"TicTacToe compute next board after a move\"){\n    Move firstMove{Token::X, 0, 0};\n    const function<TicTacToeBoard(const TicTacToeBoard)> makeFirstMove \n        = bind(makeMove, _1, firstMove);\n    const auto emptyBoardState = State<TicTacToeBoard>{EmptyBoard, \n        makeFirstMove };\n    CHECK_EQ(Token::Blank, emptyBoardState.value[0][0]); \n\n    const auto boardStateAfterFirstMove = emptyBoardState.nextState();\n    CHECK_EQ(Token::X, boardStateAfterFirstMove.value[0][0]); \n}\n```", "```cpp\ntemplate<typename ValueType>\nstruct StateEvolved{\n    const ValueType value;\n    StateEvolved<ValueType> nextState(function<ValueType(ValueType)> \n        computeNext) const{\n            return StateEvolved<ValueType>{computeNext(value)};\n    };\n};\n```", "```cpp\nTEST_CASE(\"TicTacToe compute next board after a move with \n    StateEvolved\"){\n    const auto emptyBoardState = StateEvolved<TicTacToeBoard>\n        {EmptyBoard};\n    CHECK_EQ(Token::Blank, emptyBoardState.value[0][0]); \n    auto xMove = bind(makeMove, _1, Move{Token::X, 0, 0});\n    const auto boardStateAfterFirstMove = \n        emptyBoardState.nextState(xMove);\n    CHECK_EQ(Token::X, boardStateAfterFirstMove.value[0][0]); \n}\n```", "```cpp\n    auto oMove = bind(makeMove, _1, Move{Token::O, 1, 1});\n    const auto boardStateAfterSecondMove = \n        boardStateAfterFirstMove.nextState(oMove);\n    CHECK_EQ(Token::Blank, boardStateAfterFirstMove.value[1][1]); \n    CHECK_EQ(Token::O, boardStateAfterSecondMove.value[1][1]); \n```", "```cpp\n2  + (3/0) * 5\n```", "```cpp\n    function<optional<int>(const int, const int)> divideEvenWith0 = []\n      (const int first, const int second) -> optional<int>{\n        return (second == 0) ? nullopt : make_optional(first / second);\n    };\n```", "```cpp\n    auto plusOptional = [](optional<int> first, optional<int> second) -\n        > optional<int>{\n            return (first == nullopt || second == nullopt) ? \n                nullopt :\n            make_optional(first.value() + second.value());\n    };\n```", "```cpp\n    auto makeOptional = [](const function<int(int, int)> operation){\n        return [operation](const optional<int> first, const \n            optional<int> second) -> optional<int>{\n            if(first == nullopt || second == nullopt) return nullopt;\n            return make_optional(operation(first.value(), \n                second.value()));\n        };\n    };\n```", "```cpp\n    auto plusOptional = makeOptional(plus<int>());\n    auto divideOptional = makeOptional(divides<int>());\n\n    CHECK_EQ(optional{3}, plusOptional(optional{1}, optional{2}));\n    CHECK_EQ(nullopt, plusOptional(nullopt, optional{2}));\n\n    CHECK_EQ(optional{2}, divideOptional(optional{2}, optional{1}));\n    CHECK_EQ(nullopt, divideOptional(nullopt, optional{1}));\n```", "```cpp\n//    CHECK_EQ(nullopt, divideOptional(optional{2}, optional{0}));\n//    cout << \"Result of 2 / 0 = \" << to_string(divideOptional\n        (optional{2}, optional{0})) << endl;\n```", "```cpp\n    function<optional<int>(const int, const int)> divideEvenWith0 = []\n      (const int first, const int second) -> optional<int>{\n        return (second == 0) ? nullopt : make_optional(first / second);\n    };\n\n```", "```cpp\n    auto divideOptional = makeOptional(divideEvenWith0);\n\n    CHECK_EQ(nullopt, divideOptional(optional{2}, optional{0}));\n    cout << \"Result of 2 / 0 = \" << to_string(divideOptional\n        (optional{2}, optional{0})) << endl;\n```", "```cpp\nResult of 2 / 0 = None\n```", "```cpp\ntemplate<typename ValueType>\nstruct Maybe{\n    typedef function<optional<ValueType>(const ValueType, const \n        ValueType)> OperationType;\n    const optional<ValueType> value;\n\n    optional<ValueType> apply(const OperationType operation, const \n        optional<ValueType> second){\n            if(value == nullopt || second == nullopt) return nullopt;\n            return operation(value.value(), second.value());\n    }\n};\n```", "```cpp\nTEST_CASE(\"Compute with Maybe monad\"){\n    function<optional<int>(const int, const int)> divideEvenWith0 = []\n      (const int first, const int second) -> optional<int>{\n        return (second == 0) ? nullopt : make_optional(first / second);\n    };\n\n    CHECK_EQ(3, Maybe<int>{1}.apply(plus<int>(), 2));\n    CHECK_EQ(nullopt, Maybe<int>{nullopt}.apply(plus<int>(), 2));\n    CHECK_EQ(nullopt, Maybe<int>{1}.apply(plus<int>(), nullopt));\n\n    CHECK_EQ(2, Maybe<int>{2}.apply(divideEvenWith0, 1));\n    CHECK_EQ(nullopt, Maybe<int>{nullopt}.apply(divideEvenWith0, 1));\n    CHECK_EQ(nullopt, Maybe<int>{2}.apply(divideEvenWith0, nullopt));\n    CHECK_EQ(nullopt, Maybe<int>{2}.apply(divideEvenWith0, 0));\n    cout << \"Result of 2 / 0 = \" << to_string(Maybe<int>\n        {2}.apply(divideEvenWith0, 0)) << endl;\n}\n```", "```cpp\ntemplate<typename ValueType>\nstruct StateEvolved{\n    const ValueType value;\n\n    StateEvolved<ValueType> nextState(function<ValueType(ValueType)> \n        computeNext) const{\n            return StateEvolved<ValueType>{computeNext(value)};\n    };\n};\n```", "```cpp\ntemplate<typename ValueType>\nstruct Maybe{\n    typedef function<optional<ValueType>(const ValueType, const \n        ValueType)> OperationType;\n    const optional<ValueType> value;\n\n    optional<ValueType> apply(const OperationType operation, const \n        optional<ValueType> second) const {\n            if(value == nullopt || second == nullopt) return nullopt;\n            return operation(value.value(), second.value());\n    }\n};\n```"]