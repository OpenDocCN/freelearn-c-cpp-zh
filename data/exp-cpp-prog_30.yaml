- en: Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Implementing a path normalizer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施路径标准化
- en: Getting canonical file paths from relative paths
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从相对路径获取规范文件路径
- en: Listing all files in directories
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出目录中的所有文件
- en: Implementing a grep-like text search tool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施类似grep的文本搜索工具
- en: Implementing an automatic file renamer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施自动文件重命名工具
- en: Implementing a disk usage counter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施磁盘使用量计数器
- en: Calculating statistics about file types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算文件类型的统计信息
- en: Implementing a tool that reduces folder size by substituting duplicates with
    symlinks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施通过用符号链接替换重复项来减小文件夹大小的工具
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Working with filesystem paths is always tedious if we don't have a library that
    helps us because there are many conditions that we need to handle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一个帮助我们的库，处理文件系统路径总是很繁琐，因为有许多条件需要我们处理。
- en: Some paths are *absolute*, some are *relative*, and maybe they are not even
    straightforward because they also contain `.` (current directory) and `..` (parent
    directory) indirections. Then, at the same time, different operating systems use
    the slash `/` to separate directories (Linux, MacOS, and different UNIX derivatives),
    or the backslash (Windows). And of course there are different types of files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有些路径是*绝对*的，有些是*相对*的，也许它们甚至不是直接的，因为它们还包含`.`（当前目录）和`..`（父目录）的间接。同时，不同的操作系统使用斜杠`/`来分隔目录（Linux、MacOS和不同的UNIX衍生版本），或者反斜杠（Windows）。当然还有不同类型的文件。
- en: Since every other program that handles filesystem-related things needs such
    functionality, it is great to have the new filesystem library in the C++17 STL.
    The best thing about it is that it works the same way for different operating
    systems, so we don't have to write different code for versions of our programs
    that support different operating systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理与文件系统相关的其他程序都需要这样的功能，因此在C++17 STL中拥有新的文件系统库是非常好的。最好的一点是，它对不同的操作系统都是以相同的方式工作，因此我们不必为支持不同操作系统的程序版本编写不同的代码。
- en: In this chapter, we will first see how the `path` class works, because it is
    most central to anything else in this library. Then, we will see how powerful
    but yet simple to use `directory_iterator` and `recursive_directory_iterator`
    classes are, while we do useful things with files. In the end, we will use some
    small and simple example tools that do some real-life tasks related to the filesystem.
    From this point, it will be easy to build more complex tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先看到`path`类的工作原理，因为它对于这个库中的任何其他内容都是最核心的。然后，我们将看到`directory_iterator`和`recursive_directory_iterator`类是多么强大但又简单易用，同时我们会对文件进行一些有用的操作。最后，我们将使用一些小而简单的示例工具，执行一些与文件系统相关的真实任务。从这一点开始，构建更复杂的工具将变得容易。
- en: Implementing a path normalizer
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施路径标准化
- en: We start this chapter with a very simple example around the `std::filesystem::path`
    class and a helper function that intelligently normalizes filesystem paths.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章以围绕`std::filesystem::path`类和一个智能规范化文件系统路径的辅助函数的非常简单的示例开始。
- en: The result of this recipe is a little application that takes any filesystem
    path and returns us the same path in normalized form. Normalized means that we
    get an absolute path that contains no `.` or `..` path indirections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的结果是一个小应用程序，它接受任何文件系统路径，并以规范化形式返回相同的路径。规范化意味着我们得到一个不包含`.`或`..`路径间接的绝对路径。
- en: While implementing that, we will also see what details we need to pay attention
    to when working with this basic part of the filesystem library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施这一点的同时，我们还将看到在处理文件系统库的这个基本部分时需要注意哪些细节。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will implement a program that just accepts a filesystem
    path as a command-line argument and then prints it in normalized form.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个程序，它只接受文件系统路径作为命令行参数，然后以规范化形式打印出来。
- en: Includes come first, and then we declare that we use namespace `std` and `filesystem`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是包含，然后我们声明使用`std`和`filesystem`命名空间。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the main function, we check whether the user provided a command-line argument.
    If that is not the case, we error out and print how to use the program. If a path
    was provided, we instantiate a `filesystem::path` object from it.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们检查用户是否提供了命令行参数。如果没有，我们就会报错并打印如何使用程序。如果提供了路径，我们就会从中实例化一个`filesystem::path`对象。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we can instantiate `path` objects from any string, we cannot be sure if
    the path really exists on the filesystem of the computer. In order to do that,
    we can use the `filesystem::exists` function. If it doesn't, we simply error out
    again.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可以从任何字符串实例化`path`对象，我们不能确定路径是否真的存在于计算机的文件系统中。为了做到这一点，我们可以使用`filesystem::exists`函数。如果不存在，我们就会再次报错。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Okay, at this point, we are pretty sure that the user provided some *existing*
    path knowing that we can ask for a normalized version of it, which we then print.
    `filesystem::canonical` returns us another `path` object. We could print it directly,
    but the `path` type overload of the `<<` operator surrounds paths with quotation
    marks. In order to avoid that, we can print a path through its `.c_str()` or `.string()`
    method.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，在这一点上，我们非常确定用户提供了一条*现有*路径，知道我们可以要求其规范化版本，然后我们打印出来。`filesystem::canonical`会返回另一个`path`对象。我们可以直接打印它，但`path`类型重载的`<<`运算符会用引号括起路径。为了避免这种情况，我们可以通过其`.c_str()`或`.string()`方法打印路径。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's compile the program and play with it. When we execute it in my home directory
    on the relative path `"src"`, it will print the full absolute path.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译程序并与之交互。当我们在我的家目录中执行它，使用相对路径`"src"`，它将打印出完整的绝对路径。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we run the program in my home directory again, but give it a quirky relative
    path description that first enters my `Desktop` folder, then steps out of it again
    using `..`, then enters the `Documents` folder and steps out again in order to
    finally enter the `src` directory, the program prints the *same* path as before!
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们再次在我的家目录中运行程序，但给它一个古怪的相对路径描述，首先进入我的`Desktop`文件夹，然后再次使用`..`退出它，然后进入`Documents`文件夹并再次退出，最后进入`src`目录，程序打印出*相同*的路径！
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As a starter on `std::filesystem`, this recipe is still fairly short and straightforward.
    We initialized a `path` object from a string that contains a filesystem path description.
    The `std::filesystem::path` class plays a very central role whenever we use the
    filesystem library because most of the functions and classes relate to it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`std::filesystem`的入门，这个示例仍然相当简短和直接。我们从包含文件系统路径描述的字符串初始化了一个`path`对象。`std::filesystem::path`类在我们使用文件系统库时扮演着非常重要的角色，因为大多数函数和类都与它相关。
- en: Using the `filesystem::exists` function, we were able to check if the path really
    exists. Up to that point, we could not be sure about that, because it is indeed
    possible to create `path` objects that do not relate to an existing filesystem
    object. `exists` just accepts a `path` instance and returns `true` if it really
    exists. The function is already able to determine itself if we gave it an absolute
    or a relative path, which makes it very comfortable to use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filesystem::exists`函数，我们能够检查路径是否真的存在。在那之前，我们不能确定，因为确实可能创建与现有文件系统对象无关的`path`对象。`exists`只接受一个`path`实例，并在它真的存在时返回`true`。该函数已经能够自行确定我们给它一个绝对路径还是相对路径，这使得它非常方便使用。
- en: Finally, we used `filesystem::canonical` on the directory in order to print
    it in normalized form.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`filesystem::canonical`在目录上，以便以规范化的形式打印它。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`canonical` accepts a path and as an optional second argument, it accepts another
    path. The second path `base` is prepended to path `p` if `p` is a relative path.
    After doing that, `canonical` tries to remove any `.` and `..` path indirections.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`canonical`接受一个路径，并作为可选的第二个参数，它接受另一个路径。如果`p`是一个相对路径，第二个路径`base`将被添加到路径`p`之前。在这样做之后，`canonical`会尝试移除任何`.`和`..`路径指示。'
- en: While printing, we used the `.c_str()` method on the canonicalized path. The
    reason for this is that the overload of `operator<<` for output streams surrounds
    paths with quotation marks, which we may not always want.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印时，我们在规范化的路径上使用了`.c_str()`方法。这样做的原因是，对于输出流的`operator<<`的重载会用引号括起路径，而我们并不总是想要这样。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`canonical` throws a `filesystem_error` type exception if the path we want
    to canonicalize does not exist. In order to prevent that, we checked our filesystem
    path with `exists`. But was that check really sufficient to avoid getting unhandled
    exceptions? No.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要规范化的路径不存在，`canonical`会抛出一个`filesystem_error`类型的异常。为了防止这种情况，我们用`exists`检查了我们的文件系统路径。但是那个检查真的足以避免出现未处理的异常吗？不是。
- en: Both `exists` and `canonical` can throw `bad_alloc` exceptions. If those hit
    us, one could argue that the program is doomed anyway. A far more critical, and
    also much more probable problem would occur if, between us checking if the file
    exists and canonicalizing it, someone else renames or deletes the underlying file!
    In that case, `canonical` would throw a `filesystem_error`, although we checked
    for the file's existence before.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`exists`和`canonical`都可以抛出`bad_alloc`异常。如果遇到这些异常，有人可能会认为程序无论如何都要失败。一个更为严重，也更为可能的问题是，当我们检查文件是否存在并对其进行规范化之间，其他人重命名或删除了底层文件！在这种情况下，`canonical`会抛出一个`filesystem_error`，尽管我们之前检查了文件的存在。'
- en: Most filesystem functions have an additional overload that takes the same arguments,
    but also an `std::error_code` reference.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数文件系统函数都有一个额外的重载，它接受相同的参数，但还有一个`std::error_code`引用。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This way we can choose if we surround our filesystem function calls with `try`-`catch`
    constructs or check the errors manually. Note that this only changes the behavior
    of *filesystem-related* errors! With and without the `ec` parameter, more fundamental
    exceptions, for example, `bad_alloc`, can still be thrown if the system runs out
    of memory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们可以选择是否用`try`-`catch`结构包围我们的文件系统函数调用，或者手动检查错误。请注意，这只会改变*与文件系统相关的*错误的行为！有了`ec`参数和没有`ec`参数，更基本的异常，例如`bad_alloc`，如果系统内存不足，仍然可能被抛出。
- en: Getting canonical file paths from relative paths
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从相对路径获取规范化的文件路径
- en: In the last recipe, we already canonicalized/normalized paths. The `filesystem::path`
    class is, of course, capable of more things than just holding and checking paths.
    It also helps us in composing paths from strings easily, and also to decompose
    them again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们已经规范化/标准化了路径。`filesystem::path`类当然能够做更多的事情，而不仅仅是保存和检查路径。它还帮助我们轻松地从字符串中组合路径，并再次分解它们。
- en: At this point, `path` does already abstract operating system details away from
    us, but there are also certain instances where we still need to keep such details
    in mind.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`path`已经将操作系统的细节抽象化了，但也有一些情况下我们仍然需要记住这些细节。
- en: We will see how to deal with paths and their composition/decomposition by playing
    around with absolute and relative paths.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过玩弄绝对路径和相对路径来看如何处理路径及其组合/分解。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will play around with absolute and relative paths in order
    to see the strengths of the `path` class and the helper functions around it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将尝试使用绝对路径和相对路径，以便看到`path`类及其周围的辅助函数的优势。
- en: First, we include all the necessary headers and declare that we use namespace
    `std` and `sfilesystem`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含了所有必要的头文件，并声明我们使用`std`和`sfilesystem`命名空间。
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, we declare an example path. At this point, it is not important that the
    text file it refers to really exists. There are some functions, however, that
    throw exceptions if the underlying file does not exist.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明一个示例路径。在这一点上，它指的文本文件是否真的存在并不重要。然而，如果底层文件不存在，有一些函数会抛出异常。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will have a look at four different filesystem library functions now. `current_path`
    returns us the path the program is currently executed in, the *working directory*.
    `absolute` accepts a relative path like our path `p` and returns the absolute,
    nonambiguous path in the whole filesystem. `system_complete` does practically
    the same as `absolute` on Linux, MacOS, or UNIX-like operating systems. On Windows,
    we would get the absolute path additionally prepended by the disk volume letter
    (for example, `"C:"`). `canonical` does again the same as `absolute` does, but
    then additionally removes any `"."` (short for *"this directory"*) or `".."` (short
    for *"one directory up"*) indirections. We will play with such indirections in
    the following steps:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将看看四个不同的文件系统库函数。`current_path`返回程序当前执行的路径，即*工作目录*。`absolute`接受一个相对路径，比如我们的路径`p`，并返回整个文件系统中的绝对、非歧义路径。`system_complete`在Linux、MacOS或类UNIX操作系统上实际上与`absolute`做的事情几乎一样。在Windows上，我们会得到绝对路径，另外还会加上磁盘卷标（例如`"C:"`）。`canonical`再次做的事情与`absolute`一样，但然后又移除了任何`"."`（代表*当前目录*）或`".."`（代表*上一级目录*）的间接。我们将在以下步骤中玩弄这样的间接：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Another nice thing about the `path` class is that it overloads the `/` operator.
    This way we can concatenate folder names and filenames using `/` and compose paths
    from that. Let's try it out and print a composed path.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`path`类的另一个好处是它重载了`/`运算符。这样我们就可以使用`/`连接文件夹名称和文件名，并从中组合路径。让我们试一试，并打印一个组合的路径。'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's play with `canonical` and composed paths. By giving `canonical` a relative
    path such as `"foobar.txt"` and a composed absolute path `current_path() / "testdir"`,
    it should return us the existing absolute path. In another call, we give it our
    path `p` (which is `"testdir/foobar.txt"`) and provide it an absolute path that
    is `current_path()`, which directs us into `"testdir"` and up again. This should
    be the same as `current_path()`, because of the indirection. In both calls, `canonical`
    should return us the same absolute path.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来玩玩`canonical`和组合路径。通过给`canonical`一个相对路径，比如`"foobar.txt"`，和一个组合的绝对路径`current_path()
    / "testdir"`，它应该返回我们现有的绝对路径。在另一个调用中，我们给它我们的路径`p`（即`"testdir/foobar.txt"`），并提供一个绝对路径`current_path()`，这将引导我们进入`"testdir"`，然后再次返回。这应该与`current_path()`相同，因为有间接。在这两个调用中，`canonical`应该返回相同的绝对路径。
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can also test for the equivalence of two paths that are not canonical. `equivalence`
    canonicalizes the paths, which it accepts as arguments and returns `true` if they
    describe the same path after all. For this test, the path must really *exist,*
    otherwise, it throws an exception.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以测试两个非规范路径的等价性。`equivalence`将接受的路径规范化，并在最终描述相同路径时返回`true`。对于这个测试，路径必须真的*存在*，否则会抛出异常。
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compiling and running the program yields the following output. `current_path()`
    returns the home folder on my laptop because I executed the application from there.
    Our relative path `p` has been prepended with this directory by `absolute_path`,
    `system_complete`, and `canonical`. We see that `absolute_path` and `system_complete`
    yield exactly the same path on my system because it is a Mac (it would be the
    same on Linux). On a Windows machine, `system_complete` would have prepended `"C:"`,
    or whatever drive the working directory is located in.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下输出。`current_path()`返回我笔记本电脑上的主文件夹，因为我是从那里执行应用程序的。我们的相对路径`p`已经被`absolute_path`、`system_complete`和`canonical`添加了这个目录。我们看到`absolute_path`和`system_complete`在我的系统上返回完全相同的路径，因为我用的是Mac（在Linux上也是一样的）。在Windows机器上，`system_complete`会添加`"C:"`，或者工作目录所在的任何驱动器。
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We do not handle any exceptions in our short program. If we remove the `foobar.txt`
    file in the `testdir` directory, then the program aborts its execution due to
    an exception. The `canonical` function requires the path to exist. There is also
    a `weakly_canonical` function that does not come with this requirement.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的简短程序中没有处理任何异常。如果我们删除`testdir`目录中的`foobar.txt`文件，那么程序会因为异常而中止执行。`canonical`函数要求路径存在。还有一个`weakly_canonical`函数，它不具备这个要求。
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The goal of this recipe is to see how easy it is to compose new paths on the
    fly. This is mainly because the `path` class has a handy overload for the `/`
    operator. In addition to that, the filesystem functions get along well with relative
    and absolute paths, as well as with paths that contain `.` and `..` indirections.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的目标是看看动态组合新路径有多容易。这主要是因为`path`类对`/`运算符有一个方便的重载。除此之外，文件系统函数可以很好地处理相对路径、绝对路径，以及包含`.`和`..`间接的路径。
- en: There is quite a jungle of functions that return parts of a `path` instance,
    with or without transformations. We are not going to list all functions there
    are here because a short glance into the C++ reference is the best way to get
    an oversight.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`实例的函数有很多，有些带有转换，有些没有。我们不会在这里列出所有的函数，因为简单地查看C++参考文献是获得概述的最佳方式。'
- en: The member functions of the `path` class, however, might be worth a closer look.
    Let's see which part of a path is returned by what member function of `path`.
    The following diagram also shows how Windows paths are slightly different from
    UNIX/Linux paths.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`类的成员函数可能值得更仔细地研究。让我们看看`path`的成员函数返回路径的哪一部分。下面的图表还显示了Windows路径与UNIX/Linux路径稍有不同。'
- en: '![](img/9c9ab3d9-e0c4-41d0-b90c-2de3c0075dd2.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c9ab3d9-e0c4-41d0-b90c-2de3c0075dd2.png)'
- en: You can see that the diagram shows what the member functions of `path` return
    for an *absolute* path. For *relative* paths, `root_path`, `root_name`, and `root_directory`
    are empty. `relative_path` then just returns the path if it is relative already.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到图表显示了`path`的成员函数对*绝对*路径返回的内容。对于*相对*路径，`root_path`、`root_name`和`root_directory`是空的。然后，如果路径已经是相对的，`relative_path`就只返回路径。
- en: Listing all files in directories
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出目录中的所有文件
- en: Of course, every operating system that offers filesystem support also comes
    with some kind of utility that does just *list* all files within a directory in
    the filesystem. The simplest examples are the `ls` command on Linux, MacOS, and
    other UNIX-related operating systems. In DOS and Windows, there is the `dir` command.
    Both list all files in a directory and provide supplemental information such as
    file size, permissions, and so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每个提供文件系统支持的操作系统也都配备了某种在文件系统中仅*列出*目录中所有文件的实用程序。最简单的例子是Linux、MacOS和其他UNIX相关操作系统上的`ls`命令。在DOS和Windows中，有`dir`命令。两者都列出目录中的所有文件，并提供文件大小、权限等补充信息。
- en: Reimplementing such a tool is, however, also a nice standard task to get going
    with directory and file traversal. So, let's just do that!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重新实现这样的工具也是一个很好的标准任务，可以开始进行目录和文件遍历。所以，让我们来做吧！
- en: Our own `ls`/`dir` utility will be able to list all items in a directory by
    name, indicate what kind of items there are, list their access permission flags,
    and display the number of bytes they occupy on the filesystem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的`ls`/`dir`实用程序将能够按名称列出目录中的所有项目，指示有哪些项目，列出它们的访问权限标志，并显示它们在文件系统上占用的字节数。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will implement a little tool that lists all files in any
    user provided directory. It will not only list the filenames, but also their type,
    size, and access permissions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个小工具，列出用户提供的任何目录中的所有文件。它不仅会列出文件名，还会列出它们的类型、大小和访问权限。
- en: First, we need to include some headers and declare that we use the namespaces
    `std` and `filesystem` by default.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含一些头文件，并声明我们默认使用`std`和`filesystem`命名空间。
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One helper function that we are going to need is `file_info`. It accepts a `directory_entry`
    object reference and extracts the path from it, as well as a `file_status` object
    (using the `status` function), which contains file type and permission information.
    Finally, it also extracts the size of the entry if it is a regular file. For directories
    or other special files, we plainly return a size of `0`. All this information
    is bundled into a tuple.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要的另一个辅助函数是`file_info`。它接受一个`directory_entry`对象引用，并从中提取路径，以及一个`file_status`对象（使用`status`函数），其中包含文件类型和权限信息。最后，如果是常规文件，它还提取条目的大小。对于目录或其他特殊文件，我们简单地返回大小为`0`。所有这些信息都被捆绑成一个元组。
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Another helper function that we will need is `type_char`. A path cannot only
    represent directories and simple text/binary files. Operating systems provide
    a variety of other types that abstract something else, such as hardware device
    interfaces in the form of so-called character/block files. The STL filesystem
    library provides a lot of predicate functions for them. This way we can return
    the letter `'d'` for directories, the letter `'f'` for regular files, and so on.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的另一个辅助函数是`type_char`。路径不仅可以表示目录和简单的文本/二进制文件。操作系统提供了许多其他类型，用于抽象其他内容，例如硬件设备接口，以所谓的字符/块文件的形式。STL文件系统库为它们提供了许多谓词函数。这样，我们可以为目录返回字母'd'，对于常规文件返回字母'f'，依此类推。
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yet another helper we will need is the `rwx` function. It accepts a `perms`
    variable (which is just an `enum` class type from the filesystem library) and
    returns a string such as `"rwxrwxrwx"` that describes the file's permission settings.
    The first group of `"rwx"` characters describes the ***r**ead, **w**rite, and
    e**x**ecution* permissions for the owner of the file. The next group describes
    the same rights for all users that are part of the *user group* the file belongs
    to. The last character group describes which rights everyone else has for accessing
    the file. A string such as `"rwxrwxrwx"` means that everyone can access the object
    in any way. `"rw-r--r--"` means that only the owner can read and modify the file,
    while anyone else can only read it.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要的另一个辅助函数是`rwx`函数。它接受一个`perms`变量（它只是文件系统库中的一个`enum`类类型）并返回一个字符串，例如`"rwxrwxrwx"`，描述文件的权限设置。第一组`"rwx"`字符描述了文件所有者的***读、写和执行***权限。下一组描述了属于文件所属的*用户组*的所有用户的相同权限。最后一组字符描述了其他所有人对访问文件的权限。例如`"rwxrwxrwx"`表示每个人都可以以任何方式访问对象。`"rw-r--r--"`表示只有所有者可以读取和修改文件，而其他人只能读取。
- en: We just compose a string from such read/write/execute character values, permission
    bit by permission bit. A lambda expression helps us with the repetitive work of
    checking if the `perms` variable `p` contains a specific owner bit and then returns
    `'-'` or the right character.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需从这些读/写/执行字符值中组合一个字符串，逐个权限位检查`perms`变量`p`是否包含特定的所有者位，然后返回'-'或正确的字符。
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, the last helper function accepts an integral file size and converts
    it to a better to read form. We just ignore the period while dividing numbers
    down and floor them to the nearest kilo, mega, or giga boundary.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，最后一个辅助函数接受一个整数文件大小，并将其转换为更易读的形式。我们在除法时忽略小数点，并将其向下取整到最近的千、兆或吉边界。
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we can finally implement the main function. We begin with checking if the
    user provided a path in the command line. If he didn't, we just take the current
    directory "`.`". Then, we check if the directory exists. If it doesn't, we can't
    possibly list any files.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们终于可以实现主函数了。我们首先检查用户是否在命令行中提供了路径。如果没有，我们就使用当前目录"。"。然后，我们检查目录是否存在。如果不存在，我们就无法列出任何文件。
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we will fill a `vector` with file information tuples just like our first
    helper function `file_info` returns from `directory_entry` objects. We instantiate
    a `directory_iterator` and give its constructor the `path` object, which we created
    in the last step. While iterating with the directory iterator, we transform the
    `directory_entry` objects to file information tuples and insert them into the
    vector.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将用文件信息元组填充一个`vector`，就像我们的第一个辅助函数`file_info`从`directory_entry`对象返回的那样。我们实例化一个`directory_iterator`，并将其构造函数给予我们在上一步中创建的`path`对象。在使用目录迭代器进行迭代时，我们将`directory_entry`对象转换为文件信息元组，并将其插入向量中。
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have all information saved in the vector items and can simply print it
    using all the helper functions we wrote.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将所有信息保存在向量项中，可以使用我们编写的所有辅助函数简单地打印它。
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compiling and running the project with a file path in the offline version of
    the C++ documentation yields the following output. We see that the folder only
    contains directories and plain files because there are only `'d'` and `'f'` entries
    as first characters of all output lines. These files have different access permissions,
    and of course different sizes. Note that the files appear in alphabetical order
    of their names, but we cannot really rely on that because alphabetic ordering
    is not required by the C++17 standard.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在离线版本的C++文档中使用文件路径编译和运行项目会产生以下输出。我们看到该文件夹只包含目录和普通文件，因为所有输出行的第一个字符只有'd'和'f'。这些文件具有不同的访问权限，当然也有不同的大小。请注意，文件按其名称的字母顺序出现，但我们不能真正依赖它，因为字母顺序不是C++17标准要求的。
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we iterated over files, and for every file, we checked its status
    and size. While all our per-file operations are fairly straightforward and simple,
    our actual directory traversal looked a bit magic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们遍历了文件，并对每个文件检查了其状态和大小。虽然我们的每个文件操作都相当简单直接，但我们的实际目录遍历看起来有点神奇。
- en: In order to traverse our directory, we just instantiated a `directory_iterator`
    and then iterated over it. Traversing a directory is fantastically simple with
    the filesystem library.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遍历我们的目录，我们只需实例化一个`directory_iterator`，然后对其进行迭代。使用文件系统库遍历目录非常简单。
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There is not much more to say about this class apart from the following things:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个类，除了以下几点外，没有更多要说的：
- en: It visits every element of the directory once
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它访问目录的每个元素一次
- en: The order in which the directory elements are iterated is unspecified
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录元素的迭代顺序是未指定的
- en: Directory elements `.` and `..` are already filtered out
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录元素`.`和`..`已经被过滤掉
- en: 'However, it might be noticeable that `directory_iterator` seems to be an *iterator*,
    and an *iterable range* at the same time. Why? In the minimal `for` loop example
    we just had a look at, it was used as an iterable range. In the actual recipe
    code, we used it like an iterator:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，`directory_iterator`似乎既是*迭代器*，又是*可迭代范围*。为什么？在我们刚刚看到的最小`for`循环示例中，它被用作可迭代范围。在实际的代码中，我们将它用作迭代器：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The truth is, it is just an iterator class type, but the `std::begin` and `std::end`
    functions provide overloads for this type. This way we can call the `begin` and
    `end` function on this kind of iterator and they return us iterators again. That
    might look strange at first sight, but it makes this class more useful.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，它只是一个迭代器类类型，但`std::begin`和`std::end`函数为这种类型提供了重载。这样我们就可以在这种迭代器上调用`begin`和`end`函数，它们会再次返回给我们迭代器。乍一看可能会觉得奇怪，但这样可以使这个类更有用。
- en: Implementing a grep-like text search tool
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现类似grep的文本搜索工具
- en: Most operating systems come equipped with some kind of local search engine.
    Users can fire it up with some keyboard shortcut and then just enter what local
    file they are looking for.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都配备了某种本地搜索引擎。用户可以通过一些键盘快捷键启动它，然后输入他们要查找的本地文件。
- en: Before such features came up, command-line users already searched through files
    with tools such as `grep` or `awk`. The user can simply type "`grep -r foobar
    .`" and the tool will crawl recursively through the current directory and find
    any file that contains the `"foobar"` string.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些功能出现之前，命令行用户已经使用诸如`grep`或`awk`之类的工具搜索文件。用户可以简单地输入"`grep -r foobar .`"，该工具将在当前目录中递归搜索，并找到包含`"foobar"`字符串的任何文件。
- en: In this recipe, we will implement exactly such an application. Our little grep
    clone will just accept a pattern from the command line, and then recursively search
    through the directory we are in at the time of the application start. It will
    then print the name of every file that matches our pattern. The pattern matching
    will be applied linewise, so we can also print on which exact line numbers a file
    is matching the pattern.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将实现一个这样的应用程序。我们的小型grep克隆将从命令行接受一个模式，然后递归地搜索我们在应用程序启动时所在的目录。然后，它将打印出每个与我们的模式匹配的文件的名称。模式匹配将逐行应用，因此我们还可以打印出文件匹配模式的确切行号。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will implement a little tool that searches for user-provided text patterns
    in files. The tool works similar to the UNIX tool `grep`, but will not be as mature
    and powerful, for the sake of simplicity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个小工具，用于在文件中搜索用户提供的文本模式。该工具类似于UNIX工具`grep`，但为了简单起见，它不会像`grep`那样成熟和强大。
- en: First, we need to include all the necessary headers and declare that we use
    namespace `std` and `filesystem`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包括所有必要的头文件，并声明我们使用`std`和`filesystem`命名空间。
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We implement a helper function first. It accepts a file path and a regular expression
    object that describes the pattern we are looking for. Then, we instantiate a `vector`
    that shall contain pairs of matching line numbers and their content. And we instantiate
    an input file stream object from which we will read and pattern-match the content,
    line by line.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个辅助函数。它接受一个文件路径和一个描述我们正在寻找的模式的正则表达式对象。然后，我们实例化一个`vector`，其中包含匹配行号和它们的内容。我们还实例化了一个输入文件流对象，从中我们将逐行读取和匹配内容。
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We traverse the file line by line using the `getline` function. `regex_search`
    returns `true` if the string contains our pattern. If this is the case, then we
    put the line number and the string into the vector. Finally, we return all collected
    matches.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`getline`函数逐行遍历文件。如果`regex_search`返回`true`，则表示字符串包含我们的模式。如果是这种情况，我们将行号和字符串放入向量中。最后，我们返回所有收集到的匹配项。
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the main function, we first check whether the user provided a command-line
    argument that we can use as the pattern. If not, we error out.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先检查用户是否提供了可以用作模式的命令行参数。如果没有，我们会报错。
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, we construct a regular expression object from the input pattern. If the
    pattern is not a valid regular expression, this would lead to an exception. If
    such an exception occurs, we catch it and error out.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从输入模式构造一个正则表达式对象。如果模式不是有效的正则表达式，这将导致异常。如果发生这样的异常，我们会捕获它并报错。
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, we can finally iterate over the filesystem and look for pattern matches.
    We use `recursive_directory_iterator` to iterate over all the files in the working
    directory. It works exactly like `directory_iterator` in the previous recipe,
    but it also descends down into subdirectories. This way we don't have to manage
    recursion. On every entry, we call our helper function `matches`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们终于可以遍历文件系统并寻找模式匹配了。我们使用`recursive_directory_iterator`来遍历工作目录中的所有文件。它的工作方式与上一个教程中的`directory_iterator`完全相同，但它还会进入子目录。这样我们就不必管理递归。在每个条目上，我们调用我们的辅助函数`matches`。
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For every match (if any) we print the file path, its line number, and the matching
    line's complete content.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个匹配（如果有的话），我们打印文件路径、行号和匹配行的完整内容。
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's prepare a file called `"foobar.txt"`, which contains some test lines we
    can search for.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们准备一个名为`"foobar.txt"`的文件，其中包含一些我们可以搜索的测试行。
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compiling and running yields the following output. I launched the app in the
    `/Users/tfc/testdir` folder on my laptop, first with the pattern `"bar"`. Within
    that directory, it found the second line of our `foobar.txt` file and another
    file `"text1.txt"` that is located in `testdir/dir1`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行产生以下输出。我在我的笔记本电脑的`/Users/tfc/testdir`文件夹中启动了应用程序，首先使用模式`"bar"`。在该目录中，它找到了我们的`foobar.txt`文件的第二行和另一个文件`"text1.txt"`，它位于`testdir/dir1`中。
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Launching the app again, but this time with the pattern `"baz"`, it finds the
    third line of our example text file.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次启动应用程序，但这次使用模式`"baz"`，它找到了我们示例文本文件的第三行。
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: Setting up and using a regular expression in order to filter the content of
    files is certainly the main task of this recipe. However, let's concentrate on
    `recursive_directory_iterator` because filtering recursively iterated files was
    just our motivation to use this special iterator class in this recipe.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和使用正则表达式来过滤文件内容肯定是这个教程的主要任务。然而，让我们集中在`recursive_directory_iterator`上，因为递归地过滤迭代的文件只是我们在这个教程中使用这个特殊迭代器类的动机。
- en: Just like `directory_iterator`, `recursive_directory_iterator` iterates over
    elements of a directory. Its specialty is to do this recursively, as its name
    tells. Whenever it hits a filesystem element that is a *directory*, it will yield
    a `directory_entry` instance to this path, but then also descend down into it
    in order to iterate its children, too.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`directory_iterator`一样，`recursive_directory_iterator`遍历目录的元素。它的特点是递归地执行这个操作，正如它的名字所示。每当它遇到一个文件系统元素是*目录*时，它将向这个路径产生一个`directory_entry`实例，然后还会进入其中以遍历它的子元素。
- en: '`recursive_directory_iterator` has some interesting member functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`recursive_directory_iterator`有一些有趣的成员函数：'
- en: '`depth()`: This tells us how many levels the iterator has currently descended
    down into subdirectories.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depth（）`：这告诉我们迭代器当前已经进入子目录的级数。'
- en: '`recursion_pending()`: This tells us if the iterator is going to descend down
    after the element it currently points to.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recursion_pending（）`：这告诉我们迭代器当前指向的元素之后是否会进入递归。'
- en: '`disable_recursion_pending()`: This can be called to keep the iterator from
    descending into the next subdirectory if it is currently pointing to a directory
    into which it would descend. This means that calling this method has no effect
    if we call it *too early*.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用递归挂起（）：如果当前指向的是一个目录，可以调用此方法来阻止迭代器进入下一个子目录，如果它当前指向的是一个目录，那么调用此方法将不起作用，因为我们调用它*太早*。
- en: '`pop()`: This aborts the current recursion level and goes one level up in the
    directory hierarchy to continue from there.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop（）`：中止当前递归级别，并在目录层次结构中向上移动一级以从那里继续。'
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Another thing to know about is the `directory_options` enum class. The constructor
    of `recursive_directory_iterator` does indeed accept a value of this type as a
    second argument. The default value which we have been implicitly using is `directory_options::none`.
    The other values are:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还要了解的一件事是`directory_options`枚举类。`recursive_directory_iterator`的构造函数确实接受这种类型的值作为第二个参数。我们一直在隐式使用的默认值是`directory_options::none`。其他值包括：
- en: '`follow_directory_symlink`: This allows the recursive iterator to follow symbolic
    links to directories'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`follow_directory_symlink`：这允许递归迭代器跟随符号链接到目录'
- en: '`skip_permission_denied`: This tells the iterator to skip directories that
    would otherwise result in errors because permission to access is denied by the
    filesystem'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip_permission_denied`：这告诉迭代器跳过否则会因为文件系统拒绝访问权限而导致错误的目录'
- en: These options can be combined with the `|` operator.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项可以与`|`运算符结合使用。
- en: Implementing an automatic file renamer
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自动文件重命名器
- en: This recipe is motivated by a situation I find myself in pretty often. When
    collecting picture files from holidays, for example, from different friends and
    also different photo devices in one folder, the file endings often look different.
    Some JPEG files have a `.jpg` extension, some have `.jpeg`, and some others even
    have `.JPEG`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程的动机是我经常发现自己处于这样的情况。例如，从不同的朋友和不同的照片设备收集假期的图片文件放在一个文件夹中，文件扩展名经常看起来不同。一些JPEG文件有“.jpg”扩展名，一些有“.jpeg”，还有一些甚至有“.JPEG”。
- en: Some people might prefer to homogenize all extensions. It would be useful to
    rename all files with a single command. At the same time, we could remove spaces
    `' '` and substitute them by underscores `'_'`, for example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能更喜欢使所有扩展名统一。使用单个命令重命名所有文件将是有用的。同时，我们可以删除空格`' '`并用下划线`'_'`替换它们，例如。
- en: 'In this recipe, we will implement such a tool and call it `renamer`. It will
    accept a range of input patterns and their substitutes like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将实现这样一个工具，并将其称为`renamer`。它将接受一系列输入模式及其替代品，如下所示：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In that case, renamer will iterate recursively through the current directory
    and search for the patterns `jpeg` and `JPEG` in all filenames. It will substitute
    both with `jpg`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重命名器将递归地遍历当前目录，并在所有文件名中搜索模式`jpeg`和`JPEG`。它将用`jpg`替换两者。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will implement a tool that recursively scans all files within a directory
    and matches their filenames with patterns. All matches are replaced with user
    provided tokens and the affected files are renamed accordingly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个工具，递归扫描目录中的所有文件，并将它们的文件名与模式进行匹配。所有匹配项都将替换为用户提供的标记，并相应地重命名受影响的文件。
- en: First, we need to include a few headers and declare that we use namespaces `std`
    and `filesystem`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包括一些头文件，并声明我们使用命名空间`std`和`filesystem`。
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We implement a short helper function that accepts an input file path in the
    form of a string and a range of replacement pairs. Each replacement pair consists
    of a pattern and its replacement. While looping through the replacement range,
    we use `regex_replace` to feed it with the input string and let it return the
    transformed string. Afterward, we return the resulting string.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个简短的辅助函数，它接受一个字符串形式的输入文件路径和一系列替换对。每个替换对包括一个模式和其替换。在循环遍历替换范围时，我们使用`regex_replace`将其提供给输入字符串，并让其返回转换后的字符串。然后，我们返回结果字符串。
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the main function, we first validate the command line. We accept command-line
    arguments in *pairs* because we want patterns together with their replacements.
    The first element of `argv` is always the executable name. This means that if
    the user provides at least one pair or more, then `argc` must be *odd* and not
    smaller than `3`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先验证命令行。我们接受*成对*的命令行参数，因为我们希望模式与它们的替换一起。`argv`的第一个元素始终是可执行文件名。这意味着如果用户提供了至少一对或更多对，那么`argc`必须是*奇数*，且不小于`3`。
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once we checked that there are pairs of input, we will fill a vector with these.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们检查到有输入对，我们将用这些对填充一个向量。
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we can iterate over the filesystem. For the sake of simplicity, we just
    define the application's current path as the directory to iterate over.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以遍历文件系统。为了简单起见，我们只需将应用程序的当前路径定义为要遍历的目录。
- en: For every directory entry, we extract its original path to the `opath` variable.
    Then, we take only the filename without the rest of this path and transform it
    according to the list of patterns and replacements we collected before. We take
    a copy of `opath`, call it `rpath`, and replace its filename part with the new
    filename.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个目录条目，我们提取其原始路径到`opath`变量中。然后，我们只取文件名而不是其余路径，并根据之前收集的模式和替换列表进行转换。我们复制`opath`，称其为`rpath`，并用新文件名替换其文件名部分。
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For all files that are affected by our patterns, we print that we rename them.
    In case the resulting filename from replacing the patterns does already exist,
    we can't proceed. Let's just skip such files. We could of course alternatively
    just append some number to the path or something else to resolve the name clash.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于受我们模式影响的所有文件，我们打印出我们重命名它们。如果替换模式后的文件名已经存在，我们无法继续。让我们跳过这样的文件。当然，我们当然也可以只向路径追加一些数字或其他内容来解决名称冲突。
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Compiling and running the program in an example directory yields the following
    output. I have put some JPEG pictures into the directory but have given them different
    name endings `jpg`, `jpeg`, and `JPEG`. Then, I executed the program with the
    patterns `jpeg` and `JPEG` and chose `jpg` as the replacement for both. The result
    is a folder with homogenous filename extensions.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例目录中编译和运行程序会产生以下输出。我把一些JPEG图片放入了目录中，但给它们不同的名称结尾`jpg`，`jpeg`和`JPEG`。然后，我用模式`jpeg`和`JPEG`执行了程序，并选择了`jpg`作为两者的替换。结果是一个具有同质文件扩展名的文件夹。
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Implementing a disk usage counter
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现磁盘使用计数器
- en: We already implemented a tool that works like `ls` on Linux/MacOS, or `dir`
    on Windows, but just as these tools, it doesn't print the file size for *directories*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了一个类似于Linux/MacOS上的`ls`或Windows上的`dir`的工具，但与这些工具一样，它不会打印*目录*的文件大小。
- en: In order to get the size equivalent of a directory, we would have to descend
    down into it and sum up the size of all files that it contains.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得目录的大小等价值，我们需要进入其中并计算其中包含的所有文件的大小。
- en: In this recipe, we will implement a tool that does just that. The tool can be
    run on any folder and will summarize the accumulated size of all directory entries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将实现一个工具来做到这一点。该工具可以在任何文件夹上运行，并汇总所有目录条目的累积大小。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will implement an app that iterates over a directory and
    lists the file size of each entry. This is simple for regular files, but if we
    are looking at a directory entry that itself is a directory, then we have to look
    into it and summarize the size of all the files it holds.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将实现一个应用程序，它遍历目录并列出每个条目的文件大小。对于常规文件来说很简单，但如果我们看到的目录条目本身是一个目录，那么我们必须查看它并总结其包含的所有文件的大小。
- en: First, we need to include all the necessary headers and declare that we use
    namespace `std` and `filesystem`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包括所有必要的头文件，并声明我们使用命名空间`std`和`filesystem`。
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then we implement a helper function that accepts a `directory_entry` as an argument
    and returns its size in the filesystem. If it is not a directory, we simply return
    the file size calculated by `file_size`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们实现一个辅助函数，它接受一个`directory_entry`作为参数，并返回其在文件系统中的大小。如果不是目录，我们只需返回由`file_size`计算的文件大小。
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If it is a directory, we need to iterate over all its entries and calculate
    their size. We end up calling our own `entry_size` helper function recursively
    if we stumble upon subdirectories again.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是目录，我们需要遍历其所有条目并计算它们的大小。如果我们再次遇到子目录，我们最终会递归调用我们自己的`entry_size`辅助函数。
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For better readability, we use the same `size_string` function as in other recipes
    in this chapter. It just divides large file sizes in to shorter and nicer ones
    to read strings with kilo, mega, or giga suffix.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地可读性，我们在本章的其他示例中使用相同的`size_string`函数。它只是将大文件大小分成更短、更美观的字符串，以便读取带有kilo、mega或giga后缀的字符串。
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first thing we need to do in the main function is to check whether the user
    provided a filesystem path on the command line. If that is not the case, we just
    take the current folder. Before proceeding, we check whether it exists.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们需要做的第一件事是检查用户是否在命令行上提供了文件系统路径。如果不是这种情况，我们就取当前文件夹。在继续之前，我们要检查它是否存在。
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, we can iterate over all directory entries and print their sizes and names.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以遍历所有目录条目并打印它们的大小和名称。
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Compiling and running the program yields the following results. I launched it
    in a folder in the C++ offline reference. As it contains subfolders too, our recursive
    file size summary helper is immediately helpful.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下结果。我在C++离线参考手册的一个文件夹中启动了它。由于它也包含子文件夹，我们的递归文件大小摘要助手立即就派上了用场。
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: The whole program revolves around using `file_size` on regular files. If the
    program sees a directory, it recursively descends down into it and calls `file_size`
    on all its entries.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 整个程序围绕着在常规文件上使用`file_size`。如果程序看到一个目录，它会递归进入其中，并对所有条目调用`file_size`。
- en: The only thing we did to distinguish if we call `file_size` directly or if we
    need the recursion strategy was asking the `is_directory` predicate. This works
    well for directories that only contain regular files and directories.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来区分是否直接调用`file_size`还是需要递归策略的唯一方法是询问`is_directory`谓词。这对于只包含常规文件和目录的目录非常有效。
- en: 'As simple as our example program is, it would crash under the following conditions,
    because of unhandled exceptions:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的示例程序很简单，但在以下情况下会崩溃，因为没有处理异常：
- en: '`file_size` only works on regular files and symbolic links. It throws an exception
    in any other case.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_size`只对常规文件和符号链接有效。在其他情况下会抛出异常。'
- en: Although `file_size` works on symbolic links, it *still* throws an exception
    if we call it on a *broken* symbolic link.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管`file_size`对符号链接有效，但如果我们在*损坏的*符号链接上调用它，它仍然会抛出异常。
- en: In order to make this example recipe program more mature, we need more defensive
    programming against the wrong type of files and handling of exceptions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例程序更加成熟，我们需要更多的防御性编程来处理错误类型的文件和异常处理。
- en: Calculating statistics about file types
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算文件类型的统计信息
- en: In the last recipe, we implemented a tool that lists the size of all members
    of any directory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们实现了一个工具，列出任何目录中所有成员的大小。
- en: In this recipe, we will be counting sizes recursively, too, but this time we
    will accumulate the size of each file to their filename *extension*. This way
    we can print the user a table that lists how many files of each file type we have,
    and what the average size of such file types is.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们也将递归计算大小，但这次我们将每个文件的大小累积到它们的文件名*扩展名*中。这样我们就可以向用户打印一个表，列出我们有多少个每种文件类型的文件，以及这些文件类型的平均大小。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will implement a little tool that recursively iterates over
    a given directory. While doing that, it counts the number and size of all files,
    grouped by their extensions. Finally, it prints which filename extensions exist
    within that directory, how many there are per extension, and their average file
    size.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个小工具，它会递归地遍历给定目录。在这样做的过程中，它会计算所有文件的数量和大小，按其扩展名分组。最后，它会打印出该目录中存在的文件名扩展名，每个扩展名的数量以及它们的平均文件大小。
- en: We need to include necessary headers and we declare that we use namespace `std`
    and `filesystem`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包括必要的头文件，并声明我们使用`std`和`filesystem`命名空间。
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `size_string` function was already helpful in other recipes. It transforms
    file sizes to human-readable strings.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`size_string`函数在其他示例中已经很有用了。它将文件大小转换为人类可读的字符串。'
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Then, we implement a helper function that accepts a `path` object as its argument
    and iterates over all files within that path. On its way, it collects all information
    in a map that maps from filename extensions to pairs that contain the total number
    and accumulated size of all files that have the same extension.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实现一个辅助函数，它接受一个`path`对象作为参数，并遍历该路径下的所有文件。在此过程中，它将所有信息收集到一个映射中，该映射将文件名扩展名映射到包含具有相同扩展名的所有文件的总数和累积大小的对中。
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If a directory entry is a directory itself, we skip it. Skipping it at this
    point does not mean that we are not recursively descending into it. `recursive_directory_iterator`
    still does that, but we do not want to look at the directory entries themselves.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目录条目本身是一个目录，我们就跳过它。此时跳过它并不意味着我们不会递归进入其中。`recursive_directory_iterator`仍然会这样做，但我们不想查看目录条目本身。
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Next, we extract the extension part of the directory entry string. If it has
    no extension, we simply skip it.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们提取目录条目字符串的扩展部分。如果没有扩展名，我们就简单地跳过它。
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Next, we calculate the size of the file we are looking at. Then, we look up
    the aggregate object in the map for this extension. If there are yet none at this
    point, it is created implicitly. We simply increment the file count and add the
    file size to the size accumulator.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们计算我们正在查看的文件的大小。然后，我们在地图中查找这个扩展名的聚合对象。如果此时还没有，它会被隐式创建。我们只是增加文件计数并将文件大小添加到大小累加器中。
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Afterward, we return the map.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们返回地图。
- en: '[PRE58]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the main function, we take either a user-provided path from the command line
    or the current directory. Of course, we need to check whether it exists because
    it would not make sense to continue otherwise.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们从命令行中获取用户提供的路径或当前目录。当然，我们需要检查它是否存在，否则继续下去就没有意义。
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can immediately iterate over the map that `ext_stats` gives us. Because the
    `accum_size` items in the map contain the sum of all files with the same extension,
    we divide this sum by the total number of such files before printing it.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以立即遍历`ext_stats`给我们的映射。因为映射中的`accum_size`项包含相同扩展名的所有文件的总和，所以在打印之前，我们将这个总和除以这些文件的总数。
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Compiling and running the program yields the following output. I gave it a folder
    from the offline C++ reference as a command-line argument.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出。我将离线C++参考手册中的一个文件夹作为命令行参数。
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Implementing a tool that reduces folder size by substituting duplicates with
    symlinks
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个通过用符号链接替换重复项来减小文件夹大小的工具
- en: There are a lot of tools that compress data in various ways. The most famous
    examples for file packing algorithms/formats are ZIP and RAR. Such tools try to
    reduce the size of files by reducing internal redundancy.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具以各种方式压缩数据。文件打包算法/格式的最著名的例子是ZIP和RAR。这些工具试图通过减少内部冗余来减小文件的大小。
- en: Before compressing files in archives, a very simple way to reduce disk usage
    is just *deleting* *duplicate* files. In this recipe, we will implement a little
    tool that crawls a directory recursively. While crawling, it will look for files
    that have the same content. If it finds such files, it will remove all duplicates
    but one. All removed files will be substituted with symbolic links that point
    to the now unique file. This saves spaces without any compression, while at the
    same time preserving all data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在将文件压缩到存档文件之前，减少磁盘使用的一个非常简单的方法就是*删除* *重复*文件。在这个示例中，我们将实现一个小工具，它会递归地遍历一个目录。在遍历过程中，它将寻找具有相同内容的文件。如果找到这样的文件，它将删除所有重复项，只保留一个。所有删除的文件将被替换为指向现在唯一文件的符号链接。这样可以节省空间，而不需要任何压缩，同时保留所有数据。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will implement a little tool that finds out which files
    in a directory are duplicates of each other. With that knowledge, it will remove
    all but one of all duplicated files, and substitute them with symbolic links,
    which reduces the folder size.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将实现一个小工具，找出目录中彼此重复的文件。有了这个知识，它将删除所有重复的文件，只保留一个，并用符号链接替换它们，从而减小文件夹的大小。
- en: Make sure to have a *backup* of your system's data. We will be playing with
    STL functions that remove files. A simply *misspelled* path in such a program
    can lead to a program that greedily removes too many files in unwanted ways.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 确保系统数据有一个*备份*。我们将使用STL函数删除文件。在这样一个程序中，一个简单的*拼写错误*路径可能导致程序以不希望的方式贪婪地删除太多文件。
- en: First, we need to include the necessary headers and then we declare that we
    use namespace `std` and `filesystem` by default.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含必要的头文件，然后我们声明我们默认使用`std`和`filesystem`命名空间。
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In order to find out which files are duplicates of each other, we will construct
    a hash map that maps from hashes of file content to the path of the first file
    from which that hash was generated. It would be a better idea to use a production
    hash algorithm for files such as MD5 or an SHA variant. In order to keep the recipe
    clean and simple, we just read the whole file into a string and then use the same
    hash function object that `unordered_map` already uses for strings to calculate
    hashes.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了找出哪些文件是彼此的重复项，我们将构建一个哈希映射，将文件内容的哈希映射到生成该哈希的第一个文件的路径。对于文件，使用生产哈希算法如MD5或SHA变体会是一个更好的主意。为了保持清晰和简单，我们只是将整个文件读入一个字符串，然后使用`unordered_map`已经用于字符串的相同哈希函数对象来计算哈希。
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Then we implement the function that constructs such a hash map and deletes duplicates.
    It iterates recursively through a directory and its subdirectories.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们实现构建这样一个哈希映射并删除重复项的函数。它通过目录及其子目录进行递归迭代。
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: For every directory entry, it checks whether it is a directory itself. All directory
    items are skipped. For every file, we generate its hash value and try to insert
    it into the hash map. If the hash map already contains the same hash, then this
    means that we already inserted a file with the same hash. This means that we just
    found a duplicate! In case of a clash during insertion, the second value in the
    pair that `try_emplace` returns is `false`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个目录条目，它都会检查它是否是一个目录本身。所有目录项都将被跳过。对于每个文件，我们生成其哈希值并尝试将其插入哈希映射中。如果哈希映射已经包含相同的哈希，则这意味着我们已经插入了具有相同哈希的文件。这意味着我们刚刚找到了一个重复项！在插入过程中发生冲突时，`try_emplace`返回的对中的第二个值为`false`。
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using the return values from `try_emplace`, we can tell the user that we just
    inserted a file because we have seen its hash for the first time. In case we found
    a duplicate, we tell the user what other file it is a duplicate of and delete
    it. After deletion, we create a symbolic link that replaces the duplicate.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`try_emplace`的返回值，我们可以告诉用户我们刚刚插入了一个文件，因为我们第一次看到了它的哈希。如果我们找到了重复项，我们会告诉用户它是哪个其他文件的重复项，并将其删除。删除后，我们创建一个替换重复项的符号链接。
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: After the filesystem iteration, we return the number of files we deleted and
    replaced with symlinks.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件系统迭代之后，我们返回删除的文件数，并用符号链接替换。
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the main function, we make sure that the user provided a directory on the
    command line, and that this directory exists.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们确保用户在命令行上提供了一个目录，并且该目录存在。
- en: '[PRE68]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The only thing we need to do now is to call `reduce_dupes` on this directory
    and print how many files it deleted.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们唯一需要做的就是在这个目录上调用`reduce_dupes`，并打印它删除了多少文件。
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Compiling and running the program on an example directory that contains some
    duplicate files looks like the following. I used the `du` tool to check the folder
    size before and after launching our program to demonstrate that the approach works.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含一些重复文件的示例目录上编译和运行程序如下。我使用`du`工具在启动我们的程序之前和之后检查文件夹大小，以演示这种方法的工作原理。
- en: '[PRE70]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We used the `create_symlink` function in order to make a filesystem entry point
    to another file in the filesystem. This way we can avoid having duplicate files.
    We could also have set a hard link using `create_hard_link`. Semantically, this
    is similar, but hard links have other technical implications than soft links.
    Different filesystem formats might not support hard links at all, or only a certain
    number of hard links that refer to the same file. Another problem is that hard
    links cannot link from one filesystem to the other.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`create_symlink`函数来使文件系统中的一个文件指向文件系统中的另一个文件。这样我们就可以避免重复的文件。我们也可以使用`create_hard_link`来设置硬链接。从语义上讲，这是相似的，但是硬链接有其他技术含义。不同的文件系统格式可能根本不支持硬链接，或者只支持指向同一文件的一定数量的硬链接。另一个问题是硬链接不能从一个文件系统链接到另一个文件系统。
- en: However, apart from implementation details, there is one *blatant error* source
    when using `create_symlink` or `create_hard_link`. The following lines contain
    a bug. Can you spot it immediately?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了实现细节之外，在使用`create_symlink`或`create_hard_link`时有一个*明显的错误*源。以下行包含一个错误。你能立刻发现它吗？
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Nothing bad happens when executing this program, but the symlink will be *broken*.
    The symlink points to `"some_dir/some_file.txt"`, which is wrong. The problem
    is that it should really either point to `"/absolute/path/some_dir/some_file.txt"`,
    or `"../some_dir/some_file.txt"`. The `create_symlink` call uses a correct absolute
    path if we write it as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此程序时不会发生任何不良情况，但符号链接将会*损坏*。符号链接指向`"some_dir/some_file.txt"`，这是错误的。问题在于它实际上应该指向`"/absolute/path/some_dir/some_file.txt"`，或者`"../some_dir/some_file.txt"`。如果我们将`create_symlink`调用写成以下形式，则使用了正确的绝对路径：
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`create_symlink` does not check whether the path we are linking to is *correct*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_symlink`不检查我们要链接的路径是否*正确*。'
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We already noticed that our hash function is a too simple one. For the sake
    of keeping this recipe simple and without external dependencies, we chose this
    way.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经注意到我们的哈希函数太简单了。为了使这个方法简单并且没有外部依赖，我们选择了这种方式。
- en: 'What is the problem with our hash function? There are actually two problems:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的哈希函数有什么问题？实际上有两个问题：
- en: We read the whole file into a string. This is disastrous for files that are
    larger than our system memory.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将整个文件读入一个字符串。这对于大于我们系统内存的文件是灾难性的。
- en: The C++ hash function trait `hash<string>` is most probably not designed for
    such hashes.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++哈希函数特性`hash<string>`很可能不是为这样的哈希设计的。
- en: If we are looking for a better hash function, we should take one that is fast,
    memory-friendly, and that makes sure that no two really large but different files
    get the same hash. The latter requirement is maybe the most important one. If
    we decide that one file is a duplicate of the other although they do not contain
    the same data, we surely have some *data loss* after deleting it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在寻找更好的哈希函数，我们应该选择一个快速、内存友好的函数，并确保没有两个真正大但不同的文件得到相同的哈希值。后一个要求可能是最重要的。如果我们决定一个文件是另一个文件的副本，尽管它们不包含相同的数据，那么在删除后我们肯定会有一些*数据丢失*。
- en: Better hash algorithms are, for example, MD5 or one of the SHA variants. In
    order to get access to such functions in our program, we could use the OpenSSL
    cryptography API, for example.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的哈希算法例如MD5或SHA变体之一。为了在我们的程序中访问这样的函数，我们可以使用OpenSSL密码API。
