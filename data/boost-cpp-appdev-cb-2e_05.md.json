["```cpp\n#include <cstddef> // for std::size_t\n\nbool is_first_run(); \n\n// Function that executes for a long time.\nvoid fill_file(char fill_char, std::size_t size, const char* filename);\n\n// Called in thread that draws a user interface:\nvoid example_without_threads() {\n    if (is_first_run()) {\n        // This will be executing for a long time during which\n        // users interface freezes...\n        fill_file(0, 8 * 1024 * 1024, \"save_file.txt\");\n    }\n}\n```", "```cpp\n#include <boost/thread.hpp> \n\n// Called in thread that draws a user interface:\nvoid example_with_threads() {\n    if (is_first_run()) {\n        boost::thread(boost::bind(\n            &fill_file,\n            0,\n            8 * 1024 * 1024,\n            \"save_file.txt\"\n        )).detach();\n    }\n}\n```", "```cpp\nvoid example_with_joining_threads() {\n    if (is_first_run()) {\n        boost::thread t(boost::bind(\n            &fill_file,\n            0,\n            8 * 1024 * 1024,\n            \"save_file.txt\"\n        ));\n\n        // Do some work.\n        // ...\n\n        // Waiting for thread to finish.\n        t.join();\n    }\n} \n```", "```cpp\n#include <boost/thread/scoped_thread.hpp> \n\nvoid some_func(); \n\nvoid example_with_raii() { \n    boost::scoped_thread<boost::join_if_joinable> t( \n        boost::thread(&some_func) \n    ); \n\n    // 't' will be joined at scope exit.\n} \n```", "```cpp\n#include <cassert> \n#include <cstddef> \n#include <iostream>\n\n// In previous recipe we included \n// <boost/thread.hpp>, which includes all \n// the classes of Boost.Thread.\n// Following header includes only boost::thread. \n#include <boost/thread/thread.hpp> \n\nint shared_i = 0;\n\nvoid do_inc() {\n    for (std::size_t i = 0; i < 30000; ++i) {\n        const int i_snapshot = ++shared_i;\n        // Do some work with i_snapshot.\n        // ...\n    }\n}\n\nvoid do_dec() {\n    for (std::size_t i = 0; i < 30000; ++i) {\n        const int i_snapshot = --shared_i;\n        // Do some work with i_snapshot.\n        // ...\n    }\n}\n\nvoid run() {\n    boost::thread t1(&do_inc);\n    boost::thread t2(&do_dec);\n\n    t1.join();\n    t2.join();\n\n    assert(global_i == 0); // Oops!\n    std::cout << \"shared_i == \" << shared_i;\n}\n```", "```cpp\n    shared_i == 19567\n```", "```cpp\n#include <boost/thread/mutex.hpp> \n#include <boost/thread/locks.hpp> \n\nint shared_i = 0; \nboost::mutex i_mutex; \n```", "```cpp\n      {   // Critical section begin \n          boost::lock_guard<boost::mutex> lock(i_mutex); \n```", "```cpp\n      }   // Critical section end \n```", "```cpp\nvoid do_inc() {\n    for (std::size_t i = 0; i < 30000; ++i) {\n        int i_snapshot;\n        { // Critical section begin.\n            boost::lock_guard<boost::mutex> lock(i_mutex);\n            i_snapshot = ++shared_i;\n        } // Critical section end.\n\n        // Do some work with i_snapshot.\n        // ...\n    }\n}\n\nvoid do_dec() {\n    for (std::size_t i = 0; i < 30000; ++i) {\n        int i_snapshot;\n        { // Critical section begin.\n            boost::lock_guard<boost::mutex> lock(i_mutex);\n            i_snapshot = -- shared_i;\n        } // Critical section end.\n\n        // Do some work with i_snapshot.\n        // ...\n    }\n} \n```", "```cpp\n{   // Critical section begin.\n    boost::lock_guard<boost::mutex> lock(i_mutex); \n    i_snapshot = ++ shared_i; \n}   // Critical section end.\n```", "```cpp\n#include <cassert> \n#include <cstddef> \n#include <iostream>\n\n#include <boost/thread/thread.hpp> \n#include <boost/atomic.hpp> \n```", "```cpp\nboost::atomic<int> shared_i(0); \n```", "```cpp\nvoid do_inc() {\n    for (std::size_t i = 0; i < 30000; ++i) {\n        const int i_snapshot = ++ shared_i;\n\n        // Do some work with i_snapshot.\n        // ...\n    }\n}\n\nvoid do_dec() {\n    for (std::size_t i = 0; i < 30000; ++i) {\n        const int i_snapshot = -- shared_i;\n\n        // Do some work with i_snapshot.\n        // ...\n    }\n}\n```", "```cpp\nint main() {\n    boost::thread t1(&do_inc);\n    boost::thread t2(&do_dec);\n\n    t1.join();\n    t2.join();\n\n    assert(shared_i == 0);\n    std::cout << \"shared_i == \" << shared_i << std::endl;\n\n    assert(shared_i.is_lock_free());\n}\n```", "```cpp\n--shared_i;    // Transaction #1 \n// Some other may change value of `shared_i`!!\n++shared_i;    // Transaction #2 \n```", "```cpp\n#include <boost/static_assert.hpp> \nBOOST_STATIC_ASSERT(BOOST_ATOMIC_INT_LOCK_FREE == 2); \n```", "```cpp\nassert(shared_i.is_lock_free()); \n```", "```cpp\ntypedef boost::function<void()> task_t; \n```", "```cpp\n#include <deque>\n#include <boost/function.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/condition_variable.hpp>\n\nclass work_queue {\npublic:\n    typedef boost::function<void()> task_type;type;\n\nprivate:\n    std::deque<task_type> tasks_;\n    boost::mutex tasks_mutex_;\n    boost::condition_variable cond_;\n```", "```cpp\npublic:\n    void push_task(const task_type& task) {\n        boost::unique_lock<boost::mutex> lock(tasks_mutex_);\n        tasks_.push_back(task);\n        lock.unlock();\n\n        cond_.notify_one();\n    }\n```", "```cpp\n    task_type try_pop_task() {\n        task_type ret;\n        boost::lock_guard<boost::mutex> lock(tasks_mutex_);\n        if (!tasks_.empty()) {\n            ret = tasks_.front();\n            tasks_.pop_front();\n        }\n\n        return ret;\n    }\n```", "```cpp\n    task_type pop_task() {\n        boost::unique_lock<boost::mutex> lock(tasks_mutex_);\n        while (tasks_.empty()) {\n            cond_.wait(lock);\n        }\n\n        task_type ret = tasks_.front();\n        tasks_.pop_front();\n\n        return ret;\n    }\n}; \n```", "```cpp\n#include <boost/thread/thread.hpp>\n\nwork_queue g_queue;\n\nvoid some_task();\nconst std::size_t tests_tasks_count = 3000 /*000*/;\n\nvoid pusher() {\n    for (std::size_t i = 0; i < tests_tasks_count; ++i) {\n        g_queue.push_task(&some_task);\n    }\n}\n\nvoid popper_sync() {\n    for (std::size_t i = 0; i < tests_tasks_count; ++i) {\n        work_queue::task_type t = g_queue.pop_task();\n        t();         // Executing task.\n    }\n}\n\nint main() {\n    boost::thread pop_sync1(&popper_sync);\n    boost::thread pop_sync2(&popper_sync);\n    boost::thread pop_sync3(&popper_sync);\n\n    boost::thread push1(&pusher);\n    boost::thread push2(&pusher);\n    boost::thread push3(&pusher);\n\n    // Waiting for all the tasks to push.\n    push1.join();\n    push2.join();\n    push3.join();\n    g_queue.flush(); \n\n    // Waiting for all the tasks to pop.\n    pop_sync1.join();\n    pop_sync2.join();\n    pop_sync3.join();\n\n    // Asserting that no tasks remained,\n    // and falling though without blocking.\n    assert(!g_queue.try_pop_task());\n\n    g_queue.push_task(&some_task);\n\n    // Asserting that there is a task,\n    // and falling though without blocking.\n    assert(g_queue.try_pop_task());\n}\n```", "```cpp\n $time -f E ./work_queue\n 0:07.38\n```", "```cpp\n $ time -f E ./work_queue \n 0:05.39\n```", "```cpp\n#include <unordered_map> \n#include <boost/thread/mutex.hpp> \n#include <boost/thread/locks.hpp> \n\nstruct user_info {\n    std::string address;\n    unsigned short age;\n\n    // Other parameters\n    // ...\n};\n\nclass users_online {\n    typedef boost::mutex mutex_t;\n\n    mutable mutex_t                             users_mutex_;\n    std::unordered_map<std::string, user_info>  users_;\n\npublic:\n    bool is_online(const std::string& username) const {\n        boost::lock_guard<mutex_t> lock(users_mutex_);\n        return users_.find(username) != users_.end();\n    }\n\n    std::string get_address(const std::string& username) const {\n        boost::lock_guard<mutex_t> lock(users_mutex_);\n        return users_.at(username).address;\n    }\n\n    void set_online(const std::string& username, user_info&& data) {\n        boost::lock_guard<mutex_t> lock(users_mutex_);\n        users_.emplace(username, std::move(data));\n    }\n\n    // Other methods:\n    // ...\n};\n```", "```cpp\n#include <boost/thread/shared_mutex.hpp> \n\nclass users_online {\n    typedef boost::shared_mutex mutex_t;\n\n    mutable mutex_t                             users_mutex_;\n    std::unordered_map<std::string, user_info>  users_;\n\npublic:\n    bool is_online(const std::string& username) const {\n        boost::shared_lock<mutex_t> lock(users_mutex_);\n        return users_.find(username) != users_.end();\n    }\n\n    std::string get_address(const std::string& username) const {\n        boost::shared_guard<mutex_t> lock(users_mutex_);\n        return users_.at(username).address;\n    }\n\n    void set_online(const std::string& username, user_info&& data) {\n        boost::lock_guard<mutex_t> lock(users_mutex_);\n        users_.emplace(username, std::move(data));\n    }\n\n    // Other methods:\n    // ...\n};\n```", "```cpp\n#include <boost/noncopyable.hpp>\n\nclass connection: boost::noncopyable {\npublic:\n    // Opening a connection is a slow operation\n    void open();\n\n    void send_result(int result);\n\n    // Other methods\n    // ...\n};\n```", "```cpp\nconnection& get_connection();\n```", "```cpp\n#include <boost/thread/tss.hpp>\nboost::thread_specific_ptr<connection> connection_ptr;\n\nconnection& get_connection() {\n    connection* p = connection_ptr.get();\n    if (!p) {\n        connection_ptr.reset(new connection);\n        p = connection_ptr.get();\n        p->open();\n    }\n\n    return *p;\n}\n```", "```cpp\nvoid task() {\n    int result;\n    // Some computations go there.\n    // ...\n\n    // Sending the result:\n    get_connection().send_result(result);\n}\n```", "```cpp\nint main() {\n    boost::thread parser_thread(&do_parse);\n\n    // ...\n\n    if (stop_parsing) {\n        // No more parsing required.\n        // TODO: Stop the parser!\n    }\n\n    // ...\n\n    parser_thread.join();\n}\n```", "```cpp\nif (stop_parsing) { \n    // No more parsing required. \n    parser_thread.interrupt(); \n}\n```", "```cpp\nvoid do_parse() {\n    while (not_end_of_parsing) {\n        // If current thread was interrupted, the following\n        // line will throw an boost::thread_interrupted.\n        boost::this_thread::interruption_point();\n\n        // Some parsing goes here.\n        // ...\n    }\n}\n```", "```cpp\n#include <boost/thread.hpp>\n\nvoid some_function();\n\nvoid sample() {\n    boost::thread t1(&some_function);\n    boost::thread t2(&some_function);\n    boost::thread t3(&some_function);\n\n    // ... \n\n    t1.join();\n    t2.join();\n    t3.join();\n} \n```", "```cpp\n#include <boost/thread.hpp>\n\nint main() {\n    boost::thread_group threads;\n```", "```cpp\n    // Launching 10 threads.\n    for (unsigned i = 0; i < 10; ++i) {\n        threads.create_thread(&some_function);\n    }\n```", "```cpp\n    // Joining all threads.\n    threads.join_all();\n\n    // We can also interrupt all of them\n    // by calling threads.interrupt_all();\n}\n```", "```cpp\nstruct postprocessor {\n    typedef std::vector<std::string> answer_t;\n\n    // Concurrent calls on the same variable are safe.\n    answer_t act(const std::string& in) const {\n        if (in.empty()) {\n            // Extremely rare condition.\n            return read_defaults();\n        }\n\n        // ...\n    }\n};\n```", "```cpp\n// Executes for a long time.\nstd::vector<std::string> read_defaults();\n```", "```cpp\nstruct postprocessor {\n    typedef std::vector<std::string> answer_t;\n\nprivate:\n    answer_t default_;\n\npublic:\n    postprocessor()\n        : default_(read_defaults())\n    {}\n\n    // Concurrent calls on the same variable are safe.\n    answer_t act(const std::string& in) const {\n        if (in.empty()) {\n            // Extremely rare condition.\n            return default_;\n        }\n\n        // ...\n    }\n};\n```", "```cpp\n#include <boost/thread/once.hpp>\n\nstruct postprocessor {\n    typedef std::vector<std::string> answer_t;\n\nprivate:\n    mutable boost::once_flag default_flag_;\n    mutable answer_t default_;\n```", "```cpp\npublic:\n    postprocessor()\n        : default_flag_(BOOST_ONCE_INIT)\n        , default_()\n    {}\n```", "```cpp\n    // Concurrent calls on the same variable are safe.\n    answer_t act(const std::string& in) const {\n        answer_t ret;\n        if (in.empty()) {\n            // Extremely rare condition.\n            boost::call_once(default_flag_, [this]() {\n                this->default_ = read_defaults();\n            });\n            return default_;\n        }\n\n        // ...\n        return ret;\n    }\n};\n```", "```cpp\n#include <iostream>\n\nvoid once_printer(int i) {\n    static boost::once_flag flag = BOOST_ONCE_INIT;\n    boost::call_once(\n        flag,\n        [](int v) { std::cout << \"Print once \" << v << '\\n'; },\n        i // <=== Passed to lambda from above.\n    );\n\n    // ...\n}\n```", "```cpp\nint main() {\n    for (unsigned i = 0; i < 10; ++i) {\n        once_printer(i);\n    }\n}\n```", "```cpp\nPrint once 0\n```", "```cpp\nclass user {\n    boost::mutex        loot_mutex_;\n    std::vector<item_t> loot_;\npublic:\n    // ...\n\n    void exchange_loot(user& u);\n};\n```", "```cpp\nvoid user::exchange_loot(user& u) {\n    // Terribly wrong!!! ABBA deadlocks.\n    boost::lock_guard<boost::mutex> l0(loot_mutex_);\n    boost::lock_guard<boost::mutex> l1(u.loot_mutex_);\n    loot_.swap(u.loot_);\n}\n```", "```cpp\n#include <boost/thread/lock_factories.hpp>\n\nvoid user::exchange_loot(user& u) {\n    typedef boost::unique_lock<boost::mutex> lock_t;\n\n    std::tuple<lock_t, lock_t> l = boost::make_unique_locks(\n        loot_mutex_, u.loot_mutex_\n    );\n\n    loot_.swap(u.loot_);\n}\n```", "```cpp\n#include <boost/thread/lock_factories.hpp>\n\nvoid user::exchange_loot(user& u) {\n    auto l = boost::make_unique_locks(\n        loot_mutex_, u.loot_mutex_\n    );\n\n    loot_.swap(u.loot_);\n}\n```", "```cpp\n#include <boost/thread/locks.hpp>\n\nvoid user::exchange_loot(user& u) {\n    typedef boost::unique_lock<boost::mutex> lock_t;\n\n    lock_t l0(loot_mutex_, boost::defer_lock);\n    lock_t l1(u.loot_mutex_, boost::defer_lock);\n    boost::lock(l0, l1);\n\n    loot_.swap(u.loot_);\n}\n```", "```cpp\n#include <mutex>\n\nvoid user::exchange_loot(user& u) {\n    std::scoped_lock l(loot_mutex_, u.loot_mutex_);\n    loot_.swap(u.loot_);\n}\n```", "```cpp\nstd::scoped_lock<std::mutex, std::mutex>\n```"]