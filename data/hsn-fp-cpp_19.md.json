["```cpp\nTEST_CASE(\"Identity function\"){\n    function<int(int)> identity = [](int value) { return value;};\n\n    CHECK_EQ(1, identity(1));\n}\n```", "```cpp\nTEST_CASE(\"Free function\"){\n    function<int()> f = freeFunctionReturns2;\n\n    CHECK_EQ(2, f());\n}\n```", "```cpp\nclass JustAClass{\n    public:\n        int functionReturns2() const { return 2; };\n};\n\nTEST_CASE(\"Class method\"){\n    function<int(const JustAClass&)> f = &JustAClass::functionReturns2;\n    JustAClass justAClass;\n\n    CHECK_EQ(2, f(justAClass));\n}\n```", "```cpp\nTEST_CASE(\"Sort with predefined function\"){\n    vector<int> values{3, 1, 2, 20, 7, 5, 14};\n    vector<int> expectedDescendingOrder{20, 14, 7, 5, 3,  2, 1};\n\n    sort(values.begin(), values.end(), greater<int>());\n\n    CHECK_EQ(expectedDescendingOrder, values);\n}\n```", "```cpp\nTEST_CASE(\"Partial application using bind\"){\n    auto add = [](int first, int second){\n        return first + second;\n    };\n\n    auto increment = bind(add, _1, 1);\n\n    CHECK_EQ(3, add(1, 2));\n    CHECK_EQ(3, increment(2));\n}\n```", "```cpp\nTEST_CASE(\"Project names from a vector of people\"){\n    vector<Person> people = {\n        Person(\"Alex\", 42),\n        Person(\"John\", 21),\n        Person(\"Jane\", 14)\n    };\n\n    vector<string> expectedNames{\"Alex\", \"John\", \"Jane\"};\n    vector<string> names = transformAll<vector<string>>(\n            people, \n            [](Person person) { return person.name; } \n    );\n\n    CHECK_EQ(expectedNames, names);\n}\n```", "```cpp\ntemplate<typename DestinationType>\nauto transformAll = [](auto source, auto lambda){\n    DestinationType result;\n    transform(source.begin(), source.end(), back_inserter(result), \n        lambda);\n    return result;\n};\n```", "```cpp\nTEST_CASE(\"Minor or major\"){\n    vector<Person> people = {\n        Person(\"Alex\", 42),\n        Person(\"John\", 21),\n        Person(\"Jane\", 14)\n    };\n\n    vector<bool> expectedIsMinor{false, false, true};\n    vector<bool> isMinor = transformAll<vector<bool>>(\n            people, \n            [](Person person) { return person.age < 18; } \n    );\n\n    CHECK_EQ(expectedIsMinor, isMinor);\n}\n```", "```cpp\nTEST_CASE(\"String representation\"){\n    vector<Person> people = {\n        Person(\"Alex\", 42),\n        Person(\"John\", 21),\n        Person(\"Jane\", 14)\n    };\n\n    vector<string> expectedJSON{\n        \"{'person': {'name': 'Alex', 'age': '42'}}\",\n        \"{'person': {'name': 'John', 'age': '21'}}\",\n        \"{'person': {'name': 'Jane', 'age': '14'}}\"\n    };\n    vector<string> peopleAsJson = transformAll<vector<string>>(\n            people, \n            [](Person person) { \n            return \n            \"{'person': {'name': '\" + person.name + \"', 'age': \n                '\" + to_string(person.age) + \"'}}\"; } \n    );\n\n    CHECK_EQ(expectedJSON, peopleAsJson);\n}\n```", "```cpp\nstruct Product{\n    string name;\n    string category;\n    double price;\n    Product(string name, string category, double price): name(name), \n        category(category), price(price){}\n};\n```", "```cpp\nmap<string, int> taxLevelByCategory = {\n    {\"book\", 5},\n    {\"cosmetics\", 20},\n    {\"food\", 10},\n    {\"alcohol\", 40}\n};\n```", "```cpp\n    vector<Product> products = {\n        Product(\"Lord of the Rings\", \"book\", 22.50),\n        Product(\"Nivea\", \"cosmetics\", 15.40),\n        Product(\"apple\", \"food\", 0.30),\n        Product(\"Lagavulin\", \"alcohol\", 75.35)\n    };\n\n```", "```cpp\nauto accumulateAll = [](auto collection, auto initialValue,  auto \n    lambda){\n        return accumulate(collection.begin(), collection.end(), \n            initialValue, lambda);\n};\n```", "```cpp\n   auto totalWithoutTax = accumulateAll(transformAll<vector<double>>\n        (products, [](Product product) { return product.price; }), 0.0, \n            plus<double>());\n     CHECK_EQ(113.55, doctest::Approx(totalWithoutTax));\n```", "```cpp\n    auto pricesWithTax = transformAll<vector<double>>(products, \n            [](Product product){\n                int taxPercentage = \n                    taxLevelByCategory[product.category];\n                return product.price + product.price * \n                    taxPercentage/100;\n            });\n    auto totalWithTax = accumulateAll(pricesWithTax, 0.0, \n        plus<double> ());\n    CHECK_EQ(147.925, doctest::Approx(totalWithTax));\n```", "```cpp\n    string expectedJSONList = \"{people: {'person': {'name': 'Alex', \n        'age': '42'}}, {'person': {'name': 'John', 'age': '21'}}, \n            {'person': {'name': 'Jane', 'age': '14'}}}\"; \n    string peopleAsJSONList = \"{people: \" + accumulateAll(peopleAsJson, \n        string(),\n            [](string first, string second){\n                return (first.empty()) ? second : (first + \", \" + \n                    second);\n            }) + \"}\";\n    CHECK_EQ(expectedJSONList, peopleAsJSONList);\n```", "```cpp\nTEST_CASE(\"Find all minors\"){\n    vector<Person> people = {\n        Person(\"Alex\", 42),\n        Person(\"John\", 21),\n        Person(\"Jane\", 14),\n        Person(\"Diana\", 9)\n    };\n\n    vector<Person> expectedMinors{Person(\"Jane\", 14), \n                                  Person(\"Diana\", 9)};\n\n    vector<Person> minors;\n    copy_if(people.begin(), people.end(), back_inserter(minors), []\n        (Person& person){ return person.age < 18; });\n\n    CHECK_EQ(minors, expectedMinors);\n}\n```", "```cpp\n    vector<Person> people = {\n        Person(\"Alex\", 42),\n        Person(\"John\", 21),\n        Person(\"Jane\", 14),\n        Person(\"Diana\", 0)\n    };\n```", "```cpp\nAlex, major\nJohn, major\nJane, minor\nInvalid person\n```", "```cpp\nstruct MajorOrMinorPerson{\n    Person person;\n    optional<string> majorOrMinor;\n\n    MajorOrMinorPerson(Person person, string majorOrMinor) : \n        person(person), majorOrMinor(optional<string>(majorOrMinor)){};\n\n    MajorOrMinorPerson(Person person) : person(person), \n        majorOrMinor(nullopt){};\n};\n    auto majorMinorPersons = transformAll<vector<MajorOrMinorPerson>>\n        (people, [](Person& person){ \n            if(person.age <= 0) return MajorOrMinorPerson(person);\n            if(person.age > 0 && person.age < 18) return \n                MajorOrMinorPerson(person, \"minor\");\n            return MajorOrMinorPerson(person, \"major\");\n            });\n```", "```cpp\n    auto majorMinorPersonsAsString = transformAll<vector<string>>\n        (majorMinorPersons, [](MajorOrMinorPerson majorOrMinorPerson){\n            return majorOrMinorPerson.majorOrMinor ? \n            majorOrMinorPerson.person.name + \", \" + \n                majorOrMinorPerson.majorOrMinor.value() :\n                    \"Invalid person\";\n            });\n```", "```cpp\n    auto completeString = accumulateAll(majorMinorPersonsAsString, \n        string(), [](string first, string second){\n            return first.empty() ? second : (first + \"\\n\" + second);\n            });\n```", "```cpp\n    string expectedString(\"Alex, major\\nJohn, major\\nJane, \n                                    minor\\nInvalid person\");\n\n    CHECK_EQ(expectedString, completeString);\n```", "```cpp\nTEST_CASE(\"Ranges\"){\n    vector<Person> people = {\n        Person(\"Alex\", 42),\n        Person(\"John\", 21),\n        Person(\"Jane\", 14),\n        Person(\"Diana\", 0)\n    };\n    using namespace ranges;\n\n    string completeString = ranges::accumulate(\n            people |\n            view::transform(personToMajorMinor) | \n            view::transform(majorMinor),\n            string(),\n            combineWithNewline\n           ); \n    string expectedString(\"Alex, major\\nJohn, major\\nJane, \n                                    minor\\nInvalid person\");\n\n    CHECK_EQ(expectedString, completeString);\n}\n```", "```cpp\nTEST_CASE(\"Find all minors with ranges\"){\n    using namespace ranges;\n\n    vector<Person> people = {\n        Person(\"Alex\", 42),\n        Person(\"John\", 21),\n        Person(\"Jane\", 14),\n        Person(\"Diana\", 9)\n    };\n    vector<Person> expectedMinors{Person(\"Jane\", 14),\n                                   Person(\"Diana\", 9)};\n\n    vector<Person> minors = people | view::filter(isMinor);\n\n    CHECK_EQ(minors, expectedMinors);\n}\n```"]