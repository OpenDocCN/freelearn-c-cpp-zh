- en: Chapter 8. Actors and Pawns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。演员和棋子
- en: Now we will really delve into UE4 code. At first, it is going to look daunting.
    The UE4 class framework is massive, but don't worry. The framework is massive,
    so your code doesn't have to be. You will find that you can get a lot done and
    a lot onto the screen using relatively less code. This is because the UE4 engine
    code is so extensive and well programmed that they have made it possible to get
    almost any game-related task done easily. Just call the right functions, and voila,
    what you want to see will appear on the screen. The entire notion of a framework
    is that it is designed to let you get the gameplay you want, without having to
    spend a lot of time in sweating out the details.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将真正深入到UE4代码中。一开始，它可能会看起来令人畏惧。UE4类框架非常庞大，但别担心。框架虽然庞大，但你的代码不必如此。你会发现，你可以用相对较少的代码完成很多事情，并将很多内容显示在屏幕上。这是因为UE4引擎代码非常广泛且编程良好，以至于他们使得几乎任何与游戏相关的任务都能轻松完成。只需调用正确的函数，voila，你想要看到的内容就会出现在屏幕上。框架的整个概念就是它被设计成让你获得你想要的玩法，而不必花费大量时间在细节上费尽心思。
- en: Actors versus pawns
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员与棋子的区别
- en: In this chapter, we will discuss actors and pawns. Although it sounds as if
    pawns will be a more basic class than actors, it is actually the other way around.
    A UE4 actor (the `Actor` class) object is the basic type of the things that can
    be placed in the UE4 game world. In order to place anything in the UE4 world,
    you must derive from the `Actor` class.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论演员和棋子。尽管听起来棋子似乎比演员更基础，但实际上情况正好相反。UE4演员（`Actor`类）对象是可以在UE4游戏世界中放置的基本类型。为了在UE4世界中放置任何东西，你必须从`Actor`类派生。
- en: A `Pawn` is an object that represents something that you or the computer's **Artificial
    Intelligence** (**AI**) can control on the screen. The `Pawn` class derives from
    the `Actor` class, with the additional ability to be controlled by the player
    directly or by an AI script. When a pawn or actor is controlled by a controller
    or AI, it is said to be possessed by that controller or AI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pawn`是一个代表你可以或计算机的**人工智能**（**AI**）在屏幕上控制的对象。`Pawn`类从`Actor`类派生，并具有由玩家直接或由AI脚本控制的附加能力。当一个棋子或演员被控制器或AI控制时，它被称为被该控制器或AI所拥有。'
- en: Think of the `Actor` class as a character in a play. Your game world is going
    to be composed of a bunch of *actors*, all acting together to make the gameplay
    work. The game characters, **Non-player Characters** (**NPC**s), and even treasure
    chests will be actors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Actor`类想象成戏剧中的角色。你的游戏世界将由许多*演员*组成，他们一起行动以使游戏玩法工作。游戏角色、**非玩家角色**（**NPC**）甚至宝箱都将作为演员。
- en: Creating a world to put your actors in
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个世界来放置你的演员
- en: Here, we will start from scratch and create a basic level into which we can
    put our game characters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从头开始创建一个基本关卡，我们可以将游戏角色放入其中。
- en: The UE4 team has already done a great job of presenting how the world editor
    can be used to create a world in UE4\. I want you to take a moment to create your
    own world.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: UE4团队已经很好地展示了如何使用世界编辑器在UE4中创建世界。我希望你能花点时间创建自己的世界。
- en: 'First, create a new, blank UE4 project to get started. To do this, in the Unreal
    Launcher, click on the **Launch** button beside your most recent engine installation,
    as shown in the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的、空白的UE4项目以开始。为此，在Unreal启动器中，点击你最近安装的引擎旁边的**启动**按钮，如图所示：
- en: '![Creating a world to put your actors in](img/00075.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个世界来放置你的演员](img/00075.jpeg)'
- en: That will launch the Unreal Editor. The Unreal Editor is used to visually edit
    your game world. You're going to spend a lot of time in the Unreal Editor, so
    please take your time to experiment and play around with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Unreal编辑器。Unreal编辑器用于视觉编辑你的游戏世界。你将在Unreal编辑器中花费大量时间，所以请慢慢来，尝试并玩弄它。
- en: I will only cover the basics of how to work with the UE4 editor. You will need
    to let your creative juices flow, however, and invest some time in order to become
    familiar with the editor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我将只介绍如何使用UE4编辑器的基础知识。然而，你需要让创意的源泉流淌，并投入一些时间来熟悉编辑器。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To learn more about the UE4 editor, take a look at the *Getting Started: Introduction
    to the UE4 Editor* playlist, which is available at [https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl](https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于UE4编辑器的信息，请查看*入门：UE4编辑器简介*播放列表，该播放列表可在[https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl](https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl)找到。
- en: 'Once you''ve launched the UE4 editor, you will be presented with the **Projects**
    dialog. The following screenshot shows the steps to be performed with numbers
    corresponding to the order in which they need to be performed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 启动UE4编辑器后，你将看到一个**项目**对话框。以下截图显示了需要执行的步骤，数字对应于它们需要执行的顺序：
- en: '![Creating a world to put your actors in](img/00076.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个世界来放置你的演员](img/00076.jpeg)'
- en: 'Perform the following steps to create a project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建项目：
- en: Select the **New Project** tab at the top of the screen.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部选择**新建项目**标签页。
- en: Click on the **C++** tab (the second subtab).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**C++**标签（第二个子标签）。
- en: Then select **Basic Code** from the available projects listing.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从可用的项目列表中选择**基本代码**。
- en: Set the directory where your project is located (mine is **Y:\Unreal Projects\**).
    Choose a hard disk location with a lot of space (the final project will be around
    1.5 GB).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的项目所在目录（我的目录是**Y:\Unreal Projects\**）。选择一个空间充足的硬盘位置（最终项目大小约为1.5 GB）。
- en: Name your project. I called mine **GoldenEgg**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的项目命名。我将其命名为**GoldenEgg**。
- en: Click on **Create Project** to finalize project creation.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建项目**以完成项目创建。
- en: 'Once you''ve done this, the UE4 launcher will launch Visual Studio. There will
    only be a couple of source files in Visual Studio, but we''re not going to touch
    those now. Make sure that **Development Editor** is selected from the **Configuration
    Manager** dropdown at the top of the screen, as shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，UE4启动器将启动Visual Studio。Visual Studio中只有几个源文件，但现在我们不会触碰它们。确保从屏幕顶部的**配置管理器**下拉菜单中选择**开发编辑器**，如图所示：
- en: '![Creating a world to put your actors in](img/00077.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个世界来放置你的演员](img/00077.jpeg)'
- en: 'Now launch your project by pressing *Ctrl* + *F5* in Visual Studio. You will
    find yourself in the Unreal Engine 4 editor, as shown in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在Visual Studio中按*Ctrl* + *F5*启动你的项目。你将发现自己处于Unreal Engine 4编辑器中，如图所示：
- en: '![Creating a world to put your actors in](img/00078.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个世界来放置你的演员](img/00078.jpeg)'
- en: The UE4 editor
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE4编辑器
- en: We will explore the UE4 editor here. We'll start with the controls since it
    is important to know how to navigate in Unreal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里探索UE4编辑器。我们将从控制开始，因为了解如何在Unreal中导航很重要。
- en: Editor controls
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑器控制
- en: 'If you''ve never used a 3D editor before, the controls can be quite hard to
    learn. These are the basic navigation controls while in edit mode:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未使用过3D编辑器，那么控制可能会很难学。以下是在编辑模式下的基本导航控制：
- en: Use the arrow keys to move around in the scene
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用箭头键在场景中移动
- en: Press *Page Up* or *Page Down* to go up and down vertically
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*Page Up*或*Page Down*上下垂直移动
- en: Left mouse click + drag it left or right to change the direction you are facing
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左键点击并拖动鼠标左右移动以改变面向的方向
- en: Left mouse click + drag it up or down to *dolly* (move the camera forward and
    backward, same as pressing up/down arrow keys)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左键点击并拖动鼠标上下移动以*推拉*（前进和后退相机，与按上/下箭头键相同）
- en: Right mouse click + drag to change the direction you are facing
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键点击并拖动以改变面向的方向
- en: Middle mouse click + drag to pan the view
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中键点击并拖动以平移视图
- en: Right mouse click and the *W*, *A*, *S*, and *D* keys to move around the scene
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键点击并使用*W*、*A*、*S*和*D*键在场景中移动
- en: Play mode controls
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放模式控制
- en: Click on the **Play** button in the bar at the top, as shown in the following
    screenshot. This will launch the play mode.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部栏中点击**播放**按钮，如图所示。这将启动播放模式。
- en: '![Play mode controls](img/00079.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![播放模式控制](img/00079.jpeg)'
- en: 'Once you click on the **Play** button, the controls change. In play mode, the
    controls are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**播放**按钮后，控制会改变。在播放模式下，控制如下：
- en: The *W*, *A*, *S*, and *D* keys for movement
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*W*、*A*、*S*和*D*键用于移动'
- en: The left or right arrow keys to look toward the left and right, respectively
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左右箭头键分别用于向左和向右看
- en: The mouse's motion to change the direction in which you look
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标移动以改变你观察的方向
- en: The *Esc* key to exit play mode and return to edit mode
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*Esc*键退出播放模式并返回到编辑模式
- en: What I suggest you do at this point is try to add a bunch of shapes and objects
    into the scene and try to color them with different *materials*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你现在尝试向场景添加一些形状和对象，并尝试用不同的*材料*给它们上色。
- en: Adding objects to the scene
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向场景添加对象
- en: Adding objects to the scene is as easy as dragging and dropping them in from
    the **Content Browser** tab. The **Content Browser** tab appears, by default,
    docked at the left-hand side of the window. If it isn't seen, simply select **Window**
    and navigate to **Content Browser** in order to make it appear.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 向场景添加对象就像从**内容浏览器**选项卡拖放它们一样简单。默认情况下，**内容浏览器**选项卡停靠在窗口的左侧。如果看不到，请选择**窗口**并导航到**内容浏览器**以使其出现。
- en: '![Adding objects to the scene](img/00080.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![向场景添加对象](img/00080.jpeg)'
- en: Make sure that the Content Browser is visible in order to add objects to your
    level
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 确保内容浏览器可见，以便将对象添加到你的级别中
- en: Next, select the **Props** folder on the left-hand side of the **Content Browser**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**内容浏览器**的左侧选择**道具**文件夹。
- en: '![Adding objects to the scene](img/00081.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![向场景添加对象](img/00081.jpeg)'
- en: Drag and drop things from the Content Browser into your game world
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将内容浏览器中的内容拖放到你的游戏世界中
- en: To resize an object, press *R* on your keyboard. The manipulators around the
    object will appear as boxes, which denotes resize mode.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整对象大小，请按键盘上的*R*键。对象周围的操纵器将显示为框，表示调整大小模式。
- en: '![Adding objects to the scene](img/00082.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![向场景添加对象](img/00082.jpeg)'
- en: Press *R* on your keyboard to resize an object
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按下键盘上的*R*键来调整对象大小
- en: In order to change the material that is used to paint the object, simply drag
    and drop a new material from the **Content Browser** window inside the **Materials**
    folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改用于绘制对象的材料，只需从**内容浏览器**窗口内的**材料**文件夹中拖放一个新的材料。
- en: '![Adding objects to the scene](img/00083.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![向场景添加对象](img/00083.jpeg)'
- en: Drag and drop a material from the Content Browser's Materials folder to color
    things with a new color
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从内容浏览器中的材料文件夹拖放一个材料到新颜色
- en: 'Materials are like paints. You can coat an object with any material you want
    by simply dragging and dropping the material you desire onto the object you desire
    it to be coated on. Materials are only skin-deep: they don''t change the other
    properties of an object (such as weight).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 材料就像油漆。你可以通过简单地拖放你想要的材料到你想涂覆的对象上，来给任何对象涂上你想要的材料。材料只是表面功夫：它们不会改变对象的其它属性（如重量）。
- en: Starting from scratch
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始
- en: 'If you want to start creating a level from scratch, simply click on **File**
    and navigate to **New Level...**, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从头开始创建一个级别，只需点击**文件**并导航到**新建级别...**，如下所示：
- en: '![Starting from scratch](img/00084.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![从头开始](img/00084.jpeg)'
- en: You can then select between **Default** and **Empty Level**. I think selecting
    **Empty Level** is a good idea, for the reasons that are mentioned later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择**默认**和**空级别**。我认为选择**空级别**是个好主意，原因将在后面提到。
- en: '![Starting from scratch](img/00085.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![从头开始](img/00085.jpeg)'
- en: The new level will be completely black in color to start with. Try dragging
    and dropping some objects from the **Content Browser** tab again.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 新级别最初将完全为黑色。再次尝试从**内容浏览器**选项卡拖放一些对象。
- en: This time, I added a resized shapes / box for the ground plane and textured
    it with moss, a couple of **Props** / **SM_Rocks**, **Particles** / **P_Fire**,
    and most importantly, a light source.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我为地面平面添加了一个调整大小的形状/盒子，并用苔藓纹理化，还添加了几样**道具**/ **SM_Rocks**，**粒子**/ **P_Fire**，最重要的是，一个光源。
- en: 'Be sure to save your map. Here''s a snapshot of my map (how does yours look?):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要保存你的地图。这是我地图的快照（你的看起来怎么样？）：
- en: '![Starting from scratch](img/00086.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![从头开始](img/00086.jpeg)'
- en: 'If you want to change the default level that opens when you launch the editor,
    go to **Project Settings** | **Maps & Modes**; then you will see a **Game Default
    Map** and **Editor Startup Map** setting, as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更改启动编辑器时默认打开的级别，请转到**项目设置** | **地图和模式**；然后你将看到**游戏默认地图**和**编辑器启动地图**设置，如下面的截图所示：
- en: '![Starting from scratch](img/00087.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![从头开始](img/00087.jpeg)'
- en: Adding light sources
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加光源
- en: Note that if your scene appears completely black, it is possible that you forgot
    to put a light source into it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你的场景完全为黑色，可能是因为你忘记在其中添加光源。
- en: 'In the previous scene, the **P_Fire** particle emitter acts as a light source,
    but it only emits a small amount of light. To make sure that everything appears
    well-lit in your scene, you should add a light source, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个场景中，**P_Fire**粒子发射器充当光源，但它只发出少量的光。为了确保你的场景中的一切都看起来光线充足，你应该添加一个光源，如下所示：
- en: Go to **Window** and then click on **Modes** to ensure that the light sources
    panel is shown:![Adding light sources](img/00088.jpeg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**窗口**然后点击**模式**以确保显示光源面板：![添加光源](img/00088.jpeg)
- en: Then, from the **Modes** panel, drag one of the **Lights** object into the scene:![Adding
    light sources](img/00089.jpeg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从**模式**面板中，将一个**灯光**对象拖入场景：![添加光源](img/00089.jpeg)
- en: Select the lightbulb and box icon (it looks like a mushroom, but it isn't).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择灯泡和盒子图标（它看起来像蘑菇，但不是）。
- en: Click on **Lights** in the left-hand side panel.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中点击**灯光**。
- en: Select the type of light you want and just pull it into your scene.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要的灯光类型并将其拖入你的场景。
- en: If you don't have a light source, your scene will appear completely black.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有光源，你的场景将完全变黑。
- en: Collision volumes
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞体积
- en: You might have noticed that, so far, the camera just passes through all the
    scene geometry, even in play mode. That's not good. Let's make it such that the
    player can't just walk through the rocks in our scene.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，到目前为止，摄像机只是穿过场景中的所有几何形状，即使在播放模式中也是如此。这并不好。让我们让它变得这样，即玩家不能轻易穿过场景中的岩石。
- en: There are a few different types of collision volumes. Generally, perfect mesh-mesh
    collisions are way too expensive to do at runtime. Instead, we use an approximation
    (a bounding volume) to guess the collision volume.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的碰撞体积类型。通常，在运行时进行完美的网格-网格碰撞成本太高。相反，我们使用一个近似值（边界体积）来猜测碰撞体积。
- en: Adding collision detection for the objects editor
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为对象编辑器添加碰撞检测
- en: The first thing we have to do is associate a collision volume with each of the
    rocks in the scene.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是将每个场景中的岩石与一个碰撞体积关联起来。
- en: 'We can do this from the UE4 editor as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从UE4编辑器这样做：
- en: Click on an object in the scene for which you want to add a collision volume.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击场景中你想添加碰撞体积的对象。
- en: Right-click on this object in the **Scene Outliner** tab (the default appears
    on the right-hand side of the screen) and select edit, as shown in the following
    screenshot:![Adding collision detection for the objects editor](img/00090.jpeg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景大纲**标签（默认显示在屏幕右侧）中右键单击此对象，并选择编辑，如图下所示：![为对象编辑器添加碰撞检测](img/00090.jpeg)
- en: Note
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will find yourself in the mesh editor.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会发现自己处于网格编辑器中。
- en: Ensure that the collision volume is highlighted, at the top of the screen:![Adding
    collision detection for the objects editor](img/00091.jpeg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保碰撞体积在屏幕顶部突出显示：![为对象编辑器添加碰撞检测](img/00091.jpeg)
- en: Go to the **Collision** menu and then click on **Add Capsule Simplified Collision**:![Adding
    collision detection for the objects editor](img/00092.jpeg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**碰撞**菜单然后点击**添加胶囊简化碰撞**：![为对象编辑器添加碰撞检测](img/00092.jpeg)
- en: The collision volume, when added successfully, will appear as a bunch of lines
    surrounding the object, as shown in the following images:![Adding collision detection
    for the objects editor](img/00093.jpeg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当成功添加碰撞体积时，它将显示为围绕对象的一组线条，如图下所示：![为对象编辑器添加碰撞检测](img/00093.jpeg)
- en: The default collision capsule (left) and manually resized versions (right)
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认的碰撞胶囊（左侧）和手动调整大小的版本（右侧）
- en: You can resize (*R*), rotate (*E*), move (*W*), and change the collision volume
    as you wish, the same way you would manipulate an object in the UE4 editor.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以按需调整大小（*R*）、旋转（*E*）、移动（*W*）并更改碰撞体积，就像你在UE4编辑器中操纵对象一样。
- en: When you're done with adding collision meshes, try to click on **Play**; you
    will notice that you can no longer pass through your collidable objects.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成添加碰撞网格后，尝试点击**播放**；你会注意到你不能再穿过你的可碰撞对象。
- en: Adding an actor to the scene
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向场景添加演员
- en: Now that we have a scene up and running, we need to add an actor to the scene.
    Let's first add an avatar for the player, complete with a collision volume. To
    do this, we'll have to inherit from a UE4 `GameFramework` class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个正在运行的场景，我们需要向场景添加一个演员。让我们首先为玩家添加一个带有碰撞体积的化身。为此，我们将必须从UE4的`GameFramework`类继承。
- en: Creating a player entity
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家实体
- en: In order to create an onscreen representation of the player, we'll need to derive
    from the `Character` class in Unreal.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上创建玩家的表示，我们需要从Unreal的`Character`类派生。
- en: Inheriting from UE4 GameFramework classes
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从UE4 GameFramework类继承
- en: 'UE4 makes it easy to inherit from the base framework classes. All you have
    to do is perform the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: UE4使得从基础框架类继承变得容易。你只需要执行以下步骤：
- en: Open your project in the UE4 editor.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4编辑器中打开你的项目。
- en: Go to **File** and then select **Add Code to Project...**.![Inheriting from
    UE4 GameFramework classes](img/00094.jpeg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**文件**然后选择**添加代码到项目...**。[从UE4 GameFramework类继承](img/00094.jpeg)
- en: Navigating to File | Add Code To Project... will allow you to derive from any
    of the UE4 GameFramework classes
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过导航到文件 | 添加代码到项目...，你可以从任何UE4 GameFramework类派生
- en: From here, choose the base class you want to derive from. You have **Character**,
    **Pawn**, **Actor**, and so on, but for now, we will derive from **Character**:![Inheriting
    from UE4 GameFramework classes](img/00095.jpeg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，选择你想要从其派生的基类。你有**Character**、**Pawn**、**Actor**等等，但就目前而言，我们将从**Character**派生：[从UE4
    GameFramework类继承](img/00095.jpeg)
- en: Select the UE4 class you want to derive from
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择你想要从其派生的UE4类
- en: Click on **Next >** to get this dialog box, where you name the class. I named
    my player's class `Avatar`.![Inheriting from UE4 GameFramework classes](img/00096.jpeg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步 >**以获取此对话框，在这里你命名类。我给我的玩家类命名为`Avatar`。[从UE4 GameFramework类继承](img/00096.jpeg)
- en: Finally, click on **Create Class** to create the class in code, as shown in
    the preceding screenshot.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**创建类**以在代码中创建类，如图中所示。
- en: Let UE4 refresh your Visual Studio project when it asks you. Open the new `Avatar.h`
    file from the **Solution Explorer**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当UE4要求你刷新Visual Studio项目时，请让它刷新。从**解决方案资源管理器**打开新的`Avatar.h`文件。
- en: The code that UE4 generates will look a little weird. Remember the macros that
    I suggested you avoid in [Chapter 5](part0034_split_000.html#10DJ41-dd4a3f777fc247568443d5ffb917736d
    "Chapter 5. Functions and Macros"), *Functions and Macros*. The UE4 code uses
    macros extensively. These macros are used to copy and paste boilerplate starter
    code that lets your code integrate with the UE4 editor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: UE4生成的代码看起来可能有点奇怪。记住我在[第五章](part0034_split_000.html#10DJ41-dd4a3f777fc247568443d5ffb917736d
    "第五章。函数和宏")“函数和宏”中建议你避免的宏。UE4代码广泛使用了这些宏。这些宏用于复制和粘贴样板启动代码，使你的代码能够与UE4编辑器集成。
- en: 'The contents of the `Avatar.h` file are shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`Avatar.h`文件的内容：
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's talk about macros for a moment.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时谈谈宏。
- en: The `UCLASS()` macro basically makes your C++ code class available in the UE4
    editor. The `GENERATED_UCLASS_BODY()` macro copies and pastes code that UE4 needs
    to make your class function properly as a UE4 class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`UCLASS()`宏基本上使你的C++代码类在UE4编辑器中可用。`GENERATED_UCLASS_BODY()`宏复制并粘贴UE4需要以UE4类正确工作的代码。'
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For `UCLASS()` and `GENERATED_UCLASS_BODY()`, you don't truly need to understand
    how UE4 works its magic. You just need to make sure that they are present at the
    right spot (where they were when you generated the class).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`UCLASS()`和`GENERATED_UCLASS_BODY()`，你并不真正需要理解UE4是如何施展魔法的。你只需要确保它们出现在正确的位置（它们生成类时的位置）。
- en: Associating a model with the Avatar class
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模型与Avatar类关联
- en: Now we need to associate a model with our character object. In order to do this,
    we need a model to play with. Fortunately, there is a whole pack of sample models
    available from the UE4 marketplace for free.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将一个模型与我们的角色对象关联起来。为了做到这一点，我们需要一个可以操作的模型。幸运的是，UE4市场上有大量免费样本模型可供使用。
- en: Downloading free models
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下载免费模型
- en: To create the player object, we'll download the **Animation Starter Pack** file
    (which is free) from the **Marketplace** tab.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建玩家对象，我们将从**市场**标签下载**动画启动包**文件（这是免费的）。
- en: '![Downloading free models](img/00097.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![下载免费模型](img/00097.jpeg)'
- en: From the Unreal Launcher, click on Marketplace and search for Animation Starter
    Pack, which is free at the time of writing this book
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，从Unreal启动器点击市场并搜索动画启动包，它是免费的。
- en: 'After you''ve downloaded the **Animation Starter Pack** file, you will be able
    to add it to any of the projects you''ve previously created, as shown in the following
    screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下载**动画启动包**文件后，你将能够将其添加到之前创建的任何项目中，如图中所示：
- en: '![Downloading free models](img/00098.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![下载免费模型](img/00098.jpeg)'
- en: 'When you click on **Add to project** under **Animation Starter Pack**, you
    will get this pop up, asking which project to add the pack to:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在**动画起始包**下的**添加到项目**处点击时，你会看到一个弹出窗口，询问要将包添加到哪个项目中：
- en: '![Downloading free models](img/00099.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![下载免费模型](img/00099.jpeg)'
- en: Simply select your project and the new artwork will be available in your **Content
    Browser**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地选择你的项目，新的艺术品将出现在你的**内容浏览器**中。
- en: Loading the mesh
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载网格
- en: In general, it is considered a bad practice to hardcode your assets into the
    game. Hardcoding means that you write C++ code that specifies the asset to load.
    However, hardcoding means the loaded asset is part of the final executable, which
    will mean that changing the asset that is loaded wouldn't be modifiable at runtime.
    This is a bad practice. It is much better to be able to change the asset loaded
    during runtime.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将资产硬编码到游戏中被认为是一种不好的做法。硬编码意味着你编写了指定要加载的资产的C++代码。然而，硬编码意味着加载的资产是最终可执行文件的一部分，这意味着更改加载的资产在运行时是不可修改的。这是一个不好的做法。能够在运行时更改加载的资产会更好。
- en: For this reason, we're going to use the UE4 blueprints feature to set up the
    model mesh and collision capsule of our `Avatar` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用UE4蓝图功能来设置我们的`Avatar`类的模型网格和碰撞胶囊。
- en: Creating a blueprint from our C++ class
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从我们的C++类创建蓝图
- en: This is really easy. Open the **Class Viewer** tab by navigating to **Window**
    and then clicking on **Class Viewer**, as shown here:![Creating a blueprint from
    our C++ class](img/00100.jpeg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这真的很简单。通过导航到**窗口**并点击**类查看器**来打开**类查看器**标签页，如图所示：![从我们的C++类创建蓝图](img/00100.jpeg)
- en: In the **Class Viewer** dialog, start typing in the name of your C++ class.
    If you have properly created and exported the class from your C++ code, it will
    appear, as shown in the following screenshot:![Creating a blueprint from our C++
    class](img/00101.jpeg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类查看器**对话框中，开始输入你的C++类的名字。如果你已经从C++代码中正确创建并导出了这个类，它将显示出来，如图所示：![从我们的C++类创建蓝图](img/00101.jpeg)
- en: Tip
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If your `Avatar` class does not show up, close the editor and compile/run the
    C++ project again.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的`Avatar`类没有显示出来，请关闭编辑器并再次编译/运行C++项目。
- en: Right-click on the class that you want to create a blueprint of (in my case,
    it's my **Avatar** class).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击你想要创建蓝图的那个类（在我的例子中，是我的**Avatar**类）。
- en: Name your blueprint something unique. I called my blueprint **BP_Avatar**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的蓝图起一个独特的名字。我给我的蓝图命名为**BP_Avatar**。
- en: Now, open this blueprint for editing, by double-clicking on **BP_Avatar** (it
    will appear in the **Class Viewer** tab after you add it, just under **Avatar**),
    as shown in the following screenshot:![Creating a blueprint from our C++ class](img/00102.jpeg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过双击**BP_Avatar**（添加后它将出现在**类查看器**标签页中，位于**Avatar**之下）来打开这个蓝图进行编辑，如图所示：![从我们的C++类创建蓝图](img/00102.jpeg)
- en: You will be presented with the blueprints window for your new **BP_Avatar**
    object, as shown here:![Creating a blueprint from our C++ class](img/00103.jpeg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到你的新**BP_Avatar**对象的蓝图窗口，如图所示：![从我们的C++类创建蓝图](img/00103.jpeg)
- en: Note
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From this window, you can attach a model to the `Avatar` class visually. Again,
    this is the recommended pattern since artists will typically be the ones setting
    up their assets for game designers to play with.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个窗口，你可以将模型可视地附加到`Avatar`类。再次强调，这是推荐的模式，因为艺术家通常会为游戏设计师设置他们的资产。
- en: To set up the default mesh, click on the **Defaults** button at the top. Scroll
    down through the properties until you come across **Mesh**.![Creating a blueprint
    from our C++ class](img/00104.jpeg)
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置默认网格，请点击顶部的**默认值**按钮。向下滚动属性，直到你遇到**网格**。![从我们的C++类创建蓝图](img/00104.jpeg)
- en: Click on the dropdown and select **HeroTPP** for your mesh, as shown in the
    preceding screenshot.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下拉菜单，并选择如图所示的**HeroTPP**作为你的网格。
- en: If **HeroTPP** doesn't appear in the dropdown, make sure that you download and
    add the **Animation Starter Pack** to your project. Alternatively, you can add
    the yellow **TutorialTPP** model to your project if you select **Show Engine Content**
    under **View** **Options**:![Creating a blueprint from our C++ class](img/00105.jpeg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**HeroTPP**没有出现在下拉菜单中，请确保你已经下载并将**动画起始包**添加到你的项目中。或者，如果你在**视图** **选项**下选择**显示引擎内容**，你也可以将黄色的**教程TPP**模型添加到你的项目中：![从我们的C++类创建蓝图](img/00105.jpeg)
- en: What about the collision volume? Click on the **Components** tab in the blueprint
    editor for your avatar:![Creating a blueprint from our C++ class](img/00106.jpeg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于碰撞体积？在蓝图编辑器中点击您的角色所在的**组件**标签：![从我们的 C++ 类创建蓝图](img/00106.jpeg)
- en: If your capsule doesn't encapsulate your model, adjust the model so that it
    fits
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您的胶囊没有封装您的模型，调整模型使其适合
- en: Note
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your model ended up like mine, the capsule is off the mark! We need to adjust
    it.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您的模型最终像我的一样，胶囊位置不正确！我们需要调整它。
- en: Click on the blue Avatar model and press the *W* key. Move him down until he
    fits inside the capsule. If the capsule isn't big enough, you can adjust its size
    in the **Details** tab under **Capsule Height** and **Capsule Radius**, as shown
    in the following screenshot:![Creating a blueprint from our C++ class](img/00107.jpeg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色的角色模型并按*W*键。将他向下移动，直到他适合胶囊内。如果胶囊不够大，您可以在**细节**标签下的**胶囊高度**和**胶囊半径**中调整其大小，如下面的截图所示：![从我们的
    C++ 类创建蓝图](img/00107.jpeg)
- en: You can stretch your capsule by adjusting the Capsule Height property
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过调整胶囊高度属性来拉伸胶囊
- en: Now, we're ready to add this avatar to the game world. Click and drag your **BP_Avatar**
    model from the **Class Viewer** tab to your scene in the UE4 editor.![Creating
    a blueprint from our C++ class](img/00108.jpeg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备将这个角色添加到游戏世界中。在 UE4 编辑器中，从**类查看器**标签拖动您的**BP_Avatar**模型到场景中。![从我们的 C++
    类创建蓝图](img/00108.jpeg)
- en: Our Avatar class added to the scene, in a T-pose
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 场景中添加的我们的角色类，处于 T-pose
- en: The pose of Avatar is called the T-pose. Animators often leave their characters
    in this default pose. Animations can be applied to the character in order to make
    them change this default pose to something more interesting. You want him animated,
    you say! Well, that's easy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 角色的姿态被称为 T-pose。动画师通常将角色留在这个默认姿态。可以通过应用动画来使角色改变这个默认姿态，使其更加有趣。您想要他动起来，对吧！这很简单。
- en: Under the **Defaults** tab in the blueprint editor, just above **Mesh**, there
    is an **Animation** section where you can select the active animation on your
    **Mesh**. If you wish to use a certain animation asset, simply click on the drop-down
    menu and choose the animation you desire to show.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图编辑器的**默认**选项卡中，在**网格**上方，有一个**动画**部分，您可以在其中选择**网格**上的活动动画。如果您想使用某个动画资产，只需点击下拉菜单并选择您想要的动画即可。
- en: A better thing to do, however, is to use a blueprint for the animation. This
    way, an artist can properly set the animation based on what the character is doing.
    If you select **Use Animation Blueprint** from **Animation Mode** and then select
    **ASP_HeroTPP_AnimBlueprint** from the drop-down menu, the character will appear
    to behave much better in the game, because the animation will be adjusted by the
    blueprint (which would have been done by an artist) as the character moves.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更好的做法是使用动画蓝图。这样，艺术家可以根据角色的动作正确设置动画。如果您从**动画模式**中选择**使用动画蓝图**，然后从下拉菜单中选择**ASP_HeroTPP_AnimBlueprint**，角色在游戏中的表现将看起来更好，因为动画将由蓝图（由艺术家完成）根据角色的移动进行调整。
- en: '![Creating a blueprint from our C++ class](img/00109.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![从我们的 C++ 类创建蓝图](img/00109.jpeg)'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can't cover everything here. Animation blueprints are covered in [Chapter
    11](part0076_split_000.html#28FAO1-dd4a3f777fc247568443d5ffb917736d "Chapter 11. Monsters"),
    *Monsters*. If you're really interested in animation, it also wouldn't be a bad
    idea to sit through a couple of Gnomon Workshop tutorials on IK, animation, and
    rigging, such as Alex Alvarez's *Rigging 101* class at [http://www.thegnomonworkshop.com/store/product/768/Rigging-101](http://www.thegnomonworkshop.com/store/product/768/Rigging-101).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里无法涵盖所有内容。动画蓝图在[第 11 章](part0076_split_000.html#28FAO1-dd4a3f777fc247568443d5ffb917736d
    "第 11 章。怪物") *怪物* 中有介绍。如果您对动画真的感兴趣，观看几节 Gnomon Workshop 关于逆运动学、动画和绑定教程也不会错，例如
    Alex Alvarez 的 *Rigging 101* 课程，可在[http://www.thegnomonworkshop.com/store/product/768/Rigging-101](http://www.thegnomonworkshop.com/store/product/768/Rigging-101)找到。
- en: 'One more thing: let''s make the camera for the Avatar appear behind it. This
    will give you a third person''s point-of-view, which will allow you to see the
    whole character, as shown in the following screenshot with the corresponding steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：让我们让角色的摄像机出现在它的后面。这将为您提供第三人称视角，让您可以看到整个角色，如下面的截图和相应的步骤所示：
- en: '![Creating a blueprint from our C++ class](img/00110.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![从我们的 C++ 类创建蓝图](img/00110.jpeg)'
- en: In the **BP_Avatar** blueprint editor, click on the **Components** tab.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**BP_Avatar**蓝图编辑器中，点击**组件**标签。
- en: Click on **Add Component**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加组件**。
- en: Choose to add a **Camera**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择添加一个 **摄像头**。
- en: A camera will appear in the viewport. You can click on the camera and move it
    around. Position the camera so that it is somewhere behind the player. Make sure
    that the blue arrow on the player is facing the same direction as the camera.
    If it isn't, rotate the Avatar model mesh so that it faces the same direction
    as its blue-colored arrow.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 视口将出现一个摄像头。你可以点击摄像头并移动它。将摄像头定位在玩家后面某个位置。确保玩家上的蓝色箭头指向与摄像头相同的方向。如果不是，旋转 Avatar
    模型网格，使其与蓝色箭头指向相同方向。
- en: '![Creating a blueprint from our C++ class](img/00111.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![从我们的 C++ 类创建蓝图](img/00111.jpeg)'
- en: The blue-colored arrow on your model mesh indicates the forward direction for
    the model mesh. Make sure that the camera's opening faces the same direction as
    the character's forward vector
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你模型网格上的蓝色箭头指示模型网格的前进方向。确保摄像头的开口方向与角色的前进向量相同。
- en: Writing C++ code that controls the game's character
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写控制游戏角色的 C++ 代码
- en: When you launch your UE4 game, you might notice that the camera is a default,
    free-flying camera. What we will do now is make the starting character an instance
    of our `Avatar` class and control our character using the keyboard.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动你的 UE4 游戏，你可能会注意到摄像头是一个默认的、自由飞行的摄像头。我们现在要做的就是将起始角色设置为我们的 `Avatar` 类的实例，并使用键盘控制我们的角色。
- en: Making the player an instance of the Avatar class
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将玩家设置为 Avatar 类的实例
- en: In the Unreal Editor, create a subclass of **Game Mode** by navigating to **File**
    | **Add Code To Project...** and selecting **Game Mode**. I named mine **GameModeGoldenEgg**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unreal 编辑器中，通过导航到 **文件** | **将代码添加到项目...** 并选择 **游戏模式** 来创建 **游戏模式** 的子类。我命名为
    **GameModeGoldenEgg**。
- en: '![Making the player an instance of the Avatar class](img/00112.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![将玩家设置为 Avatar 类的实例](img/00112.jpeg)'
- en: The UE4 **GameMode** contains the rules of the game and describes how the game
    is played to the engine. We will work more with our `GameMode` class later. For
    now, we need to subclass it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: UE4 的 **GameMode** 包含游戏的规则，并描述了游戏如何被引擎所执行。我们稍后会更多地使用我们的 `GameMode` 类。现在，我们需要创建它的子类。
- en: Recompile your project from Visual Studio, so you can create a **GameModeGoldenEgg**
    blueprint. Create the **GameMode** blueprint by going to the **Blueprints** icon
    in the menu bar at the top, clicking on **GameMode**, and then selecting **+ Create**
    | **GameModeGoldenEgg** (or whatever you named your **GameMode** subclass in step
    1).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Visual Studio 重新编译你的项目，以便你可以创建一个 **GameModeGoldenEgg** 蓝图。通过转到菜单栏顶部的 **蓝图**
    图标，点击 **游戏模式**，然后选择 **+ 创建** | **GameModeGoldenEgg**（或你在第一步中为你的 **GameMode** 子类命名的任何名称）来创建
    **GameMode** 蓝图。
- en: '![Making the player an instance of the Avatar class](img/00113.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![将玩家设置为 Avatar 类的实例](img/00113.jpeg)'
- en: Name your blueprint; I called mine **BP_GameModeGoldenEgg**, as shown in the
    following screenshot:![Making the player an instance of the Avatar class](img/00114.jpeg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的蓝图命名；我命名为 **BP_GameModeGoldenEgg**，如图所示：![将玩家设置为 Avatar 类的实例](img/00114.jpeg)
- en: Your newly created blueprint will open in the blueprint editor. If it doesn't,
    you can open the **BP_GameModeGoldenEgg** class from the **Class Viewer** tab.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你新创建的蓝图将在蓝图编辑器中打开。如果它没有打开，你可以从 **类查看器** 选项卡打开 **BP_GameModeGoldenEgg** 类。
- en: Select your **BP_Avatar** class from the **Default Pawn Class** panel, as shown
    in the following screenshot. The **Default Pawn Class** panel is the type of object
    that will be used for the player.![Making the player an instance of the Avatar
    class](img/00115.jpeg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **默认角色类** 面板中选择你的 **BP_Avatar** 类，如图所示。**默认角色类** 面板是用于玩家的对象类型。![将玩家设置为 Avatar
    类的实例](img/00115.jpeg)
- en: Now, launch your game. You can see a back view as the camera is placed behind
    the place, as shown here:![Making the player an instance of the Avatar class](img/00116.jpeg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启动你的游戏。你可以看到背面视图，因为摄像头放置在后面，如图所示：![将玩家设置为 Avatar 类的实例](img/00116.jpeg)
- en: You'll notice that you can't move. Why is that? The answer is because we haven't
    set up the controller inputs yet.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到你无法移动。这是为什么？答案是，我们还没有设置控制器输入。
- en: Setting up controller inputs
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置控制器输入
- en: To set up controller inputs, go to **Settings** | **Project Settings...**:![Setting
    up controller inputs](img/00117.jpeg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置控制器输入，转到 **设置** | **项目设置...**：![设置控制器输入](img/00117.jpeg)
- en: Next, in the left-hand side panel, scroll down until you see **Input** under
    **Engine**.![Setting up controller inputs](img/00118.jpeg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在左侧面板中向下滚动，直到在 **引擎** 下方看到 **输入**。![设置控制器输入](img/00118.jpeg)
- en: On the right-hand side, you can set up some **Bindings**. Click on the small
    arrow next to **Axis Mappings** in order to expand it. Add just two axis mappings
    to start, one called **Forward** (connected to the keyboard letter *W*) and one
    called **Strafe** (connected to the keyboard letter *D*). Remember the names that
    you set; we will look them up in C++ code in just a moment.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，你可以设置一些 **绑定**。点击 **轴映射** 旁边的箭头以展开它。开始时只需添加两个轴映射，一个称为 **Forward**（连接到键盘字母
    *W*）和一个称为 **Strafe**（连接到键盘字母 *D*）。记住你设置的名称；我们将在稍后的 C++ 代码中查找它们。
- en: Close the **Project Settings** dialog. Now, open your C++ code.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 **项目设置** 对话框。现在，打开你的 C++ 代码。
- en: 'In the `Avatar.h` constructor, you need to add three member function declarations,
    as shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Avatar.h` 构造函数中，你需要添加三个成员函数声明，如下所示：
- en: '[PRE1]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how the first member function we're adding (`SetupPlayerInputComponent`)
    is an override of a virtual function. `SetupPlayerInputComponent` is a virtual
    function in the `APawn` base class.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加的第一个成员函数（`SetupPlayerInputComponent`）是虚拟函数的一个重写。`SetupPlayerInputComponent`
    是 `APawn` 基类中的一个虚拟函数。
- en: 'In the `Avatar.cpp` file, you need to put the function bodies. Add the following
    member function definitions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Avatar.cpp` 文件中，你需要放置函数体。添加以下成员函数定义：
- en: '[PRE2]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This member function looks up the **Forward** and **Strafe** axis bindings
    that we just created in Unreal Editor and connects them to the member functions
    inside the `this` class. Which member functions should we connect to? Why, we
    should connect to `AAvatar::MoveForward` and `AAvatar::MoveRight`. Here are the
    member function definitions for these two functions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个成员函数查找我们在 Unreal 编辑器中创建的 **Forward** 和 **Strafe** 轴绑定，并将它们连接到 `this` 类内部的成员函数。我们应该连接到哪些成员函数呢？当然，我们应该连接到
    `AAvatar::MoveForward` 和 `AAvatar::MoveRight`。以下是这两个函数的成员函数定义：
- en: '[PRE3]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `Controller` object and the `AddMovementInput` functions are defined in
    the `APawn` base class. Since the `Avatar` class derives from `ACharacter`, which
    in turn derives from `APawn`, we get free use of all the member functions in the
    base class `APawn`. Now do you see the beauty of inheritance and code reuse?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller` 对象和 `AddMovementInput` 函数在 `APawn` 基类中定义。由于 `Avatar` 类从 `ACharacter`
    继承，而 `ACharacter` 又从 `APawn` 继承，因此我们可以自由使用基类 `APawn` 中的所有成员函数。现在你看到继承和代码重用的美妙之处了吗？'
- en: Exercise
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Add axis bindings and C++ functions to move the player to the left and back.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 添加轴绑定和 C++ 函数以使玩家向左和向后移动。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here'' a hint: you only need to add axis bindings if you realize going backwards
    is only the negative of going forward.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个提示：如果你意识到向后移动只是向前移动的负值，你只需要添加轴绑定。
- en: Solution
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Enter two extra axis bindings by navigating to **Settings** | **Project Settings...**
    | **Input**, as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到 **设置** | **项目设置...** | **输入**，添加两个额外的轴绑定，如下截图所示：
- en: '![Solution](img/00119.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![解决方案](img/00119.jpeg)'
- en: Scale the **S** and **A** inputs by -1.0\. This will invert the axis. So pressing
    the *S* key in the game will move the player forward. Try it!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **S** 和 **A** 输入的缩放比例设置为 -1.0。这将反转轴。因此，在游戏中按下 *S* 键将使玩家向前移动。试试看！
- en: 'Alternatively, you can define two completely separate member functions in your
    `AAvatar` class, as follows, and bind the *A* and *S* keys to `AAvatar::MoveLeft`
    and `AAvatar::MoveBack`, respectively:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在你的 `AAvatar` 类中定义两个完全独立的成员函数，如下所示，并将 *A* 和 *S* 键分别绑定到 `AAvatar::MoveLeft`
    和 `AAvatar::MoveBack`：
- en: '[PRE4]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Yaw and pitch
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏航和俯仰
- en: We can change the direction in which the player looks by setting the yaw and
    pitch of the controller.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置控制器的偏航和俯仰来改变玩家查看的方向。
- en: 'All we have to do here is add in new axis bindings for the mouse, as shown
    in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需添加鼠标的新轴绑定，如下截图所示：
- en: '![Yaw and pitch](img/00120.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![偏航和俯仰](img/00120.jpeg)'
- en: 'From C++, you need to add in two new member function declarations to `AAvatar.h`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C++ 中，你需要向 `AAvatar.h` 添加两个新的成员函数声明：
- en: '[PRE5]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The bodies of these member functions will go in the `AAvatar.cpp` file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员函数的函数体将放在 `AAvatar.cpp` 文件中：
- en: '[PRE6]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, add two lines to `SetupPlayerInputComponent`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向 `SetupPlayerInputComponent` 添加两行：
- en: '[PRE7]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, notice how I've multiplied the `amount` values in the `Yaw` and `Pitch`
    functions by 200\. This number represents the mouse's sensitivity. You can (should)
    add a `float` member to the `AAvatar` class in order to avoid hardcoding this
    sensitivity number.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，请注意，我在 `Yaw` 和 `Pitch` 函数中将 `amount` 值乘以了 200。这个数字代表鼠标的灵敏度。你可以在 `AAvatar`
    类中添加一个 `float` 成员，以避免硬编码这个灵敏度数字。
- en: '`GetWorld()->GetDeltaSeconds()` gives you the amount of time that passed between
    the last frame and this frame. It isn''t a lot: `GetDeltaSeconds()` should be
    around 16 milliseconds (0.016 s) most of the time (if your game is running at
    60 fps).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWorld()->GetDeltaSeconds()`给你的是上一帧和这一帧之间经过的时间量。这并不多：`GetDeltaSeconds()`应该大约是16毫秒（0.016秒），大多数时候（如果你的游戏以60fps运行）。'
- en: 'So, now we have player input and control. To add new functionality to your
    Avatar, this is all that you have to do:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有了玩家输入和控制。要为你的角色添加新功能，你只需做以下这些：
- en: Bind your key or mouse actions by going to **Settings** | **Project Settings**
    | **Input**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**设置** | **项目设置** | **输入**来绑定你的键或鼠标操作。
- en: Add a member function to run when that key is pressed.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个成员函数，当按下该键时运行。
- en: Add a line to `SetupPlayerInputComponent`, connecting the name of the bound
    input to the member function we want to run when that key is pushed.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SetupPlayerInputComponent`中添加一行，将绑定的输入名称连接到当按下该键时要运行的成员函数。
- en: Creating non-player character entities
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建非玩家角色实体
- en: So, we need to create a few **NPC**s (**non-playable characters**). NPCs are
    characters within the game that help the player. Some offer special items, some
    are shop vendors, and some have information to give to the player. In this game,
    they will react to the player as he gets near. Let's program in some of this behavior.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一些**NPC**（不可玩角色）。NPC是游戏中的角色，帮助玩家。一些提供特殊物品，一些是商店卖家，一些有信息要告诉玩家。在这个游戏中，它们会在玩家靠近时做出反应。让我们编写一些这种行为。
- en: First, create another subclass of **Character**. In the UE4 Editor, go to **File**
    | **Add Code To Project...** and choose the **Character** class from which you
    can make a subclass. Name your subclass `NPC`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建另一个**Character**的子类。在UE4编辑器中，转到**文件** | **将代码添加到项目...**，然后从可以创建子类的**Character**类中选择。将你的子类命名为`NPC`。
- en: Now, edit your code in Visual Studio. Each NPC will have a message to tell the
    player, so we add in a `UPROPERTY() FString` property to the `NPC` class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Visual Studio中编辑你的代码。每个NPC都会有一个消息告诉玩家，因此我们在`NPC`类中添加了一个`UPROPERTY() FString`属性。
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`FString`s are UE4''s version of C++''s `<string>` type. When programming in
    UE4, you should use the `FString` objects over C++ STL''s `string` objects. In
    general, you should preferably use UE4''s built-in types, as they guarantee cross-platform
    compatibility.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`FString`是UE4版本的C++ `<string>` 类型。在UE4中编程时，你应该使用`FString`对象而不是C++ STL的`string`对象。一般来说，你最好使用UE4的内置类型，因为它们保证了跨平台兼容性。'
- en: 'How to add the `UPROPERTY() FString` property to the `NPC` class is shown in
    the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将`UPROPERTY() FString`属性添加到`NPC`类中，以下代码显示了：
- en: '[PRE8]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we put the `EditAnywhere` and `BlueprintReadWrite` properties into
    the `UPROPERTY` macro. This will make the `NpcMessage` editable in blueprints.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`EditAnywhere`和`BlueprintReadWrite`属性放入了`UPROPERTY`宏中。这将使`NpcMessage`在蓝图中被编辑。
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Full descriptions of all the UE4 property specifiers are available at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有UE4属性说明的完整描述可在[https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html)找到。
- en: Recompile your project (as we did for the `Avatar` class). Then, go to the **Class
    Viewer**, right click on your `NPC` class, and create a blueprint from it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译你的项目（就像我们对`Avatar`类所做的那样）。然后，转到**类查看器**，右键单击你的`NPC`类，并从它创建一个蓝图。
- en: 'Each NPC character you want to create can be a blueprint based off of the `NPC`
    class. Name each blueprint something unique, as we''ll be selecting a different
    model mesh and message for each NPC that appears, as shown in the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要创建的每个NPC角色都可以基于`NPC`类创建蓝图。为每个蓝图命名一个独特的名称，因为我们将为每个出现的NPC选择不同的模型网格和消息，如以下截图所示：
- en: '![Creating non-player character entities](img/00121.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![创建非玩家角色实体](img/00121.jpeg)'
- en: Now, open the blueprint, select skeletal **mesh** from the **Add** **Components**,
    and adjust the capsule (as we did for **BP_Avatar**). You can also change the
    material of your new character so that he looks different from the player.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开蓝图，从**添加组件**中选择骨骼**网格**，并调整胶囊（就像我们对**BP_Avatar**所做的那样）。你还可以更改你新角色的材质，使其看起来与玩家不同。
- en: '![Creating non-player character entities](img/00122.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![创建非玩家角色实体](img/00122.jpeg)'
- en: Change the material of your character in your mesh's properties. Under the Rendering
    tab, click on the + icon to add a new material. Then, click on the small capsule-shaped
    item to select a material to render with.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网格属性中更改角色的材质。在渲染选项卡下，点击+图标添加一个新的材质。然后，点击小胶囊形状的项来选择要渲染的材质。
- en: 'In the **Defaults** tab, search for the `NpcMessage` property. This is our
    connection between C++ code and blueprints: because we entered a `UPROPERTY()`
    function on the `FString NpcMessage` variable, that property appears editable
    within UE4, as shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在**默认**选项卡中，搜索`NpcMessage`属性。这是C++代码和蓝图之间的连接：因为我们在一个`FString NpcMessage`变量上输入了`UPROPERTY()`函数，所以该属性在UE4中显示为可编辑，如下面的截图所示：
- en: '![Creating non-player character entities](img/00123.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![创建非玩家角色实体](img/00123.jpeg)'
- en: Now, drag **BP_NPC_Owen** into the scene. You can create a second or third character
    as well, and be sure to give them unique names, appearances, and messages.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将**BP_NPC_Owen**拖入场景。你也可以创建第二个或第三个角色，并确保给他们起独特的名字、外观和消息。
- en: '![Creating non-player character entities](img/00124.jpeg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![创建非玩家角色实体](img/00124.jpeg)'
- en: I've created two blueprints for NPCs based on the NPC base classes, BP_NPC_Justin
    and BP_NPC_Owen. They have different appearances and different messages for the
    player.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我基于NPC基类创建了两个蓝图，BP_NPC_Justin和BP_NPC_Owen。它们有不同的外观和为玩家提供不同的消息。
- en: '![Creating non-player character entities](img/00125.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![创建非玩家角色实体](img/00125.jpeg)'
- en: Justin and Owen in the scene
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的贾斯汀和欧文
- en: Displaying a quote from each NPC dialog box
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示每个NPC对话框中的引用
- en: To display a dialog box, we need a custom (heads-up display) **HUD**. In the
    UE4 editor, go to **File** | **Add Code To Project...** and choose the `HUD` class
    from which the subclass is created. Name your subclass as you wish; I've named
    mine `MyHUD`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示对话框，我们需要一个自定义的（抬头显示）**HUD**。在UE4编辑器中，转到**文件** | **将代码添加到项目...** 并选择创建子类的`HUD`类。根据你的意愿命名你的子类；我把我命名为`MyHUD`。
- en: After you have created the `MyHUD` class, let Visual Studio reload. We will
    make some code edits.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了`MyHUD`类之后，让Visual Studio重新加载。我们将进行一些代码编辑。
- en: Displaying messages on the HUD
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在HUD上显示消息
- en: 'Inside the `AMyHUD` class, we need to implement the `DrawHUD()` function in
    order to draw our messages to the HUD and to initialize a font to draw to the
    HUD with, as shown in the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AMyHUD`类内部，我们需要实现`DrawHUD()`函数，以便将我们的消息绘制到HUD上，并初始化一个用于绘制到HUD的字体，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The HUD font will be set in a blueprinted version of the `AMyHUD` class. The
    `DrawHUD()` function runs once per frame. In order to draw within the frame, add
    a function to the `AMyHUD.cpp` file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: HUD字体将在`AMyHUD`类的蓝图版本中设置。`DrawHUD()`函数每帧运行一次。为了在帧内绘制，需要在`AMyHUD.cpp`文件中添加一个函数：
- en: '[PRE10]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Wait! We haven't initialized our font yet. To do this, we need to set it up
    in blueprints. Compile and run your Visual Studio project. Once you are in the
    editor, go to the **Blueprints** menu at the top and navigate to **GameMode**
    | **HUD** | **+ Create** | **MyHUD**.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我们还没有初始化我们的字体。为了做到这一点，我们需要在蓝图中进行设置。编译并运行你的Visual Studio项目。一旦你进入编辑器，转到顶部的**蓝图**菜单并导航到**游戏模式**
    | **HUD** | **+ 创建** | **MyHUD**。
- en: '![Displaying messages on the HUD](img/00126.jpeg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![在HUD上显示消息](img/00126.jpeg)'
- en: Creating a blueprint of the MyHUD class
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 创建MyHUD类的蓝图
- en: 'I called mine `BP_MyHUD`. Edit `BP_MyHUD` and select a font from the drop-down
    menu under **HUDFont**:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我把它命名为`BP_MyHUD`。编辑`BP_MyHUD`并从**HUDFont**下的下拉菜单中选择一个字体：
- en: '![Displaying messages on the HUD](img/00127.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![在HUD上显示消息](img/00127.jpeg)'
- en: I selected RobotoDistanceField for my HUD font
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我为我的HUD选择了RobotoDistanceField字体
- en: 'Next, edit your **Game Mode** blueprint (**BP_GameModeGoldenEgg**) and select
    your new `BP_MyHUD` (not `MyHUD` class) for the **HUD Class** panel:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑你的**游戏模式**蓝图（**BP_GameModeGoldenEgg**）并选择你的新`BP_MyHUD`（不是`MyHUD`类）用于**HUD类**面板：
- en: '![Displaying messages on the HUD](img/00128.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![在HUD上显示消息](img/00128.jpeg)'
- en: Test your program by running it! You should see text printed on the screen.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行程序来测试你的程序！你应该会在屏幕上看到打印的文本。
- en: '![Displaying messages on the HUD](img/00129.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![在HUD上显示消息](img/00129.jpeg)'
- en: Using TArray<Message>
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TArray<Message>
- en: 'Each message we want to display for the player will have a few properties:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要向玩家显示的每条消息都将有几个属性：
- en: An `FString` variable for the message
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于消息的`FString`变量
- en: A `float` variable for the time to display it
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示时间的`float`变量
- en: An `FColor` variable for the color of the message
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于消息颜色的`FColor`变量
- en: So it makes sense for us to write a little `struct` function to contain all
    this information.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们编写一个小的 `struct` 函数来包含所有这些信息是有意义的。
- en: 'At the top of `MyHUD.h`, insert the following `struct` declaration:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MyHUD.h` 的顶部插入以下 `struct` 声明：
- en: '[PRE11]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An enhanced version of the `Message` structure (with a background color) is
    in the code package for this chapter. We used simpler code here so that it'd be
    easier to understand the chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码包中有一个增强版的 `Message` 结构（带有背景颜色）。在这里我们使用了更简单的代码，以便更容易理解本章内容。
- en: 'Now, inside the `AMyHUD` class, we want to add a `TArray` of these messages.
    A `TArray` is a UE4-defined special type of dynamically growable C++ array. We
    will cover the detailed use of `TArray` in the next chapter, but this simple usage
    of `TArray` should be a nice introduction to garner your interest in the usefulness
    of arrays in games. This will be declared as `TArray<Message>`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `AMyHUD` 类中，我们想要添加一个这些消息的 `TArray`。`TArray` 是 UE4 定义的一种特殊类型的动态可增长 C++ 数组。我们将在下一章中详细介绍
    `TArray` 的使用，但这个简单的 `TArray` 使用应该是一个很好的介绍，以激发你对游戏中使用数组的有用性的兴趣。这将被声明为 `TArray<Message>`：
- en: '[PRE12]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, whenever the NPC has a message to display, we're just need to call `AMyHud::addMessage()`
    with our message. The message will be added to `TArray` of the messages to be
    displayed. When a message expires (after a certain amount of time), it will be
    removed from the HUD.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当 NPC 有消息要显示时，我们只需调用 `AMyHud::addMessage()` 并传入我们的消息。该消息将被添加到要显示的消息的 `TArray`
    中。当消息过期（经过一定时间后），它将从 HUD 中移除。
- en: 'Inside the `AMyHUD.cpp` file, add the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AMyHUD.cpp` 文件中，添加以下代码：
- en: '[PRE13]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `AMyHUD::DrawHUD()` function now draws all the messages in the `messages`
    array, and arranges each message in the `messages` array by the amount of time
    that passed since the last frame. Expired messages are removed from the `messages`
    collection once their `time` value drops below 0.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`AMyHUD::DrawHUD()` 函数现在会绘制 `messages` 数组中的所有消息，并按照自上一帧以来经过的时间对 `messages`
    数组中的每个消息进行排列。一旦消息的 `time` 值低于 0，过期的消息将从 `messages` 集合中移除。'
- en: Exercise
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Refactor the `DrawHUD()` function so that the code that draws the messages to
    the screen is in a separate function called `DrawMessages()`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 重构 `DrawHUD()` 函数，以便将绘制到屏幕上的消息代码放在一个名为 `DrawMessages()` 的单独函数中。
- en: The `Canvas` variable is only available in `DrawHUD()`, so you will have to
    save `Canvas->SizeX` and `Canvas->SizeY` in class-level variables.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas` 变量仅在 `DrawHUD()` 中可用，因此您必须将 `Canvas->SizeX` 和 `Canvas->SizeY` 保存为类级别变量。'
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refactoring means to change the way code works internally so that it is more
    organized or easier to read but still has the same apparent result to the user
    running the program. Refactoring often is a good practice. The reason why refactoring
    occurs is because nobody knows exactly what the final code should look like once
    they start writing it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 重构意味着改变代码内部的工作方式，使其更加有序或更容易阅读，但仍然对运行程序的用户提供相同的外观结果。重构通常是一种良好的实践。重构发生的原因是因为一旦开始编写代码，没有人确切知道最终代码应该是什么样子。
- en: Solution
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: See the `AMyHUD::DrawMessages()` function in the code package for this chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章代码包中的 `AMyHUD::DrawMessages()` 函数。
- en: Triggering an event when it is near an NPC
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在接近 NPC 时触发事件
- en: To trigger an event near the NPC, we need to set an additional collision detection
    volume that is a bit wider than the default capsule shape. The additional collision
    detection volume will be a sphere around each NPC. When the player steps into
    the NPC sphere, the NPC reacts and displays a message.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 NPC 附近触发事件，我们需要设置一个额外的碰撞检测体积，该体积略大于默认的胶囊形状。额外的碰撞检测体积将是每个 NPC 周围的球体。当玩家进入
    NPC 球体时，NPC 会做出反应并显示消息。
- en: '![Triggering an event when it is near an NPC](img/00130.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![在接近 NPC 时触发事件](img/00130.jpeg)'
- en: We're going to add the dark red sphere to the NPC so that he can tell when the
    player is nearby
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向 NPC 添加一个深红色球体，以便他能够知道玩家是否在附近。
- en: 'Inside your `NPC.h` class file, add the following code in order to declare
    `ProxSphere` and `UFUNCTION` called `Prox`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `NPC.h` 类文件中，添加以下代码以声明 `ProxSphere` 和名为 `Prox` 的 `UFUNCTION`：
- en: '[PRE14]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This looks a bit messy, but it is actually not that complicated. Here, we declare
    an extra bounding sphere volume called `ProxSphere`, which detects when the player
    is near the NPC.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点杂乱，但实际上并不复杂。在这里，我们声明了一个额外的边界球体体积 `ProxSphere`，用于检测玩家是否接近 NPC。
- en: 'In the `NPC.cpp` file, we need to add the following code in order to complete
    the proximity detection:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NPC.cpp` 文件中，我们需要添加以下代码以完成近距离检测：
- en: '[PRE15]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Make the NPC display something to the HUD when something is nearby
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当附近有东西时，让NPC向HUD显示某些内容
- en: When the player is near the NPC sphere collision volume, display a message to
    the HUD that alerts the player about what the NPC is saying.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家接近NPC的球体碰撞体积时，向HUD显示一条消息，提醒玩家NPC在说什么。
- en: 'This is the complete implementation of `ANPC::Prox_Implementation`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ANPC::Prox_Implementation`的完整实现：
- en: '[PRE16]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first thing we do in this function is to cast `OtherActor` (the thing that
    came near the NPC) to `AAvatar`. The cast succeeds (and is not `nullptr`) when
    `OtherActor` is an `AAvatar` object. We get the HUD object (which happens to be
    attached to the player controller) and pass a message from the NPC to the HUD.
    The message is displayed whenever the player is within the red bounding sphere
    surrounding the NPC.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先将`OtherActor`（靠近NPC的东西）强制转换为`AAvatar`。当`OtherActor`是一个`AAvatar`对象时，转换成功（并且不是`nullptr`）。我们获取HUD对象（它恰好附加到玩家控制器）并将NPC的消息传递给HUD。当玩家在NPC周围的红色边界球体内时，会显示这条消息。
- en: '![Make the NPC display something to the HUD when something is nearby](img/00131.jpeg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![当附近有东西时，让NPC向HUD显示某些内容](img/00131.jpeg)'
- en: Owen's greeting
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 欧文的问候
- en: Exercises
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Add a `UPROPERTY` function name for the NPC's name so that the name of the NPC
    is editable in blueprints, similar to the message that the NPC has for the player.
    Show the NPC's name in the output.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为NPC的名称添加一个`UPROPERTY`函数名，以便在蓝图中对NPC的名称进行编辑，类似于NPC对玩家说的话。在输出中显示NPC的名称。
- en: Add a `UPROPERTY` function (type `UTexture2D*`) for the NPC's face texture.
    Draw the NPC's face beside its message in the output.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为NPC的面部纹理添加一个`UPROPERTY`函数（类型`UTexture2D*`）。在输出中在其消息旁边绘制NPC的脸。
- en: Render the player's HP as a bar (filled rectangle).
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以条形（填充矩形）的形式渲染玩家的HP。
- en: Solutions
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add this property to the `ANPC` class:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将此属性添加到`ANPC`类中：
- en: '[PRE17]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in `ANPC::Prox_Implementation`, change the string passed to the HUD to:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`ANPC::Prox_Implementation`中，将传递给HUD的字符串更改为：
- en: '[PRE18]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This way, the NPC's name will be attached to the message.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，NPC的名称就会附加到消息上。
- en: 'Add `this` property to the `ANPC` class:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将此属性添加到`ANPC`类中：
- en: '[PRE19]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then you can select face icons to be attached to the NPC's face in blueprints.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在蓝图中选择要附加到NPC脸上的面部图标。
- en: 'Attach a texture to your `struct Message`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将纹理附加到你的`struct Message`：
- en: '[PRE20]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To render these icons, you need to add a call to `DrawTexture()` with the right
    texture passed in to it:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染这些图标，你需要添加一个调用`DrawTexture()`的调用，并将正确的纹理传递给它：
- en: '[PRE21]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Be sure to check whether the texture is valid before you render it. The icons
    should look similar to what is shown here, at the top of the screen:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染之前，务必检查纹理是否有效。图标应类似于屏幕顶部所示的内容：
- en: '![Solutions](img/00132.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![解决方案](img/00132.jpeg)'
- en: 'This is how a function to draw the player''s remaining health in a bar will
    look:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是绘制玩家剩余健康度的条形函数的样子：
- en: '[PRE22]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through a lot of material. We showed you how to create
    a character and display it on the screen, control your character with axis bindings,
    and create and display NPCs that can post messages to the HUD.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了大量内容。我们向您展示了如何创建角色并在屏幕上显示它，如何使用轴绑定来控制角色，以及如何创建和显示可以发布消息到HUD的NPC。
- en: In the upcoming chapters, we will develop our game further by adding an *Inventory
    System and Pickup Items* in [Chapter 10](part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d
    "Chapter 10. Inventory System and Pickup Items"), as well as the code and the
    concept to account for what the player is carrying. Before we do that, though,
    we will do an in-depth exploration of some of the UE4 container types in [Chapter
    9](part0066_split_000.html#1UU541-dd4a3f777fc247568443d5ffb917736d "Chapter 9. Templates
    and Commonly Used Containers"), *Templates and Commonly Used Containers*.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过在[第10章](part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d
    "第10章。库存系统和拾取物品")中添加*库存系统及拾取物品*以及相应的代码和概念来进一步开发我们的游戏。在此之前，我们将在[第9章](part0066_split_000.html#1UU541-dd4a3f777fc247568443d5ffb917736d
    "第9章。模板和常用容器")中深入探讨一些UE4容器类型，*模板和常用容器*。
