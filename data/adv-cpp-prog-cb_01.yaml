- en: Getting Started with Library Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用库开发
- en: In this chapter, we will cover some useful recipes for creating our own libraries,
    including an explanation of the principle of least surprise, which encourages
    us to implement libraries using semantics that our users are already familiar
    with. We will also look at how to namespace everything to ensure our custom libraries
    don't conflict with others. In addition, we will look at how to create header-only
    libraries, as well as some best practices associated with library development.
    Finally, we will conclude this chapter with a demonstration of the boost libraries
    to show you what a large library looks like and how it can be used by users in
    their own projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些有用的配方，用于创建我们自己的库，包括最少惊讶原则的解释，该原则鼓励我们使用用户已经熟悉的语义来实现库。我们还将看看如何对所有内容进行命名空间处理，以确保我们的自定义库不会与其他库发生冲突。此外，我们还将介绍如何创建仅包含头文件的库，以及与库开发相关的一些最佳实践。最后，我们将通过演示boost库来结束本章，以向您展示一个大型库的样子以及用户如何在自己的项目中使用它。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Understanding the principle of least surprise
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解最少惊讶原则
- en: How to namespace everything
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对所有内容进行命名空间处理
- en: Header-only libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅包含头文件的库
- en: Learning library development best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习库开发的最佳实践
- en: Learning how to use the boost APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用boost API
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, you must install the following packages using
    the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有管理访问权限，可以访问运行Ubuntu 18.04的计算机，并具有正常的互联网连接。在运行这些示例之前，您必须使用以下命令安装以下软件包：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个安装在除Ubuntu 18.04之外的任何操作系统上，那么将需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Understanding the principle of least surprise
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解最少惊讶原则
- en: When either using existing C++ libraries or creating your own, understanding
    the **principle of least surprise** (also called the **principle of least astonishment**)
    is critical to developing source code efficiently and effectively. This principle
    simply states that any feature that a C++ library provides should be intuitive
    and should operate as the developer expects. Another way of saying this is that
    a library's APIs should be self-documenting. Although this principle is critically
    important when designing libraries, it can and should be applied to all forms
    of software development. In this recipe, we will explore this principle in depth.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用现有的C++库或创建自己的库时，理解**最少惊讶原则**（也称为**最少惊讶原则**）对于高效和有效地开发源代码至关重要。这个原则简单地指出，C++库提供的任何功能都应该是直观的，并且应该按照开发人员的期望进行操作。另一种说法是，库的API应该是自我记录的。尽管这个原则在设计库时至关重要，但它可以并且应该应用于所有形式的软件开发。在本教程中，我们将深入探讨这个原则。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As with all of the recipes in this chapter, ensure that all of the technical
    requirements have been met, including installing Ubuntu 18.04 or higher and running
    the following in a Terminal window:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的所有配方一样，确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you've done this, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成本教程：
- en: 'From a new Terminal, run the following code to download the source code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下代码来下载源代码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码被编译，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的功能以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As stated in the previous section, the principle of least surprise states that
    a library's APIs should be intuitive and self-documenting and this principle generally
    applies to all forms of software development and not just library design. To understand
    this, we'll look at some examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，最少惊讶原则指出，库的API应该直观且自我记录，这个原则通常适用于所有形式的软件开发，而不仅仅是库设计。为了理解这一点，我们将看一些例子。
- en: Example 1
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例1
- en: 'Example 1 demonstrates the principle of least surprise as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1演示了最少惊讶原则，如下所示：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in the preceding example, we have implemented a library API that adds
    two integers and returns the results. The problem is that we named the function
    `sub`, which most developers would associate with subtraction and not addition;
    although the API functions as designed, it breaks the principle of least surprise
    because the API's name is not intuitive.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们实现了一个库API，它可以将两个整数相加并返回结果。问题在于我们将函数命名为`sub`，大多数开发人员会将其与减法而不是加法联系起来；尽管API按设计工作，但它违反了最少惊讶原则，因为API的名称不直观。
- en: Example 2
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例2
- en: 'Example 2 demonstrates the principle of least surprise as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2演示了最少惊讶原则，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As shown in the preceding example, we have implemented the same library API
    that we implemented in the previous exercise; it is designed to add two numbers
    and return the result. The issue with this example is that the API is implementing
    the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们已经实现了与上一个练习中实现的相同的库API；它旨在添加两个数字并返回结果。这个例子的问题在于API实现了以下内容：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example, the principle of least surprise is being violated in two different
    ways:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，最少惊讶原则以两种不同的方式被违反：
- en: The add function's arguments are `a` and then `b`, even though we would write
    this equation as `b += a`, meaning that the order of the arguments is intuitively
    backward.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: add函数的参数是`a`，然后是`b`，尽管我们会将这个等式写成`b += a`，这意味着参数的顺序在直觉上是相反的。
- en: It is not immediately obvious to the user of this API that the result would
    be returned in `b` without reading the source code.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这个API的用户来说，不会立即明显地意识到结果将在`b`中返回，而不必阅读源代码。
- en: A function's signature should document how the function will execute using semantics
    the user is already accustomed to, thus reducing the probability of causing the
    user to execute the API incorrectly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名应该使用用户已经习惯的语义来记录函数将如何执行，从而降低用户错误执行API的概率。
- en: Example 3
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例3
- en: 'Example 3 demonstrates the principle of least surprise as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3演示了最少惊讶原则如下：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown in the preceding example, we're adhering to the principle of least
    surprise here. The API is designed to add two integers and return the result,
    and the API intuitively performs this action as expected.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们在这里遵循了最少惊讶原则。API旨在将两个整数相加并返回结果，API直观地执行了预期的操作。
- en: Example 4
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例4
- en: 'Example 4 demonstrates the principle of least surprise as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4演示了最少惊讶原则如下：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As shown in the preceding example, another great example of the principle of
    least surprise is the difference between `printf()` and `std::cout`. The `printf()`
    function requires the addition of format specifiers to output integers to `stdout`.
    There are many reasons why `printf()` is not intuitive:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，另一个很好的最少惊讶原则的例子是`printf()`和`std::cout`之间的区别。`printf()`函数需要添加格式说明符来将整数输出到`stdout`。`printf()`不直观的原因有很多：
- en: To a beginner, the `printf()` function's name, which stands for print formatted,
    is not intuitive (or in other words, the function's name is not self-documenting).
    Other languages avoid this issue by picking more intuitive names for a print function,
    such as `print()` or `console()`, which do a better job of adhering to the principle
    of least surprise.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于初学者来说，`printf()`函数的名称，代表打印格式化，不直观（或者换句话说，函数的名称不是自我说明的）。其他语言通过选择更直观的打印函数名称来避免这个问题，比如`print()`或`console()`，这些名称更好地遵循了最少惊讶原则。
- en: The format specifier symbol for an integer is `d`. Once again, to a beginner
    this is unintuitive. In this specific case, `d` stands for decimal, which is another
    way of saying *signed integer*. A better format specifier might have been `i`
    to match the language's use of `int`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数的格式说明符符号是`d`。对于初学者来说，这是不直观的。在这种特定情况下，`d`代表十进制，这是说*有符号整数*的另一种方式。更好的格式说明符可能是`i`，以匹配语言对`int`的使用。
- en: Contrast this with `std::cout`, which stands for character output. Although
    this is less intuitive compared to `print()` or `console()`, it is more intuitive
    than `printf()`. Furthermore, to output an integer to `stdout`, the user doesn't
    have to memorize a table of format specifiers to complete their task. Instead,
    they can simply use the `<<` operator. Then, the APIs handle formatting for you,
    which is not only more intuitive but also safer (especially when working with
    `std::cin` as opposed to `scanf()`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::cout`相比，它代表字符输出。虽然与`print()`或`console()`相比这不太直观，但比`printf()`更直观。此外，要将整数输出到`stdout`，用户不必记忆格式说明符表来完成任务。相反，他们可以简单地使用`<<`运算符。然后，API会为您处理格式，这不仅更直观，而且更安全（特别是在使用`std::cin`而不是`scanf()`时）。
- en: Example 5
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例5
- en: 'Example 5 demonstrates the principle of least surprise as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5演示了最少惊讶原则如下：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As shown in the preceding example, the `++` operators uphold the principle of
    least surprise. Although a beginner would have to learn that `++` represents the
    increment operator, which means the variable is incremented by `1`, the position
    of `++` with respect to the variable is quite helpful.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`++`运算符遵循最少惊讶原则。尽管初学者需要学习`++`代表递增运算符，意味着变量增加`1`，但`++`与变量的位置相当有帮助。
- en: To understand the difference between `++variable` and `variable++`, all the
    user has to do is read the code left to right as normal. When `++` is on the left,
    the variable is incremented and then the contents of the variable are returned.
    When `++` is on the right, the contents of the variable are returned and then
    the variable is incremented. The only issue with respect to the position of `++`
    is the fact that `++` on the left is generally more efficient (as the implementation
    doesn't require extra logic to store the value of the variable prior to the increment
    operation).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`++variable`和`variable++`之间的区别，用户只需像平常一样从左到右阅读代码。当`++`在左边时，变量被递增，然后返回变量的内容。当`++`在右边时，返回变量的内容，然后递增变量。关于`++`位置的唯一问题是，左边的`++`通常更有效率（因为实现不需要额外的逻辑来存储递增操作之前的变量值）。
- en: Example 6
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例6
- en: 'Example 6 demonstrates the principle of least surprise as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6演示了最少惊讶原则如下：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As shown in the preceding code, we have implemented two different APIs. The
    first adds two integers and returns the results while the second subtracts two
    integers and returns the results. The issue with the subtract function is two-fold:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们实现了两个不同的API。第一个是将两个整数相加并返回结果，而第二个是将两个整数相减并返回结果。减法函数的问题有两个：
- en: The addition function is in lowercase while the subtraction function is in uppercase.
    This is not intuitive and users of the APIs would have to learn which APIs are
    in lowercase and which are in uppercase.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法函数是小写的，而减法函数是大写的。这不直观，API的用户必须学习哪些API是小写的，哪些是大写的。
- en: The C++ standard APIs are all in snake case, meaning they leverage lowercase
    words with the use of `_` to denote a space. In general, it is better to design
    C++ library APIs with snake case as a beginner is more likely to find this intuitive.
    It should be noted that, although this is generally the case, the use of snake
    case is highly subjective and there are several languages that do not adhere to
    this guidance. The most important thing is to pick a convention and stick to it.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++标准API都是蛇形命名法，意思是它们利用小写单词并使用`_`来表示空格。一般来说，最好设计C++库API时使用蛇形命名法，因为初学者更有可能找到这种方式直观。值得注意的是，尽管这通常是这样，但蛇形命名法的使用是高度主观的，有几种语言不遵循这一指导。最重要的是选择一个约定并坚持下去。
- en: Once again, ensuring your APIs mimic existing semantics ensures the user can
    quickly and easily learn to use your APIs, while reducing the probability of the
    user writing your APIs incorrectly, leading to compile errors.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次确保您的API模仿现有语义，确保用户可以快速轻松地学会使用您的API，同时降低用户错误编写API的可能性，从而导致编译错误。
- en: Example 7
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例7
- en: 'Example 7 demonstrates the principle of least surprise as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7演示了最小惊讶原则的如下内容：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown in the preceding example, we are showing you how a `std::queue` can
    be used to add integers to a queue, output the queue to `stdout`, and remove elements
    from the queue. The point of this example is to highlight the fact that C++ already
    has a standard set of naming conventions that should be leveraged during C++ library
    development.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们向您展示了如何使用`std::queue`将整数添加到队列中，将队列输出到`stdout`，并从队列中删除元素。这个例子的重点是要突出C++已经有一套标准的命名约定，应该在C++库开发过程中加以利用。
- en: If you are designing a new library, it is helpful to the user of your library
    to use the same naming conventions that C++ has already defined. Doing so will
    lower the barrier to entry and provide a more intuitive API.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在设计一个新的库，使用C++已经定义的相同命名约定对您的库的用户是有帮助的。这样做将降低使用门槛，并提供更直观的API。
- en: Example 8
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例8
- en: 'Example 8 demonstrates the principle of least surprise as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例8演示了最小惊讶原则的如下内容：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As shown in the preceding example, we are demonstrating how the use of `auto`,
    which tells the compiler to figure out what the return type of the function is
    automatically, does not uphold the principle of least surprise. Although `auto`
    is extremely helpful for writing generic code, its use should be avoided as much
    as possible when designing a library API. Specifically, for the user of the API
    to understand what the inputs and outputs of the API are, the user must read the
    API's implementation as `auto` does not specify the output type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们展示了`auto`的使用方式，告诉编译器自动确定函数的返回类型，这不符合最小惊讶原则。尽管`auto`对于编写通用代码非常有帮助，但在设计库API时应尽量避免使用。特别是为了让API的用户理解API的输入和输出，用户必须阅读API的实现，因为`auto`不指定输出类型。
- en: Example 9
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例9
- en: 'Example 9 demonstrates the principle of least surprise as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9演示了最小惊讶原则的如下内容：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As shown in the preceding example, we are demonstrating a more appropriate way
    to uphold the principle of least surprise while simultaneously supporting generic
    programming. Generic programming (also called template meta-programming or programming
    with C++ templates) provides the programmer with a way to create an algorithm
    without stating the types that are being used in the algorithm. In this case,
    the `add` function doesn't dictate the input type, allowing the user to add two
    values of any type (in this case, the type is called `T`, which can take on any
    type that supports the `add` operator). Instead of returning an `auto`, which
    would not state the output type, we return a type `T`. Although `T` is not defined
    here as it represents any type, it does tell the user of the API that any type
    we input into this function will also be returned by the function. This same logic
    is used heavily in the C++ standard library.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们展示了一种更合适的方式来支持最小惊讶原则，同时支持通用编程。通用编程（也称为模板元编程或使用C++模板进行编程）为程序员提供了一种在不声明算法中使用的类型的情况下创建算法的方法。在这种情况下，`add`函数不会规定输入类型，允许用户添加任何类型的两个值（在这种情况下，类型称为`T`，可以采用支持`add`运算符的任何类型）。我们返回一个类型`T`，而不是返回`auto`，因为`auto`不会声明输出类型。尽管`T`在这里没有定义，因为它代表任何类型，但它告诉API的用户，我们输入到这个函数中的任何类型也将被函数返回。这种逻辑在C++标准库中大量使用。
- en: How to namespace everything
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何对一切进行命名空间
- en: When creating a library, it is important to namespace everything. Doing so ensures
    that of the APIs provided by the library cause name collisions with the user's
    code or with facilities provided by other libraries. In this recipe, we will demonstrate
    how to do this in our own libraries.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建库时，对一切进行命名空间是很重要的。这样做可以确保库提供的API不会与用户代码或其他库提供的设施发生名称冲突。在本示例中，我们将演示如何在我们自己的库中做到这一点。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As with all of the recipes in this chapter, ensure that all of the technical
    requirements have been met, including installing Ubuntu 18.04 or higher and running
    the following in a Terminal window:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的所有示例一样，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you have done this, open a new Terminal. We
    will use this Terminal to download, compile, and run our examples.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to complete this recipe:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本文，您需要执行以下步骤：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中，运行以下命令下载源代码：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To compile the source code, run the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下代码：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码被编译，您可以通过运行以下命令来执行本文中的每个示例：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本文所教授的课程的关系。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: C++ provides us with the ability to wrap code in a `namespace`, which simply
    adds the `namespace` name to all functions and variables inside the `namespace`
    code (it should be noted that C style macros are not included in the `namespace`
    and should be used with care because C macros are a preprocessor feature that
    does not contribute to the code's compiled syntax). To explain why we should `namespace`
    everything when creating our own libraries, we'll look at some examples.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了将代码包裹在`namespace`中的能力，这简单地将`namespace`名称添加到`namespace`代码中的所有函数和变量（应该注意的是，C风格的宏不包括在`namespace`中，并且应该谨慎使用，因为C宏是预处理器功能，不会对代码的编译语法产生影响）。为了解释为什么我们在创建自己的库时应该将所有东西都放在`namespace`中，我们将看一些例子。
- en: Example 1
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例1
- en: 'Example 1 demonstrates how to wrap your library''s APIs in a C++ `namespace`
    :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1演示了如何在C++`namespace`中包裹库的API：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As shown in the preceding example, the contents of the library are wrapped in
    a `namespace` and stored in the header (this example demonstrates a header-only
    library, which is an extremely useful design approach as the end user doesn't
    have to compile libraries, install them on his/her system, and then link against
    them). The library user simply includes the library header file and uses the `using
    namespace library_name` statement to unwrap the library's APIs. If the user has
    more than one library with the same API names, this statement can be omitted to
    remove any ambiguity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如上例所示，库的内容被包裹在一个`namespace`中，并存储在头文件中（这个例子演示了一个头文件库，这是一种非常有用的设计方法，因为最终用户不需要编译库，将其安装在他/她的系统上，然后链接到它们）。库用户只需包含库头文件，并使用`using
    namespace library_name`语句来解开库的API。如果用户有多个具有相同API名称的库，可以省略此语句以消除任何歧义。
- en: Example 2
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例2
- en: 'Example 2 expands upon the previous example and demonstrates how to wrap your
    library''s APIs in a C++ namespace header-only library while still including global
    variables:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2扩展了上一个示例，并演示了如何在C++命名空间头文件库中包裹库的API，同时包括全局变量：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As shown in the preceding example, C++17 was leveraged to create an `inline`
    global variable that is wrapped in our library's `namespace`. `inline` variables
    are needed as header-only libraries don't have a source file to define global
    variables; without the `inline` keyword, defining a global variable in a header
    would result in the variable being defined multiple times (that is, the result
    would be a linking error during compilation). C++17 resolved this issue by adding
    `inline` global variables, which allows a header-only library to define global
    variables without the need for tricky magic (such as returning a pointer to a
    static variable from a singleton style function).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，利用C++17创建了一个包裹在我们库的`namespace`中的`inline`全局变量。`inline`变量是必需的，因为头文件库没有源文件来定义全局变量；没有`inline`关键字，在头文件中定义全局变量会导致变量被多次定义（也就是说，在编译过程中会出现链接错误）。C++17通过添加`inline`全局变量解决了这个问题，这允许头文件库定义全局变量而无需使用tricky
    magic（比如从单例样式函数返回静态变量的指针）。
- en: In addition to the library's `namespace` , we wrapped the global variable in
    a `details namespace`. This is done to create a `private` place within your library
    in case the user of the library declares `using namespace library_name`. If the
    user does this, all of the APIs and variables that are wrapped by the `library_name`
    namespace become globally accessible within the scope of the `main()` function.
    For this reason, any private APIs or variables that are not meant to be accessible
    by the user should be wrapped by a second `namespace` (typically called `details`)
    to prevent their global accessibility. Finally, leveraging C++17's `inline` keyword
    allows us to create a global variable for use in our library while still supporting
    a header-only design.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了库的`namespace`，我们还将全局变量包裹在`details namespace`中。这是为了在库的用户声明`using namespace
    library_name`的情况下，在库内创建一个`private`的地方。如果用户这样做，所有被`library_name`命名空间包裹的API和变量都会在`main()`函数的范围内变得全局可访问。因此，任何不希望用户访问的私有API或变量都应该被第二个`namespace`（通常称为`details`）包裹起来，以防止它们的全局可访问性。最后，利用C++17的`inline`关键字允许我们在库中创建全局变量，同时仍然支持头文件库的设计。
- en: Header-only libraries
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头文件库
- en: Header-only libraries are exactly as they sound; an entire library is implemented
    using header files (usually a single header file). The benefit of header-only
    libraries is that they are easy to include in your project as you simply include
    the header and you are done (there is no need to compile the library as there
    are no source files to compile). In this recipe, we will learn about some issues
    that arise when attempting to create a header-only library and how to overcome
    them. This recipe is important because, if you plan to create your own library,
    a header-only library is a great place to start and will likely increase your
    adoption rates as downstream users will have less trouble integrating your library
    into their code base.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件库就像它们的名字一样；整个库都是使用头文件实现的（通常是一个头文件）。头文件库的好处在于，它们很容易包含到您的项目中，只需包含头文件即可（不需要编译库，因为没有需要编译的源文件）。在本配方中，我们将学习在尝试创建头文件库时出现的一些问题以及如何克服这些问题。这个配方很重要，因为如果您计划创建自己的库，头文件库是一个很好的起点，并且可能会增加您的库被下游用户整合到他们的代码库中的几率。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As with all of the recipes in this chapter, ensure that all of the technical
    requirements have been met, including installing Ubuntu 18.04 or higher and running
    the following in a Terminal window:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的所有配方一样，请确保已满足所有技术要求，包括安装 Ubuntu 18.04 或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you have done this, open a new Terminal. We
    will use this Terminal to download, compile, and run our examples.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本配方中的示例。完成这些步骤后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'You need to perform the following steps to complete this recipe:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此配方，您需要执行以下步骤：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中，运行以下命令以下载源代码：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To compile the source code, run the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下代码：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令执行本配方中的每个示例：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它们与本配方中所教授的课程的关系。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To create a header-only library, simply ensure that all of your code is implemented
    in header files, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个头文件库，只需确保所有代码都在头文件中实现，如下所示：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding example implements a simple library with a single function. The
    entire implementation of this library can be implemented in a single header file
    and included in our code as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例实现了一个简单的库，其中有一个函数。这个库的整个实现可以在一个头文件中实现，并包含在我们的代码中，如下所示：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although creating header-only libraries seems simple enough, there are some
    issues that arise when attempting to create a header-only library that should
    be taken into account.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管创建头文件库似乎很简单，但在尝试创建头文件库时会出现一些问题，这些问题应该考虑在内。
- en: How to handle includes
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何处理包含
- en: In the preceding example, you might have noticed that, when we used our custom
    header-only library, we included the library first. This is an essential first
    step to writing a header-only library. When writing examples or tests for header-only
    libraries, our library should be the first thing we include to ensure that all
    of the header's dependencies are defined in the header-only library and not in
    our example or test.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您可能已经注意到，当我们使用我们的自定义头文件库时，我们首先包含了库。这是编写头文件库的一个基本步骤。在为头文件库编写示例或测试时，我们的库应该是我们包含的第一件事，以确保所有头文件的依赖关系都在头文件库中定义，而不是在我们的示例或测试中定义。
- en: 'For example, suppose we change our library as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们将我们的库更改如下：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As shown in the preceding code snippet, instead of returning an integer our
    API now outputs to `stdout`. We can use our new API as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们的 API 现在不再返回整数，而是输出到 `stdout`。我们可以如下使用我们的新 API：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Although the preceding code compiles and runs as expected, there is a bug in
    the code that would likely only be identified by the user of your library. Specifically,
    if the user of your library swaps the order of the includes or doesn''t `#include
    <iostream>`, the code will fail to compile and produce the following error:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的代码编译和运行如预期，但代码中存在一个错误，这个错误可能只有您的库的用户才能识别出来。具体来说，如果您的库的用户交换了包含的顺序或者没有`#include
    <iostream>`，代码将无法编译并产生以下错误：
- en: '![](img/14a94075-f946-458b-aa5c-a4bfd158978a.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14a94075-f946-458b-aa5c-a4bfd158978a.png)'
- en: This is because the header-only library itself doesn't include all of its dependencies.
    Since our example put the library after other includes, our example accidentally
    hides this issue. For this reason, when creating your own header-only library,
    always include the library first in your tests and examples to ensure this type
    of issue never happens to your users.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为头文件库本身没有包含所有的依赖关系。由于我们的示例将库放在其他包含之后，我们的示例意外地隐藏了这个问题。因此，当创建自己的头文件库时，始终在测试和示例中首先包含库，以确保这种类型的问题永远不会发生在您的用户身上。
- en: Global variables
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'One of the biggest limitations with header-only libraries is that, prior to
    C++17, there was no way to create global variables. Although global variables
    should be avoided whenever possible, there are situations where they are needed.
    To demonstrate this, let''s create a simple API that outputs to `stdout` as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件库的最大限制之一是，在 C++17 之前，没有办法创建全局变量。尽管应尽量避免使用全局变量，但有些情况下是必需的。为了演示这一点，让我们创建一个简单的
    API，输出到 `stdout` 如下：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding example creates an API that will output to `stdout`. If the API
    is executed with `true` instead of the default `false`, it will output integers
    in hexadecimal instead of decimal format. In this example, the change from decimal
    to hexadecimal is really a configuration setting in our library. Without global
    variables, however, we would have to resort to other mechanisms to make this work,
    including macros or, in the preceding example, function parameters; the latter
    choice is even worse as it couples the configuration of the library to its API,
    which means any additional configuration options would alter the API itself.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例创建了一个API，将输出到`stdout`。如果使用`true`而不是默认的`false`执行API，则将以十六进制而不是十进制格式输出整数。在这个例子中，从十进制到十六进制的转换实际上是我们库中的一个配置设置。然而，如果没有全局变量，我们将不得不采用其他机制来实现这一点，包括宏或前面的示例中的函数参数；后者选择甚至更糟，因为它将库的配置与其API耦合在一起，这意味着任何额外的配置选项都会改变API本身。
- en: 'One of the best ways to address this is to use global variables in C++17, as
    follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最佳方法之一是在C++17中使用全局变量，如下所示：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As shown in the preceding example, we added a new namespace to our library
    called `config`. Our API no longer needs any parameters and determines how to
    function based on an inline global variable instead. Now, we can use this API
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们在库中添加了一个名为`config`的新命名空间。我们的API不再需要任何参数，并根据内联全局变量确定如何运行。现在，我们可以按以下方式使用此API：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The results in the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出的结果：
- en: '![](img/2abe9bca-2a0e-4075-a8f8-e5fa3140663e.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2abe9bca-2a0e-4075-a8f8-e5fa3140663e.png)'
- en: It should be noted that we placed the configuration setting in a `config` namespace
    to ensure that our library's namespace isn't polluted with name collisions, which
    ultimately ensures that the intent of the global variable is obvious.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们将配置设置放在`config`命名空间中，以确保我们的库命名空间不会因名称冲突而被污染，从而确保全局变量的意图是明显的。
- en: Issues with C-style macros
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C风格宏的问题
- en: 'The biggest issue with C-style macros is that, if you place them in a C++ namespace,
    their name is not decorated by the namespace. This means that macros always pollute
    the global namespace. For example, suppose you are writing a library that needs
    to check the value of a variable, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: C风格宏的最大问题在于，如果将它们放在C++命名空间中，它们的名称不会被命名空间修饰。这意味着宏总是污染全局命名空间。例如，假设您正在编写一个需要检查变量值的库，如下所示：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As shown in the preceding code snippet, we have created a simple API that uses
    a C-style macro to check an integer value in its implementation. The problem with
    the preceding example is that, if you attempt to use a unit test library with
    your own library, you will likely end up with a namespace collision.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们创建了一个简单的API，它在实现中使用了C风格的宏来检查整数值。前面示例的问题在于，如果您尝试在自己的库中使用单元测试库，很可能会遇到命名空间冲突。
- en: C++20 could fix this using C++20 modules and is a topic we will discuss in more
    detail in [Chapter 13](69ea92ce-8503-4c3f-95c7-9733bd86d039.xhtml), *Bonus – Using
    C++20 Features*. Specifically, C++20 modules do not expose C-style macros to the
    user of the library. The positive side of this is you will be able to use macros
    without namespace issues as your macros will not be exposed to the user. The downside
    to this approach is that a lot of library authors use C-style macros to configure
    a library (for example, they define a macro prior to including the library to
    change its default behavior). This type of library configuration will not work
    with C++ modules unless the macros are defined on the command line when the library
    is compiled.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: C++20可以通过使用C++20模块来解决这个问题，并且这是我们将在[第13章](69ea92ce-8503-4c3f-95c7-9733bd86d039.xhtml)中更详细讨论的一个主题，*奖励-使用C++20功能*。具体来说，C++20模块不会向库的用户公开C风格的宏。这样做的积极方面是，您将能够使用宏而不会出现命名空间问题，因为您的宏不会暴露给用户。这种方法的缺点是，许多库作者使用C风格的宏来配置库（例如，在包含库之前定义宏以更改其默认行为）。这种类型的库配置在C++模块中将无法工作，除非在编译库时在命令行上定义了这些宏。
- en: 'Until C++20 is available, if you need to use macros make sure you manually
    add decorations to the macro names, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 直到C++20可用，如果需要使用宏，请确保手动向宏名称添加修饰，如下所示：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding line of code would do the same thing as having the macro were
    inside the C++ namespace, ensuring your macro doesn't collide with macros from
    other libraries or macros the user might define.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行将执行与宏位于C++命名空间内相同的操作，确保您的宏不会与其他库的宏或用户可能定义的宏发生冲突。
- en: How to implement a large library as header-only
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将大型库实现为仅头文件
- en: Ideally, a header-only library is implemented using a single header. That is,
    the user only has to copy a single header to their source code to use the library.
    The problem with this approach is that, for really big projects, a single header
    can get really large. A great example of this is a popular JSON library for C++
    located here: [https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp](https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，头文件库应使用单个头文件实现。也就是说，用户只需将单个头文件复制到其源代码中即可使用该库。这种方法的问题在于，对于非常大的项目，单个头文件可能会变得非常庞大。一个很好的例子是C++中一个流行的JSON库，位于此处：[https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp](https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp)。
- en: At the time of writing, the preceding library is more than 22,000 lines of code.
    Attempting to make modifications to a file that is 22,000 lines of code would
    be awful (if your editor could even handle it). Some projects overcome this problem
    by implementing their header-only library using several header files with a single
    header file that includes the individual header files as needed (for example,
    Microsoft's Guideline Support Library for C++ is implemented this way). The problem
    with this approach is that the user must copy and maintain multiple header files,
    which starts to defeat the purpose of a header-only library as its complexity
    increases.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，上述库的代码行数超过22,000行。尝试对一个有22,000行代码的文件进行修改将是非常糟糕的（即使您的编辑器能够处理）。一些项目通过使用多个头文件实现其仅包含头文件库，并使用单个头文件根据需要包含各个头文件来解决这个问题（例如，Microsoft的C++指南支持库就是这样实现的）。这种方法的问题在于用户必须复制和维护多个头文件，随着复杂性的增加，这开始破坏头文件库的目的。
- en: 'Another way to handle this problem is to use something such as CMake to autogenerate
    a single header file from multiple header files. For example, in the following,
    we have a header-only library with the following headers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种处理这个问题的方法是使用诸如CMake之类的工具从多个头文件中自动生成单个头文件。例如，在下面的示例中，我们有一个仅包含头文件的库，其中包含以下头文件：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As shown in the preceding code snippet, this is the same as our configuration
    example, with the exception that the configuration portion of the example has
    been replaced with an include to a `config.h` file. We can create this second
    header file as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，这与我们的配置示例相同，唯一的区别是示例的配置部分已被替换为对`config.h`文件的包含。我们可以按照以下方式创建这个第二个头文件：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This implements the remaining portion of the example. In other words, we have
    split our header into two headers. We can still use our headers as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了示例的剩余部分。换句话说，我们已经将我们的头文件分成了两个头文件。我们仍然可以像下面这样使用我们的头文件：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, the problem is that users of our library would need a copy of both
    headers. To remove this problem, we need to autogenerate a header file. There
    are many ways to do this, but the following is one way to do so with CMake:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题在于我们的库的用户需要拥有两个头文件的副本。为了解决这个问题，我们需要自动生成一个头文件。有许多方法可以做到这一点，但以下是使用CMake的一种方法：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code reads both headers into CMake variables using the `file()`
    function. This function converts each variable into a CMake list of strings (each
    string is a line in the file). Then, we combine both files into a single list.
    To create our new, autogenerated single header file, we loop through the list
    and write each line to a new header called `my_library_single.h`. Finally, if
    we see a reference to a local include, we comment it out to ensure that there
    are no references to our additional headers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用`file()`函数将两个头文件读入CMake变量。这个函数将每个变量转换为CMake字符串列表（每个字符串是文件中的一行）。然后，我们将两个文件合并成一个列表。为了创建我们的新的自动生成的单个头文件，我们遍历列表，并将每一行写入一个名为`my_library_single.h`的新头文件。最后，如果我们看到对本地包含的引用，我们将其注释掉，以确保没有引用我们的额外头文件。
- en: 'Now, we can use our new single header file as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像下面这样使用我们的新单个头文件：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using the preceding method, we can develop our library using as many includes
    as we like and our build system can autogenerate our single header file, which
    will be used by the end user, giving us the best of both worlds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述方法，我们可以开发我们的库，使用尽可能多的包含，并且我们的构建系统可以自动生成我们的单个头文件，这将被最终用户使用，为我们提供了最好的两全其美。
- en: Learning library development best practices
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习库开发最佳实践
- en: When writing your own library, there are certain best practices that all library
    authors should adhere to. In this recipe, we will explore some higher-priority
    best practices and conclude with some information about a project dedicated to
    defining these best practices, including a registration system that provides your
    library with a grade as to how well it compiles. This recipe is important as it
    will teach you how to make the highest-quality library, ensuring a strong and
    vibrant user base.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写自己的库时，所有库作者都应该遵循某些最佳实践。在本教程中，我们将探讨一些优先级较高的最佳实践，并总结一些关于一个专门定义这些最佳实践的项目的信息，包括一个注册系统，为您的库提供编译的评分。这个教程很重要，因为它将教会您如何制作最高质量的库，确保强大和充满活力的用户群体。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As with all of the recipes in this chapter, ensure that all of the technical
    requirements have been met, including installing Ubuntu 18.04 or higher and running
    the following in a Terminal window:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的所有示例一样，请确保所有技术要求都已满足，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you have done this, open a new Terminal. We
    will use this Terminal to download, compile, and run our examples.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to complete this recipe:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来完成本教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To compile the source code, run the following code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下代码：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码被编译，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Every library author should ensure their library is easy to use and incorporate
    into their users' own projects. Doing so will ensure your users continue to use
    your library, resulting in a growing user base over time. Let's look at a few
    of these best practices.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图书馆的作者都应该确保他们的图书馆易于使用并且可以整合到用户自己的项目中。这样做将确保您的用户继续使用您的图书馆，从而导致用户群随着时间的推移不断增长。让我们来看看其中一些最佳实践。
- en: What about warnings?
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警告呢？
- en: 'The lowest possible hanging fruit for any library author is ensuring your code
    compiles with as many warnings enabled as possible. Sadly, GCC does not make this
    process simple as there is no one warning flag to rule them all, specifically
    because GCC has many warning flags that are not useful for modern versions of
    C++ (in other words, they are, in a sense, mutually exclusive). The best place
    to start is with the following warnings:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 任何图书馆作者的最低挂果是确保您的代码尽可能多地编译。遗憾的是，GCC并没有简化这个过程，因为没有一个警告标志可以统治所有警告，特别是因为GCC有许多对于现代C
    ++版本来说并不有用的警告标志（换句话说，它们在某种程度上是相互排斥的）。开始的最佳地方是以下警告：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This turns on most of the important warnings while ensuring that any warnings
    that your examples or tests compile will generate an error. For some libraries,
    however, this will not be enough. At the time of writing, the following are the
    flags that Microsoft''s Guideline Support Library uses:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开大部分重要的警告，同时确保您的示例或测试编译时生成错误的任何警告。然而，对于一些库来说，这还不够。在撰写本文时，微软的指南支持库使用以下标志：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: One additional warning that the GSL uses is conversion warnings, which will
    tell you when you convert between different integer types. If you are using Clang,
    this process can be a lot easier as it provides `-Weverything`. If weeding through
    all of the warnings that GCC provides is too much work, one approach to solving
    this issue is to make sure that your library compiles with the Clang compiler
    with this warning turned on, which will ensure your code compiles with most of
    the warnings that GCC provides. This way, your users will not have trouble with
    your library when they have to ensure specific warnings are enabled in their code
    as you will have tested as many of them as possible.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: GSL使用的另一个警告是转换警告，它会在您在不同的整数类型之间转换时告诉您。如果您使用Clang，这个过程可能会更容易，因为它提供了`-Weverything`。如果筛选GCC提供的所有警告太麻烦，解决这个问题的一种方法是确保您的库在打开此警告的情况下与Clang编译器编译，这将确保您的代码与GCC提供的大部分警告一起编译。这样，当用户必须确保他们的代码中启用了特定警告时，您的用户在使用您的库时就不会遇到麻烦，因为您已经尽可能地测试了其中的许多。
- en: Static and dynamic analysis
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态和动态分析
- en: In addition to testing for warnings, libraries should also be tested with static
    and dynamic analysis tools. Once again, as an author of a library, you must assume
    your users might use static and dynamic analysis tools to shore up the quality
    of their own applications. If your library triggers these tools, your users are
    more likely to look for alternatives that have been tested more thoroughly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试警告之外，库还应该使用静态和动态分析工具进行测试。再次强调，作为图书馆的作者，您必须假设您的用户可能会使用静态和动态分析工具来加强他们自己应用程序的质量。如果您的库触发了这些工具，您的用户更有可能寻找经过更彻底测试的替代方案。
- en: 'For C++, there is a large number of tools that can be used to analyze your
    libraries. In this recipe, we will focus on Clang Tidy and Valgrind, which are
    both free to use. Let''s look at the following simple example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C ++，有大量工具可用于分析您的库。在本教程中，我们将专注于Clang Tidy和Valgrind，它们都是免费使用的。让我们看看以下简单的例子：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding example, we created a function called `universe()` that returns
    an integer and allocates an integer. In our main function, our `universe()` function
    output the results to `stdout`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个名为`universe()`的函数，它返回一个整数并分配一个整数。在我们的主函数中，我们的`universe()`函数将结果输出到`stdout`。
- en: 'To statically analyze the preceding code, we can use CMake as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要对前面的代码进行静态分析，我们可以使用CMake，如下所示：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding line of code tells CMake to use `clang-tidy` when compiling the
    preceding example. When we compile the code, we get the following result:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码告诉CMake在编译前面的示例时使用`clang-tidy`。当我们编译代码时，我们得到以下结果：
- en: '![](img/90475cde-2dd5-45e5-a2fe-e2a0ed81b304.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90475cde-2dd5-45e5-a2fe-e2a0ed81b304.png)'
- en: If a user of your library has turned on static analysis using Clang Tidy, this
    is the error they might receive, even though their code is perfectly fine. If
    you are using someone else's library and run into this issue, one way to overcome
    the problem is to include the library as a system include, which tells tools such
    as Clang Tidy to ignore these errors. This, however, doesn't always work as some
    libraries require the use of macros, which expose the library's logic to your
    own code, resulting in chaos. In general, if you are a library developer, statically
    analyze your library as much as you can afford to as you don't know how your users
    might use your library.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的库的用户已经打开了使用Clang Tidy进行静态分析，这可能是他们会收到的错误，即使他们的代码完全正常。如果您正在使用别人的库并遇到了这个问题，克服这个问题的一种方法是将库包含为系统包含，这告诉Clang
    Tidy等工具忽略这些错误。然而，这并不总是有效，因为有些库需要使用宏，这会将库的逻辑暴露给您自己的代码，导致混乱。一般来说，如果您是库开发人员，尽可能多地对您的库进行静态分析，因为您不知道您的用户可能如何使用您的库。
- en: 'The same goes for dynamic analysis. The preceding analysis didn''t detect the
    obvious memory leak. To identify this, we can use `valgrind`, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析也是一样。前面的分析没有检测到明显的内存泄漏。为了识别这一点，我们可以使用`valgrind`，如下所示：
- en: '![](img/e501ffa7-bfb7-46d1-b2e1-38630c9e0921.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e501ffa7-bfb7-46d1-b2e1-38630c9e0921.png)'
- en: As shown in the preceding screenshot, `valgrind` is able to detect the memory
    leak in our code. Actually, `valgrind` also detects the fact that we never initialize
    our temporary variable in the `universe()` function, but the output is far too
    verbose to show here. Once again, if you fail to identify these types of problem
    with your libraries, you will end up exposing these bugs to your users.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，`valgrind`能够检测到我们代码中的内存泄漏。实际上，`valgrind`还检测到我们在`universe()`函数中从未初始化临时变量的事实，但输出内容过于冗长，无法在此展示。再次强调，如果你未能识别出这些类型的问题，你最终会暴露这些错误给你的用户。
- en: Documentation
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: Documentation is an absolute must for any good library. Besides buggy code,
    a lack of documentation will absolutely prevent others from using your library.
    Libraries should be easy to set up and install, and even easier to learn and incorporate
    into your own applications. One of the most frustrating aspects of using existing
    C++ libraries is the lack of documentation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 文档对于任何良好的库来说都是绝对必要的。除了有bug的代码，缺乏文档也会绝对阻止其他人使用你的库。库应该易于设置和安装，甚至更容易学习和融入到你自己的应用程序中。使用现有的C++库最令人沮丧的一点就是缺乏文档。
- en: CII Best Practices
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CII最佳实践
- en: In this recipe, we have touched on a couple of common best practices that all
    library developers should incorporate into their projects. In addition to these
    best practices, a more complete list of best practices is provided by the CII
    Best Practices program here: [https://bestpractices.coreinfrastructure.org/en](https://bestpractices.coreinfrastructure.org/en).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们涉及了一些所有库开发者都应该在其项目中应用的常见最佳实践。除了这些最佳实践，CII最佳实践项目在这里提供了更完整的最佳实践清单：[https://bestpractices.coreinfrastructure.org/en](https://bestpractices.coreinfrastructure.org/en)。
- en: The CII Best Practices program provides a comprehensive list of best practices
    that are updated over time and that library developers (and any application in
    general) can leverage. These best practices are grouped into passing, silver,
    and gold, with the gold practices being the hardest to achieve. The higher your
    score, the more likely users are to use your library as it shows commitment and
    stability.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: CII最佳实践项目提供了一个全面的最佳实践清单，随着时间的推移进行更新，库开发者（以及一般的应用程序）可以利用这些最佳实践。这些最佳实践分为通过、银和金三个级别，金级实践是最难实现的。你的得分越高，用户使用你的库的可能性就越大，因为这显示了承诺和稳定性。
- en: Learning how to use the boost APIs
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用boost API
- en: The boost libraries are a set of libraries designed to work in conjunction with
    the standard C++ libraries. In fact, a lot of the libraries that are currently
    being provided by C++ originated from the boost libraries. The boost libraries
    provide everything from containers, clocks, and timers to more complicated mathematical
    APIs such as graphs and CRC calculations. In this recipe, we will learn how to
    use the boost libraries, specifically to demonstrate what a large library looks
    like and how such a library would be included in a user's project. This recipe
    is important as it will demonstrate just how complicated a library can get, teaching
    you how to write your own libraries accordingly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: boost库是一组设计用于与标准C++库配合使用的库。事实上，目前由C++提供的许多库都起源于boost库。boost库提供了从容器、时钟和定时器到更复杂的数学API，如图形和CRC计算等一切。在这个示例中，我们将学习如何使用boost库，特别是演示一个大型库的样子以及如何将这样的库包含在用户的项目中。这个示例很重要，因为它将演示一个库可以变得多么复杂，教会你如何相应地编写你自己的库。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As with all of the recipes in this chapter, ensure that all of the technical
    requirements have been met, including installing Ubuntu 18.04 or higher and running
    the following in a Terminal window:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的所有示例一样，请确保已满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once you have done this, open a new Terminal. We
    will use this Terminal to download, compile, and run our examples.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保你的操作系统具有编译和执行本教程中示例所需的正确工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'You need to perform the following steps to complete this recipe:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要执行以下步骤来完成这个示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To compile the source code, run the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下代码：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，你可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将逐个介绍这些例子，并解释每个示例程序的作用，以及它们与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The boost libraries provide a set of user APIs that implement commonly needed
    functionality in most programs. These libraries can be included in your own projects
    to simplify your code and provide an example of what a finished library might
    look like. To explain how your own libraries could be leveraged by others, let's
    look at some examples of how to use the boost libraries.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: boost库提供了一组用户API，实现了大多数程序中常用的功能。这些库可以包含在你自己的项目中，简化你的代码，并提供一个完成的库可能是什么样子的示例。为了解释你自己的库如何被他人利用，让我们看一些如何使用boost库的示例。
- en: Example 1
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 例子1
- en: 'In this example, we are using the boost APIs to output the current date and
    time to `stdout`, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用boost API将当前日期和时间输出到`stdout`，如下所示：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As shown in the preceding example, the current date and time are outputted
    to `stdout` as the total number of nanoseconds since the Unix Epoch (January 1,
    1970). In addition to including boost in your source code, you must also link
    your application against the boost libraries. In this case, we needed to link
    against the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，当前日期和时间以自Unix纪元（1970年1月1日）以来的纳秒总数的形式被输出到`stdout`。除了在源代码中包含boost，你还必须将你的应用程序链接到boost库。在这种情况下，我们需要链接到以下内容：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: An example of how this is done can be seen in the `CMakeLists.txt` file that
    was downloaded with this recipe. Once these libraries have been linked to your
    project, your code will be able to leverage the APIs inside them. This extra step
    is why header-only libraries can be so useful when creating your own libraries
    as they obviate the need for additional linking.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如何完成这一步骤的示例可以在随这个示例一起下载的`CMakeLists.txt`文件中看到。一旦这些库被链接到你的项目中，你的代码就能够利用它们内部的API。这个额外的步骤就是为什么仅包含头文件的库在创建自己的库时可以如此有用，因为它们消除了额外链接的需要。
- en: Example 2
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例2
- en: 'In this example, we''re demonstrating how to log to the console using boost''s
    trivial logging APIs, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们演示了如何使用boost的trivial logging APIs来记录到控制台，如下所示：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As shown in the preceding example, the `"debug message"` and `"info message"` messages
    were outputted to `stdout`. In addition to linking against the proper boost libraries,
    we also had to include the following definition during compilation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`"debug message"`和`"info message"`消息被输出到`stdout`。除了链接正确的boost库，我们还必须在编译过程中包含以下定义：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Once again, linking these libraries ensures that the APIs you are using in your
    code (as shown in the preceding example) exist in the executable.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，链接这些库可以确保你在代码中使用的API（如前面的示例所示）存在于可执行文件中。
- en: See also
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on the boost libraries, please check out [https://www.boost.org/](https://www.boost.org/).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有关boost库的更多信息，请查看[https://www.boost.org/](https://www.boost.org/)。
