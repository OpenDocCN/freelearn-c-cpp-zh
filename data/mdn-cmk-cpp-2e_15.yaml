- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Creating Your Professional Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的专业项目
- en: We have gathered all the necessary knowledge to build professional projects,
    including structuring, building, dependency management, testing, analyzing, installing,
    and packaging. Now, it’s time to apply these skills by creating a coherent, professional
    project. It’s important to understand that even trivial programs benefit from
    automated quality checks and a seamless process that transforms raw code into
    a complete solution. It’s true that implementing these checks and processes is
    a significant investment, as it requires many steps to set up everything correctly.
    This is especially true when adding these mechanisms to existing code bases, which
    are often large and complex. That’s why it’s beneficial to use CMake from the
    start and establish all the necessary processes early on. It’s easier to configure
    and more efficient, as such quality controls and build automation will eventually
    need to be integrated into long-term projects anyway.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经掌握了构建专业项目所需的所有知识，包括结构化、构建、依赖管理、测试、分析、安装和打包。现在，是时候通过创建一个连贯的专业项目来应用这些技能了。重要的是要理解，即使是微不足道的程序也能从自动化质量检查和将原始代码转化为完整解决方案的无缝流程中受益。的确，实现这些检查和流程是一个重要的投资，因为它需要许多步骤才能正确设置一切。尤其是将这些机制添加到现有的代码库时，这些代码库通常庞大而复杂。这就是为什么从一开始就使用
    CMake 并尽早建立所有必要的流程是有益的。这样配置起来更简单，也更高效，因为这些质量控制和构建自动化最终需要集成到长期项目中。
- en: In this chapter, we will develop a new solution that is as small as possible,
    while making the most of the CMake practices we discussed in the book so far.
    To keep it simple, we will implement only a single practical function – adding
    two numbers. Such basic business code will allow us to focus on the build-related
    aspects of the project we learned in previous chapters. To tackle a more challenging
    problem related to building, this project will include both a library and an executable.
    The library will handle the internal business logic and be available as a CMake
    package for other projects. The executable, intended for end users, will provide
    a user interface demonstrating the library’s functionality.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个尽可能小的解决方案，同时充分利用我们到目前为止在本书中讨论的 CMake 实践。为了保持简单，我们将只实现一个实际的功能——两个数字相加。这样的基础业务代码将使我们能够专注于前几章中学习的与构建相关的项目方面。为了处理一个与构建相关的更具挑战性的问题，项目将同时包含一个库和一个可执行文件。库将处理内部业务逻辑，并作为
    CMake 包可供其他项目使用。可执行文件面向最终用户，将提供一个演示库功能的用户界面。
- en: 'To sum that up, in this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本章中，我们将涵盖以下主要内容：
- en: Planning our work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划我们的工作
- en: Project layout
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目布局
- en: Building and managing dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和管理依赖
- en: Testing and program analysis
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与程序分析
- en: Installing and packaging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装与打包
- en: Providing the documentation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供文档
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch15](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch15).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章中的代码文件，地址为 [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch15](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch15)。
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，请始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace the placeholders `<build tree>` and `<source tree>` with
    appropriate paths. As a reminder: the **build tree** is the path to the target/output
    directory, and the **source tree** is the path at which your source code is located.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符 `<build tree>` 和 `<source tree>` 替换为适当的路径。提醒一下：**构建树**是目标/输出目录的路径，**源代码树**是源代码所在的路径。
- en: This chapter is compiled with GCC to provide compatibility between code coverage
    instrumentation with the `lcov` tool used to collect the results. If you want
    to compile with `llvm` or another toolchain, be sure to adapt the coverage processing
    as needed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用 GCC 编译，以便与用于收集结果的 `lcov` 工具的代码覆盖率仪器兼容。如果你想使用 `llvm` 或其他工具链进行编译，请确保根据需要调整覆盖率处理。
- en: 'To run tests, execute the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，执行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or simply execute it from the build tree directory:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者直接从构建树目录执行：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that, in this chapter, the tests will be outputted to the `test` subdirectory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本章中，测试结果将输出到 `test` 子目录。
- en: Planning our work
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划我们的工作
- en: The software we’ll be building in this chapter isn’t meant to be extremely complex
    – we’ll create a simple calculator that adds two numbers together (*Figure 15.1*).
    It will be a console application with a text user interface, utilizing a third-party
    library and a separate calculation library that could be used in other projects.
    Although this project may not have significant practical applications, its simplicity
    is perfect for demonstrating the application of various techniques discussed throughout
    the book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将构建的软件并不打算过于复杂——我们将创建一个简单的计算器，能够将两个数字相加（*图 15.1*）。它将是一个控制台应用程序，采用文本用户界面，利用第三方库和一个独立的计算库，后者可以在其他项目中使用。尽管这个项目可能没有重大实际应用，但它的简洁性非常适合展示本书中讨论的各种技术的应用。
- en: '![](img/B19844_15_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_15_01.png)'
- en: 'Figure 15.1: The text user interface of our project executed in a terminal
    with mouse support'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1：在终端中执行的我们的项目的文本用户界面，支持鼠标操作
- en: Usually, projects either generate a user-facing executable or a library for
    developers. It’s less common for projects to produce both, though it does happen.
    For instance, some applications come with standalone SDKs or libraries to help
    develop plugins. Another example is a library bundled with usage examples. Our
    project falls into the latter category, showcasing the library’s functionalities.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，项目要么生成面向用户的可执行文件，要么生成供开发者使用的库。项目同时生成这两者的情况比较少见，尽管也会发生。例如，一些应用程序会附带独立的SDK或库，帮助开发插件。另一个例子是一个包含使用示例的库。我们的项目属于后一类，展示了该库的功能。
- en: 'We’ll start planning by reviewing the chapter list, recalling the contents
    of each chapter, and selecting the techniques and tools described that we’ll use
    to build our application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过回顾章节列表、回想每个章节的内容，并选择我们将用于构建应用程序的技术和工具来开始规划：
- en: '*Chapter 1*, *First Steps with CMake*:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第1章*，*CMake的第一步*：'
- en: This chapter provided basic details about CMake, including installation and
    command-line usage for building projects. It also covered essential information
    about project files, such as their roles, typical naming conventions, and peculiarities.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了关于CMake的基本信息，包括安装和命令行使用方法，以构建项目。它还涵盖了项目文件的基本信息，如它们的作用、典型命名约定和特殊性。
- en: '*Chapter 2*, *The CMake Language*:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第2章*，*CMake语言*：'
- en: We introduced the necessary tools for writing correct CMake listfiles and scripts,
    covering code basics like comments, command invocations, and arguments. We explained
    variables, lists, and control structures, introducing several useful commands.
    This foundation will be crucial throughout our project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了编写正确CMake列表文件和脚本所需的工具，涵盖了基本的代码内容，如注释、命令调用和参数。我们解释了变量、列表和控制结构，并介绍了一些有用的命令。这些基础将贯穿整个项目。
- en: '*Chapter 3*, *Using CMake in Popular IDEs*:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3章*，*在流行的IDE中使用CMake*：'
- en: We discussed three IDEs – CLion, VS Code, and Visual Studio IDE – highlighting
    their strengths. In our final project, choosing an IDE (or not) is up to you.
    Once decided, you can start this project in a Dev container to enjoy a fully prepared
    environment with just a few steps to build a Docker image (or just get it from
    the Docker Hub). Running the image in a container ensures that the development
    environment mirrors production.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了三种IDE——CLion、VS Code和Visual Studio IDE——并强调了它们的优点。在我们的最终项目中，选择使用哪个IDE（或是否使用IDE）由你决定。一旦决定，你可以在Dev容器中开始这个项目，只需通过几步构建一个Docker镜像（或者直接从Docker
    Hub获取）。在容器中运行镜像可以确保开发环境与生产环境一致。
- en: '*Chapter 4*, *Setting Up Your First CMake Project*:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4章*，*设置你的第一个CMake项目*：'
- en: Configuring the project is crucial as it determines the CMake policies that
    will be in effect, naming, versioning, and programming language. We’ll use this
    chapter to influence the fundamental behavior of the build process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 配置项目至关重要，因为它决定了生效的CMake策略、命名、版本控制和编程语言。我们将利用这一章来影响构建过程的基本行为。
- en: We’ll also follow established project partitioning and structuring to determine
    the layout of directories and files, and utilize system discovery variables to
    adapt to different build environments. Toolchain configuration is another critical
    aspect that allows us to mandate a specific C++ version and the standards supported
    by the compiler. Following the chapter’s advice, we will disable in-source builds
    to maintain a clean workspace.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将遵循既定的项目划分和结构来确定目录和文件的布局，并利用系统发现变量适应不同的构建环境。工具链配置是另一个关键方面，它使我们能够强制指定一个特定的
    C++ 版本和编译器支持的标准。按照本章的建议，我们将禁用源代码内构建，以保持工作空间的整洁。
- en: '*Chapter 5*, *Working with Targets*:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 5 章*，*与目标一起工作*：'
- en: Here, we learned how every modern CMake project makes extensive use of targets.
    We’ll, of course, apply targets as well to define a few libraries and executables
    (both for test and production) that will keep the project organized and ensure
    we comply with the principle of **DRY** (**Don’t Repeat Yourself**). The acquired
    knowledge of target properties and transitive usage requirements (propagated properties)
    will allow us to keep the configuration close to target definitions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们了解了每个现代 CMake 项目如何广泛使用目标。我们当然也会使用目标来定义一些库和可执行文件（既用于测试，也用于生产），以保持项目的组织性，并确保遵守**DRY**（**Don’t
    Repeat Yourself**）原则。通过学习目标属性和传递使用要求（传播属性），我们将能够将配置保持在目标定义附近。
- en: '*Chapter 6*, *Using Generator Expressions*:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 6 章*，*使用生成器表达式*：'
- en: Generator expressions are heavily used throughout our project. We’ll aim to
    keep these expressions as straightforward as possible. The project will incorporate
    custom commands to generate files for Valgrind and coverage reports. Additionally,
    we’ll employ target hooks, specifically `PRE_BUILD`, to clean up the `.gcda` files
    that are produced by the coverage instrumentation process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式在整个项目中被大量使用。我们将尽量使这些表达式保持简单明了。项目将包含自定义命令，以生成 Valgrind 和覆盖率报告的文件。此外，我们还将使用目标钩子，特别是
    `PRE_BUILD`，来清理覆盖率插桩过程产生的 `.gcda` 文件。
- en: '*Chapter 7*, *Compiling C++ Sources with CMake*:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 7 章*，*使用 CMake 编译 C++ 源代码*：'
- en: 'There’s no C++ project without compilation. The basics are quite simple, but
    CMake allows us to tweak this process in so many ways: extend the sources of a
    target, configure the optimizer, and provide debugging information. For this project,
    the default compilation flags will do just fine, but we’ll go ahead and play a
    bit with the preprocessor:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 C++ 项目是不需要编译的。基础知识非常简单，但 CMake 允许我们以多种方式调整这一过程：扩展目标的源文件、配置优化器、提供调试信息。对于这个项目，默认的编译标志已经足够，但我们还是会稍微玩一下预处理器：
- en: We’ll store build metadata (the project version, build time, and the Git commit
    SHA) in the compiled executable and show it to the user.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在编译后的可执行文件中存储构建元数据（项目版本、构建时间和 Git 提交 SHA），并将其展示给用户。
- en: We’ll enable the precompilation of headers. It’s not really a necessity in such
    a small project, but it will help us practice this concept.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将启用头文件的预编译。这在如此小的项目中并不是必需的，但它有助于我们练习这一概念。
- en: Unity builds won’t be necessary – this project won’t be big enough to make adding
    them worthwhile.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要 Unity 构建——这个项目不会大到需要添加它们才有意义。
- en: '*Chapter 8*, *Linking Executables and Libraries*:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 8 章*，*链接可执行文件和库*：'
- en: 'We will obtain general information on linking, useful in any project by default.
    Additionally, since this project includes a library, we will explicitly reference
    some specific building instructions for the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得有关链接的一般信息，这在任何项目中默认都是有用的。此外，由于这个项目包含一个库，我们将明确引用一些特定的构建指令，具体如下：
- en: Static libraries for testing and development
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试和开发的静态库
- en: Shared libraries for release
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于发布的共享库
- en: This chapter also outlines how to isolate the `main()` function for testing
    purposes, a practice we will adopt.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还概述了如何隔离 `main()` 函数以进行测试，这是我们将采用的做法。
- en: '*Chapter 9*, *Managing Dependencies in CMake*:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 9 章*，*在 CMake 中管理依赖项*：'
- en: 'To enhance the project’s appeal, we will introduce an external dependency:
    a text-based UI library. *Chapter 9* explores various methods for managing dependencies.
    The choice will be simple: the `FetchContent` utility module is generally recommended
    and most convenient.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强项目的吸引力，我们将引入一个外部依赖项：一个基于文本的 UI 库。*第 9 章* 探讨了管理依赖项的各种方法。选择将很简单：`FetchContent`
    工具模块通常是推荐的且最方便的。
- en: '*Chapter 10*, *Using C++20 Modules*:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 10 章*，*使用 C++20 模块*：'
- en: Although we have explored the use of C++20 modules and the environment requirements
    to support this feature (CMake 3.28, latest compilers), its wide support is still
    lacking. To ensure the project’s accessibility, we will not incorporate modules
    yet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经探讨了 C++20 模块的使用以及支持此功能的环境要求（CMake 3.28，最新编译器），但其广泛支持仍然不足。为了确保项目的可访问性，我们暂时不会引入模块。
- en: '*Chapter 11*, *Testing Frameworks*:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第11章*，*测试框架*：'
- en: Implementing proper automated tests is imperative to ensuring the quality of
    our solution remains consistent over time. We will integrate CTest and organize
    our project to facilitate testing, applying the `main()` function separation mentioned
    previously.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实施适当的自动化测试对于确保我们解决方案的质量在时间的推移中保持一致至关重要。我们将集成 CTest，并组织我们的项目以便于测试，应用之前提到的 `main()`
    函数分离。
- en: 'This chapter discusses two testing frameworks: Catch2 and GTest with GMock;
    we will use the latter. To obtain detailed information on our coverage, we will
    generate HTML reports with LCOV.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了两个测试框架：Catch2 和 GTest 配合 GMock；我们将使用后者。为了获取详细的覆盖率信息，我们将使用 LCOV 生成 HTML
    报告。
- en: '*Chapter 12*, *Program Analysis Tools*:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第12章*，*程序分析工具*：'
- en: 'For static analysis, we can select from a range of tools: Clang-Tidy, Cpplint,
    Cppcheck, include-what-you-use, and link-what-you-use. We will opt for Cppcheck,
    as Clang-Tidy is less compatible with precompiled headers built using GCC.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态分析，我们可以选择一系列工具：Clang-Tidy，Cpplint，Cppcheck，include-what-you-use 和 link-what-you-use。我们将选择
    Cppcheck，因为 Clang-Tidy 与使用 GCC 构建的预编译头文件兼容性较差。
- en: Dynamic analysis will be conducted using Valgrind’s Memcheck tool, complemented
    by the Memcheck-cover wrapper to produce HTML reports. Additionally, our source
    code will be automatically formatted during the build process with ClangFormat.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析将使用 Valgrind 的 Memcheck 工具进行，并辅以 Memcheck-cover 包装器生成 HTML 报告。此外，我们的源代码将在构建过程中通过
    ClangFormat 自动格式化。
- en: '*Chapter 13*, *Generating Documentation:*'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第13章*，*生成文档：*'
- en: Providing documentation is essential when offering a library as part of our
    project. CMake facilitates the automation of documentation generation using `Doxygen`.
    We will adopt this approach in a refreshed design by incorporating the `doxygen-awesome-css`
    theme.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提供文档在将库作为我们项目的一部分时是至关重要的。CMake 通过使用 `Doxygen` 实现文档生成的自动化。我们将在更新的设计中采用这种方法，并结合
    `doxygen-awesome-css` 主题。
- en: '*Chapter 14*, *Installing and Packaging*:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第14章*，*安装与打包*：'
- en: Finally, we’ll configure the installation and packaging of our solution and
    prepare files to form the package as described, along with target definitions.
    We’ll install that and the artifacts from build targets to appropriate directories
    by including the `GNUInstallDirs` module. We will additionally configure a few
    components to modularize the solution and prepare it for use with CPack.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将配置解决方案的安装和打包，并准备文件形成如上所述的包，同时包括目标定义。我们将通过包含 `GNUInstallDirs` 模块，安装解决方案及构建目标的产物到相应目录。我们还将配置一些组件来模块化解决方案，并为与
    CPack 的使用做准备。
- en: 'Professional projects also come with a few text files: `README`, `LICENSE`,
    `INSTALL`, and so on. We will briefly cover these at the end of the chapter.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 专业项目通常还包括一些文本文件：`README`、`LICENSE`、`INSTALL` 等。我们将在本章末尾简要介绍这些文件。
- en: To make things simpler, we won’t implement custom logic that checks whether
    all the required utilities and dependencies are available. We’ll rely on CMake
    to show its diagnostics and tell users what’s missing. If your projects get significant
    traction, you might want to consider adding these mechanisms to improve the user
    experience.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化过程，我们不会实现自定义逻辑来检查是否所有必需的工具和依赖项都可用。我们将依赖 CMake 来显示其诊断信息，并告诉用户缺少什么。如果你的项目得到广泛关注，可能需要考虑添加这些机制来改善用户体验。
- en: Having formed a clear plan, let’s discuss how to actually structure the project,
    both in terms of logical targets and directory structure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了清晰的计划后，接下来我们将讨论如何实际构建项目，无论是从逻辑目标还是目录结构的角度。
- en: Project layout
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目布局
- en: 'To build any project, we should start with a clear understanding of what logical
    targets are going to be created within it. In this case, we’ll follow the structure
    shown in the following figure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构建任何项目时，我们应该先清楚地理解将在其中创建哪些逻辑目标。在这种情况下，我们将遵循以下图所示的结构：
- en: '![](img/B19844_15_02.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_15_02.png)'
- en: 'Figure 15.2: A structure of logical targets'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2：逻辑目标的结构
- en: Let’s explore the structure by following the build order. First, we compile
    `calc_obj`, an **object library**. For a refresher on object libraries, please
    check *Chapter 5*, *Working with Targets*. We should then turn our attention to
    **static** **libraries** and **shared libraries**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照构建顺序来探索结构。首先，我们编译`calc_obj`，一个**目标库**。如果需要回顾目标库，请查看*第5章*，*与目标合作*。然后，我们应关注**静态**
    **库**和**共享库**。
- en: Shared libraries versus static libraries
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库与静态库
- en: In *Chapter 8*, *Linking Executables and Libraries*, we introduced both shared
    and static libraries. We noted that shared libraries can reduce overall memory
    usage when multiple programs use the same library. Also, it’s common for users
    to already have popular libraries installed or to know how to install them quickly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章*，*链接可执行文件和库*中，我们介绍了共享库和静态库。我们指出，当多个程序使用相同的库时，共享库可以减少整体内存使用。此外，用户通常已经安装了流行的库，或者知道如何快速安装它们。
- en: More importantly, **shared libraries** are separate files that must be placed
    in specific paths for the dynamic linker to locate them. In contrast, **static
    libraries** are embedded directly into the executable file, which leads to faster
    usage as there are no additional steps required to locate the code in memory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，**共享库**是独立的文件，必须放置在特定路径中，以便动态链接器能够找到它们。相比之下，**静态库**直接嵌入到可执行文件中，这使得使用时更快，因为无需额外步骤来定位内存中的代码。
- en: As library authors, we can decide whether we’re providing a static or a shared
    version of the library, or we can simply ship both versions and leave this decision
    to the programmer using our library in their project. Since we’re exercising our
    knowledge, we will deliver two versions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为库的作者，我们可以决定提供静态版本还是共享版本，或者我们可以同时提供这两种版本，并将此决定留给使用我们库的程序员。由于我们在应用我们的知识，我们将提供两个版本。
- en: The `calc_test` target, which includes unit tests to verify the library’s core
    functionality, will utilize the static library. Although we are building both
    types of libraries from the same *object files*, testing with either library type
    is acceptable since their functionalities should be identical. The console app
    associated with `calc_console_static` target will use the shared library. This
    target also links against an external dependency, the Functional Terminal (X)
    User Interface (FTXUI) library by Arthur Sonzogni (there is a link to the GitHub
    project in the *Further reading* section).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_test`目标，包括用于验证库核心功能的单元测试，将使用静态库。虽然我们从相同的*目标文件*构建这两种类型的库，但测试任一库类型都是可以接受的，因为它们的功能应该是相同的。与`calc_console_static`目标关联的控制台应用程序将使用共享库。该目标还链接了一个外部依赖项，即Arthur
    Sonzogni的功能终端（X）用户界面（FTXUI）库（*进一步阅读*部分有指向GitHub项目的链接）。'
- en: 'The last two targets, `calc_console` and `calc_console_test`, are designed
    to tackle a common issue in testing executables: the clash of multiple entry points
    provided by both the test frameworks and the executables. To circumvent this,
    we have intentionally isolated the `main()` function into a bootstrap target,
    `calc_console`, which merely invokes the primary function from `calc_console_static`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个目标，`calc_console`和`calc_console_test`，旨在解决测试可执行文件中的常见问题：测试框架和可执行文件提供的多个入口点的冲突。为避免此问题，我们故意将`main()`函数隔离到一个引导目标`calc_console`中，它仅调用`calc_console_static`中的主要功能。
- en: With an understanding of the necessary targets and their interrelations, our
    next step is to organize the project’s structure with appropriate files and directories.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了必要的目标及其相互关系之后，我们的下一步是使用适当的文件和目录组织项目的结构。
- en: Project file structure
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目文件结构
- en: 'The project consists of two key elements: the `calc` libraries and the `calc_console`
    executable. To organize our project effectively, we will employ the following
    directory structure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目由两个关键元素组成：`calc`库和`calc_console`可执行文件。为了有效地组织我们的项目，我们将采用以下目录结构：
- en: '`src` contains sources for all released targets and library header files.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`包含所有已发布目标和库头文件的源代码。'
- en: '`test` contains tests for the above libraries and executables.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`包含上述库和可执行文件的测试。'
- en: '`cmake` contains utility modules and helper files used by CMake to build and
    install the project.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake`包含CMake用于构建和安装项目的工具模块和辅助文件。'
- en: '*root directory* contains top-level configuration and documentation files.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*根目录*包含顶级配置和文档文件。'
- en: 'This structure (shown in *Figure 15.3*) ensures a clear separation of concerns,
    facilitating easier navigation and maintenance of the project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构（如*图15.3*所示）确保了关注点的清晰分离，便于项目的导航和维护：
- en: '![](img/B19844_15_03.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_15_03.png)'
- en: 'Figure 15.3: The directory structure of the project'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：项目的目录结构
- en: 'Here’s the full list of files in each of the four main directories:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个四个主要目录中的文件完整列表：
- en: '| **Root directory** | `./test` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **根目录** | `./test` |'
- en: '| `CHANGELOG` | `CMakeLists.txt` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `CHANGELOG` | `CMakeLists.txt` |'
- en: '| **CMakeLists.txt** | **calc/CMakeLists.txt** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **CMakeLists.txt** | **calc/CMakeLists.txt** |'
- en: '| `INSTALL``LICENSE``README.md` | `calc/calc_test.cpp``calc_console/CMakeLists.txt``calc_console/tui_test.cpp`
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `INSTALL``LICENSE``README.md` | `calc/calc_test.cpp``calc_console/CMakeLists.txt``calc_console/tui_test.cpp`
    |'
- en: '| `./src` | `./cmake` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `./src` | `./cmake` |'
- en: '| `CMakeLists.txt``calc/CMakeLists.txt``calc/CalcConfig.cmake``calc/basic.cpp``calc/include/calc/basic.h``calc_console/CMakeLists.txt``calc_console/bootstrap.cpp``calc_console/include/tui.h``calc_console/tui.cpp`
    | `BuildInfo.cmake``Coverage.cmake``CppCheck.cmake``Doxygen.cmake``Format.cmake``GetFTXUI.cmake``Packaging.cmake``Memcheck.cmake``NoInSourceBuilds.cmake``Testing.cmake``buildinfo.h.in``doxygen_extra_headers`
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `CMakeLists.txt``calc/CMakeLists.txt``calc/CalcConfig.cmake``calc/basic.cpp``calc/include/calc/basic.h``calc_console/CMakeLists.txt``calc_console/bootstrap.cpp``calc_console/include/tui.h``calc_console/tui.cpp`
    | `BuildInfo.cmake``Coverage.cmake``CppCheck.cmake``Doxygen.cmake``Format.cmake``GetFTXUI.cmake``Packaging.cmake``Memcheck.cmake``NoInSourceBuilds.cmake``Testing.cmake``buildinfo.h.in``doxygen_extra_headers`
    |'
- en: 'Table 15.1: File structure of the project'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1：项目文件结构
- en: While it may appear that CMake introduces considerable overhead, with the `cmake`
    directory initially containing more content than the actual business code, this
    dynamic will shift as the project expands in functionality. The initial effort
    to establish a clean and organized project structure is substantial, but rest
    assured, this investment will yield significant benefits in the future.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来CMake引入了相当大的开销，且`cmake`目录最初包含的内容比实际的业务代码还多，但随着项目功能的扩展，这种动态会发生变化。最初建立一个清晰、有序的项目结构需要付出较大的努力，但可以放心，这项投资在未来将带来显著的回报。
- en: 'We’ll go through all the files mentioned in *Table 15.1* throughout the chapter
    and see in detail what they do and what role they play in the project. This will
    happen in four steps: building, testing, installing, and providing documentation.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细讲解*表15.1*中提到的所有文件，并逐步分析它们的功能以及在项目中的作用。这个过程将分为四个步骤：构建、测试、安装和提供文档。
- en: Building and managing dependencies
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和管理依赖项
- en: All build processes follow the same procedure. We begin with the top-level listfile
    and progress downward through the project’s source tree. *Figure 15.4* illustrates
    the project files involved in the build process, with numbers in parentheses indicating
    the order of CMake script execution.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有构建过程都遵循相同的程序。我们从顶层的列表文件开始，向下推进到项目的源代码树中。*图15.4*展示了构建过程中的项目文件，括号中的数字表示CMake脚本执行的顺序。
- en: '![](img/B19844_15_04.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_15_04.png)'
- en: 'Figure 15.4: Files used in the build stage'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：构建阶段使用的文件
- en: 'The top-level `CMakeLists.txt` (1) listfile configures the project:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层的`CMakeLists.txt`（1）列表文件配置了项目：
- en: '**ch15/01-full-project/CMakeLists.txt**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/CMakeLists.txt**'
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We start by specifying essential project details and setting the path to the
    CMake utility modules (the `cmake` directory in our project). We then prevent
    in-source builds using a custom module. Following that, we enable testing with
    the `CTest` module (built into CMake). This should be done at the project’s root
    level because this command creates the `CTestTestfile.cmake` file in the binary
    tree relative to its location in the source tree. Placing it elsewhere would prevent
    `ctest` from finding it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先指定项目的基本信息，并设置CMake工具模块的路径（即项目中的`cmake`目录）。然后，我们通过自定义模块来防止源代码构建。接着，我们启用`CTest`模块（CMake内置的测试模块）。此步骤应该在项目的根目录进行，因为该命令会在相对于源代码树位置的二进制树中创建`CTestTestfile.cmake`文件。如果放在其他地方，将导致`ctest`无法找到它。
- en: 'Next, we include two key directories:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们包括两个关键目录：
- en: '`src`, containing the project source (to be named `bin` in the build tree)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`，包含项目源代码（在构建树中命名为`bin`）'
- en: '`test`, containing all the testing utilities'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`，包含所有测试工具'
- en: Finally, we include the `Packaging` module, details of which will be discussed
    in the *Installing and packaging* section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们包括`Packaging`模块，相关内容将在*安装与打包*部分中讨论。
- en: 'Let’s examine the `NoInSourceBuilds` utility module to understand its function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下 `NoInSourceBuilds` 实用模块，以理解它的功能：
- en: '**ch15/01-full-project/cmake/NoInSourceBuilds.cmake**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/NoInSourceBuilds.cmake**'
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: No surprises here, we check if the user has provided a separate destination
    directory for generated files using the `cmake` command. It must differ from the
    project’s source tree path. If not, we instruct the user on how to specify it
    and how to clean up the repository if they made a mistake.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么意外，我们检查用户是否提供了一个单独的生成文件目标目录，使用 `cmake` 命令。它必须与项目的源代码树路径不同。如果没有，我们将指导用户如何指定该目录，并在他们出错时如何清理仓库。
- en: 'Our top-level listfile then includes the `src` subdirectory, instructing CMake
    to process the listfile within it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶级 listfile 随后包括了 `src` 子目录，指示 CMake 处理其中的 listfile 文件：
- en: '**ch15/01-full-project/src/CMakeLists.txt**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/CMakeLists.txt**'
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This file is straightforward – it includes all the modules from the `./cmake`
    directory we will be using and directs CMake to the nested directories to execute
    the listfiles found there.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件很简单——它包括了我们将要使用的 `./cmake` 目录中的所有模块，并引导 CMake 到嵌套的目录中去执行那里的 listfile 文件。
- en: Next, let’s examine the listfile for the `calc` library. It’s somewhat complex,
    so we’ll break it down and discuss it in sections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查 `calc` 库的 listfile。它有些复杂，因此我们将其分解并按部分进行讨论。
- en: Building the Calc library
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Calc 库
- en: 'The listfile in the `calc` directory configures various aspects of this library
    but, for now, we’ll focus only on the building:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc` 目录中的 listfile 配置了该库的各个方面，但现在，我们只关注构建部分：'
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (fragment)**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/CMakeLists.txt（片段）**'
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We define three targets:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个目标：
- en: '`calc_obj`, an *object library* compiling the `basic.cpp` implementation file.
    Its `basic.h` header file is included using the `FILE_SET` keyword in the `target_sources()`
    command. This implicitly configures appropriate include directories to be exported
    correctly for both building and installation modes. By creating an *object library*,
    we prevent redundant compilation for the two library versions, but it’s essential
    to enable `POSITION_INDEPENDENT_CODE` so that the shared library can depend on
    this target.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc_obj`，一个*目标库*，编译 `basic.cpp` 实现文件。它的 `basic.h` 头文件通过 `target_sources()`
    命令中的 `FILE_SET` 关键字包含进来。这样隐式地配置了合适的包含目录，以便在构建和安装模式下正确导出。通过创建*目标库*，我们避免了对两个库版本的冗余编译，但启用
    `POSITION_INDEPENDENT_CODE` 是必要的，这样共享库才能依赖于该目标。'
- en: '`calc_shared`, a shared library that depends on `calc_obj`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc_shared`，一个依赖于 `calc_obj` 的共享库。'
- en: '`calc_static`, a static library that also depends on `calc_obj`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc_static`，一个同样依赖于 `calc_obj` 的静态库。'
- en: 'For context, here’s the C++ header for the basic library. This header file
    simply declares two functions within the `Calc` namespace, which helps avoid name
    collisions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供背景信息，以下是基础库的 C++ 头文件。这个头文件仅声明了 `Calc` 命名空间中的两个函数，帮助避免命名冲突：
- en: '**ch15/01-full-project/src/calc/include/calc/basic.h**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/include/calc/basic.h**'
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The implementation file is straightforward as well:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件也很直接：
- en: '**ch15/01-full-project/src/calc/basic.cpp**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/basic.cpp**'
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This wraps up the explanation of files in the `src/calc` directory. Next up
    is the `src/calc_console` and building the executable of the console calculator
    using this library.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分解释完了 `src/calc` 目录中的文件。接下来是 `src/calc_console` 以及如何使用该库构建控制台计算器的可执行文件。
- en: Building the Calc console executable
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Calc 控制台可执行文件
- en: 'The `calc_console` directory contains several files: a listfile, two implementation
    files (the business logic and a bootstrap file), and a header file. The listfile
    looks as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_console` 目录包含多个文件：一个 listfile，两个实现文件（业务逻辑和引导文件），以及一个头文件。这个 listfile 如下所示：'
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.txt (fragment)**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc_console/CMakeLists.txt（片段）**'
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Though the listfile appears complex, as seasoned CMake users, we can now easily
    decipher its contents:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个 listfile 看起来复杂，但作为经验丰富的 CMake 用户，我们现在可以轻松地解读它的内容：
- en: Define the `calc_console_static` target, containing the business code without
    the `main()` function to allow linking with GTest, which has its own entry point.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `calc_console_static` 目标，包含没有 `main()` 函数的业务代码，以便与具有自己入口点的 GTest 进行链接。
- en: Configure the *include directories*. We could add headers individually with
    `FILE_SET`, but since they are internal, we simplify this step.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置*包含目录*。我们本可以通过 `FILE_SET` 单独添加头文件，但由于它们是内部文件，我们简化了这一步。
- en: Implement header precompilation, here demonstrated with just the `<string>`
    header as an example, though larger projects might include many more.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现头文件预编译，这里仅用`<string>`头文件作为示例，尽管更大的项目可能会包含更多头文件。
- en: Include a custom CMake module to fetch the FTXUI dependency.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含一个自定义CMake模块，用于获取FTXUI依赖项。
- en: Link the business code with the shared `calc_shared` library and the FTXUI components.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将业务代码与共享的`calc_shared`库和FTXUI组件链接。
- en: Add a custom module to generate build information and embed it into the artifact.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个自定义模块，用于生成构建信息并将其嵌入到产物中。
- en: 'Outline additional steps for this target: coverage instrumentation, testing,
    program analysis, and documentation.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此目标概述额外的步骤：代码覆盖度仪器、测试、程序分析和文档生成。
- en: Create and link the `calc_console` bootstrap executable, establishing the entry
    point.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并链接`calc_console`引导程序可执行文件，建立入口点。
- en: Outline the installation.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 概述安装过程。
- en: We will explore testing, documentation, and installation processes in their
    respective sections later in this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后续的相关部分探索测试、文档和安装过程。
- en: 'We’re including the `GetFTXUI` utility module rather than looking for `config-module`
    in the system because it’s not very likely that most users have it installed.
    We’ll just fetch and build it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在包含`GetFTXUI`实用模块，而不是在系统中查找`config-module`，因为大多数用户不太可能已经安装它。我们只需要获取并构建它：
- en: '**ch15/01-full-project/cmake/GetFTXUI.cmake**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/GetFTXUI.cmake**'
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’re using the recommended `FetchContent` method, described in detail in *Chapter
    9*, *Managing Dependencies in CMake*. The only unusual addition is the calls of
    the `option()` command, which lets us bypass the lengthy build steps for FTXUI
    and prevents its installation steps from affecting this project’s installation
    process. For more details, refer to the *Further reading* section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用推荐的`FetchContent`方法，该方法在*第9章*《*CMake中的依赖管理*》中有详细介绍。唯一不同的是调用了`option()`命令，这使我们可以绕过FTXUI的漫长构建步骤，并防止其安装步骤影响此项目的安装过程。有关更多详细信息，请参阅*进一步阅读*部分。
- en: 'The listfile for the `calc_console` directory includes another custom utility
    module that is build-related: `BuildInfo`. This module will capture three pieces
    of information to be displayed in the executable:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_console`目录的列表文件包含另一个与构建相关的自定义实用模块：`BuildInfo`。该模块将捕获三条信息，并将其显示在可执行文件中：'
- en: The current Git commit SHA
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前Git提交的SHA。
- en: The build timestamp
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建时间戳。
- en: The project version specified in the top-level listfile
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级列表文件中指定的项目版本。
- en: 'As we learned in *Chapter 7*, *Compiling C++ Sources with CMake*, CMake can
    capture build-time values and pass them to C++ code via template files, for example,
    with a struct:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第7章*《*使用CMake编译C++源代码*》中学到的，CMake可以捕获构建时的值并通过模板文件将其传递给C++代码，例如使用一个结构体：
- en: '**ch15/01-full-project/cmake/buildinfo.h.in**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/buildinfo.h.in**'
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To fill that structure during the configuration stage, we’ll use the following
    code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在配置阶段填充该结构体，我们将使用以下代码：
- en: '**ch15/01-full-project/cmake/BuildInfo.cmake**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/BuildInfo.cmake**'
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After including the module, we have set variables to capture the desired information
    and use `configure_file()` to generate `buildinfo.h`. The final step was to invoke
    the `BuildInfo` function to include the generated file’s directory in the target’s
    `include` directories.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含该模块后，我们设置变量以捕获所需的信息，并使用`configure_file()`生成`buildinfo.h`。最后一步是调用`BuildInfo`函数，将生成的文件目录包含到目标的`include`目录中。
- en: The produced header file can be then shared with multiple different consumers
    if needed. In such a case, you’ll probably want to add `include_guard(GLOBAL)`
    at the top of the listfile to avoid running the `git` command for every target.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的头文件如果需要，可以与多个不同的消费者共享。在这种情况下，你可能希望在列表文件的顶部添加`include_guard(GLOBAL)`，以避免为每个目标都运行`git`命令。
- en: 'Before looking into the implementation of the console calculator, I’d like
    to emphasize that you don’t need to deeply understand the intricacies of the `tui.cpp`
    file or the FXTUI library, as this isn’t essential for our purposes. Instead,
    let’s focus on the highlighted parts of the code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实现控制台计算器之前，我想强调的是，你不需要深入理解`tui.cpp`文件或FTXUI库的复杂细节，因为这对我们当前的目的并不重要。相反，让我们关注代码中的高亮部分：
- en: '**ch15/01-full-project/src/calc_console/tui.cpp**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc_console/tui.cpp**'
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This piece of code provides the `getTui()` function, which returns a `ftxui::Component`,
    an object that encapsulates interactive UI elements like labels, text fields,
    separators, and a border. For those curious about the detailed workings of these
    elements, further materials are available in the *Further reading* section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码提供了`getTui()`函数，该函数返回一个`ftxui::Component`对象，这个对象封装了交互式UI元素，如标签、文本字段、分隔符和边框。对于那些好奇这些元素的详细工作原理的人，更多的资料可以在*进一步阅读*部分找到。
- en: More importantly, the *include directives* link to the headers from the `calc_obj`
    target and the `BuildInfo` module. The interaction begins with the lambda function,
    invoking `Calc::Sum`, and displaying the result using the `text()` function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，*包含指令*链接到`calc_obj`目标和`BuildInfo`模块中的头文件。交互从lambda函数开始，调用`Calc::Sum`，并使用`text()`函数显示结果。
- en: The values from the `buildinfo.h` collected at build time are used in a similar
    way and will be shown to the user at runtime.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时收集的`buildinfo.h`中的值会以类似的方式使用，并在运行时显示给用户。
- en: 'Alongside `tui.cpp`, there’s a header file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tui.cpp`旁边，有一个头文件：
- en: '**ch15/01-full-project/src/calc_console/include/tui.h**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc_console/include/tui.h**'
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This header is used by the bootstrap file in the `calc_console` target:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件被`calc_console`目标中的引导文件使用：
- en: '**ch15/01-full-project/src/calc_console/bootstrap.cpp**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc_console/bootstrap.cpp**'
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This brief code initializes an interactive console screen with FTXUI, displaying
    the `Component` object from `getTui()` and handling keyboard inputs in a loop.
    With all files in the `src` directory addressed, we can now progress to testing
    and analyzing the program.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简短的代码初始化了一个带有FTXUI的交互式控制台屏幕，显示`getTui()`返回的`Component`对象，并在循环中处理键盘输入。所有`src`目录下的文件都已处理完毕，我们现在可以继续进行程序的测试和分析。
- en: Testing and program analysis
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和程序分析
- en: 'Program analysis and testing are essential components that work together to
    ensure the quality of our solutions. For instance, using Valgrind is more effective
    when running test code (because of its consistency and coverage). Therefore, we
    will configure testing and program analysis in the same place. *Figure 15.5* illustrates
    the execution flow and files needed to set them up:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 程序分析和测试是确保我们解决方案质量的重要组成部分。例如，在运行测试代码时，使用Valgrind更加有效（因为它具有一致性和覆盖率）。因此，我们将把测试和程序分析配置在同一位置。*图
    15.5* 展示了执行流程和设置它们所需的文件：
- en: '![](img/B19844_15_05.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_15_05.png)'
- en: 'Figure 15.5: Files used to enable testing and program analysis'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：用于启用测试和程序分析的文件
- en: 'The numbers in parentheses represent the sequence in which listfiles are processed.
    Start from the top-level listfile and add the `src` and `test` directories:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的数字表示处理列表文件的顺序。从顶级列表文件开始，并添加`src`和`test`目录：
- en: In `src`, include `Coverage`, `Format`, and `CppCheck` modules, and add the
    `src/calc` and `src/calc_console` directories.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src`中，包含`Coverage`、`Format`和`CppCheck`模块，并添加`src/calc`和`src/calc_console`目录。
- en: In `src/calc`, define targets and configure them with included modules.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/calc`中，定义目标并使用包含的模块进行配置。
- en: In `src/calc_console`, define targets and configure them with included modules.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`src/calc_console`中，定义目标并使用包含的模块进行配置。
- en: In `test`, include `Testing` (which includes `Memcheck`) and add the `test/calc`
    and `test/calc_console` directories.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`test`中，包含`Testing`（包括`Memcheck`），并添加`test/calc`和`test/calc_console`目录。
- en: In `test/calc`, define test targets and configure them with included modules.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`test/calc`中，定义测试目标并使用包含的模块进行配置。
- en: In t`est/calc_console`, define test targets and configure them with included
    modules.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`test/calc_console`中，定义测试目标并使用包含的模块进行配置。
- en: 'Let’s examine the listfile for the `test` directory:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来查看一下`test`目录的列表文件：
- en: '**ch15/01-full-project/test/CMakeLists.txt**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/test/CMakeLists.txt**'
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this level, the `Testing` utility module is included to provide functionality
    for both target groups (from the `calc` and `calc_console` directories):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层次中，包含了`Testing`实用模块，为两个目标组（来自`calc`和`calc_console`目录）提供功能：
- en: '**ch15/01-full-project/cmake/Testing.cmake (fragment)**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Testing.cmake（片段）**'
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We enabled testing and included the `FetchContent` module to obtain GTest and
    GMock. Although GMock isn’t used in this project, it’s included with GTest in
    the same repository, so we configure it as well. The key configuration step is
    preventing the installation of these frameworks from affecting our project’s installation
    by using the `option()` command.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用了测试并包含了 `FetchContent` 模块来获取 GTest 和 GMock。虽然 GMock 在本项目中没有使用，但它与 GTest
    一起在同一仓库中提供，因此我们也进行了配置。关键的配置步骤是通过使用 `option()` 命令，防止这些框架的安装影响到我们项目的安装。
- en: 'In the same file, we define an `AddTests()` function to facilitate comprehensive
    testing of business targets:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个文件中，我们定义了一个 `AddTests()` 函数，以方便全面测试业务目标：
- en: '**ch15/01-full-project/cmake/Testing.cmake (continued)**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Testing.cmake (续)**'
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, we include the necessary modules: `GoogleTest` is bundled with CMake,
    and `Coverage` and `Memcheck` are custom utility modules included in the project.
    The `AddTests` macro is then provided to prepare a target for testing, applying
    coverage instrumentation, and memory checking. The `AddCoverage()` and `AddMemcheck()`
    functions are defined in their respective utility modules. Now, we can proceed
    to implement them.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含了必要的模块：`GoogleTest` 与 CMake 一起捆绑提供，`Coverage` 和 `Memcheck` 是项目中自定义的工具模块。接着，提供了
    `AddTests` 宏，用于准备一个测试目标，应用覆盖率插桩和内存检查。`AddCoverage()` 和 `AddMemcheck()` 函数分别在它们各自的工具模块中定义。现在，我们可以继续实现它们。
- en: Preparing the Coverage module
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 Coverage 模块
- en: 'Adding coverage across various targets involves several steps. The `Coverage`
    module provides a function that defines the coverage target for a specified target:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个目标上添加覆盖率涉及几个步骤。`Coverage` 模块提供了一个函数，用于为指定目标定义覆盖率目标：
- en: '**ch15/01-full-project/cmake/Coverage.cmake (fragment)**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Coverage.cmake (片段)**'
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This implementation differs slightly from the one introduced in *Chapter 11*,
    *Testing Frameworks*, as it now includes the target name in the output path to
    prevent name conflicts. Next, we need a function to clear previous coverage results:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现与 *第11章* 中介绍的实现略有不同，因为它现在在输出路径中包括了目标名称，以防止名称冲突。接下来，我们需要一个函数来清除之前的覆盖率结果：
- en: '**ch15/01-full-project/cmake/Coverage.cmake (continued)**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Coverage.cmake (续)**'
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Additionally, we have a function to prepare a target for coverage analysis:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提供了一个函数来准备目标进行覆盖率分析：
- en: '**ch15/01-full-project/cmake/Coverage.cmake (fragment)**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Coverage.cmake (片段)**'
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `InstrumentForCoverage()` function is applied to `src/calc` and `src/calc_console`,
    enabling the generation of the coverage data files when targets `calc_obj` and
    `calc_console_static` are executed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstrumentForCoverage()` 函数应用于 `src/calc` 和 `src/calc_console`，在执行目标 `calc_obj`
    和 `calc_console_static` 时生成覆盖率数据文件。'
- en: 'To generate reports for both test targets, execute the following `cmake` commands
    after configuring the project with the `Debug` build type:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要为两个测试目标生成报告，请在配置项目并选择 `Debug` 构建类型后，执行以下 `cmake` 命令：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we want to perform dynamic program analysis on multiple targets we defined,
    so to apply the Memcheck module, introduced in *Chapter 12*, *Program Analysis
    Tools*, we need to tweak it slightly to scan more than one target.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望对我们定义的多个目标进行动态程序分析，因此，要应用在 *第12章* 中介绍的 Memcheck 模块，*程序分析工具*，我们需要稍作调整，以扫描多个目标。
- en: Preparing the Memcheck module
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 Memcheck 模块
- en: 'The generation of Valgrind memory management reports is initiated by `AddTests()`.
    We begin the Memcheck module with its initial setup:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 Valgrind 内存管理报告由 `AddTests()` 启动。我们通过其初始设置开始 Memcheck 模块：
- en: '**ch15/01-full-project/cmake/Memcheck.cmake (fragment)**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Memcheck.cmake (片段)**'
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code is already familiar to us. Now, let’s examine the function that creates
    the necessary targets for generating reports:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码我们已经很熟悉了。现在，让我们来看一下创建必要目标以生成报告的函数：
- en: '**ch15/01-full-project/cmake/Memcheck.cmake (continued)**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Memcheck.cmake (续)**'
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We slightly improved the `AddMemcheck()` function from *Chapter 12* to handle
    multiple targets. We made the `REPORT_PATH` variable target-specific.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微改进了 *第12章* 中的 `AddMemcheck()` 函数，以便处理多个目标。我们使 `REPORT_PATH` 变量针对每个目标特定。
- en: 'To generate Memcheck reports, use the following commands (note that generating
    reports is more effective when using the `Debug` build type for configuration):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 Memcheck 报告，请使用以下命令（请注意，当使用 `Debug` 构建类型进行配置时，生成报告更为有效）：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Okay, we defined our `Coverage` and `Memcheck` modules (they are used in the
    `Testing` module), so let’s see how the actual test targets are configured.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们定义了 `Coverage` 和 `Memcheck` 模块（它们在 `Testing` 模块中使用），那么让我们看看实际的测试目标是如何配置的。
- en: Applying testing scenarios
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用测试场景
- en: 'To implement testing, we’ll follow this scenario:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现测试，我们将遵循以下场景：
- en: Write unit tests.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写单元测试。
- en: Define and configure executable targets for tests with `AddTests()`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `AddTests()` 定义并配置测试的可执行目标。
- en: Instrument the **Software Under Test** (**SUT**) to enable coverage collection.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**被测软件**（**SUT**）进行插桩，以启用覆盖率收集。
- en: Ensure that coverage data is cleared between the builds to prevent segmentation
    faults.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在构建之间清除覆盖率数据，以防止出现段错误。
- en: 'Let’s start with the unit tests we have to write. To keep things brief, we’ll
    provide the simplest (and perhaps a bit incomplete) unit tests possible. First,
    test the library:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从必须编写的单元测试开始。为了简洁起见，我们将提供最简单（也许有些不完整）的单元测试。首先，测试库：
- en: '**ch15/01-full-project/test/calc/basic_test.cpp**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/test/calc/basic_test.cpp**'
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Follow with the tests for the console – for this purpose, we’ll use the FXTUI
    library. Again, understanding the source code completely isn’t necessary; these
    tests are for illustrative purposes:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接着测试控制台——为此我们将使用 FXTUI 库。同样，完全理解源代码并不是必要的；这些测试仅用于说明目的：
- en: '**ch15/01-full-project/test/calc_console/tui_test.cpp**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/test/calc_console/tui_test.cpp**'
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This test renders the UI to a static `Screen` object and checks if the string
    output contains the expected sum. Not really a great test, but at least it’s a
    short one.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将 UI 渲染到一个静态的 `Screen` 对象，并检查字符串输出是否包含预期的和。虽然这不是一个很好的测试，但至少它是一个简短的测试。
- en: 'Now, let’s configure our tests with two nested listfiles. First, for the library:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过两个嵌套的列表文件配置我们的测试。首先，针对库：
- en: '**ch15/01-full-project/test/calc/CMakeLists.txt**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/test/calc/CMakeLists.txt**'
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And then for the executable:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是可执行文件：
- en: '**ch15/01-full-project/test/calc_console/CMakeLists.txt**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/test/calc_console/CMakeLists.txt**'
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These configurations enable CTest to execute the tests. We also need to prepare
    the business logic targets for coverage analysis and ensure that the coverage
    data is refreshed between builds.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置使 CTest 可以执行测试。我们还需要为业务逻辑目标准备覆盖率分析，并确保覆盖率数据在构建之间得到更新。
- en: 'Let’s add the necessary instructions to the `calc` library target:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `calc` 库目标添加必要的指令：
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/CMakeLists.txt（续）**'
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Instrumentation is added to the `calc_obj` with the extra `--coverage` flag,
    but `CleanCoverage()` is called for the `calc_static` target. Normally, you’d
    apply it on the `calc_obj` for consistency, but we’re using the `PRE_BUILD` keyword
    in `CleanCoverage()`, and CMake doesn’t allow `PRE_BUILD`, `PRE_LINK`, or `POST_BUILD`
    hooks to the object libraries.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 插桩通过额外的 `--coverage` 标志添加到 `calc_obj`，但是 `CleanCoverage()` 被调用到 `calc_static`
    目标。通常情况下，你会对 `calc_obj` 应用它以保持一致性，但我们在 `CleanCoverage()` 中使用了 `PRE_BUILD` 关键字，而
    CMake 不允许在对象库上使用 `PRE_BUILD`、`PRE_LINK` 或 `POST_BUILD` 钩子。
- en: 'Finally, we’ll instrument and clean the console target as well:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将插桩并清理控制台目标：
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.txt (continued)**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc_console/CMakeLists.txt（续）**'
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With these steps, CTest is now set up to run our tests and collect coverage.
    Next, we’ll add instructions for enabling static analysis, as we want our project
    to be of high quality during the first build and all of the subsequent builds.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，CTestr已设置好运行我们的测试并收集覆盖率。接下来，我们将添加启用静态分析的指令，因为我们希望在第一次构建以及后续所有构建中都保持项目的高质量。
- en: Adding static analysis tools
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加静态分析工具
- en: 'We’re nearing the completion of configuring quality assurance for our targets.
    The final step involves enabling automatic formatting and integrating `CppCheck`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将完成为我们的目标配置质量保证的工作。最后一步是启用自动格式化并集成`CppCheck`：
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/CMakeLists.txt（续）**'
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We face a minor issue here: `calc_obj` cannot have a `PRE_BUILD` hook, so we
    apply formatting to `calc_static` instead. We also make sure that the `calc_console_static`
    target is formatted and checked:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到一个小问题：`calc_obj` 不能有 `PRE_BUILD` 钩子，因此我们改为对 `calc_static` 应用格式化。我们还确保
    `calc_console_static` 目标被格式化并检查：
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.cmake (continued)**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc_console/CMakeLists.cmake（续）**'
- en: '[PRE33]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We still need to define the `Format` and `CppCheck` functions. Starting with
    `Format()`, we’re borrowing the code described in *Chapter 12*, *Program Analysis
    Tools*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要定义`Format`和`CppCheck`函数。从`Format()`开始，我们借用了*第12章*，*程序分析工具*中描述的代码：
- en: '**ch15/01-full-project/cmake/Format.cmake**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Format.cmake**'
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To integrate `CppCheck` with our sources, we use:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`CppCheck`与我们的源代码集成，我们使用：
- en: '**ch15/01-full-project/cmake/CppCheck.cmake**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/CppCheck.cmake**'
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is simple and convenient. You may see some resemblance to the Clang-Tidy
    module (from *Chapter 12*, *Program Analysis Tools*) showcasing CMake’s consistency
    in functionality.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单方便。你可能会发现它与Clang-Tidy模块（见*第12章*，*程序分析工具*）有些相似，展示了CMake在功能上的一致性。
- en: 'The arguments for `cppcheck` are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`cppcheck`的参数如下：'
- en: '`--enable=warning`: Activates warning messages. To enable additional checks,
    refer to the Cppcheck manual (see the *Further reading* section).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--enable=warning`：启用警告信息。要启用更多检查，请参阅Cppcheck手册（见*进一步阅读*部分）。'
- en: '`--error-exitcode=1`: Sets the error code returned when `cppcheck` detects
    an issue. This can be any number from `1` to `255` (as `0` indicates success),
    although some numbers can be reserved by the system.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--error-exitcode=1`：设置当`cppcheck`检测到问题时返回的错误代码。可以是`1`到`255`之间的任何数字（因为`0`表示成功），尽管某些数字可能被系统保留。'
- en: With all files in the `src` and `test` directories created, our solution is
    now buildable and fully tested. We can proceed to the installation and packaging
    steps.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`src`和`test`目录中的文件都已创建，我们的解决方案现在可以构建并完全测试。我们可以继续进行安装和打包步骤。
- en: Installing and packaging
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和打包
- en: '*Figure 15.6* shows where we’ll configure our project for installation and
    packaging:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15.6*显示了我们将如何配置项目进行安装和打包：'
- en: '![](img/B19844_15_06.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_15_06.png)'
- en: 'Figure 15.6: File configuring installation and packaging'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：配置安装和打包的文件
- en: 'The top-level listfile includes the `Packaging` utility module:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层的listfile包括`Packaging`工具模块：
- en: '**ch15/01-full-project/CMakeLists.txt (fragment)**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/CMakeLists.txt（片段）**'
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `Packaging` module details the package configuration for the project, which
    we will explore in the *Packaging with CPack* section. Our focus now is on installing
    three main components:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Packaging`模块详细描述了项目的包配置，我们将在*使用CPack打包*部分中探讨。我们现在的重点是安装三个主要组件：'
- en: 'The Calc library artifacts: static and shared libraries, header files, and
    target export files'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Calc库的工件：静态和共享库、头文件以及目标导出文件
- en: The package definition config file for the Calc library
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Calc库的包定义配置文件
- en: The Calc console executable
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Calc控制台可执行文件
- en: Everything is planned, so it’s time to configure the installation of the library.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都已规划好，现在是配置库的安装的时候了。
- en: Installation of the library
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库的安装
- en: 'To install the library, we start by defining logical targets and their artifact
    destinations, utilizing the `GNUInstallDirs` module’s default values to avoid
    manual path specification. Artifacts will be grouped into components. The default
    installation will install all files, but you may choose to only install the `runtime`
    component and skip the `development` artifacts:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装该库，我们首先定义逻辑目标及其工件目的地，利用`GNUInstallDirs`模块的默认值以避免手动指定路径。工件将按组件分组。默认安装将安装所有文件，但你可以选择只安装`runtime`组件，跳过`development`工件：
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/CMakeLists.txt（续）**'
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For UNIX systems, we also configure post-installation registration of the shared
    library with `ldconfig`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于UNIX系统，我们还配置了共享库的安装后注册，使用`ldconfig`：
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/CMakeLists.txt（续）**'
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To enable reusability in other CMake projects, we’ll package the library by
    generating and installing a target export file and a config file that references
    it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在其他CMake项目中启用可重用性，我们将通过生成并安装一个目标导出文件和一个引用它的配置文件来打包该库：
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/CMakeLists.txt（续）**'
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For simplicity, the `CalcConfig.cmake` file is kept minimal:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，`CalcConfig.cmake`文件保持简洁：
- en: '**ch15/01-full-project/src/calc/CalcConfig.cmake**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/CalcConfig.cmake**'
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This file is located in `src/calc` since it only includes the library targets.
    If there were target definitions from other directories, like `calc_console`,
    you would typically place `CalcConfig.cmake` in the top-level or `src` directory.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件位于 `src/calc` 中，因为它只包含库目标。如果有来自其他目录的目标定义，比如 `calc_console`，通常会将 `CalcConfig.cmake`
    放在顶层或 `src` 目录中。
- en: Now, the library is prepared to be installed with the `cmake --install` command
    after building the project. However, we still need to configure the installation
    of the executable.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，库已经准备好在构建项目后通过 `cmake --install` 命令进行安装。然而，我们仍然需要配置可执行文件的安装。
- en: Installation of the executable
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可执行文件的安装
- en: 'We, of course, want our users to be able to enjoy the executable in their system,
    so we will install it with CMake. Preparing the installation of the binary executable
    is straightforward; to achieve it, we only need to include `GNUInstallDirs` and
    use a single `install()` command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望用户能够在他们的系统上使用可执行文件，因此我们将使用 CMake 安装它。准备二进制可执行文件的安装非常简单；为此，我们只需要包含 `GNUInstallDirs`
    并使用一个 `install()` 命令：
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.txt (continued)**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc_console/CMakeLists.txt（续）**'
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With that, the executable is set to be installed. Now, let’s proceed to packaging.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，可执行文件已经设置好可以安装了。现在，让我们继续进行打包。
- en: Packaging with CPack
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CPack 进行打包
- en: 'We could go wild and configure a vast multitude of supported package types;
    for this project, however, a basic configuration will be enough:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置多种支持的包类型，但对于这个项目，基本配置就足够了：
- en: '**ch15/01-full-project/cmake/Packaging.cmake**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Packaging.cmake**'
- en: '[PRE42]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Such a minimal setup works well for standard archives, such as ZIP files. To
    test the installation and packaging processes after building the project, use
    the following command within the build tree:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的最小配置对于标准存档（如 ZIP 文件）非常有效。为了在构建项目后测试安装和打包过程，可以在构建树内使用以下命令：
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This concludes the installation and packaging; the next order of business is
    documentation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了安装和打包的部分；接下来的任务是文档。
- en: Providing the documentation
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供文档
- en: The final touch to a professional project is the documentation. Undocumented
    projects are very difficult to navigate and understand when working in teams and
    when shared with external audiences. I would even go as far as saying that programmers
    often read their own documentation after stepping away from a specific file to
    understand what is happening inside.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一个专业项目的最后润色是文档。没有文档的项目在团队合作和与外部分享时都非常难以导航和理解。我甚至会说，程序员常常在离开某个特定文件后，重新阅读自己的文档，以便理解文件中的内容。
- en: Documentation is also important for legal and compliance reasons and to inform
    the users how to act with the software. If time permits, we should invest in setting
    up documentation for our project.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 文档对于法律和合规性以及告知用户如何使用软件也非常重要。如果时间允许，我们应该投入精力为我们的项目设置文档。
- en: 'Documentation usually falls into two categories:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 文档通常分为两类：
- en: Technical documentation (covering interfaces, designs, classes, and files)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术文档（涵盖接口、设计、类和文件）
- en: General documentation (encompassing all other non-technical documents)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般文档（涵盖所有其他非技术文档）
- en: As we saw in *Chapter 13*, *Generating Documentation*, much of the technical
    documentation can be automatically generated with CMake using `Doxygen`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第 13 章*中看到的，*生成文档*，大部分技术文档可以通过 CMake 使用 `Doxygen` 自动生成。
- en: Generating the technical documentation
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成技术文档
- en: While some projects generate documentation during the build phase and include
    it in the package, we’ve chosen not to do so for this project. However, there
    could be valid reasons to opt otherwise, like if the documentation needs to be
    hosted online.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些项目在构建阶段生成文档并将其包含在包中，但我们选择不这样做。尽管如此，也有可能出于某些有效原因选择这样做，比如如果文档需要在线托管。
- en: '*Figure 15.7* provides an overview of the documentation generation process:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15.7* 提供了文档生成过程的概述：'
- en: '![](img/B19844_15_07.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_15_07.png)'
- en: 'Figure 15.7: Files used to generate documentation'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7：用于生成文档的文件
- en: 'To generate documentation, we’ll create another CMake utility module, `Doxygen`.
    Start by using the `Doxygen` `find-module` and download the `doxygen-awesome-css`
    project for themes:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成文档，我们将创建另一个 CMake 工具模块 `Doxygen`。首先使用 `Doxygen` `find-module` 并下载 `doxygen-awesome-css`
    项目来获取主题：
- en: '**ch15/01-full-project/cmake/Doxygen.cmake (fragment)**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Doxygen.cmake（片段）**'
- en: '[PRE44]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we’ll need a function to create targets that generate documentation.
    We’ll adapt the code introduced in *Chapter 13*, *Generating Documentation*, to
    support multiple targets:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个函数来创建生成文档的目标。我们将调整在*第13章*《生成文档》中介绍的代码，以支持多个目标：
- en: '**ch15/01-full-project/cmake/Doxygen.cmake (continued)**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/cmake/Doxygen.cmake（续）**'
- en: '[PRE45]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use this function by calling it for the library target:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用库目标来使用此功能：
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (fragment)**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc/CMakeLists.txt（片段）**'
- en: '[PRE46]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And for the console executable:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控制台可执行文件：
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.txt (fragment**)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/src/calc_console/CMakeLists.txt（片段）**'
- en: '[PRE47]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This setup adds two targets to the project: `doxygen-calc` and `doxygen-calc_console`,
    allowing for the on-demand generation of technical documentation. Now, let’s consider
    what other documents should be included.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置为项目添加了两个目标：`doxygen-calc`和`doxygen-calc_console`，允许按需生成技术文档。现在，让我们考虑应该包含哪些其他文档。
- en: Writing non-technical documents for a professional project
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为专业项目编写非技术性文档
- en: 'Professional projects should include a set of non-technical documents stored
    in the top-level directory, essential for comprehensive understanding and legal
    clarity:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 专业项目应包括一组非技术性文档，存储在顶层目录中，对于全面理解和法律清晰度至关重要：
- en: '`README`: Provides a general description of the project'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README`: 提供项目的一般描述'
- en: '`LICENSE`: Details the legal parameters regarding the project’s use and distribution'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LICENSE`: 详细说明有关项目使用和分发的法律参数'
- en: 'Additional documents you might consider include:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能考虑的其他文档包括：
- en: '`INSTALL`: Offers step-by-step installation instructions'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSTALL`: 提供逐步的安装说明'
- en: '`CHANGELOG`: Presents significant changes across versions'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHANGELOG`: 提示版本之间的重要变更'
- en: '`AUTHORS`: Lists contributors and their contact information if the project
    has multiple contributors'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTHORS`: 列出贡献者及其联系方式，如果项目有多个贡献者的话'
- en: '`BUGS`: Advises on known issues and details on reporting new ones'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUGS`: 提供已知问题和报告新问题的详细信息'
- en: 'CMake doesn’t directly interact with these files, as they don’t involve automated
    processing or scripting. Yet, their presence is vital for a well-documented C++
    project. Here’s a minimal example of each document:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: CMake不会直接与这些文件交互，因为它们不涉及自动处理或脚本。然而，它们的存在对于一个良好文档化的C++项目至关重要。以下是每个文档的最小示例：
- en: '**ch15/01-full-project/README.md**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/README.md**'
- en: '[PRE48]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is short and maybe a little silly. Note the `.md` extension – it stands
    for *Markdown*, which is a text-based formatting language that is easily readable.
    Websites such as GitHub and many text editors will render these files with rich
    formatting.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简短，可能有点傻。注意`.md`扩展名——它代表*Markdown*，这是一种基于文本的格式化语言，易于阅读。像GitHub这样的站点和许多文本编辑器会以丰富的格式呈现这些文件。
- en: 'Our `INSTALL` file will look like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`INSTALL`文件将如下所示：
- en: '**ch15/01-full-project/INSTALL**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/INSTALL**'
- en: '[PRE49]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `LICENSE` file is a bit tricky, as it requires some expertise in copyright
    law (and otherwise). Instead of writing all the clauses by ourselves, we can do
    what many other projects do and use a readily available software license. For
    this project, we’ll go with the MIT License, which is extremely permissive. Check
    the *Further reading* section for some useful references:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`LICENSE`文件有点棘手，因为它需要一些版权法方面的专业知识（以及其他方面）。我们可以像许多其他项目一样，使用现成的开源软件许可证，而不是自己编写所有条款。对于这个项目，我们将使用MIT许可证，它非常宽松。请查看*进一步阅读*部分，获取一些有用的参考资料：'
- en: '**ch15/01-full-project/LICENSE**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/LICENSE**'
- en: '[PRE50]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lastly, we have the `CHANGELOG`. As suggested earlier, it’s good to keep track
    of changes in a file so that developers using your project can easily find out
    which version supports the features they need. For example, it might be useful
    to say that a multiplication feature was added to the library in version 0.8.2\.
    Something as simple as the following is already helpful:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`CHANGELOG`。如前所述，保持文件中的变更记录很有帮助，这样使用你项目的开发者可以轻松找到支持他们所需功能的版本。例如，可能有用的是说明在版本0.8.2中为库添加了乘法功能。像以下这样简单的内容已经非常有帮助：
- en: '**ch15/01-full-project/CHANGELOG**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch15/01-full-project/CHANGELOG**'
- en: '[PRE51]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With these documents, the project not only gains an operational structure but
    also communicates its usage, changes, and legal considerations effectively, ensuring
    users and contributors have all the necessary information at their disposal.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些文档，项目不仅获得了操作结构，还有效地传达了其使用方法、变更和法律事项，确保用户和贡献者掌握所有必要的信息。
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we put together a professional project based on everything
    we’ve learned so far. Let’s do a quick recap.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们基于迄今为止学到的一切，整合了一个专业的项目。让我们快速回顾一下。
- en: 'We started by laying out the project and discussing what files will live in
    which directory. Based on previous experience and the desire to practice more
    advanced scenarios, we delineated a main application for the users and a library
    that another developer might use. This shaped the structure of directories and
    relations between the CMake targets we want to build. We then followed with the
    configuration of individual targets for the build: we provided the source code
    for the library, defined its targets, and set it up for consumption with position-independent
    code parameters. The user-facing application also had its executable target defined,
    provided with source code, and configured its dependency: the FTXUI library.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先规划了项目结构，并讨论了哪些文件将位于哪个目录中。基于之前的经验和对更高级场景的实践需求，我们划分了面向用户的主要应用程序和另一个开发人员可能使用的库。这决定了目录结构和我们希望构建的
    CMake 目标之间的关系。接着，我们为构建配置了各个目标：我们提供了库的源代码，定义了它的目标，并为其配置了独立位置代码参数以供使用。面向用户的应用程序也定义了它的可执行目标，提供了源代码，并配置了它的依赖：FTXUI
    库。
- en: Armed with artifacts to build, we continued to enhance our project with tests
    and quality assurance. We added the coverage module to produce coverage reports,
    Memcheck to verify the solution with Valgrind during the runtime, and `CppCheck`
    to execute static analysis as well.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有构建工件后，我们继续通过测试和质量保证来增强我们的项目。我们添加了覆盖率模块以生成覆盖报告，使用 Memcheck 在运行时通过 Valgrind
    验证解决方案，并且还使用 `CppCheck` 执行静态分析。
- en: Such a project was now ready to be installed, so we created appropriate installation
    entries for the library and the executable using the techniques learned so far,
    and we prepared a package configuration for CPack. The final task was to ensure
    that the project was correctly documented, so we set up automatic documentation
    generation with Doxygen and wrote a few basic documents that take care of less
    technical aspects of the software distribution.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个项目已经准备好安装，因此我们使用迄今为止学到的技术为库和可执行文件创建了适当的安装条目，并为 CPack 准备了一个包配置。最后的任务是确保项目的文档是正确的，因此我们设置了自动文档生成（使用
    Doxygen），并编写了一些基础文档来处理软件分发中的非技术性方面。
- en: 'This led us to the completion of the project configuration and we can now easily
    build it and install it with just a few precisely used CMake commands. But what
    if we could just use one simple command to complete the entire process? Let’s
    discover how in the final chapter: *Chapter 16*, *Writing CMake Presets*.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们完成了项目配置，现在我们可以轻松地使用几个精确的 CMake 命令来构建并安装它。但如果我们能只用一个简单的命令来完成整个过程呢？让我们在最后一章：*第16章*，*编写
    CMake 预设*中探索如何做到这一点。
- en: Further reading
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，您可以参考以下链接：
- en: 'Building both a static library and a shared library: [https://stackoverflow.com/q/2152077](https://stackoverflow.com/q/2152077)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建静态库和共享库：[https://stackoverflow.com/q/2152077](https://stackoverflow.com/q/2152077)
- en: A FXTUI library project:[https://github.com/ArthurSonzogni/FTXUI](https://github.com/ArthurSonzogni/FTXUI)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 FXTUI 库项目：[https://github.com/ArthurSonzogni/FTXUI](https://github.com/ArthurSonzogni/FTXUI)
- en: The documentation of the `option()` command:[https://cmake.org/cmake/help/latest/command/option.html](https://cmake.org/cmake/help/latest/command/option.html)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`option()` 命令的文档：[https://cmake.org/cmake/help/latest/command/option.html](https://cmake.org/cmake/help/latest/command/option.html)'
- en: Preparing for release (of open source software) by Google:[https://opensource.google/docs/releasing/preparing/](https://opensource.google/docs/releasing/preparing/)
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 的开源软件发布准备：[https://opensource.google/docs/releasing/preparing/](https://opensource.google/docs/releasing/preparing/)
- en: Why we can’t use Clang-Tidy for GCC-precompiled headers:[https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104](https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104)
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们不能为 GCC 预编译头使用 Clang-Tidy：[https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104](https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104)
- en: Cppcheck manual:[https://cppcheck.sourceforge.io/manual.pdf](https://cppcheck.sourceforge.io/manual.pdf)
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cppcheck 手册：[https://cppcheck.sourceforge.io/manual.pdf](https://cppcheck.sourceforge.io/manual.pdf)
- en: How to write a README:[https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/](https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/)
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写 README：[https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/](https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/)
- en: Creative Commons licenses for GitHub projects:[https://github.com/santisoler/cc-licenses](https://github.com/santisoler/cc-licenses)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 项目的 Creative Commons 许可证：[https://github.com/santisoler/cc-licenses](https://github.com/santisoler/cc-licenses)
- en: Commonly used project licenses recognized by GitHub:[https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository)
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 常用的项目许可证：[https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository)
- en: Leave a review!
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoyed this book? Help readers like you by leaving an Amazon review. Scan the
    QR code below to get a free eBook of your choice.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过在亚马逊上留下评论，帮助像你一样的读者。扫描下方二维码，获取你选择的免费电子书。
- en: '![](img/Review_Copy.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Review_Copy.png)'
