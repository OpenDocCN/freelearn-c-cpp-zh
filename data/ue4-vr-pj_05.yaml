- en: Interacting with the Virtual World - Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与虚拟世界互动-第一部分
- en: In the previous chapter, we learned how to make our player character move using
    teleport locomotion and then by adding a more immersive seamless locomotion scheme.
    We gave our users feet. Now, in this chapter, we're going to give them hands.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们学习了如何使用传送定位和添加更沉浸式的无缝定位方案来使玩家角色移动。我们给了我们的用户脚。现在，在本章中，我们将给他们双手。
- en: We'll start out by creating a new project using assets from the Marketplace
    to explore another way of starting up a VR project, and then we'll take the VRPawn
    we built in the preceding chapter and migrate it into this new project. Once we're
    set up, we'll begin by adding hands to the VRPawn and exploring ways of interacting
    with objects in the world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用市场上的资产创建一个新项目，探索另一种启动VR项目的方式，然后将我们在前一章中构建的VRPawn迁移到这个新项目中。一旦我们设置好了，我们将首先为VRPawn添加手部，并探索与世界中的物体互动的方式。
- en: This is important. As humans interacting with the world, we're most conscious
    of the way things appear as we look around, but we're nearly as conscious of our
    hands and what they're doing. VR developers call this *hand presence*, and when
    it's done right, it can contribute significantly to immersion. Think about it
    for a moment. Your hands are the part of your body that you're probably most aware
    of most of the time. How well we represent them in VR has a meaningful impact
    on how *embodied* we feel in the experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要。作为与世界互动的人类，我们最关注的是我们环顾四周时事物的外观，但我们对我们的手和它们的动作也有很高的意识。VR开发者称之为“手的存在感”，当它做得好时，它可以显著提高沉浸感。请稍微思考一下。你的手是你身体的一部分，你可能大部分时间都对它们最有意识。我们在VR中如何很好地代表它们对我们在体验中的“具身感”有着有意义的影响。
- en: 'In this chapter, we''re going to learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: How to create Blueprint-driven virtual hands for our players
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为玩家创建基于蓝图的虚拟手
- en: How to use a construction script to customize an object when it's created in
    the world
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在创建世界中的对象时使用构造脚本进行自定义
- en: How to use animation blend spaces and animation blueprints to animate our hands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用动画混合空间和动画蓝图来为我们的手添加动画
- en: How to set up new inputs to drive our hands
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置新的输入来驱动我们的手
- en: Let's get to it!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Starting a new project from existing work
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从现有工作开始一个新项目
- en: Let's begin by creating a new project. We'll migrate the Pawn and game mode
    we made in the previous chapter into this one, and we'll add some scenery from
    the Marketplace. As you start to develop a library of elements you've developed
    yourself, or acquired through the Marketplace, this will become a common way of
    getting a new project going.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新项目开始。我们将把我们在前一章中制作的Pawn和游戏模式迁移到这个项目中，并从市场上添加一些景观。当您开始开发自己开发的元素库或通过市场获得元素时，这将成为启动新项目的常见方式。
- en: Migrating Blueprints to a new project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将蓝图迁移到新项目
- en: 'Launch your current engine version, and in your Unreal Project Browser, create
    a new project with the following parameters:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 启动当前版本的引擎，并在Unreal项目浏览器中使用以下参数创建一个新项目：
- en: Blank Blueprint template
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白蓝图模板
- en: Hardware target set to Mobile / Tablet
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件目标设置为移动/平板电脑
- en: Graphics target set to Scalable 3D or 2D
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形目标设置为可扩展的3D或2D
- en: No starter content
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有初始内容
- en: Put it wherever you'd like.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将其放在您喜欢的任何位置。
- en: 'Now, let''s take the pawn we created in the previous project and add it to
    this one. To do this, we''re going to have to jump back to our previous project
    to grab the assets we want to migrate:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将在前一个项目中创建的Pawn添加到这个项目中。为了做到这一点，我们将不得不跳回到我们之前的项目中，以获取我们想要迁移的资产：
- en: Select File | Open Project and browse to your previous project's `.uproject`
    file. Open it up. Your current project will close when you do this.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件 | 打开项目，并浏览到您之前项目的`.uproject`文件。打开它。这样做时，您当前的项目将关闭。
- en: Once in your previous project, find the `BP_VRGameMode` blueprint we created.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入您之前的项目，找到我们创建的`BP_VRGameMode`蓝图。
- en: 'Right-click it and select Asset Actions | Migrate..., as shown in the following
    screenshot:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它，选择Asset Actions | Migrate...，如下图所示：
- en: '![](img/9441816b-3345-4281-a762-a8ad4dbd1fdf.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9441816b-3345-4281-a762-a8ad4dbd1fdf.png)'
- en: 'In addition to the object you select, the Migrate... utility collects any other
    object that your selected object relies on to work. Because our Game Mode uses
    the VRPawn as its default pawn, the Migrate... utility will collect the pawn,
    as well as the teleport indicator we made for it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您选择的对象之外，Migrate...实用程序还会收集您选择的对象所依赖的任何其他对象。因为我们的游戏模式使用VRPawn作为默认Pawn，所以Migrate...实用程序将收集Pawn以及我们为其创建的传送指示器：
- en: '![](img/99ea7613-1e40-499b-a43d-bf3f54d337bf.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99ea7613-1e40-499b-a43d-bf3f54d337bf.png)'
- en: Hit OK, and when you're asked where to put the new content, select your new
    project's `Content` directory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确定，当被问到要将新内容放在哪里时，选择你的新项目的Content目录。
- en: Great! Copies of your game mode and pawn have now been added to your new project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你的游戏模式和Pawn的副本现在已经添加到你的新项目中。
- en: We also mapped a few inputs, and we're going to need those too.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还映射了一些输入，我们也需要它们。
- en: Copying input bindings
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制输入绑定
- en: 'Remember when we mentioned that input mappings are just text entries in `DefaultInput.ini`?
    Since we haven''t mapped any inputs in our new project, we can recreate the old
    project''s input bindings by just copying the `DefaultInput.ini` file. You could
    just as easily recreate the inputs using the Project Settings menu, but it''s
    faster to do it this way when you can get away with it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们提到过输入映射只是`DefaultInput.ini`中的文本条目吗？由于我们在新项目中没有映射任何输入，我们可以通过复制`DefaultInput.ini`文件来重新创建旧项目的输入绑定。您也可以使用项目设置菜单重新创建输入，但是如果可以这样做，这种方式更快：
- en: Navigate to your old project's `Config` directory.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到旧项目的Config目录。
- en: Select `DefaultInput.ini` and copy it to your new project's `Config` directory.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`DefaultInput.ini`并将其复制到您的新项目的`Config`目录中。
- en: 'If you open it up, you''ll see that it contains the input bindings we created,
    as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开它，你会看到它包含了我们创建的输入绑定，如下面的截图所示：
- en: '![](img/7a79d9be-4067-4c64-bccf-d0d76e8f8198.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a79d9be-4067-4c64-bccf-d0d76e8f8198.png)'
- en: Setting up new project to use the migrated game mode
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新项目使用迁移的游戏模式
- en: 'Now that we''ve copied our Game Mode and our Pawn, and our input bindings have
    been set up, we can return to our new project:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经复制了我们的游戏模式和Pawn，并且我们的输入绑定已经设置好，我们可以返回到我们的新项目：
- en: If you hit File | Recent Projects, it should be listed there, but if not, use
    File | Open Project to navigate to it
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你点击文件 | 最近的项目，它应该在列表中，但如果没有，使用文件 | 打开项目导航到它
- en: 'Now, let''s set up our project to use the game mode we just brought over:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置我们的项目使用刚刚带过来的游戏模式：
- en: Open Project Settings | Project | Maps & Modes, and under Default Modes, set
    Default GameMode to `BP_VRGameMode`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开项目设置 | 项目 | 地图和模式，并在默认模式下，将默认游戏模式设置为`BP_VRGameMode`
- en: This will cause this game mode to be used on any map in our project, unless
    we override it. As you'll recall, this game mode tells the project to load up
    our VRPawn.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致该游戏模式在我们项目中的任何地图上使用，除非我们覆盖它。正如你记得的那样，这个游戏模式告诉项目加载我们的VRPawn。
- en: Additional project settings for VR
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VR相关的其他项目设置
- en: 'Remember to set those other VR-relevant settings we described in [Chapter 3](d32af29c-fd54-4d92-95df-30f74ad63a72.xhtml),
    *Hello World – Your First VR Project*, as well:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记得设置我们在[第3章](d32af29c-fd54-4d92-95df-30f74ad63a72.xhtml)中描述的其他与VR相关的设置，例如：
- en: Project Settings | Engine | Rendering | VR | Instanced Stereo: True
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | VR | 实例化立体声：True
- en: Project Settings | Engine | Rendering | VR | Round Robin Occlusion Queries: True
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | VR | 环形轮询遮蔽查询：True
- en: Project Settings | Engine | Rendering | Forward Renderer | Forward Shading: True
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | 正向渲染器 | 正向着色：True
- en: Project Settings | Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | 默认设置 | 抗锯齿方法：MSAA
- en: Project Settings | Engine | Rendering | Default Settings | Ambient Occlusion
    Static Fraction: False
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 引擎 | 渲染 | 默认设置 | 环境遮蔽静态分数：False
- en: Project Settings | Project | Description | Settings | Start in VR: True
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置 | 项目 | 描述 | 设置 | 在VR中启动：True
- en: Also, remember that you shouldn't follow these blindly. For lots of VR projects,
    forward shading will be the way to go, but you should always put a little bit
    of thought into whether the particular thing you're doing would work better with
    the deferred shading model. (This may be the case if you're going to do a lot
    of dynamic lighting and reflective surfaces.) The same goes for the anti-aliasing
    method. MSAA is usually what you'll want if you're doing forward shading, but
    there are instances in which temporal anti-aliasing or FXAA will look better.
    Instanced Stereo is pretty much always something you'll want, and the same goes
    for the Round-Robin Occlusion Queries.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，你不应该盲目地遵循这些步骤。对于许多VR项目，正向渲染将是最佳选择，但你应该对你正在做的特定事物是否适合延迟渲染模型进行一些思考。（如果你要进行大量的动态照明和反射表面，这可能是适用的情况。）对于抗锯齿方法也是一样。如果你使用正向渲染，通常会选择MSAA，但在某些情况下，时域抗锯齿或FXAA会更好看。实例化立体声几乎总是你想要的，环形轮询遮蔽查询也是一样。
- en: Testing our migrated game mode and pawn
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们迁移的游戏模式和Pawn
- en: 'Let''s test it before we do anything else:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何其他操作之前，让我们先测试一下：
- en: Drag a Nav Mesh Bounds Volume onto the default map that opened with our project,
    and scale it to cover the entire floor. (Remember that you can hit *P* to view
    it.)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个导航网格边界体拖到我们项目中默认打开的地图上，并将其缩放到覆盖整个地板。（记住你可以按下P键查看它。）
- en: Launch a VR Preview and verify that you can teleport around your map and use
    seamless movement.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动VR预览，验证你可以在地图上进行传送并使用无缝移动。
- en: Excellent. This quick test allows us to verify that the game mode we brought
    over from the other project has loaded and it's spawning an instance of our VR
    Pawn at the player start.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。这个快速测试可以让我们验证从其他项目中带过来的游戏模式已加载，并在玩家起始点生成了我们的VR Pawn的实例。
- en: Test things as you build them, a step at a time. It's far easier to find the
    source of a bug after a few changes than after a lot of changes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时逐步测试事物。在进行了一些更改之后，找到错误的源头要比进行了很多更改之后容易得多。
- en: Adding scenery
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加景观
- en: 'Now, let''s bring in some scenery so that we have a place to play:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们引入一些景观，以便我们有一个玩耍的地方：
- en: 'Open up your Epic Games Launcher and in the Marketplace, search for Soul: City.
    (It''s free.)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开你的Epic Games Launcher，在市场中搜索Soul: City。（它是免费的。）'
- en: Hit Add To Project, and add it to the project you're working on now.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加到项目，并将其添加到你现在正在工作的项目中。
- en: Once it's done, reopen your project if you closed it, and open Content | Soul
    City | Maps | LV_Soul_Slum_Mobile.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，如果你关闭了项目，请重新打开它，并打开内容 | Soul City | 地图 | LV_Soul_Slum_Mobile。
- en: Grab a coffee while your shaders compile. Now, we should set up our project
    to open this map automatically.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译着色器时喝杯咖啡。现在，我们应该设置我们的项目自动打开这个地图。
- en: In Project Settings | Project | Maps & Modes, set Editor Startup Map and Game
    Default Map to `LV_Soul_Slum_Mobile`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目设置 | 项目 | 地图和模式中，将编辑器启动地图和游戏默认地图设置为`LV_Soul_Slum_Mobile`。
- en: Adding a NavMesh
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个导航网格
- en: We're also going to need to add a Nav Mesh Bounds Volume to this scene so that
    we can teleport through it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在这个场景中添加一个导航网格边界体，以便我们可以通过它进行传送。
- en: 'As you learned in the previous chapter, setting up a Bounds volume can be an
    involved process if you want to do it right. For our purposes here, we''re going
    to cheat a little and just drop a volume generally over the bulk of the scene.
    If you''d like to tune the volume further, you can scale it and place it more
    carefully, and use nav modifiers to exclude areas you don''t want. If you want
    to keep it simple, the following settings are good enough for what we''re focusing
    on here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前一章中学到的，如果你想做得正确，设置边界体积可能是一个复杂的过程。对于我们在这里的目的，我们将稍微作弊，只是大致覆盖场景的大部分区域。如果你想进一步调整体积，你可以缩放它并更仔细地放置它，并使用导航修改器来排除你不想要的区域。如果你想保持简单，以下设置对我们在这里关注的内容已经足够好了：
- en: '![](img/76a5651a-2d5e-4e99-996d-cd9a2c9877aa.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76a5651a-2d5e-4e99-996d-cd9a2c9877aa.png)'
- en: 'Location: X=3600, Y=-1200, Z=0'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置：X=3600，Y=-1200，Z=0
- en: 'Scale: X=100, Y=40, Z=30'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比例：X=100，Y=40，Z=30
- en: 'We get the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![](img/c1d22aac-c73c-448d-88fd-6469d6615a2b.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1d22aac-c73c-448d-88fd-6469d6615a2b.png)'
- en: Our NavMesh is kind of a shambles on this map. If you'd like to clean it up,
    feel free to apply the methods we talked about in the previous chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的导航网格在这个地图上有点混乱。如果你想清理一下，可以随意应用我们在前一章中讨论过的方法。
- en: Testing the map
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试地图
- en: 'Launch a VR preview and explore the scene a bit. Hmm. Something''s wrong. Our
    input isn''t working correctly. Because we verified on the previous step that
    our pawn works and our input mappings are good, we know that''s not the problem.
    Let''s make sure we''re loading the correct pawn:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 启动VR预览并探索一下场景。嗯。有些问题。我们的输入没有正常工作。因为我们在前一步验证了我们的Pawn工作正常，输入映射也没问题，所以我们知道那不是问题。让我们确保我们加载了正确的Pawn：
- en: Open up your World Settings, and look at the Game Mode | Game Mode Override.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的世界设置，查看游戏模式|游戏模式覆盖。
- en: Sure enough, there's another game mode being loaded there. Use the reset arrow
    to clear the overridden game mode.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 果然，还有另一个正在加载的游戏模式。使用重置箭头清除被覆盖的游戏模式。
- en: Let's test again. That's much better. Now, we're able to navigate through the
    environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次测试。好多了。现在，我们能够在环境中导航了。
- en: 'While we''re here and able to walk around, let''s point out a few things about
    this environment. It''s not a perfect environment for a virtual reality project,
    and in this case, that gives us a few useful things to talk about:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里并且能够四处走动时，让我们指出一些关于这个环境的事情。这不是一个完美的虚拟现实项目环境，在这种情况下，这给了我们一些有用的东西可以谈论：
- en: '**Scale matters in VR**: First, as we walk around, we can see that the scale
    of certain objects is inconsistent. Some of the staircases appear to be the correct
    size, while others are enormous. We''re not going to do anything about that here,
    but this is an important takeaway: the scale of the objects in your world matters
    a great deal in VR. People have an instinctive sense of how big things are, and
    VR gives them much stronger cues about the sizes of objects than flat screens
    do. If your scale is off, they''ll notice that in VR.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在VR中比例很重要**：首先，当我们四处走动时，我们可以看到某些物体的比例不一致。有些楼梯看起来大小合适，而其他的则很大。我们在这里不打算对此做任何处理，但这是一个重要的要点：你世界中物体的比例在VR中非常重要。人们对物体的大小有一种本能的感觉，而VR给他们提供了比平面屏幕更强烈的关于物体大小的线索。如果你的比例不正确，他们会在VR中注意到。'
- en: '**Lights can cause lens flares in VR**: The other potential issue is the bright
    neon lights. They make for a great-looking environment, but you''re probably noticing
    that they sometimes flare the Fresnel lenses in your headset from certain angles.
    We''re not saying you need to avoid bright lights or contrasts in your scenes,
    but be aware that they can sometimes call attention to the hardware. The takeaway
    here is that you always want to check your artwork in the VR headset in addition
    to the flat screen.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灯光可能会在VR中产生镜头光晕**：另一个潜在的问题是明亮的霓虹灯。它们使环境看起来很棒，但你可能会注意到它们有时会从某些角度使你的头戴设备的菲涅耳透镜产生光晕。我们并不是说你需要避免在场景中使用明亮的灯光或对比度，但要注意它们有时会引起对硬件的注意。这里的要点是你总是希望在VR头戴设备和平面屏幕上检查你的艺术作品。'
- en: Creating hands
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建手部
- en: Now that we have a scene to work with, let's get to the meat of this chapter
    and start setting up some interaction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个场景可以使用，让我们进入本章的核心并开始设置一些交互。
- en: Before we do anything else, let's improve the way we're representing the motion
    controllers in the scene. Currently, we're using debug meshes, which won't render
    correctly if our user is using a different headset from the one we used when we
    authored the scene. It was good enough to get us going, but now we need to replace
    it with something more permanent.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做其他事情之前，让我们改进一下场景中运动控制器的表示方式。目前，我们正在使用调试网格，如果我们的用户使用的是与我们在创建场景时使用的不同的头戴设备，它们将无法正确渲染。这足够让我们开始，但现在我们需要用更持久的东西来替换它。
- en: To get a hand mesh we can use, we're going to raid the VR Template. It's likely
    that, for many of your VR projects, you'll simply begin by creating a project
    based on the VR Template, or you'll migrate the entire MotionController Pawn Blueprint
    into a project you've created, but for our purposes here, we want to build the
    pawn ourselves so that we understand what's in it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得可用的手部网格，我们将从VR模板中获取。对于你的许多VR项目来说，你可能只是从VR模板开始创建一个项目，或者将整个MotionController
    Pawn蓝图迁移到你创建的项目中，但对于我们在这里的目的，我们希望自己构建Pawn，以便我们了解其中的内容。
- en: Migrating hand meshes and animations from the VR Template project
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从VR模板项目迁移手部网格和动画
- en: 'If you already have an example of the VR Template project created, use File
    > Open Project to open it up. If you don''t already have one, close your current
    project and from your Epic Launcher, launch the engine and create a new project
    using the VR Template. It doesn''t really matter what other settings you use for
    this one—we''re just here for the meshes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经创建了一个VR模板项目的示例，请使用文件>打开项目来打开它。如果你还没有一个，关闭当前项目，然后从Epic Launcher中启动引擎，并使用VR模板创建一个新项目。对于这个项目，你使用的其他设置并不重要——我们只是为了获取网格而在这里：
- en: In the VR Template project's Content Browser, navigate to Content | VirtualReality
    | Mannequin | Animations.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VR模板项目的内容浏览器中，导航到Content | VirtualReality | Mannequin | Animations。
- en: 'Select the three animation assets, right-click them, and select Asset Actions
    | Migrate. Ignore the blend space and animation blueprint for now—we''re going
    to learn how to make these ourselves:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这三个动画资产，右键点击它们，选择Asset Actions | Migrate。暂时忽略混合空间和动画蓝图，我们将学习如何自己制作它们：
- en: '![](img/0a11a901-3060-461a-93c6-d9dcad433527.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a11a901-3060-461a-93c6-d9dcad433527.png)'
- en: 'You''ll see that the Migrate utility has not only collected the animations
    you selected, but it also found the mesh, its physics asset, and its skeleton,
    along with its material and the textures that feed into it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到迁移实用程序不仅收集了您选择的动画，还找到了网格、物理资产和骨骼，以及其材质和输入到其中的纹理：
- en: '![](img/c3c36a77-fa76-48cc-b883-8d50c91d3a9c.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3c36a77-fa76-48cc-b883-8d50c91d3a9c.png)'
- en: Select your current project's `Content` directory as your destination.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前项目的Content目录选为目标。
- en: Now that we've collected a few assets we can use, we're ready to return to our
    project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了一些可以使用的资产，我们准备返回我们的项目。
- en: Hit File | Recent Projects, and open your previous project. (Use File | Open
    Project if it doesn't appear here.)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文件 | 最近的项目，打开您之前的项目。（如果这里没有出现，请使用文件 | 打开项目。）
- en: Adding hand meshes to our motion controllers
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将手部网格添加到我们的运动控制器上
- en: Back in our current project, we should now have a `VirtualReality` directory
    in our Content Browser, with a `Mannequin` subdirectory containing `Animations`
    and the `Character` folder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们当前的项目，我们现在应该在内容浏览器中有一个`VirtualReality`目录，其中包含一个`Mannequin`子目录，其中包含`Animations`和`Character`文件夹。
- en: Let's apply these hand meshes to our pawn's motion controllers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些手部网格应用到我们的角色的运动控制器上。
- en: Creating a new Blueprint Actor class
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的蓝图Actor类
- en: 'The first thing we''re going to want to do is create a Blueprint to represent
    them, since we want to animate the hands to respond to the player''s actions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个蓝图来表示它们，因为我们希望动画手部以响应玩家的动作：
- en: Right-click in your project's `Blueprints` directory, and select Create Basic
    Asset | Blueprint Class.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的蓝图目录中右键点击，选择创建基本资产 | 蓝图类。
- en: Select Actor as its parent class.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其父类设置为Actor。
- en: Let's name it `BP_VRHand`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将其命名为`BP_VRHand`。
- en: Open it up.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它。
- en: We mentioned earlier in this book that a core principle of object-oriented development
    is that we pull things that belong together into self-contained objects that can
    handle their own behaviors. This is a good opportunity to do this, since we're
    about to link animated hand meshes with our motion controllers. We could absolutely
    get away with just adding a pair of skeletal mesh components to our pawn and attaching
    them to our motion controller components, but it's going to be much cleaner and
    ultimately easier to manage if we architect things a little better than that.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中早些时候提到，面向对象开发的核心原则之一是将属于一起的东西放入自包含的对象中，这些对象可以处理自己的行为。由于我们即将将动画手部网格与运动控制器连接起来，这是一个很好的机会来做到这一点。我们完全可以只向我们的角色添加一对骨骼网格组件，并将它们附加到我们的运动控制器组件上，但如果我们能更好地设计一下，事情会更加清晰，最终也更容易管理。
- en: Adding motion controller and mesh components
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加运动控制器和网格组件
- en: 'Let''s add the components we''re going to need:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们需要的组件：
- en: Add a MotionController component to your Components list.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MotionController组件添加到您的组件列表中。
- en: 'With the new MotionController component selected, add a Skeletal Mesh component
    so that it becomes a child of the motion controller:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的MotionController组件后，添加一个骨骼网格组件，使其成为运动控制器的子组件：
- en: '![](img/eb792426-2737-4b91-93b1-00d42b257e08.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb792426-2737-4b91-93b1-00d42b257e08.png)'
- en: Let's name it `HandMesh`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将其命名为`HandMesh`。
- en: 'In the Skeletal Mesh component''s Details panel, set its Mesh | Skeletal Mesh
    property to `MannequinHand_Right`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在骨骼网格组件的详细面板中，将其Mesh | Skeletal Mesh属性设置为`MannequinHand_Right`：
- en: '![](img/5c3075ae-98fd-4640-ab12-49bd26d28e00.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c3075ae-98fd-4640-ab12-49bd26d28e00.png)'
- en: Adding a Hand variable
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个Hand变量
- en: 'Since we''re going to reuse this VRHand for both the right and left hands,
    we need to set up a way for the object to know which hand it''s representing:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在右手和左手都重用这个VRHand，我们需要设置一种方式让对象知道它代表的是哪只手：
- en: Add a variable to the Variables list of `BP_VRHand` and name it `Hand`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BP_VRHand`的变量列表中添加一个变量，并将其命名为`Hand`。
- en: Set its Variable Type to `EController Hand`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其变量类型设置为`EController Hand`。
- en: 'Set its Instance Editable property to `true`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Instance Editable属性设置为`true`：
- en: '![](img/7b94bb57-afbb-4445-9514-c19532b567d7.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b94bb57-afbb-4445-9514-c19532b567d7.png)'
- en: 'You''ll notice that, when you set Instance Editable to true, the eye icon next
    to the variable''s name is open. This indicates that this variable is allowed
    to be set to different values for each separate instance of the object in the
    world. Since we need one of these objects to be set to the right hand and the
    other to the left hand, this is what we want here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，当您将Instance Editable设置为true时，变量名称旁边的眼睛图标是打开的。这表示该变量允许为世界中的每个单独实例设置不同的值。由于我们需要将其中一个对象设置为右手，另一个设置为左手，这正是我们想要的：
- en: '![](img/dbc8ae17-185f-45c1-ab85-fef0003c6ff0.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbc8ae17-185f-45c1-ab85-fef0003c6ff0.png)'
- en: Now that we have an instance-editable Hand variable indicating which hand this
    object is going to represent, we need to tell our MotionController component about
    that too. We're going to do this in the VRHand's Construction Script.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个实例可编辑的Hand变量，指示这个对象将代表哪只手，我们还需要告诉我们的MotionController组件。
- en: Using a Construction Script to handle updates to the Hand variable
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造脚本处理对Hand变量的更新
- en: 'If you look at the Functions list for your `BP_VRHand` class, you''ll see that
    a Construction Script has been automatically created for you. This is a function
    that runs when the object is created or updated before gameplay has begun. Construction
    Scripts are very useful for synchronizing values that need to be lined up before
    the software runs. In our case, this is exactly what we want. If we change the
    value of this Hand variable, we want the motion controller''s motion source to
    change automatically to match up with it. Let''s make that happen:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`BP_VRHand`类的函数列表，你会发现一个Construction Script已经自动为你创建了。这是一个在对象创建或更新之前在游戏开始之前运行的函数。Construction
    Scripts非常有用，可以在软件运行之前同步需要对齐的值。在我们的情况下，这正是我们想要的。如果我们改变这个Hand变量的值，我们希望动作控制器的运动源自动改变以与之匹配。让我们实现这个目标：
- en: Open up your BP_VRHand's Construction Script.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的BP_VRHand的Construction Script。
- en: Drag a reference to your Motion Controller component into the Construction Script.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对Motion Controller组件的引用拖入Construction Script中。
- en: 'Drag out its output and call `Set Motion Source` on it:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖出它的输出并调用`Set Motion Source`：
- en: '![](img/d2af2436-de00-43e8-83a6-005e08e7b363.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2af2436-de00-43e8-83a6-005e08e7b363.png)'
- en: Drag a reference to the `Hand` variable into your Construction Script.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个对`Hand`变量的引用拖入你的Construction Script中。
- en: 'Drag its output onto the `Motion Source` input. You''ll see a `Convert EControllerHand
    Enum to Name` node appear automatically:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其输出拖到“Motion Source”输入上。你会看到一个“Convert EControllerHand Enum to Name”节点自动出现：
- en: '![](img/ae339c70-a222-433d-b502-8e0fdf873a8d.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae339c70-a222-433d-b502-8e0fdf873a8d.png)'
- en: Some data types can be converted easily into other types. In this case, we're
    converting an enum into a name. **Enum** is short for **enumerator**. An enum
    is a special data type that allows us to create a predefined list of values and
    then use that collection of values as a data type. If you have a known set of
    possible values for a data type, it's far better to use an enum to list them than
    it is to use a name or a string. This prevents a typo from causing a value to
    fail, and compares much, much faster than a string comparison. It's generally
    pretty easy to turn enum values into human-readable values in Blueprint when we
    need them, as we're doing here.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 某些数据类型可以很容易地转换为其他类型。在这种情况下，我们将一个枚举转换为一个名称。**Enum**是**enumerator**的缩写。枚举是一种特殊的数据类型，允许我们创建一个预定义的值列表，然后将该值集合用作数据类型。如果你对数据类型有一个已知的可能值集合，最好使用枚举来列出它们，而不是使用名称或字符串。这样可以防止拼写错误导致值失败，并且与字符串比较相比，比较速度要快得多。当我们需要时，在蓝图中将枚举值转换为可读的值通常非常容易，就像我们在这里所做的一样。
- en: 'Finally, connect your execution output of Construction Script to the `Set Motion
    Source` input, so that your whole Construction Script looks like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将你的Construction Script的执行输出连接到“Set Motion Source”输入，这样你的整个Construction Script看起来就像这样：
- en: '![](img/2896a453-4230-4ec2-950c-1d2509fcf690.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2896a453-4230-4ec2-950c-1d2509fcf690.png)'
- en: Adding BP_VRHand child actor components to your pawn
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将BP_VRHand子Actor组件添加到你的pawn中
- en: 'Let''s return to our `BP_VRPawn` blueprint now:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们返回到我们的`BP_VRPawn`蓝图中：
- en: In its Components list, select your Camera Root component, and add a Child Actor
    Component as a child.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其组件列表中，选择你的Camera Root组件，并添加一个Child Actor组件作为子组件。
- en: Name it `Hand_L`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`Hand_L`。
- en: In its Details, under Child Actor Component, set the Child Actor Class to `BP_VRHand`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细信息中，将Child Actor Component的Child Actor Class设置为`BP_VRHand`。
- en: Select Camera Root again so that it will be the parent of the next component
    we make, and add another Child Actor component.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择Camera Root，以便它成为我们接下来创建的组件的父级，并添加另一个Child Actor组件。
- en: Set its class to `BP_VRHand`, and name it `Hand_R`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其类设置为`BP_VRHand`，并将其命名为`Hand_R`。
- en: This time, below the Child Actor Class property, expand the Child Actor Template
    property.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，在Child Actor Class属性下方，展开Child Actor Template属性。
- en: Set Child Actor Template | Default | Hand to `Right`. (We're able to do this
    because we made this variable instance editable in the preceding steps.)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Child Actor Template | Default | Hand设置为`Right`。（我们能够这样做是因为在前面的步骤中我们使这个变量实例可编辑。）
- en: Now we need to ensure that the BP_VRHand actors spawned by these components
    know that this pawn is their owner. This is required for the motion controllers
    to register correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要确保由这些组件生成的BP_VRHand actors知道这个pawn是它们的所有者。这对于动作控制器正确注册是必需的。
- en: In `BP_VRPawn`, find Event BeginPlay in the Event Graph.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BP_VRPawn`中，在事件图中找到事件BeginPlay。
- en: Drag a reference to the `Hand_L` component you just created onto the graph.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将刚刚创建的`Hand_L`组件的引用拖到图表中。
- en: Drag its output and select Get Child Actor to get a reference to the `BP_VRHand`
    object it contains.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动它的输出并选择Get Child Actor以获取对其中包含的`BP_VRHand`对象的引用。
- en: Drag the Child Actor output and call Set Owner on it.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动Child Actor的输出并调用Set Owner。
- en: Right-click in the graph and select Get a Reference to Self to create a Self
    node.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击并选择Get a Reference to Self以创建一个Self节点。
- en: Drag Self into the Set Owner node's New Owner input.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Self拖入Set Owner节点的New Owner输入。
- en: Drag the execution output from Set Tracking Origin into the Set Owner node's
    execution input.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Set Tracking Origin的执行输出拖到Set Owner节点的执行输入中。
- en: Repeat this for the `Hand_R` component.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Hand_R`组件也重复这个步骤。
- en: '![](img/d4ddcbbc-30f6-4049-abb1-553fb33c76e0.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4ddcbbc-30f6-4049-abb1-553fb33c76e0.png)'
- en: Before we do anything else, let's test it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在做其他任何事情之前，让我们进行测试。
- en: We should still see our old motion controllers rendered since we haven't gotten
    rid of them yet, but we should now see a pair of hands as well, and they should
    be moving correctly with our motion controllers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该仍然能看到我们旧的动作控制器渲染出来，因为我们还没有摆脱它们，但是我们现在应该也能看到一双手，并且它们应该能正确地随着我们的动作控制器移动。
- en: Our hands have a few problems we should fix, though.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的手部还有一些问题需要解决。
- en: Fixing issues with Hand meshes
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复手部模型的问题
- en: 'If we look at our hands as they move with the motion controllers, we can see
    that they''re displaying at an unexpected angle:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察手部随着动作控制器移动的情况，我们会发现它们显示的角度是意外的：
- en: 'Let''s fix this by setting the `HandMesh` component''s Transform | Rotation
    to 90° around the *X* axis:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过将“HandMesh”组件的Transform | Rotation设置为绕*X*轴旋转90°来修复这个问题：
- en: '![](img/6c652d73-8d46-4c3e-a36f-193014a8facc.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c652d73-8d46-4c3e-a36f-193014a8facc.png)'
- en: Second, they're both appearing as right hand meshes, even though one of them
    is bound to the left hand. We can fix this in our construction script too.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它们都显示为右手网格，即使其中一个绑定到了左手。我们也可以在构造脚本中修复这个问题。
- en: Drag out an `==` operator from our Hand variable's output. Test to see whether
    it's equal to Left.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的Hand变量的输出中拖出一个“==”运算符。测试它是否等于Left。
- en: Add a Branch node using this test result as its condition.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此测试结果作为条件添加一个分支节点。
- en: Drag a reference to your `Hand Mesh` into your construction script graph.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对“Hand Mesh”的引用拖入构造脚本图中。
- en: 'If Hand `==` Left, call `Set World Scale 3D` on your `Hand Mesh` to X=1.0,
    Y=1.0, and Z=-1.0:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Hand `==` Left，则在你的“Hand Mesh”上调用“Set World Scale 3D”，将其设置为X=1.0，Y=1.0和Z=-1.0：
- en: '![](img/e87d46f2-d119-4c57-82b0-cd9807418627.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e87d46f2-d119-4c57-82b0-cd9807418627.png)'
- en: Setting the Hand mesh scale to -1 on its *Z* axis mirrors it along that axis,
    which is a spiffy way of creating a left-handed mesh from a right hand without
    having to create a second mesh.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将手的网格缩放设置为-1，即在其*Z*轴上进行镜像，这是一种聪明的方法，可以从右手创建一个左手的网格，而无需创建第二个网格。
- en: 'Give it another try. The hands should now be angled better, and you should
    now have one left and one right hand. It''s still not perfect, though. The hand
    meshes aren''t quite in the right spot, and as a result, they don''t quite feel
    like our own hands:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次。现在手应该更好地倾斜，你应该有一个左手和一个右手。不过，还不完美。手的网格位置还不太对，因此它们不太像我们自己的手：
- en: Select the `HandMesh` component from your Components list, and set its Details
    | Transform | Location to X=-13.0, Y=0.0, Z=-1.8.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从组件列表中选择“HandMesh”组件，并将其详细信息|转换|位置设置为X=-13.0，Y=0.0，Z=-1.8。
- en: Nudge these values around until they feel about right to you.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微调这些值，直到它们对你感觉合适。
- en: Getting the angle of the hands right is very important in VR. As we discussed
    in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml), *Thinking in VR*,
    our proprioceptive sense of where our hands are is very strong, and if they look
    even a little bit out of place, they won't feel real. Take the time to find what
    feels natural here. It's a subtle detail, but it matters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中，正确设置手的角度非常重要。正如我们在[第1章](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml)中讨论的那样，我们对手的位置的感知能力非常强，如果它们看起来有一点点不对劲，它们就不会感觉真实。花时间找到在这里感觉自然的方式。这是一个微妙的细节，但它很重要。
- en: Replacing references to our old motion controller components in blueprints
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图中替换对旧的运动控制器组件的引用
- en: 'Now that we''ve got our hands in place, we need to remove the old, redundant
    motion controller components from our pawn and where we''re referring to them,
    replace those references with references to our new hands. Let''s get started:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将手放在了正确的位置，我们需要从角色中删除旧的、多余的运动控制器组件，并将引用它们的地方替换为对我们新手的引用。让我们开始吧：
- en: Open up your pawn blueprint and select its `MotionController_L` component.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的角色蓝图，并选择其“MotionController_L”组件。
- en: 'Right-click it and select Find References (Pressing *Alt* + *Shift* + *F* will
    do this as well):'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它，选择查找引用（按下*Alt* + *Shift* + *F*也可以）：
- en: '![](img/e4099af1-18d8-4c1e-ad2e-3f87ff5c8511.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4099af1-18d8-4c1e-ad2e-3f87ff5c8511.png)'
- en: A Find Results panel will open and show you where this component is being used
    in your blueprint. We can see from this list that `MotionController_L` is being
    used in one place in our graph.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个查找结果面板将打开，并显示此组件在蓝图中的使用位置。从这个列表中我们可以看到，“MotionController_L”在我们的图表中被使用了一次。
- en: 'Double-click it to jump to where it''s being used in our Event Graph:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击它跳转到在事件图中使用它的位置：
- en: '![](img/8874a793-6d8f-48e8-9662-b06486378b41.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8874a793-6d8f-48e8-9662-b06486378b41.png)'
- en: We want to replace our reference to `MotionController_L` with a reference to
    our newly created `Hand_L`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要用对新创建的“Hand_L”的引用替换对“MotionController_L”的引用。
- en: Drag a reference to `Hand_L` onto your graph.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对“Hand_L”的引用拖入你的图表中。
- en: We can't simply replace a reference to `MotionController_L` with a reference
    to our `Hand_L` object, because that object itself isn't moving with the controller.
    It contains a motion controller component, and the visible Hand Mesh is a child
    of that motion controller. We need to get a reference to that motion controller—or
    even better since the player can see it—to the hand mesh.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将对“MotionController_L”的引用替换为对我们的“Hand_L”对象的引用，因为该对象本身并不随控制器移动。它包含一个运动控制器组件，可见的手网格是该运动控制器的子级。我们需要获取对该运动控制器的引用，或者更好的是，因为玩家可以看到它，获取对手的网格的引用。
- en: Creating a function to get our hand mesh
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数来获取我们的手的网格
- en: 'The first thing we need to do to get access to the internal components of our
    `VRHand` object is to get a reference to the child actor that''s contained within
    our Child Actor Component. Let''s get started:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问我们的“VRHand”对象的内部组件，我们首先需要获取对包含在我们的子级角色组件中的子级角色的引用。让我们开始吧：
- en: 'From `Hand_L`, drag out a connector and select Get Child Actor:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Hand_L”中拖出一个连接器，并选择“获取子级角色”：
- en: '![](img/8cf55bda-db79-4ec9-8c66-7390fe740f90.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cf55bda-db79-4ec9-8c66-7390fe740f90.png)'
- en: Remember all of the times we mentioned that Unreal Engine is an object-oriented
    environment? We keep coming back to this because it's important. The Child Actor
    reference we just extracted from our Child Actor component is a reference to an
    `Actor` class. As we mentioned in the previous chapters, Actor is the parent class
    for any object that can be placed in the world. The `Actor` class, however, doesn't
    have a Hand Mesh component. It just has the basic stuff required to place any
    object in the world. A `BP_VRHand` object, which is a child of the `Actor` class,
    does contain this component. We need to tell Unreal that the actor we're working
    with in this case is a `BP_VRHand`. We do this using a `Cast` operator.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们提到过虚幻引擎是一个面向对象的环境吗？我们一直回到这一点，因为这很重要。我们刚刚从Child Actor组件中提取的Child Actor引用是对Actor类的引用。正如我们在前几章中提到的，Actor是可以放置在世界中的任何对象的父类。然而，Actor类本身没有Hand
    Mesh组件。它只有将任何对象放置在世界中所需的基本内容。而BP_VRHand对象，它是Actor类的子类，包含了这个组件。我们需要告诉虚幻引擎，我们在这种情况下正在处理的Actor是一个BP_VRHand。我们使用一个Cast运算符来实现这个目的。
- en: 'Drag a connector from `Child Actor` and select `Cast to BP_VRHand`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Child Actor”拖动一个连接器，并选择“Cast to BP_VRHand”：
- en: '![](img/a930e668-cc8e-4bb7-adba-4b43e9bed11a.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/a930e668-cc8e-4bb7-adba-4b43e9bed11a.png)
- en: This will create a `Cast` node. `Cast` nodes require an execution input because
    they're not guaranteed to succeed. If you try to cast some random actor to a `BP_VRHand`,
    it will fail, because the actor you gave it isn't a `VRHand`. The cast node doesn't
    turn the object into an actor of that type—it tells the system to treat the reference
    as the specified type if it actually is an instance of that type.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个Cast节点。Cast节点需要一个执行输入，因为它们不能保证成功。如果你尝试将一些随机的actor转换为BP_VRHand，它将失败，因为你给它的actor不是VRHand。Cast节点不会将对象转换为该类型的actor-它只是告诉系统，如果实际上是该类型的实例，则将引用视为指定的类型。
- en: We're going to deal with this execution line in a moment, but first, let's get
    the hand mesh from our object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一会儿处理这个执行线，但首先，让我们从对象中获取手部网格。
- en: 'Drag a connector from the `Cast` node''s `As BP_VRHand` output and select `Get
    HandMesh`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Cast节点的As BP_VRHand输出拖动一个连接器，并选择Get HandMesh：
- en: '![](img/0a2437b2-0a7b-4e80-af3b-cc20b77b2c58.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/0a2437b2-0a7b-4e80-af3b-cc20b77b2c58.png)
- en: We can now feed this into the `GetWorldRotation` node that's currently reading
    from `MotionController_L`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将其输入到当前正在从MotionController_L读取的GetWorldRotation节点中。
- en: 'Drag the `HandMesh` output into `GetWorldRotation`, replacing the old `MotionController_L`
    reference:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HandMesh输出拖入GetWorldRotation中，替换旧的MotionController_L引用：
- en: '![](img/cbcdc4ce-9caf-419b-804d-d9a7d865691d.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/cbcdc4ce-9caf-419b-804d-d9a7d865691d.png)
- en: This isn't going to work yet, though, because we haven't connected the execution
    lines to our `Cast` node yet. If you try to compile this right now, you'll see
    a warning on the cast node and an error on `Get HandMesh` because of this.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不起作用，因为我们还没有将执行线连接到我们的Cast节点。如果你现在尝试编译这个，你会看到Cast节点上有一个警告，Get HandMesh上有一个错误，因为这个原因。
- en: There are two ways we could fix this. We could insert the Cast node into the
    main execution lines from our inputs, and only make the Add Movement Input calls
    if they succeed, but in our case here, there's a cleaner way. We can create a
    *Pure function* to perform the cast.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以解决这个问题。我们可以将Cast节点插入到输入的主执行线中，并且只有在成功时才进行Add Movement Input调用，但在我们的情况下，有一种更简洁的方法。我们可以创建一个*纯函数*来执行转换。
- en: A **Pure function** is a function that doesn't change the state of the object
    that contains it, and because of this, it doesn't need to be placed into an execution
    line. In our case here, we're just getting a reference to the hand mesh—it doesn't
    matter when we do this because we're not changing anything. We're just reading
    a value, so as long as that happens before we need to use it, that's fine.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数**是一个不改变包含它的对象状态的函数，因此它不需要放置在执行线中。在我们的情况下，我们只是获取手部网格的引用-这并不重要我们何时这样做，因为我们没有改变任何东西。我们只是读取一个值，只要在我们需要使用它之前发生这种情况，那就没问题。'
- en: Select the Hand_L node, its Child Actor, the Cast, and the Get Hand Mesh nodes.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Hand_L节点，它的Child Actor，Cast和Get Hand Mesh节点。
- en: 'Right-click and select Collapse to Function:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择折叠到函数：
- en: '![](img/45e5bf52-fdd9-48e1-abe8-96b05d235b3c.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/45e5bf52-fdd9-48e1-abe8-96b05d235b3c.png)
- en: Name the function `GetHandMeshForHand`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数命名为GetHandMeshForHand。
- en: 'Set its Pure property to `true`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Pure属性设置为true：
- en: '![](img/87e12995-9226-4f80-a43c-aea3d1e5dbd2.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/87e12995-9226-4f80-a43c-aea3d1e5dbd2.png)
- en: You'll notice that, when you did this, the execution pins went away. Now, we
    have a simple, clean node we can use to get our Hand mesh.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当你这样做时，执行引脚消失了。现在，我们有一个简单、干净的节点，可以用来获取我们的手部网格。
- en: Let's improve it. We know we're going to need to do the same operation for the
    right hand, but it would be wasteful to make a second function to do an almost-identical
    job. Let's set this function up so that it can grab either hand.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进一下。我们知道我们将需要为右手执行相同的操作，但是制作一个几乎相同的函数来完成这个工作是浪费的。让我们设置这个函数，使其可以获取任何一只手。
- en: With the function selected, find its Details | Inputs list, and hit the + button
    to create a new parameter.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择函数后，找到其详细信息|输入列表，并点击+按钮创建一个新的参数。
- en: 'Set the parameter''s type to `EControllerHand` and name it `Hand`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数的类型设置为EControllerHand，并将其命名为Hand：
- en: '![](img/0a989ac8-c9bd-40c1-b49f-a19793c8bac0.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/0a989ac8-c9bd-40c1-b49f-a19793c8bac0.png)
- en: You'll see that your pure function node now has an input selector, and because
    the input we're using is an enumerator, it already knows what values are available.
    Useful, right?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到你的纯函数节点现在有一个输入选择器，因为我们使用的输入是一个枚举器，它已经知道可用的值。很有用，对吧？
- en: This is yet another reason why enumerators are superior to strings as data types.
    Please, oh please, with very few exceptions, don't use strings as data types.
    They're slow and massively prone to user error.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个枚举器优于字符串作为数据类型的原因。请不要使用字符串作为数据类型，除非有非常少的例外情况。它们速度慢，并且极易出错。
- en: Now, we need to update our function to use this new input.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新我们的函数以使用这个新的输入。
- en: Open the `Get Hand Mesh for Hand` function.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Get Hand Mesh for Hand`函数。
- en: Right now, we're getting a reference to Hand_L, regardless of what the user
    selects for the `Hand` input. It's time to fix that.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论用户选择`Hand`输入什么，我们都会得到对Hand_L的引用。是时候修复这个问题了。
- en: Drag a connector from your `Hand` input and create a Select node.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的`Hand`输入拖出一个连接器并创建一个Select节点。
- en: Drag the return value from the Select node into the Target input of Child Actor,
    replacing the input from `Hand_L`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Select节点的返回值拖入Child Actor的Target输入中，替换`Hand_L`的输入。
- en: Take the Hand_L reference and feed its output into the selector's Left input.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取Hand_L引用并将其输出输入到选择器的Left输入中。
- en: Drag an instance of Hand_R onto the graph and feed it into the selector's Right
    input.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖出一个Hand_R的实例到图表中，并将其输入到选择器的Right输入中。
- en: 'We can leave the rest of the inputs as Null, as we''re not using them here:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将其余的输入设为Null，因为我们在这里不使用它们：
- en: '![](img/5fdf49b6-7ab3-485e-a103-d81a355e8561.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fdf49b6-7ab3-485e-a103-d81a355e8561.png)'
- en: Now, if the user feeds Left into the `Hand` argument, the `Hand_L` reference
    will be used, and if they feed in Right, it will read from `Hand_R`. We're not
    safely handling cases where the user passes in any other value here, so the function
    would throw an error if the user selected Gun or some other input. Technically,
    this would probably be fine in this case since we know exactly what inputs we
    plan to give it, but for the sake of good practice, let's make it safer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户将Left传递给`Hand`参数，将使用`Hand_L`引用，如果他们传递Right，将从`Hand_R`读取。我们在这里没有安全处理用户传入任何其他值的情况，所以如果用户选择了Gun或其他输入，函数将抛出一个错误。从技术上讲，在这种情况下，这可能是可以的，因为我们知道我们计划给它什么输入，但为了良好的实践，让我们使它更安全一些。
- en: If we pass a value into the Select node that isn't Left or Right, it's going
    to return a Null (empty) reference. Trying to read a value from an empty reference
    is a bad thing to do. In C++, it will crash your application. In Blueprint, it
    will just throw an error, but it's still not good practice to let it happen.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传入一个既不是Left也不是Right的值给Select节点，它将返回一个Null（空）引用。尝试从空引用中读取值是一件不好的事情。在C++中，它会导致应用程序崩溃。在蓝图中，它只会抛出一个错误，但是让它发生仍然不是一个好的做法。
- en: 'Drag an output from the Select node, and create an IsValid node. You have two
    versions here. Use the macro version (the one with the question mark), as this
    will give you convenient execution pins you can use:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Select节点拖出一个输出，并创建一个IsValid节点。你有两个版本可以选择。使用宏版本（带有问号的版本），因为这将为你提供方便的执行引脚：
- en: '![](img/7251e35e-efe5-49d3-85bc-1717f72d8d6c.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7251e35e-efe5-49d3-85bc-1717f72d8d6c.png)'
- en: Drag the execution pin from the function input into the Exec pin on the `IsValid`
    node.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数输入的执行引脚拖动到`IsValid`节点的Exec引脚上。
- en: Drag the IsValid output into your Cast node's input so that the IsValid check
    will happen before the cast is attempted.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将IsValid输出拖入Cast节点的输入中，以便在尝试转换之前进行IsValid检查。
- en: Drag out from the Is Not Valid output and select Add Return Node. Don't connect
    anything to the Hand Mesh output here. This will return a Null (empty) value if
    the user passes a bad input into the `Hand` variable.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Is Not Valid输出中拖出并选择Add Return Node。在这里不要连接任何东西到Hand Mesh输出。如果用户将一个错误的输入传递给`Hand`变量，这将返回一个Null（空）值。
- en: While we're at it, we should also connect our `Cast` node's Cast Failed output
    to this empty return node, so if the cast fails, it won't try to get the HandMesh
    from a bad object.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们进行这些操作的同时，我们还应该将`Cast`节点的Cast Failed输出连接到这个空的返回节点，这样如果转换失败，它就不会尝试从一个错误的对象中获取HandMesh。
- en: 'The completed function should look like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的函数应该是这样的：
- en: '![](img/deb1bd24-1277-4f47-a527-f8b9bc6ae32a.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/deb1bd24-1277-4f47-a527-f8b9bc6ae32a.png)'
- en: 'We''ve now created a pure function that returns the HandMesh contained within
    the child actor component for the supplied hand. Here it is in use:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个纯函数，它返回所提供手的子actor组件中包含的HandMesh。下面是它的使用方法：
- en: '![](img/c805256e-7c12-4d21-a1b3-eb890a1280d4.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c805256e-7c12-4d21-a1b3-eb890a1280d4.png)'
- en: Now that we've created a clean, easy-to-use function to get our Hand mesh, let's
    use it to replace our `MotionController_R` references as well.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个干净、易于使用的函数来获取我们的Hand模型，让我们用它来替换我们的`MotionController_R`引用。
- en: From your Components list, right-click `MotionController_R` and select Find
    References. You'll see that we're using it in two places.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的组件列表中，右键点击`MotionController_R`并选择Find References。你会看到我们在两个地方使用它。
- en: Double-click the first use to jump to that part of the graph.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击第一个使用，跳转到图表的那部分。
- en: Drag an instance of the `GetHandMeshForHand` function onto the graph where `MotionController_R`
    is currently being used.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GetHandMeshForHand`函数的一个实例拖到当前正在使用`MotionController_R`的图表上。
- en: From the Hand drop-down menu, select Right.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Hand下拉菜单中选择Right。
- en: 'Press *Ctrl* + drag the output connection from `MotionController_R` onto the
    output connection from `GetHandMeshForHand`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住Ctrl键并将`MotionController_R`的输出连接从`GetHandMeshForHand`的输出连接上拖动：
- en: '![](img/f007673f-122d-4c2f-8b7f-15d946e2d39b.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f007673f-122d-4c2f-8b7f-15d946e2d39b.png)'
- en: Pressing *Ctrl* + dragging is a fast way to move all of the connections to a
    Blueprint node from one pin to another.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 按住Ctrl键并拖动是一种快速将所有连接从一个引脚移动到另一个引脚的方法。
- en: 'Your graph should now look like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你的图表现在应该是这样的：
- en: '![](img/8c6f288d-c718-4e35-b153-77990fd27829.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c6f288d-c718-4e35-b153-77990fd27829.png)'
- en: Do the same for the other reference to `MotionController_R`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对另一个对`MotionController_R`的引用也做同样的操作。
- en: From the Components list, delete the `MotionController_L` and `MotionController_R`
    components.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从组件列表中删除MotionController_L和MotionController_R组件。
- en: Test it out. Your motion controllers should be working as they did before, but
    the hand meshes have now replaced the old controller meshes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下。你的动作控制器应该像以前一样工作，但是手的模型现在替换了旧的控制器模型。
- en: Animating our hands
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给我们的手添加动画
- en: Now, let's get our hands to change their posture based on the player's input.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据玩家的输入来改变手的姿势。
- en: 'The first thing we''re going to need to do here is tell the hand when the player
    wants to do something with it. Let''s do this by creating a pair of functions
    on the `BP_VRHand` that can be called from outside:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要告诉手部玩家何时想要对其进行操作。让我们通过在`BP_VRHand`上创建一对可以从外部调用的函数来实现这一点：
- en: Open up your `BP_VRHand` Blueprint.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_VRHand`蓝图。
- en: Create a new function in its Functions list. Call it `Grab Actor`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数列表中创建一个新函数。将其命名为`Grab Actor`。
- en: Create another function called `Release Actor`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`Release Actor`的函数。
- en: 'Inside each of these functions, create a Print String node with the name of
    the function in it. Since we''re not going to make these functions do anything
    just yet, we want to be able to see when they''re being called:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些函数的内部，创建一个带有函数名称的Print String节点。由于我们暂时不打算让这些函数做任何事情，我们希望能够看到它们被调用的时候：
- en: '![](img/a2664fdd-60c1-4a9c-8240-40bbe9386e41.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2664fdd-60c1-4a9c-8240-40bbe9386e41.png)'
- en: Let's do a better job of organizing our functions and variables. We haven't
    been doing this yet, but it's good practice.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更好地组织我们的函数和变量。虽然我们还没有这样做，但这是一个好的实践。
- en: For both of these functions, set their Details | Graph | Category to `Grabbing`.
    After you've used a category name once, it will appear in the drop-down list for
    other functions and variables.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这两个函数，将它们的Details | Graph | Category设置为`Grabbing`。在使用过一次类别名称后，它将出现在其他函数和变量的下拉列表中。
- en: A quick word about access specifiers
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于访问限定符的一点说明
- en: 'While we''re here, take note of the Access Specifier property for these functions.
    By default, it''s set to Public. In this case, this is what we want, but let''s
    take a moment to talk about what these access specifiers mean:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要注意这些函数的访问限定符属性。默认情况下，它设置为Public。在这种情况下，这是我们想要的，但让我们花点时间来讨论一下这些访问限定符的含义：
- en: '**Public** functions can be called from outside the class. So, if I create
    a `Foo` class with a public function called `Bar`, I can grab an instance of `Foo`
    from some other blueprint and call its `Bar` function.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Public**函数可以从类外部调用。因此，如果我创建了一个名为`Foo`的类，并在其中创建了一个名为`Bar`的公共函数，我可以从其他蓝图中获取`Foo`的实例并调用其`Bar`函数。'
- en: '**Private** functions cannot be called from outside the class. Let''s say that
    the `Bar` function is an internal operation that the `Foo` class uses as part
    of some other operation, and it shouldn''t be called from outside. In that instance,
    the function should be set to private so that nobody else will try to call it
    from outside and it won''t clutter the list of available actions for the class
    in other contexts.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Private**函数不能从类外部调用。假设`Bar`函数是`Foo`类作为某个其他操作的一部分使用的内部操作，并且不应该从外部调用。在这种情况下，应将函数设置为私有，以便其他人不会尝试从外部调用它，并且它不会在其他上下文中混淆类的可用操作列表。'
- en: '**Protected** functions cannot be called from outside the class, but can be
    called from within child objects of the class. If the `FooChild` class inherited
    from the `Foo` class, and the `Bar` function was private in the `Foo` class, `FooChild`
    would not be allowed to call it. If it was protected, then `FooChild` could call
    it, but it still couldn''t be called from outside the object.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Protected**函数不能从类外部调用，但可以从类的子对象中调用。如果`FooChild`类继承自`Foo`类，并且`Foo`类中的`Bar`函数是私有的，那么`FooChild`将无法调用它。如果它是受保护的，那么`FooChild`可以调用它，但它仍然不能从对象外部调用。'
- en: Your general rule of thumb should be to make every function private unless you
    intend to call it from outside the class. Unreal defaults to making functions
    public because this is easy for developers who may not understand access specifiers
    yet, but now that you do, you should be making everything private unless you have
    a reason not to. Early on in your development, when your application is still
    small, this won't make much of a difference, but once it gets big, it will. It's
    a big time saver and debugging aid to be able to look at a function and know that
    it's safe to change it because you can be sure that nobody else is using it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你的一般准则应该是将每个函数都设置为私有，除非你打算从类外部调用它。虚幻默认将函数设置为公共，因为这对于可能不了解访问限定符的开发人员来说很容易，但是现在你已经了解了，除非有理由不这样做，否则应该将所有函数都设置为私有。在开发的早期阶段，当应用程序还很小的时候，这不会有太大的影响，但是一旦应用程序变得庞大，它将会有所不同。能够查看一个函数并知道可以安全地更改它是一个大的时间节省和调试辅助，因为你可以确信没有其他人在使用它。
- en: For these two functions we just created, the default `Public` access specifier
    is correct, because we intend to call them from the pawn.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们刚刚创建的这两个函数，默认的`Public`访问限定符是正确的，因为我们打算从pawn中调用它们。
- en: Calling our grab functions from the pawn
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从pawn调用我们的抓取函数
- en: For now, we can close out of `BP_VRHand` and open up `BP_VRPawn`. Before we
    can do much with our pawn, though, we're going to need to add a few more action
    mappings to our project's inputs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以关闭`BP_VRHand`并打开`BP_VRPawn`。然而，在我们对pawn进行任何操作之前，我们需要向项目的输入中添加一些其他的动作映射。
- en: Creating new input action mappings
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的输入动作映射
- en: 'We''re going to do this just as we''ve done previously, using the Input UI
    in our Project Settings. Keep it somewhere in the back of your mind as well that
    these settings are just reading and writing your `DefaultInput.ini`. It''s pretty
    much always a good idea to do your work here, but worthwhile to know what''s really
    happening when you make changes in this interface. Let''s get started:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像以前一样使用项目设置中的输入UI来完成这个任务。同时，还要记住这些设置只是读取和写入你的`DefaultInput.ini`。在这里做工作几乎总是一个好主意，但了解在更改此界面时实际发生的情况也是值得的。让我们开始吧：
- en: Open Project Settings | Engine | Input, and expand the Action Mappings list.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目设置 | 引擎 | 输入，并展开动作映射列表。
- en: Add a new Action Mapping named `GrabLeft`, and bind it to `MotionController
    (L) Trigger`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`GrabLeft`的新动作映射，并将其绑定到`MotionController (L) Trigger`。
- en: 'Add another new action named `GrabRight`, and bind it to `MotionController
    (R) Trigger`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个名为`GrabRight`的新动作，并将其绑定到`MotionController (R) Trigger`：
- en: '![](img/ccdde9ce-9074-4ea7-b642-99596fbc5ab6.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccdde9ce-9074-4ea7-b642-99596fbc5ab6.png)'
- en: Close your project settings and return to your `BP_VRPawn` blueprint.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭项目设置，返回到`BP_VRPawn`蓝图。
- en: Adding handlers for new action mappings
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的动作映射处理程序
- en: 'Now that we''ve created new input actions in our project settings, let''s get
    our pawn listening for them:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在项目设置中创建了新的输入动作，让我们让我们的角色监听它们：
- en: In your pawn's Event Graph, add an InputAction GrabLeft.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的角色的事件图表中，添加一个InputAction GrabLeft。
- en: Drag a reference to your Hand_L child actor component onto the graph.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对Hand_L子级角色组件的引用拖动到图表中。
- en: Call `Get Child Actor` on it.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Get Child Actor`。
- en: '`Cast` the Child Actor''s output to a `BP_VRHand`.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子级角色的输出转换为`BP_VRHand`。
- en: Drag a connector from the As BP_VRHand output from the `Cast` node, and call
    `Grab Actor`. You're able to call this function here because we made it public.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Cast`节点的As BP_VRHand输出拖动一个连接器，并调用`Grab Actor`。你可以在这里调用这个函数，因为我们将它设置为公共的。
- en: Call the `Cast` node from the input action's Pressed output.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入动作的Pressed输出调用`Cast`节点。
- en: 'Call `Grab Actor` if the cast succeeds. The blueprint editor will probably
    connect this for you automatically:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果转换成功，则调用`Grab Actor`。蓝图编辑器可能会自动为你连接这个：
- en: '![](img/d151b385-8798-4c44-9fd8-90f5bc799408.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d151b385-8798-4c44-9fd8-90f5bc799408.png)'
- en: You can see here that we stacked the inputs on top of the Cast node. This is
    purely a visual organization strategy. It's often a convenient way of organizing
    your nodes to make it clear that the whole cluster is really just referring to
    a single object.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们将输入堆叠在Cast节点的顶部。这只是一种视觉组织策略。这通常是一种方便的方式来组织你的节点，以便清楚地表明整个集群实际上只是指一个单一的对象。
- en: Drag a marquee over the `Hand_L` node, its `Get Child Actor` call, and the `Cast`
    to select all three nodes.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动一个选框覆盖`Hand_L`节点，它的`Get Child Actor`调用和`Cast`，以选择这三个节点。
- en: Right-click them and select Collapse to Macro.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它们，选择折叠为宏。
- en: Name the new macro `GetHand_L`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新宏命名为`GetHand_L`。
- en: The new macro will have automatically inserted itself where these nodes originally
    stood.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 新的宏将自动插入到这些节点最初所在的位置。
- en: Hit *Ctrl* + *W* to duplicate the macro.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *W*复制宏。
- en: Connect the input action's Released output to the new macro's input.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入动作的Released输出连接到新宏的输入。
- en: Call `Release Actor` on the As BP_VRHand output from the macro.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在宏的As BP_VRHand输出上调用`Release Actor`。
- en: 'If we open up the `GetHand_L` macro, we will see that it contains the nodes
    we previously had sitting loose in our graph:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开`GetHand_L`宏，我们会看到它包含了我们之前在图表中散落的节点：
- en: '![](img/e49d15fe-cf98-4750-b332-8e5d69738f76.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e49d15fe-cf98-4750-b332-8e5d69738f76.png)'
- en: We can see that we're not doing anything if the cast fails, and in this case,
    that's what we want. If, for some reason, the `Hand_L` class's child actor changed
    or wasn't set, we don't want to try to make any calls on it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到如果转换失败，我们什么都不做，而在这种情况下，这正是我们想要的。如果由于某种原因，`Hand_L`类的子级角色发生了变化或未设置，我们不希望尝试进行任何调用。
- en: It's important to make the distinction that *macros are not functions*. They
    look like functions and can often be used to do similar jobs, but a macro is really
    just an instruction to the Blueprint compiler to paste its contents into the graph
    where the macro appears. It doesn't have the ability to house local variables
    the way a function does. Macros are very simple—just an automated copy and paste.
    Some developers will advise you to avoid macros outright. This is definitely good
    advice if your understanding of how macros differ from functions is fuzzy, but
    if you understand how they work, they can be very useful. As a good rule of thumb,
    keep your macros very small. If you're doing a lot of work in a macro, you're
    really telling the compiler to paste a ton of nodes into your graph, and it should
    probably be a function in that case. Treat macros as a way of making a reusable
    node that does a simple job. Use them for readability and to make your code easier
    to modify later on.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分*宏不是函数*。它们看起来像函数，通常可以用来做类似的工作，但宏实际上只是一条指令，告诉蓝图编译器将其内容粘贴到宏出现的图表中。它没有像函数那样存储局部变量的能力。宏非常简单，只是自动复制和粘贴。一些开发人员会建议你完全避免使用宏。如果你对宏与函数的区别不清楚，这绝对是一个好建议，但如果你了解它们的工作原理，它们可以非常有用。作为一个好的经验法则，保持你的宏非常小。如果你在宏中做了很多工作，你实际上是在告诉编译器将大量的节点粘贴到你的图表中，这种情况下它应该是一个函数。将宏视为一种创建可重用节点的简单任务的方式。使用它们可以提高可读性，并使你的代码更容易修改。
- en: 'Now, let''s repeat this for our right controller input:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为右控制器输入重复这个过程：
- en: Select your `GetHand_L` macro from your Macros list, and hit *Ctrl* + *W* to
    duplicate it.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从宏列表中选择你的`GetHand_L`宏，并按下*Ctrl* + *W*进行复制。
- en: Rename the new macro `GetHand_R`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新宏命名为`GetHand_R`。
- en: Inside it, replace the `Hand_L` reference with a reference to `Hand_R`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，将`Hand_L`引用替换为对`Hand_R`的引用。
- en: Drag two instances of `GetHand_R` onto your graph.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中拖动两个`GetHand_R`实例。
- en: Connect them to the InputAction GrabRight node's Pressed and Released pins.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们连接到InputAction GrabRight节点的Pressed和Released引脚。
- en: Call `GrabActor` and `ReleaseActor` on their outputs, like you did previously.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在它们的输出上调用`GrabActor`和`ReleaseActor`，就像之前做的那样。
- en: 'Your completed graph should look like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你的完成的图表应该是这样的：
- en: '![](img/66bc4299-e3d8-486d-b5b1-6e91e615f55b.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66bc4299-e3d8-486d-b5b1-6e91e615f55b.png)'
- en: If you're thinking that we could have copied our GetMeshForHand function and
    modified it to return the `BP_VRHand` reference directly, you're right. We could
    also have modified that function outright and moved the Get HandMesh calls we
    made in the teleport functions outside. There are often many right ways to do
    the same job. In this instance, where we're just doing a simple cast, a pair of
    macros is a nice way of keeping our blueprint readable.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为我们可以复制我们的GetMeshForHand函数并修改它以直接返回`BP_VRHand`引用，那么你是对的。我们也可以直接修改该函数，并将我们在传送函数中进行的Get
    HandMesh调用移出来。通常有很多正确的方法来完成同样的工作。在这种情况下，我们只是做了一个简单的转换，一对宏是保持我们的蓝图可读性的好方法。
- en: Let's test it. If we've done everything right, we should now see `Grab Actor`
    and `Release Actor` messages appearing in our view when we squeeze and release
    the triggers.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行测试。如果我们做得没错，当我们挤压和释放扳机时，我们现在应该在视图中看到`Grab Actor`和`Release Actor`消息出现。
- en: Implementing grab animations in the Hand blueprints
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在手部蓝图中实现抓取动画
- en: Now that we've set up our inputs and set up the `VRPawn` to pass them along
    to their respective motion controllers, let's get those motion controllers animating
    when these inputs are received.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了输入并设置好了`VRPawn`以将它们传递给各自的运动控制器，让我们在接收到这些输入时使这些运动控制器进行动画化。
- en: 'Let''s jump back into our `BP_VRHand` Blueprint:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`BP_VRHand`蓝图中：
- en: In the Variables list of `BP_VRHand`, add a new Boolean variable named `bWantsToGrip`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BP_VRHand`的变量列表中，添加一个名为`bWantsToGrip`的新布尔变量。
- en: Hit *Alt* + drag a setter for `bWantsToGrip` into the `Grab Actor` function
    graph. Set it to true when `Grab Actor` is called.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt*+拖动`bWantsToGrip`的setter到`Grab Actor`函数图中。当调用`Grab Actor`时将其设置为true。
- en: 'Hit *Alt* + drag a setter for `bWantsToGrip` into `Release Actor`. Set it to
    false here:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt*+拖动`bWantsToGrip`的setter到`Release Actor`中。在这里将其设置为false：
- en: '![](img/30920426-f0e5-4583-8f94-8a4ffcc5077b.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30920426-f0e5-4583-8f94-8a4ffcc5077b.png)'
- en: Pressing *Ctrl*+ dragging a variable automatically creates a getter for that
    variable. Pressing *Alt* + dragging a variable creates a setter.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl*+拖动一个变量会自动创建该变量的getter。按下*Alt*+拖动一个变量会创建一个setter。
- en: Creating an Animation Blueprint for the hand
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为手部创建一个动画蓝图
- en: 'Unreal uses Animation Blueprints to control animations on Skeletal Meshes.
    We''re going to need one for our hand:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻使用动画蓝图来控制骨骼网格上的动画。我们需要一个手部的动画蓝图：
- en: 'In your content browser, right-click in your project''s `Blueprints` directory,
    and select Create Advanced Asset | Animation | Animation Blueprint:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，在项目的`Blueprints`目录中右键单击，选择创建高级资产|动画|动画蓝图：
- en: '![](img/a5a02e55-f40b-4e57-9b53-5db05d8bc15d.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5a02e55-f40b-4e57-9b53-5db05d8bc15d.png)'
- en: 'A dialog will appear asking for the animation Blueprint''s parent class and
    for the target skeleton it''s going to control:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对话框将出现，询问动画蓝图的父类和它要控制的目标骨骼：
- en: '![](img/655b5933-2b45-4868-a9b4-44ab8f1e4dea.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/655b5933-2b45-4868-a9b4-44ab8f1e4dea.png)'
- en: Leave the parent class empty, and select `MannequinHand_Right_Skeleton` as its
    Target Skeleton.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将父类留空，并选择`MannequinHand_Right_Skeleton`作为目标骨骼。
- en: Name it `ABP_MannequinHand_Right`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`ABP_MannequinHand_Right`。
- en: Creating a blend space for our hand animations
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的手部动画创建一个混合空间
- en: Now, we want our hand animations to respond to this value. Since we want to
    be able to blend smoothly between different animation poses, our best tool for
    this job is a *Blend Space*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望我们的手部动画对这个值做出响应。由于我们希望能够在不同的动画姿势之间平滑混合，我们最好的工具是*混合空间*。
- en: 'You have two types of Blend Space available to you. There''s the standard Blend
    Space, which blends two different axes (this is commonly used for aiming poses
    in shooters), and a simpler blend space that just blends along one axis. This
    is the one we want. Let''s get started:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两种可用的混合空间类型。有标准的混合空间，可以混合两个不同的轴（这通常用于射击游戏中的瞄准姿势），还有一个更简单的只沿一个轴混合的混合空间。这是我们想要的那个。让我们开始吧：
- en: Right-click in your `Blueprints` directory, and select Create Advanced Asset
    | Animation | Blend Space 1D.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Blueprints`目录中右键单击，选择创建高级资产|动画|1D混合空间。
- en: A dialog will appear asking what skeleton this Blend Space will apply to. Select
    `MannequinHand_Right_Skeleton`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个对话框将出现，询问这个混合空间将应用于哪个骨骼。选择`MannequinHand_Right_Skeleton`。
- en: 'Name it `BS_HandGrip`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`BS_HandGrip`：
- en: '![](img/184020ca-e2d9-4ae6-9aa3-8087c0660880.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/184020ca-e2d9-4ae6-9aa3-8087c0660880.png)'
- en: 'Open up the blend space we just created:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们刚刚创建的混合空间：
- en: '![](img/06d88057-4706-4024-b71a-94cae11d2b99.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06d88057-4706-4024-b71a-94cae11d2b99.png)'
- en: The Blend Space editor consists of an Asset Details panel on the left, a preview
    window, the Sample Point workspace at the bottom,
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 混合空间编辑器由左侧的资产详细信息面板、预览窗口、底部的示例点工作区组成，
- en: and an animation asset browser in the lower right.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 和右下角的动画资产浏览器。
- en: In the lower right-hand corner, you can see the list of animations we migrated
    from the VR template for our hand. It's simply displaying any animation in the
    `Content` directories that's mapped to the Hand Mesh's skeleton.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在右下角，您可以看到我们从VR模板迁移的手部动画列表。它只是显示与手部网格的骨骼映射的任何位于`Content`目录中的动画。
- en: In the bottom center under the preview, we can see the workspace where we're
    going to construct our blend.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览下方的中心位置，我们可以看到我们将构建混合的工作区。
- en: 'The first thing we need to do here is set up the axis we''re going to use for
    our blend. Let''s get started:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是设置我们要用于混合的轴。让我们开始吧：
- en: In the upper-left corner, find Asset Details | Axis Settings, and expand the
    Horizontal Axis block.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左上角找到资产详细信息|轴设置，并展开水平轴块。
- en: Set its Name to `Grip`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其名称设置为`Grip`。
- en: Set its Maximum Axis Value to 1.0.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其最大轴值设置为1.0。
- en: Now, we have a place to put our animation poses.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个放置动画姿势的地方。
- en: From the Asset Browser, drag `MannequinHand_Right_Open` onto the workspace until
    it snaps onto the 0.0 grid line.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从资源浏览器中，将`MannequinHand_Right_Open`拖放到工作区，直到它与0.0网格线对齐。
- en: Drag `MannequinHand_Right_Grab` onto the 1.0 line.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MannequinHand_Right_Grab`拖放到1.0线上。
- en: Drag `MannequinHand_Right_CanGrab` into the middle, at 0.5.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MannequinHand_Right_CanGrab`拖放到中间位置，即0.5。
- en: 'Test it out by holding down the *Shift* key and dragging on the workspace.
    We can blend seamlessly between the three animation poses we applied to the Grip
    axis by changing its value:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按住*Shift*键并在工作区上拖动来测试它。我们可以通过改变其值在三个动画姿势之间无缝混合，这些姿势应用于Grip轴：
- en: '![](img/d741c4b4-7018-4d3a-87a7-787919687114.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d741c4b4-7018-4d3a-87a7-787919687114.png)'
- en: Let's get this working in our Animation Blueprint.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的动画蓝图中使其工作。
- en: Wiring the blend space into the animation blueprint
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将混合空间连接到动画蓝图
- en: 'We can now use the blend space we just created as an asset in its animation
    blueprint. The animation blueprint is a powerful tool the allows you to control
    the way animations are played on a skeletal mesh. It''s split into two main sections:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将刚刚创建的混合空间作为资产在其动画蓝图中使用。动画蓝图是一种强大的工具，可以控制骨骼网格上播放动画的方式。它分为两个主要部分：
- en: The Anim Graph, which takes animation inputs and processes them to calculate
    the mesh pose on every frame
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画图表接收动画输入并处理它们以计算每帧上的网格姿势
- en: The Event Graph, which behaves similarly to the Blueprints you've already authored
    and is used to process the data that the animation blueprint is going to use to
    decide what animations to play
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件图表类似于您已经创建的蓝图，并用于处理动画蓝图将用于决定播放哪些动画的数据
- en: 'Let''s learn how it works:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习一下它的工作原理：
- en: Open the animation blueprint we created a moment ago.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们刚刚创建的动画蓝图。
- en: Looking at its My Blueprint | Graphs block, you can see that in addition to
    the familiar EventGraph we find in all of our blueprint assets, there's a second
    graph, called AnimGraph.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 查看其我的蓝图|图表块，您可以看到除了我们所有蓝图资产中都有的熟悉的EventGraph之外，还有一个名为AnimGraph的第二个图表。
- en: 'Double-click My Blueprint | Graphs | AnimGraph to open it:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击我的蓝图|图表|AnimGraph打开它：
- en: '![](img/84dbed4f-c0cc-4291-80a3-9abb1beb7b13.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/84dbed4f-c0cc-4291-80a3-9abb1beb7b13.png)
- en: The **Anim Graph** is responsible for determining the animation pose of its
    controlled skeletal mesh on each tick. We can see here that we have a Blueprint
    graph, but it's different from the event graphs we're used to. Everything in the
    Anim Graph leads to that Final Animation Pose and is used to decide what it's
    going to be. We're not going to go deeply into Animation Blueprints here, as their
    setup is a deep subject and outside the scope of this book but they're worth learning
    about. The Anim Graph for our hands is going to be fairly simple.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**Anim Graph**负责确定每个刻度上其控制的骨骼网格的动画姿势。我们可以看到这里有一个蓝图图表，但它与我们熟悉的事件图表不同。动画图表中的所有内容都导致最终的动画姿势，并用于决定它将是什么。我们不会在这里深入研究动画蓝图，因为它们的设置是一个深入的主题，超出了本书的范围，但它们值得学习。我们的手部动画图表将非常简单。'
- en: From your Content Browser, grab the `BS_HandGrip` Blend Space we created a moment
    ago and drag it onto the Anim Graph.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内容浏览器中获取我们刚刚创建的`BS_HandGrip`混合空间，并将其拖放到动画图中。
- en: Drag its Animation Pose output to the Result Animation Pose input on the Final
    Animation Pose node.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其动画姿势输出拖动到最终动画姿势节点上的结果动画姿势输入。
- en: 'Drag out a connector from the Grip input on your `BS_HandGrip` node, and promote
    it to a variable. Name the variable `Grip`:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`BS_HandGrip`节点的Grip输入拖出一个连接器，并将其提升为变量。将变量命名为`Grip`：
- en: '![](img/11ba613e-f7c9-434b-b104-50bfbd5481ee.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/11ba613e-f7c9-434b-b104-50bfbd5481ee.png)
- en: Set the `Grip` variable's Slider Range and Value Range minimum values to 0 and
    maximum values to 1.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Grip`变量的滑块范围和值范围的最小值设置为0，最大值设置为1。
- en: 'Compile the blueprint:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图：
- en: '![](img/8fa7f696-3317-4530-bda9-5501bc4bf680.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/8fa7f696-3317-4530-bda9-5501bc4bf680.png)
- en: In the lower-right corner of the window, you will see an Anim Preview Editor
    tab. The variables you create in your animation blueprint appear here, and you
    can change their values in real time to see how they would affect your animation.
    (You're not actually changing the default value of the variable here—you're just
    previewing the system's behavior with different values.) Give it a try. Mouse
    into the `Grip` value and drag it around to slide between 0.0 and 1.0\. You'll
    see that it's driving the blend space we created, which in turn is driving the
    final animation pose. You can close and open the hand by changing the value of
    the `Grip` float.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口的右下角，您将看到一个Anim Preview Editor选项卡。您在动画蓝图中创建的变量将显示在此处，您可以实时更改它们的值以查看它们如何影响动画。（您实际上并没有更改变量的默认值-您只是使用不同的值预览系统的行为。）试试看。将鼠标移到`Grip`值上并拖动它，以在0.0和1.0之间滑动。您会看到它驱动了我们创建的混合空间，进而驱动了最终的动画姿势。通过改变`Grip`浮点数的值，您可以关闭和打开手。
- en: Let's get this responding to our user's input.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使其响应用户的输入。
- en: Connecting the animation blueprint to our hand blueprint
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将动画蓝图连接到我们的手部蓝图
- en: 'We need to tell our `BP_VRHand` actor that the `HandMesh` component should
    use our new animation blueprint to drive its animation state:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉`BP_VRHand`角色，`HandMesh`组件应该使用我们的新动画蓝图来驱动其动画状态：
- en: Open up `BP_VRHand` and select the `HandMesh` Skeletal Mesh component from the
    Components list.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_VRHand`并从组件列表中选择`HandMesh`骨骼网格组件。
- en: In its Details | Animation, verify that its Animation Mode is set to Use Animation
    Blueprint. (It should be by default.)
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细信息|动画中，验证其动画模式是否设置为使用动画蓝图。（默认情况下应该是这样。）
- en: 'Use the Anim Class drop-down menu to select your new animation blueprint:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Anim Class下拉菜单选择您的新动画蓝图：
- en: '![](img/6c8249e3-562d-453c-b432-6729b49b8199.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/6c8249e3-562d-453c-b432-6729b49b8199.png)
- en: Now, let's drive the Grip value on the animation blueprint we just connected.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们驱动刚刚连接的动画蓝图上的Grip值。
- en: Find the Event Tick in event graph of `BP_VRHand`, or create it if needed.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BP_VRHand`的事件图中找到事件Tick，如果需要的话创建它。
- en: Drag a reference to `Hand Mesh` onto the graph.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对`Hand Mesh`的引用拖放到图表中。
- en: Drag a connector from `Hand Mesh` and call `Get Anim Instance` on it.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Hand Mesh`拖动一个连接器，并在其上调用`Get Anim Instance`。
- en: For a Skeletal Mesh being controlled by an animation blueprint, the Anim Instance
    is going to be a reference to that animation blueprint. Now, since we need to
    access a specific member of that blueprint, we need to cast the anim instance
    to the specific animation blueprint class we're using.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由动画蓝图控制的骨骼网格，Anim Instance将是对该动画蓝图的引用。现在，由于我们需要访问该蓝图的特定成员，我们需要将动画实例转换为我们正在使用的特定动画蓝图类。
- en: Drag a connector from the `Get Anim Instance` return value and `cast` it to
    our new animation Blueprint class (`ABP_MannequinHand_Right`.)
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Get Anim Instance`返回值拖动一个连接器，并将其转换为我们的新动画蓝图类（`ABP_MannequinHand_Right`）。
- en: From the As ABP_Mannequin Hand Right output, call `Set Grip`.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从As ABP_Mannequin Hand Right输出中调用“Set Grip”。
- en: Hit *Ctrl* + drag `bWantsToGrip` onto the graph to get its value.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* +拖动“bWantsToGrip”到图中以获取其值。
- en: Drag a connector from `bWantsToGrip` and create a `Select` node.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“bWantsToGrip”拖出一个连接器并创建一个“Select”节点。
- en: Connect the Select node's Return Value to Set Grip's Grip input.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择节点的返回值连接到Set Grip的Grip输入。
- en: Set the True value on the Select node to 1.0.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择节点上的True值设置为1.0。
- en: 'Your graph should now look like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 您的图现在应该是这样的：
- en: '![](img/842e2e06-7fb2-4e94-97b8-a0ef3bfc0327.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/842e2e06-7fb2-4e94-97b8-a0ef3bfc0327.png)'
- en: Let's run it and test it out. Okay, good. Our hands are responding to our input.
    They don't look great doing it yet, but we can see that the basics are working.
    When we squeeze the trigger on a motion controller, that input sets `bWantsToGrip`
    to `true`, and on the Tick Event of VRHand, we're setting the value of the Grip
    variable on our Animation Blueprint to 0.0 or 1.0, based on the current value
    of `bWantsToGrip`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行并测试一下。好的，很好。我们的手对我们的输入做出了响应。它们看起来还不太好，但我们可以看到基本功能正在工作。当我们在运动控制器上按下扳机时，该输入将“bWantsToGrip”设置为“true”，并且在VRHand的Tick事件上，我们根据“bWantsToGrip”的当前值将Grip变量的值设置为0.0或1.0。
- en: Now, let's improve things a bit and set the system up to be more flexible.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微改进一下，并设置系统更加灵活。
- en: Creating a new enumerator for our grip
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的抓握创建一个新的枚举器
- en: Right now, we're just driving the `Grip` value on the hand's animation blueprint
    directly, but it really makes more sense to let the animation blueprint handle
    this, and just tell it what's going on. The system that handles animation, after
    all, should be responsible for deciding how it wants to do that.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只是直接驱动手的动画蓝图上的“Grip”值，但更合理的做法是让动画蓝图处理这个，并告诉它发生了什么。毕竟，处理动画的系统应该负责决定如何处理它。
- en: 'Let''s give ourselves an easy way to communicate our grip state to the animation
    blueprint. An **enumeration** is ideal for this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为动画蓝图提供一种简单的方式来传达我们的抓握状态。**枚举**非常适合这个：
- en: 'Right-click in your Blueprints directory, and select Create Advanced Asset
    | Blueprints | Enumeration. Name it `EGripState`:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图目录中右键单击，选择“创建高级资产|蓝图|枚举”。将其命名为“EGripState”：
- en: '![](img/278490f6-fac8-4fd3-a042-d0b33c65650b.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/278490f6-fac8-4fd3-a042-d0b33c65650b.png)'
- en: Open up the new enumerator.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的枚举器。
- en: In its Enumerators list, hit New to create a new entry.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在枚举器列表中，点击“新建”创建一个新条目。
- en: 'Set the new entry''s Display Name to `Open`. You can leave its description
    blank:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新条目的显示名称设置为“Open”。可以将其描述留空：
- en: '![](img/3cdc8e91-ad75-4e80-9598-23cbb8e5fa23.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cdc8e91-ad75-4e80-9598-23cbb8e5fa23.png)'
- en: Create another enumerator entry, and name it `Gripping`.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个枚举器条目，并将其命名为“Gripping”。
- en: Close the enumerator.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭枚举器。
- en: Now, we've created a new data type that we can use to store information and
    pass it in and out of objects. Let's add it to our animation blueprint.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个新的数据类型，可以用来存储信息并在对象之间传递。让我们将其添加到我们的动画蓝图中。
- en: Open up your animation blueprint and add a new variable to its Variables list.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的动画蓝图并将一个新变量添加到其变量列表中。
- en: Set its Variable Type to `EGripState`, and name it `GripState`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其变量类型设置为“EGripState”，并将其命名为“GripState”。
- en: Remember a moment ago when we noticed that the animation blueprint contained
    two graphs—the **Anim Graph** and an **Event Graph**? Now, we're going to begin
    to make use of the event graph. This is a powerful system. It allows us to keep
    our game logic where it belongs, in the gameplay objects, and keep our animation
    logic where it belongs, in the animation blueprint. We can pass a value into the
    animation blueprint, and then in its event graph, determine what we want it to
    do with that input.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得刚才我们注意到动画蓝图包含两个图表-**动画图**和**事件图**吗？现在，我们将开始使用事件图。这是一个强大的系统。它允许我们将游戏逻辑放在游戏对象中，将动画逻辑放在动画蓝图中。我们可以将一个值传递到动画蓝图中，然后在其事件图中确定我们希望它如何处理该输入。
- en: In your animation blueprint's Event Graph, find the Event Blueprint Update Animation
    node, or create one if it isn't already present. This is the equivalent of a tick
    event in an animation blueprint.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画蓝图的事件图中，找到事件蓝图更新动画节点，如果不存在则创建一个。这相当于动画蓝图中的tick事件。
- en: Press *Ctrl* + drag a reference to your new `Grip State` variable onto the event
    graph.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* +拖动对新的“Grip State”变量的引用到事件图中。
- en: Drag a connector from its output and create a Select node.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其输出拖出一个连接器并创建一个选择节点。
- en: 'You''ll notice that, when you create a Select node from an enum, it''s automatically
    populated with that enum''s available values:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，当您从枚举创建选择节点时，它会自动填充该枚举的可用值：
- en: '![](img/5cdb551b-0401-4a4a-9fc5-0bd87b47550d.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cdb551b-0401-4a4a-9fc5-0bd87b47550d.png)'
- en: Hit *Alt* + drag a reference to the `Grip` variable onto the graph to create
    a setter.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt* +拖动对“Grip”变量的引用到图中以创建一个设置器。
- en: Drag the output from the Select node into the Grip setter.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择节点的输出拖入Grip设置器中。
- en: Set its Gripping value to 1.0.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Gripping值设置为1.0。
- en: Compile the blueprint.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图。
- en: 'In the Anim Preview editor, verify that changing Grip State from Open to Gripping
    closes the hand:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画预览编辑器中，验证将Grip State从Open更改为Gripping会关闭手：
- en: '![](img/d8db3fd1-d162-4914-8d4d-cc181a27e8fc.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8db3fd1-d162-4914-8d4d-cc181a27e8fc.png)'
- en: 'Now, let''s update `BP_VRHand` to send the enum value instead of a grip value:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新“BP_VRHand”，以发送枚举值而不是抓握值：
- en: Back in your BP_VRHand's `Event Tick`, delete the `Grip` setter and the select
    node feeding it.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在BP_VRHand的“Event Tick”中，删除“Grip”设置器和馈送它的选择节点。
- en: Drag out a connector from the `Cast` output, and select `Set Grip State`.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Cast”输出中拖出一个连接器，并选择“Set Grip State”。
- en: Drag out a new Select node from your `bWantsToGrip` getter.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“bWantsToGrip”获取器中拖出一个新的选择节点。
- en: Drag the Select node's output into the `GripState` setter's input.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择节点的输出拖入“GripState”设置器的输入中。
- en: Set the True value of the Select node to `Gripping`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择节点的True值设置为“Gripping”。
- en: 'Your graph should now look like this:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您的图现在应该是这样的：
- en: '![](img/fbb76612-c5de-4a92-b0db-3cacfab3b726.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbb76612-c5de-4a92-b0db-3cacfab3b726.png)'
- en: Test it out. There's no visible change, right? What we've done here is set up
    our graphs so that we can now modify them more easily. Now that we've verified
    that the new setup is working the same way the old one did, let's jump back into
    the animation blueprint and improve the way we handle its input.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下。没有明显的变化，对吧？我们在这里做的是设置我们的图表，以便我们现在可以更容易地修改它们。既然我们已经验证了新的设置与旧的设置的工作方式相同，让我们回到动画蓝图中，改进我们处理其输入的方式。
- en: Smoothing out our grip animation
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平滑我们的握持动画
- en: 'Snapping between the open and closed animation poses looks awful. Let''s smooth
    this out by transitioning between the values over time:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开和关闭动画姿势之间的切换看起来很糟糕。让我们通过随时间过渡值之间的变化来平滑处理这个问题：
- en: Jump back to your animation blueprint's Event Graph.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转回动画蓝图的事件图。
- en: Right-click and add an `FInterp to Constant` node.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并添加一个“FInterp to Constant”节点。
- en: Drag your `Grip` variable onto its Current input.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的“Grip”变量拖放到其当前输入上。
- en: Drag the output of your Grip State Select node onto its Target input.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Grip State Select节点的输出拖放到其目标输入上。
- en: Drag the Delta Time X value from `Event Blueprint Update Animation` into its
    Delta Time input.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Event Blueprint Update Animation”中的Delta Time X值拖放到其Delta Time输入上。
- en: Drag out a connector from its `Interp Speed` input and promote it to a variable
    named `Interp Speed`.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其“Interp Speed”输入中拖出一个连接器，并将其提升为名为“Interp Speed”的变量。
- en: Compile the Blueprint and set `Interp Speed` to 7.0.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图并将“Interp Speed”设置为7.0。
- en: 'Connect the output from `FInterpToConstant` to the `Grip` setter''s input:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“FInterpToConstant”的输出连接到“Grip”设置器的输入：
- en: '![](img/382eb742-d26e-4433-a126-cb9f18fba11e.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](img/382eb742-d26e-4433-a126-cb9f18fba11e.png)'
- en: Test it out. That's much better. Now, our hand is interpolating between poses
    instead of just snapping to the value. What's happening here is the Interp to
    Constant node is managing a smooth transition to a new target value that was selected
    by Grip State over the duration specified by InterpSpeed. If we want the transition
    to happen faster, we can just reduce Interp Speed. If we want it longer, just
    make Interp Speed larger.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下。好多了。现在，我们的手部在姿势之间进行插值，而不仅仅是跳到该值。这里发生的是Interp to Constant节点通过InterpSpeed指定的持续时间平滑地过渡到由Grip
    State选择的新目标值。如果我们希望过渡发生得更快，只需减小Interp Speed。如果我们希望过渡时间更长，只需增大Interp Speed。
- en: As simple as this example is, it begins to show the power and flexibility animation
    blueprints provide. We can easily communicate state information from the VRHand
    blueprint, telling the animation blueprint what we're trying to do, and then do
    whatever we'd like to do to illustrate that state in the animation blueprint.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子很简单，但它开始展示了动画蓝图提供的强大和灵活性。我们可以轻松地从VRHand蓝图中传递状态信息，告诉动画蓝图我们想要做什么，然后在动画蓝图中以任何我们想要的方式来展示该状态。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was another involved chapter. We did a lot here. We began by creating a
    new project and migrating our VRPawn blueprints, along with their required objects,
    into the new project. We learned a quick way of recreating input bindings by copying
    the contents of `DefaultInput.ini` to a new project. We then added the Soul:City
    assets and maps to our project and set up a navmesh so that we could explore it.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个复杂的章节。我们在这里做了很多工作。我们首先创建了一个新项目，并将我们的VRPawn蓝图以及所需的对象迁移到新项目中。我们学会了通过将“DefaultInput.ini”的内容复制到新项目中来重新创建输入绑定的快速方法。然后，我们将Soul:City资源和地图添加到我们的项目中，并设置了一个导航网格，以便我们可以探索它。
- en: Then, we got to the meat of this chapter. We scavenged a hand mesh from the
    VR Template project and created a `Blueprint` class to drive their behavior. We
    learned how to use construction scripts to change objects when they're created,
    both in the editor and in-game. We learned how to create child actor components
    inside our pawn and how to use them in blueprints. We learned how to create an
    animation blend space and an animation blueprint to animate our hand meshes and
    how to use an enumerator to pass state information into the animation blueprint.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入了本章的重点。我们从VR模板项目中回收了一个手部网格，并创建了一个“蓝图”类来驱动它们的行为。我们学会了如何使用构造脚本在编辑器和游戏中创建对象时改变它们。我们学会了如何在我们的角色中创建子级角色组件以及如何在蓝图中使用它们。我们学会了如何创建动画混合空间和动画蓝图来为我们的手部网格添加动画，并学会了如何使用枚举器将状态信息传递到动画蓝图中。
- en: In the next chapter, we're going to learn how to use these hands to pick up
    objects. We'll learn how to use blueprint interfaces to enable function calls
    to be made on a wide variety of objects and how to detect actors we can pick up.
    We'll also learn a bit about using haptic feedback effects to indicate to players
    when they've made contact with an object they can pick up.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用这些手来拾取物体。我们将学习如何使用蓝图接口来启用对各种对象进行函数调用，并学习如何检测我们可以拾取的角色。我们还将学习一些关于使用触觉反馈效果来指示玩家何时与可以拾取的物体接触的知识。
