["```cpp\nnumber = 42 \n```", "```cpp\nstring = 'single quote string' \n```", "```cpp\nstring = \"double quotes string\" \n```", "```cpp\nstring  = [[ multi-line  \n             string]] \n```", "```cpp\nstring = nil \n```", "```cpp\nwhile number < 100 do \n    number = number + 1 \nend \n```", "```cpp\nif number > 100 then \n    print('Number is over 100') \nelseif number == 50 then \n    print('Number is 50') \nelse \n    print(number) \nend \n```", "```cpp\nfunction fib(number) \n    if number < 2 then \n        return 1 \n    end \n    return fib(number - 2) + fib(number -1) \nend \n```", "```cpp\ntable = { key1 = 'value1', \n          key2 = 100, \n          key3 = false }\n```", "```cpp\nprint (table.key1) \nPrints the text value1 \n\ntable.key2 = nil \n```", "```cpp\ntable.newKey = {}  \n```", "```cpp\nplayer = { \n    name = \"Bob\", \n    isSpawned = false \n} \n\nfunction fib(number) \n    if number < 2 then \n        return 1 \n    end \n    return fib(number - 2) + fib(number -1) \nend \n```", "```cpp\n#include <sol/sol.hpp> \n```", "```cpp\n    sol::state lua; \n```", "```cpp\n    lua.open_libraries(sol::lib::base, sol::lib::package); \n```", "```cpp\n    lua.script_file(\"Scripts/PlayerTest.lua\"); \n```", "```cpp\n    std::string stringFromLua = lua[\"player\"][\"name\"]; \n    std::cout << stringFromLua << std::endl; \n```", "```cpp\n    double numberFromLua = lua[\"fib\"](20); \n    std::cout << numberFromLua << std::endl; \n```", "```cpp\nstd::vector<BookEngine::IGUILabel*> choices; \nBookEngine::IGUILabel* m_dialog;\n```", "```cpp\nvoid SetDialog(std::string text); \nvoid SetOption(std::string text, int choiceNumber); \nvoid RemoveAllPanelElements(); \n```", "```cpp\nvoid DialogGUI::SetDialog(std::string text) \n{ \n    m_dialog = new BookEngine::IGUILabel(glm::vec4(0, 110, 250, 30), \n        glm::vec2(110, -10), \n        text, \n        new BookEngine::SpriteFont(\"Fonts/Impact_Regular.ttf\", 72), \n        glm::vec2(0.3f), m_panel); \n\n    AddGUIElement(*m_dialog); \n} \n```", "```cpp\nvoid DialogGUI::SetOption(std::string text, int choiceNumber) \n{ \n    choices.resize(m_choices.size() + 1); \n    choices[choiceNumber] =  \nnew BookEngine::IGUILabel(glm::vec4(0, 110, 250, 20), \n            glm::vec2(110, 10), \n            text, \n            new BookEngine::SpriteFont(\"Fonts/Impact_Regular.ttf\", 72), \n            glm::vec2(0.3f), m_panel); \n\n    AddGUIObject(*choices[choiceNumber]); \n}\n```", "```cpp\nvoid DialogGUI::RemoveAllPanelElements() \n{ \n    m_panel->RemoveAllGUIElements(); \n} \n```", "```cpp\nvoid RemoveAllGUIObjects() { m_GUIObjectsList.clear(); }; \n```", "```cpp\n... \n    enum InteractionState \n    { \n        Display, \n        WaitingForInput, \n    }; \n...\n```", "```cpp\nInteractionState currentState; \n```", "```cpp\n    sol::state lua; \n```", "```cpp\n    DialogGUI* m_gui; \n```", "```cpp\nNPC::NPC(DialogGUI& gui) : m_gui(&gui) \n{ \n    std::cout << \"Loading Scripts n\"; \n    lua.open_libraries(sol::lib::base, sol::lib::package, sol::lib::table); \n    lua.script_file(\"Scripts/NPC.lua\"); \n    currentState = InteractionState::Display; \n} \n```", "```cpp\n void NPC::Say(std::string stringToSay) \n{ \n    m_gui->SetDialog(stringToSay); \n} \n```", "```cpp\nvoid NPC::PresentOptions() \n{ \n\n    sol::table choices = lua[\"CurrentDialog\"][\"choices\"]; \n    int i = 0; \n    if (choices.valid()) \n    { \n        choices.for_each([&](sol::object const& key, sol::object const& value) \n        { \n            m_gui->SetOption(value.as<std::string>(), i); \n            i++; \n        }); \n    } \n}\n```", "```cpp\nvoid NPC::Update(float deltaTime) \n{ \n    switch (currentState) \n    { \n    case InteractionState::Display: \n        Say(lua[\"CurrentDialog\"][\"say\"]); \n        PresentOptions(); \n        currentState = InteractionState::WaitingForInput; \n        break; \n    case InteractionState::WaitingForInput: \n        for (int i = 0; i < m_gui->choices.size(); i++) \n        { \n            if (m_gui->choices[i]->GetClickedStatus() == true) \n            { \n                lua[\"CurrentDialog\"][\"onSelection\"](m_gui-> \nchoices[i]->GetLabelText()); \n                currentState = InteractionState::Display; \n                m_gui->choices.clear(); \n                m_gui->RemoveAllPanelElements (); \n            } \n        } \n        break; \n    } \n} \n```", "```cpp\nintro = { \n    say = 'Hello I am the Helper NPC, can I help you?', \n    choices = { \n                 choice1 = \"Yes! I need help\", \n                 choice2 = \"No!! Leave me alone\" \n    }, \n\n    onSelection = function (choice)  \n        if choice == CurrentDialog[\"choices\"][\"choice1\"] then CurrentDialog = getHelp end \n        if choice  == CurrentDialog[\"choices\"][\"choice2\"] then CurrentDialog = goodbye_mean end \n    end \n} \n\ngetHelp = { \n    say = 'Ok I am still working on my helpfulness', \n    choices = { \n                 choice1 = \"That's okay! Thank you!\", \n                 choice2 = \"That's weak, what a waste!\", \n                 choice3 = \"Start over please.\" \n        }, \n    onSelection = function (choice)  \n        if choice  == CurrentDialog[\"choices\"][\"choice1\"] then CurrentDialog = goodbye  \n        elseif choice  == CurrentDialog[\"choices\"][\"choice2\"] then CurrentDialog = goodbye_mean  \n        elseif choice  == CurrentDialog[\"choices\"][\"choice3\"] then CurrentDialog = intro end \n    end \n\n} \n\ngoodbye = { \n    say = \"See you soon, goodbye!\" \n} \n\ngoodbye_mean = { \n    say = \"Wow that is mean, goodbye!\" \n} \n\nCurrentDialog = intro \n```", "```cpp\nintro = { \n    say = 'Hello I am the Helper NPC, can I help you?', \n    choices = { \n                 choice1 = \"Yes! I need help\", \n                 choice2 = \"No!! Leave me alone\" \n    }, \n\n    onSelection = function (choice)  \n        if choice == CurrentDialog[\"choices\"][\"choice1\"] then CurrentDialog = getHelp end \n        if choice  == CurrentDialog[\"choices\"][\"choice2\"] then CurrentDialog = goodbye_mean end \n    end \n} \n```", "```cpp\nclass Quest \n{ \npublic: \n    Quest(std::string name,  \n    std::vector<GameObjects> rewards,  \n    std::string description,  \n    NPC questGiver); \n    ~Quest(); \n    Accept(); //accept the quest \n    TurnIn(); //complete the quest \nprivate: \n     std::string m_questName; \n       std::vector<GameObjects> m_rewards; \n       std::string m_questDescription; \n       NPC m_questGiver; \n     Bool isActive; \n}; \n```", "```cpp\nlocal questsys = {} \nquestsys.quest = {} \n\nfunction questsys.new(questname, objectives, reward, description, location, level, questgiver) \nfor keys, value in ipairs(objectives) do \n    value.value = 0 \n  end \n  questsys.quest[#questsys.quest+1] = { \n    questname = questname, \n    objectives = objectives, \n    reward = reward, \n    description = description, \n    questgiver = questgiver, \n    accepted = false, \n    completed = false, \n    isAccepted = function(self) return self.accepted end, \n    isCompleted = function(self) return self.completed end \n  } \nend \n\nfunction questsys.accept(questname) \n  for key, value in ipairs(questsys.quest) do \n    if value.questname == questname then \n      if not value.accepted then \n        value.accepted = true \n      end \n  end \nend \n\n... \n\nfunction questsys.turnin(questname) \n  rejectMsg = \"You have not completed the quest.\" \n  for key, value in ipairs(questsys.quest) do \n    if value.questname == questname then \n      for i, j in ipairs(questsys.quest[key].objectives) do \n        if j.value == j.maxValue then \n          value.completed = true \n          value.reward() \n        else return rejectMsg end \n      end \n  end \nend \n\n... \n\nquestsys.get(questname, getinfo) \n  for key, value in ipairs(questsys.quest) do \n    if value.questname == questname then \n      if getinfo == \"accepted\" then return value:isAccepted() end \n      if getinfo == \"completed\" then return value:isCompleted() end \n      if getinfo == \"questname\" then return value.questname end \n      if getInfo == \"description\" then return value.description end \n      if getInfo == \"location\" then return value.location end \n      if getInfo == \"level\" then return value.level end \n      if getInfo == \"questgiver\" then return value.questgiver end \n    else error(\"No such quest name!\") \n  end \nend \n\nreturn questsys \n```", "```cpp\nlocal questsys = require('questsys') \n```"]