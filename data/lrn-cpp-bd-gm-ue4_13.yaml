- en: Spell Book
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法术书
- en: The player does not yet have a means to defend himself. We will now equip the
    player with a very useful and interesting way of doing so, called magic spells.
    Magic spells will be used by the player to affect monsters nearby, so you can
    now damage them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家目前还没有自卫手段。我们现在将为玩家配备一种非常有用和有趣的方式，称为魔法法术。玩家将使用魔法法术来影响附近的怪物，因此现在可以对它们造成伤害。
- en: We'll begin the chapter by describing how to create our own particle systems.
    We'll then move on to wrap the particle emitter into a `Spell` class, and write
    a `CastSpell` function for the avatar to be able to actually `CastSpells`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从描述如何创建自己的粒子系统开始本章。然后，我们将把粒子发射器包装到一个`Spell`类中，并为角色编写一个`CastSpell`函数，以便实际`CastSpells`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is a spell?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是法术？
- en: Particle systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子系统
- en: Spell class actor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法术类角色
- en: Attaching right mouse click to CastSpell
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将右键单击附加到`CastSpell`
- en: Creating other spells
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建其他法术
- en: What is a spell?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是法术？
- en: Practically, spells will be a combination of a particle system with an area
    of effect represented by a bounding volume. The bounding volume is checked for
    actors contained in each frame. When an actor is within the bounding volume of
    a spell, then that actor is affected by that spell.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，法术将是粒子系统与由边界体积表示的影响区域的组合。每一帧都会检查边界体积中包含的角色。当一个角色在法术的边界体积内时，那么该角色就会受到该法术的影响。
- en: 'The following is a screenshot of the blizzard spell, with the bounding volume
    highlighted in orange:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是暴风雪法术的截图，其中突出显示了边界体积：
- en: '![](img/d502f3b7-aa44-4c5a-a35c-e7b0580c894d.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d502f3b7-aa44-4c5a-a35c-e7b0580c894d.png)'
- en: The blizzard spell has a long, box-shaped bounding volume. In each frame, the
    bounding volume is checked for contained actors. Any actor contained in the spell's
    bounding volume is going to be affected by that spell for that frame only. If
    the actor moves outside the spell's bounding volume, the actor will no longer
    be affected by that spell. Remember, the spell's particle system is a visualization
    only; the particles themselves are not what will affect game actors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 暴风雪法术有一个长方形的边界体积。在每一帧中，都会检查边界体积中包含的角色。法术边界体积中包含的任何角色在该帧中都将受到该法术的影响。如果角色移出法术的边界体积，那么该角色将不再受到该法术的影响。请记住，法术的粒子系统仅用于可视化；粒子本身不会影响游戏角色。
- en: 'The `PickupItem` class we created in [Chapter 8](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml),
    *Actors and Pawns*, can be used to allow the player to pick up items representing
    the spells. We will extend the `PickupItem` class and attach the blueprint of
    a spell to cast each `PickupItem`. Clicking on a spell''s widget from the HUD
    will cast it. The interface will look something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml)中创建的`PickupItem`类，*角色和卫兵*，可用于允许玩家拾取代表法术的物品。我们将扩展`PickupItem`类，并附加一个法术的蓝图以施放每个`PickupItem`。从HUD中点击法术的小部件将施放它。界面将看起来像这样：
- en: '![](img/9ac617a8-92ec-4798-b090-495b3fcb6524.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ac617a8-92ec-4798-b090-495b3fcb6524.png)'
- en: Setting up particle systems
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置粒子系统
- en: 'First, we need a place to put all our snazzy effects. To do so, we will follow
    these steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个放置所有华丽特效的地方。为此，我们将按照以下步骤进行：
- en: In your Content Browser tab, right-click on the Content root and create a new
    folder called `ParticleSystems`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的内容浏览器选项卡中，右键单击内容根目录，创建一个名为`ParticleSystems`的新文件夹。
- en: 'Right-click on that new folder, and select New Asset | Particle System, as
    shown in the following screenshot:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击该新文件夹，然后选择New Asset | Particle System，如下截图所示：
- en: '![](img/8dda3c34-0393-4b68-b568-3a3b14626a26.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dda3c34-0393-4b68-b568-3a3b14626a26.png)'
- en: 'See this Unreal Engine 4 particle systems guide for information on how Unreal
    particle emitters work: [https://www.youtube.com/watch?v=OXK2Xbd7D9w&amp;index=1&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/watch?v=OXK2Xbd7D9w&index=1&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此虚幻引擎4粒子系统指南，了解虚幻粒子发射器的工作原理：[https://www.youtube.com/watch?v=OXK2Xbd7D9w&amp;index=1&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/watch?v=OXK2Xbd7D9w&index=1&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t)。
- en: 'Double-click on the NewParticleSystem icon that appears, as shown in the following
    screenshot:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击出现的NewParticleSystem图标，如下截图所示：
- en: '![](img/17c681be-20b8-4b94-8296-407dd2f2fda4.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17c681be-20b8-4b94-8296-407dd2f2fda4.png)'
- en: 'Once you are done with the preceding steps, you will be in Cascade, the particle
    editor. The environment is shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上述步骤后，您将进入Cascade，粒子编辑器。环境如下截图所示：
- en: '![](img/173d7371-cbb2-419b-8ed1-863f44e04ebb.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/173d7371-cbb2-419b-8ed1-863f44e04ebb.png)'
- en: 'There are several different panes here, each of which shows different information.
    They are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有几个不同的窗格，每个窗格显示不同的信息。它们如下： '
- en: At the top left is the Viewport pane. This shows you an animation of the current
    emitter as it's currently working.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左上角是视口窗格。这显示了当前发射器的动画，因为它当前正在工作。
- en: At the right is the Emitters pane. Inside it, you can see a single object called
    Particle Emitter (you can have more than one emitter in your particle system,
    but we don't want that now). The listing of modules of Particle Emitter appears
    listed under it. From the preceding screenshot, we have the Required, Spawn, Lifetime,
    Initial Size, Initial Velocity, and Color Over Life modules.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧是`Emitters`面板。在其中，您可以看到一个名为Particle Emitter的单个对象（您的粒子系统中可以有多个发射器，但我们现在不需要）。粒子发射器的模块列表显示在其下。从前面的截图中，我们有`Required`、`Spawn`、`Lifetime`、`Initial
    Size`、`Initial Velocity`和`Color Over Life`模块。
- en: Changing particle properties
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改粒子属性
- en: 'The default particle emitter emits crosshair-like shapes. We want to change
    that to something more interesting. To do this, follow these steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认粒子发射器会发射类似十字准星的形状。我们想要将其更改为更有趣的东西。要做到这一点，请按照以下步骤进行：
- en: Click on the yellow Required box under the Emitters panel, then open the Material
    drop-down in the Details panel.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`Emitters`面板下的黄色`Required`框，然后在`Details`面板中打开`Material`下拉菜单。
- en: A list of all the available particle materials will pop up (you can type `particles`
    in the top to make it easier to find the ones you want).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将弹出所有可用的粒子材料列表（您可以在顶部输入`particles`以便更容易找到您想要的材料）。
- en: 'Choose the m_flare_01 option to create our first particle system, as shown
    in the following screenshot:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择m_flare_01选项来创建我们的第一个粒子系统，如下截图所示：
- en: '![](img/ac976fd3-6e9a-4358-8b5a-142353c6dba7.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac976fd3-6e9a-4358-8b5a-142353c6dba7.png)'
- en: 'Now, let''s change the behavior of the particle system. Click on the Color
    Over Life entry under the Emitters pane. The Details pane at the bottom shows
    information about the different parameters, as shown in the following screenshot:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更改粒子系统的行为。单击发射器窗格下的Color Over Life条目。底部的详细信息窗格显示了不同参数的信息，如下截图所示：
- en: '![](img/4c64ae04-cd1d-4801-a952-deee7b5ae84d.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c64ae04-cd1d-4801-a952-deee7b5ae84d.png)'
- en: In the Details pane of Color Over Life entry, I increased R, but not G and not
    B. This gives the particle system a reddish glow. (R is red, G is green, and B
    is blue). You can see the color on the bar.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Color Over Life条目的详细信息窗格中，我增加了R，但没有增加G和B。这给了粒子系统一种红色的发光效果。（R是红色，G是绿色，B是蓝色）。您可以在条上看到颜色。
- en: 'Instead of editing the raw numbers, however, you can actually change the particle
    color more visually. If you click on the greenish zigzag button beside the Color
    Over Life entry under Emitters, you will see the graph for Color Over Life displayed
    in the Curve Editor tab, as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以通过更直观地更改粒子颜色来编辑原始数字。如果您点击发射器下的Color Over Life条目旁边的绿色锯齿按钮，您将看到Color Over
    Life的图表显示在曲线编辑器选项卡中，如下截图所示：
- en: '![](img/cf931d8b-84fa-44fb-80fa-e72bc65ea783.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf931d8b-84fa-44fb-80fa-e72bc65ea783.png)'
- en: 'We can now change the Color Over Life parameters. The graph in the Curve Editor
    tab displays the emitted color versus the amount of time the particle has been
    alive. You can adjust the values by dragging the points around. Pressing *Ctrl*
    + left mouse button adds a new point to a line (if it doesn''t work, click in
    the yellow box to deselect AlphaOverLife and make sure only ColorOverLife is selected):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更改颜色随生命周期变化的参数。在曲线编辑器选项卡中的图表显示了发射的颜色与粒子存活时间的关系。您可以通过拖动点来调整数值。按住*Ctrl*键+鼠标左键可以在线条上添加新的点（如果不起作用，请点击黄色框取消选择AlphaOverLife，确保只选择ColorOverLife）：
- en: '![](img/6c416672-9b92-4de2-b9ef-882ea4895335.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c416672-9b92-4de2-b9ef-882ea4895335.png)'
- en: You can play around with the particle emitter settings to create your own spell
    visualizations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调整粒子发射器设置，创建自己的法术可视化效果。
- en: Settings for the blizzard spell
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴风雪法术的设置
- en: At this point, we should rename our particle system from NewParticleSystem to
    something more descriptive. Let's rename it `P_Blizzard`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该将粒子系统从NewParticleSystem重命名为更具描述性的名称。让我们将其重命名为`P_Blizzard`。
- en: '![](img/422079ca-06d0-49ff-b57f-59b93b200da7.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/422079ca-06d0-49ff-b57f-59b93b200da7.png)'
- en: 'You can rename your particle system by simply clicking on it and pressing *F2,
    as shown below*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击粒子系统并按下*F2来重命名您的粒子系统，如下所示：
- en: '![](img/adcfef39-8761-4855-be26-c1884276844b.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adcfef39-8761-4855-be26-c1884276844b.png)'
- en: 'We will tweak some of the settings to get a blizzard particle effect spell.
    Perform the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调整一些设置，以获得暴风雪粒子效果法术。执行以下步骤：
- en: Go back into the P_Blizzard particle system to edit it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回P_Blizzard粒子系统进行编辑。
- en: 'Under the Spawn module, change the spawn rate to `200.0`. This increases the
    density of the visualization, as shown here:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Spawn模块下，将生成速率更改为`200.0`。这会增加可视化效果的密度，如下所示：
- en: '![](img/d29f563b-55a5-4525-8a58-bad64b23d627.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d29f563b-55a5-4525-8a58-bad64b23d627.png)'
- en: 'Under the Lifetime module, increase the Max property from `1.0` to `2.0`, as
    shown in the following screenshot. This introduces some variation to the length
    of time a particle will live, with some of the emitted particles living longer
    than others:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Lifetime模块下，将Max属性从`1.0`增加到`2.0`，如下截图所示。这会使发射的粒子的存活时间产生一些变化，一些发射的粒子的存活时间会比其他的长：
- en: '![](img/3fa2b655-864f-4888-b124-d7d2bebba71b.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fa2b655-864f-4888-b124-d7d2bebba71b.png)'
- en: 'Under the Initial Size module, change the Min property size to `12.5` in X,
    Y, and Z, as shown in the following screenshot:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Initial Size模块下，将Min属性大小更改为`12.5`，如下截图所示：
- en: '![](img/67d82c41-cf10-43b4-b50f-1e7931a51416.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67d82c41-cf10-43b4-b50f-1e7931a51416.png)'
- en: 'Under the Initial Velocity module, change the Min / Max values to the values
    shown here:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Initial Velocity模块下，将Min / Max值更改为以下数值：
- en: '![](img/5b14c94b-a895-4f16-a7c6-f1e890175a0f.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b14c94b-a895-4f16-a7c6-f1e890175a0f.png)'
- en: The reason we're having the blizzard blow in +X is because the player's forward
    direction starts out in +X. Since the spell will come from the player's hands,
    we want the spell to point in the same direction as the player.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之所以让暴风雪向+X方向吹，是因为玩家的前进方向从+X开始。由于法术将来自玩家的手，我们希望法术指向与玩家相同的方向。
- en: 'Under the Color Over Life menu, change the blue (B) value to `100.0`. Also
    change R back to `1.0`. You will see an instant change to a blue glow:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Color Over Life菜单下，将蓝色（B）值更改为`100.0`。同时将R更改回`1.0`。您会立即看到蓝色发光的变化：
- en: '![](img/278ad147-cb00-4705-890f-4c0866c07900.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/278ad147-cb00-4705-890f-4c0866c07900.png)'
- en: Now it's starting to look magical!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它开始看起来有点神奇了！
- en: 'Right-click on the blackish area below the Color Over Life module. Choose Location
    | Initial Location, shown in the screenshot:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击Color Over Life模块下方的黑色区域。选择Location | Initial Location，如截图所示：
- en: '![](img/bcf639ba-60da-462f-b93c-b2bb17afbeeb.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcf639ba-60da-462f-b93c-b2bb17afbeeb.png)'
- en: 'Enter values under Start Location | Distribution as shown in the following
    screenshot:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图所示，在Start Location | Distribution下输入数值：
- en: '![](img/be1b38a4-0f7d-436f-8ca9-39f1822e792d.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be1b38a4-0f7d-436f-8ca9-39f1822e792d.png)'
- en: 'You should have a blizzard that looks like this:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到一个如此的暴风雪：
- en: '![](img/3b25a958-cb24-40c4-b82b-98475a219166.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b25a958-cb24-40c4-b82b-98475a219166.png)'
- en: 'Move the camera to a position you like, and then click on the Thumbnail option
    in the top menu bar. This will generate a Thumbnail icon for your particle system
    in the Content Browser tab, as shown in the following screenshot:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机移动到你喜欢的位置，然后点击顶部菜单栏中的缩略图选项。这将在内容浏览器选项卡中为你的粒子系统生成一个缩略图图标，如下截图所示：
- en: '![](img/a422433a-ec14-4068-af06-32445aa0ad80.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a422433a-ec14-4068-af06-32445aa0ad80.png)'
- en: Spell class actor
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法术类角色
- en: The `Spell` class will ultimately do damage to all monsters. Toward that end,
    we need to contain both a particle system and a bounding box inside the `Spell`
    class actor. When a `Spell` class is cast by the avatar, the `Spell` object will
    be instantiated into the level and start `Tick()` functioning. On every `Tick()`
    of the `Spell` object, any monster contained inside the spell's bounding volume
    will be affected by that `Spell`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spell`类最终会对所有怪物造成伤害。为此，我们需要在`Spell`类角色中包含粒子系统和边界框。当角色施放`Spell`类时，`Spell`对象将被实例化到关卡中并开始`Tick()`功能。在`Spell`对象的每个`Tick()`上，任何包含在法术边界体积内的怪物都将受到影响。'
- en: 'The `Spell` class should look something like the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spell`类应该看起来像以下代码：'
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are only three functions we need to worry about implementing, namely the
    `ASpell::ASpell()` constructor, the `ASpell::SetCaster()` function, and the `ASpell::Tick()`
    function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要担心实现三个函数，即`ASpell::ASpell()`构造函数，`ASpell::SetCaster()`函数和`ASpell::Tick()`函数。
- en: 'Open the `Spell.cpp` file. Underneath the include line for `Spell.h`, add a
    line to include the `Monster.h` file, so we can access the definition of `Monster`
    objects inside the `Spell.cpp` file (as well as a couple of other includes), as
    shown in the following line of code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Spell.cpp`文件。在`Spell.h`的包含行下面，添加一行包括`Monster.h`文件的代码，这样我们就可以在`Spell.cpp`文件中访问`Monster`对象的定义（以及其他一些包括），如下代码所示：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, the constructor, which sets up the spell and initializes all components,
    is shown in the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是构造函数，它设置了法术并初始化了所有组件，如下代码所示：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Of particular importance is the last line here, `PrimaryActorTick.bCanEverTick
    = true`. If you don't set that, your `Spell` objects won't ever have `Tick()`
    called.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的是这里的最后一行，`PrimaryActorTick.bCanEverTick = true`。如果你不设置它，你的`Spell`对象将永远不会调用`Tick()`。
- en: 'Next, we have the `SetCaster()` method. This is called so that the person who
    casts the spell is known to the `Spell` object. We can ensure that the caster
    can''t hurt himself with his own spells by using the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`SetCaster()`方法。这是为了让`Spell`对象知道施法者是谁。我们可以通过以下代码确保施法者不能用自己的法术伤害自己：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we have the `ASpell::Tick()` method, which actually deals damage to
    all contained actors, as shown in the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`ASpell::Tick()`方法，它实际上对所有包含的角色造成伤害，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `ASpell::Tick()` function does a number of things, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ASpell::Tick()`函数会执行一些操作，如下所示：'
- en: It gets all actors overlapping `ProxBox`. Any actor that is not the caster gets
    damaged if the component overlapped is the root component of that object. The
    reason we have to check for overlapping with the root component is because, if
    we don't, the spell might overlap the monster's `SightSphere`, which means we
    will get hits from very far away, which we don't want.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它获取所有与`ProxBox`重叠的角色。如果组件重叠的不是施法者的根组件，那么任何角色都会受到伤害。我们必须检查与根组件的重叠，因为如果不这样做，法术可能会与怪物的`SightSphere`重叠，这意味着我们会受到很远处的攻击，这是我们不想要的。
- en: Notice that if we had another class of thing that should get damaged, we would
    have to attempt a cast to each object type specifically. Each class type might
    have a different type of bounding volume that should be collided with; other types
    might not even have `CapsuleComponent` (they might have `ProxBox` or `ProxSphere`).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，如果我们有另一个应该受到伤害的东西类，我们将不得不尝试对每种对象类型进行转换。每种类别可能具有不同类型的边界体积应该进行碰撞；其他类型甚至可能没有`CapsuleComponent`（它们可能有`ProxBox`或`ProxSphere`）。
- en: It increases the amount of time the spell has been alive for. If the spell exceeds
    the duration it is allotted to be cast for, it is removed from the level.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加了法术存在的时间。如果法术超过了分配的施法时间，它将从关卡中移除。
- en: Now, let's focus on how the player can acquire spells, by creating an individual
    `PickupItem` for each spell object that the player can pick up.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于玩家如何获得法术，通过为玩家可以拾取的每个法术对象创建一个单独的`PickupItem`。
- en: Blueprinting our spells
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图化我们的法术
- en: 'Compile and run your C++ project with the `Spell` class that we just added.
    We need to create blueprints for each of the spells we want to be able to cast.
    To do this, follow these steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行刚刚添加的`Spell`类的C++项目。我们需要为我们想要施放的每个法术创建蓝图。要做到这一点，请按照以下步骤进行：
- en: In the Class Viewer tab, start to type `Spell`, and you should see your Spell
    class appear
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Class Viewer选项卡中，开始输入`Spell`，你应该看到你的Spell类出现
- en: 'Right-click on Spell, and create a blueprint called BP_Spell_Blizzard as shown
    in the following screenshot:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击Spell，创建一个名为BP_Spell_Blizzard的蓝图，如下截图所示：
- en: '![](img/d2c44941-90e5-47c0-bad6-063fd84cab08.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2c44941-90e5-47c0-bad6-063fd84cab08.png)'
- en: If it doesn't open automatically, double-click to open it.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它没有自动打开，请双击打开它。
- en: 'Inside the spell''s properties, choose the P_Blizzard spell for the particle
    emitter, as shown in the following screenshot:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在法术的属性中，选择P_Blizzard法术作为粒子发射器，如下截图所示：
- en: '![](img/f1ce427a-570e-4bc1-98b5-2ee9c87c8efa.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1ce427a-570e-4bc1-98b5-2ee9c87c8efa.png)'
- en: If you can't find it, try selecting Particles (Inherited) under Components.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到它，请尝试在组件下选择Particles (Inherited)。
- en: 'With  BP_SpellBlizzard(self) selected, scroll down until you reach the Spell
    category, and update the Damage Per Second and Duration parameters to values you
    like, as shown in the following screenshot. Here, the blizzard spell will last
    `3.0` seconds, and do `16.0` damage per second. After three seconds, the blizzard
    will disappear:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 选择BP_SpellBlizzard(self)，向下滚动直到到达法术类别，并更新每秒伤害和持续时间参数为你喜欢的值，如下截图所示。在这里，暴风雪法术将持续`3.0`秒，每秒造成`16.0`点伤害。三秒后，暴风雪将消失：
- en: '![](img/592a8226-92ac-4099-a193-662622fa24c8.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/592a8226-92ac-4099-a193-662622fa24c8.png)'
- en: 'After you have configured the Default properties, switch over to the Components
    tab to make some further modifications. Click on and change the shape of `ProxBox`
    so that its shape makes sense. The box should wrap the most intense part of the
    particle system, but don''t get carried away in expanding its size. The `ProxBox`
    object shouldn''t be too big, because then your blizzard spell would affect things
    that aren''t even being touched by the blizzard. As shown in the following screenshot,
    a couple of outliers are OK:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了默认属性之后，切换到组件选项卡进行一些进一步的修改。点击并改变`ProxBox`的形状，使其形状合理。盒子应该包裹粒子系统最强烈的部分，但不要过分扩大其大小。`ProxBox`对象不应该太大，因为那样你的暴风雪法术会影响到甚至没有被暴风雪触及的东西。如下截图所示，一些离群值是可以接受的：
- en: '![](img/cbf2312a-6a5d-4de4-8ac3-ead61614357c.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbf2312a-6a5d-4de4-8ac3-ead61614357c.png)'
- en: Your blizzard spell is now blueprinted and ready to be used by the player.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你的暴风雪法术现在已经制作成蓝图，并准备好供玩家使用。
- en: Picking up spells
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捡起法术
- en: 'Recall that we previously programmed our inventory to display the number of
    pickup items the player has when the user presses *I*. We want to do more than
    that, however:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们之前编程使我们的库存在用户按下*I*时显示玩家拥有的捡起物品的数量。然而，我们想做的不仅仅是这样：
- en: '![](img/0d443ba0-5008-4ed8-a000-1cfbb0a04eae.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d443ba0-5008-4ed8-a000-1cfbb0a04eae.png)'
- en: Items displayed when the user presses I
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 用户按下I时显示的物品
- en: 'To allow the player to pick up spells, we''ll modify the `PickupItem` class
    to include a slot for a blueprint of the spell the player casts by using the following
    code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家捡起法术，我们将修改`PickupItem`类，包括一个用以下代码使用的法术蓝图的槽：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you've added the `UClass* Spell` property to the `APickupItem` class, recompile
    and rerun your C++ project. Now, you can proceed to make blueprints of `PickupItem`
    instances for your `Spell` objects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为`APickupItem`类添加了`UClass* Spell`属性，重新编译并重新运行你的C++项目。现在，你可以继续为你的`Spell`对象制作`PickupItem`实例的蓝图。
- en: Creating blueprints for PickupItems that Cast Spells
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建施放法术的PickupItems的蓝图
- en: 'Create a PickupItem blueprint called BP_Pickup_Spell_Blizzard, as shown in
    the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为BP_Pickup_Spell_Blizzard的PickupItem蓝图，如下截图所示：
- en: '![](img/c858650a-7e6b-496c-9855-2027dc4dd31f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c858650a-7e6b-496c-9855-2027dc4dd31f.png)'
- en: 'It should open automatically so you can edit its properties. I set the blizzard
    item''s pickup properties as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该自动打开，这样你就可以编辑它的属性。我将暴风雪物品的捡起属性设置如下：
- en: 'The name of the item is Blizzard Spell, and `5` are in each package. I took
    a screenshot of the blizzard particle system and imported it into the project,
    so the Icon is selected as that image. Under Spell, I selected BP_Spell_Blizzard
    as the name of the spell to be cast (not BP_Pickup_Spell_Blizzard), as shown in
    the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 物品的名称是暴风雪法术，每个包装中有`5`个。我拍摄了暴风雪粒子系统的截图，并将其导入到项目中，因此图标被选为该图像。在法术下，我选择了BP_Spell_Blizzard作为要施放的法术的名称（而不是BP_Pickup_Spell_Blizzard），如下截图所示：
- en: '![](img/0ef88141-1364-4dea-9d2c-904abd726f13.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ef88141-1364-4dea-9d2c-904abd726f13.png)'
- en: 'I selected a blue sphere for the `Mesh` class of the `PickupItem` class (you
    can also get an interesting one by using the M_Water_Lake material). For Icon,
    I took a screenshot of the blizzard spell in the particle viewer preview, saved
    it to disk, and imported that image to the project, as shown in the following
    screenshot (see the `images` folder in the Content Browser tab of the sample project):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我为`PickupItem`类的`Mesh`类选择了一个蓝色的球（你也可以使用M_Water_Lake材质来获得有趣的效果）。对于图标，我在粒子查看器预览中拍摄了暴风雪法术的截图，保存到磁盘，并将该图像导入到项目中，如下截图所示（在示例项目的内容浏览器选项卡中查看`images`文件夹）：
- en: '![](img/612d25a5-142b-45fb-ba60-f7cbfd0f501f.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/612d25a5-142b-45fb-ba60-f7cbfd0f501f.png)'
- en: 'Place a few of these `PickupItem` in your level. If we pick them up, we will
    have some blizzard spells in our inventory (if you can''t pick them up make sure
    you made the ProxSphere big enough):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的关卡中放置一些`PickupItem`。如果我们捡起它们，我们的库存中将有一些暴风雪法术（如果你捡不起来，请确保你的ProxSphere足够大）：
- en: '![](img/badddff5-2324-4dc4-9320-1957be5bf452.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/badddff5-2324-4dc4-9320-1957be5bf452.png)'
- en: Now, we need to activate the blizzard. Since we already attached the left mouse
    click in [Chapter 10](45ff2a5d-da41-49dd-90af-8be3fb8c30d5.xhtml), *Inventory
    System and Pickup Items*, to drag the icons around, let's attach the right mouse
    click to casting the spell.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要激活暴风雪。由于我们已经在[第10章](45ff2a5d-da41-49dd-90af-8be3fb8c30d5.xhtml)中将左键单击附加到拖动图标的*库存系统和捡起物品*，让我们将右键单击附加到施放法术。
- en: Attaching right mouse click to CastSpell
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将右键单击附加到CastSpell
- en: 'The right mouse click will have to go through quite a few function calls before
    calling the avatar''s `CastSpell` method. The call graph would look something
    like the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用角色的`CastSpell`方法之前，右键单击将经过多次函数调用。调用图看起来会像下面的截图所示：
- en: '![](img/3946b2e1-8cbb-40fe-b7aa-556f61174f31.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3946b2e1-8cbb-40fe-b7aa-556f61174f31.png)'
- en: 'A few things happen between right-click and spell cast. They are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在右键单击和施法之间会发生一些事情。它们如下：
- en: As we saw before, all user mouse and keyboard interactions are routed through
    the `Avatar` object. When the `Avatar` object detects a right-click, it will pass
    the click event to `HUD` through `AAvatar::MouseRightClicked()`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，所有用户鼠标和键盘交互都通过`Avatar`对象路由。当`Avatar`对象检测到右键单击时，它将通过`AAvatar::MouseRightClicked()`将点击事件传递给`HUD`。
- en: 'In [Chapter 10](45ff2a5d-da41-49dd-90af-8be3fb8c30d5.xhtml), *Inventory System
    and Pickup Items* we used a `struct Widget` class to keep track of the items the
    player had picked up. `struct Widget` only had three members:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第10章](45ff2a5d-da41-49dd-90af-8be3fb8c30d5.xhtml)中，*库存系统和拾取物品*，我们使用了一个`struct
    Widget`类来跟踪玩家拾取的物品。`struct Widget`只有三个成员：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will now need to add an extra property for the `struct Widget` class to remember
    the spell it casts.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们需要为`struct Widget`类添加一个额外的属性来记住它施放的法术。
- en: The `HUD` will determine if the click event was inside `Widget` in `AMyHUD::MouseRightClicked()`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HUD`将确定点击事件是否在`AMyHUD::MouseRightClicked()`中的`Widget`内。'
- en: If the click was on the `Widget` that casts a spell, the `HUD` then calls the
    avatar back with the request to cast that spell, by calling `AAvatar::CastSpell()`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点击的是施放法术的`Widget`，则`HUD`将通过调用`AAvatar::CastSpell()`向avatar发出施放该法术的请求。
- en: Writing the avatar's CastSpell function
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写avatar的CastSpell函数
- en: 'We will implement the preceding call graph in reverse. We will start by writing
    the function that actually casts spells in the game, `AAvatar::CastSpell()`, as
    shown in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以相反的方式实现前面的调用图。我们将首先编写实际在游戏中施放法术的函数`AAvatar::CastSpell()`，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Also make sure to add the function to `Avatar.h` and add `#include "Spell.h"`
    to the top of this file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保将该函数添加到`Avatar.h`中，并在该文件的顶部添加`#include "Spell.h"`。
- en: 'You might find that actually calling a spell is remarkably simple. There are
    two basic steps to casting the spell:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现实际施放法术非常简单。施放法术有两个基本步骤：
- en: Instantiate the spell object using the world object's `SpawnActor` function
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用世界对象的`SpawnActor`函数实例化法术对象
- en: Attach it to the avatar
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其附加到avatar
- en: Once the `Spell` object is instantiated, its `Tick()` function will run each
    frame when that spell is in the level. On each `Tick()`, the `Spell` object will
    automatically feel out monsters in the level and damage them. A lot happens with
    each line of code mentioned previously, so let's discuss each line separately.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Spell`对象被实例化，当该法术在关卡中时，它的`Tick()`函数将在每一帧运行。在每个`Tick()`上，`Spell`对象将自动感知关卡中的怪物并对它们造成伤害。每个先前提到的代码行都会发生很多事情，因此让我们分别讨论每一行。
- en: Instantiating the spell – GetWorld()->SpawnActor()
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化法术- GetWorld()->SpawnActor()
- en: To create the `Spell` object from the blueprint, we need to call the `SpawnActor()`
    function from the `World` object. The `SpawnActor()` function can take any blueprint
    and instantiate it within the level. Fortunately, the `Avatar` object (and indeed
    any `Actor` object) can get a handle to the `World` object at any time by simply
    calling the `GetWorld()` member function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从蓝图创建`Spell`对象，我们需要从`World`对象调用`SpawnActor()`函数。`SpawnActor()`函数可以使用任何蓝图在关卡中实例化它。幸运的是，`Avatar`对象（实际上任何`Actor`对象）可以随时通过简单调用`GetWorld()`成员函数获得`World`对象的句柄。
- en: 'The line of code that brings the `Spell` object into the level is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Spell`对象带入关卡的代码行如下：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are a couple of things to note about the preceding line of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上述代码行有几件事情需要注意：
- en: '`bpSpell` must be the blueprint of a `Spell` object to create. The `<ASpell>`
    object in angle brackets indicates that expectation.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpSpell`必须是要创建的`Spell`对象的蓝图。尖括号中的`<ASpell>`对象表示期望。'
- en: The new `Spell` object starts out at the origin (`0`, `0`, `0`), and with no
    additional rotation applied to it. This is because we will attach the `Spell`
    object to the `Avatar` object, which will supply translation and direction components
    for the `Spell` object.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`Spell`对象从原点(`0`, `0`, `0`)开始，并且没有应用额外的旋转。这是因为我们将`Spell`对象附加到`Avatar`对象，后者将为`Spell`对象提供平移和方向组件。
- en: if(spell)
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if(spell)
- en: We always test if the call to `SpawnActor<ASpell>()` succeeds by checking `if(
    spell )`. If the blueprint passed to the `CastSpell` object is not actually a
    blueprint based on the `ASpell` class, then the `SpawnActor()` function returns
    a `NULL` pointer instead of a `Spell` object. If that happens, we print an error
    message to the screen indicating that something went wrong during spell casting.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终通过检查`if( spell )`来测试对`SpawnActor<ASpell>()`的调用是否成功。如果传递给`CastSpell`对象的蓝图实际上不是基于`ASpell`类的蓝图，则`SpawnActor()`函数返回一个`NULL`指针而不是`Spell`对象。如果发生这种情况，我们会在屏幕上打印错误消息，指示在施放法术期间出现了问题。
- en: spell->SetCaster(this)
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: spell->SetCaster(this)
- en: When instantiating, if the spell does succeed, we attach the spell to the `Avatar`
    object by calling `spell->SetCaster( this )`. Remember, in the context of programming
    within the `Avatar` class, the `this` method is a reference to the `Avatar` object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化时，如果法术成功，则通过调用`spell->SetCaster( this )`将法术附加到`Avatar`对象。请记住，在`Avatar`类内编程的上下文中，`this`方法是对`Avatar`对象的引用。
- en: Now, how do we actually connect spell casting from UI inputs, to call the `AAvatar::CastSpell()`
    function in the first place? We need to do some `HUD` programming again.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实际将UI输入的法术施放连接到首先调用`AAvatar::CastSpell()`函数呢？我们需要再次进行一些`HUD`编程。
- en: Writing AMyHUD::MouseRightClicked()
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写AMyHUD::MouseRightClicked()
- en: The spell cast commands will ultimately come from the HUD. We need to write
    a C++ function that will walk through all the HUD widgets and test to see if a
    click is on any one of them. If the click is on a `widget` object, then that `widget`
    object should respond by casting its spell, if it has one assigned.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 法术施放命令最终将来自HUD。我们需要编写一个C++函数，遍历所有HUD小部件，并测试点击是否在其中任何一个上。如果点击在`widget`对象上，则该`widget`对象应该通过施放其法术来做出响应，如果它有一个已分配的话。
- en: 'We have to extend our `Widget` object to have a variable to hold the blueprint
    of the spell to cast. Add a member to your `struct Widget` object by using the
    following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须扩展我们的`Widget`对象以具有保存要施放的法术蓝图的变量。使用以下代码向您的`struct Widget`对象添加成员：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, recall that our `PickupItem` had the blueprint of the spell it casts attached
    to it previously. However, when the `PickupItem` class is picked up from the level
    by the player, then the `PickupItem` class is destroyed, as shown in the following
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回想一下，我们的`PickupItem`之前附有其施放的法术的蓝图。但是，当玩家从级别中拾取`PickupItem`类时，然后`PickupItem`类被销毁，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, we need to retain the information of what spell each `PickupItem` casts.
    We can do that when that `PickupItem` is first picked up.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要保留每个`PickupItem`施放的法术的信息。当首次拾取`PickupItem`时，我们可以这样做。
- en: 'Inside the `AAvatar` class, add an extra map to remember the blueprint of the
    spell that an item casts, by item name, with the following line of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AAvatar`类中，通过以下代码添加额外的映射来记住物品施放的法术的蓝图，按物品名称：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, in `AAvatar::Pickup()`, remember the class of spell the `PickupItem` class
    instantiates with the following line of code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`AAvatar::Pickup()`中，使用以下代码记住`PickupItem`类实例化的法术类：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, in `AAvatar::ToggleInventory()`, we can have the `Widget` object that displays
    on the screen. Remember what spell it is supposed to cast by looking up the `Spells`
    map.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`AAvatar::ToggleInventory()`中，我们可以在屏幕上显示的`Widget`对象。通过查找`Spells`映射来记住它应该施放的法术。
- en: 'Find the line where we create the widget, and modify it to add assignment of
    the `bpSpell` objects that the `Widget` casts, as shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 找到我们创建小部件的行，并修改它以添加`Widget`施放的`bpSpell`对象的赋值，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following function to `AMyHUD`, which we will set to run whenever the
    right mouse button is clicked on the icon:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到`AMyHUD`，每当在图标上单击鼠标右键时，我们将其设置为运行：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is very similar to our left mouse click function. We simply check the click
    position against all the widgets. If any `Widget` was hit by the right-click,
    and that `Widget` has a `Spell` object associated with it, then a spell will be
    cast by calling the avatar's `CastSpell()` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的左键单击功能非常相似。我们只需检查点击位置是否与所有小部件相交。如果任何`Widget`被鼠标右键点击，并且该`Widget`与`Spell`对象相关联，则将通过调用角色的`CastSpell()`方法施放法术。
- en: Activating right mouse button clicks
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活鼠标右键点击
- en: 'To connect this HUD function to run, we need to attach an event handler to
    the mouse right-click. We can do so by performing the following steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此HUD功能运行，我们需要将事件处理程序附加到鼠标右键点击。我们可以通过执行以下步骤来实现：
- en: Go to Settings | Project Settings; the dialog pops up
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到设置 | 项目设置；对话框弹出
- en: 'Under Engine - Input, add an action mapping for Right Mouse Button, as shown
    in the following screenshot:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在引擎 - 输入下，添加一个右键鼠标按钮的操作映射，如下面的屏幕截图所示：
- en: '![](img/222a2cf3-be13-4d8d-a73c-df854a0550b4.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/222a2cf3-be13-4d8d-a73c-df854a0550b4.png)'
- en: 'Declare a function in `Avatar.h`/`Avatar.cpp` called `MouseRightClicked()`
    with the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Avatar.h`/`Avatar.cpp`中声明一个名为`MouseRightClicked()`的函数，使用以下代码：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, in `AAvatar::SetupPlayerInputComponent()`, we should attach the `MouseClickedRMB`
    event to that `MouseRightClicked()` function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`AAvatar::SetupPlayerInputComponent()`中，我们应该将`MouseClickedRMB`事件附加到`MouseRightClicked()`函数：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have finally hooked up spell casting. Try it out; the gameplay is pretty
    cool, as shown in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于连接了施法。试一试；游戏玩起来非常酷，如下面的屏幕截图所示：
- en: '![](img/28b4e241-832c-405a-85d7-b66336ffac8d.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28b4e241-832c-405a-85d7-b66336ffac8d.png)'
- en: Creating other spells
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建其他法术
- en: By playing around with particle systems, you can create a variety of different
    spells that do different effects. You can create spells for fire, or lightning,
    or to push the enemy away from you. You've probably run into many other possible
    spells while playing other games.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过玩弄粒子系统，您可以创建各种不同的法术，产生不同的效果。您可以创建火焰、闪电或将敌人推开的法术。在玩其他游戏时，您可能已经遇到了许多其他可能的法术。
- en: The fire spell
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 火焰法术
- en: 'You can easily create a fire variant of our blizzard spell by changing the
    color of the particle system to red. This is how the fire variant of our blizzard
    spell will appear:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将粒子系统的颜色更改为红色，您可以轻松创建我们暴风雪法术的火焰变体。这是我们暴风雪法术的火焰变体的外观：
- en: '![](img/1b86ad1b-7a5e-4675-b4b1-233d26ed5059.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b86ad1b-7a5e-4675-b4b1-233d26ed5059.png)'
- en: The out val of the color changed to red
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色的输出值更改为红色
- en: Exercises
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try the following exercises:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习：
- en: '**Lightning spell**: Create a lightning spell by using the beam particle. Follow
    Zak''s tutorial for an example of how beams are created and shot in a direction,
    at [https://www.youtube.com/watch?v=ywd3lFOuMV8&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&amp;index=7](https://www.youtube.com/watch?v=ywd3lFOuMV8&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&index=7).'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闪电法术**：使用光束粒子创建闪电法术。按照Zak的教程示例，了解如何创建光束并朝一个方向发射，网址为[https://www.youtube.com/watch?v=ywd3lFOuMV8&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&amp;index=7](https://www.youtube.com/watch?v=ywd3lFOuMV8&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&index=7)。'
- en: '**Forcefield spell**: A forcefield will deflect attacks. It is essential for
    any player. Suggested implementation: derive a subclass of `ASpell` called `ASpellForceField`.
    Add a bounding sphere to the class, and use that in the `ASpellForceField::Tick()`
    function to push the monsters out.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力场法术**：力场将使攻击偏转。对于任何玩家来说都是必不可少的。建议实现：派生`ASpell`的子类称为`ASpellForceField`。向该类添加一个边界球，并在`ASpellForceField::Tick()`函数中使用它将怪物推出。'
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You now know how to create spells to defend yourself in game. We've used particle
    systems to create a visible spell effect, and an area that can be used to cause
    damage to any enemies inside it. You can expand on what you've learned to create
    even more.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何在游戏中创建防御法术。我们使用粒子系统创建了可见的法术效果，并且可以用来对任何在其中的敌人造成伤害的区域。您可以扩展所学知识以创建更多内容。
- en: In the next chapter we will look into a newer and easier way to build the user
    interface.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一种更新且更容易的构建用户界面的方法。
