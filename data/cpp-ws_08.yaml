- en: 8\. Creating and Using Web API Clients
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 创建和使用Web API客户端
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will step into the world of HTTP practice by making calls
    to Web APIs. You will interact with Web APIs in a variety of ways using a web
    browser, your own HTTP client, and NuGet packages. You will learn the basics of
    security involved in Web APIs, use PayPal to make sandbox payments, and explore
    cloud services such as Azure Text Analytics and Azure Blob storage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将通过使用Web浏览器、自己的HTTP客户端和NuGet软件包以多种方式与Web API进行交互，进入HTTP实践的世界。您将学习涉及Web
    API的安全基础知识，使用PayPal进行沙盒支付，并探索云服务，如Azure文本分析和Azure Blob存储。
- en: By the end of this chapter, you will be able to read HTTP requests and response
    messages, make calls to any Web API, and create your own HTTP client to simplify
    your work with complex APIs. You will also be able to dissect and learn both incoming
    HTTP requests and outgoing HTTP responses in any form and use development tools
    in the Chrome browser to inspect traffic moving back and forth when browsing your
    favorite websites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够阅读HTTP请求和响应消息，调用任何Web API，并创建自己的HTTP客户端以简化与复杂API的工作。您还将能够解剖和学习任何形式的传入HTTP请求和传出HTTP响应，并使用Chrome浏览器中的开发工具检查在浏览您喜爱的网站时来回移动的流量。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The World Wide Web (WWW) (or just the web) is a big store of all sorts of documents
    (XML, JSON, HTML, MP3, JPG, etc.) accessible through Uniform Resource Locators
    (URLs). A document in the context of the web is often called a resource. Some
    resources do not change. They are stored somewhere, and with every request, the
    same resource will be returned. Such resources are called static. Other resources
    are dynamic, which means they will be generated on demand.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网（WWW）（或者只是网络）是各种文档（XML、JSON、HTML、MP3、JPG等）的大型存储库，可通过统一资源定位符（URL）访问。在网络上下文中，文档通常称为资源。一些资源不会改变。它们存储在某个地方，每次请求时都会返回相同的资源。这些资源称为静态资源。其他资源是动态的，这意味着它们将根据需要生成。
- en: 'Communication on the web happens through protocols. In the context of retrieving
    documents, you use Hypertext Transfer Protocol (HTTP). Hypertext is a special
    text that holds a link to a resource on the web. Clicking on it opens the resource
    it points to. HTTP is based on a client-server architecture. In simple terms,
    a client sends requests, and the server responds. An example of this in practice
    is the communication between a browser (client) and a website (hosted on a server).
    Usually, a single server serves many clients:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通信通过协议进行。在检索文档的情况下，您使用超文本传输协议（HTTP）。超文本是一种特殊的文本，其中包含指向网络资源的链接。单击它会打开它指向的资源。HTTP基于客户端-服务器架构。简单来说，客户端发送请求，服务器响应。实践中的一个例子是浏览器（客户端）与网站（托管在服务器上）之间的通信。通常，一个服务器为多个客户端提供服务：
- en: '![Figure 8.1: Client-server architecture'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：客户端-服务器架构'
- en: '](img/B16835_08_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_01.jpg)'
- en: 'Figure 8.1: Client-server architecture'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：客户端-服务器架构
- en: 'When you navigate to a website, you send an `HTTP GET` request, and the server
    responds by displaying the relevant site content in the browser. `GET` is an HTTP
    verb—a method identifying how a request should be treated. Common HTTP verbs are
    the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导航到一个网站时，您发送一个`HTTP GET`请求，服务器通过在浏览器中显示相关站点内容来做出响应。`GET`是一个HTTP动词，用于标识请求应该如何处理。常见的HTTP动词如下：
- en: '`GET`: Get a resource.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 获取资源。'
- en: '`POST`: Create a resource or send a complex query.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: 创建资源或发送复杂查询。'
- en: '`PUT`: Update all resource fields.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: 更新所有资源字段。'
- en: '`PATCH`: Update a single field.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`: 更新单个字段。'
- en: '`DELETE`: Remove a resource.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 删除资源。'
- en: Browser
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器
- en: 'A modern browser is more than just a tool to access content on the internet.
    It includes tools to dissect elements of a website, inspect traffic, and even
    execute code. This side of a browser is called developer tools. The exact key
    binds may vary but pressing `F12` or `Control + Shift + I` should call up the
    Developer Tools tab. Perform the following steps to get to know it better:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器不仅是访问互联网内容的工具。它包括用于解剖网站元素、检查流量甚至执行代码的工具。浏览器的这一方面称为开发者工具。确切的键绑定可能有所不同，但按下`F12`或`Control
    + Shift + I`应该调出开发者工具选项卡。执行以下步骤以更好地了解它：
- en: Open Google Chrome or any other browser.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开谷歌浏览器或任何其他浏览器。
- en: Navigate to [google.com](http://google.com). Press the keys `Control + Shift
    + I`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[google.com](http://google.com)。按下键`Control + Shift + I`。
- en: 'Go to `Network` (`1`). The following window should be displayed:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Network`（`1`）。应该显示以下窗口：
- en: '![Figure 8.2: Chrome with developer tools open with google.com loaded'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2：打开带有google.com的开发者工具的Chrome'
- en: '](img/B16835_08_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_02.jpg)'
- en: 'Figure 8.2: Chrome with developer tools open with google.com loaded'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：打开带有google.com的开发者工具的Chrome
- en: Select the first entry, [www.google.com](http://www.google.com) (`2`).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第一个条目，[www.google.com](http://www.google.com)（`2`）。
- en: Click `Headers` (`3`).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Headers`（`3`）。
- en: In the `General` (`4`) section, you can observe the effects when you navigated
    to [google.com](http://google.com). The first thing that happened was `HTTP GET`
    request was sent to [https://www.google.com/](https://www.google.com/).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`General`（`4`）部分，您可以观察到当您导航到[google.com](http://google.com)时的效果。发生的第一件事是发送了`HTTP
    GET`请求到[https://www.google.com/](https://www.google.com/)。
- en: In the `Request Headers` section (`5`), you can see the metadata sent with the request.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Request Headers`部分（`5`），您可以看到与请求一起发送的元数据。
- en: To see how Google responded, click the `Response` section (`6`).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看谷歌的响应，请点击`Response`部分（`6`）。
- en: 'This flow is called the client-server architecture, and the following applies:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流程称为客户端-服务器架构，以下内容适用：
- en: The client is the Chrome browser that sends a request to [google.com](http://google.com).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端是Chrome浏览器，它向[google.com](http://google.com)发送请求。
- en: The server is a machine(s) hosting [google.com](http://google.com) that responds
    with [google.com](http://google.com) website contents.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器是托管[google.com](http://google.com)并响应[google.com](http://google.com)网站内容的机器（S）。
- en: Web API
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web API
- en: An Application Programming Interface (API) is an interface through which you
    can call some functionality using code. It could be a class or an interface in
    C#, or a browser (you can interact with it through code provided by its own interface),
    but in the context of HTTP, it is a web service. A web service is an API hosted
    on a remote machine that is accessible through HTTP. An access point used to invoke
    a single piece of functionality on a Web API is called an endpoint. The most commonly
    used Web API type is RESTful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口（API）是一个通过代码调用某些功能的接口。它可以是C#中的类或接口，也可以是浏览器（您可以通过其自己的接口提供的代码与其交互），但在HTTP的上下文中，它是一个Web服务。Web服务是托管在远程计算机上通过HTTP可访问的API。用于在Web
    API上调用单个功能的访问点称为端点。最常用的Web API类型是RESTful。
- en: RESTful API
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTful API
- en: 'A Representational State Transfer (REST) API is an API built on the following
    six principles. Four principles are a given whatever framework you use implementing
    a RESTful API, and, as a client, they should be expected:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表述状态转移（REST）API是建立在以下六个原则上的API。无论您使用何种框架实现RESTful API，都应该预期四个原则：
- en: 'Client-server: A connection is made between a client and server. The client
    sends a request in order to get a response from a server.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器：客户端和服务器之间建立连接。客户端发送请求以获取服务器的响应。
- en: 'Stateless: The server will be able to process requests regardless of prior
    requests. This means that each request should contain all the information, rather
    than relying on a server to remember what happened before.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态：服务器将能够处理请求，而不考虑之前的请求。这意味着每个请求都应包含所有信息，而不是依赖服务器记住之前发生的事情。
- en: 'Cacheable: The ability to specify which requests can be cached using HTTP methods
    or headers.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存：能够指定可以使用HTTP方法或标头缓存哪些请求。
- en: 'Code on demand (optional): REST allows scripts to be downloaded and executed
    on the client side. Back when the internet was made mostly of static pages, this
    was useful, but nowadays it is either not needed or is seen as a security risk.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需代码（可选）：REST允许在客户端上下载并执行脚本。在互联网主要由静态页面组成的早期，这是有用的，但现在要么不需要，要么被视为安全风险。
- en: However, the other two principles (Client-server and Stateless) depend on you,
    and thus you will want to pay more attention to them. A layered system is a system
    made of layers, and each layer communicates only with the layer directly below
    it. A typical example of this is a three-tier architecture, where you separate
    presentation, business logic, and the data store. From a practical point of view,
    this means that a RESTful API (business logic layer) should not send HTML as a
    response because the responsibility for rendering output lies with the client
    (the presentation layer).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，另外两个原则（客户端-服务器和无状态）取决于您，因此您将希望更加关注它们。分层系统是由层构成的系统，每个层只与直接下面的层通信。这的典型例子是三层架构，其中您将分离表示、业务逻辑和数据存储。从实际角度来看，这意味着RESTful
    API（业务逻辑层）不应发送HTML作为响应，因为呈现输出的责任在于客户端（表示层）。
- en: 'The last principle is called a uniform interface. It defines a set of rules
    for an API:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个原则称为统一接口。它定义了API的一组规则：
- en: 'Identification of resources:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的识别：
- en: Some examples of these are get all instances of a resource (`/resource`), create
    a resource (`/resource`), get a single resource (`/resource/id`), and get all
    instances of a subresource in a resource (`/resource/subresource/`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些例子是获取资源的所有实例（`/resource`）、创建资源（`/resource`）、获取单个资源（`/resource/id`）以及获取资源中子资源的所有实例（`/resource/subresource/`）。
- en: 'Manipulation of resources through these representations:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过这些表示来操作资源：
- en: Resources are manipulated using HTTP verbs representing Create, Read, Update,
    and Delete (CRUD)—`GET`, `UPDATE`, `PUT`, `PATCH`, `DELETE`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代表创建、读取、更新和删除（CRUD）的HTTP动词来操作资源——`GET`、`UPDATE`、`PUT`、`PATCH`、`DELETE`。
- en: 'Self-descriptive messages:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自描述消息：
- en: A response that includes all the required information, without any extra documentation,
    and indicates how the message should be processed (headers, mime type, etc.).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含所有所需信息，没有任何额外的文档，并指示消息应如何处理（标头、媒体类型等）。
- en: 'Hypermedia as the engine of application state (HATEOAS):'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超媒体作为应用状态的引擎（HATEOAS）：
- en: Hyperlinks are included in response to all the related resources so that you
    can navigate to them. This guideline is usually ignored.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中包含所有相关资源的超链接，以便您可以导航到它们。通常会忽略这个指南。
- en: REST is not the same as HTTP. REST is a set of guidelines, while HTTP is a protocol.
    The two might be confused because HTTP constraints heavily overlap with REST constraints
    (methods, headers, etc.). However, a RESTful API does not have to use HTTP to
    be RESTful, and at the same time HTTP can violate REST constraints by using a
    session or query parameters to provide actions to perform. A RESTful API can work
    with both XML and JSON data formats. However, almost all scenarios involve JSON.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: REST不同于HTTP。REST是一组指南，而HTTP是一种协议。两者可能会混淆，因为HTTP的约束与REST的约束（方法、标头等）有很大的重叠。然而，RESTful
    API不必使用HTTP才能成为RESTful，同时HTTP也可以通过使用会话或查询参数来违反REST的约束，以提供要执行的操作。RESTful API可以使用XML和JSON数据格式。然而，几乎所有的场景都涉及JSON。
- en: Postman
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Postman
- en: 'Postman is one of the most popular tools used for testing different kinds of
    Web APIs. It is easy to set up and use. Postman, just like a browser, acts as
    an HTTP client. In order to download Postman, go to [https://www.postman.com/](https://www.postman.com/).
    You will need to sign up and then download the installer. Once you have installed
    Postman, perform the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Postman是用于测试不同类型Web API的最流行工具之一。它易于设置和使用。Postman就像浏览器一样，充当HTTP客户端。要下载Postman，请转到[https://www.postman.com/](https://www.postman.com/)。您需要注册然后下载安装程序。安装了Postman后，请执行以下步骤：
- en: Open Postman.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Postman。
- en: Create your workspace by clicking `Workspaces` and then click on `Create Workspace`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击“工作区”然后单击“创建工作区”来创建您的工作区。
- en: In the new window, go to the `Collections` tab (`2`) and click the `Create new
    Collection` (`+`) button (`3`).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，转到`Collections`选项卡（`2`），并点击`Create new Collection`（+）按钮（`3`）。
- en: Create a `New Collection` (`4`).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`New Collection`（`4`）。
- en: 'Click on `Add a request` (`5`):'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Add a request`（`5`）：
- en: '![Figure 8.3: New Postman collection without requests'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：没有请求的新Postman集合'
- en: '](img/B16835_08_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_03.jpg)'
- en: 'Figure 8.3: New Postman collection without requests'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：没有请求的新Postman集合
- en: A new request window will open.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的请求窗口将打开。
- en: Click the edit symbol beside `New Request` and name the new request `Users` (`6`).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`New Request`旁边的编辑符号，并将新请求命名为`Users`（`6`）。
- en: Select the `GET` HTTP verb and copy-paste the URL [https://api.github.com/users/github-user](https://api.github.com/users/github-user)
    (`7`).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`GET` HTTP动词并复制粘贴URL [https://api.github.com/users/github-user](https://api.github.com/users/github-user)
    (`7`)。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Here, and in all places that follow, replace `github-user` with your own GitHub
    username.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，以及所有接下来的地方，用你自己的GitHub用户名替换`github-user`。
- en: Click the `Send` button (`8`).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Send`按钮（`8`）。
- en: 'Now scroll down to see the response result returned (`9`):'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向下滚动以查看返回的响应结果（`9`）：
- en: '![Figure 8.4: GET GitHub user request in Postman'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：在Postman中获取GitHub用户请求'
- en: '](img/B16835_08_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_04.jpg)'
- en: 'Figure 8.4: GET GitHub user request in Postman'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：在Postman中获取GitHub用户请求
- en: Postman is superior to a browser when it comes to acting as an HTTP client.
    It is focused on forming HTTP requests and displays response information compactly,
    offering multiple output formats. In Postman, you can use multiple environments,
    set up pre-and post-conditions for requests, automated calls, and a lot more,
    but going through those advanced features is beyond the scope of this chapter.
    For now, it is enough to learn that Postman is a go-to tool for testing Web APIs
    by hand.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到充当HTTP客户端时，Postman比浏览器更优越。它专注于形成HTTP请求，并紧凑地显示响应信息，提供多种输出格式。在Postman中，你可以使用多个环境，设置请求的前后条件，自动化调用等等，但是深入了解这些高级功能超出了本章的范围。现在，了解Postman是一个用于手动测试Web
    API的必备工具就足够了。
- en: Client
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端
- en: REST requires communication between a client and a server. In the previous examples,
    the client role was taken by either a browser or Postman. However, neither a browser
    nor Postman can replace a client in your code. Instead, you'll need to create
    an HTTP request using C#.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: REST需要客户端和服务器之间的通信。在前面的示例中，客户端角色由浏览器或Postman扮演。然而，既不是浏览器也不是Postman可以在你的代码中替代客户端。相反，你需要使用C#创建一个HTTP请求。
- en: Popular Web APIs often have a client created for you (in most common languages
    as well). The purpose of a Web API client is to simplify interactions with the
    underlying API. For example, instead of sending a `DELETE` request on an endpoint
    that does not support it and getting the response `Method Not Allowed`, you won't
    even have such an option on a custom client.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的Web API通常会为你创建一个客户端（在大多数常见的语言中也是如此）。Web API客户端的目的是简化与底层API的交互。例如，不是在不支持的端点上发送`DELETE`请求并收到响应`Method
    Not Allowed`，你在自定义客户端上甚至不会有这样的选项。
- en: Octokit
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Octokit
- en: Octokit is a GitHub API client. It exposes a C# class through which you can
    pass objects to make calls to GitHub. The benefit of such a client is that you
    don't need to worry about which headers to pass or how to name things so that
    they are properly serialized. An API client handles all that for you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Octokit是一个GitHub API客户端。它通过一个C#类公开，通过该类你可以传递对象来调用GitHub。这样一个客户端的好处是你不需要担心要传递哪些头部或者如何命名事物以便它们被正确序列化。API客户端会为你处理所有这些。
- en: 'You can install the Octokit client in your project by running the following
    command in the VS Code terminal or command prompt:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在VS Code终端或命令提示符中运行以下命令来在项目中安装Octokit客户端：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you have the Octokit client installed, you can use it to create a GitHub
    client, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了Octokit客户端，你就可以使用它来创建一个GitHub客户端，如下所示：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding snippet, you needed a new `ProductHeaderValue` because GitHub
    expects a `UserAgent` header. As mentioned earlier, custom HTTP clients prevent
    a mistake from happening before you can even make a request. In this case, not
    providing a `UserAgent` header (through `ProductHeaderValue`) is not an option.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，你需要一个新的`ProductHeaderValue`，因为GitHub需要一个`UserAgent`头部。正如前面提到的，自定义HTTP客户端可以在你发出请求之前防止错误发生。在这种情况下，不提供`UserAgent`头部（通过`ProductHeaderValue`）不是一个选项。
- en: 'To see whether the client works, try to get information on the username `github-user`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看客户端是否工作，请尝试获取有关用户名`github-user`的信息：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In GitHub, `github-user` is displayed as `Almantask`. It is better to change
    it to your individual GitHub username for the code to work.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub中，`github-user`显示为`Almantask`。最好将其更改为你个人的GitHub用户名以使代码正常工作。
- en: 'To print the date when the user was created, type the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印用户创建日期，输入以下代码：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will see the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Every method available on the GitHub API is also available on **GitHub client
    Octokit**. You don't need to worry about the endpoint, mandatory headers, a response,
    or the request format; it is all defined by the strongly typed client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub API上的每个可用方法也都可以在**GitHub客户端Octokit**上使用。你不需要担心端点、强制头部、响应或请求格式；这一切都由强类型的客户端定义。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/DK2n2](https://packt.link/DK2n2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/DK2n2](https://packt.link/DK2n2)找到本示例使用的代码。
- en: API Key
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API密钥
- en: 'With many public free APIs, you may be faced with concerns such as the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多公共免费的API，你可能会面临以下问题：
- en: How can you control an overwhelming number of requests?
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何控制大量的请求？
- en: At what point should which client be charged?
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么时候应该收费哪个客户端？
- en: If all these public APIs offered only anonymous access, you would not be able
    to identify the clients or determine how many calls each of them has made. An
    API key serves as the most basic means of authentication (identifying the client)
    and authorization (granting them access to do something with an API). Simply put,
    an API key allows you to call an API. Without it, you would have little to no
    access to an API.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些公共API只提供匿名访问，您将无法识别客户端或确定每个客户端进行了多少次调用。API密钥作为身份验证（识别客户端）和授权（授予他们对API执行某些操作的访问权限）的最基本手段。简而言之，API密钥允许您调用API。没有它，您几乎无法访问API。
- en: To help you grasp the use of API keys better, the next section will look at
    a Web API that requires one, that is, Azure Text Analytics.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解API密钥的使用，下一节将介绍一个需要API密钥的Web API，即Azure文本分析。
- en: Azure Text Analytics
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure文本分析
- en: 'Azure Text Analytics is an Azure API used to analyze text in the following
    ways:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Azure文本分析是用于以下方式分析文本的Azure API：
- en: Identify named entities (people, events, organizations)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别命名实体（人物、事件、组织）
- en: Interpret the mood of the text (positive, negative, neutral)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释文本的情绪（积极、消极、中性）
- en: Produce a summary of a document or highlight key phrases
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文档摘要或突出关键短语
- en: Process unstructured medical data, such as recognizing people, classifying diagnoses,
    and so on
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理非结构化的医疗数据，例如识别人员、分类诊断等
- en: 'In order to demonstrate the Azure Text Analytics API, you will focus on sentimental
    analysis. This is the process of evaluating text according to a positive, negative,
    or neutral confidence score:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示Azure文本分析API，您将专注于情感分析。这是根据积极、消极或中性置信度评估文本的过程：
- en: The score of 1, which means 100%, is the probability that the prediction (negative,
    positive, neutral) is correct.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1分的得分表示100%的概率，即预测（消极、积极、中性）是正确的。
- en: The score of 0, which means 0%, is an impossible prediction.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0分的得分表示0%的概率，即是不可能的预测。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using Azure Text Analytics is free until you analyze more than 5,000 words per
    30 days.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure文本分析是免费的，直到您分析超过30天内的5000个单词。
- en: Before you begin coding, you'll need to set up Azure Text Analytics on the Azure
    cloud. After all, you need both an endpoint and an API key to make a call to this
    API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，您需要在Azure云上设置Azure文本分析。毕竟，您需要端点和API密钥才能调用此API。
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you have set up an Azure subscription. If you don't have one, go to
    [https://azure.microsoft.com/en-gb/free/search](https://azure.microsoft.com/en-gb/free/search)
    and follow the instructions there to create a **free** subscription. An Azure
    free trial offers many services for free. Some of those services will remain free
    even after a year. A student subscription is an option for getting Azure credits
    and free services for a longer period. A credit or debit card is required to create
    an Azure subscription; however, you won't be charged unless you exceed the given
    Azure credits of the free service limitations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已设置了Azure订阅。如果没有，请转到[https://azure.microsoft.com/en-gb/free/search](https://azure.microsoft.com/en-gb/free/search)并按照那里的说明创建一个**免费**订阅。Azure免费试用提供许多免费服务。其中一些服务甚至在一年后仍然免费。学生订阅是获得Azure积分和免费服务更长时间的选项。创建Azure订阅需要信用卡或借记卡；但是，除非超出免费服务限制的给定Azure积分，否则不会收费。
- en: 'One way in which Azure Text Analytics could be used to sort positive and negative
    feedback is by determining whether what you wrote sounds passive-aggressive or
    friendly. To see this in action, follow the steps to create a small application
    that analyzes any text you input into a console:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Azure文本分析可以用于对正面和负面反馈进行分类的一种方法是确定您写的内容是被动攻击还是友好的。要了解这一点，请按照以下步骤创建一个分析您输入到控制台的任何文本的小应用程序：
- en: First, go to [https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics](https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到[https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics](https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics)。
- en: 'Click `Continue to create your resource` without using any additional features:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“继续创建您的资源”而不使用任何其他功能：
- en: '![Figure 8.5: Azure Text Analytics resource creation'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5：Azure文本分析资源创建'
- en: '](img/B16835_08_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_05.jpg)'
- en: 'Figure 8.5: Azure Text Analytics resource creation'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：Azure文本分析资源创建
- en: In the Create text analytics window, click the `Basics` tab. This is the first
    tab opened at the start of the creation of a new resource.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建文本分析窗口中，单击“基本”选项卡。这是在创建新资源时打开的第一个选项卡。
- en: 'Select an option in the `Subscription` and `Resource group` fields:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“订阅”和“资源组”字段中选择一个选项：
- en: '![Figure 8.6: Entering the project details for new resource creation'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6：输入新资源创建的项目详细信息'
- en: '](img/B16835_08_06.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_06.jpg)'
- en: 'Figure 8.6: Entering the project details for new resource creation'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：输入新资源创建的项目详细信息
- en: Then, select the region, for example, `North Europe`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择地区，例如“北欧”。
- en: Enter the name, for example, `Packt-Test`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称，例如“Packt-Test”。
- en: 'After that, select the `Free F0` pricing tier and click the `Review + create` button:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择“免费F0”定价层，并单击“审核+创建”按钮：
- en: '![Figure 8.7: Azure Text Analytics pricing tier'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7：Azure文本分析定价层'
- en: '](img/B16835_08_07.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_07.jpg)'
- en: 'Figure 8.7: Azure Text Analytics pricing tier'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：Azure文本分析定价层
- en: A new window gets displayed confirming your input.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示一个确认您输入的新窗口。
- en: Click the `Create` option. The Text Analytics API will start deploying. After
    the deployment of the service is done, a new window will open saying `Your deployment
    is complete`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“创建”选项。文本分析API将开始部署。服务部署完成后，将打开一个新窗口，显示“您的部署已完成”。
- en: 'Click on the `Go to resource` button:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“转到资源”按钮：
- en: '![Figure 8.8: The Text Analytics API showing the deployment as complete'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8：文本分析API显示部署已完成'
- en: '](img/B16835_08_08.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_08.jpg)'
- en: 'Figure 8.8: The Text Analytics API showing the deployment as complete'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：文本分析API显示部署已完成
- en: The Text Analytics resource window gets displayed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 显示文本分析资源窗口。
- en: 'Click the `Keys and Endpoint` option. You will see the `Endpoint` option along
    with `KEY 1` and `KEY 2` to make calls to this API. You can choose from either
    of the keys:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`Keys and Endpoint`选项。您将看到`Endpoint`选项以及`KEY 1`和`KEY 2`，以调用此API。您可以从这两个密钥中选择一个：
- en: '![Figure 8.9: Azure Text Analytics quick start window with API key hyperlink'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9：带有API密钥超链接的Azure Text Analytics快速入门窗口'
- en: '](img/B16835_08_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_09.jpg)'
- en: 'Figure 8.9: Azure Text Analytics quick start window with API key hyperlink'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：带有API密钥超链接的Azure Text Analytics快速入门窗口
- en: Keep track of `KEY 1` (an API key). An API key is a secret and should not be
    exposed in plain text. You will once again be using the environment variables
    to store it.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪`KEY 1`（API密钥）。API密钥是一个秘密，不应以纯文本形式暴露。您将再次使用环境变量来存储它。
- en: 'Create an environment variable with key and value pair. The value will be the
    endpoint API key required to connect to Azure Text Analytics. To help identify
    the missing environment variable, use a helper class. The `GetOrThrow` method
    will get a user environment variable, and if it doesn''t exist, will throw an
    exception:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有键和值对的环境变量。值将是连接到Azure Text Analytics所需的端点API密钥。为了帮助识别缺失的环境变量，使用一个辅助类。`GetOrThrow`方法将获取用户环境变量，如果不存在，将抛出异常：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Keep track of the `Endpoint` option. You will use it in the upcoming exercise
    to call the API you have just deployed.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪`Endpoint`选项。您将在即将进行的练习中使用它来调用刚刚部署的API。
- en: This section helped you to set up Azure Text Analytics on the Azure cloud, in
    addition to setting both an endpoint and an API key to make a call to the API.
    In the following exercise, you will be using the Azure Text Analytics client to
    make calls to the API.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本节帮助您在Azure云上设置Azure Text Analytics，除了设置端点和API密钥以调用API之外。在接下来的练习中，您将使用Azure
    Text Analytics客户端调用API。
- en: 'Exercise 8.01: Performing Sentimental Text Analysis on Any Text'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01：对任何文本进行情感文本分析
- en: Azure Text Analytics is just another REST API. Once again, you make HTTP calls
    to it and get a response. This time, you will send over a text to get its sentimental
    analysis. Do another practice run of using a strongly typed client and make calls
    to a RESTful API from C#.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Text Analytics只是另一个REST API。再次向其发出HTTP调用并获得响应。这次，您将发送一段文本以获取其情感分析。再次练习使用强类型客户端并从C#调用RESTful
    API。
- en: 'Using a recently deployed Azure Text Analytics service (`Pack-Test`, in this
    case), perform sentimental analysis on any text you want. Perform the following
    steps to complete this exercise:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最近部署的Azure Text Analytics服务（在本例中为`Pack-Test`），对您想要的任何文本进行情感分析。执行以下步骤完成此练习：
- en: 'Install the `Azure.AI.TextAnalytics` NuGet package to get an Azure Text Analytics
    API client as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`Azure.AI.TextAnalytics` NuGet包，以获取Azure Text Analytics API客户端，如下所示：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Add the `TextAnalysisApiKey` environmental variable.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`TextAnalysisApiKey`环境变量。
- en: Then add the `TextAnalysisEndpoint` environmental variable.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加`TextAnalysisEndpoint`环境变量。
- en: 'Create a `Demo` class and add references to the two environmental variables
    that you have recently added:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Demo`类，并添加对您最近添加的两个环境变量的引用：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These properties are used to hide sensitive values of the API key and endpoint.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性用于隐藏API密钥和端点的敏感值。
- en: 'Create a new `BuildClient` method to build an API client:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`BuildClient`方法来构建API客户端：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The API client requires both a base URL—a kind of Unified Resource Identifier
    (URI)—and an API key to operate, both of which are passed to it during initialization.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: API客户端在初始化期间需要基本URL（一种统一资源标识符（URI））和API密钥，这两者都将在初始化期间传递给它。
- en: 'Using the client, create the `PerformSentimentalAnalysis` method to analyze
    the text:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用客户端，创建`PerformSentimentalAnalysis`方法来分析文本：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you are using the configuration object `AnalyzeSentimentOptions` to extract
    targets and opinions on them. The client has both the `AnalyzeSentimentAsync`
    and `AnalyzeSentiment` methods. For public client libraries, exposing both async
    and non-async versions of the same method is a very common scenario. After all,
    not everyone will be comfortable with an async API. However, when making calls
    to another machine (DB, API, and similar) it's best to use an async API. This
    is because an async call will not block the thread on which the call is made while
    it is waiting for a response from an API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在使用配置对象`AnalyzeSentimentOptions`来提取目标和对它们的意见。客户端具有`AnalyzeSentimentAsync`和`AnalyzeSentiment`方法。对于公共客户端库，公开同一方法的异步和非异步版本是非常常见的情况。毕竟，并不是每个人都会对异步API感到舒适。但是，当调用另一个机器（数据库、API等）时，最好使用异步API。这是因为异步调用不会阻塞进行调用的线程，而是在等待API响应时。
- en: 'Now create a `DisplaySentenceSymmary` function to display the sentence''s overall
    evaluation:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建`DisplaySentenceSymmary`函数来显示句子的整体评估：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a `DisplaySentenceOpinions` function to display the message `Opinions`
    for every target in a sentence:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`DisplaySentenceOpinions`函数，以显示句子中每个目标的`Opinions`消息：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The target of a sentence is a subject that has an opinion (grammatical modifier)
    applied to it. For example, with the sentence, **a beautiful day**, **day** would
    be a target and **beautiful** an opinion.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 句子的目标是具有应用于它的意见（语法修饰语）的主题。例如，对于句子**a beautiful day**，**day**将是一个目标，**beautiful**是一个意见。
- en: 'To perform a sentimental analysis on text typed in a console, create a `SentimentAnalysisExample`
    method:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在控制台中对文本进行情感分析，请创建一个`SentimentAnalysisExample`方法：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The analysis text, in the preceding code snippet, evaluates the overall text's
    sentiment and then breaks it down into sentences, evaluating each.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，分析文本评估了整体文本的情绪，然后将其分解为句子，并对每个句子进行评估。
- en: 'To demonstrate how your code works, create a static `Demo.Run` method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示您的代码如何工作，创建一个静态的`Demo.Run`方法：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the environment variable set correctly, the following output should be displayed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设置环境变量后，应显示以下输出：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You did not hardcode the value of an API key here because an API key, exposed
    publicly, poses a risk of being used not the way it was intended to. If stolen,
    it could have disastrous consequences (for example, being overused, creating a
    false resource, leaking data, deleting data, etc.). That is why when dealing with
    secrets, use the minimal possible countermeasures, that is, environmental variables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里没有硬编码API密钥的值，因为公开的API密钥使用不当可能会带来风险。如果被盗，可能会产生灾难性后果（例如被滥用、创建虚假资源、泄露数据、删除数据等）。这就是为什么在处理机密信息时，使用尽可能少的对策，也就是环境变量。
- en: Another benefit of environment variables is the ability to have a different
    value in different environments (local, integration, system test, production,
    etc.). Different environments often use different resources. So, pointing to those
    resources through environment variables will not require any changes to the code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量的另一个好处是在不同环境（本地、集成、系统测试、生产等）中具有不同的值的能力。不同的环境通常使用不同的资源。因此，通过环境变量指向这些资源将不需要对代码进行任何更改。
- en: In order to run this exercise, go to [https://packt.link/GR27A](https://packt.link/GR27A)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `await Exercises.Exercise01.Demo.Run();`. Similarly, uncomment the respective
    exercises'/examples'/activities' code lines in `Program.cs` before executing each
    of them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个练习，去[https://packt.link/GR27A](https://packt.link/GR27A)并注释掉`static void`
    `Main(string[] args)`体内的所有行，除了`await Exercises.Exercise01.Demo.Run();`。同样，在执行每个练习/示例/活动之前，取消注释`Program.cs`中相应的练习/示例/活动的代码行。
- en: Note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/y1Bqy](https://packt.link/y1Bqy).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/y1Bqy](https://packt.link/y1Bqy)找到用于这个练习的代码。
- en: This exercise is just one of the many in which you consumed a public Web API.
    Azure is full of services like this. Calling an API using a strongly typed client
    is simple; however, not all APIs have one. In the next section, you will learn
    how to create your own Web API client.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习只是你使用公共Web API的众多练习之一。Azure充满了这样的服务。使用强类型客户端调用API很简单；然而，并非所有API都有。在下一节中，你将学习如何创建自己的Web
    API客户端。
- en: Your Own Client
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你自己的客户端
- en: So far, you've only used a premade client to consume a Web API. However, for
    less popular APIs, there will not be any client for you to use. In those cases,
    you will have to make HTTP calls yourself. In .NET, the way of making calls has
    evolved quite a lot. If you don't want any third-party libraries, you can use
    the `HttpClient` class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只使用了一个预制的客户端来消费Web API。然而，对于不太流行的API，可能没有客户端供你使用。在这种情况下，你将不得不自己进行HTTP调用。在.NET中，进行调用的方式已经有了很大的发展。如果你不想使用第三方库，你可以使用`HttpClient`类。
- en: HttpClient
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HttpClient
- en: 'In this section, you''ll repeat the GitHub `Users` example (from the *Postman*
    section), but this time using `HttpClient`. The flow for this is quite simple
    and is described for you in detail in the following example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将重复GitHub`Users`示例（来自*Postman*部分），但这次使用`HttpClient`。这个流程非常简单，并且在下面的示例中为你详细描述：
- en: 'Within the `GitHttp` static class, create the `GetUser` method:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GitHttp`静态类中，创建`GetUser`方法：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Within the `GitExamples` method, first, create a client:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GitExamples`方法中，首先创建一个客户端：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating a client almost always involves specifying a specific base URL. Often,
    Web APIs require mandatory headers to be passed, or else they will invalidate
    the request (`400 Bad Request`). For GitHub, you need to send the `User-Agent`
    header identifying the client that calls the API. Adding the `Packt` user agent
    header to default headers will send that header with every request to the client.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是需要指定特定基本URL来创建客户端。通常，Web API要求传递强制性标头，否则它们将使请求无效（`400 Bad Request`）。对于GitHub，你需要发送`User-Agent`标头来标识调用API的客户端。将`Packt`用户代理标头添加到默认标头将在每个请求发送到客户端时发送该标头。
- en: 'You then create a request as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以按以下方式创建一个请求：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember to replace `github-user` with your own GitHub username. Here, you've
    specified that you want to create a `GET` request. You did not specify a full
    path, but rather only the endpoint you want to hit; therefore, you had to flag
    `UriKind` as `Relative`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 记得用你自己的GitHub用户名替换`github-user`。在这里，你指定要创建一个`GET`请求。你没有指定完整的路径，而是只指定了你要访问的端点；因此，你必须将`UriKind`标记为`Relative`。
- en: 'Next, send a request using the client:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用客户端发送请求：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is only an async version of sending an HTTP request message, so you need
    to wait for it. The result of sending `HttpRequestMessage` is `HttpResponseMessage`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个发送HTTP请求消息的异步版本，所以你需要等待它。发送`HttpRequestMessage`的结果是`HttpResponseMessage`。
- en: 'Then, deserialize the content to a usable object as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按以下方式将内容反序列化为可用对象：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Deserializing is the act of converting a structured text such as JSON into
    in-memory objects. For this, you need to convert the content to a string and then
    deserialize it. You could use a user model from Octokit NuGet. Since you are already
    making custom calls, you might as well use a custom model. For the bare minimum
    (only the fields you use), your model could look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化是将结构化文本（如JSON）转换为内存对象的行为。为此，你需要将内容转换为字符串，然后进行反序列化。你可以使用Octokit NuGet中的用户模型。由于你已经在进行自定义调用，那么你可能也会使用自定义模型。对于最基本的（只使用的字段），你的模型可能如下所示：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The line `[JsonProperty("created_at")]`, above `public DateTime CreatedAt {
    get; set; }`, binds the JSON field to the C# property. This binding is needed
    because the names don't match.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public DateTime CreatedAt { get; set; }`上面的`[JsonProperty("created_at")]`一行将JSON字段绑定到C#属性。这种绑定是必需的，因为名称不匹配。
- en: If you want to create your own client (for making GitHub calls), it's your responsibility
    to expose all data that the API returns and not just the data you may need for
    a particular scenario by letting the consumer choose.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建自己的客户端（用于调用GitHub），那么你有责任暴露API返回的所有数据，而不仅仅是你可能需要的特定场景的数据。
- en: 'Use the message from a previous call from Postman to get the GitHub user response
    body to generate models to deserialize to. In this case, the response message
    is as follows (message truncated for clarity):'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postman中的先前调用的消息从GitHub用户响应主体生成要反序列化的模型。在这种情况下，响应消息如下（为了清晰起见，消息已截断）：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are many tools available that can convert JSON to the C# model.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的工具可以将JSON转换为C#模型。
- en: In this case, use [https://json2csharp.com/](https://json2csharp.com/) to convert
    JSON to the C# model code.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，使用[https://json2csharp.com/](https://json2csharp.com/)将JSON转换为C#模型代码。
- en: Copy the response (`GET github/user`) and go to [https://json2csharp.com/](https://json2csharp.com/).
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制响应（`GET github/user`）并转到[https://json2csharp.com/](https://json2csharp.com/)。
- en: 'Paste the response into the textbox on the left and click the `Convert` button:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将响应粘贴到左侧的文本框中，然后单击“转换”按钮：
- en: '![Figure 8.10: Converting JSON to the C# model code'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10：将JSON转换为C#模型代码'
- en: '](img/B16835_08_10.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_10.jpg)'
- en: 'Figure 8.10: Converting JSON to the C# model code'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：将JSON转换为C#模型代码
- en: The left side displays a model for the JSON, while the right side displays the
    code (C# class) that is generated from JSON.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧显示了JSON的模型，右侧显示了从JSON生成的代码（C#类）。
- en: 'Copy the content on the right and paste it into your code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制右侧的内容并粘贴到您的代码中：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is your model. Observe in the preceding code that `Root` is an unreadable
    class name. This is because the converter didn't have a way to know what class
    JSON represents. The `Root` class represents a user; therefore, rename it `User`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的模型。请注意，在上述代码中，`Root`是一个不可读的类名。这是因为转换器无法知道JSON代表什么类。`Root`类代表一个用户；因此，请将其重命名为`User`。
- en: 'Lastly, the converter was probably created prior to .NET 5, which is why it
    didn''t have a feature for records. A record is a great class for serialization
    purposes and a great candidate for a data transfer object (DTO). A DTO is a class
    that has no logic but simply data, and sometimes attributes for binding serialization.
    The benefits you get are the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，转换器可能是在.NET 5之前创建的，这就是为什么它没有记录功能。记录是用于序列化目的的一个很好的类，也是数据传输对象（DTO）的一个很好的候选者。DTO是一个没有逻辑但只是数据的类，有时还有用于绑定序列化的属性。您获得的好处如下：
- en: Value equality
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值相等
- en: '`ToString` will return properties and their values'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToString`将返回属性及其值'
- en: The ability to define them with a less verbose syntax
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以更简洁的语法定义它们的能力
- en: So, use a record for defining DTOs in your applications whenever possible.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽可能在应用程序中使用记录来定义DTO。
- en: 'Rename the (`Root` to `User`) and change the type from `class` to `record`.
    The code line looks like this with no changes needed to the properties:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将（`Root`更名为`User`）并将类型从`class`更改为`record`。代码行看起来像这样，不需要更改属性：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, run the following line of code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行以下代码行：
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output gets displayed as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示如下：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In order to run this exercise, go to [https://packt.link/GR27A](https://packt.link/GR27A)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `await Examples.GitHttp.Demo.Run();`. Similarly, uncomment the respective exercises'/examples'/activities'
    code lines in `Program.cs` before execution.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此练习，请转到[https://packt.link/GR27A](https://packt.link/GR27A)，并在`static void`
    `Main(string[] args)`体内注释掉所有行，除了`await Examples.GitHttp.Demo.Run();`。同样，在执行之前，取消注释`Program.cs`中相应练习/示例/活动的代码行。
- en: Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/UPxmW](https://packt.link/UPxmW).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/UPxmW](https://packt.link/UPxmW)找到此示例使用的代码。
- en: Now that you have seen the benefits of using the `HttpClient` class in lieu
    of third-party libraries, you can now explore the `IDisposable` pattern in the
    following section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了在使用`HttpClient`类而不是第三方库时的好处，现在可以在以下部分探索`IDisposable`模式。
- en: HttpClient and IDisposable
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HttpClient和IDisposable
- en: '`HttpClient` implements the `IDisposable` pattern. In general, right after
    you are done using an object that implements `IDisposable`, you should clean up
    and call the `Dispose` method or wrap the calls within a `using` block. However,
    `HttpClient` is special in that you should not frequently create and dispose of
    it all over again. The problem with disposing and re-initializing `HttpClient`
    is that `HttpClient` manages connections it makes to other APIs and disposing
    of `HttpClient` does not properly close those connections (or sockets).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`实现了`IDisposable`模式。一般来说，在您使用实现了`IDisposable`的对象之后，您应该清理并调用`Dispose`方法，或者将调用包装在`using`块中。但是，`HttpClient`是特殊的，您不应该频繁地创建和处理它。处理和重新初始化`HttpClient`的问题在于，`HttpClient`管理它与其他API建立的连接，并且处理`HttpClient`不会正确关闭这些连接（或套接字）。'
- en: The most dangerous part about that is that you will not notice any difference
    in developing your application locally, due to the massive number of connections
    available. However, when deploying an application to a live environment, you risk
    running out of free socket connections. Once again, avoid calling a `Dispose`
    method and reinitializing `HttpClient`. If you must, use `HttpClientFactory`.
    Not only does `HttpClientFactory` manage the lifetime of socket connections by
    managing `HttpClientMessageHandler` (the component responsible for sending the
    HTTP request and receiving the response) but it also provides logging capability,
    allows centralized management of clients' configuration, supports injecting middleware
    to clients, etc. The mentioned benefits are important if you use `HttpClient`
    in an enterprise setting. You can learn more about `HttpClientFactory` in *Chapter
    9*, *Creating API Services*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险的部分是，由于可用连接数量庞大，您在本地开发应用程序时不会注意到任何差异。但是，当将应用程序部署到实时环境时，您可能会耗尽免费的套接字连接。再次强调，避免调用`Dispose`方法并重新初始化`HttpClient`。如果必须这样做，请使用`HttpClientFactory`。`HttpClientFactory`不仅通过管理`HttpClientMessageHandler`（负责发送HTTP请求和接收响应的组件）来管理套接字连接的生命周期，还提供日志记录功能，允许对客户端的配置进行集中管理，支持向客户端注入中间件等。如果您在企业环境中使用`HttpClient`，则上述好处非常重要。您可以在*第9章*
    *创建API服务*中了解有关`HttpClientFactory`的更多信息。
- en: Ideally, you should have one static `HttpClient`, which you can reuse for calls
    to Web APIs throughout your application. However, you should not have a single
    `HttpClient` for everything. The point about not disposing of `HttpClient` and
    having a static one is not a hard rule. If you call many different APIs, they
    will have their own base addresses, mandatory headers, and so on. Having a single
    object for all is not a viable scenario.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您应该有一个静态的“HttpClient”，可以在整个应用程序中重复使用来调用Web API。但是，您不应该为所有事情都有一个单独的“HttpClient”。不释放“HttpClient”并拥有一个静态的“HttpClient”并不是一个硬性规定。如果您调用许多不同的API，它们将有自己的基本地址、强制性标头等。为所有这些使用一个对象并不是一个可行的情况。
- en: The requests you've handled so far were publicly accessible and did not have
    security. However, expensive or private operations in Web APIs are usually protected.
    Typically, protection is set up using an Authorization header. In many cases,
    an Authorization header involves some sort of an ID and secret. In the case of
    the GitHub API, it involves a client ID and client secret. But to get them, you
    will need to create an OAuth app.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您处理的请求是公开可访问的，没有安全性。然而，Web API中的昂贵或私有操作通常是受保护的。通常，保护是使用授权标头设置的。在许多情况下，授权标头涉及某种ID和密钥。在GitHub
    API的情况下，它涉及客户端ID和客户端密钥。但是，要获得它们，您需要创建一个OAuth应用程序。
- en: Before you can do this though, you need to get familiar with OAuth.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在做这些之前，您需要熟悉OAuth。
- en: OAuth
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth
- en: 'OAuth is an open-standard authorization protocol that allows delegating access
    on behalf of a user. This section will explore two examples:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一种开放标准的授权协议，允许代表用户委派访问权限。本节将探讨两个示例：
- en: Real-life analogy
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实生活类比
- en: API analogy
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API类比
- en: Real-life Analogy
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现实生活类比
- en: 'Imagine a child at school. The teacher of that child is organizing a trip to
    another city. A permission slip from the parents is needed. The parents give a
    note: *It''s okay for my child to go to place X.* The child gives the note to
    the teacher and gets permission to travel to a field trip to destination X.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个在学校的孩子。那个孩子的老师正在组织去另一个城市的旅行。需要父母的许可证。父母给了一张纸条：*可以让我的孩子去X地方。*孩子把纸条给老师，获得了去X目的地的实地考察的许可。
- en: API Analogy
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API类比
- en: Many applications are interconnected, with integrations to each other. For example,
    the famous social platform Discord allows you to display whatever accounts you
    have on other social media. But to do that, you need to connect to the platform
    of social media you want to display. For example, when you are on Discord and
    try to link a Twitter account, you will be required to log in on Twitter. A login
    will require a certain scope of access (your profile name, in this case). A successful
    login is proof that access is given, and Discord will be able to display your
    profile information on Twitter on your behalf.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序是相互连接的，彼此集成。例如，著名的社交平台Discord允许您显示您在其他社交媒体上拥有的任何帐户。但是，为了做到这一点，您需要连接到您想要显示的社交媒体平台。例如，当您在Discord上尝试链接Twitter帐户时，您将需要在Twitter上登录。登录将需要一定范围的访问权限（在这种情况下是您的个人资料名称）。成功登录证明已经授予了访问权限，Discord将能够代表您在Twitter上显示您的个人资料信息。
- en: OAuth App for GitHub
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub的OAuth应用程序
- en: Returning to the subject of GitHub, what is an OAuth app? It is a registration
    for a single point of security. It acts as your application identity. A GitHub
    user might have zero or more applications. As mentioned before, an OAuth app includes
    a client ID and secret. Through them, you can use the GitHub API. In other words,
    you can set it up to request access to secure features of GitHub, such as changing
    your personal data on GitHub.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 回到GitHub的主题，OAuth应用程序是什么？它是一个单一安全点的注册。它充当您的应用程序身份。GitHub用户可能有零个或多个应用程序。如前所述，OAuth应用程序包括客户端ID和密钥。通过它们，您可以使用GitHub
    API。换句话说，您可以设置它来请求访问GitHub的安全功能，例如更改GitHub上的个人数据。
- en: GitHub has an interesting API limitation. If more than 60 unauthenticated requests
    come from the same IP, it will block subsequent requests for up to an hour. However,
    the rate limitation can be removed by authorizing requests. That is the prime
    reason why you will be using authorization for an otherwise public endpoint.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub有一个有趣的API限制。如果来自同一IP的未经身份验证的请求超过60个，它将阻止接下来的请求长达一小时。但是，可以通过授权请求来删除速率限制。这就是为什么您将为否则公共端点使用授权的主要原因。
- en: 'OAuth usually involves two client applications:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth通常涉及两个客户端应用程序：
- en: One that requests permission on behalf of someone
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代表某人请求权限
- en: Another that grants that permission
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个授予该权限
- en: 'Therefore, when setting up OAuth, you will most likely be required to create
    a URL to return to after the permission is granted from the client that can grant
    access. Setting up an OAuth app on GitHub involves these steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设置OAuth时，您很可能需要创建一个URL，以便在客户端授予权限后返回。在GitHub上设置OAuth应用程序涉及以下步骤：
- en: 'In the top-right corner, click on your profile picture and click `Settings`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角，单击您的个人资料图片，然后单击“设置”：
- en: '![Figure 8.11: Account settings in GitHub'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11：GitHub中的帐户设置'
- en: '](img/B16835_08_11.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_11.jpg)'
- en: 'Figure 8.11: Account settings in GitHub'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：GitHub中的帐户设置
- en: 'On the left side, scroll down almost to the bottom of the menu and click the
    `Developer settings` option:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧，向下滚动到菜单的几乎底部，然后单击“开发者设置”选项：
- en: '![Figure 8.12: Developer settings in GitHub'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12：GitHub中的开发者设置'
- en: '](img/B16835_08_12.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_12.jpg)'
- en: 'Figure 8.12: Developer settings in GitHub'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：GitHub中的开发者设置
- en: 'Now select the `Oauth Apps` option:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择“Oauth Apps”选项：
- en: '![Figure 8.13: Selecting OAuth apps in Developer settings in GitHub'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13：在GitHub的开发者设置中选择OAuth应用程序'
- en: '](img/B16835_08_13.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_13.jpg)'
- en: 'Figure 8.13: Selecting OAuth apps in Developer settings in GitHub'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：在GitHub的开发者设置中选择OAuth应用程序
- en: 'Then click the `Register a new application` button:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击“注册新应用”按钮：
- en: '![Figure 8.14: Creating a new OAuth app in GitHub'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14：在GitHub中创建一个新的OAuth应用程序'
- en: '](img/B16835_08_14.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_14.jpg)'
- en: 'Figure 8.14: Creating a new OAuth app in GitHub'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：在GitHub中创建一个新的OAuth应用程序
- en: Note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have previously created an OAuth app, then this window will display all
    those listed. In order to create a new one, you will have to click `New OAuth
    App`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前创建过OAuth应用程序，那么此窗口将显示所有已列出的应用程序。为了创建一个新的应用程序，您将需要点击`新的OAuth应用程序`。
- en: In the next window, you will complete the form. Start by filling in `Application
    name` (`5`). Avoid using special characters.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个窗口中，您将完成表格。首先填写`应用程序名称`（`5`）。避免使用特殊字符。
- en: Next, fill in `Homepage URL` (`6`).
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，填写`主页URL`（`6`）。
- en: This URL usually points to a website that describes the use of OAuth for a particular
    case and why it is required. Even if you don't have a website that describes such
    a case, you can type a placeholder URL (in this case, `myapp.com`). The field
    accepts anything as long as it is a valid URL.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此URL通常指向一个网站，描述了为特定情况使用OAuth的情况以及为什么需要它。即使您没有描述这种情况的网站，您也可以输入一个占位符URL（在本例中为`myapp.com`）。只要是有效的URL，该字段就接受任何内容。
- en: Fill in the `Authorization callback URL` (`7`) field. This can be whatever you
    want. Here, `myapp.com/home` is used. Use a valid callback URL.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写`授权回调URL`（`7`）字段。这可以是任何您想要的。在这里，使用了`myapp.com/home`。使用一个有效的回调URL。
- en: 'Click `Register application` (`8`):![Figure 8.15: New OAuth app window in GitHub'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`注册应用程序`（`8`）：![图8.15：GitHub中的新OAuth应用程序窗口
- en: '](img/B16835_08_15.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_15.jpg)'
- en: 'Figure 8.15: New OAuth app window in GitHub'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：GitHub中的新OAuth应用程序窗口
- en: 'In the new window, you will see `Client ID` and `Client secrets`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，您将看到`客户端ID`和`客户端密钥`：
- en: '![Figure 8.16: Details of a new OAuth app on GitHub with app'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16：GitHub上一个新的OAuth应用程序的详细信息'
- en: credentials—Client ID and Client secrets
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 凭据——客户端ID和客户端密钥
- en: '](img/B16835_08_16.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_16.jpg)'
- en: 'Figure 8.16: Details of a new OAuth app on GitHub with app credentials—Client
    ID and Client secrets'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：GitHub上一个新的OAuth应用程序的详细信息凭据——客户端ID和客户端密钥
- en: It is best to store a client secret in a safe place for future reference because
    you will see it only once on GitHub. If you forget it, you will have to create
    a new secret and delete the old one.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将客户端密钥存储在一个安全的地方以备将来参考，因为您只会在GitHub上看到它一次。如果您忘记了它，您将不得不创建一个新的密钥并删除旧的密钥。
- en: Now you have successfully created an OAuth app on GitHub. The client secret
    is partly hidden in this screenshot for a reason. You should never expose it publicly.
    In order to use it in a demo, you will use environmental variables first to hide
    them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已成功在GitHub上创建了一个OAuth应用程序。客户端密钥在此截图中部分隐藏是有原因的。您不应该公开它。为了在演示中使用它，您将首先使用环境变量来隐藏它们。
- en: So, store the values in environmental variables `GithubClientId` and `GithubSecret`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，将值存储在环境变量`GithubClientId`和`GithubSecret`中。
- en: 'Then expose the two through static properties in `Demo.cs` (explained earlier)
    as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过`Demo.cs`中的静态属性公开这两个值（前面已经解释过）：
- en: '[PRE26]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This section covered the steps to set up an OAuth app in GitHub that can be
    used to request access to secure features of GitHub, such as changing your personal
    data. With this knowledge, you can now use a client ID and client secret to create
    authorized calls on the GitHub API, as demonstrated in the following section.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了在GitHub中设置OAuth应用程序的步骤，该应用程序可用于请求访问GitHub的安全功能，例如更改个人数据。有了这些知识，您现在可以使用客户端ID和客户端密钥来创建GitHub
    API上的授权调用，如下一节所示。
- en: Authorization Header
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权标头
- en: Authorization headers come in three forms—basic, API key (or personal access
    token), and third-party authentication. The GitHub API does not allow an unlimited
    number of calls from the same source. Like the Azure Text Analytics client, it
    uses an API key as well. However, in this case, the API key is used for rate limiting
    (how many calls you can make in an hour). For anonymous calls, it only allows
    60 calls an hour. However, by using a valid Authorization header, the amount is
    increased to 5,000.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 授权标头有三种形式——基本的、API密钥（或个人访问令牌）和第三方认证。GitHub API不允许来自相同来源的无限次调用。就像Azure文本分析客户端一样，它也使用API密钥。然而，在这种情况下，API密钥用于速率限制（一个小时内可以进行多少次调用）。对于匿名调用，它只允许每小时60次调用。然而，通过使用有效的授权标头，这个数量增加到了5,000。
- en: 'In the following example, you''ll make one more call than the rate limit allows
    (60 + 1 = 61). That way, you will get user information 61 times. For that to happen,
    you will also make sure that the `CacheControl` header is set to `NoCache` because
    you don''t want a request to be ignored after 60 consecutive calls:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，您将进行比速率限制允许的调用次数多一次的调用（60 + 1 = 61）。这样，您将获取用户信息61次。为了实现这一点，您还需要确保`CacheControl`标头设置为`NoCache`，因为您不希望在连续60次调用后被忽略：
- en: '[PRE27]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This block of code is an adaptation of the `GetUser` method from the *HttpClient*
    section. There are three main adjustments here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块是从*HttpClient*部分的`GetUser`方法进行了调整。这里有三个主要的调整：
- en: The first is that everything in a loop runs 61 times.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是循环中的所有内容运行了61次。
- en: You have also added an error handler, which means if a response is not a success,
    you will print an error message returned by the API.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还添加了一个错误处理程序，这意味着如果响应不成功，您将打印API返回的错误消息。
- en: Lastly, you add a `CacheControl` header to ignore caching (because you do want
    61 calls to the server).
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您添加了一个`CacheControl`标头来忽略缓存（因为您不希望服务器忽略61次调用）。
- en: 'Running this code results in an error message on the sixty-first call, which
    proves the API rate limitation (the error message has been truncated for clarity):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会导致在第61次调用时出现错误消息，这证明了API的速率限制（出于清晰起见，错误消息已被截断）：
- en: '[PRE28]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To fix this, you will need to add an `Authorization` header (you will add it
    just under the `CacheControl` header):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您需要添加一个`Authorization`标头（您将在`CacheControl`标头下面添加它）：
- en: '[PRE29]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Due to GitHub's limitations on anonymous calls (for example, the fact that you
    can make only 60 requests per hour to get user profile information), you will
    find it more efficient to provide an Authorization header so that you are identified
    and therefore released from such strict constraints. In the examples that follow,
    you will get an authorization token that you will feed to this method, thus showing
    how authorization will help you overcome the rate limit.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GitHub对匿名调用的限制（例如，您每小时只能发出60个请求以获取用户配置文件信息），因此最好提供授权标头，以便您被识别，从而摆脱这些严格的限制。在接下来的示例中，您将获得一个授权令牌，然后将其提供给这个方法，从而展示授权如何帮助您克服速率限制。
- en: When running the demo code placed at [https://packt.link/Uz2BL](https://packt.link/Uz2BL),
    it is recommended that you run one example at a time (i.e., uncomment one line
    and comment the rest within the `Run` method). This is because the `Demo.cs` file
    is a mix of authorized and anonymous calls, and you might get unexpected results.
    However, keep the line where you get a token as it may be required by individual
    examples.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行放置在[https://packt.link/Uz2BL](https://packt.link/Uz2BL)的演示代码时，建议您一次运行一个示例（即取消注释一个行并在`Run`方法中注释其余部分）。这是因为`Demo.cs`文件是授权和匿名调用的混合体，您可能会得到意外的结果。但是，请保留获取令牌的行，因为个别示例可能需要它。
- en: At the end of this section, you should have grasped the logic behind the Authorization
    header and its three forms—basic, API key (or personal access token), and third-party
    authentication—and learned that, like the Azure Text Analytics client, the GitHub
    API uses an API key. Now you can move on to basic authentication.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结束时，您应该已经掌握了授权标头及其三种形式（基本、API密钥（或个人访问令牌）和第三方身份验证）背后的逻辑，并了解到，与Azure文本分析客户端一样，GitHub
    API使用API密钥。现在您可以继续进行基本身份验证。
- en: Basic Authentication
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: 'Basic authentication involves a username and password. The two are usually
    combined in a single string and encoded using the following format:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证涉及用户名和密码。这两者通常组合在一个字符串中，并使用以下格式进行编码：
- en: '[PRE30]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the code used to generate an authorization taken for basic authentication:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于生成基本身份验证授权令牌的代码：
- en: '[PRE31]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use a username and password to get a basic token. Then pass it to the `GetUser61Times`
    method:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户名和密码获取基本令牌。然后将其传递给`GetUser61Times`方法：
- en: '[PRE32]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Calling `GetUser61Times` no longer displays an error because the rate limitation
    is avoided by supplying an Authorization header.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`GetUser61Times`不再显示错误，因为通过提供授权标头避免了速率限制。
- en: Note
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/Uz2BL](https://packt.link/Uz2BL)
    and [https://packt.link/UPxmW](https://packt.link/UPxmW).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/Uz2BL](https://packt.link/Uz2BL)和[https://packt.link/UPxmW](https://packt.link/UPxmW)找到此示例使用的代码。
- en: The next section will cover the more specialized API key and personal access
    token, which are similar as they both grant access to otherwise protected data.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍更专业的API密钥和个人访问令牌，它们非常相似，因为它们都可以访问受保护的数据。
- en: API Key and Personal Access Token
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API密钥和个人访问令牌
- en: A personal access token is limited to personal data. However, an API key can
    be used for the whole API. Other than the scope of what can be accessed, the two
    have no difference in how they are used. You can add an API key or a personal
    access token to an Authorization header as is.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 个人访问令牌仅限于个人数据。但是，API密钥可以用于整个API。除了可以访问的范围之外，它们在使用方式上没有区别。您可以将API密钥或个人访问令牌添加到授权标头中。
- en: 'But, of course, to use an access token of a certain API, you first need to
    create it. You can do this through the following steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当然，要使用特定API的访问令牌，您首先需要创建它。您可以通过以下步骤完成：
- en: Go to GitHub's `Developer settings` option under `Settings` window.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到GitHub的“设置”窗口下的“开发人员设置”选项。
- en: Navigate to `Personal access tokens` (`1`).
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“个人访问令牌”（`1`）。
- en: 'Select `Generate new token` button (`2`):'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“生成新令牌”按钮（`2`）：
- en: '![Figure 8.17: Creating a new personal access token'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：创建新的个人访问令牌'
- en: '](img/B16835_08_17.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_17.jpg)'
- en: 'Figure 8.17: Creating a new personal access token'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：创建新的个人访问令牌
- en: Next, enter your GitHub password.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入您的GitHub密码。
- en: Add a note (this can be anything) and scroll down. This screen will help you
    to modify user data, so check the `user` checkbox (`4`) to get access to it.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个注释（可以是任何内容）并向下滚动。此屏幕将帮助您修改用户数据，因此勾选“用户”复选框（`4`）以获取访问权限。
- en: 'Click the `Generate token` button (`5`):'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“生成令牌”按钮（`5`）：
- en: '![Figure 8.18: Scope of access configured for a personal access token'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18：为个人访问令牌配置的访问范围'
- en: '](img/B16835_08_18.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_18.jpg)'
- en: 'Figure 8.18: Scope of access configured for a personal access token'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：为个人访问令牌配置的访问范围
- en: 'In the new window, you will see all the personal access tokens, along with
    the newly added ones:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在新窗口中，您将看到所有个人访问令牌，以及新添加的令牌：
- en: '![Figure 8.19: A new personal access token created on GitHub'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19：在GitHub上创建的新个人访问令牌'
- en: '](img/B16835_08_19.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_19.jpg)'
- en: 'Figure 8.19: A new personal access token created on GitHub'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：在GitHub上创建的新个人访问令牌
- en: Note
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you will see the value of a token only once. So, make sure you
    copy and store it securely. Also, be aware that the personal access token expires
    after a month, at which point you need to regenerate it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您只能看到令牌的值一次。因此，请确保您安全地复制和存储它。另外，请注意，个人访问令牌在一个月后会过期，届时您需要重新生成它。
- en: Create an environmental variable called `GitHubPersonalAccess`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GitHubPersonalAccess`的环境变量。
- en: 'Add the personal access token to `Demo.cs`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将个人访问令牌添加到`Demo.cs`：
- en: '[PRE33]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the following code:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE34]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You will observe that calling the `GetUser61Times` method does not fail.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到调用`GetUser61Times`方法不会失败。
- en: Access tokens, authorization tokens, API keys, and JWTs (which will be further
    covered in the following sections) are different means to prove to an API that
    you have been granted access to it and have rights to a resource you want. But
    regardless of which specific kind of authorization you use, they will usually
    all go to the same place—that is, the Authorization header.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌、授权令牌、API密钥和JWT（将在以下部分进一步介绍）是证明您已被授予对API的访问权限并拥有您想要的资源的不同手段。但无论您使用哪种特定类型的授权，它们通常都会到达同一个地方——即Authorization标头。
- en: The next section will detail an authorization protocol called OAuth2.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将详细介绍一个名为OAuth2的授权协议。
- en: Third-Party Authentication—OAuth2
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方认证——OAuth2
- en: GitHub is an example of an authorization server. It allows access to a resource
    or functionality in the name of the owner. For example, updating the user's employment
    status is only available to a logged-in user. However, this can be done directly
    given the user has been granted the access to do so. A program getting access
    on behalf of someone is what OAuth2 is all about.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub是授权服务器的一个示例。它允许以所有者的名义访问资源或功能。例如，只有登录用户才能更新用户的就业状态。但是，只要用户已被授予执行此操作的访问权限，这就可以直接完成。代表某人获取访问权限是OAuth2的核心。
- en: 'Perform the following steps to modify the user''s employment status:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来修改用户的就业状态：
- en: 'Navigate to this URL or send an HTTP `GET` request:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到此URL或发送HTTP `GET`请求：
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `{{ClientId}}` and `{{RedirectUrl}}` are the values that you have set
    in the OAuth2 GitHub app.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`{{ClientId}}`和`{{RedirectUrl}}`是您在OAuth2 GitHub应用程序中设置的值。
- en: Note
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Replace the placeholders `{{ClientId}}` and `{{RedirectUrl}}` with the ones
    from your GitHub OAuth app.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 用您的GitHub OAuth应用程序中的值替换占位符`{{ClientId}}`和`{{RedirectUrl}}`。
- en: 'The following screen prompts you to log in to your GitHub app:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕提示您登录到您的GitHub应用程序：
- en: '![Figure 8.20: Signing in to OAuth2 GitHub app'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20：登录到OAuth2 GitHub应用程序'
- en: '](img/B16835_08_20.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_20.jpg)'
- en: 'Figure 8.20: Signing in to OAuth2 GitHub app'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：登录到OAuth2 GitHub应用程序
- en: Complete `Username` and `Password`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`用户名`和`密码`。
- en: Next, click the `Sign in` button to log in.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击`登录`按钮登录。
- en: After a successful login, you will be redirected to a URL specified in your
    OAuth2 app.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，您将被重定向到OAuth2应用程序中指定的URL。
- en: 'Create a request for the token by sending an HTTP `POST` request to a URI in
    the following format:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向以下格式的URI发送HTTP `POST`请求来为令牌创建请求：
- en: '[PRE36]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code for it is as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 其代码如下：
- en: '[PRE37]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this case, the redirect URL was [https://www.google.com](https://www.google.com).
    The URI you ended up with was [https://www.google.com/?code=a681b5126b4d0ba160ba](https://www.google.com/?code=a681b5126b4d0ba160ba).
    The `code=` part is the code needed to get the `OAuth` access token. The token
    is returned in the following format:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重定向URL是[https://www.google.com](https://www.google.com)。您最终得到的URI是[https://www.google.com/?code=a681b5126b4d0ba160ba](https://www.google.com/?code=a681b5126b4d0ba160ba)。`code=`部分是获取`OAuth`访问令牌所需的代码。令牌以以下格式返回：
- en: '[PRE38]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before this token can be used, you need to parse it from the response. So,
    create a function to parse the token response:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此令牌可以使用之前，您需要从响应中解析它。因此，创建一个函数来解析令牌响应：
- en: '[PRE39]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This takes every `=` property and puts it into a dictionary. The string before
    `=` is a key and the string after `=` is a value.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这将每个`=`属性放入字典中。`=`之前的字符串是键，`=`之后的字符串是值。
- en: 'Use the `GetToken` function to create and send a request and parse a response,
    then format the token and return it:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetToken`函数创建并发送请求并解析响应，然后格式化令牌并返回它：
- en: '[PRE40]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, you created a request, sent it to a client, parsed the response as a
    token, and then returned it. `ValidateNoError` is commented out for now. You will
    come back to it later. The returned token should look something like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个请求，将其发送给客户端，将响应解析为令牌，然后返回。`ValidateNoError`现在被注释掉了。您稍后会回来处理它。返回的令牌应该看起来像这样：
- en: '[PRE41]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This token is a bearer token, which is a token generated by an authorization
    server (in this case, GitHub) that grants access to GitHub on behalf of you (or
    any other username used for logging in to GitHub). You can use it to send requests
    that require special access. For example, update the employment status of a user.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此令牌是一个持有者令牌，是由授权服务器（在本例中是GitHub）生成的，代表您（或用于登录GitHub的任何其他用户名）授予对GitHub的访问权限。您可以使用它发送需要特殊访问权限的请求。例如，更新用户的就业状态。
- en: 'To update the employment status of a user, use the `UpdateEmploymentStatus`
    function:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新用户的就业状态，使用`UpdateEmploymentStatus`函数：
- en: '[PRE42]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This block of code sets the user's property `isHireable` to `true` and prints
    the updated user information. The important part here is content; when sending
    `PUT`, `PATCH`, or a `POST` request, you often need a body with a request (or
    content in other words).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块将用户的属性`isHireable`设置为`true`并打印更新后的用户信息。这里重要的部分是内容；当发送`PUT`、`PATCH`或`POST`请求时，通常需要一个请求体（或者换句话说，内容）。
- en: The act of converting an in-memory object into structured text (for example,
    JSON) is called serialization. In this case, a body is a user update. You send
    a `PATCH` request because you only want to change the updated values. If a value
    is not provided in the content, it should not change. That's the key difference
    between a `PATCH` and `POST` request—a successful request overrides all values
    (even if you don't provide them).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存中的对象转换为结构化文本（例如JSON）的行为称为序列化。在这种情况下，body是用户更新。您发送一个`PATCH`请求，因为您只想更改更新的值。如果内容中没有提供值，它就不应该改变。这是`PATCH`和`POST`请求之间的关键区别——成功的请求会覆盖所有值（即使您没有提供它们）。
- en: You used `new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore
    }` in order to avoid providing `null` values. This is because you do not want
    to update all the fields; just the ones you have supplied.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用了`new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore
    }`来避免提供`null`值。这是因为您不想更新所有字段，只想更新您提供的字段。
- en: 'When creating HTTP content, you also need to supply a MIME type (a type of
    media sent over with the request). It is needed so that the server has a hint
    for how it is expected to process the request. A MIME type follows this format:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建HTTP内容时，您还需要提供一个MIME类型（一种随请求发送的媒体类型）。这是必需的，以便服务器有一个提示，表明它应该如何处理请求。MIME类型遵循这种格式：
- en: '[PRE43]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, `application/json` means that the client should expect JSON from
    a server. `application` is the most common MIME type, which means binary data.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`application/json`表示客户端应该从服务器期望JSON。`application`是最常见的MIME类型，表示二进制数据。
- en: There is also `StringContent`, which is a type of serialized content, usually
    as JSON or XML. Alternatively, you could use `StreamContent` or `ByteContent`,
    but those are slightly rarer and are used when performance or the volume of data
    is of concern.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`StringContent`，它是一种序列化内容的类型，通常是JSON或XML。或者，您可以使用`StreamContent`或`ByteContent`，但这些类型稍微罕见，通常在性能或数据量成为关注点时使用。
- en: 'The following code shows the full demo:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了完整的演示：
- en: '[PRE44]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `GetToken` method (used in *Step 6* of the *Third-Party Authentication
    (OAuth2)* section), there was one commented line of code, `ValidateNoError`. Uncomment
    it and implement the `GetToken` method, because you won''t always get a successful
    response, and parsing a token in that case will fail (i.e., it won''t exist).
    Therefore, it is always a good idea to validate the server response and throw
    an exception when the unexpected happens. Look at the following GitHub error format:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetToken`方法（在*第三方身份验证（OAuth2）*部分的*步骤6*中使用）中，有一行被注释掉的代码`ValidateNoError`。取消注释并实现`GetToken`方法，因为您不总是会得到成功的响应，而在这种情况下解析令牌将失败（即，它不存在）。因此，验证服务器响应并在发生意外情况时抛出异常总是一个好主意。看一下以下GitHub错误格式：
- en: '[PRE45]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It is not very readable. `ValidateNoError` will format the response and throw
    that as an exception, instead of letting it fail silently:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这不太可读。`ValidateNoError`将格式化响应并将其作为异常抛出，而不是让它悄悄失败：
- en: '[PRE46]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you run the code again and it fails for the same reasons, the error message
    will now read as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次运行代码并且出现相同的原因失败，错误消息现在将如下所示：
- en: '[PRE47]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This section covered the basics of how to send HTTP requests with some sort
    of security in place. In the sections that follow (*Restsharp* and *Refit*), you
    will create clients using third-party libraries to remove some of the boilerplate
    code required by `HttpClient`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何在发送带有某种安全性的HTTP请求的基础知识。在接下来的章节（*Restsharp*和*Refit*）中，您将使用第三方库创建客户端，以消除`HttpClient`所需的一些样板代码。
- en: Note
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/UPxmW](https://packt.link/UPxmW).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/UPxmW](https://packt.link/UPxmW)找到此示例使用的代码。
- en: Request Idempotency
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求幂等性
- en: An idempotent HTTP request is a request that always results in the same outcome.
    Only `GET`, `PUT`, and `PATCH` requests are idempotent because they either make
    no change or make the same change all over again, but that change does not ever
    cause an error and results in the same data. `DELETE` is not idempotent because
    deleting an already deleted item will produce an error. `POST` may or may not
    be idempotent, but that solely depends on the implementation.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等的HTTP请求是一种总是产生相同结果的请求。只有`GET`、`PUT`和`PATCH`请求是幂等的，因为它们要么不做任何更改，要么再次做相同的更改，但该更改永远不会导致错误并且产生相同的数据。`DELETE`不是幂等的，因为删除已经删除的项目将产生错误。`POST`可能是幂等的，但这完全取决于实现。
- en: PUT, PATCH, or POST
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PUT、PATCH或POST
- en: 'The difference between `PUT`, `PATCH`, and `POST` can be summed up as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`、`PATCH`和`POST`之间的区别可以总结如下：'
- en: '`PUT` is used for overriding fields in a model. Even if a single value is explicitly
    provided, the whole model will have the unprovided values (or at least that''s
    the expectation). For example, if you wanted to update user details by first getting
    the old details and then sending a modified version, you would use `PUT`.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`用于覆盖模型中的字段。即使提供了单个值，整个模型也将具有未提供的值（或者至少是期望如此）。例如，如果您想要通过首先获取旧详细信息然后发送修改后的版本来更新用户详细信息，您将使用`PUT`。'
- en: '`PATCH` is used for updating only a single value that was provided explicitly.
    For example, if you wanted to update a username, it would make sense to send `PATCH`
    over a `PUT` request.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`用于仅更新显式提供的单个值。例如，如果您想要更新用户名，发送`PATCH`请求而不是`PUT`请求是有意义的。'
- en: '`POST` is used for creating items or sending a complex query. Either way, the
    default expectation of this verb is to have side effects. For example, if you
    wanted to create a user, you would use a `POST` request.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`用于创建项目或发送复杂查询。无论哪种方式，此动词的默认期望是具有副作用。例如，如果您想要创建一个用户，您将使用`POST`请求。'
- en: 'Exercise 8.02: HttpClient Calling a Star Wars Web API'
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.02：使用HttpClient调用星球大战Web API
- en: You might be familiar with Star Wars. There are movies, games, and TV series.
    However, did you know that it also has multiple APIs to retrieve data? The upcoming
    exercise will introduce you to a different format of an API and will make you
    familiar with deserializing slightly more complex responses.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉星球大战。有电影、游戏和电视系列。但是，你知道它也有多个API来检索数据吗？即将进行的练习将向你介绍API的不同格式，并让你熟悉反序列化稍微复杂的响应。
- en: 'In this exercise, you will create a strongly typed API client that will, under
    the hood, use `HttpClient`. The client will be used to return Star Wars movies.
    You will be using Star Wars API (SWAPI) ([https://swapi.dev/](https://swapi.dev/)).
    The required endpoint is [https://swapi.dev/api/films/](https://swapi.dev/api/films/).
    Perform the following steps to complete this exercise:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个强类型的API客户端，它将在幕后使用`HttpClient`。客户端将用于返回星球大战电影。您将使用星球大战API（SWAPI）（[https://swapi.dev/](https://swapi.dev/)）。所需的端点是[https://swapi.dev/api/films/](https://swapi.dev/api/films/)。执行以下步骤来完成这个练习：
- en: 'Create a new class to hold `HttpClient` with a base URL:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类来保存带有基本URL的`HttpClient`：
- en: '[PRE48]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will act as a strongly typed API client.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为一个强类型的API客户端。
- en: Note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `/` at the end of the URI indicates that more text will be appended to the
    URI (after `api` rather than after `dev`).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: URI末尾的`/`表示URI将被附加更多文本（在`api`之后而不是在`dev`之后）。
- en: 'Create a type for representing a movie:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于表示电影的类型：
- en: '[PRE49]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is a class you will use for deserializing movies within a response. The
    `ReleaseDate` property has `[JsonProperty("release_date")]` above it to specify
    that the `"release_date"` JSON field will map to the `ReleaseDate` C# property.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于在响应中反序列化电影的类。`ReleaseDate`属性的上方有`[JsonProperty("release_date")]`，以指定`"release_date"`
    JSON字段将映射到`ReleaseDate` C#属性。
- en: 'Create a type for storing results:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于存储结果的类型：
- en: '[PRE51]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is also a type for deserializing a movie response; however, the Star Wars
    API returns results in paginated format. It contains `Previous` and `Next` properties
    pointing to previous and next pages. For example, if you don't provide the page
    you want, it will return a value of `null`. However, the next property will point
    to the next page only if there are any elements left (otherwise it will also be
    `null`). Querying the API using next or previous as a URI will return the resources
    of that page. You used the `JsonProperty` attribute above `T Data` to provide
    JSON-to-property mapping because the property and JSON names do not match (the
    JSON field name is `results` while `Data` is the property name).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一种用于反序列化电影响应的类型；但是，星球大战API以分页格式返回结果。它包含指向上一页和下一页的`Previous`和`Next`属性。例如，如果您没有提供要获取的页面，它将返回一个`null`值。但是，如果还有剩余元素，下一个属性将指向下一页（否则它也将是`null`）。使用下一个或上一个作为URI查询API将返回该页面的资源。您在`T
    Data`上方使用`JsonProperty`属性来提供JSON到属性的映射，因为属性和JSON名称不匹配（JSON字段名为`results`，而`Data`是属性名）。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You could have changed `ApiResult` to have the `Results` property instead of
    `Data`. However, `ApiResult.Results` is a bit confusing. When writing code, instead
    of ease of automation (in this case, serialization), choose ease of maintainability
    and readability. For this reason, the name chosen in *Step 3* is different but
    clearer.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`ApiResult`更改为具有`Results`属性而不是`Data`。但是，`ApiResult.Results`有点令人困惑。在编写代码时，选择易于维护和可读性而不是自动化的便利性（在这种情况下是序列化）。因此，*步骤3*中选择的名称不同但更清晰。
- en: 'Now, create a method to get multiple films:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个获取多部电影的方法：
- en: '[PRE52]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You've returned a task so that others can await this method. Almost all HTTP
    calls will be `async Task`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您返回了一个任务，以便其他人可以等待此方法。几乎所有的HTTP调用都将是`async Task`。
- en: 'Create an HTTP request to get all movies:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTTP请求以获取所有电影：
- en: '[PRE53]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The URI is relative because you're calling it from `HttpClient` that already
    has a base URI set.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: URI是相对的，因为您是从已经设置了基本URI的`HttpClient`中调用它。
- en: 'To query the Star Wars API for movies, send this request:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查询星球大战API的电影，请发送此请求：
- en: '[PRE54]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It returns `HttpResponseMessage`. There are two important parts to this: status
    code and response body. C# has a method to determine whether there were any errors
    based on the status code. To handle errors, use the following code:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它返回`HttpResponseMessage`。这有两个重要部分：状态码和响应体。C#有一个方法可以根据状态码确定是否有任何错误。要处理错误，请使用以下代码：
- en: '[PRE55]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Error handling is important because a failed HTTP request will often result
    in an error status code rather than an exception. It's recommended you do something
    similar before trying to deserialize the response body as, if it fails, you might
    get an unexpected body.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理很重要，因为失败的HTTP请求通常会导致错误状态码而不是异常。建议在尝试反序列化响应体之前执行类似的操作，因为如果失败，您可能会得到一个意外的响应体。
- en: 'Now, call the `ReadAsStringAsync` method:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用`ReadAsStringAsync`方法：
- en: '[PRE56]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The response has content that is more likely to be a kind of stream. To convert
    `HttpContent` to a string, call the `ReadAsStringAsync` method. This returns a
    string (JSON), which allows you to convert JSON to a C# object and deserialize
    the results. Lastly, you get the results by deserializing the response content
    body and converting it all to `ApiResult<Film>`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的内容更可能是一种流的形式。要将`HttpContent`转换为字符串，请调用`ReadAsStringAsync`方法。这将返回一个字符串（JSON），允许您将JSON转换为C#对象并反序列化结果。最后，通过反序列化响应内容体并将其全部转换为`ApiResult<Film>`来获取结果。
- en: 'For a demo, create the client and use it to get all the Star Wars films, then
    print them:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示，创建客户端并使用它获取所有星球大战电影，然后打印它们：
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If everything is fine, you should see the following result:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该看到以下结果：
- en: '[PRE58]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This exercise illustrates how to create strongly typed HTTP clients for simplicity.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习说明了如何创建强类型的HTTP客户端以简化操作。
- en: Note
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/2CHpb](https://packt.link/2CHpb).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/2CHpb](https://packt.link/2CHpb)找到此练习中使用的代码。
- en: You might have noticed that sending an HTTP request and using an HTTP client
    is very similar to the way a simple text file is sent to the GitHub API. Even
    if it was different, endpoints throughout the same API usually share the same
    requirements. However, if you manually craft an HTTP request every time you need
    to call an API, you are not being very efficient. A better way is to create something
    reusable. A common approach is to create `BaseHttpClient`. You will put this into
    practice in the following activity.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，发送HTTP请求并使用HTTP客户端与将简单文本文件发送到GitHub API的方式非常相似。即使它不同，同一API中的端点通常共享相同的要求。但是，如果您每次需要调用API时手动创建HTTP请求，那么效率并不高。更好的方法是创建可重用的东西。一个常见的方法是创建`BaseHttpClient`。您将在接下来的活动中实践这一点。
- en: 'Activity 8.01: Reusing HttpClient for the Rapid Creation of API Clients'
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：重用HttpClient快速创建API客户端
- en: 'The problem with `HttpClient` is that you still have to manage many things
    by yourself:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`的问题在于您仍然必须自己管理许多事情：'
- en: Error handling
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Serializing and deserializing
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化和反序列化
- en: Mandatory headers
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制头
- en: Authorization
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: When working in a team or on a bigger project, you are likely to be making more
    than just one HTTP call. The consistency and same requirements between different
    calls need to be managed.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队中工作或在一个更大的项目上工作时，您可能会进行多个HTTP调用。不同调用之间的一致性和相同要求需要进行管理。
- en: The aim of this activity is to show one of many ways you can simplify working
    with repetitive HTTP calls. You will be using the `BaseHttpClient` class, which
    you will create first. The class will generalize error handling and deserializing
    responses and requests, which will significantly simplify different HTTP calls
    that you make. Here, you will learn how to implement a base client by rewriting
    `StarWarsClient` using `BaseHttpClient`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的目的是展示简化重复HTTP调用的许多方法之一。您将使用首先创建的`BaseHttpClient`类。该类将概括错误处理和反序列化响应和请求，这将大大简化您进行的不同HTTP调用。在这里，您将学习如何通过重写`StarWarsClient`使用`BaseHttpClient`来实现基本客户端。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Create a base `HttpClient` class. A base client wraps `HttpClient`. Therefore,
    you will hold a private reference to it and allow it to be created from a URL.
    The inner `HttpClient` often also includes base headers, but they are not required
    in this case.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本的`HttpClient`类。基本客户端包装`HttpClient`。因此，您将持有对它的私有引用，并允许从URL创建它。内部的`HttpClient`通常还包括基本标头，但在这种情况下并不是必需的。
- en: Define a way to create requests for every method. For brevity, stick to a `GET`
    request. Within a `GET` request, it is a common practice to define the default
    headers, but once again, it is not mandatory in this example.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一种为每种方法创建请求的方式。为简洁起见，坚持使用`GET`请求。在`GET`请求中，定义默认标头是一种常见做法，但在本例中并不是强制性的。
- en: Create a method to send requests and include error handling and deserialization.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来发送请求并包括错误处理和反序列化。
- en: In SWAPI, if you are querying multiple results, you get back `ApiResult<IEnumerable<T>>`
    for pagination. Create a `SendGetManyRequest` method.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SWAPI中，如果您查询多个结果，您将获得用于分页的`ApiResult<IEnumerable<T>>`。创建一个`SendGetManyRequest`方法。
- en: Use the base client you have created and simplify the client from *Exercise
    8.02*.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您创建的基本客户端简化*Exercise 8.02*中的客户端。
- en: Run the code through the same demo code but using the new version of `StarWarsClient`.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过相同的演示代码运行代码，但使用新版本的`StarWarsClient`。
- en: 'If you run the demo once again with the new `StarWarsClient`, you should see
    the same films returned:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用新的`StarWarsClient`再次运行演示，您应该会看到相同的电影返回：
- en: '[PRE59]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In order to run this activity, go to [https://packt.link/GR27A](https://packt.link/GR27A)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `await Activities.Activity01.Demo.Run();`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此活动，请转到[https://packt.link/GR27A](https://packt.link/GR27A)，并在`static void`
    `Main(string[] args)`主体中注释所有行，除了`await Activities.Activity01.Demo.Run();`。
- en: Note
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到此活动的解决方案。
- en: 'Reusing `HttpClient` like that is very useful because it removes code duplication.
    However, calling a Web API and removing duplicate code is a common problem and
    is likely to be solved in some way by some libraries. The following section will
    explore how to simplify calls to a Web API using two popular NuGet packages:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样重用`HttpClient`非常有用，因为它消除了代码重复。但是，调用Web API并消除重复代码是一个常见的问题，很可能会以某种方式由某些库解决。接下来的部分将探讨如何使用两个流行的NuGet包简化对Web
    API的调用：
- en: RestSharp
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RestSharp
- en: Refit
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Refit
- en: RestSharp
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RestSharp
- en: 'The idea behind RestSharp is very similar to the base `HttpClient`—reducing
    code duplicity. It simplifies the creation of a request and provides a lot of
    the utility for making HTTP calls. Redo `StarWarsClient` using `RestSharp`, but
    first, you''ll install the `RestSharp` NuGet:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: RestSharp的思想与基本`HttpClient`非常相似——减少代码重复。它简化了请求的创建，并提供了许多实用程序来进行HTTP调用。使用`RestSharp`重新编写`StarWarsClient`，但首先，您需要安装`RestSharp`
    NuGet：
- en: '[PRE60]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now create a client that is very similar to the one you created in *Activity
    8.01*:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个与*Activity 8.01*中创建的非常相似的客户端：
- en: '[PRE61]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Having `RestSharp` created gives you a response serialization out of the box.
    It is also able to guess which HTTP method you will use:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`RestSharp`后，您可以立即获得响应序列化。它还能够猜测您将使用哪种HTTP方法：
- en: '[PRE62]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You passed the minimum required information to make an HTTP request (calling
    films, returning `ApiResult<IEnumerable<Film>>`) and the rest is done. This is
    very much like the base client you wrote previously.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 您传递了进行HTTP请求所需的最低信息（调用电影，返回`ApiResult<IEnumerable<Film>>`），其余工作已完成。这与您之前编写的基本客户端非常相似。
- en: Note
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ApiResult` is the same type used in *Exercise 8.02*.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiResult`是*Exercise 8.02*中使用的相同类型。'
- en: 'However, if you run this code against your demo, you will notice that the `Data`
    property (on JSON) comes back as `null`. This is because you had a `JsonProperty`
    attribute on the `response` and `film` classes. RestSharp uses a different serializer,
    which does not know about those attributes. To make it work, you could either
    change all the attributes to what RestSharp comprehends or use the same serializer
    as before. You are using `Newtonsoft.Json` and, in order to use that in RestSharp,
    you need to call the `UseSerializer` method, selecting `JsonNetSerializer`:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您对您的演示运行此代码，您会注意到`Data`属性（在JSON上）返回为`null`。这是因为在`response`和`film`类上有一个`JsonProperty`属性。RestSharp使用不同的序列化程序，不知道这些属性。要使其工作，您可以将所有属性更改为RestSharp理解的属性，或者使用与之前相同的序列化程序。您正在使用`Newtonsoft.Json`，为了在RestSharp中使用它，您需要调用`UseSerializer`方法，选择`JsonNetSerializer`：
- en: '[PRE63]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'On running the demo, the following output gets displayed:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 运行演示后，将显示以下输出：
- en: '[PRE64]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The results are the same as those in *Exercise 8.02*; however, the difference
    is using the `Newtonsoft` serializer in the preceding example. `RestSharp` is
    probably the best abstraction for `HttpClient` as it minimizes the amount of code
    you need to write to make HTTP calls even while keeping its similarities with
    `HttpClient`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与*练习8.02*中的结果相同；然而，不同之处在于在前面的示例中使用了`Newtonsoft`序列化程序。`RestSharp`可能是`HttpClient`的最佳抽象，因为它最大程度地减少了您需要编写的代码量，同时保持与`HttpClient`的相似之处。
- en: Note
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/f5vVG](https://packt.link/f5vVG).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/f5vVG](https://packt.link/f5vVG)找到此示例使用的代码。
- en: The example aims to communicate with Web APIs using HTTP requests. Even though
    the demo files look the same, they are using either a different library or design
    pattern. In the following activity, you will practice consuming more APIs using RestSharp.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例旨在使用HTTP请求与Web API进行通信。尽管演示文件看起来相同，但它们使用的是不同的库或设计模式。在接下来的活动中，您将练习使用RestSharp来消耗更多的API。
- en: 'Activity 8.02: The Countries API Using RestSharp to List all Countries'
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.02：使用RestSharp列出所有国家的国家API
- en: The address [https://restcountries.com/v3/](https://restcountries.com/v3/) is
    a public web API that provides a list of all existing countries. Suppose that
    using that API, you need to get a list of all countries, find a country by its
    capital city (for example, Vilnius), and find all the countries that speak in
    a given language (for example, Lithuanian). You need to print only the first two
    country names, their regions, and their capitals, and implement a strongly typed
    client to access this API using `RestSharp`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 地址[https://restcountries.com/v3/](https://restcountries.com/v3/)是一个公共Web API，提供了所有现有国家的列表。假设使用该API，您需要获取所有国家的列表，按其首都城市（例如Vilnius）查找国家，并找到所有使用特定语言（例如立陶宛语）的国家。您只需要打印前两个国家的名称、地区和首都，并实现一个强类型的客户端来访问此API，使用`RestSharp`。
- en: The aim of this activity is to make you feel more comfortable using third-party
    libraries (`RestSharp`) when making HTTP calls. Using third-party libraries often
    saves a lot of time. It allows you to reuse something that is already available.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的目的是让您在进行HTTP调用时更加舒适地使用第三方库（`RestSharp`）。使用第三方库通常可以节省大量时间。它允许您重用已经可用的东西。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Create a base client class using the URL [https://restcountries.com/v3/](https://restcountries.com/v3/).
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用URL[https://restcountries.com/v3/](https://restcountries.com/v3/)创建一个基本客户端类。
- en: Note
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Navigating to [https://restcountries.com/v3/](https://restcountries.com/v3/)
    will return the HTTP status code `404` with a `Page Not Found` message. This is
    because the base API URI doesn't contain any information on a resource; it is
    yet to be completed and is just the beginning of a full URI for a resource.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到[https://restcountries.com/v3/](https://restcountries.com/v3/)将返回HTTP状态码`404`和`Page
    Not Found`消息。这是因为基本API URI不包含有关资源的任何信息；它尚未完成，只是资源的完整URI的开始。
- en: Create models for serialization.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于序列化的模型。
- en: Use the example [https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)
    to get a response.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用示例[https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)来获取响应。
- en: Copy the response and then use a class generator, such as [https://json2csharp.com/](https://json2csharp.com/),
    to make models out of JSON (response).
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制响应，然后使用类生成器，例如[https://json2csharp.com/](https://json2csharp.com/)，将JSON（响应）转换为模型。
- en: 'Within the client, create the following methods: `Get`, `GetByCapital`, and
    `GetByLanguage`.'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端内创建以下方法：`Get`，`GetByCapital`和`GetByLanguage`。
- en: Create a demo calling all three methods.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个调用所有三种方法的演示。
- en: Print the countries within each response.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印每个响应中的国家。
- en: 'The result should be as follows:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该如下：
- en: '[PRE65]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到此活动的解决方案。
- en: You now know that RestSharp simplifies the creation of a request and provides
    a lot of the utilities for making HTTP calls. The next section will help you practice
    using Refit, which is another way to consume an API.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道RestSharp简化了请求的创建，并提供了大量用于进行HTTP调用的实用程序。接下来的部分将帮助您练习使用Refit，这是另一种消耗API的方式。
- en: Refit
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Refit
- en: 'Refit is the smartest client abstraction because it generates a client from
    an interface. All you have to do is provide an abstraction:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: Refit是最聪明的客户端抽象，因为它从接口生成客户端。您只需提供一个抽象：
- en: 'To use the `Refit` library, first install the `Refit` NuGet:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`Refit`库，首先安装`Refit` NuGet：
- en: '[PRE66]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To create a client in Refit, first create an interface with HTTP methods:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Refit中创建客户端，首先创建一个带有HTTP方法的接口：
- en: '[PRE67]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Please note that the endpoint here is `/films` rather than `films`. If you run
    the code with `films`, you will get an exception suggesting that you change the
    endpoint with a preceding `/`.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此处的端点是`/films`而不是`films`。如果您使用`films`运行代码，将会收到一个异常，建议您使用前导`/`更改端点。
- en: 'To resolve the client, simply run the following code:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解析客户端，只需运行以下代码：
- en: '[PRE68]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'On running the demo, the following output gets displayed:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 运行演示后，将显示以下输出：
- en: '[PRE69]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The results are the same as the ones you saw in *Exercise 8.02*; however, the difference
    is in the implementation.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与*练习8.02*中看到的结果相同；然而，不同之处在于实现。
- en: Note
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/cqkH5](https://packt.link/cqkH5).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/cqkH5](https://packt.link/cqkH5)找到此示例使用的代码。
- en: Use Refit only when your scenarios are trivial. Though Refit might seem like
    the easiest solution, it comes with its own complications when you need custom
    authorization for more complex scenarios. You will simplify the solution further
    in the following activity.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您的场景很简单时才使用Refit。尽管Refit可能看起来是最简单的解决方案，但在需要更复杂的自定义授权时，它会带来自己的复杂性。您将在接下来的活动中进一步简化解决方案。
- en: 'Activity 8.03: The Countries API Using Refit to List all Countries'
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.03：使用Refit列出所有国家的国家API
- en: The more different ways you know of doing the same thing, the easier you can
    make a choice and pick the best tool for the job. Different teams may use different
    tools and Refit is quite a unique, minimalistic approach that you may encounter.
    Others may say it complicates work because there is too much hidden in the client
    interface (less code often does not mean that you can grasp the code easily).
    It doesn't matter whether you are for Refit or against it; it's good to have practiced
    things first-hand and formed your own opinion. This activity will help you do
    exactly that. Here, you will access the Countries API to display all countries,
    countries by their language, and by their capital city.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 您了解到的做同一件事的不同方式越多，您就越容易做出选择并选择最适合工作的最佳工具。不同的团队可能使用不同的工具，Refit是一种独特的、极简主义的方法，您可能会遇到。其他人可能会说它使工作复杂化，因为客户端接口中隐藏了太多内容（代码少并不意味着您可以轻松理解代码）。无论您是支持Refit还是反对它，最好先亲自练习并形成自己的观点。这项活动将帮助您做到这一点。在这里，您将访问Countries
    API以显示所有国家、按其语言和首都城市显示的国家。
- en: 'The aim of this activity is to show how practical Refit can be for rapid prototyping
    when it comes to consuming simple APIs. The steps for this are as follows:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这项活动的目的是展示在消费简单API时，Refit在快速原型设计中可以有多实用。其步骤如下：
- en: Create models for serialization. For that, use the example [https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)
    to get a response.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为序列化创建模型。为此，请使用示例[https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)获取响应。
- en: Now copy the response.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在复制响应。
- en: Then use a class generator, such as [https://json2csharp.com/](https://json2csharp.com/),
    to make models out of JSON (response).
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用类生成器，例如[https://json2csharp.com/](https://json2csharp.com/)，将JSON（响应）转换为模型。
- en: 'Define an interface with methods: `Get`, `GetByCapital`, and `GetByLanguage`.'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个带有方法的接口：`Get`，`GetByCapital`和`GetByLanguage`。
- en: Create a demo printing a country name, region, and country status.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个演示，打印国家名称、地区和国家状态。
- en: 'The result will be displayed as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将显示如下：
- en: '[PRE70]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: .NET has a few other native ways of creating HTTP requests, and for that, you
    can use `HttpWebRequest` or `WebClient`. The two are not deprecated and it is
    fine to use them, but they are older alternatives compared to the newer `HttpClient`.
    The next section covers all these.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: .NET还有其他几种本机创建HTTP请求的方式，你可以使用`HttpWebRequest`或`WebClient`。这两种方式并未被弃用，可以使用，但与较新的`HttpClient`相比，它们是较老的替代方案。下一节将涵盖所有这些内容。
- en: In the following section, you'll find out about other libraries that solve the
    problem of code duplication when using `HttpClient`.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，您将了解到解决使用`HttpClient`时代码重复问题的其他库。
- en: Other Ways of Making HTTP Requests
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他进行HTTP请求的方式
- en: Refit and RestSharp are just two of many libraries solving the problem of code
    duplication when using `HttpClient`. Flurl and TinyRest are another two popular
    alternatives. New libraries are created every year and they are ever evolving.
    There is no one best way that suits all scenarios. To be sure you make the right
    choice, you'll want to do a little research first as there are some pitfalls to
    these alternatives to consider.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: Refit和RestSharp只是解决使用`HttpClient`时代码重复问题的许多库中的两个。Flurl和TinyRest是另外两个流行的替代方案。每年都会创建新的库，它们不断发展。没有一种适合所有场景的最佳方式。为了确保您做出正确的选择，您需要先进行一些研究，因为这些替代方案有一些需要考虑的缺陷。
- en: '`HttpClient` was designed for the lowest-level HTTP calls in .NET. It is the
    safest option because it is well-documented, tested, and allows the most freedom.
    Though there are many libraries that are much simpler to use than `HttpClient`,
    they often target basic scenarios (no authorization, no dynamically set headers).
    When it comes to creating advanced HTTP calls, they often turn out to be quite
    complicated.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`是为.NET中最低级别的HTTP调用而设计的。这是最安全的选择，因为它有很好的文档记录，经过测试，并且允许最大的自由。虽然有许多库比`HttpClient`更简单易用，但它们通常针对基本场景（无授权，无动态设置标头）。当涉及创建高级HTTP调用时，它们往往变得相当复杂。'
- en: When it comes to choosing which client to use, first go for the one provided
    natively by the API. If there is no client for the API, think about the complexity
    and scope of your project. For simple, small-scope projects, use whatever NuGet
    `HttpClient` alternative you find the most convenient. But if the scope of a project
    is big and the calls are complex, use the native `HttpClient` offered by the framework.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要使用的客户端时，首先选择API本身提供的客户端。如果API没有提供客户端，请考虑项目的复杂性和范围。对于简单、小范围的项目，请使用您认为最方便的任何NuGet
    `HttpClient`替代方案。但是，如果项目的范围很大，调用很复杂，请使用框架提供的本机`HttpClient`。
- en: In the next exercise, you will implement an example where using Refit will turn
    it into a complication. To fix that complication, you will use both `HttpClient`
    and RestSharp.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将实现一个使用Refit会变得复杂的示例。为了解决这个复杂性，您将同时使用`HttpClient`和RestSharp。
- en: 'Exercise 8.03: A Strongly Typed HTTP Client for Testing Payments in a PayPal
    Sandbox'
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.03：在PayPal沙盒中测试付款的强类型HTTP客户端
- en: A common scenario in programming is making payments. However, during the development
    stage, you don't want to use a real bank account and thus look for ways to process
    payments in a test environment—that is, a sandbox. In this exercise, you will
    learn how to call a payments sandbox API. You will use PayPal's sandbox API ([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/))
    to create an order and get the order that you have created.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的常见场景是进行付款。然而，在开发阶段，您不希望使用真实的银行账户，因此寻找在测试环境中处理付款的方法——即沙盒。在这个练习中，您将学习如何调用支付沙盒API。您将使用PayPal的沙盒API([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/))来创建订单并获取您创建的订单。
- en: 'This exercise will use `Refit` for the client interface and the implementation
    resolution. It will also use `HttpClient` to provide a way of getting `auth` headers
    for Refit. Lastly, you will use RestSharp to get an access token from within `HttpClient`.
    Perform the following steps to complete this exercise:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习将使用`Refit`来创建客户端接口和实现分辨率。它还将使用`HttpClient`来提供获取`auth`头部的方法。最后，您将使用RestSharp从`HttpClient`中获取访问令牌。执行以下步骤完成此练习：
- en: Go to [https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection).
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection)。
- en: Create a PayPal account (either personal or business).
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个PayPal账户（个人或商业）。
- en: Choose your location and click the `Get Started` button.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的位置并点击“开始”按钮。
- en: Provide your mobile number.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供您的手机号码。
- en: Click the `Next` button and enter the code.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮并输入代码。
- en: Set up your profile by entering an email address and password.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入电子邮件地址和密码设置您的个人资料。
- en: Provide your address details.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供您的地址详细信息。
- en: Now link your credit or debit card. You can also do this for free by following
    the instructions given at [https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection).
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在链接您的信用卡或借记卡。您也可以免费按照[https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection)上的说明进行操作。
- en: Note
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Creating an account on PayPal is free. The linking of credit (or debit) card
    requirement is just a part of account creation, and it doesn't charge you. The
    payment gets refunded as soon as the authentication is confirmed.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在PayPal上创建账户是免费的。链接信用卡（或借记卡）的要求只是账户创建的一部分，并不会收费。一旦确认身份验证，付款将被退还。
- en: Now log out of the account and go to [https://developer.paypal.com/developer/accounts/](https://developer.paypal.com/developer/accounts/).
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在注销账户，然后转到[https://developer.paypal.com/developer/accounts/](https://developer.paypal.com/developer/accounts/)。
- en: 'Click the `Log in to Dashboard` button and proceed ahead:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“登录到仪表板”按钮并继续：
- en: '![Figure 8.21: Log in to the PayPal dashboard to manage both sandbox and live
    environments'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21：登录PayPal仪表板以管理沙箱和实时环境'
- en: '](img/B16835_08_21.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_21.jpg)'
- en: 'Figure 8.21: Log in to the PayPal dashboard to manage both sandbox and live
    environments'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：登录PayPal仪表板以管理沙箱和实时环境
- en: Then enter the requested credentials and proceed to the next screen.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后输入请求的凭据并继续下一步。
- en: 'Click the `Accounts` option under the `Sandbox` option. You will see two test
    accounts created for you:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Sandbox`选项下的`Accounts`选项。您将看到为您创建的两个测试账户：
- en: '![Figure 8.22: Sandbox PayPal accounts for testing'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22：用于测试的沙箱PayPal账户'
- en: '](img/B16835_08_22.jpg)'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_22.jpg)'
- en: 'Figure 8.22: Sandbox PayPal accounts for testing'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22：用于测试的沙箱PayPal账户
- en: You will use these accounts to do testing in the next steps.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用这些账户在接下来的步骤中进行测试。
- en: Note
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The PayPal sandbox is free.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: PayPal沙箱是免费的。
- en: Go to [https://developer.paypal.com/developer/applications](https://developer.paypal.com/developer/applications)
    to get your client ID and secret. Just like the GitHub example, PayPal uses an
    OAuth app to provide you with a client ID and a secret.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://developer.paypal.com/developer/applications](https://developer.paypal.com/developer/applications)获取您的客户端ID和秘钥。就像GitHub示例一样，PayPal使用OAuth应用程序为您提供客户端ID和秘钥。
- en: 'For one of the default accounts, PayPal also generates a default OAuth app.
    So, click the `Sandbox` tab and select `Default Application`:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个默认账户，PayPal还生成了一个默认的OAuth应用。因此，点击“沙箱”选项卡，然后选择“默认应用程序”：
- en: '![Figure 8.23: OAuth app creation for PayPal'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23：为PayPal创建OAuth应用'
- en: '](img/B16835_08_23.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_23.jpg)'
- en: 'Figure 8.23: OAuth app creation for PayPal'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23：为PayPal创建OAuth应用
- en: In the new window, inspect both `Client ID` and `Secret`.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，检查`Client ID`和`Secret`。
- en: 'Take note of both and store them in environmental variables:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意这两点，并将它们存储在环境变量中：
- en: '![Figure 8.24: Default application details displaying Client ID and Secret'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24：显示客户端ID和秘钥的默认应用程序详情'
- en: '](img/B16835_08_24.jpg)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_24.jpg)'
- en: 'Figure 8.24: Default application details displaying Client ID and Secret'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：显示客户端ID和秘钥的默认应用程序详情
- en: 'Create properties for accessing the PayPal client ID and secret in a new empty
    class, `Exercise03.AuthHeaderHandler.cs`:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的空类`Exercise03.AuthHeaderHandler.cs`中创建用于访问PayPal客户端ID和秘钥的属性：
- en: '[PRE71]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, the `EnvironmentVariable.GetOrThrow` helper methods are used to get the
    user's environment variable or throw it if it doesn't exist. You will use these
    properties to make a connection to the sandbox PayPal API.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用`EnvironmentVariable.GetOrThrow`辅助方法来获取用户的环境变量，如果不存在则抛出。您将使用这些属性来连接到沙箱PayPal
    API。
- en: Note
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for environment variables at [https://packt.link/y2MCy](https://packt.link/y2MCy).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/y2MCy](https://packt.link/y2MCy)找到用于环境变量的代码。
- en: 'In the `Demo.cs` class, add a `const` variable for the `BaseAddress` of a PayPal sandbox:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Demo.cs`类中，添加一个用于PayPal沙箱的`BaseAddress`的`const`变量：
- en: '[PRE72]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`BaseAddress` will be used for initializing different clients (RestSharp and
    Refit) with the PayPal URL.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseAddress`将用于使用PayPal URL初始化不同的客户端（RestSharp和Refit）。'
- en: 'Use `Refit` to create a client with `CreateOrder` and `GetOrder` methods:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Refit`创建一个带有`CreateOrder`和`GetOrder`方法的客户端：
- en: '[PRE73]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To get a sample request, refer to the documentation of the API that you want
    to call. Usually, they have an example request. In this case, the PayPal `CreateOrder`
    request can be found at [https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取示例请求，请参考您想要调用的API的文档。通常，它们会有一个示例请求。在这种情况下，PayPal的`CreateOrder`请求可以在[https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/)找到：
- en: '[PRE74]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![Figure 8.25: PayPal CreateOrder example request with highlighted body'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25：PayPal创建订单示例请求，突出显示主体'
- en: '](img/B16835_08_25.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_25.jpg)'
- en: 'Figure 8.25: PayPal CreateOrder example request with highlighted body'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25：PayPal创建订单示例请求，突出显示主体
- en: In *Figure 8.25*, `-d` is an argument and does not belong to the request body.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.25*中，`-d`是一个参数，不属于请求主体。
- en: Use [https://json2csharp.com/](https://json2csharp.com/) and generate C# classes
    out of the JSON. The corresponding C# classes will be generated for you.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[https://json2csharp.com/](https://json2csharp.com/)并从JSON生成C#类。相应的C#类将为您生成。
- en: 'Rename `RootObject` to `Order` and change all classes to the `record` type
    because it''s a more suitable type for DTO:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RootObject`重命名为`Order`，并将所有类更改为`record`类型，因为它是DTO的更合适的类型：
- en: '[PRE75]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Using the same PayPal docs ([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/)),
    copy the example response:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的PayPal文档([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/))，复制示例响应：
- en: '[PRE77]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Use [https://json2csharp.com/](https://json2csharp.com/) and generate C# classes
    out of the JSON. Here, you will get classes very similar to the ones from request
    JSON. The only difference is the response (simplified for brevity):'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[https://json2csharp.com/](https://json2csharp.com/)并从JSON生成C#类。在这里，您将获得与请求JSON非常相似的类。唯一的区别是响应（为简洁起见进行了简化）：
- en: '[PRE78]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Use `AuthHeaderHandler` to fetch an access token when you make a request and
    make sure it inherits `DelegatingHandler`:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AuthHeaderHandler`在发出请求时获取访问令牌，并确保它继承`DelegatingHandler`：
- en: '[PRE79]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: To make calls to PayPal, you will need an `auth` header with every request.
    The `auth` header value is retrieved from yet another endpoint. Refit cannot just
    add a header on a whim. You can, however, set up Refit using a custom `HttpClient`
    with a custom `HttpMessageHandler` that fetches an access token whenever you make
    a request. The `AuthHeaderHandler` is used for that reason.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用PayPal，您需要在每个请求中使用`auth`标头。`auth`标头的值是从另一个端点检索的。Refit不能随意添加标头。但是，您可以使用自定义`HttpClient`和自定义`HttpMessageHandler`设置Refit，每当发出请求时都会获取访问令牌。出于这个原因使用`AuthHeaderHandler`。
- en: '`DelegatingHandler` is a class that allows intercepting `HttpRequest` when
    it''s being sent and doing something before or after it. In this case, before
    you send an HTTP request, you will fetch an `auth` header and add it to the request sent.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelegatingHandler`是一个允许拦截`HttpRequest`的类，当它被发送时，在发送HTTP请求之前或之后执行某些操作。在这种情况下，在发送HTTP请求之前，您将获取`auth`标头并将其添加到发送的请求中。'
- en: 'Now, override `SendRequest` by adding a bearer token to `AuthenticationHeader`:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过向`AuthenticationHeader`添加一个令牌来重写`SendRequest`：
- en: '[PRE80]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To get an access token, you first need to get an OAuth token using basic `auth`
    (the client ID and secret):'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取访问令牌，您首先需要使用基本的`auth`（客户端ID和密钥）获取OAuth令牌：
- en: '[PRE81]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Getting an access token will require an `auth` token. Use the `RestSharp` client
    and add an `Authorization` header to the request.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取访问令牌将需要一个`auth`令牌。使用`RestSharp`客户端并向请求添加`Authorization`标头。
- en: Next, set `content-type` to `application/x-www-form-urlencoded` as per the PayPal
    API spec.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据PayPal API规范将`content-type`设置为`application/x-www-form-urlencoded`。
- en: 'Add the body content `grant_type=client_credentials` as follows:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`grant_type=client_credentials`作为请求正文内容添加：
- en: '[PRE82]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Execute the preceding request and return the response using the private nested
    class `Response` to simplify your work:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行上述请求并使用私有嵌套类`Response`返回响应，以简化您的工作：
- en: '[PRE83]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Why is the nested class needed? Here, the access token is nested within the
    response. It's not just a string that it returns, but rather an object. To parse
    it yourself from JSON would be a little complicated. However, you already know
    how to deserialize objects. So, even if it's just one property, deserializing
    still helps.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要嵌套类？在这里，访问令牌嵌套在响应中。它不仅仅是一个字符串，而是一个对象。从JSON中自行解析会有点复杂。但是，您已经知道如何反序列化对象。因此，即使只是一个属性，反序列化仍然有所帮助。
- en: 'Now, create `RestClient` for the `GetAccessToken` method. Do so in the `AuthHandler`
    class:'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`AuthHandler`类中为`GetAccessToken`方法创建`RestClient`：
- en: '[PRE84]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the `Demo` class, create the method `Run`:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Demo`类中，创建`Run`方法：
- en: '[PRE85]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Resolve a `Refit` client with a custom `AuthHeaderHandler` provider:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义`AuthHeaderHandler`提供程序解析`Refit`客户端：
- en: '[PRE86]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Assuming that a payment was made by creating an `Order` object, run the following
    code:'
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设通过创建`Order`对象进行了付款，运行以下代码：
- en: '[PRE87]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now, call PayPal API and create an order endpoint with the order you've just created.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用PayPal API并创建一个刚刚创建的订单的订单端点。
- en: 'Get the created order to see if it works and print the retrieved order payment information:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的订单以查看是否有效，并打印检索到的订单支付信息：
- en: '[PRE88]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'With the environment variables set correctly, you should see the following output:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果环境变量设置正确，您应该会看到以下输出：
- en: '[PRE89]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'As mentioned earlier, this is a sandbox API. However, a switch to a live environment
    with real money would just be a matter of setting up new PayPal accounts in that
    environment and calling a different endpoint: [https://api-m.paypal.com](https://api-m.paypal.com).'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，这是一个沙盒API。然而，切换到带有真实货币的实时环境只是设置在该环境中创建新的PayPal账户并调用不同的端点：[https://api-m.paypal.com](https://api-m.paypal.com)。
- en: Note
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You won't be able to access [https://api-m.paypal.com](https://api-m.paypal.com)
    because it is for production PayPal use and is paid. However, that should be the
    only change in code (a different base URI) when you are ready to move on to real
    integration with PayPal.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 您将无法访问[https://api-m.paypal.com](https://api-m.paypal.com)，因为它是用于生产PayPal使用并且是付费的。然而，当您准备好与PayPal进行真正的集成时，这应该是代码中唯一的更改（不同的基本URI）。
- en: Please make sure you have the environment variables set and are using your own
    client and secret. Otherwise, some unhandled exception errors may be displayed.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您已设置环境变量并且正在使用您自己的客户端和密钥。否则，可能会显示一些未处理的异常错误。
- en: Note
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/cFRq6](https://packt.link/cFRq6).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/cFRq6](https://packt.link/cFRq6)找到此练习中使用的代码。
- en: You now know how to do simple CRUD operations with Web APIs. However, you have
    only worked with text so far. So, will calling an API with an image be any different?
    Find that out in the next activity.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道如何使用Web API执行简单的CRUD操作。但是，到目前为止，您只使用了文本。那么，使用图像调用API会有所不同吗？在下一个活动中找出答案。
- en: 'Activity 8.04: Using an Azure Blob Storage Client to Upload and Download Files'
  id: totrans-624
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.04：使用Azure Blob Storage客户端上传和下载文件
- en: Azure Blob Storage is a cloud service on Azure for storing different files (logs,
    images, music, and whole drives). Before you can use any Azure Storage services,
    you will need a storage account. Blobs are just files, but they cannot be directly
    stored within an account; instead, they need a container.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Blob Storage是Azure上用于存储不同文件（日志、图像、音乐和整个驱动器）的云服务。在您可以使用任何Azure存储服务之前，您将需要一个存储账户。Blob只是文件，但不能直接存储在账户中；相反，它们需要一个容器。
- en: An Azure Storage Container is like a directory where other files are stored.
    However, unlike a directory, a container cannot contain other containers. Use
    an Azure Storage Account to create two containers, upload an image and a text
    file, and then download the uploaded files locally. All this will be done in your
    own client, which wraps around the Azure Blob storage client.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: Azure存储容器类似于存储其他文件的目录。但是，与目录不同，容器不能包含其他容器。使用Azure存储账户创建两个容器，上传图像和文本文件，然后在本地下载上传的文件。所有这些都将在您自己的客户端中完成，该客户端包装了Azure
    Blob存储客户端。
- en: 'The aim of this activity is to familiarize yourself with working on files through
    cloud storage while putting all that you have learned so far to the test. Perform
    the following steps to complete this activity:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的目的是让您熟悉通过云存储处理文件，并将迄今为止学到的知识付诸实践。执行以下步骤完成此活动：
- en: Navigate to `Azure Storage Accounts`.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Azure存储账户`。
- en: Create a new Azure Storage Account.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Azure存储账户。
- en: Store a blob storage access key in environmental variables with the name `BlobStorageKey`.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在环境变量中存储blob存储访问密钥，名称为`BlobStorageKey`。
- en: Install the `Azure Blob Storage` client.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`Azure Blob Storage`客户端。
- en: Create the `FilesClient` class for storing fields for blobs client and default
    container client (where blobs will be stored by default).
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为存储字段和默认容器客户端（默认情况下将在其中存储blob的容器）创建`FilesClient`类。
- en: Create a constructor to initialize the two clients (to support access to different containers).
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构造函数来初始化两个客户端（以支持访问不同的容器）。
- en: Add a method to create a container or get an existing one if it already exists.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来创建一个容器，如果已经存在则获取一个现有的容器。
- en: Create a method to upload a file to a specific container.
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法，将文件上传到特定的容器。
- en: Create a method to download a file from a specific container.
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法，从特定的容器下载文件。
- en: Create a `Demo` class with paths to download and upload directories.
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Demo`类，其中包含下载和上传目录的路径。
- en: 'Add test data, namely the two files—that is, an image and a text file (*Figure
    8.26*, *Figure 8.27*, and *Figure 8.28*):'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加测试数据，即两个文件，即图像和文本文件（*图8.26*，*图8.27*和*图8.28*）：
- en: '![Figure 8.26: Two Azure Storage containers, exercise04 and exercise04b,'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.26：两个Azure存储容器，exercise04和exercise04b，'
- en: in your storage account
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的存储账户中
- en: '](img/B16835_08_26.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_26.jpg)'
- en: 'Figure 8.26: Two Azure Storage containers, exercise04 and exercise04b, in your
    storage account'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26：您的存储账户中的两个Azure存储容器，exercise04和exercise04b
- en: 'Text file:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件：
- en: '![Figure 8.27: Test1.txt file uploaded in exercise04 container'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.27：Test1.txt文件上传到exercise04容器'
- en: '](img/B16835_08_27.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_27.jpg)'
- en: 'Figure 8.27: Test1.txt file uploaded in exercise04 container'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27：Test1.txt文件上传到exercise04容器
- en: 'Image file:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 图像文件：
- en: '![Figure 8.28: Morning.jpg file uploaded in exercise04b container'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.28：Morning.jpg文件上传到exercise04b容器'
- en: '](img/B16835_08_28.jpg)'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_28.jpg)'
- en: 'Figure 8.28: Morning.jpg file uploaded in exercise04b container'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28：Morning.jpg文件上传到exercise04b容器
- en: Create the method `Run` to upload a text file and then download it locally.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建方法`Run`，上传一个文本文件，然后在本地下载它。
- en: 'Run the code. If you did everything correctly, you should see the following
    output with both files downloaded locally:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。如果您做得正确，您应该看到以下输出，两个文件都已在本地下载：
- en: '![Figure 8.29: Morning.jpg and Test1.txt files downloaded from the two containers'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.29：从两个容器中下载的Morning.jpg和Test1.txt文件'
- en: after the demo code execution
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 演示代码执行后
- en: '](img/B16835_08_29.jpg)'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_08_29.jpg)'
- en: 'Figure 8.29: Morning.jpg and Test1.txt files downloaded from the two containers
    after the demo code execution'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29：在演示代码执行后从两个容器中下载的Morning.jpg和Test1.txt文件
- en: Note
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: It is near impossible to create a perfect client that is suitable for everyone.
    Therefore, even when there is a solution for some problem given to you, you will
    often still need to further abstract it away, adapting it to solve exactly the
    problem you have. The problem you had was in uploading and downloading a file
    from and to a specific folder. To solve the problem, you abstracted away layers
    of clients exposing just two functions—one for uploading a file and another for
    downloading a file.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎不可能创建一个适合所有人的完美客户端。因此，即使对于给定给您的一些问题已经有了解决方案，您通常仍需要进一步将其抽象化，使其适应解决您确切问题的需求。您遇到的问题是从特定文件夹上传和下载文件。为了解决这个问题，您将客户端的层级抽象化，仅暴露两个功能——一个用于上传文件，另一个用于下载文件。
- en: Summary
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: No matter the kind of programmer you are, there will be many scenarios in which
    you will have to consume a web service. There are different kinds of services
    online, but the most common type is RESTful. REST is just a set of guidelines
    and should therefore not be mixed up with HTTP. REST APIs are simple, self-documented,
    well-structured, and are currently a golden standard of Web APIs. However, in
    most cases in the context of RESTful APIs, a request is sent over HTTP and your
    message contains JSON.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是什么样的程序员，都会有许多情况需要使用Web服务。在线有不同类型的服务，但最常见的类型是RESTful。REST只是一组指南，因此不应与HTTP混淆。REST
    API简单、自我记录、结构良好，目前是Web API的黄金标准。然而，在大多数情况下，在RESTful API的上下文中，请求是通过HTTP发送的，您的消息包含JSON。
- en: The main tool for making HTTP calls using C# is `HttpClient`, however, before
    you try to implement HTTP calls yourself, you should look for a NuGet package
    of the Web API you're trying to consume. Azure Blob storage, Azure Text Analytics,
    PayPal, and GitHub are just a few examples of Web APIs.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C#进行HTTP调用的主要工具是`HttpClient`，但是，在尝试自己实现HTTP调用之前，您应该寻找要使用的Web API的NuGet包。Azure
    Blob存储、Azure文本分析、PayPal和GitHub只是一些Web API的例子。
- en: In this chapter, you learned about a lot of functionality on the web that is
    done for you. It's not hard to consume; all you need to know now is how to communicate
    with the third-party RESTful Web APIs. In the next chapter, you will learn how
    to create your own RESTful web services using the ASP.NET Core Web API template
    as well as being introduced to Azure Functions and the special tools Swagger and
    NuGet.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了很多在网络上为您完成的功能。消费起来并不难；现在您需要知道的是如何与第三方的RESTful Web API进行通信。在下一章中，您将学习如何使用ASP.NET
    Core Web API模板创建自己的RESTful web服务，同时还将介绍Azure Functions以及特殊工具Swagger和NuGet。
