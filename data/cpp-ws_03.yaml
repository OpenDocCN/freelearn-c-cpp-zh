- en: 3\. Delegates, Events, and Lambdas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 委托、事件和Lambda
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how delegates are defined and invoked, and you
    will explore their wide usage across the .NET ecosystem. With this knowledge,
    you will move on to the inbuilt `Action` and `Func` delegates to discover how
    their usage reduces unnecessary boilerplate code. You will then see how multicast
    delegates can be harnessed to send messages to multiple parties, and how events
    can be incorporated into event-driven code. Along the way, you will discover some
    common pitfalls to avoid and best practices to follow that prevent a great application
    from turning into an unreliable one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将学习如何定义和调用委托，并探索它们在.NET生态系统中的广泛使用。有了这些知识，您将继续使用内置的`Action`和`Func`委托，以发现它们的使用如何减少不必要的样板代码。然后，您将看到如何利用多播委托向多个方发送消息，以及如何将事件纳入事件驱动的代码中。在这个过程中，您将发现一些常见的陷阱要避免，以及一些最佳实践，以防止一个优秀的应用程序变成一个不可靠的应用程序。
- en: This chapter will demystify the lambda syntax style and show how it can be used
    effectively. By the end of the chapter, you will be able to use the lambda syntax
    comfortably to create code that is succinct, as well as easy to grasp and maintain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将揭开lambda语法风格的神秘面纱，并展示如何有效地使用它。在本章结束时，您将能够舒适地使用lambda语法来创建简洁、易于理解和维护的代码。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, you learned some of the key aspects of Object Oriented
    Programming (OOP). In this chapter, you will build on this by looking at the common
    patterns used specifically in C# that enable classes to interact.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了面向对象编程（OOP）的一些关键方面。在本章中，您将通过查看C#中专门用于使类进行交互的常见模式来进一步学习。
- en: Have you found yourself working with a code that has to listen to certain signals
    and act on them, but you cannot be sure until runtime what those actions should
    be? Maybe you have a block of code that you need to reuse or pass to other methods
    for them to call when they are ready. Or, you may want to filter a list of objects,
    but need to base how you would do that on a combination of user preferences. Much
    of this can be achieved using interfaces, but it is often more efficient to create
    chunks of code that you can then pass to other classes in a type-safe way. Such
    blocks are referred to as delegates and form the backbone of many .NET libraries,
    allowing methods or pieces of code to be passed as parameters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否发现自己正在处理必须监听某些信号并对其进行操作的代码，但在运行时无法确定这些操作应该是什么？也许您有一段代码块需要重用或传递给其他方法，在它们准备好调用时。或者，您可能想要过滤对象列表，但需要根据用户偏好的组合来确定如何进行过滤。使用接口可以实现这些，但通常更有效的方法是创建代码块，然后以类型安全的方式将其传递给其他类。这些代码块被称为委托，并构成许多.NET库的基础，允许将方法或代码片段作为参数传递。
- en: The natural extension to a delegate is the event, which makes it possible to
    offer a form of optional behavior in software. For example, you may have a component
    that broadcasts live news and stock prices, but unless you provide a way to opt
    into these services, you may limit the usability of such a component.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 委托的自然扩展是事件，它使得在软件中提供一种可选行为成为可能。例如，您可能有一个组件可以广播实时新闻和股票价格，但除非您提供一种选择这些服务的方式，否则您可能会限制这种组件的可用性。
- en: User Interface (UI) apps often provide notifications of various user actions,
    for example, keypresses, swiping a screen, or clicking a mouse button; such notifications
    follow a standard pattern in C#, which will be discussed fully in this chapter.
    In such scenarios, the UI element detecting such actions is referred to as a publisher,
    whereas the code that acts upon those messages is called a subscriber. When brought
    together, they form an event-driven design referred to as the publisher-subscriber,
    or pub-sub, pattern. You will see how this can be used in all types of C#. Remember
    that its usage is not just the exclusive domain of UI applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面（UI）应用程序通常会提供各种用户操作的通知，例如按键、滑动屏幕或点击鼠标按钮；这些通知遵循C#中的标准模式，在本章中将对此进行全面讨论。在这种情况下，检测此类操作的UI元素被称为发布者，而对这些消息进行操作的代码被称为订阅者。当它们聚集在一起时，它们形成了一个称为发布者-订阅者或pub-sub模式的事件驱动设计。您将看到这可以在所有类型的C#中使用。请记住，它的使用不仅仅局限于UI应用程序的领域。
- en: Finally, you will learn about lambda statements and lambda expressions, collectively
    known as lambdas. These have an unusual syntax, which can initially take a while
    to become comfortable with. Rather than having lots of methods and functions scattered
    within a class, lambdas allow for smaller blocks of code that are often self-contained
    and located within close proximity to where they are used in the code, thereby
    offering an easier way to follow and maintain code. You will learn about lambdas
    in detail in the latter half of this chapter. First, you will learn about delegates.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将学习关于lambda语句和lambda表达式，统称为lambda。这些具有不寻常的语法，最初可能需要一段时间才能适应。与在类中散布大量方法和函数不同，lambda允许使用更小的代码块，这些代码块通常是自包含的，并且位于代码中使用它们的地方附近，从而提供了一种更容易遵循和维护代码的方式。您将在本章的后半部分详细了解lambda。首先，您将学习关于委托。
- en: Delegates
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托
- en: The .NET delegate is similar to function pointers found in other languages,
    such as C++; in other words, it is like a pointer to a method to be invoked at
    runtime. In essence, it is a placeholder for a block of code, which can be something
    as simple as a single statement or a full-blown multiline code block, complete
    with complex branches of execution, that you ask other code to execute at some
    point in time. The term delegate hints at some form of **representative**, which
    is precisely what this placeholder concept relates to.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: .NET委托类似于其他语言中的函数指针，比如C++；换句话说，它就像是一个在运行时调用的方法的指针。实质上，它是一段代码的占位符，可以是一个简单的语句，也可以是一个完整的多行代码块，包括复杂的执行分支，您可以要求其他代码在某个时间点执行。委托一词暗示了某种**代表**，这正是这个占位符概念所涉及的。
- en: Delegates allow for minimum coupling between objects, and much less code. There
    is no need to create classes that are derived from specific classes or interfaces.
    By using a delegate, you are defining what a compatible method should look like,
    whether it is in a class or struct, static, or instance-based. The arguments and
    return type define this calling compatibility.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 委托允许对象之间的耦合最小化，并且代码量大大减少。无需创建从特定类或接口派生的类。通过使用委托，您正在定义兼容方法应该是什么样子，无论它是在类或结构、静态或基于实例。参数和返回类型定义了这种调用兼容性。
- en: Furthermore, delegates can be used in a callback fashion, which allows multiple
    methods to be wired up to a single publication source. They often require much
    less code and provide more features than found using an interface-based design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，委托可以以回调方式使用，允许将多个方法连接到单个发布源。它们通常需要更少的代码，并提供比使用基于接口的设计更多的功能。
- en: 'The following example shows how effective delegates can be. Suppose you have
    a class that searches for users by surname. It would probably look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了委托可以有多么有效。假设您有一个按姓氏搜索用户的类。它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You then need to extend this to include a search of the user''s login name:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要扩展此功能以包括对用户登录名的搜索：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once again, you decide to add yet another search, this time by location:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您决定添加另一个搜索，这次是按位置搜索：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You start the searches with code like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码开始搜索：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Can you see the pattern that is occurring every time? You are repeating the
    same code that iterates through the list of users, applying a Boolean condition
    (also known as a predicate) to find the first matching user.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您能看到每次发生的模式吗？您重复了遍历用户列表的相同代码，应用布尔条件（也称为谓词）以找到第一个匹配的用户。
- en: The only thing that is different is that the predicate decides whether a match
    has been found. This is one of the common cases where delegates are used at a
    basic level. The `predicate` can be replaced with a delegate, acting as a placeholder,
    which is evaluated when required.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不同的是谓词决定是否找到了匹配项。这是委托在基本级别上使用的常见情况之一。`predicate`可以被替换为一个委托，充当占位符，在需要时进行评估。
- en: Converting this code to a delegate style, you define a delegate named `FindUser`
    (this step can be skipped as .NET contains a delegate definition that you can
    reuse; you will come to this later).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码转换为委托样式，您定义了一个名为`FindUser`的委托（可以跳过此步骤，因为.NET包含一个可以重用的委托定义；稍后您将了解到这一点）。
- en: 'All you need is a single helper method, `Find`, which is passed a `FindUser`
    delegate instance. Find knows how to loop through the users, invoking the delegate
    passing in the user, which returns true or false for a match:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要一个名为`Find`的单一辅助方法，它接受一个`FindUser`委托实例。Find知道如何循环遍历用户，调用传入用户的委托，返回true或false以进行匹配：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the code is kept together and is much more concise now. There
    is no need to cut and paste code that loops through the users, as that is all
    done in one place. For each type of search, you simply define a delegate once
    and pass it to `Find`. To add a new type of search, all you need to do is define
    it in a single statement line, rather than copying at least eight lines of code
    that repeat the looping function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，代码现在被保持在一起，更加简洁。无需剪切和粘贴循环遍历用户的代码，因为所有这些都在一个地方完成。对于每种类型的搜索，您只需一次定义一个委托并将其传递给`Find`。要添加新类型的搜索，您只需要在一条语句中定义它，而不是复制至少八行重复循环功能的代码。
- en: The lambda syntax is a fundamental style used to define method bodies, but its
    strange syntax can prove to be an obstacle at first. At first glance, lambda expressions
    can look odd with their `=>` style, but they do offer a cleaner way to specify
    a target method. The act of defining a lambda is similar to defining a method;
    you essentially omit the method name and use `=>` to prefix a block of code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda语法是一种用于定义方法体的基本样式，但其奇怪的语法可能首先会成为障碍。乍一看，Lambda表达式的`=>`样式可能看起来很奇怪，但它们确实提供了一种更清晰的指定目标方法的方式。定义Lambda的行为类似于定义方法；您基本上省略了方法名，并使用`=>`来前缀一段代码块。
- en: You will now look at another example, using interfaces this time. Consider that
    you are working on a graphics engine and need to calculate the position of an
    image onscreen each time the user rotates or zooms in. Note that this example
    skips any complex math calculations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将看另一个示例，这次使用接口。假设您正在开发一个图形引擎，并且需要在用户旋转或缩放时每次计算图像在屏幕上的位置。请注意，此示例跳过了任何复杂的数学计算。
- en: 'Consider that you need to transform a `Point` class using the `ITransform`
    interface with a single method named `Move`, as shown in the following code snippet:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到您需要使用具有名为`Move`的单个方法的`ITransform`接口来转换`Point`类，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the user rotates an object, you need to use `RotateTransform`, and for
    a zoom operation, you will use `ZoomTransform`, as follows. Both are based on
    the `ITransform` interface:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户旋转对象时，您需要使用`RotateTransform`，而对于缩放操作，您将使用`ZoomTransform`，如下所示。两者都基于`ITransform`接口：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, given these two classes, a point can be transformed by creating a new `Transform`
    instance, which is passed to a method named `Calculate`, as shown in the following
    code. `Calculate` calls the corresponding `Move` method, and does some extra unspecified
    work on point, before returning point to the caller:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，鉴于这两个类，可以通过创建一个新的`Transform`实例来转换一个点，该实例被传递给一个名为`Calculate`的方法，如下面的代码所示。`Calculate`调用相应的`Move`方法，并对点进行一些额外的未指定的工作，然后将点返回给调用者：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a standard class and interface-based design, but you can see that you
    have made a lot of effort to create new classes with just a single numeric value
    from a `Move` method. It is a worthwhile idea to have the calculations broken
    down into an easy-to-follow implementation. After all, it could have led to a
    future maintenance problem if implemented in a single method with multiple if-then
    branches.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的基于类和接口的设计，但您可以看到，您已经付出了很多努力，只是从`Move`方法中获得了一个单一的数值。将计算分解成易于遵循的实现是一个值得的想法。毕竟，如果在一个方法中实现了多个if-then分支，可能会导致未来的维护问题。
- en: By re-implementing a delegate-based design, you still have maintainable code,
    but much less of it to look after. You can have a `TransformPoint` delegate and
    a new `Calculate` function that can be passed a `TransformPoint` delegate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新实现基于委托的设计，您仍然可以拥有可维护的代码，但要处理的代码量要少得多。您可以有一个`TransformPoint`委托和一个新的`Calculate`函数，该函数可以传递一个`TransformPoint`委托。
- en: 'You can invoke a delegate by appending brackets around its name and passing
    in any arguments. This is similar to how you would call a standard class-level
    function or method. You will cover this invocation in more detail later; for now,
    consider the following snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在其名称周围添加括号并传递任何参数来调用委托。这类似于调用标准的类级函数或方法。稍后您将更详细地介绍这种调用；现在，请考虑以下片段：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You still need the actual target `Rotate` and `Zoom` methods, but you do not
    have the overhead of creating unnecessary classes to do this. You can add the
    following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然需要实际的目标`Rotate`和`Zoom`方法，但您不需要创建不必要的类来执行这些操作。您可以添加以下代码：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, calling the method delegates is as simple as the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用方法委托就像下面这样简单：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how using delegates in this way helps eliminate a lot of unnecessary
    code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用委托的方式有助于消除大量不必要的代码。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/AcwZA](https://packt.link/AcwZA).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/AcwZA](https://packt.link/AcwZA)找到此示例使用的代码。
- en: In addition to invoking a single placeholder method, a delegate also contains
    extra plumbing that allows it to be used in a **multicast** manner, that is, a
    way to chain multiple target methods together, each being invoked one after the
    other. This is often referred to as an invocation list or delegate chain and is
    initiated by code that acts as a publication source.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用单个占位符方法之外，委托还包含额外的管道，使其能够以**多播**的方式使用，即一种将多个目标方法链接在一起的方式，每个方法依次被调用。这通常被称为调用列表或委托链，并由充当发布源的代码发起。
- en: 'A simple example of how this multicast concept applies can be seen in UIs.
    Imagine you have an application that shows the map of a country. As the user moves
    their mouse over the map, you may want to perform various actions, such as the
    following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多播概念应用的一个简单例子可以在UI中看到。想象一下，您有一个显示国家地图的应用程序。当用户在地图上移动鼠标时，您可能希望执行各种操作，例如以下操作：
- en: Changing the mouse pointer to a different shape while over a building.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在鼠标悬停在建筑物上时，将鼠标指针更改为不同的形状。
- en: Showing a tooltip that calculates the real-world longitude and latitude coordinates.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一个工具提示，计算真实世界的经度和纬度坐标。
- en: Showing a message in a status bar that calculates the population of the area
    where the mouse is hovering.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态栏中显示一个消息，计算鼠标悬停区域的人口。
- en: To achieve this, you would need some way to detect when the user moves the mouse
    over the screen. This is often referred to as the publisher. In this example,
    its sole purpose is to detect mouse movements and publish them to anyone who is
    listening.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您需要一种方法来检测用户在屏幕上移动鼠标的方式。这通常被称为发布者。在这个例子中，它的唯一目的是检测鼠标移动并将其发布给任何正在监听的人。
- en: To perform the three required UI actions, you would create a class that has
    a list of objects to notify when the mouse position changes, allowing each object
    to perform whatever activity it needs, in isolation from the others. Each of these
    objects is referred to as a subscriber.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行三个必需的UI操作，您可以创建一个类，该类具有一个对象列表，当鼠标位置发生变化时通知这些对象，使每个对象能够独立于其他对象执行其所需的任何活动。这些对象中的每一个被称为订阅者。
- en: 'When your publisher detects that the mouse has moved, you follow this pseudo
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的发布者检测到鼠标移动时，您可以按照以下伪代码进行操作：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This assumes that `subscriptionList` is a list of objects, perhaps based on
    an interface with the `OnMouseMoved` method. It is up to you to add code that
    enables interested parties to subscribe to and unsubscribe from the `OnMouseMoved`
    notifications. It would be an unfortunate design if code that has previously subscribed
    has no way to unsubscribe and gets called repeatedly when there is no longer any
    need for it to be called.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设`subscriptionList`是一个对象列表，可能基于具有`OnMouseMoved`方法的接口。您需要添加代码，使感兴趣的各方能够订阅和取消订阅`OnMouseMoved`通知。如果以前订阅的代码没有取消订阅的方法，并且在不再需要调用它时被重复调用，那将是一个不幸的设计。
- en: In the preceding code, there is a fair amount of coupling between the publisher
    and subscribers, and you are back to using interfaces for a type-safe implementation.
    What if you then needed to listen for keypresses, both key down and key up? It
    would soon get quite frustrating having to repeatedly copy such similar code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发布者和订阅者之间存在相当多的耦合，并且您又开始使用接口进行类型安全的实现。如果您需要监听按键按下和松开，会怎么样？如果您不得不反复复制这样相似的代码，很快就会变得相当沮丧。
- en: Fortunately, the delegate type contains all this as inbuilt behavior. You can
    use single or multiple target methods interchangeably; all you need to do is invoke
    a delegate and the delegate will handle the rest for you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，委托类型包含所有这些内置行为。您可以交替使用单个或多个目标方法；您只需要调用委托，委托将为您处理其余的工作。
- en: You will take an in-depth look at multicast delegates shortly, but first, you
    will explore the single-target method scenario.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不久之后，您将深入研究多播委托，但首先，您将探索单目标方法场景。
- en: Defining a Custom Delegate
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义委托
- en: Delegates are defined in a way that is similar to that of a standard method.
    The compiler does not care about the code in the body of a target method, only
    that it can be invoked safely at some point in time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 委托的定义方式与标准方法的定义方式类似。编译器不关心目标方法体中的代码，只关心它在某个时间点上可以安全地被调用。
- en: 'The `delegate` keyword is used to define a delegate, using the following format:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`delegate`关键字来定义委托，格式如下：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following list describes each component of this syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了此语法的每个组件：
- en: 'Scope: An access modifier, such as `public`, `private`, or `protected`, to
    define the scope of the delegate. If you do not include a modifier, the compiler
    will default to marking it as private, but it is always better to be explicit
    in showing the intent of your code.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：访问修饰符，如`public`、`private`或`protected`，用于定义委托的范围。如果不包括修饰符，编译器将默认将其标记为私有，但最好明确显示代码的意图。
- en: The `delegate` keyword.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delegate`关键字。'
- en: 'Return type: If there is no return type, `void` is used.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型：如果没有返回类型，将使用`void`。
- en: 'Delegate name: This can be anything that you like, but the name must be unique
    within the namespace. Many naming conventions (including Microsoft''s) suggest
    adding `Handler` or `EventHandler` to your delegate''s name.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托名称：这可以是任何您喜欢的东西，但名称必须在命名空间内是唯一的。许多命名约定（包括微软的）建议在委托的名称中添加`Handler`或`EventHandler`。
- en: Arguments, if required.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，参数。
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Delegates can be nested within a class or namespace; they can also be defined
    within the global namespace, although this practice is discouraged. When defining
    classes in C#, it is common practice to define them within a parent namespace,
    typically based on a hierarchical convention that starts with the company name,
    followed by the product name, and finally the feature. This helps to provide a
    more unique identity to a type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 委托可以嵌套在类或命名空间中；它们也可以在全局命名空间中定义，尽管这种做法是不鼓励的。在C#中定义类时，通常习惯于在父命名空间中定义它们，通常基于以公司名称开头的分层约定，然后是产品名称，最后是功能。这有助于为类型提供更独特的标识。
- en: By defining a delegate without a namespace, there is a high chance that it will
    clash with another delegate with the same name if it is also defined in a library
    without the protection of a namespace. This can cause the compiler to become confused
    as to which delegate you are referring to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在没有命名空间的情况下定义委托，很有可能会与另一个具有相同名称的委托发生冲突，如果它也在没有命名空间保护的库中定义。这可能会导致编译器对你所指的委托感到困惑。
- en: In earlier versions of .NET, it was common practice to define custom delegates.
    Such code has since been replaced with various inbuilt .NET delegates, which you
    will look at shortly. For now, you will briefly cover the basics of defining a
    custom delegate. It is worthwhile know about this if you maintain any legacy C#
    code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早版本的.NET中，定义自定义委托是常见做法。这样的代码已经被各种内置的.NET委托所取代，您很快将看到。现在，您将简要介绍定义自定义委托的基础知识。如果您维护任何旧的C#代码，了解这一点是值得的。
- en: In the next exercise, you will create a custom delegate, one that is passed
    a `DateTime` parameter and returns a Boolean to indicate validity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将创建一个自定义委托，该委托传递一个`DateTime`参数并返回一个布尔值以指示有效性。
- en: 'Exercise 3.01: Defining and Invoking Custom Delegates'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.01：定义和调用自定义委托
- en: Say you have an application that allows users to order products. While filling
    in the order details, the customer can specify an order date and a delivery date,
    both of which must be validated before accepting the order. You need a flexible
    way to validate these dates. For some customers, you may allow weekend delivery
    dates, while for others, it must be at least seven days away. You may also allow
    an order to be back-dated for certain customers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个允许用户订购产品的应用程序。在填写订单详细信息时，客户可以指定订单日期和交货日期，这两者在接受订单之前必须经过验证。您需要一种灵活的方式来验证这些日期。对于一些客户，您可以允许周末交货日期，而对于其他客户，必须至少提前七天。您还可以允许某些客户对订单进行回溯。
- en: You know that delegates offer a way to vary an implementation at runtime, so
    that is the best way to proceed. You do not want multiple interfaces, or worse,
    a complex jumble of `if-then` statements, to achieve this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道委托提供了一种在运行时变化实现的方式，因此这是继续的最佳方式。您不希望使用多个接口，或者更糟糕的是，一堆复杂的`if-then`语句来实现这一点。
- en: 'Depending on the customer''s profile, you can create a class named `Order`,
    which can be passed different date validation rules. These rules can be validated
    by a `Validate` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据客户的配置文件，您可以创建一个名为`Order`的类，该类可以传递不同的日期验证规则。这些规则可以通过`Validate`方法进行验证：
- en: 'Perform the following steps to do so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a new folder called `Chapter03`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter03`的新文件夹。
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise01`,
    using the CLI `dotnet` command, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Chapter03`文件夹并使用CLI `dotnet`命令创建一个名为`Exercise01`的新控制台应用程序，如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will see the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open `Chapter03\Exercise01.csproj` and replace the contents with these settings:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter03\Exercise01.csproj`并用以下设置替换内容：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open `Exercise01\Program.cs` and clear the contents.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise01\Program.cs`并清空内容。
- en: The preference for using namespaces to prevent a clash with objects from other
    libraries was mentioned earlier, so to keep things isolated, use `Chapter03.Exercise01`
    as the namespace.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 早些时候提到了使用命名空间来防止与其他库中的对象发生冲突的偏好，因此为了保持事物的隔离，使用`Chapter03.Exercise01`作为命名空间。
- en: 'To implement your date validation rules, you will define a delegate that takes
    a single `DateTime` argument and returns a Boolean value. You will name it `DateValidationHandler`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现您的日期验证规则，您将定义一个委托，该委托接受一个`DateTime`参数并返回一个布尔值。您将其命名为`DateValidationHandler`：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, you will create a class named `Order`, which contains details of the
    order and can be passed to two date validation delegates:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将创建一个名为`Order`的类，其中包含订单的详细信息，并可以传递给两个日期验证委托：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how you have declared two read-only, class-level instances of `DateValidationHandler`,
    one to validate the order date and a second to validate the delivery date. This
    design assumes that the date validation rules are not going to be altered for
    this `Order` instance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您已声明了两个只读的类级别`DateValidationHandler`实例，一个用于验证订单日期，另一个用于验证交货日期。 此设计假定日期验证规则不会为此`Order`实例更改。
- en: 'Now for the constructor, you pass the two delegates:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在对于构造函数，您传递了两个委托：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this design, a different class is typically responsible for deciding which
    delegates to use, based on the selected customer's profile.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设计中，通常由不同的类负责根据所选客户的配置文件决定使用哪些委托。
- en: 'You need to add the two date properties that are to be validated. These dates
    may be set using a UI that listens to keypresses and applies user edits directly
    to this class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要添加要验证的两个日期属性。 这些日期可以使用监听按键并直接将用户编辑应用于此类的UI来设置：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now add an `IsValid` method that passes `OrderDate` to the `orderDateValidator`
    delegate and `DeliveryDate` to the `deliveryDateValidator` delegate:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个`IsValid`方法，将`OrderDate`传递给`orderDateValidator`委托，并将`DeliveryDate`传递给`deliveryDateValidator`委托：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If both are valid, then this call will return `true`. The key here is that
    `Order` doesn''t need to know about the precise implementation of an individual
    customer''s date validation rules, so you can easily reuse `Order` elsewhere in
    a program. To invoke a delegate, you simply wrap any arguments in brackets, in
    this case passing the correct date property to each delegate instance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两者都有效，则此调用将返回`true`。 关键在于`Order`不需要了解单个客户的日期验证规则的具体实现，因此您可以轻松地在程序的其他位置重用`Order`。
    要调用委托，只需将任何参数括在括号中，本例中将正确的日期属性传递给每个委托实例：
- en: 'To create a console app to test this, add a `static` class called `Program`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个控制台应用程序来测试这一点，请添加一个名为`Program`的`static`类：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You want to create two functions that validate whether the date passed to them
    is valid. These functions will form the basis of your delegate target methods:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您希望创建两个函数，用于验证传递给它们的日期是否有效。 这些函数将成为您的委托目标方法的基础：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how both have the exact signature that the `DateValidationHandler` delegate
    is expecting. Neither is aware of the nature of the date that they are validating,
    as that is not their concern. They are both marked `static` as they do not interact
    with any variables or properties anywhere in this class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两者都具有`DateValidationHandler`委托所期望的确切签名。 他们都不知道他们正在验证的日期的性质，因为这不是他们关心的事情。
    他们都标记为`static`，因为它们不与此类中的任何变量或属性交互。
- en: 'Now for the `Main` entry point. Here, you create two `DateValidationHandler`
    delegate instances, passing `IsPastDate` to one and `IsWeekendDate` to the second.
    These are the target methods that will get called when each of the delegates is
    invoked:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是`Main`入口点。 在这里，您创建了两个`DateValidationHandler`委托实例，将`IsPastDate`传递给一个委托，将`IsWeekendDate`传递给第二个委托。
    这些是在调用每个委托时将被调用的目标方法：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now you can create an `Order` instance, passing in the delegates and setting
    the order and delivery dates:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以创建一个`Order`实例，传递委托并设置订单和交货日期：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are various ways to create delegates. Here, you have assigned them to
    variables first to make the code clearer (you will cover different styles later).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以创建委托。 在这里，您首先将它们分配给变量，以使代码更清晰（稍后将介绍不同的样式）。
- en: 'Now it''s just a case of displaying the dates in the console and calling `IsValid`,
    which, in turn, will invoke each of your delegate methods once. Notice that a
    custom date format is used to make the dates more readable:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只需在控制台中显示日期并调用`IsValid`，然后`IsValid`将依次调用您的每个委托方法。 请注意，使用自定义日期格式使日期更易读：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the console app produces output like this:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生以下输出：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This order is **not** valid as the delivery date is a Thursday, not a weekend
    as you require:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此顺序**无效**，因为交货日期是星期四，而不是周末，正如您所要求的：
- en: You have learned how to define a custom delegate and have created two instances
    that make use of small helper functions to validate dates. This gives you an idea
    of how flexible delegates can be.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何定义自定义委托，并创建了两个实例，这些实例使用小的辅助函数来验证日期。 这使您了解了委托可以有多灵活的想法。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/cmL0s](https://packt.link/cmL0s).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/cmL0s](https://packt.link/cmL0s)找到此练习使用的代码。
- en: The Inbuilt Action and Func Delegates
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置的Action和Func委托
- en: 'When you define a delegate, you are describing its signature, that is, the
    return type and a list of input parameters. With that said, consider these two
    delegates:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义委托时，您正在描述其签名，即返回类型和输入参数列表。 也就是说，考虑这两个委托：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'They both have the same signature but vary by name alone, which is why you
    can declare an instance of each and have them **both** point at the **same** target
    method when invoked:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都具有相同的签名，但仅通过名称不同，这就是为什么您可以声明每个实例并在调用时**都**指向**相同**的目标方法：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the console app produces the same results in both calls:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生两次调用相同的结果：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/r6B8n](https://packt.link/r6B8n).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/r6B8n](https://packt.link/r6B8n)找到此示例使用的代码。
- en: It would be great if you could dispense with defining both `DoStuff` and `DoMoreStuff`
    delegates and use a more generalized delegate with precisely the same signature.
    After all, it does not matter in the preceding snippet if you create a `DoStuff`
    or `DoMoreStuff` delegate, since both make a call to the same target method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以不定义`DoStuff`和`DoMoreStuff`委托并使用具有完全相同签名的更通用的委托，那将是很好的。 毕竟，在前面的片段中，如果您创建了`DoStuff`或`DoMoreStuff`委托，都不重要，因为两者都调用相同的目标方法。
- en: .NET does, in fact, provide various inbuilt delegates that you can make use
    of directly, saving you the effort of defining such delegates yourself. These
    are the `Action` and `Func` delegates.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: .NET实际上提供了各种内置委托，您可以直接使用这些委托，而无需自己定义这些委托。 这些是`Action`和`Func`委托。
- en: There are many possible combinations of `Action` and `Func` delegates, each
    allowing an increasing number of parameters. You can specify anywhere from zero
    to 16 different parameter types. With so many combinations available, it is extremely
    unlikely that you will ever need to define your own delegate type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action`和`Func`委托有许多可能的组合，每个组合都允许越来越多的参数。你可以指定从零到16个不同的参数类型。由于有这么多的组合可用，你极有可能永远不需要定义自己的委托类型。'
- en: It is worth noting that `Action` and `Func` delegates were added in a later
    version of .NET and, as such, the use of custom delegates tends to be found in
    older legacy code. There is no need to create new delegates yourself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Action`和`Func`委托是在.NET的较新版本中添加的，因此自定义委托的使用往往可以在较旧的遗留代码中找到。没有必要自己创建新的委托。
- en: 'In the following snippet, `MyMethod` is invoked using the three-argument `Func`
    variation; you will cover the odd-looking `<string, int, string>` syntax shortly:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中，`MyMethod`使用了三参数的`Func`变体进行调用；你很快就会涵盖到那个看起来有点奇怪的`<string, int, string>`语法：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This produces the same return value as the two earlier invocations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了与前两个调用相同的返回值：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Before you continue exploring `Action` and `Func` delegates, it is useful to
    explore the `Action<string, int, string>` syntax a bit further. This syntax allows
    type parameters to be used to define classes and methods. These are known as generics
    and act as placeholders for a particular type. In *Chapter 4*, *Data Structures
    and LINQ*, you will cover generics in much greater detail, but it is worth summarizing
    their usage here with the `Action` and `Func` delegates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续探索`Action`和`Func`委托之前，探索`Action<string, int, string>`语法会很有用。这种语法允许使用类型参数来定义类和方法。这些被称为泛型，并充当特定类型的占位符。在*第4章*，*数据结构和LINQ*中，你将更详细地介绍泛型，但在这里用`Action`和`Func`委托总结它们的用法是值得的。
- en: 'The non-generic version of the `Action` delegate is predefined in .NET as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action`委托的非泛型版本在.NET中预定义如下：'
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you know from your earlier look at delegates, this is a delegate that does
    not take any arguments and does not have a return type; it is the simplest type
    of delegate available.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从之前对委托的了解，这是一个不带任何参数且没有返回类型的委托；这是可用的最简单的委托类型。
- en: 'Contrast that with one of the generic `Action` delegates predefined in .NET:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与.NET中预定义的一个泛型`Action`委托相对比：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can see this includes a `<T>` and `T` parameter section, which means it
    accepts a `Action` that is constrained to a string, which takes a single string
    argument and returns no value, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这包括一个`<T>`和`T`参数部分，这意味着它接受一个被限制为字符串的`Action`，它接受一个字符串参数并且不返回值，如下所示：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'How about an `int` constrained version? This also has no return type and takes
    a single `int` argument:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再来一个被限制为`int`的版本？这也没有返回类型，接受一个`int`参数：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Can you see the pattern here? In essence, the type that you specify can be used
    to declare a type at compile time. What if you wanted two arguments, or three,
    or four…or 16? Simple. There are `Action` and `Func` generic types that can take
    up to **16** different argument types. You are very unlikely to be writing code
    that needs more than 16 parameters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到这里的模式吗？实质上，你指定的类型可以用来在编译时声明一个类型。如果你想要两个参数，或三个，或四个…或16个呢？简单。有`Action`和`Func`泛型类型，可以接受**16**种不同的参数类型。你很少会写需要超过16个参数的代码。
- en: 'This two-argument `Action` takes `int` and `string` as parameters:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个两参数的`Action`接受`int`和`string`作为参数：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can spin that around. Here is another two-argument `Action`, but this takes
    a `string` parameter and then an `int` parameter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把它转过来。这里是另一个两参数的`Action`，但是这个接受一个`string`参数，然后是一个`int`参数：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These cover most argument combinations, so you can see that it is very rare
    to create your own delegate types.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些涵盖了大多数参数组合，所以你可以看到很少需要创建自己的委托类型。
- en: 'The same rules apply to delegates that return a value; this is where the `Func`
    types are used. The generic `Func` type starts with a single value type parameter:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 委托返回值也适用相同的规则；这就是`Func`类型被使用的地方。通用的`Func`类型以单个值类型参数开始：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the following example, `funcE` is a delegate that returns a Boolean value
    and takes no arguments:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`funcE`是一个返回布尔值且不带参数的委托：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Can you guess which is the return type from this rather long `Func` declaration?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到这个相当长的`Func`声明的返回类型是什么吗？
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This gives a delegate that returns a `string` . In other words, the last argument
    type in a `Func` defines the return type. Notice that `funcF` takes four arguments:
    `bool`, `int`, `int`, and `DateTime`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个返回`string`的委托。换句话说，在`Func`中的最后一个参数类型定义了返回类型。注意`funcF`接受四个参数：`bool`、`int`、`int`和`DateTime`。
- en: In summary, generics are a great way to define types. They save a lot of duplicate
    code by allowing type parameters to act as placeholders.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，泛型是定义类型的一种很好的方式。它们通过允许类型参数充当占位符来节省了大量重复的代码。
- en: Assigning Delegates
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配委托
- en: You covered creating custom delegates and briefly how to assign and invoke a
    delegate in *Exercise 3.01*. You then looked at using the preferred `Action` and
    `Func` equivalents, but what other options do you have for assigning the method
    (or methods) that form a delegate? Are there other ways to invoke a delegate?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你在*练习3.01*中介绍了创建自定义委托以及如何分配和调用委托的简要方法。然后你看了使用首选的`Action`和`Func`等价物，但是你还有哪些其他选项来分配形成委托的方法（或方法）？有其他方式来调用委托吗？
- en: Delegates can be assigned to a variable in much the same way that you might
    assign a class instance. You can also pass new instances or static instances around
    without having to use variables to do so. Once assigned, you can invoke the delegate
    or pass the reference to other classes so they can invoke it, and this is often
    done within the Framework API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 委托可以被分配给一个变量，就像你可能会分配一个类实例一样。你也可以传递新实例或静态实例，而不必使用变量来这样做。一旦分配，你可以调用委托或将引用传递给其他类，以便它们可以调用它，这在框架API中经常这样做。
- en: 'You will now look at a `Func` delegate, which takes a single `DateTime` argument
    and returns a `bool` value to indicate validity. You will use a `static` class
    containing two helper methods, which form the actual target:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您将查看一个`Func`委托，它接受一个`DateTime`参数并返回一个`bool`值来指示有效性。您将使用一个包含两个帮助方法的`static`类，这些方法形成了实际的目标：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/mwmxh](https://packt.link/mwmxh).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/mwmxh](https://packt.link/mwmxh)找到此示例的代码。
- en: Note that the `DateValidators` class is marked as `static`. You may have heard
    the phrase **statics are inefficient**. In other words, creating an application
    with many static classes is a weak practice. Static classes are instantiated the
    first time they are accessed by running code and remain in memory until the application
    is closed. This makes it difficult to control their lifetime. Defining small utility
    classes as static is less of an issue, provided they do indeed remain stateless.
    Stateless means they do not set any local variables. Static classes that set local
    states are very difficult to unit test; you can never be sure that the variable
    set is from one test or another test.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`DateValidators`类标记为`static`。您可能听说过短语**静态是低效的**。换句话说，创建具有许多静态类的应用程序是一种薄弱的做法。静态类在首次被运行代码访问时实例化，并且会一直保留在内存中，直到应用程序关闭。这使得难以控制它们的生命周期。将小型实用程序类定义为静态类不是问题，前提是它们确实保持无状态。无状态意味着它们不设置任何局部变量。设置局部状态的静态类非常难以进行单元测试；您永远无法确定设置的变量是来自一个测试还是另一个测试。
- en: In the preceding snippet, `IsFuture` returns `true` if the `Date` property of
    the `DateTime` argument is later than the current date. You are using the static
    `DateTime.Today` property to retrieve the current system date. `IsWeekend` is
    defined using an expression-bodied syntax and will return `true` if the `DateTime`
    argument's day of the week falls on a Saturday or Sunday.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，如果`DateTime`参数的`Date`属性晚于当前日期，则`IsFuture`返回`true`。您正在使用静态的`DateTime.Today`属性来检索当前系统日期。使用表达式主体语法定义了`IsWeekend`，如果`DateTime`参数的星期几是星期六或星期日，则将返回`true`。
- en: 'You can assign delegates the same way that you would assign regular variables
    (remember you do `futureValidator` and `weekendValidator`. Each constructor is
    passed the actual target method, the `IsFuture` or `IsWeekend` instance, respectively:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像分配常规变量一样分配委托（记住您要做`futureValidator`和`weekendValidator`）。每个构造函数分别传递实际的目标方法，即`IsFuture`或`IsWeekend`实例：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that it is not valid to use the `var` keyword to assign a delegate without
    wrapping in the `Func` prefix:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`var`关键字分配委托而不包装在`Func`前缀中是无效的：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This results in the following compiler error:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下编译器错误：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Taking this knowledge of delegates, proceed to how you can invoke a delegate.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了委托的这些知识后，继续了解如何调用委托。
- en: Invoking a Delegate
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用委托
- en: 'There are several ways to invoke a delegate. For example, consider the following definition:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种调用委托的方法。例如，考虑以下定义：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To invoke `futureValidator`, you must pass in a `DateTime` value, and it will
    return a `bool` value using any of these styles:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`futureValidator`，您必须传入一个`DateTime`值，并且它将返回一个`bool`值，可以使用以下任何一种样式：
- en: 'Invoke with the null-coalescing operator:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空合并运算符调用：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is the preferred and safest approach; you should always check for a null
    before calling `Invoke`. If there is a chance that a delegate does not point to
    an object in memory, then you must perform a null reference check before accessing
    methods and properties. A failure to do so will result in `NullReferenceException`
    being thrown. This is the runtime's way of warning you that the object is not
    pointing at anything.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是首选且最安全的方法；在调用`Invoke`之前，您应该始终检查空值。如果委托有可能不指向内存中的对象，则在访问方法和属性之前必须执行空引用检查。不这样做将导致抛出`NullReferenceException`。这是运行时警告您对象没有指向任何内容的方式。
- en: By using the null-coalescing operator, the compiler will add the null check
    for you. In the code, you explicitly declared `futureValidator`, so here it cannot
    be null. But what if you had been passed `futureValidator` from another method?
    How can you be sure that the caller had correctly assigned a reference?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用空合并运算符，编译器将为您添加空检查。在代码中，您明确声明了`futureValidator`，因此它在这里不可能为空。但是，如果您从另一个方法中传递了`futureValidator`会怎么样？您如何确保调用者已正确分配了引用？
- en: Delegates have additional rules that make it possible for them to throw `NullReferenceException`
    when invoked. In the preceding example, `futureValidator` has a single target,
    but as you will see later, the `NullReferenceException`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 委托有额外的规则，使它们在被调用时可能会抛出`NullReferenceException`。在前面的例子中，`futureValidator`有一个单一的目标，但正如您将在后面看到的，会抛出`NullReferenceException`。
- en: Direct Invoke
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接调用
- en: 'This is the same as the previous method, but without the safety of the null
    check. This is not recommended for the same reason; that is, the delegate can
    throw a `NullReferenceException`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以前的方法相同，但没有空检查的安全性。出于同样的原因，这是不推荐的；也就是说，委托可能会抛出`NullReferenceException`：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Without the `Invoke` prefix
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`Invoke`前缀
- en: 'This looks more succinct as you simply call the delegate without the `Invoke`
    prefix. Again, this is not recommended due to a possible null reference:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更简洁，因为您只需调用委托，而无需`Invoke`前缀。同样，由于可能存在空引用，这是不推荐的：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Try assigning and safely invoking a delegate through an exercise by bringing
    them together.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过练习将委托分配和安全调用结合在一起。
- en: 'Exercise 3.02: Assigning and Invoking Delegates'
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.02：分配和调用委托
- en: In this exercise, you are going to write a console app showing how a `Func`
    delegate can be used to extract numeric values. You will create a `Car` class
    that has `Distance` and `JourneyTime` properties. You will prompt the user to
    enter the distance traveled yesterday and today, passing this information to a
    `Comparison` class that is told how to extract values and calculate their differences.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个控制台应用程序，展示如何使用`Func`委托来提取数值。你将创建一个`Car`类，它有`Distance`和`JourneyTime`属性。你将提示用户输入昨天和今天的行驶距离，将这些信息传递给一个`Comparison`类，告诉它如何提取值并计算它们的差异。
- en: 'Perform the following steps to do so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '执行以下步骤来完成： '
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise02`,
    using the CLI `dotnet` command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Chapter03`文件夹，并使用CLI `dotnet`命令创建一个名为`Exercise02`的新控制台应用程序：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open `Chapter03\Exercise02.csproj` and replace the entire file with these settings:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter03\Exercise02.csproj`，并用以下设置替换整个文件：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Open `Exercise02\Program.cs` and clear the contents.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise02\Program.cs`并清空内容。
- en: Start by adding a record called `Car`. Include the `System.Globalization` namespace
    for string parsing. Use the `Chapter03.Exercise02` namespace to keep code separate
    from the other exercises.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一个名为`Car`的记录。包括`System.Globalization`命名空间以进行字符串解析。使用`Chapter03.Exercise02`命名空间将代码与其他练习分开。
- en: 'Add two properties, `Distance` and `JourneyTime`. They will have `init`-only
    properties, so you will use the `init` keyword:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个属性，`Distance`和`JourneyTime`。它们将具有`init`-only属性，因此你将使用`init`关键字：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, create a class named `Comparison` that is passed a `Func` delegate to
    work with. The `Comparison` class will use the delegate to extract either the
    `Distance` or `JourneyTime` properties and calculate the difference for two `Car`
    instances. By using the flexibility of delegates, `Comparison` will not know whether
    it is extracting `Distance` or `JourneyTime`, just that it is using a double to
    calculate the differences. This shows that you can reuse this class should you
    need to calculate other `Car` properties in the future:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`Comparison`的类，它被传递一个`Func`委托来使用。`Comparison`类将使用委托来提取`Distance`或`JourneyTime`属性，并计算两个`Car`实例的差异。通过使用委托的灵活性，`Comparison`将不知道它是提取`Distance`还是`JourneyTime`，只知道它使用一个`double`来计算差异。这表明你可以在将来需要计算其他`Car`属性时重用这个类：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add three properties that form the results of the calculation, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个属性，形成计算结果，如下：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now for the calculation, pass two `Car` instances, one for the car journey
    yesterday, `yesterdayCar`, and one for today, `todayCar`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进行计算，传入两个`Car`实例，一个是昨天的汽车行程`yesterdayCar`，另一个是今天的`todayCar`：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To calculate a value for `Yesterday`, invoke the `valueSelector` `Func` delegate,
    passing in the `yesterdayCar` instance. Again, remember that the `Comparison`
    class is unaware whether it is extracting `Distance` or `JourneyTime`; it just
    needs to know that when the `delegate` is invoked with a `Car` argument, it will
    get a double number back:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算`Yesterday`的值，调用`valueSelector` `Func`委托，传入`yesterdayCar`实例。再次记住，`Comparison`类并不知道它是提取`Distance`还是`JourneyTime`；它只需要知道当`delegate`被`Car`参数调用时，它将得到一个`double`数字：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Do the same to extract the value for `Today` by using the same `Func` delegate,
    but passing in the `todayCar` instance instead:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '同样的方法提取`Today`的值，使用相同的`Func`委托，但传入`todayCar`实例： '
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now it is just a case of calculating the difference between the two extracted
    numbers; you don''t need to use the `Func` delegate to do that:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只是计算两个提取的数字之间的差异；你不需要使用`Func`委托来做到这一点：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So, you have a class that knows how to invoke a `Func` delegate to extract
    a certain `Car` property when it is told how to. Now, you need a class to wrap
    up the `Comparison` instances. For this, add a class called `JourneyComparer`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，你有一个知道如何调用`Func`委托来提取特定`Car`属性的类，当它被告知如何操作时。现在，你需要一个类来封装`Comparison`实例。为此，添加一个名为`JourneyComparer`的类：
- en: '[PRE58]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the car journey, you need to calculate the difference between the `Yesterday`
    and `Today` `Distance` properties. To do so, create a `Comparison` class that
    is told how to extract a value from a `Car` instance. You may as well use the
    same name for this `Comparison` class as you will extract a car''s `Distance`.
    Remember that the `Comparison` constructor needs a `Func` delegate that is passed
    a `Car` instance and returns a double value. You will add `GetCarDistance()` shortly;
    this will eventually be invoked by passing `Car` instances for yesterday''s and
    today''s journeys:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于汽车行程，你需要计算`Yesterday`和`Today`的`Distance`属性之间的差异。为此，创建一个`Comparison`类，告诉它如何从`Car`实例中提取值。你可能会使用相同的名称来为这个`Comparison`类，因为你将提取汽车的`Distance`。记住，`Comparison`构造函数需要一个`Func`委托，它被传递一个`Car`实例并返回一个`double`值。你将很快添加`GetCarDistance()`；这将最终通过传递昨天和今天的行程的`Car`实例来调用：
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Repeat the process as described in the preceding steps for a `JourneyTime`
    `Comparison`; this one should be told to use `GetCarJourneyTime()` as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照前面步骤中描述的过程重复这个过程，用于`JourneyTime` `Comparison`；这个应该被告知使用`GetCarJourneyTime()`如下：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, add another `Comparison` property called `AverageSpeed` as follows.
    You will see shortly that `GetCarAverageSpeed()` is yet another function:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加另一个名为`AverageSpeed`的`Comparison`属性，如下。你很快会看到`GetCarAverageSpeed()`是另一个函数：
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now for the `GetCarDistance` and `GetCarJourneyTime` local functions, they
    are passed a `Car` instance and return either `Distance` or `JourneyTime` accordingly:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在对于`GetCarDistance`和`GetCarJourneyTime`本地函数，它们被传递一个`Car`实例，并根据需要返回`Distance`或`JourneyTime`：
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`GetCarAverageSpeed`, as the name suggests, returns the average speed. Here,
    you have shown that the `Func` delegate just needs a compatible function; it doesn''t
    matter what it returns as long as it is `double`. The `Comparison` class does
    not need to know that it is returning a calculated value such as this when it
    invokes the `Func` delegate:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetCarAverageSpeed`，顾名思义，返回平均速度。在这里，你已经表明`Func`委托只需要一个兼容的函数；只要返回值是`double`，它返回的内容并不重要。`Comparison`类在调用`Func`委托时并不需要知道它返回的是这样的一个计算值：'
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The three `Comparison` properties should be defined like this:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个`Comparison`属性应该定义如下：
- en: '[PRE64]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now for the main `Compare` method. This will be passed two `Car` instances,
    one for `yesterday` and one for `today`, and it simply calls `Compare` on the
    three `Comparison` items passing in the two `Car` instances:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是主要的`Compare`方法。这将传递两个`Car`实例，一个用于`昨天`，一个用于`今天`，然后简单地调用三个`Comparison`项上的`Compare`，传入两个`Car`实例：
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You need a console app to enter the miles traveled per day, so add a class
    called `Program` with a static `Main` entry point:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要一个控制台应用程序来输入每天的行驶里程，因此添加一个名为`Program`的类，并具有静态`Main`入口点：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can randomly assign journey times to save some input, so add a new `Random`
    instance and the start of a `do-while` loop, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以随机分配旅行时间以保存一些输入，因此添加一个新的`Random`实例和一个`do-while`循环的开始，如下所示：
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Read for yesterday''s distance, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读昨天的距离，如下所示：
- en: '[PRE68]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can use the distance to create yesterday''s `Car` with a random `JourneyTime`,
    as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用距离创建昨天的`Car`，并使用随机的`JourneyTime`，如下所示：
- en: '[PRE69]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Do the same for today''s distance:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于今天的距离也是如此：
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now that you have two `Car` instances populated with values for yesterday and
    today, you can create the `JourneyComparer` instance and call `Compare`. This
    will then call `Compare` on your three `Comparison` instances:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您有两个填充了昨天和今天的`Car`实例，您可以创建`JourneyComparer`实例并调用`Compare`。然后，这将在三个`Comparison`实例上调用`Compare`：
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, write the results to the console:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将结果写入控制台：
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Write out yesterday''s results:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出昨天的结果：
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Write out today''s results:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出今天的结果：
- en: '[PRE74]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, write the summary values using the `Difference` properties:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`Difference`属性写入摘要值：
- en: '[PRE75]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finish off the `do-while` loop, exiting if the user enters an empty string:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`do-while`循环，如果用户输入空字符串，则退出：
- en: '[PRE76]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Running the console and entering distances of `1000` and `900` produces the
    following results:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台并输入`1000`和`900`的距离会产生以下结果：
- en: '[PRE77]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The program will run in a loop until you enter a blank value. You will notice
    a different output as the `JourneyTime` is set using a random value returned by
    an instance of `Random` class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将在循环中运行，直到您输入空白值。您会注意到不同的输出，因为`JourneyTime`是使用`Random`类的实例返回的随机值设置的。
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/EJTtS](https://packt.link/EJTtS).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/EJTtS](https://packt.link/EJTtS)找到此练习使用的代码。
- en: In this exercise, you have seen how a `Func<Car, double>` delegate is used to
    create general-purpose code that can be easily reused without the need to create
    extra interfaces or classes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已经看到了如何使用`Func<Car, double>`委托来创建通用代码，而无需创建额外的接口或类。
- en: Now it is time to look at the second important aspect of deletes and their ability
    to chain multiple target methods together.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看一下委托的第二个重要方面，即它们能够将多个目标方法链接在一起。
- en: Multicast Delegates
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播委托
- en: So far, you have invoked delegates that have a single method assigned, typically
    in the form of a function call. Delegates offer the ability to combine a list
    of methods that are executed with a single invocation call, using the `+=` operator,
    any number of additional target methods can be added to the target list. Every
    time the delegate is invoked, each one of the target methods gets invoked too.
    But what if you decide you want to remove a target method? That is where the `-=`
    operator is used.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经调用了具有单个分配方法的委托，通常以函数调用的形式。委托提供了将一系列方法组合在一起并使用`+=`运算符进行单次调用的能力，可以将任意数量的附加目标方法添加到目标列表中。每次调用委托时，每个目标方法都会被调用。但是，如果您决定要删除目标方法怎么办？这就是`-=`运算符的用法。
- en: 'In the following code snippet, you have an `Action<string>` delegate named
    `logger`. It starts with a single target method, `LogToConsole`. If you were to
    invoke this delegate, passing in a string, then the `LogToConsole` method will
    be called once:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，您有一个名为`logger`的`Action<string>`委托。它以单个目标方法`LogToConsole`开始。如果您调用此委托并传入一个字符串，那么`LogToConsole`方法将被调用一次：
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If you were to watch the call stack, you would observe these calls:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察调用堆栈，您将观察到这些调用：
- en: '[PRE79]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To add a new target method, you use the `+=` operator. The following statement
    adds `LogToFile` to the `logger` delegate''s invocation list:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新的目标方法，您可以使用`+=`运算符。以下语句将`LogToFile`添加到`logger`委托的调用列表中：
- en: '[PRE80]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, every time you invoke `logger`, both `LogToConsole` and `LogToFile` will
    be called. Now invoke `logger` a second time:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次调用`logger`时，都会调用`LogToConsole`和`LogToFile`。现在再次调用`logger`：
- en: '[PRE81]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The call stack looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 调用堆栈如下所示：
- en: '[PRE82]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Again, suppose you use `+=` to add a third target method called `LogToDataBase`
    as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设您使用`+=`添加第三个目标方法，称为`LogToDataBase`，如下所示：
- en: '[PRE83]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now invoke it once again:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次调用它：
- en: '[PRE84]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The call stack looks like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 调用堆栈如下所示：
- en: '[PRE85]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'However, consider that you may no longer want to include `LogToFile` in the
    target method list. In such a case, simply use the `-=` operator to remove it,
    as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请考虑您可能不再想在目标方法列表中包括`LogToFile`。在这种情况下，只需使用`-=`运算符将其删除，如下所示：
- en: '[PRE86]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can again invoke the delegate as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式再次调用委托：
- en: '[PRE87]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And now, the call stack looks like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用堆栈如下所示：
- en: '[PRE88]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As can be seen, this code resulted in just `LogToConsole` and `LogToDataBase`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，此代码仅导致`LogToConsole`和`LogToDataBase`。
- en: By using delegates in this way, you can decide which target methods get called
    based on certain criteria at runtime. This allows you to pass this configured
    delegate into other methods, to be invoked as and when needed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式使用委托，您可以根据运行时的某些条件决定调用哪些目标方法。这使您可以将配置的委托传递到其他方法中，以在需要时调用。
- en: You have seen that `Console.WriteLine` can be used to write messages to the
    console window. To create a method that logs to a file (as `LogToFile` does in
    the preceding example), you need to use the `File` class from the `System.IO`
    namespace. `File` has many static methods that can be used to read and write files.
    You will not go into full details about `File` here, but it is worth mentioning
    the `File.AppendAllText` method, which can be used to create or replace a text
    file containing a string value, `File.Exists`, which is used to check for the
    existence of a file, and `File.Delete`, to delete a file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到可以使用“Console.WriteLine”将消息写入控制台窗口。要创建一个记录到文件的方法（如前面示例中的“LogToFile”），您需要使用“System.IO”命名空间中的“File”类。
    “File”有许多静态方法可用于读取和写入文件。在这里不会详细介绍“File”，但值得一提的是“File.AppendAllText”方法，它可用于创建或替换包含字符串值的文本文件，“File.Exists”用于检查文件是否存在，以及“File.Delete”用于删除文件。
- en: Now it is time to practice what you have learned through an exercise.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是练习所学知识的时间。
- en: 'Exercise 3.03: Invoking a Multicast Delegate'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.03：调用多播委托
- en: In this exercise, you will use a multicast delegate to create a cash machine
    that logs details when a user enters their PIN and asks to see their balance.
    For this, you will create a `CashMachine` class that invokes a configured **logging**
    delegate, which you can use as a controller class to decide whether messages are
    sent to the file or to the console.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用多播委托创建一个现金机，在用户输入他们的PIN并要求查看余额时记录详细信息。为此，您将创建一个“CashMachine”类，该类调用配置的**日志**委托，您可以将其用作控制器类，以决定消息是发送到文件还是控制台。
- en: You will use an `Action<string>` delegate as you do not need any values to return.
    Using `+=`, you can control which target methods get called when your delegate
    is invoked by `CashMachine`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用“Action<string>”委托，因为您不需要返回任何值。使用“+=”，您可以控制在调用“CashMachine”时调用哪些目标方法。
- en: 'Perform the following steps to do so:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来这样做：
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise03`,
    using the CLI `dotnet` command:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到“Chapter03”文件夹，并使用CLI“dotnet”命令创建一个名为“Exercise03”的新控制台应用程序：
- en: '[PRE89]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Open `Chapter03\Exercise03.csproj` and replace the entire file with these settings:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Chapter03\Exercise03.csproj”并用以下设置替换整个文件：
- en: '[PRE90]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Open `Exercise03\Program.cs` and clear the contents.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Exercise03\Program.cs”并清除内容。
- en: Add a new class called `CashMachine`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“CashMachine”的新类。
- en: 'Use the `Chapter03.Exercise03` namespace:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“Chapter03.Exercise03”命名空间：
- en: '[PRE91]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `CashMachine` constructor is passed the `Action<string>` delegate, which
    you can assign to a `readonly` class variable called `_logger`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: “CashMachine”构造函数接收“Action<string>”委托，您可以将其分配给名为“_logger”的“readonly”类变量。
- en: 'Add a `Log` helper function that checks whether the `_logger` delegate is null
    before invoking:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个“Log”辅助函数，检查“_logger”委托在调用之前是否为null：
- en: '[PRE92]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'When the `VerifyPin` and `ShowBalance` methods are called, a message should
    be logged with some details. Create these methods as follows:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用“VerifyPin”和“ShowBalance”方法时，应记录一条带有一些详细信息的消息。按照以下方式创建这些方法：
- en: '[PRE93]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, add a console app that configures a `logger` delegate that you can pass
    into a `CashMachine` object. Note that this is a common form of usage: a class
    that is responsible for deciding how messages are logged by other classes. Use
    a constant, `OutputFile`, for the filename to be used for file logging, as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个配置“logger”委托的控制台应用程序，您可以将其传递给“CashMachine”对象。请注意，这是一种常见的用法：一个负责决定其他类如何记录消息的类。使用常量“OutputFile”作为文件记录使用的文件名，如下所示：
- en: '[PRE94]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Each time the program runs, it should start with a `File.Delete` to delete
    the output file:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次程序运行时，它应该从“File.Delete”开始删除输出文件：
- en: '[PRE95]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create a delegate instance, `logger`, that starts with a single target method,
    `LogToConsole`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个委托实例“logger”，该实例以单个目标方法“LogToConsole”开始：
- en: '[PRE96]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Using the `+=` operator, add `LogToFile` as a second target method to also
    be called whenever the delegate is invoked by `CashMachine`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“+=”运算符，添加“LogToFile”作为第二个目标方法，每当“CashMachine”调用委托时也会被调用：
- en: '[PRE97]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You will implement the two target logging methods shortly; for now, create
    a `cashMachine` instance and get ready to call its methods, as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将很快实现这两个目标日志方法；现在，创建一个“cashMachine”实例，并准备调用其方法，如下所示：
- en: '[PRE98]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Prompt for a `pin` and pass it to the `VerifyPin` method:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示输入“pin”并将其传递给“VerifyPin”方法：
- en: '[PRE99]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In case you enter a blank value, then it is checked and a warning is displayed.
    This will then close the program using a `return` statement.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入空值，则会进行检查并显示警告。然后使用“return”语句关闭程序。
- en: 'Wait for the `Enter` key to be pressed before calling the `ShowBalance` method:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用“ShowBalance”方法之前，等待按下“Enter”键：
- en: '[PRE100]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now for the logging methods. They must be compatible with your `Action<string>`
    delegate. One writes a message to the console and the other appends it to the
    text file. Add these two static methods as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是记录方法的时间。它们必须与您的“Action<string>”委托兼容。一个将消息写入控制台，另一个将其附加到文本文件。按照以下方式添加这两个静态方法：
- en: '[PRE101]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Running the console app, you see that `VerifyPin` and `ShowBalance` calls are
    written to the console:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，您会看到“VerifyPin”和“ShowBalance”调用被写入控制台：
- en: '[PRE102]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'For each `logger` delegate invocation, the `LogToFile` method will also be
    called, so when opening `activity.txt`, you should see the following line:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个“logger”委托调用，“LogToFile”方法也将被调用，因此在打开“activity.txt”时，您应该看到以下行：
- en: '[PRE103]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/h9vic](https://packt.link/h9vic).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/h9vic](https://packt.link/h9vic)找到用于此练习的代码。
- en: It is important to remember that delegates are immutable, so each time you use
    the `+=` or `-=` operators, you create a **new** delegate instance. This means
    that if you alter a delegate after you have passed it to a target class, you will
    not see any changes to the methods called from inside that target class.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住委托是不可变的，因此每次使用“+=”或“-=”运算符时，都会创建一个**新的**委托实例。这意味着如果在将委托传递给目标类后更改委托，则不会看到从该目标类内部调用的方法发生任何更改。
- en: 'You can see this in action in the following example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下示例中看到这一点：
- en: '[PRE104]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'All objects in C# have a `GetHashCode()` function that returns a unique ID.
    Running the code produces this output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的所有对象都有一个返回唯一 ID 的 `GetHashCode()` 函数。运行代码会产生这个输出：
- en: '[PRE105]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: You can see that the `+=` call. This shows that the object reference is changing
    each time.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到 `+=` 调用。这表明对象引用每次都在改变。
- en: 'Now look at another example using an `Action<string>` delegate. Here, you will
    use the `+=` operator to add target methods and then use `-=` to remove the target methods:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看另一个示例，使用 `Action<string>` 委托。在这里，您将使用 `+=` 运算符添加目标方法，然后使用 `-=` 删除目标方法：
- en: '[PRE106]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You start with one target method, `LogToConsole`, and then add the same target
    method a second time. Invoking the logger delegate using `logger("Console x 2")`
    results in `LogToConsole` being called twice.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先使用一个目标方法 `LogToConsole`，然后第二次添加相同的目标方法。使用 `logger("Console x 2")` 调用 logger
    委托会导致 `LogToConsole` 被调用两次。
- en: 'You then use `-=` to remove `LogToConsole` **twice** such that had two targets
    and now you do not have any at all. Running the code produces the following output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `-=` 两次删除 `LogToConsole`，这样就有了两个目标，现在一个也没有了。运行代码会产生以下输出：
- en: '[PRE107]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'However, rather than `logger("logger is now null")` running correctly, you
    end up with an unhandled exception being thrown like so:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其正确运行 `logger("logger is now null")`，你最终会遇到一个未处理的异常被抛出，如下所示：
- en: '[PRE108]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: By removing the last target method, the `-=` operator returned a null reference,
    which you then assigned to the logger. As you can see, it is important to always
    check that a delegate is not null before trying to invoke it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除最后一个目标方法，`-=` 运算符返回了一个空引用，然后将其分配给了 logger。正如您所看到的，重要的是在尝试调用之前始终检查委托是否为空。
- en: Multicasting with a Func Delegate
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Func 委托进行多播
- en: So far, you have used `Action<string>` delegates within `Action` delegates.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经在 `Action` 委托中使用了 `Action<string>` 委托。
- en: You have seen that `Func` delegates are used when a return value is required
    from an invoked delegate. It is also perfectly legal for the C# complier to use
    `Func` delegates in multicast delegates.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到当从调用的委托中需要返回值时，使用 `Func` 委托。C# 编译器在多播委托中使用 `Func` 委托也是完全合法的。
- en: 'Consider the following example where you have a `Func<string, string>` delegate.
    This delegate supports functions that are passed a string and return a formatted
    string is returned. This could be used when you need to format an email address
    by removing the `@` sign and dot symbols:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中您有一个 `Func<string, string>` 委托。这个委托支持传入一个字符串并返回一个格式化的字符串。当您需要通过删除 `@`
    符号和点符号来格式化电子邮件地址时，可以使用这个委托：
- en: '[PRE109]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'You start by assigning the `RemoveDots` string function to `emailFormatter`
    and invoke it using the `Address` constant:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先将 `RemoveDots` 字符串函数分配给 `emailFormatter`，然后使用 `Address` 常量调用它：
- en: '[PRE110]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Then you add a second target, `RemoveAtSign`, and invoke `emailFormatter` a
    second time:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加第二个目标 `RemoveAtSign`，并第二次调用 `emailFormatter`：
- en: '[PRE111]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Running the code produces this output:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生这个输出：
- en: '[PRE112]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The first invocation returns the `admin@googlecom` string. The `RemoveAtSign`
    added to the target list, returns a value with only the `@` symbol removed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用返回 `admin@googlecom` 字符串。添加到目标列表的 `RemoveAtSign` 返回一个只删除 `@` 符号的值。
- en: Note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/fshse](https://packt.link/fshse).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/fshse](https://packt.link/fshse) 找到此示例使用的代码。
- en: Both `Func1` and `Func2` are invoked, but only the value from `Func2` is returned
    to both `ResultA` and `ResultB` variables, even though the correct arguments are
    passed in. When a `Func<>` delegate is used with multicast in this manner, all
    of the target `Func` instances are called, but the return value will be that of
    the last `Func<>` in the chain. `Func<>` is better suited in a single method scenario,
    although the compiler will still allow you to use it as a multicast delegate without
    any compilation error or warning.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`Func1` 和 `Func2` 都被调用，但只有 `Func2` 的值被返回给 `ResultA` 和 `ResultB` 变量，尽管传入了正确的参数。当以这种方式使用多播的
    `Func<>` 委托时，所有目标 `Func` 实例都会被调用，但返回值将是链中最后一个 `Func<>` 的返回值。`Func<>` 更适合于单个方法的场景，尽管编译器仍然允许您将其用作多播委托，而不会出现任何编译错误或警告。'
- en: What Happens When Things Go Wrong?
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当事情出错时会发生什么？
- en: When a delegate is invoked, all methods in the invocation list are called. In
    the case of single-name delegates, this will be one target method. What happens
    in the case of multicast delegates if one of those targets throws an exception?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用委托时，调用列表中的所有方法都会被调用。对于单个名称委托，这将是一个目标方法。如果多播委托中的一个目标抛出异常会发生什么呢？
- en: 'Consider the following code. When the `logger` delegate is invoked, by passing
    in `try log this`, you may expect the methods to be called in the order that they
    were added: `LogToConsole`, `LogToError`, and finally `LogToDebug`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码。当调用 `logger` 委托时，通过传入 `try log this`，您可能期望按照它们被添加的顺序调用方法：`LogToConsole`，`LogToError`，最后是
    `LogToDebug`：
- en: '[PRE113]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: If any target method throws an exception, such as the one you see in `LogToError`,
    then the remaining targets are **not** called.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何目标方法抛出异常，比如您在 `LogToError` 中看到的异常，那么剩下的目标就**不会**被调用。
- en: 'Running the code results in the following output:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE114]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: You will see this output because the `LogToDebug` method wasn't called at all.
    Consider a UI with multiple targets listening to a mouse button click. The first
    method fires when a button is pressed and disables the button to prevent double-clicks,
    the second method changes the button's image to indicate success, and the third
    method enables the button.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到这个输出，因为 `LogToDebug` 方法根本没有被调用。考虑一个 UI，其中有多个目标监听鼠标按钮点击。第一个方法在按下按钮时触发并禁用按钮以防止双击，第二个方法更改按钮的图像以指示成功，第三个方法启用按钮。
- en: If the second method fails, then the third method will not get called, and the
    button could remain in a disabled state with an incorrect image assigned, thereby
    confusing the user.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二种方法失败，那么第三种方法将不会被调用，按钮可能会保持禁用状态，并且分配了一个不正确的图像，从而使用户感到困惑。
- en: 'To ensure that all target methods are run regardless, you can enumerate through
    the invocation list and invoke each method manually. Take a look at the .NET `MulticastDelegate`
    type. You will find that there is a function, `GetInvocationList`, that returns
    an array of the delegate objects. This array contains the target methods that
    have been added:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保无论如何都运行所有目标方法，你可以枚举调用列表并手动调用每个方法。查看一下.NET的`MulticastDelegate`类型。你会发现有一个函数`GetInvocationList`，它返回一个委托对象的数组。这个数组包含已添加的目标方法：
- en: '[PRE115]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: You can then loop through those target methods and execute each one inside a
    `try`/`catch` block. Now practice what you learned through this exercise.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以循环遍历这些目标方法，并在`try`/`catch`块中执行每个方法。现在通过这个练习来实践你所学到的知识。
- en: 'Exercise 3.04: Ensuring All Target Methods Are Invoked in a Multicast Delegate'
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.04：确保在多播委托中调用所有目标方法
- en: Throughout this chapter, you have been using `Action<string>` delegates to perform
    various logging operations. In this exercise, you have a list of target methods
    for a logging delegate and you want to ensure that "all" target methods are invoked
    even if earlier ones fail. You may have a scenario where logging to a database
    or filesystem fails occasionally, maybe due to network issues. In such a situation,
    you will want other logging operations to at least have a chance to perform their
    logging activity.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你一直在使用`Action<string>`委托来执行各种日志记录操作。在这个练习中，你有一个日志委托的目标方法列表，你希望确保“所有”目标方法都被调用，即使之前的方法失败了。你可能会遇到偶尔由于网络问题而导致向数据库或文件系统记录日志失败的情况。在这种情况下，你希望其他日志操作至少有机会执行它们的日志记录活动。
- en: 'Perform the following steps to do so:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现：
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise04`,
    using the CLI `dotnet` command:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Chapter03`文件夹并使用CLI `dotnet`命令创建一个名为`Exercise04`的新控制台应用程序：
- en: '[PRE116]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Open `Chapter03\Exercise04.csproj` and replace the entire file with these settings:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter03\Exercise04.csproj`并用以下设置替换整个文件：
- en: '[PRE117]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Open `Exercise04\Program.cs` and clear the contents.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise04\Program.cs`并清空内容。
- en: 'Now add a static `Program` class for your console app, including `System` and,
    additionally, `System.IO` as you want to create a file:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为你的控制台应用程序添加一个静态`Program`类，包括`System`和额外的`System.IO`，因为你想要创建一个文件：
- en: '[PRE118]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Use a `const` to name the logging file. This file is created when the program executes:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`const`来命名日志文件。当程序执行时，将创建此文件：
- en: '[PRE119]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now you must define the app''s `Main` entry point. Here you delete the output
    file if it already exists. It is best to start with an empty file here, as otherwise,
    the log file will keep growing every time you run the app:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你必须定义应用程序的`Main`入口点。在这里，如果输出文件已经存在，你可以删除它。最好从一个空文件开始，否则每次运行应用程序时，日志文件都会不断增长：
- en: '[PRE120]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'You will start with `logger` having just one target method, `LogToConsole`,
    which you will add shortly:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将从`logger`只有一个目标方法`LogToConsole`开始，稍后将添加：
- en: '[PRE121]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'You use the `InvokeAll` method to invoke the delegate, passing in `"First call"`
    as an argument. This will not fail as `logger` has a single valid method and you
    will add `InvokeAll` shortly, too:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用`InvokeAll`方法来调用委托，传入`"First call"`作为参数。这不会失败，因为`logger`有一个有效的方法，你很快也会添加`InvokeAll`：
- en: '[PRE122]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The aim of this exercise is to have a multicast delegate, so add some additional
    target methods:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个练习的目的是要有一个多播委托，所以添加一些额外的目标方法：
- en: '[PRE123]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Try a second call using `InvokeAll` as follows:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用`InvokeAll`进行第二次调用，如下所示：
- en: '[PRE124]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Now for the target methods that were added to the delegate. Add the following
    code for this:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在针对添加到委托中的目标方法，添加以下代码：
- en: '[PRE125]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'You can now implement the `InvokeAll` method:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以实现`InvokeAll`方法：
- en: '[PRE126]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: It is passed an `Action<string>` delegate that matches the `logger` delegate
    type, along with an `arg` string to use when invoking each target method. Before
    that though, it is important to check that `logger` is not already null and there
    is nothing you can do with a null delegate.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 它传递了一个与`logger`委托类型匹配的`Action<string>`委托，以及在调用每个目标方法时使用的`arg`字符串。不过，在此之前，重要的是要检查`logger`是否已经为null，对于null委托，你无法做任何操作。
- en: 'Use the delegate''s `GetInvocationList()` method to get a list of all the target
    methods:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用委托的`GetInvocationList()`方法来获取所有目标方法的列表：
- en: '[PRE127]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, loop through each item in the list as follows:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式循环遍历列表中的每个项目：
- en: '[PRE128]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'After wrapping each loop element in a `try`/`catch`, cast `del` into an `Action<string>`:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个循环元素中用`try`/`catch`包装，将`del`转换为`Action<string>`：
- en: '[PRE129]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`GetInvocationList` returns each item as the base delegate type regardless
    of their actual type.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInvocationList`返回每个项目作为基本委托类型，而不考虑它们的实际类型。'
- en: 'If it is the correct type and **not** null, then it is safe to try invoking:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它是正确的类型且**不是**null，那么尝试调用是安全的：
- en: '[PRE130]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: You have added some extra details to show what is about to be invoked by using
    the delegate's `Method.Name` property.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经添加了一些额外的细节，以显示委托的`Method.Name`属性即将被调用的内容。
- en: 'Finish with a `catch` block that logs the error message if an error was caught:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后使用一个`catch`块，如果捕获到错误，则记录错误消息：
- en: '[PRE131]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Running the code, creates a file called `Exercise04.txt` with the following results:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，创建一个名为`Exercise04.txt`的文件，其中包含以下结果：
- en: '[PRE132]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You will see that it catches the error thrown by `LogToDatabase` and still allows
    `LogToFile` to be called.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现它捕获了`LogToDatabase`抛出的错误，但仍然允许调用`LogToFile`。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/Dp5H4](https://packt.link/Dp5H4).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/Dp5H4](https://packt.link/Dp5H4)找到用于这个练习的代码。
- en: It is now important to expand upon the multicast concept using events.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很重要的是要扩展使用事件的多播概念。
- en: Events
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: In the previous sections, you have created delegates and invoked them directly
    in the same method or passed them to another method for it to invoke when needed.
    By using delegates in this way, you have a simple way for code to be notified
    when something of interest happens. So far, this has not been a major problem,
    but you may have noticed that there appears to be no way to prevent an object
    that has access to a delegate from invoking it directly.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您已经创建了委托，并直接在同一方法中调用它们，或者将它们传递给另一个方法，在需要时进行调用。通过这种方式使用委托，您可以简单地让代码在感兴趣的事情发生时得到通知。到目前为止，这还不是一个主要问题，但您可能已经注意到，似乎没有办法阻止具有委托访问权限的对象直接调用它。
- en: 'Consider the following scenario: you have created an application that allows
    other programs to register for notifications when a new email arrives by adding
    their target method to a delegate that you have provided. What if a program, either
    by mistake or for malicious reasons, decides to invoke your delegate itself? This
    could quite easily overwhelm all the target methods in your invocation list. Such
    listener programs should never be allowed to invoke a delegate in this way—after
    all, they are meant to be passive listeners.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景：您创建了一个应用程序，允许其他程序通过将它们的目标方法添加到您提供的委托中来注册通知，当新的电子邮件到达时。如果一个程序，无论是出于错误还是出于恶意原因，决定自己调用您的委托会怎么样？这很容易就会压倒调用列表中的所有目标方法。这样的监听程序绝不能被允许以这种方式调用委托——毕竟，它们应该是被动的监听者。
- en: You could add extra methods that allow listeners to add or remove their target
    methods from the invocation list and shield the delegate from direct access, but
    what if you have hundreds of such delegates available in an application? That
    is a great deal of code to write.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加额外的方法，允许监听者将他们的目标方法添加或从调用列表中移除，并保护委托免受直接访问，但是如果在应用程序中有数百个这样的委托会怎么样？这需要大量的代码来编写。
- en: The `event` keyword instructs the C# complier to add extra code to ensure that
    a delegate can **only** be invoked by the class or struct that it is declared
    in. External code can add or remove target methods but is prevented from invoking
    the delegate. Attempting to do so results in a compiler error.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`关键字指示C#编译器添加额外的代码，以确保委托**只能**由声明它的类或结构调用。外部代码可以添加或移除目标方法，但不能调用委托。试图这样做会导致编译器错误。'
- en: This pattern is commonly known as the pub-sub pattern. The object raising an
    event is called the event sender or **publisher**; the object(s) receiving the
    event are called event handlers or **subscribers**.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常被称为发布-订阅模式。引发事件的对象称为事件发送者或**发布者**；接收事件的对象称为事件处理程序或**订阅者**。
- en: Defining an Event
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义事件
- en: 'The `event` keyword is used to define an event and its associated delegates.
    Its definition looks similar to the way delegates are defined, but unlike delegates,
    you cannot use the global namespace to define events:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`关键字用于定义事件及其关联的委托。它的定义看起来类似于委托的定义方式，但与委托不同的是，您不能使用全局命名空间来定义事件。'
- en: '[PRE133]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Events have four elements:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 事件有四个元素：
- en: 'Scope: An access modifier, such as `public`, `private`, or `protected`, to
    define the scope.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：访问修饰符，如`public`、`private`或`protected`，用于定义范围。
- en: The `event` keyword.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`关键字。'
- en: 'Delegate type: The associated delegate, `EventHandler` in this example.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托类型：关联的委托，在这个例子中是`EventHandler`。
- en: 'Event name: This can be anything you like, `MouseDoubleClicked`, for example.
    However, the name must be unique within the namespace.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件名称：这可以是您喜欢的任何名称，例如`MouseDoubleClicked`。但是，名称必须在命名空间内是唯一的。
- en: Events are typically associated with the inbuilt .NET delegates, `EventHandler`,
    or its generic `EventHandler<>` version. It is rare to create custom delegates
    for events, but you may find this in older legacy code created prior to the `Action`
    and generic `Action<T>` delegates.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通常与内置的.NET委托`EventHandler`或其泛型`EventHandler<>`版本相关联。很少会为事件创建自定义委托，但您可能会在旧的遗留代码中找到这种情况，这些代码是在`Action`和泛型`Action<T>`委托之前创建的。
- en: 'The `EventHandler` delegate was available in early versions of .NET. It has
    the following signature, taking a sender `object` and an `EventArgs` parameter:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventHandler`委托在早期的.NET版本中是可用的。它具有以下签名，接受一个发送者`object`和一个`EventArgs`参数：'
- en: '[PRE134]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The more recent generic-based `EventHandler<T>` delegate looks similar; it
    also takes a sender `object` and a parameter defined by the type `T`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的基于泛型的`EventHandler<T>`委托看起来类似；它也接受一个发送者`object`和由类型`T`定义的参数。
- en: '[PRE135]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The `sender` parameter is defined as `object`, allowing any type of object to
    be sent to subscribers for them to identify the sender of the event. This can
    be useful in a situation where you have a centralized method that needs to work
    on various types of objects rather than specific instances.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`sender`参数被定义为`object`，允许任何类型的对象被发送给订阅者，以便它们识别事件的发送者。这在您需要一个集中的方法来处理各种类型的对象而不是特定实例的情况下非常有用。'
- en: For example, in a UI app, you may have one subscriber that listens for an OK
    button being clicked, and a second subscriber that listens for a **Cancel** button
    being clicked–each of these could be handled by two separate methods. In the case
    of multiple checkboxes used to toggle options on or off, you could use a single
    target method that simply needs to be told that a checkbox is the sender, and
    to toggle the setting accordingly. This allows you to reuse the same checkbox
    handler rather than creating a method for every checkbox on a screen.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在UI应用程序中，您可能有一个订阅者监听OK按钮的点击，另一个订阅者监听**取消**按钮的点击——每个按钮可以由两个不同的方法处理。在使用多个复选框来切换选项的情况下，您可以使用一个单一的目标方法，只需告诉它复选框是发送者，并相应地切换设置。这允许您重用相同的复选框处理程序，而不是为屏幕上的每个复选框创建一个方法。
- en: It is not mandatory to include details of the sender when invoking an `EventHandler`
    delegate. Often, you may not want to divulge the inner workings of your code to
    the outside; in this case, it is common practice to pass a null reference to the
    delegate.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`EventHandler`委托时，不是强制包含发送者的详细信息。通常，您可能不希望向外界透露代码的内部工作方式；在这种情况下，将一个空引用传递给委托是常见做法。
- en: The second argument in both delegates can be used to provide extra contextual
    information about the event (for example, was it the left or right mouse button
    that was pressed?). Traditionally, this extra information was wrapped up using
    a class derived from `EventArgs`, but that convention has been relaxed in newer
    .NET versions.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个委托中的第二个参数可以用于提供有关事件的额外上下文信息（例如，是按下了左键还是右键？）。传统上，这些额外信息是使用从`EventArgs`派生的类进行封装的，但在较新的.NET版本中，这种约定已经放宽。
- en: There are two standard .NET delegates you should for your event definition?
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个标准的.NET委托可以用于事件定义？
- en: '`EventHandler`: This can be used when there is no extra information to describe
    the event. For example, a checkbox click event may not need any extra information,
    it was simply clicked. In this case, it is perfectly valid to pass null or `EventArgs.Empty`
    as the second parameter. This delegate can often be found in legacy apps that
    use a class derived from `EventArgs` to describe the event further. Was it a double-click
    of the mouse that triggered this event? In this case, a `Clicks` property may
    have been added to an `EventArgs` derived class to provide such extra details.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventHandler`：当没有额外信息描述事件时可以使用此委托。例如，复选框点击事件可能不需要任何额外信息，只是被点击了。在这种情况下，将null或`EventArgs.Empty`作为第二个参数传递是完全有效的。这个委托通常可以在使用从`EventArgs`派生的类来进一步描述事件的旧应用程序中找到。是鼠标的双击触发了这个事件吗？在这种情况下，可能已经向`EventArgs`派生类添加了一个`Clicks`属性来提供这样的额外细节。'
- en: '`EventHandler<T>`: Since the inclusion of generics in C#, this has become the
    more frequently used delegate for events, simply because using generics requires
    fewer classes to be created.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventHandler<T>`：自从C#中引入泛型以来，这已经成为更频繁使用的事件委托，简单地因为使用泛型需要创建更少的类。'
- en: 'Interestingly, no matter what scope you give to your event (`public`, for example),
    the C# compiler will internally create a private member with that name. This is
    the key concept with events: only the class that defines the event may **invoke
    it**. Consumers are free to add or remove their interest, but they **cannot**
    invoke it themselves.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，无论您给事件赋予什么作用域（例如`public`），C#编译器都会在内部创建一个同名的私有成员。这是事件的关键概念：只有定义事件的类可以**调用它**。消费者可以自由添加或删除他们的兴趣，但他们**不能**自己调用它。
- en: When an event is defined, the publisher class in which it is defined can simply
    invoke it as and when needed, in the same way that you invoke delegates. In the
    earlier examples, a point was made of always checking that the delegate is not
    null before invoking. The same approach should be taken with events, as you have
    little control over how or when a subscriber may add or remove their target methods.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义事件时，其中定义它的发布者类可以在需要时简单地调用它，就像调用委托一样。在早期的示例中，总是强调在调用之前始终检查委托是否为null。与事件一样，应采用相同的方法，因为您无法控制订阅者何时以及如何添加或删除他们的目标方法。
- en: When a publisher class is initially created, all events have an initial value
    of null. This will change to not null when any subscriber adds a target method.
    Conversely, as soon as a subscriber removes a target method, the event will revert
    to null if there are no methods left in the invocation list and all this is handled
    by the runtime. This is the standard behavior you saw earlier with delegates.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当发布者类最初创建时，所有事件的初始值都为null。当任何订阅者添加目标方法时，这将更改为非null。相反，一旦订阅者删除目标方法，如果调用列表中没有方法了，事件将恢复为null，所有这些都由运行时处理。这是您在早期使用委托时看到的标准行为。
- en: 'You can prevent an event from ever becoming null by adding an empty delegate
    to the end of the event definition:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在事件定义的末尾添加一个空委托来防止事件永远变为null：
- en: '[PRE136]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Rather than having the default null value, you are adding your own default delegate
    instance—one that does nothing. Hence the blank between the `{}` symbols.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 您不是使用默认的null值，而是添加自己的默认委托实例——一个什么也不做的实例。因此在`{}`符号之间留空。
- en: 'There is a common pattern often followed when using events within a publisher
    class, particularly in classes that may be subclassed further. You will now see
    this with the help of a simple example:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布者类中使用事件时通常遵循一种常见模式，特别是在可能进一步被子类化的类中。现在，您将通过一个简单的示例来看到这一点：
- en: 'Define a class, `MouseClickedEventArgs`, that contains additional information
    about the event, in this case, the number of mouse clicks that were detected:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`MouseClickedEventArgs`的类，其中包含有关事件的其他信息，例如检测到的鼠标点击次数：
- en: '[PRE137]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Observe the `MouseClickPublisher` class, This has a `MouseClicked` event defined
    using the generic `EventHandler<>` delegate.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`MouseClickPublisher`类，它使用泛型`EventHandler<>`委托定义了一个`MouseClicked`事件。
- en: 'Now add the `delegate { };` block to prevent `MouseClicked` from being null
    initially:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加`delegate { };`块以防止`MouseClicked`最初为null：
- en: '[PRE138]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Add an `OnMouseClicked` virtual method that gives any further subclassed `MouseClickPublisher`
    classes a chance to suppress or change the event notification, as follows:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`OnMouseClicked`虚方法，让任何进一步子类化的`MouseClickPublisher`类有机会抑制或更改事件通知，如下所示：
- en: '[PRE139]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Now you need a method that tracks the mouse clicks. In this example, you will
    not actually show how mouse clicks are detected, but you will call `OnMouseClicked`,
    passing in `2` to indicate a double-click.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您需要一个跟踪鼠标点击的方法。在这个例子中，您实际上不会展示如何检测鼠标点击，但您将调用`OnMouseClicked`，传入`2`以指示双击。
- en: 'Notice how you have not invoked the `MouseClicked` event directly; you always
    go via the `OnMouseClicked` intermediary method. This provides a way for other
    implementations of `MouseClickPublisher` to override the event notification if
    they need to:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，您没有直接调用 `MouseClicked` 事件；您总是通过中间方法 `OnMouseClicked` 进行。这为其他 `MouseClickPublisher`
    的实现提供了一种覆盖事件通知的方式，如果需要的话：
- en: '[PRE140]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now add a new type of publisher that is based on `MouseClickPublisher`:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个基于 `MouseClickPublisher` 的新类型的发布者：
- en: '[PRE141]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This `MouseSingleClickPublisher` overrides the `OnMouseClicked` method and only
    calls the base `OnMouseClicked` if a single click was detected. By implementing
    this type of pattern, you allow different types of publishers to control whether
    events are fired to subscribers in a customized manner.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `MouseSingleClickPublisher` 覆盖了 `OnMouseClicked` 方法，并且只有在检测到单击时才调用基本的 `OnMouseClicked`。通过实现这种类型的模式，您可以允许不同类型的发布者以定制的方式控制事件是否传递给订阅者。
- en: Note
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/J1EiB](https://packt.link/J1EiB).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/J1EiB](https://packt.link/J1EiB) 找到此示例的代码。
- en: You can now practice what you learned through the following exercise.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过以下练习来练习所学到的知识。
- en: 'Exercise 3.05: Publishing and Subscribing to Events'
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.05：发布和订阅事件
- en: In this exercise, you will create an alarm clock as an example of a publisher.
    The alarm clock will simulate a `Ticked` event. You will also add a `WakeUp` event
    that is published when the current time matches an alarm time. In .NET, `DateTime`
    is used to represent a point in time, so you will use that for the current time
    and alarm time properties. You will use `DateTime.Subtract` to get the difference
    between the current time and the alarm time and publish the `WakeUp` event when
    it is due.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个闹钟作为发布者的示例。闹钟将模拟 `Ticked` 事件。您还将添加一个 `WakeUp` 事件，当当前时间匹配闹钟时间时发布。在
    .NET 中，`DateTime` 用于表示时间点，因此您将用它来表示当前时间和闹钟时间属性。您将使用 `DateTime.Subtract` 来获取当前时间和闹钟时间之间的差异，并在到期时发布
    `WakeUp` 事件。
- en: 'Perform the following steps to do so:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise05`,
    using the CLI `dotnet` command:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Chapter03` 文件夹，并使用 CLI `dotnet` 命令创建一个名为 `Exercise05` 的新控制台应用程序：
- en: '[PRE142]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Open `Chapter03\Exercise05.csproj` and replace the entire file with these settings:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Chapter03\Exercise05.csproj` 并用以下设置替换整个文件：
- en: '[PRE143]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Open `Exercise05\Program.cs` and clear the contents.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Exercise05\Program.cs` 并清空内容。
- en: 'Add a new class called `AlarmClock`. Here you need to use a `DateTime` class,
    so include the `System` namespace:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `AlarmClock` 的新类。在这里，您需要使用 `DateTime` 类，因此包括 `System` 命名空间：
- en: '[PRE144]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: You will offer two events for subscribers to listen to—`WakeUp`, based on the
    non-generic `EventHandler` delegate (since you will not pass any extra information
    in this event), and `Ticked`, which uses the generic `EventHandler` delegate with
    a `DateTime` parameter type.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您将为订阅者提供两个事件来监听——`WakeUp`，基于非泛型的 `EventHandler` 委托（因为您不会在此事件中传递任何额外信息），以及使用泛型
    `EventHandler` 委托和 `DateTime` 参数类型的 `Ticked`。
- en: 'You will use this to pass along the current time to display in the console.
    Notice that both have the initial `delegate {};` safety mechanism:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用此方法将当前时间传递给控制台显示。请注意，两者都具有初始的 `delegate {};` 安全机制：
- en: '[PRE145]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Include an `OnWakeUp` override as an example, but do not do the same with `Ticked`;
    this is to show the different invocation approaches:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括一个 `OnWakeUp` 覆盖作为示例，但不要对 `Ticked` 做同样的操作；这是为了展示不同的调用方法：
- en: '[PRE146]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Now add two `DateTime` properties, the alarm and clock times, as follows:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加两个 `DateTime` 属性，闹钟和时钟时间，如下所示：
- en: '[PRE147]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'A `Start` method is used to start the clock. You simulate a clock ticking once
    every minute for `24 hours` using a simple loop as follows:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Start` 方法用于启动时钟。您使用一个简单的循环模拟每分钟一次的时钟滴答声，持续 `24 小时`，如下所示：'
- en: '[PRE148]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'For each simulated minute, increment the clock using `DateTime.AddMinute` and
    publish the `Ticked` event, passing in `this` (the `AlarmClock` sender instance)
    and the clock time:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个模拟的分钟，使用 `DateTime.AddMinute` 增加时钟并发布 `Ticked` 事件，传入 `this`（`AlarmClock`
    发送方实例）和时钟时间：
- en: '[PRE149]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '`ClockTime.Subtract` is used to calculate the difference between the click
    and alarm times.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClockTime.Subtract` 用于计算点击和闹钟时间之间的差异。'
- en: 'You pass the `timeRemaining` value to the local function, `IsTimeToWakeUp`,
    calling the `OnWakeUp` method and break out of the loop if it is time to wake
    up:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `timeRemaining` 值传递给本地函数 `IsTimeToWakeUp`，调用 `OnWakeUp` 方法，并在该时间到达时退出循环：
- en: '[PRE150]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Use the `IsTimeToWakeUp`, a relational pattern, to see whether there is less
    than one minute remaining. Add the following code for this:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用关系模式 `IsTimeToWakeUp` 来查看是否剩余不到一分钟。添加以下代码：
- en: '[PRE151]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Now add a console app that subscribes to the alarm clock and its two events
    by starting from the static void `Main` entry point:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个控制台应用程序，通过从静态 void `Main` 入口点开始订阅闹钟及其两个事件：
- en: '[PRE152]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Create the `AlarmClock` instance and use the `+=` operator to subscribe to
    the `Ticked` event and the `WakeUp` events. You will define `ClockTicked` and
    `ClockWakeUp` shortly. For now, just add the following code:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `AlarmClock` 实例，并使用 `+=` 运算符订阅 `Ticked` 事件和 `WakeUp` 事件。您将很快定义 `ClockTicked`
    和 `ClockWakeUp`。现在，只需添加以下代码：
- en: '[PRE153]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Set the clock''s current time, use `DateTime.AddMinutes` to add `120` minutes
    to the alarm time, and then start the clock, as follows:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置时钟的当前时间，使用 `DateTime.AddMinutes` 来将 `120` 分钟添加到闹钟时间，然后启动时钟，如下所示：
- en: '[PRE154]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Finish off `Main` by prompting for the `Enter` key to be pressed:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提示按下 `Enter` 键来完成 `Main`：
- en: '[PRE155]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Now you can add the event subscriber local methods:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以添加事件订阅者本地方法：
- en: '[PRE156]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '`ClockWakeUp` is passed sender and `EventArgs` arguments. You don''t use either
    of these, but they are required for the `EventHandler` delegate. When this subscriber''s
    method is called, you write `"Wake up"` to the console.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClockWakeUp` 传递了发送方和 `EventArgs` 参数。您两者都没有使用，但它们是 `EventHandler` 委托所需的。当调用此订阅者的方法时，您将在控制台中写入
    `"Wake up"`。'
- en: '`ClockTicked` is passed the `DateTime` argument as required by the `EventHandler<DateTime>`
    delegate. Here, you pass the current time, so you write that to the console using
    `:t` to show the time in a short format:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ClockTicked`按照`EventHandler<DateTime>`委托所需的方式传递`DateTime`参数。在这里，您传递当前时间，因此使用`:t`将其以短格式显示在控制台上：'
- en: '[PRE157]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Running the app produces this output:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序会产生以下输出：
- en: '[PRE158]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: In this example you see that the alarm clock simulates a tick every minute and
    publishes a `Ticked` event.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以看到闹钟模拟每分钟发出一次滴答声并发布`Ticked`事件。
- en: Note
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/GPkYQ](https://packt.link/GPkYQ).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/GPkYQ](https://packt.link/GPkYQ)找到用于此练习的代码。
- en: Now it is time to grasp the difference between events and delegates.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候理解事件和委托之间的区别了。
- en: Events or Delegates?
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件还是委托？
- en: 'On the face of it, events and delegates look remarkably similar:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，事件和委托看起来非常相似：
- en: Events are an extended form of delegates.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件是委托的扩展形式。
- en: Both offer **late-bound** semantics, so rather than calling methods that are
    known precisely at compile-time, you can defer a list of target methods when known
    at runtime.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都提供**后期绑定**语义，因此不是在编译时精确知道要调用的方法，而是在运行时知道时，可以推迟一系列目标方法。
- en: Both are `Invoke()` or, more simply, the `()` suffix shortcut, ideally with
    a null check before doing so.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都是`Invoke()`，或者更简单地说，是`()`后缀的快捷方式，在这样做之前最好进行空值检查。
- en: 'The key considerations are as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 关键考虑因素如下：
- en: 'Optionality: Events offer an optional approach; callers can decide to opt into
    events or not. If your component can complete its task without needing any subscriber
    methods, then it is preferable to use an event-based approach.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选性：事件提供一种可选的方法；调用者可以决定是否选择事件。如果您的组件可以在不需要任何订阅者方法的情况下完成其任务，那么最好使用基于事件的方法。
- en: 'Return types: Do you need to handle return types? Delegates associated with
    events are always void.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型：您需要处理返回类型吗？与事件相关的委托始终是void。
- en: 'Lifetime: Event subscribers typically have a shorter lifetime than their publishers,
    leaving the publisher to continue detecting new messages even if there are no
    active subscribers.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期：事件订阅者通常比发布者的生命周期更短，即使没有活跃的订阅者，发布者仍然会继续检测新消息。
- en: Static Events Can Cause Memory Leaks
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态事件可能会导致内存泄漏
- en: Before you wrap up your look at events, it pays to be **careful** when using
    events, particularly those that are statically defined.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束查看事件之前，使用事件时要**小心**。
- en: Whenever you add a subscriber's target method to a publisher's event, the publisher
    class will store a reference to your target method. When you have finished using
    a subscriber instance and it remains attached to a `static` publisher, it is possible
    that the memory used by your subscriber will not be cleared up.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 每当将订阅者的目标方法添加到发布者的事件中时，发布者类将存储对目标方法的引用。当您完成使用订阅者实例并且它仍然附加到`static`发布者时，可能会导致订阅者使用的内存不会被清除。
- en: These are often referred to as orphaned, phantom, or ghost events. To prevent
    this, always try to pair up each `+=` call with a corresponding `-=` operator.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常被称为孤立、幻影或幽灵事件。为了防止这种情况发生，始终尝试将每个`+=`调用与相应的`-=`运算符配对。
- en: Note
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reactive Extensions (Rx) ([https://github.com/dotnet/reactive](https://github.com/dotnet/reactive))
    is a great library for leveraging and taming event-based and asynchronous programming
    using LINQ-style operators. Rx provides a way to time-shift, for example, buffering
    a very chatty event into manageable streams with just a few lines of code. What's
    more, Rx streams are very easy to unit test, allowing you to effectively take
    control of time.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式扩展（Rx）([https://github.com/dotnet/reactive](https://github.com/dotnet/reactive))是一个很棒的库，可以利用和驯服基于事件和异步编程，使用LINQ风格的操作符。Rx提供了一种时移的方法，例如，用几行代码将一个非常喧闹的事件缓冲成可管理的流。而且，Rx流非常容易进行单元测试，可以有效地控制时间。
- en: Now read about the interesting topic of lambda expressions.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在阅读有关lambda表达式的有趣主题。
- en: Lambda Expressions
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: 'Throughout the previous sections, you have mainly used class-level methods
    as targets for your delegates and events, such as the `ClockTicked` and `ClockWakeUp`
    methods, that were also used in *Exercise 3.05*:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您主要使用了类级别的方法作为委托和事件的目标，例如`ClockTicked`和`ClockWakeUp`方法，这些方法也在*Exercise
    3.05*中使用过：
- en: '[PRE159]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The `ClockWakeUp` and `ClockTicked` methods are easy to follow and step through.
    However, by converting them into lambda expression syntax, you can have a more
    succinct syntax and closer proximity to where they are in code.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClockWakeUp`和`ClockTicked`方法易于理解和逐步执行。然而，通过将它们转换为lambda表达式语法，您可以获得更简洁的语法，并且更接近它们在代码中的位置。'
- en: 'Now convert the `Ticked` and `WakeUp` events to use two different lambda expressions:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`Ticked`和`WakeUp`事件转换为使用两个不同的lambda表达式：
- en: '[PRE160]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: You have used the same `+=` operator, but instead of method names, you see `(sender,
    e) =>` and identical blocks of code, as seen in `ClockTicked` and `ClockWakeUp`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用了相同的`+=`运算符，但是不是方法名称，而是看到了`(sender, e) =>`和相同的代码块，就像在`ClockTicked`和`ClockWakeUp`中看到的那样。
- en: 'When defining a lambda expression, you can pass any parameters within parentheses,
    `()`, followed by `=>` (this is often read as **goes to**), and then by your expression/statement
    block:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义lambda表达式时，您可以在括号`()`内传递任何参数，然后是`=>`（这经常被读作**转到**），然后是您的表达式/语句块：
- en: '[PRE161]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The code block can be as complex as you need and can return a value if it is
    a `Func`-based delegate.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块可以尽您需要的那样复杂，并且如果是基于`Func`的委托，可以返回一个值。
- en: The compiler can normally infer each of the parameter types, so you do not even
    need to specify their types. Moreover, you can omit the parentheses if there is
    only one argument and the compiler can infer its type.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常可以推断出每个参数的类型，因此您甚至不需要指定它们的类型。此外，如果只有一个参数且编译器可以推断出其类型，您可以省略括号。
- en: Wherever a delegate (remember that `Action`, `Action<T>`, and `Func<T>` are
    inbuilt examples of a delegate) needs to be used as an argument, rather than creating
    a class or local method or function, you should consider using a lambda expression.
    The main reason is that this often results in less code, and that code is placed
    closer to the location where it is used.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时需要使用委托（记住`Action`、`Action<T>`和`Func<T>`是内置的委托示例），而不是创建类或本地方法或函数，您都应该考虑使用lambda表达式。主要原因是这通常会导致更少的代码，并且该代码放置在使用它的位置附近。
- en: 'Now consider another example on Lambda. Given a list of movies, you can use
    the `List<string>` class to store these string-based names, as shown in the following snippet:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑Lambda的另一个例子。给定一个电影列表，您可以使用`List<string>`类来存储这些基于字符串的名称，如下所示：
- en: '[PRE162]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'You can use the `List.Sort` method to sort the names alphabetically (the final
    output will be shown at the end of this example):'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`List.Sort`方法按字母顺序对名称进行排序（最终输出将在本示例结束时显示）：
- en: '[PRE163]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'If you need more control over how this sort works, the `List` class has another
    `Sort` method that accepts a delegate of this form: `delegate int Comparison<T>(T
    x, T y)`. This delegate is passed two arguments of the same type (`x` and `y`)
    and returns an `int` value. The `int` value can be used to define the sort order
    of items in the list without you having to worry about the internal workings of
    the `Sort` method.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多控制如何进行排序，`List`类还有另一个接受此形式委托的`Sort`方法：`delegate int Comparison<T>(T x,
    T y)`。这个委托传递了相同类型的两个参数（`x`和`y`），并返回一个`int`值。`int`值可以用来定义列表中项目的排序顺序，而无需担心`Sort`方法的内部工作。
- en: As an alternative, you can sort the names to exclude `"The"` from the beginning
    of movie titles. This is often used as an alternative way to list names. You can
    achieve this by passing a lambda expression, using the `( )` syntax to wrap two
    strings, `x, y`, that will be passed by `Sort()` when it invokes your lambda.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一种选择，您可以对名称进行排序，从电影标题开头排除“the”。这通常被用作列出名称的另一种方式。您可以通过传递一个lambda表达式来实现这一点，使用`(
    )`语法来包装两个字符串`x, y`，当`Sort()`调用您的lambda时，这两个字符串将被传递。
- en: 'If `x` or `y` starts with your noise word, `"The"`, then you use the `string.Substring`
    function to skip the first four characters. `String.Compare` is then used to return
    a numeric value that compares the resulting string values, as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`或`y`以您的噪声词“the”开头，那么您可以使用`string.Substring`函数跳过前四个字符。然后使用`String.Compare`返回一个比较生成的字符串值的数值，如下所示：
- en: '[PRE164]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'You can then write out the sorted results to the console:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将排序后的结果写入控制台：
- en: '[PRE165]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Running the example code produces the following output:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例代码会产生以下输出：
- en: '[PRE166]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: You can see that the second set of names is sorted with `"The"` is ignored.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到第二组名称是按照忽略“the”进行排序的。
- en: Note
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [http://packt.link/B3NmQ](http://packt.link/B3NmQ).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://packt.link/B3NmQ](http://packt.link/B3NmQ)找到此示例中使用的代码。
- en: To see these lambda statements put into practice, try your hand at the following exercise.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这些lambda语句付诸实践，请尝试以下练习。
- en: 'Exercise 3.06: Using a Statement Lambda to Reverse Words in a Sentence'
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.06：使用语句Lambda来反转句子中的单词
- en: In this exercise, you are going to create a utility class that splits the words
    in a sentence and returns that sentence with the words in reverse order.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个实用程序类，它会拆分句子中的单词，并返回单词顺序相反的句子。
- en: 'Perform the following steps to do so:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现：
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise06`,
    using the CLI `dotnet` command:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Chapter03`文件夹并使用CLI`dotnet`命令创建一个名为`Exercise06`的新控制台应用程序：
- en: '[PRE167]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Open `Chapter03\Exercise06.csproj` and replace the entire file with these settings:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter03\Exercise06.csproj`并用以下设置替换整个文件：
- en: '[PRE168]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Open `Exercise02\Program.cs` and clear the contents.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise02\Program.cs`并清空内容。
- en: 'Add a new class named `WordUtilities` with a string function called `ReverseWords`.
    You need to include the `System.Linq` namespace to help with the string operations:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`WordUtilities`的新类，其中包含一个名为`ReverseWords`的字符串函数。您需要包括`System.Linq`命名空间来帮助进行字符串操作：
- en: '[PRE169]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Define a `Func<string, string>` delegate called `swapWords` that takes a string
    input and returns a string value:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`swapWords`的`Func<string, string>`委托，它接受一个字符串输入并返回一个字符串值：
- en: '[PRE170]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'You will accept a string input argument named `phrase`:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将接受一个名为`phrase`的字符串输入参数：
- en: '[PRE171]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Now for the lambda statement body. Use the `string.Split` function to split
    the `phrase` string into an array of strings using a space as the splitting character:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是lambda语句体。使用`string.Split`函数将`phrase`字符串按空格拆分为字符串数组：
- en: '[PRE172]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '`String.Reverse` reverses the order of strings in the array, before finally
    joining the reversed words string array in a single string using `string.Join`.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.Reverse`反转数组中字符串的顺序，最后使用`string.Join`将反转的单词字符串数组连接成一个字符串。'
- en: 'You have defined the required `Func`, so invoke it by passing the sentence
    parameter and returning that as the result:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经定义了所需的`Func`，现在通过传递句子参数来调用它，并将其作为结果返回：
- en: '[PRE173]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Now for a console app that prompts for a sentence to be entered, which is passed
    to `WordUtilities.ReverseWords`, with the result being written to the console:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个控制台应用程序，提示输入一个句子，将其传递给`WordUtilities.ReverseWords`，并将结果写入控制台：
- en: '[PRE174]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Running the console app produces results output similar to this:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生类似于以下内容的结果输出：
- en: '[PRE175]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Note
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/z12sR](https://packt.link/z12sR).
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/z12sR](https://packt.link/z12sR)找到此练习中使用的代码。
- en: You will conclude this look at lambdas with some of the less obvious issues
    that you might not expect to see when running and debugging.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 您将通过一些不太明显的问题来结束对lambda的探讨，这些问题在运行和调试时可能出乎您的意料。
- en: Captures and Closures
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获和闭包
- en: Lambda expressions can **capture** any of the variables or parameters within
    the method where they are defined. The word capture is used to describe the way
    that a lambda expression captures or reaches up into the parent method to access
    any variables or parameters.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以**捕获**方法内的任何变量或参数。捕获一词用于描述lambda表达式捕获或访问父方法中的任何变量或参数的方式。
- en: 'To grasp this better, consider the following example. Here you will create
    a `Func<int, string>` called `joiner` that joins words together using the `Enumerable.Repeat`
    method. The `word` variable (known as an `Outer Variables`) is captured inside
    the body of the `joiner` expression:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，请考虑以下示例。在这里，您将创建一个名为`joiner`的`Func<int, string>`，它使用`Enumerable.Repeat`方法将单词连接在一起。`word`变量（称为`Outer
    Variables`）被捕获在`joiner`表达式的主体内部：
- en: '[PRE176]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Running the preceding example produces the following output:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的例子会产生以下输出：
- en: '[PRE177]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: You invoked the `joiner` delegate by passing `2` as an argument. At that moment
    in time, the outer `word` variable has a value of `"hello"`, which is repeated
    twice.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过传递`2`作为参数来调用`joiner`委托。在那一刻，外部`word`变量的值为`"hello"`，这个值被重复两次。
- en: 'This confirms that captured variables, from the parent method, were evaluated
    `Func` was invoked. Now change the value of `word` from `hello` to `goodbye` and
    invoke `joiner` once again, passing `3` as the argument:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了从父方法中捕获的变量在调用`Func`时被评估。现在将`word`的值从`hello`更改为`goodbye`，再次调用`joiner`，并将`3`作为参数传递：
- en: '[PRE178]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Running this example produces the following output:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例会产生以下输出：
- en: '[PRE179]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: It is worth remembering that it does not matter where in the code you defined
    `joiner`. You could have changed the value of `word` to any number of strings
    before or after declaring `joiner`.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，无论您在代码中的何处定义了`joiner`，都不重要。在声明`joiner`之前或之后，您可以将`word`的值更改为任意数量的字符串。
- en: 'Taking captures one step further, if you define a variable with the same name
    inside a lambda, it will be scoped `word`, which will have no effect on the outer
    variable with the same name:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步地，如果您在lambda内部定义了与外部同名的变量，它将被作用域化为`word`，这对同名的外部变量没有影响：
- en: '[PRE180]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The preceding example results in the following output. Notice how the outer
    variable, `word`, remains unchanged from `goodbye`:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例导致以下输出。请注意外部变量`word`如何保持不变，仍为`goodbye`：
- en: '[PRE181]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Finally, you will look at the concept of closures that is a subtle part of the
    C# language and often leads to unexpected results.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将了解闭包的概念，这是C#语言中微妙的部分，经常导致意想不到的结果。
- en: 'In the following example, you have a variable, `actions`, that contains a `List`
    of `Action` delegates. You use a basic `for` loop to add five separate `Action`
    instances to the list. The lambda expression for each `Action` simply writes that
    value of `i` from the `for` loop to the console. Finally, the code simply runs
    through each `Action` in the `actions` list and invokes each one:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，您有一个名为`actions`的变量，其中包含`Action`委托的`List`。您使用基本的`for`循环将五个单独的`Action`实例添加到列表中。每个`Action`的lambda表达式只是将`for`循环中的`i`的值写入控制台。最后，代码只是运行`actions`列表中的每个`Action`并调用每个动作：
- en: '[PRE182]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Running the example produces the following output:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生以下输出：
- en: '[PRE183]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The reason why `MyAction: i` did not start from `0` is that the value of `i`,
    when accessed from inside a `Action` delegate, is only evaluated once the `Action`
    is invoked. By the time each delegate is invoked, the outer loop has already repeated
    five times over.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAction: i`之所以没有从`0`开始，是因为当从`Action`委托内部访问`i`的值时，只有在调用`Action`时才会计算。在每次调用委托时，外部循环已经重复了五次。'
- en: Note
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/vfOPx](https://packt.link/vfOPx).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/vfOPx](https://packt.link/vfOPx)找到此示例的代码。
- en: This is similar to the capture concept you observed, where the outer variables,
    `i` in this case, are only evaluated when invoked. You used `i` in the `for` loop
    to add each `Action` to the list, but by the time you invoked each action, `i`
    had its final value of `5`.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于您观察到的捕获概念，其中外部变量，此处为`i`，只有在调用时才会被计算。您在`for`循环中使用`i`来将每个`Action`添加到列表中，但在调用每个动作时，`i`已经具有最终值`5`。
- en: This can often lead to unexpected behavior, especially if you assume that an
    `i` is being used inside each action's loop variable. To ensure that the incrementing
    value of `i` is used inside each lambda expression, you need to introduce a `for`
    loop, one that takes a copy of the iterator variable.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会导致意外的行为，特别是如果您假设在每个动作的循环变量中使用了`i`。为了确保在每个lambda表达式中使用递增值`i`，您需要引入一个`for`循环，它会复制迭代器变量。
- en: 'In the following code snippet, you have added the `closurei` variable. It looks
    very subtle, but you now have a more locally scoped variable, which you access
    from inside the lambda expression, rather than the iterator, `i`:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，您已经添加了`closurei`变量。它看起来非常微妙，但现在您有了一个更局部作用域的变量，您可以从lambda表达式内部访问它，而不是迭代器`i`：
- en: '[PRE184]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Running the example produces the following output. You can see that the incrementing
    value is used when each `Action` is invoked, rather than the value of `5` that
    you saw earlier:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生以下输出。您可以看到在每次调用`Action`时都使用递增值，而不是您之前看到的`5`的值：
- en: '[PRE185]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: You have covered the key aspects of delegates and events in event-driven applications.
    You extended this by using the succinct coding style offered by lambdas, to be
    notified when events of interest occur.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经涵盖了委托和事件在事件驱动应用程序中的关键方面。您通过使用lambda提供的简洁编码风格来扩展了这一点，以便在发生感兴趣的事件时得到通知。
- en: You will now bring these ideas together into an activity in which you will use
    some of the inbuilt .NET classes with their own events. You will need to adapt
    these events to your own format and publish so they can be subscribed to by a
    console app.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将把这些想法结合到一个活动中，在这个活动中，您将使用一些内置的.NET类及其自己的事件。您需要调整这些事件以适应您自己的格式，并发布，以便可以由控制台应用程序订阅。
- en: Now it is time to practice all you have learned through the following activity.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过以下活动来练习您所学到的所有知识了。
- en: 'Activity 3.01: Creating a Web File Downloader'
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.01：创建Web文件下载器
- en: You plan to investigate patterns in US storm events. To do this, you need to
    download storm event datasets from online sources for later analysis. The National
    Oceanic and Atmospheric Administration is one such source of data and can be accessed
    from [https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles](https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 您计划调查美国风暴事件中的模式。为此，您需要从在线来源下载风暴事件数据集，以供以后分析。美国国家海洋和大气管理局是这样的数据来源之一，可以从[https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles](https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles)访问。
- en: You are tasked with creating a .NET Core console app that allows a web address
    to be entered, the contents of which are downloaded to a local disk. To be as
    user-friendly as possible, the application needs to use events that signal when
    an invalid address is entered, the progress of a download, and when it completes.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是创建一个.NET Core控制台应用程序，允许输入网址，其内容将被下载到本地磁盘。为了尽可能用户友好，应用程序需要使用事件来信号当输入无效地址时，下载的进度以及下载完成时。
- en: Ideally, you should try to hide the internal implementation that you use to
    download files, preferring to adapt any events that you use to ones that your
    caller can subscribe to. This form of adaption is often used to make code more
    maintainable by hiding internal details from callers.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您应该尝试隐藏用于下载文件的内部实现，而是倾向于调整您使用的任何事件，使其适用于您的调用者可以订阅的事件。这种调整形式通常用于通过隐藏内部细节来使代码更易于维护。
- en: 'For this purpose, the `WebClient` class in C# can be used for download requests.
    As with many parts of .NET, this class returns objects that implement the `IDisposable`
    interface. This is a standard interface and it indicates that the object you are
    using should be wrapped in a `using` statement to ensure that any resources or
    memory are cleaned away for you when you have finished using the object. `using`
    takes this format:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，C#中的`WebClient`类可以用于下载请求。与.NET的许多部分一样，这个类返回实现`IDisposable`接口的对象。这是一个标准接口，它表示您正在使用的对象应该被包装在`using`语句中，以确保在您使用完对象后，任何资源或内存都被清除。`using`采用以下格式：
- en: '[PRE186]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Finally, the `WebClient.DownloadFileAsync` method downloads files in the background.
    Ideally, you should use a mechanism that allows one part of your code to `System.Threading.ManualResetEventSlim`
    is a class that has `Set` and `Wait` methods that can help with this type of signaling.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`WebClient.DownloadFileAsync`方法在后台下载文件。理想情况下，您应该使用一种机制，允许代码的一部分`System.Threading.ManualResetEventSlim`是一个具有`Set`和`Wait`方法的类，可以帮助进行此类信号传递。
- en: 'For this activity, you will need to perform the following steps:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，您需要执行以下步骤：
- en: Add a progress changed `EventArgs` class (an example name could be `DownloadProgressChangedEventArgs`)
    that can be used when publishing progress events. This should have `ProgressPercentage`
    and `BytesReceived` properties.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个进度更改`EventArgs`类（一个示例名称可以是`DownloadProgressChangedEventArgs`），在发布进度事件时可以使用。这应该有`ProgressPercentage`和`BytesReceived`属性。
- en: The `WebClient` class from `System.Net` should be used to download a requested
    web file. You should create an adapter class (a suggested name is `WebClientAdapter`)
    that hides your internal usage of `WebClient` from your callers.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用`System.Net`中的`WebClient`类来下载所请求的网络文件。您应该创建一个适配器类（建议的名称是`WebClientAdapter`），它可以隐藏您对`WebClient`的内部使用，使其对您的调用者不可见。
- en: Your adapter class should provide three events—`DownloadCompleted`, `DownloadProgressChanged`,
    and `InvalidUrlRequested`—that a caller can subscribe to.
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的适配器类应该提供三个事件——`DownloadCompleted`，`DownloadProgressChanged`和`InvalidUrlRequested`——供调用者订阅。
- en: The adapter class will need a `DownloadFile` method that calls the `WebClient`
    class's `DownloadFileAsync` method to start the download request. This requires
    converting a string-based web address into a Uniform Resource Identifier (URI)
    class. The `Uri.TryCreate()` method can create an absolute address from the string
    entered via the console. If the call to `Uri.TryCreate` fails, you should publish
    the `InvalidUrlRequested` event to indicate this failure.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器类将需要一个`DownloadFile`方法，该方法调用`WebClient`类的`DownloadFileAsync`方法来启动下载请求。这需要将基于字符串的网址转换为统一资源标识符（URI）类。`Uri.TryCreate()`方法可以从通过控制台输入的字符串创建绝对地址。如果调用`Uri.TryCreate`失败，您应该发布`InvalidUrlRequested`事件以指示此失败。
- en: '`WebClient` has two events—`DownloadFileCompleted` and `DownloadProgressChanged`.
    You should subscribe to these two events and republish them using your own similar
    events.'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebClient`有两个事件——`DownloadFileCompleted`和`DownloadProgressChanged`。您应该订阅这两个事件，并使用自己类似的事件重新发布它们。'
- en: Create a console app that uses an instance of `WebClientAdapter` (as created
    in *Step 2*) and subscribe to the three events.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个控制台应用程序，使用`WebClientAdapter`的一个实例（如*步骤2*中创建的），并订阅这三个事件。
- en: By subscribing to the `DownloadCompleted` event, you should indicate success
    in the console.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过订阅`DownloadCompleted`事件，您应该在控制台中指示成功。
- en: By subscribing to `DownloadProgressChanged`, you should report progress messages
    to the console showing the `ProgressPercentage` and `BytesReceived` values.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过订阅`DownloadProgressChanged`，您应该向控制台报告进度消息，显示`ProgressPercentage`和`BytesReceived`的值。
- en: By subscribing to the `InvalidUrlRequested` event, you should show a warning
    on the console using a different console background color.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过订阅`InvalidUrlRequested`事件，您应该使用不同的控制台背景颜色在控制台上显示警告。
- en: Use a `do` loop that allows the user to repeatedly enter a web address. This
    address and a temporary destination file path can be passed to `WebClientAdapter.DownloadFile()`
    until the user enters a blank address to quit.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个`do`循环，允许用户重复输入网址。直到用户输入空白地址退出为止，可以将该地址和临时目标文件路径传递给`WebClientAdapter.DownloadFile()`。
- en: 'Once you run the console app with various download requests, you should see
    an output similar to the following:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您使用各种下载请求运行控制台应用程序，您应该看到类似以下的输出：
- en: '[PRE187]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: By completing this activity, you have seen how to subscribe to events from an
    existing .NET event-based publisher class (`WebClient`), adapting them to your
    own specification before republishing them in your adapter class (`WebClientAdapter`),
    which were ultimately subscribed to by a console app.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，您已经学会了如何订阅现有的.NET基于事件的发布者类（`WebClient`）的事件，并在重新发布到适配器类（`WebClientAdapter`）中进行自己的规范调整，最终由控制台应用程序订阅。
- en: Note
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到此活动的解决方案。
- en: Summary
  id: totrans-635
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you took an in-depth look at delegates. You created custom
    delegates and saw how they could be replaced with their modern counterparts, the
    inbuilt `Action` and `Func` delegates. By using null reference checks, you discovered
    the safe way to invoke delegates and how multiple methods can be chained together
    to form multicast delegates. You extended delegates further to use them with the
    `event` keyword to restrict invocation and followed the preferred pattern when
    defining and invoking events. Finally, you covered the succinct lambda expression
    style and saw how bugs can be avoided by recognising the use of captures and closures.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您深入了解了委托。您创建了自定义委托，并看到它们如何被其现代对应物，内置的`Action`和`Func`委托所取代。通过使用空引用检查，您发现了调用委托的安全方式，以及如何将多个方法链接在一起形成多播委托。您进一步扩展了委托，将其与`event`关键字一起使用，以限制调用，并遵循在定义和调用事件时的首选模式。最后，您了解了简洁的lambda表达式风格，并看到通过识别捕获和闭包的使用可以避免错误。
- en: In the next chapter, you will look at LINQ and data structures, the fundamental
    parts of the C# language.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习LINQ和数据结构，这是C#语言的基本部分。
