- en: Introduction to Object-Orientated Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程简介
- en: So far, you have seen how to modularize code in functions and encapsulate data
    with code in a class. You have also seen how to write generic code with templates.
    Classes and encapsulation allow you to combine together code and data as an object.
    In this chapter, you'll learn how to *reuse* code through inheritance and composition
    and how to use class inheritance to write object-orientated code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了如何在函数中将代码模块化，并在类中用代码封装数据。您还看到了如何使用模板编写通用代码。类和封装允许您将代码和数据组合在一起作为一个对象。在本章中，您将学习如何通过继承和组合来*重用*代码，以及如何使用类继承来编写面向对象的代码。
- en: Inheritance and composition
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和组合
- en: 'The classes you have seen so far are complete classes: you can create an instance
    of the class on the free store or the stack. You can do this because the data
    members of the class have been defined and so it is possible to calculate how
    much memory is needed for the object, and you have provided the full functionality
    of the class. These are called **concrete classes**.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您所看到的类都是完整的类：您可以在自由存储区或堆栈上创建类的实例。这是因为类的数据成员已经定义，因此可以计算出对象所需的内存量，并且已经提供了类的全部功能。这些被称为**具体类**。
- en: If you have a routine in a class that proves useful and you want to reuse in
    a new class, you have a few choices. The first is called **composition**. With
    composition you add an instance of your utility class as a data member of the
    classes that will use the routine. A simple example is the `string` class--this
    provides all the functionality that you want from a string. It will allocate memory
    according to how many characters have to be stored and deallocate the memory it
    uses when the string object is destroyed. Your class uses the functionality of
    a string, but it is not a string itself, hence it has the string as a data member.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个类中有一个证明有用的例程，并且希望在新类中重用，您有几种选择。第一种称为**组合**。通过组合，您可以将实用程序类的实例作为将使用该例程的类的数据成员添加进去。一个简单的例子是`string`类--它提供了您从字符串中想要的所有功能。它将根据需要存储的字符数分配内存，并在字符串对象被销毁时释放它使用的内存。您的类使用字符串的功能，但它本身不是一个字符串，因此它将字符串作为数据成员。
- en: 'The second option is to use **inheritance**. There are many ways to use inheritance,
    and this chapter will mention some of them. In basic terms, inheritance is when
    one class *extends* another class the class being extended is called the **base
    class**, **parent class**, or **superclass**, and the class doing the extending
    is called a **derived class**, **child class**, or **subclass**. However, there
    is an important concept to understand with inheritance: the relationship of the
    derived class to the base class. It is commonly given in terms of **is-a**. If
    the derived class is a type of base class, then the relationship is inheritance.
    An mp3 file is an operating system file, so if you have a `os_file` class, then
    you could legitimately derive from it to create an `mp3_file` class.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用**继承**。有许多使用继承的方式，本章将提到其中一些。基本上，继承是指一个类*扩展*另一个类，被扩展的类称为**基类**、**父类**或**超类**，而进行扩展的类称为**派生类**、**子类**或**子类**。然而，有一个重要的概念需要理解：派生类与基类的关系。通常以**是一个**的方式给出。如果派生类是基类的一种类型，那么这种关系就是继承。mp3文件是操作系统文件，因此如果您有一个`os_file`类，那么您可以合理地从中派生出一个`mp3_file`类。
- en: The derived class has the functionality and state of the base class (although
    it may not have complete access to them, as will be explained later), so it can
    use the functionality of the base class. In this case, it is similar to composition.
    However, there are significant differences. In general, in composition, the composed
    object is used by the class and not exposed directly to the client of the class.
    With inheritance, an object of the derived class is an object of the base class,
    so usually the client code will see the base class functionality. However, a derived
    class can hide the functionality of the base class, so client code will not see
    the hidden base class member, and the derived class can override the base class
    methods and provide its own version.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类具有基类的功能和状态（尽管可能无法完全访问它们，稍后将进行解释），因此它可以使用基类的功能。在这种情况下，它类似于组合。然而，存在重大差异。通常情况下，在组合中，组合对象由类使用，而不直接暴露给类的客户端。通过继承，派生类的对象是基类的对象，因此通常客户端代码将看到基类的功能。然而，派生类可以隐藏基类的功能，因此客户端代码将看不到隐藏的基类成员，并且派生类可以覆盖基类的方法并提供自己的版本。
- en: There is a lot of disagreement in the C++ community over whether you should
    use inheritance or composition to reuse code, and there are advantages and disadvantages
    of each. Neither is perfect and often a compromise is needed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++社区中，关于是否应该使用继承或组合来重用代码存在很多争议，每种方法都有其优缺点。两者都不完美，通常需要妥协。
- en: Inheriting from a class
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从类继承
- en: 'Consider a class that wraps an operating system. This will provide lots of
    methods to give access to things such as the creation date, modification date,
    and the size of the file obtained by calling operating system functions. It could
    also provide methods to open the file, close the file, map the file into memory,
    and other useful things. Here are a few such members:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包装操作系统的类。这将提供许多方法，以便通过调用操作系统函数来获取文件的创建日期、修改日期和大小。它还可以提供打开文件、关闭文件、将文件映射到内存以及其他有用的方法。以下是一些这样的成员：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An mp3 file is an operating system file, but there are other operating system
    functions to access its data. We could decide to create an `mp3_file` class that
    derives from an `os_file` so that it has the functionality of the operating system
    file and extend this with the functionality of an mp3 file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: mp3文件是操作系统文件，但有其他操作系统函数可以访问其数据。我们可以决定创建一个`mp3_file`类，它从`os_file`派生，以便具有操作系统文件的功能，并通过mp3文件的功能进行扩展：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line of the `mp3_file` class indicates that it uses *public* *inheritance*
    (we will explain what public inheritance means later, but it is worth pointing
    out that this is the most common way to derive from a class). The derived class
    inherits the data members and the methods, and users of the derived class can
    use the members of the base class through the derived class, subject to the access
    specifiers. In this example, if some code has an `mp3_file` object, it can call
    the `get_length_in_seconds` method from the `mp3_file` class, and it can also
    call the `get_size_in_bytes` method from the base because this method is `public`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`mp3_file`类的第一行表示它使用*public* *inheritance*（我们稍后会解释什么是public inheritance，但值得指出的是，这是从一个类派生的最常见方式）。派生类继承了数据成员和方法，派生类的用户可以通过派生类使用基类的成员，取决于访问说明符。在这个例子中，如果某些代码有一个`mp3_file`对象，它可以从`mp3_file`类调用`get_length_in_seconds`方法，也可以从基类调用`get_size_in_bytes`方法，因为这个方法是`public`的。'
- en: 'The base class methods will most likely access the base class data members,
    and this illustrates an important point: the derived object contains the base
    class data members. Conceptually, in memory, you can think of the derived object
    as being the base class object data members with the extra data members defined
    in the derived object. That is, the derived object is an extended version of the
    base class object. This is illustrated in the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基类方法很可能访问基类数据成员，这说明了一个重要的观点：派生对象包含基类数据成员。在内存中，你可以把派生对象看作是基类对象数据成员加上派生对象中定义的额外数据成员。也就是说，派生对象是基类对象的扩展版本。这在下面的图表中有所说明：
- en: '![](img/92734943-7c75-4c41-8840-907b7ddd8b2b.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92734943-7c75-4c41-8840-907b7ddd8b2b.png)'
- en: In memory, an `os_file` object has two data members, `file_name` and `file_handle`,
    and an `mp3_file` object has these two data members and an additional data member,
    `length_in_secs`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，`os_file`对象有两个数据成员，`file_name`和`file_handle`，而`mp3_file`对象有这两个数据成员和一个额外的数据成员`length_in_secs`。
- en: The encapsulation principle is important in C++. Although an `mp3_file` object
    contains the `file_name` and `file_handle` data members, they should only be changed
    by the base class methods. In this code, this is enforced by making them `private`
    to the `os_file` class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 封装原则在C++中很重要。虽然`mp3_file`对象包含`file_name`和`file_handle`数据成员，但它们应该只能由基类方法来改变。在这段代码中，通过将它们设为`private`来强制执行这一点。
- en: 'When a derived object is created, the base object must be created first (with
    an appropriate constructor), similarly, when a derived object is destroyed, the
    derived part of the object is destroyed first (through the destructor of the derived
    class) before the base class destructor is called. Consider the following code
    snippet, using the members discussed in preceding text:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个派生对象时，必须首先创建基对象（使用适当的构造函数），同样，当销毁一个派生对象时，首先销毁对象的派生部分（通过派生类的析构函数），然后才调用基类析构函数。考虑以下代码片段，使用前面文本中讨论的成员：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `open_file` and `close_file` functions will be some operating system functions
    to open and close operating system files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`open_file`和`close_file`函数将是一些操作系统函数，用于打开和关闭操作系统文件。'
- en: The derived class no longer has to perform the action of closing the file because
    the base class destructor, `~os_file`, is automatically called after the derived
    class destructor is called. The `mp3_file` constructor calls the base class constructor
    through its constructor member list. If you do not explicitly call a base class
    constructor, then the compiler will call the default constructor of the base class
    as the first action of the derived class constructor. If the member list initializes
    data members, these will be initialized after any base class constructor is called.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类不再需要执行关闭文件的操作，因为在派生类析构函数被调用后，基类析构函数`~os_file`会自动被调用。`mp3_file`构造函数通过其构造函数成员列表调用基类构造函数。如果你没有显式调用基类构造函数，那么编译器会在派生类构造函数的第一个动作中调用基类的默认构造函数。如果成员列表初始化了数据成员，那么这些数据成员会在任何基类构造函数被调用后初始化。
- en: Overriding methods and hiding names
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖方法和隐藏名称
- en: 'The derived class inherits the functionality of the base class (subject to
    the access level of the methods), so a base class method can be called through
    an object of the derived class. The derived class can implement a method with
    the same prototype as the base class method, in which case the base class method
    is *overridden* by the derived class method and the derived class provides the
    functionality. A derived class will often override a base class method to provide
    functionality that is specific to the derived class; however, it can call the
    base class method by calling the method using the name resolution operator:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类继承了基类的功能（取决于方法的访问级别），因此可以通过派生类的对象调用基类方法。派生类可以实现一个与基类方法具有相同原型的方法，这种情况下，基类方法被派生类方法*覆盖*，派生类提供功能。派生类通常会覆盖基类方法，以提供特定于派生类的功能；然而，它可以通过使用名称解析运算符调用基类方法：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remember that a struct is a `class` type where members are `public` by default,
    and inheritance is `public` by default.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，结构体是一个默认成员为`public`的`class`类型，继承默认为`public`。
- en: 'Here, the `base::f` and `base::g` methods will perform some action available
    to users of instances of this class. The `derived` class inherits both methods,
    and since it does not implement the method `g` when instances of the `derived`
    class call the `g` method, they will actually call the `base::g` method. The `derived`
    class implements its own version of the `f` method, so when an instance of the
    `derived` class calls the `f` method, they will call `derived::f` and not the
    base class version. In this implementation, we have decided that we need some
    of the functionality of the base class version, so `derived::f` explicitly calls
    the `base::f` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`base::f`和`base::g`方法将执行一些可供此类实例的用户使用的操作。`derived`类继承了这两种方法，由于它没有实现`g`方法，当`derived`类的实例调用`g`方法时，它们实际上会调用`base::g`方法。`derived`类实现了自己版本的`f`方法，因此当`derived`类的实例调用`f`方法时，它们将调用`derived::f`而不是基类版本。在这个实现中，我们决定我们需要一些基类版本的功能，所以`derived::f`明确调用`base::f`方法：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous example, the method calls the base class version first before
    providing its own implementation. There is no specific convention here. Class
    libraries are sometimes implemented specifically for you to derive from a base
    class and use the class library code. The documentation of the class library will
    say whether you are expected to replace the base class implementation or if you
    are expected to add to the base class implementation, and if so, whether you will
    call the base class method before or after your code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，该方法首先调用基类版本，然后提供自己的实现。这里没有具体的约定。类库有时是专门为您实现的，以便您从基类派生并使用类库代码。类库的文档将说明您是否应该替换基类实现，或者您是否应该添加到基类实现，如果是这样，您是否会在您的代码之前或之后调用基类方法。
- en: 'In this example, the derived class provides a method with the exact prototype
    as the method on the base class to override it. In fact, adding any method with
    the same name as a method in the base class hides that base class method from
    the client code that uses the derived instance. So, consider that the `derived`
    class is implemented like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，派生类提供了一个与基类方法完全相同原型的方法来覆盖它。事实上，添加任何与基类中方法同名的方法会隐藏客户端代码中使用派生实例的基类方法。因此，可以将`derived`类实现如下：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this case, the `base::f` method is hidden from the code that creates a `derived`
    object, even though the method has a different prototype:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`base::f`方法被隐藏，即使该方法具有不同的原型：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The base class method with the same name is hidden, so the last line will not
    compile. You can, however, call the function explicitly by providing the base
    class name:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相同名称的基类方法被隐藏，因此最后一行将无法编译。但是，您可以通过提供基类名称来显式调用该函数：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At first sight, this syntax looks a little odd but once you know that the `.`
    and `->` operators give access to a member, and the symbol after the operator
    is the name of the member, in this case, explicitly specified using the class
    name and scope resolution operator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个语法看起来有点奇怪，但一旦你知道`.`和`->`运算符可以访问成员，并且运算符后面的符号是成员的名称，这种情况下，使用类名和作用域解析运算符明确指定。
- en: In general, the code shown so far is called **implementation inheritance**,
    where a class inherits the implementation from a base class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所展示的代码通常被称为**实现继承**，其中一个类从基类继承实现。
- en: Using pointers and references
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针和引用
- en: In C++, you can get a pointer to where an object (a built-in type or a custom
    type) resides in memory using the `&` operator. The pointer is typed, so the code
    using the pointer assumes that the pointer points to the memory layout of the
    object of the type. Similarly, you can obtain a reference to an object, and the
    reference is an *alias* for the object, that is, operations on the reference occur
    on the object. A pointer (or a reference) to an instance of a derived class can
    be implicitly converted to a pointer (or a reference) to a base class object.
    This means that you can write a function that acts upon base class objects, using
    the behavior of the base class objects, and as long as the parameter is a pointer
    or reference to a base class, you can pass any derived class object to the function.
    The function does not know about, nor does it care about, the derived class functionality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，您可以使用`&`运算符获取对象（内置类型或自定义类型）在内存中的位置的指针。指针是有类型的，因此使用指针的代码假定指针指向该类型的对象的内存布局。同样，您可以获得对象的引用，引用是对象的*别名*，也就是说，对引用的操作会在对象上进行。派生类的实例的指针（或引用）可以隐式转换为基类对象的指针（或引用）。这意味着您可以编写一个作用于基类对象的函数，使用基类对象的行为，并且只要参数是指向基类的指针或引用，就可以将任何派生类对象传递给该函数。该函数不知道，也不关心派生类的功能。
- en: 'You should think about the derived object as being a base class object and
    accept that it can be used as a base class object. Clearly, a base class pointer
    will only have access to the members on the base class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将派生对象视为基类对象，并接受它可以被用作基类对象。显然，基类指针只能访问基类的成员：
- en: '![](img/3893edb8-394f-41f6-8150-a82d8a8a097d.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3893edb8-394f-41f6-8150-a82d8a8a097d.png)'
- en: If the derived class hides a member of the base class, it means that a pointer
    to the derived class will call the derived version through the member name, but
    the base class pointer will only see the base class member, not the derived version.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果派生类隐藏了基类的成员，这意味着派生类的指针将通过成员名称调用派生版本，但基类指针只能看到基类成员，而看不到派生版本。
- en: 'If you have a base class pointer, you can cast it to a derived class pointer
    using `static_cast`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个基类指针，可以使用`static_cast`将其转换为派生类指针：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The problem here is how can the `print_y` function guarantee that the base class
    pointer passed as the parameter to the specific derived object? It cannot, without
    discipline from the developers using the function guaranteeing that they will
    never pass a derived class pointer of a different type. The `static_cast` operator
    will return a pointer to a `derived` object even if the memory does not contain
    that object. There is a mechanism to perform type checking on the pointer being
    cast, which we will cover later in this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`print_y`函数如何保证将基类指针传递给特定派生对象？如果没有开发人员使用该函数的纪律保证他们永远不会传递不同类型的派生类指针，那么它是无法保证的。即使内存中不包含该对象，`static_cast`操作符也会返回指向`derived`对象的指针。有一种机制可以对进行强制转换的指针进行类型检查，我们将在本章后面介绍。
- en: Access levels
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问级别
- en: 'So far, we have seen two access specifiers for class members: `public` and
    `private`. Members declared in the `public` section can be accessed by code in
    the class *and* by code outside the class either on an object or if the member
    is `static`, using the class name. Members declared in the `private` section can
    only be accessed by other members in the same class. A derived class can access
    the `private` members of the base class but not the `private` members. There is
    a third type of member access: `protected`. Members declared in the `protected`
    section can be accessed by methods in the same class or by methods in any derived
    class and by friends, but not by external code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了类成员的两种访问限定符：`public`和`private`。在`public`部分声明的成员可以被类内部和类外部的代码访问，无论是在对象上还是（如果成员是`static`的话）使用类名。在`private`部分声明的成员只能被同一类中的其他成员访问。派生类可以访问基类的`private`成员，但不能访问`private`成员。还有第三种成员访问方式：`protected`。在`protected`部分声明的成员可以被同一类中的方法或任何派生类的方法和友元访问，但不能被外部代码访问：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this code, the `test` method can be called by members in the `derived` class
    but not by code outside of the class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`test`方法可以被`derived`类中的成员调用，但不能被类外的代码调用：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you are writing a base class that you intend only ever to be used as a base
    class (client code should not create instances of it), then it makes sense to
    make the destructor `protected`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写一个基类，您只打算将其用作基类（客户端代码不应创建其实例），那么将析构函数设置为`protected`是有意义的：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The compiler will not allow you to create objects of this class on the free
    store and then destroy with `delete`, because this operator will call the destructor.
    Similarly, the compiler won't allow you to create objects on the stack because
    the compiler will call the inaccessible destructor when the object goes out of
    scope. This destructor will be called through the destructor of the derived class,
    so you can be assured that a correct cleanup of the base class will occur. This
    pattern does mean that you always only intend to use pointers to the derived classes
    to destroy the object with a call to the `delete` operator.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不允许您在自由存储器上创建此类的对象，然后使用`delete`销毁它，因为此操作符将调用析构函数。同样，编译器也不会允许您在堆栈上创建对象，因为当对象超出范围时，编译器将调用不可访问的析构函数。此析构函数将通过派生类的析构函数调用，因此您可以确保基类的正确清理将发生。这种模式意味着您总是打算使用指向派生类的指针，以便通过调用`delete`操作符销毁对象。
- en: Changing access level through inheritance
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过继承改变访问级别
- en: 'When you override a method in the derived class, the access to the method is
    defined by the derived class. So if the base class method is `protected` or `public`,
    the access can be changed by the derived class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在派生类中重写方法时，对该方法的访问由派生类定义。因此，如果基类方法是`protected`或`public`，则派生类可以更改访问权限：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, the `base::f` method is `protected`, so only the `derived`
    class can access it. The `derived` class overrides this method (and can call the
    base class method if the fully qualified name is used) and makes it `public`.
    Similarly, the `base::g` method is `public` but the `derived` class overrides
    this method and makes it `protected` (and if desired, it could make the method
    `private`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`base::f`方法是`protected`，因此只有`derived`类可以访问它。`derived`类重写了此方法（并且可以调用基类方法，如果使用了完全限定名称），并将其设置为`public`。类似地，`base::g`方法是`public`，但`derived`类重写了此方法并将其设置为`protected`（如果需要，它也可以将该方法设置为`private`）。
- en: 'You can also expose a `protected` base class from a derived class as a `public`
    member with a `using` statement:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`using`语句将派生类中的`protected`基类公开为`public`成员：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, the `derived::f` method is `public` without the derived class creating
    a new method. A better use of this facility is to make a method `private` so that
    it is not available to derived classes (or if it was `public`, through an instance),
    or make it `protected` so that external code cannot access the member:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`derived::f`方法是`public`，而不是派生类创建一个新方法。更好地使用此功能的方法是将方法设置为`private`，以便派生类（或者如果它是`public`，则通过实例）无法访问它，或者将其设置为`protected`，以便外部代码无法访问该成员：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code can be used like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以这样使用：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last line won''t compile because the `f` method is `protected`. If the
    intention is to make the method available only in the derived class and not to
    in any classes that may derive from it, you can use the `using` statement in the
    `private` section of the derived class; this is similar to deleting a base class
    method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行不会编译，因为`f`方法是`protected`。如果意图是仅在派生类中使该方法可用，并且不在可能从中派生的任何类中使其可用，您可以在派生类的`private`部分使用`using`语句；这类似于删除基类方法：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `f` method cannot be used through the `derived` class, but the class can
    call the `base` class method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`方法无法通过`derived`类使用，但该类可以调用`base`类方法。'
- en: Inheritance access levels
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承访问级别
- en: Earlier, you saw that to derive from a class, you provide the base class name
    and give an inheritance access specifier; the examples so far have used `public`
    inheritance, but you can use `protected` or `private` inheritance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您看到了要从一个类派生，您需要提供基类名称并给出继承访问限定符；到目前为止的示例都使用了`public`继承，但您也可以使用`protected`或`private`继承。
- en: This is another difference between class and struct. For a class, if you miss
    off the inheritance access specifier, the compiler will assume that it is private;
    for a struct, if you miss off the inheritance access specifier, the compiler will
    assume that it is public.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类和结构之间的另一个区别。对于类，如果您省略了继承访问说明符，编译器将假定它是私有的；对于结构，如果您省略了继承访问说明符，编译器将假定它是公共的。
- en: The inheritance specifier applies more access restrictions, it will not relax
    them. The access specifier does not determine the access it has to the base class
    members, instead it alters the accessibility of those members through the derived
    class (that is through an instance of the class, or if another class derives from
    it). If a base class has `private` members, and a class inherits using `public`
    inheritance, the derived class still cannot access the `private` members; it only
    has access to `public` and `protected` members and objects of the derived class
    can only access the `public` members, and a class deriving from this class will
    only have access to the `public` and `protected` members.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 继承说明符应用更多的访问限制，而不是放宽它们。访问说明符不确定它对基类成员的访问权限，而是通过派生类（即通过类的实例，或者如果另一个类从它派生）改变这些成员的可访问性。如果一个基类有`private`成员，并且一个类使用`public`继承进行继承，那么派生类仍然无法访问`private`成员；它只能访问`public`和`protected`成员，派生类的对象只能访问`public`成员，而从这个类派生的类只能访问`public`和`protected`成员。
- en: If a derived class derives through the *protected inheritance*, it still has
    the same access to the base class as `public` and `protected` members, but the
    base class `public` and `protected` members will now be treated as `protected`
    through the derived class, so they can be accessed by a further derived class
    but are not accessible through an instance. If a class derives through private
    inheritance then all base class members become `private` in the derived class;
    so, although the derived class can access `public` and `protected` members, classes
    that derive from it cannot access any of the base class members.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果派生类通过*protected继承*派生，它仍然具有与`public`和`protected`成员相同的对基类的访问权限，但是基类的`public`和`protected`成员现在将通过派生类视为`protected`，因此它们可以被进一步派生的类访问，但不能通过实例访问。如果一个类通过私有继承派生，那么所有基类成员在派生类中都变为`private`；因此，尽管派生类可以访问`public`和`protected`成员，但从它派生的类不能访问任何基类成员。
- en: One way of looking at protected inheritance is if the derived class had a `using`
    statement for each of the `public` members of the base class in the `protected`
    part of the class. Similarly, private inheritance is as if you have deleted each
    of the `public` and `protected` methods of the base class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 保护继承的一种看法是，如果派生类在类的`protected`部分对基类的每个`public`成员都有一个`using`语句。类似地，私有继承就好像您已删除了基类的每个`public`和`protected`方法。
- en: In general, most inheritance will be through *public inheritance*. However,
    *private inheritance* has a use when you want to access some functionality from
    a base class but do not want its functionality to be available to classes that
    derive from your class. This is a little like composition, where you are using
    functionality but do not want that functionality directly exposed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，大多数继承都将通过*public继承*。但是，当您想要从基类访问一些功能但不希望其功能对从您的类派生的类可用时，*private继承*是有用的。这有点像组合，您在使用功能但不希望该功能直接暴露。
- en: Multiple inheritance
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'C++ allows you to inherit from more than one base class. This is a powerful
    facility when used with interfaces, as we will discover later in this chapter.
    It can be useful for implementation inheritance, but it can cause some problems.
    The syntax is simple: you provide a list of classes to inherit from:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许您从多个基类继承。当与接口一起使用时，这是一个强大的功能，我们将在本章后面发现。它对于实现继承可能很有用，但可能会引起一些问题。语法很简单：您提供一个要继承的类的列表：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One way to use multiple inheritances is to build up libraries of classes each
    providing some functionality, or services. To get these services in your class
    you can add the class from the library to your base class list. Such a *building
    block* approach to creating classes through implementation inheritance has issues,
    as we will see later, and often a better approach is to use composition.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多重继承的一种方法是构建提供某些功能或服务的类库。要在您的类中获得这些服务，您可以将库中的类添加到基类列表中。通过实现继承来创建类的*构建块*方法存在问题，我们稍后会看到，通常更好的方法是使用组合。
- en: It is important when you consider multiple inheritances that you carefully review
    that you need the services via inheritance or whether composition is more appropriate.
    If a class provides a member that you do not want to be used by instances and
    you decide that you need to delete it, it is a good sign that you should consider
    composition.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑多重继承时，重要的是仔细审查您是需要通过继承获取服务还是组合更合适。如果一个类提供了一个您不希望实例使用的成员，并且您决定需要删除它，这是一个很好的迹象，表明您应该考虑组合。
- en: 'If both classes have a member with the same name, then there is a potential
    problem. The most obvious case is if the base classes have a data member with
    the same name:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个类具有相同名称的成员，则可能会出现问题。最明显的情况是如果基类具有相同名称的数据成员：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous example, both base classes have a data member called `x`. The
    `derived` class inherits from both classes, so does this mean that it gets just
    one data member called `x`? No. If it did, then this would mean that the `base1`
    class would be able to alter a data member in the `base2` class without knowing
    that it is affecting another class, and similarly the `base2` class will find
    its data member being altered by the `base1` class even though that class is not
    a `friend`. Consequently, when you derive from two classes with data members that
    have the same name, the derived class gets both data members.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，两个基类都有一个名为`x`的数据成员。`derived`类继承自这两个类，这意味着它只会得到一个名为`x`的数据成员吗？不是的。如果是这样的话，那么`base1`类将能够修改`base2`类中的数据成员，而不知道这会影响到另一个类，同样地，`base2`类将发现它的数据成员被`base1`类修改，即使那个类不是`friend`。因此，当你从两个具有相同名称的数据成员的类派生时，派生类会得到这两个数据成员。
- en: This yet again illustrates the importance of maintaining encapsulation. Such
    data members should be `private` and only changed by the base class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次说明了保持封装的重要性。这样的数据成员应该是`private`的，并且只能由基类进行更改。
- en: 'The derived class (and the code that uses instances, if the data members are
    accessible) can distinguish between them using their full names:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类（以及使用实例的代码，如果数据成员是可访问的）可以通过它们的全名来区分它们：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The class can be summed up with the following diagram, illustrating the memory
    occupied by the three classes: `base1`, `base2`, and `derived`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以用下面的图表来总结，说明了三个类`base1`，`base2`和`derived`所占用的内存：
- en: '![](img/05bc19b7-42ab-43b1-83a6-dd934527e416.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05bc19b7-42ab-43b1-83a6-dd934527e416.png)'
- en: 'If you maintain encapsulation and make data members `private` and give access
    only through accessor methods, then derived classes will not have direct access
    to the data members and will not see this issue. However, the same issue occurs
    with methods, but the problem occurs even if the methods have different prototypes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你保持封装并将数据成员设为`private`，并且只通过访问器方法访问，那么派生类将不能直接访问数据成员，也不会看到这个问题。然而，方法也会出现相同的问题，但即使方法有不同的原型，问题也会出现： '
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this case, the two base classes have a method with the same name, `a`, but
    with a different prototype. This causes a problem when using the `derived` class,
    even when it may be obvious by the parameters what method should be called:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个基类都有一个名为`a`的方法，但原型不同。当使用`derived`类时，这会导致问题，即使通过参数可能很明显应该调用哪个方法。
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code will not compile, and the compiler will complain that the method
    call is ambiguous. Again, the solution to this problem is simple, you just need
    to specify which base class method to use:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将无法编译，编译器会抱怨方法调用是模棱两可的。再次，这个问题的解决方法很简单，你只需要指定使用哪个基类方法：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Multiple inheritances can get even more complicated. The problem occurs if you
    have two classes that derive from the same base class and then you create another
    class that derives from both. Does the new class get two copies of the topmost
    base class members--one through each of its immediate base classes?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承可能会变得更加复杂。问题出现在如果你有两个类都从同一个基类派生，然后你创建另一个类从这两个类派生。新类会得到最顶层基类成员的两个副本吗？一个通过每个直接基类？
- en: '![](img/cb441eea-fa33-4434-b4ba-56255cba5624.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb441eea-fa33-4434-b4ba-56255cba5624.png)'
- en: 'At the first level of inheritance, each of the classes (`base1` and `base2`)
    inherit the data member from the ultimate base class (here, the data members are
    both called `base::x` to illustrate that they are inherited from the ultimate
    base class, `base`). The most derived class, `derived`, inherits *two* data members,
    so which one is `base::x`? The answer is that only one of them is, `base1::x`
    is `base::x`, because it is the first in the inheritance list. When the `base`
    methods change it, the change will be seen in `base1` through `base1::x`. The
    `base2::x` member is a separate data member and not affected when `base` changes
    `base::x`. This is perhaps an unexpected result: the most-derived class inherits
    `x` from both of its parent classes.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承的第一级，每个类（`base1`和`base2`）都从最终基类继承了数据成员（这里，数据成员都被称为`base::x`，以说明它们是从最终基类`base`继承的）。最派生类`derived`继承了*两个*数据成员，那么`base::x`是哪个？答案是只有一个，`base1::x`是`base::x`，因为它是继承列表中的第一个。当`base`方法改变它时，改变将在`base1`中通过`base1::x`看到。`base2::x`成员是一个独立的数据成员，当`base`改变`base::x`时不受影响。这可能是一个意想不到的结果：最派生类从它的父类中都继承了`x`。
- en: This may not be the behavior you want. This issue is often called *diamond inheritance
    issue* and it should be apparent from the preceding diagram, where this name comes
    from. The solution is straightforward, and will be covered later in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你想要的行为。这个问题通常被称为*菱形继承问题*，并且从前面的图表中应该很明显，这个名字是从哪里来的。解决方法很简单，稍后在本章中会介绍。
- en: Object slicing
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象切片
- en: Earlier in the chapter, you saw that if you use a base class pointer to a derived
    object only the base class members can be safely accessed. The other members are
    still there, but they can only be accessed through an appropriate derived class
    pointer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，你看到如果你使用一个基类指针指向一个派生对象，只有基类成员可以被安全访问。其他成员仍然存在，但只能通过适当的派生类指针访问。
- en: 'However, if you cast a derived class object to a base class object, something
    else happens: you create a new object, and that object is the base class object,
    just the base class object. The variable that you have cast to will only have
    the memory for the base class object, so the result is only the base class object
    part of the derived object:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将一个派生类对象转换为一个基类对象，会发生另外的事情：你创建了一个新对象，那个对象就是基类对象，只是基类对象。你转换的变量只有基类对象的内存，所以结果只有派生对象的基类对象部分：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, the objects `b1` and `b2` have been created by *slicing off* the extra
    data in the `derived` class object `d`. This code looks a bit perverse, and you
    are not likely to write it, but the situation is likely to happen if you pass
    an object by value to a function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对象`b1`和`b2`是通过对`derived`类对象`d`进行*切片*来创建的。这段代码看起来有点反常，你不太可能写出来，但如果你通过值传递一个对象给一个函数，情况很可能会发生：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you pass a `derived` object to this function, the `base` copy constructor
    will be called to create a new object, slicing off the `derived` class data members.
    In most cases, you do not want this behavior. This issue also has an unexpected
    behavior if your base class has virtual methods and expects the polymorphic functionality
    that virtual methods offer (virtual methods are covered later in this chapter).
    It is almost always a better idea to pass objects by reference.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个`derived`对象传递给这个函数，将调用`base`的复制构造函数来创建一个新对象，切掉`derived`类的数据成员。在大多数情况下，你不希望出现这种行为。如果你的基类有虚方法，并且期望虚方法提供的多态功能（虚方法稍后在本章中介绍），这个问题也会有意想不到的行为。最好总是通过引用传递对象。
- en: Introducing polymorphism
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入多态
- en: Polymorphism comes from the Greek for *many shapes*. So far, you have a basic
    form of polymorphism. If you use a base class pointer to an object, then you can
    access the base class behavior, and if you have a derived class pointer, you get
    the derived class behavior. This is not as trivial as it appears because the derived
    class can implement its own version of the base class methods, so you can have
    a different implementation of that behavior.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 多态来自希腊语，意为*多种形态*。到目前为止，你已经有了多态的基本形式。如果你使用一个指向对象的基类指针，那么你可以访问基类的行为，如果你有一个派生类指针，你就会得到派生类的行为。这并不像看起来那么简单，因为派生类可以实现自己版本的基类方法，所以你可以有不同的行为实现。
- en: 'You can have more than one class derived from a base class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从一个基类派生出多个类：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since C++ is strongly typed, it means that a pointer to one derived class cannot
    be used to point to another derived class. So you cannot use a `derived1*` pointer
    to access an instance of `derived2`, it can only point to an object of type `derived1`.
    Even if the classes have the same members, they are still different types and
    their pointers are different. However, all derived classes have something in common,
    which is the base class. A derived class pointer can be implicitly converted to
    a base class pointer, so a `base*` pointer can point to an instance of `base`,
    `derived1`, `derived2`, or `derived3`. This means that a generic function taking
    a `base*` pointer as a parameter can be passed a pointer to any of these classes.
    This is the basis of interfaces, as we will see later.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++是强类型的，这意味着一个派生类的指针不能用来指向另一个派生类。所以你不能使用`derived1*`指针来访问`derived2`的实例，它只能指向`derived1`类型的对象。即使这些类有相同的成员，它们仍然是不同的类型，它们的指针也是不同的。然而，所有的派生类都有一个共同点，那就是基类。派生类指针可以被隐式转换为基类指针，所以`base*`指针可以指向`base`、`derived1`、`derived2`或`derived3`的实例。这意味着一个接受`base*`指针作为参数的通用函数可以传递给这些类的任何一个指针。这是接口的基础，我们稍后会看到。
- en: The polymorphic aspect is that through pointers (or references), an instance
    of a class can be treated as an instance of any of the classes in its inheritance
    hierarchy.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 多态的方面是，通过指针（或引用），一个类的实例可以被视为其继承层次结构中任何一个类的实例。
- en: Virtual methods
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚方法
- en: 'A base class pointer or reference giving access to just the base class functionality,
    and makes sense, but it is restrictive. If you have a `car` class that provides
    the interface for a car, a gas pedal, and brake to alter the speed, a steering
    wheel and reverse gear to alter the direction-you can derive from this class various
    other car types: a sports car, an SUV, or a family sedan. When you press the gas
    pedal, you expect the car to have the torque of an SUV, if your car is an SUV,
    or the speed of a sports car if it''s a sports car. Similarly, if you call the
    `accelerate` method on a `car` pointer and that pointer is to a `suv`, then you
    expect to get method to reflect the torque of the SUV, and if the `car` pointer
    points to a `sportscar` object, you performance acceleration. Earlier, we said
    that if you access a derived class instance through a base class pointer, then
    you will get the implementation of the base class methods. This means that, calling
    the `accelerate` method on a `car` pointer that points to an `suv` or a `sportscar`
    object, you will still get the implementation of `car::accelerate` and not `suv::accelerate`
    or `sportscar::accelerate` which you would want.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基类指针或引用只能访问基类的功能，这是有意义的，但它是有限制的。如果你有一个`car`类，它提供了汽车的接口，油门和刹车来改变速度，方向盘和倒挡来改变方向-你可以从这个类派生出各种其他类型的汽车：跑车、SUV或家庭轿车。当你踩油门时，你期望汽车有SUV的扭矩，如果你的车是SUV，或者如果它是跑车，你期望它有跑车的速度。同样，如果你在`car`指针上调用`accelerate`方法，而该指针指向`suv`，那么你期望得到反映SUV扭矩的方法，如果`car`指针指向`sportscar`对象，你期望得到性能加速。之前我们说过，如果你通过基类指针访问派生类实例，那么你将得到基类方法的实现。这意味着，当你在指向`suv`或`sportscar`对象的`car`指针上调用`accelerate`方法时，你仍然会得到`car::accelerate`的实现，而不是`suv::accelerate`或`sportscar::accelerate`，这是你想要的。
- en: This behavior of calling the derived method through a base class pointer is
    known as **method dispatching**. The code calling a method through a base class
    pointer does not know the type of object that the pointer points to, but it still
    gets the functionality of that object because the method on that object is called.
    This method dispatching is not applied by default because it involves a little
    extra cost both in memory and performance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通过基类指针调用派生方法的行为被称为**方法分派**。通过基类指针调用方法的代码并不知道指针指向的对象的类型，但它仍然获得了该对象的功能，因为调用了该对象上的方法。这种方法分派不是默认应用的，因为它在内存和性能上都需要一些额外的成本。
- en: 'Methods that can take part in method dispatching are marked with the keyword
    `virtual` in the base class, and hence are usually called **virtual methods**.
    When you call such a method through a base class pointer, the compiler ensures
    that the method on the actual object''s class is called. Since every method has
    a `this` pointer as a hidden parameter, the method dispatching mechanism must
    ensure that the `this` pointer is appropriate when the method is called. Consider
    the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以参与方法分派的方法在基类中用关键字`virtual`标记，因此通常被称为**虚方法**。当你通过基类指针调用这样的方法时，编译器会确保调用实际对象类的方法。由于每个方法都有一个`this`指针作为隐藏参数，方法分派机制必须确保在调用方法时`this`指针是适当的。考虑以下例子：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There is a base class and two child classes, `derived1` and `derived2`. There
    is a further level of inheritance through `derived2` to a class called `derived3`.
    The base class implements a method called `who` that prints the class name. This
    method is implemented appropriately on each of the derived classes so that when
    this method is called on an object of `derived3`, the method will print `derived3`
    in the console. The `main` function creates an instance of each of the derived
    classes and passes each one by reference to a function called `who_is_it` that
    calls the `who` method. This function has a parameter that is a reference to `base`,
    and since this is the base class of all of the classes (for `derived3`, its immediate
    base class is `derived2`). When you run this code, the result will be as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个基类和两个子类，`derived1`和`derived2`。通过`derived2`进一步继承到一个名为`derived3`的类。基类实现了一个名为`who`的方法，打印类名。这个方法在每个派生类上都被适当地实现，所以当在`derived3`对象上调用这个方法时，控制台将打印`derived3`。`main`函数创建了每个派生类的一个实例，并将每个实例通过引用传递给一个名为`who_is_it`的函数，该函数调用`who`方法。这个函数有一个参数，是对`base`的引用，因为这是所有类的基类（对于`derived3`，它的直接基类是`derived2`）。当你运行这段代码时，结果将如下所示：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This output comes from the three calls to the `who_is_it` function, passing
    objects that are instances of the `derived1`, `derived2`, and `derived3` classes.
    Since the parameter is a reference to `base`, it means that the `base::who` method
    is called.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出来自对`who_is_it`函数的三次调用，传递的对象是`derived1`、`derived2`和`derived3`类的实例。由于参数是对`base`的引用，这意味着调用`base::who`方法。
- en: 'Making one simple change will alter this behavior completely:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个简单的改变将完全改变这种行为：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All that has changed is the addition of the `virtual` keyword to the `who`
    method in the base class, but the result is significant. When you run this code,
    the result will be as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有改变的是在基类的`who`方法中添加了`virtual`关键字，但结果是显著的。当你运行这段代码时，结果将如下所示：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You have not changed the `who_is_it` function, nor the methods on the derived
    classes, yet the output of `who_is_it` is very different compared to what it was
    earlier. The `who_is_it` function calls the `who` method through a reference,
    but now, rather than calling the `base::who` method, the `who` method on the actual
    object that the reference aliases is called. The `who_is_it` function has done
    nothing additional to make sure that the derived class function is called--it
    is *exactly* the same as earlier.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有改变`who_is_it`函数，也没有改变派生类的方法，但是`who_is_it`的输出与之前相比非常不同。`who_is_it`函数通过引用调用`who`方法，但是现在，与其调用`base::who`方法不同，实际对象的`who`方法被调用。`who_is_it`函数没有做任何额外的工作来确保派生类方法被调用--它和之前*完全*一样。
- en: The `derived3` class is not derived directly from `base`, instead, it is derived
    from `derived2`, which is itself a child class of `base`. Even so, the method
    dispatching works on instances of the `derived3` class. This illustrates that
    however far up the inheritance chain `virtual` is applied, the method dispatching
    will still work on the inherited method of the derived class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`derived3`类不是直接从`base`派生的，而是从`derived2`派生的，后者本身是`base`的子类。即便如此，方法分派也适用于`derived3`类的实例。这说明了无论`virtual`应用到继承链的多高，方法分派仍然适用于派生类的继承方法。'
- en: It is important to point out that the method dispatching is applied *only* to
    the methods that `virtual` has been applied to in the base class. Any other methods
    in the base class not marked with `virtual` will be called without method dispatching.
    A derived class will inherit a `virtual` method and get the method dispatching
    automatically, it does not have to use the `virtual` keyword on any methods it
    overrides, but it is a useful visual indication as to how the method can be called.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要指出，方法分派*仅*应用于在基类中应用了`virtual`的方法。基类中没有标记为`virtual`的任何其他方法都将在没有方法分派的情况下被调用。派生类将继承一个`virtual`方法并自动获得方法分派，它不必在任何覆盖的方法上使用`virtual`关键字，但这是一个有用的视觉指示，说明方法如何被调用。
- en: 'With the derived classes implementing `virtual` methods, you can use a single
    container to hold pointers to instances of all such classes and invoke their `virtual`
    methods without the invocation code knowing the type of the object:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过派生类实现`virtual`方法，你可以使用一个容器来保存所有这些类的实例的指针，并调用它们的`virtual`方法，而不需要调用代码知道对象的类型：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, the `arr` built-in array holds pointers to objects of the three types
    and the ranged `for` loop iterates through the array and calls the method virtually.
    This gives the expected result:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`arr`内置数组保存了三种类型的对象的指针，范围`for`循环遍历数组并调用方法。这给出了预期的结果：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are three important points about the preceding code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码有三个重要的点：
- en: It is important that a built-in array is used here; there are issues with the
    Standard Library containers like `vector`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里使用内置数组是很重要的；像`vector`这样的标准库容器存在问题。
- en: It is important that the array holds pointers, not objects. If you have an array
    of `base` objects, they will be initialized by slicing the derived objects.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是数组保存的是指针，而不是对象。如果你有一个`base`对象数组，它们将通过切片初始化派生对象。
- en: It is also important that the address of a stack object is used. This is because
    there are issues with destructors.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还重要的是使用堆栈对象的地址。这是因为析构函数存在问题。
- en: These three issues are covered in later sections.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个问题将在后面的章节中讨论。
- en: For a `virtual` method to be called using method dispatching, the derived class
    method must match the same signature as the base class' `virtual` method in terms
    of the name, parameters, and return type. If any of these are different (for example,
    different parameters), then the compiler will think that the derived method is
    a new function, and so when you call the `virtual` method through the base pointer,
    you'll get the base method. This is a rather insidious error because the code
    will compile, but you will get the wrong behavior.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用方法分派调用`virtual`方法，派生类方法必须与基类的`virtual`方法在名称、参数和返回类型方面具有相同的签名。如果其中任何一个不同（例如，参数不同），那么编译器将认为派生方法是一个新函数，因此当您通过基指针调用`virtual`方法时，将得到基方法。这是一个相当隐匿的错误，因为代码将编译，但您将得到错误的行为。
- en: The one exception to the last paragraph is if two methods differ by return types
    that are **covariant**, that is, one type can be converted to the other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段的一个例外是，如果两个方法的返回类型是**协变**的，即一个类型可以转换为另一个类型。
- en: Virtual method tables
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚方法表
- en: The behavior of method dispatching via virtual methods is all you need to know,
    but it is helpful to see how the C++ compiler implements method dispatching because
    it highlights the overhead of the `virtual` methods.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过虚方法进行方法分派的行为是您需要了解的全部，但了解C++编译器如何实现方法分派是有帮助的，因为它突出了`virtual`方法的开销。
- en: When the compiler sees a `virtual` method on a class, it will create a method
    pointer table, called the **vtable**, and put a pointer to each of the `virtual`
    methods in the class in the table. There will be a single copy of the `vtable`
    for the class. The compiler will also add a pointer to this table, called the
    **vptr**, in every instance of the class. So, when you mark a method as `virtual`,
    there will be a single memory overhead of a `vtable` being created for that class
    at runtime, and the memory overhead of an extra data member, the `vptr`, for every
    object created from the class. Normally, when client code calls a (non-inline)
    method, the compiler will place a jump to the function in the client code to the
    method. When the client code calls a `virtual` method, the compiler has to dereference
    the `vptr` to get to the `vtable` and then use the appropriate address stored
    there. Clearly, this involves an extra level of indirection.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器在类上看到一个`virtual`方法时，它将创建一个方法指针表，称为**vtable**，并将类中每个`virtual`方法的指针放入表中。该类将有一个`vtable`的单个副本。编译器还将在类的每个实例中添加一个指向该表的指针，称为**vptr**。因此，当您将方法标记为`virtual`时，将在运行时为该类创建一个`vtable`的单个内存开销，并为从该类创建的每个对象添加一个额外的数据成员，即`vptr`的内存开销。通常，当客户端代码调用（非内联）方法时，编译器将在客户端代码中将跳转到该方法的函数。当客户端代码调用`virtual`方法时，编译器必须解引用`vptr`以获取`vtable`，然后使用存储在其中的适当地址。显然，这涉及额外的间接级别。
- en: 'There is a separate entry in the `vtable` for each `virtual` method in the
    base class, in the order in which they are declared. When you derive from a base
    class with `virtual` methods, the derived class will also have a `vptr`, but the
    compiler will make it point to the `vtable` of the derived class, that is, the
    compiler will populate the `vtable` with the addresses of the `virtual` method
    implementations in the derived class. If the derived class does not implement
    a `virtual` method it inherits, then the pointer in the `vtable` will be to the
    base class method. This is illustrated in the following diagram:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在基类中的每个`virtual`方法都有一个单独的`vtable`条目，按照它们声明的顺序排列。当您从具有`virtual`方法的基类派生时，派生类也将有一个`vptr`，但编译器将使其指向派生类的`vtable`，也就是说，编译器将使用派生类中`virtual`方法实现的地址填充`vtable`。如果派生类没有实现继承的`virtual`方法，则`vtable`中的指针将指向基类方法。这在下图中有所说明：
- en: '![](img/fc74ce55-48c9-4bd6-bd99-e02d38151193.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc74ce55-48c9-4bd6-bd99-e02d38151193.png)'
- en: On the left-hand side, there are two classes; the base class has two virtual
    functions, and the derived class implements just one of these. On the right-hand
    side, there is an illustration of the memory layout. Two objects are shown as
    a `base` object and a `derived` object. Each object has a single `vptr` followed
    by the data members of the class, and the data members are arranged in such a
    way that the base class data members are arranged first, followed by the derived
    class data members. The `vtable` pointers contain method pointers to the `virtual`
    methods. In the case of the base class, the method pointers point to the methods
    implemented on the `base` class. In the case of the derived class, only the second
    method is implemented in the `derived` class, so the `vtable` for this class has
    a pointer to one virtual method in the `base` class and the other in the `derived`
    class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，有两个类；基类有两个虚函数，派生类只实现其中一个。在右侧，有一个内存布局的示例。显示了两个对象，一个是`base`对象，一个是`derived`对象。每个对象都有一个单独的`vptr`，后面是类的数据成员，数据成员的排列方式是基类数据成员首先排列，然后是派生类数据成员。`vtable`指针包含指向`virtual`方法的方法指针。对于基类，方法指针指向`base`类上实现的方法。对于派生类，只有第二个方法在`derived`类中实现，因此该类的`vtable`中有一个指向`base`类中的虚方法和另一个指向`derived`类中的虚方法。
- en: 'This raises the question: what happens if a derived class introduces a new
    method, not available in the base class, and makes that `virtual`? This is not
    inconceivable since the ultimate base class could provide just part of the behavior
    needed and classes derived from it, provide more of the behavior to be called
    through virtual method dispatching on subclasses. The implementation is quite
    simple: the compiler creates a `vtable` for all of the `virtual` methods on the
    class, so if a derived class has extra `virtual` methods, the pointers for these
    appear in the `vtable` after the pointers to the `virtual` methods inherited from
    the base class. When the object is called through a base class pointer, wherever
    that class is in the inheritance hierarchy, it will only see the `vtable` entries
    relevant to it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题：如果派生类引入了一个新方法，在基类中不可用，并将其设为`virtual`，会发生什么？这并非不可想象，因为最终的基类可能只提供所需行为的一部分，从它派生的类提供更多的行为，通过子类上的虚方法分派来调用。实现非常简单：编译器为类上的所有`virtual`方法创建一个`vtable`，因此，如果派生类有额外的`virtual`方法，这些指针将出现在`vtable`中，位于从基类继承的`virtual`方法指针之后。当通过基类指针调用对象时，无论该类在继承层次结构中的位置如何，它只会看到与其相关的`vtable`条目：
- en: '![](img/eccd155e-2d01-427f-96ed-3261ff940476.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eccd155e-2d01-427f-96ed-3261ff940476.png)'
- en: Multiple inheritance and virtual method tables
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承和虚方法表
- en: 'If a class derives from more than one class and the parent classes have `virtual`
    methods, then the vtable for the derived class will be a combination of the vtables
    of its parents arranged in the order in which the parent classes were listed in
    the derivation list:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类从多个类派生，并且父类有`virtual`方法，那么派生类的`vtable`将是其父类的`vtable`的组合，按照派生列表中列出的父类的顺序排列：
- en: '![](img/f3c6f103-1c95-4b1d-ac49-1b656fb4c8d6.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3c6f103-1c95-4b1d-ac49-1b656fb4c8d6.png)'
- en: If the object is accessed through a base class pointer, the `vptr` has access
    to the part of the `vtable` relevant to that base class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过基类指针访问对象，则`vptr`将访问与该基类相关的`vtable`部分。
- en: Virtual methods, construction, and destruction
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚方法、构造和析构
- en: The derived class portion of the object won't be constructed until the constructor
    has completed, so if you call a `virtual` method, the `vtable` entry will not
    be set up to call the correct method. Similarly, in a destructor, the derived
    class portions of the object will have already been destroyed-including their
    data members, and so the `virtual` methods on the derived class cannot be called
    because they may attempt to access data members that no longer exist. If the `virtual`
    method dispatching was allowed in these situations, the result would be unpredictable.
    You should not call a `virtual` method in a constructor or a destructor, if you
    do, the call will resolve to the base class version of the method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的派生类部分直到构造函数完成后才会被构造，因此，如果调用一个`virtual`方法，`vtable`条目将无法设置为调用正确的方法。同样，在析构函数中，对象的派生类部分已经被销毁，包括它们的数据成员，因此无法调用派生类上的`virtual`方法，因为它们可能会尝试访问不再存在的数据成员。如果在这些情况下允许`virtual`方法分派，结果将是不可预测的。你不应该在构造函数或析构函数中调用`virtual`方法，如果这样做，调用将解析为基类版本的方法。
- en: If a class is expected to be called through base class pointers with the `virtual`
    method dispatching, then you should make the destructor `virtual`. We do this
    because a user may delete a base class pointer, and in this situation, you will
    want the derived destructor to be called. If the destructor is not `virtual` and
    the base class pointer is deleted, then only the base class destructor is called,
    potentially causing a memory leak.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类预期通过基类指针调用`virtual`方法分派，那么你应该使析构函数`virtual`。我们这样做是因为用户可能会删除一个基类指针，在这种情况下，你会希望调用派生析构函数。如果析构函数不是`virtual`，并且删除了基类指针，那么只会调用基类析构函数，可能导致内存泄漏。
- en: In general, a base class destructor should be either `protected` and non-virtual,
    or `public` and `virtual`. If the intention is to use the class through base class
    pointers, then the destructor should be `public` and `virtual` so that the derived
    class destructor is called, but if the base class is intended to be used to provide
    services available only through a derived class object, then you should not give
    direct access to base class objects, and so the destructor should be `protected`
    and non-virtual.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，基类的析构函数应该是`protected`且非虚拟的，或者是`public`且`virtual`的。如果意图是通过基类指针使用类，那么析构函数应该是`public`且`virtual`，以便调用派生类的析构函数，但如果基类旨在提供仅通过派生类对象可用的服务，那么你不应该直接访问基类对象，因此析构函数应该是`protected`且非虚拟的。
- en: Containers and virtual methods
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和虚方法
- en: 'One advantage of the `virtual` methods is to put objects related by a base
    class into a container; earlier, we saw a specific case of using a built-in array
    of base class pointers, but what about the Standard Library containers? As an
    example, imagine that you have a class hierarchy where there is one base class,
    `base`, and three derived classes, `derived1`, `derived2`, and `derived3`, and
    each class implements a `virtual` method `who`, as used earlier. One attempt to
    put objects in a container may be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual`方法的一个优势是将由基类相关的对象放入容器；之前，我们看到了使用内置基类指针数组的特定情况，但标准库容器呢？举个例子，假设你有一个类层次结构，其中有一个基类`base`，三个派生类`derived1`、`derived2`和`derived3`，每个类都实现了一个`virtual`方法`who`，就像之前使用的那样。尝试将对象放入容器可能如下所示：'
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The problem is that the vector holds `base` objects, and so as the items in
    the initialization list are put into the container, they are actually used to
    initialize new `base` objects. Since the type of `vec` is `vector<base>`, the
    `push_back` method will slice the object. Thus, the statement that calls the `who`
    method on each object will print a string `base`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于向量保存了`base`对象，因此在初始化列表中的项目放入容器时，它们实际上被用来初始化新的`base`对象。由于`vec`的类型是`vector<base>`，`push_back`方法将切片对象。因此，调用每个对象上的`who`方法的语句将打印一个字符串`base`。
- en: In order to have `virtual` method dispatching, we need to put the whole object
    in the container. We can do this either with a pointer or a reference. To use
    a pointer, you can use the addresses of stack objects as long as the `vector`
    does not live longer than the objects in the container. If you use objects created
    on the heap, then you need to ensure that the objects are deleted appropriately,
    and you can do this using smart pointers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行`virtual`方法分派，我们需要将整个对象放入容器中。我们可以使用指针或引用来实现这一点。使用指针，你可以使用堆栈对象的地址，只要`vector`的生存期不长于容器中的对象。如果你使用在堆上创建的对象，那么你需要确保对象被适当地删除，你可以使用智能指针来实现这一点。
- en: 'You may be tempted to create a container of references:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想创建一个引用容器：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will result in a slew of errors; unfortunately, none of them fully indicate
    the issue. The `vector` must contain types that are copy constructible and assignable.
    This is not the case with references because they are aliases to actual objects.
    There is a solution. The `<functional>` header contains an adapter class called
    `reference_wrapper` that has a copy constructor and assignment operator. The class
    converts a reference of an object to a pointer to that object. Now you can write
    the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一系列错误；不幸的是，它们都没有完全指示问题。`vector`必须包含可复制构造和可赋值的类型。这对引用来说并不成立，因为它们是实际对象的别名。有一个解决方案。`<functional>`头文件包含一个名为`reference_wrapper`的适配器类，它有一个复制构造函数和赋值运算符。该类将对象的引用转换为指向该对象的指针。现在你可以写如下代码：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The downside of using `reference_wrapper` is that to call the wrapped object
    (and their virtual methods), you need to call the `get` method, which will return
    a *reference* to the wrapped object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`reference_wrapper`的缺点是，要调用包装对象（及其虚拟方法），你需要调用`get`方法，它将返回对包装对象的*引用*。
- en: Friends and inheritance
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 友元和继承
- en: In C++, friendship is not inherited. If a class makes another class (or function)
    a friend, it means that the friend has access to its `private` and `protected`
    members as if the friend is a member of the class. If you derive from the `friend`
    class, the new class is not a friend of the first class, and it has no access
    to the members of that first class.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，友元关系不会被继承。如果一个类使另一个类（或函数）成为友元，这意味着友元可以访问它的`private`和`protected`成员，就好像友元是类的成员一样。如果你从`friend`类派生，新类不是第一个类的友元，并且它无法访问第一个类的成员。
- en: 'In the last chapter, we saw how you can insert an object into an `ostream`
    object to print it by writing a global insertion operator and making this a `friend`
    of the class. In the following, the `friend` function is implemented inline, but
    it is actually a separate, global function that can be called without an object
    or name resolution with the class name:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何通过编写全局插入运算符并将其作为类的`friend`来将对象插入`ostream`对象中进行打印。在下面的例子中，`friend`函数是内联实现的，但实际上它是一个独立的全局函数，可以在没有对象或使用类名解析的情况下调用。
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we derive from the `base` class, we will need to implement a `friend` function
    to insert the derived object into the stream. Since the function is a *friend*,
    it will be able to access the `private` and `protected` members of the derived
    class, but it cannot access the `private` members of the base class. This situation
    will mean that the insertion operator that is a *friend* of the derived class
    can only print out part of the object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从`base`类派生，我们将需要实现一个`friend`函数，将派生对象插入流中。由于这个函数是一个*friend*，它将能够访问派生类的`private`和`protected`成员，但它不能访问基类的`private`成员。这种情况意味着作为派生类*friend*的插入运算符只能打印对象的一部分。
- en: If a `derived` class object is cast to a `base` class, say, through a pointer
    or reference when passing by reference, and the object is printed, it will be
    the `base` version of the insertion operator that will be called. The insertion
    operator is a `friend` function so that it has access to the class' non-public
    data members, but being a *friend* is not enough to allow it to be a `virtual`
    method, so there is no `virtual` method dispatching.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`derived`类对象被转换为`base`类，比如通过引用或指针传递，然后打印对象，将调用`base`版本的插入运算符。插入运算符是一个`friend`函数，因此它可以访问类的非公共数据成员，但作为*friend*并不足以使它成为一个`virtual`方法，因此没有`virtual`方法分派。
- en: 'Although the `friend` function cannot be called as a `virtual` method, it can
    call `virtual` methods and get the method dispatching:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`friend`函数不能被调用为`virtual`方法，但它可以调用`virtual`方法并进行方法分派：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this version, there is just one insertion operator and it is defined for
    the `base` class. This means that any object that can be converted to the `base`
    class can be printed using this operator. The actual work of printing out the
    object is delegated to a `virtual` function called `output`. This function is
    protected because it is intended only to be used by the class or derived classes.
    The `base` class version of this prints out the data members of the base class.
    The `derived` class version has two tasks: printing out the data members in the
    `base` class and then printing out the data members specific to the `derived`
    class. The first task is accomplished by calling the `base` class version of the
    method by qualifying the name with the base class name. The second task is simple
    because it has access to its own data members. If you were to derive another class
    from `derived`, then its version of `output` function will be similar, but it
    would call `derived::output`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，只有一个插入运算符，它是为`base`类定义的。这意味着任何可以转换为`base`类的对象都可以使用这个运算符进行打印。打印对象的实际工作被委托给了一个叫做`output`的`virtual`函数。这个函数是受保护的，因为它只打算被类或派生类使用。`base`类版本打印出了基类的数据成员。`derived`类版本有两个任务：打印出基类的数据成员，然后打印出特定于`derived`类的数据成员。第一个任务是通过用基类名称限定名称来调用方法的基类版本来完成的。第二个任务很简单，因为它可以访问自己的数据成员。如果你从`derived`派生另一个类，那么它的`output`函数版本将是类似的，但它将调用`derived::output`。
- en: Now when an object is inserted into an `ostream` object like `cout`, the insertion
    operator will be called, and the call to the `output` method will be dispatched
    to the appropriate derived class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当一个对象被插入到`ostream`对象中，比如`cout`，插入运算符将被调用，并且对`output`方法的调用将被分派到适当的派生类。
- en: Override and final
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖和final
- en: 'As mentioned earlier, if you type the prototype of a derived `virtual` method
    wrong, for example, use the wrong parameter types, the compiler will treat the
    method as a new method and will compile it. It is perfectly legal for a derived
    class not to override the method of the base class; this is a feature that you
    will often want to use. However, if you make a mistake in typing the prototype
    of a derived `virtual` method, the base method will be called when you intended
    your new version to be called. The `override` specifier is designed to prevent
    this bug. When the compiler sees this specifier, it knows that you intend to override
    a `virtual` method inherited from a base class and it will search the inheritance
    chain to find a suitable method. If no such method can be found, then the compiler
    will issue an error:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你错误地输入了派生`virtual`方法的原型，例如，使用了错误的参数类型，编译器将把该方法视为新方法并进行编译。派生类不覆盖基类的方法是完全合法的；这是一个你经常会想要使用的特性。然而，如果你在输入派生`virtual`方法的原型时出现错误，当你打算调用你的新版本时，基本方法将被调用。`override`修饰符旨在防止这种错误。当编译器看到这个修饰符时，它知道你打算覆盖从基类继承的`virtual`方法，并且它将搜索继承链以找到合适的方法。如果找不到这样的方法，那么编译器将发出错误：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, `derived::f` won't compile because there is no method in the inheritance
    chain with the same signature. The `override` specifier gets the compiler to perform
    some useful checks, so it is a good habit to use it on all derived overridden
    methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`derived::f`不会编译，因为在继承链中没有具有相同签名的方法。`override`修饰符让编译器执行一些有用的检查，因此在所有派生的重写方法上使用它是一个好习惯。
- en: 'C++11 also provides a specifier called `final`, which you can apply to a method
    to indicate that a derived class cannot override it, or you can apply it to a
    class to indicate that you cannot derive from it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C++11还提供了一个称为`final`的修饰符，你可以将其应用于方法以指示派生类不能覆盖它，或者将其应用于类以指示你不能从它派生：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It is rare that you'll want to use this.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 很少会想要使用这个。
- en: Virtual inheritance
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟继承
- en: 'Earlier, we talked about the so-called *diamond* problem with multiple inheritance,
    where a class inherits from a single ancestor class via two base classes. When
    a class inherits from another class, it will get the parent class'' data members
    so that an instance of the derived class is treated as being made up of the base
    class data members and the derived class data members. If the parent classes are
    derived from the same ancestor class, they will each get the ancestor class''
    data members resulting in the final derived classes getting copies of the ancestor
    class'' data members from each parent class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们谈到了多重继承中所谓的*菱形*问题，其中一个类通过两个基类从单个祖先类继承。当一个类从另一个类继承时，它将获得父类的数据成员，以便派生类的实例被视为由基类数据成员和派生类数据成员组成。如果父类都是从同一个祖先类派生的，它们将分别获得祖先类的数据成员，导致最终派生类从每个父类获得祖先类的数据成员的副本：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When you create an instance of the `most_derived` class, you have two copies
    of `base` in the object: one from each of the `derived1` and `derived2`. This
    means that the `most_derived` object will have two copies of the data member `x`.
    Clearly, the intention is for the derived class to get just one copy of the ancestor
    class'' data members, so how can this be achieved? The solution to this problem
    is **virtual inheritance**:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`most_derived`类的实例时，对象中会有两个`base`的副本：一个来自`derived1`，一个来自`derived2`。这意味着`most_derived`对象将有两个数据成员`x`的副本。显然，派生类的意图是只获取祖先类的数据成员的一个副本，那么如何实现呢？这个问题的解决方案是**虚拟继承**：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Without virtual inheritance, derived classes just call the constructors of
    their immediate parent. When you use `virtual` inheritance, the `most_derived`
    class has the responsibility to call the constructor of the topmost parent class
    and if you do not explicitly call the base class constructor, the compiler will
    automatically call the default constructor:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 没有虚拟继承时，派生类只调用其直接父类的构造函数。当你使用`virtual`继承时，`most_derived`类有责任调用最顶层父类的构造函数，如果你没有显式调用基类构造函数，编译器将自动调用默认构造函数：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, the `most_derived` constructor calls the `base` constructor
    because this is the base class that its parent classes inherit from virtually.
    The `virtual` base classes are always created before the non-virtual base classes.
    In spite of the call to the `base` constructor in the `most_derived` constructor,
    we still have to call the `base` constructor in the derived classes. If we further
    derive from `most_derived`, then that class must call the constructor of `base`
    too because that is where the `base` object will be created. Virtual inheritance
    is more expensive than single or multiple inheritance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`most_derived`构造函数调用`base`构造函数，因为这是其父类通过虚拟继承继承的基类。`虚拟`基类总是在非虚拟基类之前创建。尽管在`most_derived`构造函数中调用了`base`构造函数，我们仍然必须在派生类中调用`base`构造函数。如果我们进一步从`most_derived`派生，那么该类也必须调用`base`的构造函数，因为那是`base`对象将被创建的地方。虚拟继承比单一或多重继承更昂贵。
- en: Abstract classes
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: A class with `virtual` methods is still a **concrete class**--you can create
    instances of the class. You may decide that you want to provide just a part of
    the functionality, with the intention that a user *has* to derive from the class
    and add the missing functionality.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`virtual`方法的类仍然是一个**具体类**--你可以创建类的实例。你可能决定只提供部分功能，希望用户*必须*从类中派生并添加缺失的功能。
- en: One way to do this is to provide a `virtual` method that has no code. This means
    that you can call the `virtual` method in your class, and at runtime, the version
    of the method in the derived class will be called. However, although this provides
    a mechanism for you to call derived methods in your code, it does not *force*
    the implementation of those `virtual` methods. Instead, the derived class will
    inherit the empty `virtual` methods and if it does not override them, the client
    code will be able to call the empty method. You need a mechanism to *force* a
    derived class to provide an implementation of those `virtual` methods.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是提供一个没有代码的`virtual`方法。这意味着您可以在类中调用`virtual`方法，并且在运行时，将调用派生类中的方法版本。但是，尽管这为您在代码中调用派生方法提供了一种机制，但它并不*强制*实现这些`virtual`方法。相反，派生类将继承空的`virtual`方法，如果它不覆盖它们，客户端代码将能够调用空方法。您需要一种机制来*强制*派生类提供这些`virtual`方法的实现。
- en: 'C++ provides a mechanism called **pure virtual methods** that indicates that
    the method should be overridden by a derived class. The syntax is simple, you
    mark the method with `= 0`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了一种称为**纯虚方法**的机制，表示该方法应该被派生类重写。语法很简单，您可以使用`= 0`标记该方法：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is the complete class; it is all that this class provides for the definition
    of the method `f`. This class will compile even though the method `g` calls a
    method that has no implementation. However, the following will not compile:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的类；这是该类为方法`f`的定义提供的全部内容。即使方法`g`调用了没有实现的方法，这个类也会编译。但是，以下内容将无法编译：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'By declaring a pure virtual function, you make the class abstract, which means
    that you cannot create instances. You can, however, create pointers or references
    to the class and call code on them. This function will compile:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明纯虚函数，使类成为抽象类，这意味着您无法创建实例。但是，您可以创建指向该类的指针或引用，并对其调用代码。这个函数将编译：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This function only knows about the public interface of the class and does not
    care how that is implemented. We have implemented the method `g` to call the method
    `f` to show that you can call a pure virtual method in the same class. In fact,
    you can call the pure virtual function outside the class too; this code is just
    as valid:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只知道类的公共接口，不关心其实现方式。我们已经实现了方法`g`来调用方法`f`，以表明您可以在同一类中调用纯虚方法。实际上，您也可以在类外调用纯虚函数；这段代码同样有效：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The only way to use an abstract class is to derive from it and implement the
    pure virtual functions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象类的唯一方法是从中派生并实现纯虚函数：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here are two classes derived from the abstract class, which both implement
    the pure virtual function. These are concrete classes and you can create instances
    of them:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从抽象类派生的两个类，它们都实现了纯虚函数。这些是具体类，您可以创建它们的实例：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Abstract classes are used to indicate that a specific functionality has to
    be provided by a derived class, and the `= 0` syntax indicates that the method
    body is not provided by the abstract class. In fact, it is more subtle than this;
    the class must be derived and the method called on the derived class must be defined
    on the derived class, but the abstract base class can also provide a body for
    the method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类用于指示特定功能必须由派生类提供，并且`= 0`语法表示抽象类未提供方法体。实际上，情况比这更微妙；类必须是派生的，必须在派生类上定义调用的方法，但抽象基类也可以为该方法提供方法体：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Again, this class cannot be instantiated, you *must* derive from it and you
    *must* implement the method to be able to instantiate an object:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个类不能被实例化，您*必须*从中派生，并且*必须*实现该方法才能实例化对象：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The derived class can call the pure virtual function defined in the abstract
    class, but when external code calls such a method, it will always result (through
    method dispatching) in a call to the implementation of the virtual method on the
    derived class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类可以调用抽象类中定义的纯虚函数，但是当外部代码调用这样的方法时，它将始终导致（通过方法分派）调用派生类上虚方法的实现。
- en: Obtaining type information
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取类型信息
- en: C++ provides type information, that is, you can get information that is unique
    to that type and, which identifies it. C++ is a strongly typed language so the
    compiler will determine type information at compile time and will enforce typing
    rules when it comes to conversions between variable types. Any type checking that
    the compiler does, you can do as the developer. As a general rule of thumb if
    you need to cast using `static_cast`, `const_cast`, `reinterpret_cast`, or C-like
    casts, then you are making the types do something they shouldn't and hence you
    should reconsider rewriting your code. The compiler is very good at telling you
    where there is a misalignment of types, so you should use this as a hint to reassess
    your code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了类型信息，也就是说，您可以获取该类型特有的信息，并对其进行标识。C++是一种强类型语言，因此编译器将在编译时确定类型信息，并在变量类型之间进行转换时强制执行类型规则。编译器进行的任何类型检查，您作为开发人员也可以进行。一般的经验法则是，如果需要使用`static_cast`、`const_cast`、`reinterpret_cast`或类C风格的转换，那么您正在让类型执行其不应执行的操作，因此应重新考虑重写代码。编译器非常擅长告诉您类型不匹配的地方，因此您应该将其视为重新评估代码的提示。
- en: A *no casting* rule can be a bit too strict, and often code using casts is simpler
    to write and easier to read, but such a rule does focus your mind to always question
    whether a cast is needed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*不进行转换*的规则可能过于严格，通常使用转换的代码更容易编写和阅读，但这样的规则确实让您始终质疑是否需要进行转换。'
- en: 'When you use polymorphism, you will often get a pointer or reference to a type
    that is different to the type of the object, and this becomes especially true
    when you move to interface programming where frequently the actual object is unimportant,
    as it is the behavior that is important. There may be occasions when you need
    to obtain type information and the compiler is unable to help you at compile time.
    C++ provides a mechanism to obtain type information called **Runtime Type Information**
    (**RTTI**) because you can obtain this information at runtime. This information
    is obtained using the `typeid` operator on an object:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用多态时，通常会得到一个指向与对象类型不同的类型的指针或引用，当您转向接口编程时，情况变得尤为真实，因为实际对象并不重要，重要的是行为。可能会有需要在编译时无法帮助您的情况。C++提供了一种获取类型信息的机制，称为**运行时类型信息**（**RTTI**），因为您可以在运行时获取此信息。使用对象上的`typeid`运算符获取此信息：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The result is the following printed at the command-line:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行打印以下结果：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This reflects that the `string` class is in fact a `typedef` for the templated
    class, `basic_string`, with a `char` as the character type with character traits
    described by the specialization of the `char_traits` class and an allocator object
    (used to maintain the buffer used by the string), which is a specialization of
    the `allocator` class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了`string`类实际上是模板类`basic_string`的`typedef`，字符类型为`char`，字符特性由`char_traits`类的特化描述，以及分配器对象（用于维护字符串使用的缓冲区），这是`allocator`类的特化。
- en: The `typeid` operator returns a `const` reference to a `type_info` object, and
    in this case, we use the `name` method to return a `const char` pointer to the
    name of the type of the object. This is the readable version of the type name.
    The type name is actually stored in a compact, decorated name, which is obtained
    via the `raw_name` method, but if you want to store objects according to their
    type (in a dictionary object, for example), then a more efficient mechanism is
    to use the 32-bit integer returned from the `hash_code` method rather than the
    decorated name. In all cases, the value returned will be the same for all objects
    of the same type, but different to objects of another type.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeid`运算符返回一个`type_info`对象的`const`引用，在这种情况下，我们使用`name`方法返回对象类型的`const char`指针的名称。这是类型名称的可读版本。类型名称实际上存储在一个紧凑的装饰名称中，可以通过`raw_name`方法获得，但如果您想根据它们的类型（例如在字典对象中）存储对象，那么比较有效的机制是使用`hash_code`方法返回的32位整数，而不是装饰名称。在所有情况下，对于相同类型的所有对象，返回的值将是相同的，但对于另一种类型的对象则不同。'
- en: The `type_info` class has no copy constructor or copy assignment operator, and
    so objects of this class cannot be put in a container. If you want to put `type_info`
    objects in an associative container like a `map`, then you have two options. First
    you can put a pointer to the `type_info` object into a container (a pointer can
    be obtained from a reference); in which case, if the container is ordered, you
    need to define a comparison operator. The `type_info` class has a `before` method,
    which can be used to compare two `type_info` objects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`type_info`类没有复制构造函数或复制赋值运算符，因此无法将此类的对象放入容器中。如果要将`type_info`对象放入像`map`这样的关联容器中，则有两种选择。首先，可以将`type_info`对象的指针放入容器中（可以从引用中获取指针）；在这种情况下，如果容器是有序的，则需要定义比较运算符。`type_info`类有一个`before`方法，可用于比较两个`type_info`对象。'
- en: The second option (in C++11) is to use objects of the `type_index` class as
    the key to the associative container, and this class is used to wrap the `type_info`
    objects.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项（在C++11中）是使用`type_index`类的对象作为关联容器的键，该类用于包装`type_info`对象。
- en: The `type_info` class is intended to be read-only, and the only way to create
    instances is through the `typeid` operator. You can, however, call the comparison
    operators, `==` and `!=`, on `type_info` objects, which means that you can compare
    at runtime the types of objects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`type_info`类旨在是只读的，创建实例的唯一方法是通过`typeid`运算符。但是，您可以在`type_info`对象上调用比较运算符`==`和`!=`，这意味着您可以在运行时比较对象的类型。'
- en: 'Since you can apply the `typeid` operator on both variables and types, it means
    that you can use the operator to perform casts that are safe from slicing or from
    casting to a completely unrelated type:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`typeid`运算符可以应用于变量和类型，这意味着您可以使用该运算符执行安全的转换，避免切片或转换为完全不相关的类型：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This function can take a pointer for any class that is derived from the `base`
    class. The first line uses the conditional operator where the comparison is between
    the type information for the object pointed to by the function parameter and the
    type of the class `derived`. If the pointer is to a `derived` object, then the
    cast will work. If the pointer is to an object of another derived type, but not
    the `derived` class, then the comparison will fail and the expression evaluates
    to `nullptr`. The `call_me` function will only call the `f` method if the pointer
    points to an instance of the `derived` class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以为从`base`类派生的任何类的指针。第一行使用条件运算符，其中比较是函数参数指向的对象的类型信息与类`derived`的类型之间的比较。如果指针指向`derived`对象，则转换将起作用。如果指针指向另一个派生类型的对象，但不是`derived`类，则比较将失败，并且表达式将求值为`nullptr`。只有当指针指向`derived`类的实例时，`call_me`函数才会调用`f`方法。
- en: 'C++ provides a cast operator that performs runtime, and such type checking
    at runtime is called `dynamic_cast`. If the object can be cast to the requested
    type, then the operation will succeed and return a valid pointer. If the object
    cannot be accessed through the requested pointer, then the cast fails and the
    operator returns `nullptr`. This means that whenever you use `dynamic_cast`, you
    should always check the returned pointer before using it. The `call_me` function
    can be rewritten as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了一个执行运行时的转换操作符，这种类型检查在运行时称为`dynamic_cast`。如果对象可以转换为请求的类型，则操作将成功并返回有效指针。如果对象无法通过请求的指针访问，则转换失败，操作符返回`nullptr`。这意味着每当您使用`dynamic_cast`时，都应该在使用之前检查返回的指针。`call_me`函数可以重写如下：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is essentially the same code as earlier; the `dynamic_cast` operator performs
    runtime type checking and returns an appropriate pointer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是与之前相同的代码；`dynamic_cast`运算符执行运行时类型检查并返回适当的指针。
- en: 'Note that you cannot downcast, neither to a `virtual` base class pointer nor
    to a class derived through `protected` or `private` inheritance. The `dynamic_cast`
    operator can be used for casts other than downcasts; clearly, it will work for
    an upcast (to a base class, although it is not necessary), it can be used for
    casts sideways:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不能进行向下转换，无论是到`virtual`基类指针还是到通过`protected`或`private`继承派生的类。`dynamic_cast`运算符可用于除向下转换之外的转换；显然，它将适用于向上转换（到基类，尽管不是必要的），它可用于侧向转换：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here there are two base classes, so if you access a derived object through
    one of the base class pointers, you can use the `dynamic_cast` operator to cast
    to a pointer of the other base class:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个基类，因此如果您通过其中一个基类指针访问派生对象，您可以使用`dynamic_cast`运算符将其转换为另一个基类的指针：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Smart pointers and virtual methods
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能指针和虚方法
- en: If you want to use dynamically created objects, you will want to use smart pointers
    to manage their lifetime. The good news is that `virtual` method dispatching works
    through smart pointers (they are simply wrappers around object pointers), and
    the bad news is that the class relationships are lost when you use smart pointers.
    Let's examine why.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用动态创建的对象，您将希望使用智能指针来管理它们的生命周期。好消息是，`virtual`方法分派通过智能指针（它们只是对象指针的包装器）工作，坏消息是，当您使用智能指针时，类关系会丢失。让我们来看看为什么。
- en: 'For example, the following two classes are related by inheritance:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下两个类是通过继承相关的：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is straightforward: that implement a `virtual` method, which indicates
    the type of the object. There is, a `virtual` destructor because we are going
    to hand over the lifetime management to a smart pointer object and we want to
    ensure that the `derived` class destructor is called appropriately. You can create
    an object on the heap using `make_shared` or the constructor of the `shared_ptr`
    class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单：实现一个`virtual`方法，指示对象的类型。有一个`virtual`析构函数，因为我们将把生命周期管理交给智能指针对象，并且我们希望确保适当地调用`derived`类析构函数。您可以使用`make_shared`或`shared_ptr`类的构造函数在堆上创建对象：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A derived class pointer can be converted to a base class pointer and this is
    explicit in the first statement: `new` returns a `derived*` pointer, which is
    passed to a `shared_ptr<base>` constructor that expects a `base*` pointer. The
    situation in the second statement is a bit more complicated. The `make_shared`
    function returns a temporary `shared_ptr<derived>` object that is converted to
    a `shared_ptr<base>` object. This is carried out by a conversion constructor on
    the `shared_ptr` class that calls a **compiler intrinsic** called `__is_convertible_to`,
    which determines if one pointer type can be converted to the other. In this case,
    there is an upcast so the conversion is allowed.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类指针可以转换为基类指针，这在第一条语句中是明确的：`new`返回一个`derived*`指针，传递给期望一个`base*`指针的`shared_ptr<base>`构造函数。第二条语句中的情况稍微复杂一些。`make_shared`函数返回一个临时的`shared_ptr<derived>`对象，它被转换为一个`shared_ptr<base>`对象。这是通过`shared_ptr`类上的一个转换构造函数执行的，该构造函数调用了一个名为`__is_convertible_to`的**编译器内在**，它确定一个指针类型是否可以转换为另一个。在这种情况下，有一个向上转换，因此允许转换。
- en: Compiler intrinsic are essentially functions provided by the compiler. In this
    example `__is_convertible_to(derived*, base*)` will return `true` and `__is_convertible_to(base*,
    derived*)` will return `false`. You will rarely need to know about intrinsics
    unless you are writing libraries.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器内在本质上是编译器提供的函数。在这个例子中，`__is_convertible_to(derived*, base*)`将返回`true`，而`__is_convertible_to(base*,
    derived*)`将返回`false`。除非您正在编写库，否则您很少需要了解内在本质。
- en: Since a temporary object is created in the statement using the `make_shared`
    function, it is more efficient to use the first statement.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在使用`make_shared`函数的语句中创建了一个临时对象，因此使用第一条语句更有效。
- en: 'The `operator->` on a `shared_ptr` object will give direct access to the wrapped
    pointer and hence this means that the following code will perform `virtual` method
    dispatching, as expected:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`对象上的`operator->`将直接访问包装的指针，因此这意味着以下代码将执行`virtual`方法分派，如预期的那样：'
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The smart pointer will ensure that the derived object is destroyed through the
    base class pointer when `b_ptr` goes out of scope, and since we have a `virtual`
    destructor, appropriate destruction will occur.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当`b_ptr`超出范围时，智能指针将确保通过基类指针销毁派生对象，并且由于我们有一个`virtual`析构函数，适当的销毁将发生。
- en: 'If you have multiple inheritance, you can use `dynamic_cast` (and RTTI) to
    cast between pointers to the base classes so that you can select only the behavior
    that you need. Consider the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多重继承，您可以使用`dynamic_cast`（和RTTI）在基类指针之间进行转换，以便只选择您需要的行为。考虑以下代码：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you have a pointer to either of these base classes, you can convert one
    to the other:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有指向这些基类的指针，您可以将一个转换为另一个：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `who` and `what` methods can be called on a `derived*` pointer and hence
    they can be called on the smart pointer. The following lines obtain a base class
    pointer so that *specific* behavior is accessed. In this code, we call the `get`
    method to get the raw pointer from the smart pointer. The problem with this method
    is that there is now a pointer to the object that is not protected by the smart
    pointer lifetime management, so it is possible for code to call `delete` on either
    pointer `b1_ptr` or `b2_ptr` and cause problems later when the smart pointer attempts
    to delete the object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`who`和`what`方法可以在`derived*`指针上调用，因此它们也可以在智能指针上调用。以下行获取基类指针，以便访问*特定*行为。在这段代码中，我们调用`get`方法从智能指针获取原始指针。这种方法的问题在于现在有一个指向对象的指针，它没有受到智能指针生命周期管理的保护，因此代码可能调用`delete`来删除`b1_ptr`或`b2_ptr`指针，从而在智能指针尝试删除对象时造成问题。'
- en: 'This code works, and there is correct lifetime management of the dynamically-created
    object in this code, but accessing raw pointers like this is inherently unsafe
    because there is no guarantee that the raw pointers will not be deleted. The temptation
    is to use smart pointers:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以运行，而且在这段代码中动态创建的对象有正确的生命周期管理，但是像这样访问原始指针本质上是不安全的，因为无法保证原始指针不会被删除。诱惑是使用智能指针：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The problem is that even though the classes `base1` and `derived` are related,
    the classes `shared_ptr<derived>` and `shared_ptr<base1>` are *not* related, and
    so a different control block will be used for each smart pointer type even though
    they refer to the *same object*. The `shared_ptr` class will reference the count
    using the control block and will delete the object when the reference count falls
    to zero. Having two unrelated `shared_ptr` objects and two control blocks to the
    same object means that they will attempt to manage the lifetime of the `derived`
    object independently of each other, and this will ultimately mean one smart pointer
    deleting the object before the other has finished with it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，尽管类`base1`和`derived`是相关的，但类`shared_ptr<derived>`和`shared_ptr<base1>`*不*相关，因此每种智能指针类型将使用不同的控制块，即使它们指向*同一个对象*。`shared_ptr`类将使用控制块引用计数，并在引用计数降至零时删除对象。拥有两个不相关的`shared_ptr`对象和两个控制块指向同一个对象意味着它们将独立地尝试管理`derived`对象的生命周期，这最终意味着一个智能指针在另一个智能指针完成之前删除对象。
- en: 'There are three messages here: a smart pointer is a lightweight wrapper around
    a pointer, so you can call `virtual` methods with method dispatching; however,
    be cautious about using raw pointers obtained from smart pointers, and bear in
    mind that although you can have many `shared_ptr` objects to the same object,
    they must be of the same type so that only one control block is used.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三条信息：智能指针是指针的轻量级包装器，所以你可以使用方法分派调用`virtual`方法；然而，要谨慎使用从智能指针获取的原始指针，并且要记住，虽然你可以有许多指向同一对象的`shared_ptr`对象，但它们必须是相同类型的，以便只使用一个控制块。
- en: Interfaces
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Pure virtual functions and virtual method dispatching leads to an incredibly
    powerful way of writing object-orientated code, which is called **interfaces**.
    An interface is a class that has no functionality; it only has pure virtual functions.
    The purpose of an interface is to define a behavior. A concrete class that derives
    from an interface *must* provide an implementation of all of the methods on the
    interface, and hence this makes the interface a kind of contract. Users of objects
    that implement an interface have a guarantee that the object that has the interface
    will implement *all* the methods of the interface. Interface programming decouples
    behavior from the implementation. Client code is only interested in behavior and
    they are not interested in the actual class that provides the interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 纯虚函数和虚方法分派导致了一种非常强大的编写面向对象代码的方式，这被称为**接口**。接口是一个没有功能的类；它只有纯虚函数。接口的目的是定义一种行为。从接口派生的具体类*必须*提供接口上所有方法的实现，因此这使得接口成为一种契约。实现接口的对象的用户保证对象将实现接口的*所有*方法。接口编程将行为与实现解耦。客户端代码只对行为感兴趣，他们对提供接口的实际类不感兴趣。
- en: For example, an `IPrint` interface could give access to the behavior of printing
    a document (setting page size, orientation, number of copies, and telling the
    printer to print the document). The `IScan` interface can give access to the behavior
    of scanning a sheet of paper (resolution, grayscale or color, and adjustments
    like rotation and cropping). These two interfaces are two different behaviors.
    Client code will use an `IPrint` if it wants to print a document or an `IScan`
    interface pointer if it wants to scan a document. Such client code does not care
    whether it is a `printer` object that implements the `IPrint` interface or a `printer_scanner`
    object that implements both the `IPrint` and `IScan` interfaces. Client code that
    is passed to an `IPrint*` interface pointer is guaranteed that it can call every
    method.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`IPrint`接口可以访问打印文档的行为（设置页面大小、方向、副本数量，并告诉打印机打印文档）。`IScan`接口可以访问扫描纸张的行为（分辨率、灰度或彩色，以及旋转和裁剪等调整）。这两个接口是两种不同的行为。客户端代码将使用`IPrint`，如果要打印文档，或者使用`IScan`接口指针，如果要扫描文档。这样的客户端代码不在乎是实现了`IPrint`接口的`printer`对象，还是实现了`IPrint`和`IScan`接口的`printer_scanner`对象。传递给`IPrint*`接口指针的客户端代码保证可以调用每个方法。
- en: 'In the following code, we have defined the `IPrint` interface (the `define`
    makes it more obvious that we are defining abstract classes as interfaces):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们定义了`IPrint`接口（`define`使得我们更清楚地定义抽象类作为接口）：
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'A class can implement this interface:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以实现这个接口：
- en: '[PRE63]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can then create the `printer` object and call the function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以创建`printer`对象并调用该函数：
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Our inkjet printer is also a scanner, so we can make it implement the `IScan`
    interface:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的喷墨打印机也是扫描仪，所以我们可以让它实现`IScan`接口：
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The next version of the `inkject_printer` class can use multiple inheritance
    to implement this interface, but note that there is a problem. The class already
    implements a method called `set_page`, and since the page properties of the printer
    will be different from the page properties of the scanner, we want a different
    method for the `IScan` interface. We can address this with two different methods
    and qualifying their names:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`inkject_printer`类的下一个版本可以使用多重继承来实现这个接口，但请注意存在一个问题。该类已经实现了一个名为`set_page`的方法，由于打印机的页面属性将与扫描仪的页面属性不同，我们希望为`IScan`接口使用不同的方法。我们可以通过两种不同的方法来解决这个问题，并对它们的名称进行限定：'
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we can get the `IScan` interface on the `inkjet` object and call it as
    a scanner:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以获取`inkjet`对象上的`IScan`接口，并将其作为扫描仪调用：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Since the `inkject_printer` class derives from both the `IPrinter` and `IScan`
    interfaces, you can obtain one interface pointer and cast to the other through
    the `dynamic_cast` operator since this will use RTTI to ensure that the cast is
    possible. So assuming that you''ve got an `IScanner` interface pointer, you can
    test to see if you can cast this to an `IPrint` interface pointer:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`inkject_printer`类从`IPrinter`和`IScan`接口派生，您可以通过`dynamic_cast`运算符获得一个接口指针，并通过它转换为另一个接口，因为这将使用RTTI来确保转换是可能的。因此，假设您有一个`IScanner`接口指针，您可以测试是否可以将其转换为`IPrint`接口指针：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Effectively, the `dynamic_cast` operator is being used to request one interface
    pointer if the behavior represented by another interface is unavailable on the
    object that pointer points to.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`dynamic_cast`运算符被用于在指向的对象上请求一个接口指针，如果另一个接口表示的行为在该对象上不可用。
- en: An interface is a contract; once you have defined it, you should *never* change
    it. This does not constrain you from changing the class. In fact, this is the
    advantage of using interfaces because the class implementation can change completely,
    but as long as it continues to implement the interfaces that the client code uses,
    users of the class can continue to use the class (although a recompile will be
    needed). There are cases when you will discover that the interface you defined
    is inadequate. Perhaps there is a parameter which is incorrectly typed that you
    need to fix, or perhaps you need to add additional functionality.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种契约；一旦您定义了它，就不应该再更改。这并不限制您更改类。事实上，这就是使用接口的优势，因为类的实现可以完全改变，但只要它继续实现客户端代码使用的接口，类的用户就可以继续使用类（尽管需要重新编译）。有时您会发现您定义的接口是不足够的。也许有一个参数被错误地类型化，您需要修复，或者您需要添加额外的功能。
- en: 'For example, imagine that you want to tell the printer object to print an entire
    document rather than a page at a time. The way to do this is to derive from the
    interface that needs changing and create a new interface; interface inheritance:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想要告诉打印机对象一次打印整个文档而不是一页一页地打印。要做到这一点，需要从需要更改的接口派生，并创建一个新的接口；接口继承：
- en: '[PRE69]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Interface inheritance means that `IPrint2` has three methods, `set_page`, `print_page`,
    and `print_doc`. Since the `IPrint2` interface is an `IPrint` interface, this
    means that when you implement the `IPrint2` interface, you also implement the
    `IPrint` interface, so you need to change the class to derive from the `IPrint2`
    interface to add the new functionality:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接口继承意味着`IPrint2`有三个方法，`set_page`，`print_page`和`print_doc`。由于`IPrint2`接口是`IPrint`接口，这意味着当您实现`IPrint2`接口时，您也实现了`IPrint`接口，因此需要更改类以从`IPrint2`接口派生以添加新功能：
- en: '[PRE70]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The other two methods on the `IPrint2` interface already exist on this class
    from the implementation of the `IPrint` interface. Now, a client can obtain both
    `IPrint` pointers and `IPrint2` pointers from instances of this class. You have
    extended the class, and yet the older client code will still compile.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPrint2`接口上的另外两个方法已经存在于该类中，因为实现了`IPrint`接口。现在，客户端可以从该类的实例中获取`IPrint`指针和`IPrint2`指针。您已经扩展了类，但旧的客户端代码仍将编译通过。'
- en: Microsoft's **Component Object Model** (**COM**) takes this concept a step further.
    COM is based upon interface programming, so COM objects are only ever accessed
    through interface pointers. The extra step is that this code can be loaded into
    your process using a dynamic loaded library, or in another process on your machine
    or on another machine, and since you use interface programming, the objects are
    accessed in *exactly* the same way regardless of their location.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的**组件对象模型**（**COM**）将这个概念推进了一步。COM基于接口编程，因此只能通过接口指针访问COM对象。额外的一步是，这段代码可以加载到您的进程中，使用动态加载库，或者加载到您的机器上的另一个进程中，或者加载到另一台机器上，由于使用接口编程，无论位置如何，都可以以*完全*相同的方式访问对象。
- en: Class relationships
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类关系
- en: 'Inheritance appears to be an ideal way to reuse code: you write it once in
    as generic way possible and then derive a class from the base class and reuse
    the code, specializing it if necessary. You will find, however, a lot of advice
    against this. Some people will tell you that inheritance is the worst way possible
    to reuse code and you should use composition instead. In fact, the situation is
    somewhere between the two: inheritance offers some benefits, but it should not
    be treated as the best or only solution.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 继承似乎是重用代码的理想方式：您可以以尽可能通用的方式编写代码，然后从基类派生一个类，并重用代码，必要时进行特化。然而，您会发现很多人反对这种做法。有些人会告诉您，继承是重用代码的最糟糕方式，您应该使用组合代替。实际上，情况介于两者之间：继承提供了一些好处，但不应将其视为最佳或唯一的解决方案。
- en: 'It is possible to get carried away with designing a class library, and there
    is a general principle to bear in mind: the more code you write, the more maintenance
    you (or someone else) will have to do. If you change a class, all the other classes
    that depend upon it will change.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 设计类库时可能会走火入魔，有一个一般原则需要牢记：您写的代码越多，您（或其他人）就必须做的维护工作就越多。如果更改一个类，所有依赖它的其他类都将发生变化。
- en: 'At the highest level, you should be aware of three main issues to avoid:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高级别，您应该注意避免的三个主要问题：
- en: '**Rigidity**: It is too hard to change a class because any change will affect
    too many other classes.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**僵化性**：更改类太困难，因为任何更改都会影响太多其他类。'
- en: '**Fragility**: When you change your class, it could cause unexpected changes
    in other classes.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脆弱性**：更改类可能会导致其他类出现意外更改。'
- en: '**Immobility**: It is hard to reuse the class because it is too dependent on
    other classes.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可移动性**：很难重用类，因为它过于依赖其他类。'
- en: This occurs when you have tight coupling between classes. In general, you should
    design your classes to avoid this and interface programming is an excellent way
    to do this because an interface is simply a behavior and not an instance of a
    specific class.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当类之间存在紧密耦合时就会出现这种情况。通常，您应该设计您的类以避免这种情况，接口编程是一个很好的方法，因为接口只是一种行为，而不是特定类的实例。
- en: Such problems occur when you have *dependency inversion*, that is, higher level
    code, using components, becomes dependent upon the details of how the lower level
    components are implemented. If you have code that performs some action and then
    logs the result if you write that logging to use a specific device (say the `cout`
    object), then the code is rigidly coupled to, and dependent upon, that logging
    device and you have no option in the future to change to another device. If you
    abstract the functionality, typically, through an interface pointer-then you break
    this dependency enabling the code to be used with other components in the future.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当您存在*依赖反转*时，就会出现这样的问题，即更高级别的代码使用组件时会依赖于较低级别组件的实现细节。如果您编写执行某些操作然后记录结果的代码，并且将记录到特定设备（比如`cout`对象）中，那么代码就会严格耦合并依赖于该记录设备，未来无法更改为其他设备。如果您通过接口指针来抽象功能，那么就会打破这种依赖，使代码能够在未来与其他组件一起使用。
- en: Another principle is that in general you should design your classes to be extendable.
    Inheritance is quite a brute force mechanism to extend a class because you are
    creating a whole new type. If the functionality only needs to be refined, then
    inheritance can be an overkill. A more lightweight form of refining an algorithm
    is to pass a method pointer (or a functor), or an interface pointer to the method
    of a class for that method to call at an appropriate time to refine how it works.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原则是，通常应该设计可扩展的类。继承是一种相当蛮力的扩展类的机制，因为您正在创建一个全新的类型。如果功能只需要进行细化，那么继承可能会过度。一种更轻量级的细化算法的方法是传递一个方法指针（或者一个函数对象），或者一个接口指针给类的方法，以便在适当的时候调用该方法来细化其工作方式。
- en: For example, most sort algorithms require that you pass a method pointer to
    perform comparisons of two objects of the type that it is sorting. The sort mechanism
    is generic and does the work of ordering the objects in the most efficient manner,
    but it bases this on you telling it how to order the two objects. It is excessive
    to write a new class for every type since the majority of the algorithm remains
    the same.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大多数排序算法要求您传递一个方法指针来执行对其正在排序的两个对象进行比较。排序机制是通用的，以最有效的方式对对象进行排序，但这是基于您告诉它如何对这两个对象进行排序。为每种类型编写一个新类是多余的，因为大多数算法保持不变。
- en: Using mixin classes
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用混合类
- en: The **mixin** technique allows you to provide extensibility to classes without
    the lifetime issues of composition or the heavyweight aspect of raw inheritance.
    The idea here is that you have a library with specific functionality that can
    be added to an object. One way to do this is to apply it as a base class with
    `public` methods, and so if the derived class publicly derives from that class,
    it will also have those methods as `public` methods. This works fine unless the
    functionality requires that the derived class performs some functionality too
    in those methods, in which case the documentation of the library will require
    that the derived class overrides the method, calls the base class implementation,
    and adds their own code to the method to complete the implementation (the base
    class method could be called before, or after the extra derived class code, and
    the documentation would have to specify this). We have seen this used several
    times so far in this chapter, and it is a technique used by some older class libraries,
    for example, Microsoft's **Foundation Classes library** (**MFC**). Visual C++
    makes this easier because it generates MFC code with a wizard tool and there are
    comments about where the developer should add their code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合**技术允许您为类提供可扩展性，而不会出现组合的生命周期问题或原始继承的重量级方面。这里的想法是，您有一个具有特定功能的库，可以将其添加到对象中。一种方法是将其应用为具有`public`方法的基类，因此如果派生类公开从该类派生，它也将具有这些方法作为`public`方法。这很好地工作，除非功能要求派生类在这些方法中也执行某些功能，此时库的文档将要求派生类覆盖该方法，调用基类实现，并添加自己的代码以完成实现（基类方法可以在额外的派生类代码之前或之后调用，文档必须指定这一点）。迄今为止，在本章中我们已经看到这种方法被多次使用，这是一些旧的类库使用的技术，例如微软的**基础类库**（**MFC**）。Visual
    C++使这变得更容易，因为它使用向导工具生成MFC代码，并且有关开发人员应该在何处添加其代码的注释。'
- en: The problem with this approach is that it requires the developer deriving from
    the base class implements specific code and follows the rules.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，它要求从基类派生的开发人员实现特定的代码并遵循规则。
- en: There is a possibility that the developer will write code that compiles and
    runs, but since it is not written to the desired rules, it has the wrong behavior
    at runtime.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可能会编写可以编译和运行的代码，但由于未按照期望的规则编写，因此在运行时会出现错误的行为。
- en: A mixin class turns this concept on its head. Instead of the developer deriving
    from a base class provided by the library and extending the functionality provided,
    the mixin class provided by the library *is derived from a class provided by the
    developer*. This solves several problems. First, the developer will have to provide
    specific methods as required by the documentation, otherwise the mixin class (which
    will use those methods) will not compile. The compiler is enforcing the rules
    of the class library author to require that the developer using the library provides
    specific code. Second, the methods on the mixin class can call the base class
    methods (provided by the developer) exactly where it needs them. The developer
    using the class library is no longer provided with detailed instructions about
    how their code is developed, other than that, they have to implement certain methods.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类将这个概念颠倒过来。开发人员不再从库提供的基类派生并扩展提供的功能，而是库提供的混合类*从开发人员提供的类派生*。这解决了几个问题。首先，开发人员必须按照文档要求提供特定的方法，否则混合类（将使用这些方法）将无法编译。编译器强制执行类库作者的规则，要求使用库的开发人员提供特定的代码。其次，混合类上的方法可以在需要的地方调用基类方法（由开发人员提供）。使用类库的开发人员不再提供关于他们的代码如何开发的详细说明，除了他们必须实现某些方法。
- en: 'So, how can this be achieved? The class library author does not know about
    the code that the client developer will write and they do not know about the names
    of the classes a client developer will write, so they cannot derive from such
    classes. C++ allows you to provide a type through a template parameter so that
    the class is instantiated using this type at compile time. With mixin classes,
    the type passed through a template parameter is the name of a type that will be
    used as the base class. The developer simply provides a class with the specific
    methods and then creates a specialization of the mixin class using their class
    as the template parameter:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何实现这一点呢？类库作者不知道客户端开发人员将编写的代码，也不知道客户端开发人员将编写的类的名称，因此他们无法从这样的类派生。C++允许您通过模板参数提供类型，以便在编译时使用该类型实例化类。对于混合类，通过模板参数传递的类型是将用作基类的类型的名称。开发人员只需提供一个具有特定方法的类，然后使用他们的类作为模板参数创建混合类的特化：
- en: '[PRE71]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This class is used in this way:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是这样使用的：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As you can see, the `mixin` class implements a method called `something` and
    it calls a base class method called `something`. This means that a client developer
    using the functionality of the mixin class must implement a method with this name
    and with the same prototype, otherwise the mixin class cannot be used. The client
    developer writing the `impl` class does not know how or where their code will
    be used, just that they have to provide methods with specific names and prototypes.
    In this case, the `mixin::something` method calls the base class method in the
    code between the functionality that it provides, the writer of the `impl` class
    does not need to know this. The output of this code is as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`mixin`类实现了一个名为`something`的方法，并调用了一个名为`something`的基类方法。这意味着使用混合类功能的客户端开发人员必须实现一个具有相同名称和原型的方法，否则无法使用混合类。编写`impl`类的客户端开发人员不知道他们的代码将如何被使用，只知道他们必须提供具有特定名称和原型的方法。在这种情况下，`mixin::something`方法在提供的功能之间调用基类方法，`impl`类的编写者不需要知道这一点。这段代码的输出如下：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This shows that the `mixin` class can call the `impl` class where it thinks
    is appropriate. The `impl` class only has to provide the functionality; the `mixin`
    class determines how it is used. In fact, any class that implements a method with
    the right name and prototype can be provided as a parameter to the template of
    the `mixin` class-even another mixin class!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`mixin`类可以在它认为合适的地方调用`impl`类。`impl`类只需提供功能；`mixin`类确定如何使用它。实际上，只要实现了具有正确名称和原型的方法的任何类都可以作为`mixin`类的模板的参数提供-甚至另一个混合类！
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This can be used like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以这样使用：
- en: '[PRE75]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The result will be as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE76]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that the `mixin` and `mixin2` classes know nothing about each other, other
    than the fact that the appropriate methods are implemented.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`mixin`和`mixin2`类除了实现适当的方法之外，对彼此一无所知。
- en: Since the mixin class cannot be used without the type provided by the template
    parameter, they are sometimes called abstract subclasses.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有提供模板参数的类型，混合类有时被称为抽象子类。
- en: 'This works fine if the base class only has a default constructor. If the implementation
    requires another constructor, then the mixin must know what constructor to call
    and must have appropriate parameters. Also, if you chain the mixins, then they
    get coupled through the constructors. One way to get around this is to use two
    stage construction, that is, provide a named method (say, `init`) used to initialize
    data members in the object after construction. The mixin classes will still be
    created using their default constructors as earlier, and so there will be no coupling
    between the classes, that is, the `mixin2` class will know nothing about the data
    members of `mixin` or those of `impl`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基类只有一个默认构造函数，那么这将起作用。如果实现需要另一个构造函数，那么混合类必须知道调用哪个构造函数，并且必须具有适当的参数。另外，如果链接混合类，那么它们将通过构造函数耦合在一起。解决这个问题的一种方法是使用两阶段构造，也就是说，提供一个命名方法（比如`init`）用于在构造后初始化对象的数据成员。混合类仍将使用它们的默认构造函数创建，因此类之间不会有耦合，也就是说，`mixin2`类将不知道`mixin`或`impl`的数据成员：
- en: '[PRE77]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This works because you can call a public base class method as long as you qualify
    the name of the method. The parameter list in these three `init` methods can be
    different. However, this does pose the problem that the client now has to initialize
    all the base classes in the chain.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为只要限定方法的名称，就可以调用公共基类方法。这三个`init`方法中的参数列表可以不同。然而，这确实带来了一个问题，即客户端现在必须初始化链中的所有基类。
- en: This is the approach that Microsoft's **ActiveX Template Library** (**ATL**)
    (now part of MFC) uses to provide implementation of standard COM interfaces.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微软的**ActiveX模板库**（**ATL**）（现在是MFC的一部分）用来提供标准COM接口的实现的方法。
- en: Using polymorphism
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多态
- en: In the following example, we will create code that simulates a team of C++ developers.
    The code will use interfaces to decouple the classes so that it is possible to
    change the services that a class uses without changing that class. In this simulation,
    we have a manager managing a team, so a property of the manager is their team.
    Further, every worker, whether a manager or a team member have some common properties
    and behaviors--they all have a name and a job position and they all do work of
    some kind.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建模拟C++开发团队的代码。该代码将使用接口来解耦类，以便可以更改类使用的服务而不更改该类。在这个模拟中，我们有一个经理管理一个团队，因此经理的一个属性是他们的团队。此外，每个工人，无论是经理还是团队成员，都有一些共同的属性和行为--他们都有一个名称和工作职位，他们都做某种工作。
- en: 'Create a folder for the chapter and in that folder, create a file called `team_builder.cpp`,
    and since this application will use a `vector`, smart pointers, and files, add
    the following lines to the top of the file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为该章节创建一个文件夹，在该文件夹中创建一个名为`team_builder.cpp`的文件，并且由于此应用程序将使用`vector`、智能指针和文件，因此在文件顶部添加以下行：
- en: '[PRE78]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The application will have command-line parameters, but for the time being,
    just provide an empty copy of the `main` function:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将具有命令行参数，但目前只需提供一个空的`main`函数副本：
- en: '[PRE79]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We are going to define interfaces, so before the `main` function, add the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义接口，因此在`main`函数之前添加以下内容：
- en: '[PRE80]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This is just syntactic sugar, but it makes the code a bit more readable to
    show the purpose of the abstract classes. Under this, add the following interfaces:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一种语法糖，但它使代码更易读，以显示抽象类的目的。在此之下，添加以下接口：
- en: '[PRE81]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'All the workers will implement the first interface, which gives access to their
    name and job position and a method that tells them to do some work. The two types
    of workers we will define are a manager who manages a team by scheduling their
    time and a developer who writes code. The manager has a `vector` of `IWork*` pointers,
    and since these pointers will be to objects created on the free store, the `vector`
    members are smart pointers wrapping these pointers. This is saying that the manager
    maintains the lifetime of these objects: while the manager object exists; so will
    their team.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工人都将实现第一个接口，该接口允许访问他们的名称和工作职位以及告诉他们做一些工作的方法。我们将定义两种类型的工人，一个通过安排时间来管理团队的经理和编写代码的开发人员。经理有一个`IWork*`指针的`vector`，由于这些指针将指向在自由存储上创建的对象，因此`vector`成员是包装这些指针的智能指针。这意味着经理维护这些对象的生命周期：只要经理对象存在，他们的团队也会存在。
- en: 'The first action is to create a helper class that does the basic work of a
    worker. The reason for this will be apparent later in the example. This class
    will implement the `IWork` interface:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是创建一个助手类，该类执行工人的基本工作。稍后在示例中将会看到这一点。该类将实现`IWork`接口：
- en: '[PRE82]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'A `worker` object must be created with a name and job position. We will also
    have a helper class for a manager:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用名称和工作职位创建一个`worker`对象。我们还将为经理创建一个助手类：
- en: '[PRE83]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note that the `do_work` method is implemented in terms of the virtual function,
    `manage_team`, which means that a derived class only needs to implement the `manage_team`
    method since it will inherit the `do_work` method from its parent and method dispatching
    will mean the correct method is called. The rest of the class is straightforward,
    but note that the constructor calls the base class constructor to initialize the
    name and job position (a manager is, after all, a worker) and that the `manager`
    class has a function to add items to the team as shared in smart pointers.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`do_work`方法是根据虚函数`manage_team`实现的，这意味着派生类只需要实现`manage_team`方法，因为它将从其父类继承`do_work`方法，并且方法分派将意味着调用正确的方法。类的其余部分很简单，但请注意构造函数调用基类构造函数以初始化名称和工作职位（毕竟，经理也是工人），并且`manager`类有一个函数来使用智能指针将项目添加到团队中。
- en: 'To test this out, we need to create a `manager` class that manages developers:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们需要创建一个管理开发人员的`manager`类：
- en: '[PRE84]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This overrides calls to the base class constructor passing the name of the
    project manager and a literal describing the job. The class also overrides `manage_team`
    to say what the manager actually does. At this point, you should be able to create
    a `project_manager` and add some members to their team (use the `worker` objects,
    you''ll create developers in a moment). Add the following to the `main` function:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这覆盖了对基类构造函数的调用，传递了项目经理的名称和描述工作的文字。该类还覆盖了`manage_team`以说明经理实际上做了什么。在这一点上，您应该能够创建一个`project_manager`并向他们的团队添加一些成员（使用`worker`对象，您将在一会儿创建开发人员）。将以下内容添加到`main`函数中：
- en: '[PRE85]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This code will compile, but there will be no output when it runs, so create
    a method to print out a manager''s team:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将编译，但运行时不会有输出，因此创建一个方法来打印经理的团队：
- en: '[PRE86]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This function shows how useful interfaces are. You can pass any worker to the
    function, and it will print out the information relevant to all workers (name
    and job position). It then asks the object if it is a manager by requesting the
    `IManage` interface. The function can only get the manager behavior (in this case,
    having a team) if the object implements this interface. At the end of the `main`
    function, after the last call to the `program_manager` object, call this function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数显示了接口有多么有用。您可以将任何工人传递给该函数，并且它将打印出与所有工人相关的信息（名称和工作职位）。然后，它通过请求`IManage`接口询问对象是否是经理。如果对象实现了此接口，函数只能获取经理的行为（在这种情况下，拥有一个团队）。在`main`函数的最后，在对`program_manager`对象的最后一次调用之后，调用此函数：
- en: '[PRE87]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Compile this code (remember to use the `/EHsc` switch) and run the code. You
    will get the following output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码（记得使用`/EHsc`开关）并运行代码。您将获得以下输出：
- en: '[PRE88]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now we will add a level of polymorphism, so add the following classes before
    the `print_team` function:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加多态性，所以在`print_team`函数之前添加以下类：
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You can change the `main` function so that rather than using `worker` objects,
    you use `cpp_developer` for Bill, Chris, and Dave and `database_admin` for Edith:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改`main`函数，以便使用`cpp_developer`代替`worker`对象，用于Bill、Chris和Dave，以及使用`database_admin`代替Edith：
- en: '[PRE90]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You can now compile and run the code and see that not only can you add different
    types of objects to the manager's team, but you will also get the appropriate
    information printed through the `IWork` interface.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以编译和运行代码，看到不仅可以将不同类型的对象添加到经理的团队中，而且还可以通过`IWork`接口打印出相应的信息。
- en: 'The next task is to add code to serialize and deserialize these objects. Serialization
    means writing the object''s state (and type information) to a stream and deserialization
    will take that information and create a new object of the appropriate type and
    with the specified state. To do this, every object must have a constructor that
    takes an interface pointer to a deserialzer object, and the constructor should
    call this interface to extract the state of the object being created. Further,
    such classes should implement a method to serialize and write an object''s state
    to a serializer object. Let''s first look at serialization. At the top of the
    file, add the following interfaces:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是添加代码来序列化和反序列化这些对象。序列化意味着将对象的状态（和类型信息）写入流，反序列化将获取该信息并创建具有指定状态的适当类型的新对象。为此，每个对象必须具有一个构造函数，该构造函数接受一个指向反序列化器对象的接口指针，并且构造函数应调用此接口以提取正在创建的对象的状态。此外，这样的类应实现一种方法，将对象的状态序列化并写入序列化器对象。让我们首先看一下序列化。在文件顶部添加以下接口：
- en: '[PRE91]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The forward declaration is needed because the `ISerializer` interface uses the
    `IWork` interface. The first interface, `ISerializer`, is implemented by an object
    that provides serialization services. This could be based on a file, a network
    socket, a database, or whatever you want to use to store the object. The underlying
    storage mechanism is unimportant to the user of this interface; all that is important
    is that the interface can store a string and it can store an entire object passed
    using an `IWork` interface pointer or a collection of such objects.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 需要前向声明，因为`ISerializer`接口使用`IWork`接口。第一个接口`ISerializer`由提供序列化服务的对象实现。这可以基于文件、网络套接字、数据库或任何您想要用于存储对象的东西。底层存储机制对于此接口的用户来说并不重要；重要的是接口可以存储字符串，并且可以使用`IWork`接口指针或此类对象的集合存储整个对象。
- en: 'The objects that can be serialized must implement the `ISerializable` interface
    and this has a single method that takes an interface pointer to the object that
    will provide the serialization service. After the definition of the interfaces,
    add the following class:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 可以序列化的对象必须实现`ISerializable`接口，该接口具有一个方法，该方法接受提供序列化服务的对象的接口指针。在接口的定义之后，添加以下类：
- en: '[PRE92]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This class provides the `ISerializer` interface for a file, so the `write_string`
    method uses the `ifstream` insertion operator to write the string on a single
    line in the file. The `write_worker` method writes the worker object to the file.
    To do this, it first asks the worker object if it can serialize itself by casing
    the `IWork` interface an `ISerializable` interface. If the worker object implements
    this interface, the serializer can ask the worker object to serialize itself by
    passing the `ISerializer` interface pointer to the `serialize` method on the worker
    object. It is up to the worker object to determine the information that must be
    serialized. The worker object knows nothing about the `file_writer` class other
    than the `ISerializer` interface, and the `file_writer` class knows nothing about
    the worker object, other than that it implements the `IWork` and `ISerializable`
    interfaces.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 该类为文件提供了`ISerializer`接口，因此`write_string`方法使用`ifstream`插入运算符将字符串写入文件的单行。`write_worker`方法将worker对象写入文件。为此，它首先询问worker对象是否可以通过将`IWork`接口转换为`ISerializable`接口来对自身进行序列化。如果worker对象实现了此接口，序列化器可以通过将`ISerializer`接口指针传递给worker对象的`serialize`方法来要求worker对象对自身进行序列化。工作对象决定必须序列化的信息。工作对象除了`ISerializer`接口之外对`file_writer`类一无所知，而`file_writer`类除了知道它实现了`IWork`和`ISerializable`接口之外对worker对象一无所知。
- en: If the worker object is serializable, the first thing that the `write_worker`
    method does is obtain type information about the object. The `IWork` interface
    will be on a class (`project_manager`, `cpp_developer`, or `database_admin`) and
    so dereferencing the pointer will give the `typeid` operator access to the class
    type information. We store the raw type name in the serializer because it is compact.
    Once the type information is serialized, we ask the object to serialize itself
    by calling the `serialize` method on its `ISerializable` interface. The worker
    object will store whatever information it wants.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果worker对象是可序列化的，`write_worker`方法的第一件事是获取有关对象的类型信息。`IWork`接口将位于一个类（`project_manager`、`cpp_developer`或`database_admin`）上，因此解引用指针将使`typeid`运算符访问类类型信息。我们将原始类型名称存储在序列化器中，因为它很紧凑。一旦类型信息被序列化，我们通过调用其`ISerializable`接口上的`serialize`方法要求对象对自身进行序列化。worker对象将存储任何它想要的信息。
- en: A manager object will need to serialize their team and they do this by passing
    a collection of worker objects to the `write_workers` method. This indicates that
    the objects being serialized are an array by writing them between two markers,
    `[[` and `]]`. Note that because the container has `unique_ptr` objects, there
    is no copy constructor because that would imply shared ownership. So instead,
    we access the items through the index operator, which will give us a reference
    to the `unique_ptr` object within the container.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: manager对象需要序列化他们的团队，他们通过将worker对象的集合传递给`write_workers`方法来实现这一点。这表明被序列化的对象是一个数组，通过在两个标记`[[`和`]]`之间写入它们来表示。请注意，因为容器有`unique_ptr`对象，所以没有复制构造函数，因为那将意味着共享所有权。所以我们通过索引操作符访问项目，这将给我们一个对容器中`unique_ptr`对象的引用。
- en: 'Now, for every class that can be serialized, you must derive the class from
    `ISerializable` and implement the `serialize` method. The class inheritance tree
    means that every class for a type of worker derives from the `worker` class, so
    we only need this class to inherit from the `ISerializable` interface:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于每个可以被序列化的类，你必须从`ISerializable`派生出类，并实现`serialize`方法。类继承树意味着每个worker类型的类都从`worker`类派生，所以我们只需要这个类从`ISerializable`接口派生：
- en: '[PRE93]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The convention is that a class only serializes its own state and delegates
    to its base class to serialize the base class object. At the top of the inheritance
    tree is the `worker` class, so at the bottom of this class, add the following
    interface method:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 约定是一个类只序列化自己的状态，并委托给它的基类来序列化基类对象。在继承树的顶部是`worker`类，所以在这个类的底部添加以下接口方法：
- en: '[PRE94]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This simply serializes the name and job position to the serializer. Note that
    the worker object does not know what the serializer will do with this information
    and does not know which class provides the `ISerializer` interface.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将名字和工作职位序列化到序列化器中。请注意，worker对象不知道序列化器将如何处理这些信息，也不知道哪个类提供了`ISerializer`接口。
- en: 'At the bottom of the `cpp_developer` class, add this method:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cpp_developer`类的底部，添加这个方法：
- en: '[PRE95]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `cpp_developer` class does not have any additional state, so it delegates
    the serialization to its parent class. If the developer class had a state, then
    it would serialize this state after serializing the base object. Add exactly the
    same code to the bottom of the `database_admin` class.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpp_developer`类没有任何额外的状态，所以它将序列化委托给它的父类。如果开发者类有一个状态，那么它将在序列化基对象之后序列化这个状态。在`database_admin`类的底部添加完全相同的代码。'
- en: 'The `project_manager` class also calls its base class, but this is `manager`,
    so add the following to the bottom of the `project_manager` class:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`project_manager`类也调用了它的基类，但这是`manager`，所以在`project_manager`类的底部添加以下内容：'
- en: '[PRE96]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `manager::serialize` is more complicated because this class has state that
    should be serialized:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`manager::serialize`更复杂，因为这个类有应该被序列化的状态：'
- en: '[PRE97]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The first action is to serialize the base class: a `worker` object. Then the
    code serializes the state of the `manager` object, which means serializing the
    `team` data member by passing this collection to the serializer.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是序列化基类：一个`worker`对象。然后代码序列化`manager`对象的状态，这意味着通过将这个集合传递给序列化器来序列化`team`数据成员。
- en: 'To be able to test the serialization, create a method above the `main` method
    and move the `project_manager` code to the new method and add code to serialize
    the objects:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够测试序列化，创建一个方法在`main`方法之上，并将`project_manager`的代码移到新方法中，并添加代码来序列化对象：
- en: '[PRE98]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The preceding code creates a `file_writer` object for the specified file, obtains
    the `ISerializer` interface on that object, and then serializes the project manager
    object. If you have other teams, you can serialize them to the file before closing
    the `writer` object.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个`file_writer`对象用于指定的文件，获取了该对象上的`ISerializer`接口，然后序列化了项目经理对象。如果你有其他团队，你可以在关闭`writer`对象之前将它们序列化到文件中。
- en: 'The `main` function will take two parameters. The first is the name of the
    file and the second is a character, `r` or `w` (to read or write the file). Add
    the following code to replace the `main` function:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数将接受两个参数。第一个是文件的名字，第二个是一个字符，`r`或`w`（读或写文件）。添加以下代码来替换`main`函数：'
- en: '[PRE99]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You can now compile this code and run it, giving the name of a file:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以编译这段代码并运行它，给出一个文件的名字：
- en: '[PRE100]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This will create a file called `cpp_team.txt` containing information about
    the team; type it at the command-line with `**type cpp_team.txt**`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`cpp_team.txt`的文件，其中包含关于团队的信息；在命令行中输入`**type cpp_team.txt**`：
- en: '[PRE101]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This file is not intended to be read by humans, but as you can see, it has one
    piece of information on each line and each serialized object is preceded by the
    type of the class.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件不是为人类阅读而设计的，但是你可以看到，每一行都有一条信息，每个序列化对象都在类的类型之前。
- en: 'Now you will write the code to deserialize an object. The code needs a class
    that will read the serialization data and return worker objects. This class is
    tightly coupled to the serializer class, but it should be accessed through an
    interface so that it is not coupled to the worker objects. After the declaration
    of the `ISerializable` interface, add the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将编写代码来反序列化一个对象。代码需要一个类来读取序列化数据并返回worker对象。这个类与序列化器类紧密耦合，但应该通过接口访问，以便不与worker对象耦合。在`ISerializable`接口的声明之后，添加以下内容：
- en: '[PRE102]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The first method obtains a serialization string and the other two methods obtain
    a single object and a collection of objects. Since these worker objects will be
    created on the free store, these methods use smart pointers. Every class can serialize
    itself, and so now you will make each serializable class able to deserialize itself.
    To do this, for every class that implements `ISerializable`, add a constructor
    that takes an `IDeserializer` interface pointer. Start with the `worker` class;
    add the following public constructor:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法获取序列化字符串，另外两个方法获取单个对象和对象集合。由于这些worker对象将在自由存储上创建，这些方法使用智能指针。每个类都可以对自身进行序列化，因此现在您将使每个可序列化的类能够对自身进行反序列化。为实现`ISerializable`的每个类添加一个接受`IDeserializer`接口指针的构造函数。从`worker`类开始；添加以下公共构造函数：
- en: '[PRE103]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Essentially, this reverses what the `serialize` method does, it reads the name
    and position string from the deserializer *in the same order* in which they were
    passed to the serializer. Since the `cpp_developer` and `database_admin` classes
    have no state, they do not need to do any other deserializing work other than
    call the base class constructor. For example, add the following public constructor
    to the `cpp_developer` class:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这颠倒了`serialize`方法的操作，它按照传递给序列化器的顺序从反序列化器中读取名称和位置字符串。由于`cpp_developer`和`database_admin`类没有状态，它们在调用基类构造函数之外不需要进行任何其他反序列化工作。例如，向`cpp_developer`类添加以下公共构造函数：
- en: '[PRE104]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Add a similar constructor to the `database_admin` class.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为`database_admin`类添加类似的构造函数。
- en: 'Managers have a state, so there is a bit more work to deserialize them. Add
    the following to the `manager` class:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 经理们有状态，因此反序列化它们需要更多的工作。在`manager`类中添加以下内容：
- en: '[PRE105]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The initializer list constructs the base class and after this is run, the constructor
    initializes the `team` collection with zero or more worker objects by calling
    `read_workers` on the `IDeserializer` interface. Finally, the `project_manager`
    class derives from the `manager` class, but adds no extra state, so add the following
    constructor:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化列表构造了基类，在此之后，构造函数通过在`IDeserializer`接口上调用`read_workers`来将`team`集合初始化为零个或多个worker对象。最后，`project_manager`类派生自`manager`类，但不添加额外的状态，因此添加以下构造函数：
- en: '[PRE106]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, every serializable class can deserialize itself, the next action is to
    write the deserializer class that will read a file. After the `file_writer` class,
    add the following (note that two methods are not implemented inline):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个可序列化的类都可以对自身进行反序列化，下一步是编写读取文件的反序列化器类。在`file_writer`类之后，添加以下内容（注意有两个方法没有内联实现）：
- en: '[PRE107]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The constructor opens the specified file and the destructor closes it. The
    `read_string` interface method reads a line from the file and returns it as a
    string. The main work is carried out in the two interface methods not implemented
    here. The `read_workers` method will read a collection of `IWork` objects and
    put them into the collection passed by reference. This method will call the `read_worker`
    method for every object in the file and put them in the collection, and so the
    main work of reading the file is carried out in this method. The `read_worker`
    method is the only part of the class that has any coupling to the serializable
    classes, and because of this, it has to be defined below the definition of the
    worker classes. Above the `serialize` global function, add the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数打开指定的文件，析构函数关闭文件。`read_string`接口方法从文件中读取一行并将其作为字符串返回。主要工作在这里未实现的两个接口方法中进行。`read_workers`方法将读取一组`IWork`对象并将它们放入传递的集合中。此方法将为文件中的每个对象调用`read_worker`方法并将它们放入集合中，因此读取文件的主要工作在此方法中进行。`read_worker`方法是该类唯一与可序列化类有耦合的部分，因此必须在worker类的定义下定义。在`serialize`全局函数上方添加以下内容：
- en: '[PRE108]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The `read_workers` method will read each object from the file using the `read_worker`
    method, which returns each object in a `unique_ptr` object. We want to put this
    object into the container, but because there should be exclusive ownership of
    the pointer, we need to move the ownership into the object in the container. There
    are two ways to do this. The first way is simply to use the call to `read_worker`
    as the parameter to `push_back`. The `read_worker` method returns a temporary
    object, which is an rvalue, so the compiler will use move semantics when creating
    the object in the container. We do not do this because the `read_worker` method
    may return a `nullptr` (which we want to test for), so instead we create a new
    `unique_ptr` object (move semantics will pass ownership to this object), and once
    we have tested that this object is not a `nullptr`, we call the Standard Library
    function, `move`, to move copy the object into the container.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_workers`方法将使用`read_worker`方法从文件中读取每个对象，该方法将每个对象以`unique_ptr`对象的形式返回。我们希望将此对象放入容器中，但由于指针应该具有独占所有权，因此我们需要将所有权移动到容器中的对象中。有两种方法可以做到这一点。第一种方法是简单地将`read_worker`的调用作为`push_back`的参数。`read_worker`方法返回一个临时对象，即右值，因此编译器在创建容器中的对象时将使用移动语义。我们不这样做是因为`read_worker`方法可能返回`nullptr`（我们希望进行测试），因此我们创建一个新的`unique_ptr`对象（移动语义将所有权传递给此对象），一旦我们测试了这个对象不是`nullptr`，我们调用标准库函数`move`将对象复制到容器中。'
- en: If the `read_worker` method reads the end marker of an array, it returns a `nullptr`
    and hence the `read_workers` method loops, reading each worker and putting them
    in the collection until a `nullptr` is returned.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`read_worker`方法读取数组的结束标记，则返回`nullptr`，因此`read_workers`方法循环读取每个worker并将它们放入集合，直到返回`nullptr`。
- en: 'Implement the `read_worker` method like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样实现`read_worker`方法：
- en: '[PRE109]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The first line reads the type information of the worker object from the file
    so that it knows what object to create. Since the file will have markers to indicate
    the array of team members, the code has to detect these. If the start of the array
    is detected, the marker string is ignored and the next line is read to get the
    type of the first object in the team. If the end marker is read, then this is
    the end of the array so a `nullptr` is returned.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行从文件中读取工作对象的类型信息，以便知道要创建什么对象。由于文件将有标记来指示团队成员的数组，代码必须检测这些标记。如果检测到数组的开始，标记字符串将被忽略，并且将读取下一行以获取团队中第一个对象的类型。如果读取到结束标记，那么这就是数组的结束，所以返回`nullptr`。
- en: 'The code for a `worker` object is shown here. The `if` statement tests to check
    whether the type string is the same as the raw name of the `worker` class. If
    it is, then we must create a `worker` object and request that it deserializes
    itself by calling the constructor that takes an `IDeserializer` pointer. The `worker`
    object is created on the free store and the `dynamic_cast` operator is called
    to obtain the `IWork` interface pointer, which is then used to initialize a smart
    pointer object. The constructor for the `unique_ptr` is `explicit`, so you have
    to call it. Now add similar code for all the other serializable classes:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了一个`worker`对象的代码。`if`语句用于检查类型字符串是否与`worker`类的原始名称相同。如果是，则我们必须创建一个`worker`对象，并请求它通过调用接受`IDeserializer`指针的构造函数来反序列化自己。`worker`对象在自由存储上创建，并调用`dynamic_cast`运算符来获取`IWork`接口指针，然后用它来初始化智能指针对象。`unique_ptr`的构造函数是`explicit`的，所以您必须调用它。现在为所有其他可序列化的类添加类似的代码：
- en: '[PRE110]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Finally, you need to create a `file_reader` and deserialize a file. After the
    `serialize` function, add the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要创建一个`file_reader`并反序列化一个文件。在`serialize`函数之后，添加以下内容：
- en: '[PRE111]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This code simply creates a `file_reader` object based on the file name and
    then reads each worker object from the file printing out the object and, if it
    is a `project_manager`, prints out their team. Finally, add a line in the `main`
    function to call this function:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地创建了一个基于文件名的`file_reader`对象，然后从文件中读取每个工作对象并打印出对象，如果是`project_manager`，则打印出他们的团队。最后，在`main`函数中添加一行来调用这个函数：
- en: '[PRE112]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now you can compile the code and use it to read in the serialization file with
    the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以编译代码并使用它来读取序列化文件，如下所示：
- en: '[PRE113]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: (Note the `r` parameter.) The code should print out the objects that you serialized
    to the file.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: （注意 `r` 参数。）代码应该打印出你序列化到文件中的对象。
- en: The previous example has shown that you can write serializable objects that
    do not know about the mechanism that is used to serialize them. If you want to
    use a different mechanism than a flat file (for example, an XML file or to a database),
    you do not need to alter any of the worker classes. Instead, you write an appropriate
    class that implements the `ISerializer` interface and the `IDeserailizer` interface.
    If you need to create another worker class, all you need to do is alter the `read_worker`
    method to deserialize objects of that type.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子表明，您可以编写可序列化的对象，而这些对象并不知道用于序列化它们的机制。如果您想使用不同的机制（例如XML文件或数据库），您无需更改任何工作类。相反，您可以编写一个适当的类来实现`ISerializer`接口和`IDeserailizer`接口。如果您需要创建另一个工作类，您只需要修改`read_worker`方法以反序列化该类型的对象。
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you saw how to use C++ inheritance to reuse code and provide
    an is-a relationship between objects. You also saw how this can be used to implement
    polymorphism, where related objects can be treated as having the same behavior
    while still maintaining the ability to call each object's methods, and interfaces
    that group together behaviors. In the next chapter, you'll see the features of
    the C++ Standard Library and the various utility classes it provides.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了如何使用C++继承来重用代码，并在对象之间提供is-a关系。您还看到了如何使用这个特性来实现多态性，相关的对象可以被视为具有相同的行为，同时仍然保持调用每个对象的方法的能力，以及将行为组合在一起的接口。在下一章中，您将看到C++标准库的特性以及它提供的各种实用类。
