- en: Chapter 9. Formula Interpretation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 公式解释
- en: The spreadsheet program is capable of handling text, numerical values, and formulas
    composed by the four arithmetic operators. In order to do so, we need to interpret
    the formulas. We also need to find the sources of a formula (the cells referred
    to in the formula) and the targets of a cell (the cells affected by a change).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格程序能够处理文本、数值和由四个算术运算符组成的公式。为了做到这一点，我们需要解释公式。我们还需要找到公式的来源（公式中引用的单元格）和单元格的目标（受单元格变化影响的单元格）。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Interpretation (scanning and parsing) of numerical expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值表达式的解释（扫描和解析）
- en: Parse and syntax trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析和语法树
- en: Evaluation of formulas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公式的评估
- en: References and matrices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考和矩阵
- en: Drawing of cells
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制单元格
- en: Loading and saving of cells
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格的加载和保存
- en: 'In the following spreadsheet, the `C3` cell is being edited:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下电子表格中，正在编辑的单元格是`C3`：
- en: '![Formula Interpretation](img/B05475_09_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![公式解释](img/B05475_09_01.jpg)'
- en: Formula interpretation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公式解释
- en: The core of a spreadsheet program is its ability to interpret formulas. When
    the user inputs a formula in a cell, it is interpreted and its value is evaluated.
    The process of formula interpretation is divided into three separate steps. First,
    given the input string, the **Scanner** generates a **Token List**, then the **Parser**
    generates a **Syntax Tree**, and the **Evaluator** determines the value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格程序的核心是其解释公式的能力。当用户在单元格中输入一个公式时，它会被解释并计算其值。公式解释的过程分为三个独立的步骤。首先，给定输入字符串，**扫描器**生成**标记列表**，然后**解析器**生成**语法树**，最后**评估器**确定值。
- en: '![Formula interpretation](img/B05475_09_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![公式解释](img/B05475_09_02.jpg)'
- en: A token is the least significant part of the formula. For instance, *a1* is
    interpreted as a reference and *1.2* is interpreted as a value. Assuming that
    the cells have values according to the following sheet, the formula interpretation
    process will be as follows. Remember that a formula is text beginning with an
    equal sign (**=**).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 标记是公式中最不重要的部分。例如，`a1`被解释为引用，而`1.2`被解释为值。假设根据以下表格，单元格具有以下值，公式解释过程将如下所示。请记住，公式是以等号（`**=**`）开头的文本。
- en: '![Formula interpretation](img/B05475_09_03.jpg)![Formula interpretation](img/B05475_09_04.jpg)![Formula
    interpretation](img/B05475_09_05.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![公式解释](img/B05475_09_03.jpg)![公式解释](img/B05475_09_04.jpg)![公式解释](img/B05475_09_05.jpg)'
- en: The tokens
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记
- en: 'The scanner takes a string as input and finds its least significant parts-its
    tokens. Spaces between the tokens are ignored, and the scanner makes out no difference
    between capital and small letters. The `Value` token needs an extra piece of information
    to keep track of the actual value, which is called an **attribute**. In the same
    way, `Reference` needs an attribute to keep track of reference. In this application,
    there are nine different tokens:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描器以字符串作为输入，并找到其最不重要的部分——其标记。标记之间的空格被忽略，扫描器对大小写没有区别。`Value`标记需要额外信息来跟踪实际值，这被称为**属性**。同样，`Reference`需要一个属性来跟踪引用。在这个应用中，有九种不同的标记：
- en: '**Token.h**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Token.h**'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '| **Token** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **Token** | **描述** |'
- en: '| `Plus`, `Minus`, `Star`, and `Slash` | These are the four arithmetic operators:
    "`+`", "`-`", "`*`", and "`/`" |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `Plus`, `Minus`, `Star`, 和 `Slash` | 这四个是算术运算符："`+`", "`-`", "`*`", 和 "`/`"
    |'
- en: '| `LeftParenthesis` and `RightParenthesis` | These are the left and right parentheses:
    "`(`" and "`)`" |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `LeftParenthesis` 和 `RightParenthesis` | 这是左右括号："`(`" 和 "`)`" |'
- en: '| Value | This is a numerical value, for instance, `124`, `3.14`, or `-0.23`.
    It does not matter whether the value is integral or decimal. Nor does it matter
    if the decimal point (if present) is preceded or succeeded by digits. However,
    the value must contain at least one digit. This needs a value of type double as
    an attribute. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 这是一个数值，例如，`124`，`3.14`，或`-0.23`。无论是整数还是小数，都无关紧要。同样，如果存在小数点，它前面或后面是否有数字也无关紧要。然而，值必须至少包含一个数字。这需要一个类型为`double`的值作为属性。
    |'
- en: '| Reference | This is a reference, for instance, `b8, c6`. This needs `Reference`
    object as an attribute. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 参考 | 这是一个参考，例如，`b8, c6`。这需要一个`Reference`对象作为属性。 |'
- en: '| EndOfLine | This is at the end of the line, there are no more (non-space)
    characters in the string. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 行尾 | 这是行尾，字符串中没有更多（非空格）字符。 |'
- en: As stated previously, the string *1.2 * (b2 + c3)* generates the tokens in the
    table on the next page. The end-of-line token is added at the end of the list.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，字符串`1.2 * (b2 + c3)`生成了下一页表中的令牌。列表末尾添加了行尾令牌。
- en: '| **Text** | **Token** | **Attribute** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **文本** | **令牌** | **属性** |'
- en: '| 1.2 | Value | 1.2 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 1.2 | 值 | 1.2 |'
- en: '| * | Star |  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| * | 星号 |  |'
- en: '| ( | LeftParenthesis |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| ( | 左括号 |  |'
- en: '| b2 | Reference | row `1`, col `1` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| b2 | 引用 | 行 `1`，列 `1` |'
- en: '| + | Plus |  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| + | 加号 |  |'
- en: '| c3 | Reference | row `2`, col `2` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| c3 | 引用 | 行 `2`，列 `2` |'
- en: '| ) | RightParanthesis |  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| ) | 右括号 |  |'
- en: '|  | EndOfLine |  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  | 行尾 |  |'
- en: The tokens are defined in the `Token` class. A token is made up of a token identifier,
    a double value in case of the value token, and a `Reference` object in case of
    the reference token.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌在`Token`类中定义。令牌由一个令牌标识符、在值令牌的情况下一个双精度值，以及在引用令牌的情况下一个`Reference`对象组成。
- en: '**Token.h**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Token.h**'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Token.cpp**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**Token.cpp**'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The tree node
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树节点
- en: 'As mentioned earlier, the parser generates a syntax tree. More specifically,
    it generates an object of the `Tree` class (described in [Chapter 12](ch12.html
    "Chapter 12. The Auxiliary Classes"), *Auxiliary Classes*), which is a template
    class with a node type: `TreeNode`. There are 10 identities for a node and, similar
    to `Token`, a value node has a double value as its attribute and a reference node
    has a reference object as attribute.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，解析器生成一个语法树。更具体地说，它生成一个`Tree`类的对象（在第12章[辅助类](ch12.html "第12章。辅助类")中描述），这是一个具有节点类型的模板类：`TreeNode`。节点有10个标识符，类似于`Token`，值节点有一个双精度值作为其属性，引用节点有一个引用对象作为属性。
- en: '**TreeNode.h**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**TreeNode.h**'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default constructor is used when reading the value from a file or the clipboard
    buffer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当从文件或剪贴板缓冲区读取值时，使用默认构造函数。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A cell of a spreadsheet can be saved to a file as well as cut, copied, and
    pasted, thus we included the following methods:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格的一个单元格可以保存到文件中，也可以剪切、复制和粘贴，因此我们包含了以下方法：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The identity and value of the node can only be inspected, not modified. However,
    the reference can be modified, since it is updated when the user copies a cell
    and then pastes it to another location:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的标识符和值只能被检查，不能被修改。然而，引用可以被修改，因为它在用户复制单元格并将其粘贴到另一个位置时会被更新：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**TreeNode.cpp**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**TreeNode.cpp**'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The node identity, the value, and the reference are written and read, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 节点标识符、值和引用被写入和读取，如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Scanner – Generating the list of tokens
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Scanner` – 生成令牌列表'
- en: The task of the `Scanner` class is to group characters into tokens. For instance,
    *12.34* is interpreted as the value *12.34*. The constructor takes a string as
    parameter while `Scan` generates a list of tokens by repeatedly calling `NextToken`
    until the string is empty.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`类的任务是分组字符为令牌。例如，`*12.34*`被解释为值`*12.34*`。构造函数接受一个字符串作为参数，而`Scan`通过重复调用`NextToken`直到字符串为空来生成令牌列表。'
- en: '**Scanner.h**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scanner.h**'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `NextToken` method returns `EndOfLine` when it encounters the end of the
    string. The `ScanValue` and `ScanReference` methods return `true` if they encounter
    a value or a reference:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当`NextToken`方法遇到字符串的末尾时，它返回`EndOfLine`。如果`ScanValue`和`ScanReference`方法遇到值或引用，则返回`true`：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next token is continually read from the buffer until it is empty:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个令牌会不断地从缓冲区中读取，直到它为空：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Scanner.cpp**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scanner.cpp**'
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`TEXT(''\0'')` is added to the string for simplicity; instead of checking whether
    the remaining text is empty, we look for the `null` character:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，向字符串中添加了`TEXT('\0')`；而不是检查剩余的文本是否为空，我们寻找`null`字符：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Scan` method adds the token from the buffer to `tokenList` until it encounters
    `EndOfLine`. Finally, the list is returned:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scan`方法将缓冲区中的令牌添加到`tokenList`中，直到遇到`EndOfLine`。最后，返回列表：'
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `NextToken` method does the actual work of the scanner by finding the next
    token in the buffer. First, we skip the blanks. It is rather simple to extract
    the token when it comes to the arithmetic symbols and the parentheses. We just
    check the next character of the buffer. It becomes slightly more difficult when
    it comes to numerical values or references. We have two auxiliary methods for
    that purpose: `ScanValue` and `ScanReference`. Take a look at the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`NextToken`方法通过在缓冲区中找到下一个令牌来完成扫描器的实际工作。首先，我们跳过空白字符。当涉及到算术符号和括号时，提取令牌相当简单。我们只需检查缓冲区的下一个字符。当涉及到数值或引用时，这会变得稍微困难一些。为此，我们有两个辅助方法：`ScanValue`和`ScanReference`。看看以下代码：'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If none of the trivial cases apply, the token may be a value or a reference.
    The `ScanValue` and `ScanReference` methods find out if that is the case. If not,
    the scanner has encountered an unknown character and a syntax error exception
    is thrown:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有适用任何简单情况，标记可能是一个值或一个引用。`ScanValue` 和 `ScanReference` 方法会找出是否是这样。如果不是，扫描器遇到了未知字符，并抛出语法错误异常：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ScanValue` uses the `_stscanf_s` standard function, which is the safe generic
    version of `sscanf`. The returned value is stored in `fieldCount`, which is set
    to `1` if the double value was successfully read. We also need the number of the
    character read, which is stored in `charCount`, in order to erase the correct
    number of characters from the buffer:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScanValue` 使用 `_stscanf_s` 标准函数，这是 `sscanf` 的安全通用版本。返回值存储在 `fieldCount` 中，如果成功读取双精度值，则将其设置为
    `1`。我们还需要读取的字符数，它存储在 `charCount` 中，以便从缓冲区中删除正确的字符数：'
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`ScanReference` checks whether the first two characters are a letter and a
    digit. If so, it extracts the column and the row of the reference:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScanReference` 检查前两个字符是否为字母和数字。如果是，它将提取引用的列和行：'
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We extract the column by subtracting the lowercase letter from *a*, which gives
    that the first column has the index zero, and erases the letter from the buffer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从 *a* 减去小写字母来提取列，这给出第一列的索引为零，并从缓冲区中删除字母。
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similar to `ScanValue`, we extract the row by calling `_stscanf_s`, which reads
    the row integer value and the number of characters, which we use to erase the
    characters read from the buffer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ScanValue` 类似，我们通过调用 `_stscanf_s` 来提取行，它读取行整数值和字符数，我们使用这些信息来从缓冲区中删除读取的字符：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The parser – Generating the syntax tree
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析器 – 生成语法树
- en: 'The user inputs a formula beginning with an equal sign (**=**). The parser''s
    task is to translate the scanner''s token list into a syntax tree. The syntax
    of a valid formula can be defined by a **grammar**. Let''s start with a grammar
    that handles expressions that make use of the arithmetic operators:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入一个以等号（**=**）开头的公式。解析器的任务是翻译扫描器的标记列表为语法树。有效公式的语法可以通过**语法**来定义。让我们从一个处理使用算术运算符的表达式的语法开始：
- en: '![The parser – Generating the syntax tree](img/B05475_09_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_06.jpg)'
- en: A grammar is a set of rules. In the preceding grammar, there are eight rules.
    **Formula** and **Expression** are called **non-terminals**; **EndOfLine**, **Value**,
    and the characters **+**, **-**, *****, **/**, **(**, and **)** are called **terminals**.
    Terminals and non-terminals are called symbols. One of the rules is the grammar's
    **start rule**, in our case the first rule. The symbol to the left of the start
    rules is called the grammar's **start symbol**, in our case **Formula**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是一组规则。在先前的语法中，有八个规则。**公式**和**表达式**被称为**非终结符**；**行尾**、**值**以及字符**+**、**-**、*****、**/**、**(**
    和 **)**被称为**终结符**。终结符和非终结符统称为符号。其中一条规则是语法的**起始规则**，在我们的例子中是第一条规则。起始规则左侧的符号被称为语法的**起始符号**，在我们的例子中是**公式**。
- en: 'The arrow can be read as "**is**", and the preceding grammar can be read as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头可以读作“**是**”，先前的语法可以读作：
- en: '*A formula is an expression followed by end-of-line. An expression is the sum
    of two expressions, the difference of two expressions, the product of two expressions,
    the quotient of two expressions, an expression enclosed by parentheses, a reference,
    or a numerical value.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*公式是一个表达式后跟行尾。表达式是两个表达式的和、差、积、商，或者括号内的表达式、引用或数值。*'
- en: 'This is a good start, but there are a few problems. Let''s test if the string
    *1 + 2 * 3* is accepted by the grammar. We can test that by doing a **derivation**,
    where we start with the start symbol `Formula` and apply the rules until there
    are only terminals. The digits in the following derivation refer to the grammar
    rules:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的开始，但有几个问题。让我们测试字符串 *1 + 2 * 3* 是否被语法接受。我们可以通过进行**推导**来测试，从起始符号 `Formula`
    开始，应用规则，直到只剩下终结符。以下推导中的数字指的是语法规则：
- en: '![The parser – Generating the syntax tree](img/B05475_09_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_07.jpg)'
- en: The derivation can be illustrated by the development of a **parse tree**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 推导可以通过**解析树**的发展来表示。
- en: '![The parser – Generating the syntax tree](img/B05475_09_08.jpg)Let''s try
    another derivation of the same string, with the rules applied in a different order.![The
    parser – Generating the syntax tree](img/B05475_09_09.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_08.jpg)让我们尝试对同一个字符串进行另一种推导，这次按照不同的顺序应用规则。![解析器
    – 生成语法树](img/B05475_09_09.jpg)'
- en: 'This derivation generates a different parse tree, which is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推导生成了一个不同的解析树，如下所示：
- en: '![The parser – Generating the syntax tree](img/B05475_09_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_10.jpg)'
- en: 'The grammar is said to be ambiguous as it can generate two different parse
    trees for the same input string, which we would like to avoid. The second tree
    is obviously a violation of the laws of mathematics, stating that multiplication
    has higher precedence than addition, but the grammar does not know that. One way
    to avoid ambiguity is to introduce a new set of rules for each level of precedence:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个语法可以针对同一个输入字符串生成两个不同的解析树，那么它被认为是**歧义的**。第二个树显然违反了数学定律，即乘法的优先级高于加法，但语法并不知道这一点。避免歧义的一种方法是为每个优先级级别引入一组新的规则：
- en: '![The parser – Generating the syntax tree](img/B05475_09_11.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_11.jpg)'
- en: The new grammar is not ambiguous. If we try our string with this grammar, we
    can only generate one parse tree, regardless of the order that we choose to apply
    the rules. There are formal methods to prove that the grammar is not ambiguous;
    however, that is outside the scope of this book. Check out the references at the
    end of this chapter for references.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语法不是歧义的。如果我们用这个语法尝试我们的字符串，我们只能生成一个解析树，无论我们选择应用规则的顺序如何。有正式的方法可以证明语法不是歧义的；然而，这超出了本书的范围。请参阅本章末尾的参考文献。
- en: '![The parser – Generating the syntax tree](img/B05475_09_12.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_12.jpg)'
- en: This derivation gives the following tree. As it is not possible to derive two
    different trees from the same input string, the grammar is **unambiguous**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推导给出了以下树。由于不可能从同一个输入字符串推导出两个不同的树，因此语法是**无歧义的**。
- en: '![The parser – Generating the syntax tree](img/B05475_09_13.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_13.jpg)'
- en: 'We are now ready to write a parser. Essentially, there are two types of parsers:
    **top-down parser** and **bottom-up parser**. As the terms imply, a top-down parser
    starts by the grammar''s start symbol together with the input string, and it tries
    to apply rules until we are left with only terminals. A bottom-up parser starts
    with the input string and tries to apply rules backward, reducing the rules until
    we reach the start symbol.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写解析器了。本质上，有两种类型的解析器：**自顶向下解析器**和**自底向上解析器**。正如术语所暗示的，自顶向下解析器从语法的起始符号和输入字符串开始，并尝试应用规则，直到我们只剩下终结符。自底向上解析器从输入字符串开始，并尝试反向应用规则，直到我们达到起始符号。
- en: It is a complicated matter to construct a bottom-up parser. It is usually not
    done manually; instead, there are **parser generators** constructing a **parser
    table** for the given grammar and skeleton code for the implementation of the
    parser. However, the theory of bottom-up parsing is outside the scope of this
    book.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自底向上解析器是一个复杂的问题。通常不是手动完成的；相反，有**解析器生成器**为给定的语法构建一个**解析器表**和解析器实现的骨架代码。然而，自底向上解析的理论超出了本书的范围。
- en: It is easier to construct a top-down parser than a bottom-up parser. One way
    to construct a simple, but inefficient, top-down parser would be to apply all
    possible rules in random order. If we reach a dead end, we simply backtrack and
    try another rule. A more efficient, but rather simple, parser is a look-ahead
    parser. Given a suitable grammar, we only need to look at the next token in order
    to uniquely determine the rule to apply. If we reach a dead end, we do not have
    to backtrack; we simply draw the conclusion that the input string is incorrect
    according to the grammar-it is said to be **syntactically incorrect**, that is,
    it has a **syntax error**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自顶向下解析器比构建自底向上解析器更容易。构建一个简单但效率低下的自顶向下解析器的一种方法是在随机顺序中应用所有可能的规则。如果我们遇到了死胡同，我们只需回溯并尝试另一条规则。一个更高效但相对简单的解析器是前瞻解析器。给定一个合适的语法，我们只需要查看下一个标记，就可以唯一确定要应用的规则。如果我们遇到了死胡同，我们不需要回溯；我们只需得出结论，即输入字符串根据语法是不正确的——它被称为**语法错误**。
- en: 'The first attempt to implement a look-ahead parser could be to write a function
    for each rule in the grammar. Unfortunately, we cannot do that quite yet because
    that would result in a function `Expression` like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个前瞻解析器的第一次尝试可能是为语法中的每个规则编写一个函数。不幸的是，我们目前还不能这样做，因为这会导致一个像`Expression`这样的函数：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Do you see the problem? The method calls itself without changing the input stream,
    which would result in an infinite number of recursive calls. This is called **left
    recursion**. We can solve the problem, however, with the help of a simple translation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到问题了吗？该方法在未改变输入流的情况下调用自身，这将导致无限次的递归调用。这被称为**左递归**。然而，我们可以通过简单的转换来解决该问题。
- en: '![The parser – Generating the syntax tree](img/B05475_09_14.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_14.jpg)'
- en: 'The preceding rules can be translated to the equivalent set of rules (where
    epsilon ε denotes empty string):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的规则可以转换为等价的规则集（其中epsilon ε表示空字符串）：
- en: '![The parser – Generating the syntax tree](img/B05475_09_15.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_15.jpg)'
- en: 'If we apply this transformation to the **Expression** and **Term** rules in
    the preceding grammar, we receive the following grammar:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这种转换应用于前面语法中的**表达式**和**项**规则，我们将得到以下语法：
- en: '![The parser – Generating the syntax tree](img/B05475_09_16.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_16.jpg)'
- en: Let's try this new grammar with our string *1 + 2 * 3*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们的字符串*1 + 2 * 3*尝试这个新语法。
- en: '![The parser – Generating the syntax tree](img/B05475_09_17.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_17.jpg)'
- en: 'The derivation generates the following parse tree:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 推导生成了以下解析树：
- en: '![The parser – Generating the syntax tree](img/B05475_09_18.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_18.jpg)'
- en: The requirement for a grammar to be suitable for a look-ahead parser is that
    every set of rules with the same left-hand side symbol must begin with different
    terminals at its right-hand side. If it does not have an empty rule, it may have
    at the most one rule with a non-terminal as the first symbol on the right-hand
    side. The preceding grammar we covered meets these requirements.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 语法适合前瞻解析器的条件是，具有相同左侧符号的每个规则集必须以不同的终结符开始其右侧。如果没有空规则，它最多只能有一个以非终结符作为右侧第一个符号的规则。我们前面讨论的语法满足这些要求。
- en: 'Now we are ready to write the parser. However, the parser should also generate
    some kind of output, representing the string. One such representation is the **syntax
    tree**, which can be viewed as an abstract parse tree-we keep only the essential
    information. For instance, the previous parse tree has a matching syntax, which
    is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写解析器了。然而，解析器还应生成某种类型的输出，表示字符串。一种这样的表示是**语法树**，它可以被视为一个抽象的解析树——我们只保留必要的信息。例如，前面的解析树有一个匹配的语法，如下所示：
- en: '![The parser – Generating the syntax tree](img/B05475_09_19.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_19.jpg)'
- en: The following is the `Parser` class. The idea is that we write a method for
    every set of rules with the same left-hand symbol. Each such method generates
    a part of the resulting syntax tree. The constructor takes the text to parse and
    lets the scanner generate a list of tokens. Then, `Parse` starts the parsing process,
    and returns the generated syntax tree. If an error occurs during the parsing process,
    a syntax error exception is thrown. When the token list has been parsed, we should
    make sure that there are no extra tokens left in the list except `EndOfLine`.
    Also, if the input buffer is completely empty (the user inputs only a single equal
    sign), there is still the `EndOfLine` token in the list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是`Parser`类。其思路是，我们为每个具有相同左侧符号的规则集编写一个方法。每个这样的方法生成结果语法树的一部分。构造函数接受要解析的文本，并让扫描器生成一个标记列表。然后，`Parse`开始解析过程，并返回生成的语法树。如果在解析过程中发生错误，将抛出语法错误异常。当标记列表被解析后，我们应该确保列表中没有除`EndOfLine`之外的额外标记。此外，如果输入缓冲区完全为空（用户只输入了一个等号），列表中仍然有`EndOfLine`标记。
- en: The result of the parsing is a syntax tree representing the formula. For instance,
    the formula *a1 * c3 / 3.6 + 2.4 * (b2 - 2.4)* generates the following syntax
    tree, and we take advantage of the `Tree` class of [Chapter 12](ch12.html "Chapter 12. The
    Auxiliary Classes"), *Auxiliary Classes*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 解析的结果是一个表示公式的语法树。例如，公式*a1 * c3 / 3.6 + 2.4 * (b2 - 2.4)*生成了以下语法树，我们利用了[第12章](ch12.html
    "第12章。辅助类")中的`Tree`类，*辅助类*。
- en: '![The parser – Generating the syntax tree](img/B05475_09_20.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![解析器 – 生成语法树](img/B05475_09_20.jpg)'
- en: 'As mentioned in the `TreeNode` section earlier, there are nine types of syntax
    tree: the four arithmetic operators, unary addition and subtraction, expressions
    in parentheses, references, and numerical values. We do not actually need the
    parentheses to store the formula correctly, as the priority of the expression
    is stored in the syntax tree itself. However, we need it to regenerate the original
    string from the syntax tree when written in a cell.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文在 `TreeNode` 节中所述，有九种类型的语法树：四个算术运算符、一元加法和减法、括号内的表达式、引用和数值。我们实际上不需要括号来正确存储公式，因为表达式的优先级存储在语法树本身中。然而，我们需要它来从语法树中重新生成原始字符串，当它在单元格中写入时。
- en: '**Parser.h**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parser.h**'
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Parse` method is called in order to interpret the text that the user has
    input. It receives the token list from the scanner, which holds at least the `EndOfLine`
    token and parses the token list and receives a pointer to the syntax tree. When
    the token list has been parsed, it checks whether the next token is `EndOfLine`
    to make sure that there are no extra characters (except spaces) left in the buffer:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parse` 方法被调用以解释用户输入的文本。它接收来自扫描器的标记列表，其中至少包含 `EndOfLine` 标记，并解析标记列表并接收指向语法树的指针。当标记列表被解析后，它会检查下一个标记是否为
    `EndOfLine` 以确保缓冲区中没有多余的字符（除了空格）：'
- en: '**Parser.cpp**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parser.cpp**'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Match` method is used to match the next token in the list with the expected
    token. If they do not match or if the token list is empty, a syntax error exception
    is thrown. Otherwise, the next token is removed from the list:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Match` 方法用于匹配列表中的下一个标记与期望的标记。如果它们不匹配或如果标记列表为空，则抛出一个语法错误异常。否则，下一个标记将从列表中移除：'
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The rest of the methods implement the grammar we discussed earlier. There is
    one method for each for the symbols `Expression`, `NextExpression`, `Term`, `NextTerm`,
    and `Factor`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的方法实现了我们之前讨论的语法。对于 `Expression`、`NextExpression`、`Term`、`NextTerm` 和 `Factor`
    符号，每个都有一个方法：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `NextExpression` method takes care of addition and subtraction. If the
    next token is `Plus` or `Minus`, we match it and parse its right operand. Then,
    we create and return a new syntax tree with the operator in question. If the next
    token is neither `Plus` nor `Minus`, we just assume that another rule applies
    and return the given left syntax tree:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`NextExpression` 方法负责处理加法和减法。如果下一个标记是 `Plus` 或 `Minus`，我们将其匹配并解析其右操作数。然后，我们创建并返回一个新的包含运算符的语法树。如果下一个标记既不是
    `Plus` 也不是 `Minus`，我们假设适用另一条规则，并返回给定的左语法树：'
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `NextTerm` method works with multiplication and division in a way similar
    to `NextExpression`. Remember that we need a set of methods for each precedence
    level of the grammar.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`NextTerm` 方法以类似于 `NextExpression` 的方式处理乘法和除法。记住，我们需要为语法中的每个优先级级别的方法集。'
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Factor` method parses values, references, and expressions enclosed by
    parentheses. If the next token is a unary operator (plus or minus), we parse its
    expression and create a syntax tree holding the expression:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Factor` 方法解析括号内的值、引用和表达式。如果下一个标记是一元运算符（加号或减号），我们解析其表达式并创建一个包含表达式的语法树：'
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the next token is a left parenthesis, we match it, parse the following expression,
    and match the closing right parenthesis:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个标记是左括号，我们将其匹配，解析随后的表达式，并匹配关闭的右括号：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the next token is a reference, we receive the reference attribute with its
    row and column and match the reference token. We create a new syntax tree holding
    a reference. Note that the parser does not check whether the reference is valid
    (refers to a cell inside the spreadsheet); that is the task of the evaluation
    of the formula''s value:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个标记是引用，我们接收带有其行和列的引用属性并匹配引用标记。我们创建一个新的包含引用的语法树。请注意，解析器不会检查引用是否有效（是否指向电子表格内的单元格）；这是公式值评估的任务：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If none of the preceding tokens applies, the user has input an invalid expression
    and a syntax error exception is thrown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的任何标记都不适用，则用户输入了一个无效的表达式，并抛出一个语法错误异常：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Matrix and reference
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵和引用
- en: The `Matrix` class is used when storing the cells of spreadsheet, and the `Reference`
    class is used when accessing cells in the spreadsheet.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当存储电子表格的单元格时使用 `Matrix` 类，当访问电子表格中的单元格时使用 `Reference` 类。
- en: The reference class
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类
- en: 'The `Reference` class holds the row and column of a cell in the `Matrix` class,
    as shown in the next section:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reference` 类在 `Matrix` 类中持有单元格的行和列，如下一节所示：'
- en: '**Reference.h**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reference.h**'
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The default constructor initializes the row and column to zero. A reference
    can be initialized by and assigned to another reference:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数将行和列初始化为零。引用可以通过 `new` 关键字初始化，并赋值给另一个引用：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The compare operators first compare the rows. If they are equal, the columns
    are then compared:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符首先比较行。如果它们相等，则比较列：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The addition operators add and subtract the rows and columns separately:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 加法运算符分别对行和列进行加法和减法操作：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Clear` method sets both the row and column to zero, and `IsEmpty` returns
    `true` if the row and column is zero:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clear` 方法将行和列都设置为零，如果行和列为零，则 `IsEmpty` 返回 `true`：'
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `ToString` method returns a string representing the reference:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString` 方法返回表示引用的字符串：'
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A reference is inside a block of references defined by a smallest and a largest
    reference if it is greater than or equal to the smallest one and less than or
    equal to the largest one:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个引用大于或等于最小引用且小于或等于最大引用，则它位于由最小和最大引用定义的引用块内：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The reference can be written to and read from a file stream, the clipboard,
    and the registry:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 引用可以写入和读取到文件流、剪贴板和注册表中：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The row and column are inspected by the constant methods and modified by the
    non-constant methods:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 行和列通过常量方法进行检查，通过非常量方法进行修改：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Reference.cpp**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reference.cpp**'
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `ToString` method returns to reference as a string. We increase the number
    of rows by one, implying that row zero corresponds to *1*. The column is converted
    to characters, implying that column zero corresponds to *a*. If the number of
    rows or columns is less than zero, `?` is returned:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString` 方法返回引用作为字符串。我们增加行数，意味着行零对应于 *1*。列被转换为字符，意味着列零对应于 *a*。如果行数或列数小于零，则返回
    `?`：'
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When communicating with the registry, we use the `WriteBuffer` and `ReadBuffer`
    static methods. In order for that to work, we place the row and column values
    in the `ReferenceStruct` structure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当与注册表通信时，我们使用 `WriteBuffer` 和 `ReadBuffer` 静态方法。为了使其工作，我们将行和列值放入 `ReferenceStruct`
    结构体中：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Matrix class
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Matrix` 类'
- en: The `Matrix` class holds a set of cells organized in rows and columns.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matrix` 类包含一组按行和列组织的单元格。'
- en: '**Matrix.h**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Matrix.h**'
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The matrix can be initialized by or assigned to another matrix; in both cases,
    they call `Init` to do the actual initialization:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵可以通过 `new` 关键字初始化或赋值给另一个矩阵；在这两种情况下，它们都调用 `Init` 来执行实际的初始化：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The index operator takes a row or a `Reference` object. In the case of a row,
    an array of columns is returned (technically, the address of its first value is
    returned), which can be further indexed by the regular index operator to obtain
    the value in the buffer. In the case of a reference, the value is accessed directly
    by indexing the row and column of the buffer. Note that in this class, the vertical
    row coordinate holds the first index and the horizontal column coordinate the
    second index:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 索引运算符接受一个行或 `Reference` 对象。在行的情况下，返回一个列数组（技术上，返回其第一个值的地址），可以通过常规索引运算符进一步索引以获取缓冲区中的值。在引用的情况下，通过索引缓冲区的行和列直接访问值。请注意，在这个类中，垂直行坐标持有第一个索引，水平列坐标持有第二个索引：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Since Matrix is a template class, we place the definition of its methods in
    the `header` file. The default constructor lets the default cell constructor initialize
    the cells:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Matrix` 是一个模板类，我们将其方法的定义放在 `header` 文件中。默认构造函数允许默认单元格构造函数初始化单元格：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The copy constructor and the assignment operator copies the cells by calling
    `Init`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数和赋值运算符通过调用 `Init` 来复制单元格：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The cell
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元格
- en: 'The cell can hold three modes: (possible empty) text, a numerical value, or
    a formula. Its mode is stored in the `cellMode` field. It can hold the value `TextMode`,
    `ValueMode`, or `FormulaMode`. Similar to `CalcDocument` in this chapter and `WordDocument`
    in the previous chapters, we refer to the current value of `cellMode` in expressions
    such as **in text mode**, **in value mode**, and **in formula mode**.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格可以保持三种模式：（可能的空）文本、数值或公式。其模式存储在 `cellMode` 字段中。它可以保持 `TextMode`、`ValueMode`
    或 `FormulaMode` 的值。类似于本章中的 `CalcDocument` 和前几章中的 `WordDocument`，我们在 **文本模式**、**数值模式**
    和 **公式模式** 等表达式中引用 `cellMode` 的当前值。
- en: '`HeaderWidth`, `HeaderHeight`, `ColWidth`, and `RowHeight` are the size of
    the headers and cells of the spreadsheet. In order for the cell text to not overwrite
    the cell''s borders, `CellMargin` is used. The spreadsheet is made up of ten rows
    and four columns.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeaderWidth`、`HeaderHeight`、`ColWidth` 和 `RowHeight` 是电子表格标题和单元格的大小。为了防止单元格文本覆盖单元格的边框，使用
    `CellMargin`。电子表格由十行和四列组成。'
- en: '**Cell.h**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cell.h**'
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A cell can be aligned at the left, center, right or justified in the horizontal
    direction, and it can be aligned at the top, center, or bottom in the vertical
    direction:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格可以在水平方向上左对齐、居中对齐、右对齐或两端对齐，并且在垂直方向上可以顶部对齐、居中对齐或底部对齐：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `Clear` method is called when the user selects the new menu item and clears
    the font and background color of the cell before calling `Reset`, which clears
    the text and sets the cell to the text mode. `Reset` is also called when the user
    deletes the cell, in that case, the text is cleared, but not the font or color:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择新菜单项时，会调用 `Clear` 方法，并在调用 `Reset` 之前清除单元格的字体和背景颜色，`Reset` 清除文本并将单元格设置为文本模式。`Reset`
    也会在用户删除单元格时被调用，在这种情况下，文本会被清除，但字体或颜色不会被清除：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `CharDown` method is called when the user inputs a character that is inserted
    before the current character or overwrites it depending on the value of the `keyboardMode`
    parameter. When the user double-clicks on the text in a cell, `MouseToIndex` calculates
    the index of the character clicked on:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入一个字符，该字符插入到当前字符之前或根据 `keyboardMode` 参数的值覆盖它时，会调用 `CharDown` 方法。当用户在单元格中的文本上双击时，`MouseToIndex`
    计算被点击字符的索引：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `Text` and `CaretList` methods return the text and caret rectangle list
    of the cell.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text` 和 `CaretList` 方法返回单元格的文本和光标矩形列表。'
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The font and background color of the cell can both be modified and inspected,
    so can the horizontal and vertical alignment:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格的字体和背景颜色都可以修改和检查，同样也可以修改水平和垂直对齐方式：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `DrawCell` method draws the border of the cell in black, fills the cell
    with the background color, and draws the text. All colors are inverted if the
    inverse parameter is true, which it is if the cell is either being edited or is
    marked:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawCell` 方法用黑色绘制单元格的边框，用背景色填充单元格，并绘制文本。如果反转参数为 `true`，则所有颜色都会反转，这发生在单元格正在编辑或被标记的情况下：'
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `DisplayFormula` method is called when the user starts editing the cell.
    A cell with a formula can be displayed with its value or its formula. When the
    user edits the cell, the formula is displayed. When they mark it, its value is
    displayed. The `DisplayFormula` method replaces the value by the formula (or an
    error message in case of an incorrect formula):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户开始编辑单元格时，会调用 `DisplayFormula` 方法。带有公式的单元格可以显示其值或其公式。当用户编辑单元格时，显示公式。当用户标记它时，显示其值。`DisplayFormula`
    方法将值替换为公式（或错误信息，如果公式不正确）：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `InterpretCell` method interprets the text of the cell, which is interpreted
    as text, a numerical value, or a formula. If the formula contains a syntax error,
    an exception is thrown:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`InterpretCell` 方法解释单元格的文本，该文本被解释为文本、数值或公式。如果公式包含语法错误，则抛出异常：'
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the `formula` mode, `GenerateSourceSet` analyzes the formula and returns
    the (possibly empty) set of all its references. In the `text` or `value` mode,
    an empty set is returned:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `formula` 模式下，`GenerateSourceSet` 分析公式并返回所有引用的（可能为空）集合。在 `text` 或 `value`
    模式下，返回一个空集合：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the `formula` mode, `TreeToString` returns the formula converted from the
    syntax tree to the string that is displayed in the cell when being edited:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `formula` 模式下，`TreeToString` 返回从语法树转换成字符串的公式，该字符串在编辑单元格时显示在单元格中：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When the user cuts, copies, and pastes cells, their references are updated.
    `UpdateTree` updates all references in the formula mode:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户剪切、复制和粘贴单元格时，它们的引用会更新。`UpdateTree` 更新公式模式下的所有引用：
- en: '[PRE60]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `HasValue` method returns `true` if the cell holds a value: `true` in the
    `value` mode, `false` in the `text` mode, and `true` in the `formula` mode if
    it has been evaluated to a value, `false` if an evaluation error (missing value,
    reference out of scope, circular reference, or division by zero) occurred:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasValue` 方法返回 `true` 如果单元格包含一个值：在 `value` 模式下为 `true`，在 `text` 模式下为 `false`，在
    `formula` 模式下如果已评估为值则为 `true`，如果发生评估错误（缺少值、引用超出范围、循环引用或除以零）则为 `false`：'
- en: '[PRE61]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `Evaluate` method evaluates the syntax tree of the formula; `valueMap`
    holds the values of the cells in the source set:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluate` 方法评估公式的语法树；`valueMap` 保存源集合中单元格的值：'
- en: '[PRE62]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The cell can be saved to a file or cut, copied, and pasted:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格可以保存到文件或剪切、复制和粘贴：
- en: '[PRE63]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As mentioned at the beginning of this section, the cell can hold (possibly
    empty) text, a numerical value, or a formula, indicated by the value `cellMode`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，单元格可以保存（可能为空）文本、数值或公式，由`cellMode`的值指示：
- en: '[PRE64]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'All characters in the cell hold the same font and background color. The cell
    can be aligned at the left, center, right, or justified horizontally, and it can
    be aligned at the top, center, or bottom vertically:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格中的所有字符都持有相同的字体和背景颜色。单元格可以水平对齐在左、中、右或两端对齐，并且可以垂直对齐在顶部、居中或底部：
- en: '[PRE65]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `text` field holds the text displayed in the cell. In the `edit` mode,
    it is the text currently input by the user. In the `mark` mode, it is the text
    input by the user (in text mode), a numerical value input by the user converted
    to text, the calculated value of a formula, or an error message (missing value,
    reference out of scope, circular reference, or division by zero):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`字段保存单元格中显示的文本。在`edit`模式下，它是用户当前输入的文本。在`mark`模式下，它是用户输入的文本（在文本模式下），用户输入的数值转换为文本，公式的计算值或错误消息（缺失值、引用超出范围、循环引用或除以零）：'
- en: '[PRE66]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The caret list holds the caret rectangle of each character in `text`. It also
    holds the rectangle for the index after the last character, which means that the
    size of the caret list is always one more than the text:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 光标列表保存了`text`中每个字符的光标矩形。它还保存了最后一个字符之后的索引的矩形，这意味着光标列表的大小总是比文本多一个：
- en: '[PRE67]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When the value of a formula is being calculated, it may result in a value or
    any of the errors we discussed earlier. If the cell holds a value, `hasValue`
    is `true` and `value` holds the actual value:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算公式的值时，它可能得到一个值或我们之前讨论过的任何错误。如果单元格包含一个值，则`hasValue`为`true`，`value`包含实际值：
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When the user inputs a formula starting with *=*, it is interpreted as a syntax
    tree by the `Scanner` and `Parser` classes, and it is stored in `syntaxTreePtr`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户以`=*`开头输入公式时，它被`Scanner`和`Parser`类解释为语法树，并存储在`syntaxTreePtr`中：
- en: '[PRE69]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**Cell.cpp**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cell.cpp**'
- en: '[PRE70]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The width of a cell is the width of the column minus the margins, and its height
    is the row height minus the margins:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格的宽度是列宽减去边距，其高度是行高减去边距：
- en: '[PRE71]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When a cell is created, it is empty, it holds the text mode, it is center aligned
    in both horizontal and vertical directions, and it holds the system font with
    black text on white background:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建单元格时，它是空的，它持有文本模式，它在水平和垂直方向上居中对齐，并且它持有系统字体，文本为黑色，背景为白色：
- en: '[PRE72]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The copy constructor and assignment operator check whether `syntaxTreePtr`
    is `null`, if it is not null it is copied dynamically, its constructor continues
    copying its children recursively. It is not enough to simply copy the pointer,
    since one of the formulas of either the original or copy cell may be changed,
    but not the other one:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数和赋值运算符检查`syntaxTreePtr`是否为`null`，如果不是`null`，则动态复制，其构造函数继续递归地复制其子节点。仅仅复制指针是不够的，因为原始单元格或复制单元格的公式中可能有一个被更改，而另一个没有：
- en: '[PRE73]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'One difference between the copy constructor and the assignment operator is
    that we delete the syntax tree pointer in the assignment operator since it may
    point at dynamically allocated memory, which is not the case in the copy constructor.
    If it points at `null`, the `delete` operator does nothing:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数和赋值运算符之间的一个区别是，在赋值运算符中我们删除了语法树指针，因为它可能指向动态分配的内存，而在复制构造函数中不是这样。如果它指向`null`，则`delete`运算符不执行任何操作：
- en: '[PRE74]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The syntax tree is the only dynamically allocated memory of the cell. Again,
    in case of a null pointer, `delete` does nothing:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 语法树是单元格中唯一的动态分配的内存。再次强调，如果指针为`null`，则`delete`不执行任何操作：
- en: '[PRE75]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The difference between `Clear` and `Reset` is:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clear`和`Reset`之间的区别是：'
- en: '`Clear` is called when the user selects the **New** menu item and the spreadsheet
    shall be totally cleared and also the cell''s font, color and alignment shall
    be reset.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户选择**新建**菜单项时，会调用`Clear`，此时电子表格应完全清除，并且单元格的字体、颜色和对齐方式也应重置。
- en: '`Reset` is called when the user deletes a cell and its mode and text shall
    be reset.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户删除单元格及其模式时，会调用`Reset`，此时其模式和文本应重置。
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Character input
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符输入
- en: The `CharDown` method is called by `WindowProc` (which in turn is called by
    the Windows system) every time the user presses a graphical character. If the
    input index is at the end of the text (one step to the right of the text), we
    just add the character at the end. If it is not at the end of the text, we have
    to take into consideration the keyboard mode, which is either insert or overwrite.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharDown`方法由`WindowProc`（它反过来由Windows系统调用）在用户按下图形字符时调用。如果输入索引位于文本的末尾（文本右侧一步），我们只需添加末尾的字符。如果不是文本的末尾，我们必须考虑键盘模式，它可以是插入或覆盖。'
- en: 'In case of an insert, we insert the character, and in case of overwrite, we
    overwrite the character previously located at the edit index. Unlike the word
    processor in the previous chapters, we do not have to deal with the font, since
    all characters in the cell have the same font:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入的情况下，我们插入字符，在覆盖的情况下，我们覆盖位于编辑索引处的先前字符。与前几章中的文字处理器不同，我们不需要处理字体，因为单元格中的所有字符都有相同的字体：
- en: '[PRE77]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `MouseToIndex` method is called when the user double-clicks on the cell.
    First, we need to subtract the cell margin from the mouse position, then we iterate
    the caret list and return the position of the character hit by the mouse. If the
    user hits to the left of the first character (aligned at the center or right),
    zero index is returned, and if they hit to the right of the last character (aligned
    to the left or center), the size of the text is returned, which corresponds to
    the index to the right of the last character:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户双击单元格时，会调用`MouseToIndex`方法。首先，我们需要从鼠标位置减去单元格边距，然后遍历光标列表并返回鼠标击中的字符位置。如果用户击中第一个字符的左侧（居中对齐或右对齐），则返回零索引，如果他们击中最后一个字符的右侧（左对齐或居中对齐），则返回文本的大小，这对应于最后一个字符右侧的索引：
- en: '[PRE78]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Drawing
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制
- en: 'The `Draw` method is called when the contents of the cell are to be drawn.
    The drawing of the text is rather straightforward-for each character in the character
    list, we just draw the character in its caret rectangle. This particular cell
    may be marked or in the process of being edited, in which case the inverse is
    true. In that case, the text, background, and border colors are inverted. In order
    to not overwrite the border of the cell, we also take the cell margin into consideration:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要绘制单元格内容时，会调用`Draw`方法。文本的绘制相当直接——对于字符列表中的每个字符，我们只需在其光标矩形中绘制该字符。这个特定的单元格可能被标记或正在被编辑，在这种情况下，情况正好相反。在这种情况下，文本、背景和边框颜色被反转。为了不覆盖单元格的边框，我们还要考虑单元格边距：
- en: '[PRE79]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Caret rectangle list generation
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光标矩形列表生成
- en: When the user adds or removes a character of the text of a cell or changes its
    font or alignment, the caret rectangles need to be recalculated. `GenerateCaretList`
    can be considered a simplified version of `GenerateParagraph` in the word processor
    of the previous chapters. Its task is to calculate the character rectangles, which
    are used when setting the caret, drawing the text, and calculating the index of
    a mouse click.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户向单元格的文本中添加或删除字符、更改其字体或对齐方式时，需要重新计算光标矩形。`GenerateCaretList`可以被认为是前几章中文字处理器的`GenerateParagraph`的简化版本。其任务是计算字符矩形，这些矩形用于设置光标、绘制文本和计算鼠标点击的索引。
- en: 'First, we need to calculate the width of each character as well as the width
    of the text in order to set its horizontal start position. In case of justified
    alignment, we calculate the text width without spaces and count the spaces:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算每个字符的宽度以及文本的宽度，以便设置其水平起始位置。在两端对齐的情况下，我们计算不带空格的文本宽度并计算空格的数量：
- en: '[PRE80]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'When we have calculated the text width, we set the horizontal start position.
    In case of left or justified alignment, the start position is set to the cell
    margin. In the case of justified alignment, we also set the width of each space
    in the text. In the case of right alignment, we add the difference between the
    width of the cell and the text to the cell margin in order to place the rightmost
    part of the text at the right border in the cell. In the case of center alignment,
    we add half the difference in order for the text to be placed in the middle of
    the cell:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计算出文本宽度时，我们设置水平起始位置。在左对齐或两端对齐的情况下，起始位置设置为单元格边距。在两端对齐的情况下，我们还设置文本中每个空格的宽度。在右对齐的情况下，我们将单元格宽度与文本宽度的差值加到单元格边距上，以便将文本的最右侧部分放置在单元格的右边界上。在居中对齐的情况下，我们添加一半的差值，以便将文本放置在单元格的中间：
- en: '[PRE81]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The vertical top position is set in a similar manner. In the case of top alignment,
    the top position is set to the cell margin. In the case of bottom alignment, we
    add the difference between the height of the cell and the text to the cell margin
    in order to place the bottom part of the text at the bottom border in the cell.
    In the case of center alignment, we add half the difference in order to place
    the text in the middle of the cell:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直顶部位置以类似的方式设置。在顶部对齐的情况下，顶部位置设置为单元格边距。在底部对齐的情况下，我们将单元格高度与文本高度的差值加到单元格边距上，以便将文本的底部部分放置在单元格的底部边界。在居中对齐的情况下，我们添加一半的差值，以便将文本放置在单元格的中间：
- en: '[PRE82]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When the horizontal start position and the top vertical position has been set,
    we iterate through the characters and add the rectangles to `caretList` for each
    of them. Note that we use the value of `spaceWidth` for spaces in the case of
    justified alignment:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当水平起始位置和顶部垂直位置已设置后，我们遍历字符，并将每个字符的矩形添加到`caretList`中。请注意，在两端对齐的情况下，我们使用`spaceWidth`的值来处理空格：
- en: '[PRE83]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'When each rectangle is added, we add the rectangle for the character to the
    right of the text. We set its width to the width of an average character of the
    cell''s font:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个矩形被添加时，我们将文本右侧字符的矩形添加到其中。我们将其宽度设置为单元格字体平均字符的宽度：
- en: '[PRE84]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Formula interpretation
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公式解释
- en: 'When the user single-clicks or double-clicks on a cell, its text remains unchanged
    in the text or value mode, but it gets changed in the formula mode. In the formula
    mode, the calculated value of the formula is displayed in the mark mode, while
    in the edit mode, the formula itself is displayed. `DisplayFormula` calls `TreeToString`
    in the formula mode, which generates the text of the formula:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击或双击单元格时，其文本在文本或值模式下保持不变，但在公式模式下会发生变化。在公式模式下，公式的计算值以标记模式显示，而在编辑模式下，显示公式本身。`DisplayFormula`在公式模式下调用`TreeToString`，生成公式的文本：
- en: '[PRE85]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `InterpretCell` method is called when the user terminates the text input
    by pressing the ***Enter*** or ***Tab*** key or clicking the mouse. If the user
    has input a formula (starting with *=*), it is parsed. `Parse` returns a syntax
    tree holding the formula or throws an exception in the case of a syntax error.
    Note that `InterpretCell` only report the syntax error. All other errors (missing
    value, references out of range, circular reference, or division by zero) are handled
    by the following `Evaluate`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过按***Enter***或***Tab***键或单击鼠标来终止文本输入时，会调用`InterpretCell`方法。如果用户输入了一个公式（以`=*`开头），则对其进行解析。`Parse`返回包含公式的语法树或抛出语法错误时的异常。请注意，`InterpretCell`仅报告语法错误。所有其他错误（缺失值、引用超出范围、循环引用或除以零）都由下面的`Evaluate`处理：
- en: '[PRE86]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `GenerateSourceSet` method traverses the syntax tree and extracts a (possible
    empty) set of all its references in the formula mode. In the case of text or value
    mode, the set is empty, since only formulas hold references:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateSourceSet`方法遍历语法树，并在公式模式下提取所有引用的（可能为空）集合。在文本或值模式下，集合为空，因为只有公式包含引用：'
- en: '[PRE87]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In case of unary addition or subtraction or an expression enclosed by parentheses,
    the source set of its child node is returned:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在一元加法或减法或括号内的表达式中，返回其子节点的源集：
- en: '[PRE88]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the case of a binary expression, the union of the source sets of the two
    children is returned:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在二元表达式中，返回两个子集的源集的并集：
- en: '[PRE89]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the case of a reference, a set holding only the reference is returned if
    it is located in the spreadsheet. No references outside the spreadsheet are included
    in the set:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用的情况下，如果它位于电子表格中，则返回仅包含引用的集合。集合中不包含电子表格外的任何引用：
- en: '[PRE90]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Finally, in the case of a value, an empty set is returned:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在值的情况下，返回一个空集：
- en: '[PRE91]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `TreeToString` method traverses the syntax tree and converts it to a string.
    Note that it is quite possible to have a formula with a reference out of scope.
    However, the `Reference` class returns `?` in that case:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeToString`方法遍历语法树并将其转换为字符串。请注意，可能存在具有超出作用域引用的公式。然而，在这种情况下，`Reference`类返回`?`：'
- en: '[PRE92]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In the case of unary addition or subtraction, `+` or `-` is added to the text
    of the child node:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在一元加法或减法的情况下，将`+`或`-`添加到子节点文本中：
- en: '[PRE93]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'In the case of a binary expressions `+`, `-`, `*`, or `/` is inserted between
    the text of the child nodes:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在二元表达式`+`、`-`、`*`或`/`之间插入子节点文本：
- en: '[PRE94]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In the case of an expression enclosed by parentheses, the text of the child
    node enclosed by parentheses is returned:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内的表达式的情况下，返回括号内子节点的文本：
- en: '[PRE95]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In the case of a reference, its text is returned. Again, if the reference is
    out of range, `?` is returned:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用的情况下，返回其文本。再次强调，如果引用超出范围，`?`会被返回：
- en: '[PRE96]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In the case of a value, its converted text is returned:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在值的情况下，返回其转换后的文本：
- en: '[PRE97]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'When the user copies and pastes a block of cells, the references of each formula
    are relative and will be updated. `UpdateTree` looks for and updates references
    in the syntax tree. In all other cases, it iterates through the child list and
    calls `UpdateTree` recursively for each child (one child each in a unary expression
    and a parentheses expression, two children in a binary expression, and no children
    in values or references):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户复制粘贴一组单元格时，每个公式的引用是相对的，并且会更新。`UpdateTree`会在语法树中查找并更新引用。在所有其他情况下，它会遍历子列表，并对每个子项递归调用`UpdateTree`（一元表达式和括号表达式各有一个子项，二元表达式有两个子项，值或引用没有子项）：
- en: '[PRE98]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'When the value of a formula is evaluated, it may return a valid value, in which
    case `hasValue` is set to `true`. However, if an error occurs during the evaluation
    (missing value, references out of range, circular reference, or division by zero),
    `hasValue` is set to `false`. `hasValue` is called when a value of a formula of
    another cell is being evaluated. If it returns `false`, the evaluation will result
    in the missing value error:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当公式的值被评估时，它可能返回一个有效值，在这种情况下，`hasValue`被设置为`true`。然而，如果在评估过程中发生错误（值缺失、引用超出范围、循环引用或除以零），`hasValue`被设置为`false`。当评估另一个单元格的公式值时，会调用`hasValue`。如果它返回`false`，评估将导致缺失值错误：
- en: '[PRE99]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In the formula mode, the formula is being evaluated to a value. If an error
    occurs (missing value, reference out of range, circular reference, or division
    by zero), an exception is thrown by `Evaluate`, and the cell text is set to the
    error message text. Note that it is possible to input references out of scope,
    which `InterpretCell` accepts. However, `Evaluate` throws an exception with an
    error message that is displayed in the cell.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在公式模式下，公式正在被评估为值。如果发生错误（值缺失、引用超出范围、循环引用或除以零），`Evaluate`会抛出异常，并将单元格文本设置为错误消息文本。请注意，可以输入超出范围的引用，`InterpretCell`可以接受这些引用。然而，`Evaluate`会抛出一个包含错误消息的异常，该错误消息会在单元格中显示。
- en: 'Moreover, it is quite possible to cut, copy, and paste a cell so that its references
    get located out of the scope and then cut, copied, and pasted again so that the
    references become valid. However, if the user edits a formula with references
    out of the scope, `?` is returned by the `ToString` method in the `Reference`
    class, since it is difficult to express references with negative columns:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，完全有可能剪切、复制和粘贴一个单元格，使其引用超出范围，然后再次剪切、复制和粘贴，使引用变得有效。然而，如果用户编辑超出范围的引用的公式，`Reference`类的`ToString`方法会返回`?`，因为很难用负列表示引用：
- en: '[PRE100]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The `Evaluate` method finds the current value of the cell by looking up the
    values of the cells referred to by the formula:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluate`方法通过查找公式引用的单元格的值来找到单元格的当前值：'
- en: '[PRE101]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In the case of a unary or binary expression, the value is calculated (unary
    addition is only present for the sake of completeness and does not change the
    value):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在一元或二元表达式的情况下，值会被计算（一元加法只是为了完整性，不会改变值）：
- en: '[PRE102]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: In case of division by zero, an exception is thrown.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在除以零的情况下，会抛出异常。
- en: '[PRE103]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In the case of an expression within parentheses, we simply return its evaluated
    value:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内的表达式的情况下，我们只需返回其评估值：
- en: '[PRE104]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In the case of a reference, we look up the source cell in `valueMap`. In the
    case of a source cell with a missing value (not present in `valueMap`) or a reference
    out of scope (referring to a cell outside the spreadsheet), exceptions are thrown:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用的情况下，我们在`valueMap`中查找源单元格。在源单元格缺失值（不在`valueMap`中）或引用超出范围（引用工作表外的单元格）的情况下，会抛出异常：
- en: '[PRE105]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'In the case of a value, we simply return the value:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在值的情况下，我们直接返回该值：
- en: '[PRE106]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: File management
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件管理
- en: 'The `WriteDocumentToStream` method is called by `CalcDocument` every time the
    user selects the **Save** or **Save As** menu items from the file menu. In the
    formula mode, we call `WriteTreeToStream` on the syntax tree:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户从文件菜单中选择**保存**或**另存为**菜单项时，`CalcDocument`都会调用`WriteDocumentToStream`方法。在公式模式下，我们在语法树上调用`WriteTreeToStream`：
- en: '[PRE107]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In `ReadCellFromStream`, we dynamically create and read the syntax tree in
    the formula mode:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ReadCellFromStream`中，我们动态地在公式模式下创建和读取语法树：
- en: '[PRE108]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `WriteCellToClipboard` and `ReadCellFromClipboard` methods are called by
    `CalcDocument` when the user cuts, copies, and pastes the cell. It works in the
    same way as `WriteDocumentToStream` and `ReadCellFromStream` we saw earlier:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户剪切、复制和粘贴单元格时，`CalcDocument`会调用`WriteCellToClipboard`和`ReadCellFromClipboard`方法。它的工作方式与之前我们看到的`WriteDocumentToStream`和`ReadCellFromStream`相同：
- en: '[PRE109]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Further reading
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If the scanner and parser of this chapter have got you interested in compilers,
    I recommend that you refer to *Compilers: Principles, Techniques, and Tools* by
    A. V. Aho et al. (second edition. Addison Wesley, 2007). It is the second edition
    of the classic *Dragon Book*. The authors explain the theory and practice of compilers
    from scanning and parsing to advanced optimization.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本章的扫描器和解析器让你对编译器产生了兴趣，我建议你参考A. V. Aho等人所著的《编译原理、技术和工具》（第二版，Addison Wesley，2007）。这是经典之作《龙书》的第二版。作者从扫描和解析到高级优化，解释了编译器的理论和实践。
- en: If the concept of graphs has caught your interest, I recommend *Introduction
    to Graph Theory* by D. B. West (Prentice Hall, 2000), which reasons about graphs
    from a mathematical point of view.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图的概念引起了你的兴趣，我推荐D. B. West所著的《图论导论》（Prentice Hall，2000），它从数学的角度对图进行推理。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered the spreadsheet program implementation. This chapter
    concludes the first part of this book: how to develop an application with Small
    Windows. [Chapter 10](ch10.html "Chapter 10. The Framework"), *The Framework*,
    introduces the second part: the implementation of Small Windows.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了电子表格程序的实施。本章结束了本书的第一部分：如何使用小窗口开发应用程序。[第10章](ch10.html "第10章。框架")，《框架》，介绍了第二部分：小窗口的实现。
