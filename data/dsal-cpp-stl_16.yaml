- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Creating STL-Types Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建STL-类型容器
- en: Developers can harness unparalleled interoperability, consistency, and efficiency
    by integrating custom types with the C++ **Standard Template Library** (**STL**).
    This chapter focuses on the essential aspects of creating custom types that effortlessly
    interoperate with STL algorithms, emphasize proper operator overloading, and implement
    robust iterators. By the end of this chapter, you will be proficient in designing
    and implementing custom types, ensuring they fully utilize the strengths of the
    STL and elevate the overall effectiveness of your applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过将自定义类型与C++ **标准模板库**（**STL**）集成，利用无与伦比的互操作性、一致性和效率。本章重点介绍创建与STL算法无缝交互的自定义类型的必要方面，强调适当的操作符重载，并实现健壮的迭代器。到本章结束时，你将熟练于设计和实现自定义类型，确保它们充分利用STL的优势，并提高应用程序的整体有效性。
- en: 'In this section, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下主题：
- en: The advantages of STL-compatible types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL兼容类型的优势
- en: Interacting with STL algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与STL算法交互
- en: Essential requirements for compatibility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容性的基本要求
- en: Crafting iterators for custom types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义类型构建迭代器
- en: Effective operator overloading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的操作符重载
- en: Creating custom hash functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义哈希函数
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: The advantages of STL-compatible types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL兼容类型的优势
- en: Building STL-compatible types in C++ offers many advantages for developers seeking
    to elevate their programming prowess. One of the foremost reasons is the ability
    to tailor containers to specific needs and performance requirements. While the
    STL provides a rich set of generic containers, custom containers allow us to finely
    tune data structures when standard ones fall short in catering to intricate application
    demands or optimization goals. Moreover, crafting our own containers grants us
    enhanced control over critical aspects, such as memory layout, allocation strategies,
    and container behaviors. This granular control empowers us to optimize memory
    usage and boost application efficiency. Beyond the tangible benefits, embarking
    on the journey of building custom containers is an invaluable opportunity to deepen
    our understanding of C++ internals and intricacies. It’s a path that leads to
    a higher level of expertise in a language known for its depth and precision.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中构建STL兼容类型为寻求提升编程能力的开发者提供了许多优势。其中最显著的原因是能够根据特定需求和性能要求定制容器。虽然STL提供了一套丰富的泛型容器，但自定义容器使我们能够在标准容器无法满足复杂应用需求或优化目标时，对数据结构进行精细调整。此外，创建自己的容器使我们能够对关键方面，如内存布局、分配策略和容器行为，拥有更大的控制权。这种细粒度的控制使我们能够优化内存使用并提高应用程序的效率。除了实际的好处之外，开始构建自定义容器的旅程是加深我们对C++内部和复杂性的理解的无价机会。这是一条通往语言深度和精确度更高水平的专家知识的道路。
- en: One language, one approach
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种语言，一种方法
- en: First and foremost, making custom types STL-friendly offers an undeniable benefit
    – uniformity. Consider the vast plethora of algorithms and containers within the
    STL. From sorting routines to complex data structures, the STL is the bedrock
    of C++ development. By aligning your types with the STL, you ensure they can seamlessly
    interoperate with this expansive library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先也是最重要的，使自定义类型与STL友好提供了一种不可否认的好处——一致性。考虑STL中大量算法和容器的多样性。从排序例程到复杂的数据结构，STL是C++开发的基石。通过使你的类型与STL保持一致，你确保它们可以与这个庞大的库无缝交互。
- en: Picture this – a developer new to your code base, already familiar with STL,
    finds themselves at home when they see that your custom types follow the same
    patterns. This consistent approach significantly reduces the learning curve, offering
    a familiar and intuitive experience. Imagine the convenience of using the `std::for_each`
    algorithm on your custom type, just as one would with `std::vector` or `std::list`.
    This unity in design boosts productivity and fosters code readability.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下——一个刚接触您的代码库的开发者，已经熟悉 STL，当他们看到您的自定义类型遵循相同的模式时，会感到宾至如归。这种一致的方法显著降低了学习曲线，提供了熟悉且直观的体验。想象一下在您的自定义类型上使用
    `std::for_each` 算法的便利性，就像使用 `std::vector` 或 `std::list` 一样。这种设计上的统一性提高了生产力，并促进了代码的可读性。
- en: Reusability – the gift that keeps giving
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重用性——源源不断的礼物
- en: Building upon the notion of uniformity, there’s another equally compelling argument
    for STL compatibility – reusability. Adhering to STL conventions makes your custom
    types reusable across diverse scenarios. Think of the vast collection of algorithms
    provided by the STL. Once your type is STL-compatible, it can immediately benefit
    from all these algorithms without reinventing the wheel.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在统一性概念的基础上，关于 STL 兼容性的另一个同样有说服力的论点是可重用性。遵循 STL 规范可以使您的自定义类型在多种场景中可重用。想想 STL
    提供的庞大算法集合。一旦您的类型与 STL 兼容，它就可以立即从所有这些算法中受益，无需重新发明轮子。
- en: Moreover, reusability isn’t just limited to algorithms. The chances are that
    if your type is STL-compatible, other developers can adopt it in their projects
    with ease. Over time, this encourages collaborative development and fosters an
    ecosystem where code is written, shared, reviewed, and improved upon by a broader
    community.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可重用性不仅限于算法。如果您的类型与 STL 兼容，其他开发者可以轻松地在他们的项目中采用它。随着时间的推移，这鼓励了协作开发，并培养了一个更广泛的社区参与编写、共享、审查和改进代码的生态系统。
- en: Efficiency in the familiar
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在熟悉的领域中提高效率
- en: At the heart of the STL lies a commitment to performance. The library is meticulously
    optimized to ensure efficiency. By making your types STL-compatible, you position
    them to leverage these optimizations. Whether it is a sorting routine or a complex
    associative container, you can be confident that your type will benefit from all
    of the performance optimizations within the STL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的核心是对性能的承诺。该库经过精心优化以确保效率。通过使您的类型与 STL 兼容，您使它们能够利用这些优化。无论是排序例程还是复杂的关联容器，您都可以确信您的类型将受益于
    STL 中的所有性能优化。
- en: Furthermore, an STL-friendly design often guides developers away from common
    pitfalls. Given that the STL has been tried and tested over the years, aligning
    with its conventions inherently encourages best practices in type design.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，STL 友好型设计通常引导开发者避免常见的陷阱。鉴于 STL 多年来经过测试和验证，与它的规范一致本质上鼓励了类型设计中的最佳实践。
- en: Paving the way forward
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为前进铺路
- en: With an evident appreciation of the merits of STL-compatible types, the journey
    ahead becomes even more interesting. The stage is set as we recognize the value
    of uniformity, reusability, and efficiency that comes with STL compatibility.
    The subsequent sections will uncover the intricacies of ensuring your custom types
    align with STL and shine in their uniqueness. From interacting with STL algorithms
    to the nuances of crafting custom iterators, the roadmap is clear – creating types
    that stand tall in their compatibility and versatility.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对 STL 兼容类型优点的明显认可使未来的旅程变得更加有趣。随着我们认识到统一性、可重用性和效率的价值，我们已经为 STL 兼容性做好了准备。接下来的章节将揭示确保您的自定义类型与
    STL 保持一致并展现其独特性的复杂性。从与 STL 算法交互到定制迭代器的细微差别，路线图清晰可见——创建兼容性强、多功能性高的类型。
- en: In this section, we explored the advantages of making custom types STL-compatible.
    This journey has equipped you with the understanding of why STL-friendly design
    is not merely a choice but also a significant stride in C++ development. We looked
    at the virtues of uniformity, reusability, and efficiency, highlighting how these
    qualities elevate your custom types within the C++ landscape.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了使自定义类型 STL 兼容的优点。这段旅程使您理解了 STL 友好型设计不仅仅是一个选择，而且在 C++ 开发中是一个重要的进步。我们研究了统一性、可重用性和效率的优点，强调了这些品质如何提升您的自定义类型在
    C++ 生态系统中的地位。
- en: As we move on to the next section, *Interacting with STL algorithms*, we’ll
    transition from the *why* to the *how* of STL compatibility. This upcoming section
    will guide you through the crucial role of iterators in interfacing with STL algorithms,
    adapting your custom types to meet algorithmic expectations, and handling errors
    effectively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入下一节“与 STL 算法交互”时，我们将从“为什么”过渡到“如何”实现 STL 兼容性。即将到来的这一节将指导你了解迭代器在接口 STL 算法中的关键作用，调整你的自定义类型以满足算法预期，并有效地处理错误。
- en: Interacting with STL algorithms
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 STL 算法交互
- en: This section will focus on equipping you with the skills necessary to seamlessly
    integrate custom types with STL algorithms, a critical aspect of advanced C++
    programming. This integration is not just about conforming to standards but also
    about creating a symbiotic relationship, where custom types and STL algorithms
    enhance each other’s capabilities. You will learn how to design and implement
    robust iterators for your custom types, which is crucial for enabling smooth interaction
    with STL algorithms. Understanding the specific requirements of different STL
    algorithms and tailoring your custom types to meet these needs is also a key focus.
    This includes supporting various operations, such as copying, comparison, and
    arithmetic, which are essential for algorithms to function correctly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将专注于为你提供将自定义类型无缝集成到 STL 算法中的技能，这是高级 C++ 编程的一个关键方面。这种集成不仅仅是符合标准，而且是一种共生关系，其中自定义类型和
    STL 算法相互增强彼此的能力。你将学习如何为你的自定义类型设计和实现健壮的迭代器，这对于与 STL 算法实现顺畅交互至关重要。了解不同 STL 算法的具体要求，并调整你的自定义类型以满足这些需求也是关键焦点。这包括支持各种操作，如复制、比较和算术运算，这些都是算法正确运行所必需的。
- en: We will also cover the nuances of error handling and feedback mechanisms, teaching
    you how to make your custom types not only facilitate the operations of STL algorithms
    but also respond appropriately to unexpected scenarios. Emphasizing algorithmic
    efficiency, we will guide you through best practices to ensure that your custom
    types do not become performance bottlenecks. By the end of this section, you will
    have gained invaluable insights into creating custom types that are not only compatible
    with STL algorithms but also optimized for performance, making your C++ programming
    more effective and your applications more efficient and maintainable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涵盖错误处理和反馈机制的细微差别，教你如何让你的自定义类型不仅能够促进 STL 算法的操作，而且能够适当地应对意外情况。强调算法效率，我们将引导你通过最佳实践来确保你的自定义类型不会成为性能瓶颈。到本节结束时，你将获得关于创建与
    STL 算法兼容且性能优化的自定义类型的宝贵见解，这将使你的 C++ 编程更加有效，你的应用程序更加高效和易于维护。
- en: The centrality of iterators
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器的核心地位
- en: Iterators serve as the bridge between custom types and STL algorithms. At their
    core, STL algorithms predominantly rely on iterators to navigate and manipulate
    data within containers. Hence, any custom type aiming for flawless integration
    must prioritize a robust iterator design. While we’ll touch upon crafting iterators
    in a dedicated section, it is essential to understand their pivotal role. Providing
    a suite of iterators – ranging from forward iterators to bidirectional and even
    random-access ones – enhances the spectrum of STL algorithms that your custom
    type can interact with.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是自定义类型和 STL 算法之间的桥梁。在核心上，STL 算法主要依赖于迭代器在容器内导航和操作数据。因此，任何旨在完美集成的自定义类型都必须优先考虑一个健壮的迭代器设计。虽然我们将在专门的章节中涉及迭代器的构建，但理解它们的关键作用是至关重要的。提供一系列迭代器——从正向迭代器到双向迭代器，甚至随机访问迭代器——扩展了你的自定义类型可以与之交互的
    STL 算法范围。
- en: Adapting to algorithmic expectations
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适应算法预期
- en: Each STL algorithm has a set of requirements or expectations from the containers
    it interacts with. For instance, the `std::sort` algorithm operates optimally
    with random-access iterators. As such, to ensure that a custom type meshes well
    with this sorting routine, it should ideally support random-access iterators.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 STL 算法都有一套来自其交互的容器的需求或预期。例如，`std::sort` 算法与随机访问迭代器配合工作最为优化。因此，为了确保自定义类型与这种排序例程良好配合，它应该理想地支持随机访问迭代器。
- en: But the relationship goes deeper. Some algorithms expect the ability to copy
    elements, some require comparison operations, while others might need arithmetic
    operations. Therefore, understanding the prerequisites of the algorithms you aim
    to support is crucial. The more you fine-tune your custom type based on these
    expectations, the better the synergy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种关系更为深入。一些算法期望能够复制元素，一些需要比较操作，而另一些可能需要算术操作。因此，理解你想要支持的算法的先决条件至关重要。你根据这些期望对自定义类型进行越精细的调整，协同作用就越好。
- en: Error handling and feedback mechanisms
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理和反馈机制
- en: A robust custom type does not merely facilitate an algorithm’s operations but
    also offers feedback mechanisms. Suppose an STL algorithm encounters an unexpected
    scenario while operating on your custom type. In such a case, how does your type
    respond? Implementing mechanisms to handle potential issues and provide meaningful
    feedback is integral. This could be in the form of exceptions or other error-handling
    paradigms that C++ supports.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个健壮的自定义类型不仅能够促进算法的操作，还提供了反馈机制。假设 STL 算法在操作你的自定义类型时遇到意外情况。在这种情况下，你的类型将如何响应？实现处理潜在问题并提供有意义反馈的机制是至关重要的。这可能以异常或其他
    C++ 支持的错误处理范例的形式出现。
- en: 'Let’s look at the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看以下示例：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding example has a `CustomType` that supports comparison, arithmetic,
    and copy operations. We also have a `CustomContainer` that provides random-access
    iterators (through the underlying `std::vector`). The `std::sort` algorithm is
    used to sort the elements in the container. If an error occurs during the sorting
    process, it is caught and handled in the `catch` block.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中的 `CustomType` 支持比较、算术和复制操作。我们还有一个 `CustomContainer`，它提供了随机访问迭代器（通过底层的
    `std::vector`）。使用 `std::sort` 算法对容器中的元素进行排序。如果在排序过程中发生错误，它将在 `catch` 块中被捕获和处理。
- en: Algorithmic efficiency and your type
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法效率和你的类型
- en: STL algorithms are known for their performance, often crafted with intricate
    optimizations. However, the custom type can bottleneck the algorithm’s efficiency
    if it is not designed with performance in mind. Consider scenarios where the algorithm
    might need to access elements or frequently iterate over the custom container.
    Any latency in these fundamental operations can amplify during the algorithm’s
    execution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: STL 算法以其性能著称，通常经过复杂的优化。然而，如果自定义类型没有考虑到性能，它可能会成为算法效率的瓶颈。考虑以下场景：算法可能需要访问元素或频繁遍历自定义容器。在这些基本操作中的任何延迟都可能在算法执行过程中放大。
- en: As a best practice, continually benchmark your custom type’s performance when
    subjected to STL algorithms. Profiling tools can offer insights into potential
    bottlenecks and guiding optimizations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，当你的自定义类型受到 STL 算法的影响时，应持续对其性能进行基准测试。性能分析工具可以提供关于潜在瓶颈和指导优化的见解。
- en: Laying a solid foundation
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立坚实的基础
- en: In essence, the journey to making custom types STL algorithm-friendly is multifaceted.
    Starting from the foundational element of iterators, venturing into understanding
    algorithmic expectations, emphasizing error handling, and prioritizing efficiency
    form the crux of this endeavor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使自定义类型成为 STL 算法友好的旅程是多方面的。从迭代器的基础元素开始，探索理解算法期望，强调错误处理，以及优先考虑效率，构成了这一努力的精髓。
- en: In this section, we have immersed ourselves in the process of integrating custom
    types with STL algorithms. This helps our code form a symbiotic relationship with
    the STL, where custom types and STL algorithms mutually enhance each other’s functionality.
    We explored the critical role of iterators as the vital link between custom types
    and STL algorithms, understanding their necessity for smooth data navigation and
    manipulation. Additionally, we learned about adapting custom types to meet the
    specific requirements of various STL algorithms, ensuring optimal performance
    and effective integration.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了将自定义类型与 STL 算法集成的过程。这有助于我们的代码与 STL 形成共生关系，其中自定义类型和 STL 算法相互增强对方的功能。我们探讨了迭代器在自定义类型和
    STL 算法之间的关键作用，作为连接两者的纽带，理解它们在数据流畅导航和处理中的必要性。此外，我们还学习了如何使自定义类型适应各种 STL 算法的特定要求，确保最佳性能和有效集成。
- en: As we move forward to the next section, *Essential requirements for compatibility*,
    our focus will shift from the broad interactions with STL algorithms to the specific
    requirements and standards for achieving true STL compatibility.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入下一节“兼容性的基本要求”时，我们的关注点将从与 STL 算法的广泛交互转移到实现真正 STL 兼容的具体要求和标准。
- en: Essential requirements for compatibility
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兼容性的基本要求
- en: In this section, we focus on the foundational aspects that make a custom type
    truly compatible with the STL. Understanding and implementing the key elements
    we will outline is crucial for leveraging the full potential of STL’s robust and
    versatile toolkit. We will cover the essentials, such as the design of iterators,
    adherence to value semantics, operational guarantees, and the provision of size
    and capacity information, each playing a vital role in ensuring seamless integration
    with STL algorithms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们关注使自定义类型真正与 STL 兼容的基础方面。理解和实现我们将概述的关键元素对于充分利用 STL 强大且多功能的工具包的潜力至关重要。我们将涵盖基本要素，例如迭代器的设计、遵循值语义、操作保证以及提供大小和容量信息，每个要素都在确保与
    STL 算法的无缝集成中发挥着至关重要的作用。
- en: The goal here is to equip your custom types with the capability to not only
    interact with but also enhance the efficiency and functionality of STL algorithms.
    This requires an understanding of the STL’s expectations in terms of performance,
    behavior under operations, and exception safety. By meeting these requirements,
    you will be able to create custom types that are not just functional but also
    optimized for performance and reliability within the STL framework.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的目标是使您的自定义类型不仅能够与 STL 算法交互，还能提高其效率和功能。这需要理解 STL 在性能、操作行为和异常安全性方面的期望。通过满足这些要求，您将能够创建不仅功能性强，而且在
    STL 框架内针对性能和可靠性进行了优化的自定义类型。
- en: The cornerstones of compatibility
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容性的基石
- en: Venturing into the world of STL compatibility is akin to joining an exclusive
    club. The key to entry is understanding and adhering to foundational requirements.
    Once you’ve got these down pat, the immense benefits of the STL are yours for
    the taking. Let’s embark on this transformative journey and unravel the essential
    components for seamless integration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 STL 兼容性的世界就像加入一个独家俱乐部。进入的关键是理解和遵守基础要求。一旦您掌握了这些，STL 的巨大好处就属于您了。让我们开始这段变革之旅，揭示无缝集成所必需的基本组件。
- en: The vitality of iterators
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器的重要性
- en: An STL-compatible type is synonymous with iterators. They’re the veins that
    channel data to and from the STL’s algorithms. However, it is not enough to merely
    provide an iterator. The nature and capabilities of your iterators define which
    algorithms can interact with your custom type. A forward iterator might grant
    basic functionalities, but you’d need bidirectional or even random-access iterators
    if you wish to leverage more advanced algorithms. Ensuring your custom type exposes
    the appropriate iterator opens the doors to a broader range of algorithmic interactions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与 STL 兼容的类型等同于迭代器。它们是向 STL 算法输送数据的脉络。然而，仅仅提供迭代器是不够的。您迭代器的性质和能力定义了哪些算法可以与您的自定义类型交互。正向迭代器可能提供基本功能，但若要利用更高级的算法，您需要双向甚至随机访问迭代器。确保您的自定义类型公开适当的迭代器，将为更广泛的算法交互打开大门。
- en: Embracing value semantics
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拥抱值语义
- en: C++ and its STL thrive on value semantics. This means that objects clearly understand
    copy, assignment, and destruction. When constructing an STL-compatible type, it
    is imperative to define clear and efficient copy constructors, copy assignment
    operators, move operations, and destructors. A well-defined semantic behavior
    ensures that algorithms can seamlessly create, modify, or destroy instances of
    your custom type without unforeseen consequences.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 及其 STL 依赖于值语义。这意味着对象明确理解复制、赋值和销毁。在构建与 STL 兼容的类型时，定义清晰且高效的复制构造函数、复制赋值运算符、移动操作和析构函数至关重要。定义良好的语义行为确保算法可以无缝地创建、修改或销毁您的自定义类型的实例，而不会出现未预见的后果。
- en: Operational guarantees
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作保证
- en: Algorithms rely on certain operations being performed in predictable time frames.
    For instance, `std::vector` guarantees constant-time access to its elements. If
    your custom type promises similar access, it should consistently deliver on that
    promise. Providing accurate operational guarantees ensures that the algorithm
    performs optimally and as expected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 算法依赖于某些操作在可预测的时间框架内执行。例如，`std::vector`保证其元素可以以常数时间访问。如果你的自定义类型承诺类似的访问，它应该始终如一地履行这一承诺。提供准确的操作保证确保算法以最佳和预期的方式执行。
- en: Size and capacity queries
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大小和容量查询
- en: STL algorithms often require information about the size of a container or, in
    some cases, its capacity. Your custom type needs to furnish these details promptly.
    Functions such as `size()`, `empty()`, and potentially, `capacity()` should be
    integral components of your design.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法通常需要关于容器大小或在某些情况下其容量的信息。你的自定义类型需要及时提供这些细节。`size()`、`empty()`和可能还有`capacity()`函数应该是你设计中的基本组成部分。
- en: Element access and manipulation
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素访问和操作
- en: Beyond understanding the structure, STL algorithms need to access and manipulate
    the elements within. This calls for member functions or operators to facilitate
    direct access, insertion, and removal. The more versatile these operations, the
    broader the range of algorithms your custom type can befriend.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅要理解结构，STL算法还需要访问和操作其内部的元素。这需要成员函数或运算符来简化直接访问、插入和删除。这些操作越灵活，你的自定义类型能够兼容的算法范围就越广。
- en: Consistency in exception safety
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常安全性的一致性
- en: Exception safety is the assurance that your code won’t leak resources or end
    up undefined when exceptions occur. The STL adopts a nuanced approach to exception
    safety, often categorized into levels such as “basic” and “strong.” Aligning your
    custom type’s exception safety guarantees with those of the STL ensures smoother
    interactions and fortifies your type’s reliability.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 异常安全性是确保你的代码在异常发生时不会泄露资源或变得未定义的保证。STL采用了一种细微的异常安全性方法，通常分为“基本”和“强”等层次。将你的自定义类型的异常安全性保证与STL的保证相一致，确保更顺畅的交互并加强你类型的可靠性。
- en: 'Let’s look at an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the example output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code defines a `CustomType` class that is compatible with the STL. It provides
    iterators and defines copy and move constructors, assignment operators, and a
    destructor. It also provides functions to query size and capacity and to access
    and manipulate elements. The `main` function demonstrates how to use an STL algorithm
    (`std::for_each`) with an instance of `CustomType`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了一个与STL兼容的`CustomType`类。它提供了迭代器，并定义了拷贝构造函数、移动构造函数、赋值运算符和析构函数。它还提供了查询大小和容量以及访问和操作元素的函数。`main`函数演示了如何使用`CustomType`实例与STL算法（`std::for_each`）一起使用。
- en: Looking forward to enhanced integration
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 期待增强的集成
- en: With a grasp of these foundational requirements, you’re well on your way to
    crafting types that resonate harmoniously with the STL. Remember, it is a partnership.
    While the STL offers algorithms and utilities of unparalleled power, your custom
    types bring unique functionalities and nuances. When these worlds collide in compatibility,
    the result is coding magic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这些基础要求之后，你将朝着制作与STL和谐共鸣的类型迈进。记住，这是一个伙伴关系。虽然STL提供了无与伦比强大算法和工具，但你的自定义类型带来了独特的功能和细微差别。当这些世界在兼容性中碰撞时，结果就是编码魔法。
- en: As we progress to the subsequent sections, we’ll deepen our understanding, touching
    upon the intricate art of crafting iterators and the subtleties of operator overloading.
    Each step you take solidifies your position in the elite club of STL integration,
    unlocking greater programming prowess.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入下一部分，我们将深化对创建迭代器的复杂艺术和运算符重载的微妙之处的理解。你每迈出的一步都巩固了你在STL集成精英俱乐部中的地位，解锁了更大的编程能力。
- en: Crafting iterators for custom types
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为自定义类型创建迭代器
- en: Iterators are, without a doubt, the heartbeat of data access in the world of
    the STL. They act as bridges, connecting custom data structures with the vast
    array of STL algorithms. A well-crafted iterator ensures seamless data access
    and modification, making your custom types feel like they’ve been part of the
    STL family all along.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器无疑是STL数据访问世界的心脏。它们作为桥梁，将自定义数据结构与STL算法的广泛数组连接起来。一个精心设计的迭代器确保了无缝的数据访问和修改，使你的自定义类型感觉就像一直是STL家族的一员。
- en: Creating STL iterators for custom types is pivotal in C++ programming, as they
    act as essential bridges, enabling seamless integration and interaction between
    custom types and the myriad of STL algorithms. They facilitate the traversal and
    manipulation of data within custom containers, ensuring that these types can fully
    leverage the power and efficiency of STL’s algorithms. Without properly designed
    iterators, custom types would be isolated, unable to tap into the extensive and
    optimized functionalities that the STL offers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++编程中，为自定义类型创建STL迭代器至关重要，因为它们作为基本桥梁，使得自定义类型与STL算法的众多算法之间能够无缝集成和交互。它们促进了自定义容器内数据的遍历和操作，确保这些类型能够充分利用STL算法的强大功能和效率。如果没有设计良好的迭代器，自定义类型将会孤立，无法利用STL提供的广泛和优化的功能。
- en: Choosing the right iterator type
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的迭代器类型
- en: There is a myriad of iterator types to pick from, each bringing its own capabilities
    to the table. A forward iterator enables one-way movement through a sequence,
    while a bidirectional iterator offers you the ability to traverse in reverse.
    Stepping it up, random-access iterators allow swift jumps to any position in a
    data structure. When crafting iterators for your custom types, it is crucial to
    identify which type aligns with the nature of your data and the operations you
    wish to support. The chosen type sets the stage for the algorithms that can be
    utilized and the efficiency of those operations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多迭代器类型可供选择，每种类型都为其提供了独特的功能。正向迭代器允许通过序列进行单向移动，而双向迭代器则提供了反向遍历的能力。更进一步，随机访问迭代器允许在数据结构中的任何位置进行快速跳跃。当为自定义类型构建迭代器时，确定哪种类型与你的数据和希望支持的运算的性质相匹配至关重要。所选类型为可以使用的算法和这些操作的效率设定了舞台。
- en: The selection of an iterator type should be guided by the inherent characteristics
    of your data structure and the efficiency requirements of the operations you intend
    to perform. Forward iterators are the simplest, supporting only one-directional
    traversal. They are suitable for data structures requiring only sequential access,
    such as singly linked lists. This simplicity can lead to more optimized performance
    for such tasks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 选择迭代器类型应该根据你数据结构的固有特性和你打算执行的操作的效率要求来指导。正向迭代器是最简单的，只支持单向遍历。它们适用于只需要顺序访问的数据结构，例如单链表。这种简单性可以导致此类任务性能的优化。
- en: Bidirectional iterators, which allow traversal in both directions, are apt for
    structures such as doubly linked lists, where reverse iteration is as fundamental
    as forward iteration. The added flexibility of moving backward comes with a slight
    increase in complexity, but if your data structure and algorithms benefit from
    bidirectional traversal, this is a justified choice.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 双向迭代器允许双向遍历，适用于如双向链表这样的结构，其中反向迭代与正向迭代一样基本。向后移动的额外灵活性伴随着轻微的复杂性增加，但如果你的数据结构和算法从双向遍历中受益，这是一个合理的选择。
- en: Random access iterators offer the most flexibility, enabling direct access to
    any element in constant time, akin to array indexing. They are indispensable for
    data structures such as vectors and arrays, where such capabilities are essential.
    However, this level of functionality is not necessary for all data types and can
    add unnecessary overhead if the data structure does not inherently support fast
    random access.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随机访问迭代器提供了最大的灵活性，允许在常数时间内直接访问任何元素，类似于数组索引。它们对于向量、数组等需要此类功能的数据结构是必不可少的。然而，这种级别的功能对于所有数据类型来说并不是必需的，如果数据结构本身不支持快速随机访问，这可能会增加不必要的开销。
- en: In essence, while you can design a data structure to use a more advanced iterator
    type such as random access, doing so without a need for its capabilities can lead
    to inefficiencies. The iterator choice should align with the natural behavior
    and requirements of your data structure to ensure optimal performance and resource
    utilization. It is about finding the right balance between the functionality provided
    by the iterator and the nature of the data structure it is intended for.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，虽然你可以设计一个数据结构来使用更高级的迭代器类型，如随机访问，但在不需要其功能的情况下这样做可能会导致效率低下。迭代器的选择应与数据结构的自然行为和需求相一致，以确保最佳性能和资源利用。这是在迭代器提供的功能与它打算用于的数据结构的本质之间找到正确平衡的问题。
- en: Crafting the basic components
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基本组件
- en: At its core, an iterator must support a set of basic operations that define
    its behavior. This includes dereferencing to access the underlying data, incrementing
    and potentially decrementing to navigate through the data, and comparison to determine
    the relative positions of two iterators. Implementing these operations effectively
    ensures that your custom type’s iterators play nicely with STL algorithms.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，迭代器必须支持一组基本操作来定义其行为。这包括解引用以访问底层数据，递增和可能递减以遍历数据，以及比较以确定两个迭代器的相对位置。有效地实现这些操作确保你的自定义类型的迭代器能够与
    STL 算法良好协作。
- en: Addressing iterator categories with type traits
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型特性处理迭代器类别
- en: STL algorithms, being the discerning entities they are, often look for clues
    about the nature of an iterator. They use these hints to optimize their behavior.
    This is where type traits come into play. By specializing `std::iterator_traits`
    for your custom iterator, you’re effectively whispering in the algorithm’s ear,
    telling it what to expect. This knowledge equips algorithms to make the best choices
    in their operations, ensuring peak performance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: STL 算法，作为有洞察力的实体，经常寻找关于迭代器性质的线索。它们使用这些线索来优化其行为。这正是类型特性发挥作用的地方。通过为你的自定义迭代器特化
    `std::iterator_traits`，你实际上是在算法耳边低语，告诉它预期什么。这种知识使算法能够在操作中做出最佳选择，确保最佳性能。
- en: End iterators – signifying the finish line
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束迭代器 – 标志着终点线
- en: Every journey needs a clear destination, and iterators are no exception. Beyond
    the iterators that allow access to data, it is paramount to provide an *end* iterator.
    This special iterator doesn’t point to valid data but signifies the boundary –
    the point past the last valid element. STL algorithms rely on this sentinel to
    know when to stop their operations, making it an essential part of any iterator
    suite.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每次旅行都需要一个明确的终点，迭代器也不例外。除了允许访问数据的迭代器之外，提供一个*结束*迭代器至关重要。这个特殊的迭代器不指向有效数据，而是表示边界
    – 超过最后一个有效元素的点。STL 算法依赖于这个哨兵来知道何时停止操作，使其成为任何迭代器套件的重要组成部分。
- en: Considerations for const iterators
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于常量迭代器的考虑
- en: Just as a library provides regular books and reference-only texts, data structures
    often need to cater to modification and mere viewing. **Const iterators** cater
    to the latter scenario, allowing data to be accessed without the risk of modification.
    Crafting const iterators ensures that your custom type can be safely used in scenarios
    where data integrity is paramount.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如图书馆提供常规书籍和仅作参考的文本一样，数据结构通常需要满足修改和仅查看的需求。**常量迭代器**满足后一种场景，允许数据被访问而不存在修改的风险。构建常量迭代器确保你的自定义类型可以在数据完整性至关重要的场景中安全使用。
- en: 'Let’s look at an illustrative C++ code example that demonstrates the creation
    of a custom iterator for a custom data structure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个说明性的 C++ 代码示例，演示了为自定义数据结构创建自定义迭代器的过程：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the example output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Performance optimizations and advanced techniques
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能优化和高级技术
- en: Crafting an iterator isn’t just about functionality but also finesse. Consider
    memory caching techniques, prefetching, and other optimizations to enhance performance.
    Remember, an iterator is a frequently used component, and any efficiency improvements
    can have a significant ripple effect on overall application performance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 构建迭代器不仅仅是关于功能，还需要技巧。考虑内存缓存技术、预取和其他优化来提升性能。记住，迭代器是一个经常使用的组件，任何效率提升都可能对整体应用性能产生重大影响。
- en: Embracing the iterative spirit
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拥抱迭代精神
- en: With a deep dive into the world of iterators behind us, it is clear that they
    are more than just tools – they are a testament to the versatility and power of
    the STL. By meticulously crafting iterators for your custom types, you enhance
    interoperability with STL algorithms and elevate the user experience, making data
    access intuitive and efficient. Throughout this section, we learned why it is
    important to choose the right iterator types, how to write basic iterators, and
    the things to consider when building const iterators. In the next section, we’ll
    explore the nuances of operator overloading, ensuring that our custom types genuinely
    feel at home in the world of C++ and STL.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解迭代器世界之后，很明显，它们不仅仅是工具——它们是 STL 通用性和强大功能的证明。通过精心设计自定义类型的迭代器，你可以增强与 STL 算法的互操作性，提升用户体验，使数据访问直观且高效。在本节中，我们学习了为什么选择正确的迭代器类型很重要，如何编写基本的迭代器，以及构建常量迭代器时需要考虑的事项。在下一节中，我们将探讨操作符重载的细微差别，确保我们的自定义类型在
    C++ 和 STL 的世界中真正感到舒适。
- en: Effective operator overloading
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的操作符重载
- en: Next, let’s work to understand the strategic implementation of operator overloading
    in C++, a feature that significantly enhances the functionality and integration
    of custom types. Operator overloading allows custom types to emulate the behavior
    of built-in types, providing a seamless interface for STL algorithms to work with
    these types as efficiently as they do with native C++ types. This feature is instrumental
    in ensuring that custom types are not just compatible with STL algorithms but
    also optimized for their efficient execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们努力理解 C++ 中操作符重载的战略实现，这是一个显著增强自定义类型功能和集成特性的特性。操作符重载允许自定义类型模拟内置类型的行为，为
    STL 算法提供一个无缝的接口，以便它们能够像处理原生 C++ 类型一样高效地处理这些类型。这一特性对于确保自定义类型不仅与 STL 算法兼容，而且针对其高效执行进行了优化至关重要。
- en: The focus here is on designing operator overloads that facilitate the integration
    of custom types into the STL framework. For example, overloading arithmetic operators
    such as `+`, `-`, and `*` allows custom types to directly participate in STL algorithms
    that perform mathematical operations, such as `std::transform` or `std::accumulate`.
    Similarly, overloading relational operators such as `==`, `<`, and `>` enables
    custom types to be effectively used with STL algorithms that require element comparisons,
    such as `std::sort` or `std::binary_search`. The key is to ensure that these overloaded
    operators mimic the behavior of their counterparts for built-in types, maintaining
    the intuitive nature of operations and enhancing the predictability of algorithm
    outcomes. By carefully implementing operator overloading, we can ensure that custom
    types not only interact flawlessly with STL algorithms but also contribute to
    the overall efficiency and readability of C++ programs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此处重点在于设计操作符重载，以促进自定义类型集成到 STL 框架中。例如，重载算术操作符如 `+`、`-` 和 `*` 允许自定义类型直接参与执行数学运算的
    STL 算法，如 `std::transform` 或 `std::accumulate`。同样，重载关系操作符如 `==`、`<` 和 `>` 使自定义类型能够有效地用于需要元素比较的
    STL 算法，如 `std::sort` 或 `std::binary_search`。关键是要确保这些重载的操作符模仿内置类型对应操作符的行为，保持操作直观性并提高算法结果的可预测性。通过精心实现操作符重载，我们可以确保自定义类型不仅与
    STL 算法无缝交互，而且有助于提高 C++ 程序的整体效率和可读性。
- en: Operator overloading in C++
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 中的操作符重载
- en: Operator overloading allows custom types in C++ to have specialized behaviors
    for standard operators. By leveraging this feature, developers can implement operations
    on custom types as straightforwardly as with built-in types, enhancing code readability
    and consistency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符重载允许 C++ 中的自定义类型为标准操作符提供特定的行为。通过利用这一特性，开发者可以像使用内置类型一样直接实现自定义类型上的操作，从而提高代码的可读性和一致性。
- en: Considerations in overloading
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载时的考虑因素
- en: Although operator overloading can make expressions more expressive, it’s crucial
    to use it judiciously. The primary objective should be to enhance clarity, not
    introduce confusion. A fundamental guideline is that an overloaded operator should
    behave similarly to its counterpart for built-in types. Deviating from this standard
    can produce code that is difficult to understand and maintain.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管操作符重载可以使表达式更加丰富，但关键是要谨慎使用。主要目标应该是提高清晰度，而不是引起混淆。一个基本的指导原则是，重载的操作符应该与内置类型的对应操作符表现相似。偏离这个标准可能会产生难以理解和维护的代码。
- en: Implementing arithmetic operators for custom types
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义类型的算术运算符
- en: For a custom mathematical vector type, it’s reasonable to implement operations
    such as addition (`+`), subtraction (`-`), and multiplication (`*`). Overloading
    these operators ensures that developers can operate on your custom type just as
    with primitive data types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义的数学向量类型，实现加法（`+`）、减法（`-`）和乘法（`*`）等操作是合理的。重载这些运算符确保开发者可以像处理原始数据类型一样操作您的自定义类型。
- en: Overloading relational operators for clear comparisons
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载关系运算符以进行清晰的比较
- en: Relational operators (`==`, `!=`, `<`, `<=`, `>`, `>=`) are not limited to primitive
    types. By overloading these operators for custom types, you provide a direct method
    to compare instances. This capability simplifies tasks such as sorting a list
    of custom objects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符（`==`、`!=`、`<`、`<=`、`>`、`>=`）不仅限于原始类型。通过为自定义类型重载这些运算符，您提供了直接比较实例的方法。这种能力简化了如对自定义对象列表进行排序等任务。
- en: 'Consider a custom `Product` class with an overload of the `+`, `<`, `=`, and
    `+=` operators. The implementation is straightforward and provides a very intuitive
    way to interact with the class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个自定义的 `Product` 类，它重载了 `+`、`<`、`=` 和 `+=` 运算符。实现方式简单直观，为与类的交互提供了非常直观的方式：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the example output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example demonstrates how to leverage operator overloads on custom types.
    These overloads (especially comparisons) are required for types to be compatible
    with various STL algorithms.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了如何利用自定义类型上的运算符重载。这些重载（尤其是比较）对于类型与各种 STL 算法兼容是必需的。
- en: Simplifying tasks with assignment and compound assignment
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用赋值和复合赋值简化任务
- en: Overloading assignment (`=`) and compound assignment operators (`+=`, `-=`,
    `|=`, `>>=`, and many more) offer a straightforward method to modify instances
    of your custom type, eliminating the need for lengthier function calls.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重载赋值运算符（`=`）和复合赋值运算符（`+=`、`-=`、`|=`、`>>=` 以及更多）为修改您的自定义类型的实例提供了一种简单的方法，消除了需要更长的函数调用的需求。
- en: Stream operators for efficient I/O
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效 I/O 的流运算符
- en: I/O operations are central to most applications. Overloading the stream insertion
    (`<<`) and extraction (`>>`) operators enables custom types to work effortlessly
    with C++ streams, ensuring a uniform I/O interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 操作对于大多数应用程序来说至关重要。重载流插入运算符（`<<`）和提取运算符（`>>`）使得自定义类型可以轻松地与 C++ 流一起工作，确保了统一的
    I/O 接口。
- en: Operator precedence and associativity in overloading
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载中的运算符优先级和结合性
- en: When defining operator overloads, keeping the established precedence and associativity
    rules in C++ in mind is essential. This ensures that expressions involving your
    custom type are processed as expected.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义运算符重载时，牢记 C++ 中已建立的优先级和结合性规则是至关重要的。这确保了涉及您的自定义类型的表达式按预期处理。
- en: The role of operator overloading in C++
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 中运算符重载的作用
- en: Operator overloading enhances the integration of custom types in C++. It facilitates
    concise and intuitive operations, enabling custom types to work well with STL
    algorithms and containers. By using this feature thoughtfully, developers can
    create custom types that offer functionality and ease of use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符重载增强了自定义类型在 C++ 中的集成。它促进了简洁直观的操作，使得自定义类型能够很好地与 STL 算法和容器一起工作。通过深思熟虑地使用此功能，开发者可以创建提供功能和使用便利的自定义类型。
- en: In subsequent sections, we’ll look at the tools and practices that can optimize
    your C++ development experience, aiming to make application development effective
    and straightforward.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们将探讨可以优化您的 C++ 开发体验的工具和实践，旨在使应用程序开发既有效又简单。
- en: Creating custom hash functions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义哈希函数
- en: As we have seen, the STL offers a vast array of container classes such as `std::unordered_map`,
    `std::unordered_set`, and `std::unordered_multiset`, which rely heavily on hash
    functions for their efficient operation. When working with custom types, creating
    custom hash functions tailored to your data structures is imperative. In this
    section, we will learn about the significance of implementing custom hash functions,
    explore the characteristics of a good hash function, and provide an illustrative
    example of how to integrate a custom type with an STL container, using a custom
    hash function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，STL 提供了大量的容器类，如 `std::unordered_map`、`std::unordered_set` 和 `std::unordered_multiset`，它们在很大程度上依赖于哈希函数以实现高效操作。当与自定义类型一起工作时，创建针对您的数据结构定制的自定义哈希函数是必不可少的。在本节中，我们将了解实现自定义哈希函数的重要性，探讨良好哈希函数的特征，并提供一个示例，说明如何使用自定义哈希函数将自定义类型与
    STL 容器集成。
- en: Interoperability with STL containers
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 STL 容器的互操作性
- en: STL containers such as `std::unordered_map` or `std::unordered_set` use hash
    tables to store and retrieve elements efficiently. To make your custom types compatible
    with these containers, you need to provide a way for them to compute a hash value,
    which is used to determine the storage location of an element within the container.
    Without a custom hash function, the STL containers would not know how to hash
    your custom objects correctly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: STL 容器，如 `std::unordered_map` 或 `std::unordered_set`，使用哈希表来高效地存储和检索元素。为了使你的自定义类型与这些容器兼容，你需要提供一种方法，让它们能够计算哈希值，该值用于确定元素在容器中的存储位置。没有自定义哈希函数，STL
    容器将不知道如何正确地哈希你的自定义对象。
- en: 'By implementing custom hash functions, you ensure that your custom types can
    seamlessly interoperate with STL containers, providing the following benefits:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现自定义哈希函数，你可以确保你的自定义类型可以无缝地与 STL 容器交互，从而提供以下好处：
- en: '**Efficiency**: Custom hash functions can be optimized for your specific data
    structure, leading to faster access and retrieval times within STL containers.
    This optimization can significantly boost the overall performance of your application.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：自定义哈希函数可以针对你的特定数据结构进行优化，从而在 STL 容器中实现更快的访问和检索时间。这种优化可以显著提高应用程序的整体性能。'
- en: '**Consistency**: Custom hash functions enable hashing consistency for your
    custom types. Without them, different instances of the same custom type may yield
    different hash values, causing problems retrieving elements from containers.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：自定义哈希函数使你的自定义类型能够实现哈希一致性。没有它们，同一自定义类型的不同实例可能会产生不同的哈希值，导致从容器中检索元素时出现问题。'
- en: '**Correctness**: A well-designed custom hash function ensures that your custom
    types are correctly hashed, preventing collisions and maintaining the integrity
    of your data within the container.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确性**：一个设计良好的自定义哈希函数确保你的自定义类型被正确哈希，防止冲突并保持容器内数据的完整性。'
- en: Custom type semantics
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类型语义
- en: Custom types often have unique semantics and internal structures that require
    special handling when hashing. STL containers, by default, use the `std::hash`
    function provided by the standard library. This function may not adequately handle
    the intricacies of your custom type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型通常具有独特的语义和内部结构，在哈希时需要特殊处理。STL 容器默认使用标准库提供的 `std::hash` 函数。这个函数可能无法充分处理你的自定义类型的复杂性。
- en: By crafting your custom hash function, you can tailor the hashing process to
    the specific requirements of your data structure. For instance, you might want
    to consider the internal state of your custom type, selectively hash some members
    while excluding others, or even apply additional transformations to ensure an
    optimal distribution of elements in the container.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过精心设计你的自定义哈希函数，你可以根据数据结构的特定要求定制哈希过程。例如，你可能需要考虑自定义类型的内部状态，有选择地哈希某些成员而排除其他成员，或者甚至应用额外的转换以确保容器中元素的最佳分布。
- en: The characteristics of a good hash function
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好哈希函数的特征
- en: 'Adhering to specific characteristics that define a good hash function is essential
    when creating a custom hash function. A good hash function should possess the
    following properties:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义哈希函数时，遵循定义良好哈希函数的具体特征是至关重要的。一个良好的哈希函数应该具备以下属性：
- en: '**Deterministic**: A hash function should always produce the same value for
    the input. This property ensures that the elements are consistently placed in
    the same location within the container.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性**：哈希函数应该总是为输入产生相同的值。这个属性确保元素在容器内始终被放置在相同的位置。'
- en: '**Uniform distribution**: Ideally, a hash function should distribute values
    uniformly across the entire range of possible hash values. Uneven distribution
    can lead to performance issues, as some buckets may become overloaded while others
    remain underutilized.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均匀分布**：理想情况下，哈希函数应该在所有可能的哈希值范围内均匀分布值。不均匀的分布可能导致性能问题，因为某些桶可能过载，而其他桶则未被充分利用。'
- en: '**Minimal collisions**: Collisions occur when two different elements produce
    the same hash value. A good hash function minimizes collisions by ensuring that
    distinct inputs generate distinct hash values. This reduces the likelihood of
    performance degradation in STL containers.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化冲突**：当两个不同的元素产生相同的哈希值时，会发生冲突。一个良好的哈希函数通过确保不同的输入生成不同的哈希值来最小化冲突，这减少了 STL
    容器性能下降的可能性。'
- en: '**High efficiency**: Efficiency is crucial for hash functions, especially when
    dealing with large datasets. A good hash function should be computationally efficient,
    ensuring minimal overhead when computing hash values.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效率**：效率对于哈希函数至关重要，尤其是在处理大数据集时。一个好的哈希函数应该是计算效率高的，确保在计算哈希值时开销最小。'
- en: '**Mixes well**: A hash function should produce hash values that are well-mixed,
    meaning small changes in the input should result in significantly different hash
    values. This property helps maintain a balanced distribution of elements within
    the container.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合良好**：哈希函数应该产生混合良好的哈希值，这意味着输入的微小变化应该导致哈希值有显著的不同。这一特性有助于在容器内保持元素的平衡分布。'
- en: Example for the creation of a custom hash function
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义哈希函数创建示例
- en: 'Let’s illustrate the creation of a custom hash function with an example. Suppose
    we have a custom `Person` class with a name and age. We want to use `std::unordered_map`
    to store `Person` objects, and we need a custom hash function to achieve this.
    The following code is an implementation of such a hash function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来说明自定义哈希函数的创建。假设我们有一个具有姓名和年龄的自定义 `Person` 类。我们想使用 `std::unordered_map`
    来存储 `Person` 对象，并且我们需要一个自定义哈希函数来实现这一点。以下是一个此类哈希函数的实现代码：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we define the `Person` class with custom equality operators
    and a custom hash function, `PersonHash`. The `PersonHash` hash function combines
    the hash values of the `name` and `age` members, using XOR to ensure a well-mixed
    hash result. This custom hash function allows us to use `Person` objects as keys
    in `std::unordered_map`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个具有自定义等价运算符和自定义哈希函数 `PersonHash` 的 `Person` 类。`PersonHash` 哈希函数结合了
    `name` 和 `age` 成员的哈希值，使用 XOR 确保哈希结果混合良好。这个自定义哈希函数使我们能够将 `Person` 对象用作 `std::unordered_map`
    中的键。
- en: By implementing a custom hash function tailored to the specific needs of our
    custom type, we enable smooth integration with STL containers and ensure efficient,
    consistent, and correct operations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现针对我们自定义类型特定需求的自定义哈希函数，我们使 STL 容器与自定义类型的平滑集成成为可能，并确保高效、一致和正确的操作。
- en: In conclusion, custom hash functions are essential when working with custom
    types in STL containers. They facilitate efficient, consistent, and correct storage
    and retrieval of elements within these containers. Adhering to the characteristics
    of a good hash function and crafting one that suits your custom type’s semantics
    is crucial. The example we provided demonstrates how to create a custom hash function
    for a custom type and use it effectively with an STL container. This knowledge
    enables you to make the most of the C++ STL when dealing with your custom data
    structures.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当在 STL 容器中使用自定义类型时，自定义哈希函数是必不可少的。它们促进了这些容器中元素的高效、一致和正确的存储和检索。遵循良好哈希函数的特征并创建一个适合自定义类型语义的哈希函数至关重要。我们提供的示例演示了如何为自定义类型创建自定义哈希函数并有效地与
    STL 容器一起使用。这种知识使您能够充分利用 C++ STL 来处理自定义数据结构。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explored the fundamental aspects of creating STL-type containers
    in C++. We started by exploring the advantages of using STL-compatible types,
    emphasizing the benefits of consistency, reusability, and efficiency. These advantages
    lay the groundwork for a smoother and more efficient development process.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了在 C++ 中创建 STL 类型容器的根本方面。我们首先探讨了使用 STL 兼容类型的优势，强调了一致性、可重用性和效率的好处。这些优势为更顺畅和更高效的开发过程奠定了基础。
- en: Then, we discussed how to interact with STL algorithms, emphasizing the centrality
    of iterators in navigating and manipulating container elements. We highlighted
    the importance of adapting your custom types to algorithmic expectations, handling
    errors gracefully, and optimizing for algorithmic efficiency.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了如何与 STL 算法交互，强调了迭代器在导航和操作容器元素中的核心地位。我们强调了将自定义类型适应算法期望、优雅地处理错误以及优化算法效率的重要性。
- en: We also covered the essential requirements for compatibility, including the
    importance of iterators, value semantics, operational guarantees, size and capacity
    queries, and element access and manipulation. Understanding these concepts ensures
    your custom types seamlessly integrate with the STL.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了兼容性的基本要求，包括迭代器的重要性、值语义、操作保证、大小和容量查询以及元素访问和操作。理解这些概念确保您的自定义类型能够无缝地与 STL
    集成。
- en: Furthermore, we explored the process of crafting iterators for custom types
    and operator overloading. Finally, we touched upon creating custom hash functions,
    which is essential when your custom types are used in associative containers such
    as `std::unordered_map`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还探讨了为自定义类型创建迭代器以及操作符重载的过程。最后，我们简要介绍了创建自定义哈希函数，这在你的自定义类型被用于关联容器，如`std::unordered_map`时是必不可少的。
- en: The information presented in this chapter equips you with the foundational knowledge
    needed to create STL-compatible custom containers effectively. It allows you to
    harness the full power of the C++ STL in your projects, resulting in more efficient
    and maintainable code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的信息为你提供了创建与STL兼容的自定义容器所需的基础知识。它使你能够充分利用C++ STL在项目中的全部功能，从而实现更高效和可维护的代码。
- en: In the following chapter, we will explore the world of template functions, overloading,
    inline functions, and creating generic algorithms. You will better understand
    how to develop algorithmic solutions that seamlessly work with various custom
    container types. We will venture into the intricacies of function templates, SFINAE,
    overloading algorithms, and customization using predicates and functors. By the
    end of the chapter, you will be well-equipped to build your own STL-compatible
    algorithms and further enhance your C++ programming skills.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索模板函数、重载、内联函数以及创建泛型算法的世界。你将更好地理解如何开发与各种自定义容器类型无缝工作的算法解决方案。我们将深入探讨函数模板、SFINAE、算法重载以及使用谓词和仿函数进行定制。到本章结束时，你将具备构建自己的与STL兼容的算法以及进一步提升你的C++编程技能的充分准备。
