["```cpp\nclass APickupItem; //  forward declare the APickupItem class, \n                   // since it will be \"mentioned\" in a member  \n                    function decl below \nUCLASS() \nclass GOLDENEGG_API AAvatar : public ACharacter \n{ \n  GENERATED_BODY() \npublic: \n  // A map for the player's backpack \n  TMap<FString, int> Backpack; \n\n  // The icons for the items in the backpack, lookup by string \n  TMap<FString, UTexture2D*> Icons; \n\n  // A flag alerting us the UI is showing \n  bool inventoryShowing; \n  // member function for letting the avatar have an item \n  void Pickup( APickupItem *item ); \n  // ... rest of Avatar.h same as before \n}; \n```", "```cpp\nstruct Item   \n{   \n  FString name;   \n  int qty;   \n  UTexture2D*   tex;   \n};   \n```", "```cpp\nvoid ToggleInventory(); \n```", "```cpp\nvoid AAvatar::ToggleInventory() \n{ \n  if( GEngine ) \n  { \n    GEngine->AddOnScreenDebugMessage( -1, 5.f, FColor::Red,  \n     \"Showing inventory...\" ); \n  } \n} \n```", "```cpp\nvoid AAvatar::SetupPlayerInputComponent(class UInputComponent*  \n   InputComponent) \n{ \n Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    check(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"Inventory\", IE_Pressed, this,\n        &AAvatar::ToggleInventory);\n  // rest of SetupPlayerInputComponent same as before \n} \n```", "```cpp\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"PickupItem.generated.h\"\n\nUCLASS()\nclass GOLDENEGG_API APickupItem : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    // Sets default values for this actor's properties\n    APickupItem(const FObjectInitializer& ObjectInitializer);\n\n    // The name of the item you are getting \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)\n        FString Name;\n\n    // How much you are getting \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)\n        int32 Quantity;\n\n    // the sphere you collide with to pick item up \n    UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category = Item)\n        USphereComponent* ProxSphere;\n\n    // The mesh of the item \n    UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category = Item)\n        UStaticMeshComponent* Mesh;\n    // The icon that represents the object in UI/canvas \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item) \n        UTexture2D* Icon; \n    // When something comes inside ProxSphere, this function runs \n    UFUNCTION(BlueprintNativeEvent, Category = Collision) \n        void Prox(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n            int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n        virtual int Prox_Implementation(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n        int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n};\n```", "```cpp\nAPickupItem::APickupItem(const FObjectInitializer& ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n    Name = \"UNKNOWN ITEM\";\n    Quantity = 0;\n\n    // initialize the unreal objects \n    ProxSphere = ObjectInitializer.CreateDefaultSubobject<USphereComponent>(this,\n        TEXT(\"ProxSphere\"));  \n    Mesh = ObjectInitializer.CreateDefaultSubobject<UStaticMeshComponent>(this,\n            TEXT(\"Mesh\"));\n\n    // make the root object the Mesh \n    RootComponent = Mesh;\n    Mesh->SetSimulatePhysics(true);\n\n    // Code to make APickupItem::Prox() run when this \n    // object's proximity sphere overlaps another actor. \n    ProxSphere->OnComponentBeginOverlap.AddDynamic(this, &APickupItem::Prox);\n    ProxSphere->AttachToComponent(Mesh, FAttachmentTransformRules::KeepWorldTransform); // very important!              \n}\n```", "```cpp\n/** Collision primitive that defines the transform (location, rotation, scale) of this Actor. */\n    UPROPERTY(BlueprintGetter=K2_GetRootComponent, Category=\"Utilities|Transformation\")\n    USceneComponent* RootComponent;\n```", "```cpp\nint APickupItem::Prox_Implementation(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,\n    int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    // if the overlapped actor is NOT the player, \n    // you simply should return \n    if (Cast<AAvatar>(OtherActor) == nullptr)\n    {\n        return -1;\n    }\n\n    // Get a reference to the player avatar, to give him \n    // the item \n    AAvatar *avatar = Cast<AAvatar>(UGameplayStatics::GetPlayerPawn(GetWorld(), 0));\n\n    // Let the player pick up item \n    // Notice use of keyword this! \n    // That is how _this_ Pickup can refer to itself. \n    avatar->Pickup(this);\n\n    // Get a reference to the controller \n    APlayerController* PController = GetWorld()->GetFirstPlayerController();\n\n    // Get a reference to the HUD from the controller \n    AMyHUD* hud = Cast<AMyHUD>(PController->GetHUD());\n    hud->addMessage(Message(Icon, FString(\"Picked up \") + FString::FromInt(Quantity) + FString(\" \") + Name, 5.f, FColor::White)\n);\n\n    Destroy();\n\n    return 0;\n}\n```", "```cpp\n#include \"Avatar.h\"\n#include \"MyHUD.h\"\n#include \"Kismet/GameplayStatics.h\"\n```", "```cpp\nMessage(UTexture2D* img, FString iMessage, float iTime, FColor iColor)\n    {\n        tex = img;\n        message = iMessage;\n        time = iTime;\n        color = iColor;\n    }\n```", "```cpp\nAAvatar *avatar = Cast<AAvatar>( \n  UGameplayStatics::GetPlayerPawn( GetWorld(), 0 ) ); \n```", "```cpp\nAPlayerController* PController = \n  GetWorld()->GetFirstPlayerController(); \n```", "```cpp\nAMyHUD* hud = Cast<AMyHUD>( PController->GetHUD() ); \n```", "```cpp\nvoid AAvatar::Pickup(APickupItem *item)\n{\n    if (Backpack.Find(item->Name))\n    {\n        // the item was already in the pack.. increase qty of it \n        Backpack[item->Name] += item->Quantity;\n    }\n    else\n    {\n        // the item wasn't in the pack before, add it in now \n        Backpack.Add(item->Name, item->Quantity);\n        // record ref to the tex the first time it is picked up \n        Icons.Add(item->Name, item->Icon);\n    }\n}\n```", "```cpp\navatar->Pickup( this ); \n```", "```cpp\nstruct Icon \n{ \n  FString name; \n  UTexture2D* tex; \n  Icon(){ name = \"UNKNOWN ICON\"; tex = 0; } \n  Icon( FString& iName, UTexture2D* iTex ) \n  { \n    name = iName; \n    tex = iTex; \n  } \n}; \n\nstruct Widget \n{ \n  Icon icon; \n  FVector2D pos, size; \n  Widget(Icon iicon) \n  { \n    icon = iicon; \n  } \n  float left(){ return pos.X; } \n  float right(){ return pos.X + size.X; } \n  float top(){ return pos.Y; } \n  float bottom(){ return pos.Y + size.Y; } \n}; \n```", "```cpp\n    // New! An array of widgets for display \n    TArray<Widget> widgets;\n    //Hold screen dimensions\n    FVector2D dims;\n```", "```cpp\nvoid AMyHUD::DrawWidgets()\n{\n    for (int c = 0; c < widgets.Num(); c++)\n    {\n        DrawTexture(widgets[c].icon.tex, widgets[c].pos.X,\n            widgets[c].pos.Y, widgets[c].size.X, widgets[c].size.Y, 0, 0,\n            1, 1);    DrawText(widgets[c].icon.name, FLinearColor::Yellow,\n                widgets[c].pos.X, widgets[c].pos.Y, hudFont, .6f, false);\n    }\n}\n```", "```cpp\nvoid AMyHUD::DrawHUD()\n{\n    Super::DrawHUD();\n    // dims only exist here in stock variable Canvas \n    // Update them so use in addWidget() \n    const FVector2D ViewportSize = FVector2D(GEngine->GameViewport->Viewport->GetSizeXY());\n    dims.X = ViewportSize.X;\n    dims.Y = ViewportSize.Y;\n    DrawMessages();\n    DrawWidgets();\n}\n```", "```cpp\nvoid AAvatar::ToggleInventory()\n{\n    // Get the controller & hud \n    APlayerController* PController = GetWorld()->GetFirstPlayerController();\n    AMyHUD* hud = Cast<AMyHUD>(PController->GetHUD());\n\n    // If inventory is displayed, undisplay it. \n    if (inventoryShowing)\n    {\n        hud->clearWidgets();\n        inventoryShowing = false;\n        PController->bShowMouseCursor = false;\n        return;\n    }\n\n    // Otherwise, display the player's inventory \n    inventoryShowing = true;\n    PController->bShowMouseCursor = true;\n    for (TMap<FString, int>::TIterator it =\n        Backpack.CreateIterator(); it; ++it)\n    {\n        // Combine string name of the item, with qty eg Cow x 5 \n        FString fs = it->Key + FString::Printf(TEXT(\" x %d\"), it->Value);\n        UTexture2D* tex;\n        if (Icons.Find(it->Key))\n        {\n            tex = Icons[it->Key];\n            hud->addWidget(Widget(Icon(fs, tex)));\n        }    \n    }\n}\n```", "```cpp\nvoid AMyHUD::addWidget( Widget widget ) \n{ \n  // find the pos of the widget based on the grid. \n  // draw the icons.. \n  FVector2D start( 200, 200 ), pad( 12, 12 ); \n  widget.size = FVector2D( 100, 100 ); \n  widget.pos = start; \n  // compute the position here \n  for( int c = 0; c < widgets.Num(); c++ ) \n  { \n    // Move the position to the right a bit. \n    widget.pos.X += widget.size.X + pad.X; \n    // If there is no more room to the right then \n    // jump to the next line \n    if( widget.pos.X + widget.size.X > dims.X ) \n    { \n      widget.pos.X = start.X; \n      widget.pos.Y += widget.size.Y + pad.Y; \n    } \n  } \n  widgets.Add( widget ); \n} \n\nvoid AMyHUD::clearWidgets()\n{\n    widgets.Empty();\n}\n```", "```cpp\n    void clearWidgets();\n    void addWidget(Widget widget);\n```", "```cpp\nvoid AAvatar::Yaw( float amount ) \n{ \n  if( inventoryShowing ) \n  { \n    return; // when my inventory is showing, \n    // player can't move \n  } \n  AddControllerYawInput(200.f*amount * GetWorld()- \n   >GetDeltaSeconds()); \n} \n```", "```cpp\nstruct Widget \n{ \n  // .. rest of struct same as before .. \n  bool hit( FVector2D p ) \n  { \n    // +---+ top (0) \n    // |   | \n    // +---+ bottom (2) (bottom > top) \n    // L   R \n    return p.X > left() && p.X < right() && p.Y > top() && p.Y <  \n     bottom(); \n  } \n}; \n```", "```cpp\nvoid MouseClicked();\n```", "```cpp\nvoid AAvatar::MouseClicked() \n{ \n  APlayerController* PController = GetWorld()- \n   >GetFirstPlayerController(); \n  AMyHUD* hud = Cast<AMyHUD>( PController->GetHUD() ); \n  hud->MouseClicked(); \n} \n```", "```cpp\nPlayerInputComponent->BindAction( \"MouseClickedLMB\", IE_Pressed, this, &AAvatar::MouseClicked );\n```", "```cpp\n    Widget* heldWidget;  // hold the last touched Widget in memory \n\n    void MouseClicked();\n    void MouseMoved();\n```", "```cpp\nvoid AMyHUD::MouseClicked()\n{\n    FVector2D mouse;\n    APlayerController* PController = GetWorld()->GetFirstPlayerController();\n    PController->GetMousePosition(mouse.X, mouse.Y);\n    heldWidget = NULL; // clear handle on last held widget \n                       // go and see if mouse xy click pos hits any widgets \n    for (int c = 0; c < widgets.Num(); c++)\n    {\n        if (widgets[c].hit(mouse))\n        {\n            heldWidget = &widgets[c];// save widget \n            return;                  // stop checking \n        }\n    }\n}\n```", "```cpp\nvoid AMyHUD::MouseMoved()\n{\n    static FVector2D lastMouse;\n    FVector2D thisMouse, dMouse;\n    APlayerController* PController = GetWorld()->GetFirstPlayerController();\n    PController->GetMousePosition(thisMouse.X, thisMouse.Y);\n    dMouse = thisMouse - lastMouse;\n    // See if the left mouse has been held down for \n    // more than 0 seconds. if it has been held down, \n    // then the drag can commence. \n    float time = PController->GetInputKeyTimeDown(\n        EKeys::LeftMouseButton);\n    if (time > 0.f && heldWidget)\n    {\n        // the mouse is being held down. \n        // move the widget by displacement amt \n        heldWidget->pos.X += dMouse.X;\n        heldWidget->pos.Y += dMouse.Y; // y inverted \n    }\n    lastMouse = thisMouse;\n}\n```", "```cpp\nvoid AAvatar::Yaw( float amount ) \n{ \n  //x axis \n  if( inventoryShowing ) \n  { \n    // When the inventory is showing, \n    // pass the input to the HUD \n    APlayerController* PController = GetWorld()- \n     >GetFirstPlayerController(); \n    AMyHUD* hud = Cast<AMyHUD>( PController->GetHUD() ); \n    hud->MouseMoved(); \n    return; \n  } \n  else \n  { \n    AddControllerYawInput(200.f*amount * GetWorld()- \n     >GetDeltaSeconds()); \n  } \n} \n```"]