- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Streamlining CMake Configuration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精简CMake配置
- en: In this chapter, we’re going to take a step back from our project and address
    some of the day-to-day pain points of working with CMake. We’ll focus on smoothing
    off some of the rough edges of using CMake to make everyday development easier
    and discuss some tools and techniques to reduce manual effort. These approaches
    will also help users unaccustomed to your project get up to speed more quickly
    without having to know all the right configuration options to use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从项目中退一步，解决一些使用CMake时的日常痛点。我们将重点讨论如何消除使用CMake时的一些粗糙细节，以使日常开发更加轻松，并讨论一些工具和技术来减少手动操作。这些方法还将帮助不熟悉你的项目的用户更快上手，而无需知道所有正确的配置选项。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Reviewing how we use CMake
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾我们如何使用CMake
- en: Using scripts to avoid repetitive commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本避免重复命令
- en: Moving to CMake presets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向CMake预设
- en: Going further with CMake presets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步使用CMake预设
- en: A return to the CMake GUI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回CMake图形界面
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along, please ensure you have met the requirements outlined in [*Chapter
    1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*. These include the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上进度，请确保你已经满足[*第一章*](B21152_01.xhtml#_idTextAnchor019)《入门》的要求。包括以下内容：
- en: A Windows, Mac, or Linux machine with an up-to-date **operating** **system**
    (**OS**)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行最新**操作** **系统**（**OS**）的Windows、Mac或Linux机器
- en: A working C/C++ compiler (a system default is recommended for each platform
    if you don’t already have this)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的C/C++编译器（如果你还没有，建议使用每个平台的系统默认编译器）
- en: 'The code examples in this chapter can be found by following this link: [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以通过以下链接找到：[https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)。
- en: Reviewing how we use CMake
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾我们如何使用CMake
- en: Throughout the first part of this book, we intentionally focused on running
    all our CMake commands directly from the terminal. This is an excellent way to
    get familiar with CMake and understand how it works, but as you get more comfortable
    with CMake, having to repeatedly enter these commands over and over can become
    tiresome. It’s also easy to forget all the options to use, especially if your
    project starts adding several different configuration options, and if you have
    a demo or project you’d like to share, expecting unfamiliar users to type in longwinded
    commands that are easy to get wrong is a non-starter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，我们故意专注于直接从终端运行所有CMake命令。这是熟悉CMake并理解其工作原理的一个很好的方法，但随着你对CMake的熟悉，反复输入这些命令会变得让人厌烦。如果你的项目开始添加几个不同的配置选项，尤其是如果你有一个演示或项目希望分享，期待不熟悉的用户输入冗长且容易出错的命令是不可行的。
- en: The first possibility that might seem like a promising idea to start with is
    to set variables directly in your `CMakeLists.txt` file and prompt users to change
    values there. The main issue with this is it becomes a maintenance nightmare and
    makes it exceedingly difficult to support different build configurations at the
    same time. The more settings you can lift out of your `CMakeLists.txt` file the
    better, to allow more customization points for yourself and others to use in the
    future.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个看起来可能是一个有前景的想法是直接在你的`CMakeLists.txt`文件中设置变量，并提示用户在那里更改值。这样做的主要问题是它会变成维护噩梦，并且使得同时支持不同的构建配置变得极其困难。你能从`CMakeLists.txt`文件中提取的设置越多越好，这样可以为自己和其他人将来使用时提供更多的自定义点。
- en: If we’re better off keeping settings outside of our `CMakeLists.txt` file, then
    we need users to pass them at the command line by using the familiar `-D<variable>=<value>`
    format. The flexibility this provides is great, but if users must provide multiple
    variables every time they configure, it can get confusing and error-prone.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们最好将设置保存在`CMakeLists.txt`文件之外，那么我们需要用户通过熟悉的`-D<variable>=<value>`格式在命令行上传递它们。这种灵活性非常好，但如果用户每次配置时都必须提供多个变量，可能会变得混乱且容易出错。
- en: 'For example, if we take our *Game of Life* project, we already have quite a
    few options to pass at the command line, some of our own making and some provided
    by CMake. A normal command might look like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们拿我们的*生命游戏*项目来举例，我们已经有了相当多的选项可以在命令行传递，其中一些是我们自己设置的，有些是CMake提供的。一个正常的命令可能如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we’d decided to use the Ninja single-config generator and explicitly set
    the build type, it would look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定使用 Ninja 单配置生成器并显式设置构建类型，它看起来会是这样的：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This already can start to look like a lot of typing, and it’s only going to
    get worse from here. Yes, you only need to type this once to get up and running,
    but it can be painful for people new to the team/project and tedious for even
    experienced developers when checking out the code in a new workspace or platform.
    So, what alternatives are there?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经开始看起来像是大量的输入，而且从这里开始只会变得更糟。是的，你只需要输入一次这些内容来启动并运行，但对于新加入团队/项目的人来说，这可能是痛苦的，甚至对于经验丰富的开发者，在新工作空间或平台上检查代码时也会感到乏味。那么，有什么替代方案呢？
- en: Using scripts to avoid repetitive commands
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本避免重复的命令
- en: 'A perfectly valid choice to start with is to introduce simple shell or batch
    scripts on your platform of choice to encapsulate common CMake commands. For example,
    on macOS, we could create a script called `configure-default.sh` that acts as
    an opinionated default for users to use initially and that fits with our day-to-day
    usage. On macOS/Linux, this might look like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始一个完全有效的选择是，在你选择的平台上引入简单的 shell 或批处理脚本，以封装常用的 CMake 命令。例如，在 macOS 上，我们可以创建一个名为
    `configure-default.sh` 的脚本，它作为用户初始使用的有主张的默认配置，并且符合我们的日常使用。在 macOS/Linux 上，这可能看起来像下面这样：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create and make this file executable, we can run the following command from
    the terminal:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并使这个文件可执行，我们可以从终端运行以下命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On Windows, we can either rely on users using Git Bash (so that they can execute
    the `.sh` script) or create a corresponding `.``bat` file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们可以依赖用户使用 Git Bash（这样他们就可以执行 `.sh` 脚本），或者创建相应的 `.bat` 文件：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To provide more flexibility, it can also be helpful to provide several scripts
    and name them according to their settings; for example, the type of generator
    (for example, `configure-ninja.sh`, `configure-vs-2022.bat`, `configure-xcode.sh`,
    and so on) or the type of library we’re building, be that static or shared (for
    example, `configure-shared-ninja.sh`, `configure-static-vs-2022.bat`, and so on).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更多灵活性，提供几个脚本并根据它们的设置命名也会很有帮助；例如，生成器的类型（例如，`configure-ninja.sh`、`configure-vs-2022.bat`、`configure-xcode.sh`
    等）或我们构建的库的类型，无论是静态库还是共享库（例如，`configure-shared-ninja.sh`、`configure-static-vs-2022.bat`
    等）。
- en: As well as speeding up daily development, the other advantage to creating these
    scripts is to act as a form of documentation for users to see how to configure
    and tweak your application or library without having to go hunting through the
    `CMakeLists.txt` file at the outset. This again smooths the learning curve and
    allows new developers to iterate on these commands themselves from the terminal.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加速日常开发外，创建这些脚本的另一个优点是可以作为一种文档形式，帮助用户了解如何配置和调整你的应用程序或库，而不必一开始就去翻找`CMakeLists.txt`文件。这再次平滑了学习曲线，并允许新开发者从终端自行迭代这些命令。
- en: A useful feature within Git is the ability to create custom `.gitignore` rules
    in your repo. These can be added to `.git/info/exclude`, so it may be worth recommending
    users create a copy of one of the existing configure scripts, rename it to `configure-<username>.sh/bat`,
    and then add it to their `.``git/info/exclude` file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Git 中的一个有用功能是能够在你的仓库中创建自定义的 `.gitignore` 规则。这些可以添加到 `.git/info/exclude` 文件中，因此值得建议用户复制现有的配置脚本，将其重命名为
    `configure-<username>.sh/bat`，然后将其添加到 `.git/info/exclude` 文件中。
- en: 'Up until now, we’ve only focused on the configuring stage of CMake as the first
    configure command tends to have the most options. Combining our configure scripts
    with a build command can also be helpful to have a user be able to configure and
    build the application all at once. A `configure-build.sh/bat` file could look
    like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们只关注了 CMake 配置阶段，因为第一次配置命令通常有最多的选项。将我们的配置脚本与构建命令结合使用也很有帮助，这样用户就可以一次性配置并构建应用程序。一个
    `configure-build.sh/bat` 文件可能看起来像这样：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Even better would be to keep the configure logic separate and then call it
    from the `configure-build` script. This can be achieved with the following on
    macOS/Linux:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的做法是将配置逻辑分开，然后从 `configure-build` 脚本中调用它。这可以通过在 macOS/Linux 上执行以下操作来实现：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On Windows, this can be achieved with the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，可以通过以下方式实现：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To try out these scripts, see `ch5/part-1/app` from the book’s accompanying
    repository.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这些脚本，请参见书籍附带仓库中的`ch5/part-1/app`。
- en: If you’re using a single-config generator, specifying your own subfolders for
    each build type can be convenient (though in practice, the functionality provided
    by multi-config generators is excellent and conveniently handles this complexity
    for you).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是单配置生成器，为每种构建类型指定自己的子文件夹可能会很方便（尽管实际上，多配置生成器提供的功能非常优秀，能便捷地为你处理这些复杂性）。
- en: It would also be possible to include a call to run the application if you so
    wished, though this will depend on the kind of application you’re building and
    shouldn’t be necessary if clear instructions are provided in the `README` or `CMakeLists.txt`
    file for where the output files are found. The working directory (where you run
    the application from) can be important here, so keep this in mind if loading other
    resources (we’ll cover how to handle this in [*Chapter 10*](B21152_10.xhtml#_idTextAnchor214)*,
    Packaging the Project* *for Sharing*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，也可以包含一个调用来运行应用程序，尽管这取决于你正在构建的应用程序类型，并且如果在 `README` 或 `CMakeLists.txt`
    文件中提供了关于输出文件所在位置的清晰指示，则不应有必要。工作目录（你从中运行应用程序的目录）在这里可能很重要，所以如果加载其他资源时，请记住这一点（我们将在
    [*第10章*](B21152_10.xhtml#_idTextAnchor214)*，打包项目* *以供共享* 中介绍如何处理这个问题）。
- en: Having a few of these scripts can be helpful for you, and any users or maintainers
    looking to check out or contribute to your project, but maintenance can become
    a pain. Having to support separate `.bat` and `.sh` scripts if you’re building
    a multiplatform project is also frustrating. The other downside is these scripts
    need to be run from the terminal where they’re located. Attempting to run them
    from the OS file explorer will most likely not work, as the working directory
    is usually set to the user’s home directory `(~/` on macOS/Linux and `C:\Users\<username>`
    on Windows).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些脚本对你以及任何希望查看或贡献你项目的用户或维护者来说可能是有帮助的，但维护起来可能会变得很麻烦。如果你正在构建一个跨平台项目，支持单独的 `.bat`
    和 `.sh` 脚本也会让人感到沮丧。另一个缺点是，这些脚本需要从它们所在的终端运行。试图从操作系统文件浏览器中运行它们可能不起作用，因为工作目录通常会被设置为用户的主目录（在
    macOS/Linux 上是`~/`，在 Windows 上是 `C:\Users\<username>`）。
- en: Script GUI support
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本图形用户界面支持
- en: If you’re determined, it is possible to set the working directory to where the
    file is found. On macOS and Linux, this can be achieved by adding `cd "$(dirname
    "$0")"` to the start of the `.sh` file (`$0` expands to the name of the file,
    and `dirname` gives the folder containing it), and on Windows you can add `cd
    /d "%~dp0"` to the beginning of the `.bat` file (`%~dp0` is a batch variable that
    expands to the drive and path of the file). You’ll have to remember to update
    your path in certain cases depending on where CMake is installed (for example,
    if CMake is not installed in a default system location on Linux), and you may
    also want to consider renaming the `.sh` file to `.command` on macOS to make it
    easily runnable from *Finder*. Due to the extra complexity, we’ll stick to just
    running from the terminal for the remainder of the book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你下定决心，可以将工作目录设置为文件所在的位置。在 macOS 和 Linux 上，可以通过在 `.sh` 文件开头添加 `cd "$(dirname
    "$0")"` 来实现（`$0` 展开为文件名，`dirname` 给出包含它的文件夹），在 Windows 上，可以在 `.bat` 文件的开头添加 `cd
    /d "%~dp0"`（`%~dp0` 是一个批处理变量，展开为文件的驱动器和路径）。你需要记住根据 CMake 安装位置的不同，在某些情况下更新路径（例如，如果
    CMake 没有安装在 Linux 的默认系统位置），你还可能希望在 macOS 上将 `.sh` 文件重命名为 `.command`，以便可以轻松地从 *Finder*
    中运行。由于额外的复杂性，接下来的部分我们将仅从终端运行。
- en: Luckily, there’s a relatively new CMake feature that mostly (though not entirely)
    removes the need for `.bat` and `.sh` scripts called CMake presets (available
    from CMake `3.19` onward), which we’ll cover in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，CMake 有一个相对较新的功能，它在很大程度上（尽管不是完全）消除了对 `.bat` 和 `.sh` 脚本的需求，这个功能叫做 CMake
    预设（从 CMake `3.19` 版本开始提供），我们将在下一节中介绍。
- en: Moving to CMake presets
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向 CMake 预设
- en: '`.sh` and `.bat` files but provide tighter integration with CMake, and can
    be used with other tools such as Visual Studio Code, Visual Studio, and CLion
    (a cross-platform C/C++ development environment).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sh` 和 `.bat` 文件可以与 CMake 紧密集成，并可以与其他工具如 Visual Studio Code、Visual Studio
    和 CLion（一个跨平台的 C/C++ 开发环境）一起使用。'
- en: To get started with CMake presets, we need to create a file called `CMakePresets.json`
    at the root of our project. CMake presets are simply a `{}`) as the root. A `CMakePresets.json`
    file has multiple sections for each stage of a CMake build (configure, build,
    test, package, and more). To begin with, we’ll focus on the configure and build
    portions, but we will return to our `CMakePresets.json` file in later chapters
    as the project continues to mature.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 CMake 预设，我们需要在项目根目录下创建一个名为 `CMakePresets.json` 的文件。CMake 预设仅是一个以 `{}`
    作为根的文件。`CMakePresets.json` 文件有多个部分，涵盖 CMake 构建的各个阶段（配置、构建、测试、打包等）。一开始，我们将专注于配置和构建部分，但随着项目的不断发展，我们将在后续章节中再次回到
    `CMakePresets.json` 文件。
- en: Authoring CMake preset files
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 CMake 预设文件
- en: Authoring CMake preset files can sometimes be a challenge due to their use of
    JSON. To make life easier, it is highly recommended to use a text editor with
    built-in syntax support for JSON (Visual Studio Code is a notable example). This
    way, if you’re missing a quotation mark or closing brace, you’ll get immediate
    feedback in the editor in the form of a red or yellow underline highlighting the
    problem. Running `cmake --preset <preset>` with an invalid `CMakePreset.json`
    file will output a `JSON Parse Error` error with a column and line number, but
    the visual editor feedback will let you know there’s a problem as you’re typing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 CMake 预设文件有时会因其使用 JSON 而变得具有挑战性。为了简化工作，强烈建议使用内置 JSON 语法支持的文本编辑器（Visual Studio
    Code 是一个显著的例子）。这样，如果你缺少引号或闭括号，编辑器会立即给出反馈，用红色或黄色下划线标出问题。运行 `cmake --preset <preset>`
    时，如果 `CMakePreset.json` 文件无效，将输出 `JSON Parse Error` 错误，并附上列和行号，但通过视觉编辑器的反馈，你在输入时就能知道存在问题。
- en: 'Let’s review a minimal `CMakePresets.json` file for our project:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下一个最小化的 `CMakePresets.json` 文件：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After the opening JSON object brace, we must first provide a number showing
    the version of the schema (at the time of writing, `8` is the latest version and
    is available from CMake `3.28` and above). If you consult the CMake documentation
    about presets (see [https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html](https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html)),
    features are usually associated with a given schema version.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的 JSON 对象大括号后，我们必须首先提供一个数字，表示模式的版本（截至目前，`8` 是最新版本，并且适用于 CMake `3.28` 及以上版本）。如果你查阅
    CMake 关于预设的文档（参见 [https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html](https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html)），功能通常与特定的模式版本相关联。
- en: The next key is `configurePresets`, which maps to an array of values for different
    configurations (this is like how we could have one or more `.bat` or `.sh` scripts
    offering different configuration options). We have just one provided for now,
    but it’s trivial to add more in the future. The first key for the object is the
    `name` field; this is the only required field, and other keys are optional (there
    are many more we’ve omitted for brevity).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个键是 `configurePresets`，它映射到不同配置的值数组（这就像我们可能有一个或多个 `.bat` 或 `.sh` 脚本，提供不同的配置选项）。目前我们只提供了一个，但将来添加更多非常简单。该对象的第一个键是
    `name` 字段；这是唯一必需的字段，其他键是可选的（为了简洁起见，我们省略了更多字段）。
- en: 'Walking through the set of options, we can see how each corresponds to what
    we would have originally used at the command line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历一组选项，我们可以看到每个选项如何对应于我们原本在命令行中使用的内容：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this preset added, we can run `cmake --list-presets` from our root directory
    to see a list of available presets:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此预设后，我们可以从根目录运行 `cmake --list-presets` 来查看可用预设的列表：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we want to be a bit friendlier to our users, we can provide a `displayName`
    field like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望对用户更加友好，可以像这样提供一个 `displayName` 字段：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running `cmake --list-presets` will display the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `cmake --list-presets` 将显示以下内容：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s also possible to provide a description (with the `description` field);
    however, this is not displayed from the command line or the CMake GUI. The description
    may be displayed in other tools; for example, Visual Studio Code chooses to display
    it when a CMake preset is present when selecting **CMake: Configure** from the
    *Command Palette*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '也可以提供描述（使用 `description` 字段）；不过，这不会在命令行或 CMake GUI 中显示。描述可能会在其他工具中显示；例如，当选择
    **CMake: Configure** 时，Visual Studio Code 选择显示它，在 *命令面板* 中显示：'
- en: '![Figure 5.1: Visual Studio Code CMake preset description](img/B21152_05_1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：Visual Studio Code CMake 预设描述](img/B21152_05_1.jpg)'
- en: 'Figure 5.1: Visual Studio Code CMake preset description'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：Visual Studio Code CMake 预设描述
- en: 'Its presence serves as documentation for those using the preset and so may
    be worth including based on the context. With our configuration preset added,
    simply run `cmake --preset default` from your root directory to have CMake configure
    your project with the settings provided. The command will output the CMake variables
    that have been provided, along with their corresponding values, and then the familiar
    configuration output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它的存在为使用该预设的用户提供了文档，因此根据上下文可能值得包括此信息。添加配置预设后，只需从根目录运行 `cmake --preset default`，即可让
    CMake 使用提供的设置配置项目。该命令将输出已提供的 CMake 变量及其对应的值，随后是常见的配置输出：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To see a working example of this, review `ch5/part-2/app/CMakePresets.json`
    from the book’s accompanying repository.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看此功能的实际示例，请查看书籍随附的代码库中的`ch5/part-2/app/CMakePresets.json`。
- en: We’ve covered adding a single CMake preset, which can be useful to add default
    structured configuration options to our project, but there’s a lot more CMake
    presets can do.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了添加单个 CMake 预设的方法，这对于将默认结构化配置选项添加到项目中非常有用，但 CMake 预设的功能远不止于此。
- en: Going further with CMake presets
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 CMake 预设
- en: If we want to get a little more advanced and provide more flexibility for our
    users, there are some other fields provided by `CMakePresets.json` that are good
    to know about. The first is `inherits`, which allows one preset to inherit the
    values of another. A small selection of keys/values are not inherited (including
    `name`, `displayName`, `description`, and `inherits` itself), but nearly everything
    else is. The next field is `hidden`; this allows a preset to be defined but stops
    it from being displayed to an end user when running `cmake --list-presets`. This
    is convenient for defining base or common types that can then be inherited by
    more bespoke or concrete types that only then need to provide a small number of
    custom fields.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望更进一步，为用户提供更多灵活性，`CMakePresets.json` 还提供了一些其他字段，值得了解。第一个字段是 `inherits`，它允许一个预设继承另一个预设的值。某些键/值对不会被继承（包括
    `name`、`displayName`、`description` 和 `inherits` 本身），但几乎所有其他内容都会被继承。下一个字段是 `hidden`；它允许定义一个预设，但阻止其在运行
    `cmake --list-presets` 时显示给最终用户。这对于定义基本或通用类型非常方便，这些类型可以继承更多具体类型，然后只需提供少量自定义字段。
- en: 'As an example, taking our *Game of Life* project, we could define a CMake preset
    file like so:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，假设我们的 *生命游戏* 项目，我们可以像下面这样定义一个 CMake 预设文件：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It starts with a configuration preset called `base`, which has the `hidden`
    field set to `true`. There, we define a binary directory based on any later preset
    name:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它以一个名为 `base` 的配置预设开始，其中 `hidden` 字段被设置为 `true`。在那里，我们根据任何后续预设名称定义了一个二进制目录：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `${sourceDir}` and `${presetName}` names are called *macros* and expand
    to meaningful values based on the project context (`${sourceDir}` expands to the
    project root directory, for example). In this case, we also provide our preferred
    generator: `"generator": "``Ninja Multi-Config"`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`${sourceDir}` 和 `${presetName}` 被称为 *宏*，它们根据项目上下文展开为有意义的值（例如，`${sourceDir}`
    会展开为项目根目录）。在这种情况下，我们还提供了我们首选的生成器：“`generator`："`Ninja Multi-Config"。'
- en: Normally, providing a specific generator in the base preset is not advised (especially
    as not all clients may have Ninja installed); it’s instead simpler to rely on
    the default generator for the specific platform and provide specific generator
    overrides as later options. In our case we've opted to stick with the Ninja multi-config
    generator throughout to keep things consistent across macOS, Windows, and Linux
    throughout the book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不建议在基础预设中提供特定的生成器（特别是因为并非所有客户端都安装了 Ninja）；相反，更简单的做法是依赖于特定平台的默认生成器，并将特定的生成器覆盖项作为后续选项提供。在我们的案例中，我们选择始终使用
    Ninja 多配置生成器，以保持在 macOS、Windows 和 Linux 上的一致性。
- en: The two following configurations then use `inherits` to essentially copy the
    value of `binaryDir` and `generator` into themselves, without having to duplicate
    the lines of code. We give each a unique name (`shared` and `static`) and specify
    the `MC_GOL_SHARED` CMake option to either `ON` or `OFF` respectively. Users can
    then call `cmake --preset static` or `cmake --preset shared` to configure the
    *Game of Life* console application to use either the static or shared version
    of the library.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的两个配置使用 `inherits`，基本上将 `binaryDir` 和 `generator` 的值复制到它们自己中，而无需重复代码行。我们为每个配置提供了一个唯一的名称（`shared`
    和 `static`），并分别指定了 `MC_GOL_SHARED` CMake 选项为 `ON` 或 `OFF`。然后，用户可以通过 `cmake --preset
    static` 或 `cmake --preset shared` 来配置 *生命游戏* 控制台应用程序，以使用库的静态或共享版本。
- en: Helpfully, macros are resolved in the context of the preset being used, which
    means in the preceding example, when `base` is inherited in either `static` or
    `shared`, the `${presetName}` variable will be substituted with `static` or `shared`
    accordingly. This means we wind up with two build folders, `<project-root>/build/shared`
    and `<project-root>/build/static`, that won’t overwrite each other.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有帮助的是，宏会在所使用的预设的上下文中解析，这意味着在前面的示例中，当 `base` 被继承到 `static` 或 `shared` 时，`${presetName}`
    变量会被分别替换为 `static` 或 `shared`。这意味着我们最终会得到两个构建文件夹，`<project-root>/build/shared`
    和 `<project-root>/build/static`，它们不会互相覆盖。
- en: 'If we run `cmake --list-presets`, we’ll see the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行 `cmake --list-presets`，我们会看到以下内容：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we then run both `cmake --preset shared` and `cmake --preset static`, we’ll
    see this folder structure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们接着运行 `cmake --preset shared` 和 `cmake --preset static`，我们会看到以下文件夹结构：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For a full example of the preceding code, see `ch5/part-3/app/CMakePresets.json`
    from the book’s accompanying repository.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前述代码的完整示例，请参见书籍随附仓库中的 `ch5/part-3/app/CMakePresets.json`。
- en: CMake preset overrides
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMake 预设覆盖
- en: 'One very handy property of CMake presets is they compose nicely with CMake
    command-line arguments. Suppose in the preceding example, we’d like to use the
    `shared` CMake preset, but would rather use a different generator from Ninja Multi-Config.
    To do this, we simply pass a different generator at the command line, and CMake
    will override the value in the CMake preset:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 预设的一个非常方便的特性是它们与 CMake 命令行参数很好地组合。假设在前面的示例中，我们想使用 `shared` CMake 预设，但更愿意使用与
    Ninja 多配置不同的生成器。为此，我们只需在命令行中传递一个不同的生成器，CMake 会覆盖 CMake 预设中的值：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code will use all the values from the preset, except the generator,
    instead preferring Xcode in this case. It’s possible to override more than one
    value, so a potentially even better choice might be the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码会使用预设中的所有值，除了生成器，在此案例中，它会优先选择 Xcode。我们也可以覆盖多个值，因此一个可能更好的选择可能是以下内容：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The new `xcode-shared` build folder then won’t conflict with the already defined
    `build/static` and `build/shared` folders if we decide to revert to the Ninja
    Multi-Config generator in the future (we will have to remember to pass this folder
    explicitly if using a build preset, introduced in the next section, so adding
    Xcode as a configure preset longer-term likely isn’t a bad idea). It’s also worth
    briefly mentioning Xcode is also a multi-config generator, so it’s not necessary
    for us to provide a build type at configure time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `xcode-shared` 构建文件夹在将来如果我们决定恢复使用 Ninja 多配置生成器时，就不会与已定义的 `build/static` 和
    `build/shared` 文件夹发生冲突（如果使用构建预设，需要显式地传递此文件夹，下一节会介绍这一点，所以从长远来看，将 Xcode 作为配置预设是个不错的选择）。还值得简要提到，Xcode
    也是一个多配置生成器，因此在配置时不需要为我们指定构建类型。
- en: Having the flexibility to try out different options quickly is great, but we’re
    back to the same problem again of typing long commands into the terminal. Fortunately,
    there’s a particularly useful feature within CMake presets we can lean on called
    CMake user presets.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有快速尝试不同选项的灵活性是非常棒的，但我们又回到了在终端中输入长命令的老问题。幸运的是，CMake 预设中有一个特别有用的功能，可以帮助我们，那就是
    CMake 用户预设。
- en: '`CMakeUserPresets.json` file (as opposed to the shared `CMakePresets.json`
    file). `CMakePresets.json` is implicitly included in `CMakeUserPresets.json`,
    so existing presets can be inherited from there, as we did earlier.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakeUserPresets.json` 文件（与共享的 `CMakePresets.json` 文件相对）。`CMakePresets.json`
    会隐式包含在 `CMakeUserPresets.json` 中，因此可以从那里继承现有的预设，就像我们之前所做的那样。'
- en: 'To add a custom preset that uses a generator of our choosing (in this case,
    Xcode), we just add the following to `CMakeUserPresets.json`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个自定义预设，使用我们选择的生成器（在此案例中为 Xcode），我们只需将以下内容添加到 `CMakeUserPresets.json` 中：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can then run `cmake --preset xcode-static` to configure our project using
    CMake, and because of the way we specified `binaryDir` in the `base` preset, our
    build files will be created in `build/xcode-static` automatically.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以运行 `cmake --preset xcode-static` 来配置我们的项目，使用 CMake，并且由于我们在 `base` 预设中指定了
    `binaryDir`，我们的构建文件会自动创建在 `build/xcode-static` 中。
- en: It’s important to note that while `CMakePresets.json` is intended to be shared
    by multiple developers and checked into in source control, `CMakeUserPresets.json`
    is not. It is intended purely for local development and should be added to your
    `.gitignore` file or equivalent to avoid leaving your machine (in the *Minimal
    CMake* repo, `CMakeUserPresets.json` is already added to the `.``gitignore` file).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，虽然 `CMakePresets.json` 旨在供多个开发者共享并提交到源代码管理中，但 `CMakeUserPresets.json`
    并不是。它纯粹用于本地开发，应当添加到你的 `.gitignore` 文件或等效文件中，以避免将其从你的机器中上传（在 *Minimal CMake* 仓库中，`CMakeUserPresets.json`
    已经被添加到 `.gitignore` 文件中）。
- en: 'Another useful feature available to CMake presets is the `condition` field.
    This is used to decide if a preset should be enabled or not. In the preceding
    example where we specified Xcode, that generator is only useful on macOS, so we
    could update our preset to include these lines:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 预设中另一个有用的功能是 `condition` 字段。它用于决定一个预设是否应该启用。在前面的例子中，我们指定了 Xcode，该生成器仅在
    macOS 上有效，因此我们可以更新我们的预设，包含以下几行：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The name `Darwin` is how CMake identifies macOS. For more information about
    how CMake determines the OS it is running on, see [https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Darwin` 是 CMake 用来识别 macOS 的方式。有关 CMake 如何确定其运行的操作系统的更多信息，请参见 [https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html](https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html)。'
- en: 'The preceding code ensures when we run `cmake --list-presets`, we won’t see
    `xcode-static` on any platform other than macOS. If we try to run `cmake --preset
    xcode-static`, we’ll get this error message:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码确保当我们运行 `cmake --list-presets` 时，在 macOS 以外的平台上不会看到 `xcode-static`。如果我们尝试运行
    `cmake --preset xcode-static`，我们会得到以下错误信息：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The condition check is most useful in the regular `CMakePresets.json` file to
    ensure developers aren’t presented with unnecessary options when running `cmake
    --list-presets`, depending on the platform they’re using.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition` 检查在常规的 `CMakePresets.json` 文件中最为有用，以确保开发人员在运行 `cmake --list-presets`
    时，根据所使用的平台不会看到不必要的选项。'
- en: An example has been included in the book’s repository. It can be found by navigating
    to `ch5/part3/app` and looking at `CMakeUserPresets.json.example`. To experiment
    with the preset, simply rename the file by removing the `.``example` postfix.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例已包含在本书的仓库中。可以通过导航到 `ch5/part3/app` 并查看 `CMakeUserPresets.json.example` 来找到它。要尝试该预设，只需将文件重命名，去掉
    `.example` 后缀即可。
- en: Other kinds of CMake presets
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类型的 CMake 预设
- en: Everything we’ve covered so far about CMake presets has focused primarily on
    CMake configuration (using `configurePresets`). Configuration presets tend to
    be the most used, and we’ve only scratched the surface of what settings are available.
    Before we move on, it’s useful to look at the other kinds of presets. These include
    build, test, package, and workflow presets. For now, we’ll only cover build and
    workflow presets, but we’ll continue to return to presets in the future as we
    introduce tests and packaging to our application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关于 CMake 预设所涵盖的内容主要集中在 CMake 配置（使用 `configurePresets`）上。配置预设通常是最常用的，我们只是触及了可用设置的表面。在我们继续之前，看看其他类型的预设是有用的。这些预设包括构建、测试、打包和工作流预设。现在，我们只介绍构建和工作流预设，但随着我们将测试和打包引入到应用程序中，我们将继续回到预设。
- en: '`buildPresets` field. They can be displayed by calling `cmake --build --list-presets`
    and are also visible in certain tools (for example, in the CMake Tools plugin
    for Visual Studio Code, which we’ll cover in [*Chapter 11*](B21152_11.xhtml#_idTextAnchor228),
    *Supporting Tools and Next Steps*). Build presets aren’t quite as impactful to
    everyday development as configure presets, but they have their uses. In our simplified
    example, we show how `buildPresets` might be configured:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildPresets` 字段。它们可以通过调用 `cmake --build --list-presets` 来显示，并且在某些工具中也可见（例如，在
    Visual Studio Code 的 CMake Tools 插件中，我们将在[*第 11 章*](B21152_11.xhtml#_idTextAnchor228)，*支持工具和下一步*中介绍）。构建预设不像配置预设那样对日常开发有如此大的影响，但它们也有自己的用途。在我们简化的示例中，我们展示了
    `buildPresets` 可能如何配置：'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There tends to be less that can be easily shared across build presets, so we’ll
    omit a hidden base build preset for now. Each build preset must map to exactly
    one `configurePreset`; we’ve therefore mapped a configure preset to each build
    preset that corresponds to the version of our application using either the static
    or shared version of the *Game of Life* library. There is another field we can
    add called `configuration`, which is equivalent to passing `--config` from the
    command line when invoking CMake. This would look like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构建预设之间可以共享的内容通常较少，因此我们暂时省略了一个隐藏的基础构建预设。每个构建预设必须映射到一个`configurePreset`；因此，我们将每个构建预设映射到一个配置预设，该配置预设对应我们应用程序的版本，使用的是静态或共享版本的*生命游戏*库。我们还可以添加另一个字段，称为`configuration`，它相当于从命令行调用CMake时传递的`--config`。这看起来像如下所示：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: One issue with this is we’d then need `shared-debug`, `shared-release`, `static-debug`,
    `static-release`, and so on. This might be necessary and can come in handy when
    we begin implementing things such as **continuous integration**(**CI**) build
    scripts in the future, but for now, it’s probably overkill (it’s worth mentioning
    discussions around how to avoid the combinatorial explosion of build presets is
    an open area of investigation for Kitware, the maintainers of CMake).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的问题是，我们需要`shared-debug`、`shared-release`、`static-debug`、`static-release`等等。这可能是必要的，当我们开始实现如**持续集成**（**CI**）构建脚本时，它也会派上用场，但现在来看可能有些过头（值得一提的是，如何避免构建预设的组合爆炸是CMake维护者Kitware正在研究的一个开放问题）。
- en: 'To invoke a build preset, we run `cmake --build --preset <build-preset-name>`
    (after first running `cmake --preset <configure-preset-name>`), as in the following
    example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用一个构建预设，我们运行`cmake --build --preset <build-preset-name>`（首先运行`cmake --preset
    <configure-preset-name>`），如以下示例所示：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A quick reminder that in this context, it’s possible to also specify the configuration
    with `--config` without needing all config variations in the `CMakePresets.json`
    file, which can be useful for local development. Here’s an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 提个小提醒，在此上下文中，也可以通过`--config`来指定配置，而无需在`CMakePresets.json`文件中包含所有配置变体，这对于本地开发非常有用。以下是一个示例：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The last handy preset we’ll mention for now is the workflow preset. **Workflow
    presets** allow you to chain together presets to run one after another, allowing
    you to potentially configure, build, test, and package all with one command. The
    configure preset must come first, and then any later presets can run (right now,
    we just have a build preset, but we might want to expand this in the future).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在提到的最后一个有用的预设是工作流预设。**工作流预设**允许你将多个预设串联在一起，依次运行，允许你用一个命令潜在地配置、构建、测试和打包。配置预设必须先执行，然后可以运行后续的任何预设（目前，我们只有一个构建预设，但将来可能希望扩展这一点）。
- en: 'Workflow presets take the following form:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流预设采取以下形式：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'They can be invoked with `cmake --workflow --preset <workflow-preset-name>`.
    In our case, we run the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以通过`cmake --workflow --preset <workflow-preset-name>`来调用。在我们的情况下，我们运行以下命令：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We’ll then see the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将看到以下输出：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Unfortunately, we can’t provide the `--config` override with the `--workflow`
    command. This means build preset variants specifying the configuration (in the
    case of multi-config generators) would be necessary to have workflows build all
    different configurations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法在`--workflow`命令中提供`--config`覆盖。这意味着需要构建预设变体来指定配置（在多配置生成器的情况下），以便工作流能够构建所有不同的配置。
- en: 'Finally, to show all presets, we can run `cmake --list-presets all` from the
    command line to display every kind of preset at once. Preset names only need to
    be unique within a preset type, so we can use the same name for configure, build
    and workflow presets:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要显示所有预设，我们可以从命令行运行`cmake --list-presets all`，一次显示所有类型的预设。预设名称只需要在同一预设类型内唯一，因此我们可以为配置、构建和工作流预设使用相同的名称：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To see an example of both build and workflow presets, take a moment to visit
    `ch5/part-4/app/CMakePresets.json` on the accompanying *Minimal* *CMake* repo.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看构建和工作流预设的示例，可以花点时间访问附带的*Minimal* *CMake*库中的`ch5/part-4/app/CMakePresets.json`。
- en: CMake presets are an excellent mechanism for keeping your `CMakeLists.txt` files
    clean and uncluttered with configuration details. They must be treated with care
    as the number of presets can grow exponentially with the combinatorial explosion
    of settings. Sticking to the most common presets is a good place to start; they
    can then be expanded to handle more complex configurations in the future to ease
    cross-team collaboration and project maintenance. They also integrate nicely with
    CMake tooling. In [*Chapter 11*](B21152_11.xhtml#_idTextAnchor228), *Supporting
    Tools and Next Steps*, we’ll look at how CMake presets make building and debugging
    in Visual Studio Code a breeze.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 预设是保持 `CMakeLists.txt` 文件简洁、不含配置细节的绝佳机制。它们需要小心处理，因为随着设置的组合爆炸，预设的数量可能会呈指数增长。从最常见的预设开始是一个不错的起点；它们可以在未来扩展，以处理更复杂的配置，帮助跨团队协作和项目维护。它们与
    CMake 工具也能够很好地集成。在 [*第 11 章*](B21152_11.xhtml#_idTextAnchor228)，*支持工具与后续步骤*中，我们将讨论
    CMake 预设如何使在 Visual Studio Code 中的构建与调试变得轻松。
- en: In this section, we saw how to create configure CMake presets to avoid duplication,
    how CMake presets can be used in combination with command-line overrides, and
    understood where build and workflow presets fit in. There’s even more CMake presets
    can do, which we’ll return to when we look at testing and, later, packaging. Next,
    we’ll get reacquainted with the CMake GUI.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们了解了如何创建配置 CMake 预设以避免重复，如何将 CMake 预设与命令行重写结合使用，以及构建和工作流预设的作用。CMake 预设还能做更多事情，稍后我们将在测试和打包部分回顾它们的用法。接下来，我们将重新熟悉
    CMake GUI。
- en: A return to the CMake GUI
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归 CMake GUI
- en: Throughout this book, we’ve focused almost exclusively on using CMake from the
    command line/terminal. This is the best way to get familiar with how CMake works
    and understand the most common commands. It’s often the fastest way to get things
    done and we’ll continue to use it, but sometimes getting a fresh perspective on
    a project can be worthwhile.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我们几乎专注于从命令行/终端使用 CMake。这是熟悉 CMake 工作原理和理解最常用命令的最佳方式。它通常是最快完成任务的方式，我们将继续使用它，但有时候，从新视角审视项目也是值得的。
- en: This is where the CMake GUI comes in. The CMake GUI is somewhat limited in what
    it provides (you’re not able to build a project directly from the GUI) but getting
    a graphical view of all relevant CMake variables is often immensely helpful.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 CMake GUI 的作用所在。CMake GUI 提供的功能有些有限（你不能直接从 GUI 构建项目），但获取所有相关 CMake 变量的图形化视图通常非常有帮助。
- en: The most reliable way to open the CMake GUI is by running `cmake-gui .` from
    the root of your project. This ensures the tool inherits the same environment
    variables you have configured from the terminal. This is important on Windows
    as we’re using the *Visual Studio Command Prompt*, and on macOS, opening from
    *Finder* won’t have the same environment variables as from the terminal. If we
    don’t do this, it’s possible the CMake GUI won’t find CMake, a C/C++ compiler,
    or the generator we want to use (for example, Ninja on Windows).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 CMake GUI 最可靠的方法是从项目根目录运行`cmake-gui .`。这样可以确保工具继承你从终端配置的相同环境变量。这在 Windows
    上尤其重要，因为我们使用的是*Visual Studio 命令提示符*，而在 macOS 上，从*Finder*打开时，环境变量与从终端打开时不同。如果不这样做，CMake
    GUI 可能无法找到 CMake、C/C++ 编译器或我们想要使用的生成器（例如，在 Windows 上使用 Ninja）。
- en: The installers for CMake on Windows and macOS will add a shortcut/icon for opening
    the CMake GUI, but unfortunately, opening it this way is not always guaranteed
    to work. If you would like to open the CMake GUI from the desktop on Linux, you
    can either navigate to `/opt/cmake-3.28.1-linux-<arch>/bin/` and double-click
    `cmake-gui` or to add a desktop icon for the CMake GUI, (this is specifically
    if you’ve installed CMake using the approach outlined in [*Chapter 1*](B21152_01.xhtml#_idTextAnchor019),
    *Getting Started*). Launching the CMake GUI with the `cmake-gui .` command is
    the most reliable cross-platform way to have the CMake GUI open at the right place.
    The documentation states passing `-S` and `-B` for the source and build directory
    is supported; however, from personal experience, this seems to not work consistently
    across all platforms. Once a project is configured, running just `cmake-gui` (without
    `.`) will open things where you left off. If you don’t provide a starting directory,
    you can select the source and build directory from within the tool, though this
    can be a fiddly process. It’s also possible to use CMake presets in combination
    with the CMake GUI, either providing one directly at the command line or selecting
    one inside the tool.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Windows和macOS上的CMake安装程序会添加一个快捷方式/图标用于打开CMake GUI，但不幸的是，通过这种方式打开并不总是能成功。如果你想在Linux桌面上打开CMake
    GUI，你可以导航到`/opt/cmake-3.28.1-linux-<arch>/bin/`并双击`cmake-gui`，或者为CMake GUI添加一个桌面图标（如果你是按照[*第1章*](B21152_01.xhtml#_idTextAnchor019)的方式安装CMake，*入门*部分）。使用`cmake-gui
    .`命令启动CMake GUI是最可靠的跨平台方法，可以在正确的地方打开CMake GUI。文档中说明了可以传递`-S`和`-B`来指定源目录和构建目录；然而，根据个人经验，这在所有平台上并不总是有效。一旦项目配置完成，仅运行`cmake-gui`（不带`.`）将会打开你上次离开的地方。如果没有提供起始目录，你可以从工具内部选择源目录和构建目录，尽管这个过程可能有点繁琐。也可以结合使用CMake预设和CMake
    GUI，直接在命令行提供预设，或者在工具内选择一个预设。
- en: 'When first opening the CMake GUI, you’ll be presented with a view resembling
    the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次打开CMake GUI时，你会看到类似于以下的界面：
- en: '![Figure 5.2: CMake GUI](img/B21152_05_2.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：CMake GUI](img/B21152_05_2.jpg)'
- en: 'Figure 5.2: CMake GUI'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：CMake GUI
- en: The top section shows the source directory, preset (if selected), and build
    directory. The center section displays all CMake variables after configuration,
    and the bottom section shows the output you’d normally see when running CMake
    from the terminal.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部区域显示源目录、预设（如果选择了）和构建目录。中间区域显示配置后的所有CMake变量，底部区域则显示你通常在终端运行CMake时看到的输出。
- en: The CMake GUI is set up to work better with project files that can be opened
    in some kind of `CMakeLists.txt` file, and the tools handle configuration (such
    as Visual Studio Code from Microsoft or CLion from JetBrains). There is an updated
    `CMakePreset.json` file in `ch5/part-5/app` that shows configurations for Xcode,
    Visual Studio, and Ninja Multi-Config.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CMake GUI被设置为更好地与可以在某种`CMakeLists.txt`文件中打开的项目文件一起工作，且这些工具可以处理配置（例如微软的Visual
    Studio Code或JetBrains的CLion）。`ch5/part-5/app`中有一个更新版的`CMakePreset.json`文件，展示了Xcode、Visual
    Studio和Ninja Multi-Config的配置。
- en: 'Once the source directory and build folder are set, clicking **Configure**
    will display all new (or changed) CMake variables. These display in red, which
    can initially be a little disconcerting, but isn’t an error. Press the **Configure**
    button again to check if any CMake variables have changed; all the red highlights
    should then disappear:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦源目录和构建文件夹设置完成，点击**配置**将显示所有新的（或更改的）CMake变量。这些变量会以红色显示，刚开始可能会让人感到有些困惑，但这并不是错误。再次按下**配置**按钮检查是否有任何CMake变量发生变化；所有红色高亮应随之消失：
- en: '![Figure 5.3: CMake GUI after initial configuration](img/B21152_05_3.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：初始配置后的CMake GUI](img/B21152_05_3.jpg)'
- en: 'Figure 5.3: CMake GUI after initial configuration'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：初始配置后的CMake GUI
- en: The CMake GUI explicitly separates the **Configure** and **Generate** steps,
    which normally happen together when running from the command line. Once the configuration
    is complete, press the **Generate** button to create the project files. In the
    preceding example, we’ve used the Visual Studio generator, so clicking **Open
    Project** will open the Visual Studio solution. Visual Studio can then be used
    to build the project directly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: CMake GUI明确区分了**配置**和**生成**步骤，而这两个步骤通常在命令行运行时是一起完成的。配置完成后，点击**生成**按钮来创建项目文件。在之前的示例中，我们使用了Visual
    Studio生成器，因此点击**打开项目**将会打开Visual Studio解决方案。此时可以直接使用Visual Studio构建项目。
- en: Toggling the `MC_GOL_SHARED` in an ungrouped section, but in the future, entries
    beginning with `MC_` will be grouped together.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 切换 `MC_GOL_SHARED` 到一个未分组的部分，但将来，所有以 `MC_` 开头的条目将会被分组在一起。
- en: Checking `list_cmake_variables` function we saw in [*Chapter 3*](B21152_03.xhtml#_idTextAnchor065),
    *Using FetchContent with External Dependencies*, but it’s a good place to start
    and is often sufficient.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们在[ *第 3 章* ](B21152_03.xhtml#_idTextAnchor065)中看到的`list_cmake_variables`函数，*使用
    FetchContent 和外部依赖*，虽然它是一个不错的起点，并且通常足够用。
- en: The last useful feature is the **Add Entry** button. Clicking it provides a
    form to add new CMake variables to the CMake cache. This interface can be a little
    friendlier than adding variables from the command line. Remember to run **Configure**
    again after adding a new variable (it will appear in red in the central section
    of the tool as a reminder). There is also a corresponding **Remove Entry** button,
    which will remove CMake variables from the cache.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个有用的功能是**添加条目**按钮。点击它会提供一个表单，用于将新的 CMake 变量添加到 CMake 缓存中。这个界面比从命令行添加变量要友好一些。记得在添加新变量后重新运行**配置**（它会以红色出现在工具的中央部分，作为提醒）。还有一个相应的**移除条目**按钮，它会将
    CMake 变量从缓存中移除。
- en: It’s good to know about the CMake GUI, but for the rest of this book, we’ll
    stick predominantly to the command line to get things done. Please use it if you
    prefer, and most of what’s covered will be transferable between the CMake GUI
    and the command line.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 CMake 图形界面是很有帮助的，但在本书的剩余部分，我们将主要依赖命令行来完成工作。如果你更喜欢图形界面，也可以使用它，大部分内容在 CMake
    图形界面和命令行之间是可以互换的。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小结
- en: Excellent work getting to this point. In this chapter, we learned how using
    simple scripts can take some of the monotony out of typing the same CMake commands
    over and over again, as well as how this can make life easier for new users checking
    out your project. We then looked at how to use CMake presets to further improve
    how we configure projects and ensure we keep our `CMakeLists.txt` files clean.
    We saw how to use CMake presets to create configure, build, and workflow commands.
    Lastly, we took a closer look at the CMake GUI to gain a deeper understanding
    of how it works and what we can use it for.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了这一部分的内容。在这一章中，我们学习了如何使用简单的脚本消除反复输入相同 CMake 命令的单调感，以及这如何让新用户在查看你的项目时更加轻松。接着，我们探讨了如何使用
    CMake 预设进一步优化项目配置，并确保保持我们的`CMakeLists.txt`文件的整洁。我们还了解了如何使用 CMake 预设来创建配置、构建和工作流命令。最后，我们深入了解了
    CMake 图形界面，以便更好地理解它的工作原理以及我们可以用它做什么。
- en: In the next chapter, we’re going to change gears and return to our *Game of
    Life* project. We are going to leave our console application behind and move to
    a proper cross-platform windowed experience. To achieve this, we’ll learn how
    to add larger dependencies to our project and understand exactly what it means
    to *install* a library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将切换主题，回到我们的*生命游戏*项目。我们将放弃控制台应用程序，转向一个真正的跨平台窗口体验。为此，我们将学习如何向项目中添加更大的依赖，并理解*安装*一个库的真正含义。
