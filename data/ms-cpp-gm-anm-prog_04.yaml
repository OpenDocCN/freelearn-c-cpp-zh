- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Adding a Visual Selection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加视觉选择
- en: Welcome to *Chapter 3*! In the previous chapter, we offloaded the majority of
    matrix and vector calculations to the GPU. A modern graphics card has more (and
    also more specialized) computing cores than a desktop CPU, so, moving the compute
    load to the GPU will free the main CPU from most of the animation work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*第三章*！在前一章中，我们将大部分矩阵和向量计算任务卸载到了GPU上。现代显卡的计算核心（以及更专业的计算核心）比桌面CPU要多，因此，将计算负载移至GPU将释放主CPU的大部分动画工作。
- en: In this chapter, we will add a couple of simplifications when working with a
    lot of model instances. After the changes in the previous chapter, we are able
    to display thousands of model instances on the screen, but selecting a specific
    instance is still hard. We will start by adding coordinate arrows to identify
    the currently selected instance. Next, we will add a function that allows us to
    center the specified instance in the middle of the screen. Then, a graphical highlight
    will be created, further helping us to find the selected instance among all instances.
    As the last step, we will add a model without triangles, and an instance from
    this empty model, allowing us to deselect the visible instances.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加一些简化操作，以便在处理大量模型实例时使用。在前一章的更改之后，我们能够在屏幕上显示数千个模型实例，但选择特定的实例仍然很困难。我们将首先添加坐标箭头以识别当前选定的实例。接下来，我们将添加一个允许我们将指定实例居中显示在屏幕中间的功能。然后，我们将创建一个图形高亮显示，进一步帮助我们找到所有实例中的选定实例。作为最后一步，我们将添加一个没有三角形的模型，以及从这个空模型中创建的一个实例，允许我们取消选择可见的实例。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementing a “move to instance” function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个“移动到实例”功能
- en: Adding a highlight to the selected instance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为选定的实例添加高亮显示
- en: Selecting a model instance with point and click
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点选选择模型实例
- en: Implementing a null object to allow deselection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个空对象以允许取消选择
- en: At first glance, these topics may look unrelated to animation programming. But
    proper tooling is an essential part of creating a user-friendly application. Good
    tools will help the user to simplify application handling.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这些主题似乎与动画编程无关。但适当的工具是创建用户友好应用程序的重要组成部分。好的工具将帮助用户简化应用程序的处理。
- en: Later in the book, when you have created dozens or even hundreds of instances
    that are happily jumping and running around randomly on the screen, selecting
    one instance by simply clicking on it with the mouse, using a UI button to center
    the instance on the screen, or moving and rotating the instance by using the mouse
    will make your life a lot easier. And you might even forget how cumbersome the
    first two chapters were when it came to selecting an instance or changing instance
    properties.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，当你创建了数十个甚至数百个实例，它们在屏幕上快乐地跳跃和随机移动时，只需用鼠标单击一个实例即可选择它，使用UI按钮将实例居中显示在屏幕上，或使用鼠标移动和旋转实例，这将使你的生活变得更加轻松。你甚至可能会忘记前两章在选择实例或更改实例属性时是多么繁琐。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will need the application code from [*Chapter 2*](Chapter_2.xhtml): [https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming](https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[*第二章*](Chapter_2.xhtml)中的应用代码：[https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming](https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming)。
- en: The example source code for this chapter can be found in the folder `chapter03`,
    subfolder `01_opengl_selection` for OpenGL, and `02_vulkan_selection` for Vulkan.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在文件夹`chapter03`的子文件夹`01_opengl_selection`（用于OpenGL）和`02_vulkan_selection`（用于Vulkan）中找到。
- en: Implementing a “move to instance” function
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个“移动到实例”功能
- en: As the first change for the “move to instance” functionality, we will add a
    small set of coordinate arrows appearing at the origin of the drawn model to identify
    the currently selected instance. We will also add a button to center the currently
    selected instance. Let’s start with the implementation of the coordinate arrows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为“移动到实例”功能的第一个更改，我们将添加一组小坐标箭头，出现在绘制的模型的原点，以识别当前选定的实例。我们还将添加一个按钮以居中当前选定的实例。让我们从坐标箭头的实现开始。
- en: Adding coordinate arrows
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加坐标箭头
- en: 'Since we will use lines instead of triangles to draw coordinate arrows at the
    center of the selected instance, we need some extra data structures, objects and
    shaders. To store the vertex and color data, we add two new structs to the declarations
    in the file `OGLRenderData.h` in the `opengl` folder:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用线条而不是三角形在所选实例的中心绘制坐标箭头，我们需要一些额外的数据结构、对象和着色器。为了存储顶点和颜色数据，我们在 `opengl`
    文件夹中的 `OGLRenderData.h` 文件声明中添加了两个新的结构体：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For Vulkan, the new structs are named `VkLineVertex` and `VkLineMesh`, residing
    in the file `VkRenderData.h` in the `vulkan` folder.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vulkan，新的结构体命名为 `VkLineVertex` 和 `VkLineMesh`，位于 `vulkan` 文件夹中的 `VkRenderData.h`
    文件中。
- en: 'Uploading the coordinate arrow data to the GPU, a new class, `LineVertexBuffer`,
    in the `opengl` folder, will be added. A simple way to get the new class files
    is to copy the two source files for the `VertexIndexBuffer` class (`VertexIndexBuffer.h`
    and `VertexIndexBuffer.cpp`) in the `opengl` folder, and then adjust the `init()`
    method to send `position` and `color` data to the graphics card:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将坐标箭头数据上传到 GPU 时，将在 `opengl` 文件夹中添加一个新的类 `LineVertexBuffer`。获取新类文件的一个简单方法是将
    `VertexIndexBuffer` 类的两个源文件（`VertexIndexBuffer.h` 和 `VertexIndexBuffer.cpp`）复制到
    `opengl` 文件夹中，然后调整 `init()` 方法以将 `position` 和 `color` 数据发送到显卡：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We must also enable both the `position` and the `color` attributes by using
    `glEnableVertexAttribArray()` with the corresponding index values (the first parameter
    of `glVertexAttribPointer`) to send the vertex data for both attributes to the
    vertex shader.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须通过使用 `glEnableVertexAttribArray()` 并提供相应的索引值（`glVertexAttribPointer` 的第一个参数）来启用
    `position` 和 `color` 属性，以便将这两个属性的数据发送到顶点着色器。
- en: On the GPU side, two simple pass-through shaders are needed – the vertex and
    fragment shader will only pass the data through without additional transformations,
    except the required view and projection matrix transformations. The vertex shader
    named `line.vert`, located in the `shader` folder, uses the `view` and `projection`
    matrices of the camera position to calculate the final vertex positions. Then,
    the position and the color of the line endpoints are handed over to the fragment
    shader named `line.frag`, also located in the `shader` folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GPU 端，需要两个简单的透射着色器——顶点着色器和片段着色器将只传递数据，而不进行额外的变换，除了所需的视图和投影矩阵变换。名为 `line.vert`
    的顶点着色器位于 `shader` 文件夹中，它使用相机位置的视图和投影矩阵来计算最终的顶点位置。然后，将线条端点的位置和颜色传递给也位于 `shader`
    文件夹中的名为 `line.frag` 的片段着色器。
- en: 'The vertices for our coordinate arrows are taken from a static model file named
    `CoordArrowsModel` in the `model` folder. We can hard-code the vertex positions
    and colors to keep the initialization simple:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们坐标箭头的顶点是从名为 `CoordArrowsModel` 的静态模型文件中获取的，该文件位于 `model` 文件夹中。我们可以通过硬编码顶点位置和颜色来简化初始化过程：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The final positions for the vertices of the coordinate arrows are set in the
    `draw()` call of the render. As the first step, the line counter will be zeroed,
    and the `mLineMesh` vector for the vertices of the coordinate arrows is cleared:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标箭头顶点的最终位置是在渲染的 `draw()` 调用中设置的。作为第一步，行计数器将被置零，用于坐标箭头顶点的 `mLineMesh` 向量将被清空：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we retrieve the settings of the currently selected instance, containing
    the position and rotation of the instance:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检索当前所选实例的设置，包含实例的位置和旋转：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we add the number of vertices to the line counter variable `mCoordArrowsLineIndexCount`
    and iterate over each vertex in a `std::for_each`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将顶点数添加到行计数器变量 `mCoordArrowsLineIndexCount` 中，并使用 `std::for_each` 迭代每个顶点：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By using a lambda function, the position data of the vertices is altered to
    match the position and rotation of the instance. In addition, we dim the color
    of the coordinate arrows by dividing the color vector by a value of two.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 lambda 函数，顶点的位置数据被修改以匹配实例的位置和旋转。此外，我们通过将颜色向量除以 2 的值来降低坐标箭头的颜色。
- en: 'The resulting per-vertex data is collected in the `mLineMesh` vector:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶点的结果数据被收集在 `mLineMesh` 向量中：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we will upload the vertex data to the GPU, and draw the coordinate lines:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将顶点数据上传到 GPU，并绘制坐标线：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, the `mCoordArrowsLineIndexCount` is used to check if coordinate lines
    exist at all, and as a parameter to draw the correct number of points for the
    lines. Using the line count as a check value and a counter helps us if we don’t
    want to draw any coordinate lines at all: We can simply skip filling `mLineMesh`
    and counting coordinate lines, skipping the line drawing automatically. Or, we
    could draw multiple coordinate arrows in a multi-selection scenario.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mCoordArrowsLineIndexCount`用于检查是否存在坐标线，并且作为绘制正确数量点的参数。使用线数作为检查值和计数器可以帮助我们，如果我们根本不想绘制任何坐标线：我们可以简单地跳过填充`mLineMesh`和计数坐标线，自动跳过线绘制。或者，我们可以在多选场景中绘制多个坐标箭头。
- en: 'Uploading vertex data in Vulkan is much more complex compared to OpenGL due
    to the explicit nature of the Vulkan API. The full process for creating a different
    shader and uploading vertex data requires the following steps in Vulkan:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中上传顶点数据比OpenGL复杂得多，因为Vulkan API的显式性。创建不同着色器和上传顶点数据的完整过程在Vulkan中需要以下步骤：
- en: Create a pair of passthrough shaders in GLSL or HLSL (High-Level Shader Language
    for DirectX). For GLSL shaders, the syntax has only small differences – mostly
    it’s about being more explicit when using the `layout` statement.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GLSL或HLSL（DirectX的高级着色语言）中创建一对透射着色器。对于GLSL着色器，语法只有细微的差别——大多数情况下是在使用`layout`语句时更加明确。
- en: Create a new pipeline with the new shaders and a corresponding attribute definition.
    Vulkan needs a new pipeline since the pipeline itself will become *immutable*
    after creation (except for a few explicit dynamically configurable sub-objects,
    like the viewport). Vulkan shaders *cannot* be swapped at runtime like in OpenGL;
    we need to bind another pipeline to draw vertices with a different shader.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的着色器和相应的属性定义创建一个新的管线。Vulkan需要一个新管线，因为创建后管线本身将变为**不可变**的（除了少数几个显式动态可配置的子对象，如视口）。Vulkan的着色器**不能**像OpenGL那样在运行时交换；我们需要绑定另一个管线来使用不同的着色器绘制顶点。
- en: Upload the vertex data to the GPU by using a staging buffer. To achieve the
    best performance in Vulkan, the vertex data should be stored in an optimized format
    in a memory area where only the GPU has access. Using a buffer shared between
    the CPU and GPU requires additional synchronization by the driver and the data
    may not be in the optimal format for the GPU to draw, resulting in performance
    losses.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用阶段缓冲区将顶点数据上传到GPU。为了在Vulkan中获得最佳性能，顶点数据应存储在只有GPU可以访问的优化格式内存区域中。使用CPU和GPU之间共享的缓冲区需要驱动程序进行额外的同步，并且数据可能不是GPU绘制的最佳格式，从而导致性能损失。
- en: While recording the render pass commands to send to the GPU, we must bind both
    the new pipeline by using the `vkCmdBindPipeline()` method and the vertex buffer
    by using `vkCmdBindVertexBuffers()`. After submitting the command buffer to the
    driver, the vertices are drawn with the new shader.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在记录要发送到GPU的渲染传递命令时，我们必须使用`vkCmdBindPipeline()`方法绑定新管线，并使用`vkCmdBindVertexBuffers()`方法绑定顶点缓冲区。在提交命令缓冲区到驱动程序后，使用新着色器绘制顶点。
- en: You can check out the classes `Shader`, `Pipeline`, and `VertexBuffer` in the
    `vulkan` folder of the example code for implementation details. Also, a link in
    the section *Additional resources* to a Vulkan tutorial is available. The tutorial
    has a separate section about vertex buffer creation and data uploading.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在示例代码的`vulkan`文件夹中查看`Shader`、`Pipeline`和`VertexBuffer`类的实现细节。此外，在*附加资源*部分提供了一个指向Vulkan教程的链接。该教程有一个关于顶点缓冲区创建和数据上传的单独部分。
- en: 'Now, three small arrows are added to the selected instance, as shown in *Figure
    3.1*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在所选实例上添加了三个小箭头，如图*图3.1*所示：
- en: '![](img/Figure_3.1_B22428.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_3.1_B22428.png)'
- en: 'Figure 3.1: New coordinate arrows to identify the selected instance'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：新的坐标箭头以识别所选实例
- en: The red arrow points to the direction of the positive `x` axis, the blue arrow
    points to the positive `z` axis, and the green arrow towards the positive `y`
    axis.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 红色箭头指向正`x`轴的方向，蓝色箭头指向正`z`轴，绿色箭头指向正`y`轴。
- en: As the second step towards the “move to instance” function, the new UI button
    will be added.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为“移动到实例”功能的第二步，将添加新的UI按钮。
- en: Creating a button to center the selected instance
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个按钮以居中选择的实例
- en: For the new button in the user interface, we will follow the previous implementations
    and add a callback for the `UserInterface` class. The callback calls a method
    in the renderer class, moving the camera calculations related from the user interface
    to the renderer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户界面中的新按钮，我们将遵循之前的实现，并为`UserInterface`类添加一个回调。该回调调用渲染器类中的方法，将用户界面中的相机计算相关部分移动到渲染器。
- en: 'In the `UserInterface` class, we add a new ImGui button, plus the new callback,
    using the current instance as parameter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserInterface`类中，我们添加了一个新的ImGui按钮，以及新的回调，使用当前实例作为参数：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the renderer is initialized, the callback `miInstanceCenterCallbackFunction`
    will be bound via a lambda function to the new `centerInstance()` method of the
    renderer:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染器初始化时，回调`miInstanceCenterCallbackFunction`将通过lambda函数绑定到渲染器的新的`centerInstance()`方法：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `centerInstance()` method extracts the position of the instance, adds a
    static offset of 5 units on all axes, and calls `moveCameraTo()` of the camera
    object:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`centerInstance()`方法提取实例的位置，在所有轴向上添加5个单位的静态偏移量，并调用相机对象的`moveCameraTo()`方法：'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, `moveCameraTo()` moves the camera to the instance position plus offset
    given in the renderer, and uses fixed values for azimuth and elevation to center
    the selected instance in the middle of the screen:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`moveCameraTo()`将相机移动到渲染器中给出的实例位置加上偏移量，并使用固定的方位角和仰角值将选定的实例居中在屏幕中间：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using hard-coded values for azimuth and elevation makes the process a bit easier,
    since the extraction of both values from a matrix generated by a method like `glm::lookAt()`
    is a bit more complex. You might try to set the camera angles from a transformation
    matrix by yourself – see the *Practical sessions* section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用硬编码的方位角和仰角值使过程变得稍微容易一些，因为从像`glm::lookAt()`这样的方法生成的矩阵中提取这两个值要复杂一些。您可能尝试自己通过变换矩阵设置相机角度
    - 请参阅*实践课程*部分。
- en: 'You can add the new ImGui centering button anywhere in the collapsed header
    for the instances. In the example code, the button has been placed right below
    the arrows to select the current instance, as shown in *Figure 3.2*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在实例的折叠标题中的任何位置添加新的ImGui居中按钮。在示例代码中，按钮被放置在箭头下方以选择当前实例，如图*图3.2*所示：
- en: '![](img/Figure_3.2_B22428.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2](img/Figure_3.2_B22428.png)'
- en: 'Figure 3.2: The currently selected instance has been centered'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：当前选定的实例已被居中
- en: Centering the currently selected instance is a huge step towards a better *look
    & feel* for the application. We don’t need to search for the blinking instance
    or the coordinate arrows to find the selected instance; now, we are literally
    only a mouse click away from reaching the instance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前选定的实例居中是朝着更好的*外观和感觉*迈出的巨大一步。我们不需要搜索闪烁的实例或坐标箭头以找到选定的实例；现在，我们实际上只需点击一下鼠标即可到达实例。
- en: Still, this solution has some drawbacks. What if we don’t want to center the
    selected instance, maybe because we would like to keep the camera position fixed.
    So, let’s add another function to the code that makes the currently selected instance
    even easier to find among all instances shown on the screen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案还有一些缺点。如果我们不想居中选定的实例，可能是因为我们希望保持相机位置固定，那该怎么办？所以，让我们在代码中添加另一个函数，使得当前选定的实例在屏幕上显示的所有实例中更容易找到。
- en: Adding a highlight to the selected instance
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为选定的实例添加高亮
- en: At first sight, adding some sort of highlight seems to be easy by adding some
    more fields to the vertices and the vertex buffer. Sadly, we are using instanced
    rendering for performance reasons. This means that all instances share the same
    vertex data. So, this approach does not work.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，通过向顶点和顶点缓冲区添加更多字段，添加某种类型的高亮似乎很简单。遗憾的是，我们出于性能原因正在使用实例渲染。这意味着所有实例共享相同的顶点数据。因此，这种方法不可行。
- en: The next idea may be the instance placement and animations data. These matrices
    are calculated entirely by our compute shaders from [*Chapter 2*](Chapter_2.xhtml),
    fed by the node transform data of the nodes. Adding model related data to every
    node seems to be a bit overkill, since the highlighted data is needed only once
    per instance, not once per node.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个想法可能是实例放置和动画数据。这些矩阵完全由我们的计算着色器从[*第2章*](Chapter_2.xhtml)计算得出，由节点的节点变换数据提供。将模型相关数据添加到每个节点似乎有点过度，因为高亮的数据只需要每个实例一次，而不是每个节点一次。
- en: A better idea would be another SSBO, filled with the correct data in the `draw()`
    call of the renderer, right after the node transform data has been retrieved from
    the instance. In the instance loop, we have direct access to all instances of
    a model and can simply push a value to a `std::vector`, stating if this is the
    selected instance or not. After uploading the data of the vector to the SSBO,
    the shader instance can check the buffer data to see if the highlight should be
    added to the instance it is working on, or not.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的想法是另一个SSBO，在从实例中检索节点变换数据后，立即在渲染器的`draw()`调用中填充正确的数据。在实例循环中，我们直接访问模型的所有实例，并可以简单地向`std::vector`推送一个值，表示这是否是选定的实例。在将向量的数据上传到SSBO之后，着色器实例可以检查缓冲区数据，以确定是否应该将其高亮添加到它正在处理的实例中，或者不添加。
- en: Preparing the renderer to support highlights
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备渲染器以支持高亮显示
- en: 'As the first step for adding the highlight to the selected instance, we add
    a vector containing a `float`, and, for the OpenGL renderer, an SSBO to the renderer
    header file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为向选定实例添加高亮的第一个步骤，我们向渲染器头文件添加一个包含`float`的向量和，对于OpenGL渲染器，一个SSBO：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Due to the different data logic, for Vulkan, a `VkShaderStorageBufferData` object
    in the `VkRenderData` struct in the file `VkRenderData.h` will be used instead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同的数据逻辑，对于Vulkan，文件`VkRenderData.h`中的`VkRenderData`结构体将使用`VkShaderStorageBufferData`对象代替。
- en: 'In the `draw()` call of the renderer, we save the smart pointer of the currently
    selected instance, right before we start the loop across the models and instances:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器的`draw()`调用中，我们在开始遍历模型和实例之前，保存当前选定实例的智能指针：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In addition to storing the instance, we alter a float value inside the `OGLRenderData`
    respective `VkRenderData` struct by adding a scaled `deltaTime`, and resetting
    the value once it reaches `2.0f`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储实例之外，我们通过添加缩放的`deltaTime`并重置值，一旦达到`2.0f`，在`OGLRenderData`相应的`VkRenderData`结构体中更改一个浮点值：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The value of the variable `rdSelectedInstanceHighlightValue` will be used in
    the shader to scale up or down the color of the selected instance. By adding the
    value of `deltaTime` in every `draw()` call and resetting the highlight variable
    to `0.1f` when we reach `2.0f`, the selected install will blink from very dark
    to very bright. The blinking instance will be easier to spot on the screen, compared
    to just the coordinate arrows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`rdSelectedInstanceHighlightValue`的值将在着色器中使用，以放大或缩小选定实例的颜色。通过在每次`draw()`调用中添加`deltaTime`的值，并在达到`2.0f`时将高亮变量重置为`0.1f`，选定的实例将从非常暗变为非常亮，闪烁的实例在屏幕上更容易被发现，比仅仅的坐标箭头更容易识别。
- en: 'Inside the instance loop, we compare the smart pointer of the instance we are
    working on and the saved smart pointer of the selected instance. If they are identical,
    the alternating value of the variable `rdSelectedInstanceHighlightValue` will
    be set at the index of the current instance in the `mSelectedInstance` vector:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例循环内部，我们比较我们正在处理的实例的智能指针和保存的选定实例的智能指针。如果它们相同，变量`rdSelectedInstanceHighlightValue`的交替值将被设置为`mSelectedInstance`向量中当前实例的索引：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we are working on any other instance in the loop, we simply set the `x` value
    to `1.0f`, resulting in an unchanged color of the instance in the shader.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在循环中处理任何其他实例，我们只需将`x`值设置为`1.0f`，这将导致着色器中实例的颜色保持不变。
- en: 'The collected data of the `mSelectedInstance` vector is then uploaded to the
    SSBO. For example, the OpenGL renderer uses the `uploadSsboData()` method of the
    `ShaderStorageBuffer` class to upload the vector data to the GPU:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`mSelectedInstance`向量的收集数据上传到SSBO。例如，OpenGL渲染器使用`ShaderStorageBuffer`类的`uploadSsboData()`方法将向量数据上传到GPU：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adjusting logic to shaders and the UI
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整着色器和UI的逻辑
- en: 'As the next step for adding the highlight to the selected instance, the shaders
    have to be adjusted. In the `assimp_skinning.vert` vertex shader in the `shader`
    folder, the new SSBO must be added:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为向选定实例添加高亮的下一个步骤，着色器需要进行调整。在`shader`文件夹中的`assimp_skinning.vert`顶点着色器中，必须添加新的SSBO：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The same addition is needed in the `assimp.vert` shader in the `shader` folder,
    used for non-animated model instances.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shader`文件夹中用于非动画模型实例的`assimp.vert`着色器中也需要进行相同的添加。
- en: 'Please check the binding number – due to the missing animation data, the number
    of SSBOs differs between the shaders for animated and non-animated instances:
    The shader for animated models binds the instance selection data on binding point
    `3` since binding point `2` is already used by the world position matrices:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查绑定编号——由于缺少动画数据，动画和非动画实例的着色器中SSBO的数量不同：动画模型的着色器在绑定点`3`上绑定实例选择数据，因为绑定点`2`已经被世界位置矩阵使用：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In contrast, the shader for non-animated models binds only two buffers:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，非动画模型的着色器只绑定两个缓冲区：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To adjust the color of the selected instance, we can now use the internal variable
    `gl_InstanceID` of the shader, retrieving the value of the data at the location
    of the instance in the `selected` buffer:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用着色器的内部变量`gl_InstanceID`来调整所选实例的颜色，检索`selected`缓冲区中实例位置的数据：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As an optional change, we could also decrement the depth value of the selected
    instance by `1.0f`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可选的更改，我们还可以将所选实例的深度值减去`1.0f`：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Lowering the `z` element of the internal variable `gl_Position` will adjust
    the depth value of the triangle to the lowest possible value. This depth adjustment
    makes the highlighted instance visible even if other instances are closer to the
    camera position.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 降低内部变量`gl_Position`的`z`元素将调整三角形的深度值到可能的最小值。这种深度调整使得高亮显示的实例即使在其他实例更靠近摄像机位置时也能可见。
- en: 'Finally, we add a `Boolean` variable named `rdHighlightSelectedInstance` in
    the `OGLRenderData` respective `VkRenderData` struct, allowing us to switch the
    highlight on and off. This new variable will be attached to an ImGui checkbox
    in the `UserInterface` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`OGLRenderData`和`VkRenderData`结构体中添加了一个名为`rdHighlightSelectedInstance`的`Boolean`变量，使我们能够开关高亮显示。这个新变量将被附加到`UserInterface`类中的ImGui复选框：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In *Figure 3.3*, the effect of combining highlighting and `z` position adjustment
    in the vertex shader is shown:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.3*中，展示了在顶点着色器中结合高亮显示和`z`位置调整的效果：
- en: '![](img/Figure_3.3_B22428.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.3_B22428.png)'
- en: 'Figure 3.3: Highlighted instance drawn on top of instances closer to the camera'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：在靠近摄像机的实例上绘制的高亮显示实例
- en: According to the relative size of the brighter instance, this instance would
    be at least partially hidden behind other instances closer to the camera. Yet,
    the adjustment of the `z` position draws the selected instance on top of all instances
    on the screen.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据较亮实例的相对大小，这个实例至少部分地隐藏在靠近摄像机的其他实例后面。然而，`z`位置的调整将所选实例绘制在屏幕上所有实例的顶部。
- en: What cannot be shown in the picture is the alternating brightness of the selected
    instance. As set in the `draw()` call of the renderer, the colors of the selected
    instance go up from only 10% of the original color (start value of `0.1f`) to
    200% of the original colors (clamping at `2.0f`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图片中无法展示的是所选实例的交替亮度。如渲染器的`draw()`调用中设置的那样，所选实例的颜色从只有原始颜色的10%（`0.1f`的起始值）增加到原始颜色的200%（限制在`2.0f`）。
- en: 'The flashing colors of the instance will make it fairly easy to find the currently
    selected instance on the screen. But there is still a piece missing in the application:
    Being able to select the instance of choice by clicking into the window, instead
    of searching through all instances by using the instance number arrows. Let’s
    tackle the visual selection now.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实例的闪烁颜色将使在屏幕上找到当前所选实例变得相当容易。但应用程序中仍有一块缺失的部分：能够通过点击窗口而不是使用实例编号箭头搜索所有实例来选择所需的实例。现在让我们处理视觉选择。
- en: Selecting a model instance with point and click
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用点和点击选择模型实例
- en: 'Before we start with the implementation, we will look at the two different
    approaches to add visual selection to an application: by “shooting” a ray into
    the virtual scene, and by using a texture holding an index of the instances.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现之前，我们将探讨向应用程序添加视觉选择的不同方法：通过“射击”一个光线到虚拟场景中，以及使用包含实例索引的纹理。
- en: Pros and cons of shooting virtual rays
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击虚拟光线的优缺点
- en: 'You may find the following idea of shooting a virtual ray into your scene appealing:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现将虚拟光线射入场景中的以下想法很有吸引力：
- en: We already have the position of the camera in the virtual world as the first
    endpoint, and by mapping the mouse pointer positions back from screen positions
    to scene coordinates, you will get the second endpoint. Mapping coordinates back
    to the scene is only a couple of matrix inversions and multiplications away.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了虚拟世界中的摄像机位置作为第一个端点，通过将鼠标指针位置从屏幕位置映射回场景坐标，你将得到第二个端点。将坐标映射回场景只需要进行几个矩阵的逆运算和乘法运算。
- en: Sounds promising and easy, doesn’t it?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很有希望且简单，不是吗？
- en: Sadly, it is common to underestimate the final complexity at this point. As
    long as you only have a single model in the world, or two, everything is fine.
    You shoot the virtual ray into the scene, and loop over the triangles of each
    instance to find the closest intersection between the ray and the instance triangles.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，在这个阶段低估最终复杂性的情况很常见。只要世界上只有一个模型，或者两个，一切都会好。你将虚拟射线射入场景，然后遍历每个实例的三角形，以找到射线与实例三角形之间的最近交点。
- en: But what happens when you have, say, 1,000 instances?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你有，比如说，1,000个实例时会发生什么呢？
- en: Every time you click the selection button on your mouse, you would have to iterate
    over all triangles of all instances, hoping to find at least one match. The test
    model of the book has roughly 2,000 triangles, so you will have to check for 2,000,000
    possible intersections in a virtual world with 1,000 instances. Even with massive
    parallel computer shaders, this amount of calculation is a lot of wood to chuck
    for modern graphics cards.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你点击鼠标上的选择按钮时，你都需要遍历所有实例的所有三角形，希望至少找到一个匹配项。书中提到的测试模型大约有2,000个三角形，因此你将需要在包含1,000个实例的虚拟世界中检查2,000,000个可能的交点。即使使用大规模并行计算机着色器，这么多的计算量对于现代显卡来说也是相当大的。
- en: There are several ways to exclude large areas of the virtual world from the
    hit tests. In combination with other hierarchical approaches on the node level,
    the number of intersection checks can be lowered by several orders of magnitude.
    We will cover optimizations of the process to find intersections when we handle
    instance collisions in [*Chapter 8*](Chapter_8.xhtml).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以排除虚拟世界中大片区域参与碰撞测试。结合节点级别的其他分层方法，可以通过几个数量级降低交点检查的数量。我们将在处理实例碰撞时，在[*第8章*](Chapter_8.xhtml)中介绍该过程的优化。
- en: What about the alternative idea – using a texture?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于使用纹理的替代想法呢？
- en: Advantages of drawing the instance index into a texture
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将实例索引绘制到纹理中的优势
- en: The basic idea of an extra texture for the instance selection comes from **Deferred
    Rendering**. In deferred rendering, computations like lighting are not done in
    the fragment shader, but “deferred” after storing the required information in
    textures. The set of textures containing all information about the pixels on the
    screen is called the **G-Buffer**, short for **geometry buffer**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个额外的纹理用于实例选择的基点理念来源于**延迟渲染**。在延迟渲染中，像光照这样的计算不是在片段着色器中完成的，而是在将所需信息存储在纹理中之后“延迟”执行。包含屏幕上所有像素信息的纹理集合被称为**G-Buffer**，简称**几何缓冲区**。
- en: By using the data of the textures in the G-Buffer, the complexity to apply lighting
    to a scene is lowered from `Number of triangles * Number of lights in the entire
    scene` to `Number of pixels of the G-Buffer * Number of nearby lights`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用G-Buffer中纹理的数据，将光照应用于场景的复杂性从“三角形数量 * 场景中所有灯光的数量”降低到“G-Buffer的像素数量 * 附近灯光的数量”。
- en: Even for 4K or 8K graphic resolutions, the number of operations to create the
    lighting information is lowered drastically. And, by using other information from
    the rendering process, other effects are easily possible with deferred rendering,
    like shadow mapping, or indirect lighting.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是4K或8K的图形分辨率，创建光照信息所需的操作数量也会大幅降低。此外，通过使用渲染过程中的其他信息，使用延迟渲染可以轻松实现其他效果，如阴影映射或间接光照。
- en: For naive ray-shooting, the selection complexity grows with the number of instances
    in the virtual world, even if these instances are not visible on the screen. When
    we apply the deferred rendering approach to visual selection, we have a constant
    overhead of drawing some pixels into a separate texture. Our selection process
    no longer depends on a variable number of instances in the world. Also, the resolution
    of the buffers may affect the performance of the instance selection only marginally.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的光线投射，选择复杂性随着虚拟世界中实例数量的增加而增加，即使这些实例在屏幕上不可见。当我们应用延迟渲染方法到视觉选择时，我们在绘制一些像素到单独纹理上有一个恒定的开销。我们的选择过程不再依赖于世界中实例的变量数量。此外，缓冲区的分辨率可能只会对实例选择性能产生轻微的影响。
- en: The amount of changes required to add visual selection with a separate texture
    is surprisingly low. Let’s look at the steps we have to take.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 添加具有单独纹理的视觉选择所需的更改量出人意料地低。让我们看看我们必须采取的步骤。
- en: Adjusting the framebuffer
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整帧缓冲区
- en: We start with the `FrameBuffer` class and add a new color attachment. For the
    OpenGL version, the new color attachment is created as follows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`FrameBuffer`类开始，并添加一个新的颜色附加组件。对于OpenGL版本，新的颜色附加组件创建如下。
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For the selection texture, we add a texture containing only a single element,
    the red color. But we use a 32-bit wide red color, not only 8 bits, allowing us
    to store much more instance indices. The new texture is then added as a color
    attachment with the index 1 to the framebuffer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择纹理，我们添加一个只包含单个元素的纹理，即红色。但我们使用32位宽的红色，而不仅仅是8位，这使得我们可以存储更多的实例索引。然后，新的纹理作为索引为1的颜色附加组件添加到帧缓冲区中。
- en: A note on the texture data type (float)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于纹理数据类型（float）的说明
- en: It is possible to create a texture with the type of `GL_R32UI`, containing a
    32-bit wide unsigned integer for every pixel. But all integer versions of the
    texture use a conversion factor for the components, raising the complexity of
    the selection process due to extra computations on reads and writes. In contrast,
    a `GL_R32F` buffer stores and retrieves an unaltered float value. By using a float
    on the GPU side, we are still able to store ~16.7 million instance indices (2^(24)),
    before the precision of a 32-bit float may lead to rounding errors during the
    conversion between integer and float values. See the section *Additional resources*
    for a link to a blog entry with more details of float precision.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能创建一个类型为`GL_R32UI`的纹理，每个像素包含一个32位宽的无符号整数。但所有整数的纹理版本都使用一个转换因子来处理组件，这增加了选择过程的复杂性，因为读取和写入时需要进行额外的计算。相比之下，`GL_R32F`缓冲区存储和检索未更改的浮点值。通过在GPU端使用浮点数，我们仍然能够存储约1670万个实例索引（2^24），在32位浮点数的精度可能导致整数和浮点值转换时的舍入误差之前。有关浮点精度的更多详细信息，请参阅*附加资源*部分中的博客文章链接。
- en: 'Also, during framebuffer creation, we have to make sure our shader writes to
    both color attachments:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在创建帧缓冲区时，我们必须确保我们的着色器写入两个颜色附加组件：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we don’t change the buffers to draw to, only the models will be drawn on
    the screen, and the selection texture will never be filled.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不更改要绘制的缓冲区，则只有模型将在屏幕上绘制，选择纹理永远不会被填充。
- en: 'To clear the color buffer and the selection buffer with different values, a
    new method called `clearTextures()` has been added to the `FrameBuffer` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用不同的值清除颜色缓冲区和选择缓冲区，已向`FrameBuffer`类添加了一个名为`clearTextures()`的新方法：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The selection texture can store arbitrary float values, using a `-1.0f` to clear
    the selection texture, which is a nice method to have a unique value for the empty
    background.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 选择纹理可以存储任意浮点值，使用`-1.0f`来清除选择纹理，这是一个为空背景拥有唯一值的好方法。
- en: 'We also avoid creating yet another SSBO to store the instance index, and extend
    the `mSelectedInstance` vector from `float` to `glm::vec2`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还避免了创建另一个SSBO来存储实例索引，并将`mSelectedInstance`向量从`float`扩展到`glm::vec2`：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By moving the existing highlight color to the `x` element of the `glm::vec2`
    vector, we have a free `float` type spot, and we can store the instance index
    in the `y` element.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将现有的高亮颜色移动到`glm::vec2`向量的`x`元素，我们有一个免费的`float`类型位置，并且可以将实例索引存储在`y`元素中。
- en: Creating a selection shader
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建选择着色器
- en: 'Adding a new color buffer to the framebuffer also requires two new pairs of
    vertex/fragment shaders: One pair for animated models, another pair for non-animated
    models. But since we already send the selection information for instance highlighting
    to the shader, only small additions to the existing shader code are needed.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 向帧缓冲器添加新的颜色缓冲区也需要两对新的顶点/片段着色器：一对用于动画模型，另一对用于非动画模型。但由于我们已将实例高亮选取信息发送到着色器，因此只需对现有着色器代码进行少量添加。
- en: 'Since we can reuse the shaders, the first step is to copy the existing files.
    For the non-animated models, copy the shader `assimp.vert` to `assimp_selection.vert`,
    and `assimp.frag` to `assimp_selection.frag`. The same name addition will be used
    for the animated model shader: Copy the file `assimp_skinning.vert` to `assimp_skinning_selection.vert`,
    and `assimp_skinning.frag` to `assimp_skinning_selection.frag`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以重用着色器，第一步是复制现有文件。对于非动画模型，将着色器`assimp.vert`复制到`assimp_selection.vert`，将`assimp.frag`复制到`assimp_selection.frag`。相同的名称添加也将用于动画模型着色器：将文件`assimp_skinning.vert`复制到`assimp_skinning_selection.vert`，将`assimp_skinning.frag`复制到`assimp_skinning_selection.frag`。
- en: 'We also need two new shader objects in the renderer, so we add the `private`
    `Shader` member variables named `mAssimpSelectionShader` and `mAssimpSkinningSelectionShader`
    to the file `OGLRenderer.h`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在渲染器中添加两个新的着色器对象，因此我们在文件`OGLRenderer.h`中添加名为`mAssimpSelectionShader`和`mAssimpSkinningSelectionShader`的`private`
    `Shader`成员变量：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Like the existing shaders, the two new shaders are loaded in the `init()` method
    of the renderer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与现有的着色器一样，两个新的着色器在渲染器的`init()`方法中加载。
- en: 'Then, two lines must be added to the new vertex shaders. The first new line
    adds a new output variable named `selectInfo` to the vertex shader, allowing us
    to hand over the selection data for the current triangle to the fragment shader:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须向新的顶点着色器中添加两行代码。第一行新代码向顶点着色器添加一个名为`selectInfo`的新输出变量，使我们能够将当前三角形的选取数据传递给片段着色器：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second line at the end of the `main()` method does the actual forwarding
    to the fragment shader:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`方法的最后一行负责实际转发到片段着色器：'
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the two new fragment shaders, similar changes are needed. On top of the
    shader code, we must add the new input variable `selectInfo`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个新的片段着色器，需要类似的更改。在着色器代码之上，我们必须添加新的输入变量`selectInfo`：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Also, the fragment shader output has to be adjusted. Replace the single `FragColor`
    output line with the following two lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，片段着色器的输出也需要调整。将单个`FragColor`输出行替换为以下两行：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We write two different outputs now, one for each color buffer: The color buffer
    of the frame buffer will be filled with the RGBA values for the on-screen color
    of each pixel as before, and at the end of the `main()` method, the instance index
    passed through from the vertex shader will be written to the second color buffer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们写入两个不同的输出，每个颜色缓冲区一个：帧缓冲器的颜色缓冲区将填充每个像素的屏幕颜色RGBA值，就像之前一样，在`main()`方法的末尾，从顶点着色器传递的实例索引将被写入第二个颜色缓冲区：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we use the new selection shader now when drawing the instances, the index
    of the instance will be added to the selection buffer for every single pixel of
    that of the instances onscreen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在在绘制实例时使用新的选取着色器，实例的索引将添加到每个实例屏幕上的选取缓冲区中的每个像素。
- en: Reading a pixel from a texture
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从纹理中读取像素
- en: Reading out the color of the pixel at a given position will be done in the method
    `readPixelFromPos()` of the `FrameBuffer` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定位置读取像素的颜色将在`FrameBuffer`类的`readPixelFromPos()`方法中完成。
- en: 'First, we initialize our designated return variable with a special value, making
    it easy to find errors when OpenGL refuses to read out the pixel color due to
    a configuration problem:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用特殊值初始化指定的返回变量，以便在OpenGL由于配置问题拒绝读取像素颜色时容易找到错误：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we bind our framebuffer object as buffer to read from, and we select
    the color attachment `1` of the framebuffer, containing the selection texture:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将帧缓冲对象绑定为缓冲区以读取，并选择帧缓冲区的颜色附加`1`，其中包含选取纹理：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we adjust the internal alignment used during the read process, and read
    out the color value of a single pixel at the given `xPos` and `yPos` position:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调整读取过程中使用的内部对齐方式，并在给定的`xPos`和`yPos`位置读取单个像素的颜色值：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we switch the framebuffer back to color attachment `0`, unbind the
    buffer and return the pixel color:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将帧缓冲区切换回颜色附加`0`，解绑缓冲区并返回像素颜色：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Adding mouse button handling
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加鼠标按钮处理
- en: Selecting an instance will be added to the left mouse button. It feels natural
    to click on an instance to select it. To store the status of the selection, a
    Boolean member variable named `mMousePick` is added to the renderer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将实例选择添加到左鼠标按钮。点击实例来选择它感觉很自然。为了存储选择状态，我们在渲染器中添加了一个名为 `mMousePick` 的布尔成员变量。
- en: 'Then, the following line must be added to the `handleMouseButtonEvents()` method
    of the renderer:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须在渲染器的 `handleMouseButtonEvents()` 方法中添加以下行：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using the `GLFW_RELEASE` `action` here, reacting when the left mouse button
    is released, matches the selection style of many applications. If you want to
    change the behavior, you can use the action `GLFW_PRESS`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GLFW_RELEASE` `action` 在这里，当左鼠标按钮释放时做出反应，与许多应用程序的选择风格相匹配。如果您想更改行为，可以使用 `GLFW_PRESS`
    动作。
- en: We use the `mMousePick` value to trigger different actions in the drawing process
    only when a selection event has been triggered by the user. Separating normal
    drawing and the extra operation for selection helps to retain the maximum speed
    of the application, avoiding operations that are only required during the selection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅在用户通过选择事件触发选择时，使用 `mMousePick` 值在绘图过程中触发不同的动作。将正常绘制和选择额外操作分开，有助于保持应用程序的最大速度，避免仅在选择期间需要的操作。
- en: 'As an example, the shader with the logic to draw into the selection texture
    will be only called if a selection event was triggered:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，只有当触发选择事件时，具有将内容绘制到选择纹理中的逻辑的着色器才会被调用：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Assigning an index to each instance
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为每个实例分配一个索引
- en: To ensure we always maintain a unique index for every instance, any time an
    instance is added or removed, we assign its overall index. Using the unique index
    per instance also helps us in accessing the current instance in the `miAssimpInstances`
    vector.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们始终为每个实例维护一个唯一的索引，每次添加或删除实例时，我们都会分配其整体索引。使用每个实例的唯一索引也有助于我们在 `miAssimpInstances`
    向量中访问当前实例。
- en: 'We add a new variable `isInstanceIndexPosition` to the struct `InstanceSettings`,
    located in the file `InstanceSettings.h` in the `model` folder:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `model` 文件夹中 `InstanceSettings.h` 文件所在的 `InstanceSettings` 结构体中添加了一个新变量
    `isInstanceIndexPosition`：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The variable `isInstanceIndexPosition` will be set in the method `assignInstanceIndices()`,
    doing a loop over all the instances:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `isInstanceIndexPosition` 将在 `assignInstanceIndices()` 方法中设置，该方法会遍历所有实例：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The method `assignInstanceIndices()` is called whenever instances are added
    or removed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例被添加或删除时，会调用 `assignInstanceIndices()` 方法。
- en: 'Having an easy to access instance number at hand helps us to fill the `y` element
    of the `mSelectedInstance` vector during the loop over all instances of a model:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 手头有一个易于访问的实例编号有助于我们在遍历模型的所有实例时填充 `mSelectedInstance` 向量的 `y` 元素：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Selecting the instance at mouse positions
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在鼠标位置选择实例
- en: 'As the final step for the visual selection, we trigger the pixel read at the
    end of the `draw()` call in the renderer:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为视觉选择的最后一步，我们在渲染器中的 `draw()` 调用结束时触发像素读取：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: By surrounding the pixel read with a check for the `mMousePick` variable, we
    make sure the functions to read back the pixel will be called only on the selection
    event.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在像素读取周围检查 `mMousePick` 变量，我们确保只有在选择事件上才会调用读取像素的函数。
- en: This guarding check is especially important for the calls to `glFlush()` and
    `glFinish()`. Both commands are required to make sure all shader runs have ended,
    and the data in the selection texture is complete. While `glFlush()` empties the
    internal buffers and triggers the rendering itself, `glFinish()` blocks the renderer
    and waits for all previous OpenGL calls to have finished. Forcing these OpenGL
    commands on every frame decreases the number of frames per second in most implementations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这种保护检查对于调用 `glFlush()` 和 `glFinish()` 尤为重要。这两个命令都是必需的，以确保所有着色器运行都已结束，选择纹理中的数据已完整。虽然
    `glFlush()` 清空内部缓冲区并触发渲染本身，但 `glFinish()` 会阻塞渲染器并等待所有之前的 OpenGL 调用完成。在大多数实现中，强制这些
    OpenGL 命令在每个帧上都会降低每秒帧数。
- en: 'Next, we call `readPixelFromPos()` on the `FrameBuffer` instance:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `FrameBuffer` 实例上调用 `readPixelFromPos()`：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Due to the different orientations of the `y` axis in OpenGL on the one hand
    and Windows and Linux on the other, we need to invert the `y` position when reading
    out the pixel.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OpenGL 中的 `y` 轴方向在 Windows 和 Linux 上的不同，我们需要在读取像素时反转 `y` 位置。
- en: 'After we retrieve the pixel color, we check if any instance was selected, or
    the mouse click was done on the background of the screen:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检索像素颜色之后，我们检查是否有任何实例被选中，或者鼠标点击是在屏幕的背景上完成的：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As the last step, we set `mMousePick` to `false`, stopping the selection mode
    immediately.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将 `mMousePick` 设置为 `false`，立即停止选择模式。
- en: 'In *Figure 3.4*, the selection texture for a larger group of model instances
    is shown:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3.4* 中，展示了较大组模型实例的选择纹理：
- en: '![](img/Figure_3.4_B22428.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.4_B22428.png)'
- en: 'Figure 3.4: The selection texture'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：选择纹理
- en: The background color in *Figure 3.4* has been changed to white. In the actual
    selection texture, the clear value of `-1.0f` will be clamped to zero, resulting
    in a black background. Also, the index values have been adjusted to enhance the
    visibility of the instances. If we render the selection texture with the real
    float values, all index values will be clamped to `1.0f`, resulting in a picture
    where all instances appear in bright red.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.4* 中的背景颜色已被改为白色。在实际的选择纹理中，清晰的值 `-1.0f` 将被钳位到零，从而得到一个黑色背景。此外，索引值已调整以增强实例的可见性。如果我们用实际的浮点值渲染选择纹理，所有索引值都将被钳位到
    `1.0f`，从而得到一个所有实例都显示为鲜红色的图片。'
- en: Selecting a single instance by using the mouse is working great now. As one
    of the ideas in the *Practical sessions* section, you could try to add more functionality,
    like selecting multiple instances at the same time. i.e., by keeping the *Ctrl*
    or *Shift* key down while selecting instances, newly selected instances are added,
    showing the coordinate arrows and the highlight on all selected instances.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标选择单个实例现在工作得很好。作为 *实践课程* 部分中的一个想法，你可以尝试添加更多功能，比如同时选择多个实例。例如，在选中实例时按住 *Ctrl*
    或 *Shift* 键，新选中的实例将被添加，显示所有选中实例的坐标箭头和高亮。
- en: 'But there is one thing left that may annoy you: There is no way to select no
    instance at all. We will add a solution for an empty selection in the last section
    of this chapter.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一件事可能让你感到烦恼：没有方法可以完全不选择任何实例。我们将在本章的最后部分添加一个空选择的解决方案。
- en: Implementing a null object to allow deselection
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现空对象以允许取消选择
- en: 'Adding a deselection by doing a click into the background of the application
    window comes with a bunch of interesting implications. For instance, the position
    `0` may be a valid index in the `miAssimpInstance` vector, stating that the first
    instance has been selected. So, simply using zero to signal that no instances
    are selected does not work. Even worse: Using zero as the first index may confuse
    users of the application, as it is not intentional to start counting numbers at
    zero, instead of one.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序窗口的背景上点击以取消选择带来了一系列有趣的含义。例如，位置 `0` 可能是 `miAssimpInstance` 向量中的一个有效索引，表示已选择了第一个实例。所以，简单地使用零来表示没有实例被选中是不行的。更糟糕的是：将零作为第一个索引可能会让应用程序的用户感到困惑，因为从零开始计数并不是有意为之，而是从一开始的。
- en: In addition, the default buffer background value of `–1` is an invalid array
    index. Using the value of `-1` as an index into the `miAssimpInstance` vector
    would simply crash the application. Since we will use the instance vector frequently
    in the code, adding a range check for every single access would be crucial because
    even missing a single check will lead to a crash.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`-1` 的默认缓冲区背景值是一个无效的数组索引。使用 `-1` 作为 `miAssimpInstance` 向量的索引将简单地导致应用程序崩溃。由于我们将在代码中频繁使用实例向量，为每次单独访问添加范围检查将至关重要，因为即使错过一次检查也会导致崩溃。
- en: So, we need another signalling mechanism to switch between the two selection
    variants and a simplification of the range checks. To catch both problems with
    a single solution, we will use an empty model as a **null object**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要另一种信号机制来在两种选择变体之间切换，并简化范围检查。为了用一个解决方案来捕捉这两个问题，我们将使用一个空模型作为 **空对象**。
- en: What is a null object?
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是空对象？
- en: Using a null object is a well-known design pattern for object-oriented programming.
    Usually, you would use a `nullptr` to signal the absence of an object instance.
    But, using a `nullptr` requires creating an extra check before every usage of
    the instance for being valid or not. Dereferencing a non-existing instance leads
    to a runtime error, and the application crashes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空对象是面向对象编程中众所周知的设计模式。通常，你会使用 `nullptr` 来表示对象实例的缺失。但是，使用 `nullptr` 需要在每次使用实例之前进行额外的检查，以确定其实例是否有效。取消引用一个不存在的实例会导致运行时错误，并使应用程序崩溃。
- en: The null object is a valid object instance, delivering a well-defined, but neutral
    behavior. Function calls in the instance of the null object are valid, but may
    return nothing viable, like an empty list, or some default values. This behavior
    frees the code of extra checks, since the instance itself is valid.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象是一个有效的对象实例，提供了一种定义良好但中性的行为。空对象实例中的函数调用是有效的，但可能返回无用的结果，例如空列表或一些默认值。这种行为使得代码无需进行额外的检查，因为实例本身是有效的。
- en: For our selection problem, we simply create an instance of the `AssimpModel`
    class that returns no vertices, plus empty lists or vectors for nodes, meshes,
    and so on. Then, we add the special model as the first model to the `miModelList`
    vector and add one instance of the “null model” as the first instance to the `miAssimpInstances`
    vector and to the `miAssimpInstancesPerModel` map.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的选择问题，我们简单地创建一个返回无顶点的 `AssimpModel` 类实例，以及节点、网格等空列表或向量。然后，我们将特殊模型作为第一个模型添加到
    `miModelList` 向量中，并将一个“空模型”实例作为第一个实例添加到 `miAssimpInstances` 向量以及 `miAssimpInstancesPerModel`
    映射中。
- en: If we select the first model instance now, we have a valid object, just without
    any triangles drawn to the screen. Switching off the coordinate arrows or adjusting
    the user interface to disable controls if no instance is selected can be done
    without extra signalling variables. We just need to test `miSelectedInstance`
    for being `0`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在选择第一个模型实例，我们将有一个有效的对象，只是屏幕上没有绘制任何三角形。关闭坐标箭头或调整用户界面以禁用未选择实例的控制，无需额外的信号变量。我们只需要测试
    `miSelectedInstance` 是否为 `0`。
- en: We will alter the original pattern a bit, and don’t use a derived class. Instead,
    we will provide an empty object of the `AssimpModel` class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍微改变原始模式，不使用派生类。相反，我们将提供一个空的 `AssimpModel` 类对象。
- en: Creating and using the AssimpModel null object
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用 AssimpModel 空对象
- en: Since we initialized the class members variables already in the header file
    `AssimpModel.h` with default values, creating a null object can be achieved by
    creating an empty instance. And the simplest way to create an instance of the
    `AssimpModel` class without setting any data is by using the implicitly created
    default constructor. We don’t even need to define a custom constructor; the C++
    compiler will handle everything we need in the background.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在头文件 `AssimpModel.h` 中使用默认值初始化了类成员变量，因此创建一个空对象可以通过创建一个空实例来实现。创建 `AssimpModel`
    类实例而不设置任何数据的最简单方法是通过使用隐式创建的默认构造函数。我们甚至不需要定义自定义构造函数；C++ 编译器将在后台处理我们需要的所有内容。
- en: 'In the `init()` method of the renderer, we create a smart pointer to the null
    model, and add the model pointer to the `miModelList` vector:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器的 `init()` 方法中，我们创建了一个指向空模型的智能指针，并将模型指针添加到 `miModelList` 向量中：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we can create an `AssimpInstance` instance from the null model, and place
    it into the `miAssimpInstancesPerModel` map and the `miAssimpInstances` vector:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从空模型创建一个 `AssimpInstance` 实例，并将其放入 `miAssimpInstancesPerModel` 映射和 `miAssimpInstances`
    向量中：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As the final initialization step, we update the index numbers of the instances:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的初始化步骤，我们更新实例的索引号：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, the instance of the `nullModel` model has the index number `0`. Any instance
    added in the application will now start at index `1`. Matching numbers for the
    overall number of instances and the instance index will avoid confusion about
    differences in the instance numbering schema.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`nullModel` 模型实例的索引号为 `0`。任何在应用程序中添加的实例现在将从索引 `1` 开始。匹配实例总数和实例索引号将避免对实例编号方案的混淆。
- en: 'To skip the model during vertex processing in the `draw()` call of the renderer,
    a check for the triangle count has been added:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在渲染器的 `draw()` 调用中跳过模型进行顶点处理，添加了一个对三角形数量的检查：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In case we have no triangles in a model, all instances of this specific model
    will be skipped.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型中没有三角形，将跳过该特定模型的全部实例。
- en: 'In addition, we check for the instance number `0` before generating the final
    vertex position for the coordinate arrows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在生成坐标箭头的最终顶点位置之前检查实例号 `0`：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Whenever the very first instance is selected – the instance of the null model
    – no coordinate arrows will be drawn on the screen. We can even remove the `size()`
    check of the `miAssimpInstances` vector here, as we know we have at least one
    valid instance available.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择第一个实例——空模型实例——时，屏幕上不会绘制任何坐标箭头。我们甚至可以在这里移除 `miAssimpInstances` 向量的 `size()`
    检查，因为我们知道至少有一个有效的实例可用。
- en: Adjusting the user interface
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整用户界面
- en: 'In the user interface, we will cheat a bit to keep the instance selection fields
    disabled in case the null instance is selected:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面中，我们将稍微作弊一下，以保持实例选择字段在选中空实例时禁用：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: By subtracting `1` from the size of the `miModelList` vector, we ignore the
    null model in that vector. We also ignore the null instance of the null model
    to count the instances in `numberOfInstances`. The additional Boolean `nullInstanceSelected`
    helps us to disable parts of the user interface when models and instances are
    available, but we have not selected any of the instances.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 `miModelList` 向量的尺寸中减去 `1`，我们忽略了该向量中的空模型。我们还忽略了空模型的空实例，以计算 `numberOfInstances`
    中的实例数量。额外的布尔值 `nullInstanceSelected` 帮助我们在模型和实例可用但未选择任何实例时禁用用户界面的部分。
- en: 'In *Figure 3.5*, the effect of the deselection by using the null object is
    shown:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图3.5* 中，展示了使用空对象取消选择的效果：
- en: '![](img/Figure_3.5_B22428.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.5_B22428.png)'
- en: 'Figure 3.5: User interface is partially disabled when nothing is selected'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：当没有选择任何内容时，用户界面部分禁用
- en: No coordinate arrows are drawn at the feet of the model instance, as we hide
    the arrows when the null instance is selected. Also, the user interface is partially
    disabled, an effect of ignoring the null instance when counting the number of
    instances.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 模型实例的脚下不绘制坐标箭头，因为我们选择空实例时隐藏箭头。此外，用户界面部分禁用，这是在计算实例数量时忽略空实例的效果。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we enhanced the instance selection methods in the code for
    better handling of finding the selected instance on the screen. Plus, we added
    the ability to select an instance by using the mouse. First, we implemented a
    button to center our virtual camera on the selected instance. Next, we added the
    ability to highlight the selected model, making it easier to spot on the screen.
    Then, we implemented a visual selection, allowing the user to select an instance
    by clicking on any instance with the mouse. Finally, we created the possibility
    to select no instance at all, avoiding accidental changes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们增强了代码中的实例选择方法，以更好地处理在屏幕上找到所选实例。此外，我们添加了使用鼠标选择实例的能力。首先，我们实现了一个按钮，将我们的虚拟相机中心对准所选实例。接下来，我们添加了突出显示所选模型的能力，使其更容易在屏幕上找到。然后，我们实现了视觉选择，允许用户通过点击任何实例来选择实例。最后，我们创建了选择零个实例的可能性，以避免意外更改。
- en: In the next chapter, we will lay some groundwork to adapt more game engine features
    to the model viewer. As well as splitting the behavior of the viewer into an edit
    mode and a pure viewer functionality, we will add the ability to revert ongoing
    changes to an instance. At the end of the next chapter, we will implement undo/redo
    functionality, allowing the user to revert changes, or to reapply previous changes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为将更多游戏引擎功能适配到模型查看器打下一些基础。除了将查看器的行为分为编辑模式和纯查看功能外，我们还将添加将正在进行中的更改还原到实例的能力。在下一章的结尾，我们将实现撤销/重做功能，使用户能够撤销更改，或者重新应用之前的更改。
- en: Practical sessions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'There are some additions you could make to the code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中添加一些内容：
- en: Calculate azimuth and elevation when moving the camera.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动相机时计算方位角和仰角。
- en: Right now, the values for azimuth and elevation are hard-coded. You could try
    to calculate both values from the transformation matrix.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，方位角和仰角的值是硬编码的。你可以尝试从变换矩阵中计算这两个值。
- en: Implement a visual multi-selection.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现视觉多选。
- en: Enhance the selection so that holding *Ctrl* or *Shift* during selection clicks
    will add the newly selected instance to the other selected instances, instead
    of replacing the current selected instance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 增强选择功能，以便在选择点击时按住 *Ctrl* 或 *Shift*，将新选定的实例添加到其他选定的实例中，而不是替换当前选定的实例。
- en: 'Extra difficulty: Implement instance moving via coordinate arrows.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外难度：通过坐标箭头实现实例移动。
- en: Since the coordinate arrows for the selection are drawn in a separate shader,
    you could try to add an extra set of selection indices to the arrows and adding
    the arrows to the selection texture. When the user clicks on one of the arrows
    instead of the mode, you could switch the application to a mode where the instance
    can be moved along the selected axis. This behavior is similar to moving an instance
    in any common 3D editor.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于选择用的坐标箭头是在一个单独的着色器中绘制的，你可以尝试向箭头添加一组额外的选择索引，并将箭头添加到选择纹理中。当用户点击箭头而不是模式时，你可以将应用程序切换到允许实例沿选定轴移动的模式。这种行为类似于在任何常见的3D编辑器中移动实例。
- en: Additional resources
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'OpenGL basics: [https://learnopengl.com/Getting-started/Hello-Triangle](https://learnopengl.com/Getting-started/Hello-Triangle)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL 基础：[https://learnopengl.com/Getting-started/Hello-Triangle](https://learnopengl.com/Getting-started/Hello-Triangle)
- en: 'OpenGL Shader programming: [https://learnopengl.com/Getting-started/Shaders](https://learnopengl.com/Getting-started/Shaders)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL 着色器编程：[https://learnopengl.com/Getting-started/Shaders](https://learnopengl.com/Getting-started/Shaders)
- en: 'Vulkan Tutorial: [https://vulkan-tutorial.com](https://vulkan-tutorial.com)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vulkan 教程：[https://vulkan-tutorial.com](https://vulkan-tutorial.com)
- en: 'Demystifying Floating Point Precision: [https://blog.demofox.org/2017/11/21/floating-point-precision/](https://blog.demofox.org/2017/11/21/floating-point-precision/)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点精度揭秘：[https://blog.demofox.org/2017/11/21/floating-point-precision/](https://blog.demofox.org/2017/11/21/floating-point-precision/)
- en: 'Null object pattern: [https://www.geeksforgeeks.org/null-object-design-pattern/](https://www.geeksforgeeks.org/null-object-design-pattern/)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空对象模式：[https://www.geeksforgeeks.org/null-object-design-pattern/](https://www.geeksforgeeks.org/null-object-design-pattern/)
- en: Join our community on Discord
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码 AI 生成的内容可能不正确。](img/QR_code_Discord.png)'
