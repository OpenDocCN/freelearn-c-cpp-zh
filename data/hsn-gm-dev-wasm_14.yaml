- en: UI and Mouse Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI和鼠标输入
- en: A **user** **interface** (**UI**) defines the interaction between a computer
    program and the user. In our game, our interaction so far has been limited to
    a keyboard interface that controls our player's spaceship. When we wrote our particle
    system configuration apps, we used HTML to define a more robust user interface,
    which allowed us to input values to configure our particle system. From that user
    interface, our code had to interact with the WebAssembly code indirectly. That
    is a technique you could continue to use for games if you wanted to leverage HTML
    to define your user interface, but it has a few disadvantages. First of all, we
    may want user interface elements that overlay the content of our game. Going through
    the DOM for this kind of effect is not very efficient. It is also easier to have
    interactions between our UI and objects from within the game if the UI elements
    are rendered inside of the game engine. In addition, you may be developing your
    C/C++ code to be used for a platform as well as a web release. If this is the
    case, you may not want HTML to have much of a role in your user interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面**（**UI**）定义了计算机程序与用户之间的交互。在我们的游戏中，到目前为止，我们的交互仅限于控制玩家飞船的键盘界面。当我们编写粒子系统配置应用程序时，我们使用HTML来定义更强大的用户界面，这使我们能够输入值来配置我们的粒子系统。从该用户界面，我们的代码必须间接地与WebAssembly代码进行交互。这是一种您可以继续在游戏中使用的技术，如果您想利用HTML来定义您的用户界面，但它有一些缺点。首先，我们可能希望用户界面元素覆盖我们游戏内容。通过DOM进行此类效果的效率不是很高。如果UI元素在游戏引擎内部呈现，游戏内的UI和对象之间的交互也更容易。此外，您可能正在开发C/C++代码以用于平台以及Web发布。如果是这种情况，您可能不希望HTML在用户界面中扮演太大的角色。'
- en: In this chapter, we will be implementing a few UI features inside our game.
    We will need to implement a `Button` class, which is one of the simplest and most
    common UI elements. We will also need to implement a separate screen and game
    state so that we can have a starting and an ending game screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在游戏中实现一些UI功能。我们需要实现一个`Button`类，这是最简单和最常见的UI元素之一。我们还需要实现一个单独的屏幕和游戏状态，以便我们可以有一个开始和结束游戏画面。
- en: 'You will need to include several images and audio files in your build to make
    this project work. Make sure that you include the `/Chapter14/sprites/` and `/Chapter14/audio/`
    folders from this project''s GitHub repository. If you haven''t downloaded the
    GitHub project yet, you can get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Development](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在构建中包含几个图像和音频文件，以使此项目正常工作。确保您从此项目的GitHub存储库中包含`/Chapter14/sprites/`和`/Chapter14/audio/`文件夹。如果您还没有下载GitHub项目，可以在这里在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Development](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: UI requirements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI需求
- en: Getting mouse input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取鼠标输入
- en: Creating a button
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个按钮
- en: The start game screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始游戏画面
- en: The game over screen
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束画面
- en: UI requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI需求
- en: 'The first thing we will need to do when implementing our UI is to decide on
    some requirements. What exactly do we need for our user interface? The first part
    of that is deciding what game screens we need for our game. This is usually the
    kind of thing you do early in the game design process, but because I am writing
    a book about WebAssembly, I have saved this step for a later chapter. Deciding
    what screens your game needs usually involves a storyboard and a process by which
    you either talk through (if more than one person is working on the game) or think
    through the way a user will interact with your web page, as well as the game that
    is on that page:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现UI时，我们需要做的第一件事是确定一些需求。我们的用户界面到底需要什么？其中的第一部分是决定我们游戏需要哪些游戏画面。这通常是游戏设计过程中早期就要做的事情，但因为我正在写一本关于WebAssembly的书，所以我把这一步留到了后面的章节。决定游戏需要哪些画面通常涉及故事板和一个过程，通过这个过程，您可以通过讨论（如果有多人在游戏上工作）或者思考用户将如何与您的网页以及网页上的游戏进行交互的方式来决定：
- en: '![](img/44bf0fc4-4b90-44ee-bf06-3d7e6882c67e.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44bf0fc4-4b90-44ee-bf06-3d7e6882c67e.png)'
- en: 'Figure 14.1: Storyboard example for our user interface'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：我们用户界面的故事板示例
- en: 'You don''t have to draw a storyboard, but I find it useful when thinking through
    what I need for a game''s UI. It is even more useful when you need to relay that
    information to another team member or an artist. When thinking through what we
    need in this game for the preceding storyboard, I came up with the following list
    of requirements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必绘制故事板，但我发现在思考游戏UI所需的内容时很有用。当您需要将这些信息传达给另一名团队成员或艺术家时，它甚至更有用。在思考我们在这个游戏中需要什么之前的故事板时，我列出了以下需求清单：
- en: Opening screen
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开场画面
- en: Instructions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说明
- en: Play button
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放按钮
- en: Game play screen
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏游玩画面
- en: Score text
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分文本
- en: Game over screen
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束画面
- en: You win message
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你赢了的消息
- en: You lose message
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你输了的消息
- en: Play again button
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再玩一次按钮
- en: Opening screen
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开场画面
- en: 'Our game needs an opening screen for a few reasons. First of all, we don''t
    want the game to start as soon as the user loads up the web page. There are a
    lot of reasons the user may load up the web page and not start playing the instant
    the web page has completely loaded. If they are on a slow connection, they may
    turn away from the computer while the game is loading up and may not notice the
    second it loads. If they reached this page by clicking a link, they might not
    be prepared to start playing the instant the game loads. It is also good practice
    in general to have something the player must do to acknowledge they are ready
    before throwing them into gameplay. The opening screen should also include some
    instructions for basic gameplay. Arcade games have a long history of putting simple
    instructions on the cabinet to tell the player what they must do to play the game.
    Famously, the game Pong came with the instructions *Avoid missing ball for high
    score* printed on the cabinet. Unfortunately, we do not have an arcade cabinet
    to print our instructions on, so using the opening game screen is the next best
    thing. We will also need a button that will allow the user to begin playing the
    game when they click it, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏需要一个开场画面，原因有几个。首先，我们不希望用户加载网页后立即开始游戏。用户加载网页并不立即开始玩游戏有很多原因。如果他们的连接速度慢，他们可能在游戏加载时离开电脑，可能不会注意到游戏加载完成的那一刻。如果他们通过点击链接来到这个页面，他们可能还没有准备好在游戏加载完成后立即开始玩。在将玩家投入游戏之前，让玩家确认他们已经准备好是一个很好的做法。开场画面还应包括一些基本游戏玩法的说明。街机游戏在街机柜上放置简单的说明，告诉玩家他们必须做什么才能玩游戏。众所周知，游戏Pong在柜子上印有说明*避免错过球以获得高分*。不幸的是，我们没有街机柜来打印我们的说明，所以使用开场游戏画面是下一个最好的选择。我们还需要一个按钮，让用户在点击时开始玩游戏，如下所示：
- en: '![](img/d514eacc-d959-427c-96d8-92bff06984f1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d514eacc-d959-427c-96d8-92bff06984f1.png)'
- en: 'Figure 14.2: Opening screen image'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：开场画面图像
- en: Play screen
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏画面
- en: 'The play screen is the screen we have always had. It is the screen where the
    player moves their spaceship around, trying to destroy the enemy spaceship. We
    may not need to change how this screen works, but we will need to add transitions
    to and from this screen based on the game state. The game will need to transition
    to our play screen from the opening screen when the player clicks a button. The
    player will also need to transition from the screen to the game over screen if
    either of the ships are destroyed. This is shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏画面是我们一直拥有的画面。这是玩家在其中移动他们的太空飞船，试图摧毁敌人飞船的画面。我们可能不需要改变这个画面的工作方式，但我们需要根据游戏状态添加到这个画面的过渡。游戏需要在玩家点击按钮时从开场画面过渡到我们的游戏画面。如果任何一艘飞船被摧毁，玩家还需要从这个画面过渡到游戏结束画面。如下所示：
- en: '![](img/2a9a73da-59ea-4d7f-9456-4c7faace707d.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a9a73da-59ea-4d7f-9456-4c7faace707d.png)'
- en: 'Figure 14.3: The original screen is now the play screen'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：原始画面现在是游戏画面
- en: Game over screen
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束画面
- en: 'If one of the spaceships is destroyed, the game is over. If the player''s ship
    is destroyed, then the player loses the game. If the enemy ship is destroyed,
    then the player wins the game. The *game over screen* lets us know that the game
    is over and tells us if the player has won or lost. It also needs to provide a
    button that allows our player to play the game again if they would like to. The
    game over screen is shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一艘飞船被摧毁，游戏就结束了。如果玩家的飞船被摧毁，那么玩家就输了游戏。如果敌人的飞船被摧毁，那么玩家就赢了游戏。*游戏结束画面*告诉我们游戏结束了，并告诉我们玩家是赢了还是输了。它还需要提供一个按钮，让我们的玩家如果愿意的话可以再次玩游戏。游戏结束画面如下所示：
- en: '![](img/d1ba8bf3-352c-4a1c-9774-b335856ee951.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1ba8bf3-352c-4a1c-9774-b335856ee951.png)'
- en: 'Figure 14.4: Game over screen'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：游戏结束画面
- en: Mouse input
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标输入
- en: 'Before we can implement a button, we need to learn how to use mouse input in
    SDL. The code we used to get the keyboard input is in our `main.cpp` file. Inside
    the `input` function, you will find a call to `SDL_PollEvent`, followed by a few
    different switch statements. The first switch statements check the `event.type`
    for `SDL_KEYDOWN`. The second switch checks `event.key.keysym.sym` to see which
    key we pressed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现按钮之前，我们需要学习如何在SDL中使用鼠标输入。我们用来获取键盘输入的代码在我们的`main.cpp`文件中。在`input`函数内，您会找到对`SDL_PollEvent`的调用，然后是几个不同的switch语句。第一个switch语句检查`event.type`是否为`SDL_KEYDOWN`。第二个switch检查`event.key.keysym.sym`来查看我们按下了哪个键：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we are looking for mouse input, we need to use the same `SDL_PollEvent`
    function to retrieve our mouse events. The three mouse events we are concerned
    with are `SDL_MOUSEMOTION`, `SDL_MOUSEBUTTONDOWN`, and `SDL_MOUSEBUTTONUP`. Once
    we know the kind of mouse event we are dealing with, we can use `SDL_GetMouseState`
    to find the `x` and `y` coordinates of our mouse when the event occurs:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们寻找鼠标输入时，我们需要使用相同的`SDL_PollEvent`函数来检索我们的鼠标事件。我们关心的三个鼠标事件是`SDL_MOUSEMOTION`，`SDL_MOUSEBUTTONDOWN`和`SDL_MOUSEBUTTONUP`。一旦我们知道我们正在处理的鼠标事件的类型，我们就可以使用`SDL_GetMouseState`来找到鼠标事件发生时的`x`和`y`坐标：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we can receive mouse input, let's create a simple user interface button.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以接收鼠标输入，让我们创建一个简单的用户界面按钮。
- en: Creating a button
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个按钮
- en: 'Now that we know how to capture mouse input in WebAssembly using SDL, we can
    use this knowledge to create a button that can be clicked by a mouse. The first
    thing we will need to do is create a `UIButton` class definition inside of the
    `game.hpp` file. Our button will have more than one sprite texture associated
    with it. Buttons usually have a hover state and a clicked state, so we will want
    to display an alternative version of our sprite if the user is hovering the mouse
    cursor over the button, or has clicked the button:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何在WebAssembly中使用SDL捕获鼠标输入，我们可以利用这些知识创建一个可以被鼠标点击的按钮。我们需要做的第一件事是在`game.hpp`文件中创建一个`UIButton`类定义。我们的按钮将有多个与之关联的精灵纹理。按钮通常有悬停状态和点击状态，因此如果用户将鼠标悬停在按钮上或点击按钮，我们将希望显示我们精灵的另一个版本：
- en: '![](img/647d63a3-ca68-451a-9781-0dd05a7f5597.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/647d63a3-ca68-451a-9781-0dd05a7f5597.png)'
- en: 'Figure 14.5: Button states'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：按钮状态
- en: 'To capture these events, we will need functions to detect whether the mouse
    has clicked on our button or hovered over it. Here is what our class definition
    looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获这些事件，我们将需要函数来检测鼠标是否点击了我们的按钮或悬停在其上。以下是我们类定义的样子：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first three attributes are button state attributes that tell our render
    function what sprite to draw, or if the button is inactive, not to draw anything.
    The `m_Hover` attribute will cause our renderer to draw `m_HoverTexture` if it
    is `true`. The `m_Click` attribute will cause our renderer to draw `m_ClickTexture`
    if it is `true`. Finally, `m_Active`, if set to `false`, will cause our renderer
    not to draw anything.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个属性是按钮状态属性，告诉我们的渲染函数要绘制什么精灵，或者如果按钮处于非活动状态，则不要绘制任何内容。如果`m_Hover`属性为`true`，则会导致我们的渲染器绘制`m_HoverTexture`。如果`m_Click`属性为`true`，则会导致我们的渲染器绘制`m_ClickTexture`。最后，如果将`m_Active`设置为`false`，则会导致我们的渲染器不绘制任何内容。
- en: 'The following line is a function pointer to our callback:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行是指向我们回调函数的函数指针：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function pointer is set in our constructor and is the function that we
    call whenever someone clicks on the button. After the function pointer, we have
    our destination rectangle, which will have the location, width, and height of
    the button image file after the constructor runs:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数指针在我们的构造函数中设置，是我们在有人点击按钮时调用的函数。在函数指针之后，我们有我们的目标矩形，它将在构造函数运行后具有按钮图像文件的位置、宽度和高度：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we have three textures. These textures are used to draw an image to our
    canvas and chosen during the render, based on the state flags we discussed earlier:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有三个纹理。这些纹理用于根据我们之前讨论的状态标志在渲染时绘制图像：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we have the constructor function. This function takes in the `x` and
    `y` screen coordinates of our button. After that, there are three strings, which
    are the locations of the three PNG files we will use to load our textures. The
    last parameter is a pointer to the callback function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有构造函数。此函数获取我们按钮的`x`和`y`屏幕坐标。之后，有三个字符串，它们是我们将用来加载纹理的三个PNG文件的位置。最后一个参数是回调函数的指针：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, there are the three functions we will need to call after we call `SDL_PollEvent`,
    based on the current state of the mouse:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据鼠标的当前状态，我们将需要在调用`SDL_PollEvent`之后调用三个函数：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `KeyDown` function will take a key code if a key is pressed, and if the
    key code matches our hotkey, we would like to use it as an alternative to clicking
    the button with the mouse:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyDown`函数将在按下键时获取键码，如果键码与我们的热键匹配，我们希望将其用作使用鼠标点击按钮的替代方法：'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `RenderUI` function is similar to the `Render` functions we''ve created
    for other objects. The difference between `RenderUI` and `Render` is that the
    `Render` function will take the camera position into account when rendering a
    sprite to the screen. The `RenderUI` function will always render in canvas space:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderUI`函数类似于我们为其他对象创建的`Render`函数。`RenderUI`和`Render`之间的区别在于，当将精灵渲染到屏幕时，`Render`函数将考虑摄像机位置。`RenderUI`函数将始终在画布空间中进行渲染：'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the next section, we will create user interface state information to track
    the current screen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建用户界面状态信息以跟踪当前屏幕。
- en: Screen states
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕状态
- en: 'Before we begin adding new screens to our game, we will need to create some
    screen states. We will do most of the management of these states from within the
    `main.cpp` file. Different screen states will require different input, will run
    different logic, and different render functions. We will manage all of this at
    the highest level of our code as functions called by our game loop. We will define
    a list of possible states from within the `game.hpp` file as an enumeration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向游戏添加新屏幕之前，我们需要创建一些屏幕状态。我们将在`main.cpp`文件中管理这些状态的大部分内容。不同的屏幕状态将需要不同的输入，将运行不同的逻辑和不同的渲染函数。我们将在我们代码的最高级别管理所有这些，作为我们游戏循环调用的函数。我们将在`game.hpp`文件中作为枚举定义可能的状态列表：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You may notice that even though there will only be three different screens,
    we have a total of five different screen states. `START_SCREEN` and `PLAY_SCREEN`
    are the start screen and play screen respectively. The `PLAY_TRANSITION` state
    transitions the screens between `START_SCREEN` and `PLAY_SCREEN` by fading in
    the gameplay instead of having an abrupt switch to play. We will use two different
    states for our game over screen. These states are `GAME_OVER_SCREEN` and `YOU_WIN_SCREEN`.
    The only difference between these two states is the message that's displayed when
    the game is over.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，即使只有三个不同的屏幕，我们总共有五种不同的屏幕状态。`START_SCREEN`和`PLAY_SCREEN`分别是开始屏幕和播放屏幕。`PLAY_TRANSITION`状态通过淡入游戏来在`START_SCREEN`和`PLAY_SCREEN`之间过渡屏幕，而不是突然切换到播放。我们将为游戏结束屏幕使用两种不同的状态。这些状态是`GAME_OVER_SCREEN`和`YOU_WIN_SCREEN`。这两种状态之间唯一的区别是游戏结束时显示的消息。
- en: Changes to games.hpp
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对games.hpp的更改
- en: 'There are a few additional changes we will need to make to our `game.hpp` file.
    In addition to our `UIButton` class, we will need to add a `UISprite` class definition
    file. The `UISprite` is just a plain, ordinary image drawn in canvas space. It
    will not have any functionality on top of just being a sprite rendered as a UI
    element. Here is what the definition looks like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要对我们的`game.hpp`文件进行一些额外的更改。除了我们的`UIButton`类，我们还需要添加一个`UISprite`类定义文件。`UISprite`只是一个普通的在画布空间中绘制的图像。它除了作为UI元素呈现的精灵之外，不具有任何功能。定义如下：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Like the button, it has an active state that''s represented by the `m_Active`
    attribute. If this value is false, the sprite will not render. It also has a sprite
    texture and a destination attribute that tells the renderer what to draw and where
    to draw it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与按钮类似，它具有一个由`m_Active`属性表示的活动状态。如果此值为false，则精灵将不会渲染。它还具有精灵纹理和目标属性，告诉渲染器要绘制什么以及在哪里绘制它：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It has a simple constructor that takes in the `x` and `y` coordinates where
    we will render the sprite on the canvas, and the file name of the image in the
    virtual filesystem from which we will load the sprite:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个简单的构造函数，接受我们将在画布上呈现精灵的`x`和`y`坐标，以及虚拟文件系统中图像的文件名，我们将从中加载精灵：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, it has a render function called `RenderUI` that will render the sprite
    to the canvas:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它有一个名为`RenderUI`的渲染函数，将精灵呈现到画布上：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Modifying the RenderManager class
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改RenderManager类
- en: The `RenderManager` class will need a new attribute and a new function. In previous
    versions of our game, we had one type of background that we could render, and
    that was our scrolling starfield. When we render our start screen, I would like
    to use a new custom background that includes some instructions for how to play
    the game.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderManager`类将需要一个新属性和一个新函数。在我们游戏的先前版本中，我们可以呈现一种类型的背景，那就是我们的滚动星空。当我们呈现我们的开始屏幕时，我想使用一个包含一些游戏玩法说明的新自定义背景。'
- en: 'Here is the new version of the `RenderManager` class definition:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`RenderManager`类定义的新版本：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have added a new `SDL_Texture`, which we will use to render the background
    image in the start screen:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的`SDL_Texture`，我们将使用它在开始屏幕上呈现背景图像：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In addition to the new attribute, we have added a new function to render that
    image when the start screen is active:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新属性之外，我们还添加了一个新函数，在开始屏幕激活时呈现该图像：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The alpha value that's passed into this function will be used to fade out the
    start screen during the `PLAY_TRANSITION` screen state. That transition state
    will begin when the player clicks the "Play" button and will last for about a
    second.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 传入此函数的alpha值将用于在“PLAY_TRANSITION”屏幕状态期间淡出开始屏幕。该过渡状态将在玩家点击“播放”按钮时开始，并持续约一秒钟。
- en: New external variables
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的外部变量
- en: 'We need to add three new `extern` variable definitions that will reference
    variables we declare in the `main.cpp` file. Two of these variables are pointers
    to `UISprite` objects, and one of these variables is a pointer to a `UIButton`.
    Here are the three `extern` definitions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加三个新的`extern`变量定义，这些变量将引用我们在`main.cpp`文件中声明的变量。其中两个变量是指向`UISprite`对象的指针，其中一个变量是指向`UIButton`的指针。以下是三个`extern`定义：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use these two `UISprite` pointers in the game over screen. The first, `you_win_sprite`,
    is the sprite that will be displayed when the player wins the game. The second
    sprite, `game_over_sprite`, is the sprite that will be displayed when the player
    loses. The final variable, `play_btn`, is the play button that will be displayed
    on the start screen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在游戏结束屏幕上使用这两个`UISprite`指针。第一个`you_win_sprite`是玩家赢得游戏时将显示的精灵。第二个精灵`game_over_sprite`是玩家失败时将显示的精灵。最后一个变量`play_btn`是在开始屏幕上显示的播放按钮。
- en: Changes to main.cpp
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对main.cpp的更改
- en: We manage the new screen states from within our game loop. Because of this,
    we will make most of the changes in the `main.cpp` file. We will need to break
    the `input` function up into three new functions, one for each of our game screens.
    We will need to break our `render` function into `start_render` and `play_render`
    functions. We don't need an `end_render` function because we will continue to
    use the `play_render` function when the end screen is displayed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从游戏循环内管理新的屏幕状态。因此，我们将在`main.cpp`文件中进行大部分更改。我们需要将`input`函数分解为三个新函数，分别用于我们的游戏屏幕中的每一个。我们需要将我们的`render`函数分解为`start_render`和`play_render`函数。我们不需要`end_render`函数，因为在显示结束屏幕时，我们将继续使用`play_render`函数。
- en: We will also need a function to display the transition between the start screen
    and the play screen. Inside of the game loop, we will need to add logic to perform
    different loop logic based on the current screen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来显示开始屏幕和游戏屏幕之间的过渡。在游戏循环内，我们需要添加逻辑以根据当前屏幕执行不同的循环逻辑。
- en: Adding global variables
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加全局变量
- en: 'The first change we need to make to our `main.cpp` file is to add new global
    variables. We will need new global variables for our user interface sprites and
    buttons. We will need a new global variable to represent the current screen state,
    the transition time between states, and a flag telling us if the player has won
    the game. Here are the new global variables we need in the `main.cpp` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`main.cpp`文件进行的第一个更改是添加新的全局变量。我们将需要新的全局变量来表示我们的用户界面精灵和按钮。我们将需要一个新的全局变量来表示当前屏幕状态，状态之间的过渡时间，以及告诉我们玩家是否赢得了游戏的标志。以下是我们在`main.cpp`文件中需要的新全局变量：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first two variables are `UIButton` object pointers. The first is `play_btn`,
    which is the start screen button that the user will click to begin playing the
    game. The second is `play_again_btn`, which is a button on the end game screen
    the player can click to restart the game. After the UIButtons, we have two `UISprite`
    objects:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个变量是`UIButton`对象指针。第一个是`play_btn`，这是用户将点击以开始玩游戏的开始屏幕按钮。第二个是`play_again_btn`，这是玩家可以点击以重新开始游戏的游戏结束屏幕上的按钮。在UIButtons之后，我们有两个`UISprite`对象：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These are the sprites that are displayed on the end game screen. Which sprite
    is displayed depends on whether or not the player destroyed the enemy ship or
    vice versa. After those sprites, we have a `SCREEN_STATE` variable, which is used
    to track the current screen state:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是显示在游戏结束屏幕上的精灵。显示哪个精灵取决于玩家是否摧毁了敌舰还是相反。在这些精灵之后，我们有一个`SCREEN_STATE`变量，用于跟踪当前屏幕状态：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `transition_time` variable is used to keep track of the amount of time left
    in the transition state between the start screen and the play screen. The `you_win`
    flag is set when the game is over and is used to keep track of who won the game.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`transition_time`变量用于跟踪开始屏幕和游戏屏幕之间过渡状态中剩余的时间量。`you_win`标志在游戏结束时设置，并用于跟踪谁赢得了游戏。'
- en: Input functions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入函数
- en: 'The previous version of our game had a single `input` function that used `SDL_PollEvent`
    to poll for key presses. In this version, we want an input function for each of
    the three screen states. The first thing we should do is rename the original `input`
    function `play_input`. This will no longer be a universal input function, – it
    will only perform the input functionality for the play screen. Now that we have
    renamed our original input function, let''s define the input function for our
    start screen and call it `start_input`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的先前版本有一个单一的`input`函数，它使用`SDL_PollEvent`来轮询按键。在这个版本中，我们希望为三个屏幕状态中的每一个都有一个输入函数。我们应该做的第一件事是将原始的`input`函数重命名为`play_input`。这将不再是一个通用的输入函数，它只会执行游戏屏幕的输入功能。现在我们已经重命名了原始的输入函数，让我们定义开始屏幕的输入函数并称之为`start_input`：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Like our `play_input` function, the `start_input` function will be making a
    call to `SDL_PollEvent`. In addition to checking `SDL_KEYDOWN` to determine whether
    a key was pressed, we will also be checking three mouse events: `SDL_MOUSEMOTION`,
    `SDL_MOUSEBUTTONDOWN`, and `SDL_MOUSEBUTTONUP`. When checking for those mouse
    events, we will call the `play_btn` functions based on the `SDL_GetMouseState`
    values we retrieve. A mouse event will trigger the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`play_input`函数一样，`start_input`函数将调用`SDL_PollEvent`。除了检查`SDL_KEYDOWN`来确定是否按下了键，我们还将检查三个鼠标事件：`SDL_MOUSEMOTION`，`SDL_MOUSEBUTTONDOWN`和`SDL_MOUSEBUTTONUP`。在检查这些鼠标事件时，我们将根据我们检索到的`SDL_GetMouseState`值来调用`play_btn`函数。鼠标事件将触发以下代码：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If `event.type` was `SDL_MOUSEMOTION`, we create `x_val` and `y_val` integer
    variables and use a call to `SDL_GetMouseState` to retrieve the `x` and `y` coordinates
    of our mouse cursor. We then call `play_btn->MouseMove(x_val, y_val)`. This passes
    the mouse x and y coordinates to the play button, which uses those values to determine
    whether the button is in a hover state. We do something similar if `event.type`
    is `SDL_MOUSEBUTTONDOWN`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`event.type`是`SDL_MOUSEMOTION`，我们创建`x_val`和`y_val`整数变量，并使用`SDL_GetMouseState`来检索鼠标光标的`x`和`y`坐标。然后我们调用`play_btn->MouseMove(x_val,
    y_val)`。这将鼠标x和y坐标传递给播放按钮，按钮使用这些值来确定按钮是否处于悬停状态。如果`event.type`是`SDL_MOUSEBUTTONDOWN`，我们会做类似的事情：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If the mouse button is pressed, we look inside of `event.button.button` to see
    if the button that was clicked was the left mouse button. If it is, we use `x_val`
    and `y_val` in combination with `SDL_GetMouseState` to find the mouse cursor position.
    We use those values to call `play_btn->MouseClick(x_val, y_val)`. The `MouseClick`
    function will determine whether the button click fell within the button and if
    so, it will call the button's callback function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标按钮被按下，我们会查看`event.button.button`来确定被点击的按钮是否是左鼠标按钮。如果是，我们将使用`x_val`和`y_val`与`SDL_GetMouseState`结合来找到鼠标光标的位置。我们使用这些值来调用`play_btn->MouseClick(x_val,
    y_val)`。`MouseClick`函数将确定按钮点击是否落在按钮内，如果是，它将调用按钮的回调函数。
- en: 'The code that executes when the event is `SDL_MOUSEBUTTONUP` is very similar
    to `SDL_MOUSEBUTTONDOWN`, with the exception that it calls `play_btn->MouseUp`
    instead of `play_btn->MouseClick`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件是`SDL_MOUSEBUTTONUP`时执行的代码与`SDL_MOUSEBUTTONDOWN`非常相似，唯一的区别是它调用`play_btn->MouseUp`而不是`play_btn->MouseClick`：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In addition to the mouse events, we will be passing keyboard events to our
    button. This is done so that we can create a hotkey that will trigger the callback:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了鼠标事件，我们还将把键盘事件传递给我们的按钮。这样做是为了我们可以创建一个热键来触发回调函数：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The end_input function
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束输入函数
- en: 'After the `start_input` function, we will define the `end_input` function.
    The `end_input` function is very similar to the `start_input` function. The only
    significant difference is that the `play_btn` object is replaced by the `play_again_btn`
    object, which will have a different callback and SDL texture associated with it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start_input`函数之后，我们将定义`end_input`函数。`end_input`函数与`start_input`函数非常相似。唯一的显著区别是`play_btn`对象被`play_again_btn`对象替换，它将有一个不同的回调和与之关联的SDL纹理：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The render functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染函数
- en: 'In previous versions of our game, we had a single render function. Now, we
    must have a render function for both our start screen and our play screen. The
    existing renderer will become our new play screen renderer, so we must rename
    the `render` function `play_render`. We also need to add a rendering function
    for our start screen called `start_render`. This function will render our new
    background and `play_btn`. Here is the code for `start_render`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们游戏的先前版本中，我们有一个单一的渲染函数。现在，我们必须为我们的开始屏幕和游戏屏幕分别设置渲染函数。现有的渲染器将成为我们新的游戏屏幕渲染器，因此我们必须将`render`函数重命名为`play_render`。我们还需要为我们的开始屏幕添加一个名为`start_render`的渲染函数。这个函数将渲染我们的新背景和`play_btn`。以下是`start_render`的代码：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The collisions function
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞函数
- en: 'There will need to be some minor modifications to the `collisions()` function.
    When a player ship or an enemy ship gets destroyed, we will need to change the
    current screen to the game over screen. Depending on which ship gets destroyed,
    we will either need to change it to the win screen or the lose screen. Here is
    the new version of our collisions function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`collisions()`函数需要进行一些小的修改。当玩家飞船或敌人飞船被摧毁时，我们需要将当前屏幕更改为游戏结束屏幕。根据哪艘飞船被摧毁，我们将需要将其更改为胜利屏幕或失败屏幕。以下是我们碰撞函数的新版本：'
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will notice that every line where the player is destroyed, there is a call
    to `player->m_Explode->Run()`. We now follow that line with a call to `current_screen
    = GAME_OVER_SCREEN` to set the screen to the player lose screen. Another way we
    could have done this is by adding a function to the `Ship` class, which runs both
    the explosion animation and sets the game screen, but I chose to modify fewer
    files by making the change inside of the `main` function. If we were using this
    project for more than demonstration purposes, I probably would have done it the
    other way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到每次玩家被销毁时，都会调用`player->m_Explode->Run()`。现在我们会在这行代码后面调用`current_screen =
    GAME_OVER_SCREEN`，将屏幕设置为玩家失败画面。我们还可以通过向`Ship`类添加一个函数来完成此操作，该函数既运行爆炸动画又设置游戏画面，但我选择通过在`main`函数内部进行更改来修改更少的文件。如果我们将此项目用于除演示目的之外的其他用途，我可能会选择另一种方式。
- en: 'The other changes we have made to collisions are similar. Whenever an enemy
    was destroyed by running the `enemy->m_Explode->Run()` function, we followed it
    with a line that set the current screen to the "you win" screen, like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对碰撞所做的其他更改类似。每当敌人被`enemy->m_Explode->Run()`函数销毁时，我们会跟着一行代码将当前画面设置为“你赢了”画面，就像这样：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The transition state
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过渡状态
- en: 'A sudden transition from the start screen into gameplay can be a little jarring.
    To make the transition smoother, we will create a transition function called `draw_play_transition`,
    which will use an alpha fade to transition our screen from the start screen to
    the gameplay screen. Here is what that function looks like:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从开始画面突然过渡到游戏画面可能有点令人不适。为了使过渡更加平滑，我们将创建一个名为`draw_play_transition`的过渡函数，它将使用alpha淡入淡出来将我们的画面从开始画面过渡到游戏画面。该函数如下所示：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function uses the `transition_time` global variable we created earlier
    and subtracts the time in milliseconds since the last frame. It uses that value
    divided by 4 as the alpha value when drawing the start screen background to fade
    it out as it transitions to the gameplay. When the transition time drops below
    0, we set the current screen to the play screen. When the transition begins, we
    set `transition_time` to 1,020 milliseconds, which is a bit more than a second.
    Dividing that value by 4 gives us a value that transitions from 255 (full opacity)
    to 0 (full transparency).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用我们之前创建的`transition_time`全局变量，并减去自上一帧以来的毫秒数。它使用该值除以4作为alpha值，用于绘制开始画面背景，使其在过渡到游戏画面时淡出。当过渡时间降至0以下时，我们将当前画面设置为播放画面。过渡开始时，我们将`transition_time`设置为1,020毫秒，稍多于一秒。将该值除以4会得到一个从255（完全不透明）到0（完全透明）的值。
- en: The game loop
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: 'The `game_loop` function will need to be modified to perform different logic
    for each screen. Here is what the new version of the game loop will look like:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`game_loop`函数将需要修改以执行每个画面的不同逻辑。以下是游戏循环的新版本：'
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have new branching logic that branches based on the current screen. The
    first `if` block runs if the current screen is the start screen. It runs the `start_input`
    and `start_render` functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有新的分支逻辑，根据当前画面进行分支。第一个`if`块在当前画面是开始画面时运行`start_input`和`start_render`函数：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The play screen and the play transition have the same logic as the original
    game loop, except for the `if` block around `PLAY_TRANSITION` at the end of this
    block of code. This draws the play transition by calling the `draw_play_transition()`
    function that we defined earlier:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏画面和游戏过渡与原始游戏循环逻辑相同，除了代码块末尾的`PLAY_TRANSITION`周围的`if`块。这通过调用我们之前定义的`draw_play_transition()`函数来绘制游戏过渡：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The final block of code in the function is for the game over screen. It will
    render `you_win_sprite` if the current screen is `YOU_WIN_SCREEN` and will render
    `game_over_sprite` if the current screen is `GAME_OVER_SCREEN`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的最后一块代码是游戏结束画面。如果当前画面是`YOU_WIN_SCREEN`，它将渲染`you_win_sprite`，如果当前画面是`GAME_OVER_SCREEN`，它将渲染`game_over_sprite`：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Play and play again callbacks
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放和再玩一次回调
- en: 'After our changes to the game loop, we need to add some callback functions
    for our buttons. The first of these functions is the `play_click` function. This
    is the callback that runs when the player clicks the play button on the start
    screen. This function will set the current screen to the play transition and set
    the transition time to 1,020 milliseconds:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在对游戏循环进行更改后，我们需要为我们的按钮添加一些回调函数。其中之一是`play_click`函数。这是当玩家在开始画面上点击播放按钮时运行的回调。此函数将当前画面设置为播放过渡，并将过渡时间设置为1,020毫秒：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, we will define the `play_again_click` callback. This function runs
    when the player clicks the play again button on the game over screen. Because
    this is a web game, we will use a little trick to simplify this logic. In a game
    written for almost any other platform, you would need to create some reinitialization
    logic that would have to go back through your game and reset the state of everything.
    We are going to *cheat* by simply reloading the web page using JavaScript:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将定义`play_again_click`回调。当玩家在游戏结束画面上点击再玩一次按钮时，此函数将运行。因为这是一个网络游戏，我们将使用一个小技巧来简化这个逻辑。在几乎任何其他平台上编写的游戏中，您需要创建一些重新初始化逻辑，需要回到游戏中并重置所有内容的状态。我们将通过使用JavaScript简单地重新加载网页来*作弊*：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This cheat won't work for all games. Reloading some games would cause unacceptable
    delays. For some games, there may be too much state information that we need to
    keep. However, for this game, reloading the page is a quick and easy way to get
    the job done.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种作弊方法并不适用于所有游戏。重新加载某些游戏会导致无法接受的延迟。对于某些游戏，可能有太多的状态信息需要保留。但是，对于这个游戏，重新加载页面是一个快速简单的方法来完成任务。
- en: Changes to the main function
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数的更改
- en: We use the `main` function in our application to perform all of the game initialization.
    This is where we will need to add some code to initialize the sprites we will
    use on our game over screen and our new buttons.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中使用`main`函数来执行所有游戏初始化。这是我们需要添加一些代码来初始化游戏结束画面和新按钮所使用的精灵的地方。
- en: 'In the following code snippet, we have our new sprite initialization lines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们有我们的新精灵初始化行：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can see that we are setting the `game_over_sprite` coordinates and the
    `you_win_sprite` coordinates to `400, 300`. That will place these sprites in the
    center of the screen. We are setting both sprites to be active because they will
    only be rendered on the end game screen anyway. Later in the code, we will call
    the constructors for our `UIButton` objects:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们将`game_over_sprite`坐标和`you_win_sprite`坐标设置为`400, 300`。这将使这些精灵位于屏幕中央。我们设置两个精灵都处于活动状态，因为它们只会在游戏结束屏幕上呈现。在代码的后面，我们将调用我们的`UIButton`对象的构造函数：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This places both of these buttons at `400, 500`, centered on the x-axis, but
    near the bottom of the game screen on the y-axis. The callbacks are set to `play_click`
    and `play_again_click`, which we defined earlier. Here is what the entire `main`
    function looks like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将两个按钮都放置在`400, 500`，在x轴上居中，但靠近游戏屏幕底部的y轴。回调设置为`play_click`和`play_again_click`，我们之前定义过。以下是整个`main`函数的样子：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the next section, we will define functions in our `ui_button.cpp` file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将在我们的`ui_button.cpp`文件中定义函数。
- en: ui_button.cpp
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ui_button.cpp
- en: The `UIButton` object has several functions that must be defined. We have created
    a new `ui_button.cpp` file that will hold all of these new functions. We will
    need to define a constructor, as well as `MouseMove`, `MouseClick`, `MouseUp`,
    `KeyDown`, and `RenderUI`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIButton`对象有几个必须定义的函数。我们创建了一个新的`ui_button.cpp`文件，将保存所有这些新函数。我们需要定义一个构造函数，以及`MouseMove`、`MouseClick`、`MouseUp`、`KeyDown`和`RenderUI`。'
- en: 'First, we will include our `game.hpp` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将包括我们的`game.hpp`文件：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we will define our constructor function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义我们的构造函数：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The constructor function starts by setting the callback function from the passed
    in parameter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数从传入的参数设置回调函数开始：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, it sets the `m_dest` rectangle''s `x` and `y` coordinates from the parameters
    we passed in:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它从我们传递的参数设置了`m_dest`矩形的`x`和`y`坐标：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After that, it loads three different image files into three different textures
    for the button, the button''s hover state, and the button''s clicked state:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它将三个不同的图像文件加载到三个不同的纹理中，用于按钮、按钮的悬停状态和按钮的点击状态：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code should look pretty familiar because loading an image file
    into an `SDL_Texture` object is something we have done a lot at this point. After
    that, we use the width and height values we queried earlier to center the destination
    rectangle:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该看起来很熟悉，因为在这一点上，将图像文件加载到`SDL_Texture`对象中是我们经常做的事情。之后，我们使用之前查询的宽度和高度值来居中目标矩形：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we set our hover, click, and active state flags:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置悬停、点击和活动状态标志：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The MouseMove function
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MouseMove功能
- en: 'We need a function to determine whether the mouse cursor has been moved to
    hover over our button. We call the `MouseMove` function from our input function,
    and we pass in the current mouse cursor `x` and `y` coordinates. We check these
    coordinates against our `m_dest` rectangle to see if they overlap. If so, we set
    our hover flag to `true`. If not, we set the hover flag to `false`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个函数来确定鼠标光标是否移动到我们的按钮上。我们从我们的输入函数中调用`MouseMove`函数，并传入当前鼠标光标的`x`和`y`坐标。我们检查这些坐标是否与我们的`m_dest`矩形重叠。如果是，我们将悬停标志设置为`true`。如果不是，我们将悬停标志设置为`false`：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The MouseClick function
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MouseClick功能
- en: 'The `MouseClick` function is very similar to the `MouseMove` function. It is
    also called from our input function when the user presses the left mouse button.
    The `x` and `y` coordinates of the mouse cursor are passed in, and the function
    uses the `m_dest` rectangle to see if the mouse cursor was over the button when
    it was clicked. If it was, we set the click flag to `true`. If not, we set the
    click flag to `false`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseClick`函数与`MouseMove`函数非常相似。当用户按下鼠标左键时，也会从我们的输入函数中调用。鼠标光标的`x`和`y`坐标被传入，函数使用`m_dest`矩形来查看鼠标光标在点击时是否在按钮上。如果是，我们将单击标志设置为`true`。如果不是，我们将单击标志设置为`false`：'
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The MouseUp function
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标弹起功能
- en: 'When the left mouse button is released, we call this function. No matter what
    the mouse cursor coordinates are, we want to set the click flag to `false`. If
    the mouse was over the button at the time the button was released, and the button
    is clicked, we need to make a call to our callback function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当释放鼠标左键时，我们调用此功能。无论鼠标光标坐标如何，我们都希望将单击标志设置为“false”。如果鼠标在释放按钮时位于按钮上，并且按钮被点击，我们需要调用回调函数：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The KeyDown function
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KeyDown功能
- en: 'I could have made the key down function a little more flexible. It would have
    been better to have the hotkey set to a value that''s set in the object. That
    would have supported more than a single button on a screen. As it is, if someone
    hits the *Enter* key, all the buttons on the screen will be clicked. This is not
    a problem for our game because we aren''t going to have more than one button on
    a screen, but if you want to improve the hotkey functionality, this shouldn''t
    be too difficult. As the function is, it hard codes the key it is checking against
    to `SDLK_RETURN`. Here is the version of the function we have:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以使按键按下功能更加灵活。最好将热键设置为对象中设置的值。这将支持屏幕上不止一个按钮。目前，如果有人按下*Enter*键，屏幕上的所有按钮都将被点击。这对我们的游戏不是问题，因为我们不会在屏幕上放置多个按钮，但是如果您想改进热键功能，这应该不难。因为该函数将其检查的键硬编码为`SDLK_RETURN`。以下是我们的函数版本：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The RenderUI function
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RenderUI功能
- en: 'The `RenderUI` function checks the various state flags in the button and renders
    the correct sprite based on those values. If the `m_Active` flag is `false`, the
    function doesn''t render anything. Here is the function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderUI`函数检查按钮中的各种状态标志，并根据这些值呈现正确的精灵。如果`m_Active`标志为`false`，函数将不呈现任何内容。以下是函数：'
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the next section, we will define functions in our `ui_sprite.cpp` file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将在我们的`ui_sprite.cpp`文件中定义函数。
- en: ui_sprite.cpp
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ui_sprite.cpp
- en: 'The `UISprite` class is pretty simple. It has only two functions: a constructor
    and a rendering function. Like with every other CPP file in our project, the first
    thing we must do is include the `game.hpp` file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`UISprite`类非常简单。它只有两个函数：一个构造函数和一个渲染函数。与项目中的每个其他CPP文件一样，我们必须首先包含`game.hpp`文件：'
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Defining the constructor
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义构造函数
- en: 'The constructor is very familiar. It sets the `m_dest` rectangle''s `x` and
    `y` values to the values that were passed into the constructor. It loads the texture
    from the virtual filesystem using the `file_name` variable that we passed in as
    a parameter. Finally, it centers the `m_dest` rectangle using the width and height
    values that were retrieved using the `SDL_QueryTexture` function. Here is the
    code for the constructor:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数非常熟悉。它将`m_dest`矩形的`x`和`y`值设置为传入构造函数的值。它使用我们传入的`file_name`变量从虚拟文件系统加载纹理。最后，它使用`SDL_QueryTexture`函数检索的宽度和高度值来居中`m_dest`矩形。以下是构造函数的代码：
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The RenderUI function
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RenderUI函数
- en: 'The `RenderUI` function for our sprite is also straightforward. It checks to
    see if the sprite is active, and if it is, calls the render manager''s `RenderUI`
    function. Here is the code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们精灵的`RenderUI`函数也很简单。它检查精灵是否处于活动状态，如果是，则调用渲染管理器的`RenderUI`函数。以下是代码：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Compile ui.html
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译ui.html
- en: 'Now that we have added a user interface to our game, let''s compile it, serve
    it from our web server or emrun, and open it up in a web browser. Here is the
    `em++` command we need to compile our `ui.html` file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的游戏添加了用户界面，让我们编译它，从我们的Web服务器或emrun中提供它，并在Web浏览器中打开它。以下是我们需要编译`ui.html`文件的`em++`命令：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The new version will open to our start screen. If you want to play the game,
    you will now need to click the *Play* button. Here is a screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本将打开到我们的开始屏幕。如果您想玩游戏，现在需要点击*播放*按钮。这是一个截图：
- en: '![](img/af0aed53-ba7c-4980-82e7-52d72d32ed5a.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af0aed53-ba7c-4980-82e7-52d72d32ed5a.png)'
- en: 'Figure 14.6: Opening screen'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：开场画面
- en: You will notice that the *opening screen* has instructions on how to play the
    game. It is usually good to have an opening screen in an action-oriented web game
    because the player isn't always ready to play when the page loads. Not all web
    games need an opening screen. My website, [classicsolitaire.com](https://www.classicsolitaire.com/),
    doesn't have a single one. This is because solitaire is a turn-based game where
    the player isn't thrown into the action right away. The user interface needs of
    your game are likely to be different than the game we are writing for this book.
    So, sketch up a storyboard and take the time to gather requirements. You'll be
    glad you did.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到*开场画面*上有关于如何玩游戏的说明。在面向动作的网络游戏中通常很好有一个开场画面，因为玩家加载页面时并不总是准备好玩。并非所有网络游戏都需要开场画面。我的网站[classicsolitaire.com](https://www.classicsolitaire.com/)没有一个。这是因为纸牌是一种回合制游戏，玩家并不会立即投入行动。您的游戏的用户界面需求可能与我们为本书编写的游戏不同。因此，请绘制一个故事板，并花时间收集需求。您会为此感到高兴的。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we spent some time gathering requirements for our user interface.
    We created a storyboard to help us think through what screens we require for our
    game and how they might look. We discussed the layout for our opening screen,
    and why we need it. We then broke out the screen that had been our entire game
    into the play screen. Then, we discussed the layout of the game over screen and
    what UI elements we required for it and learned how to use SDL to retrieve mouse
    input. We also created a button class as a part of our user interface, as well
    as an enumeration for our screen states and discussed transitions between those
    states. We then added a sprite user interface object, before modifying our render
    manager to allow us to render our start screen's background image. Finally, we
    made changes to our code to support multiple game screens.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们花了一些时间收集用户界面的要求。我们创建了一个故事板，帮助我们思考我们的游戏需要哪些屏幕以及它们可能的外观。我们讨论了开场画面的布局，以及为什么我们需要它。然后，我们将原本是整个游戏的屏幕分解为播放屏幕。然后，我们讨论了游戏结束屏幕的布局以及我们需要的UI元素，并学习了如何使用SDL检索鼠标输入。我们还创建了一个按钮类作为我们用户界面的一部分，以及一个用于我们屏幕状态的枚举，并讨论了这些状态之间的转换。然后，我们添加了一个精灵用户界面对象，然后修改了我们的渲染管理器，以便我们可以渲染开始屏幕的背景图像。最后，我们对代码进行了更改，以支持多个游戏屏幕。
- en: In the next chapter, we will learn how to write new shaders and implement them
    using WebAssembly's OpenGL API.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何编写新的着色器并使用WebAssembly的OpenGL API实现它们。
