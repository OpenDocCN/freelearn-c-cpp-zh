["```cpp\n{\n    \"reference\": \"CLIENT0001\",\n    \"name\": \"Dale Cooper\"\n}\n```", "```cpp\n{\n    \"reference\": \"CLIENT0001\",\n    \"name\": \"Dale Cooper\",\n    \"supplyAddress\": {\n         \"number\": 7,\n        \"name\": \"White Lodge\",\n        \"street\": \"Lost Highway\",\n        \"city\": \"Twin Peaks\",\n        \"postcode\": \"WS119\"\n    },\n    \"billingAddress\": null\n}\n```", "```cpp\n{\n    \"reference\": \"CLIENT0001\",\n    \"name\": \"Dale Cooper\",\n    \"supplyAddress\": {\n        \"number\": 7,\n        \"name\": \"White Lodge\",\n        \"street\": \"Lost Highway\",\n        \"city\": \"Twin Peaks\",\n        \"postcode\": \"WS119\"\n    },\n    \"billingAddress\": null,\n    \"contacts\": [\n        {\n            \"type\": 1,\n            \"address\": \"+12345678\"\n        },\n        {\n            \"type\": 2,\n            \"address\": \"dale.cooper@fbi.com\"\n        }\n    ],\n    \"appointments\": []\n}\n```", "```cpp\n#ifndef DATADECORATOR_H\n#define DATADECORATOR_H\n\n#include <QJsonObject>\n#include <QJsonValue>\n#include <QObject>\n#include <QScopedPointer>\n\n#include <cm-lib_global.h>\n\nnamespace cm {\nnamespace data {\n\nclass Entity;\n\nclass CMLIBSHARED_EXPORT DataDecorator : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY( QString ui_label READ label CONSTANT )\n\npublic:\n    DataDecorator(Entity* parent = nullptr, const QString& key = \n                  \"SomeItemKey\", const QString& label = \"\");\n                                 virtual ~DataDecorator();\n\n    const QString& key() const;\n    const QString& label() const;\n    Entity* parentEntity();\n\n    virtual QJsonValue jsonValue() const = 0;\n    virtual void update(const QJsonObject& jsonObject) = 0;\n\nprivate:\n    class Implementation;\n    QScopedPointer<Implementation> implementation;\n};\n\n}}\n\n#endif\n```", "```cpp\n#include \"data-decorator.h\"\n\nnamespace cm {\nnamespace data {\n\nclass DataDecorator::Implementation\n{\npublic:\n    Implementation(Entity* _parent, const QString& _key, const QString& \n                                                         _label)\n        : parentEntity(_parent)\n        , key(_key)\n        , label(_label)\n    {\n    }\n    Entity* parentEntity{nullptr};\n    QString key;\n    QString label;\n};\n\nDataDecorator::DataDecorator(Entity* parent, const QString& key, const QString& label)\n    : QObject((QObject*)parent)\n{\n    implementation.reset(new Implementation(parent, key, label));\n}\n\nDataDecorator::~DataDecorator()\n{\n}\n\nconst QString& DataDecorator::key() const\n{\n    return implementation->key;\n}\n\nconst QString& DataDecorator::label() const\n{\n    return implementation->label;\n}\n\nEntity* DataDecorator::parentEntity()\n{\n    return implementation->parentEntity;\n}\n\n}}\n```", "```cpp\n#ifndef STRINGDECORATOR_H\n#define STRINGDECORATOR_H\n\n#include <QJsonObject>\n#include <QJsonValue>\n#include <QObject>\n#include <QScopedPointer>\n#include <QString>\n\n#include <cm-lib_global.h>\n#include <data/data-decorator.h>\n\nnamespace cm {\nnamespace data {\n\nclass CMLIBSHARED_EXPORT StringDecorator : public DataDecorator\n{\n    Q_OBJECT\n\n    Q_PROPERTY( QString ui_value READ value WRITE setValue NOTIFY \n               valueChanged )\npublic:\n    StringDecorator(Entity* parentEntity = nullptr, const QString& key = \"SomeItemKey\", const QString& label = \"\", const QString& value = \"\");\n    ~StringDecorator();\n\n    StringDecorator& setValue(const QString& value);\n    const QString& value() const;\n\n    QJsonValue jsonValue() const override;\n    void update(const QJsonObject& jsonObject) override;\n\nsignals:\n    void valueChanged();\n\nprivate:\n    class Implementation;\n    QScopedPointer<Implementation> implementation;\n};\n\n}}\n\n#endif\n```", "```cpp\n#include \"string-decorator.h\"\n\n#include <QVariant>\n\nnamespace cm {\nnamespace data {\n\nclass StringDecorator::Implementation\n{\npublic:\n    Implementation(StringDecorator* _stringDecorator, const QString& \n                                                      _value)\n        : stringDecorator(_stringDecorator)\n        , value(_value)\n    {\n    }\n\n    StringDecorator* stringDecorator{nullptr};\n    QString value;\n};\n\nStringDecorator::StringDecorator(Entity* parentEntity, const QString& key, const QString& label, const QString& value)\n    : DataDecorator(parentEntity, key, label)\n{\n    implementation.reset(new Implementation(this, value));\n}\n\nStringDecorator::~StringDecorator()\n{\n}\n\nconst QString& StringDecorator::value() const\n{\n    return implementation->value;\n}\n\nStringDecorator& StringDecorator::setValue(const QString& value)\n{\n    if(value != implementation->value) {\n        // ...Validation here if required...\n        implementation->value = value;\n        emit valueChanged();\n    }\n    return *this;\n}\n\nQJsonValue StringDecorator::jsonValue() const\n{\n    return QJsonValue::fromVariant(QVariant(implementation->value));\n}\n\nvoid StringDecorator::update(const QJsonObject& _jsonObject)\n{\n    if (_jsonObject.contains(key())) {\n        setValue(_jsonObject.value(key()).toString());\n    } else {\n        setValue(\"\");\n    }\n}\n}}\n```", "```cpp\nQ_PROPERTY( QString ui_iso8601String READ toIso8601String NOTIFY valueChanged )\nQ_PROPERTY( QString ui_prettyDateString READ toPrettyDateString NOTIFY valueChanged )\nQ_PROPERTY( QString ui_prettyTimeString READ toPrettyTimeString NOTIFY valueChanged )\nQ_PROPERTY( QString ui_prettyString READ toPrettyString NOTIFY valueChanged )\n```", "```cpp\nQString DateTimeDecorator::toIso8601String() const\n{\n    if (implementation->value.isNull()) {\n        return \"\";\n    } else {\n        return implementation->value.toString(Qt::ISODate);\n    }\n}\n```", "```cpp\nQString DateTimeDecorator::toPrettyString() const\n{\n    if (implementation->value.isNull()) {\n        return \"Not set\";\n    } else {\n        return implementation->value.toString( \"ddd d MMM yyyy @ HH:mm:ss\" );\n    }\n}\n```", "```cpp\nQString DateTimeDecorator::toPrettyDateString() const\n{\n    if (implementation->value.isNull()) {\n        return \"Not set\";\n    } else {\n        return implementation->value.toString( \"d MMM yyyy\" );\n    }\n}\n\nQString DateTimeDecorator::toPrettyTimeString() const\n{\n    if (implementation->value.isNull()) {\n        return \"Not set\";\n    } else {\n        return implementation->value.toString( \"hh:mm ap\" );\n    }\n}\n```", "```cpp\n#ifndef ENUMERATORDECORATOR_H\n#define ENUMERATORDECORATOR_H\n\n#include <map>\n\n#include <QJsonObject>\n#include <QJsonValue>\n#include <QObject>\n#include <QScopedPointer>\n\n#include <cm-lib_global.h>\n#include <data/data-decorator.h>\n\nnamespace cm {\nnamespace data {\n\nclass CMLIBSHARED_EXPORT EnumeratorDecorator : public DataDecorator\n{\n    Q_OBJECT\n    Q_PROPERTY( int ui_value READ value WRITE setValue NOTIFY \n                                              valueChanged )\n    Q_PROPERTY( QString ui_valueDescription READ valueDescription \n                                             NOTIFY valueChanged )\n\npublic:\n    EnumeratorDecorator(Entity* parentEntity = nullptr, const QString& \n    key = \"SomeItemKey\", const QString& label = \"\", int value = 0,  \n    const std::map<int, QString>& descriptionMapper = std::map<int, \n     QString>());\n    ~EnumeratorDecorator();\n\n    EnumeratorDecorator& setValue(int value);\n    int value() const;\n    QString valueDescription() const;\n\n    QJsonValue jsonValue() const override;\n    void update(const QJsonObject& jsonObject) override;\n\nsignals:\n    void valueChanged();\n\nprivate:\n    class Implementation;\n    QScopedPointer<Implementation> implementation;\n};\n\n}}\n\n#endif\n```", "```cpp\nQString EnumeratorDecorator::valueDescription() const\n{\n    if (implementation->descriptionMapper.find(implementation->value) \n                       != implementation->descriptionMapper.end()) {\n        return implementation->descriptionMapper.at(implementation-\n                                                    >value);\n    } else {\n        return {};\n    }\n}\n```", "```cpp\n#ifndef ENTITY_H\n#define ENTITY_H\n\n#include <map>\n\n#include <QObject>\n#include <QScopedPointer>\n\n#include <cm-lib_global.h>\n#include <data/data-decorator.h>\n\nnamespace cm {\nnamespace data {\n\nclass CMLIBSHARED_EXPORT Entity : public QObject\n{\n    Q_OBJECT\n\npublic:\n    Entity(QObject* parent = nullptr, const QString& key = \n                                                  \"SomeEntityKey\");\n    Entity(QObject* parent, const QString& key, const QJsonObject& \n     jsonObject);\n    virtual ~Entity();\n\npublic:\n    const QString& key() const;\n    void update(const QJsonObject& jsonObject);\n    QJsonObject toJson() const;\n\nsignals:\n    void childEntitiesChanged();\n    void dataDecoratorsChanged();\n\nprotected:\n    Entity* addChild(Entity* entity, const QString& key);\n    DataDecorator* addDataItem(DataDecorator* dataDecorator);\n\nprotected:\n    class Implementation;\n    QScopedPointer<Implementation> implementation;\n};\n\n}}\n\n#endif\n```", "```cpp\n#include \"entity.h\"\n\nnamespace cm {\nnamespace data {\n\nclass Entity::Implementation\n{\npublic:\n    Implementation(Entity* _entity, const QString& _key)\n        : entity(_entity)\n        , key(_key)\n    {\n    }\n    Entity* entity{nullptr};\n    QString key;\n    std::map<QString, Entity*> childEntities;\n    std::map<QString, DataDecorator*> dataDecorators;\n};\n\nEntity::Entity(QObject* parent, const QString& key)\n    : QObject(parent)\n{\n    implementation.reset(new Implementation(this, key));\n}\n\nEntity::Entity(QObject* parent, const QString& key, const QJsonObject& \n               jsonObject) : Entity(parent, key)\n{\n    update(jsonObject);\n}\n\nEntity::~Entity()\n{\n}\n\nconst QString& Entity::key() const\n{\n    return implementation->key;\n}\n\nEntity* Entity::addChild(Entity* entity, const QString& key)\n{\n    if(implementation->childEntities.find(key) == \n        std::end(implementation->childEntities)) {\n        implementation->childEntities[key] = entity;\n        emit childEntitiesChanged();\n    }\n    return entity;\n}\n\nDataDecorator* Entity::addDataItem(DataDecorator* dataDecorator)\n{\n    if(implementation->dataDecorators.find(dataDecorator->key()) == \n       std::end(implementation->dataDecorators)) {\n        implementation->dataDecorators[dataDecorator->key()] = \n        dataDecorator;\n        emit dataDecoratorsChanged();\n    }\n    return dataDecorator;\n}\n\nvoid Entity::update(const QJsonObject& jsonObject)\n{\n    // Update data decorators\n    for (std::pair<QString, DataDecorator*> dataDecoratorPair : \n         implementation->dataDecorators) {\n        dataDecoratorPair.second->update(jsonObject);\n    }\n    // Update child entities\n    for (std::pair<QString, Entity*> childEntityPair : implementation-\n    >childEntities) {childEntityPair.second>update(jsonObject.value(childEntityPair.first).toObject());\n    }\n}\n\nQJsonObject Entity::toJson() const\n{\n    QJsonObject returnValue;\n    // Add data decorators\n    for (std::pair<QString, DataDecorator*> dataDecoratorPair : \n                         implementation->dataDecorators) {\n        returnValue.insert( dataDecoratorPair.first, \n        dataDecoratorPair.second->jsonValue() );\n    }\n    // Add child entities\n    for (std::pair<QString, Entity*> childEntityPair : implementation->childEntities) {\n        returnValue.insert( childEntityPair.first, childEntityPair.second->toJson() );\n    }\n    return returnValue;\n}\n\n}}\n```", "```cpp\n#ifndef ENTITYCOLLECTION_H\n#define ENTITYCOLLECTION_H\n\nnamespace cm {\nnamespace data {\n    class Entity;\n}}\n\n#endif\n```", "```cpp\nclass CMLIBSHARED_EXPORT EntityCollectionObject : public QObject\n{\n    Q_OBJECT\n\npublic:\n    EntityCollectionObject(QObject* _parent = nullptr) : QObject(_parent) {}\n    virtual ~EntityCollectionObject() {}\n\nsignals:\n    void collectionChanged();\n};\n```", "```cpp\nclass EntityCollectionBase : public EntityCollectionObject\n{\npublic:\n    EntityCollectionBase(QObject* parent = nullptr, const QString& key \n                                         = \"SomeCollectionKey\")\n        : EntityCollectionObject(parent)\n        , key(key)\n    {}\n\n    virtual ~EntityCollectionBase()\n    {}\n\n    QString getKey() const\n    {\n        return key;\n    }\n\n    virtual void clear() = 0;\n    virtual void update(const QJsonArray& json) = 0;\n    virtual std::vector<Entity*> baseEntities() = 0;\n\n    template <class T>\n    QList<T*>& derivedEntities();\n\n    template <class T>\n    T* addEntity(T* entity);\n\nprivate:\n    QString key;\n};\n```", "```cpp\ntemplate <typename T>\nclass EntityCollection : public EntityCollectionBase\n{\npublic:\n    EntityCollection(QObject* parent = nullptr, const QString& key = \n             \"SomeCollectionKey\")\n        : EntityCollectionBase(parent, key)\n    {}\n\n    ~EntityCollection()\n    {}\n\n    void clear() override\n    {\n        for(auto entity : collection) {\n            entity->deleteLater();\n        }\n        collection.clear();\n    }\n\n    void update(const QJsonArray& jsonArray) override\n    {\n        clear();\n        for(const QJsonValue& jsonValue : jsonArray) {\n            addEntity(new T(this, jsonValue.toObject()));\n        }\n    }\n\n    std::vector<Entity*> baseEntities() override\n    {\n        std::vector<Entity*> returnValue;\n        for(T* entity : collection) {\n            returnValue.push_back(entity);\n        }\n        return returnValue;\n    }\n\n    QList<T*>& derivedEntities()\n    {\n        return collection;\n    }\n\n    T* addEntity(T* entity)\n    {\n        if(!collection.contains(entity)) {\n            collection.append(entity);\n            EntityCollectionObject::collectionChanged();\n        }\n        return entity;\n    }\n\nprivate:\n    QList<T*> collection;       \n};\n```", "```cpp\ntemplate <class T>\nQList<T*>& EntityCollectionBase::derivedEntities()\n{\n    return dynamic_cast<const EntityCollection<T>&>(*this).derivedEntities();\n}\n\ntemplate <class T>\nT* EntityCollectionBase::addEntity(T* entity)\n{\n    return dynamic_cast<const EntityCollection<T>&>(*this).addEntity(entity);\n}\n```", "```cpp\nvoid childCollectionsChanged(const QString& collectionKey);\n```", "```cpp\nEntityCollectionBase* addChildCollection(EntityCollectionBase* entityCollection);\n```", "```cpp\nstd::map<QString, EntityCollectionBase*> childCollections;\n```", "```cpp\nEntityCollectionBase* Entity::addChildCollection(EntityCollectionBase* entityCollection)\n{\n    if(implementation->childCollections.find(entityCollection- \n     >getKey()) == std::end(implementation->childCollections)) {\n        implementation->childCollections[entityCollection->getKey()] =  \n                                        entityCollection;\n        emit childCollectionsChanged(entityCollection->getKey());\n    }\n    return entityCollection;\n}\n```", "```cpp\nvoid Entity::update(const QJsonObject& jsonObject)\n{\n    // Update data decorators\n    for (std::pair<QString, DataDecorator*> dataDecoratorPair :   \n         implementation->dataDecorators) {\n        dataDecoratorPair.second->update(jsonObject);\n    }\n\n    // Update child entities\n    for (std::pair<QString, Entity*> childEntityPair : implementation- \n       >childEntities) { childEntityPair.second- \n       >update(jsonObject.value(childEntityPair.first).toObject());\n    }\n\n    // Update child collections\n    for (std::pair<QString, EntityCollectionBase*> childCollectionPair \n         : implementation->childCollections) {\n            childCollectionPair.second-\n        >update(jsonObject.value(childCollectionPair.first).toArray());\n    }\n}\n```", "```cpp\nQJsonObject Entity::toJson() const\n{\n    QJsonObject returnValue;\n\n    // Add data decorators\n    for (std::pair<QString, DataDecorator*> dataDecoratorPair : \n        implementation->dataDecorators) {\n        returnValue.insert( dataDecoratorPair.first, \n        dataDecoratorPair.second->jsonValue() );\n    }\n\n    // Add child entities\n    for (std::pair<QString, Entity*> childEntityPair : implementation-\n        >childEntities) {\n        returnValue.insert( childEntityPair.first, \n       childEntityPair.second->toJson() );\n    }\n\n    // Add child collections\n    for (std::pair<QString, EntityCollectionBase*> childCollectionPair \n        : implementation->childCollections) {\n        QJsonArray entityArray;\n            for (Entity* entity : childCollectionPair.second-\n           >baseEntities()) {\n            entityArray.append( entity->toJson() );\n        }\n        returnValue.insert( childCollectionPair.first, entityArray );\n    }\n\n    return returnValue;\n}\n```", "```cpp\n#ifndef ADDRESS_H\n#define ADDRESS_H\n\n#include <QObject>\n\n#include <cm-lib_global.h>\n#include <data/string-decorator.h>\n#include <data/entity.h>\n\nnamespace cm {\nnamespace models {\n\nclass CMLIBSHARED_EXPORT Address : public data::Entity\n{\n    Q_OBJECT\n    Q_PROPERTY(cm::data::StringDecorator* ui_building MEMBER building \n                                                      CONSTANT)\n    Q_PROPERTY(cm::data::StringDecorator* ui_street MEMBER street  \n                                                    CONSTANT)\n    Q_PROPERTY(cm::data::StringDecorator* ui_city MEMBER city CONSTANT)\n    Q_PROPERTY(cm::data::StringDecorator* ui_postcode MEMBER postcode \n                                                      CONSTANT)\n    Q_PROPERTY(QString ui_fullAddress READ fullAddress CONSTANT)\n\npublic:\n    explicit Address(QObject* parent = nullptr);\n    Address(QObject* parent, const QJsonObject& json);\n\n    data::StringDecorator* building{nullptr};\n    data::StringDecorator* street{nullptr};\n    data::StringDecorator* city{nullptr};\n    data::StringDecorator* postcode{nullptr};\n\n    QString fullAddress() const;\n};\n\n}}\n\n#endif\n```", "```cpp\n#include \"address.h\"\n\nusing namespace cm::data;\n\nnamespace cm {\nnamespace models {\n\nAddress::Address(QObject* parent)\n        : Entity(parent, \"address\")\n{\n    building = static_cast<StringDecorator*>(addDataItem(new StringDecorator(this, \"building\", \"Building\")));\n    street = static_cast<StringDecorator*>(addDataItem(new StringDecorator(this, \"street\", \"Street\")));\n    city = static_cast<StringDecorator*>(addDataItem(new StringDecorator(this, \"city\", \"City\")));\n    postcode = static_cast<StringDecorator*>(addDataItem(new StringDecorator(this, \"postcode\", \"Post Code\")));\n}\n\nAddress::Address(QObject* parent, const QJsonObject& json)\n        : Address(parent)\n{\n    update(json);\n}\n\nQString Address::fullAddress() const\n{\n    return building->value() + \" \" + street->value() + \"\\n\" + city->value() + \"\\n\" + postcode->value();\n}\n\n}}\n```", "```cpp\nbuilding = static_cast<StringDecorator*>(addDataItem(new StringDecorator(this, \"building\", \"Building\")));\n```", "```cpp\nenum eContactType {\n    Unknown = 0,\n    Telephone,\n    Email,\n    Fax\n};\n\n```", "```cpp\nstd::map<int, QString> Contact::contactTypeMapper = std::map<int, QString> {\n    { Contact::eContactType::Unknown, \"\" }\n    , { Contact::eContactType::Telephone, \"Telephone\" }\n    , { Contact::eContactType::Email, \"Email\" }\n    , { Contact::eContactType::Fax, \"Fax\" }\n};\n```", "```cpp\ncontactType = static_cast<EnumeratorDecorator*>(addDataItem(new EnumeratorDecorator(this, \"contactType\", \"Contact Type\", 0, contactTypeMapper)));\n```", "```cpp\n#ifndef CLIENT_H\n#define CLIENT_H\n\n#include <QObject>\n#include <QtQml/QQmlListProperty>\n\n#include <cm-lib_global.h>\n#include <data/string-decorator.h>\n#include <data/entity.h>\n#include <data/entity-collection.h>\n#include <models/address.h>\n#include <models/appointment.h>\n#include <models/contact.h>\n\nnamespace cm {\nnamespace models {\n\nclass CMLIBSHARED_EXPORT Client : public data::Entity\n{\n    Q_OBJECT\n    Q_PROPERTY( cm::data::StringDecorator* ui_reference MEMBER \n                                           reference CONSTANT )\n    Q_PROPERTY( cm::data::StringDecorator* ui_name MEMBER name CONSTANT )\n    Q_PROPERTY( cm::models::Address* ui_supplyAddress MEMBER \n                                     supplyAddress CONSTANT )\n    Q_PROPERTY( cm::models::Address* ui_billingAddress MEMBER \n                                     billingAddress CONSTANT )\n    Q_PROPERTY( QQmlListProperty<Appointment> ui_appointments READ \n                        ui_appointments NOTIFY appointmentsChanged )\n    Q_PROPERTY( QQmlListProperty<Contact> ui_contacts READ ui_contacts \n                                          NOTIFY contactsChanged )\n\npublic:    \n    explicit Client(QObject* parent = nullptr);\n    Client(QObject* parent, const QJsonObject& json);\n\n    data::StringDecorator* reference{nullptr};\n    data::StringDecorator* name{nullptr};\n    Address* supplyAddress{nullptr};\n    Address* billingAddress{nullptr};\n    data::EntityCollection<Appointment>* appointments{nullptr};\n    data::EntityCollection<Contact>* contacts{nullptr};\n\n    QQmlListProperty<cm::models::Appointment> ui_appointments();\n    QQmlListProperty<cm::models::Contact> ui_contacts();\n\nsignals:\n    void appointmentsChanged();\n    void contactsChanged();\n};\n\n}}\n\n#endif\n```", "```cpp\n#include \"client.h\"\n\nusing namespace cm::data;\n\nnamespace cm {\nnamespace models {\n\nClient::Client(QObject* parent)\n    : Entity(parent, \"client\")\n{\n    reference = static_cast<StringDecorator*>(addDataItem(new \n                StringDecorator(this, \"reference\", \"Client Ref\")));\n    name = static_cast<StringDecorator*>(addDataItem(new \n                StringDecorator(this, \"name\", \"Name\")));\n    supplyAddress = static_cast<Address*>(addChild(new Address(this), \n                                          \"supplyAddress\"));\n    billingAddress = static_cast<Address*>(addChild(new Address(this), \n                                          \"billingAddress\"));\n    appointments = static_cast<EntityCollection<Appointment>*>\n    (addChildCollection(new EntityCollection<Appointment>(this, \n                                            \"appointments\")));\n    contacts = static_cast<EntityCollection<Contact>*>(addChildCollection(new EntityCollection<Contact>(this, \"contacts\")));\n}\n\nClient::Client(QObject* parent, const QJsonObject& json)\n    : Client(parent)\n{\n    update(json);\n}\n\nQQmlListProperty<Appointment> Client::ui_appointments()\n{\n    return QQmlListProperty<Appointment>(this, appointments->derivedEntities());\n}\n\nQQmlListProperty<Contact> Client::ui_contacts()\n{\n    return QQmlListProperty<Contact>(this, contacts->derivedEntities());\n}\n\n}}\n```", "```cpp\nqmlRegisterType<cm::data::DateTimeDecorator>(\"CM\", 1, 0, \"DateTimeDecorator\");\nqmlRegisterType<cm::data::EnumeratorDecorator>(\"CM\", 1, 0, \"EnumeratorDecorator\");\nqmlRegisterType<cm::data::IntDecorator>(\"CM\", 1, 0, \"IntDecorator\");\nqmlRegisterType<cm::data::StringDecorator>(\"CM\", 1, 0, \"StringDecorator\");\n\nqmlRegisterType<cm::models::Address>(\"CM\", 1, 0, \"Address\");\nqmlRegisterType<cm::models::Appointment>(\"CM\", 1, 0, \"Appointment\");\nqmlRegisterType<cm::models::Client>(\"CM\", 1, 0, \"Client\");\nqmlRegisterType<cm::models::Contact>(\"CM\", 1, 0, \"Contact\");\n```", "```cpp\nClient* newClient{nullptr};\n```", "```cpp\nnewClient = new Client(masterController);\n```", "```cpp\nClient* MasterController::newClient()\n{\n    return implementation->newClient;\n}\n```", "```cpp\nQ_PROPERTY( cm::models::Client* ui_newClient READ newClient CONSTANT )\n```", "```cpp\nproperty Client newClient: masterController.ui_newClient\n```", "```cpp\nreadonly property real sizeScreenMargin: 20\n```", "```cpp\nreadonly property color colourDataControlsBackground: \"#ffffff\"\nreadonly property color colourDataControlsFont: \"#131313\" \nreadonly property int pixelSizeDataControls: 18 \nreadonly property real widthDataControls: 400 \nreadonly property real heightDataControls: 40\n```", "```cpp\nimport QtQuick 2.9\nimport CM 1.0\nimport assets 1.0\n\nItem {\n    property StringDecorator stringDecorator\n\n    height: width > textLabel.width + textValue.width ? \n    Style.heightDataControls : Style.heightDataControls * 2\n\n    Flow {\n        anchors.fill: parent\n\n        Rectangle {\n            width: Style.widthDataControls\n            height: Style.heightDataControls\n            color: Style.colourBackground\n            Text {\n                id: textLabel\n                anchors {\n                    fill: parent\n                    margins: Style.heightDataControls / 4\n                }\n                text: stringDecorator.ui_label\n                color: Style.colourDataControlsFont\n                font.pixelSize: Style.pixelSizeDataControls\n                verticalAlignment: Qt.AlignVCenter\n            }\n        }\n\n        Rectangle {\n            id: background\n            width: Style.widthDataControls\n            height: Style.heightDataControls\n            color: Style.colourDataControlsBackground\n            border {\n                width: 1\n                color: Style.colourDataControlsFont\n            }\n            TextInput {\n                id: textValue\n                anchors {\n                    fill: parent\n                    margins: Style.heightDataControls / 4\n                }\n                text: stringDecorator.ui_value\n                color: Style.colourDataControlsFont\n                font.pixelSize: Style.pixelSizeDataControls\n                verticalAlignment: Qt.AlignVCenter\n            }\n        }\n\n        Binding {\n            target: stringDecorator\n            property: \"ui_value\"\n            value: textValue.text\n        }\n    }\n}\n```", "```cpp\nStringEditorSingleLine {\n    stringDecorator: newClient.ui_name\n}\n```", "```cpp\nimport QtQuick 2.9\nimport QtQuick.Controls 2.2\nimport CM 1.0\nimport assets 1.0\nimport components 1.0\n\nItem {\n    property Client newClient: masterController.ui_newClient\n\n    Rectangle {\n        anchors.fill: parent\n        color: Style.colourBackground\n    }\n\n    ScrollView {\n        id: scrollView\n        anchors {\n            left: parent.left\n            right: parent.right\n            top: parent.top\n            bottom: commandBar. top\n            margins: Style.sizeScreenMargin\n        }\n        clip: true\n        Column {\n            spacing: Style.sizeScreenMargin\n            width: scrollView.width\n            StringEditorSingleLine {\n                stringDecorator: newClient.ui_name\n                anchors {\n                    left: parent.left\n                    right: parent.right\n                }\n            }\n        }\n    }\n\n    CommandBar {\n        id: commandBar\n        commandList: masterController.ui_commandController.ui_createClientViewContextCommands\n    }\n}\n```"]