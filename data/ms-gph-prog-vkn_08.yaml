- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Adding Shadows Using Mesh Shaders
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格着色器添加阴影
- en: In the previous chapter, we added support for multiple lights using clustered
    deferred techniques with the latest innovations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用集群延迟技术添加了对多个光源的支持，并引入了最新的创新。
- en: We added a hard limit of 256 maximum lights, with the possibility for each one
    to be dynamic and unique in its properties.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个硬限制，最多256个光源，每个光源都可以是动态的，并且具有独特的属性。
- en: In this chapter, we will add the possibility for each of these lights to cast
    shadows to further enhance the visuals of any asset displayed in Raptor Engine,
    and we will exploit the possibilities given by mesh shaders of having many of
    these lights cast shadows and still be in a reasonable frame time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为这些光源中的每一个添加投射阴影的可能性，以进一步增强Raptor Engine中显示的任何资产的可视效果，并且我们将利用网格着色器提供的可能性，让许多这些光源投射阴影，同时保持合理的帧时间。
- en: We will also have a look at using sparse resources to improve shadow map memory
    usage, moving the possibility of having many shadow-casting lights from something
    almost impossible to something possible and performant with current hardware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨使用稀疏资源来提高阴影图内存使用，将拥有许多阴影投射光源的可能性从几乎不可能变为在当前硬件上可能且性能良好的状态。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: A brief history of shadow techniques
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阴影技术的简要历史
- en: Implementing shadow mapping using mesh shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格着色器实现阴影映射
- en: Improving shadow memory with Vulkan’s sparse resources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vulkan的稀疏资源改进阴影内存
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter8](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter8)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下网址找到：[https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter8](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter8)
- en: A brief history of shadow techniques
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阴影技术的简要历史
- en: Shadows are one of the biggest additions to any rendering framework as they
    really enhance the perception of depth and volume across a scene. Being a phenomenon
    linked to lights, they have been studied in graphics literature for decades, but
    the problem is still far from being solved.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影是任何渲染框架中最大的新增功能之一，因为它们确实增强了场景中深度和体积的感知。作为一个与光线相关的现象，它们在图形文献中被研究了数十年，但问题仍然远未解决。
- en: The most used shadow technique right now is shadow mapping, but recently, thanks
    to hardware-enabled ray tracing, ray traced shadows are becoming popular as a
    more realistic solution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最常用的阴影技术是阴影映射，但最近，得益于硬件支持的光线追踪，光线追踪阴影作为一种更真实解决方案正在变得流行。
- en: There were some games—especially *Doom 3*—that also used shadow volumes as a
    solution to make lights cast shadows, but they are not used anymore.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有些游戏——特别是*Doom 3*——也使用了阴影体积作为使光线产生阴影的解决方案，但现在已经不再使用。
- en: Shadow volumes
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影体积
- en: Shadow volumes are an old concept, already proposed by Frank Crow in 1977\.
    They are defined as the projection of each vertex of a triangle along the light
    direction and toward infinity, thus creating a volume.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影体积是一个古老的概念，由Frank Crow在1977年提出。它们被定义为沿着光线方向和向无限延伸的每个三角形的顶点的投影，从而创建一个体积。
- en: The shadows are sharp, and they require each triangle and each light to process
    accordingly. The most recent implementation uses the stencil buffer, and this
    change enabled it to be used in real time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影非常清晰，并且需要针对每个三角形和每束光进行处理。最新的实现使用了模板缓冲区，这一变化使得它能够实时使用。
- en: The problem with shadow volumes is that they require a lot of geometry work
    and become fill-rate intensive, and in this case, shadow maps are a clear winner.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影体积的问题在于它们需要大量的几何工作，并且变得填充率很高，在这种情况下，阴影图是一个明显的赢家。
- en: Shadow mapping
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影映射
- en: The most used technique of all, first appearing around 1978, shadow mapping
    is the industry standard in both real-time and offline rendering. The idea behind
    shadow mapping is to render the scene from the perspective of the light and save
    the depth of each pixel.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有技术中最常用的技术，首次出现在1978年左右，是实时和离线渲染的行业标准。阴影映射背后的想法是从光线的视角渲染场景，并保存每个像素的深度。
- en: After that, when rendering the scene from the camera point of view, the pixel
    position can be converted to the shadow coordinate system and tested against the
    corresponding pixel in the shadow map to see whether the current pixel is in shadow
    or not.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当从摄像机视角渲染场景时，像素位置可以转换为阴影坐标系，并测试与阴影贴图中的相应像素是否重叠，以确定当前像素是否处于阴影中。
- en: The resolution of a shadow map is very important, as well as what type of information
    is saved inside it. With time, filters started to appear, using mathematical tools
    to add the possibility to soften the shadows, or adding calculations to harden
    the shadows the closer they are to the blocker geometry.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影贴图的分辨率非常重要，以及其中保存的信息类型。随着时间的推移，过滤器开始出现，使用数学工具添加软化阴影的可能性，或者添加计算来使阴影在靠近阻挡几何体时变得更硬。
- en: Shadow mapping suffers from a lot of issues as well, but being the de facto
    standard, many techniques are used to alleviate them. Some problems that can be
    encountered are aliasing, shadow acne, and Peter Panning.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影映射也存在许多问题，但由于它是事实上的标准，因此使用了许多技术来减轻这些问题。可能遇到的一些问题是走样、阴影痤疮和彼得·潘效应。
- en: Finding a robust shadow solution is one of the most intricate steps of a rendering
    engine and normally requires a lot of trial and error and custom solutions tailored
    to different scenes and situations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找一个稳健的阴影解决方案是渲染引擎中最复杂的步骤之一，通常需要大量的试错和针对不同场景和情况定制的解决方案。
- en: Raytraced shadows
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光线追踪阴影
- en: In the last few years, raytracing—a technique that uses rays to trace any kind
    of rendering information—got hardware support on customer GPUs, enabling rendering
    programmers to use a different scene representation to trace rays and enhance
    the look of different rendering phenomena.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，光线追踪——一种使用光线追踪任何类型渲染信息的技术——在客户GPU上获得了硬件支持，使得渲染程序员可以使用不同的场景表示来追踪光线，并增强不同渲染现象的外观。
- en: We will look at raytracing toward the end of the book, but for now, it is sufficient
    to say that using this special representation of the scene (different from mesh
    and meshlets we already use), it is possible to trace, for each pixel on the screen,
    one ray toward each light affecting the pixel and calculate the final shadow contribution
    to that pixel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的末尾探讨光线追踪，但就目前而言，只需说使用这种特殊的场景表示（不同于我们已使用的网格和网格块），对于屏幕上的每个像素，都可以向影响该像素的每个光源追踪一条光线，并计算该像素的最终阴影贡献即可。
- en: It is the most advanced and realistic form of a shadow, but still, performance-wise—despite
    the hardware support—it can be slow, and the diffusion of GPUs supporting it is
    not as elevated as needed to make it the new standard.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是阴影最先进和最真实的形式，但性能方面——尽管有硬件支持——可能仍然较慢，并且支持它的GPU的扩散程度并不像所需的那样高，以使其成为新的标准。
- en: That is why shadow mapping is still the standard—any hardware, including mobile
    phones, can render shadow maps, and they can still achieve a convincing look.
    Based on this consideration, we chose to implement shadow mapping as the main
    shadow technique for Raptor Engine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，阴影映射仍然是标准——任何硬件，包括移动电话，都可以渲染阴影贴图，并且仍然可以呈现出令人信服的外观。基于这一考虑，我们选择将阴影映射作为Raptor
    Engine的主要阴影技术。
- en: Implementing shadow mapping using mesh shaders
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格着色器实现阴影映射
- en: Now that we have looked at the different ways to render a shadow, we will describe
    the algorithm and the implementation’s detail used to render many shadow maps
    at once leveraging the mesh shader power.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了渲染阴影的不同方法，我们将描述用于一次渲染多个阴影贴图的算法和实现细节，利用网格着色器的强大功能。
- en: Overview
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: In this section, we will give an overview of the algorithm. What we are trying
    to achieve is to render shadows using meshlets and mesh shaders, but this will
    require some compute work to generate commands to actually draw the meshlets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将概述该算法。我们试图实现的是使用网格块和网格着色器来渲染阴影，但这将需要一些计算工作来生成实际绘制网格块的命令。
- en: We will draw shadows coming from point lights, and we will use cubemaps as textures
    to store the necessary information. We will talk about cubemaps in the following
    section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制由点光源产生的阴影，并使用立方体贴图作为纹理来存储必要的信息。我们将在下一节中讨论立方体贴图。
- en: Back to the algorithm, the first step will be to cull mesh instances against
    lights. This is done in a compute shader and will save a per-light list of visible
    mesh instances. Mesh instances are used to retrieve associated meshes later on,
    and per-meshlet culling will be performed using task shaders later on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回到算法，第一步将是针对灯光剪裁网格实例。这是在计算着色器中完成的，并将保存每个灯光的可见网格实例列表。网格实例用于稍后检索关联的网格，并且将使用任务着色器稍后执行每个网格集的剪裁。
- en: The second step is to write indirect draw meshlet arguments to perform the actual
    rendering of meshlets into shadow maps, again in a compute shader. There is a
    caveat here that will be explained in the *A note about multiview* *rendering*
    section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将间接绘制网格集参数写入以执行网格集的实际渲染到阴影图中，这同样是在计算着色器中完成的。这里有一个需要注意的地方，将在“关于多视图渲染”部分进行解释。
- en: The third step is to draw meshlets using indirect mesh shaders, drawing into
    the actual shadow maps.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是使用间接网格着色器绘制网格集，将其绘制到实际的阴影图中。
- en: We will use a layered cubemap shadow texture as we are drawing, with each layer
    corresponding to each light.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用分层立方体贴图阴影纹理进行绘制，每个层对应每个灯光。
- en: The fourth and final step is to sample the shadow texture when lighting the
    scene.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步和最后一步是在场景照明时采样阴影纹理。
- en: We will render shadows with almost no filtering, as the focus of this chapter
    is on mesh shader-driven shadows, but we will give links to filtering options
    at the end of the chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以几乎无过滤的方式渲染阴影，因为本章的重点是网格着色器驱动的阴影，但我们将提供过滤选项的链接，放在本章的末尾。
- en: 'Here is a visual overview of the algorithm:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是算法的视觉概述：
- en: '![Figure 8.1 – Algorithm overview](img/B18395_08_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 算法概述](img/B18395_08_01.jpg)'
- en: Figure 8.1 – Algorithm overview
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 算法概述
- en: In the next section, we will talk about cubemap shadows, used to store shadows
    from point lights.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论立方体贴图阴影，用于存储点光源的阴影。
- en: Cubemap shadows
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立方体贴图阴影
- en: '**Cubemaps** are a general way of mapping a 3D direction (*x*, *y*, *z*) with
    six faces containing image information.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**立方体贴图**是一种将3D方向（*x*、*y*、*z*）映射到包含图像信息的六个面的通用方法。'
- en: They are used not only for shadow rendering but in general to draw environments
    as well (such as sky boxes, or far distant landscapes), and they are so standardized
    that even hardware contains support for cubemap sampling and filtering.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不仅用于阴影渲染，而且在一般情况下也用于绘制环境（如天空盒或远处的景观），并且它们已经标准化到连硬件都包含对立方体贴图采样和过滤的支持。
- en: 'Each direction of the cubemap has normally a name and an orientation and a
    single texture associated with it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图的每个方向通常都有一个名称、一个方向和一个与之关联的单个纹理：
- en: Positive *x*
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正向 *x*
- en: Negative *x*
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负向 *x*
- en: Positive *y*
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正向 *y*
- en: Negative *y*
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负向 *y*
- en: Positive *z*
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正向 *z*
- en: Negative *z*
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负向 *z*
- en: When rendering to a face, we need to provide matrices that will look in the
    correct direction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染到一个面时，我们需要提供矩阵，使其朝正确的方向查看。
- en: When reading, a single vector will be translated (behind the scenes) to the
    corresponding image. For shadows, the process will be manual, as we will provide
    for each face a view projection matrix that will be read by the meshlets to direct
    the rendering to the correct face.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取时，一个单独的向量将被（在幕后）转换为相应的图像。对于阴影，这个过程将是手动的，因为我们将为每个面提供一个视图投影矩阵，网格集将读取它以将渲染引导到正确的面。
- en: A caveat for that also is that we will need to duplicate the drawing commands
    for each face, as one vertex can be rendered only to one image view associated
    with each face.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，还有一个需要注意的地方，即我们需要为每个面复制绘图命令，因为一个顶点只能渲染到与每个面关联的图像视图。
- en: There are some extensions that can associate a vertex with more than one image,
    as we will see in the next section, but their support in mesh shaders at the time
    of writing is still limited.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些扩展可以将一个顶点与多个图像关联，正如我们将在下一节中看到的，但它们在编写时的网格着色器中的支持仍然有限。
- en: Another important aspect of the proposed shadow rendering is that we will use
    an array of cubemaps so that we can both read and write every shadow using layered
    rendering.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的阴影渲染的另一个重要方面是，我们将使用立方体贴图数组，这样我们就可以通过分层渲染来读取和写入每个阴影。
- en: 'Here is the unrolled cubemap shadow rendering for one point light, with a texture
    for each cubemap face:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是针对一个点光源的展开立方体贴图阴影渲染，每个立方体贴图面都有一个纹理：
- en: '![Figure 8.2 – The six cubemap faces rendered from the light point of view](img/B18395_08_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 从灯光视角渲染的六个立方体贴图面](img/B18395_08_02.jpg)'
- en: Figure 8.2 – The six cubemap faces rendered from the light point of view
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 从光线视角渲染的六个立方体贴图面
- en: As we can see, only the positive *Z* is rendering something. We will provide
    some culling mechanisms to avoid rendering meshlets in empty cubemap faces.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，只有正*Z*方向在渲染内容。我们将提供一些剔除机制，以避免在空立方体贴图面上渲染网格块。
- en: A note about multiview rendering
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于多视图渲染的说明
- en: 'As written in the previous section, there is an extension that helps with rendering
    a vertex on more than a cubemap face: Multiview Rendering. This extension is widely
    used in virtual reality applications to render a vertex in both the views of a
    stereographic projection and can be used as well with cubemaps.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有一个扩展可以帮助在多个立方体贴图面上渲染顶点：多视图渲染。这个扩展在虚拟现实应用中广泛使用，可以在双目投影的两个视图中渲染一个顶点，也可以与立方体贴图一起使用。
- en: At the time of writing, mesh shaders don’t have a proper extension supported,
    so we are using the NVIDIA Vulkan extension, and this is not supporting Multiview
    Rendering properly, thus we are manually generating commands for each face and
    drawing using those commands.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，网格着色器还没有得到适当的扩展支持，所以我们使用NVIDIA的Vulkan扩展，但这并不支持多视图渲染，因此我们手动为每个面生成命令并使用这些命令进行绘制。
- en: We are aware that a multi-vendor extension is on the way, so we will update
    the code accordingly, but the core algorithm does not change, as multiview rendering
    is more of an optimization.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道一个多供应商扩展正在路上，因此我们将相应地更新代码，但核心算法不会改变，因为多视图渲染更多的是一种优化。
- en: We are now ready to see the algorithm steps.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查看算法步骤。
- en: Per-light mesh instance culling
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每光线网格实例剔除
- en: The first step in preparing for shadow rendering is a coarse grain culling done
    in a compute shader. In Raptor, we have both mesh and meshlet representations,
    thus we can use meshes and their bounding volumes as a *higher hierarchy* linked
    to meshlets.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 准备阴影渲染的第一步是在计算着色器中进行的粗粒度剔除。在Raptor中，我们有网格和网格块表示，因此我们可以使用网格及其边界体积作为与网格块链接的*更高层次*。
- en: We will perform a very simple light sphere to mesh sphere intersection, and
    if intersecting, we will add the corresponding meshlets. The first thing to know
    is that we will dispatch this compute shader using mesh instances and light together,
    so we will calculate for each light and for each mesh instance if the light influences
    the mesh instance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行一个非常简单的光线球与网格球相交操作，如果相交，我们将添加相应的网格块。首先要知道的是，我们将使用网格实例和光线一起调度这个计算着色器，因此我们将为每个光线和每个网格实例计算光线是否影响网格实例。
- en: We will then output a list of per-light meshlet instances, defined as both a
    mesh instance and global meshlet index combined. We will also write the per-light
    meshlet instances count, to skip empty lights and to correctly read the indices.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将输出一个每个光线的网格块实例列表，定义为网格实例和全局网格块索引的组合。我们还将写入每个光线的网格块实例计数，以跳过空灯光并正确读取索引。
- en: 'The first step is thus to reset the per-light counts:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是重置每个光线的计数：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will then skip threads that will work on out-of-bounds lights. When we dispatch,
    we round up the numbers after dividing by 32, so some threads can be working on
    empty lights.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将跳过那些将在超出范围的灯光上工作的线程。当我们调度时，我们在除以32后向上取整数字，因此一些线程可能正在处理空灯光。
- en: 'The dispatch of this compute will be done by linking each mesh instance with
    each light, like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算调度将通过将每个网格实例与每个光线链接来完成，如下所示：
- en: '![Figure 8.3 – Organization of the command buffer to render the cubemaps for
    multiple lights using a single draw call](img/B18395_08_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 使用单个绘制调用渲染多个光线的立方体贴图的命令缓冲区组织](img/B18395_08_03.jpg)'
- en: Figure 8.3 – Organization of the command buffer to render the cubemaps for multiple
    lights using a single draw call
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 使用单个绘制调用渲染多个光线的立方体贴图的命令缓冲区组织
- en: 'Here is the early out and light index calculation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是提前退出和光线索引计算：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In a similar way, we calculate the mesh instance index, and *early out* again
    if the dispatch rounding up is too much:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们计算网格实例索引，并在调度向上取整过多时再次*提前退出*：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can finally gather the bounding sphere of the mesh instance and the model
    and simply calculate the world space bounding sphere:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以收集网格实例和模型的边界球，并简单地计算世界空间边界球：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, we know that the mesh instance is influenced by the light, so
    increase the per-light meshlet count and add all the indices necessary to draw
    the meshlets:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道网格实例受到光的影响，因此增加每个光源的网格块计数，并添加所有必要的索引以绘制网格块：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will end up writing both the mesh instance index—to retrieve the world matrix—and
    the global meshlet index—to retrieve meshlet data in the following task shader.
    But before that, we need to generate an indirect draw commands list, and we will
    see that in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的任务着色器中同时写入网格实例索引以检索世界矩阵，以及全局网格块索引以检索网格块数据。但在那之前，我们需要生成一个间接绘制命令列表，我们将在下一节中看到这一点。
- en: Also, based on the scene, we have a maximum number of meshlet instances, and
    we allocate them upfront for each light.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据场景，我们有网格块实例的最大数量，并且我们为每个光源预先分配它们。
- en: Indirect draw commands generation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间接绘制命令生成
- en: This compute shader will generate a list of indirect commands for each light.
    We will use the last element of the per-light meshlet instances’ **Shader Storage
    Buffer Object** (**SSBO**) to atomically count the number of indirect commands.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算着色器将为每个光源生成一个间接命令列表。我们将使用每个光源网格块实例的**着色器存储缓冲对象**（**SSBO**）的最后一个元素来原子计数间接命令的数量。
- en: 'As before, reset `atomic int` used for the indirect commands count:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，重置用于间接命令计数的`atomic int`：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will early out execution for rounded-up light indices:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提前终止执行以处理四舍五入的光索引：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can finally write the indirect data and the packed light index, only if the
    light contains visible meshes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以写入间接数据和打包的光索引，前提是光源包含可见的网格。
- en: 'Note that we write six commands, one for each cubemap face:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们写入六个命令，每个立方体贴图面一个：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now have a list of indirect drawing commands, six for each light. We will
    perform further culling in the task shader, shown in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个间接绘制命令列表，每个光源六个。我们将在任务着色器中执行进一步的剔除，下一节将展示。
- en: Shadow cubemap face culling
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影立方体贴图面剔除
- en: 'In the indirect drawing task shader, we will add a mechanism to cull a meshlet
    against a cubemap to optimize the rendering. To do that, we have a utility method
    that will calculate, given a cubemap and an axis-aligned bounding box, which face
    will be visible in the cubemap. It is using cubemap face normals to calculate
    whether the center and extents are enclosed in the four planes used to define
    one of the six cubemap faces:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在间接绘制任务着色器中，我们将添加一个机制来剔除网格块与立方体贴图的交集以优化渲染。为此，我们有一个实用方法，它将计算给定立方体贴图和轴对齐的边界框时，哪个面将在立方体贴图中可见。它是使用立方体贴图面法线来计算中心点和范围是否包含在定义六个立方体贴图面之一的四个平面中：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These methods return a bitmask with each of the six bits set as `1` when the
    current axis-aligned bounding box is visible in that face.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回一个位掩码，其中每个六位都设置为`1`，当当前轴对齐的边界框在该面上可见时。
- en: Meshlet shadow rendering – task shader
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格块阴影渲染 – 任务着色器
- en: Now that we have this utility method in place, we can look at the task shader.
    We changed some things with the other task shaders to accommodate the indirect
    drawing and to use layered rendering to write on different cubemaps.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个实用方法，我们可以看看任务着色器。我们改变了一些其他任务着色器的内容，以适应间接绘制并使用分层渲染来写入不同的立方体贴图。
- en: 'We will pass `uint` to the mesh shader that packs a light and a face index
    to retrieve the corresponding cubemap view projection matrix and write to the
    correct layer:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递`uint`到网格着色器，它打包一个光和一个面索引以检索相应的立方体贴图视图投影矩阵并将其写入正确的层：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The meshlet calculation is tricky, as indices need to be calculated globally.
    We first calculate the meshlet index global to the indirect draw:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 网格块计算比较复杂，因为需要全局计算索引。我们首先计算间接绘制全局的网格块索引：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then extrapolate the light index and the read offset in the meshlet instances
    written in the culling compute shader:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在剔除计算着色器中写入的网格块实例中外推光索引和读取偏移量：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can finally read the correct meshlet and mesh instance indices:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以读取正确的网格块和网格实例索引：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we calculate the face index, and we can start the culling phase:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们计算面索引，然后我们可以开始剔除阶段：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Culling is performed similarly to previous task shaders, but we added also
    per-face culling:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 剔除与之前的任务着色器执行方式类似，但我们还添加了按面剔除：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point of the shader we write each visible meshlet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个着色器点，我们写入每个可见的网格块：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And finally, we write the packed light and face index:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们写入打包的光和面索引：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we will see the mesh shader.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到网格着色器。
- en: Meshlet shadow rendering – mesh shader
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格块阴影渲染 – 网格着色器
- en: In this mesh shader, we will need to retrieve the layer index in the cubemap
    array to write to, and the light index to read the correct view-projection transform.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个网格着色器中，我们需要检索要写入的立方体贴图数组中的层索引和读取正确视图投影变换的光索引。
- en: It’s important to note that each face has its own transform, as we effectively
    render to each face separately.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，每个面都有自己的变换，因为我们实际上是在单独渲染每个面。
- en: Note that each face of the cubemap is considered a layer, thus the first cubemap
    will be rendered in layers 0-5, the second in layers 6-11, and so on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，立方体贴图的每个面都被视为一个层，因此第一个立方体贴图将在层0-5中渲染，第二个在层6-11中，依此类推。
- en: 'Here is the code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we write the layer index for each primitive. The usage of these offsets
    is to avoid bank conflict when writing, as seen on previous shaders:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为每个基元写入层索引。这些偏移量的使用是为了在写入时避免银行冲突，正如之前着色器中看到的那样：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After this mesh shader rendering of shadows is complete, as there is no fragment
    shader associated. We can now read the generated shadow texture in the lighting
    shader, as explained in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个网格着色器渲染的阴影之后，由于没有关联的片段着色器，我们现在可以在光照着色器中读取生成的阴影纹理，如下一节所述。
- en: Shadow map sampling
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影贴图采样
- en: Given that we are just using hard shadow maps without filtering, the code to
    sample it is standard cubemap code. We calculate the world-to-light vector and
    use it to sample the cubemap.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只是使用没有过滤的硬阴影贴图，因此采样它的代码是标准的立方体贴图代码。我们计算世界到光向量和使用它来采样立方体贴图。
- en: 'Being a layered cubemap, we need both the 3D direction vector and the layer
    index, which we saved in the light itself:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个分层立方体贴图，我们需要3D方向向量和层索引，这些我们已经在光源本身中保存：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then convert the depth to raw depth values with the `vector_to_depth_value`
    utility method, which takes the major axis from the light vector and converts
    it to raw depth so that we can compare the value read from the cubemap:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`vector_to_depth_value`实用方法将深度转换为原始深度值，该方法从光向量中获取主轴并将其转换为原始深度，这样我们就可以比较从立方体贴图中读取的值：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `vector_to_depth_value` method is shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了`vector_to_depth_value`方法：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It takes the major axis from the direction vector and converts it to the raw
    depth using the formula coming from the projection matrix. This value is now usable
    with any depth value stored in a shadow map.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它从方向向量中获取主轴，并使用来自投影矩阵的公式将其转换为原始深度。这个值现在可以与存储在阴影贴图中的任何深度值一起使用。
- en: 'Here is an example of shadow coming from a point light:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个来自点光源的阴影示例：
- en: '![Figure 8.4 – Shadows produced by a single point light in the scene](img/B18395_08_04.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 场景中单个点光源产生的阴影](img/B18395_08_04.jpg)'
- en: Figure 8.4 – Shadows produced by a single point light in the scene
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 场景中单个点光源产生的阴影
- en: As we can see, shadows are a great improvement in rendering, giving the viewer
    a fundamental visual cue of an object’s relationship with its environment.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，阴影在渲染中是一个巨大的改进，为观众提供了物体与其环境之间基本视觉线索。
- en: Until here, we saw how to implement mesh shader-based shadows, but there is
    still room for improvement, especially in memory usage. Right now, this solution
    allocates upfront a single cubemap for each light, and the memory can become big
    quickly if we consider that we have six textures for each light.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了如何实现基于网格着色器的阴影，但仍有改进的空间，尤其是在内存使用方面。目前，这个解决方案为每个光源预先分配一个立方体贴图，如果我们考虑每个光源有六个纹理，内存可能会很快变得很大。
- en: We will look at a solution to lower the shadow map memory using sparse resources
    in the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用稀疏资源降低阴影贴图内存的解决方案。
- en: Improving shadow memory with Vulkan’s sparse resources
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vulkan的稀疏资源改进阴影内存
- en: As we mentioned at the end of the last section, we currently allocate the full
    memory for each cubemap for all the lights. Depending on the screen size of the
    light, we might be wasting memory as distant and small lights won’t be able to
    take advantage of the high resolution of the shadow map.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节末尾提到的，我们目前为所有光源的每个立方体贴图分配全部内存。根据光源的屏幕大小，我们可能会浪费内存，因为远处的和小的光源无法利用阴影贴图的高分辨率。
- en: For this reason, we have implemented a technique that allows us to dynamically
    determine the resolution of each cubemap based on the camera position. With this
    information, we can then manage a sparse texture and re-assign its memory at runtime
    depending on the requirements for a given frame.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们实现了一种技术，可以根据相机位置动态确定每个立方体贴图的分辨率。有了这些信息，我们就可以管理稀疏纹理，并在运行时根据给定帧的要求重新分配其内存。
- en: Sparse textures (sometimes also referred to as **virtual textures**) can be
    implemented manually, but luckily, they are supported natively in Vulkan. We are
    now going to describe how to use the Vulkan API to implement them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏纹理（有时也称为**虚拟纹理**）可以手动实现，但幸运的是，它们在Vulkan中是原生支持的。我们现在将描述如何使用Vulkan API来实现它们。
- en: Creating and allocating sparse textures
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和分配稀疏纹理
- en: Regular resources in Vulkan must be bound to a single memory allocation, and
    it’s not possible to bind a given resource to a different allocation. This works
    well for resources that are known at runtime and that we don’t expect to change.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan中的常规资源必须绑定到单个内存分配，并且无法将给定的资源绑定到不同的分配。这对于在运行时已知且我们预计不会更改的资源来说效果很好。
- en: 'However, when using cubemaps with a dynamic resolution, we need to be able
    to bind different portions of memory to a given resource. Vulkan exposes two methods
    to achieve this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用具有动态分辨率的立方体贴图时，我们需要能够将内存的不同部分绑定到给定的资源。Vulkan提供了两种方法来实现这一点：
- en: Sparse resources allow us to bind a resource to non-contiguous memory allocations,
    but the full resource needs to be bound.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稀疏资源允许我们将资源绑定到非连续的内存分配，但完整的资源需要绑定。
- en: Sparse residency allows us to partially bind a resource to different memory
    allocations. This is what we need for our implementation, as we are likely to
    use only a subsection of each layer of a cubemap.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稀疏驻留允许我们将资源部分绑定到不同的内存分配。这正是我们实现所需的功能，因为我们可能只会使用立方体贴图每一层的子集。
- en: 'Both methods allow users to re-bind a resource to different allocations at
    runtime. The first step needed to start using sparse resources is to pass the
    right flag when creating resources:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都允许用户在运行时将资源重新绑定到不同的分配。开始使用稀疏资源所需的第一步是在创建资源时传递正确的标志：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are requesting a resource that supports sparse residency. Once an image
    is created, we don’t need to immediately allocate memory for it. Instead, we are
    going to allocate a region of memory from which we will sub-allocate individual
    pages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在请求支持稀疏驻留的资源。一旦创建了一个图像，我们就不需要立即为其分配内存。相反，我们将从内存的一个区域分配，然后从该区域中子分配单个页面。
- en: 'It’s important to note that Vulkan has strict requirements for the size of
    individual pages. These are the required sizes taken from the Vulkan specification:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，Vulkan对单个页面的大小有严格的要求。这些是从Vulkan规范中获取的所需大小：
- en: '![Table 8.1 – Sparse block sizes for images](img/B18395_08_Table_01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![表8.1 – 图像的稀疏块大小](img/B18395_08_Table_01.jpg)'
- en: Table 8.1 – Sparse block sizes for images
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 – 图像的稀疏块大小
- en: 'We will need this information to determine how many pages to allocate for a
    cubemap of a given size. We can retrieve the details for a given image with the
    following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些信息来确定为给定大小的立方体贴图分配多少页面。我们可以使用以下代码检索给定图像的详细信息：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The information for this structure is already available in our texture data
    structure. Next, we retrieve the block size for the given image:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构的信息已经包含在我们的纹理数据结构中。接下来，我们检索给定图像的块大小：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this information, we can now allocate a pool of pages. First, we retrieve
    the memory requirements for the image:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，我们现在可以分配一个页面池。首先，我们检索图像的内存要求：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the same code we would use for a regular texture; however, `memory_requirements.alignment`
    will contain the block size for the given image format.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们用于常规纹理的相同代码；然而，`memory_requirements.alignment`将包含给定图像格式的块大小。
- en: 'Next, we compute the number of blocks we need to allocate for the given pool
    size:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算给定池大小所需的块数量：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The final step is to allocate the pages that we will use later to write into
    our cubemaps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是为我们将用于写入立方体贴图的页面分配：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `vmaAllocateMemoryPages`, to allocate multiple pages at once.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmaAllocateMemoryPages`，用于一次性分配多个页面。'
- en: Now that we have allocated the memory for our shadow maps, we need to determine
    the resolution for each cubemap.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的阴影映射分配了内存，我们需要确定每个立方体贴图的分辨率。
- en: Choosing per-light shadow memory usage
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择每光照阴影内存使用
- en: To determine the resolution of the cubemap for a given light, we need to find
    how much influence it has on the scene. Intuitively, a more distant light will
    have less influence, depending on its radius (at least for point lights), but
    we need to quantify its amount of influence. We have implemented a solution similar
    to the one proposed in the *More Efficient Virtual Shadow Maps for Many* *Lights*
    paper.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定给定光线的立方体贴图的分辨率，我们需要找到它对场景的影响程度。直观上，距离更远的光线将有更小的影响，这取决于它的半径（至少对于点光源），但我们需要量化它的影响量。我们实现了一个类似于在
    *More Efficient Virtual Shadow Maps for Many* *Lights* 论文中提出的解决方案。
- en: 'We are going to reuse the concept introduced in the previous chapter: clusters.
    We subdivide the screen into tiles and *slice* the frustum on the *z* axis. This
    will give us smaller frustums (approximated by axis-aligned bounding boxes) that
    we will use to determine which regions are covered by a given light.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用前一章中引入的概念：簇。我们将屏幕细分为瓦片，并在 *z* 轴上 *切割* 截锥体。这将给我们更小的截锥体（由轴对齐的边界框近似），我们将使用它来确定哪些区域被给定光线覆盖。
- en: 'Let’s look at the code to achieve this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现这一点的代码：
- en: 'We start by computing the bounding box for each light in camera space:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先计算每个光线在相机空间中的边界框：
- en: '[PRE28]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we iterate over the tiles and each depth slice to compute each cluster
    position and size. We start by computing the camera space position of each tile:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历瓦片和每个深度切片，计算每个簇的位置和大小。我们首先计算每个瓦片的相机空间位置：
- en: '[PRE43]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We then need to determine the minimum and maximum depth for each slice:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要确定每个切片的最小和最大深度：
- en: '[PRE54]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we combine both values to retrieve the position and size of the cluster:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将这两个值结合起来，以检索簇的位置和大小：
- en: '[PRE58]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now that we have obtained the cluster, we iterate over each light to determine
    whether it covers the cluster and the projection of the cluster onto the light;
    we’ll clarify what this means in a moment.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了簇，我们遍历每个光线，以确定它是否覆盖了簇以及簇在光线上的投影；我们将在稍后澄清这究竟意味着什么。
- en: 'The next step is a box intersection test between the light and the cluster:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在光线和簇之间进行盒相交测试：
- en: '[PRE72]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If they do intersect, we compute an approximation of the projected area of
    the light onto the cluster:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们确实相交，我们将计算光线在簇上的投影面积的一个近似值：
- en: '[PRE110]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The idea is to take the distance between the light and cluster center in screen
    space, compute the solid angle subtended by the cluster onto the light position,
    and compute the resolution of the cubemap using the size in pixels of the cluster.
    We refer you to the paper for more details.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是取光线和簇中心在屏幕空间中的距离，计算簇对光线位置的立体角，并使用簇的像素大小来计算立方体贴图的分辨率。更多细节请参阅论文。
- en: We keep the maximum resolution, and we will use the computed value to bind the
    memory for each cubemap.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留最大分辨率，并将使用计算出的值来绑定每个立方体贴图的内存。
- en: Rendering into a sparse shadow map
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将渲染到稀疏阴影贴图中
- en: 'Now that we have determined the resolution of the cubemaps for a given frame,
    we need to assign the pre-allocated pages to our textures:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了给定帧的立方体贴图的分辨率，我们需要将预分配的页面分配给我们的纹理：
- en: 'The first step is to record which pages are assigned to each image:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是记录哪些页面分配给每个图像：
- en: '[PRE111]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We start by getting the details for the allocation that we are going to use
    for a given block, as we need to access the `VkDeviceMemory` handle and the offset
    into the pool it was allocated from.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取我们将要用于给定块的分配的详细信息，因为我们需要访问 `VkDeviceMemory` 处理器和它从池中分配的偏移量。
- en: 'Next, we compute the texture offset for each block:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们计算每个块的纹理偏移量：
- en: '[PRE125]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Then, we record this information into a `VkSparseImageMemoryBind` data structure
    that will be used later to update the memory bound to the cubemap texture:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将此信息记录到 `VkSparseImageMemoryBind` 数据结构中，该结构将用于稍后更新绑定到立方体贴图纹理的内存：
- en: '[PRE129]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: It’s important to note that, as we mentioned previously, we only use one image
    with many layers. The layer variable determines which layer each allocation will
    belong to. Please refer to the full code for more details.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，正如我们之前提到的，我们只使用一个具有许多层的图像。层变量确定每个分配将属于哪个层。请参阅完整代码以获取更多详细信息。
- en: 'Finally, we record which image these pages will be bound to:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们记录这些页面将绑定到哪些图像上：
- en: '[PRE142]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '`array_offset` is an offset into the `pending_sparse_queue_binds` array so
    that we can store all pending allocations in a single array.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_offset` 是 `pending_sparse_queue_binds` 数组中的一个偏移量，这样我们就可以在一个数组中存储所有挂起的分配。'
- en: Now that we have recorded the list of allocation updates, we need to submit
    them to a queue for them to be executed by the GPU.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经记录了分配更新的列表，我们需要将它们提交到队列中，以便GPU执行。
- en: 'First, we populate a `VkSparseImageMemoryBindInfo` structure for each layer:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们为每个层填充一个`VkSparseImageMemoryBindInfo`结构：
- en: '[PRE147]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Next, we submit all pending binding operations to the main queue:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将所有挂起的绑定操作提交到主队列：
- en: '[PRE158]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: It’s important to note that it’s the responsibility of the user to make sure
    this operation is completed before accessing the resources whose allocations we
    just updated. We achieve this by signaling a semaphore, `vulkan_bind_semaphore`,
    which will then be waited on by the main rendering work submission.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，确保在访问我们刚刚更新的资源分配之前完成此操作是用户的责任。我们通过发出一个信号量`vulkan_bind_semaphore`来实现这一点，然后主渲染工作提交将等待该信号量。
- en: It’s important to note that the queue we call `vkQueueBindSparse` on must have
    the `VK_QUEUE_SPARSE_BINDING_BIT` flag.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们在其上调用`vkQueueBindSparse`的队列必须具有`VK_QUEUE_SPARSE_BINDING_BIT`标志。
- en: In this section, we have covered the steps necessary to allocate and use sparse
    textures. We first explained how sparse textures work and why they are useful
    for our cubemap use case.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了分配和使用稀疏纹理所需的步骤。我们首先解释了稀疏纹理的工作原理以及为什么它们对我们使用立方体贴图的情况很有用。
- en: Next, we illustrated the algorithm we used to dynamically determine the resolution
    of each cubemap based on each light contribution to the scene. Finally, we demonstrated
    how to use the Vulkan API to bind memory to sparse resources.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们说明了我们用来根据每个灯光对场景的贡献动态确定每个立方体贴图分辨率的算法。最后，我们展示了如何使用Vulkan API将内存绑定到稀疏资源。
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we extended our lighting system to support many point lights
    with an efficient implementation. We started with a brief history of shadow algorithms,
    and their benefits and shortcomings, up until some of the most recent techniques
    that take advantage of raytracing hardware.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们的照明系统扩展到支持许多点光源，并实现了高效的实现。我们从阴影算法的简要历史开始，讨论了它们的优缺点，直到最近利用光线追踪硬件的一些技术。
- en: Next, we covered our implementation of shadows for many point lights. We explained
    how cubemaps are generated for each light and the optimizations we implemented
    to make the algorithm scale to many lights. In particular, we highlighted the
    culling method we reused from the main geometry pass and the use of a single indirect
    draw call for each light.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了我们对许多点光源阴影的实现。我们解释了为每个灯光生成立方体贴图的方法，以及我们为了使算法能够扩展到许多灯光而实施的优化。特别是，我们强调了从主几何体遍历中重用的剔除方法以及每个灯光使用单个间接绘制调用的方法。
- en: In the last section, we introduced sparse textures, a technique that allows
    us to dynamically bind memory to a given resource. We highlighted the algorithm
    we used to determine the contribution of each point light to the scene and how
    we use that information to determine the resolution of each cubemap. Finally,
    we demonstrated how to use sparse resources with the Vulkan API.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们介绍了稀疏纹理，这是一种允许我们动态地将内存绑定到给定资源的技术。我们强调了我们用来确定每个点光源对场景的贡献的算法，以及我们如何使用这些信息来确定每个立方体贴图的分辨率。最后，我们展示了如何使用Vulkan
    API与稀疏资源一起使用。
- en: 'While we only covered point lights in this chapter, some of the techniques
    can be reused with other types of lights. Some steps could also be optimized further:
    for instance, it’s possible to further reduce the cubemap resolution to account
    only for the area where geometry is visible.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们本章只涵盖了点光源，但一些技术可以与其他类型的灯光一起重用。一些步骤也可以进一步优化：例如，可以进一步降低立方体贴图的分辨率，仅考虑几何体可见的区域。
- en: The cluster computation is currently done on the CPU for clarity and to avoid
    having to read back the cluster data from the GPU, which could be a slow operation,
    but it might be worth moving the implementation to the GPU. We encourage you to
    experiment with the code and add more features!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，集群计算目前是在CPU上完成的，以避免从GPU读取集群数据，这可能是一个缓慢的操作，但可能值得将实现移至GPU。我们鼓励您尝试代码并添加更多功能！
- en: Further reading
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The book *Real-Time Shadows* provides a good overview of many techniques to
    implement shadows, many of which are still in use today.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍《实时阴影》提供了许多实现阴影的技术的好概述，其中许多至今仍在使用。
- en: '*GPU Pro 360 Guide to Shadows* collects articles from the *GPU Pro* series
    that are focused on shadows.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 《GPU Pro 360阴影指南》收集了专注于阴影的《GPU Pro》系列文章。
- en: 'An interesting technique described in the book is called tetrahedron shadow
    mapping: the idea is to project the shadow map to a tetrahedron and then unwrap
    it to a single texture.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 书中描述的一种有趣的技术称为四面体阴影映射：其想法是将阴影映射投影到一个四面体上，然后将其展开到一个单独的纹理上。
- en: The original concept was introduced in the *Shadow Mapping for Omnidirectional
    Light Using Tetrahedron Mapping* chapter (originally published in *GPU Pro*) and
    later expanded in *Tile-based Omnidirectional Shadows* (originally published in
    *GPU* *Pro 6*).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 原始概念是在*使用四面体映射进行全向光阴影映射*章节中引入的（最初发表在*GPU Pro*中），后来在*基于瓦片的全方位阴影*（最初发表在*GPU Pro
    6*中）中进行了扩展。
- en: 'For more details, we refer you to the code provided by the author: [http://www.hd-prg.com/tileBasedShadows.xhtml](http://www.hd-prg.com/tileBasedShadows.xhtml).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节，请参考作者提供的代码：[http://www.hd-prg.com/tileBasedShadows.xhtml](http://www.hd-prg.com/tileBasedShadows.xhtml).
- en: 'Our sparse texture implementation is based on this SIGGRAPH presentation: [https://efficientshading.com/wp-content/uploads/s2015_shadows.pdf](https://efficientshading.com/wp-content/uploads/s2015_shadows.pdf).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的稀疏纹理实现基于这个SIGGRAPH演示：[https://efficientshading.com/wp-content/uploads/s2015_shadows.pdf](https://efficientshading.com/wp-content/uploads/s2015_shadows.pdf).
- en: 'This expands on their original paper, found here: [http://newq.net/dl/pub/MoreEfficientClusteredShadowsPreprint.pdf.](http://newq.net/dl/pub/MoreEfficientClusteredShadowsPreprint.pdf%0D)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这扩展了他们的原始论文，可以在以下链接找到：[http://newq.net/dl/pub/MoreEfficientClusteredShadowsPreprint.pdf.](http://newq.net/dl/pub/MoreEfficientClusteredShadowsPreprint.pdf%0D)
- en: While we haven’t implemented it in this chapter, shadow map caching is an important
    technique to reduce the cost of computing shadow maps and amortize the shadow
    map updates over several frames.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这章中没有实现它，但阴影映射缓存是一种重要的技术，可以减少计算阴影映射的成本，并将阴影映射更新分摊到多个帧上。
- en: 'A good starting point is this presentation: [https://www.activision.com/cdn/research/2017_DD_Rendering_of_COD_IW.pdf](https://www.activision.com/cdn/research/2017_DD_Rendering_of_COD_IW.pdf).'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的起点是这个演示：[https://www.activision.com/cdn/research/2017_DD_Rendering_of_COD_IW.pdf](https://www.activision.com/cdn/research/2017_DD_Rendering_of_COD_IW.pdf).
- en: 'Our cluster computation closely follows the one presented in this article:
    [http://www.aortiz.me/2018/12/21/CG.xhtml#part-2.](http://www.aortiz.me/2018/12/21/CG.xhtml#part-2%0D)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们集群计算的方法与本文中提出的方法非常接近：[http://www.aortiz.me/2018/12/21/CG.xhtml#part-2.](http://www.aortiz.me/2018/12/21/CG.xhtml#part-2%0D)
- en: 'The Vulkan specification provides many more details on how to use the API for
    sparse resources: [https://registry.khronos.org/vulkan/specs/1.2-extensions/html/vkspec.xhtml#sparsememory](https://registry.khronos.org/vulkan/specs/1.2-extensions/html/vkspec.xhtml#sparsememory).'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan规范提供了更多关于如何使用API进行稀疏资源的信息：[https://registry.khronos.org/vulkan/specs/1.2-extensions/html/vkspec.xhtml#sparsememory](https://registry.khronos.org/vulkan/specs/1.2-extensions/html/vkspec.xhtml#sparsememory).
