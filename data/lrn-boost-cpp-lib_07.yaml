- en: Chapter 7. Higher Order and Compile-time Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。高阶和编译时编程
- en: A number of Standard Library algorithms take callable entities called **function
    objects** (function pointers, functors, and so on) as parameters. They call these
    function objects on individual elements of containers to compute some value or
    perform some action. Thus, a part of the runtime logic of the algorithm is encapsulated
    in a function or functor and supplied as an argument to the algorithm. A function
    may also return function objects instead of data values. The returned function
    object can be applied on a set of parameters and may in turn return either a value
    or another function object. This gives rise to higher order transforms. This style
    of programming involving passing and returning functions is called **higher order
    programming**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准库算法接受可调用实体，称为**函数对象**（函数指针、函数符等）作为参数。它们调用这些函数对象来计算容器中的各个元素的某个值或执行某些操作。因此，算法的一部分运行时逻辑被封装在一个函数或函数符中，并作为算法的参数提供。函数也可以返回函数对象而不是数据值。返回的函数对象可以应用于一组参数，并可能反过来返回一个值或另一个函数对象。这就产生了高阶变换。这种涉及传递和返回函数的编程风格称为**高阶编程**。
- en: C++ templates enable us to write type generic code. Using templates, it is possible
    to execute branching and recursive logic at compile time and conditionally include,
    exclude, and generate code from simpler building blocks. This style of programming
    is called **compile-time programming** or **template metaprogramming**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++模板使我们能够编写类型通用的代码。使用模板，可以在编译时执行分支和递归逻辑，并根据简单的构建块条件地包含、排除和生成代码。这种编程风格称为**编译时编程**或**模板元编程**。
- en: 'In the first part of this chapter, we will learn the applications of higher
    order programming in C++ using the Boost Phoenix Library and C++11 facilities
    like bind and lambda. In the next part of this chapter, we will learn C++ template
    metaprogramming techniques that execute at compile time to help generate more
    efficient and expressive code. In the last part of this chapter we look at domain-specific
    languages created within C++ by applying higher order programming techniques in
    combination with metaprogramming. The topics of this chapter are divided into
    the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将学习使用Boost Phoenix库和C++11的绑定和lambda等设施在C++中应用高阶编程的应用。在本章的下一部分，我们将学习C++模板元编程技术，这些技术在编译时执行，帮助生成更高效和更具表现力的代码。在本章的最后一部分，我们将通过将高阶编程技术与元编程相结合，在C++中创建领域特定语言。本章的主题分为以下几个部分：
- en: Higher order programming using Boost
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost进行高阶编程
- en: Compile-time programming using Boost
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost进行编译时编程
- en: Domain Specific Embedded Languages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域特定嵌入式语言
- en: In this chapter, we will explore an alternate paradigm of programming, which
    is different from object-oriented and procedural programming and draws heavily
    from functional programming. We will also develop generic programming techniques
    that ultimately help us implement more efficient template libraries.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨一种与面向对象和过程式编程不同的编程范式，它大量借鉴了函数式编程。我们还将开发通用编程技术，最终帮助我们实现更高效的模板库。
- en: Higher order programming with Boost
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost进行高阶编程
- en: 'Consider a type `Book` with three string fields: the ISBN, title, and author
    (for our purposes, assume that there is only one author). Here is how we can choose
    to define this type:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个类型`Book`，它有三个字符串字段：ISBN、标题和作者（对于我们的目的，假设只有一个作者）。以下是我们可以选择定义这种类型的方式：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is a `struct` with three fields and a constructor that initializes these
    three fields. The `isbn` field uniquely identifies the book and therefore is used
    to define an ordering of `Book` objects, using the overloaded `operator<` (line
    14).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个带有三个字段和一个构造函数的`struct`，用于初始化这三个字段。`isbn`字段唯一标识书籍，因此用于定义`Book`对象的排序，使用重载的`operator<`（第14行）。
- en: 'Now imagine that we have a list of these `Book` objects in a `std::vector`,
    and we want to sort these books. Thanks to the overloaded `operator<`, we can
    easily sort them using the Standard Library `sort` algorithm:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有一个`std::vector`中的这些`Book`对象的列表，并且我们想对这些书籍进行排序。由于重载的`operator<`，我们可以轻松地使用标准库的`sort`算法对它们进行排序：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we put four `Book` objects in the vector `books`. We
    do this by calling the `emplace_back` method (lines 11-18) rather than `push_back`.
    The `emplace_back` method (introduced in C++11) takes the constructor arguments
    for the stored type (`Book`) and constructs an object in the vector's layout rather
    than copying or moving in a pre-constructed object. We then sort the vector using
    `std::sort`, which ultimately uses the `operator<` for `Book` objects. Without
    this overloaded operator, `std::sort` would have failed to compile.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将四个`Book`对象放入向量`books`中。我们通过调用`emplace_back`方法（第11-18行）而不是`push_back`来实现这一点。`emplace_back`方法（在C++11中引入）接受存储类型（`Book`）的构造函数参数，并在向量的布局中构造一个对象，而不是复制或移动预先构造的对象。然后我们使用`std::sort`对向量进行排序，最终使用`Book`对象的`operator<`。如果没有这个重载的运算符，`std::sort`将无法编译。
- en: This is all great, but what if you wanted to sort the books in descending order
    of the ISBN? Or you could want to sort the books by their authors instead. Also,
    for two books with the same author, you might want to sort them further by their
    title. We will see a method to sort them this way in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但如果您想按ISBN的降序对书籍进行排序怎么办？或者您可能想按作者对书籍进行排序。此外，对于两本具有相同作者的书，您可能希望进一步按标题对它们进行排序。我们将在下一节中看到一种按这种方式对它们进行排序的方法。
- en: Function objects
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数对象
- en: 'There is a three-argument overload of `std::sort` algorithm that takes a function
    object for comparing two elements as the third argument. This function object
    should return true if the first argument appears before the second argument in
    the final ordering and false otherwise. So, even without an overloaded `operator<`,
    you can tell `std::sort` how to compare two elements and sort the vector. Here
    is how we do the sorting using an ordering function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sort`算法有一个三参数重载，第三个参数是一个用于比较两个元素的函数对象。这个函数对象应该在最终排序中如果第一个参数出现在第二个参数之前则返回true，否则返回false。因此，即使没有重载`operator<`，你也可以告诉`std::sort`如何比较两个元素并对向量进行排序。以下是使用排序函数进行排序的方法：'
- en: '**Listing 7.1: Passing functions to algorithms**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.1：将函数传递给算法**'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function `byDescendingISBN` takes const references to two books and returns
    true if the ISBN of the first book (`lhs`) is lexically greater than that of the
    second (`rhs`) and false otherwise. The signature of the function compatible with
    the function object that `std::sort` algorithm expects as its third argument.
    To sort the `books` vector in descending order, we pass to `std::sort`, a pointer
    to this function (line 7).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`byDescendingISBN`接受两本书的const引用，并在第一本书的ISBN（`lhs`）在字典顺序上大于第二本书（`rhs`）的ISBN时返回true，否则返回false。该函数的签名与`std::sort`算法期望的函数对象兼容。为了按降序对`books`向量进行排序，我们将指向这个函数的指针传递给`std::sort`（第7行）。
- en: 'Function pointers are by no means the only callable entities you can pass around.
    A *functor* is a type that overloads the function call operator member (`operator()`).
    By applying or calling an instance of a functor on a set of arguments, you invoke
    the overloaded `operator()` member. In the following example, we define a functor
    to order books by author names, and in case of a tie with author names, by titles:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针绝不是你可以传递的唯一可调用实体。*函数对象*是一种重载了函数调用运算符成员（`operator()`）的类型。通过在一组参数上应用或调用函数对象的实例，你调用了重载的`operator()`成员。在下面的例子中，我们定义了一个函数对象来按作者名对书籍进行排序，如果作者名相同，则按标题排序：
- en: '**Listing 7.2: Defining and passing functors to algorithms**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.2：定义和传递函数对象给算法**'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We define a functor called `CompareBooks` with an overloaded `operator()` that
    takes two `Book` objects to compare (line 4). It returns true if the name of the
    first book's author is lexicographically smaller than the name of second book's
    author. In case the authors of the two books are same, it returns true if the
    title of the first book is lexicographically smaller than that of the second.
    To use this functor as the sorting criterion, we pass a temporary instance of
    `CompareBooks` as the third argument of the `std::sort` algorithm (line 14). Functors
    like `CompareBooks`, that map one or more arguments to a Boolean truth value are
    called **predicates**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`CompareBooks`的函数对象，它重载了`operator()`，接受两个要比较的`Book`对象（第4行）。如果第一本书的作者名在字典顺序上小于第二本书的作者名，则返回true。如果两本书的作者相同，则如果第一本书的标题在字典顺序上小于第二本书的标题，则返回true。为了将这个函数对象作为排序标准使用，我们将`CompareBooks`的临时实例作为`std::sort`算法的第三个参数传递（第14行）。像`CompareBooks`这样将一个或多个参数映射到布尔真值的函数对象被称为**谓词**。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**A note on terminology**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语说明**'
- en: We use the term **function object** to refer to all callable entities that can
    be passed around and stored for later use by the application. These include function
    pointers and functors as well as other kinds of callable entities like unnamed
    functions or **lambdas**, which we will explore in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语**函数对象**来指代所有可调用的实体，可以在应用程序中传递和存储以供以后使用。这些包括函数指针和函数对象，以及其他类型的可调用实体，如未命名函数或**lambda**，我们将在本章中探讨。
- en: A **functor** is simply a class or struct that defines an overloaded function
    call operator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数对象**简单地是定义了重载的函数调用运算符的类或结构。'
- en: A function object that takes one or more arguments and maps them to a Boolean
    truth value is usually called a **predicate**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受一个或多个参数并将它们映射到布尔真值的函数对象通常被称为**谓词**。
- en: The **arity** of a function object is the number of arguments it takes. A function
    with no arguments has 0-arity or is **nullary**, a function with one argument
    has 1-arity or is **unary**, a function with two arguments has 2-arity or is **binary**,
    and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象的**arity**是它所接受的参数数量。没有参数的函数具有0-arity或者是**nullary**，一个参数的函数具有1-arity或者是**unary**，两个参数的函数具有2-arity或者是**binary**，依此类推。
- en: A **pure function** is a function whose return value depends solely on the values
    of the arguments passed to it and which has no side effects. Modifying states
    of objects not local to the function, performing I/O, or otherwise modifying the
    execution environment—all qualify as side effects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数**是一个其返回值仅取决于传递给它的参数值，并且没有副作用的函数。修改不属于函数的本地状态，执行I/O，或者以其他方式修改执行环境都属于副作用。'
- en: 'Functors are especially useful when you want them to retain some state between
    calls. For example, imagine you have an unsorted list of names, and you just want
    to make a comma-separated list of all names, starting with a particular letter.
    Here is a way to do this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望函数对象在调用之间保留一些状态时，函数对象特别有用。例如，想象一下你有一个未排序的名字列表，你只想制作一个以特定字母开头的所有名字的逗号分隔列表。以下是一种方法：
- en: '**Listing 7.3: Functors with states**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.3：带状态的函数对象**'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We define a functor called `ConcatIfStartsWith` (line 6), which stores some
    state, namely the starting character to match (`startCh`) and a string to contain
    the comma-separated list of names (`csNames`). When the functor is invoked on
    a name, it checks whether it starts with the specified character, and if so, concatenates
    it to `csNames` (lines 10-11). We use the `std::for_each` algorithm to apply the
    `ConcatIfStartsWith` functor to each name in a vector of names (lines 30-31),
    looking for names starting with the letter G. The functor we pass is a temporary
    one (line 31), but we need a reference to it in order to access the concatenated
    string stored in it. The `std::for_each` algorithm actually returns a reference
    to the passed functor, which we then use to get the concatenated string. Here
    is the output, listing the names starting with G:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`ConcatIfStartsWith`的函数对象（第6行），它存储一些状态，即要匹配的起始字符（`startCh`）和包含逗号分隔的名称列表的字符串（`csNames`）。当在名称上调用函数对象时，它会检查名称是否以指定字符开头，如果是，则将其连接到`csNames`（第10-11行）。我们使用`std::for_each`算法将`ConcatIfStartsWith`函数对象应用于名称向量中的每个名称（第30-31行），寻找以字母G开头的名称。我们传递的函数对象是一个临时的（第31行），但我们需要一个引用来访问其中存储的连接字符串。`std::for_each`算法实际上返回对传递的函数对象的引用，然后我们使用它来获取连接的字符串。这是输出，列出以G开头的名称：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This illustrates an important point about functors; they are particularly useful
    when you want to maintain state that persists between successive calls to the
    function. They are also great if you need to use them at multiple places in your
    code. By naming them intuitively, their purpose can be made evident at the point
    of use:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了关于函数对象的一个重要观点；当您希望在连续调用函数之间保持状态时，它们特别有用。如果您需要在代码中的多个地方使用它们，它们也非常有用。通过直观地命名它们，可以在使用的地方清楚地表明它们的目的：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But sometimes, what a functor needs to do is trivial (for example, to check
    whether a number is even or odd). Often, we don't need it to maintain any state
    between calls. We may not even need to use it at multiple places. Sometimes, the
    functionality we are looking for may already be there in some form, maybe as a
    member function of the objects. In such cases, writing a new functor seems like
    overkill. C++11 introduced lambdas or unnamed functions to address precisely such
    cases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，一个函数对象需要做的事情是微不足道的（例如，检查一个数字是偶数还是奇数）。通常，我们不需要在调用之间维护任何状态。我们甚至可能不需要在多个地方使用它。有时，我们正在寻找的功能可能已经以某种形式存在，也许作为对象的成员函数。在这种情况下，编写一个新的函数对象似乎有些过度。C++11引入了lambda或未命名函数，以精确解决这种情况。
- en: Lambdas – unnamed function literals
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda - 未命名函数文字
- en: The character string `"hello"` is a valid C++ expression. It has a well-defined
    type (`const char[6]`), can be assigned to variables of type `const char*`, and
    passed to functions that take arguments of type `const char*`. Likewise, there
    are numeric literals like `3.1415` or `64000U`, Boolean literals like `true` and
    `false`, and so on. C++11 introduces **lambda expressions** for generating anonymous
    functions defined at the site, where they are invoked. Often, simply called **lambdas**
    (from Alonzo Church's λ-calculus), they consist of a function body not bound to
    a function name and are used to generate a function definition at any point in
    the lexical scope of a program, where you would expect to pass a function object.
    Let us first understand how this is done with the help of an example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`"hello"`是一个有效的C++表达式。它有一个明确定义的类型（`const char[6]`），可以赋值给类型为`const char*`的变量，并传递给接受`const
    char*`类型参数的函数。同样，还有像`3.1415`或`64000U`这样的数字文字，像`true`和`false`这样的布尔文字，等等。C++11引入了**lambda表达式**，用于在调用它们的地方定义匿名函数。通常简称为**lambda**（来自Alonzo
    Church的λ演算），它们由一个未绑定到函数名称的函数体组成，并用于在程序的词法范围内的任何点生成函数定义，您期望传递一个函数对象。让我们首先通过一个例子来了解如何做到这一点。
- en: We have a list of integers, and we want to find the first odd number in the
    list using the `std::find_if` algorithm. The predicate passed to `std::find_if`
    is defined using a lambda.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个整数列表，并希望使用`std::find_if`算法在列表中找到第一个奇数。传递给`std::find_if`的谓词是使用lambda定义的。
- en: '**Listing 7.4: Using lambdas**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.4：使用lambda**'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The lambda to compute whether a number is odd or even is a block of code passed
    as the third argument to `std::find_if` (lines 9-10). Let us look at the lambda
    in isolation to understand the syntax. First, consider what this function does;
    given an integer, it returns true if it is odd and false otherwise. So, we have
    an unnamed function that maps an `int` to a `bool`. The way to write this in lambda-land
    is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个数字是奇数还是偶数的lambda是作为第三个参数传递给`std::find_if`的代码块（第9-10行）。让我们单独看一下lambda以了解语法。首先，考虑这个函数做什么；给定一个整数，如果它是奇数则返回true，否则返回false。因此，我们有一个未命名函数，将`int`映射到`bool`。在lambda-land中编写这个的方式如下：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We introduce the unnamed function with an empty pair of square brackets, and
    we describe the mapping by writing a parameter list like that of a conventional
    function, followed by an arrow and the return type. Following this, we write the
    body of the function just like you would for a normal function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一对空方括号引入未命名函数，并通过编写类似于常规函数的参数列表，后跟一个箭头和返回类型来描述映射。在此之后，我们编写函数体，就像为正常函数编写一样：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The pair of square brackets, often called **lambda introducers**, need not
    be empty, as we will see shortly. There are several other variations possible
    with this syntax, but you can define a lambda using just this bit of syntax. The
    return type specification for lambdas is optional in simple cases, where the compiler
    can easily deduce the return type from the function body. Thus, we could have
    rewritten the lambda from the preceding example without the return type because
    the function body is really simple:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号对，通常称为**lambda引入者**，不一定为空，我们很快就会看到。这种语法还有其他几种变体，但您可以仅使用这一小部分语法来定义lambda。在简单情况下，lambda的返回类型规范是可选的，编译器可以轻松从函数体中推断出返回类型。因此，我们可以重新编写前面示例中的lambda，而不需要返回类型，因为函数体实际上非常简单：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lambda captures
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Lambda捕获
- en: 'The lambda we defined in the previous example was a pure function without any
    state. In fact, how could a lambda conceivably store the state that persists between
    calls? Actually, lambdas can access local variables from the surrounding scope
    (in addition to global variables). To enable such an access, we can specify **capture
    clauses** in the lambda introducer to list which variables from the surrounding
    scope are accessible to the lambda and *how*. Consider the following example in
    which we filter out names longer than a user-specified length from a vector of
    names and return a vector containing only the shorter names:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的示例中定义的lambda是一个没有任何状态的纯函数。实际上，lambda如何可能存储在调用之间持续存在的状态？实际上，lambda可以访问来自周围范围的局部变量（以及全局变量）。为了启用这样的访问，我们可以在lambda引入器中指定**捕获子句**，列出了来自周围范围的哪些变量可以访问lambda以及*如何*。考虑以下示例，其中我们从名称向量中过滤出长度超过用户指定长度的名称，并返回仅包含较短名称的向量：
- en: '**Listing 7.5: Lambdas with captures**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.5：带捕获的lambda**'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `getNamesShorterThan` function takes two parameters: a vector called `names`
    and a variable `maxSize` that caps the size of strings to be filtered. It copies
    names shorter than `maxSize` from the `names` vector into a second vector called
    `shortNames`, using the `std::copy_if` algorithm from the standard library. We
    use a lambda expression (lines 12-14) to generate the predicate for `std::copy_if`.
    You can see that we name the `maxSize` variable from the surrounding lexical scope
    inside the square brackets (line 12), and access it inside the body of the lambda
    to compare the size of the passed string (line 13). This enables read-only access
    to the `maxSize` variable inside the lambda. If we wanted to potentially access
    any variable from the surrounding scope instead of a specific one, we could instead
    write the lambda with an equals sign in the square brackets; this would *implicitly
    capture* any variable used from the surrounding scope:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNamesShorterThan`函数接受两个参数：一个名为`names`的向量和一个名为`maxSize`的变量，该变量限制要过滤的字符串的大小。它将`names`向量中短于`maxSize`的名称复制到第二个名为`shortNames`的向量中，使用标准库中的`std::copy_if`算法。我们使用lambda表达式（第12-14行）生成`std::copy_if`的谓词。您可以看到我们在方括号中命名了来自周围词法范围的`maxSize`变量（第12行），并在lambda主体中访问它以比较传递的字符串的大小（第13行）。这使得lambda内部对`maxSize`变量的只读访问成为可能。如果我们想要潜在地访问周围范围中的任何变量而不是特定的变量，我们可以在方括号中使用等号来编写lambda；这将*隐式捕获*来自周围范围的任何使用的变量：'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You may want to modify a local copy of a variable from the surrounding scope,
    without affecting its value in the surrounding scope. To enable your lambda to
    do this, it must be declared as mutable:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望修改来自周围范围的局部变量的副本，而不影响周围范围中的值。为了使您的lambda能够执行此操作，必须将其声明为mutable：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `mutable` keyword trails the parameter list but appears before the return
    type if you specify one. This does not affect the value of `maxSize` in the surrounding
    scope.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutable`关键字跟在参数列表后面，但如果指定了返回类型，则出现在返回类型之前。这不会影响周围范围中`maxSize`的值。'
- en: You can also modify a variable from the surrounding scope inside a lambda. To
    do this, you must capture the variable by reference, by prefixing an ampersand
    to its name in the square brackets.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在lambda内部修改来自周围范围的变量。为此，必须通过在方括号中的变量名称前加上一个和符号来引用捕获变量。
- en: 'Here is listing 6.3 rewritten using a lambda:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用lambda重写的6.3清单：
- en: '**Listing 7.6: Reference captures in lambda**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.6：lambda中的引用捕获**'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding example, we concatenate all names from the vector `names`
    that start with a specific character. The starting character is picked up from
    the variable `startCh`. The concatenated string is stored in the variable `concat`.
    We call `std::for_each` on the elements of the vector and pass a lambda, which
    explicitly captures `concat` as a reference (with a leading ampersand) and `startCh`
    as a read-only value from the surrounding scope (line 13). Thus, it is able to
    append to `concat` (line 15). This code prints the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将来自向量`names`的所有以特定字符开头的名称连接起来。起始字符取自变量`startCh`。连接的字符串存储在变量`concat`中。我们对向量的元素调用`std::for_each`，并传递一个lambda，该lambda显式地将`concat`作为引用捕获（带有前导和符号），并将`startCh`作为来自周围范围的只读值传递（第13行）。因此，它能够附加到`concat`（第15行）。此代码打印以下输出：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the latest revision of the C++ Standard, dubbed C++14, lambdas get a little
    niftier. You can write a *generic lambda* whose parameter types are deduced based
    on the context. For example, in C++14, you can write the call to `std::for_each`
    in the previous example, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的C++标准中，被称为C++14，lambda变得更加巧妙。您可以编写一个*通用lambda*，其参数类型是根据上下文推断的。例如，在C++14中，您可以按照前面示例中的调用`std::for_each`，编写如下：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type of the argument to lambda is written as `const auto&`, and the compiler
    deduces it as `const std::string&` based on the type of elements in the iterated
    sequence.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: lambda的参数类型写为`const auto&`，编译器根据迭代序列中元素的类型推断为`const std::string&`。
- en: Delegates and closures
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 委托和闭包
- en: 'Let us suppose you are writing a high-level C++ API for reading incoming messages
    on a message queue. The client of your API must register for the types of messages
    it is interested in and pass a callback—a function object that will be invoked
    when messages of your interest arrive. Your API could be a member of a `Queue`
    class. Here is one possible API signature:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在编写一个用于读取消息队列上传入消息的高级C++ API。您的API的客户端必须注册其感兴趣的消息类型，并传递一个回调函数对象，当您感兴趣的消息到达时将调用该对象。您的API可以是`Queue`类的成员。以下是一个可能的API签名：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `listen` member template takes two parameters: the message type `msgtype`,
    which identifies the messages of interest, and a callback function object `cb`
    that will be called when a new message arrives. Since we want the client to be
    able to pass function pointers, pointer to member functions, functors, as well
    as lambdas for the callback, we make `listen` a member template parameterized
    on the type of the callback. Of course, the callback should have a specific signature.
    Let us suppose it should be compatible with the signature of the following function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen`成员模板接受两个参数：消息类型`msgtype`，用于标识感兴趣的消息，以及回调函数对象`cb`，当新消息到达时将调用它。由于我们希望客户端能够传递函数指针、成员函数指针、仿函数以及lambda作为回调，因此我们将`listen`作为一个成员模板参数化为回调类型。当然，回调应该具有特定的签名。假设它应该与以下函数的签名兼容：'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `Message` is the type of messages read from the queue. The `listen` member
    template is a little too permissive because it can be instantiated with function
    objects that do not conform to the preceding signature. For a signature-incompatible
    callback, a compilation error occurs at the point where the callback is invoked
    inside `listen` rather than the point where the nonconforming callback is passed.
    This can make debugging the compiler errors more difficult.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Message`是从队列中读取的消息的类型。`listen`成员模板有点过于宽松，因为它可以实例化为不符合前面签名的函数对象。对于不符合签名的回调，编译错误会发生在调用`listen`内部的回调处，而不是传递不符合签名的回调的地方。这可能会使调试编译器错误变得更加困难。
- en: 'The Boost.Function library and its C++11 incarnate `std::function` offer function
    object wrappers that are tailor-made to fix such problems. We can write the type
    of the function `msgRead` as `void (Message)`. The general syntax for the type
    of a function of arity N is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Function库及其C++11版本`std::function`提供了专门设计用于解决此类问题的函数对象包装器。我们可以将函数`msgRead`的类型写为`void
    (Message)`。具有N个参数的函数类型的一般语法如下：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The more familiar **function pointer type** corresponding to the preceding
    **function type** would be:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的**函数类型**对应的更熟悉的**函数指针类型**将是：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Thus, the type of a function `int foo(double, const char*)` would be:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数`int foo(double, const char*)`的类型将是：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A pointer to will be of type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 指针将是以下类型：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using `std::function` with the appropriate function type, we can declare `listen`
    so that it accepts only function objects that conform to the correct signature:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有适当函数类型的`std::function`，我们可以声明`listen`，以便它只接受符合正确签名的函数对象：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The callback is now declared to be of type `boost::function<void(Message)>`.
    You can now call `listen` with a pointer to a global function, a functor, or even
    a lambda, and it will only compile if the function object has a conforming signature.
    We could have used `std::function` in place of `boost::function` if we were using
    a C++11 compiler. On pre-C++11 compilers, `boost::function` supports signatures
    with up to ten arguments, while `std::function` does not have any such limitation
    as it uses C++11 *variadic templates*. For more features of `boost::function`
    and its differences from `std::function` (which are minor), you can refer to the
    online documentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 回调现在被声明为`boost::function<void(Message)>`类型。现在可以使用指向全局函数、仿函数或甚至lambda调用`listen`，只有当函数对象具有符合签名时才会编译。如果使用的是C++11编译器，我们可以使用`std::function`代替`boost::function`。在C++11之前的编译器上，`boost::function`支持最多十个参数的签名，而`std::function`没有任何这样的限制，因为它使用了C++11的*可变模板*。有关`boost::function`的更多特性及其与`std::function`的区别（这些区别很小），您可以参考在线文档。
- en: 'Passing a nonstatic member function as a callback requires a little bit more
    work, because a non-static member must be called on an instance of its class.
    Consider the following class `MessageHandler` with a member `handleMessage`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将非静态成员函数作为回调需要更多的工作，因为非静态成员必须在其类的实例上调用。考虑以下类`MessageHandler`，它有一个成员`handleMessage`：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `handleMessage` member function is implicitly passed a pointer to the `MessageHandler`
    object on which it is invoked as its first parameter; so its effective signature
    is:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleMessage`成员函数会隐式地传递一个指向其所调用的`MessageHandler`对象的指针作为其第一个参数；因此它的有效签名是：'
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we want to pass this as a callback to `Queue::listen`, we probably already
    know which object we want `handleMessage` to be called on, and it would be great
    if we could somehow attach that object instance too in the call to listen. There
    are a couple of ways in which this can be done.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将其作为回调传递给`Queue::listen`时，我们可能已经知道要调用`handleMessage`的对象，如果我们可以在调用listen时以某种方式附加该对象实例，那将是很好的。有几种方法可以做到这一点。
- en: 'The first method involves wrapping the call to `handleMessage` in a lambda
    and passing it to `listen`. The following snippet illustrates this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法涉及将对`handleMessage`的调用包装在lambda中，并将其传递给`listen`。以下代码片段说明了这一点：
- en: '**Listing 7.7: Member function callbacks using closures**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.7：使用闭包的成员函数回调**'
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, the second argument to `listen` is generated using a lambda expression,
    which also captures a pointer to the `handler` object from the surrounding scope.
    In this example, `handler` is a local variable in the calling scope, but the lambda
    captures it and binds it into the function object it generates. This function
    object is not invoked immediately on it but delayed until a message of interest
    is received on the queue, when it forwards the call to the `handleMessage` method
    on the `handler` object pointer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`listen`的第二个参数是使用lambda表达式生成的，它还捕获了来自周围范围的`handler`对象的指针。在这个例子中，`handler`是调用范围内的一个局部变量，但是lambda捕获了它并将其绑定到它生成的函数对象中。这个函数对象不会立即被调用，而是延迟到队列上接收到感兴趣的消息时，它会将调用转发到`handler`对象指针上的`handleMessage`方法。
- en: The `handler` pointer is created in the calling scope but becomes indirectly
    accessible in another scope via the lambda capture. This is referred to as **dynamic
    scoping**, and functions of this kind that bind to variables in the lexical scope,
    in which they are created, are called **closures**. Of course, the handler pointer
    must still point to a valid `MessageHandler` object at the time when `handleMessage`
    is called on it, not just when the lambda is created.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler`指针是在调用范围内创建的，但通过lambda捕获变得间接可访问到另一个范围。这被称为**动态作用域**，在创建它们的词法作用域中绑定到变量的这种函数被称为**闭包**。当然，在调用`handleMessage`时，`handler`指针仍然必须指向一个有效的`MessageHandler`对象，而不仅仅是在lambda创建时。'
- en: 'More often than not, such lambdas would be generated from inside a member function,
    like a member function of the `MessageHandler` class and would capture the `this`
    pointer with some consequent syntactic simplifications:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，这样的lambda表达式会从类的成员函数内部生成，比如`MessageHandler`类的成员函数，并且会捕获`this`指针，从而简化语法：
- en: '**Listing 7.8: Capturing this-pointer in lambdas**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.8：在lambda中捕获this指针**'
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, we create a closure using a lambda expression that
    captures the `this` pointer (line 6). The call to `handleMsg` inside the lambda
    automatically binds to the `this` pointer, just as it would in a member function.
    Callbacks, especially when bound to specific objects, as mentioned earlier, are
    sometimes called **delegates**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用lambda表达式创建了一个闭包，它捕获了`this`指针（第6行）。在lambda内部调用`handleMsg`会自动绑定到`this`指针，就像在成员函数中一样。回调函数，特别是绑定到特定对象的回调函数，如前所述，有时被称为**委托**。
- en: The `boost::function` / `std::function` wrapper provides an effective and type-checked
    way of passing and returning function objects as callbacks or delegates. They
    are sometimes called polymorphic function wrappers because they completely abstract
    the type of the underlying callable entity (function pointer, functor, and so
    on) from the caller. Most implementations allocate memory dynamically though,
    so you should pay due diligence to assess their impact on runtime performance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::function` / `std::function`包装器提供了一种有效的、经过类型检查的方式来传递和返回函数对象作为回调或委托。它们有时被称为多态函数包装器，因为它们完全将底层可调用实体（函数指针、函数对象等）的类型从调用者中抽象出来。大多数实现都会动态分配内存，因此您应该认真评估它们对运行时性能的影响。'
- en: Partial function application
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分函数应用
- en: 'Given the Standard Library function `pow`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 给定标准库函数`pow`：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Consider the effect of the line of code `x = pow(2, 3)`. When this line is encountered,
    the function `pow` is immediately called with two arguments, the values 2 and
    3\. The function `pow` computes 2 raised to 3 and returns the value 8.0, which
    is then assigned to `x`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下代码行`x = pow(2, 3)`的效果。当遇到这行代码时，函数`pow`立即被调用，带有两个参数，值为2和3。函数`pow`计算2的3次方，并返回值8.0，然后赋给`x`。
- en: 'Now, say you have a list of numbers, and you want to put their cubes into another
    list. The Standard Library algorithm `std::transform` is a perfect fit for this.
    We just need to find the right functor to raise the numbers to their cubic power.
    The following functor takes a single numeric argument and raises it to a specific
    power, using the `pow` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你有一个数字列表，你想把它们的立方放入另一个列表中。标准库算法`std::transform`非常适合这个任务。我们只需要找到正确的函数对象来将数字提升到它们的立方幂。以下函数对象接受一个数字参数，并使用`pow`函数将其提升到特定的幂：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We could also have used a lambda expression to generate the function object,
    as shown in listing 7.7 and 7.8 in the last section. Using `RaiseTo` with the
    `std::transform` algorithm, the following code does the job:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用lambda表达式来生成函数对象，就像上一节的清单7.7和7.8中所示。使用`RaiseTo`和`std::transform`算法，以下代码完成了任务：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The core computation in `RaiseTo` is done by the `pow` function. The `RaiseTo`
    functor provides a way to fix the power through the constructor argument and a
    call signature compatible with what `std::transform` expects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`RaiseTo`中的核心计算是由`pow`函数完成的。`RaiseTo`函数对象通过构造函数参数和与`std::transform`期望的调用签名兼容的方式来固定幂。'
- en: Imagine if you could do this in C++ without functors or lambdas. What if using
    the following *imaginary* syntax, you could do the same thing?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果在C++中可以不使用函数对象或lambda来做到这一点。如果使用以下*虚构的*语法，你可以做同样的事情吗？
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is as if you are passing the `pow` function with one of its two arguments
    fixed at 3 and asking the `transform` algorithm to fill in the blank; supply the
    number to raise to. The expression `pow(_, 3)` would have evaluated to a function
    object, taking one argument instead of 2\. We essentially achieved this using
    the `RaiseTo` functor, but the Boost Bind library and its C++11 incarnate `std::bind`
    help us do this with less syntax. Formally, what we have just done is referred
    to as **partial function application**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就好像你正在传递`pow`函数，其中有两个参数中的一个被固定为3，并要求`transform`算法填写空白；提供要提升的数字。表达式`pow(_, 3)`将会评估为一个函数对象，接受一个参数而不是2个。我们基本上使用`RaiseTo`函数对象实现了这一点，但Boost
    Bind库及其C++11版本的`std::bind`帮助我们以更少的语法来实现这一点。正式地说，我们刚刚做的被称为**部分函数应用**。
- en: 'To create a partially applied function object for `pow` using `bind`, you would
    need to write:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bind`创建一个部分应用的`pow`函数对象，你需要写：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding expression generates an unnamed functor which takes a single argument
    and returns its value raised to the power of 3, using the standard library function
    `pow`. The similarity with our imaginary syntax should be evident. The value to
    be cubed is passed as the sole argument of the generated functor and is mapped
    to the special placeholder `_1`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式生成了一个无名的函数对象，它接受一个参数并返回它的值的3次方，使用标准库函数`pow`。与我们的虚构语法的相似之处应该是显而易见的。要立方的值作为生成的函数对象的唯一参数传递，并映射到特殊的占位符`_1`。
- en: '**Listing 7.9: Using Boost Bind**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.9：使用Boost Bind**'
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the generated functor takes more arguments, then they could be mapped to
    the placeholders `_2`, `_3`, and so on, based on their positions in the argument
    list. In general, the nth argument maps to the placeholder *_n*. Boost Bind by
    default supports maximum nine positional placeholders (`_1` through `_9`); `std::bind`
    might support more (varies from one compiler to the next), but you will need to
    access them from the `std::placeholders` namespace, using one of the following
    directives:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成的函数对象接受更多的参数，则可以根据它们在参数列表中的位置将它们映射到占位符`_2`、`_3`等。一般来说，第n个参数映射到占位符`_n`。Boost
    Bind默认支持最多九个位置占位符（`_1`到`_9`）；`std::bind`可能支持更多（根据编译器的不同），但您需要从`std::placeholders`命名空间中访问它们，使用以下指令之一：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You may adapt functions by reordering their arguments without changing function
    arity to achieve a new functionality. For example, given the functor `std::less`
    that returns `true` if its first argument is less than its second argument, we
    can generate a functor, which returns true if its first argument is greater than
    its second argument by swapping the arguments. The following expression generates
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过重新排序它们的参数而不改变函数arity来调整函数以实现新的功能。例如，给定返回`true`的函数`std::less`，如果它的第一个参数小于它的第二个参数，我们可以生成一个函数对象，如果它的第一个参数大于它的第二个参数，则返回`true`。以下表达式生成了这个：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, `std::less<int>` takes two arguments, and we generate a wrapper function
    object, which also takes two arguments but swaps their positions before passing
    them to `std::less`. We can directly call the generated functor in-place, like
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`std::less<int>`接受两个参数，我们生成了一个包装函数对象，它也接受两个参数，但在将它们传递给`std::less`之前交换它们的位置。我们可以直接在原地调用生成的函数对象，就像这样：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can safely assert that 1 is not greater than 10 but is, in fact, less:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地断言1不大于10，但实际上是小于：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Boost Bind is also useful for generating delegates, and other methods of generating
    delegates were illustrated in listing 7.7 and 7.8\. Here is Listing 7.8 rewritten
    using `boost::bind`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Bind还可用于生成委托，清单7.7和7.8中还演示了生成委托的其他方法。以下是使用`boost::bind`重写的清单7.8：
- en: '**Listing 7.10: Generating delegates with Boost Bind**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7.10：使用Boost Bind生成委托
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We must bind a member function to an object instance. We do this by binding
    `this` to the first argument of `MessageHandler::handleMsg` (lines 6-7). This
    technique is generally useful for invoking member functions on each object in
    a collection. Moreover, `boost::bind` / `std::bind` intelligently deal with objects,
    pointers, smart pointers, and so on, so you do not need to write different binders,
    depending on whether it is a copy of an object, a pointer, or a smart pointer.
    In the following example, we take a vector of `std::string`s, compute their lengths
    using the `size` member function, and put them in a vector of lengths:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将一个成员函数绑定到一个对象实例。我们通过将`this`绑定到`MessageHandler::handleMsg`的第一个参数（第6-7行）来实现这一点。这种技术通常用于在集合中的每个对象上调用成员函数。此外，`boost::bind`
    / `std::bind`智能地处理对象、指针、智能指针等，因此您无需根据对象的复制、指针或智能指针来编写不同的绑定器。在下面的示例中，我们获取了一个`std::string`的向量，使用`size`成员函数计算它们的长度，并将它们放入一个长度向量中：
- en: '**Listing 7.11: Generating delegates with Boost Bind**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7.11：使用Boost Bind生成委托
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The lengths are computed by calling the `size` member function on each `std::string`
    object. The expression `std::bind(&std::string::size, _1)` generates an unnamed
    functor, which calls the `size` member on the `string` object passed to it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 长度是通过在每个`std::string`对象上调用`size`成员函数来计算的。表达式`std::bind(&std::string::size, _1)`生成了一个未命名的函数对象，它调用传递给它的`string`对象的`size`成员。
- en: Even if `names` was a vector of pointers to `std::string` objects, or smart
    pointers, the bind expression (line 9) would not need to change. The `bind` function
    takes its parameters by value. Thus, in the preceding example, each string is
    copied into the generated functor—a source of potential performance issue.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`names`是指向`std::string`对象的指针或智能指针的向量，绑定表达式（第9行）也不需要改变。`bind`函数按值传递其参数。因此，在前面的示例中，每个字符串都被复制到生成的函数对象中，这可能导致性能问题。
- en: Another function template called `boost::mem_fn` and its Standard Library counterpart
    `std::mem_fn` make it a tad easier to call member functions on objects and generate
    delegates. The `mem­_fn` function template creates a wrapper around pointers to
    class members. For a member function `f` of arity `N` in class `X`, `mem_fn(&X::f)`
    generates a functor of arity `N+1`, whose first argument must be a reference,
    pointer, or smart pointer to the object on which the member function is invoked.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为`boost::mem_fn`的函数模板及其标准库对应物`std::mem_fn`使得在对象上调用成员函数和生成委托变得更加容易。`mem_fn`函数模板创建了一个指向类成员的包装器。对于类`X`中的arity`N`的成员函数`f`，`mem_fn(&X::f)`生成一个arity`N+1`的函数对象，其第一个参数必须是对对象的引用、指针或智能指针，该对象上调用成员函数。
- en: 'We can write listing 7.11 to use `mem_fn` instead:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写清单7.11来使用`mem_fn`：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Because `std::string::size` is nullary, the functor generated by `boost::mem_fn`
    is unary and can be readily used with `transform`, without additional binding.
    The savings are in not having to write the `_1` placeholder, and thus have less
    syntactic noise.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`std::string::size`是nullary的，`boost::mem_fn`生成的函数对象是一元的，并且可以直接与`transform`一起使用，无需额外的绑定。节省了不必写`_1`占位符，因此语法上更简洁。
- en: 'When we generate a function object using `bind`, it does not immediately check
    whether the type and number of arguments match the signature of the function being
    bound to. Only when the generated function object is invoked, does the compiler
    detect parameter type and arity mismatch:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`bind`生成函数对象时，它不会立即检查参数类型和数量是否与绑定到的函数的签名匹配。只有在调用生成的函数对象时，编译器才会检测到参数类型和arity不匹配：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For example, the preceding code would compile even though you cannot call the
    `size` member function of `std::string` on a numeric literal 5 (line 2). Nor does
    the `size` member function take an additional numeric argument (line 3). But as
    soon as you try to call these generated function objects, you will get errors
    due to type and arity mismatch:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，即使你不能在数字文字 5 上调用 `std::string` 的 `size` 成员函数（第2行），前面的代码也会编译。`size` 成员函数也不接受额外的数字参数（第3行）。但是一旦你尝试调用这些生成的函数对象，你将因为类型和参数数量不匹配而得到错误：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Binding member functions that are overloaded requires more syntactic effort.
    Generating functions of even moderate complexity with `bind` is an exercise in
    nesting binds, which more often than not produces unmaintainable code. In general,
    with the availability of C++11 lambda and its further refinement in C++14, lambdas
    rather than bind should be the preferred mechanism of generating unnamed functors.
    Use `bind` only when it makes your code more expressive than a lambda can.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定重载的成员函数需要更多的语法工作。使用 `bind` 生成甚至是中等复杂度的函数是一个嵌套绑定的练习，这往往会产生难以维护的代码。一般来说，有了 C++11
    lambda 的可用性以及在 C++14 中的进一步完善，应该优先使用 lambda 而不是 bind 作为生成匿名函数对象的机制。只有在使用 `bind`
    使你的代码比 lambda 更具表现力时才使用它。
- en: Compile-time programming with Boost
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Boost 进行编译时编程
- en: Templates allow us to write C++ code that is independent of specific types of
    operands and can thus work unchanged with a large family of types. We can create
    both **function templates** and **class templates** (or struct templates), which
    take type parameters, nontype parameters (like constant integers), as well as
    template parameters. When a *specialization* of a class template is instantiated,
    member functions that are not directly or indirectly called are never instantiated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模板允许我们编写独立于操作数特定类型的 C++ 代码，因此可以在大量类型的情况下不变地工作。我们可以创建**函数模板**和**类模板**（或结构模板），它们接受类型参数、非类型参数（如常量整数）以及模板参数。当类模板的*特化*被实例化时，从未直接或间接调用的成员函数将不会被实例化。
- en: The power of C++ templates goes beyond the ability to write generic code though.
    C++ templates are a powerful computation subsystem using which we can introspect
    C++ types, glean their properties, and write sophisticated recursive and branching
    logic that executes at compile time. Using these capabilities, it is possible
    to define generic interfaces to implementations that are highly optimized for
    each type they operate upon.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 模板的威力不仅仅在于能够编写通用代码。C++ 模板是一个强大的计算子系统，我们可以利用它来审视 C++ 类型，获取它们的属性，并编写复杂的递归和分支逻辑，这些逻辑在编译时执行。利用这些能力，我们可以定义对每种操作类型高度优化的通用接口。
- en: Basic compile-time control flow using templates
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板进行基本的编译时控制流
- en: In this section, we briefly look at branching and recursive logic generated
    using templates.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要地看一下使用模板生成的分支和递归逻辑。
- en: Branching
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支
- en: 'Consider the function template `boost::lexical_cast`, introduced in [Chapter
    2](ch02.html "Chapter 2. The First Brush with Boost''s Utilities"), *The First
    Brush with Boost''s Utilities*. To convert a `string` to a `double`, we would
    write code like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑函数模板 `boost::lexical_cast`，它在[第 2 章](ch02.html "第 2 章. Boost 实用工具的初次尝试")中介绍过，*Boost
    实用工具的初次尝试*。要将 `string` 转换为 `double`，我们可以编写如下代码：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The primary template of `lexical_cast` is declared this way:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`lexical_cast` 的主模板是这样声明的：'
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The default implementation of `lexical_cast` (called the **primary template**)
    writes the source object to a memory buffer via an interface like `ostringstream`
    and reads back from it via another interface like `istringstream`. This conversion
    may incur some performance overhead but has an expressive syntax. Now let us suppose
    that for a particularly performance-intensive application, you want to improve
    the performance of these string-to-double conversions, but do not want to replace
    `lexical_cast` with some other function calls. How would you do it? We can create
    an **explicit specialization** of the `lexical_cast` function template to perform
    a branching at compile time based on the types involved in the conversion. Since
    we want to override the default implementation for `string` to `double` conversions,
    this is how we would write the specialization:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`lexical_cast` 的默认实现（称为**主模板**）通过类似 `ostringstream` 的接口将源对象写入内存缓冲区，然后通过类似 `istringstream`
    的另一个接口从中读取。这种转换可能会产生一些性能开销，但具有表现力的语法。现在假设对于一个特别性能密集型的应用程序，你想要提高这些字符串到双精度浮点数的转换性能，但又不想用其他函数调用替换
    `lexical_cast`。你会怎么做？我们可以创建 `lexical_cast` 函数模板的**显式特化**，以便根据转换中涉及的类型在编译时执行分支。由于我们想要覆盖默认实现的
    `string` 到 `double` 转换，这就是我们会写特化的方式：'
- en: '**Listing 7.12: Explicit specialization of function templates**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 7.12：函数模板的显式特化**'
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `template` keyword with an empty argument list (`template<>`) indicates
    that this is a specialization for specific type arguments (line 2). The **template
    identifier** `lexical_cast <double, std::string>` lists the specific types for
    which the specialization takes effect (line 3). With this specialization available,
    the compiler invokes it whenever it sees code like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 关键字与空参数列表 (`template<>`) 表示这是特定类型参数的特化（第2行）。**模板标识符** `lexical_cast
    <double, std::string>` 列出了特化生效的特定类型（第3行）。有了这个特化，编译器在看到这样的代码时会调用它：'
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that it is possible to *overload function templates* (not just functions).
    For example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*重载函数模板*（而不仅仅是函数）是可能的。例如：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding example, `foo` is a function template (1) that is overloaded
    (2 and 3). The function `foo` itself is overloaded (4). The function template
    `foo` (1) is also specialized (5). When the compiler encounters a call to `foo`,
    it first looks for a matching non-template overload, failing which it looks for
    the most specialized template overload. In the absence of a matching specialized
    overload, this would simply resolve to the primary template. Thus, the call to
    `foo(&x)` resolves to `template<typename T> void foo(T*)`. If such an overload
    was not present, it would resolve to `template<typename T> void foo(T)`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`foo`是一个函数模板（1），它被重载（2和3）。函数`foo`本身也被重载（4）。函数模板`foo`（1）也被专门化（5）。当编译器遇到对`foo`的调用时，它首先寻找匹配的非模板重载，如果找不到，则寻找最专门化的模板重载。在没有匹配的专门化重载的情况下，这将简单地解析为主模板。因此，对`foo(&x)`的调用解析为`template<typename
    T> void foo(T*)`。如果不存在这样的重载，它将解析为`template<typename T> void foo(T)`。
- en: 'It is possible to create specializations for class templates too. In addition
    to explicit specializations, which specialize a class template for a fixed set
    of type and non-type arguments, we can also create **partial specializations**
    of class templates that specialize a class template for a family or category of
    types:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类模板也可以创建专门化。除了显式专门化之外，还可以创建类模板的**部分专门化**，为一类类型专门化一个类模板。
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding example, the primary template `Bar` takes two type arguments.
    We create a partial specialization for `Bar` for those cases, where the first
    of these two arguments is a pointer-type and the second argument is the pointer-type
    for the first. Thus, instantiating `Bar<int, float>` or `Bar<double, double*>`
    will instantiate the primary template, but `Bar<float*, float>`, `Bar<Foo*, Foo>`,
    etc. will instantiate the partially specialized template. Note that functions
    cannot be partially specified.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，主模板`Bar`接受两个类型参数。我们为`Bar`创建了一个部分特化，对于这些情况，其中这两个参数中的第一个是指针类型，第二个参数是第一个参数的指针类型。因此，实例化`Bar<int,
    float>`或`Bar<double, double*>`将实例化主模板，但`Bar<float*, float>`，`Bar<Foo*, Foo>`等将实例化部分特化模板。请注意，函数不能被部分指定。
- en: Recursion
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归
- en: Recursion using templates is best illustrated using an example of calculating
    factorials at compile time. Class templates (as well as function templates) can
    take integer arguments as long as the values are known at compile time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板进行递归最好通过一个在编译时计算阶乘的例子来说明。类模板（以及函数模板）可以接受整数参数，只要这些值在编译时是已知的。
- en: '**Listing 7.13: Compile-time recursion using templates**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.13：使用模板进行编译时递归**'
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The primary template for calculating factorials defines a compile-time constant
    enum `value`. The `value` enum in `Factorial<N>` contains the value of the factorial
    of `N`. This is calculated recursively by instantiating the `Factorial` template
    for `N-1` and multiplying its nested `value` enum with `N`. The stopping condition
    is provided by the specialization of `Factorial` for 0\. These calculations happen
    at compile time, as the `Factorial` template gets instantiated with successively
    smaller arguments until `Factorial<0>` stops further instantiation. Thus, the
    value `40320` is computed completely at compile time and baked into the binary
    that is built. For example, we could have written the following and it would have
    compiled and generated an array of 40320 integers on the stack:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算阶乘的主模板定义了一个编译时常量枚举`value`。`Factorial<N>`中的`value`枚举包含`N`的阶乘值。这是通过递归计算的，通过实例化`Factorial`模板为`N-1`并将其嵌套的`value`枚举与`N`相乘来实现的。停止条件由专门化的`Factorial`为0提供。这些计算发生在编译时，因为`Factorial`模板被用逐渐变小的参数实例化，直到`Factorial<0>`停止进一步的实例化。因此，值`40320`完全在编译时计算，并嵌入到构建的二进制文件中。例如，我们可以编写以下内容，它将编译并在堆栈上生成一个包含40320个整数的数组：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Boost Type Traits
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost类型特征
- en: The Boost Type Traits library provides a set of templates used to query types
    for properties and generate derivative types at compile time. They are useful
    in generic code, that is, code which uses parameterized types, for purposes such
    as choosing an optimal implementation based on the properties of a type parameter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Boost类型特征库提供了一组模板，用于在编译时查询类型的属性并生成派生类型。它们在通用代码中很有用，即使用参数化类型的代码，用于根据类型参数的属性选择最佳实现。
- en: 'Consider the following template:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下模板：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `IsPointer` template has a nested enum called `value`. This is set to 0
    in the primary template. We also define a partial specialization of `IsPointer`
    for pointer-type arguments and set the nested `value` to 1\. How is this class
    template useful? For any type `T`, `IsPointer<T>::value` is 1 if and only if `T`
    is a pointer-type and 0 otherwise. The `IsPointer` template maps its type argument
    to a compile-time constant value 0 or 1, which can be used for further branching
    decisions at compile time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsPointer`模板有一个名为`value`的嵌套枚举。这在主模板中设置为0。我们还为指针类型的参数定义了`IsPointer`的部分特化，并将嵌套的`value`设置为1。这个类模板有什么用呢？对于任何类型`T`，只有当`T`是指针类型时，`IsPointer<T>::value`才为1，否则为0。`IsPointer`模板将其类型参数映射到一个编译时常量值0或1，这可以用于进一步的编译时分支决策。'
- en: The Boost Type Traits library is chock full of such templates (including `boost::is_pointer`)
    that can glean information about types and also generate new types at compile
    time. They can be used for selecting or generating the optimal code for the types
    at hand. Boost Type Traits was accepted for the C++ TR1 release in 2007 and as
    of C++11, there is a Type Traits library in the Standard Library.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Boost类型特征库中充满了这样的模板（包括`boost::is_pointer`），它们可以获取有关类型的信息，并且还可以在编译时生成新类型。它们可以用于选择或生成针对手头类型的最佳代码。Boost类型特征在2007年被接受为C++
    TR1版本，并且在C++11中，标准库中有一个类型特征库。
- en: Each type trait is defined in its own header so that you can include only those
    type traits that you need. For example, `boost::is_pointer` would be defined in
    `boost/type_traits/is_pointer.hpp`. The corresponding `std::is_pointer` (introduced
    in C++11) is defined in the standard header `type_traits`, there being no separate
    standard header for it. Each type trait has an embedded type called `type`, and
    in addition, it may have a member `value` of type bool. Here is an example of
    using a few type traits.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型特征都在自己的头文件中定义，这样您就可以只包含您需要的那些类型特征。例如，`boost::is_pointer`将在`boost/type_traits/is_pointer.hpp`中定义。相应的`std::is_pointer`（在C++11中引入）定义在标准头文件`type_traits`中，没有单独的标准头文件。每个类型特征都有一个嵌入类型称为`type`，此外，它可能有一个名为`value`的bool类型成员。以下是使用一些类型特征的示例。
- en: '**Listing 7.14: Using type traits**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.14：使用类型特征**'
- en: '[PRE52]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, we use a number of type traits to query information about types.
    We define a type `intptr` as an integer pointer (line 18). Applying `boost::is_pointer`
    to `intptr` yields true (line 20).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了许多类型特征来查询有关类型的信息。我们将类型`intptr`定义为整数指针（第18行）。将`boost::is_pointer`应用于`intptr`将返回true（第20行）。
- en: The `decltype` specifier used here was introduced in C++ 11\. It generates the
    type of the expression or entity it is applied to. Thus, `decltype(arr)` (line
    24) yields the declared type of arr, including any `const` or `volatile` qualifiers.
    It is a useful means of computing the type of an expression. We apply the `boost::is_array`
    trait to an array type, which obviously yields true (line 24). To find the number
    of dimensions or the rank of an array, we use the trait `boost::rank` (lines 25
    and 26). The rank of `arr[10]` is 1 (line 25), but the rank of `arr2[10][15]`
    is 2 (line 26). The `boost::extent` trait is used to find the extent of an array's
    rank. It must be passed the array's type and rank. If the rank is not passed,
    it defaults to 0 and returns the extent for one-dimensional arrays (line 27) or
    the zeroth dimension of multi-dimensional arrays (line 28). Otherwise, the rank
    should be explicitly specified (line 29).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的`decltype`说明符是在C++ 11中引入的。它生成应用于表达式或实体的类型。因此，`decltype(arr)`（第24行）返回arr的声明类型，包括任何`const`或`volatile`限定符。这是计算表达式类型的有用手段。我们将`boost::is_array`特征应用于数组类型，显然返回true（第24行）。要找到数组的维数或秩，我们使用特征`boost::rank`（第25和26行）。`arr[10]`的秩为1（第25行），但`arr2[10][15]`的秩为2（第26行）。`boost::extent`特征用于查找数组秩的范围。它必须传递数组的类型和秩。如果未传递秩，则默认为0，并返回一维数组的范围（第27行）或多维数组的零维（第28行）。否则，应明确指定秩（第29行）。
- en: The `boost::is_pod` trait returns whether a type is a Plain Old Data type or
    not. It returns true for a simple struct without any constructors or destructors
    like `MyStruct` (line 34) and false for `std::string`, which is obviously not
    a POD type (line 38).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::is_pod`特征返回一个类型是否是POD类型。它对于一个没有任何构造函数或析构函数的简单结构，如`MyStruct`，返回true（第34行），对于显然不是POD类型的`std::string`，返回false（第38行）。'
- en: As mentioned before, there is also an embedded type in these traits called `type`.
    This is defined as `boost::true_type` or `boost::false_type`, depending on whether
    the trait returned true or false. Now consider that we are writing a generic algorithm
    to copy arrays of arbitrary objects into an array on the heap. For POD-types,
    a shallow copy or `memcpy` of the whole array is good enough, while for non-POD
    types, we need to perform element by element copies.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些特征中还有一个嵌入类型称为`type`。这被定义为`boost::true_type`或`boost::false_type`，具体取决于特征返回true还是false。现在假设我们正在编写一个通用算法，将任意对象的数组复制到堆上的数组中。对于POD类型，整个数组的浅复制或`memcpy`就足够了，而对于非POD类型，我们需要逐个元素复制。
- en: '**Listing 7.15: Leveraging type traits**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.15：利用类型特征**'
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `fastCopy` function template creates a copy of the array on the heap (lines
    31-35). We create two overloads of it: one for copying POD-types (lines 11-12)
    and the other for copying non-POD types (lines 21-22), by adding a second parameter
    of type `boost::true_type` in the first case and `boost::false_type` in the second
    case. We create two arrays: one of the POD-type `MyStruct` and the other of the
    non-POD type `std::string` (lines 42-43). We call `fastCopy` on both, which are
    resolved to the one argument overload (line 32). This forwards the call to the
    two argument overloads of `fastCopy`, passing an instance of `boost::is_pod<T>::type`
    as the second argument (line 34). This automatically routes the call to the correct
    overload, depending on whether the stored type `T` is POD-type or not.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`fastCopy`函数模板在堆上创建数组的副本（第31-35行）。我们创建了两个重载：一个用于复制POD类型（第11-12行），另一个用于复制非POD类型（第21-22行），在第一种情况下添加`boost::true_type`类型的第二个参数，在第二种情况下添加`boost::false_type`类型的第二个参数。我们创建了两个数组：一个是POD类型`MyStruct`，另一个是非POD类型`std::string`（第42-43行）。我们在两者上调用`fastCopy`，这将解析为单参数重载（第32行）。这将调用`fastCopy`的两个参数重载，传递`boost::is_pod<T>::type`的实例作为第二个参数（第34行）。这将根据存储的类型`T`是POD类型还是非POD类型自动路由调用到正确的重载。'
- en: There are many, many more type traits than we can cover in the scope of this
    book. You have type traits to check whether one type is a base class of another
    (`boost::is_base`), whether a type is copy constructible (`boost::is_copy_constructible`),
    has specific operators (for example, `boost::has_pre_increment`), is same as another
    type (`boost::is_same`), and so on. The online documentation is a good place to
    go dig traits and see which ones fit a job at hand.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围内有许多类型特征，远远超出我们可以涵盖的范围。您可以使用类型特征来检查一个类型是否是另一个类型的基类（`boost::is_base`），一个类型是否可以被复制构造（`boost::is_copy_constructible`），是否具有特定的操作符（例如，`boost::has_pre_increment`），是否与另一个类型相同（`boost::is_same`）等等。在线文档是挖掘特征并找到适合当前工作的特征的好地方。
- en: SFINAE and enable_if / disable_if
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SFINAE和enable_if / disable_if
- en: Each time a compiler encounters a call to a function with the same name as a
    function template, it creates an overload resolution set of matching template
    and non-template overloads. The compiler deduces template arguments as needed
    to determine which function template overloads (and specializations thereof) qualify,
    and the qualifying template overloads are instantiated in the process. If substitution
    of the deduced type arguments in the template's argument list or the function
    parameter list causes an error, this does not cause the compilation to abort.
    Instead, the compiler removes the candidate from its overload resolution set.
    This is referred to as **Substitution Failure Is Not An Error** or **SFINAE**.
    The compiler only flags an error if, at the end of the process, the overload resolution
    set is empty (no candidates) or has multiple equally good candidates (ambiguity).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每次编译器遇到与函数模板同名的函数调用时，它会创建一个匹配模板和非模板重载的重载解析集。编译器根据需要推断模板参数，以确定哪些函数模板重载（及其特化）符合条件，并在此过程中实例化符合条件的模板重载。如果在模板的参数列表或函数参数列表中替换推断出的类型参数导致错误，这不会导致编译中止。相反，编译器会从重载解析集中移除该候选项。这被称为**替换失败不是错误**或**SFINAE**。只有在过程结束时，重载解析集为空（没有候选项）或有多个同样好的候选项（歧义）时，编译器才会标记错误。
- en: Using a few clever tricks involving compile-time type computation, it is possible
    to leverage SFINAE to conditionally include templates or exclude them from the
    overload resolution set. The most succinct syntax to do this is provided by the
    `boost::enable_if` / `boost::disable_if` templates that are part of the Boost.Utility
    library.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 利用一些巧妙的技巧，涉及编译时类型计算，可以利用SFINAE有条件地包含模板或从重载解析集中排除它们。最简洁的语法是由`boost::enable_if`
    / `boost::disable_if`模板提供的，它们是Boost.Utility库的一部分。
- en: 'Let us write a function template to copy an array of elements into another
    array. The signature of the primary template is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数模板，将一个元素数组复制到另一个数组中。主模板的签名如下：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Thus, you pass two arrays of same size storing the same type of elements, and
    the elements of the second arguments are copied into the first array in the correct
    order. We also assume that the arrays never overlap; this keeps the implementation
    simple. Needless to say this is not the most general setting in which such an
    assignment can take place, but we will relax some of these restrictions a little
    later. Here is a generic implementation for this template:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您传递两个存储相同类型元素的相同大小的数组，第二个参数的元素按正确顺序复制到第一个数组中。我们还假设数组永远不会重叠；这保持了实现的简单性。不用说，这不是这样的赋值可以发生的最一般情况，但我们稍后会放宽一些这些限制。这是此模板的通用实现：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The first opportunity for optimization here is when T is a POD-type and a bitwise
    copy is good enough and possibly faster. We will create a special implementation
    for POD-types and use SFINAE to choose this implementation only when we are dealing
    with arrays of POD-types. Our technique should exclude this overload from the
    overload set when dealing with non-POD type arrays. Here is the special implementation
    for POD-types:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个优化机会是当T是POD类型且位拷贝足够好且可能更快时。我们将为POD类型创建一个特殊的实现，并使用SFINAE仅在处理POD类型数组时选择此实现。我们的技术应该在处理非POD类型数组时将此重载排除在重载集之外。这是POD类型的特殊实现：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you noticed, the two implementations have identical signature and obviously
    cannot coexist. This is where the `boost::enable_if` template comes in. The `boost::enable_if`
    template takes two parameters: a type `T` and a second type `E`, which defaults
    to `void`. `enable_if` defines an embedded type called `type`, which is typedef''d
    to `E` only when `T` has an embedded type called `type` and `T::type` is `boost::true_type`.
    Otherwise, no embedded type is defined. Using `enable_if`, we modify the optimized
    implementation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，这两个实现具有相同的签名，显然不能共存。这就是`boost::enable_if`模板发挥作用的地方。`boost::enable_if`模板接受两个参数：一个类型`T`和第二个类型`E`，默认为`void`。`enable_if`定义了一个名为`type`的嵌入类型，当`T`有一个名为`type`的嵌入类型且`T::type`是`boost::true_type`时，它被typedef为`E`。否则，不定义嵌入类型。使用`enable_if`，我们修改了优化实现。
- en: '**Listing 7.16: Using enable_if**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.16：使用enable_if**'
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `typename` keyword is required because otherwise the compiler has no way
    of knowing whether the expression `boost::enable_if<boost::is_pod<T>>::type` names
    a type or a member.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`typename`关键字是必需的，因为否则编译器无法知道表达式`boost::enable_if<boost::is_pod<T>>::type`是一个类型还是一个成员。'
- en: 'If we now instantiate an array of a non-POD type, it will resolve to the default
    implementation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在实例化一个非POD类型的数组，它将解析为默认实现：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The call to `copy` causes the compiler to instantiate both templates but `boost::is_pod<std::string>::type`
    is `boost::false_type`. Now `enable_if<false_type>` does not have a nested type
    as required by the return type specification of the version of `copy` optimized
    for POD-arrays. Therefore, there is a substitution failure, and this overload
    is removed from the overload resolution set, and the first or generic implementation
    is invoked. Now consider what happens in the following case, where we try to copy
    an array of POD-types (`double`):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对`copy`的调用会导致编译器实例化两个模板，但`boost::is_pod<std::string>::type`是`boost::false_type`。现在`enable_if<false_type>`没有嵌套类型，这是`copy`版本的返回类型规范所要求的。因此，存在替换失败，这个重载被从重载解析集中移除，并调用第一个或通用实现。现在考虑以下情况，我们尝试复制POD类型（`double`）的数组：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the current state of affairs, the POD-optimized version will no longer encounter
    a substitution failure, but the default implementation would also be signature-compatible
    with this call. Thus, there would be ambiguity and this would result in a compiler
    error. To fix this, we would have to make sure that the generic implementation
    excuses itself from the overload set this time. This is done using `boost::disable_if`
    (which is really `boost::enable_if` negated) in the return type of the generic
    implementation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前情况下，POD 优化版本将不再遇到替换失败，但默认实现也将与此调用兼容。因此，会出现歧义，这将导致编译器错误。为了解决这个问题，我们必须确保通用实现这次从重载集中豁免自己。这是通过在通用实现的返回类型中使用
    `boost::disable_if`（实际上是 `boost::enable_if` 的否定形式）来实现的。
- en: '**Listing 7.17: Using disable_if**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 7.17：使用 disable_if**'
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When `T` is a POD-type, `is_pod<T>::type` is `boost::true_type`. `boost::disable_if<true_type>`
    does not have a nested `type` and thus a substitution failure occurs with the
    generic implementation. This way, we build two mutually exclusive implementations
    that are correctly resolved at compile time.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `T` 是 POD 类型时，`is_pod<T>::type` 是 `boost::true_type`。`boost::disable_if<true_type>`
    没有嵌套的 `type`，因此在通用实现中会发生替换失败。这样，我们构建了两个互斥的实现，在编译时正确解析。
- en: 'We can also use the `boost::enable_if_c<>` template which takes a Boolean parameter
    instead of a type. `boost::enable_if_c<true>` has an embedded `type`, while `boost::enable_if_c<false>`
    does not. With these, the return type in listing 7.17 would look like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `boost::enable_if_c<>` 模板，它接受一个布尔参数而不是类型。`boost::enable_if_c<true>`
    有一个嵌入的 `type`，而 `boost::enable_if_c<false>` 没有。在清单 7.17 中，返回类型将如下所示：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The Standard Library, as of C++11, has `std::enable_if` only, and it behaves
    like `boost::enable_if_c`, taking a Boolean argument rather than a type. It is
    available from the standard header `type_traits`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库在 C++11 中只有 `std::enable_if`，它的行为类似于 `boost::enable_if_c`，接受一个布尔参数而不是类型。它可以从标准头文件
    `type_traits` 中获得。
- en: The Boost Metaprogramming Library (MPL)
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost 元编程库（MPL）
- en: The **Boost Metaprogramming Library**, **MPL** for short, is a general purpose
    library for template metaprogramming. It is ubiquitous in the Boost codebase,
    and most libraries use some metaprogramming facility from MPL. Some libraries
    like Phoenix, BiMap, MultiIndex, and Variant use it very heavily. It is used heavily
    for type manipulation and optimization through conditional selection of specific
    template implementations. This section is a short overview of some of the concepts
    and techniques involving MPL.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boost 元编程库**，简称 **MPL**，是一个用于模板元编程的通用库。它在 Boost 代码库中无处不在，大多数库都使用了 MPL 的一些元编程功能。一些库，如
    Phoenix、BiMap、MultiIndex 和 Variant，使用得非常频繁。它被广泛用于类型操作和通过条件选择特定模板实现进行优化。本节是关于 MPL
    涉及的一些概念和技术的简要概述。'
- en: Metafunctions
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元函数
- en: The heart of the MPL library is a **metafunction**. Formally, a metafunction
    is either a class template with only type parameters or a class, which exposes
    a single embedded type called `type`. In effect, type parameters if any are analogous
    to parameters to a function and the embedded `type`, which is computed at compile
    time based on the parameters, is analogous to the return value of a function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: MPL 库的核心是**元函数**。形式上，元函数要么是只有类型参数的类模板，要么是一个类，它公开一个名为 `type` 的嵌入类型。实际上，如果有的话，类型参数类似于函数的参数，而根据参数在编译时计算得到的嵌入
    `type` 类似于函数的返回值。
- en: 'Type traits provided by Boost Type Traits library are first-class metafunctions.
    Consider the `boost::add_pointer` type trait:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Type Traits 库提供的类型特征是一流的元函数。考虑 `boost::add_pointer` 类型特征：
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The type `add_pointer<int>::type` is `int*`. The `add_pointer` template is a
    unary metafunction with a single type parameter and an embedded type called `type`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_pointer<int>::type` 类型是 `int*`。`add_pointer` 模板是一个一元元函数，有一个类型参数和一个名为 `type`
    的嵌入类型。'
- en: Sometimes, the effective result of a type computation is numeric – case in point
    `boost::is_pointer<T>` (Boolean truth value) or `boost::rank<T>` (a positive integer).
    In such cases, the embedded `type` will have a static member called `value` containing
    this result, and it will also be directly accessible from the metafunction as
    a non-type member called `value`. Thus, `boost::is_pointer<T>::type::value` and
    `boost::is_pointer<T>::value` are both valid, the latter being more concise.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，类型计算的有效结果是数值型的 - 例如 `boost::is_pointer<T>`（布尔真值）或 `boost::rank<T>`（正整数）。在这种情况下，嵌入的
    `type` 将具有一个名为 `value` 的静态成员，其中包含此结果，并且还可以直接从元函数中作为非类型成员的 `value` 访问。因此，`boost::is_pointer<T>::type::value`
    和 `boost::is_pointer<T>::value` 都是有效的，后者更加简洁。
- en: Using MPL metafunctions
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 MPL 元函数
- en: The MPL working in conjunction with Boost Type Traits makes a lot of metaprogramming
    jobs easy. For this, the MPL provides a number of metafunctions to compose existing
    metafunctions together.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: MPL 与 Boost Type Traits 协同工作，使得许多元编程工作变得简单。为此，MPL 提供了许多将现有元函数组合在一起的元函数。
- en: 'Like type traits, MPL facilities are partitioned into independent, highly granular
    header files. All metafunctions are in the `boost::mpl` namespace. We can compose
    unnamed metafunctions together into composite metafunctions using the MPL library.
    This is not unlike lambdas and bind at runtime. The following snippet uses `boost::mpl::or_`
    metafunction to check whether a type is either an array or a pointer:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型特征一样，MPL 设施被分成独立的、高度细粒度的头文件。所有元函数都在 `boost::mpl` 命名空间中。我们可以使用 MPL 库将未命名的元函数组合成复合元函数。这与运行时的
    lambda 和 bind 类似。以下代码片段使用 `boost::mpl::or_` 元函数来检查一个类型是否是数组或指针：
- en: '**Listing 7.18: Using MPL metafunctions**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 7.18：使用 MPL 元函数**'
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `boost::mpl::or_` metafunction checks whether any of its argument metafunctions
    evaluates to true. We can create our own reusable metafunction that packages the
    preceding logic by using a technique called **metafunction forwarding**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::mpl::or_` 元函数检查其参数元函数中是否有任何一个评估为 true。我们可以使用一种称为**元函数转发**的技术，创建自己的可重用元函数，将前述逻辑打包起来。'
- en: '**Listing 7.19: Creating your own metafunction**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 7.19：创建自己的元函数**'
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We combine the existing type trait metafunctions using `boost::mpl::or_` and
    inherit from the composed entity, as shown in the preceding listing (line 6).
    We can now use `is_pointer_or_array` like any type trait.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `boost::mpl::or_` 来组合现有的类型特性元函数，并从组合实体继承，如前述清单所示（第6行）。现在我们可以像使用任何类型特性一样使用
    `is_pointer_or_array`。
- en: 'Sometimes, we need to pass numeric arguments, which are clearly non-type, to
    metafunctions. For example, to compare whether the size of a type T is smaller
    than that of another type U, we ultimately need to compare two numeric sizes.
    Let us write the following trait to compare the size of two types:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要将明显是非类型的数值参数传递给元函数。例如，为了比较类型 T 的大小是否小于另一类型 U 的大小，我们最终需要比较两个数值大小。让我们编写以下特性来比较两种类型的大小：
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`is_smaller<T, U>::value` will be true if and only if `sizeof(T)` is less than
    `sizeof(U)`, and will be false otherwise.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_smaller<T, U>::value` 如果且仅如果 `sizeof(T)` 小于 `sizeof(U)`，则为true，否则为false。'
- en: '**Listing 7.20: Using integral wrappers and other metafunctions**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 7.20：使用整数包装器和其他元函数**'
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: MPL provides a metafunction `boost::mpl::integral_c` to wrap integral values
    of a specified type (`size_t`, `short`, etc.). We use it to wrap the sizes of
    the two types. The `boost::mpl::less` metafunction compares the two sizes and
    its nested `value` is set to true only if the first argument is numerically less
    than the second. We can use it like any other trait.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: MPL 提供了一个元函数 `boost::mpl::integral_c` 来包装指定类型（`size_t`、`short` 等）的整数值。我们使用它来包装两种类型的大小。`boost::mpl::less`
    元函数比较这两个大小，如果第一个参数在数值上小于第二个参数，则其嵌套的 `value` 只会设置为真。我们可以像使用其他特性一样使用它。
- en: 'We will now try to write something slightly less trivial. We want to write
    a function to assign arrays. Here is the function template signature:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试写一些稍微不那么琐碎的东西。我们想要编写一个函数来赋值数组。以下是函数模板的签名：
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The type `T(&)[M]` is a reference to an array of `M` elements of type `T`; likewise
    for `S (&)[N]`. We want to assign the second argument `rhs` to the first argument
    `lhs`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `T(&)[M]` 是指向 `M` 个类型为 `T` 的元素的数组的引用；`S (&)[N]` 也是如此。我们希望将第二个参数 `rhs` 赋给第一个参数
    `lhs`。
- en: You can assign an array of type `S[]` to an array of type `T[]` as long as `S`
    and `T` are the same types, or the conversion from `S` to `T` is allowed and does
    not cause loss of information. Also, `M` must not be smaller than `N`. We will
    define a trait `is_array_assignable` which captures these constraints. Thus, `is_array_assignable<T(&)[M],
    S(&)[N]>::value` will be true only if the preceding constraints are met.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将类型为 `S[]` 的数组赋给类型为 `T[]` 的数组，只要 `S` 和 `T` 是相同类型，或者从 `S` 到 `T` 的转换是允许的且不会导致信息丢失。此外，`M`
    不能小于 `N`。我们将定义一个特性 `is_array_assignable` 来捕捉这些约束。因此，只有在满足前述约束时，`is_array_assignable<T(&)[M],
    S(&)[N]>::value` 才为真。
- en: 'First, we need to define three helper metafunctions: `is_floating_assignable`,
    `is_integer_assignable`, and `is_non_pod_assignable`. The `is_floating_assignable<T,
    S>` metafunction checks whether it is possible to assign a numeric value of type
    `S` to a floating point type `T`. The `is_integer_assignable<T, S>` metafunction
    checks whether both `T` and `S` are integers, and an assignment for `T` and `S`
    does not cause any potential loss or narrowing. Thus, signed integers cannot be
    assigned to unsigned integers, unsigned integers can only be assigned to larger
    signed integer types, and so on. The `is_non_pod_assignable<T, S>` trait checks
    whether at least one of `S` and `T` is non-POD type and whether an assignment
    operator from `S` to `T` exists.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义三个辅助元函数：`is_floating_assignable`，`is_integer_assignable` 和 `is_non_pod_assignable`。`is_floating_assignable<T,
    S>` 元函数检查是否可以将类型为 `S` 的数值赋给浮点类型 `T`。`is_integer_assignable<T, S>` 元函数检查 `T` 和
    `S` 是否都是整数，并且 `T` 和 `S` 的赋值不会导致潜在的损失或缩小。因此，有符号整数不能赋给无符号整数，无符号整数只能赋给更大的有符号整数类型，依此类推。`is_non_pod_assignable<T,
    S>` 特性检查 `S` 和 `T` 中至少有一个是非POD类型，并且是否存在从 `S` 到 `T` 的赋值运算符。
- en: We will then define `is_array_assignable` using these and other metafunctions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用这些和其他元函数来定义 `is_array_assignable`。
- en: '**Listing 7.21: Defining useful type traits using MPL**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 7.21：使用 MPL 定义有用的类型特性**'
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The primary template of the `is_array_assignable` metafunction always returns
    false (lines 61-64). The partial specialization of `is_array_assignable` (line
    66-78) is the heart of the implementation. It uses the `mpl::or_` metafunction
    to check whether any one of the following conditions is met:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_array_assignable` 元函数的主模板始终返回 false（第61-64行）。`is_array_assignable` 的部分特化（第66-78行）是实现的核心。它使用
    `mpl::or_` 元函数来检查是否满足以下任何一个条件：'
- en: The source and target types are the same (line 70)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源类型和目标类型相同（第70行）
- en: The target type is a floating point, the source type is numeric, and an assignment
    is possible without narrowing (line 71)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标类型是浮点数，源类型是数值，并且可以进行赋值而不会缩小（第71行）
- en: The target type is integral (signed or unsigned), the source type is integral,
    and an assignment is possible without narrowing (line 72)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标类型是整数（有符号或无符号），源类型是整数，并且可以进行赋值而不会缩小（第72行）
- en: At least one of the source and target types is a non-POD type and a conversion
    from the source to the target type is possible (line 73)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源和目标类型中至少有一个是非POD类型，并且从源类型到目标类型的转换是可能的（第73行）
- en: 'The `mpl::or_` metafunction is analogous to the logic or operator of C++, and
    its static member `value` is set to true if any one of the passed conditions is
    true. Along with this composite condition being true, the following condition
    must also hold:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`mpl::or_` 元函数类似于 C++ 的逻辑或运算符，如果传递的条件中有任何一个为真，则其静态成员 `value` 就设置为真。除了这个复合条件为真之外，还必须满足以下条件：'
- en: The number of elements in the target array should be at least as much as the
    elements in the source array.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 目标数组中的元素数量至少应与源数组中的元素数量一样多。
- en: We use the `mpl::greater_equal` metafunction to compare these two values `M`
    and `N`. Since the metafunction needs to take type parameters, we generate type
    parameters corresponding to `M` and `N` using `boost::mpl::integral_c` wrapper
    (lines 75-76). We compute the logical-OR of conditions 1-4 and its logical-AND
    with condition 5 using the `mpl::and_` metafunction (line 61).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`mpl::greater_equal`元函数来比较这两个值`M`和`N`。由于元函数需要获取类型参数，我们使用`boost::mpl::integral_c`包装器生成与`M`和`N`对应的类型参数（第75-76行）。我们使用`mpl::and_`元函数计算条件1-4的逻辑或及其与条件5的逻辑与（第61行）。
- en: We use `boost::enable_if` that leverages SFINAE to disable `assignArray` when
    `is_array_assignable` returns false.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`boost::enable_if`，它利用SFINAE在`is_array_assignable`返回false时禁用`assignArray`。
- en: Let us now look at the implementation of the `is_integer_assignable`. It checks
    if the target and source types are both integral, (lines 38-39) and the source
    type is not bigger than the target type (line 40). In addition, we use `boost::mpl::if_`
    metafunction, which takes three metafunctions; if the first metafunction evaluates
    to `true`, the second metafunction is returned, otherwise the third metafunction
    is returned. Using `mpl::if_`, we express the constraints on the source and target
    types (lines 41-47). If the source type is a signed integer (line 41), then the
    target type must also be a signed integer (line 42). But if the source type be
    an unsigned integer, then the target type must either be an unsigned integer (line
    43) or a signed integer larger than the source type (lines 44-45). The rest of
    the traits are similarly defined using Boost MPL library facilities.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`is_integer_assignable`的实现。它检查目标和源类型是否都是整数（第38-39行），并且源类型不大于目标类型（第40行）。此外，我们使用`boost::mpl::if_`元函数，它需要三个元函数；如果第一个元函数评估为`true`，则返回第二个元函数，否则返回第三个元函数。使用`mpl::if_`，我们表达了源类型和目标类型的约束（第41-47行）。如果源类型是有符号整数（第41行），那么目标类型也必须是有符号整数（第42行）。但是如果源类型是无符号整数，那么目标类型必须是无符号整数（第43行）或大于源类型的有符号整数（第44-45行）。其余的特性也是使用Boost
    MPL库设施类似地定义的。
- en: Metaprogramming is not just a tool for choosing optimal implementations or catching
    violations at compile time. It actually helps create expressive libraries like
    `boost::tuple` or `boost::variant`, involving significant type manipulation. We
    introduced only a few basic abstractions from the Boost MPL library to help you
    ease into template metaprogramming. If you have worked through the examples in
    this chapter, you should have no problems exploring MPL further on your own.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程不仅是选择最佳实现或在编译时捕获违规的工具。它实际上有助于创建像`boost::tuple`或`boost::variant`这样的表达性库，涉及重要的类型操作。我们只介绍了Boost
    MPL库中的一些基本抽象，以帮助您轻松进入模板元编程。如果您已经在本章中的示例中工作过，那么您应该没有问题自己进一步探索MPL。
- en: Domain Specific Embedded Languages
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域特定嵌入式语言
- en: In the last third of this chapter, we look at the applications of higher order
    and compile-time programming mainly in the area Domain Specific Embedded Languages.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后三分之一，我们主要看了高阶和编译时编程在领域特定嵌入式语言中的应用。
- en: Lazy evaluation
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性评估
- en: 'In C++, when we see the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，当我们看到以下代码时：
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We know that the value of `z` is immediately computed when the control reaches
    past the statement `z = x + y()`. In fact, the act of computing the sum involves
    evaluating the expressions `x` and `y()` themselves. Here, `y` is presumably a
    function or a functor instance, so the call to `y()` will in turn trigger more
    evaluations. Irrespective of whether `z` is ever used for anything later, its
    value would still be computed. This is the model of **eager evaluation** that
    a lot of programming languages follow. The actual story is slightly more complex
    because compilers can reorder and optimize away computations but there is little
    control the programmer has on the process.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道当控制到达语句`z = x + y()`之后，`z`的值会立即计算。事实上，计算总和涉及对`x`和`y()`表达式本身的评估。在这里，`y`可能是一个函数或一个函数符实例，因此对`y()`的调用将依次触发更多的评估。无论`z`是否以后被用于任何事情，它的值仍然会被计算。这是许多编程语言遵循的**急切评估**模型。实际情况稍微复杂一些，因为编译器可以重新排序和优化计算，但程序员对这个过程几乎没有控制。
- en: 'What if we could defer the evaluation of such expressions and any of their
    sub-expressions until we have to make use of the result? This is the **lazy evaluation**
    model seen in a lot of functional programming languages, like Haskell. If we could
    construct arbitrary language expressions that are lazily evaluated, then such
    expressions could be passed around just like functors and evaluated where necessary.
    Imagine a function called `integrate` that evaluates definite integrals of arbitrary
    functions, given boundary values:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够推迟对这些表达式及其任何子表达式的评估，直到我们必须使用结果，会怎么样？这是许多函数式编程语言中看到的**惰性评估**模型，比如Haskell。如果我们能够构造惰性评估的任意语言表达式，那么这些表达式就可以像函数符一样传递，并在必要时进行评估。想象一个名为`integrate`的函数，它评估任意函数的定积分，给定边界值：
- en: '[PRE70]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Imagine being able to evaluate the integral ![Lazy evaluation](img/1217OT_07_02.jpg)
    by calling the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下通过调用以下代码来评估积分![惰性评估](img/1217OT_07_02.jpg)：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The key would be to not evaluate the expression `x + 1/x` eagerly but pass
    it to the `integrate` function as a lazy expression. Now C++ does not have any
    built-in mechanism to create lazy expressions like these using regular variables.
    But we can quite easily write a lambda to get our job done:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是不急切评估表达式`x + 1/x`，而是将其作为惰性表达式传递给`integrate`函数。现在C++没有任何内置机制来使用常规变量创建这样的惰性表达式。但是我们可以很容易地编写一个lambda来完成我们的工作：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This works albeit with some syntactic noise, but in many applications, lambda
    and bind just do not scale with complexity. In this section, we briefly study
    **expression templates** and more generally, **Domain Specific Embedded Languages**
    (**DSELs**), which are the means of constructing lazily evaluated function objects
    within C++ that get your job done without sacrificing on expressive syntax.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做虽然有一些语法噪音，但在许多应用中，lambda和bind并不适用于复杂性。在本节中，我们简要研究**表达式模板**，更一般地说，**领域特定嵌入式语言**（**DSELs**），这是在C++中构建惰性评估函数对象的手段，可以在不牺牲表达语法的情况下完成工作。
- en: Expression templates
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式模板
- en: So, how do we express a function *f(x)=x+1/x* in the language of the domain
    rather than through a syntactic compromise within the confines of C++? To create
    a generic solution, we must be able to support a variety of algebraic expressions.
    Let us start with the most basic function—a constant function, such as *f(x)=5*.
    Irrespective of the value of *x*, this function should always return 5.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在领域语言中表达一个函数*f(x)=x+1/x*，而不是通过C++的语法妥协来实现呢？为了创建一个通用解决方案，我们必须能够支持各种代数表达式。让我们从最基本的函数开始
    - 一个常数函数，比如*f(x)=5*。无论*x*的值如何，这个函数应该始终返回5。
- en: 'The following functor can be used for this purpose:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数对象可用于此目的：
- en: '**Listing 7.22a: An expression template mini-library – lazy literals**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.22a：表达式模板迷你库 - 惰性文字**'
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `operator()` returns the stored `val_` and ignores its argument, which
    is unnamed. Now let us see how we can represent a function like *f(x)=x*, using
    a similar functor:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator()`返回存储的`val_`并忽略它的参数，该参数是无名的。现在让我们看看如何使用类似的函数对象来表示*f(x)=x*这样的函数：'
- en: '**Listing 7.22b: An expression template mini-library – lazy variables**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.22b：表达式模板迷你库 - 惰性变量**'
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We now have a functor that yields whatever value is passed to it; exactly what
    *f(x)=x* does. But how do we express an expression like *x + 1/x*? The general
    form of a functor that represents an arbitrary function of a single variable should
    be as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个产生传递给它的任何值的函数对象；正是*f(x)=x*所做的。但是如何表达一个类似*x + 1/x*的表达式呢？表示单变量任意函数的函数对象的一般形式应该如下：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Both `Constant` and `Variable` conform to this form. But consider a more complex
    expression like *f(x)=x+1/x*. We can break it down to two sub-expressions *x*
    and *1/x* acted upon by the binary operation +. The expression *1/x* can be further
    broken down to two sub-expressions *1* and *x* acted upon by the binary operation
    /.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Constant`和`Variable`都符合这个形式。但是考虑一个更复杂的表达式，比如*f(x)=x+1/x*。我们可以将它分解为两个子表达式*x*和*1/x*，由二元操作+作用。表达式*1/x*可以进一步分解为两个子表达式*1*和*x*，由二元操作/作用。'
- en: 'This can be represented by an **Abstract Syntax Tree** (**AST**), as shown
    here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用**抽象语法树**（**AST**）来表示，如下所示：
- en: '![Expression templates](img/1217OT_07_01.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![表达式模板](img/1217OT_07_01.jpg)'
- en: 'The non-leaf nodes in the tree represent operations. Binary operation nodes
    have two children: the left operand is the left child and the right operand is
    the right child. The AST has an operation (*+*) at the root and two sub-expressions
    as two children. The left sub-expression is *x*, while the right sub-expression
    is *1/x*. This *1/x* is further deconstructed in a sub-tree with operation (*/*)
    at the root, *1* as the left child, and *x* as the right child. Notice that values
    like *1* and *x* only appear at the leaf level and correspond to the `Constant`
    and `Variable` classes we defined. All non-leaf nodes represent operators.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 树中的非叶节点表示操作。二元操作节点有两个子节点：左操作数是左子节点，右操作数是右子节点。AST在根部有一个操作（*+*），并且有两个子表达式作为两个子节点。左子表达式是*x*，而右子表达式是*1/x*。*1/x*进一步在一个子树中被分解，根部是操作（*/*），*1*是左子节点，*x*是右子节点。注意像*1*和*x*这样的值只出现在叶级别，并且对应于我们定义的`Constant`和`Variable`类。所有非叶节点表示操作符。
- en: 'We can model a complex expression as one that is composed of two sub-expressions
    with an operator:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将复杂表达式建模为由两个带有运算符的子表达式组成的表达式：
- en: '**Listing 7.22c: An expression template mini-library – complex expressions**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.22c：表达式模板迷你库 - 复杂表达式**'
- en: '[PRE76]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When the `ComplexExpression` functor is invoked, that is, when it evaluates
    its left and right sub-expressions and then applies the operator on them (line
    7), this in turn triggers the evaluation of the left and right sub-expressions.
    If they are `ComplexExpression`s themselves, then they trigger further evaluations
    that traverse down the tree, depth-first. This is definitive **lazy evaluation**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`ComplexExpression`函数对象时，也就是当它评估其左右子表达式然后对它们应用运算符（第7行），这将触发左右子表达式的评估。如果它们本身是`ComplexExpression`，那么它们将触发进一步的评估，深度优先遍历树。这是明确的**延迟评估**。
- en: Now, in order to easily generate complex expression functors, we need to overload
    the arithmetic operators to combine sub-expressions of type `Constant`, `Variable`,
    `ComplexExpression<>`, or primitive arithmetic types. To do this better, we create
    an abstraction for all kinds of expressions called `Expr`. We also modify our
    definition of `ComplexExpression` to use `Expr`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了轻松生成复杂表达式函数对象，我们需要重载算术运算符，以组合`Constant`、`Variable`、`ComplexExpression<>`或原始算术类型的子表达式。为了更好地做到这一点，我们为所有类型的表达式创建一个名为`Expr`的抽象。我们还修改了`ComplexExpression`的定义以使用`Expr`。
- en: '**Listing 7.22d: An expression template mini-library – generic expressions**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.22d：表达式模板迷你库 - 通用表达式**'
- en: '[PRE77]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We will pass around all kinds of expressions wrapped in `Expr`, for example,
    `Expr<Constant>`, `Expr<ComplexExpression>`, and so on. If you are unsure why
    we need the second template parameter `Enable`, then hang on for the answer in
    a bit. Before that, we will define the arithmetic operators between any two `Expr`s,
    starting with `operator+`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递包装在`Expr`中的各种表达式，例如`Expr<Constant>`、`Expr<ComplexExpression>`等。如果您不确定为什么我们需要第二个模板参数`Enable`，那么稍等片刻就会得到答案。在此之前，我们将定义任何两个`Expr`之间的算术运算符，从`operator+`开始：
- en: '**Listing 7.22e: An expression template mini-library – overloaded operators**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.22e：表达式模板迷你库 - 重载运算符**'
- en: '[PRE78]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Any binary operation will produce a `ComplexExpression`. Since we will pass
    everything abstracted as `Expr`, we return `Expr<ComplexExpression<…>>` from the
    arithmetic operators. It is easy to write an `operator-`, `operator*`, or `operator/`
    on the same lines. We can replace `std::plus` with `std::minus`, `std::multiples`,
    or `std::divides` in the preceding implementation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 任何二元操作都将产生一个 `ComplexExpression`。由于我们将一切抽象为 `Expr`，所以我们从算术运算符中返回 `Expr<ComplexExpression<…>>`。在相同的行上很容易编写
    `operator-`、`operator*` 或 `operator/`。我们可以在前面的实现中用 `std::plus` 替换为 `std::minus`、`std::multiples`
    或 `std::divides`。
- en: 'There is only one more detail to take care of. With the preceding code, we
    can write expressions of the following form:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个细节需要注意。有了前面的代码，我们可以写出以下形式的表达式：
- en: '[PRE79]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: But we cannot write *x + 1/x* using numeric literals. To do this, we must automatically
    convert numeric literals to `Constant`. For this, we will create a partial specialization
    of `Expr` and use `boost::enable_if` to enable it for numeric types. This is where
    the `Enable` argument of the `Expr` template comes in handy. It defaults to `void`
    for the primary template, but it helps us write the partial specialization for
    wrapping arithmetic-type literals.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们无法使用数字文字来写 *x + 1/x*。为了做到这一点，我们必须自动将数字文字转换为 `Constant`。为此，我们将创建 `Expr` 的部分特化，并使用
    `boost::enable_if` 为数字类型启用它。这就是 `Expr` 模板的 `Enable` 参数派上用场的地方。对于主模板，默认为 `void`，但它帮助我们编写包装算术类型文字的部分特化。
- en: '**Listing 7.22f: An expression template mini-library – a small trick**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7.22f：一个表达式模板迷你库 – 一个小技巧**'
- en: '[PRE80]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This partial specialization is invoked only when `E` is an arithmetic type
    (`int`, `double`, `long`, etc.). This stores the arithmetic value as a `Constant`.
    With this change, we can use numeric literals in our expressions, and as long
    as there is a single `Variable` in the expression, the literals would get wrapped
    in a `Constant` via the partial specialization in listing 7.22f. We can now generate
    a functor using just natural algebraic expressions:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 `E` 是算术类型（`int`、`double`、`long`等）时，才会调用这个部分特化（partial specialization）。这将算术值存储为
    `Constant`。有了这个改变，我们可以在我们的表达式中使用数字文字，只要表达式中有一个单一的 `Variable`，这些文字就会通过列表 7.22f
    中的部分特化被包装为 `Constant`。现在我们可以仅使用自然的代数表达式生成一个函数器：
- en: '**Listing 7.22g: An expression template mini-library – using the expressions**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7.22g：一个表达式模板迷你库 – 使用表达式**'
- en: '[PRE81]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We can add many more refinements to this very basic *expression template* library
    of not even a hundred lines of code. But it already allows us to generate arbitrary
    algebraic functions of a single variable using very simple syntax. This is an
    example of a *Domain Specific Language*. Also, specifically, because we use valid
    C++ syntax to do all this instead of defining a new syntax, it is specifically
    called **Domain Specific Embedded Language** (**DSEL**) or sometimes **Embedded
    Domain Specific Language** (**EDSL**). We will now look at Boost Phoenix, an elaborate
    library of lazy expressions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对这个非常基本的 *表达式模板* 库进行许多更多的改进，即使代码不到一百行。但它已经允许我们使用非常简单的语法生成单变量的任意代数函数。这是一个*特定领域语言*的例子。而且，特别是因为我们使用有效的
    C++ 语法来做所有这些，而不是定义一个新的语法，它被称为**特定领域嵌入语言**（**DSEL**）或有时称为**嵌入式特定领域语言**（**EDSL**）。现在我们将看一下
    Boost Phoenix，一个复杂的惰性表达式库。
- en: Boost Phoenix
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost Phoenix
- en: Boost Phoenix 3 is a library for enabling functional programming constructs
    in C++. It defines an elaborate and very readable DSEL with scores of functors
    and operators, which can be used to generate fairly involved lambdas. It provides
    a comprehensive library for constructing lazy expressions and an excellent example
    of what expression templates can achieve. This section features a very short introduction
    to using Phoenix expressions as lambdas, and we will see some examples of using
    Phoenix with Boost Spirit Parser Framework. It is too extensive a library to cover
    in a single chapter, let alone a subsection of it, but this introduction should
    still provide enough tail wind to master Phoenix, with the benefit of the excellent
    online documentation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Phoenix 3 是一个在 C++ 中启用函数式编程构造的库。它定义了一个复杂而易读的 DSEL，其中包含大量的函数器和运算符，可以用来生成相当复杂的
    lambda。它提供了一个全面的库，用于构造惰性表达式，并展示了表达式模板可以实现的优秀示例。本节简要介绍了如何使用 Phoenix 表达式作为 lambda，并将看到一些使用
    Boost Spirit Parser Framework 的 Phoenix 示例。这是一个非常庞大的库，甚至在一个章节中都无法覆盖，更不用说它的一个子部分，但这个介绍应该足够提供足够的支持来掌握
    Phoenix，同时还可以获得优秀的在线文档的好处。
- en: Phoenix expressions are composed of **actors**, which are abstractions for lazy
    functions. Actors are used to generate unnamed functions or lambdas. They support
    partial function application by binding some arguments to values and keeping others
    unspecified. They can be composed to generate more complex functors. In that sense,
    Phoenix is a lambda language library.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Phoenix 表达式由**演员**组成，演员是惰性函数的抽象。演员用于生成未命名函数或 lambda。它们通过将一些参数绑定到值并保持其他参数未指定来支持部分函数应用。它们可以组合以生成更复杂的函数器。在这个意义上，Phoenix
    是一个 lambda 语言库。
- en: 'Actors are categorized based on functionality and exposed through a set of
    header files. The most basic actor is `val` which represents a lazy immutable
    value (not unlike the `Constant` functor in our expression template example).
    The `ref` actor is used to create a lazy mutable variable reference, and the `cref`
    actor generates a lazy immutable reference. There is a whole set of actors that
    define lazy operators, including arithmetic (`+`, `-`), comparison (`<`, `==`,
    `>`), logical (`&&`, `||`), bitwise operators (`|`, `^`, `&`), and other kinds
    of operators. Using just these, we can construct algebraic expressions, as we
    do in the following example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 演员根据功能进行分类，并通过一组头文件公开。最基本的演员是 `val`，它表示惰性不可变值（与我们表达式模板示例中的 `Constant` 函数器类似）。`ref`
    演员用于创建惰性可变变量引用，`cref` 演员生成惰性不可变引用。还有一整套定义惰性运算符的演员，包括算术运算符（`+`、`-`）、比较运算符（`<`、`==`、`>`）、逻辑运算符（`&&`、`||`）、位运算符（`|`、`^`、`&`）和其他类型的运算符。仅使用这些，我们就可以构造代数表达式，就像我们在下面的示例中所做的那样：
- en: '**Listing 7.23: Lazy algebraic expressions with Phoenix**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.23：使用Phoenix的惰性代数表达式**'
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Using `boost::phoenix::ref`, we generate an actor for lazily evaluating the
    variable `eX` (**e** for **eager**) and cache it in a variable `x`. The expressions
    `x + 1/x` and `x*x – x + 4` generate anonymous functors just like the expression
    templates from listing 7.22, except that `x` is already bound to the variable
    `eX`. The actor `x` is said to **infect** the numeric literals in the expressions
    by its presence; the literals get wrapped in `boost::phoenix::val`. The operators
    `+`, `-`, `*`, and `/` used in the expression are lazy operators from Phoenix
    (just like the operators we defined for our expression template in listing 7.22e)
    and generate anonymous functors.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`boost::phoenix::ref`，我们生成了一个用于惰性评估变量`eX`（**e**代表**eager**）的actor，并将其缓存在变量`x`中。表达式`x
    + 1/x`和`x*x – x + 4`生成了匿名函数，就像清单7.22中的表达式模板一样，只是`x`已经绑定到变量`eX`。actor `x`的存在通过其影响了表达式中的数字文字；这些文字被包装在`boost::phoenix::val`中。表达式中使用的`+`、`-`、`*`和`/`操作符是来自Phoenix的惰性操作符（就像我们在清单7.22e中为我们的表达式模板定义的操作符一样），并生成了匿名函数。
- en: 'Writing simple lambdas can sometimes be extremely succinct using Phoenix. Look
    at how we can print each element in a vector using `std::for_each` and Phoenix''s
    lazy `operator<<`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Phoenix有时可以非常简洁地编写简单的lambda。看看我们如何使用`std::for_each`和Phoenix的惰性`operator<<`来打印向量中的每个元素：
- en: '**Listing 7.24: Simpler lambdas with Phoenix**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.24：使用Phoenix的简单lambda**'
- en: '[PRE83]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The expression `std::cout << arg1` is actually a lambda that generates a functor.
    The actor `arg1` (`boost::phoenix::arg_names::arg1`) represents the first argument
    to the functor and is lazily evaluated. The presence of `arg1` in the expression
    `std::cout << arg1` invokes the lazy `operator<<` and infects the entire expression
    to generate an unnamed function that prints its argument to the standard output.
    In general, you can use `arg1` through `argN` to refer to the lazy arguments of
    an N-ary functor generated with Phoenix. By default, up to ten argument actors
    (`arg1` through `arg10`) are supported. These are akin to `_1`, `_2`, etc. for
    `boost::bind`. You can also use `boost::phoenix::placeholders::_1`, `_2`, etc.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`std::cout << arg1`实际上是生成一个函数对象的lambda。actor `arg1`（`boost::phoenix::arg_names::arg1`）代表函数对象的第一个参数，并且是惰性评估的。表达式`std::cout
    << arg1`中的`arg1`的存在调用了惰性`operator<<`并感染整个表达式，生成一个未命名函数，将其参数打印到标准输出。通常情况下，您可以使用`arg1`到`argN`来引用使用Phoenix生成的N元函数的惰性参数。默认情况下，支持最多十个参数actors（`arg1`到`arg10`）。这类似于`boost::bind`的`_1`、`_2`等。您还可以使用`boost::phoenix::placeholders::_1`、`_2`等。
- en: 'Phoenix actors are not limited to expressions involving operators. We can generate
    actors that lazily evaluate entire blocks of code with branching and looping constructs.
    Let us say we have a vector of the names of personnel in a band''s lineup, and
    we want to print whether a person is a vocalist or instrumentalist:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Phoenix actors不仅限于涉及运算符的表达式。我们可以生成惰性评估包含分支和循环结构的整个代码块的actors。假设我们有一个乐队阵容中人员姓名的向量，并且我们想要打印一个人是歌手还是乐器演奏者：
- en: '**Listing 7.25: Lazy control structures with Phoenix**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.25：使用Phoenix的惰性控制结构**'
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We want to run through the vector of last names of the four legendary members
    of *The Who* and list them with their roles. For (Roger) Daltrey, the role would
    be of a vocalist and for the others, instrumentalist. We use `std::for_each` to
    iterate the list of names. We pass a unary functor to it generated using Phoenix's
    statement actors, specifically `boost::phoenix::if_`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要遍历*The Who*四位传奇成员的姓氏向量，并列出他们的角色。对于（罗杰）达特里，角色将是一个歌手，而对于其他人来说，是乐器演奏者。我们使用`std::for_each`来迭代名单。我们通过使用Phoenix的语句actors生成的一元函数来传递给它一个unary
    functor，具体来说是`boost::phoenix::if_`。
- en: 'The syntax is intuitive enough to look at and understand what is going on.
    The actual statements in the `if_` and `else_` blocks are put in square brackets
    instead of braces (which cannot be overloaded) and are lazily evaluated. If there
    were multiple statements, they would need to be separated by commas. Notice how
    the `else_` is a member call invoked with a dot on the preceding expression (line
    18). The presence of `arg1` is said to *infect* the statements, that is, it invokes
    the lazy `operator<<` and causes the literal character strings to be automatically
    wrapped in `boost::phoenix::val` (lines 16, 17, 19). Running this code prints
    the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 语法足够直观，可以理解正在发生的事情。`if_`和`else_`块中的实际语句被放在方括号中，而不是大括号（不能被重载），并且被惰性评估。如果有多个语句，它们需要用逗号分隔。注意`else_`是在前面的表达式上调用的成员调用，用点调用（第18行）。`arg1`的存在被称为*感染*语句，即它调用了惰性`operator<<`并导致文字字符串自动包装在`boost::phoenix::val`中（第16、17、19行）。运行此代码将打印以下内容：
- en: '[PRE85]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The power of Phoenix should be evident already. It defines an expressive sub-language
    using, standard C++ operator overloading and functors that easily generates unnamed
    functions or lambdas as needed, and starts to mimic the host language itself.
    There is more to the Phoenix library. It is chock-full of actors for lazy evaluation
    of STL container member functions and STL algorithms. Let us look at an example
    to understand this better:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Phoenix的强大之处已经显而易见。它使用标准C++运算符重载和函数对象定义了一个表达力强的子语言，可以轻松生成所需的未命名函数或lambda，并开始模仿宿主语言本身。Phoenix库还有更多内容。它充斥着用于惰性评估STL容器成员函数和STL算法的actors。让我们看一个例子来更好地理解这一点：
- en: '**Listing 7.26: Actors for STL algorithms and container member functions**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.26：用于STL算法和容器成员函数的actors**'
- en: '[PRE86]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We have a vector `greets` of hello greetings in different languages (English,
    Spanish, Swahili, and German), and we want to search for a specific greet. We
    want to do so lazily using Phoenix. Phoenix provides actors for generating lazy
    versions of most STL algorithms. We use the lazy form of the `std::find` algorithm
    available via the header `boost/phoenix/stl/algorithm.hpp` (line 5), and call
    the `boost::phoenix::find` actor to generate a unary functor named `finder` (line
    14). The `finder` functor takes as its only argument, the string to look for in
    `greets`. The call `boost::phoenix::find(greets, arg1)` takes two arguments and
    generates a unary functor. The first argument is a reference to the vector `greets`,
    which is automatically wrapped in a `cref` actor and stored for lazy evaluation
    later. The second argument to `find` is the Phoenix placeholder `arg1`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含不同语言的问候语（英语、西班牙语、斯瓦希里语和德语）的向量`greets`，我们想要搜索特定的问候语。我们想要使用Phoenix进行延迟搜索。Phoenix提供了用于生成大多数STL算法的延迟版本的actors。我们使用`boost/phoenix/stl/algorithm.hpp`头文件中可用的`std::find`算法的延迟形式（第5行），并调用`boost::phoenix::find`
    actor来生成一个名为`finder`的一元函数对象（第14行）。`finder`函数对象以`greets`中要查找的字符串作为唯一参数。调用`boost::phoenix::find(greets,
    arg1)`需要两个参数并生成一个一元函数对象。第一个参数是对向量`greets`的引用，它会自动包装在`cref` actor中并存储以供以后延迟评估。`find`的第二个参数是Phoenix占位符`arg1`。
- en: When `finder` is called with the string to lookup as its sole argument, it evaluates
    the `arg1` actor to get this string argument. It also evaluates the `cref` actor
    it stored earlier to get a reference to `greets`. It then calls `std::find` on
    the `greets` vector, looking for the string passed, which returns an iterator.
    We look for the string `Hujambo` which is the present in the vector(line 15).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当`finder`以要查找的字符串作为唯一参数调用时，它评估`arg1` actor以获取此字符串参数。它还评估它之前存储的`cref` actor以获取对`greets`的引用。然后在`greets`向量上调用`std::find`，查找传递的字符串，返回一个迭代器。我们查找向量中存在的字符串`Hujambo`（第15行）。
- en: 'To check whether the iterator returned is valid, we need to compare it against
    `greets.end()`. Just to show that it can be done, we generate the lazy version
    of the `end` member function call using the `boost::phoenix::end` actor available
    from the header `boost/phoenix/stl/algorithm.hpp`. The call `boost::phoenix::end(greets)`
    generates a functor, and we call it in-place by suffixing parentheses. We compare
    the result with the iterator returned by `finder` (line 17). We print the greeting
    pointed by the iterator returned by `find` and the element after that (lines 18-20):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查返回的迭代器是否有效，我们需要将其与`greets.end()`进行比较。只是为了表明可以做到这一点，我们使用从头文件`boost/phoenix/stl/algorithm.hpp`中可用的`boost::phoenix::end`
    actor生成`end`成员函数调用的延迟版本。调用`boost::phoenix::end(greets)`生成一个函数对象，我们通过在后面加括号来直接调用它。我们将结果与`finder`返回的迭代器进行比较（第17行）。我们打印`find`返回的迭代器指向的问候语以及其后的元素（第18-20行）：
- en: '[PRE87]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Actors from Phoenix are polymorphic. You can apply `boost::phoenix::find` on
    any kind of container that supports searching via `std::find`, and you can look
    up an object of any type that the underlying container can store.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Phoenix的actors是多态的。您可以在任何支持通过`std::find`进行搜索的容器上应用`boost::phoenix::find`，并且可以查找底层容器可以存储的任何类型的对象。
- en: 'In the final example on Phoenix, we look at how we can define our own actors,
    which can fit in with the rest of Phoenix. We have a vector of names from which
    we print the first name in each entry, using `std::for_each` and functors generated
    using Phoenix. We extract first names from a name string by looking up the first
    space character in the string and extracting the prefix up to that point. We can
    use the `find` actor to locate the space but to extract the prefix, we need a
    lazy way to call the `substr` member of `std::string`. There is no `substr` actor
    currently available in Phoenix, so we need to roll out our own:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在Phoenix的最后一个例子中，我们将看看如何定义自己的actor，这些actor可以与Phoenix的其余部分相匹配。我们有一个名称向量，我们从中打印每个条目的第一个名称，使用`std::for_each`和使用Phoenix生成的函数对象。我们通过查找字符串中的第一个空格字符并提取直到该点的前缀来从名称字符串中提取名字。我们可以使用`find`
    actor来定位空格，但是要提取前缀，我们需要一种延迟调用`std::string`的`substr`成员的方法。目前在Phoenix中没有`substr`
    actor可用，因此我们需要自己编写：
- en: '**Listing 7.27: User defined actors and STL actors**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.27：用户定义的actors和STL actors**'
- en: '[PRE88]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We write the `substr_impl` functor, which has a member template `operator()`
    (line 17) and a metafunction called `result` (line 12). The `operator()` is a
    template used to make `substr_impl` polymorphic. Any type `C` with a member function
    called `substr`, which takes two parameters of type `F1` and `F2` (which may or
    may not be of different types) can be covered by this single implementation (lines
    17-20). The embedded `type` in the `result` metafunction is the return type of
    the wrapped function (`substr`). The actual `substr` actor is an instance of type
    `boost::phoenix::function<substr_impl>` (line 29). We use the `substr` actor,
    we just defined, to generate a unary functor, which we pass to the `std::for_each`
    algorithm (lines 32-33). Since we want to extract the first name from each string
    in the `names` vector, the first argument is `arg1` (the name passed to the functor),
    the second offset argument is 0, while the third length argument is the offset
    of the first space character in the string. The third argument is calculated lazily
    as the expression `boost::phoenix::find(arg1, ' ') – boost::phoenix::begin(arg1)`.
    The `find(arg1, ' ')` is an actor that looks up the first space in the string
    passed to it using the generic find actor from Phoenix that we also used in listing
    7.26\. The `begin(arg1)` is an actor that returns the begin iterator of its argument
    (in this case the string). The difference between them returns the length of the
    first name.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了`substr_impl`函数对象，它有一个成员模板`operator()`（第17行）和一个名为`result`的元函数（第12行）。`operator()`是一个模板，用于使`substr_impl`多态化。任何具有名为`substr`的成员函数的类型`C`，它接受类型为`F1`和`F2`的两个参数（可能是不同类型）都可以由这个单一实现覆盖（第17-20行）。`result`元函数中的`type`是包装函数（`substr`）的返回类型。实际的`substr`操作者是`boost::phoenix::function<substr_impl>`类型的实例（第29行）。我们使用刚刚定义的`substr`操作者来生成一个一元函数对象，然后将其传递给`std::for_each`算法（第32-33行）。由于我们想要从`names`向量中的每个字符串中提取第一个名字，所以第一个参数是`arg1`（传递给函数对象的名字），第二个偏移参数是0，而第三个长度参数是字符串中第一个空格字符的偏移量。第三个参数被懒惰地计算为表达式`boost::phoenix::find(arg1,
    ' ') – boost::phoenix::begin(arg1)`。`find(arg1, ' ')`是一个操作者，它使用我们在列表7.26中也使用的Phoenix的通用查找操作者来查找字符串中的第一个空格。`begin(arg1)`是一个操作者，它返回其参数（在本例中是字符串）的起始迭代器。它们之间的差异返回第一个名字的长度。
- en: Boost Spirit Parser Framework
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升Spirit解析器框架
- en: Boost Spirit is a very popular DSEL used for generating lexers and parsers,
    which uses Boost Phoenix. Writing custom lexers and parsers used to be heavily
    reliant on specialized tools like lex/flex, yacc/bison, and ANTLR that generated
    C or C++ code from a language neutral specification in the **Extended Backus-Naur
    Form** (EBNF). Spirit eliminates the need for creating such a specification outside
    the language, and for tools to translate from such specifications. It defines
    a declarative DSEL with intuitive syntax in C++ and uses only the C++ compiler
    to generate parsers. Spirit makes heavy use of template metaprogramming, resulting
    in slower compile times but generates parsers that are efficient at runtime.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Spirit是一个非常流行的用于生成词法分析器和解析器的领域特定语言，它使用Boost Phoenix。编写自定义词法分析器和解析器过去严重依赖于专门的工具，如lex/flex、yacc/bison和ANTLR，这些工具从**扩展巴科斯-瑙尔范式**（EBNF）的语言中立规范生成C或C++代码。Spirit消除了在语言之外创建这样的规范的需要，也消除了从这样的规范翻译的工具的需要。它在C++中定义了一个具有直观语法的声明式领域特定语言，并且只使用C++编译器来生成解析器。Spirit大量使用模板元编程，导致编译时间较慢，但生成的解析器在运行时非常高效。
- en: Spirit is a rich framework that includes Spirit Lex – a lexer, Spirit Qi – a
    parser, and Spirit Karma – a generat. You can use these separately, or use them
    all in collaboration to build powerful data translation engines.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Spirit是一个包含Spirit Lex（词法分析器）、Spirit Qi（解析器）和Spirit Karma（生成器）的丰富框架。您可以单独使用它们，或者协作使用它们来构建强大的数据转换引擎。
- en: 'In this book we only look at Spirit Qi. It is used primarily to parse *text
    data* according to some specified *grammar* that the data is supposed to obey,
    with the following objectives:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们只关注Spirit Qi。它主要用于根据一些指定的*语法*来解析*文本数据*，数据应该遵守以下目标：
- en: Verifying that the input conforms to the grammar
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证输入是否符合语法
- en: Decomposing a conforming input into meaningful semantic components
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将符合语法的输入分解为有意义的语义组件
- en: For example, we can parse some input text to verify whether it is a valid timestamp,
    and if it is, extract the components of the timestamp, such as year, month, day,
    hours, minutes, and so on. For this, we need to define a grammar for the timestamp,
    and we need to define the actions to be taken, as we parse the data in terms of
    its semantic constituents. Let us see a concrete example.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以解析一些输入文本，以验证它是否是有效的时间戳，如果是，提取时间戳的组件，如年、月、日、小时、分钟等。为此，我们需要为时间戳定义一个语法，并且需要定义在解析数据时要采取的操作，以其语义组成部分的形式。让我们看一个具体的例子。
- en: Using Spirit Qi
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Spirit Qi
- en: Spirit provides **predefined parsers**, which can be combined using **parser
    operators** defined by Spirit, to define a parser for our needs. Once defined,
    we can store the parser or its components as **rules** that can be combined with
    other rules. Or we can directly pass it to a Qi **parsing API**, such as `parse`
    or `phrase_parse`, along with the input to parse.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Spirit提供了**预定义解析器**，可以使用Spirit定义的**解析器操作者**组合起来，为我们的需求定义解析器。一旦定义好，我们可以将解析器或其组件存储为可以与其他规则组合的**规则**。或者我们可以直接将其传递给Qi的**解析API**，如`parse`或`phrase_parse`，以及要解析的输入。
- en: Predefined parsers
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 预定义解析器
- en: 'Qi provides a number of predefined parsers that can be used to parse basic
    pieces of data. The parsers are available or aliased under the namespace `boost::spirit::qi`.
    Here is a listing of these parsers with their purpose:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Qi提供了许多预定义的解析器，可以用来解析基本的数据片段。这些解析器可以在命名空间`boost::spirit::qi`下使用或别名。以下是这些解析器及其目的的列表：
- en: '| Input class | Parsers | Purpose |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 输入类 | 解析器 | 目的 |'
- en: '| --- | --- | --- |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Integers | `int_`, `uint_`, `short_`, `ushort_`, `long_`, `ulong_`, `long_long`,
    `ulong_long` | Parse signed and unsigned integers |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | `int_`, `uint_`, `short_`, `ushort_`, `long_`, `ulong_`, `long_long`,
    `ulong_long` | 解析有符号和无符号整数 |'
- en: '| Real numbers | `float_`, `double_`, `long_double` | Parse real numbers with
    decimal points |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 实数 | `float_`, `double_`, `long_double` | 解析带有小数点的实数 |'
- en: '| Boolean | `bool_`, `true_`, `false_` | Parse either or both the strings,
    `true` and `false` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | `bool_`, `true_`, `false_` | 解析字符串`true`和`false`中的一个或两个 |'
- en: '| Characters | `char_`, `alpha`, `lower`, `upper`,`digit`, `xdigit`, `alnum`,`space`,
    `blank`,`punct`, `cntrl`, `graph`, `print` | Parse characters of different classes,
    like letters, digits, hexadecimal digits, punctuation, etc. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | `char_`, `alpha`, `lower`, `upper`,`digit`, `xdigit`, `alnum`,`space`,
    `blank`,`punct`, `cntrl`, `graph`, `print` | 解析不同类别的字符，如字母、数字、十六进制数字、标点等。'
- en: '| Strings | `String` | Parse specific strings |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `String` | 解析特定字符串 |'
- en: The parsers listed in the preceding table are predefined objects rather than
    types. There are generic parser templates corresponding to each of these parsers.
    For example, the template `boost::spirit::qi::int_parser` can be used to define
    custom parsers for signed integers. There are many other templates, including
    `boost::spirit::qi::uint_parser`, `boost::spirit::qi::bool_parser`, and so on.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中列出的解析器是预定义对象，而不是类型。每个解析器都有对应的通用解析器模板。例如，模板`boost::spirit::qi::int_parser`可用于定义有符号整数的自定义解析器。还有许多其他模板，包括`boost::spirit::qi::uint_parser`、`boost::spirit::qi::bool_parser`等等。
- en: The parsing API
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析API
- en: 'Qi provides two function templates, `parse` and `phrase_parse`, that are used
    to parse text input. Each takes a pair of iterators that define the input range
    and a parser expression. In addition, `phrase_parse` takes a second parser expression
    that is used to match and skip whitespace. The following short example shows you
    the essence of using Spirit:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Qi提供了两个函数模板，`parse`和`phrase_parse`，用于解析文本输入。每个函数都接受定义输入范围和解析器表达式的迭代器对。此外，`phrase_parse`接受第二个解析器表达式，用于匹配和跳过空白。以下简短的示例向您展示了使用Spirit的精髓：
- en: '**Listing 7.28: A simple Spirit example**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.28：一个简单的Spirit示例**'
- en: '[PRE89]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We include the header file `boost/spirit/include/qi.hpp` in order to access
    Spirit Qi functions, types, and objects. Our input is the string `Hello, world!`,
    and using the predefined parser `alpha`, we want to enforce that the first character
    is a letter from the Latin alphabet, as opposed to a digit or a punctuation symbol.
    For this, we use the `parse` function, passing it a pair of iterators defining
    the input and the `alpha` parser (line 10). The `parse` function returns `true`
    if the parser successfully parses the input and false otherwise. The iterator
    to the start of the range is incremented to point to the first unparsed character
    in the input. Since the first character of `Hello, world!` is H, the `alpha` parser
    parses it successfully, incrementing the `iter` by 1 (line 13) and `parse` returns
    `true` (line 12). Note that the first iterator is passed as a non-const reference
    to `parse` and is incremented by parse; the reason we pass a copy of `str.begin()`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含头文件`boost/spirit/include/qi.hpp`以便访问Spirit Qi函数、类型和对象。我们的输入是字符串`Hello, world!`，并且使用预定义解析器`alpha`，我们希望强制第一个字符是拉丁字母表中的字母，而不是数字或标点符号。为此，我们使用`parse`函数，将其传递给定义输入和`alpha`解析器的迭代器对（第10行）。`parse`函数如果成功解析输入则返回`true`，否则返回`false`。范围开始的迭代器被递增以指向输入中第一个未解析的字符。由于`Hello,
    world!`的第一个字符是H，`alpha`解析器成功解析它，将`iter`递增1（第13行），`parse`返回`true`（第12行）。请注意，第一个迭代器作为非const引用传递给`parse`，并且由`parse`递增；我们传递`str.begin()`的副本的原因。
- en: Parser operators and expressions
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析器运算符和表达式
- en: 'Spirit defines a number of overloaded operators called **parser operators**
    which can be used to compose a complex parser expression out of simpler parsers,
    including the predefined ones. The following table summarizes some of these operators:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Spirit定义了一些名为**解析器运算符**的重载运算符，可以用来将简单解析器组合成复杂的解析器表达式，包括预定义的解析器。以下表总结了其中一些运算符：
- en: '| Operator | Type | Purpose | Example |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 类型 | 目的 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| >> (Sequence operator) | Binary, infix | Two parsers serially parse two tokens
    | `string("Hello") >> string("world")`Matches `Helloworld`. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| >> (序列运算符) | 二进制，中缀 | 两个解析器依次解析两个标记 | `string("Hello") >> string("world")`匹配`Helloworld`。'
- en: '| &#124; (Disjunction operator) | Binary, infix | Any one of the two parsers
    is able to parse the token, but not both | `string("Hello") &#124; string("world")`Matches
    either `Hello` or `world` but not `Helloworld`. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| &#124; (分歧运算符) | 二进制，中缀 | 两个解析器中的任何一个都能解析标记，但不能同时解析 | `string("Hello") &#124;
    string("world")`匹配`Hello`或`world`但不匹配`Helloworld`。'
- en: '| * (Kleene operator) | Unary, prefix | Parses the empty string or one or more
    matching tokens | `*string("Hello")`Matches the empty string, `Hello`, `HelloHello,`
    and so on. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| * (Kleene运算符) | 一元，前缀 | 解析空字符串或一个或多个匹配的标记 | `*string("Hello")`匹配空字符串、`Hello`、`HelloHello`等。'
- en: '| + (Plus operator) | Unary, prefix | Parses one or more matching tokens |
    `+string("Hello")`Matches `Hello`, `HelloHello,` and so on, but not the empty
    string. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| + (加号运算符) | 一元，前缀 | 解析一个或多个匹配的标记 | `+string("Hello")`匹配`Hello`、`HelloHello`等，但不匹配空字符串。
    |'
- en: '| ~ (Negation operator) | Unary, prefix | Parses a token that does not match
    the parser | `~xdigit`Will parse any character that is not a hexadecimal digit.
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| ~ (否定运算符) | 一元，前缀 | 解析不匹配解析器的标记 | `~xdigit`将解析任何不是十六进制数字的字符。'
- en: '| - (Optional operator) | Unary, prefix | Parses the empty string or a single
    matching token | `-string("Hello")`Matches `Hello` or the empty string. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| - (可选运算符) | 一元，前缀 | 解析空字符串或单个匹配的标记 | `-string("Hello")`匹配`Hello`或空字符串。'
- en: '| - (Difference operator) | Binary, infix | *P1 - P2* parses any token that
    P1 can parse and P2 cannot | `uint_ - ushort_`Matches any `unsigned int` that
    is not also an `unsigned short`. Matches 65540 but not 65530 on a system with
    2-byte `short`. |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| - (差分运算符) | 二进制，中缀 | *P1 - P2* 解析P1可以解析而P2不能解析的任何标记 | `uint_ - ushort_`匹配任何不是`unsigned
    short`的`unsigned int`。在一个有2字节`short`的系统上，匹配65540但不匹配65530。'
- en: '| % (List operator) | Binary, infix | *P1 % D* splits the input into tokens
    that match P1 at delimiters that match D | `+alnum % +(space&#124;punct)`Splits
    input text strings into alphanumeric strings, using spaces and punctuations as
    delimiters. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| %（列表运算符）| 二进制，中缀 | *P1 % D*将输入在匹配D的分隔符处拆分为与P1匹配的标记 | `+alnum % +(space|punct)`使用空格和标点作为分隔符将输入文本字符串拆分为字母数字字符串。
    |'
- en: '| &#124;&#124; (Sequential OR operator) | Binary, infix | *P1 &#124;&#124;
    P2* is equivalent to *P1 &#124; (P1 >> P2)* | `string("Hello") &#124;&#124; string("world")`Matches
    either `Hello` or `Helloworld` but not `world`. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| ||（顺序或运算符）| 二进制，中缀 | *P1 || P2*等同于*P1 | (P1 >> P2)* | `string("Hello") ||
    string("world")`匹配`Hello`或`Helloworld`但不匹配`world`。'
- en: Note that there is a unary `operator-`, which is the optional operator, and
    binary `operator-`, which is the difference operator.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有一个一元`operator-`，即可选运算符，和一个二元`operator-`，即差运算符。
- en: The `boost::spirit::qi::parse` function template does not skip any characters
    whitespaces while parsing. Sometimes, it is convenient to ignore intervening spaces
    between tokens while parsing, and the `boost::spirit::qi::phrase_parse` does this.
    For example, the parser `string("Hello") >> string("world")` would parse `Helloworld`
    when we use `boost::spirit::qi::parse`, but not `Hello, world!`. But if we used
    `phrase_parse` and ignored spaces and punctuation, then it would parse `Hello,
    world!` too.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::spirit::qi::parse`函数模板在解析时不会跳过任何空白字符。有时，在解析时忽略标记之间的空格是很方便的，`boost::spirit::qi::phrase_parse`就是这样做的。例如，解析器`string("Hello")
    >> string("world")`在使用`boost::spirit::qi::parse`时会解析`Helloworld`，但不会解析`Hello,
    world!`。但是，如果我们使用`phrase_parse`并忽略空格和标点，那么它也会解析`Hello, world!`。'
- en: '**Listing 7.29: Using phrase_parse**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.29：使用phrase_parse**'
- en: '[PRE90]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note that we pass `+(space|punct)` as the fourth argument to `phrase_parse`,
    which tells it which characters to ignore; spaces and punctuation.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`+(space|punct)`作为第四个参数传递给`phrase_parse`，告诉它要忽略哪些字符；空格和标点。
- en: Parsing directives
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析指令
- en: 'Parsing directives are modifiers that can be used to alter the behavior of
    parsers in some way. For example, we can perform case-insensitive parses using
    the `no_case` directive, as shown in the following snippet:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 解析指令是可以用来以某种方式改变解析器行为的修饰符。例如，我们可以使用`no_case`指令执行不区分大小写的解析，如下面的代码片段所示：
- en: '[PRE91]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `skip` directive can be used to skip whitespace over a section of the input:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip`指令可用于跳过输入的某个部分上的空白：'
- en: '[PRE92]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The directive `qi::skip(qi::space)[parser]` ignores spaces even though we called
    `parse` and not `phrase_parse`. It can be selectively applied to parser sub-expressions.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 指令`qi::skip(qi::space)[parser]`即使我们调用的是`parse`而不是`phrase_parse`也会忽略空格。它可以有选择地应用于解析器子表达式。
- en: Semantic actions
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 语义动作
- en: More often than not, while using Spirit, we are not just looking to verify that
    a piece of text conforms to a certain grammar; we want to extract the tokens and
    perhaps use them in some kind of calculation or store them away. We can associate
    some action to a parser instance to be run when it successfully parses text, and
    this action can perform the necessary computation using the result of the parse.
    Such actions are defined using a function object enclosed in square brackets,
    trailing the parser it is associated with.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Spirit时，我们通常不仅仅是要验证一段文本是否符合某种语法；我们希望提取标记，并可能在某种计算中使用它们或将它们存储起来。我们可以将某个动作与解析器实例关联起来，以便在成功解析文本时运行，这个动作可以使用解析的结果进行必要的计算。这样的动作是使用方括号括起来的函数对象定义的，跟在它关联的解析器后面。
- en: '**Listing 7.30: Defining actions associated with parsers**'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.30：定义与解析器关联的动作**'
- en: '[PRE93]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the preceding example, we parse a list of unsigned integers separated by
    spaces (line 10) using the `uint_` parser (line 14). We define a function `print`
    (line 5) to print unsigned integers and associate it as an action with the `uint_`
    parser (line 14). For each unsigned integer parsed, the preceding code prints
    it on a new line by invoking the specified action. Actions can also be specified
    using functors, including those generated by Boost Bind and Boost Phoenix.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用`uint_`解析器（第10行）解析由空格分隔的无符号整数列表。我们定义一个`print`函数（第5行）来打印无符号整数，并将其作为一个动作与`uint_`解析器（第14行）关联起来。对于每个解析的无符号整数，前面的代码通过调用指定的动作在新行上打印它。动作也可以使用函数对象指定，包括由Boost
    Bind和Boost Phoenix生成的函数对象。
- en: Each parser, from the primitive to the most complex, has an associated *attribute*,
    which is set to the result of a successful parse, that is, the text it matches
    when it is applied to some input converted to the appropriate type. For a simple
    parser like `uint_`, this attribute would be of type `unsigned int`. For complex
    parsers, this could be an ordered tuple of attributes of its constituent parsers.
    When an action associated with a parser is invoked, it is passed the value of
    the parser's attribute.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始到最复杂的每个解析器都有一个关联的*属性*，它设置为成功解析的结果，即当它应用于转换为适当类型的某些输入时匹配的文本。对于像`uint_`这样的简单解析器，该属性将是`unsigned
    int`类型。对于复杂的解析器，这可能是其组成解析器的属性的有序元组。当与解析器关联的动作被调用时，它会传递解析器属性的值。
- en: 'The expression `+qi::uint_[print]` associates the print function with the `uint_`
    parser. If instead we wanted to associate an action with the composite parser
    `+qi::uint_`, then we would need to use a function with a different signature—one
    with a parameter of type `std::vector<unsigned int>` that would contain all the
    parsed numbers:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`+qi::uint_[print]`将`print`函数与`uint_`解析器关联起来。如果我们想要将动作与复合解析器`+qi::uint_`关联起来，那么我们需要使用不同签名的函数，即带有类型为`std::vector<unsigned
    int>`的参数的函数，它将包含所有解析的数字。
- en: '[PRE94]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can use Boost Bind expressions and Phoenix actors too for generating the
    action. Thus, we could have written `+qi::uint_[boost::bind(print, ::_1)]` to
    call `print` on each parsed number. The placeholders `::_1` through `::_9` are
    defined by the Boost Bind library in the global namespace. Spirit provides Phoenix
    actors that can be used for a variety of actions. The following snippet shows
    a way to add parsed numbers into a vector:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Boost Bind表达式和Phoenix操作来生成动作。因此，我们可以编写`+qi::uint_[boost::bind(print,
    ::_1)]`来在每个解析的数字上调用`print`。占位符`::_1`到`::_9`由Boost Bind库在全局命名空间中定义。Spirit提供了可以用于各种操作的Phoenix操作。以下代码片段展示了将解析的数字添加到向量中的方法：
- en: '[PRE95]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The action expression `push_back(boost::phoenix::ref(vec), qi::_1)` uses the
    `boost::phoenix::push_back` actor to append each parsed number (represented by
    the placeholder `qi::_1`) to the vector `vec`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`boost::phoenix::push_back`操作表达式`push_back(boost::phoenix::ref(vec), qi::_1)`将每个解析的数字（由占位符`qi::_1`表示）附加到向量`vec`。
- en: 'There are overloads of the `parse` and `phrase_parse` function templates that
    take an attribute argument in which you can directly store the data parsed by
    the parser. Thus, we can pass a `vector` of `unsigned int`s as the attribute argument,
    while parsing the list of unsigned integers:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 有`parse`和`phrase_parse`函数模板的重载，它们接受一个属性参数，您可以直接将解析器解析的数据存储在其中。因此，我们可以将`unsigned
    int`的`vector`作为属性参数传递，同时解析无符号整数的列表：
- en: '[PRE96]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Rules
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'So far, we have generated parsers using inline expressions. When dealing with
    more complex parsers, it is useful to cache the components and reuse them. For
    this purpose, we use the `boost::spirit::qi::rule` template. The rule template
    takes up to four arguments of which the first, that is, the iterator type for
    the input, is mandatory. Thus, we can cache a parser that parses spaces in `std::string`
    objects, as shown here:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用内联表达式生成了解析器。当处理更复杂的解析器时，缓存组件并重用它们是很有用的。为此，我们使用`boost::spirit::qi::rule`模板。规则模板最多接受四个参数，其中第一个即输入的迭代器类型是必需的。因此，我们可以缓存解析`std::string`对象中的空格的解析器，如下所示：
- en: '[PRE97]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Notice that `space_rule`, defined as above, is a parser that follows the same
    grammar as `qi::space`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如上所定义的`space_rule`是一个遵循与`qi::space`相同语法的解析器。
- en: 'More often than not, we are interested in consuming the value parsed by the
    parser. To define a rule containing such a parser, we need to specify the signature
    of a method that would be used to obtain the parsed value. For example, the `boost::spirit::qi::double_`
    parser''s attribute is of type `double`. So, we consider a function taking no
    arguments and returning a `double` as the appropriate signature `double()` to
    use. This signature is passed as the second template argument to the rule:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 往往我们对解析器解析的值感兴趣。要定义包含这样的解析器的规则，我们需要指定一个方法的签名，该方法将用于获取解析的值。例如，`boost::spirit::qi::double_`解析器的属性类型为`double`。因此，我们认为一个不带参数并返回`double`的函数是适当的签名`double()`。此签名作为规则的第二个模板参数传递：
- en: '[PRE98]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If the rule is meant to skip spaces, we specify the type of parser that is
    used to identify the characters to skip as the third template argument to `rule`.
    Thus, to define a parser for a list of `double`s separated by spaces, we can use
    the following rule with `qi::space_type`, specifying the type of the space parser:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规则用于跳过空格，我们将用于识别要跳过的字符的解析器的类型指定为`rule`的第三个模板参数。因此，要定义一个由空格分隔的`double`列表的解析器，我们可以使用以下规则和`qi::space_type`，指定空格解析器的类型：
- en: '[PRE99]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'When a rule is defined in terms of a combination of parsers, the value parsed
    by the rule is synthesized from the values parsed by the individual component
    parsers. This is called the **synthesized attribute** of the rule. The signature
    argument to the rule template should be compatible with the type of the synthesized
    attribute. For example, the parser `+qi::double_` returns a sequence of doubles,
    and therefore, the type of the synthesized attribute is `std::vector<std::double>`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当规则以一组解析器的组合形式定义时，规则解析的值是从各个组件解析器解析的值合成而来的。这称为规则的**合成属性**。规则模板的签名参数应与合成属性的类型兼容。例如，解析器`+qi::double_`返回一系列双精度浮点数，因此合成属性的类型是`std::vector<std::double>`：
- en: '[PRE100]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Notice that we assign the parser to the rule on a separate line, using `operator
    %=`. If we did not use the `%=` operator and used the plain assignment operator
    instead, then the result of a successful parse using `+qi::double_` would not
    be propagated to the synthesized attribute of `doubles_p`. Thanks to the `%=`
    operator, we can associate a semantic action with `doubles_p` to access its synthesized
    value as a `std::vector<double>`, as shown in the following example:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将解析器分配给规则的操作在单独的一行上，使用`operator %=`。如果我们不使用`%=`操作符，而是使用普通的赋值操作符，那么使用`+qi::double_`成功解析的结果将不会传播到`doubles_p`的合成属性。由于`%=`操作符，我们可以将语义动作与`doubles_p`关联起来，以访问其合成值作为`std::vector<double>`，如下例所示：
- en: '[PRE101]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Parsing timestamps
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析时间戳
- en: Consider timestamps of the form YYYY-mm-DD HH:MM:SS.ff, in which the date part
    is mandatory and the time part is optional. Moreover, the seconds and fractional
    seconds part of the time are also optional. We need to define a suitable parser
    expression.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑形式为YYYY-mm-DD HH:MM:SS.ff的时间戳，其中日期部分是必需的，时间部分是可选的。此外，时间的秒和小数秒部分也是可选的。我们需要定义一个合适的解析器表达式。
- en: 'The first thing we require is a way to define parsers for fixed-length unsigned
    integers. The `boost::spirit::qi::int_parser` template comes in handy for this
    purpose. Using template parameters of `int_parser`, we specify the base integral
    type to use, the radix or base of the number system, and the minimum and maximum
    number of digits to allow. Thus, for 4-digit years, we can use a parser type `int_parser<unsigned
    short, 10, 4, 4>`, both the minimum and maximum width being 4, as we need fixed-length
    integers. The following are the rules constructed using `int_parser`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一种方法来定义固定长度无符号整数的解析器。`boost::spirit::qi::int_parser`模板非常适用于此目的。使用`int_parser`的模板参数，我们指定要使用的基本整数类型、数字系统的基数或基数，以及允许的最小和最大数字位数。因此，对于4位数的年份，我们可以使用解析器类型`int_parser<unsigned
    short, 10, 4, 4>`，最小宽度和最大宽度都为4，因为我们需要固定长度的整数。以下是使用`int_parser`构造的规则：
- en: '[PRE102]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Of course, we need to define actions to capture the components of the timestamp.
    For simplicity, we will associate actions with the component parsers. We will
    define a type to represent timestamps and associate actions with parsers to set
    attributes of an instance of this type.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要定义操作来捕获时间戳的组件。为了简单起见，我们将操作与组件解析器相关联。我们将定义一个类型来表示时间戳，并将操作与解析器相关联，以设置此类型的实例的属性。
- en: '**Listing 7.31: Simple date and time parser**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单7.31：简单的日期和时间解析器**'
- en: '[PRE103]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `timestamp_t` type (line 6) represents a timestamp, with getters and setters
    for each of its fields. We have omitted most of the getters and setters for conciseness.
    We define actions associated with parsers for individual fields of the timestamp,
    setting appropriate attributes of a `timestamp_t` instance using `boost::bind`
    (lines 25, 27, 29, 32, 35, 38, 40).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestamp_t`类型（第6行）表示时间戳，具有每个字段的获取器和设置器。为了简洁起见，我们省略了大多数获取器和设置器。我们定义了与时间戳的各个字段的解析器相关联的操作，使用`boost::bind`（第25、27、29、32、35、38、40行）设置`timestamp_t`实例的适当属性。'
- en: Self-test questions
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'For multiple choice questions, choose all the options that apply:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多项选择题，选择所有适用的选项：
- en: Which of the following overloads/specializations does the call `foo(1.0, std::string("Hello"))`
    resolve to?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下重载/特化中的哪一个会解析到调用`foo(1.0, std::string("Hello"))`？
- en: a. `template <typename T, typename U> foo(T, U);`
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: a. `template <typename T, typename U> foo(T, U);`
- en: b. `foo(double, std::string&);`
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: b. `foo(double, std::string&);`
- en: c. `template <> foo<double, std::string>`
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: c. `template <> foo<double, std::string>`
- en: d. There is ambiguity
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: d. 存在歧义
- en: What is the interface that a metafunction must satisfy?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元函数必须满足的接口是什么？
- en: a. It must have a static `value` field
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: a. 必须有一个静态的`value`字段
- en: b. It must have an embedded type called `type`
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: b. 它必须有一个名为`type`的嵌入类型
- en: c. It must have a static `type` field
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它必须有一个静态的`type`字段
- en: d. It must have an embedded type called `result`
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: d. 它必须有一个名为`result`的嵌入类型
- en: 'What does the following statement do: `boost::mpl::or_<boost::is_floating_point<T>,
    boost::is_signed<T>>`?'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句`boost::mpl::or_<boost::is_floating_point<T>, boost::is_signed<T>>`是做什么的？
- en: a. Checks whether type T is signed and a floating point type
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: a. 检查类型T是有符号和浮点类型
- en: b. Generates a metafunction that checks (a)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: b. 生成一个检查（a）的元函数
- en: c. Checks whether type T is signed or a floating point type
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: c. 检查类型T是有符号还是浮点类型
- en: d. Generates a metafunction that checks (b)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: d. 生成一个检查（b）的元函数
- en: 'We have a template declared as: `template <typename T, typename Enable = void>
    class Bar` and does not use the `Enable` parameter in any way. How do you declare
    a partial specialization of Bar that would be instantiated only when T is a non-POD
    type?'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个声明为：`template <typename T, typename Enable = void> class Bar`的模板，并且以任何方式都不使用`Enable`参数。如何声明Bar的部分特化，只有在T是非POD类型时才实例化？
- en: a. `template <T> class Bar<T, boost::is_non_pod<T>>`
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: a. `template <T> class Bar<T, boost::is_non_pod<T>>`
- en: b. `template <T> class Bar<T, boost::enable_if<is_non_pod<T>>::type>`
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: b. `template <T> class Bar<T, boost::enable_if<is_non_pod<T>>::type>`
- en: c. `template <T> class Bar<T, boost::mpl::not<boost::is_pod<T>>>`
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: c. `template <T> class Bar<T, boost::mpl::not<boost::is_pod<T>>>`
- en: d. `template <T> class Bar<T, boost::disable_if<is_pod<T>>::type>`
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: d. `template <T> class Bar<T, boost::disable_if<is_pod<T>>::type>`
- en: Which of the following is true of C++ lambda expressions and Boost Phoenix actors?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于C++ lambda表达式和Boost Phoenix actors的哪一个是正确的？
- en: a. Lambda expressions are unnamed, Phoenix actors are not
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: a. Lambda表达式是无名的，Phoenix actors不是
- en: b. Phoenix actors are polymorphic, while polymorphic lambda expressions are
    only available from C++14
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: b. Phoenix actors是多态的，而多态lambda表达式仅在C++14中可用
- en: c. Phoenix actors can be partially applied, while lambda expressions cannot
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: c. Phoenix actors可以部分应用，而lambda表达式不能
- en: d. Lambda expressions can be used as closures but Phoenix actors cannot
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: d. Lambda表达式可以用作闭包，而Phoenix actors不能
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter was an interlude in our exploration of the Boost libraries. There
    were two key underlying themes: more expressive code and faster code. We saw how
    higher order programming helps us achieve more expressive syntaxes using functors
    and operator overloading. We saw how template metaprogramming techniques allow
    us to write code that executes at compile time and chooses the most optimal implementations
    for the task at hand.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是我们探索Boost库的插曲。有两个关键的主题：更具表现力的代码和更快的代码。我们看到高阶编程如何帮助我们使用函数对象和运算符重载实现更具表现力的语法。我们看到模板元编程技术如何使我们能够编写在编译时执行的代码，并为手头的任务选择最优实现。
- en: We covered a diverse amount of material in a single chapter and introduced a
    paradigm of programming that may be new to some of you. We solved a few problems
    with different functional patterns and saw the power of C++ functors, templates,
    and operator overloading put together. Understanding the subject of this chapter
    will be of immediate help if you are reading the implementation of most Boost
    libraries or trying to write a fast general purpose library that is efficient,
    expressive, and extensible.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个章节中涵盖了大量的材料，并介绍了一种编程范式，这可能对你们中的一些人来说是新的。我们用不同的功能模式解决了一些问题，并看到了C++函数对象、模板和运算符重载的强大力量。如果你正在阅读大多数Boost库的实现，或者试图编写一个高效、表达力强、可扩展的通用库，那么理解本章的主题将立即有所帮助。
- en: There is a lot that we did not cover in this chapter and do not cover in this
    book, including many, but the most basic details of Boost Spirit, a DSEL construction
    kit, Boost Proto; an expression template-based fast regular expression library,
    Boost Xpressive; and a more advanced tuple library, Boost Fusion. Hopefully, this
    chapter gives you enough of a head start to explore them further. Starting with
    the next chapter, where we cover Boost libraries for date and time calculations,
    we switch gears to focus on systems programming libraries in Boost.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们没有涵盖的内容还有很多，也没有在本书中涵盖，包括许多但不限于Boost Spirit的基本细节，一个DSEL构建工具包，Boost Proto；基于表达式模板的快速正则表达式库，Boost
    Xpressive；以及更先进的元组库，Boost Fusion。希望本章能够给你足够的起点来进一步探索它们。从下一章开始，我们将转向重点介绍Boost中用于日期和时间计算的库，重点关注Boost中的系统编程库。
- en: References
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: '*C++ Common Knowledge*, *Stephen C. Dewhurst*, *Addison Wesley Professional*'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C++常识》，《Stephen C. Dewhurst》，《Addison Wesley Professional》
- en: '*Modern C++ Design*, *Andrei Alexandrescu*, *Addison Wesley Professional*'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《现代C++设计》，《Andrei Alexandrescu》，《Addison Wesley Professional》
- en: '*C++ Template Metaprogramming*, *David Abrahams and Aleksey Gurtovoy*, *Addison
    Wesley Professional*'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C++模板元编程》，《David Abrahams和Aleksey Gurtovoy》，《Addison Wesley Professional》
- en: 'Proto: [http://web.archive.org/web/20120906070131/http://cpp-next.com/archive/2011/01/expressive-c-expression-optimization/](http://web.archive.org/web/20120906070131/http://cpp-next.com/archive/2011/01/expressive-c-expression-optimization/)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Proto: [http://web.archive.org/web/20120906070131/http://cpp-next.com/archive/2011/01/expressive-c-expression-optimization/](http://web.archive.org/20120906070131/http://cpp-next.com/archive/2011/01/expressive-c-expression-optimization/)'
- en: 'Boost Xpressive FTW: [http://ericniebler.com/2010/09/27/boost-xpressive-ftw/](http://ericniebler.com/2010/09/27/boost-xpressive-ftw/)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Boost Xpressive FTW: [http://ericniebler.com/2010/09/27/boost-xpressive-ftw/](http://ericniebler.com/2010/09/27/boost-xpressive-ftw/)'
- en: 'Fusion: [www.boost.org/libs/fusion](http://www.boost.org/libs/fusion)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Fusion: [www.boost.org/libs/fusion](http://www.boost.org/libs/fusion)'
