- en: Testing OS-Based Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试基于操作系统的应用程序
- en: Often, an embedded system uses a more or less regular **Operating System** (**OS**),
    which means that, often much, is the same as on our desktop OS in terms of runtime
    environment and tools, especially when targeting embedded Linux. Yet, differences
    in terms of performance and access offered by the embedded hardware versus our
    PC makes it essential to consider where to perform which parts of developing and
    testing, as well as how to integrate this into our development workflow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，嵌入式系统使用更或多或少常规的操作系统（OS），这意味着在运行时环境和工具方面，嵌入式Linux的目标与我们的桌面OS大致相同。然而，嵌入式硬件与我们的PC在性能和访问方面的差异使得必须考虑在哪里执行开发和测试的各个部分，以及如何将其整合到我们的开发工作流程中。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Developing cross-platform code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发跨平台代码
- en: Debugging and testing cross-platform code under Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux下调试和测试跨平台代码
- en: Effectively using cross-compilers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用交叉编译器
- en: Creating a build system that supports multiple targets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建支持多个目标的构建系统
- en: Avoiding real hardware
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免真实硬件
- en: One of the biggest advantages of OS-based development on platforms such as embedded
    Linux is that it's so similar to a regular desktop Linux installation. Especially
    when running an OS such as a Debian-based Linux distribution (Armbian, Raspbian,
    and others) on SoCs, we have practically the same tools available, with the entire
    package manager, compiler collections, and libraries available with a few keystrokes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式Linux等平台上进行基于操作系统的开发的最大优势之一是它与常规桌面Linux安装非常相似。特别是在SoC上运行像基于Debian的Linux发行版（Armbian、Raspbian等）时，我们几乎可以使用相同的工具，只需按几下键即可获得整个软件包管理器、编译器集合和库。
- en: This is, however, also its biggest pitfall.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也是它最大的缺点。
- en: We can write code, copy it over to the SBC, compile it there, run the test,
    and make changes to the code before repeating the process. Or, we can even write
    the code on the SBC itself, essentially using it as our sole development platform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写代码，将其复制到SBC上，在那里进行编译、运行测试，并在重复该过程之前对代码进行更改。或者，我们甚至可以在SBC上编写代码，基本上将其用作我们唯一的开发平台。
- en: 'The main reasons why we should never do this are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对不应该这样做的主要原因如下：
- en: A modern PC is much faster.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代PC速度更快。
- en: Testing on real hardware should never be done until the final stages of development.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发的最后阶段之前，不应该在真实硬件上进行测试。
- en: Automated integration testing is made much harder.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动集成测试变得更加困难。
- en: Here, the first point seems fairly obvious. What takes a single or dual-core
    ARM SoC a good minute to compile will quickly go from start of compilation to
    linking the objects in ten seconds or less with a relatively modern multi-core,
    multithreaded processor at 3+ GHz, and a toolchain that supports multi-core compilation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个观点似乎很明显。单核或双核ARM SoC编译需要大约一分钟的时间，而在相对现代的多核、多线程处理器（3+ GHz）和支持多核编译的工具链下，从编译开始到链接对象只需要十秒钟或更短的时间。
- en: This means that, instead of waiting half a minute or longer before we can run
    a new test or start a debugging session, we can do so almost instantly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，我们不必等待半分钟或更长时间才能运行新的测试或开始调试会话，几乎可以立即进行。
- en: The next two points are related. While it may seem advantageous to test on the
    real hardware, it comes with its own complications. One thing is that this hardware
    relies on a number of external factors to work properly, including its power supply,
    any wiring between power sources, peripherals, and signal interfaces. Things such
    as electromagnetic interference may also cause issues, in terms of signal degradation,
    as well as interrupts being triggered due to electromagnetic coupling.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两点是相关的。虽然在真实硬件上进行测试似乎是有利的，但它也带来了自己的复杂性。其中一点是，这些硬件依赖于许多外部因素才能正常工作，包括其电源供应、电源之间的任何布线、外围设备和信号接口。诸如电磁干扰之类的事物也可能引起问题，包括信号衰减以及由于电磁耦合而触发的中断。
- en: An example of electromagnetic coupling became apparent while developing the
    club status service project of [Chapter 3](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml),
    *Developing for Embedded Linux and Similar Systems*. Here, one of the signal wires
    for the switches ran alongside 230V AC wiring. Changes in the current on this
    mains wiring induced pulses in the signal wire, causing false interrupt trigger
    events.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml)的俱乐部状态服务项目开发过程中，出现了电磁耦合的一个例子，*为嵌入式Linux和类似系统开发*。在这里，开关的一个信号线与230V交流电线并排。这些主线布线上电流的变化在信号线上引起脉冲，导致虚假的中断触发事件。
- en: All of these potential hardware-related issues show that such tests aren't nearly
    as deterministic as we would wish them to be. The potential result of this is
    that project development takes much longer than planned, with debugging being
    complicated due to conflicting and non-deterministic test results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些潜在的与硬件相关的问题表明，这些测试并不像我们希望的那样确定。这可能导致项目开发时间比计划的要长得多，由于冲突和非确定性的测试结果，调试变得更加复杂。
- en: Another effect of a focus on developing on and for real hardware is that it
    makes automated testing much harder. The reason for this is that we cannot use
    any generic build cluster and, for example, Linux VM-based testing environment,
    as is common with mainstream **Continuous** **Integration** (**CI**) services.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于在真实硬件上进行开发的一个影响是，这使得自动化测试变得更加困难。原因在于我们无法使用任何通用的构建集群，例如基于Linux VM的测试环境，这在主流的持续集成（CI）服务中很常见。
- en: Instead of this, we would have to somehow integrate something such as an SBC
    into the CI system, having it either cross-compile and copy the binary to the
    SBC for running the test, or compile it on the SBC itself, which gets us back
    to the first point.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，我们必须以某种方式将诸如SBC之类的东西整合到CI系统中，使其可以交叉编译并将二进制文件复制到SBC上进行测试，或者在SBC上进行编译，这又回到了第一个观点。
- en: In the next few sections, we'll look at a of approaches to make embedded Linux-based
    development as painless as possible, starting with cross-compilation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨一些方法，使基于嵌入式Linux的开发尽可能轻松，从交叉编译开始。
- en: Cross-compiling for SBCs
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为SBC进行交叉编译
- en: The compile process takes the source files, turning them into an intermediate
    format, after which this format can be used to target a specific CPU architecture.
    For us, this means that we aren't limited to compiling applications for an SBC
    on that SBC itself, but we can do so on our development PC.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程将源文件转换为中间格式，然后可以使用此格式来针对特定的CPU架构。对我们来说，这意味着我们不仅仅局限于在SBC上为SBC编译应用程序，而是可以在我们的开发PC上进行编译。
- en: To do so for an SBC such as the Raspberry Pi (Broadcom Cortex-A-based ARM SoCs),
    we need to install the `arm-linux-gnueabihf` toolchain, which targets the ARM
    architecture with hard float (hardware floating point) support, outputting Linux-compatible
    binaries.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要为树莓派（Broadcom Cortex-A架构的ARM SoC）这样的SBC进行此操作，我们需要安装`arm-linux-gnueabihf`工具链，该工具链针对具有硬件浮点（hardware
    floating point）支持的ARM架构，输出Linux兼容的二进制文件。
- en: 'On a Debian-based Linux system, we can install the entire toolchain with the
    following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Debian的Linux系统上，我们可以使用以下命令安装整个工具链：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first command installs the native GCC-based toolchain for the system (if
    it wasn't already installed), along with any common related tools and utilities,
    including `make`, `libtool`, `flex`, and others. The second command installs the
    actual cross-compiler. Finally, the third package is the version of the GDB debugger
    that supports multiple architectures, which we'll need later on for doing remote
    debugging on the real hardware, as well as for analyzing core dumps produced when
    our application crashes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令安装了系统的本机基于GCC的工具链（如果尚未安装），以及任何常见的相关工具和实用程序，包括`make`，`libtool`，`flex`等。第二条命令安装了实际的交叉编译器。最后，第三个软件包是支持多种架构的GDB调试器的版本，我们以后需要用它来在真实硬件上进行远程调试，以及分析应用程序崩溃时产生的核心转储。
- en: 'We can now use the g++ compiler for the target SBC using its full name on the
    command line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在命令行上使用g++编译器为目标SBC使用其完整名称：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To test whether the toolchain was properly installed, we can execute the following
    command, which should tell us the compiler details including the version:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试工具链是否正确安装，我们可以执行以下命令，这应该告诉我们编译器的详细信息，包括版本：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In addition to this, we may need to link with some shared libraries that exist
    on the target system. For this, we can copy the entire contents of the `/lib`
    and `/usr` folders and include them as part of the system root for the compiler:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们可能需要链接一些存在于目标系统上的共享库。为此，我们可以复制`/lib`和`/usr`文件夹的全部内容，并将其包含为编译器的系统根的一部分：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, `Pi-system` is the IP address or network name of the Raspberry Pi or
    similar system. After this, we can tell GCC to use these folders instead of the
    standard paths using the `sysroot` flag:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Pi-system`是树莓派或类似系统的IP地址或网络名称。之后，我们可以告诉GCC使用这些文件夹，而不是使用标准路径，使用`sysroot`标志：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here `dir` would be the folder where we copied these folders to, in this example
    that would be `~/raspberry/sysroot`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`dir`将是我们将这些文件夹复制到的文件夹，在这个例子中将是`~/raspberry/sysroot`。
- en: Alternatively, we can just copy the header and library files we require and
    add them as part of the source tree. Whichever approach is the easiest mostly
    depends on the dependencies of the project in question.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以只复制所需的头文件和库文件，并将它们添加为源树的一部分。哪种方法最容易主要取决于所涉及项目的依赖关系。
- en: For the club status service project, we require at the very least the headers
    and libraries for WiringPi, as well as those for the POCO project and its dependencies.
    We could determine the dependencies we need and copy the required includes and
    library files that are missing from the toolchain we installed earlier. Unless
    there's a pressing need to do so, it's far easier to just copy the entire folders
    from the SBC's OS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于俱乐部状态服务项目，我们至少需要WiringPi的头文件和库，以及POCO项目及其依赖项的头文件和库。我们可以确定我们需要的依赖关系，并复制我们之前安装的工具链中缺少的所需包含和库文件。除非有迫切需要这样做，否则最容易的方法是直接从SBC的操作系统中复制整个文件夹。
- en: As an alternative to using the `sysroot` method, we can also explicitly define
    the paths to the shared libraries that we wish to use while linking our code.
    This of course comes with its own set of advantages and disadvantages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`sysroot`方法的替代方案，我们还可以在链接代码时明确定义我们希望使用的共享库的路径。当然，这也有其自身的优缺点。
- en: Integration test for club status service
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 俱乐部状态服务的集成测试
- en: In order to test the club status service on a regular desktop Linux (or macOS
    or Windows) system before we embark on cross-compiling and testing on real hardware,
    a simple integration test was written, which uses mocks for the GPIO and I2C peripherals.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在进行交叉编译并在真实硬件上测试之前，在常规桌面Linux（或macOS或Windows）系统上测试俱乐部状态服务，编写了一个简单的集成测试，该测试使用GPIO和I2C外围设备的模拟。
- en: In the source code for the project covered in [Chapter 3](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml),
    *Developing for Embedded Linux and Similar Systems*, the files for these peripherals are
    found in the `wiring` folder of that project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml)中涵盖的项目的源代码中，*为嵌入式Linux和类似系统开发*，这些外围设备的文件位于该项目的`wiring`文件夹中。
- en: 'We start with the `wiringPi.h` header:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`wiringPi.h`头文件开始：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We include a header from the POCO framework to allow us to easily create a
    timer instance later on. Then, we define all possible pin modes, just as the actual
    WiringPi header defines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了POCO框架的一个头文件，以便我们稍后可以轻松创建一个定时器实例。然后，我们定义了所有可能的引脚模式，就像实际的WiringPi头文件定义的那样：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These defines define further pin modes, including the digital input levels,
    the possible states of the pull-ups and pull-downs on the pins, and finally the
    possible types of interrupts, defining the trigger or triggers for an interrupt:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义进一步定义了引脚模式，包括数字输入电平，引脚上上拉和下拉的可能状态，最后是中断的可能类型，定义中断的触发器：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `typedef` defines the format for an interrupt callback function pointer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`typedef`定义了中断回调函数指针的格式。
- en: 'Let''s now look at the `WiringTimer` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`WiringTimer`类：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This class is the integral part of the GPIO-side of our mock implementation.
    Its main purpose is to keep track of which of the two interrupts we''re interested
    in have been registered, and to trigger them at regular intervals using the timer,
    as we''ll see in a moment:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该类是我们模拟实现的GPIO端的重要部分。其主要目的是跟踪我们感兴趣的两个中断是否已注册，并使用定时器定期触发它们，正如我们将在下一刻看到的：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we define the standard WiringPi functions before moving on the implementation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在继续实现之前，我们定义标准的WiringPi函数：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the class constructor, we set the default values before creating the timer
    instance, configuring it to call our callback function every ten seconds, after
    an initial 10-second delay:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在类构造函数中，我们在创建定时器实例之前设置默认值，并将其配置为在初始10秒延迟后每十秒调用我们的回调函数一次：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the destructor, we delete the timer callback instance:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在析构函数中，我们删除了定时器回调实例：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this function, we actually start the timer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们实际上启动了定时器：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This last function in the class is the callback for the timer. The way it functions
    is that it keeps track of how many times it has been triggered, with it setting
    the appropriate pin level in the form of a value in a file that we write to disk.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该类中的最后一个函数是定时器的回调函数。它的功能是跟踪触发的次数，并将适当的引脚电平设置为我们写入磁盘的文件中的值。
- en: 'After the initial delay, the first trigger will set the lock switch to `false`,
    the second the status switch to `true`, the third the status switch back to `false`,
    and finally the fourth trigger sets the lock switch back to `true`, before resetting
    the counter and starting over again:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始延迟之后，第一个触发器将将锁定开关设置为`false`，第二个将状态开关设置为`true`，第三个将状态开关设置回`false`，最后第四个触发器将锁定开关设置回`true`，然后重置计数器并重新开始：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We add a global namespace in which we have a `unique_ptr` instance for a `WiringTimer`
    class instance, along with an initialization status indicator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在其中添加了一个全局命名空间，其中有一个`WiringTimer`类实例的`unique_ptr`实例，以及一个初始化状态指示器。
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The setup function is used to write the default values for the mocked GPIO
    pin inputs value to disk. We also create the pointer to a `WiringTimer` instance
    here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数用于将模拟GPIO引脚输入值的默认值写入磁盘。我们还在这里创建了一个`WiringTimer`实例的指针：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because our mocked implementation determines the behavior of the pins, we can
    ignore any input on these functions. For testing purposes, we could add an assert
    to validate that these functions have been called at the right times with the
    appropriate settings:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模拟实现确定了引脚的行为，我们可以忽略这些函数的任何输入。为了测试目的，我们可以添加一个断言来验证这些函数在适当的时间以及具有适当的设置被调用：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When reading the value for one of the two mocked pins, we open its respective
    file and read out its content, which is either the 1 or 0 set by the setup function
    or by the callback:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取两个模拟引脚之一的值时，我们打开其相应的文件并读取其内容，这是由设置函数或回调设置的1或0：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function is used to register an interrupt and its associated callback function.
    After an initial check that the mock has been initialized by the setup function,
    we then continue to register the interrupt for one of the two specified pins.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于注册中断及其关联的回调函数。在通过设置函数初始化模拟后，我们继续注册两个指定引脚中的一个的中断。
- en: Once both pins have had an interrupt set for them, we start the timer, which
    will in turn start generating events for the interrupt callbacks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦两个引脚都设置了中断，我们就启动定时器，定时器将开始生成中断回调的事件。
- en: 'Next is the I2C bus mock:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是I2C总线模拟：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We just need two functions here: the setup function and the simple one-byte
    register write function.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们只需要两个函数：设置函数和简单的一字节寄存器写入函数。
- en: 'The implementation is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the setup function, we log the requested device ID (I2C bus address) and
    return a standard device handle. Here, we use the `log()` function from the `Club`
    class to make the mock integrate into the rest of the code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置函数中，我们记录请求的设备ID（I2C总线地址），并返回一个标准设备句柄。在这里，我们使用`Club`类中的`log()`函数，使模拟集成到其余代码中：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since the code that would call this function wouldn't be expecting a response,
    beyond a simple acknowledgment that the data has been received, we can just log
    the received data and further details here. The `NumberFormatter` class from POCO
    is used here as well for formatting the integer data as hexadecimal values like
    in the application, for consistency.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调用此函数的代码不会期望除了简单的确认数据已被接收之外的响应，我们可以在这里记录接收到的数据和更多细节。同样，为了一致性，这里也使用了POCO的`NumberFormatter`类来格式化整数数据为十六进制值，就像在应用程序中一样。
- en: 'We now compile the project and use the following command-line command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编译项目并使用以下命令行命令：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running the application (under GDB, to see when new threads are created/destroyed)
    now gets us the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序（在GDB下，以查看何时创建/销毁新线程）会得到以下输出：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, the system has been configured with all interrupts set and the
    I2C device configured by the application. The timer has started its initial countdown:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，系统已配置所有中断并由应用程序配置了I2C设备。定时器已经开始了初始倒计时：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The initial status of the GPIO pins has been read out and both switches are
    found to be in the `off` position, so we activate the red light on the traffic
    light indicator by writing its position in the register:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO引脚的初始状态已被读取，两个开关都处于“关闭”位置，因此我们通过将其位置写入寄存器来激活交通灯指示灯上的红灯：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, the timer starts triggering the callback function repeatedly, causing
    it to go through its different stages. This allows us to ascertain that the basic
    functioning of the code is correct.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定时器开始触发回调函数，导致它经历不同的阶段。这使我们能够确定代码的基本功能是正确的。
- en: At this point, we can start implementing more complex test cases, conceivably
    even implementing scriptable test cases using an embedded Lua, Python runtime
    or similar.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以开始实施更复杂的测试用例，甚至可以使用嵌入式Lua、Python运行时或类似的工具来实施可编写脚本的测试用例。
- en: Mock versus hardware
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟与硬件
- en: An obvious question to ask when mocking away large sections of code and hardware
    peripherals is how realistic the resulting mock is. We obviously want to be able
    to cover as many real-life scenarios as possible with our integration test before
    we move to testing on the target system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟大段代码和硬件外设时，一个明显的问题是最终模拟的结果有多现实。显然，我们希望在将测试移至目标系统之前，能够尽可能多地覆盖真实场景的集成测试。
- en: If we want to know which test cases we wish to cover in our mock, we have to
    look both at our project requirements (what it should be able to handle), and
    which situations and inputs can occur in a real-life scenario.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道我们希望在模拟中覆盖哪些测试用例，我们必须同时查看我们的项目需求（它应该能够处理什么）以及真实场景中可能发生的情况和输入。
- en: For this, we would analyze the underlying code to see what conditions can occur,
    and decide on which ones are relevant for us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将分析底层代码，看看可能发生什么情况，并决定哪些情况对我们来说是相关的。
- en: In the case of the WiringPi mocks we looked at earlier, a quick glance at the
    source code for the library's implementation makes it clear just how much we simplified
    our code compared to the version we would be using on our target system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前查看的WiringPi模拟中，快速查看库实现的源代码就清楚地表明，与我们将在目标系统上使用的版本相比，我们简化了我们的代码。
- en: 'Looking at the basic WiringPi setup function, we see that it does the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 查看基本的WiringPi设置函数，我们看到它执行以下操作：
- en: Determines the exact board model and SoC to get the GPIO layout
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定确切的板型和SoC以获取GPIO布局
- en: Opens the Linux device for the memory-mapped GPIO pins
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开Linux设备以进行内存映射的GPIO引脚
- en: Sets the memory offsets into the GPIO device and uses `mmap()` to map specific
    peripherals such as PWM, timer, and GPIO into memory
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置GPIO设备的内存偏移，并使用`mmap()`将特定的外设（如PWM、定时器和GPIO）映射到内存中
- en: 'Instead of ignoring calls to `pinMode()`, the implementation does the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与忽略`pinMode()`的调用不同，实现如下：
- en: Appropriately sets the hardware GPIO direction register in the SoC (for input/output
    mode)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当设置SoC中的硬件GPIO方向寄存器（用于输入/输出模式）
- en: Starts PWM, soft PWM, or Tone mode on a pin (as requested); sub-functions set
    the appropriate registers
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引脚上启动PWM、软PWM或Tone模式（根据请求）；子函数设置适当的寄存器
- en: 'This continues with the I2C side, where the setup function implementation looks
    like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这在I2C端继续进行，设置函数的实现如下：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compared to our mock implementation, the main difference is in that an I2C peripheral
    is expected to be present on the in-memory filesystem of the OS, and the board
    revision determines which one we pick.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的模拟实现相比，主要区别在于预期在OS的内存文件系统上存在I2C外设，并且板子版本确定我们选择哪一个。
- en: 'The last function that gets called tries to open the device, as in Linux and
    similar OSes every device is simply a file that we can open and get a file handle
    to, if successful. This file handle is the ID that gets returned when the function
    returns:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个被调用的函数尝试打开设备，因为在Linux和类似的操作系统中，每个设备只是一个我们可以打开并获得文件句柄的文件，如果成功的话。这个文件句柄就是函数返回时返回的ID：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After opening the I2C device, the Linux system function, `ioctl()`, is used
    to send data to the I2C peripheral, in this case, the address of the I2C slave
    device that we wish to use. If successful, we get a non-negative response and
    return the integer that's our file handle.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打开I2C设备后，使用Linux系统函数`ioctl()`来向I2C外设发送数据，这里是我们希望使用的I2C从设备的地址。如果成功，我们会得到一个非负的响应，并返回作为文件句柄的整数。
- en: 'Writing and reading the I2C bus is also handled using `ioctl()`, as we can
    see in the same source file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 写入和读取I2C总线也使用`ioctl()`来处理，正如我们在同一源文件中所看到的：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This same inline function is called for every single I2C bus access. With the
    I2C device that we wish to use already selected, we can simply target the I2C
    peripheral and have it transmit the payload to the device.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个I2C总线访问，都会调用相同的内联函数。已经选择了我们希望使用的I2C设备，我们可以简单地针对I2C外设，并让其将有效负载传输到设备上。
- en: 'Here, the `i2c_smbus_data` type is a simple union to support various sizes
    for the return value (when performing a read operation):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`i2c_smbus_data`类型是一个简单的联合体，支持返回值的各种大小（执行读操作时）：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we mostly see the benefit of using an abstract API. Without it, we would
    have peppered our code with low-level calls that would have been much harder to
    mock away. What we also see is that there are a number of conditions that we should
    likely be testing as well, such as a missing I2C slave device, read and write
    errors on the I2C bus that may result in unexpected behavior, as well as unexpected
    input on GPIO pins, including for interrupt pins as was noted at the beginning
    of this chapter already.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们主要看到使用抽象API的好处。如果没有它，我们的代码将充斥着低级调用，这将更难以模拟。我们还看到应该测试的一些条件，例如缺少I2C从设备、I2C总线上的读写错误可能导致意外行为，以及GPIO引脚上的意外输入，包括中断引脚，正如本章开头已经指出的那样。
- en: Although obviously not all scenarios can be planned for, efforts should be made
    to document all realistic scenarios and incorporate them into the mocked-up implementation,
    so that they can be enabled at will during integration and regression testing
    and while debugging.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管显然不是所有情况都可以预先计划，但应该努力记录所有现实情况，并将其纳入模拟实现中，以便在集成和回归测试以及调试期间可以随时启用它们。
- en: Testing with Valgrind
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Valgrind进行测试
- en: Valgrind is the most commonly used collection of open source tools for analyzing
    and profiling everything from the cache and heap behavior of an application to
    memory leaks and potential multithreading issues. It works in tandem with the
    underlying operating system as, depending on the tool used, it has to intercept
    everything from memory allocations to instructions related to multithreading and
    related. This is the reason why it is only fully supported under Linux on 64-bit
    x86_64 architectures.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind是用于分析和分析应用程序的缓存和堆行为，以及内存泄漏和潜在多线程问题的开源工具集。它与底层操作系统协同工作，因为根据使用的工具，它必须拦截从内存分配到与多线程相关的指令的一切。这就是为什么它只在64位x86_64架构的Linux下得到完全支持的原因。
- en: Using Valgrind on other supported platforms (Linux on x86, PowerPC, ARM, S390,
    MIPS, and ARM, also Solaris and macOS) is definitely also an option, but the primary
    development target of the Valgrind project is x86_64/Linux, making it the best
    platform to do profiling and debugging on, even if other platforms will be targeted
    later on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他支持的平台上使用Valgrind（如x86、PowerPC、ARM、S390、MIPS和ARM上的Linux，以及Solaris和macOS）当然也是一个选择，但Valgrind项目的主要开发目标是x86_64/Linux，这使得它成为进行分析和调试的最佳平台，即使以后会针对其他平台进行定位。
- en: On the Valgrind website at [http://valgrind.org/info/platforms.html](http://valgrind.org/info/platforms.html),
    we can see a full overview of the currently supported platforms.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Valgrind网站[http://valgrind.org/info/platforms.html](http://valgrind.org/info/platforms.html)上，我们可以看到当前支持的平台的完整概述。
- en: One very attractive property of Valgrind is that none of its tools require us
    to alter the source code or resulting binary in any fashion. This makes it very
    easy to integrate into an existing workflow, including automated testing and integration
    systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind非常吸引人的一个特性是，它的工具都不需要我们以任何方式修改源代码或生成的二进制文件。这使得它非常容易集成到现有的工作流程中，包括自动化测试和集成系统。
- en: On Windows-based system, tools such as Dr. Memory ([http://drmemory.org/](http://drmemory.org/))
    are available as well, which can handle at least the profiling of memory-related
    behavior. This particular tool also comes with Dr. Fuzz, a tool that can repeatedly
    call functions with varying inputs, potentially useful for integration testing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Windows的系统上，也有诸如Dr. Memory（[http://drmemory.org/](http://drmemory.org/)）之类的工具，它们也可以处理与内存相关行为的分析。这个特定的工具还配备了Dr.
    Fuzz，一个可以重复调用具有不同输入的函数的工具，可能对集成测试有用。
- en: By using an integration test such as what we looked at in the previous section,
    we're free to fully analyze the behavior of our code from the comfort of our PC.
    Since all of Valgrind's tools significantly slow down the execution of our code
    (10-100 times), being able to do most of the debugging and profiling on a fast
    system means that we can save a significant amount of time before embarking on
    testing on the target hardware.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用像前一节中所看到的集成测试，我们可以自由地从我们的个人电脑上完全分析我们代码的行为。由于Valgrind的所有工具都会显著减慢我们代码的执行速度（10-100倍），能够在快速系统上进行大部分调试和分析意味着我们可以节省大量时间，然后再开始在目标硬件上进行测试。
- en: Of the tools we'll likely use the most often, **Memcheck**, **Helgrind**, and
    **DRD** are useful for detecting memory allocation and multithreading issues.
    Once our code passes through these three tools, while using an extensive integration
    test that provides wide coverage of the code, we can move on to profiling and
    optimizing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可能经常使用的工具中，**Memcheck**、**Helgrind**和**DRD**对于检测内存分配和多线程问题非常有用。一旦我们的代码通过了这三个工具，并使用提供代码广泛覆盖的广泛集成测试，我们就可以进行分析和优化。
- en: To profile our code, we then use **Callgrind** to see where our code spends
    the most of the time executing, followed by **Massif** to do profiling of heap
    allocations. With the information we can glean from this data, we can make changes
    to the code to streamline common allocation and de-allocation cases. It might
    also show us where it might make sense to use a cache to reuse resources instead
    of discarding them from memory.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对我们的代码进行分析，我们使用**Callgrind**来查看代码执行时间最长的地方，然后使用**Massif**来对堆分配进行分析。通过这些数据，我们可以对代码进行更改，以简化常见的分配和释放情况。它也可能向我们展示在何处使用缓存以重用资源而不是将其从内存中丢弃是有意义的。
- en: Finally, we would run another cycle of MemCheck, Helgrind, and DRD to ensure
    that our changes didn't cause any regressions. Once we're satisfied, we move on
    to deploying the code on the target system and see how it performs there.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将运行另一个循环的MemCheck、Helgrind和DRD，以确保我们的更改没有引起任何退化。一旦我们满意，我们就会部署代码到目标系统上，并查看其在那里的表现。
- en: If the target system also runs Linux or other supported OSes, we can use Valgrind
    on there as well, to check that we didn't miss anything. Depending on the exact
    platform (OS and CPU architecture), we may run into limitations of the Valgrind
    port for that platform. These can include errors such as *unhandled instruction*,
    where the tool hasn't had a CPU instruction implemented and hence Valgrind cannot
    continue.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标系统也运行Linux或其他支持的操作系统，我们也可以在那里使用Valgrind，以确保我们没有遗漏任何东西。根据确切的平台（操作系统和CPU架构），我们可能会遇到Valgrind针对该平台的限制。这些可能包括*未处理的指令*等错误，其中工具尚未实现CPU指令，因此Valgrind无法继续。
- en: By extending the integration test to use the SBC instead of a local process,
    we can set up a continuous integration system whereby, in addition to the tests
    on a local process, we also run them on real hardware, taking into account the
    limitations of the real hardware platform relative to the x86_64-based Linux system
    used for most of the testing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将集成测试扩展到使用SBC而不是本地进程，我们可以建立一个持续集成系统，除了在本地进程上进行测试外，还可以在真实硬件上运行测试，考虑到真实硬件平台相对于用于大部分测试的基于x86_64的Linux系统的限制。
- en: Multi-target build system
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多目标构建系统
- en: Cross-compilation and multi-target build systems are among the words that tend
    to frighten a lot of people, mostly because they evoke images of hugely complicated
    build scripts that require arcane incantations to perform the desired operation.
    In this chapter, we'll be looking at a simple Makefile-based build system, based
    on a build system that has seen use in commercial projects across a range of hardware
    targets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译和多目标构建系统是一些让很多人感到恐惧的词语，主要是因为它们让人联想到需要神秘咒语才能执行所需操作的复杂构建脚本。在本章中，我们将看一个基于简单Makefile的构建系统，该构建系统已在一系列硬件目标的商业项目中得到应用。
- en: The one thing that makes a build system pleasant to use is to be able to get
    everything set up for compilation with minimal fuss and have a central location
    from which we can control all relevant aspects of building the project, or parts
    of it, along with building and running tests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使构建系统易于使用的一件事是能够轻松设置所有相关方面的编译，并且有一个中心位置，我们可以从中控制项目的所有相关方面，或者部分相关方面，以及构建和运行测试。
- en: For this reason, we have a single Makefile at the top of the project, which
    handles all of the basics, including the determining of which platform we run
    on. The only simplification we're making here is that we assume a Unix-like environment,
    with MSYS2 or Cygwin on Windows, and Linux, BSD, and OS X/macOS and others using
    their native shell environments. We could, however, also adapt it to allow for
    Microsoft Visual Studio, **Intel Compiler Collection** (**ICC**), and other compilers,
    so long as they provide the basic tools.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在项目顶部只有一个Makefile，它处理所有基本内容，包括确定我们运行的平台。我们在这里做的唯一简化是假设类Unix环境，使用MSYS2或Cygwin在Windows上，以及Linux、BSD和OS
    X/macOS等使用其本机shell环境。然而，我们也可以适应Microsoft Visual Studio、Intel Compiler Collection（ICC）和其他编译器，只要它们提供基本工具。
- en: 'Key to the build system are simple Makefiles, in which we define the specific
    details of the target platform, for example, for a standard Linux system running
    on x86_x64 hardware:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统的关键是简单的Makefile，在其中我们定义目标平台的具体细节，例如，对于在x86_x64硬件上运行的标准Linux系统：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we can set the names of the command-line tools that we'll be using for
    compiling, creating archives, stripping debug symbols from binaries, and so on.
    The build system will use the target OS and architecture to keep the created binaries
    separate so that we can use the same source tree to create binaries for all target
    platforms in one run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以设置我们将用于编译、创建存档、从二进制文件中剥离调试符号等操作的命令行工具的名称。构建系统将使用目标操作系统和架构来保持创建的二进制文件分开，以便我们可以使用相同的源树在一次运行中为所有目标平台创建二进制文件。
- en: 'We can see how we separate the flags that we''ll be passing to the compiler
    and linker into different categories: platform-specific ones, common (standard)
    flags, and finally flags specific for the C and C++ compiler. The former is useful
    when integrating external dependencies that have been integrated into the source
    tree, yet are written in C. These dependencies we''ll find in the `extern` folder,
    as we''ll see in more detail in a moment.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们将传递给编译器和链接器的标志分为不同的类别：特定于平台的标志，常见（标准）标志，最后是特定于C和C ++编译器的标志。前者在集成已集成到源树中的外部依赖项时非常有用，但这些依赖项是用C编写的。我们将在`extern`文件夹中找到这些依赖项，稍后我们将更详细地看到。
- en: This kind of file will be heavily customized to fit a specific project, adding
    the required includes, libraries, and compile flags. For this example file, we
    can see a project that uses the POCO and Boost libraries, along with OpenSSL,
    tweaking the POCO library for the target platform.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的文件将被大量定制以适应特定项目，添加所需的包含文件、库和编译标志。对于这个示例文件，我们可以看到一个使用POCO和Boost库以及OpenSSL的项目，调整POCO库以适应目标平台。
- en: 'First, let''s look at the top of the configuration file for macOS:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下macOS配置文件的顶部：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Although the rest of the file is almost the same, here we can see a good example
    of generalizing what a tool is called. Although Clang supports the same flags
    as GCC, its tools are called differently. With this approach, we just write the
    different names once in this file and everything will just work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管文件的其余部分几乎相同，但在这里我们可以看到一个很好的例子，说明了如何将工具的名称泛化。尽管Clang支持与GCC相同的标志，但其工具的名称不同。通过这种方法，我们只需在这个文件中写入不同的名称一次，一切都会正常工作。
- en: 'This continues with the Linux on ARM target, which is set up as a cross-compilation
    target:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这继续了ARM目标上的Linux，它被设置为交叉编译目标：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we see the reappearance of the cross-compilation toolchain for ARM Linux
    platforms, which we looked at earlier in this chapter. To save ourselves typing,
    we define the basic name once so that it is easy to redefine. This also shows
    how flexible Makefiles are. With some more creativity, we could create a set of
    templates that would generalize entire toolchains into a simple Makefile to be
    included by the main Makefile depending on hints in the platform's Makefile (or
    other configuration file), making this highly flexible.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了之前在本章中看到的用于ARM Linux平台的交叉编译工具链的再次出现。为了节省输入，我们定义了基本名称一次，以便重新定义。这也展示了Makefile的灵活性。通过更多的创造力，我们可以创建一组模板，将整个工具链泛化为一个简单的Makefile，该Makefile将根据平台的Makefile（或其他配置文件）中的提示包含在主Makefile中，从而使其高度灵活。
- en: 'Moving on, we''ll look at the main Makefile as found in the root of the project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下项目根目录中的主Makefile：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we cannot guess what platform the user wants us to target, we require
    that the target is specified, with the platform name as the value, for example, `linux-x86_x64`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法猜测用户希望我们针对哪个平台进行目标，我们要求指定目标，并将平台名称作为值，例如`linux-x86_x64`：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Later on in the system, we''ll need to know which folder we''re in on the local
    filesystem so that we can specify absolute paths. We use the standard Make variable
    for this and export it as our own environment variable, along with the build target
    name:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后在系统中，我们需要知道本地文件系统中的文件夹位置，以便我们可以指定绝对路径。我们使用标准的Make变量，并将其导出为我们自己的环境变量，以及构建目标名称：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using the (command-line) `uname` command, we can check which OS we're running
    on, with each OS that supports the command in its shell returning its name, such
    as `Linux` for Linux and `Darwin` for macOS. On pure Windows (no MSYS2 or Cygwin),
    the command doesn't exist, which would get us the second part of this `if/else`
    statement.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用（命令行）`uname`命令，我们可以检查我们正在运行的操作系统，每个支持该命令的操作系统在其shell中返回其名称，例如Linux用于Linux，Darwin用于macOS。在纯Windows上（没有MSYS2或Cygwin），该命令不存在，这将得到我们这个`if/else`语句的第二部分。
- en: 'This statement could be expanded to support more OSes, depending on what the
    build system requires. In this case, it is only used to determine whether executables
    we create should have a file extension:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句可以扩展以支持更多的操作系统，具体取决于构建系统的要求。在这种情况下，它仅用于确定我们创建的可执行文件是否应该有文件扩展名：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this `if/else` statement, we can set the appropriate command-line commands
    for common file operations. Since we're taking the easy way out, we're assuming
    the use of MSYS2 or similar Bash shell on Windows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`if/else`语句中，我们可以为常见的文件操作设置适当的命令行命令。由于我们采取了简单的方式，我们假设在Windows上使用MSYS2或类似的Bash
    shell。
- en: 'We could take the concept of generalizing further at this point as well, splitting
    off the OS file CLI tools as its own set of Makefiles, which we can then include
    as part of OS-specific settings:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以进一步推广概念，将OS文件CLI工具作为自己的一组Makefiles拆分出来，然后将其作为OS特定设置的一部分包含进来：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At this point, we use the target parameter provided to the Makefile to include
    the appropriate configuration file. After exporting some details from it, we now
    have a configured build system:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们使用提供给Makefile的目标参数来包含适当的配置文件。在从中导出一些细节之后，我们现在有了一个配置好的构建系统：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: From this single Makefile, we can choose to compile the entire project or just
    the dependencies or the core project. We can also compile a specific external
    dependency and nothing else.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个单一的Makefile，我们可以选择编译整个项目，或者只是依赖项或核心项目。我们还可以编译特定的外部依赖项，而不编译其他内容。
- en: Finally, we can clean the core project, the dependencies, or both.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以清理核心项目、依赖项或两者。
- en: 'This top Makefile is primarily for controlling the underlying Makefiles. The
    next two Makefiles are found in the `Core` and `extern` folders. Of these, the
    `Core` Makefile simply directly compiles the project''s core:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顶级Makefile主要用于控制底层Makefiles。接下来的两个Makefiles分别位于`Core`和`extern`文件夹中。其中，`Core`
    Makefile直接编译项目的核心部分：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As the first step, we include the Makefile configuration for the target platform
    so that we have access to all of its definitions. These could also have been exported
    in the main Makefile, but this way we're free to customize the build system even
    more.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们包含目标平台的Makefile配置，以便我们可以访问其所有定义。这些也可以在主Makefile中导出，但这样我们可以自由定制构建系统。
- en: 'We specify the name of the output binary that we''re building, before some
    small tasks, including opening the `version` file (with Makefile syntax) in the
    root of the project, which contains the version number of the source we''re building
    from. This is prepared to be passed as a preprocessor definition into the compiler:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定正在构建的输出二进制文件的名称，然后执行一些小任务，包括在项目根目录中使用Makefile语法打开`version`文件，其中包含我们正在构建的源代码的版本号。这准备作为预处理器定义传递给编译器：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is another section where we rely on having a Bash shell or something compatible
    around, as we use the date command in order to create a timestamp for the build.
    The format depends on what parameter was passed to the main Makefile. If we're
    building a release, we take the timestamp from the Git repository, with the Git
    commit tag name used to retrieve the commit timestamp for that tag before formatting
    it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个部分，我们依赖于有一个Bash shell或类似的东西，因为我们使用date命令来为构建创建时间戳。格式取决于传递给主Makefile的参数。如果我们正在构建一个发布版本，我们将从Git存储库中获取时间戳，使用Git提交标签名称来检索该标签的提交时间戳，然后进行格式化。
- en: If `GITTIME` is passed as parameter, the timestamp of the most recent Git commit
    is used. Otherwise, the current time and date is used (UTC).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了`GITTIME`作为参数，则使用最近的Git提交的时间戳。否则，使用当前的时间和日期（UTC）。
- en: 'This bit of code is intended to solve one of the issues that comes with having
    lots of test and integration builds: keeping track of which ones were built when
    and with which revision of the source code. It could be adapted to other file
    revision systems, as long as it supports similar functionality with the retrieving
    of specific timestamps.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码旨在解决测试和集成构建中出现的一个问题：跟踪构建的时间和源代码的修订版本。只要它支持检索特定时间戳的类似功能，它就可以适应其他文件修订系统。
- en: 'Of note is the second timestamp we''re creating. This is a slightly different
    formatted version of the timestamp that is affixed to the produced binary, except
    when we''re building in release mode:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是我们正在创建的第二个时间戳。这是一个稍微不同格式的时间戳，附加到生成的二进制文件上，除非我们是在发布模式下构建：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we set the flags we wish to pass to the compiler, including the version
    and timestamp, both being passed as preprocessor definitions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置希望传递给编译器的标志，包括版本和时间戳，两者都作为预处理器定义传递。
- en: 'Finally, the sources in the current project folder are collected and the output
    folder for the object files is set. As we can see here, we''ll be writing the
    object files to a folder underneath the project root, with further separation
    by the compile target:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们收集当前项目文件夹中的源文件，并设置对象文件的输出文件夹。正如我们在这里看到的，我们将把对象文件写入项目根目录下的一个文件夹中，并根据编译目标进行进一步分离。
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This part is fairly generic for a Makefile. We have the `all` target, along
    with one to make the folders on the filesystem, if they don''t exist yet. Finally,
    we take in the array of source files in the next target, compiling them as configured
    and outputting the object file in the appropriate folder:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分对于Makefile来说是相当通用的。我们有`all`目标，以及一个用于在文件系统上创建文件夹（如果尚不存在）的目标。最后，我们在下一个目标中接收源文件数组，根据配置编译它们，并将对象文件输出到适当的文件夹中：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After we have created all of the object files from our source files, we want
    to link them together, which happens in this step. We can also see where the binary
    will end up: in a `bin` sub-folder of the project''s build folder.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从源文件创建了所有的目标文件之后，我们希望将它们链接在一起，这就是这一步发生的地方。我们还可以看到二进制文件将会出现在哪里：在项目构建文件夹的`bin`子文件夹中。
- en: The linker is called, and we create a copy of the resulting binary, which we
    post-fix with `.debug` to indicate that it is the version with all of the debug
    information. The original binary is then stripped of its debug symbols and other
    unneeded information, leaving us with a small binary to copy to the remote test
    system and a larger version with all of the debug information for when we need
    to analyze core dumps or do remote debugging.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器被调用，我们创建了生成二进制文件的副本，我们用`.debug`后缀来表示它是带有所有调试信息的版本。然后，原始二进制文件被剥离其调试符号和其他不需要的信息，留下一个小的二进制文件复制到远程测试系统，以及一个带有所有调试信息的较大版本，以便在需要分析核心转储或进行远程调试时使用。
- en: 'What we also see here is a small hack that got added due to an unsupported
    command-line flag by Clang''s linker, requiring the implementation of a special
    case. While working on cross-platform compiling and similar tasks, one is likely
    to run into many of such small details, all of which complicate the writing of
    a universal build system that simply works:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的另一个特点是由于Clang的链接器不支持的命令行标志而添加的一个小技巧，需要实现一个特殊情况。在跨平台编译和类似任务中，人们很可能会遇到许多这样的小细节，所有这些都会使得编写一个简单工作的通用构建系统变得复杂。
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As a final step, we allow for the generated object files to be deleted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是允许删除生成的目标文件。
- en: 'The second sub-Makefile in `extern` is also of note, as it controls all of
    the underlying dependencies:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern`中的第二个子Makefile也值得注意，因为它控制所有底层依赖关系：'
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'An interesting feature here is the dependency selector based on the target
    platform. If we have dependencies that shouldn''t be compiled for a specific platform,
    we can skip them here. This feature also allows us to directly instruct this Makefile
    to compile all dependencies for a specific platform. Here, we allow for the targeting
    of QNX, Linux, OS X/macOS, and Windows, while ignoring the architecture:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个有趣特性是基于目标平台的依赖选择器。如果我们有不应该为特定平台编译的依赖关系，我们可以在这里跳过它们。这个特性还允许我们直接指示这个Makefile为特定平台编译所有依赖关系。在这里，我们允许针对QNX、Linux、OS
    X/macOS和Windows进行定位，同时忽略架构：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The actual targets merely call another Makefile at the top of the dependency
    project, which in turn compiles that dependency and adds it to the build folder,
    where it can be used by the `Core`'s Makefile.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的目标只是调用依赖项目顶部的另一个Makefile，然后编译该依赖项并将其添加到构建文件夹中，以便`Core`的Makefile使用。
- en: 'Of course, we can also directly compile the project from this Makefile using
    an existing build system, such as here for OpenSSL:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以直接使用现有的构建系统从这个Makefile编译项目，比如这里的OpenSSL：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code works through all of the usual steps of building OpenSSL by hand,
    before copying the resulting binaries to their target folders.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过手动完成构建OpenSSL的所有常规步骤，然后将生成的二进制文件复制到它们的目标文件夹。
- en: One issue with cross-platform build systems one may notice is that a common
    GNU tool such as Autoconf is extremely slow on OSes such as Windows, due to it
    launching many processes as it runs hundreds of tests. Even on Linux, this process
    can take a long time, which is very annoying and time consuming when running through
    the same build process multiple times a day.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能会注意到跨平台构建系统的一个问题是，像Autoconf这样的常见GNU工具在Windows等操作系统上非常慢，因为它在运行数百个测试时会启动许多进程。即使在Linux上，这个过程也可能需要很长时间，当一天中多次运行相同的构建过程时，这是非常令人恼火和耗时的。
- en: 'The ideal case is having a simple Makefile in which everything is predefined
    and in a known state so that no library discovery and such are needed. This was
    one of the motivations behind adding the POCO library source code to one project
    and having a simple Makefile compile it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况是有一个简单的Makefile，其中一切都是预定义的，并且处于已知状态，因此不需要库发现等。这是将POCO库源代码添加到一个项目并有一个简单的Makefile编译它的动机之一：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This Makefile then calls the individual Makefile for each module, as in this
    example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Makefile然后调用每个模块的单独Makefile，就像这个例子：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This Makefile compiles the entire `Net` module of the library. It's similar
    in structure to the one for compiling the project core source files. In addition
    to compiling the object files, it puts them into an archive so that we can link
    against it later, and copies this archive as well as the header files to their
    place in the build folder.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Makefile编译了整个库的`Net`模块。它的结构类似于用于编译项目核心源文件的结构。除了编译目标文件，它还将它们放入一个存档中，以便我们以后可以链接，并将这个存档以及头文件复制到它们在构建文件夹中的位置。
- en: The main reason for compiling the library for the project was to allow for specific
    optimizations and tweaks that wouldn't be available with a precompiled library.
    By having everything but the basics stripped out of the library's original build
    system, trying out different settings was made very easy and even worked on Windows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许特定的优化和调整，编译库的主要原因是这些优化和调整在预编译库中是不可用的。通过从库的原始构建系统中剥离除了基本内容之外的所有内容，尝试不同的设置变得非常容易，甚至在Windows上也可以工作。
- en: Remote testing on real hardware
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在真实硬件上进行远程测试
- en: After we have done all of the local testing of our code and are reasonably certain
    that it should work on the real hardware, we can use the cross-compile build system
    to create a binary that we can then run on the target system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成了所有代码的本地测试，并且相当确信它应该可以在真实硬件上运行之后，我们可以使用交叉编译构建系统来创建一个二进制文件，然后在目标系统上运行。
- en: At this point, we can simply copy the resulting binary and associated files
    to the target system and see whether it works. The more scientific way to do this
    is to use GDB. With the GDB server service installed on the target Linux system,
    we can connect to it with GDB from our PC, either via the network or a serial
    connection.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以简单地将生成的二进制文件和相关文件复制到目标系统上，看看它是否有效。更科学的方法是使用GDB。通过在目标Linux系统上安装GDB服务器服务，我们可以通过网络或串行连接从PC连接到它。
- en: 'For SBCs running a Debian-based Linux installation, the GDB server can be easily
    installed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行基于Debian的Linux安装的SBC，GDB服务器可以很容易地安装：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Although it is called `gdbserver`, its essential function is that of a remote
    stub implementation for the debugger, which runs on the host system. This makes
    `gdbserver` very lightweight and simple to implement for new targets.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它被称为`gdbserver`，但其基本功能是作为调试器的远程存根实现，在主机系统上运行。这使得`gdbserver`非常轻量级和简单，可以为新目标实现。
- en: 'After this, we want to make sure that `gdbserver` is running by logging in
    to the system and starting it in one of a variety of ways. We can do so for TPC
    connections over the network like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们要确保`gdbserver`正在运行，方法是登录到系统并以各种方式启动它。我们可以像这样为网络上的TPC连接这样做：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Or we can attach it to a running process:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以将其附加到正在运行的进程上：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `host` part of the first argument refers to the name (or IP address) of
    the host system that will be connecting. This parameter is currently ignored,
    meaning that it can also be left empty. The port section has to be a port that
    is not currently in use on the target system.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数的`主机`部分是将要连接的主机系统的名称（或IP地址）。当前该参数被忽略，这意味着它也可以留空。端口部分必须是目标系统上当前未使用的端口。
- en: 'Or we can use some kind of serial connection:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用某种串行连接：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The moment we launch `gdbserver`, it pauses the execution of the target application
    if it was already running, allowing us to connect with the debugger from the host
    system. While on the target system, we can run a binary that has been stripped
    of its debug symbols; these are required to be present in the binary that we use
    on the host side:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动`gdbserver`，它会暂停目标应用程序的执行（如果它已经在运行），从而允许我们从主机系统连接调试器。在目标系统上，我们可以运行一个已经剥离了其调试符号的二进制文件；这些符号需要在我们在主机端使用的二进制文件中存在：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At this point, debug symbols would be loaded from the binary, along with those
    from any dependencies (if available). Connecting over a serial connection would
    look similar, just with the address and port replaced with the serial interface
    path or name. The `baud` rate of the serial connection (if not the default 9,600
    baud) is specified as a parameter to GDB when we''re starting:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，调试符号将从二进制文件中加载，以及从任何依赖项中加载（如果可用）。通过串行连接进行连接看起来类似，只是地址和端口被串行接口路径或名称替换。当我们启动时，串行连接的`波特率`（如果不是默认的9600波特率）被指定为GDB的参数：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Once we have told GDB the details of the remote target, we should see the usual
    GDB command-line interface appear, allowing us to step through, analyze, and debug
    the program as if it was running locally on our system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们告诉GDB远程目标的详细信息，我们应该看到通常的GDB命令行界面出现，允许我们像在本地系统上运行一样步进，分析和调试程序。
- en: As mentioned earlier in this chapter, we're using `gdb-multiarch` as this version
    of the GDB debugger supports different architectures, which is useful since we'll
    likely be running the debugger on an x86_64 system, whereas the SBC is very likely
    ARM-based, but could also be MIPS or x86 (i686).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，我们使用`gdb-multiarch`，因为这个版本的GDB调试器支持不同的架构，这很有用，因为我们很可能会在x86_64系统上运行调试器，而SBC很可能是基于ARM，但也可能是MIPS或x86（i686）。
- en: 'In addition to running the application directly with `gdbserver`, we can also
    start `gdbserver` to just wait for a debugger to connect:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接使用`gdbserver`运行应用程序之外，我们还可以启动`gdbserver`等待调试器连接：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Or we can do this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以这样做：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We would then connect to this remote target like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会像这样连接到这个远程目标：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At this point, we should find ourselves at the GDB command-line interface again,
    with the program binary loaded on both target and host.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该再次发现自己处于GDB命令行界面上，目标和主机上都加载了程序二进制文件。
- en: A big advantage of this method is that `gdbserver` does not exit when the application
    that's being debugged exits. In addition, this mode allows us to debug different
    applications simultaneously on the same target, assuming that the target supports
    this.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个重要优势是`gdbserver`在被调试的应用程序退出时不会退出。此外，这种模式允许我们在同一个目标上同时调试不同的应用程序，假设目标支持这一点。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to develop and test embedded, OS-based applications.
    We learned how to install and use a cross-compilation toolchain, how to do remote
    debugging using GDB, and how to write a build system that allows us to compile
    for a wide variety of target systems with minimal effort required to add a new
    target.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何开发和测试嵌入式操作系统应用程序。我们学会了如何安装和使用交叉编译工具链，如何使用GDB进行远程调试，以及如何编写构建系统，使我们能够以最小的工作量为新目标系统进行编译。
- en: At this point, you are expected to be able to develop and debug an embedded
    application for a Linux-based SBC or similar, while being able to work in an efficient
    way.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该能够以高效的方式开发和调试基于Linux的SBC或类似系统的嵌入式应用程序。
- en: In the next chapter, we'll be looking at how to develop for and test applications
    for more constrained, MCU-based platforms.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何为更受限制的基于MCU的平台开发和测试应用程序。
