- en: Designing World-Ready Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计面向全球的应用程序
- en: Using a programming language in production-ready projects is a whole new step
    in learning the language itself. Sometimes, the simple examples in this book may
    take a different approach or face many difficulties in real-world programs. When
    theory meets practice is when you learn the language. C++ is not an exception.
    It's different to learn syntax, solve some book problems, or understand somewhat
    simple examples in books. When creating real-world applications, we face a different
    range of challenges, and sometimes books lack the theory to back the practical
    issues on the road.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产就绪项目中使用编程语言是学习语言本身的一个全新步骤。有时，这本书中的简单示例可能会在实际项目中采用不同的方法或面临许多困难。当理论遇到实践时，你才会学会这门语言。C++也不例外。学习语法、解决一些书中的问题或理解书中的一些简单示例是不同的。在创建真实世界的应用程序时，我们面临着不同范围的挑战，有时书籍缺乏支持实际问题的理论。
- en: In this chapter, we will try to cover the basics of practical programming with
    C++ that will help you to tackle real-world applications better. Complex projects
    require a lot of thinking and designing. Sometimes, programmers have to completely
    rewrite the project and start from scratch just because they have made bad design
    choices at the beginning of development. This chapter tries its best to illuminate
    the process of designing software. You will learn the steps to better architecture
    for your projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试涵盖使用C++进行实际编程的基础知识，这将帮助你更好地处理真实世界的应用程序。复杂的项目需要大量的思考和设计。有时，程序员不得不完全重写项目，并从头开始，只是因为他们在开发初期做出了糟糕的设计选择。本章试图尽最大努力阐明软件设计的过程。你将学习更好地为你的项目设计架构的步骤。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Understanding the project development life cycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解项目开发生命周期
- en: Design patterns and their applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式及其应用
- en: Domain-driven design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: Designing an Amazon clone as an example of a real-world project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以亚马逊克隆为例的真实项目设计
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler with the `-std=c++2a` option is used to compile the examples
    throughout this chapter. You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用`-std=c++2a`选项的g++编译器来编译示例。你可以在[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)找到本章中使用的源文件。
- en: Project development life cycle
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目开发生命周期
- en: Whenever you approach a problem, you should carefully consider the process of
    the requirements analysis. One of the biggest mistakes in project development
    is starting coding without a thorough analysis of the problem itself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你面对一个问题时，你应该仔细考虑需求分析的过程。项目开发中最大的错误之一是在没有对问题本身进行彻底分析的情况下开始编码。
- en: Imagine a situation where you are tasked with creating a calculator, a simple
    tool that allows users to make arithmetic calculations on numbers. Let's say you
    have magically completed the project on time and released the program. Now, users
    are starting to use your calculator and sooner or later they find out that the
    result of their calculations doesn't exceed the maximum size of an integer. When
    they complain about this issue, you are ready to defend yourself (and your creation)
    with solid coding-backed arguments such as it's because of using the `int` data
    type in calculations. It's totally understandable for you and your fellow programmers,
    but end users just can't take your arguments. They want a tool that allows summing
    some big enough numbers, otherwise, they won't use your program at all. You start
    working on the next version of your calculator and this time, you use longs or
    even custom implemented big numbers. You proudly ship your program to users waiting
    for their applause when you suddenly realize that the same users complain of not
    having the functionality to find logarithms or exponents of numbers. This seems
    daunting because there might be more and more feature requests and more and more
    complaints.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种情况，你被要求创建一个计算器，一个简单的工具，允许用户对数字进行算术计算。假设你神奇地按时完成了项目并发布了程序。现在，用户开始使用你的计算器，迟早会发现他们的计算结果不会超过整数的最大值。当他们抱怨这个问题时，你准备用坚实的编码支持论据来为自己（和你的作品）辩护，比如这是因为在计算中使用了`int`数据类型。对你和你的同行程序员来说，这是完全可以理解的，但最终用户却无法接受你的论点。他们想要一个可以对足够大的数字进行求和的工具，否则他们根本不会使用你的程序。你开始着手下一个版本的计算器，这一次，你使用长整型甚至自定义实现的大数。当你自豪地将程序交付给等待你掌声的用户时，你突然意识到同样的用户抱怨没有功能来找到数字的对数或指数。这似乎令人生畏，因为可能会有越来越多的功能请求和越来越多的抱怨。
- en: Though this example is somewhat simple, it totally covers what usually happens
    in the real world. Even when you implement all of the features for your program
    and are thinking about taking a long-deserved vacation, users will start complaining
    about the bugs in the program. It turns out that there are several cases when
    your calculator behaves unexpectedly and gives no or wrong results. Sooner or
    later, you realize that proper testing is what you actually need before releasing
    the program to the masses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子有点简单，但它完全覆盖了真实世界中通常发生的情况。即使你为你的程序实现了所有功能，并考虑着去度一个值得的长假，用户也会开始抱怨程序中的错误。事实证明，有几种情况下，你的计算器表现出乎意料的行为，给出了错误的结果。迟早，你会意识到在将程序发布给大众之前，需要进行适当的测试。
- en: 'We will touch on the subjects that should be considered when working on real-world
    projects. Whenever you are starting a new project, the following steps should
    be taken into account:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涉及在处理真实世界项目时应考虑的主题。每当你开始一个新项目时，应考虑以下步骤：
- en: Requirements gathering and analysis
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需求收集和分析
- en: Specification creation
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规格书创建
- en: Design and test planning
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计和测试规划
- en: Coding
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码
- en: Testing and stabilization
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试和稳定性
- en: Release and maintenance
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布和维护
- en: The preceding steps are not hardcoded for every project, though it might be
    considered as the bare minimum that every software development team should complete
    to achieve a successful product release. In reality, most of the steps are omitted
    due to the single thing everyone in the IT field lacks the most— time. However,
    it is strongly recommended to follow the preceding steps because, eventually,
    it will save more time in the long- term.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤并非对每个项目都是硬性规定，尽管它可能被认为是每个软件开发团队应该完成以实现成功产品发布的最低要求。实际上，由于IT领域的每个人最缺乏的是时间，大多数步骤都被省略了。但是，强烈建议遵循前面的步骤，因为最终它将在长期节省更多时间。
- en: Requirements gathering and analysis
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求收集和分析
- en: This is the most crucial step in creating a stable product. One of the most
    popular reasons that programmers fail to complete their tasks on time or leave
    a lot of bugs in code is the lack of a complete understanding of the project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建稳定产品的最关键步骤。程序员未能按时完成任务或在代码中留下许多错误的最常见原因之一是对项目的完全理解不足。
- en: The domain knowledge is so important that it shouldn't be omitted in any circumstance.
    You might be lucky to develop projects that are related to something you know
    very well. However, you should take into account that not everyone is as lucky
    as you (well, you might be that unlucky, too).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 领域知识是如此重要，以至于在任何情况下都不应该被忽略。您可能很幸运地开发与您非常了解的内容相关的项目。但是，您应该考虑到并非每个人都像您一样幸运（嗯，您也可能是那么不幸）。
- en: Imagine that you are working on a project that automates the analysis and reporting
    of the stock trading in some company. Now imagine that you know nothing about
    stocks and the stock trading at all. You don't know about the bear or bull markets,
    the limitations in trading transactions, and so on. How would you complete the
    project successfully?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在开发一个自动化分析和报告某家公司股票交易的项目。现在想象一下，您对股票和股票交易一无所知。您不了解熊市或牛市，交易交易的限制等等。您如何才能成功完成这个项目？
- en: Even if you know about the stock markets and trading, you might be unaware of
    your next big project domain. What if you are tasked with designing and implementing
    (with or without a team) a project that controls the weather stations of your
    city? What you are going to do first when starting the project?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您了解股票市场和交易，您可能不了解下一个重大项目领域。如果您被要求设计和实施（有或没有团队）控制您所在城市气象站的项目，您在开始项目时会首先做什么？
- en: You should definitely start with requirements gathering and analysis. It's just
    a process that involves communicating with the client and asking a lot of questions
    about the project. If you are not dealing with any client but work in a product
    company, the project manager should be treated as the client. Even if the project
    is your idea and you are working alone, you should treat yourself as the client
    and, though it might sound ridiculous, ask yourself a lot of questions (about
    the project).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您绝对应该从需求收集和分析开始。这只是一个涉及与客户沟通并就项目提出许多问题的过程。如果您没有与任何客户打交道，而是在一家产品公司工作，项目经理应被视为客户。即使项目是您的想法，您是独自工作，您也应该将自己视为客户，并且，尽管这听起来很荒谬，但要问自己很多问题（关于项目）。
- en: Let's suppose we are going to conquer e-commerce and want to release a product
    that will eventually beat the market sharks in their own business. Popular and
    successful e-commerce marketplaces are Amazon, eBay, Alibaba, and some others.
    We should state the problem as *writing our own Amazon clone*. What should we
    do to gather the requirements for the project?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要征服电子商务，并希望发布一个最终能够击败市场上的大鳄的产品。受欢迎和成功的电子商务市场包括亚马逊，eBay，阿里巴巴等。我们应该将问题陈述为“编写我们自己的亚马逊克隆”。我们应该如何收集项目的需求？
- en: 'First of all, we should list all of the features that we should implement and
    then we''ll prioritize. For example, for the Amazon clone project, we might come
    up with the following list of features:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该列出所有我们应该实现的功能，然后我们会进行优先排序。例如，对于亚马逊克隆项目，我们可能会列出以下功能清单：
- en: Create a product.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建产品。
- en: List products.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出产品。
- en: Buy a product.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买产品。
- en: Edit product details.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑产品细节。
- en: Remove a product.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除产品。
- en: Search for products by name, price range, and weight.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按名称，价格范围和重量搜索产品。
- en: Alert the user on product availability once in a while via email.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶尔通过电子邮件提醒用户产品的可用性。
- en: Features should be described in detail as much as possible; that will sort things
    out for the developer (you, in this case). For example, creating a product should
    be done either by the project administrator or any user. If a user can create
    a product, it should have limitations, if any. There might be cases that a user
    will mistakenly create hundreds of products in our system to increase the visibility
    of their only product.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 功能应尽可能详细地描述；这将为开发人员（在这种情况下是您）解决问题。例如，创建产品应该由项目管理员或任何用户完成。如果用户可以创建产品，那么可能会有限制。可能会有用户错误地在我们的系统中创建数百个产品，以增加他们唯一产品的可见性。
- en: Details should be stated, discussed, and finalized during communications with
    the client. If you are alone in the project and you are the client of your project,
    the communication is the process of *thinking for yourself* on the project requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息应在与客户的沟通中说明，讨论和最终确定。如果您独自承担项目并且是项目的客户，则沟通是在项目需求上“为自己思考”的过程。
- en: 'When finished getting requirements, we suggest prioritizing each feature and
    classifying them into one of the following categories:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取需求完成后，我们建议对每个功能进行优先排序，并将它们分类为以下类别之一：
- en: Must have
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有
- en: Should have
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有
- en: Nice to have
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好有
- en: 'After thinking a little bit more and categorizing the preceding features, we
    could come up with the following list:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 经过更多思考并对前述功能进行分类后，我们可以列出以下清单：
- en: Create a product [must have].
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建产品[必须有]。
- en: List products [must have].
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出产品[必须有]。
- en: Buy a product [must have].
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买产品[必须有]。
- en: Edit product details [should have].
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑产品细节[应该有]。
- en: Remove a product [must have].
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除产品[必须有]。
- en: Search for products by name [must have].
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按名称搜索产品[必须有]。
- en: Search for products by price range [should have].
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按价格范围搜索产品[应该有]。
- en: Search for products by weight [nice to have].
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按重量搜索产品[很好有]。
- en: Alert the user on product availability once in a while via email [nice to have].
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶尔通过电子邮件提醒用户产品的可用性[很好有]。
- en: The classification will give you a basic idea of where to start first. Programmers
    are greedy people; they want to implement every possible feature out there for
    their products. It's a sure way toward failure. You should start from the most
    essential features first—that's why we have a couple of nice-to-have features.
    Some jokingly insist that nice-to-have features should be renamed to never-have
    features because, in practice, they never get implemented.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 分类将为您提供一个从哪里开始的基本想法。程序员是贪婪的人；他们想要为他们的产品实现每一个可能的功能。这是通向失败的确定途径。你应该从最基本的功能开始——这就是为什么我们有一些很好的功能。有些人开玩笑地坚持认为，应该将很好的功能重新命名为永远不会有的功能，因为在实践中，它们永远不会被实现。
- en: Specification creation
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规格创建
- en: Not everyone likes creating specifications. Well, most programmers hate this
    step because it's not coding—it's writing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是每个人都喜欢创建规格。嗯，大多数程序员讨厌这一步，因为这不是编码，而是写作。
- en: After gathering project requirements, you should create a document that includes
    every detail that describes your project. There are many names and types for this
    specification. It might be called a **Project Requirements Document** (**PRD**),
    a** functional specification**, a** development specification**, and so on. Serious
    programmers and serious teams produce a PRD as a result of the requirements analysis.
    The next step of these serious guys is creating the functional specification along
    with the development specification and so on. We combine all of the documentation
    in a single step named **specification creation. **
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集项目需求之后，你应该创建一个包含描述你的项目的每个细节的文档。这种规格有许多名称和类型。它可能被称为**项目需求文档**（**PRD**），**功能规格**，**开发规格**等等。认真的程序员和团队会在需求分析的结果中产生一个PRD。这些认真的人的下一步是创建功能规格以及开发规格等等。我们将所有文档组合在一个名为**规格创建**的单一步骤中。
- en: It's up to you and your team to decide whether you need any of the sub-documents
    mentioned previously. It is even better to have a visual representation of the
    product rather than a text document. Whatever the form your document takes, it
    should carefully represent what you've achieved in the requirements gathering
    step. To have a basic understanding of this, let's try to document some of the
    features that we've collected earlier (we will refer to our project as *the platform)*
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是否需要之前提到的任何子文档，这取决于你和你的团队。甚至最好有一个产品的视觉表示，而不是一个文本文档。无论你的文档采取什么形式，它都应该仔细地代表你在需求收集步骤中所取得的成就。为了对此有一个基本的理解，让我们试着记录一些我们之前收集到的功能（我们将把我们的项目称为*平台）*
- en: Create a product. A user of the platform having administrator privileges can
    create a product.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建产品。平台的用户具有管理员特权可以创建产品。
- en: The platform must allow creating users with defined privileges. At this point,
    there should be two types of users, namely regular and administrator users.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台必须允许创建具有定义特权的用户。在这一点上，应该有两种类型的用户，即普通用户和管理员用户。
- en: Any user using the platform must be able to see the list of available products.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台的任何用户都必须能够看到可用产品的列表。
- en: A product should have images, a price, name, weight, and description.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品应该有图片、价格、名称、重量和描述。
- en: To buy a product, the user provides their card details to cash out and details
    for the product shipment.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买产品时，用户提供他们的卡片详细信息以结账和产品装运的详细信息。
- en: Each registered user should provide a delivery address, credit card details,
    and an email account.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个注册用户都应该提供一个送货地址、信用卡详细信息和一个电子邮件账户。
- en: The list might go long and it actually should go long because the longer the
    list, the more the developers understand the project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可能会很长，实际上应该很长，因为列表越长，开发人员就越了解项目。
- en: Design and test planning
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和测试规划
- en: Though we insisted on the requirement gathering step as the most crucial in
    software development, the designing and test planning can be considered an equally
    crucial step as well. If you have ever started a project without designing it
    first, you already have the idea of its impossibility. Though motivational quotes
    insist that nothing is impossible, programmers are sure that at least one thing
    is impossible and that is finishing a project successfully without designing it
    first.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们坚持认为需求收集步骤是软件开发中最关键的一步，但设计和测试规划也可以被认为是同样关键的一步。如果你曾经在没有先设计项目的情况下开始一个项目，你已经知道它是不可能的。尽管激励性的语录坚持认为没有什么是不可能的，程序员确信至少有一件事是不可能的，那就是在没有先设计项目的情况下成功完成一个项目。
- en: 'The process of designing is the most interesting step; it forces us to think,
    draw, think again, clear everything, and start over. Many features of the project
    are discovered while designing it. To design a project, you should start from
    the top. First of all, list all of the entities and processes that are somehow
    involved in the project. For the Amazon clone example, we can list the following
    entities and processes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 设计的过程是最有趣的一步；它迫使我们思考、绘画、再次思考、清理一切，然后重新开始。在设计项目时，你应该从顶部开始。首先，列出所有在项目中以某种方式涉及的实体和过程。以亚马逊克隆为例，我们可以列出以下实体和过程：
- en: Users
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: Registration and authorization
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册和授权
- en: Products
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Transactions
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易
- en: Warehouses (containing products)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库（包含产品）
- en: Shipment
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装运
- en: This is a high-level design—a starting point to move through the final design.
    In this chapter, we will mostly concentrate on the design of the project.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高层设计——一个通过最终设计的起点。在这一章中，我们将主要集中在项目的设计上。
- en: Decomposing entities
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解实体
- en: 'After listing key entities and processes, we move to decompose them into more
    detailed entities that will be transformed into classes later. It''s even better
    to sketch the design of the project. Just draw rectangles containing names of
    entities and connect them with arrows if they are somehow connected together or
    are parts of the same process. You can start an arrow from entity A to entity
    B if there is a process that includes or is started by the entity A and is finished
    at or results in entity B. It doesn''t matter how good the drawing is, it''s a
    necessary step toward a better understanding of the project. For example, look
    at the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出关键实体和流程之后，我们开始将它们分解为更详细的实体，稍后将转换为类。最好还是勾画一下项目的设计。只需绘制包含实体名称的矩形，并用箭头连接它们，如果它们有某种联系或是同一流程的一部分。如果有一个包含或由实体A开始的流程，并在实体B结束或导致实体B，你可以从实体A开始一个箭头指向实体B。图画得多好并不重要，这是更好地理解项目的必要步骤。例如，看看下面的图表：
- en: '![](img/747174ee-fe32-4e39-930e-9add32033617.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/747174ee-fe32-4e39-930e-9add32033617.png)'
- en: 'Decomposing entities and processes into classes and their intercommunication
    is a subtle art requiring patience and consistency. For example, let''s try to
    add details for the **User** entity. As stated in the specification creation step,
    a registered user should provide a delivery address, an email address, and credit
    card details. Let''s draw a class diagram that represents a user:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将实体和流程分解为类及其相互通信是一种需要耐心和一致性的微妙艺术。例如，让我们尝试为**User**实体添加细节。根据规范创建步骤中所述，注册用户应提供交货地址、电子邮件地址和信用卡详细信息。让我们绘制一个代表用户的类图：
- en: '![](img/62615d23-0f68-42b3-914a-380356d7ba16.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62615d23-0f68-42b3-914a-380356d7ba16.png)'
- en: 'And here comes the interesting question: what should we do with complex types
    contained within the entity? For example, the delivery address of a user is a
    complex type. It couldn''t be just `string`, because sooner or later we might
    need to sort users by their delivery addresses to make optimal shipments. For
    example, a shipment company might cost us (or the user) a fortune if the delivery
    address of the user is in a different country than the address of the warehouse
    that contains the purchased product. This is a great scenario because it introduces
    a new problem and updates our understanding of the project. It turns out that
    we should handle situations when a user orders a product that is assigned to a
    specific warehouse physically located far from the user. If we have many warehouses,
    we should choose the nearest one to the user that contains the required product.
    These are questions that couldn''t be answered right away, but that is the quality
    result of designing the project. Otherwise, these questions would have risen during
    the coding and we would have been stuck at them longer than we thought we would.
    The initial estimation of the project wouldn''t meet its completion date in any
    known universe.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出现了一个有趣的问题：我们应该如何处理实体内包含的复杂类型？例如，用户的交货地址是一个复杂类型。它不能只是`string`，因为迟早我们可能需要按照用户的交货地址对用户进行排序，以进行最佳的发货。例如，如果用户的交货地址与包含所购产品的仓库的地址不在同一个国家，那么货运公司可能会花费我们（或用户）一大笔钱。这是一个很好的场景，因为它引入了一个新问题，并更新了我们对项目的理解。原来我们应该处理的情况是，当用户订购的产品分配给一个距离用户物理位置很远的特定仓库时。如果我们有很多仓库，我们应该选择离用户最近的一个，其中包含所需的产品。这些问题不能立即得到答案，但这是设计项目的高质量结果。否则，这些问题将在编码过程中出现，并且我们会陷入其中比我们预想的时间更长的困境中。在任何已知的宇宙中，项目的初始估计都无法满足其完成日期。
- en: 'Now, how would you store the user address in the `User` class? A simple `std::string`
    would be fine as shown in the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在`User`类中存储用户地址呢？如下例所示，简单的`std::string`就可以：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An address is a complex object in terms of its components. An address might
    consist of the country name, country code, city name, and street name, and it
    might even contain latitude and longitude. The latter is great if you need to
    find the nearest warehouse to the user. It''s totally fine to make more types
    that would make the design more intuitive for programmers. For example, the following
    struct might be a good fit to express the address of a user:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 地址在其组成部分方面是一个复杂的对象。地址可能包括国家名称、国家代码、城市名称和街道名称，甚至可能包含纬度和经度。如果需要找到用户最近的仓库，后者就非常有用。为程序员创建更多类型以使设计更直观也是完全可以的。例如，以下结构可能非常适合表示用户的地址：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, storing a user address becomes even simpler:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，存储用户地址变得更加简单：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will get back to this example later in this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会在本章回到这个例子。
- en: The process of designing the project might require to go back a couple of steps
    to restate project requirements. After clarifying the design step with the previous
    steps, we can move forward to decompose the project into smaller components. It's
    better to create interaction diagrams, too.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 设计项目的过程可能需要回到几个步骤来重新阐明项目需求。在澄清设计步骤之后，我们可以继续将项目分解为更小的组件。创建交互图也是一个不错的选择。
- en: 'An interaction diagram like the following would depict operations such as a
    transaction made by a **user** to **purchase** a product:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 像下面这样的交互图将描述一些操作，比如**用户**进行**购买**产品的交易：
- en: '![](img/0fc423b9-d3fb-4643-abb0-aadd1f55632b.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fc423b9-d3fb-4643-abb0-aadd1f55632b.png)'
- en: Test planning can also be considered as part of the design. It includes planning
    how the final application will be tested. For example, the steps before this include
    a concept for an address and as it turned out, the address can contain a country,
    city, and so on. A proper test should include checking whether a value for the
    country can be set successfully in the user address. Though test planning is not
    considered a programmer task in general, it is still a good practice to do it
    for your projects. A proper test plan would produce more useful information while
    designing the project. Most of the input data processing and security checks are
    discovered at test planning. For instance, setting a strict limit on the user
    name or email address might not be the case when doing a requirement analysis
    or writing a functional specification. Test planning cares for such scenarios
    and forces developers to take care of data checks. However, most programmers are
    impatient to reach the next step of project development, coding.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 测试规划也可以被视为设计的一部分。它包括规划最终应用程序将如何进行测试。例如，之前的步骤包括一个地址的概念，结果发现，地址可以包含国家、城市等。一个合适的测试应该包括检查用户地址中的国家值是否可以成功设置。尽管测试规划通常不被认为是程序员的任务，但为您的项目做测试规划仍然是一种良好的实践。一个合适的测试计划会在设计项目时产生更多有用的信息。大多数输入数据处理和安全检查都是在测试规划中发现的。例如，在进行需求分析或编写功能规范时，可能不会考虑对用户名称或电子邮件地址设置严格限制。测试规划关心这样的情况，并迫使开发人员注意数据检查。然而，大多数程序员都急于达到项目开发的下一步，编码。
- en: Coding
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码
- en: As already said earlier, coding is not the only part of project development.
    Before coding, you should carefully design your project by leveraging all of the
    requirements projected in the specification. Coding is a lot easier and more productive
    after the previous steps of project development are completed thoroughly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所说，编码并不是项目开发的唯一部分。在编码之前，您应该通过利用规范中的所有需求来仔细设计您的项目。在项目开发的前几步彻底完成后，编码会变得更加容易和高效。
- en: Some teams practice **Test-Driven Development (TDD)**, which is a great way
    to produce even more stable project releases. The main concept of TDD is to write
    tests before the project implementation. It's a good way for programmers to define
    project requirements and answer further questions rising during the development.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队实践**测试驱动开发（TDD）**，这是生产更加稳定的项目发布的好方法。TDD的主要概念是在项目实现之前编写测试。这对程序员来说是定义项目需求和在开发过程中出现的进一步问题的一个很好的方法。
- en: 'Let''s suppose we are implementing setters for the `User` class. The user object
    contains an email field discussed earlier, which means that we should have a `set_email()` method, as
    shown in the following snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在为`User`类实现setter。用户对象包含了之前讨论过的email字段，这意味着我们应该有一个`set_email()`方法，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The TDD approach suggests writing a test function for the `set_email()` method
    before implementing the `set_email()` method itself. Let''s say we have the following
    test function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: TDD方法建议在实现`set_email()`方法之前编写一个测试函数。假设我们有以下测试函数：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we've declared two `string` variables, one of them containing
    an invalid value for an email address. Even before running the test function,
    we know that, in the case of invalid data input, the `set_email()` method should
    react somehow. One of the common approaches is throwing an exception indicating
    the invalid input. You could also ignore the invalid input in the `set_email`
    implementation and return a `boolean` value indicating the success of the operation.
    The error handling should be consistent in the project and agreed by all team
    members. Let's consider that we are going with throwing an exception, therefore,
    the test function should expect an exception when passing an invalid value to
    the method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们声明了两个`string`变量，其中一个包含了一个无效的电子邮件地址值。甚至在运行测试函数之前，我们就知道，在无效数据输入的情况下，`set_email()`方法应该以某种方式做出反应。常见的方法之一是抛出一个指示无效输入的异常。您也可以在`set_email`的实现中忽略无效输入，并返回一个指示操作成功的`boolean`值。错误处理应该在项目中保持一致，并得到所有团队成员的认可。假设我们选择抛出异常，因此，测试函数应该在将无效值传递给方法时期望一个异常。
- en: 'The preceding code is then should be rewritten as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，上述代码应该被重写如下：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The test function seems complete. Whenever we run the test function, it outputs
    the current state of the `set_email()` method. Even if we haven't yet implemented
    the `set_email()` function, the corresponding test function is a big step toward
    its implementation details. We now have the basic idea of how should the function
    react to valid and invalid data inputs. We can add more kinds of data to make
    sure the `set_email()` method will be thoroughly tested when its implementation
    is complete. For example, we can test it with empty and long strings.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数看起来已经完成。每当我们运行测试函数时，它会输出`set_email()`方法的当前状态。即使我们还没有实现`set_email()`函数，相应的测试函数也是实现细节的重要一步。我们现在基本上知道了这个函数应该如何对有效和无效的数据输入做出反应。我们可以添加更多种类的数据来确保`set_email()`方法在实现完成时得到充分测试。例如，我们可以用空字符串和长字符串来测试它。
- en: 'Here''s an initial implementation of the `set_email()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`set_email()`方法的初始实现：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the initial implementation of the method, we should run our test function
    again to make sure that the implementation conforms with the defined test cases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的初始实现之后，我们应该再次运行我们的测试函数，以确保实现符合定义的测试用例。
- en: Writing tests for your project is considered as a good coding practice. There
    are different types of tests, such as unit tests, regression tests, smoke tests, and
    so on. Developers should support unit test coverage for their projects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目编写测试被认为是一种良好的编码实践。有不同类型的测试，如单元测试、回归测试、冒烟测试等。开发人员应该为他们的项目支持单元测试覆盖率。
- en: The process of coding is one of the steps in the project development life cycle
    that is the most chaotic. It's hard to estimate how long will the implementation
    of a class or its methods will take because most of the questions and difficulties
    arise during coding. The previous steps of the project development life cycle
    described at the beginning of this chapter tend to cover most of these questions
    and ease the process of coding.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 编码过程是项目开发生命周期中最混乱的步骤之一。很难估计一个类或其方法的实现需要多长时间，因为大部分问题和困难都是在编码过程中出现的。本章开头描述的项目开发生命周期的前几个步骤往往涵盖了大部分这些问题，并简化了编码过程。
- en: Testing and stabilization
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和稳定
- en: After the project is done, it should be properly tested. Usually, software development
    companies have **Quality Assurance** (**QA**) engineers who meticulously test
    the project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 项目完成后，应进行适当的测试。通常，软件开发公司会有**质量保证**（**QA**）工程师，他们会细致地测试项目。
- en: Issues verified during the testing phase are converted into corresponding tasks
    assigned to programmers to fix them. Issues might affect the release of the project
    or might be classified as minor issues.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试阶段验证的问题会转化为相应的任务分配给程序员来修复。问题可能会影响项目的发布，也可能被归类为次要问题。
- en: 'The basic task of the programmer is not fixing the issue right away, but finding
    the root cause of the issue. For the sake of simplicity, let''s take a look at
    the `generate_username()` function that uses random numbers combined with the
    email to generate a username:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员的基本任务不是立即修复问题，而是找到问题的根本原因。为了简单起见，让我们看一下`generate_username()`函数，它使用随机数与电子邮件结合生成用户名：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `generate_username()` function calls `get_random_number()` to combine the
    returned value with the local part of the email address. The local part is the
    part before the `@` symbol in the email address.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_username()`函数调用`get_random_number()`将返回的值与电子邮件地址的本地部分组合在一起。本地部分是电子邮件地址中`@`符号之前的部分。'
- en: QA engineers reported that the number attached to the local part of the email
    is always the same. For example, for the email `john@gmail.com`, the generated
    username is `john42`, and for `amanda@yahoo.com`, it's `amanda42`. So, the next
    time a user with the email `amanda@hotmail.com` tries to register in the system,
    the generated username, `amanda42`, conflicts with the already existing one. It's
    totally fine for testers not to be aware of the implementation details of the
    project, so they report it as an issue in the username generation functionality.
    While you might already guess that the real issue is hidden in the `get_random_number()`
    function, there can always be scenarios where the issue is fixed without finding
    its root cause. The wrong approach fixing the issue could mutate the implementation
    of the `generate_username()` function. The `generate_random_number()` function
    might be used in other functions as well, which in turn, will make all of the
    functions that call `get_random_number()` work incorrectly. Though the example
    is simple, it is crucial to think deeper and find the real reason behind the issue.
    That approach will save a lot of time in the future.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: QA工程师报告说，与电子邮件的本地部分相关联的数字总是相同的。例如，对于电子邮件`john@gmail.com`，生成的用户名是`john42`，对于`amanda@yahoo.com`，是`amanda42`。因此，下次使用电子邮件`amanda@hotmail.com`尝试在系统中注册时，生成的用户名`amanda42`与已存在的用户名冲突。测试人员不了解项目的实现细节是完全可以的，因此他们将其报告为用户名生成功能中的问题。虽然你可能已经猜到真正的问题隐藏在`get_random_number()`函数中，但总会有情况出现，问题被修复而没有找到其根本原因。错误的方法修复问题可能会改变`generate_username()`函数的实现。`generate_random_number()`函数也可能在其他函数中使用，这将使调用`get_random_number()`的所有函数工作不正确。虽然这个例子很简单，但深入思考并找到问题的真正原因至关重要。这种方法将节省大量时间。
- en: Release and maintenance
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布和维护
- en: After making the project somewhat stable by fixing all of the critical and major
    issues, it can be released. Sometimes companies release software under the **beta**
    label, hence providing an excuse in case users find it buggy. It's important to
    note that there are rare cases of software that works flawlessly. After releasing
    it, more issues will arise. So, there comes the maintenance phase, when developers
    are working on fixes and release updates.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复所有关键和重大问题使项目变得相对稳定之后，可以发布项目。有时公司会在软件上加上**beta**标签，以防用户发现有bug时有借口。需要注意的是，很少有软件能够完美无缺地运行。发布后，会出现更多问题。因此，维护阶段就会到来，开发人员会在修复和发布更新时工作。
- en: Programmers sometimes joke that release and maintenance are steps that are never
    achieved. However, if you spend enough time designing the project, releasing its
    first version won't take much time. As we have already introduced in the previous
    section, designing starts with requirements gathering. After that, we spend time
    on defining entities, decomposing them, breaking down into smaller components,
    coding, testing, and finally, releasing it. As developers, we are more interested
    in the designing and coding phases. As already noted, a good design choice has
    a great impact on further project development. Let's now have a closer look at
    the design process overall.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员有时开玩笑说，发布和维护是永远无法实现的步骤。然而，如果你花足够的时间设计项目，发布第一个版本就不会花费太多时间。正如我们在前一节中已经介绍的，设计从需求收集开始。之后，我们花时间定义实体，分解它们，将其分解为更小的组件，编码，测试，最后发布。作为开发人员，我们对设计和编码阶段更感兴趣。正如已经指出的，良好的设计选择对进一步的项目开发有很大的影响。现在让我们更仔细地看一下整个设计过程。
- en: Diving into the design process
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入设计过程
- en: 'As introduced earlier, the project design starts with listing general entities,
    such as users, products, and warehouses when designing an e-commerce platform:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，项目设计始于列出一般实体，如用户、产品和仓库，当设计电子商务平台时：
- en: '![](img/b8991f30-493e-4e8f-84d7-02f1b58ed92e.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8991f30-493e-4e8f-84d7-02f1b58ed92e.png)'
- en: 'We then decompose each entity into smaller components. To make things clearer,
    consider each entity as a separate class. When thinking of an entity as a class,
    it makes more sense in terms of decomposition. For example, we express the `user`
    entity as a class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将每个实体分解为更小的组件。为了使事情更清晰，将每个实体视为一个单独的类。将实体视为类时，在分解方面更有意义。例如，我们将`user`实体表示为一个类：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The class diagram for the `User` class is the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类的类图如下：'
- en: '![](img/bd7b14fe-6cee-47bd-be57-e54cd658200b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd7b14fe-6cee-47bd-be57-e54cd658200b.png)'
- en: 'However, as we''ve already discussed, the address field of the `User` class
    might be represented as a separate type (`class` or `struct`, it doesn''t matter
    much yet). Whether it''s a data aggregate or a complex type, the class diagram
    takes the following changes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们已经讨论过的那样，`User`类的地址字段可能被表示为一个单独的类型（`class`或`struct`，目前并不重要）。无论是数据聚合还是复杂类型，类图都会发生以下变化：
- en: '![](img/a62f3623-ed77-4cca-9d29-fffe8c9a0bfc.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a62f3623-ed77-4cca-9d29-fffe8c9a0bfc.png)'
- en: The relations between these entities will become clear during the design process.
    For example, the **Address** isn't an entity on its own, it's a part of the **User**,
    that is, it couldn't have an instance if a **User** object isn't instantiated.
    However, as we might want to gesture toward reusable code, the **Address** type
    might be used for warehouse objects as well. That is, the relation between the
    **User** and **Address** is a simple aggregation rather than a composition.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实体之间的关系将在设计过程中变得清晰。例如，**Address**不是一个独立的实体，它是**User**的一部分，也就是说，如果没有实例化**User**对象，它就不能有一个实例。然而，由于我们可能希望指向可重用的代码，**Address**类型也可以用于仓库对象。也就是说，**User**和**Address**之间的关系是简单的聚合而不是组合。
- en: 'Moving forward, we could come up with more requirements for the **User** type
    when discussing the payment options. Users of the platform should be able to insert
    an option for paying for products. Before deciding on how will we represent payment
    options in the `User` class, we should find out what those options are, after
    all. Let''s keep it simple and suppose that a payment option is one that contains
    a credit card number, the name of the cardholder, the expiration date, and the
    security code of the card. It sounds like another data aggregation, so let''s
    collect all of that in a single struct, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论支付选项时，我们可能会对**User**类型提出更多要求。平台的用户应该能够插入支付产品的选项。在决定如何在`User`类中表示支付选项之前，我们应该首先找出这些选项是什么。让我们保持简单，假设支付选项是包含信用卡号、持卡人姓名、到期日和卡的安全码的选项。这听起来像另一个数据聚合，所以让我们将所有这些内容收集到一个单独的结构体中，如下所示：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note `std::chrono::year_month` in the preceding struct; it represents a specific
    month of a specific year and is introduced in C++20\. Most payment cards carry
    only the month and year of the card expiration, so this `std::chrono::year_month` function
    is perfect for `PaymentOption`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面结构体中的`std::chrono::year_month`；它表示特定年份的特定月份，是在C++20中引入的。大多数支付卡只包含卡的到期月份和年份，因此这个`std::chrono::year_month`函数非常适合`PaymentOption`。
- en: 'So, in the process of designing the `User` class, we came up with a new type,
    `PaymentOption`. A user can have more than one payment option, so the relation
    between `User` and `PaymentOption` is one-to-many. Let''s now update our `User`
    class diagram with this new aggregation (though we go with composition in this
    case):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在设计`User`类的过程中，我们提出了一个新类型`PaymentOption`。用户可以拥有多个支付选项，因此`User`和`PaymentOption`之间的关系是一对多的。现在让我们用这个新的聚合更新`User`类的类图（尽管在这种情况下我们使用组合）：
- en: '![](img/c85c2d3a-0d3f-4143-8879-b5cf71ef29dd.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c85c2d3a-0d3f-4143-8879-b5cf71ef29dd.png)'
- en: 'The dependency between `User` and `PaymentOption` is represented in the following
    code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`和`PaymentOption`之间的依赖关系在以下代码中表示：'
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We should note that even though a user might have more than one payment option
    set up, we should mark one of them as primary. That's tricky because we could
    store all of the options in a vector, but now we have to make one of them the
    primary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，即使用户可能设置了多个支付选项，我们也应该将其中一个标记为主要选项。这很棘手，因为我们可以将所有选项存储在一个向量中，但现在我们必须将其中一个设为主要选项。
- en: 'We can use a pair or `tuple` (if being fancy) to map an option in the vector
    with a `boolean` value, indicating whether it''s primary or not. The following
    code depicts the usage of a tuple in the `User` class introduced earlier:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一对或`tuple`（如果想要花哨一点）将向量中的选项与`boolean`值进行映射，指示它是否是主要选项。以下代码描述了之前引入的`User`类中元组的使用：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can simplify the code by leveraging type aliases in the following way:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式利用类型别名简化代码：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s how the class user can retrieve the primary payment option for a user:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用户类如何检索用户的主要支付选项的方法：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We used structured binding when accessing the tuple items in the `for` loop.
    However, after studying the chapter about data structures and algorithms, you
    are now aware that searching the primary payment option is a linear operation.
    It might be considered a bad practice to loop through the vector each time we
    need to retrieve the primary payment option.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中访问元组项时，我们使用了结构化绑定。然而，在学习了关于数据结构和算法的章节之后，您现在意识到搜索主要支付选项是一个线性操作。每次需要检索主要支付选项时循环遍历向量可能被认为是一种不好的做法。
- en: You might change the underlying data structure to make things run faster. For
    example, `std::unordered_map` (that is, a hash table) sounds better. However,
    it doesn't make things faster just because it has constant-time access to its
    elements. In this scenario, we should map a `boolean` value to the payment option.
    For all of the options except one, the `boolean` value is the same falsy value.
    It will lead to collisions in the hash table, which will be handled by chaining
    values together mapped to the same hash value. The only benefit of using a hash
    table will be constant-time access to the primary payment option.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会更改底层数据结构以使事情运行更快。例如，`std::unordered_map`（即哈希表）听起来更好。但是，这并不会使事情变得更快，仅仅因为它可以在常数时间内访问其元素。在这种情况下，我们应该将`boolean`值映射到支付选项。对于除一个之外的所有选项，`boolean`值都是相同的假值。这将导致哈希表中的冲突，这将由将值链接在一起映射到相同哈希值的方式来处理。使用哈希表的唯一好处将是对主要支付选项进行常数时间访问。
- en: 'Finally, we come to the simplest solution to store the primary payment option
    separately in the class. Here''s how we should rewrite the part of payment options''
    handling in the `User` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了将主要支付选项单独存储在类中的最简单的解决方案。以下是我们应该如何重写`User`类中处理支付选项的部分：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We took you through the process of defining the way to store payment options
    so far just to show the process of designing accompanied by coding. Though we've
    created a lot of versions for the single case of payment options, it's not final.
    There is always the case for handling duplicate values in the payment options
    vector. Whenever you add a payment option to the user as primary and then add
    another option as primary, the previous one goes to the non-primary list. If we
    change our minds and add the old payment option once again as a primary, it won't
    be removed from the non-primary list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经带您了解了存储支付选项的方式的过程，只是为了展示设计伴随编码的过程。尽管我们为支付选项的单一情况创建了许多版本，但这并不是最终版本。在支付选项向量中处理重复值的情况总是存在。每当您将一个支付选项添加为主要选项，然后再添加另一个选项为主要选项时，先前的选项将移至非主要列表。如果我们改变主意并再次将旧的支付选项添加为主要选项，它将不会从非主要列表中移除。
- en: So, there are always opportunities to think deeper and avoid potential issues.
    Design and coding go hand in hand; however, you shouldn't forget about TDD. In
    most cases, writing tests before coding will help you to discover a lot of use
    cases.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总是有机会深入思考并避免潜在问题。设计和编码是相辅相成的；然而，您不应忘记TDD。在大多数情况下，在编码之前编写测试将帮助您发现许多用例。
- en: Using SOLID principles
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SOLID原则
- en: There are lots of principles and design methods that you can use in your project
    design. It's always better to keep the design simpler, however, there are principles
    that are useful in almost all projects in general. For example, **SOLID** comprises
    of five principles, all or some of which can be useful to the design.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设计中，您可以使用许多原则和设计方法。保持设计简单总是更好，但是有些原则在一般情况下几乎对所有项目都有用。例如，**SOLID**包括五个原则，其中的一个或全部可以对设计有用。
- en: 'SOLID stands for the following principles:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID代表以下原则：
- en: Single responsibility
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责
- en: Open-closed
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Liskov substitution
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里氏替换
- en: Interface segregation
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离
- en: Dependency inversion
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖反转
- en: Let's discuss each principle with examples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过示例讨论每个原则。
- en: The single responsibility principle
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'The single responsibility principle states the simple, that is, one object,
    one task. Try to reduce the functionality of your objects and their relationship
    complexity. Make each object have one responsibility even though it''s not always
    easy to dissect a complex object into smaller and simpler components. Single responsibility
    is a context-bound concept. It''s not about having just one method in a class;
    it''s about making the class or module responsible for one thing. For example,
    the `User` class that we designed earlier has one responsibility: storing user
    information. However, we added payment options into the `User` class and forced
    it to have methods for adding and removing payment options. We also introduced
    a primary payment option, which involves additional logic in the **User** methods.
    We can move toward two directions.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则简单地说明了一个对象，一个任务。尽量减少对象的功能和它们的关系复杂性。使每个对象只负责一个任务，即使将复杂对象分解为更小更简单的组件并不总是容易的。单一职责是一个上下文相关的概念。它不是指类中只有一个方法；而是使类或模块负责一个事情。例如，我们之前设计的`User`类只有一个职责：存储用户信息。然而，我们将支付选项添加到`User`类中，并强制它具有添加和删除支付选项的方法。我们还引入了主要支付选项，这涉及**User**方法中的额外逻辑。我们可以朝两个方向发展。
- en: 'The first one suggests decomposing the `User` class into two separate classes.
    Each class will have a single responsibility. The following class diagram depicts
    the idea:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个建议将`User`类分解为两个单独的类。每个类将负责一个单一的功能。以下类图描述了这个想法：
- en: '![](img/711b0c46-dd8c-438a-904c-c1727528681d.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/711b0c46-dd8c-438a-904c-c1727528681d.png)'
- en: One of them will store only the user basic information, the next will store
    payment options for a user. We named them accordingly, `UserInfo` and `UserPaymentOptions`.
    Some might like this new design, but we will stick with the old one. And here's
    why. Though the `User` class contains both user information and payment options,
    the latter also represents a piece of information. We set and get payment options
    the same way we set and get the email of a user. So, we keep the `User` class
    the same because it's already satisfying the single responsibility principle.
    When we add the functionality to make a payment in the `User` class, that will
    break the peace. In that scenario, the `User` class will both store user information
    and make payment transactions. That's unacceptable in terms of the single responsibility
    principle, therefore, we won't do that.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个将仅存储用户的基本信息，下一个将存储用户的支付选项。我们分别命名它们为`UserInfo`和`UserPaymentOptions`。有些人可能会喜欢这种新设计，但我们会坚持旧的设计。原因在于，`User`类既包含用户信息又包含支付选项，后者也代表了一部分信息。我们设置和获取支付选项的方式与设置和获取用户的电子邮件的方式相同。因此，我们保持`User`类不变，因为它已经满足了单一职责原则。当我们在`User`类中添加付款功能时，这将破坏平衡。在这种情况下，`User`类将既存储用户信息又进行付款交易。这在单一职责原则方面是不可接受的，因此我们不会这样做。
- en: The single responsibility principle relates to functions as well. The `add_payment_option()` method has
    two responsibilities. It adds a new primary payment option if the second (default)
    argument of the function is true. Otherwise, it adds the new payment option to
    the list of non-primary options. It's better to have a separate method for adding
    a primary payment option. That way, each of the methods will have a single responsibility.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则也与函数相关。`add_payment_option()`方法有两个职责。如果函数的第二个（默认）参数为true，则它会添加一个新的主要支付选项。否则，它会将新的支付选项添加到非主要选项列表中。最好为添加主要支付选项单独创建一个方法。这样，每个方法都将有单一职责。
- en: The open-closed principle
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: 'The open-closed principle states that a class should be open for extension
    but closed for modification. It means that whenever you need new functionality,
    it''s better to extend the base functionality instead of modifying it. For example,
    take the `Product` class of the e-commerce application that we designed. The following
    represents a simple diagram for the `Product` class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 开闭原则规定一个类应该对扩展开放，对修改关闭。这意味着每当你需要新的功能时，最好是扩展基本功能而不是修改它。例如，我们设计的电子商务应用程序中的`Product`类。以下是`Product`类的简单图表：
- en: '![](img/7a087189-9c02-4c59-857f-38a419d1299d.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a087189-9c02-4c59-857f-38a419d1299d.png)'
- en: 'Each `Product` object has three properties: **name**, **price**, and **weight**.
    Now, imagine that after designing the `Product` class and the whole e-commerce
    platform, a new requirement comes from the clients. They now want to buy digital
    products, such as e-books, movies, and audio recordings. Everything is fine except
    for the weight of the product. Now that there might be two types of products—tangible
    and digital—we should rethink the logic of `Product` usage. We can incorporate
    a new function into `Product` as shown in the code here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Product`对象都有三个属性：**名称**、**价格**和**重量**。现在，想象一下，在设计了`Product`类和整个电子商务平台之后，客户提出了一个新的需求。他们现在想购买数字产品，如电子书、电影和音频录音。一切都很好，除了产品的重量。现在可能会有两种产品类型——有形和数字——我们应该重新思考`Product`使用的逻辑。我们可以像这里的代码中所示那样在`Product`中加入一个新的功能：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Obviously, we modified the class—contradicting the open-closed principle. The
    principle says that the class should be closed for modification. It should be
    open for extension. We can achieve that by redesigning the `Product` class and
    making it an abstract base class for all products. Next, we create two more classes
    inheriting the `Product` base class: `PhysicalProduct` and `DigitalProduct`. The
    following class diagram depicts the new design:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们修改了类——违反了开闭原则。该原则规定类应该对修改关闭。它应该对扩展开放。我们可以通过重新设计`Product`类并将其制作成所有产品的抽象基类来实现这一点。接下来，我们创建两个更多的类，它们继承`Product`基类：`PhysicalProduct`和`DigitalProduct`。下面的类图描述了新的设计：
- en: '![](img/39a14c81-c9c5-4dee-8924-e6cbccf9a257.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39a14c81-c9c5-4dee-8924-e6cbccf9a257.png)'
- en: As you can see in the preceding diagram, we removed the `weight_` property from
    the `Product` class. Now that we have two more classes, `PhysicalProduct` has
    a `weight_` property and `DigitalProduct` does not have one. Instead, it has a
    `file_path_` property. This approach satisfies the open-closed principle because
    now all the classes are open for extension. We use inheritance to extend classes,
    and the following principle is strongly related to that.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的图表所示，我们从`Product`类中删除了`weight_`属性。现在我们有了两个更多的类，`PhysicalProduct`有一个`weight_`属性，而`DigitalProduct`没有。相反，它有一个`file_path_`属性。这种方法满足了开闭原则，因为现在所有的类都可以扩展。我们使用继承来扩展类，而下面的原则与此密切相关。
- en: The Liskov substitution principle
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则
- en: The Liskov substitution principle is about inheriting from a type the right
    way. In simple words, if there is a function that takes an argument of some type,
    then the same function should take an argument of the derived type.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则是关于正确继承类型的方式。简单来说，如果有一个函数接受某种类型的参数，那么同一个函数应该接受派生类型的参数。
- en: The Liskov substitution principle is named after Barbara Liskov, a Turing Award
    winner and doctor of computer science.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则是以图灵奖获得者、计算机科学博士芭芭拉·里斯科夫的名字命名的。
- en: 'Once you understand inheritance and the Liskov substitution principle, it''s
    hard to forget it. Let''s continue developing the `Product` class and add a new
    method that returns the price of the product based on the currency type. We can
    store the price in the same currency units and provide a function to convert the
    price for a specified currency. Here''s the simple implementation of the method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了继承和里氏替换原则，就很难忘记它。让我们继续开发`Product`类，并添加一个根据货币类型返回产品价格的新方法。我们可以将价格存储在相同的货币单位中，并提供一个将价格转换为指定货币的函数。以下是该方法的简单实现：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After a while, the company decides to incorporate lifetime discounts for all
    digital products. Now, every digital product will have a 12% discount. Short time,
    we add a separate function in the `DigitalProduct` class that returns a converted
    price by applying the discount. Here''s how it looks in `DigitalProduct`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一段时间，公司决定为所有数字产品引入终身折扣。现在，每个数字产品都将享有12%的折扣。在短时间内，我们在`DigitalProduct`类中添加了一个单独的函数，该函数通过应用折扣返回转换后的价格。以下是`DigitalProduct`中的实现：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The problem in the design is obvious. Calling `convert_price()` on the `DigitalProduct`
    instance will have no effect. Even worse, the client code must not call it. Instead,
    it should call `convert_price_with_discount()` because all digital products must
    sell with a 12% discount. The design contradicts the Liskov substitution principle.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 设计中的问题是显而易见的。在`DigitalProduct`实例上调用`convert_price()`将没有效果。更糟糕的是，客户端代码不应该调用它。相反，它应该调用`convert_price_with_discount()`，因为所有数字产品必须以12%的折扣出售。设计违反了里氏替换原则。
- en: 'Instead of damaging the class hierarchy, we should remember the beauty of polymorphism.
    Here''s what a better version will look like:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该破坏类层次结构，而应该记住多态的美妙之处。一个更好的版本将如下所示：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, we don''t need the `convert_price_with_discount()` function
    anymore. And the Liskov substitution principle holds. However, we should again
    inspect flaws in the design. Let''s make it better by incorporating private virtual
    methods for discount calculation in the base class. The following updated version
    of the `Product` class contains a private virtual member function named `calculate_discount()`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们不再需要`convert_price_with_discount()`函数。而且里氏替换原则得到了遵守。然而，我们应该再次检查设计中的缺陷。让我们通过在基类中引入用于折扣计算的私有虚方法来改进它。以下是`Product`类的更新版本，其中包含一个名为`calculate_discount()`的私有虚成员函数：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `convert_price()` function calls the private `apply_discount()` function,
    which returns the price as is. And here comes the trick. We override the `apply_discount()`
    function in derived classes as it is shown in the following `DigitalProduct` implementation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert_price()`函数调用私有的`apply_discount()`函数，该函数返回原价。这里有一个技巧。我们在派生类中重写`apply_discount()`函数，就像下面的`DigitalProduct`实现中所示：'
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can't call a private function outside the class, but we can override it in
    derived classes. And the preceding code shows the beauty of overriding private
    virtual functions. We modify the implementation leaving the interface untouched.
    A derived class doesn't override it if it does not need to provide custom functionality
    for discount calculation. On the other hand, `DigitalProduct` needs to apply a
    12% discount on the price before converting it. It is not necessary to modify
    the public interface of the base class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在类外部调用私有函数，但我们可以在派生类中重写它。前面的代码展示了重写私有虚函数的美妙之处。我们修改了实现，但接口保持不变。如果派生类不需要为折扣计算提供自定义功能，则不需要重写它。另一方面，`DigitalProduct`需要在转换之前对价格进行12%的折扣。不需要修改基类的公共接口。
- en: You should consider rethinking the design of the `Product` class. It seems even
    better to call `apply_discount()` directly in `getPrice()`, hence always returning
    the latest effective price. Though at some point you should force yourself to
    stop.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该考虑重新思考`Product`类的设计。直接在`getPrice()`中调用`apply_discount()`似乎更好，因此始终返回最新的有效价格。尽管在某些时候，您应该强迫自己停下来。
- en: The design process is creative and sometimes unthankful. It's not uncommon to
    rewrite all of the code because of unexpected new requirements. We use principles
    and approaches to minimize the breaking changes that will follow after implementing
    new features. The next principle of SOLID is one of the best practices that will
    make your design flexible.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 设计过程是有创意的，有时也是不感激的。由于意外的新需求，重写所有代码并不罕见。我们使用原则和方法来最小化在实现新功能后可能出现的破坏性变化。SOLID的下一个原则是最佳实践之一，它将使您的设计更加灵活。
- en: The interface segregation principle
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The interface segregation principle suggests dividing a complex interface into
    simpler interfaces. This segregation allows classes to avoid implementing an interface
    they don't use.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则建议将复杂的接口分成更简单的接口。这种隔离允许类避免实现它们不使用的接口。
- en: In our e-commerce application, we should implement a product shipment, replacement,
    and expiring functionalities. The shipment of the product is moving the product
    item to its buyer. We don't care for the shipment details at this point. Replacement
    of a product considers replacing a damaged or lost product after shipping to the
    buyer. Finally, expiring a product means getting rid of products that did not
    sell by their expiry date.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电子商务应用中，我们应该实现产品发货、替换和过期功能。产品的发货是将产品项目移交给买家。在这一点上，我们不关心发货的细节。产品的替换考虑在向买家发货后替换损坏或丢失的产品。最后，产品的过期意味着处理在到期日期之前未销售的产品。
- en: We are free to implement all of the functionality in the `Product` class introduced
    earlier. However, eventually, we will stumble upon types of products that, for
    example, cannot be shipped (for example, selling a house rarely involves shipping
    it to the buyer). There might be products that are not replaceable. For example,
    an original painting is not possible to replace even if it's lost or damaged.
    Finally, digital products won't expire ever. Well, for most cases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面介绍的`Product`类中实现所有功能。然而，最终我们会遇到一些产品类型，例如无法运输的产品（例如，很少有人会将房屋运送给买家）。可能有一些产品是不可替代的。例如，原始绘画即使丢失或损坏也无法替换。最后，数字产品永远不会过期。嗯，大多数情况下是这样。
- en: 'We should not force the client code to implement a behavior it doesn''t need.
    By the client, we mean the class implementing behaviors. The following example
    is a bad practice, contradictory to the interface segregation principle:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该强制客户端代码实现它不需要的行为。在这里，客户端指的是实现行为的类。以下示例是违反接口隔离原则的不良实践：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, the `Product` class implements the interface shown in the preceding. It
    has to provide an implementation for all of the methods. The interface segregation
    principle suggests the following model:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Product`类实现了前面展示的接口。它必须为所有方法提供实现。接口隔离原则建议以下模型：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, the `Product` class skips implementing any of the interfaces. Its derived
    classes derive (implement) from specific types. The following example declares
    several types of product classes, each of which supports a limited number of behaviors
    introduced earlier. Please note that we omit bodies of classes for code brevity:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Product`类跳过了实现任何接口。它的派生类从特定类型派生（实现）。以下示例声明了几种产品类的类型，每种类型都支持前面介绍的有限数量的行为。请注意，为了代码简洁起见，我们省略了类的具体内容：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Consider implementing `IShippable` for `AudioBook` if you want to wrap a file
    downloading as shipment.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将文件下载包装为货物，可以考虑为`AudioBook`实现`IShippable`。
- en: The dependency inversion principle
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: 'Finally, dependency inversion states that objects should not be strongly coupled.
    It allows switching to an alternate dependency easily. For example, when a user
    purchases a product, we send a receipt about the purchase. Technically, there
    are several ways to send a receipt, namely, printing and sending via mail, sending
    via email, or showing the receipt in the user account page on the platform. For
    the latter, we send a notification to the user via email or the app that the receipt
    is ready to be viewed. Take a look at the following interface for printing a receipt:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，依赖倒置原则规定对象不应该紧密耦合。它允许轻松切换到替代依赖。例如，当用户购买产品时，我们会发送购买收据。从技术上讲，有几种发送收据的方式，即打印并通过邮件发送，通过电子邮件发送，或在平台的用户账户页面上显示收据。对于后者，我们会通过电子邮件或应用程序向用户发送通知，告知收据已准备好查看。看一下以下用于打印收据的接口：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s suppose we''ve implemented the `purchase()` method in the `Product`
    class, and on its completion, we send the receipt. The following portion of code
    handles the sending of the receipt:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经在`Product`类中实现了`purchase()`方法，并在完成后发送了收据。以下代码部分处理了发送收据的过程：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can extend the application by adding as many receipt printing options as
    needed. The following class implements the `IReceiptSender` interface:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加所需的收据打印选项来扩展应用程序。以下类实现了`IReceiptSender`接口：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Two more classes—`EmailReceiptSender` and `InAppReceiptSender`—both implement
    `IReceiptSender`. So, to use a specific receipt, we just inject the dependency
    to `Product` via the `purchase()` method, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个类——`EmailReceiptSender`和`InAppReceiptSender`——都实现了`IReceiptSender`。因此，要使用特定的收据，我们只需通过`purchase()`方法将依赖注入到`Product`中，如下所示：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can move further by implementing a method in the `User` class that returns
    the receipt sending option desirable for the concrete user. This will make the
    classes even more decoupled.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步通过在`User`类中实现一个方法，返回具体用户所需的收据发送选项。这将使类之间的耦合更少。
- en: All of the SOLID principles discussed in the preceding are a natural way of
    composing classes. It's not mandatory to stick to the principles, however, it
    will improve your design if you do.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面讨论的所有SOLID原则中，都是组合类的一种自然方式。遵循这些原则并不是强制性的，但如果遵循这些原则，将会改善你的设计。
- en: Using domain-driven design
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用领域驱动设计
- en: The domain is the subject area of the program. We are discussing and designing
    an e-commerce platform having e-commerce as the main concept with all its supplementary
    concepts as the domain. We rather suggest you consider domain-driven design in
    your projects. However, the method is not a silver bullet for program design.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 领域是程序的主题领域。我们正在讨论和设计一个以电子商务为主题概念的电子商务平台，所有附属概念都是该领域的一部分。我们建议您在项目中考虑领域驱动设计。然而，该方法并不是程序设计的万能药。
- en: 'It''s convenient to design your projects to have the following three layers
    of the three-tier architecture in mind:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 设计项目时，考虑以下三层三层架构的三个层次是很方便的：
- en: Presentation
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示
- en: Business logic
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: Data
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: The three-tier architecture applies to client-server software such as the one
    we are designing in this chapter. The presentation layer provides users with information
    related to products, purchases, and shipment. It communicates with other layers by
    putting out the results to the client. It's a layer that clients access directly,
    for example, a web browser.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 三层架构适用于客户端-服务器软件，例如我们在本章中设计的软件。表示层向用户提供与产品、购买和货物相关的信息。它通过向客户端输出结果与其他层进行通信。这是客户直接访问的一层，例如，Web浏览器。
- en: The business logic cares for application functionality. For example, a user
    browses products provided by the presentation layer and decides to purchase one
    of them. The processing of the request is the task of the business layer. In domain-driven
    design, we tend to combine domain-level entities with their attributes to tackle
    the application complexity. We deal with users as instances of the `User` class,
    with products as instances of the `Product` class, and so on. The user purchasing
    a product is interpreted by the business logic as a `User` object creating an
    `Order` object, which, in turn, is related to a `Product` object. The `Order`
    object is then tied to a `Transaction` object related to the purchase of the product.
    Corresponding results of the purchase are represented via the presentation layer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑关心应用功能。例如，用户浏览由表示层提供的产品，并决定购买其中的一个。请求的处理是业务层的任务。在领域驱动设计中，我们倾向于将领域级实体与其属性结合起来，以应对应用程序的复杂性。我们将用户视为`User`类的实例，产品视为`Product`类的实例，依此类推。用户购买产品被业务逻辑解释为`User`对象创建一个`Order`对象，而`Order`对象又与`Product`对象相关联。然后，`Order`对象与与购买产品相关的`Transaction`对象相关联。购买的相应结果通过表示层表示。
- en: Finally, the data layer handles storing and retrieving data. From user authentication
    to product purchase, each step is retrieved from or recorded in the system database
    (or databases).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数据层处理存储和检索数据。从用户认证到产品购买，每个步骤都从系统数据库（或数据库）中检索或记录。
- en: Dividing the application into layers allows handling the complexity of it in
    general. It's much better to orchestrate objects having single responsibility.
    The domain-driven design differentiates entities from objects that don't have
    a conceptual identity. The latter are known as value objects. For example, users
    do not distinguish between each unique transaction; they are only concerned about
    information that a transaction represents. On the other hand, a user object has
    a conceptual identity in the form of a `User` class (the entity).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分成层可以处理其整体的复杂性。最好协调具有单一责任的对象。领域驱动设计区分实体和没有概念身份的对象。后者被称为值对象。例如，用户不区分每个唯一的交易；他们只关心交易所代表的信息。另一方面，用户对象以`User`类的形式具有概念身份（实体）。
- en: Operations permitted on objects using other objects(or not) are named services.
    A service is rather an operation that is not tied to a specific object. For example,
    setting the name of the user by the `set_name()` method is an operation that shouldn't
    be considered as a service. On the other hand, the purchase of a product by the
    user is an operation encapsulated by a service.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他对象（或不使用）对对象执行的操作称为服务。服务更像是一个不与特定对象绑定的操作。例如，通过`set_name()`方法设置用户的名称是一个不应被视为服务的操作。另一方面，用户购买产品是由服务封装的操作。
- en: Finally, domain-driven design intensively incorporates **repository** and **factory**
    patterns. The repository pattern is responsible for methods for retrieving and
    storing domain objects. The factory pattern creates domain objects. Using these
    patterns allows us to interchange alternative implementations if and when needed.
    Let's now find out the power of design patterns in the context of the e-commerce
    platform.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，领域驱动设计强烈地融合了**存储库**和**工厂**模式。存储库模式负责检索和存储领域对象的方法。工厂模式创建领域对象。使用这些模式允许我们在需要时交换替代实现。现在让我们在电子商务平台的背景下发现设计模式的力量。
- en: Leveraging design patterns
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用设计模式
- en: Design patterns are architectural solutions to commonly occurring problems in
    software design. It is important to note that design patterns are not methods
    nor algorithms. They are architectural constructs that provide a way of organizing
    classes and their relationship to achieve better results in code maintainability.
    Even if you didn't use a design pattern before, you most probably had invented
    one on your own. Many problems tend to recur in software design. For example,
    making a better interface for an existing library is a form of a design pattern
    known as **facade**. Design patterns have names so that programmers use them in
    conversations or documentation. It should be natural for you to chit-chat with
    fellow programmers using facades, factories, and the like.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是软件设计中常见问题的架构解决方案。重要的是要注意，设计模式不是方法或算法。它们是提供组织类和它们之间关系的一种架构构造，以实现更好的代码可维护性的方式。即使以前没有使用过设计模式，你很可能已经自己发明了一个。许多问题在软件设计中往往会反复出现。例如，为现有库创建更好的接口是一种称为**facade**的设计模式形式。设计模式有名称，以便程序员在对话或文档中使用它们。与其他程序员使用facade、factory等进行闲聊应该是很自然的。
- en: We've previously mentioned that domain-driven design incorporates repository
    and factory patterns. Let's now find out what they are and how they could be useful
    in our design endeavor.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到领域驱动设计融合了存储库和工厂模式。现在让我们来了解它们是什么，以及它们如何在我们的设计努力中发挥作用。
- en: The repository pattern
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储库模式
- en: As Martin Fowler best describes, the repository pattern "*mediates between the
    domain and data mapping layers using a collection-like interface for accessing
    domain objects*".
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Martin Fowler最好地描述的那样，存储库模式“在领域和数据映射层之间使用类似集合的接口来访问领域对象”。
- en: The pattern provides straightforward methods for data manipulation, without
    the need to work with the database driver directly. Adding, updating, removing,
    or selecting data naturally fits with the application domain.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式提供了直接的数据操作方法，无需直接使用数据库驱动程序。添加、更新、删除或选择数据自然地适用于应用程序域。
- en: 'One of the approaches is to create a generic repository class that provides
    necessary functions. A simple interface is shown as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是创建一个提供必要功能的通用存储库类。简单的接口如下所示：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We introduced a new class named `Entity` in the preceding. The `Repository` class works
    with entities and to make sure that each entity conforms to the same interface
    of `Entity`, it applies `std::enable_if` along with `std::is_base_of_v` to the
    template parameter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面引入了一个名为`Entity`的新类。`Repository`类与实体一起工作，并确保每个实体都符合`Entity`的相同接口，它应用`std::enable_if`以及`std::is_base_of_v`到模板参数。
- en: '`std::is_base_of_v` is a short representation for `std::is_base_of<>::value`.
    Also, `std::enable_if_t` replaces `std::enable_if<>::type`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::is_base_of_v`是`std::is_base_of<>::value`的简写。此外，`std::enable_if_t`替换了`std::enable_if<>::type`。'
- en: 'The `Entity` class is as simple as the following representation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity`类的表示如下：'
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each business object is an `Entity`, therefore, the classes discussed earlier
    should be updated to inherit from `Entity`. For example, the `User` class takes
    the following form:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个业务对象都是一个`Entity`，因此，前面讨论的类应该更新为从`Entity`继承。例如，`User`类的形式如下：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, we can use the repository the following way:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样使用存储库：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding repository pattern is a simple introduction to the topic, however,
    you can make it even powerful. It resembles the facade pattern. Though the point
    of using the facade pattern is not access to the database, it is still best explained
    with that example. The facade pattern wraps a complex class or classes, providing
    the client with a simple predefined interface to work with the underlying functionality.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前面介绍的存储库模式是对该主题的简单介绍，但是你可以使它更加强大。它类似于外观模式。虽然使用外观模式的重点不是访问数据库，但是最好用数据库访问来解释。外观模式包装了一个复杂的类或类，为客户端提供了一个简单的预定义接口，以便使用底层功能。
- en: The factory pattern
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: When programmers talk about factory patterns, they might confuse the factory
    method and abstract factory. Both of these are creational patterns that provide
    various object creation mechanisms. Let's discuss the factory method. It provides
    an interface for creating objects in the base class and allows derived classes
    to modify the objects that will be created.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员谈论工厂模式时，他们可能会混淆工厂方法和抽象工厂。这两者都是提供各种对象创建机制的创建模式。让我们讨论工厂方法。它提供了一个在基类中创建对象的接口，并允许派生类修改将被创建的对象。
- en: Now is the time to deal with logistics, and the factory method will help us
    in that. When you develop an e-commerce platform providing product shipments,
    you should consider that not all users live in the same area in which your warehouses
    are located. So, shipping a product from a warehouse to the buyer, you should choose
    the proper transportation type. A bicycle, a drone, a truck, and so on. The problem
    of interest is designing a flexible logistics management system.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是处理物流的时候了，工厂方法将在这方面帮助我们。当你开发一个提供产品发货的电子商务平台时，你应该考虑到并非所有用户都住在你的仓库所在的同一地区。因此，从仓库向买家发货时，你应该选择适当的运输类型。自行车、无人机、卡车等等。感兴趣的问题是设计一个灵活的物流管理系统。
- en: 'Different means of transportation require different implementations. However,
    all of them conform to one interface. The following is the class diagram for the
    `Transport` interface and its derived specific transport implementations:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的交通工具需要不同的实现。然而，它们都符合一个接口。以下是`Transport`接口及其派生的具体交通工具实现的类图：
- en: '![](img/9440ba69-a862-495f-b00d-4e2a4db2e746.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9440ba69-a862-495f-b00d-4e2a4db2e746.png)'
- en: Each of the concrete classes in the preceding diagram provides specific implementation
    to delivery.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图表中的每个具体类都提供了特定的交付实现。
- en: 'Let''s suppose we design the following `Logistics` base class responsible for
    logistics-related actions, including choosing the proper transportation method
    as shown:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们设计了以下`Logistics`基类，负责与物流相关的操作，包括选择适当的运输方式，如下所示：
- en: '![](img/69a43738-0ce0-4c88-8f17-b5a8d36fec0f.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69a43738-0ce0-4c88-8f17-b5a8d36fec0f.png)'
- en: The factory method applied in the preceding allows flexibility in adding new
    transport types as well as new logistic methods. Pay attention to the `createTransport()`
    method that returns a pointer to `Transport`. Derived classes override the method,
    each of which returns a subclass of `Transport`, hence providing a specific mode
    of transport. It's possible because subclasses return a derived type, otherwise,
    we can't return a different type when overriding base class methods.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 前面应用的工厂方法允许灵活地添加新的运输类型以及新的物流方法。注意`createTransport()`方法返回一个`Transport`指针。派生类覆盖该方法，每个派生类返回`Transport`的子类，从而提供了特定的运输方式。这是可能的，因为子类返回了派生类型，否则在覆盖基类方法时无法返回不同的类型。
- en: '`createTransport()` in `Logistics` looks as shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logistics`中的`createTransport()`如下所示：'
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `Transport` class represents a base class for `Drone`, `Truck`, and `Ship`.
    That means we can create an instance of each and refer to them using a `Transport`
    pointer as shown:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transport`类代表了`Drone`、`Truck`和`Ship`的基类。这意味着我们可以创建每个实例，并使用`Transport`指针引用它们，如下所示：'
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This lays at the foundation of the factory pattern because `RoadLogistics`,
    for example, overrides `getLogistics()` like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是工厂模式的基础，因为例如`RoadLogistics`覆盖了`getLogistics()`，如下所示：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Pay attention to the return type of the function, it's `Truck` instead of `Transport`.
    It works because `Truck` inherits from `Transport`. Also, see how object creation
    is decoupled from the object itself. Creating new objects is done via factories,
    which keeps consistency with the SOLID principles discussed earlier.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数的返回类型，它是`Truck`而不是`Transport`。这是因为`Truck`继承自`Transport`。另外，看看对象的创建是如何与对象本身解耦的。创建新对象是通过工厂完成的，这与之前讨论的SOLID原则保持一致。
- en: At first glance, it might confusingly seem that leveraging a design pattern
    incorporates additional complexity into the design. However, you should develop
    a true sense of better design when practicing design patterns because they allow
    for flexibility and extendibility of the project overall.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，利用设计模式似乎会给设计增加额外的复杂性。然而，当实践设计模式时，你应该培养对更好设计的真正感觉，因为它们允许项目整体具有灵活性和可扩展性。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Software development requires meticulous planning and design. We''ve learned
    in this chapter that project development involves the following key steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发需要细致的规划和设计。我们在本章中学到，项目开发包括以下关键步骤：
- en: 'Requirements gathering and analysis: This includes understanding the domain
    of the project, discussing and finalizing the features that should be implemented.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求收集和分析：这包括理解项目的领域，讨论和最终确定应该实现的功能。
- en: 'Specification creation: This includes documenting requirements and project
    functionality.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范创建：这包括记录需求和项目功能。
- en: 'Design and test planning: This refers to designing the project starting from
    the bigger entities down to decomposing each into a separate class with regards
    to other classes in the project. This step also involves planning how the project
    will be tested.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和测试规划：这指的是从更大的实体开始设计项目，然后将每个实体分解为一个单独的类，考虑到项目中的其他类。这一步还涉及规划项目的测试方式。
- en: 'Coding: This step involves writing code that implements the project specified
    in previous steps.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码：这一步涉及编写代码，实现前面步骤中指定的项目。
- en: 'Testing and stabilization: This means checking the project against preplanned
    use cases and scenarios to discover issues and fix them.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和稳定性：这意味着根据预先计划的用例和场景检查项目，以发现问题并加以修复。
- en: 'Release and maintenance: This is the final step that brings us to the project
    release and further maintenance.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布和维护：这是最后一步，将我们带到项目的发布和进一步的维护。
- en: The project design is a complex task for programmers. They should think ahead
    of time because part of the features is being introduced during the development
    of the process.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设计对程序员来说是一个复杂的任务。他们应该提前考虑，因为部分功能是在开发过程中引入的。
- en: To make the design flexible and robust, we've discussed principles and patterns
    leading to better architecture. We have learned the process of designing a software
    project with all its intricacies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使设计灵活而健壮，我们已经讨论了导致更好架构的原则和模式。我们已经学习了设计软件项目及其复杂性的过程。
- en: One of the best ways to avoid bad design decisions is to follow already devised
    patterns and practices. You should consider using SOLID principles along with
    proven design patterns in your future projects.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 避免糟糕的设计决策的最佳方法之一是遵循已经设计好的模式和实践。在未来的项目中，你应该考虑使用SOLID原则以及经过验证的设计模式。
- en: In the next chapter, we will design a strategy game. We will get familiar with
    more design patterns and see their applications in game development.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将设计一个策略游戏。我们将熟悉更多的设计模式，并看到它们在游戏开发中的应用。
- en: Questions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the benefits of TDD?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TDD的好处是什么？
- en: What is the purpose of interaction diagrams in UML?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UML中交互图的目的是什么？
- en: What's the difference between a composition and aggregation?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合和聚合之间有什么区别？
- en: How would you describe the Liskov substitution principle?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何描述Liskov替换原则？
- en: Let's suppose you are given the class `Animal`, and the class `Monkey`. The
    latter describes a particular animal that jumps on trees. Does inheriting a `Monkey`
    class from an `Animal` class contradict the open-closed principle?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有一个`Animal`类和一个`Monkey`类。后者描述了一种特定的会在树上跳跃的动物。从`Animal`类继承`Monkey`类是否违反了开闭原则？
- en: Apply the factory method on the `Product` class with its subclasses that were
    discussed in this chapter.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章讨论的`Product`类及其子类上应用工厂方法。
- en: Further reading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information refer to :'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅：
- en: '*Object-Oriented Analysis and Design with Applications* by Grady Booch, [https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/](https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《面向对象的分析与设计与应用》* by Grady Booch，[https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/](https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/)'
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma
    et al, [https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《设计模式：可复用面向对象软件的元素》* by Erich Gamma等人，[https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/)'
- en: '*Code Complete: A Practical Handbook of Software Construction* by Steve McConnel,[ https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《代码大全：软件构建的实用手册》* by Steve McConnel，[https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/)'
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* by Eric
    Evans, [https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《领域驱动设计：软件核心复杂性的应对》* by Eric Evans，[https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)'
