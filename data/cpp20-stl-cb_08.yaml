- en: '*Chapter 8*: Utility Classes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：实用类'
- en: The C++ Standard Library includes an assortment of utility classes designed
    for specific tasks. Some are common, and you've probably seen many of these classes
    in other recipes in this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库包含了一系列为特定任务设计的实用类。其中一些是常见的，您可能已经在本书的其他食谱中看到了这些类。
- en: 'This chapter covers a broad range of utilities, including time measurement,
    generic types, smart pointers, and more, in the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了广泛的功能，包括时间测量、泛型类型、智能指针等，以下是一些食谱：
- en: Manage optional values with `std::optional`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::optional`管理可选值
- en: Use `std::any` for type safety
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::any`进行类型安全
- en: Store different types with `std::variant`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::variant`存储不同类型
- en: Time events with `std::chrono`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::chrono`进行时间事件
- en: Use fold expressions for variadic tuples
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用折叠表达式处理可变参数元组
- en: Manage allocated memory with `std::unique_ptr`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::unique_ptr`管理分配的内存
- en: Share objects with `std::shared_ptr`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::shared_ptr`共享对象
- en: Use weak pointers with shared objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弱指针与共享对象一起使用
- en: Share members of a managed object
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享托管对象成员
- en: Compare random number engines
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较随机数生成器
- en: Compare random number distribution generators
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较随机数分布生成器
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，链接为[https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08)。
- en: Manage optional values with std::optional
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`std::optional`管理可选值
- en: Introduced with C++17, the `std::optional` class holds an *optional value*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++17 的引入，`std::optional`类包含一个*可选值*。
- en: 'Consider the case where you have a function that may or may not return a value
    – for example, a function that checks if a number is *prime* but returns the first
    factor if there is one. This function should return either a value or a `bool`
    status. We could create a `struct` that carries both value and status:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况，您有一个可能返回或不返回值的函数——例如，一个检查数字是否为*素数*但如果有第一个因子则返回它的函数。这个函数应该返回一个值或一个`bool`状态。我们可以创建一个`struct`来携带值和状态：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's a clumsy solution but it works, and it's not uncommon.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个笨拙的解决方案，但它有效，而且并不罕见。
- en: 'It could be made a lot simpler with the `optional` class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`optional`类可以使它变得更加简单：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With `optional`, we can return a value or a non-value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`optional`，我们可以返回一个值或非值。
- en: 'We can call it, like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样调用它：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our output is:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出是：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The optional class allows us to easily return the optional value and easily
    test for a value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional`类允许我们轻松返回可选值并轻松测试值。'
- en: How to do it…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we''ll look at some examples of how to use the `optional` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将查看一些如何使用`optional`类的示例：
- en: 'The `optional` class is quite simple. We construct an optional value using
    standard template notation:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optional`类相当简单。我们使用标准模板符号构造一个可选值：'
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We access the value of the `optional` with the `*` pointer dereference operator.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`*`指针解引用操作符访问`optional`的值。
- en: 'Output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We test if the `optional` has a value using its `bool` operator:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`optional`的`bool`操作符测试它是否有值：
- en: 'If `a` were constructed without a value:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`a`没有值被构造：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output would reflect the `else` condition:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将反映`else`条件：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can further simplify this by declaring a *type alias*:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过声明一个*类型别名*来进一步简化：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we want to operate on `oint` objects, with `oint` objects as the result,
    we can provide operator overloads:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在`oint`对象上操作，并且结果也是`oint`对象，我们可以提供操作符重载：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can operate on the `oint` objects directly:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直接操作`oint`对象：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Suppose we declare `b` with the default constructor:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们使用默认构造函数声明`b`：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we get the `else` branch output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到`else`分支的输出：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `std::optional` class is made for simplicity. It provides operator overloads
    for many common functions. It also includes member functions for further flexibility.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::optional`类是为了简洁而设计的。它为许多常见函数提供了操作符重载。它还包括用于进一步灵活性的成员函数。'
- en: 'The `optional` class provides an `operator bool` overload for determining if
    the object has a value:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional`类提供了一个`operator bool`重载，用于确定对象是否有值：'
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or, you may use the `has_value()` member function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`has_value()`成员函数：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To access the value, you may use the `operator*` overload:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问值，您可以使用`operator*`重载：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, you may use the `value()` member function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`value()`成员函数：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `reset()` member function destroys the value and resets the state of the
    `optional` object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset()`成员函数销毁值并重置`optional`对象的状态：'
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's more…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The `optional` class provides exception support with the `value()` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional`类通过`value()`方法提供异常支持：'
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Important Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Only the `value()` method throws an exception. The behavior of the `*` operator
    is *undefined* for an invalid value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`value()`方法会抛出异常。对于无效值，`*`运算符的行为是未定义的。
- en: Use std::any for type safety
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`std::any`进行类型安全
- en: Introduced with C++17, the `std::any` class provides a type-safe container for
    a single object of any type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: C++17引入的`std::any`类提供了一个类型安全的容器，用于存储任何类型的单个对象。
- en: 'For example, this is a default-constructed `any` object:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个默认构造的`any`对象：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This object has no value. We can test that with the `has_value()` method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象没有值。我们可以使用`has_value()`方法来测试这一点：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We assign a value to the `any` object with the assignment operator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用赋值运算符给`any`对象赋值：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, the `any` object has a value, and a type:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`any`对象有一个值和一个类型：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `type()` method returns a `type_info` object. The `type_info::name()` method
    returns an implementation-defined name for the type in a C-string. In this case,
    for GCC, the `i` means `int`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`type()`方法返回一个`type_info`对象。`type_info::name()`方法返回一个C字符串中类型的实现定义名称。在这种情况下，对于GCC，`i`表示`int`。'
- en: We use the `any_cast<`*type*`>()` non-member function to cast the value for
    use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`any_cast<`*type*`>()`非成员函数来转换值以供使用。
- en: 'We can re-assign the `any` object with different values of different types:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用不同类型的不同值重新赋值`any`对象：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I've abbreviated the long type name from GCC but you get the idea. The same
    `any` object that once held an `int` now contains an STL `string` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将GCC中的长类型名缩写了，但你应该明白这个意思。曾经包含`int`的同一个`any`对象现在包含了一个STL `string`对象。
- en: 'The main usefulness of the `any` class is in creating a polymorphic function.
    Let''s examine how to do that in this recipe:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`类的主要用途在于创建多态函数。让我们在这个菜谱中看看如何做到这一点：'
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we''ll build a polymorphic function using the `any` class.
    A polymorphic function is one that can take objects of different types in its
    parameters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`any`类构建一个多态函数。多态函数是指可以接受不同类型参数的对象：
- en: 'Our polymorphic function takes an `any` object and prints its type and value:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的多态函数接受一个`any`对象并打印其类型和值：
- en: '[PRE29]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `p_any()` function first tests to see if the object has a value. It then
    tests the `type()` method against various types and takes appropriate action for
    each type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_any()`函数首先检查对象是否有值。然后它将`type()`方法与各种类型进行比较，并为每种类型采取适当的行动。'
- en: Before the `any` class, we would have had to write four different specializations
    for this function, and we still wouldn't be able to easily handle the default
    case.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`any`类之前，我们不得不为这个函数编写四个不同的特殊化版本，而且我们仍然无法轻松处理默认情况。
- en: 'We call this function from `main()`, like this:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们像这样从`main()`函数中调用此函数：
- en: '[PRE30]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our polymorphic function handles the various types with a minimum of code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的多态函数以最少的代码处理各种类型。
- en: How it works…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `std::any` copy constructor and assignment operator use *direct initialization*
    to make a non-`const` copy of the target object as the *contained* object. The
    type of the contained object is stored separately as a `typeid` object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::any`的拷贝构造函数和赋值运算符使用*直接初始化*来创建目标对象的非`const`拷贝作为*包含*对象。包含对象的类型作为`typeid`对象单独存储。'
- en: 'Once initialized, the `any` object has the following methods:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化，`any`对象具有以下方法：
- en: '`emplace()` replaces the contained object, constructing the new object in place.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace()`替换包含的对象，在原地构造新对象。'
- en: '`reset()` destroys the contained object.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset()`销毁包含的对象。'
- en: '`has_value()` returns `true` if there is a contained object.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has_value()`如果存在包含对象则返回`true`。'
- en: '`type()` returns a `typeid` object, representing the type of the contained
    object.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type()`返回一个`typeid`对象，表示包含对象的类型。'
- en: '`operator=()` replaces the contained object by a *copy* or *move* operation.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator=()`通过*拷贝*或*移动*操作替换包含的对象。'
- en: 'The `any` class also supports the following non-member functions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`类还支持以下非成员函数：'
- en: '`any_cast<T>()`, a template function, provides type-safe access to the contained
    object.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any_cast<T>()`，一个模板函数，提供了对包含对象的类型安全访问。'
- en: Keep in mind that the `any_cast<T>()` function returns a copy of the contained
    object. You may use `any_cast<T&>()` to return a reference.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`any_cast<T>()`函数返回包含对象的副本。您可以使用`any_cast<T&>()`来返回引用。
- en: '`std::swap()` specializes the `std::swap` algorithm.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::swap()`专门化了`std::swap`算法。'
- en: 'If you try to cast an `any` object with the wrong type, it throws a `bad_any_cast`
    exception:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用错误类型转换`any`对象，它将抛出`bad_any_cast`异常：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Store different types with std::variant
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::variant存储不同类型
- en: Introduced with C++17, the `std::variant` class may hold different values, one
    at a time, where each value must fit in the same allocated memory space. It's
    useful for holding alternative types for use in a single context.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中引入的`std::variant`类可以一次持有不同的值，每个值必须适应相同的分配内存空间。它在用于单个上下文中的替代类型持有方面很有用。
- en: Differences from the primitive union structure
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与原始联合结构的区别
- en: The `variant` class is a *tagged union*. It differs from the primitive `union`
    structure in that only one type may be in effect at a time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant`类是一个*标记联合*。它与原始的`union`结构不同，因为在任何给定时间只能有一个类型有效。'
- en: 'The primitive `union` type, inherited from C, is a structure where the same
    datum may be accessed as different types. For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从C继承而来的原始`union`类型是一种结构，其中相同的数可以以不同的类型访问。例如：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, the `union` has two members, types `struct` and `uint32_t`,
    where `struct` has four `uint8_t` members. This gives us two *different perspectives
    of the same 32-bit memory space*. We can view the same `ipv4` address as either
    a 32-bit unsigned integer (**Little Endian** or **LE**) or four 8-bit unsigned
    integers in the common *dotted quad* notation. This provides a bitwise polymorphy
    that can be useful at the systems level.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`union`有两个成员，类型为`struct`和`uint32_t`，其中`struct`有四个`uint8_t`成员。这为我们提供了对相同的32位内存空间的两种不同视角。我们可以将相同的`ipv4`地址视为32位无符号整数（**小端**或**LE**）或四个8位无符号整数，使用常见的*点分十进制*表示法。这提供了一种在系统级别有用的位操作多态性。
- en: '`variant` doesn''t work like that. The `variant` class is a *tagged union*,
    where each datum is tagged with its type. If we store a value as `uint32_t`, we
    may only access it as `uint32_t`. This makes `variant` type safe but not a replacement
    for `union`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant`的行为并不像那样。`variant`类是一个*标记联合*，其中每个数据都带有其类型的标记。如果我们存储一个值为`uint32_t`，我们只能将其作为`uint32_t`访问。这使得`variant`类型安全，但不是`union`的替代品。'
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this recipe, we demonstrate the use of `std::variant` with a small catalogue
    of household pets of various species.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们展示了使用`std::variant`与各种物种的家庭宠物的小目录。
- en: 'We''ll start with a simple class to hold an `Animal`:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从包含`Animal`的简单类开始：
- en: '[PRE36]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The name of the animal and the sound that the animal makes are passed in the
    constructor.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 动物的名称和动物发出的声音通过构造函数传入。
- en: 'Individual species classes inherit from `Animal`:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个物种类从`Animal`继承：
- en: '[PRE37]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Each of these classes set the sound for their specific species by calling the
    parent constructor.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类中的每一个都通过调用父构造函数来为其特定物种设置声音。
- en: 'Now, we can define our `variant` type in an alias:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以在别名中定义我们的`variant`类型：
- en: '[PRE38]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This `variant` can hold any of the types, `Cat`, `Dog`, or `Wookie`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`variant`可以持有任何类型，`Cat`、`Dog`或`Wookie`。
- en: 'In `main()`, we create a `list` using our `v_animal` alias as the type:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`中，我们使用我们的`v_animal`别名作为类型创建一个`list`：
- en: '[PRE39]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Each element in the list is of a type included in the `variant` definition.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个元素都是`variant`定义中包含的类型。
- en: The `variant` class provides several different ways to access elements. First,
    we'll look at the `visit()` function.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variant`类提供了几种不同的方式来访问元素。首先，我们将查看`visit()`函数。'
- en: '`visit()` calls a *functor* with the object currently contained in the `variant`.
    First, let''s define a functor that accepts any of our pets:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit()`调用包含在`variant`中的对象的*函数对象*。首先，让我们定义一个接受我们任何宠物的函数对象：'
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is a simple functor class with overloads for each of the `Animal` sub-classes.
    We call it with `visit()`, with each of our `list` elements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数对象类，为每个`Animal`子类提供了重载。我们用`visit()`调用它，每个我们的`list`元素：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We get this output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这个输出：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `variant` class also provides an `index()` method:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variant`类还提供了一个`index()`方法：'
- en: '[PRE43]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each `variant` object is indexed, based on the order in which the types were
    declared in the template arguments. Our `v_animal` type was defined with `std::variant<Cat,
    Dog, Wookie>`, and these types are indexed as `0` – `2`, in that order.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`variant`对象都是基于模板参数中声明的类型顺序进行索引的。我们的`v_animal`类型是用`std::variant<Cat, Dog,
    Wookie>`定义的，这些类型按顺序索引为`0` – `2`。
- en: 'The `get_if<T>()` function tests a given element against a type:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_if<T>()` 函数测试给定元素与一个类型是否匹配：'
- en: '[PRE45]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `get_if<T>()` function returns a pointer if the type of the element matches
    `T`; otherwise, it returns `nullptr`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_if<T>()` 函数在元素类型匹配 `T` 时返回一个指针；否则，返回 `nullptr`。'
- en: 'Finally, the `holds_alternative<T>()` function returns `true` or `false`. We
    can use this to test a type against an element, without returning the element:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`holds_alternative<T>()` 函数返回 `true` 或 `false`。我们可以使用这个函数来测试一个类型与一个元素是否匹配，而不返回该元素：
- en: '[PRE47]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `std::variant` class is a single-object container. An instance of `variant<X,
    Y, Z>` must hold exactly one object of type `X`, `Y`, or `Z`. It holds both the
    value and the type of its current object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant` 类是一个单对象容器。`variant<X, Y, Z>` 的实例必须恰好包含一个 `X`、`Y` 或 `Z` 类型的对象。它同时包含其当前对象的值和类型。'
- en: 'The `index()` method tells us the type of the current object:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()` 方法告诉我们当前对象的类型：'
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `holds_alternative<T>()` non-member function returns `true` if `T` is the
    type of the current object:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`holds_alternative<T>()` 非成员函数如果 `T` 是当前对象的类型，则返回 `true`：'
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can retrieve the current object with the `get()` non-member function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `get()` 非成员函数来检索当前对象：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can combine the test for type and retrieval with the `get_if()` non-member
    function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `get_if()` 非成员函数将类型测试和检索结合起来：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `visit()` non-member function invokes a callable object with the current
    variant object as its single parameter:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit()` 非成员函数使用当前 `variant` 对象作为其单个参数调用一个可调用对象：'
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `visit()` function is the only way to retrieve an object without testing
    its type. In combination with a functor that can handle each type, this can be
    very flexible:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit()` 函数是检索对象而不测试其类型的唯一方法。结合一个可以处理每种类型的函数对象，这可以非常灵活：'
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果：
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Time events with std::chrono
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::chrono 计时事件
- en: The `std::chrono` library provides tools for measuring and reporting time and
    intervals.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono` 库提供了测量和报告时间和间隔的工具。'
- en: Many of these classes and functions were introduced with C++11\. There have
    been significant changes and updates for C++20, but at the time of writing, many
    of those updates are not yet implemented on the systems I've tested.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些类和函数是在 C++11 中引入的。C++20 有显著的变化和更新，但在撰写本文时，许多这些更新在我测试的系统上尚未实现。
- en: Using the `chrono` library, this recipe explores techniques for timing events.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `chrono` 库，本食谱探讨了计时事件的技巧。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The `system_clock` class is used for reporting the current date and time. The
    `steady_clock` and `high_resolution_clock` classes are used for timing events.
    Let''s look at the differences between these clocks:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_clock` 类用于报告当前日期和时间。`steady_clock` 和 `high_resolution_clock` 类用于计时事件。让我们看看这些时钟之间的区别：'
- en: 'Because these names can be long and unwieldy, we''ll use some type aliases
    throughout this recipe:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这些名称可能很长且难以处理，我们将在整个过程中使用一些类型别名：
- en: '[PRE56]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `duration` class represents an interval between two points in time. These
    aliases are convenient for using different intervals.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`duration` 类表示两个时间点之间的间隔。这些别名方便使用不同的间隔。'
- en: 'We can get the current time and date by using the `system_clock` class:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `system_clock` 类来获取当前时间和日期：
- en: '[PRE57]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `system_clock::now()` function returns a `time_point` object. The `<chrono>`
    library includes a `format()` specialization for `time_point` that uses `strftime()`
    format specifiers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_clock::now()` 函数返回一个 `time_point` 对象。`<chrono>` 库为 `time_point` 提供了一个
    `format()` 特化，它使用 `strftime()` 格式说明符。'
- en: 'The output is:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果为：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `<iomanip>` header includes `put_time()`, which works like `strftime()`
    for `ostream`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`<iomanip>` 头文件包括 `put_time()`，它类似于 `strftime()` 用于 `ostream`：'
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`put_time()` takes a pointer to a C-style `time_t*` value. `system_clock::to_time_t`
    converts a `time_point` object to `time_t`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`put_time()` 接受一个指向 C 风格 `time_t*` 值的指针。`system_clock::to_time_t` 将 `time_point`
    对象转换为 `time_t`。'
- en: 'This gives the same output as our `format()` example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的 `format()` 示例输出相同：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can also use `system_clock` to time an event. First, we need something to
    time. Here''s a function that counts prime numbers:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以使用 `system_clock` 来计时一个事件。首先，我们需要一个可以计时的东西。这里有一个计算素数的函数：
- en: '[PRE61]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This function counts the prime numbers between 2 and `0x1FFFF` (131,071), which
    should take a few seconds on most modern systems.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算 2 到 `0x1FFFF`（131,071）之间的素数，这在大多数现代系统上应该需要几秒钟。
- en: 'Now, we write a `timer` function to time our `count_primes()`:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们编写一个 `timer` 函数来计时我们的 `count_primes()`：
- en: '[PRE62]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This function takes an function `f` and returns `duration<double>`. We use `system_clock::now()`
    to mark the time before and after the call to `f()`. We take the difference between
    the two times and return it in a `duration` object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个函数 `f` 并返回 `duration<double>`。我们使用 `system_clock::now()` 标记 `f()` 调用之前和之后的时间。我们取两个时间之间的差值，并以
    `duration` 对象的形式返回它。
- en: 'We can call our `timer()` from `main()`, like this:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从 `main()` 中调用我们的 `timer()`，如下所示：
- en: '[PRE63]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This passes the `count_primes()` function to `timer()` and stores the `duration`
    object in `secs`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `count_primes()` 函数传递给 `timer()` 并将 `duration` 对象存储在 `secs` 中。
- en: 'Output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `count()` method on the `duration` object returns the duration in the specified
    units – in this case, `double`, representing *seconds* of duration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`duration` 对象上的 `count()` 方法返回指定单位内的持续时间 – 在这种情况下，`double`，表示持续时间的 *秒*。'
- en: This was run on a VM running *Debian* with GCC. The exact time will vary on
    different systems.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在运行 *Debian* 和 GCC 的虚拟机上运行的。确切时间会因不同系统而异。
- en: The `system_clock` class is designed to provide the current *wall clock* time.
    While its resolution may support timing purposes, it is not guaranteed to be *monotonic*.
    In other words, it may not always provide consistent *ticks* (timing intervals).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_clock` 类旨在提供当前的 *系统时钟* 时间。虽然其分辨率可能支持计时目的，但它不保证是 *单调的*。换句话说，它可能不会始终提供一致的
    *滴答*（计时间隔）。'
- en: 'The `chrono` library provides a more suitable clock in `steady_clock`. It has
    the same interface as `system_clock` but provides more reliable ticks for timing
    purposes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrono` 库在 `steady_clock` 中提供了一个更合适的时钟。它具有与 `system_clock` 相同的接口，但提供了更可靠的滴答，适用于计时目的：'
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`steady_clock` is designed to provide reliably consistent monotonic ticks,
    suitable for timing events. It uses a relative time reference, so it''s not useful
    for wall clock time. While `system_clock` measures by beginning from a fixed point
    in time (1 January 1970, 00:00 UTC), `steady_clock` uses a relative time.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`steady_clock` 是为了提供可靠一致的单调滴答而设计的，适用于计时事件。它使用相对时间参考，因此对于系统时钟时间来说没有用。虽然 `system_clock`
    从固定的时间点（1970 年 1 月 1 日，00:00 UTC）开始测量，但 `steady_clock` 使用相对时间。'
- en: Another option is `high_resolution_clock`, which provides the shortest tick
    period available on a given system but is not implemented consistently across
    different implementations. It may be an alias for `system_clock` or `steady_clock`,
    and it may or may not be monotonic. `high_resolution_clock` is not recommended
    for general-purpose use.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是 `high_resolution_clock`，它提供了给定系统上可用的最短滴答周期，但不是在不同实现中一致实现的。它可能是 `system_clock`
    或 `steady_clock` 的别名，并且可能或可能不是单调的。`high_resolution_clock` 不建议用于通用用途。
- en: 'Our `timer()` function returns `seconds`, which is an alias for `duration<double>`:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `timer()` 函数返回 `seconds`，它是 `duration<double>` 的别名：
- en: '[PRE66]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The duration class takes an optional second template parameter, a `std::ratio`
    class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间类接受一个可选的第二模板参数，一个 `std::ratio` 类：
- en: '[PRE67]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `<chrono>` header provides convenience types for many decimal ratios, including
    `milli` and `micro`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`<chrono>` 头文件提供了许多十进制比率的便利类型，包括 `milli` 和 `micro`：'
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If we require something else, we may provide our own:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要其他东西，我们可以提供自己的：
- en: '[PRE69]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`fps24` represents the number of frames of film shot at the standard 24 frames
    per second. The ratio is 1/24 of a second.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`fps24` 表示以每秒 24 帧的标准拍摄的电影帧数。该比率是秒的 1/24。'
- en: 'This allows us to easily convert between different ranges of duration:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够轻松地在不同的持续时间范围内进行转换：
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE71]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Because the `fps24` alias uses `unsigned long` instead of `double`, a type conversion
    is required. The `floor` function provides this by discarding the fractional part.
    `round()` and `ceil()` are also available in this context.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `fps24` 别名使用 `unsigned long` 而不是 `double`，需要进行类型转换。`floor` 函数通过丢弃小数部分来实现这一点。在此上下文中，`round()`
    和 `ceil()` 函数也是可用的。
- en: 'For convenience, the `chrono` library provides `format()` specializations for
    the standard `duration` ratios:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便，`chrono` 库为标准的 `duration` 比率提供了 `format()` 特殊化：
- en: '[PRE72]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE73]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: These results will vary on different implementations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果将因不同的实现而异。
- en: How it works…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are two major pieces to the `chrono` library, the *clock* classes and
    the `duration` class.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrono` 库有两个主要部分，*时钟* 类和 `duration` 类。'
- en: The clock classes
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时钟类
- en: 'The clock classes include:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟类包括：
- en: '`system_clock` – provides wall clock time.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_clock` – 提供系统时钟时间。'
- en: '`steady_clock` – provides guaranteed monotonic ticks for duration measurements.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steady_clock` – 提供了保证单调的持续时间测量滴答。'
- en: '`high_resolution_clock` – provides the shortest available tick period. It may
    be an alias of `system_clock` or `steady_clock` on some systems.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`high_resolution_clock`——提供最短的可用滴答周期。在某些系统上可能是`system_clock`或`steady_clock`的别名。'
- en: We use `system_clock` to display the current time and date. We use `steady_clock`
    to measure intervals.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`system_clock`来显示当前时间和日期。我们使用`steady_clock`来测量间隔。
- en: 'Each of the clock classes has a `now()` method that returns `time_point`, representing
    the current value of the clock. `now()` is a static member function, so it''s
    called on the class without instantiating an object:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个时钟类都有一个`now()`方法，它返回`time_point`，表示时钟的当前值。`now()`是一个静态成员函数，因此不需要实例化对象就可以调用：
- en: '[PRE74]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The std::duration class
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`std::duration`类'
- en: The `duration` class is used to hold a time interval – that is, the difference
    between two `time_point` objects. It is generally constructed with a `time_point`
    object's subtraction (`-`) operator.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`duration`类用于存储时间间隔——即两个`time_point`对象之间的差异。它通常使用`time_point`对象的减法运算符（`-`）构造。'
- en: '[PRE75]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `time_point` subtraction operator doubles as a constructor for `duration`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`time_point`减法运算符同时是`duration`的构造函数：'
- en: '[PRE76]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `duration` class has template parameters for type representation and a
    `ratio` object:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`duration`类有用于类型表示的模板参数和一个`ratio`对象：'
- en: '[PRE77]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `Period` template parameter defaults to a `ratio` of 1:1, which is seconds.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period`模板参数默认为1:1的`ratio`，即秒。'
- en: 'The library provides `ratio` aliases (such as `micro` and `milli`) for powers-of-10
    from `atto` (1/1,000,000,000,000,000,000) through `exa` (1,000,000,000,000,000,000/1).
    This allows us to create standard durations, as we did in our example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供了`ratio`别名（如`micro`和`milli`），用于从`atto`（1/1,000,000,000,000,000,000）到`exa`（1,000,000,000,000,000,000/1）的10的幂。这允许我们创建标准持续时间，就像我们在示例中所做的那样：
- en: '[PRE78]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `count()` method gives us the duration in the `Rep` type:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`方法给我们的是`Rep`类型的持续时间：'
- en: '[PRE79]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This allows us to easily access the duration for display or other purposes:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够轻松访问持续时间以进行显示或其他目的：
- en: '[PRE80]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Use fold expressions for variadic tuples
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用折叠表达式处理可变元组
- en: The `std::tuple` class is essentially a more complex, and less convenient, `struct`.
    The interface for `tuple` is cumbersome, although *class template argument deduction*
    and *structured binding* have made it somewhat easier.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::tuple`类本质上是一个更复杂、不太方便的`struct`。`tuple`的接口很繁琐，尽管*类模板参数推导*和*结构化绑定*使其变得稍微容易一些。'
- en: 'I tend to use `struct` before `tuple` for most applications, with one significant
    exception: the one real advantage of `tuple` is that it can be used with *fold
    expressions* in a variadic context.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于在大多数应用中使用`struct`而不是`tuple`，有一个显著的例外：`tuple`的一个真正优势是它可以在可变上下文中与*折叠表达式*一起使用。
- en: Fold expressions
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折叠表达式
- en: 'Designed to make it easier to expand a variadic parameter pack, *fold expressions*
    are a new feature with C++17\. Prior to fold expressions, expanding a parameter
    pack required a recursive function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 设计目的是为了使扩展可变参数包更容易，*折叠表达式*是C++17的一个新特性。在折叠表达式之前，扩展参数包需要一个递归函数：
- en: '[PRE81]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE82]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Using a fold expression, this is much simpler:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用折叠表达式，这要简单得多：
- en: '[PRE83]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Output:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE84]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'There are four types of fold expressions:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的折叠表达式：
- en: 'Unary right fold: `(args op ...)`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元右折叠：`(args op ...)`
- en: 'Unary left fold: `(... op args)`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元左折叠：`(... op args)`
- en: 'Binary right fold: `(args op ... op init)`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元右折叠：`(args op ... op init)`
- en: 'Binary left fold: `(init op ... op args)`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元左折叠：`(init op ... op args)`
- en: 'The expression in the example above is a *binary left fold*:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例中的表达式是一个*二元左折叠*：
- en: '[PRE85]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This expands to:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将展开为：
- en: '[PRE86]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Fold expressions are a great convenience for many purposes. Let's look at how
    we can use them with tuples.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠表达式在许多用途中都非常方便。让我们看看我们如何使用它们与元组一起。
- en: How to do it…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we''ll create a template function that operates on a tuple
    with varying numbers and types of elements:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个模板函数，它对一个具有不同数量和类型的元素元组进行操作：
- en: 'The heart of this recipe is a function that takes a tuple of unknown size and
    type and prints each element with `format()`:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个菜谱的核心是一个函数，它接受一个未知大小和类型的元组，并使用`format()`打印每个元素：
- en: '[PRE87]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The heart of this function is in the lambda expression. It uses the `index_sequence`
    object to generate a parameter pack of index values. We then use a fold expression
    to call `get<I>` with each index value. The templated lambda requires C++20.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的核心在于lambda表达式。它使用`index_sequence`对象生成一个索引值的参数包。然后我们使用折叠表达式调用每个索引值的`get<I>`。模板lambda需要C++20。
- en: You could use a separate function in place of the lambda, but I like keeping
    it in a single scope.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用一个单独的函数来代替lambda表达式，但我喜欢将其保持在单个作用域内。
- en: 'We can now call this from `main()` with a variety of tuples:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以从`main()`函数中用各种元组来调用这个函数：
- en: '[PRE88]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Output:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE89]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How it works…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The challenge with `tuple` is its restrictive interface. You can retrieve elements
    with `std::tie()`, with *structured bindings*, or the `std::get<>` function. None
    of these techniques are useful if you don't know the number and type of elements
    in the `tuple`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`的挑战在于其限制性的接口。你可以使用`std::tie()`、结构化绑定或`std::get<>`函数来检索元素。如果你不知道`tuple`中元素的数量和类型，这些技术都没有用。'
- en: 'We get around this limitation by using the `index_sequence` class. `index_sequence`
    is a specialization of `integer_sequence` that provides a parameter pack of the
    `size_t` elements, which we can use to index our `tuple`. We call our lambda function
    with `make_index_sequence` to set up a parameter pack in the lambda:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`index_sequence`类来克服这个限制。`index_sequence`是`integer_sequence`的一个特化，它提供了一个`size_t`元素的参数包，我们可以用它来索引我们的`tuple`。我们通过调用`make_index_sequence`来设置lambda中的参数包，以调用我们的lambda函数：
- en: '[PRE90]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The templated lambda is constructed with a parameter pack of `size_t` indexes
    for the `get()` function:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 模板lambda是用`get()`函数的`size_t`索引参数包构建的：
- en: '[PRE91]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `get()` function takes the index value as a template parameter. We use
    a *unary left fold expression* to call `get<I>()`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`函数将索引值作为模板参数。我们使用一个一元左折叠表达式来调用`get<I>()`：'
- en: '[PRE92]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The fold expression takes each element of the function's parameter pack and
    applies the comma operator. The right-hand side of the comma has a `format()`
    function that prints each element of the tuple.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠表达式将函数参数包中的每个元素取出来，并应用逗号运算符。逗号运算符的右侧有一个`format()`函数，它打印元组中的每个元素。
- en: This makes it possible to deduce the number of elements in the tuple, which
    makes it useable in a variadic context. Keep in mind that, as with template functions
    in general, the compiler will generate a separate specialization of this function
    for each combination of `tuple` parameters.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得推断元组中的元素数量成为可能，使其在可变参数上下文中可用。请注意，与模板函数一般一样，编译器将为`tuple`参数的每个组合生成此函数的单独特化。
- en: There's more…
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'We can use this technique for other tasks. For example, here''s a function
    that returns the sum of all the `int` values in a `tuple` of unknown size:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这种技术做其他任务。例如，这里有一个函数，它返回未知大小的`tuple`中所有`int`值的总和：
- en: '[PRE93]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can call this with several `tuple` objects of varying numbers of `int` values:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用不同数量的`int`值的`tuple`对象来调用这个函数：
- en: '[PRE94]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Output:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE95]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Manage allocated memory with std::unique_ptr
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::unique_ptr管理分配的内存
- en: '*Smart pointers* are an excellent tool for managing allocated *heap memory*.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*智能指针*是管理分配的*堆内存*的绝佳工具。'
- en: Heap memory is managed at the lowest level by the C functions, `malloc()` and
    `free()`. `malloc()` allocates a block of memory from the heap, and `free()` returns
    it to the heap. These functions do not perform initialization and do not call
    constructors or destructors. If you fail to return allocated memory to the heap
    with a call to `free()`, the behavior is undefined and often leads to memory leaks
    and security vulnerabilities.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存是由C函数`malloc()`和`free()`在最低级别管理的。`malloc()`从堆中分配一块内存，而`free()`将其返回到堆中。这些函数不执行初始化，也不调用构造函数或析构函数。如果你没有通过调用`free()`将分配的内存返回到堆中，其行为是未定义的，通常会导致内存泄漏和安全漏洞。
- en: C++ provides the `new` and `delete` operators to allocate and free heap memory,
    in place of `malloc()` and `free()`. The `new` and `delete` operators call object
    constructors and destructors but still do not manage memory. If you allocate memory
    with `new` and fail to free it with `delete`, you will leak memory.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了`new`和`delete`运算符来分配和释放堆内存，代替`malloc()`和`free()`。`new`和`delete`运算符调用对象构造函数和析构函数，但仍然不管理内存。如果你使用`new`分配内存，而没有使用`delete`释放它，你将导致内存泄漏。
- en: Introduced with C++14, smart pointers comply with the **Resource Acquisition
    Is Initialization** (**RAII**) idiom. This means that when memory is allocated
    for an object, that object's constructor is called. And when the object's destructor
    is called, the memory is automatically returned to the heap.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: C++14引入的智能指针符合**资源获取即初始化**（**RAII**）习惯用法。这意味着当为对象分配内存时，会调用该对象的构造函数。当调用对象的析构函数时，内存会自动返回到堆中。
- en: 'For example, when we create a new smart pointer with `make_unique()`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们使用`make_unique()`创建一个新的智能指针时：
- en: '[PRE96]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '`make_unique()` allocates memory for a `Thing` object, calls the `Thing` default
    constructor, constructs a `unique_ptr<Thing>` object, and returns the `unique_ptr`.
    When `p` goes out of scope, the `Thing` destructor is called, and the memory is
    automatically returned to the heap.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique()` 为 `Thing` 对象分配内存，调用 `Thing` 的默认构造函数，构造一个 `unique_ptr<Thing>`
    对象，并返回该 `unique_ptr`。当 `p` 超出作用域时，调用 `Thing` 的析构函数，并将内存自动返回到堆中。'
- en: 'Aside from the memory management, a smart pointer works very much like a primitive
    pointer:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内存管理外，智能指针的工作方式与原始指针非常相似：
- en: '[PRE97]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`unique_ptr` is a smart pointer that allows only one instance of the pointer.
    It may be moved, but it may not be copied. Let''s take a closer look at how to
    use `unique_ptr`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr` 是一种智能指针，它只允许指针存在一个实例。它可以被移动，但不能被复制。让我们更详细地看看如何使用 `unique_ptr`。'
- en: How to do it…
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this recipe, we examine `std::unique_ptr` with a demonstration class that
    prints when its constructors and destructor are called:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们通过一个在构造函数和析构函数被调用时打印的演示类来检查 `std::unique_ptr`。
- en: 'First, we''ll create a simple demonstration class:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的演示类：
- en: '[PRE98]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This class has a default constructor, a parameterized constructor, and a destructor.
    Each of these has a simple print statement to tell us what was called.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个默认构造函数、一个参数化构造函数和一个析构函数。每个都有简单的打印语句来告诉我们调用了什么。
- en: 'When we just construct a `unique_ptr`, it does not allocate memory or construct
    a managed object:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们仅构造一个 `unique_ptr` 时，它不会分配内存或构造一个托管对象：
- en: '[PRE99]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Output:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE100]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'When we use the `new` operator, it allocates memory and constructs a `Thing`
    object:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用 `new` 运算符时，它会分配内存并构造一个 `Thing` 对象：
- en: '[PRE101]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Output:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE102]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `new` operator constructs a `Thing` object by calling the default constructor.
    The `unique_ptr<Thing>` destructor calls the `Thing` destructor when the smart
    pointer reaches the end of its scope.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 运算符通过调用默认构造函数来构造 `Thing` 对象。当智能指针达到其作用域的末尾时，`unique_ptr<Thing>` 析构函数调用
    `Thing` 析构函数。'
- en: The `Thing` default constructor does not initialize the `thname` string, leaving
    its default value, `"unk"`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thing` 的默认构造函数没有初始化 `thname` 字符串，保留其默认值，`"unk"`。'
- en: 'We can use `make_unique()` to get the same result:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `make_unique()` 来得到相同的结果：
- en: '[PRE103]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Output:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE104]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The `make_unique()` helper function takes care of the memory allocation and
    returns a `unique_ptr` object. This is the recommended way to construct a `unique_ptr`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique()` 辅助函数负责内存分配并返回一个 `unique_ptr` 对象。这是构造 `unique_ptr` 的推荐方法。'
- en: 'Any arguments you pass to `make_unique()` are used in constructing the target
    object:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你传递给 `make_unique()` 的任何参数都用于构造目标对象：
- en: '[PRE105]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE106]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The parameterized constructor assigns a value to `thname`, so our `Thing` object
    is now `"Thing 1"`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化构造函数将值赋给 `thname`，因此我们的 `Thing` 对象现在是 `"Thing 1"`。
- en: 'Let''s write a function that takes a `unique_ptr<Thing>` argument:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们编写一个接受 `unique_ptr<Thing>` 参数的函数：
- en: '[PRE107]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If we try to pass a `unique_ptr` to this function, we get a compiler error:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将 `unique_ptr` 传递给这个函数，我们会得到编译器错误：
- en: '[PRE108]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Compiler error:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器错误：
- en: '[PRE109]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This is because the function call tries to make a copy of the `unique_ptr`
    object, but the `unique_ptr` copy constructor is *deleted* to prevent copying.
    The solution is to have the function take a `const&` reference:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为函数调用试图复制 `unique_ptr` 对象，但 `unique_ptr` 的复制构造函数被 *删除* 以防止复制。解决方案是让函数接受一个
    `const&` 引用：
- en: '[PRE110]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Output:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE111]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We can call `process_thing()` with a temporary object, which is immediately
    destroyed at the end of the function scope:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用临时对象调用 `process_thing()`，该临时对象在函数作用域结束时立即被销毁：
- en: '[PRE112]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Output:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE113]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: How it works…
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A *smart pointer* is simply an object that presents a pointer interface while
    owning and managing the resources of another object.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *智能指针* 简单来说是一个对象，它提供了一个指针接口，同时拥有和管理另一个对象资源。
- en: The `unique_ptr` class is distinguished by its deleted copy constructor and
    copy assignment operator, which prevents the smart pointer from being copied.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr` 类通过其删除的复制构造函数和复制赋值运算符而与众不同，这防止了智能指针被复制。'
- en: 'You may not copy a `unique_ptr`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能复制一个 `unique_ptr`：
- en: '[PRE114]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Compiler error:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器错误：
- en: '[PRE115]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'But you can move a `unique_ptr`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以移动一个 `unique_ptr`：
- en: '[PRE116]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: After the `move`, `p1` is invalid and `p2` is `"Thing 1"`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 移动后，`p1` 无效，而 `p2` 是 `"Thing 1"`。
- en: 'Output:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE117]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `unique_ptr` interface has a method to reset a pointer:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr` 接口有一个重置指针的方法：'
- en: '[PRE118]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Output:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE119]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `reset()` method may also be used to replace the managed object with another
    of the same type:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset()` 方法也可以用来用相同类型的另一个对象替换托管对象：'
- en: '[PRE120]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Output:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE121]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Share objects with std::shared_ptr
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 std::shared_ptr 共享对象
- en: The `std::shared_ptr` class is a smart pointer that owns its managed object
    and maintains a *use counter* to keep track of copies. This recipe explores the
    use of `shared_ptr` to manage memory while sharing copies of the pointer.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr`类是一个智能指针，它拥有其管理对象并维护一个*引用计数*来跟踪副本。这个配方探讨了使用`shared_ptr`来管理内存的同时共享指针副本。'
- en: Note
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more detail about smart pointers, see the introduction to the *Manage allocated
    memory with std::unique_ptr* recipe earlier in this chapter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 关于智能指针的更多详细信息，请参阅本章前面的*使用std::unique_ptr管理分配的内存*配方介绍。
- en: How to do it…
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we examine `std::shared_ptr` with a demonstration class that
    prints when its constructors and destructor are called:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们通过一个演示类来检查`std::shared_ptr`，该类在其构造函数和析构函数被调用时打印信息：
- en: 'First, we create a simple demonstration class:'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个简单的演示类：
- en: '[PRE122]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This class has a default constructor, a parameterized constructor, and a destructor.
    Each of these has a simple print statement to tell us what was called.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个默认构造函数、一个带参数的构造函数和一个析构函数。每个都有简单的打印语句来告诉我们调用了什么。
- en: 'The `shared_ptr` class works very much like other smart pointers, in that it
    may be constructed with the `new` operator or with its helper, the `make_shared()`
    function:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_ptr`类的工作方式与其它智能指针非常相似，它可以使用`new`运算符或其辅助函数`make_shared()`来构造：'
- en: '[PRE123]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Output:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE124]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The `make_shared()` function is recommended, as it manages the construction
    process and is less prone to error.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用`make_shared()`函数，因为它管理构造过程，并且更不容易出错。
- en: As with the other smart pointers, the managed object is destroyed, and its memory
    is returned to the heap when the pointer goes out of scope.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他智能指针一样，当指针超出作用域时，管理对象被销毁，其内存返回到堆中。
- en: 'Here''s a function to check the use count of a `shared_ptr` object:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一个函数来检查`shared_ptr`对象的引用计数：
- en: '[PRE125]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '`thname` is a member of the `Thing` class, so we access it through the pointer
    with the `p->` member dereference operator. The `use_count()` function is a member
    of the `shared_ptr` class, so we access it with the `p.` object member operator.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`thname`是`Thing`类的一个成员，因此我们通过指针使用`p->`成员解引用运算符来访问它。`use_count()`函数是`shared_ptr`类的一个成员，因此我们使用`p.`对象成员运算符来访问它。'
- en: 'Let''s call this with our pointers:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们的指针来调用这个函数：
- en: '[PRE126]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Output:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE127]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'When we make copies of our pointers, the use count increases, but no new objects
    are constructed:'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们复制我们的指针时，引用计数会增加，但不会构造新的对象：
- en: '[PRE128]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Output:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE129]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'When we check any of the other copies, we get the same result:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们检查其他任何副本时，我们得到相同的结果：
- en: '[PRE130]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Output:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE131]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Each pointer reports the same use count.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指针报告相同的引用计数。
- en: 'When the copies go out of scope, they are destroyed, and the use count is decremented:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当副本超出作用域时，它们被销毁，引用计数减少：
- en: '[PRE132]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Output:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE133]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Destroying a copy reduces the use count but does not destroy the managed object.
    The object is destroyed when the final copy goes out of scope and the use count
    reaches zero:'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁一个副本会减少引用计数，但不会销毁管理对象。对象在最后一个副本超出作用域且引用计数达到零时被销毁：
- en: '[PRE134]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Output:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE135]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Destroying `pb` (a copy) and `p1` (the original) leaves three copies of the
    pointer (`pa`, `bc`, and `pd`), so the managed object remains.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁`pb`（副本）和`p1`（原始），留下三个指针副本（`pa`、`bc`和`pd`），因此管理对象仍然存在。
- en: The remaining three pointer copies are destroyed at the end of the scope in
    which they were created. Then the object is destroyed and its memory returned
    to the heap.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的三个指针副本在它们被创建的作用域结束时被销毁。然后对象被销毁，其内存返回到堆中。
- en: How it works…
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `shared_ptr` class is distinguished by its management of multiple pointers
    to the same managed object.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`类以其对同一管理对象的多个指针的管理而区别于其他智能指针。'
- en: The `shared_ptr` object's copy constructor and copy assignment operator increment
    a *use counter*. The destructor decrements the use counter until it reaches zero,
    then destroys the managed object, and returns its memory to the heap.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`对象的复制构造函数和复制赋值运算符增加引用计数。析构函数减少引用计数，直到它达到零，然后销毁管理对象，并将其内存返回到堆中。'
- en: The `shared_ptr` class manages both the managed object and a heap-allocated
    *control block*. The control block contains the use counter, along with other
    housekeeping objects. The control block is managed and shared between copies along
    with the managed object. This allows the original `shared_ptr` object to cede
    control to its copies, so that the last remaining `shared_ptr` may manage the
    object and its memory.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr` 类管理托管对象和一个堆分配的 *控制块*。控制块包含使用计数器以及其他维护对象。控制块与托管对象一起被管理和共享。这允许原始
    `shared_ptr` 对象将其控制权转让给其副本，以便最后一个剩余的 `shared_ptr` 可以管理对象及其内存。'
- en: Use weak pointers with shared objects
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享对象与弱指针
- en: Strictly speaking, `std::weak_ptr` is not a smart pointer. Rather, it's an *observer*
    that operates in cooperation with `shared_ptr`. A `weak_ptr` object does not hold
    a pointer on its own.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`std::weak_ptr` 不是一个智能指针。相反，它是一个 *观察者*，与 `shared_ptr` 协作工作。`weak_ptr` 对象本身不持有指针。
- en: There are circumstances where `shared_ptr` objects may create dangling pointers
    or race conditions, which could lead to memory leaks or other problems. The solution
    is to use `weak_ptr` objects with `shared_ptr`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，`shared_ptr` 对象可能会创建悬垂指针或竞态条件，这可能导致内存泄漏或其他问题。解决方案是使用 `weak_ptr` 对象与 `shared_ptr`
    一起使用。
- en: How to do it…
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe, we examine the use of `std::weak_ptr` with `std::shared_ptr`,
    using a demonstration class that prints when its constructors and destructor are
    called.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们通过一个演示类来检查 `std::weak_ptr` 与 `std::shared_ptr` 的使用，该类在其构造函数和析构函数被调用时打印信息。
- en: 'We start with the same class we''ve used to demonstrate `shared_ptr` and `unique_ptr`:'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从之前用来演示 `shared_ptr` 和 `unique_ptr` 的相同类开始：
- en: '[PRE136]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This class has a default constructor, a parameterized constructor, and a destructor.
    Each of these has a simple print statement to tell us what was called.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个默认构造函数、一个参数化构造函数和一个析构函数。每个都有简单的打印语句来告诉我们调用了什么。
- en: 'We also need a function to examine a `weak_ptr` object:'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来检查一个 `weak_ptr` 对象：
- en: '[PRE137]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: A `weak_ptr` does not operate as a pointer on its own; it requires the use of
    a `shared_ptr`. The `lock()` function returns a `shared_ptr` object, which can
    then be used to access the managed object.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr` 本身不作为指针操作；它需要使用 `shared_ptr`。`lock()` 函数返回一个 `shared_ptr` 对象，然后可以使用它来访问托管对象。'
- en: 'Because `weak_ptr` requires an associated `shared_ptr`, we''ll start `main()`
    by creating a `shared_ptr<Thing>` object. When we create a `weak_ptr` object without
    assigning the `shared_ptr`, the `expired` flag is initially set:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `weak_ptr` 需要一个关联的 `shared_ptr`，所以我们将在 `main()` 中创建一个 `shared_ptr<Thing>`
    对象。当我们创建一个没有分配 `shared_ptr` 的 `weak_ptr` 对象时，`expired` 标志最初被设置为：
- en: '[PRE138]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Output:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE139]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The `make_shared()` function allocates memory and constructs a `Thing` object.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_shared()` 函数分配内存并构造一个 `Thing` 对象。'
- en: The `weak_ptr<Thing>` declaration constructs a `weak_ptr` object without assigning
    a `shared_ptr`. So, when we check the `expired` flag, it's `true`, indicating
    that there is no associated `shared_ptr`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr<Thing>` 声明构建一个没有分配 `shared_ptr` 的 `weak_ptr` 对象。因此，当我们检查 `expired`
    标志时，它是 `true`，表示没有关联的 `shared_ptr`。'
- en: The `get_weak_thing()` function is not able to obtain a lock because there is
    no `shared_ptr` available.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_weak_thing()` 函数无法获取锁，因为没有可用的 `shared_ptr`。'
- en: 'When we assign the `shared_ptr` to the `weak_ptr`, we can use the `weak_ptr`
    to access the managed object:'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们将 `shared_ptr` 分配给 `weak_ptr` 时，我们可以使用 `weak_ptr` 来访问托管对象：
- en: '[PRE140]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Output:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE141]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The `get_weak_thing()` function is now able to obtain a lock and access the
    managed object. The `lock()` method returns a `shared_ptr`, and the `use_count()`
    reflects the fact that there is now a second `shared_ptr` managing the `Thing`
    object.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_weak_thing()` 函数现在能够获取锁并访问托管对象。`lock()` 方法返回一个 `shared_ptr`，而 `use_count()`
    反映了现在有一个额外的 `shared_ptr` 正在管理 `Thing` 对象。'
- en: The new `shared_ptr` is destroyed at the end of the `get_weak_thing()` scope.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `shared_ptr` 在 `get_weak_thing()` 范围结束时被销毁。
- en: 'The `weak_ptr` class has a constructor that takes a `shared_ptr` for one-step
    construction:'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weak_ptr` 类有一个构造函数，它接受一个 `shared_ptr` 以进行一步构造：'
- en: '[PRE142]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Output:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE143]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The `use_count()` is `2` again. Remember that the previous `shared_ptr` was
    destroyed when its enclosing `get_weak_thing()` scope ended.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`use_count()` 再次变为 `2`。记住，之前的 `shared_ptr` 在其封装的 `get_weak_thing()` 范围结束时已被销毁。'
- en: 'When we reset `shared_ptr`, its associated `weak_ptr` objects are expired:'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们重置 `shared_ptr` 时，其关联的 `weak_ptr` 对象已过期：
- en: '[PRE144]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Output:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE145]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: After the `reset()`, the use count reaches zero, and the managed object is destroyed
    and the memory released.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`reset()`之后，使用计数达到零，托管对象被销毁并且内存被释放。
- en: How it works…
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A `weak_ptr` object is an *observer* that holds a non-owning reference to a
    `shared_ptr` object. The `weak_ptr` observes the `shared_ptr` so that it knows
    when the managed object is, and is not, available. This allows use of a `shared_ptr`
    in circumstances where you may not always know if the managed object is active.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr`对象是一个*观察者*，它持有对`shared_ptr`对象的非拥有引用。`weak_ptr`观察`shared_ptr`，以便知道托管对象何时可用，何时不可用。这允许在不知道托管对象是否活跃的情况下使用`shared_ptr`。'
- en: 'The `weak_ptr` class has a `use_count()` function that returns the use count
    of `shared_ptr`, or `0` if the managed object has been deleted:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr`类有一个`use_count()`函数，它返回`shared_ptr`的使用计数，或者如果托管对象已被删除，则返回`0`：'
- en: '[PRE146]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '`weak_ptr` also has an `expired()` function that reports if the managed object
    has been deleted:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr`还有一个`expired()`函数，可以报告托管对象是否已被删除：'
- en: '[PRE147]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The `lock()` function is the preferred way to access the shared pointer. It
    checks `expired()` to see if the managed object is available. If so, it returns
    a new `shared_ptr` that shares ownership with the managed object. Otherwise, it
    returns an empty `shared_ptr`. It does all that as one atomic operation:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock()`函数是访问共享指针的首选方式。它会检查`expired()`以确定托管对象是否可用。如果是，它返回一个新的`shared_ptr`，该`shared_ptr`与托管对象共享所有权。否则，它返回一个空的`shared_ptr`。它将这些操作作为一个原子操作来完成：'
- en: '[PRE148]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: There's more…
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One important use case for `weak_ptr` is when there''s a possibility of circular
    references to `shared_ptr` objects. For example, consider the case of two classes
    that link to each other (perhaps in a hierarchy):'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr`的一个重要用例是在存在`shared_ptr`对象循环引用的可能性时。例如，考虑两个相互链接的类（可能在层次结构中）的情况：'
- en: '[PRE149]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'We have print statements in the destructors, so we can see when the objects
    are destroyed. We can now create two objects that point at each other with `shared_ptr`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在析构函数中添加了打印语句，这样我们就可以看到对象何时被销毁。我们现在可以创建两个对象，它们使用`shared_ptr`相互指向：
- en: '[PRE150]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'When we run this, notice that the destructors are never called:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，请注意析构函数永远不会被调用：
- en: '[PRE151]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Because the objects maintain shared pointers that refer to each other, the use
    counts never reach zero, and the managed objects are never destroyed.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 因为对象维护指向彼此的共享指针，使用计数永远不会达到零，托管对象也永远不会被销毁。
- en: 'We can resolve this problem by changing one of the classes to use a `weak_ptr`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其中一个类改为使用`weak_ptr`来解决这个问题：
- en: '[PRE152]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The code in `main()` remains the same, and we get this output:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`中的代码保持不变，我们得到以下输出：'
- en: '[PRE153]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: By changing one `shared_ptr` to a `weak_ptr`, we have resolved the circular
    reference, and the objects are now properly destroyed at the end of their scope.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将一个`shared_ptr`更改为`weak_ptr`，我们解决了循环引用的问题，并且对象现在在它们的范围结束时被正确销毁。
- en: Share members of a managed object
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享托管对象的成员
- en: 'The `std::shared_ptr` class provides an *aliasing constructor* to share a pointer
    managed by another unrelated pointer:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr`类提供了一个*别名构造函数*来共享由另一个无关指针管理的指针：'
- en: '[PRE154]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: This returns an aliased `shared_ptr` object that uses the resources of `ref`
    but returns a pointer to `ptr`. The `use_count` is shared with ref. The deleter
    is shared with `ref`. But `get()` returns `ptr`. This allows us to share a member
    of a managed object without sharing the entire object, and without allowing the
    entire object to be deleted while we're still using the member.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了一个别名`shared_ptr`对象，它使用`ref`的资源，但返回`ptr`的指针。`use_count`与`ref`共享。析构器与`ref`共享。但`get()`返回`ptr`。这允许我们在不共享整个对象的情况下共享托管对象的成员，并且在我们使用成员时不会删除整个对象。
- en: How to do it…
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we create a managed object and share members of that object:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个托管对象并共享该对象的成员：
- en: 'We start with a class for the managed object:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一个托管对象的类开始：
- en: '[PRE155]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: This class has two members, `string` types for `name` and `sound` of the `animal`
    object. We also have print statements for the constructor and the destructor.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个成员，用于`animal`对象的`name`和`sound`的`string`类型。我们还在构造函数和析构函数中添加了打印语句。
- en: 'Now, we need a function to create an animal but only share its name and sound:'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个函数来创建一个动物，但只共享它的名称和声音：
- en: '[PRE156]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This function creates `shared_ptr` with an `animal` object, constructed with
    a name and a sound. We then create aliased `shared_ptr` objects for the name and
    sound. When we return the `name` and `sound` pointers, the `animal` pointer goes
    out of scope. It is not deleted because the aliased pointers keep the use count
    from reaching zero.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建带有 `animal` 对象的 `shared_ptr`，该对象使用名称和声音构造。然后我们为名称和声音创建别名 `shared_ptr` 对象。当我们返回
    `name` 和 `sound` 指针时，`animal` 指针超出作用域。它没有被删除，因为别名指针保持了使用计数不会达到零。
- en: 'In our `main()` function, we call `make_animal()` and inspect the results:'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `main()` 函数中，我们调用 `make_animal()` 并检查结果：
- en: '[PRE157]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Output:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE158]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: We can see that the aliased pointers each show a `use_count` of `2`. When the
    `make_animal()` function creates the aliased pointers, they each increase the
    use count of the `animal` pointer. When the function ends, the `animal` pointer
    goes out of scope, leaving its use count at 2, which is reflected in the aliased
    pointers. The aliased pointers go out of scope at the end of `main()`, which allows
    the `animal` pointer to be destroyed.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每个别名指针都显示了一个 `use_count` 的 `2`。当 `make_animal()` 函数创建别名指针时，它们各自增加了 `animal`
    指针的使用计数。当函数结束时，`animal` 指针超出作用域，其使用计数保持在 2，这反映在别名指针上。别名指针在 `main()` 函数的末尾超出作用域，这允许
    `animal` 指针被销毁。
- en: How it works…
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The *aliased* shared pointer seems a bit abstract, but it's simpler than it
    appears.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 别名共享指针看起来有点抽象，但实际上比看起来简单。
- en: 'A shared pointer uses a *control block* to manage its resources. One control
    block is associated with one managed object and is shared among the pointers that
    share that object. The control block generally contains:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 共享指针使用一个 *控制块* 来管理其资源。一个控制块与一个托管对象相关联，并由共享该对象的指针共享。控制块通常包含：
- en: A pointer to the managed object
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向托管对象的指针
- en: The *deleter*
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*删除器*'
- en: The *allocator*
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配器*'
- en: The number of `shared_ptr` objects that own the managed object (this is the
    *use count*)
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有托管对象的 `shared_ptr` 对象的数量（这是 *使用计数*）
- en: The number of `weak_ptr` objects that refer to the managed object
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向托管对象的 `weak_ptr` 对象的数量
- en: In the case of an aliased shared pointer, the control block includes the pointer
    to the *aliased object*. Everything else remains the same.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在别名共享指针的情况下，控制块包括指向 *别名对象* 的指针。其他一切保持不变。
- en: Aliased shared pointers participate in the use count, just like non-aliased
    shared pointers, preventing the managed object from being destroyed until the
    use count reaches zero. The deleter is not changed, so it destroys the managed
    object.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 别名共享指针参与使用计数，就像非别名共享指针一样，防止托管对象在计数达到零之前被销毁。删除器没有改变，因此它销毁托管对象。
- en: Important Note
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is possible to use any pointer to construct an aliased shared pointer. Usually,
    the pointer refers to a member within the aliased object. If the aliased pointer
    does not refer to an element of the managed object, you will need to manage its
    construction and destruction separately.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何指针来构造别名共享指针。通常，该指针指向别名对象内的成员。如果别名指针不指向托管对象的一个元素，您将需要单独管理其构造和销毁。
- en: Compare random number engines
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较随机数生成器
- en: The `random` library provides a selection of random number generators, each
    with different strategies and properties. In this recipe, we examine a function
    to compare the different options by creating a histogram of their output.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 库提供了一系列随机数生成器，每个生成器都有不同的策略和属性。在本例中，我们通过创建输出直方图来比较这些不同选项的功能。'
- en: How to do it…
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we compare the different random number generators provided
    by the C++ `random` library:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们比较了 C++ `random` 库提供的不同随机数生成器：
- en: 'We start with some constants to provide uniform parameters for the random number
    generators:'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一些常量开始，为随机数生成器提供统一的参数：
- en: '[PRE159]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '`n_samples` is the number of samples to examine, `n_partitions` is the number
    of partitions in which to display the samples, and `n_max` is the maximum size
    of a bar in the histogram (this will vary some due to rounding).'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_samples` 是要检查的样本数量，`n_partitions` 是显示样本的分区数量，`n_max` 是直方图中条形图的最大尺寸（这会因为四舍五入而略有变化）。'
- en: These numbers provide a reasonable display of the differences between the engines.
    Increasing the ratio of *samples* versus *partitions* tends to smooth out the
    curves and obscure the differences between the engines.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字提供了对引擎之间差异的合理展示。增加 *样本* 与 *分区* 的比率往往会使曲线平滑，并模糊引擎之间的差异。
- en: 'This is the function that collects random number samples and displays a histogram:'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是收集随机数样本并显示直方图的函数：
- en: '[PRE160]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In a nutshell, this function stores a histogram of collected samples in a `vector`.
    It then displays the histogram as a series of asterisks on the console.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个函数将收集到的样本直方图存储在`vector`中。然后，它在控制台上以一系列星号的形式显示直方图。
- en: 'We call `histogram()` from `main()`, like this:'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们像这样从`main()`中调用`histogram()`：
- en: '[PRE161]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Output:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '![Figure 8.1 – A screenshot of output from the first two random number engines'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 来自前两个随机数发生器的输出截图'
- en: '](img/B18267_08_01.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_08_01.jpg)'
- en: Figure 8.1 – A screenshot of output from the first two random number engines
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 来自前两个随机数发生器的输出截图
- en: This screenshot shows histograms of the first two random number engines. Your
    output will vary.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了前两个随机数发生器的直方图。你的输出可能会有所不同。
- en: 'If we raise the value of `n_samples` to 100,000, you''ll see that the variance
    between engines becomes more difficult to discern:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`n_samples`的值提高到100,000，你会发现引擎之间的方差变得更加难以辨别：
- en: '![Figure 8.2 – A screenshot of output with 100,000 samples'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 包含100,000个样本的输出截图'
- en: '](img/B18267_08_02.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18267_08_02.jpg)'
- en: Figure 8.2 – A screenshot of output with 100,000 samples
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 包含100,000个样本的输出截图
- en: How it works…
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each of the random number engines has a functor interface that returns the
    next random number in the sequence:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 每个随机数发生器都有一个返回序列中下一个随机数的函数接口：
- en: '[PRE162]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The functor returns a random value, evenly distributed between the `min()` and
    `max()` values. All the random number engines have this interface in common.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回一个随机值，均匀分布在`min()`和`max()`值之间。所有随机数发生器都有这个共同的接口。
- en: 'The `histogram()` function takes advantage of this uniformity by using the
    class of the random number engine in a template:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`histogram()`函数利用这种均匀性，通过在模板中使用随机数发生器的类：'
- en: '[PRE163]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: (**RNG** is a common abbreviation for **Random Number Generator**. The library
    documentation refers to these classes as *engines*, which is synonymous with RNG
    for our purposes.)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: （**RNG**是**随机数生成器**的常见缩写。库文档将这些类称为*引擎*，在我们的目的中与RNG同义。）
- en: 'We instantiate an object with the RNG class and create a histogram in a `vector`:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用RNG类实例化一个对象，并在`vector`中创建一个直方图：
- en: '[PRE164]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: This allows us to easily compare the results of the various random number engines
    with this technique.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够轻松地使用这种技术比较各种随机数引擎的结果。
- en: There's more…
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Each of the random number engines in the library have different methodologies
    and characteristics. When you run the histogram multiple times, you'll notice
    that most of the engines have the same distribution each time they're run. That's
    because they are *deterministic* – that is, they generate the same sequence of
    numbers each time. `std::random_device` is non-deterministic on most systems.
    You can use it to seed one of the other engines if you need more variation. It
    is also common to seed an RNG with the current date and time.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 库中的每个随机数发生器都有不同的方法和特性。当你多次运行直方图时，你会注意到大多数引擎每次运行时都有相同的分布。这是因为它们是*确定性的* – 即每次都生成相同的数字序列。`std::random_device`在大多数系统中是非确定性的。如果你需要更多的变化，你可以用它来初始化其他引擎之一。通常也用当前日期和时间来初始化RNG。
- en: The `std::default_random_engine` is a suitable choice for most purposes.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::default_random_engine`是大多数情况下的合适选择。'
- en: Compare random number distribution generators
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较随机数分布生成器
- en: The C++ Standard Library provides a selection of random number distribution
    generators, each with its own properties. In this recipe, we examine a function
    to compare the different options by creating a histogram of their output.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了一系列随机数分布生成器，每个生成器都有其自身的特性。在这个菜谱中，我们通过创建它们输出的直方图来比较不同的选项。
- en: How to do it…
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Like the random number engines, the distribution generators have some common
    interface elements. Unlike the random number engines, the distribution generators
    have a variety of properties to set. We can create a template function to print
    a histogram of the various distributions, but the initializations of the various
    distribution generators vary significantly:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 与随机数发生器一样，分布生成器有一些共同的接口元素。与随机数发生器不同，分布生成器有各种属性可以设置。我们可以创建一个模板函数来打印各种分布的直方图，但各种分布生成器的初始化差异很大：
- en: 'We start with some constants:'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一些常数开始：
- en: '[PRE165]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The `n_samples` constant is the number of samples to generate for each histogram
    – in this case, 10,000\.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_samples` 常数是每个直方图要生成的样本数量 – 在这种情况下，10,000。'
- en: The `n_max` constant is used as a divisor while generating our histograms.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_max` 常数在生成我们的直方图时用作除数。'
- en: 'Our histogram function takes a distribution generator as an argument and prints
    a histogram for that distribution algorithm:'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的直方图函数接受一个分布生成器作为参数，并打印出该分布算法的直方图：
- en: '[PRE166]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The `dist_histogram()` function uses a `map` to store the histogram. It then
    displays the histogram as a series of asterisks on the console.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist_histogram()` 函数使用 `map` 来存储直方图。然后，它在控制台上以一系列星号的形式显示直方图。'
- en: 'We call `dist_histogram()` from `main()`, like this:'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们像这样从 `main()` 中调用 `dist_histogram()`：
- en: '[PRE167]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Calling the `dist_histogram()` function is more complex than it was for the
    random number generators. Each random distribution class has a different set of
    parameters, according to its algorithm.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `dist_histogram()` 函数比随机数生成器要复杂。每个随机分布类都有其算法的不同参数集。
- en: For the full list, refer to the `distribution.cpp` file in the GitHub archive.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整列表，请参阅 GitHub 存档中的 `distribution.cpp` 文件。
- en: 'Output:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '![Figure 8.3 – A screenshot of random distribution histograms'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 随机分布直方图的截图'
- en: '](img/B18267_08_03.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B18267_08_03.jpg](img/B18267_08_03.jpg)'
- en: Figure 8.3 – A screenshot of random distribution histograms
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 随机分布直方图的截图
- en: Each of the distribution algorithms produces very different output. You will
    want to experiment with the different options for each random distribution generator.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分布算法都会产生非常不同的输出。您可能需要为每个随机分布生成器尝试不同的选项。
- en: How it works…
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Each of the distribution generators has a functor that returns the next value
    in the random distribution:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分布生成器都有一个返回随机分布中下一个值的函数对象：
- en: '[PRE168]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The functor takes a random number generator (RNG) object as an argument:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象接受一个随机数生成器 (RNG) 对象作为参数：
- en: '[PRE169]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: For our purposes, we're using the `std::default_random_engine` for our RNG.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们使用 `std::default_random_engine` 作为我们的随机数生成器 (RNG)。
- en: As with the RNG histogram, this is a useful tool to visualize the various random
    distribution algorithms available in the `random` library. You will want to experiment
    with the various parameters available for each algorithm.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 与 RNG 直方图一样，这是一个有用的工具，可以可视化 `random` 库中可用的各种随机分布算法。您可能需要尝试每个算法可用的各种参数。
