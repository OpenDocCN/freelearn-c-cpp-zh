- en: Chapter 4.  Loops, Arrays, Switch, Enumerations, and Functions – Implementing
    Game Mechanics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。循环，数组，开关，枚举和函数-实现游戏机制
- en: This chapter probably has more C++ information than any other chapter in the
    book. It is packed with fundamental concepts that will move our understanding
    on enormously. It will also begin to shed light on some of the murky areas that
    we have been skipping over a little bit, such as functions and game loops.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可能包含的C++信息比书中的任何其他章节都要多。它充满了将极大地推动我们的理解的基本概念。它还将开始阐明我们一直略微忽略的一些模糊领域，例如函数和游戏循环。
- en: Once we have explored a whole list of C++ language necessities we will then
    use everything we know to make the main game mechanic, the tree branches, move.
    By the end of this chapter we will be ready for the final phase and the completion
    of Timber!!!.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们探索了整个C++语言必需品清单，然后我们将利用我们所知道的一切来使主要游戏机制-树枝移动。在本章结束时，我们将准备进入最后阶段并完成《伐木者》。
- en: 'We will be looking at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究以下主题：
- en: Loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: Arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Making decisions with switch
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开关进行决策
- en: Enumerations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Getting started with functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用函数
- en: Creating and moving the tree branches
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和移动树枝
- en: Loops
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'In programming, we often need to do the same thing more than once. The obvious
    example that we have seen so far is our game loop. With all the code stripped
    out, our game loop looks like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们经常需要做同样的事情超过一次。到目前为止，我们看到的明显例子是我们的游戏循环。在剥离所有代码的情况下，我们的游戏循环看起来像这样：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are a few different types of loop and we will look at the most commonly
    used. The correct term for this type of loop is a `while` loop.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同类型的循环，我们将看看最常用的。这种类型的循环的正确术语是“while”循环。
- en: while loops
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while循环
- en: The `while` loop is quite straightforward. Think back to the `if` statements
    and their expressions that evaluated to either `true` or `false`. We can use the
    exact same combination of operators and variables in the conditional expression
    of our `while` loops.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “while”循环非常简单。回想一下“if”语句及其表达式，这些表达式评估为“true”或“false”。我们可以在“while”循环的条件表达式中使用相同的运算符和变量的组合。
- en: 'As with `if` statements, if the expression is `true` the code executes. The
    difference in comparison a `while` loop, however, is that the C++ code within
    it will continue to execute until the condition is `false`. Take a look at this
    code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与“if”语句一样，如果表达式为“true”，则代码执行。然而，与“while”循环相比，C++代码将继续执行，直到条件为“false”。看看这段代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is what is happening in the previous code. Outside of the `while` loop,
    `int numberOfZombies` is declared and initialized to `100`. Then the `while` loop
    begins. Its conditional expression is `numberOfZombies > 0`. Therefore the `while`
    loop will continue looping through the code in its body until the condition evaluates
    to `false`. This means that the code above will execute `100` times.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以前的代码中发生的事情。在“while”循环之外，声明并初始化“int numberOfZombies”为“100”。然后“while”循环开始。它的条件表达式是“numberOfZombies
    > 0”。因此，“while”循环将继续循环执行其主体中的代码，直到条件评估为“false”。这意味着上面的代码将执行100次。
- en: On the first pass through the loop, `numberOfZombies` equals `100` then 99 then
    98 and so on. But once `numberOfZOmbies` is equal to zero, it is of course, no
    longer greater than zero. Then the code will break out of the `while` loop and
    continue to run, after the closing curly brace.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的第一次通过中，“numberOfZombies”等于100，然后等于99，然后等于98，依此类推。但一旦“numberOfZOmbies”等于零，当然不再大于零。然后代码将跳出“while”循环并继续运行，在闭合大括号之后。
- en: 'Just like an `if` statement, it is possible that the `while` loop will not
    execute even once. Take a look at this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像“if”语句一样，“while”循环可能不会执行一次。看看这个：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Moreover, there is no limit to the complexity of the expression or the amount
    of code that can go in the loop body. Consider this hypothetical variation of
    a game loop:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，表达式的复杂性或可以放入循环主体的代码量没有限制。考虑游戏循环的这种假设变体：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous `while` loop would continue to execute until either `playerLives`
    or `alienShips` was equal to zero. As soon as one of those conditions occurred,
    the expression would evaluate to `false`, and the program would continue to execute
    from the first line of code after the `while` loop.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的“while”循环将继续执行，直到“playerLives”或“alienShips”之一等于零。一旦发生其中一个条件，表达式将评估为“false”，程序将从“while”循环之后的第一行代码继续执行。
- en: 'It is worth noticing that, once the body of the loop has been entered, it will
    always complete at least once, even if the expression evaluates to `false`, part
    way through, as it is not tested again until the code tries to start another pass.
    For example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一旦进入循环的主体，即使表达式在中途评估为“false”，它也将至少完成一次，因为在代码尝试开始另一个传递之前不会再次测试。例如：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous loop body will execute once. We can also set up a `while` loop
    that will run forever, unsurprisingly called an **infinite loop**. Here is an
    example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的循环体将执行一次。我们还可以设置一个永远运行的“while”循环，毫不奇怪地称为**无限循环**。这是一个例子：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you find the above loop confusing, just think of it literally. A loop executes
    when its condition is `true`. Well, `true` is always `true` and will therefore
    keep executing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得上面的循环令人困惑，只需字面理解。当条件为“true”时，循环执行。嗯，“true”总是“true”，因此将继续执行。
- en: Breaking out of a while loop
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳出while循环
- en: 'We might use an infinite loop so that we can decide when to exit the loop from
    within its body, rather than in the expression. We would do this by using the
    `break` keyword, when we are ready to leave the loop body. Perhaps it would look
    like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会使用无限循环，以便我们可以决定何时从循环中退出，而不是在表达式中。当我们准备离开循环主体时，我们将使用“break”关键字来做到这一点。也许会像这样：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You might also have been able to guess that we can combine any of the C++ decision
    making tools such as `if`, `else`, and another we will learn shortly, `switch`,
    within our `while` loops and other loop types as well. Consider this example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也能猜到，我们可以在 `while` 循环和其他循环类型中结合使用任何 C++ 决策工具，比如 `if`、`else`，以及我们即将学习的 `switch`。考虑这个例子：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We could go on for a long time looking at the various permutations of C++ `while`
    loops, but at some point we want to get back to making games. So let's move on
    to another type of loop.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花很长时间来研究 C++ `while` 循环的各种排列，但在某个时候我们想要回到制作游戏。所以让我们继续前进，看看另一种类型的循环。
- en: for loops
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for 循环
- en: 'The `for` loop has a slightly more complicated syntax than a `while` loop,
    because it takes three parts to set one up. Have a look at the code first then
    we will break it apart:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环的语法比 `while` 循环稍微复杂一些，因为它需要三个部分来设置。先看看代码，然后我们将把它分解开来：'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here is what all the parts of the `for` loop condition do.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `for` 循环条件的所有部分的作用。
- en: '`for(`declaration and initialization`;` condition`;` change before each iteration`)`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`for(`声明和初始化`;` 条件`;` 每次迭代前更改`)`'
- en: To clarify further, here is a table to explain all of the three key parts as
    they appear in the previous `for` loop example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步澄清，这里有一个表格来解释前面 `for` 循环例子中的所有三个关键部分。
- en: '| **Part** | **Description** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **部分** | **描述** |'
- en: '| Declaration and initialization | We create a new `int` variable `i` and initialize
    it to 0 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 声明和初始化 | 我们创建一个新的 `int` 变量 `i`，并将其初始化为 0 |'
- en: '| Condition | Just like the other loops, it refers to the condition that must
    be `true` for the loop to execute |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 就像其他循环一样，它指的是必须为循环执行的条件 |'
- en: '| Change after each pass through loop | In the example, `x ++` means that 1
    is added/incremented to `x` on each pass |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 循环通过每次迭代后更改 | 在这个例子中，`x ++` 表示每次迭代时 `x` 增加/递增 1 |'
- en: 'We can vary `for` loops to do many more things. Here is another simple example
    that counts down from 10:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改变 `for` 循环来做更多的事情。下面是另一个简单的例子，从 10 开始倒数：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `for` loop takes control of initialization, condition evaluation, and the
    control variable upon itself. We will use `for` loops in our game, later this
    chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环控制初始化、条件评估和控制变量。我们将在本章后面在我们的游戏中使用 `for` 循环。'
- en: Arrays
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: If a variable is a box in which we can store a value of a specific type, like
    `int`, `float`, or `char`, then we can think of an array as a whole row of boxes.
    The row of boxes can be of almost any size and type, including objects of classes.
    However, all the boxes must be of the same type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量是一个可以存储特定类型值的盒子，比如 `int`、`float` 或 `char`，那么我们可以把数组看作是一整行盒子。盒子的行可以是几乎任何大小和类型，包括类的对象。然而，所有的盒子必须是相同的类型。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The limitation of having to use the same type in each box can be circumvented,
    to an extent, once we learn some more advanced C++ in the final project.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终项目中，一旦我们学习了更高级的 C++，就可以规避在每个盒子中使用相同类型的限制。
- en: 'This array sounds like it could have been useful for our clouds from [Chapter
    2](ch02.html "Chapter 2. Variables, Operators, and Decisions – Animating Sprites"):
    *Variables, Operators, and Decisions - Animating Sprites*. So how do we go about
    creating and using an array?'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组听起来可能对我们在[第2章](ch02.html "第2章。变量、运算符和决策 - 动画精灵")中的云有用：*变量、运算符和决策 - 动画精灵*。那么我们如何创建和使用数组呢？
- en: Declaring an array
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个数组
- en: 'We can declare an array of `int` type variables like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样声明一个 `int` 类型变量的数组：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we have an array called `someInts` that can store ten `int` values. At the
    moment, however, it is empty.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为 `someInts` 的数组，可以存储十个 `int` 值。然而，目前它是空的。
- en: Initializing the elements of an array
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化数组的元素
- en: 'To add values into the elements of an array, we can use the type of syntax
    we are already familiar with, combined with some new syntax, known as **array
    notation**. In this next code, we store the value of `99` into the first element
    of the array:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向数组的元素添加值，我们可以使用我们已经熟悉的类型的语法，结合一些新的语法，称为**数组表示法**。在下面的代码中，我们将值 `99` 存储到数组的第一个元素中：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To store a value of `999` at the second element we write this code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要在第二个元素中存储值 `999`，我们写下这段代码：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can store a value of `3` at the last element as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将值 `3` 存储在最后一个元素中，如下所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the elements of an array always start at zero and go up to the size
    of the array minus 1\. Similarly to ordinary variables, we can manipulate the
    values stored in an array. The only difference is that we would use the array
    notation to do so as, although our array has a name, `someInts`, the individual
    elements do not have names.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数组的元素始终从零开始，直到数组大小减 1。与普通变量类似，我们可以操作数组中存储的值。唯一的区别是我们会使用数组表示法来做到这一点，因为虽然我们的数组有一个名字
    `someInts`，但是单独的元素没有名字。
- en: 'In this next code we add the first and second elements together and store the
    answer in the third:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将第一个和第二个元素相加，并将答案存储在第三个元素中：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Arrays can also interact seamlessly with regular variables, such as in this
    following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以与常规变量无缝交互，比如下面的例子：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Quickly initializing the elements of an array
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速初始化数组的元素
- en: 'We can quickly add values to elements such as this example using a `float`
    array:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速地向元素添加值，比如这个使用 `float` 数组的例子：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now the values `3.14`, `1.63` and `99.0` are stored in the first, second, and
    third positions respectively. Remember that when using array notation to access
    these values we would use [0], [1] and [2].
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在值 `3.14`，`1.63` 和 `99.0` 分别存储在第一、第二和第三位置。请记住，使用数组表示法访问这些值时，我们将使用 [0]、[1] 和
    [2]。
- en: 'There are other ways to initialize the elements of an array. This slightly
    abstract example shows using a `for` loop to put the values 0 through 9 into the
    `uselessArray` array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法来初始化数组的元素。这个稍微抽象的例子展示了使用 `for` 循环将值 0 到 9 放入 `uselessArray` 数组中：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code assumes that `uslessArray` had previously been initialized to hold
    at least `10` `int` variables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码假设 `uslessArray` 之前已经被初始化为至少包含 `10` 个 `int` 变量。
- en: So what do these arrays really do for our games?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么这些数组对我们的游戏到底有什么作用呢？
- en: 'We can use arrays anywhere that a regular variable can be used. For example,
    they could be used in an expression such as in the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何常规变量可以使用的地方使用数组。例如，它们可以在表达式中使用，如下所示：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Perhaps the biggest benefit of arrays in game code was hinted at the start
    of this section. Arrays can hold objects (instances of classes). Imagine that
    we have a `Zombie` class and we want to store a whole bunch of them. We could
    do so as we do in this hypothetical example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在游戏代码中的最大好处可能是在本节开始时暗示的。数组可以保存对象（类的实例）。假设我们有一个`Zombie`类，并且我们想要存储大量的`Zombie`。我们可以像在这个假设的例子中那样做：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `horde` array now holds a load of instances of the `Zombie` class. Each
    one is a separate, living (kind of), breathing, and self-determining `Zombie`
    object. We could then loop through the `horde` array, each pass through the game
    loop, moving the zombies, checking if their heads have met with an ax, or if they
    have managed to catch the player.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`horde`数组现在保存了大量`Zombie`类的实例。每个实例都是一个独立的、活着的（有点），呼吸着的、自主决定的`Zombie`对象。然后我们可以循环遍历`horde`数组，在游戏循环的每一次通过中，移动僵尸，检查它们的头是否被斧头砍中，或者它们是否设法抓住了玩家。'
- en: Arrays, had we known about them at the time, would have been perfect for handling
    our clouds. We could have had as many clouds as we wanted and written less code
    than we did for our three measly clouds.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当时我们知道数组，它们将非常适合处理我们的云。我们可以拥有任意数量的云，并且编写的代码比我们为我们的三朵微不足道的云所做的要少。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To check out this improved cloud code in full, and in action, look at the enhanced
    version of Timber!!! (the code and the playable game) in the download bundle.
    Or you can try to implement the clouds using arrays yourself before looking at
    the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的改进的云代码，并且看它实际运行，可以查看下载包中《伐木工》（代码和可玩游戏）的增强版本。或者您可以在查看代码之前尝试使用数组实现云。
- en: The best way to get a feel for all this array stuff is to see it in action.
    And we will, when we implement our tree branches.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有这些数组内容的最佳方法是看它们的实际应用。当我们实现我们的树枝时，我们将会看到它们的应用。
- en: For now we will leave our cloud code as it is so that we can get back to adding
    features to the game as soon as possible. But first let's look at a bit more C++
    decision making with `switch`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将保留我们的云代码，以便尽快回到游戏中添加功能。但首先让我们再看一下使用`switch`进行更多C++决策的内容。
- en: Making decisions with switch
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`switch`做决策
- en: We have already seen `if`, which allows us to make a decision whether to execute
    a block of code based upon the result of its expression. Sometimes a decision
    in C++ can be better made in other ways.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`if`，它允许我们根据表达式的结果来决定是否执行一段代码块。有时，在C++中做决定可能有其他更好的方法。
- en: 'When we have to make a decision based on a clear list of possible outcomes,
    which doesn''t involve complex combinations or wide ranges of values, then `switch`
    is usually the way to go. We start a `switch` decision as we can see in the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须基于一系列可能的结果做出决定时，其中不涉及复杂的组合或广泛的数值范围，通常情况下会使用`switch`。我们可以在以下代码中看到`switch`决策的开始：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the previous example, `expression` could be an actual expression or just
    a variable. Then, within the curly braces, we can make decisions based on the
    result of the expression or the value of the variable. We do this with the `case`
    and `break` keywords:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`expression`可以是一个实际的表达式或一个变量。然后，在花括号内，我们可以根据表达式的结果或变量的值做出决定。我们可以使用`case`和`break`关键字来实现这一点：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can see in the previous abstract example that, each `case` states a possible
    result and each `break` denotes the end of that `case` and the point at which
    execution leaves the `switch` block.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的抽象例子中，您可以看到，每个`case`表示一个可能的结果，每个`break`表示该`case`的结束以及执行离开`switch`块的地方。
- en: 'We can also, optionally, use the `default` keyword without a value, to run
    some code in case none of the `case` statements evaluate to `true`. Here is an
    example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以选择使用`default`关键字而不带值，以便在没有任何`case`语句评估为`true`时运行一些代码。以下是一个例子：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a final and less abstract example for `switch`, consider a retro text adventure
    where the player enters a letter such as `''n''`, `''e''`, `''s''`, or `''w''`
    to move North, East, South, or West. A `switch` block could be used to handle
    each possible input from the player, as we can see in this example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`switch`的最后一个不太抽象的例子，考虑一个复古的文本冒险游戏，玩家输入一个字母，比如`'n'`、`'e'`、`'s'`或`'w'`来向北、东、南或西移动。`switch`块可以用来处理玩家的每个可能的输入，就像我们在这个例子中看到的那样：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The best way of understanding everything we have learned about `switch` will
    be when we put it into action along with all the other new concepts we are learning.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们学到的关于`switch`的一切最好的方法是将它与我们正在学习的所有其他新概念一起应用。
- en: Class enumerations
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类枚举
- en: An enumeration is a list of all the possible values in a logical collection.
    C++ enumerations are a great way of, well, enumerating things. For example, if
    our game uses variables, which can only be in a specific range of values, and
    if those values could logically form a collection or a set, then enumerations
    are probably appropriate to use. They will make your code clearer and less error-prone.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是逻辑集合中所有可能值的列表。C++枚举是列举事物的好方法。例如，如果我们的游戏使用的变量只能在特定范围的值中，而且这些值在逻辑上可以形成一个集合或一组，那么枚举可能是合适的。它们将使您的代码更清晰，更不容易出错。
- en: To declare a class enumeration in C++ we use two keywords, `enum` and `class`,
    together, followed by the name of the enumeration, followed by the values the
    enumeration can contain, enclosed in a pair of curly braces `{...}`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中声明类枚举，我们使用两个关键字`enum`和`class`，然后是枚举的名称，然后是枚举可以包含的值，用一对花括号`{...}`括起来。
- en: 'As an example, examine this enumeration declaration. Note that it is conventional
    to declare the possible values from the enumeration all in uppercase:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，检查这个枚举声明。请注意，按照惯例，将枚举的可能值全部大写声明是常见的。
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note, at this point, we have not declared any instances of `zombieType`, just
    the type itself. If that sounds odd, think about it like this: SFML created the
    `Sprite`, `RectangleShape`, and `RenderWindow` classes, but to use any of those
    classes we had to declare an object/instance of the class.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此时我们还没有声明任何`zombieType`的实例，只是类型本身。如果这听起来有点奇怪，可以这样想：SFML创建了`Sprite`、`RectangleShape`和`RenderWindow`类，但要使用这些类中的任何一个，我们必须声明一个对象/实例。
- en: 'At this point we have created a new type called `zombieTypes`, but we have
    no instances of it. So let''s create them now:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们已经创建了一个名为`zombieTypes`的新类型，但我们还没有它的实例。所以现在让我们创建它们：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next is a sneak preview of the type of code we will soon be adding to Timber!!!.
    We will want to track which side of the tree a branch or the player is on, so
    we will declare an enumeration called `side`, as in the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对我们即将添加到Timber!!!中的代码类型的 sneak preview。我们将想要跟踪树的哪一侧有分支或玩家，因此我们将声明一个名为`side`的枚举，如以下示例所示：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We could position the player on the left as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将玩家定位在左侧，如下所示：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We could make the fourth level (arrays start from zero) of an array of branch
    positions have no branch at all, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使分支位置数组的第四级（数组从零开始）根本没有分支，如下所示：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can use enumerations in expressions as well:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在表达式中使用枚举：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will look at one more vital C++ topic and then we will get back to coding
    the game.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再看一个重要的C++主题，然后我们将回到编写游戏的代码。
- en: Getting started with functions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用函数
- en: 'So what exactly are C++ functions? A function is a collection of variables,
    expressions, and **control flow statements** (loops and branches). In fact, any
    of the code we have learnt about in the book so far can be used in a function.
    The first part of a function that we write is called the **signature**. Here is
    an example function signature:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么C++函数到底是什么？函数是一组变量、表达式和**控制流语句**（循环和分支）。事实上，我们迄今为止在书中学到的任何代码都可以在函数中使用。我们编写的函数的第一部分称为**签名**。以下是一个示例函数签名：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: "If you add an opening and closing pair of curly braces `{â\x80¦}` with some\
    \ code that the function actually performs then we have a complete function, a\
    \ definition:"
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一对大括号`{...}`，里面包含一些函数实际执行的代码，那么我们就有了一个完整的函数，一个定义：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We could then use our new function in another part of our code, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在代码的其他部分使用我们的新函数，如下所示：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we use a function we say that we **call** it. At the point where we call
    `bombPlayer`, our program's execution branches to the code contained within that
    function. The function will run until it reaches the end or is told to `return`.
    Then the code will continue running from the first line after the function call.
    We have already been using the functions that SFML provides. What is different
    here is that we will learn to write and call our own functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用一个函数时，我们说我们**调用**它。在我们调用`bombPlayer`的地方，我们的程序的执行分支到该函数中包含的代码。函数将运行直到达到结尾或被告知`return`。然后代码将从函数调用后的第一行继续运行。我们已经在使用SFML提供的函数。这里不同的是，我们将学习编写和调用我们自己的函数。
- en: 'Here is another example of a function, complete with the code to make the function
    return to the code that called it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个函数的例子，包括使函数返回到调用它的代码的代码：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The call to use the above function could look like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 调用上述函数的方式可能如下所示：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Obviously, we don't need to write functions to add two variables together, but
    the example helps us see a little further into the workings of functions. First
    we pass in the values `2` and `4`. In the function signature the value `2` is
    assigned to `int a`, and the value `4` is assigned to `int b`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不需要编写函数来将两个变量相加，但这个例子帮助我们更深入地了解函数的工作原理。首先我们传入值`2`和`4`。在函数签名中，值`2`被赋给`int
    a`，值`4`被赋给`int b`。
- en: Within the function body, the variables `a` and `b` are added together and used
    to initialize the new variable `int answer`. The line `return answer;` does just
    that. It returns the value stored in `answer` to the calling code, causing `myAnswer`
    to be initialized with the value `6`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，变量`a`和`b`相加并用于初始化新变量`int answer`。行`return answer;`就是这样。它将存储在`answer`中的值返回给调用代码，导致`myAnswer`被初始化为值`6`。
- en: Notice that each of the function signatures in the examples above varies a little.
    The reason for this is that the C++ function signature is quite flexible, allowing
    us to build exactly the functions we require.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面示例中的每个函数签名都有所不同。之所以如此，是因为C++函数签名非常灵活，允许我们构建我们需要的函数。
- en: Exactly how the function signature defines how the function must be called and
    if/how the function must return a value, deserves further discussion. Let's give
    each part of that signature a name so we can break it into parts and learn about
    them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名的确切方式定义了函数必须如何被调用以及函数必须如何返回值，这值得进一步讨论。让我们给该签名的每个部分命名，这样我们就可以将其分解成部分并学习它们。
- en: 'Here is a function signature with its parts described by their formal, technical
    terms:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个函数签名，其各部分由其正式的技术术语描述：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And here are a few examples we can use for each of those parts:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以用于每个部分的一些示例：
- en: '**Return-type**: `bool`, `float`, `int` and so on, or any C++ type or expression'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回类型**：`bool`、`float`、`int` 等，或任何C++类型或表达式'
- en: '**Name of function**: `bombPlayer`, `shootLazers`, `setCoordinates`, `addAToB`
    and so on'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数名称**：`bombPlayer`, `shootLazers`, `setCoordinates`, `addAToB` 等等'
- en: '**Parameters**: `(int number, bool hitDetected)`, `(int x, int y)` `(float
    a, float b)`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：`(int number, bool hitDetected)`, `(int x, int y)` `(float a, float
    b)`'
- en: Now let's look at each part in turn.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们依次看看每个部分。
- en: Function return types
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数返回类型
- en: 'The return type, as the name suggests, is the type of the value that will be
    returned from the function to the calling code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型，顾名思义，是从函数返回到调用代码的值的类型：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In our slightly dull, but useful, `addAtoB` example previously, the return type
    in the signature is `int`. The function `addAToB` sends back, or returns, to the
    code that called it, a value that will fit in an `int` variable. The return type
    can be any C++ type we have seen so far, or one of the ones we haven't seen yet.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们稍微沉闷但有用的`addAtoB`示例中，签名中的返回类型是`int`。函数`addAToB`将一个值返回给调用它的代码，这个值将适合在一个`int`变量中。返回类型可以是我们到目前为止看到的任何C++类型，或者是我们还没有看到的类型之一。
- en: 'A function does not have to return a value at all however. In this case the
    signature must use the `void` keyword as the return type. When the `void` keyword
    is used, the function body must not attempt to return a value as this will cause
    an error. It can, however, use the `return` keyword without a value. Here are
    some combinations of return type and the use of the `return` keyword that are
    valid:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，函数不一定要返回一个值。在这种情况下，签名必须使用`void`关键字作为返回类型。当使用`void`关键字时，函数体不得尝试返回一个值，否则将导致错误。但是，它可以使用没有值的`return`关键字。以下是一些返回类型和`return`关键字的组合：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another possibility is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能性如下：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following code gives us yet more examples of possible functions. Be sure
    to read the comments as well as the code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码给出了更多可能的函数示例。一定要阅读注释以及代码：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The last function example above, `detectCollision` is a glimpse into the near
    future of our C++ code, and demonstrates that we can also pass in  user-defined
    types, called **objects**, into functions to perform calculations on them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的最后一个函数示例`detectCollision`是我们C++代码即将到来的一个预览，并且演示了我们也可以将用户定义的类型，称为**对象**，传递到函数中对它们进行计算。
- en: 'We could call each of the functions above, in turn, like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样依次调用上面的每个函数：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Don't worry about the odd-looking syntax regarding the `detectCollision` function,
    we will see real code like this, quite soon. Simply, we are using the return value
    (`true` or `false`) as the expression, directly in an `if` statement.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心关于`detectCollision`函数的奇怪语法，我们很快就会看到像这样的真实代码。简单地说，我们将使用返回值（`true`或`false`）作为表达式，直接在`if`语句中。
- en: Function names
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数名称
- en: 'The function name, when we design our own function, can be almost anything
    at all. But it is best to use words, usually verbs, to clearly explain what the
    function will do. For example, look at this function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称，当我们设计自己的函数时，可以是几乎任何东西。但最好使用单词，通常是动词，来清楚地解释函数将要做什么。例如，看看这个函数：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The above is perfectly legal, and will work, but these next function names
    are much clearer:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例是完全合法的，并且可以工作，但是下面的函数名称更加清晰：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, let's take a closer look at how we share some values with a function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更仔细地看一下如何与函数共享一些值。
- en: Function parameters
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'We know that a function can return a result to the calling code. What if we
    need to share some data values from the calling code with the function? **Parameters**
    allow us to share values with the function. We have actually already seen examples
    of parameters while looking at return types. We will look at the same example
    but a little more closely:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道函数可以将结果返回给调用代码。如果我们需要与函数共享一些来自调用代码的数据值呢？**参数**允许我们与函数共享值。实际上，我们在查看返回类型时已经看到了参数的示例。我们将更仔细地看一下相同的示例：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Above, the parameters are `int a` and `int b`. Notice that, in the first line
    of the function body, we use `a + b` as if they are already declared and initialized
    variables. Well, that's because they are. The parameters in the function signature
    are their declaration and the code that calls the function initializes them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，参数是`int a`和`int b`。请注意，在函数主体的第一行中，我们使用`a + b`，就好像它们已经声明和初始化了变量一样。那是因为它们确实是。函数签名中的参数是它们的声明，调用函数的代码初始化它们。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Important jargon note**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要的行话说明**'
- en: 'Notice that we are referring to the variables in the function signature brackets
    `(int a, int b)` as parameters. When we pass values into the function from the
    calling code, these values are called arguments. When the arguments arrive they
    are called parameters and are used to initialize real, usable variables: `int
    returnedAnswer = addAToB(10,5);`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在函数签名括号`(int a, int b)`中引用的变量被称为参数。当我们从调用代码中将值传递到函数中时，这些值被称为参数。当参数到达时，它们被称为参数，并用于初始化真正可用的变量：`int
    returnedAnswer = addAToB(10,5);`
- en: Also, as we have partly seen in previous examples, we don't have to just use
    `int` in our parameters. We can use any C++ type. We can also use as many parameters
    as necessary to solve our problem, but it is good practice to keep the parameter
    list as short and therefore manageable as possible.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在先前的示例中部分看到的，我们不必只在参数中使用`int`。我们可以使用任何C++类型。我们还可以使用尽可能少的参数列表来解决我们的问题，但是将参数列表保持短并且易于管理是一个很好的做法。
- en: As we will see in future chapters, we have left a few of the cooler uses of
    functions out of this introductory tutorial, so that we can learn about related
    C++ concepts before we take the topic of functions further.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在未来的章节中看到的，我们已经在这个入门教程中留下了一些更酷的函数用法，这样我们就可以在进一步学习函数主题之前学习相关的C++概念。
- en: The function body
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数主体
- en: 'The body is the part we have been kind of avoiding with comments such as:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 主体部分是我们一直在避免的部分，比如：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: But actually, we know exactly what to do here already! Any C++ code we have
    learned about so far will work in the body of a function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，我们已经完全知道在这里该做什么！到目前为止，我们学到的任何C++代码都可以在函数体中工作。
- en: Function prototypes
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数原型
- en: We have seen how to code a function and we have seen how to call one as well.
    There is one more thing we need to do, however, to make them work. All functions
    must have a **prototype**. A prototype is what makes the compiler aware of our
    function; without a prototype, the entire game will fail to compile. Fortunately,
    prototypes are straightforward.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何编写函数，也看到了如何调用函数。然而，我们还需要做一件事才能使它们工作。所有函数都必须有一个**原型**。原型是使编译器意识到我们的函数的东西；没有原型，整个游戏将无法编译。幸运的是，原型很简单。
- en: 'We can simply repeat the function''s signature, followed by a semicolon. The
    caveat is that the prototype must appear before any attempt to call or define
    the function. So the absolutely simplest example of a fully usable function in
    action is as follows. Look carefully at the comments and where in the code the
    different parts of the function appear:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地重复函数的签名，后面跟一个分号。但是要注意的是，原型必须出现在任何尝试调用或定义函数之前。因此，一个完全可用的函数的最简单示例如下。仔细看看注释以及函数的不同部分在代码中的位置：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'What the previous code demonstrates is the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了以下内容：
- en: The prototype is before the `main` function
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型在`main`函数之前
- en: The call to use the function is, as we might expect, inside the `main` function
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数的调用，正如我们可能期望的那样，位于`main`函数内部
- en: The definition is after/outside the `main` function
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义在`main`函数之后/外部
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we can omit the function prototype and go straight to the definition
    when the definition occurs before the function is used. As our code becomes longer
    and spreads across multiple files, however, this will almost never happen. We
    will use separate prototypes and definitions all the time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当定义出现在函数使用之前时，我们可以省略函数原型直接进入定义。然而，随着我们的代码变得越来越长并且跨越多个文件，这几乎永远不会发生。我们将一直使用单独的原型和定义。
- en: Let's see how we can keep our functions organized.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何保持我们的函数有组织性。
- en: Organizing functions
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织函数
- en: It's well worth pointing out that, if we have multiple functions, especially
    if they are fairly long, our `.cpp` file will quickly become unwieldy. This defeats
    part of the objective that functions are intended for. The solution that we will
    see in the next project, is that we can add all of our function prototypes to
    our very own header file (`.hpp` or `.h`). Then we can code all of our functions
    in another  `.cpp` file, and then simply add another `#include...` directive in
    our main `.cpp` file. In this way we can use any number of functions without adding
    any of their code (prototype or definition) to our main code file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，如果我们有多个函数，特别是如果它们相当长，我们的`.cpp`文件很快就会变得难以控制。这违背了函数的意图。我们将在下一个项目中看到的解决方案是，我们可以将所有函数原型添加到我们自己的头文件（`.hpp`或`.h`）中。然后我们可以在另一个`.cpp`文件中编写所有函数的代码，然后在我们的主`.cpp`文件中简单地添加另一个`#include...`指令。通过这种方式，我们可以使用任意数量的函数，而不需要将它们的任何代码（原型或定义）添加到我们的主代码文件中。
- en: Function gotcha!
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数陷阱！
- en: Another point that we should discuss about functions is **scope**. If we declare
    a variable in a function, either directly or as one of the parameters, then that
    variable is not usable/visible outside the function. Furthermore, any variables
    declared outside the function cannot be seen/used inside the function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该讨论的另一点是**作用域**。如果我们在函数中声明一个变量，无论是直接声明还是作为参数之一，那么该变量在函数外部是不可用/可见的。此外，函数外部声明的任何变量在函数内部也是看不到/使用不了的。
- en: The way we should share values between function code and calling code is through
    the parameters/arguments and the return value.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该通过参数/参数和返回值在函数代码和调用代码之间共享值。
- en: When a variable is not available, because it is from another function, it is
    said to be out of scope. When it is available and usable, it is said to be in
    scope.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量不可用，因为它来自另一个函数，就说它是不在作用域内。当它可用和可用时，就说它在作用域内。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Actually, variables declared within any block in C++, are only in scope within
    that block! This includes loops and `if` blocks as well. A variable declared at
    the top of `main` is in scope anywhere in `main`. A variable declared in the game
    loop is only in scope within the game loop, and so on. A variable declared within
    a function or other block is called a **local** variable. The more code we write,
    the more this will make sense. Every time we come across an issue in our code
    regarding scope, I will discuss it to make things clear. There will be one such
    issue coming up in the next section. And there are some more C++ staples that
    blow this issue wide open. They are called **references** and **pointers** and
    we will learn about them in [Chapter 7](ch07.html "Chapter 7. C++ References,
    Sprite Sheets, and Vertex Arrays"): C++ *References, Sprite Sheets, and Vertex
    Arrays*and [Chapter 8](ch08.html "Chapter 8. Pointers, the Standard Template Library,
    and Texture Management"): *Pointers,the Standard Template Library, and Texture
    Management*, respectively.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在C++中，只有在块内声明的变量才在该块内有效！这包括循环和`if`块。在`main`的顶部声明的变量在`main`中的任何地方都是有效的。在游戏循环中声明的变量只在游戏循环内有效，依此类推。在函数或其他块中声明的变量称为**局部**变量。我们写的代码越多，这一点就越有意义。每当我们在代码中遇到作用域问题时，我都会讨论一下，以澄清事情。在下一节中将会出现这样的问题。还有一些C++的基本知识，会让这个问题变得更加明显。它们被称为**引用**和**指针**，我们将在[第7章](ch07.html
    "第7章。C++引用、精灵表和顶点数组")中学习：C++ *引用、精灵表和顶点数组*和[第8章](ch08.html "第8章。指针、标准模板库和纹理管理")中学习：*指针、标准模板库和纹理管理*。
- en: Final word on functions - for now
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的最终话-暂时
- en: There is a lot more we could learn about functions but we know enough about
    them already to implement the next part of our game. And don't worry if all the
    technical terms such as parameters, signatures and definitions, and so on have
    not completely sunk in. The concepts will become clearer when we start to use
    them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数，我们还有很多东西可以学习，但我们已经了解足够的知识来实现游戏的下一部分。如果所有技术术语，如参数、签名和定义等等，还没有完全理解，不要担心。当我们开始使用它们时，概念会变得更清晰。
- en: Absolute final word on functions - for now
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的终极最后一句话-暂时
- en: 'It has probably not escaped your attention that we have been calling functions,
    especially SFML functions, by appending the name of an object, a period before
    the function name, as in the following example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们一直在调用函数，特别是SFML函数，通过在函数名之前附加对象的名称和一个句号，如下例所示：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: And yet, our entire discussion of functions saw us calling functions without
    any objects. We can write functions as part of a class or simply as a standalone
    function. When we write a function as part of a class, we need an object of that
    class to call the function, and when we have a standalone function we don't.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们对函数的整个讨论都是在没有任何对象的情况下调用函数。我们可以将函数编写为类的一部分，也可以将其编写为独立的函数。当我们将函数编写为类的一部分时，我们需要该类的对象来调用函数，而当我们有一个独立的函数时，我们不需要。
- en: 'We will write a standalone function in a minute and we will write classes with
    functions starting in [Chapter 6](ch06.html "Chapter 6.  Object-Oriented Programming,
    Classes, and SFML Views"): *Object-Oriented Programming, Classes, and SFML Views*.
    Everything we know so far about functions is relevant in both cases.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一分钟内编写一个独立的函数，并且我们将在[第6章](ch06.html "第6章。面向对象编程、类和SFML视图")中编写以函数开头的类：*面向对象编程、类和SFML视图*。到目前为止，我们对函数的所有了解在这两种情况下都是相关的。
- en: Growing the branches
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生长树枝
- en: Next, as I have been promising for around the last seventeen pages, we will
    use all the new C++ techniques to draw and move some branches on our tree.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如我在过去大约十七页中一直承诺的那样，我们将使用所有新的C++技术来绘制和移动树上的一些树枝。
- en: 'Add this code outside the `main` function. Just to be absolutely clear, I mean
    before the code `int main()`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到`main`函数之外。为了绝对清楚，我的意思是在代码`int main()`之前：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We just achieved quite a few things with that new code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚用新代码实现了很多事情：
- en: First, we wrote a function prototype for a function called `updateBranches`.
    We can see that it does not return a value (`void`) and it takes an `int` argument
    called `seed`. We will write the function definition soon and we will then see
    exactly what it does.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们为一个名为`updateBranches`的函数声明了一个函数原型。我们可以看到它不返回值（`void`），并且它接受一个名为`seed`的`int`参数。我们将很快编写函数定义，然后我们将看到它确切地做了什么。
- en: Next, we declare a constant `int` called `NUM_BRANCHES` and initialize it to
    `6`. There will be six moving branches on the tree and we will soon see how `NUM_BRANCHES`
    will be useful to us.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们声明了一个名为`NUM_BRANCHES`的常量`int`，并将其初始化为`6`。树上将有六个移动的树枝，很快我们将看到`NUM_BRANCHES`对我们有多有用。
- en: Following this, we declare an array of `Sprite` objects called `branches` that
    can hold six Sprites.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们声明了一个名为`branches`的`Sprite`对象数组，可以容纳六个精灵。
- en: After that, we declare a new enumeration called `side` with three possible values,
    `LEFT`, `RIGHT`, and `NONE`. This will be used to describe the position of individual
    branches as well as the player, in a few places throughout our code.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们声明了一个名为`side`的新枚举，有三个可能的值，`LEFT`、`RIGHT`和`NONE`。这将用于描述个别树枝的位置，以及在我们的代码中的一些地方描述玩家的位置。
- en: Finally, in the previous new code, we initialize an array of `side` types, with
    a size of `NUM_BRANCHES` (6). To be clear about what this achieves; we will have
    an array called `branchPositions` with six values in it. Each of these values
    is of the type `side`, which can be either, `LEFT`, `RIGHT`, or `NONE`.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在之前的新代码中，我们初始化了一个`side`类型的数组，大小为`NUM_BRANCHES`（6）。为了清楚地说明这实现了什么；我们将有一个名为`branchPositions`的数组，其中包含六个值。这些值中的每一个都是`side`类型，可以是`LEFT`、`RIGHT`或`NONE`。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, what you really want to know is why the constant, the two arrays,
    and the enumeration were declared outside the `main` function. By declaring them
    above `main` they now have **global scope**. Or, describing it another way, the
    constant, the two arrays, and the enumeration have scope for the entire game.
    This will mean we can access and use them all anywhere in the `main` function
    and in the `updateBranches` function. Note that it is good practice to make all
    variables as local to where they are actually used as possible. It might seem
    useful to make everything global but this leads to hard-to-read and error-prone
    code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你真正想知道的是为什么常量、两个数组和枚举被声明在`main`函数之外。通过在`main`之上声明它们，它们现在具有**全局范围**。或者，换句话说，常量、两个数组和枚举在整个游戏中都有范围。这意味着我们可以在`main`函数和`updateBranches`函数中的任何地方访问和使用它们。请注意，将所有变量尽可能地局部化到实际使用它们的地方是一个好的做法。将所有东西都变成全局变量可能看起来很有用，但这会导致难以阅读和容易出错的代码。
- en: Preparing the branches
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备树枝
- en: 'Now we will prepare our six `Sprite` objects and load them into the `branches`
    array. Add the highlighted code just before our game loop:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将准备好我们的六个`Sprite`对象，并将它们加载到`branches`数组中。在我们的游戏循环之前添加以下突出显示的代码：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The previous code does not use any new concepts. First we declare an SFML `Texture`
    object and load the `branch.png` graphic into it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码没有使用任何新概念。首先，我们声明了一个SFML `Texture`对象，并将`branch.png`图形加载到其中。
- en: Next, we create a `for` loop, which sets `i` to zero and increments `i` by one
    each pass through the loop until `i` is no longer less than `NUM_BRANCHES`. This
    is exactly right because `NUM_BRANCHES` is 6 and the `branches` array has positions
    0 through 5.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`for`循环，将`i`设置为零，并在每次循环通过时递增`i`，直到`i`不再小于`NUM_BRANCHES`。这是完全正确的，因为`NUM_BRANCHES`是6，而`branches`数组的位置是0到5。
- en: Inside the `for` loop we set the `Texture` for each `Sprite` in the `branches`
    array with `setTexture` and then hide it off screen with `setPosition`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，我们使用`setTexture`为`branches`数组中的每个`Sprite`设置`Texture`，然后用`setPosition`将其隐藏在屏幕外。
- en: Finally, we set the origin (the point which is located when it is drawn), with
    `setOrigin`, to the center of the sprite. Soon, we will be rotating these sprites
    and having the origin in the center means they will spin nicely around, without
    moving the sprite out of position.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`setOrigin`将原点（绘制时所在的点）设置为精灵的中心。很快，我们将旋转这些精灵，并且将原点设置在中心意味着它们将很好地围绕旋转，而不会使精灵移出位置。
- en: Updating the branch sprites each frame
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每帧更新树枝精灵
- en: 'In this next code we set the position of all the sprites in the `branches`
    array, based upon their position in the array and the value of `side` in the corresponding
    `branchPositions` array. Add the highlighted code and try to understand it, then
    we can go through it in detail:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们根据`branchPositions`数组中的位置和相应的`branchPositions`数组中的`side`的值，设置`branches`数组中所有精灵的位置。添加高亮代码并尝试理解它，然后我们可以详细讨论一下：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The code we just added is one big `for` loop that sets `i` to zero, increments
    `i` by 1 each time through the loop, and keeps going until `i` is no longer less
    than 6.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码是一个大的`for`循环，将`i`设置为零，每次通过循环递增`i`，并持续进行，直到`i`不再小于6。
- en: Inside the `for` loop a new `float` variable called `height` is set to `i *
    150`. This means that the first branch will have a height of 0, the second of
    150, and the sixth of 750.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内，设置了一个名为`height`的新的`float`变量，其值为`i * 150`。这意味着第一个树枝的高度为0，第二个为150，第六个为750。
- en: 'Next we have a structure of `if` and `else` blocks. Look at the structure with
    the code stripped out:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一系列`if`和`else`块的结构。看一下剥离了代码的结构：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first `if` uses the `branchPositions` array to see whether the current branch
    should be on the left. If it is, it sets the corresponding `Sprite` from the `branches`
    array to a position on the screen, appropriate for the left (610 pixels) and whatever
    the current `height` is. It then flips the sprite by `180` degrees because the
    `branch.png` graphic hangs to the right by default.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`if`使用`branchPositions`数组来查看当前树枝是否应该在左边。如果是的话，它会将`branches`数组中的相应`Sprite`设置为屏幕上适合左边（610像素）和当前`height`的位置。然后它将精灵翻转`180`度，因为`branch.png`图形默认向右悬挂。
- en: The `else if` only executes if the branch is not on the left. It uses the same
    method to see if it is on the right. If it is then the branch is drawn on the
    right (`1330` pixels). Then the sprite rotation is set to 0 degrees, just in case
    it had previously been at `180` degrees. If the x coordinate seems a little bit
    strange, just remember that we set the origin for the branch sprites to their
    center.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if`只有在树枝不在左边时才执行。它使用相同的方法来查看它是否在右边。如果是的话，树枝就会被绘制在右边（1330像素）。然后将精灵旋转为0度，以防它之前是180度。如果x坐标看起来有点奇怪，只需记住我们将树枝精灵的原点设置为它们的中心。'
- en: The final `else` assumes, correctly, that the current `branchPosition` must
    be `NONE` and hides the branch off screen at `3000` pixels.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`else`假设，正确地，当前的`branchPosition`必须是`NONE`，并将树枝隐藏在屏幕外的`3000`像素处。
- en: At this point, our branches are in position, ready to be drawn.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的树枝已经就位，准备绘制。
- en: Drawing the branches
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制树枝
- en: 'Here we use another `for` loop, to step through the entire `branches` array
    from 0 to 5 and draw each branch sprite. Add the following highlighted code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用另一个`for`循环，从0到5遍历整个`branches`数组，并绘制每个树枝精灵。添加以下高亮代码：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Of course we still haven't written the function that actually moves all the
    branches. Once we have written that function, we will also need to work out when
    and how to call it. Let's solve the first problem and write the function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还没有编写实际移动所有树枝的函数。一旦我们编写了该函数，我们还需要解决何时以及如何调用它的问题。让我们解决第一个问题并编写该函数。
- en: Moving the branches
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动树枝
- en: We have already added the function prototype above the `main` function. Now
    we code the actual definition of the function that will move all the branches
    down by one position each time it is called. We will code this function in two
    parts so we can more easily examine what is happening.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`main`函数上面添加了函数原型。现在我们编写实际的函数定义，该函数将在每次调用时将所有树枝向下移动一个位置。我们将这个函数分为两部分编写，以便更容易地检查发生了什么。
- en: 'Add the first part of the `updateBranches` function after the closing curly
    brace of the `main` function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的右花括号后添加`updateBranches`函数的第一部分：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this first part of the function, we simply move all the branches down one
    position, one at a time, starting with the sixth branch. This is achieved by making
    the `for` loop count from 5 through to 0\. The code `branchPositions[j] = branchPositions[j
    - 1];` makes the actual move.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的第一部分中，我们只是将所有的树枝向下移动一个位置，一次一个，从第六个树枝开始。这是通过使`for`循环从5计数到0来实现的。代码`branchPositions[j]
    = branchPositions[j - 1];`实现了实际的移动。
- en: The other thing to note, with the previous code, is that, after we have moved
    the branch in position 4 to position 5, then the branch in position 3 to position
    4, and so on, we will need to add a new branch at position 0, which is the top
    of the tree.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，另一件需要注意的事情是，当我们将位置4的树枝移动到位置5，然后将位置3的树枝移动到位置4，依此类推，我们需要在位置0添加一个新的树枝，这是树的顶部。
- en: 'Now we can spawn a new branch at the top of the tree. Add the highlighted code
    and then we will talk about it:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在树的顶部生成一个新的树枝。添加高亮代码，然后我们将讨论它：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the final part of the `updateBranches` function, we use the integer `seed`
    variable that gets passed in with the function call. We do this to guarantee that
    the random number `seed` is always different and we will see how this value is
    arrived at in the next chapter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`updateBranches`函数的最后部分，我们使用传入函数调用的整数`seed`变量。我们这样做是为了确保随机数`seed`始终不同，并且我们将在下一章中看到这个值是如何得到的。
- en: Next, we generate a random number between zero and four and store the result
    in the `int` variable `r`. Now we `switch` using `r` as the expression.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们生成一个介于零和四之间的随机数，并将结果存储在`int`变量`r`中。现在我们使用`r`作为表达式进行`switch`。
- en: The `case` statements mean that, if `r` is equal to zero then we add a new branch
    on the left-hand side at the top of the tree. If `r` is equal to 1 then the branch
    goes on the right. If `r` is anything else, (2, 3, or 4) then the `default` ensures
    that no branch will be added at the top. This balance of left, right, and none
    makes the tree seem realistic and the game works quite well. You could easily
    change the code to make the branches more frequent or less so.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`语句意味着，如果`r`等于零，那么我们在树的顶部左侧添加一个新的分支。如果`r`等于1，那么分支就在右侧。如果`r`是其他任何值（2、3或4），那么`default`确保在顶部不会添加任何分支。左、右和无的平衡使得树看起来很真实，游戏运行得相当不错。你可以很容易地改变代码，使分支更频繁或更少。'
- en: Even after all this code for our branches, we still can't glimpse a single one
    of them in the game. This is because we have more work to do before we can actually
    call `updateBranches`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 即使为我们的分支编写了所有这些代码，我们仍然无法在游戏中看到任何一个分支。这是因为在我们实际调用`updateBranches`之前，我们还有更多的工作要做。
- en: 'If you really want see a branch now, you can add some temporary code and call
    the function five times with a unique seed each time, just before the game loop:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在真的想看到一个分支，你可以添加一些临时代码，并在游戏循环之前调用该函数五次，每次使用一个独特的种子：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can now see the branches in their place. But if the branches are to actually
    move we will need to call `updateBranches` on a regular basis.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到分支在它们的位置上。但是如果分支实际上要移动，我们需要定期调用`updateBranches`。
- en: '![Moving the branches](img/image_04_001.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![移动分支](img/image_04_001.jpg)'
- en: Tip
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget to remove the temporary code before moving on.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前不要忘记删除临时代码。
- en: Now we can turn our attention to the player and call the `updateBranches` function
    for real.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以把注意力转向玩家，并真正调用`updateBranches`函数。
- en: FAQ
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FAQ
- en: Q) You mentioned there were a few types of C++ loop.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 你提到了几种类型的C++循环。
- en: "A) Yes, take a look at this tutorial and explanation for `doâ\x80¦while` loops:"
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: A) 是的，看一下这个`do...while`循环的教程和解释：
- en: '[http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm](http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm](http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm)'
- en: Q) Can I assume I am an expert on arrays?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我可以假设我是数组的专家吗？
- en: A) As with many topics in this book there is always more to learn. You know
    enough about arrays to proceed, but if you're hungry for more take a look at this
    fuller array tutorial:[http://www.cplusplus.com/doc/tutorial/arrays/](http://www.cplusplus.com/doc/tutorial/arrays/).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: A) 就像本书中的许多主题一样，总是有更多的东西可以学习。你已经了解足够的关于数组的知识来继续，但如果你还想了解更多，请查看这个更详细的数组教程：[http://www.cplusplus.com/doc/tutorial/arrays/](http://www.cplusplus.com/doc/tutorial/arrays/)。
- en: Q) Can I assume I am an expert on functions?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我可以假设我是函数的专家吗？
- en: A) As with many topics in this book there is always more to learn. You know
    enough about functions to proceed but if want to know even more, take a look at
    this tutorial:[http://www.cplusplus.com/doc/tutorial/functions/](http://www.cplusplus.com/doc/tutorial/functions/).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: A) 就像本书中的许多主题一样，总是有更多的东西可以学习。你已经了解足够的关于函数的知识来继续，但如果想了解更多，请查看这个教程：[http://www.cplusplus.com/doc/tutorial/functions/](http://www.cplusplus.com/doc/tutorial/functions/)。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Although this wasn't the longest chapter it was probably the chapter where we
    covered the most C++. We looked at the different types of loop we can use, such
    as `for` and `while` loops. We studied arrays for handling large amounts of variables
    and objects without breaking a sweat. We also learnt about enumerations and `switch`.
    Probably the biggest concept in this chapter, was functions that allow us to organize
    and abstract our game's code. We will be looking more deeply at functions in a
    few more places as the book continues.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是最长的一章，但可能是我们涵盖最多C++知识的一章。我们研究了不同类型的循环，比如`for`和`while`循环。我们学习了处理大量变量和对象的数组，而不费吹灰之力。我们还学习了枚举和`switch`。也许这一章最重要的概念是允许我们组织和抽象游戏代码的函数。随着书的继续，我们将在更多地方深入研究函数。
- en: Now that we have a fully working tree, we can finish the game off in the last
    chapter for this project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全可用的树，我们可以在这个项目的最后一章中完成游戏。
