- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: The Universal Asynchronous Receiver/Transmitter Protocol
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用异步收发器协议
- en: In this chapter, we will learn about the **universal asynchronous receiver/transmitter**
    (**UART**) protocol, an important communication method widely used in embedded
    systems. UART is fundamental for enabling communication between microcontrollers
    and various peripherals, making it an essential component in embedded systems
    development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习**通用异步收发器（UART**）协议，这是一种在嵌入式系统中广泛使用的通信方法。UART对于实现微控制器和各种外设之间的通信至关重要，使其成为嵌入式系统开发中的基本组件。
- en: We will start by discussing the significance of communication protocols in embedded
    systems and highlight common use cases for UART alongside other protocols such
    as SPI and I2C. Following this, we will provide a comprehensive overview of the
    UART protocol, detailing its operational principles and features. Next, we will
    extract and examine the relevant registers for UART from the STM32 reference manual,
    providing the necessary foundational knowledge for driver development. Finally,
    we will apply this knowledge to develop a bare-metal UART driver, illustrating
    the practical aspects of initializing and transmitting data via UART.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论通信协议在嵌入式系统中的重要性，并强调UART与其他协议（如SPI和I2C）一起的常见用例。在此之后，我们将全面概述UART协议，详细说明其操作原理和特性。接下来，我们将从STM32参考手册中提取并检查UART的相关寄存器，为驱动器开发提供必要的知识基础。最后，我们将应用这些知识来开发裸机UART驱动器，展示通过UART初始化和传输数据的实际方面。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Introduction to communication protocols
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信协议简介
- en: Overview of the UART protocol
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UART协议概述
- en: The STM32F4 UART peripheral
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32F4 UART外设
- en: Developing the UART driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发UART驱动器
- en: By the end of this chapter, you will have a good understanding of the UART protocol
    and the skills needed to develop bare-metal drivers for UART communication.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解UART协议以及开发UART通信的裸机驱动器所需的技术。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Introduction to communication protocols
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信协议简介
- en: In the world of embedded systems, communication protocols are essential conduits
    that enable microcontrollers and peripheral devices to talk to each other seamlessly.
    Think of them as the languages that different devices use to understand and exchange
    information, ensuring that everything from your smartphone to your smart home
    devices works smoothly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统领域，通信协议是使微控制器和外设设备能够无缝通信的关键通道。把它们想象成不同设备用来理解和交换信息的语言，确保从你的智能手机到你的智能家居设备都能顺畅工作。
- en: Let’s dive into what communication protocols are, how they are grouped, their
    unique features and advantages, and explore some common use cases to see these
    protocols in action.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解通信协议是什么，它们是如何分组的，它们的独特特性和优势，并探索一些常见用例来观察这些协议的实际应用。
- en: What are communication protocols?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是通信协议？
- en: Communication protocols are sets of rules and conventions that allow electronic
    devices to communicate with each other. These protocols define how data is formatted,
    transmitted, and received, ensuring that devices can exchange information accurately
    and reliably. Without these protocols, it would be like trying to have a conversation
    with someone who speaks a completely different language – communication would
    be chaotic and error-prone.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通信协议是一套规则和约定，允许电子设备相互通信。这些协议定义了数据是如何格式化、传输和接收的，确保设备可以准确可靠地交换信息。没有这些协议，就像试图与说完全不同语言的人交谈一样——通信将会混乱且充满错误。
- en: In embedded systems, these protocols are crucial because they facilitate the
    interaction between microcontrollers and peripherals such as sensors, actuators,
    displays, and other microcontrollers. Whether it’s sending a simple temperature
    reading from a sensor to a microcontroller or streaming video data from a camera
    module, communication protocols make it happen.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中，这些协议至关重要，因为它们促进了微控制器与传感器、执行器、显示器和其他微控制器等外围设备之间的交互。无论是从传感器向微控制器发送简单的温度读数，还是从摄像头模块流式传输视频数据，通信协议都使其成为可能。
- en: 'Let’s analyze the classification of communication protocols, starting with
    the big picture: what communication protocols can be broadly classified into –
    **serial** and **parallel** communication.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析通信协议的分类，从宏观的角度开始：可以将通信协议广泛地归类为——**串行**和**并行**通信。
- en: Serial versus parallel communication
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 串行与并行通信
- en: Let’s start with serial communication.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从串行通信开始。
- en: Serial communication
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 串行通信
- en: 'In this category, communication protocols can be further broken down into asynchronous
    and synchronous protocols:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类别中，通信协议可以进一步细分为异步和同步协议：
- en: '**Asynchronous**: This type of communication sends data one bit at a time without
    a clock signal to synchronize the sender and receiver. Think of it as sending
    letters through the mail without a scheduled delivery time. A common example is
    UART, which is simple and efficient for many applications.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步**：这种类型的通信一次发送一个比特，没有时钟信号来同步发送者和接收者。想象一下像通过邮件发送信件一样，没有预定投递时间。一个常见的例子是 UART，它对于许多应用来说简单且高效。'
- en: '**Synchronous**: Unlike asynchronous communication, this form of communication
    uses a clock signal to coordinate the transmission of bits. It’s like having a
    drumbeat to ensure everyone marches in step. Examples include **Serial Peripheral
    Interface** (**SPI**) and **Inter-Integrated Circuit** (**I2C**). These protocols
    ensure data integrity and timing, making them suitable for more complex tasks.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**：与异步通信不同，这种通信形式使用时钟信号来协调比特的传输。这就像有一个鼓点来确保每个人都步调一致。例子包括 **串行外设接口** (**SPI**)
    和 **集成电路间接口** (**I2C**)。这些协议确保数据完整性和时序，使它们适合更复杂的任务。'
- en: Parallel communication
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 并行通信
- en: This type involves transmitting multiple bits simultaneously over multiple channels.
    Imagine sending a whole fleet of cars instead of a single one – it’s faster but
    requires more lanes (or pins, in our case). While parallel communication is faster,
    it’s less common in embedded systems due to the higher pin count. Also, it’s prone
    to crosstalk and signal integrity problems, especially over longer distances.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型涉及在多个通道上同时传输多个比特。想象一下发送一整队汽车而不是一辆——这更快，但需要更多的车道（或引脚，在我们的情况下）。虽然并行通信更快，但由于引脚数量更多，在嵌入式系统中不太常见。此外，它容易受到串扰和信号完整性问题的影响，尤其是在更长的距离上。
- en: We can also classify communication protocols based on their architecture. In
    this classification system, we have point-to-point communication and multi-device
    communication.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据它们的架构对通信协议进行分类。在这个分类体系中，我们有点对点通信和多设备通信。
- en: Point-to-point versus multi-device communication
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点对点与多设备通信
- en: Let’s look at the differences.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们之间的区别。
- en: Point-to-point
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 点对点
- en: This is a direct line of communication between two devices. **UART** is a classic
    example, where data flows directly between a microcontroller and a peripheral
    device. It’s straightforward, reliable, and ideal for many embedded systems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个设备之间直接的通信线路。**UART** 是一个经典的例子，其中数据直接在微控制器和外围设备之间流动。它简单、可靠，非常适合许多嵌入式系统。
- en: Multi-device (bus) communication
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多设备（总线）通信
- en: 'Here, multiple devices share the same communication lines, which can be either
    of the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，多个设备共享相同的通信线路，这些线路可以是以下之一：
- en: '**Multi-master**: Multiple devices can control the communication bus. **I2C**
    is a great example as it allows multiple masters and slaves on the same bus. It’s
    like a group of friends taking turns talking in a conversation.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多主设备**：多个设备可以控制通信总线。**I2C** 是一个很好的例子，因为它允许同一总线上有多个主设备和从设备。这就像一群朋友轮流在对话中交谈。'
- en: '**Master-slave**: One master device controls the communication, directing traffic
    to and from multiple slave devices. **SPI** operates this way, with a single master
    communicating with multiple slaves through dedicated lines. **I2C** can also operate
    this way. It’s akin to a teacher (master) calling on students one at a time to
    speak.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主从模式**：一个主设备控制通信，将流量导向多个从设备。**SPI**就是这样操作的，一个主设备通过专用线路与多个从设备通信。**I2C**也可以这样操作。这就像是一位老师（主设备）依次叫学生发言。'
- en: Lastly, communication protocols can be classified based on their data flow capabilities.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通信协议可以根据其数据流能力进行分类。
- en: Full-duplex versus half-duplex
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全双工与半双工对比
- en: 'Let’s see the differences between full-duplex and half-duplex:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看全双工和半双工之间的区别：
- en: '**Full-duplex**: This allows simultaneous two-way communication. Imagine a
    two-lane road where cars can travel in both directions at the same time. **UART**
    and **SPI** support full-duplex communication, making them highly efficient for
    real-time data exchange.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全双工**：这允许双向同时通信。想象一下一条双车道道路，汽车可以同时双向行驶。**UART**和**SPI**支持全双工通信，这使得它们在实时数据交换中非常高效。'
- en: '**Half-duplex**: Here, communication can occur in both directions, but not
    at the same time – it’s like a single-lane road where cars must take turns. **I2C**
    typically operates in half-duplex mode, which works well for its intended applications
    but can be a limitation in high-speed data scenarios.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半双工**：在这里，通信可以双向进行，但不能同时进行——就像一条单车道道路，汽车必须轮流行驶。**I2C**通常以半双工模式运行，这对于其预期应用来说效果很好，但在高速数据场景中可能是一个限制。'
- en: Now, let’s closely compare the three common communication protocols that are
    used in modern embedded systems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们仔细比较现代嵌入式系统中使用的三种常见通信协议。
- en: Comparing UART, SPI, and I2C
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较UART、SPI和I2C
- en: Let’s start with UART.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从串行异步接收/发送（UART）开始。
- en: UART
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UART
- en: 'Here are some key features of UART:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是UART的一些关键特性：
- en: '**Asynchronous communication**: UART doesn’t require a clock signal. Instead,
    it uses start and stop bits to synchronize data transmission.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步通信**：UART不需要时钟信号。相反，它使用起始位和停止位来同步数据传输。'
- en: '**Full-duplex**: UART can send and receive data simultaneously, which is ideal
    for many applications requiring real-time communication.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全双工**：UART可以同时发送和接收数据，这对于许多需要实时通信的应用程序来说非常理想。'
- en: '**Simple and cost-effective**: With minimal hardware requirements, UART is
    easy to implement and cost-effective.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单且成本低**：UART的硬件要求最小，易于实现且成本低。'
- en: 'The following are some of its advantages:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其优点：
- en: '**Ease of use**: Setting up UART communication is straightforward, making it
    a popular choice for beginners and simple applications'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：设置UART通信非常简单，这使得它成为初学者和简单应用的流行选择。'
- en: '**Wide support**: UART is universally supported by most microcontrollers and
    peripheral devices'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广泛支持**：UART被大多数微控制器和外设设备普遍支持。'
- en: '**Low overhead**: The lack of a clock signal means fewer pins are used, reducing
    complexity'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低开销**：没有时钟信号意味着使用的引脚更少，减少了复杂性。'
- en: 'However, it also has some disadvantages:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一些缺点：
- en: '**Speed limitations**: UART is generally slower compared to SPI and I2C, making
    it less suitable for high-speed data transfer'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度限制**：与SPI和I2C相比，UART通常较慢，这使得它不太适合高速数据传输。'
- en: '**Limited distance**: Susceptibility to noise over long distances can limit
    the range of reliable communication'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**距离限制**：在长距离上对噪声的敏感性可能会限制可靠通信的范围。'
- en: '**Point-to-point only**: UART is designed for direct, point-to-point communication,
    which can be a limitation if multiple devices need to communicate'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点对点通信**：UART是为直接、点对点通信设计的，如果多个设备需要通信，这可能是一个限制。'
- en: Next, we have SPI.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有串行外设接口（SPI）。
- en: SPI
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SPI
- en: 'Here are some key features of SPI:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是SPI的一些关键特性：
- en: '**Synchronous communication**: SPI uses a clock signal along with data lines,
    ensuring synchronized data transfer'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步通信**：SPI使用时钟信号和数据线，确保同步数据传输。'
- en: '**Full-duplex**: It allows data to be sent and received simultaneously'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全双工**：它允许数据同时发送和接收。'
- en: '**Master-slave architecture**: One master device controls multiple slave devices,
    with dedicated lines for each'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主从架构**：一个主设备控制多个从设备，每个设备都有专用线路。'
- en: 'The following are some of its advantages:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其优点：
- en: '**High speed**: SPI supports high-speed data transfer, making it ideal for
    applications requiring fast communication'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高速**：SPI支持高速数据传输，这使得它非常适合需要快速通信的应用程序。'
- en: '**Versatility**: SPI can connect multiple devices with different configurations,
    providing flexibility in design'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多功能性**：SPI可以连接具有不同配置的多个设备，为设计提供灵活性'
- en: 'However, it also has some disadvantages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一些缺点：
- en: '**More pins required**: Each slave device needs a separate select line, which
    can increase the pin count significantly'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要更多引脚**：每个从设备需要一个单独的选择线，这可能会显著增加引脚数'
- en: '**No standardized acknowledgment**: Unlike I2C, SPI does not have a built-in
    acknowledgment mechanism, which can make error detection more challenging'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有标准化的确认机制**：与I2C不同，SPI没有内置的确认机制，这可能会使错误检测更具挑战性'
- en: '**Limited multi-master capability**: SPI is not designed for multi-master systems,
    which can be a limitation in some scenarios'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的多个主能力**：SPI不是为多主系统设计的，这在某些情况下可能是一个限制'
- en: The final common communication protocol we’ll cover is I2C.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最后一个通信协议是I2C。
- en: I2C
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C
- en: 'Here are some key features of I2C:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是I2C的一些关键特性：
- en: '**Synchronous communication**: I2C uses a clock signal for synchronized data
    transfer'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步通信**：I2C使用时钟信号进行同步数据传输'
- en: '**Multi-master capability**: Multiple master devices can share the same bus,
    which is useful in more complex systems'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多主能力**：多个主设备可以共享同一总线，这在更复杂的系统中很有用'
- en: '**Two-wire interface**: I2C requires only two lines (SDA and SCL) for communication,
    minimizing the pin count'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双线接口**：I2C只需要两条线（SDA和SCL）进行通信，最小化了引脚数'
- en: 'The following are some of its advantages:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其优势：
- en: '**Simplicity in wiring**: The two-wire interface reduces the complexity and
    number of pins required'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布线简单**：双线接口减少了复杂性和所需的引脚数'
- en: '**Multi-device support**: I2C easily connects multiple devices on the same
    bus, each with a unique address'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多设备支持**：I2C可以轻松连接同一总线上具有唯一地址的多个设备'
- en: '**Built-in addressing**: I2C has a built-in addressing mechanism, making communication
    with multiple devices straightforward'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置寻址**：I2C具有内置的寻址机制，使得与多个设备的通信变得简单'
- en: 'However, it does have some disadvantages:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一些缺点：
- en: '**Slower speed**: I2C is generally slower than SPI, which can be a limitation
    for high-speed applications'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**较慢的速度**：I2C通常比SPI慢，这可能会成为高速应用的限制'
- en: '**Complex protocol**: The protocol is more complex than UART and SPI, requiring
    more sophisticated handling of data transfers and addressing'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的协议**：该协议比UART和SPI更复杂，需要更复杂的数据传输和寻址处理'
- en: '**Susceptible to noise**: Like UART, I2C can be susceptible to noise over longer
    distances, potentially affecting communication reliability'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易受噪声影响**：与UART类似，I2C在较长距离上可能会易受噪声影响，这可能会影响通信可靠性'
- en: Choosing the right communication protocol depends on your specific application
    needs. If you need simple, straightforward communication and can tolerate slower
    speeds, **UART** is a great choice. For high-speed applications with a need for
    full-duplex communication, **SPI** is ideal, especially if you can manage the
    higher pin count. When you need to connect multiple devices with minimal wiring
    and have a complex communication setup, **I2C** is your go-to protocol. To help
    you better understand when to choose which protocol, let’s explore some common
    use cases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的通信协议取决于您的具体应用需求。如果您需要简单、直接的通信并且可以容忍较慢的速度，**UART**是一个不错的选择。对于需要全双工通信的高速应用，**SPI**是理想的，尤其是如果您能够管理更高的引脚数。当您需要用最少的线缆连接多个设备并且拥有复杂的通信设置时，**I2C**是您的首选协议。为了帮助您更好地理解何时选择哪种协议，让我们探讨一些常见的用例。
- en: Common use cases for the UART, SPI, and I2C protocols
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UART、SPI和I2C协议的常见用例
- en: When designing embedded systems, selecting the right communication protocol
    is crucial for ensuring efficient and reliable data exchange. UART, SPI, and I2C
    each have unique strengths, making them suitable for different applications. Let’s
    explore the practical use cases and compelling case studies for each protocol,
    highlighting their professional and real-world relevance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计嵌入式系统时，选择合适的通信协议对于确保高效和可靠的数据交换至关重要。UART、SPI和I2C各自具有独特的优势，使它们适用于不同的应用。让我们探讨每个协议的实际用例和引人入胜的案例研究，突出其专业性和现实世界的相关性。
- en: UART
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UART
- en: 'Let’s look at some common use cases for the UART protocol:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看UART协议的一些常见用例：
- en: '**Serial communication with PCs**: UART is often used for serial communication
    between microcontrollers and computers, particularly for debugging, firmware updates,
    and data logging'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与PC的串行通信**：UART常用于微控制器和计算机之间的串行通信，尤其是用于调试、固件更新和数据记录。'
- en: '**GPS modules**: UART can be used to transmit location data from a GPS module
    to a microcontroller'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPS模块**：UART可用于将GPS模块的位置数据传输到微控制器。'
- en: '**Bluetooth modules**: UART enables wireless communication with devices via
    Bluetooth'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝牙模块**：UART通过蓝牙使设备能够进行无线通信。'
- en: These use cases represent some of the most common applications of UART, but
    the protocol is versatile and can be used in many other scenarios that require
    simple serial communication.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用例代表了UART最常见的应用之一，但该协议非常灵活，可以用于许多其他需要简单串行通信的场景。
- en: Case study – GPS module integration for autonomous drones
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究 - 自主无人机GPS模块集成
- en: Imagine you’re developing an autonomous drone that requires precise navigation
    to perform tasks such as surveying and mapping. Integrating a GPS module using
    UART can provide real-time location data essential for navigation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在开发一个需要精确导航以执行测绘和制图等任务的自主无人机。使用UART集成GPS模块可以提供导航所需的实时位置数据。
- en: '**Setup**: Connect the GPS module’s transmit (TX) pin to the microcontroller’s
    receive (RX) pin and vice versa. Configure the baud rate so that it matches the
    GPS module’s output.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置**：将GPS模块的发送（TX）引脚连接到微控制器的接收（RX）引脚，反之亦然。配置波特率，使其与GPS模块的输出相匹配。'
- en: '**Operation**: The GPS module continuously sends NMEA sentences (text strings)
    containing location data. The microcontroller reads these strings via UART, parses
    them, and uses the location information to navigate the drone accurately.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**：GPS模块持续发送包含位置数据的NMEA句子（文本字符串）。微控制器通过UART读取这些字符串，解析它们，并使用位置信息来精确导航无人机。'
- en: '**Advantage**: UART’s simplicity and widespread support make it straightforward
    to integrate the GPS module, providing reliable and continuous data flow without
    a complex setup.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**优势**：UART的简单性和广泛支持使得集成GPS模块变得简单，提供可靠且连续的数据流，无需复杂的设置。'
- en: Next, we’ll look at SPI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨SPI。
- en: SPI
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SPI
- en: 'The following are some common use cases for the SPI protocol:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些SPI协议的常见用例：
- en: '**High-speed data transfer**: It’s ideal for applications such as memory cards,
    **analog-to-digital converters** (**ADCs**), **digital-to-analog converters**
    (**DACs**), and displays'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高速数据传输**：它非常适合内存卡、**模数转换器**（ADCs）、**数模转换器**（DACs）和显示器等应用。'
- en: '**Display modules**: SPI can be used for communicating with high-resolution
    displays requiring fast refresh rates'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示模块**：SPI可用于与需要快速刷新率的高分辨率显示器通信。'
- en: '**Sensors and actuators**: SPI can handle high-frequency data outputs from
    various sensors'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传感器和执行器**：SPI可以处理来自各种传感器的高频数据输出。'
- en: Like UART, these examples highlight some typical uses of SPI, but the protocol’s
    high-speed capabilities make it suitable for a wide range of other applications
    requiring rapid data transfer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与UART类似，这些示例突出了SPI的一些典型用途，但该协议的高速能力使其适用于需要快速数据传输的广泛其他应用。
- en: Case study – SD card data logging for industrial equipment
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究 - 工业设备的SD卡数据记录
- en: Consider an industrial monitoring system that logs data from various sensors
    to an SD card for long-term analysis. SPI is the perfect protocol for this high-speed
    data transfer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个工业监控系统，它将来自各种传感器的数据记录到SD卡中，以进行长期分析。SPI是这种高速数据传输的完美协议。
- en: '**Setup**: Connect the microcontroller to the SD card using SPI pins (MISO,
    MOSI, SCLK, and CS). Initialize the SPI bus and configure the SD card.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置**：使用SPI引脚（MISO、MOSI、SCLK和CS）将微控制器连接到SD卡。初始化SPI总线并配置SD卡。'
- en: '**Operation**: The microcontroller collects data from sensors (for example,
    temperature, pressure, and vibration) and writes this data to the SD card in real
    time.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**：微控制器从传感器（例如，温度、压力和振动）收集数据，并将这些数据实时写入SD卡。'
- en: '**Advantage**: SPI’s high-speed data transfer ensures that large amounts of
    data are logged quickly and efficiently, preventing any data loss and ensuring
    accurate monitoring.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**优势**：SPI的高速数据传输确保大量数据快速高效地记录，防止数据丢失并确保准确监控。'
- en: Using SPI in this scenario allows the industrial system to maintain precise
    logs of critical parameters, which are essential for predictive maintenance and
    operational efficiency.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用SPI允许工业系统精确记录关键参数，这对于预测性维护和运营效率至关重要。
- en: Finally, we have I2C.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有I2C。
- en: I2C
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C
- en: 'Let’s consider two common use cases related to I2C:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个与I2C相关的常见用例：
- en: '**Multiple sensor integration systems**: This involves connecting several sensors
    with different addresses on the same I2C bus'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多传感器集成系统**：这涉及到在同一I2C总线上连接具有不同地址的多个传感器'
- en: '**Peripheral expansion**: This involves adding more GPIO pins to a microcontroller
    using I2C expanders'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围扩展**：这涉及到使用I2C扩展器向微控制器添加更多GPIO引脚'
- en: These use cases are just two examples of I2C’s applications. Its ability to
    support multiple devices on a single bus makes it an excellent choice for many
    other scenarios where scalability is important.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用例只是I2C应用的两个例子。它能够在单总线上支持多个设备的能力，使其成为许多其他场景下的优秀选择，在这些场景中，可扩展性很重要。
- en: Case study – environmental monitoring system for smart agriculture
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究 - 智能农业的环境监控系统
- en: Let’s say you’re developing a smart agriculture system that uses multiple sensors
    (temperature, humidity, and soil moisture) to optimize farming conditions. I2C
    is the ideal protocol for this multi-sensor integration.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个使用多个传感器（温度、湿度和土壤湿度）以优化农业条件的智能农业系统。I2C是这种多传感器集成的理想协议。
- en: '**Setup**: Connect all sensors to the I2C bus (SDA and SCL lines). Assign each
    sensor a unique address.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置**：将所有传感器连接到I2C总线（SDA和SCL线）。为每个传感器分配一个唯一的地址。'
- en: '**Operation**: The microcontroller queries each sensor in sequence, collects
    the data, and processes it to provide insights and control irrigation, ventilation,
    and lighting systems.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**：微控制器按顺序查询每个传感器，收集数据，并对其进行处理以提供见解和控制灌溉、通风和照明系统。'
- en: '**Advantage**: I2C’s ability to support multiple devices on the same bus with
    just two lines simplifies wiring, reduces costs, and saves GPIO pins, making it
    an efficient solution for complex sensor networks.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**优势**：I2C能够在同一总线上仅用两条线支持多个设备，简化了布线，降低了成本，并节省了GPIO引脚，使其成为复杂传感器网络的效率解决方案。'
- en: Starting with the next section, we’ll focus exclusively on the UART protocol.
    We’ll cover the I2C and SPI protocols in the following chapters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一节开始，我们将专注于UART协议。在接下来的章节中，我们将介绍I2C和SPI协议。
- en: Overview of the UART protocol
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UART协议概述
- en: One of the most fundamental and widely used protocols is UART. Whether you’re
    debugging hardware or enabling communication between a microcontroller and peripherals,
    understanding UART is crucial. Let’s delve into the workings of this protocol.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本且最广泛使用的协议之一是UART。无论你是调试硬件还是使微控制器与外围设备之间进行通信，理解UART都是至关重要的。让我们深入了解这个协议的工作原理。
- en: What is UART?
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是UART？
- en: UART is a hardware communication protocol that operates using asynchronous serial
    communication, allowing for adjustable data transmission speeds. The “asynchronous”
    nature of UART means it doesn’t require a clock signal to align the transmission
    of bits between the sender and receiver. Instead, both devices must agree on a
    specific baud rate, which dictates the speed at which data is exchanged. Let’s
    take a look at the interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: UART是一种硬件通信协议，它使用异步串行通信进行操作，允许调整数据传输速度。"异步"的UART特性意味着它不需要时钟信号来对齐发送器和接收器之间位传输的对齐。相反，两个设备必须就特定的波特率达成一致，这决定了数据交换的速度。让我们看看接口。
- en: The interface
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'The UART interface employs two wires for communication: TX and RX. To establish
    a connection between two devices, we simply connect the TX pin of the first device
    to the RX pin of the second device, and the RX pin of the first device to the
    TX pin of the second device. Additionally, it’s crucial to connect the ground
    pins of both devices to ensure a common electrical reference. *Figure 10**.1*
    shows the connection between two UART devices:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: UART接口使用两条线进行通信：TX和RX。为了在两个设备之间建立连接，我们只需将第一个设备的TX引脚连接到第二个设备的RX引脚，并将第一个设备的RX引脚连接到第二个设备的TX引脚。此外，连接两个设备的接地引脚以确保共同的电气参考至关重要。*图10.1*显示了两个UART设备之间的连接：
- en: '![Figure 10.1: The UART interface](img/B21914_10_1.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：UART接口](img/B21914_10_1.jpg)'
- en: 'Figure 10.1: The UART interface'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：UART接口
- en: How UART works
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UART是如何工作的
- en: 'Data in UART is transmitted as frames containing a **start bit**, **data bits**,
    an optional **parity bit**, and **stop bits**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: UART中的数据以包含**起始位**、**数据位**、可选的**奇偶校验位**和**停止位**的帧形式传输：
- en: '![Figure 10.2: The UART data packet](img/B21914_10_2.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：UART数据包](img/B21914_10_2.jpg)'
- en: 'Figure 10.2: The UART data packet'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：UART数据包
- en: 'Here’s a step-by-step breakdown of the process:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个过程的一步一步分解：
- en: '**Start bit**: The transmission line is normally held high. To start the data
    transfer, the transmitting UART pulls the line low for one clock cycle. This indicates
    the start of a new data frame.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**起始位**：传输线路通常保持高电平。为了开始数据传输，发送的UART将线路拉低一个时钟周期。这表示新数据帧的开始。'
- en: '**Data frame**: Following the start bit, the data frame typically consists
    of 5 to 9 bits and is sent from the **least significant bit** (**LSB**) to the
    **most significant** **bit** (**MSB**).'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据帧**：在起始位之后，数据帧通常由5到9位组成，并从**最低有效位**（**LSB**）到**最高有效位**（**MSB**）发送。'
- en: '**Parity bit**: This is optional and is used for error checking. It ensures
    that the number of set bits (1s) in the data is even or odd.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**奇偶校验位**：这是可选的，用于错误检查。它确保数据中设置的位（1s）的数量是偶数或奇数。'
- en: '**Stop bits**: This is one or two bits indicating the end of the data packet.
    The line is driven high during the stop bits.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**停止位**：这是一位或两位，表示数据包的结束。在停止位期间，线路被驱动到高电平。'
- en: Let’s take a closer look at the start, stop, and parity bits.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看起始位、停止位和奇偶校验位。
- en: The start, stop, and parity bits
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 起始位、停止位和奇偶校验位
- en: These bits form the backbone of the UART protocol, allowing devices to synchronize
    and verify the integrity of the transmitted data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些位构成了UART协议的骨架，允许设备同步并验证传输数据的完整性。
- en: Start bit
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 起始位
- en: The start bit is the initial signal that marks the beginning of a data frame
    in UART communication. When the transmitting device is idle, the data line is
    held at a high voltage level (logic 1). To signal the start of transmission, the
    UART transmitter pulls the line to a low voltage level (logic 0) for a 1-bit duration.
    This transition from high to low alerts the receiving device that a new data packet
    is incoming, allowing it to synchronize and prepare for data reception.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 起始位是UART通信中标记数据帧开始的初始信号。当发送设备处于空闲状态时，数据线保持在高电压水平（逻辑1）。为了表示传输的开始，UART发送器将线路拉低到低电压水平（逻辑0），持续1位时间。这种从高到低的转换通知接收设备有新的数据包到来，允许它同步并准备接收数据。
- en: Stop bit
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 停止位
- en: After the data bits and optional parity bit are transmitted, the stop bit signals
    the end of the data frame. The transmitter drives the data line back to a high
    voltage level (logic 1) for 1 or 2-bit durations, depending on the configuration.
    The stop bit(s) ensure that the receiver has time to process the last data bit
    and prepare for the next start bit. In essence, the stop bit acts as a buffer,
    providing a clear demarcation between successive data frames and helping maintain
    synchronization between the communicating devices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据位和可选的奇偶校验位传输之后，停止位表示数据帧的结束。发送器将数据线驱动回高电压水平（逻辑1），持续1或2位时间，具体取决于配置。停止位确保接收器有足够的时间处理最后一个数据位并为下一个起始位做准备。本质上，停止位充当缓冲区，在连续的数据帧之间提供清晰的分隔，并帮助保持通信设备之间的同步。
- en: Parity bit
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 奇偶校验位
- en: 'The parity bit is an optional feature that’s used for basic error checking
    in UART communication. It provides a simple method to detect errors that may have
    occurred during data transmission. The parity bit can be configured for either
    even or odd parity:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 奇偶校验位是UART通信中用于基本错误检查的可选功能。它提供了一种简单的方法来检测在数据传输过程中可能发生的错误。奇偶校验位可以配置为偶校验或奇校验：
- en: '**Even parity**: The parity bit is set to 0 if the number of 1s in the data
    frame is even, and set to 1 if the number of 1s is odd. This ensures that the
    total number of 1s (including the parity bit) is even.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偶校验**：如果数据帧中1的数量是偶数，则奇偶校验位设置为0；如果1的数量是奇数，则设置为1。这确保了包括奇偶校验位在内的1的总数是偶数。'
- en: '**Odd parity**: The parity bit is set to 0 if the number of 1s in the data
    frame is odd, and set to 1 if the number of 1s is even. This ensures that the
    total number of 1s (including the parity bit) is odd.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**奇校验**：如果数据帧中1的数量是奇数，则奇偶校验位设置为0；如果1的数量是偶数，则设置为1。这确保了包括奇偶校验位在内的1的总数是奇数。'
- en: When the receiver gets the data frame, it checks the parity bit against the
    received data bits. If there’s a mismatch, it indicates that an error occurred
    during transmission. While parity doesn’t correct errors, it helps in identifying
    them, prompting for retransmission if necessary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收方接收到数据帧时，它会将奇偶校验位与接收到的数据比特进行比较。如果存在不匹配，则表明在传输过程中发生了错误。虽然奇偶校验不能纠正错误，但它有助于识别错误，并在必要时提示重新传输。
- en: The start, stop, and parity bits are essential components of UART communication,
    each playing a critical role in ensuring data integrity and synchronization. The
    start bit signals the beginning of transmission, the stop bit marks the end, and
    the parity bit provides a basic error-checking mechanism. Together, they create
    a robust framework for reliable and efficient serial communication between devices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 开始位、停止位和奇偶校验位是 UART 通信的基本组成部分，每个部分都在确保数据完整性和同步方面发挥着关键作用。开始位表示传输的开始，停止位标记传输的结束，奇偶校验位提供基本的错误检查机制。它们共同构成了一个可靠且高效的设备间串行通信框架。
- en: Before wrapping up this section, let’s take a moment to understand the unit
    of speed that’s used in UART communication.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，让我们花一点时间来了解在 UART 通信中使用的速度单位。
- en: Understanding the baud rate – the speed of communication in embedded systems
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解波特率——嵌入式系统中通信的速度
- en: In the world of embedded systems, **baud rate** is a term you’ll encounter frequently.
    Whether you’re debugging a microcontroller, setting up a serial communication
    link, or working with various peripherals, understanding the baud rate is essential.
    But what exactly is the baud rate, and why is it so important? Let’s break it
    down.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统领域，**波特率**是一个你经常会遇到的术语。无论你是调试微控制器、设置串行通信链路还是处理各种外围设备，理解波特率都是至关重要的。但波特率究竟是什么，为什么它如此重要呢？让我们来分析一下。
- en: What is the baud rate?
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 波特率是什么？
- en: 'The baud rate is essentially the speed at which data is transmitted over a
    communication channel. It’s measured in **bits per second** (**bps**). Think of
    it as the speed limit on a highway: the higher the baud rate, the more data can
    travel along the communication path in a given amount of time.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 波特率本质上是指数据在通信信道上传输的速度。它以每秒比特数（**bps**）来衡量。把它想象成高速公路上的限速：波特率越高，在给定时间内沿通信路径传输的数据就越多。
- en: For example, a baud rate of *9,600* means *9,600 bits* of data are transmitted
    each *second*. In other words, it sets the pace for how fast data packets are
    sent and received.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，波特率为 *9,600* 意味着每 *秒* 传输 *9,600 比特* 的数据。换句话说，它设定了数据包发送和接收的速度。
- en: However, it’s important to distinguish between the baud rate and the **bit rate**.
    While the baud rate refers to the number of signal changes per second, the bit
    rate is the number of bits transmitted per second. In simple systems, *each signal
    change can represent one bit*, making the baud rate and bit rate the same. In
    more complex systems, each signal change can represent multiple bits, resulting
    in a bit rate higher than the baud rate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，区分波特率和比特率非常重要。波特率指的是每秒信号变化的次数，而比特率是每秒传输的比特数。在简单的系统中，*每次信号变化可以代表一个比特*，这使得波特率和比特率相同。在更复杂的系统中，每次信号变化可以代表多个比特，从而导致比特率高于波特率。
- en: Why does the baud rate matter?
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么波特率很重要？
- en: Imagine trying to have a conversation with someone who speaks at a wildly different
    speed than you. It would be confusing and inefficient, right? The same principle
    applies to electronic devices communicating with each other. Both the transmitting
    and receiving devices need to agree on a common baud rate to understand each other
    correctly. If they don’t, the data might get lost or garbled, leading to communication
    errors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下试图与一个说话速度与你截然不同的人交谈。这将令人困惑且效率低下，对吧？同样的原则也适用于电子设备之间的通信。发送和接收设备需要就一个共同的波特率达成一致，以便正确理解对方。如果它们不一致，数据可能会丢失或混乱，从而导致通信错误。
- en: For successful communication, both the sender and receiver must have the same
    baud rate to synchronize correctly. If one device is set to 9,600 bps and the
    other to 115,200 bps, the communication will fail, similar to how a conversation
    fails if one person is speaking too fast or too slow for the other to understand.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功通信，发送方和接收方必须具有相同的波特率以正确同步。如果一个设备设置为 9,600 bps，而另一个设置为 115,200 bps，通信将失败，就像一个人说话太快或太慢以至于对方无法理解时，对话会失败一样。
- en: 'There are standard baud rates that are commonly used in serial communication.
    Here are a few:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在串行通信中，有一些标准波特率被广泛使用。以下是一些示例：
- en: '**300 bps**: Very slow, often used for long-distance communication where bandwidth
    is limited'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**300 bps**: 非常慢，常用于带宽受限的长距离通信'
- en: '**9,600 bps**: A widely used default rate for many devices, including microcontrollers'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**9,600 bps**: 许多设备，包括微控制器广泛使用的默认速率'
- en: '**19,200 bps**: Faster, often used in more data-intensive applications'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**19,200 bps**: 更快，常用于数据密集型应用'
- en: '**115,200 bps**: High-speed communication, common in applications requiring
    quick data transfer'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**115,200 bps**: 高速通信，常见于需要快速数据传输的应用'
- en: This concludes our overview of the UART protocol. In the next section, we will
    explore the UART peripheral in the STM32F4 microcontroller.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 UART 协议的概述。在下一节中，我们将探讨 STM32F4 微控制器中的 UART 外设。
- en: The STM32F4 UART peripheral
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STM32F4 UART 外设
- en: 'STM32 microcontrollers often include several UART peripherals, though the number
    varies depending on the specific model. The STM32F411 microcontroller has three
    UART peripherals:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: STM32 微控制器通常包含多个 UART 外设，但具体数量取决于具体型号。STM32F411 微控制器有三个 UART 外设：
- en: USART1
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USART1
- en: USART2
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USART2
- en: USART6
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USART6
- en: USART versus UART
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: USART 与 UART 的比较
- en: 'Our STM32 documentation refers to the UART peripheral as **USART** because
    it stands for universal **synchronous/asynchronous** receiver/transmitter. This
    name reflects the dual functionality of the peripheral:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 STM32 文档将 UART 外设称为 **USART**，因为它代表通用 **同步/异步** 接收/发送器。这个名字反映了外设的双重功能：
- en: '**Asynchronous mode** (**UART**): In this mode, the USART operates as a traditional
    UART. It transmits and receives data without needing a clock signal, which is
    typical for standard serial communication.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步模式** (**UART**): 在此模式下，USART 作为传统的 UART 运行。它不需要时钟信号即可发送和接收数据，这是标准串行通信的典型特征。'
- en: '**Synchronous mode** (**USART**): In this mode, the USART can also operate
    with a synchronous clock signal, allowing it to communicate with devices that
    require a clock line in addition to the data lines.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步模式** (**USART**): 在此模式下，USART 也可以使用同步时钟信号进行操作，允许它与除了数据线外还需要时钟线的设备进行通信。'
- en: Let’s analyze the key registers of this peripheral, starting with the USART
    Status Register.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析此外设的关键寄存器，从 USART 状态寄存器开始。
- en: USART Status Register (USART_SR)
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: USART 状态寄存器 (USART_SR)
- en: The `USART_SR` register is one of the main registers used to monitor the status
    of the UART peripheral. It provides real-time information about various operational
    flags and errors.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`USART_SR` 寄存器是用于监控 UART 外设状态的主要寄存器之一。它提供了关于各种操作标志和错误的实时信息。'
- en: 'Let’s consider the key bits in this register:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑此寄存器中的关键位：
- en: '**Transmit data register empty** (**TXE**): This bit is set when the data register
    is empty and ready for new data to be written. It indicates that the transmitter
    can send more data.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送数据寄存器空** (**TXE**): 当数据寄存器为空且准备好写入新数据时，该位被设置。这表示发送器可以发送更多数据。'
- en: '**Read data register not empty** (**RXNE**): This bit indicates that the data
    register contains data that has not been read yet. It signals that there is incoming
    data to be processed.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取数据寄存器非空** (**RXNE**): 该位指示数据寄存器包含尚未读取的数据。它表示有要处理的数据传入。'
- en: '**Transmission complete** (**TC**): This bit is set when the last transmission
    has been completed, including all the stop bits. It shows that the data has been
    fully sent.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输完成** (**TC**): 当最后一个传输完成，包括所有停止位时，该位被设置。它表示数据已完全发送。'
- en: '**Overrun error** (**ORE**): This bit indicates that the data was lost because
    the data register wasn’t read before new data arrived. It flags an error condition.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**溢出错误** (**ORE**): 该位指示数据丢失，因为数据寄存器在新数据到达之前没有被读取。它表示一个错误条件。'
- en: You can find detailed information about this register on *page 547* of the *STM32F411
    reference manual (RM0383)*. Next, we have the `USART_DR`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *STM32F4 参考手册 (RM0383)* 的 *第547页* 找到关于此寄存器的详细信息。接下来，我们有 `USART_DR`)。
- en: USART Data Register (USART_DR)
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: USART 数据寄存器 (USART_DR)
- en: The `USART_DR` register is used for both transmitting and receiving data. It
    acts as the primary interface for data exchange through the UART peripheral.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`USART_DR` 寄存器用于发送和接收数据。它作为通过 UART 外设进行数据交换的主要接口。'
- en: 'The following are the key functions in this register:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此寄存器中的关键功能如下：
- en: '`USART_DR` sends the data through the TX line. The UART peripheral handles
    the conversion and transmission serially.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USART_DR` 通过 TX 线发送数据。UART 外设以串行方式处理转换和传输。'
- en: '`USART_DR` retrieves the data received on the RX line. This should be done
    promptly to avoid data overrun.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USART_DR` 从 RX 线上检索接收到的数据。这应该立即完成，以避免数据溢出。'
- en: Next, we have the `USART_BRR`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `USART_BRR`)。
- en: USART Baud Rate Register (USART_BRR)
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: USART 波特率寄存器 (USART_BRR)
- en: The `USART_BRR` register is used to set the baud rate for the UART communication,
    which is critical for synchronizing the data transfer speed between devices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`USART_BRR` 寄存器用于设置 UART 通信的波特率，这对于同步设备之间的数据传输速度至关重要。'
- en: 'This register has two fields:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此寄存器有两个字段：
- en: '**Mantissa**: The integer part of the division factor that sets the baud rate'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尾数**：设置波特率的分频因子的整数部分'
- en: '**Fraction**: The fractional part of the division factor that fine-tunes the
    baud rate'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分数**：分频因子的分数部分，用于微调波特率'
- en: The final register we will examine is the `USART_CR1`).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一个寄存器是 `USART_CR1`）。
- en: USART Control Register 1 (USART_CR1)
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: USART 控制寄存器 1 (USART_CR1)
- en: The `USART_CR1` register is a comprehensive control register that enables various
    UART functionalities and configurations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`USART_CR1` 寄存器是一个综合控制寄存器，它启用了各种 UART 功能和配置。'
- en: 'Let’s consider the key bits in this register:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑此寄存器中的关键位：
- en: '**USART enable** (**UE**): This bit enables or disables the UART peripheral.
    It must be set to activate UART communication.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USART 使能** (**UE**)：此位启用或禁用 UART 外设。它必须设置为激活 UART 通信。'
- en: '**Word length** (**M**): This bit configures the word length, allowing 8-bit
    or 9-bit data frames.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字长度** (**M**)：此位配置字长度，允许 8 位或 9 位数据帧。'
- en: '**Parity control enable** (**PCE**): This bit enables parity checking for error
    detection.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**奇偶校验控制使能** (**PCE**)：此位启用奇偶校验以检测错误。'
- en: '**Parity selection** (**PS**): This bit selects even or odd parity.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**奇偶校验选择** (**PS**)：此位选择偶校验或奇校验。'
- en: '**Transmitter enable** (**TE**): This bit enables the transmitter, allowing
    data to be sent.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送器使能** (**TE**)：此位启用发送器，允许发送数据。'
- en: '**Receiver enable** (**RE**): This bit enables the receiver, allowing data
    to be received.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收器使能** (**RE**)：此位启用接收器，允许接收数据。'
- en: With these registers in mind, we’re now ready to develop the UART driver. We
    will dive into that in the next section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了这些寄存器之后，我们现在可以开始开发 UART 驱动程序。我们将在下一节中深入探讨。
- en: Developing the UART driver
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 UART 驱动程序
- en: In this section, we will apply everything we’ve learned about the UART peripheral
    to develop a driver for transmitting data using the `USART2` peripheral.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将应用我们关于 UART 外设所学的所有知识，开发一个使用 `USART2` 外设发送数据的驱动程序。
- en: 'Let’s begin by identifying the GPIO pins connected to the UART2 peripheral.
    To do this, refer to the table on *page 39* of the *STM32F411RE datasheet*. This
    table lists all the GPIO pins of the microcontroller, along with their descriptions
    and additional functionalities. As shown in *Figure 10**.3*, part of this table
    reveals that PA1 has an alternate function labeled as `USART2_TX`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先识别连接到 UART2 外设的 GPIO 引脚。为此，请参考 STM32F411RE 数据表第 39 页的表格。此表列出了微控制器的所有 GPIO
    引脚，以及它们的描述和附加功能。如图 10**.3** 所示，此表的一部分显示 PA1 有一个标记为 `USART2_TX` 的交替功能：
- en: '![Figure 10.3: The USART2_TX pin](img/B21914_10_3.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3：USART2_TX 引脚](img/B21914_10_3.jpg)'
- en: 'Figure 10.3: The USART2_TX pin'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：USART2_TX 引脚
- en: 'To use PA2 as the `USART2_TX` line, we need to configure `PA2` as an alternate
    function pin in the `GPIOA_MODER` register and then specify the alternate function
    number for `USART2_TX` in the `GPIOA_AFRL` register. The STM32F4 microcontroller
    allows us to choose from 16 different alternate functions, numbered from `AF00`
    to `AF15`. The alternate function mapping table, which you can find on *page 47*
    of the datasheet, outlines these functions and their corresponding numbers. As
    shown in *Figure 10**.4*, sourced from the datasheet, configuring `PA2` as `AF07`
    will set it to function as the `USART2_TX` line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 PA2 作为 `USART2_TX` 线使用，我们需要在 `GPIOA_MODER` 寄存器中将 `PA2` 配置为交替功能引脚，然后在 `GPIOA_AFRL`
    寄存器中指定 `USART2_TX` 的交替功能编号。STM32F4 微控制器允许我们从 16 个不同的交替功能中选择，编号从 `AF00` 到 `AF15`。数据表中的交替功能映射表（您可以在数据表的第
    47 页找到），概述了这些功能和它们对应的编号。如图 10**.4** 所示，该图来自数据表，配置 `PA2` 为 `AF07` 将将其设置为作为 `USART2_TX`
    线的功能：
- en: '![Figure 10.4: PA2 alternate function](img/B21914_10_4.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4：PA2 交替功能](img/B21914_10_4.jpg)'
- en: 'Figure 10.4: PA2 alternate function'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：PA2 交替功能
- en: We now have all the information we need to develop the UART2 transmitter driver.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了开发 UART2 发送器驱动程序所需的所有信息。
- en: 'Create a copy of your previous project and rename it `UART`. Next, create a
    new file named `uart.c` in the `Src` folder and another file named `uart.h` in
    the `Inc` folder. Populate your `uart.c` file with the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你之前项目的副本，并将其重命名为 `UART`。接下来，在 `Src` 文件夹中创建一个名为 `uart.c` 的新文件，并在 `Inc` 文件夹中创建一个名为
    `uart.h` 的新文件。用以下代码填充你的 `uart.c` 文件：
- en: '[PRE0]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s break it down.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解。
- en: First, we have the necessary includes and macros.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有必要的包含和宏定义。
- en: '[PRE1]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are the uses of the macros:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是宏的使用方法：
- en: '`GPIOAEN`: This macro enables the clock for GPIOA by setting bit 0 in the `AHB1ENR`
    register.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOAEN`：此宏通过在 `AHB1ENR` 寄存器中设置位 0 来启用 GPIOA 的时钟。'
- en: '`UART2EN`: This macro enables the clock for UART2 by setting bit 17 in the
    `APB1ENR` register.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UART2EN`：此宏通过在 `APB1ENR` 寄存器中设置位 17 来启用 UART2 的时钟。'
- en: '`DBG_UART_BAUDRATE`: This macro defines the baud rate for UART communication,
    set to `115200` bps.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBG_UART_BAUDRATE`：此宏定义 UART 通信的波特率，设置为 `115200` bps。'
- en: '`SYS_FREQ`: This macro defines the system frequency, set to 16 MHz, and the
    default frequency of the STM32F411 microcontroller on the NUCLEO development board.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYS_FREQ`：此宏定义系统频率，设置为 16 MHz，并且是 NUCLEO 开发板上 STM32F411 微控制器的默认频率。'
- en: '`APB1_CLK`: This macro sets the APB1 peripheral clock frequency to the system
    frequency (16 MHz).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APB1_CLK`：此宏将 APB1 外设时钟频率设置为系统频率（16 MHz）。'
- en: '`CR1_TE`: This macro enables the transmitter by setting bit 3 in the `USART_CR1`
    register.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CR1_TE`：此宏通过在 `USART_CR1` 寄存器中设置位 3 来启用发射器。'
- en: '`CR1_UE`: This macro enables the UART module by setting bit 13 in the `USART_CR1`
    register.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CR1_UE`：此宏通过在 `USART_CR1` 寄存器中设置位 13 来启用 UART 模块。'
- en: '`SR_TXE`: This macro represents the TXE bit in the `USART_SR` register.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SR_TXE`：此宏代表 `USART_SR` 寄存器中的 TXE 位。'
- en: 'Next, we have the helper functions for computing and setting the baud rate:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有计算和设置波特率的辅助函数：
- en: '[PRE2]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This helper function calculates the baud rate divisor. It uses the peripheral
    clock and desired baud rate to compute the value to be set in the **Baud Rate**
    **Register** (**BRR**):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此辅助函数计算波特率除数。它使用外设时钟和所需的波特率来计算要设置在 **波特率** **寄存器**（**BRR**）中的值：
- en: '[PRE3]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function sets the baud rate for UART2 by writing the computed divisor
    to the BRR. Let’s turn our focus to the initialization function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过将计算出的除数写入 BRR 来设置 UART2 的波特率。让我们将注意力转向初始化函数：
- en: '[PRE4]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This line enables the clock for GPIOA by setting the appropriate bit in the
    AHB1 peripheral clock enable register:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 AHB1 外设时钟使能寄存器中设置适当的位，此行启用了 GPIOA 的时钟：
- en: '[PRE5]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These lines configure pin PA2 to operate in alternate function mode, which
    is necessary for UART functionality:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将引脚 PA2 配置为在备用功能模式下操作，这对于 UART 功能是必要的：
- en: '[PRE6]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These lines configure PA2 as an alternate function (`AF7`), which corresponds
    to `UART2_TX`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将 PA2 配置为备用功能（`AF7`），对应于 `UART2_TX`：
- en: '[PRE7]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This line enables the clock for UART2 by setting the appropriate bit in the
    APB1 peripheral clock enable register:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 APB1 外设时钟使能寄存器中设置适当的位，此行启用了 UART2 的时钟：
- en: '[PRE8]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function call sets the baud rate for UART2 using the `uart_set_baudrate()`
    function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用使用 `uart_set_baudrate()` 函数设置 UART2 的波特率：
- en: '[PRE9]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This configures UART2 for transmission by setting the transmitter enable bit
    in the control register:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在控制寄存器中设置发射使能位，此配置将 UART2 配置为传输模式：
- en: '[PRE10]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This enables the UART2 module by setting the UART enable bit in the control
    register.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在控制寄存器中设置 UART 使能位，此操作启用了 UART2 模块。
- en: 'Next, we have the function for writing to UART:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有写入 UART 的函数：
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s break it down:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解：
- en: '[PRE12]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This loop ensures that the transmit data register is empty before we write
    new data:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环确保在写入新数据之前，传输数据寄存器是空的：
- en: '[PRE13]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This line writes the character to the data register for transmission.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此行将字符写入数据寄存器以进行传输。
- en: 'Finally, we have a useful function that allows us to redirect `printf` output
    to our UART transmitter:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个有用的函数，允许我们将 `printf` 输出重定向到我们的 UART 发送器：
- en: '[PRE14]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It calls `uart_write()` to send the character and then returns the character.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用 `uart_write()` 发送字符，然后返回字符。
- en: After sending the character, `__io_putchar` returns the same character, `ch`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 发送字符后，`__io_putchar` 返回相同的字符，`ch`。
- en: Returning the character is a standard practice, allowing the function to comply
    with the typical `putchar` function signature, which returns the character written
    as an `int` variable.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 返回字符是一种标准做法，允许函数符合典型的 `putchar` 函数签名，该签名返回作为 `int` 变量的写入字符。
- en: 'Our next task is to populate the `uart.h` file. Here’s the code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是填充`uart.h`文件。以下是代码：
- en: '[PRE15]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#include <stdio.h>'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: '#include "uart.h"'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "uart.h"'
- en: int main(void)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: int main(void)
- en: '{'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /*Initialize debug UART*/
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: /*初始化调试串口*/
- en: uart_init();
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: uart_init();
- en: while(1)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: while(1)
- en: '{'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: printf("Hello from STM32...\r\n");
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: printf("来自STM32的问候...\r\n");
- en: '}'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE16]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
