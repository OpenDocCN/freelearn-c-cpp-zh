- en: Adding Enemies!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加敌人！
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'For most games involving combat, there are typically **non-player characters**
    (**NPCs**) in one form or another. NPCs give a feeling of realism and interaction
    to games, and the AI that controls them makes them believable (or not!), so it
    is very important to get it right. Making the most of UE4s BehaviorTree is a very
    important step to making games efficiently with compelling enemies and friends.
    In this chapter, we will make a basic melee enemy that will use bits of information
    from the world to update its choices in its BehaviorTree and react to the player
    appropriately. We''ll also delve into a bit of debugging the tree and its data. 
    Our main goals here will be:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数涉及战斗的游戏，通常都存在一种或多种形式的**非玩家角色**（NPCs）。NPCs为游戏增添了真实感和互动性，控制它们的AI使它们看起来可信（或不可信），因此正确地处理这一点非常重要。充分利用UE4的BehaviorTree是制作具有吸引力的敌人和朋友的游戏的重要步骤。在本章中，我们将制作一个基本的近战敌人，它将使用来自世界的信息来更新其在BehaviorTree中的选择，并适当地对玩家做出反应。我们还将深入调试树及其数据。我们在这里的主要目标将是：
- en: Importing a new character and skeletal mesh to the game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新角色和骨骼网格导入到游戏中
- en: Creating a new AIController class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的AIController类
- en: Building a basic Behavior Tree brain
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个基本的Behavior Tree大脑
- en: Add sensing via C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过C++添加感知功能
- en: Hook up behavior to the Animation Blueprint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将行为连接到Animation Blueprint
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As always, it's recommended to follow the progress in all the preceding chapters;
    however, the bulk of this chapter will work as a standalone project as well, with
    a few exceptions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，建议跟随所有前面的章节进度；然而，本章的大部分内容将作为一个独立项目工作，但有少数例外。
- en: 'The chapter''s GitHub branch is, as usual, here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub分支，如往常一样，在这里：
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-5](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-5)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-5](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-5)'
- en: 'Engine version used: 4.19.2.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的引擎版本：4.19.2。
- en: Creating an AI controller and a basic brain
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个AI控制器和一个基本的大脑
- en: Much like adding new weapons in the last chapter, we're going to want some interesting
    new visuals for our AI enemies, so let's head back to the marketplace and see
    what is freely available. The Paragon project (which was canceled) yielded a huge
    amount of assets released for free by Epic, so let's import one or more of their
    characters that we can use for our enemies. Then we give them a controller, spawn
    them in our level, and see how their brain makes decisions and ultimately becomes
    a challenging opponent for our player to fight!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一章添加新武器一样，我们希望为我们的AI敌人添加一些有趣的新视觉效果，所以让我们回到市场看看有什么免费提供的。天选者项目（该项目已被取消）由Epic发布了大量免费资产，所以让我们导入一个或多个他们的角色，我们可以用这些角色作为我们的敌人。然后我们给他们一个控制器，在我们的关卡中生成它们，看看它们的思维是如何做出决策，最终成为玩家战斗的挑战性对手！
- en: Proving out the basics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证基础
- en: 'In the marketplace, to prove out our concept, the GitHub project will begin
    by importing the Paragon: Countess assets the same way we did at the beginning
    of [Chapter 4](eadb37a8-4ecb-4fc9-b391-e65671c99fc0.xhtml), *UI Necessities –
    Menus, HUD, and Load/Save*. Note that to save approximately 200 MB of the approximately
    2 GB download of such a high-detail character, the Tier 2 skins were removed from
    GitHub, but of course you''re welcome to use any of the many amazingly detailed
    characters that were released from the Paragon project. Once the character is
    added to the project, there are three main steps to getting it doing anything
    meaningful in the game:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '在市场中，为了验证我们的概念，GitHub项目将首先以与[第4章](eadb37a8-4ecb-4fc9-b391-e65671c99fc0.xhtml)开头相同的方式导入Paragon:
    Countess资产，*UI需求 – 菜单、HUD和加载/保存*。请注意，为了节省大约200 MB的约2 GB的高清角色下载，GitHub中移除了Tier
    2皮肤，但当然，您可以使用Paragon项目发布的许多令人惊叹的高清角色中的任何一种。一旦角色被添加到项目中，要使其在游戏中做有意义的事情，有三个主要步骤：'
- en: Create a new `AIController` class and make a blueprint instance of it (here,
    it's called `MeleeAIController`).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`AIController`类并创建它的蓝图实例（在这里，它被称为`MeleeAIController`）。
- en: Add an AnimationBlueprint for and hook it to a new Character.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为角色添加一个AnimationBlueprint并将其连接到新的角色。
- en: Add a BehaviorTree to the controller with some nodes to get it to start, well,
    behaving.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制器添加一个带有一些节点的BehaviorTree，使其开始，嗯，表现良好。
- en: Getting some basic functionality from the behavior tree takes a little bit of
    additional basics, but let's go through these quickly one step at a time to get
    a basic functioning pawn in the game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从行为树获取一些基本功能需要一些额外的基础知识，但让我们一步一步快速地通过这些，以获得游戏中的基本功能。
- en: 'Upon creating the AI controller, for now just add one variable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建AI控制器时，目前只需添加一个变量：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make a blueprint instance of this in FirstPersonCPP/AI and name it CountessController.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在FirstPersonCPP/AI中创建一个蓝图实例，命名为CountessController。
- en: 'In ParagonCountess | Characters | Global, make a new Animation | Animation
    Blueprint class. When you do this, it will ask for a parent class and a skeleton:
    use AnimInstance and S_Countess_Skeleton respectively. Once created, name it `ABP_Countess`
    and double-click that to bring up its editor. If you click the AnimGraph tab,
    you can see one simple node, drag from its input and filter to StateMachine, and
    add a new one and double-click it. Drag from Entry and add a state. Name it Idle
    and double-click it and we will be done with a very temporary animation blueprint
    with one quick node, like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在ParagonCountess | Characters | Global中，创建一个新的动画 | 动画蓝图类。当你这样做时，它会要求选择一个父类和一个骨架：分别使用AnimInstance和S_Countess_Skeleton。一旦创建，将其命名为`ABP_Countess`，双击它以打开其编辑器。如果你点击动画图标签页，你可以看到一个简单的节点，从其输入拖动到状态机并添加一个新的节点，双击它。从入口拖动并添加一个状态。命名为Idle，双击它，我们就完成了一个非常临时的动画蓝图，只有一个快速节点，如下所示：
- en: '![](img/be6ad5bd-23a2-4fec-a4be-d3cabefc7444.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be6ad5bd-23a2-4fec-a4be-d3cabefc7444.png)'
- en: 'To use and test our character at all, first make a new Blueprint Class in FirstPersonCPP/AI based
    on Character, and name it `BP_Countess`. We will set it up to look like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用和测试我们的角色，首先在FirstPersonCPP/AI中基于Character创建一个新的蓝图类，命名为`BP_Countess`。我们将将其设置如下：
- en: '![](img/d851f969-da3e-4581-8f2b-4bdc4ea07f84.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d851f969-da3e-4581-8f2b-4bdc4ea07f84.png)'
- en: Note the capsule root component for collision purposes, and the mesh's position
    and rotation offsets to get things looking right on the ground in game. Also,
    click the (self) component at the top and set AIController to CountessController.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意胶囊根组件用于碰撞目的，以及网格的位置和旋转偏移，以在游戏中使事物看起来正确地放在地面上。此外，点击顶部的（self）组件，并将AIController设置为CountessController。
- en: 'Now for the most relevant part, but note that this is also going to be in a
    very bare-bones state for the moment as we simply get all our classes and requirements
    blocked out. As noted previously, whenever it''s possible to get things working
    at a basic level and checked in to source control as a checkpoint, this is a great
    idea even if the overall work changes (or classes are even deleted) as the task
    progresses. This gives a safe fallback point if anything goes wrong, and when
    you''re working in a team it allows for easy sharing of the state of your work,
    so we''ll do that once our basic tree is in. In our AI folder, right-click and
    under Artificial Intelligence and add a Behavior Tree and a Blackboard. Name them
    MeleeTree and MeleeBoard respectively. Opening the blackboard, we will add two
    keys by using the add button in the top left. Make one an object type and the
    other a vector, and we''ll name them Target and TargetLocation respectively on
    the right side of the editor in their properties. Opening the behavior tree next,
    we first click the button near the top to add a new service. This will create
    it for you at the same folder level in the content browser. Rename it `BTService_FindTarget`
    and double-click it. This service works as a piece of blueprint scripting you
    can use in various places in a behavior tree. It''s the only complicated portion
    of what we''ll currently check-in, and building its graph looks like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最相关的一部分，但请注意，目前这也会处于一个非常简化的状态，因为我们只是简单地阻塞出所有我们的类和需求。如前所述，每当有可能在基本级别上使事物工作并检查到源控制作为检查点时，即使整体工作发生变化（或类甚至被删除），这也是一个好主意。这为出错时提供了一个安全的回退点，并且当你在团队中工作时，它允许轻松共享你工作的状态，所以一旦我们的基本树就绪，我们将这样做。在我们的AI文件夹中，右键单击，在人工智能下添加一个行为树和一个黑板。分别命名为MeleeTree和MeleeBoard。打开黑板，我们将使用编辑器右上角的添加按钮添加两个键。将一个设置为对象类型，另一个设置为向量，并在编辑器的属性右侧将它们命名为Target和TargetLocation。接下来，打开行为树，我们首先点击顶部附近的一个按钮以添加一个新的服务。这将为您在内容浏览器中的同一文件夹级别创建它。将其重命名为`BTService_FindTarget`并双击它。这个服务作为可以在行为树中使用的蓝图脚本的片段。这是我们目前要检查的唯一的复杂部分，构建其图看起来如下：
- en: '![](img/5643f1ab-a62e-431e-b3ff-7c5d845d06ea.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5643f1ab-a62e-431e-b3ff-7c5d845d06ea.png)'
- en: 'Hopefully, by now this is fairly straightforward: the owning actor of any behavior
    tree service is the AI controller. We then get our hearing radius from that and
    do a sphere sweep for any MasteringCharacter pawns and, assuming we find one,
    we set the target and target location variables (by name!) to update to our player
    location. Blackboards, as the name implies, are a place to post data from various
    outside locations that can then be directly accessed internally by a behavior
    tree. Just think of them as variable holders using key/value pairs.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在为止，这已经很直接了：任何行为树服务的拥有者都是 AI 控制器。然后我们从那里获取我们的听觉半径，并对任何 MasteringCharacter
    pawn 进行球面扫描，如果我们找到了一个，我们就设置目标和目标位置变量（通过名称！）以更新到玩家位置。正如其名所示，黑板是一个可以发布来自各种外部位置的数据的地方，然后行为树可以直接内部访问。只需把它们想象成使用键/值对的变量持有者。
- en: 'Now that we have that done, we can make a super-simple behavior tree. First,
    confirm its blackboard in the root''s details is set to MeleeBoard. Next, in its
    main editing area, drag down on the behavior tree''s root and add a selector node.
    The quickest way to think about selectors and sequencers is that both do a set
    of tasks (which can, of course, have child selectors and sequencers), but selectors
    run from left to right through their children until one succeeds (and then it
    returns control back up the tree). A selector runs left to right until one of
    its children fails. On this selector, right-click its node and click Add Service.
    Of course, we''ll select our find target service and click it so that in its properties
    in its details window, we can just remove the random time interval (set to `0.0`)
    so it runs every half second. And lastly, dragging from the selector, pick a task
    and use MoveTo, and set its blackboard key to TargetLocation in its details window,
    and set its Acceptable Radius to 100.0 so she doesn''t get too close for comfort:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这些，我们可以创建一个超级简单的行为树。首先，确认根的详细信息中的黑板设置为 MeleeBoard。接下来，在其主要编辑区域，向下拖动行为树的根并添加一个选择节点。关于选择器和顺序器的快速思考方式是，两者都执行一系列任务（当然，可以有子选择器和顺序器），但选择器从左到右运行其子节点，直到有一个成功（然后它返回控制权到树的上层）。选择器从左到右运行，直到其子节点之一失败。在这个选择器上，右键单击其节点并点击“添加服务”。当然，我们将选择我们的查找目标服务并点击它，这样我们就可以在其详细窗口的属性中直接删除随机时间间隔（设置为
    `0.0`），使其每半秒运行一次。最后，从选择器拖动，选择一个任务并使用 MoveTo，在其详细窗口中设置其黑板键为 TargetLocation，并将其可接受半径设置为
    100.0，这样她就不会太靠近而感到不舒服：
- en: 'Note on navigation: to generate a nav-mesh used by the behavior here, we need
    to add a NavMesh volume to the level and have it encompass everywhere you want
    AI to be able to traverse. Going forward, adding one of these volumes (or many
    in finer detailed areas) should be standard practice. A quick link about NavMesh
    volumes will be added to the *Further reading* section at the end.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导航的说明：要生成这里行为使用的 nav-mesh，我们需要在级别中添加一个 NavMesh 体积，并使其覆盖你希望 AI 能够穿越的所有地方。从现在开始，添加这些体积（或在更详细的区域添加多个）应该是标准做法。将在
    *进一步阅读* 部分添加一个关于 NavMesh 体积的快速链接。
- en: '![](img/4766233f-8636-4da4-a61f-0a4221bb4371.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4766233f-8636-4da4-a61f-0a4221bb4371.png)'
- en: That's it! Place a `BP_Countess` directly into your level by dragging it in
    and without properly animating or smoothly turning, she should follow you around
    the map! We've reached a major checkpoint in this work, and this will be reflected
    in the GitHub project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！直接将 `BP_Countess` 拖动到你的等级中，无需进行适当的动画或平滑转向，她应该会跟随你在地图周围移动！我们在这个工作中已经达到了一个重要的检查点，这将在
    GitHub 项目中得到体现。
- en: Adding C++ decision making to the behavior tree
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 C++ 决策添加到行为树中
- en: The next process involves taking some of the logic and sensing out of blueprints
    and into C++. This can be valuable for a number of reasons. While the blackboard
    concept works just fine, it can be difficult to manage and even more difficult
    at times to debug than even typical blueprint debugging. If a variable is suddenly
    not what you expected it to be, there isn't always an obvious way to track down
    why. So, having as much logic as is reasonable and possible in C++ is always a
    help. In this instance, we're effectively removing the hearing detection and target
    setting from the preceding task into C++.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个过程涉及将一些逻辑和感知从蓝图移出，进入 C++。这有几个原因可能很有价值。虽然黑板概念运行得很好，但它可能难以管理，有时甚至比典型的蓝图调试更难调试。如果一个变量突然不是你期望的值，并不总是有明显的追踪原因的方法。因此，在
    C++ 中尽可能多地拥有合理的逻辑总是有帮助的。在这个例子中，我们实际上是将听觉检测和目标设置从前面的任务移到了 C++。
- en: 'There are always advantages and disadvantages to this. For example, we won''t
    really get new functionality out of this work here, but we gain a more scalable
    performance and easier debugging as complexity later increases. If no further
    complexity is needed, it''s probably best to stop where we did in the last section
    and call it a day. One major issue arises in synchronizing the two layers, which
    you must. For an example of iterative development, my first instinct was to use
    the `OnTargetChange` blueprint event to simply set our blackboard variable and
    then let the blackboard decorator pull the actor''s location from the target object.
    I remember once encountering a problem when I did this: as the time play begins,
    the blackboard is told to start and, in the same tick, the sphere now added to
    the player will do its initial collision query. When trying to use the edge-driven
    event to set the target, it fails on the first frame as there is no blackboard
    to set a variable on, and it will never correct itself until the player leaves
    the hearing sphere radius and re-enters. So a more pull-driven mixed solution
    was ultimately implemented here as seen here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有利和不利的一面。例如，我们在这里的工作中不会真正获得新的功能，但随着复杂性的增加，我们获得了更可扩展的性能和更易于调试。如果不需要进一步的复杂性，那么最好在我们上一次停止的地方结束，并称之为一天。一个主要问题出现在同步两个层面，这是你必须做的。作为一个迭代开发的例子，我的第一个本能是使用`OnTargetChange`蓝图事件简单地设置我们的黑板变量，然后让黑板装饰者从目标对象中提取演员的位置。我记得有一次我这样做时遇到了问题：当时间播放开始时，黑板被告知开始，在同一个tick中，现在添加到玩家身上的球体将进行初始碰撞查询。当尝试使用边缘驱动的事件来设置目标时，它会在第一帧失败，因为没有黑板来设置变量，并且它将永远不会自行纠正，直到玩家离开听觉球体半径并重新进入。因此，这里最终实施了一个更拉动的混合解决方案，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now the other advantage to this work is that our blueprint FindTarget service
    simplifies significantly, so we can call it every `0.1` seconds (or every frame,
    if desired):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个工作的另一个优点是我们的蓝图FindTarget服务简化了很多，因此我们可以每`0.1`秒（或如果需要，每帧）调用它：
- en: '![](img/889dbe94-d5c7-4c69-9ecf-e8b9452ea589.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/889dbe94-d5c7-4c69-9ecf-e8b9452ea589.png)'
- en: Now you can see this service is just a pass-through, taking the controller's
    target, and note that it uses the Nav Agent Location now too as this is much more
    accurate for navigating too (it typically puts the target location on the same
    plane as the agent trying to navigate there, so *close enough* distances are now
    in 2D rather than a 3D measurement, which is much more intuitive).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到这个服务只是一个中继器，它接受控制器的目标，并注意它现在也使用Nav Agent Location，因为这对于导航来说更准确（它通常将目标位置放置在试图导航的代理所在的同一平面上，因此*足够近*的距离现在是二维而不是三维测量，这更加直观）。
- en: While this was all a relatively simple change, setting such a precedent early
    can be a huge time saver later. Also, note that changing the Hearing Radius value
    in the CountessController blueprint won't immediately change the value of the
    hearing sphere in the blueprint, but when a new one is spawned, the constructor
    will indeed use that new value for the new instance and have the right radius
    for you. For a quick test in the default level, the one existing countess was
    moved to the far right and is now only alerted to the player when she's 6 m away.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个相对简单的改动，但早期设定这样的先例可以在后期节省大量时间。此外，请注意，在CountessController蓝图更改Hearing Radius值不会立即改变蓝图中的听觉球体值，但当一个新实例被生成时，构造函数确实会使用这个新值来为新实例设置正确的半径。为了在默认级别进行快速测试，现有的伯爵夫人被移动到最右边，现在只有当她距离玩家6米时才会被警报。
- en: Attacking the player
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击玩家
- en: 'This section sounds deceptively simple, but you''ll need several missing pieces
    when you step through the design process:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节听起来似乎很简单，但在设计过程中，你需要填补几个缺失的部分：
- en: A fleshed out animation blueprint that can switch the enemy's state while moving
    and attacking
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个详细的动画蓝图，可以在移动和攻击时切换敌人的状态
- en: The enemy's ability to be damaged and killed
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人被伤害和击杀的能力
- en: A decision on how and where attack success is resolved (weapon bounding, a one-frame
    cone-test in front of the enemy, that is, how realistic does hitting the player
    need to be?)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定如何以及在哪里解决攻击成功（武器边界，即在前方敌人面前进行一帧锥形测试，也就是说，击中玩家需要有多真实？）
- en: 'The second step typically involves a bit more of our UI section''s work, and
    the player should similarly be able to be killed and respawned, but these should
    be do-able after all the other lessons to this point and won''t be covered in
    depth here. For things such as healthbars to display over the enemy''s heads,
    see the link on 3D widgets in the *Further reading* section at the end of the
    chapter. The third step is fairly subjective to game complexity: will this be
    a player taking on many enemies at once, or NPCs that fight each other, or is
    it more of a 1-3 enemies at a time versus the player scenario and giving the player
    the absolute feeling of realism is key?'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步通常涉及更多我们UI部分的工 作，玩家也应该能够被杀死并重生，但这些应该在所有其他课程之后才能完成，这里不会深入探讨。关于在敌人头上显示健康条等内容，请参阅章节末尾“进一步阅读”部分中关于3D小部件的链接。第三步对游戏复杂度相当主观：这将是一个玩家同时对抗多个敌人，还是NPC相互战斗，或者更多的是1-3个敌人一次对抗玩家的情况，给玩家带来绝对的真实感是关键？
- en: 'So, as an incremental check-in for this overall work as the next submission
    to GitHub, there are several points to notice here to set the stage for our final
    version: the countess'' animation blueprint is now set to have her run while moving,
    she moves up to an attack radius and will tether back to her start location now
    if she''s dragged away too long without reaching her target, and new modes of
    sensing have been added for vision and a much-reduced hearing radius for stealth
    characters:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为对GitHub上这次整体工作的增量检查，以下是一些需要注意的点，为我们的最终版本做好准备：伯爵夫人的动画蓝图现在设置为在移动时奔跑，她移动到攻击半径，如果被拖得太久没有达到目标，现在会回到起始位置，并且为视觉和潜行角色的极大减少听觉半径添加了新的感知模式：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'One potential improvement could be doing a line-of-sight test to the player
    too. This is not a hard task, but one that players would expect or might notice
    as a bug if we didn''t add it down the road. Note also this change:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的改进是也对玩家进行视线测试。这不是一个困难的任务，但玩家可能会期望或可能会在将来没有添加它时将其视为一个错误。注意以下变化：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`OnReturnedHome` sets all the radii of the spheres to their set variable lengths,
    and in the constructor, `SetReturningHome` is called, which reduces them all to
    zero. I noticed during testing that on the first frame of the game, you got a
    collision with the spheres still at the world origin if you let them perform collision
    before the `Attach` calls in `BeginPlay` are made. Those two functions are also
    used in a new behavior tree task:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnReturnedHome`将所有球体的半径设置为它们的设置变量长度，在构造函数中调用`SetReturningHome`，将它们全部减少到零。我在测试中注意到，如果在`BeginPlay`中的`Attach`调用之前让它们执行碰撞，那么在游戏的第一帧，如果你让它们执行碰撞，你会在世界原点与球体发生碰撞。这两个函数也用于一个新的行为树任务：'
- en: '![](img/b9b7e002-374a-4b24-b6eb-fb10605d21ae.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9b7e002-374a-4b24-b6eb-fb10605d21ae.png)'
- en: 'And there is a very similar new task added for moving to the target so we no
    longer need to worry about the blueprint or updating it (and can remove the old
    find task service entirely at this point), as seen in our new tree with the 5-second
    kiting flow built in:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为移动到目标添加了一个非常类似的新任务，因此我们不再需要担心蓝图或更新它（并且可以完全删除旧的任务查找服务），如我们新树中内置的5秒kiting流程所示：
- en: '![](img/6404039b-0307-4f74-925e-39635f48b2c3.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6404039b-0307-4f74-925e-39635f48b2c3.png)'
- en: The easiest way in the default map to test the kiting-timeout is to go get the
    countless enemy's attention, run to the moving platform previously added, and
    stay on top of the box after that. Once 5 seconds without reaching the player
    pass (you can do this too by running from one side of the map to the other if
    you're careful), you'll see the flow kick over to move to home!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认地图中测试kiting-timeout的最简单方法就是吸引无数敌人的注意，跑到之前添加的移动平台上，并在之后保持在箱子顶部。一旦5秒内没有达到玩家通过（如果你小心的话，也可以通过从地图的一边跑到另一边来做这件事），你就会看到流程切换到移动到家的状态！
- en: The last pieces needed now are a means of switching the countess into an attack
    state and dealing damage to the player, even if the results of that damage aren't
    yet handled. To accomplish this, we need to add a variable to our animation instance
    and set that variable from a task in the behavior tree. We also need a way to
    say the countess can attack, which we will make a wait node in the behavior tree.
    The last thing needed is a quick means of dealing that damage, so we'll add an
    event to the attack animation she uses and when that fires off, we check whether
    the player is in front of her, and she'll hit the player if so.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要的最后部分是切换伯爵到攻击状态并对玩家造成伤害的方法，即使那些伤害的结果尚未处理。为了完成这个任务，我们需要在我们的动画实例中添加一个变量，并从行为树的任务中设置该变量。我们还需要一种方法来说明伯爵可以攻击，我们将在行为树中创建一个等待节点。最后需要的是快速处理伤害的方法，所以我们将向她使用的攻击动画中添加一个事件，当该事件触发时，我们检查玩家是否在她前面，如果是这样，她就会击中玩家。
- en: The most straightforward way of synchronizing a C++ class with our desired state
    is to put an enum in the controller class and have it have a reference to the
    animation instance and set variables on it. There are drawbacks to this, namely,
    these update on separate threads. And those updates aren't even deterministic,
    so you might have a C++ controller update, the animation instance update, the
    animation instance update again, then the C++ controller again, and vice versa.
    So if you choose to have C++ logic dictating the animation blueprint's state,
    beware that there can be up to a 2-frame delay between one desiring a change,
    and the other recognizing it. If you have logic directly from your animation blueprint
    updating that state too, make sure to always have one point of update, typically
    the controller, and it is highly recommended to make this a queue that synchronizes
    between frames and then proceeds to the next queue entry.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将C++类与所需状态同步的最直接方法是在控制器类中放置一个枚举，并使其具有对动画实例的引用，并在其上设置变量。这种方法有缺点，即这些更新在不同的线程上。而且，这些更新甚至不是确定的，所以你可能会有一个C++控制器更新，动画实例更新，动画实例再次更新，然后是C++控制器再次更新，反之亦然。所以如果你选择让C++逻辑决定动画蓝图的状态，请注意，在想要改变和另一个认识到它之间可能会有多达2帧的延迟。如果你直接从动画蓝图更新那个状态，确保始终有一个更新点，通常是控制器，并且强烈建议将其作为一个队列，在帧之间同步，然后继续到下一个队列条目。
- en: 'So since our AI is fairly simple, we''ll add an Attack boolean variable in
    its blueprint, then we need a new behavior tree task as before, which looks like
    this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的AI相当简单，我们将在其蓝图上添加一个攻击布尔变量，然后我们需要一个新的行为树任务，就像之前一样，看起来是这样的：
- en: '![](img/03da14fa-c381-4127-bd0a-e17c8e1888f2.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03da14fa-c381-4127-bd0a-e17c8e1888f2.png)'
- en: 'Note that it simply sets us into the attack state of our animation blueprint,
    waits for a short time, and then clears that (so we don''t immediately re-enter
    again when it finishes). And there''s an update to the tree that is quite simple,
    like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它只是将我们设置为动画蓝图中的攻击状态，等待一段时间，然后清除它（这样在它完成后我们不会立即重新进入）。并且树有一个相当简单的更新，如下所示：
- en: '![](img/e62e098c-7964-4275-912f-9b755ebb39fb.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e62e098c-7964-4275-912f-9b755ebb39fb.png)'
- en: The wait after the attack is our cooldown, and so you'll see our countess waits
    for that time between attacking the player when in range or defers to moving after
    the player if she's not in range from the move-to-target node.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击后的等待时间是冷却时间，所以你会看到我们的伯爵在攻击玩家时等待那个时间，如果她在范围内，或者如果她不在范围内，她将移动到目标节点后延迟移动。
- en: 'And, of course, the animation blueprint must reflect these, so again, add an
    Attack boolean blueprint variable, and make the transitions look like this (we
    wait for the attack animation to be near the end to go back to idle, and from
    idle or moving, we enter attack if the behavior tree sets our Attack variable):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，动画蓝图必须反映这些，所以再次添加一个攻击布尔蓝图变量，并使转换看起来像这样（我们等待攻击动画接近结束时返回空闲状态，如果是从空闲或移动状态，当行为树设置我们的攻击变量时，我们进入攻击状态）：
- en: '![](img/503ddba8-bed8-4551-a513-641533d2b267.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/503ddba8-bed8-4551-a513-641533d2b267.png)'
- en: 'So, the remaining piece to AI attacking is just seeing whether we hit the character.
    And once again, player death and UI for this are not covered here for brevity
    but should be fairly trivial after the rest of this work. All we need now is an
    animation notify event on the attack animation, an event in the animation blueprint
    that handles this, and a little logic on the controller, all in blueprint here.
    So, first go to the controller and add this blueprint function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，AI攻击的剩余部分只是查看我们是否击中了角色。再次强调，由于篇幅原因，玩家死亡和UI在此处未涵盖，但在完成这项工作后应该相当简单。我们现在需要的只是一个攻击动画的通知事件，一个处理此事件的动画蓝图事件，以及控制器上的一点点逻辑，所有这些都在蓝图上。所以，首先转到控制器并添加此蓝图函数：
- en: '![](img/7d091f61-2df1-4c05-9166-250d88e12d58.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d091f61-2df1-4c05-9166-250d88e12d58.png)'
- en: 'As you can see, this will display to the screen when the player was 1.5 m or
    closer in front of the countess, was therefore hit, and for how much damage. Again,
    translating this into gameplay to kill and then respawn the player should be fairly
    trivial at this point. Next, head to the animation (`Primary_Attack_A_Normal`
    is what is set in the attack node in the animation blueprint) and add this notification
    by right-clicking in the timeline, clicking Add New Notify at the bottom, and
    naming it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当玩家在伯爵夫人前方1.5米或更近时，这将在屏幕上显示，因此被击中，以及受到多少伤害。再次强调，将此转换为游戏以杀死并重新生成玩家应该在这个阶段相当简单。接下来，转到动画（在动画蓝图中的攻击节点中设置的是`Primary_Attack_A_Normal`）并右键单击时间轴，在底部单击“添加新通知”，并命名为：
- en: '![](img/e2a9bfcf-c443-43b0-9cc6-5d163ca49256.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2a9bfcf-c443-43b0-9cc6-5d163ca49256.png)'
- en: 'Then go to the animation blueprint''s event graph and right-click to add an
    event for that notify:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后转到动画蓝图的事件图，右键单击以添加一个通知事件：
- en: '![](img/be650199-76c4-46ff-a38f-a70e86cca6ba.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be650199-76c4-46ff-a38f-a70e86cca6ba.png)'
- en: And thus having our AI chase the player, attack on an interval, run home when
    kited, and transmit damage has been taken when hit is completed. Congratulations,
    we have a fully functional AI enemy (with some improvements to add in the next
    section)! And as usual, these latest changes are all in GitHub, so feel free to
    examine all of them in detail in the submissions there.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的AI追逐玩家，在间隔时间内攻击，当被风筝时跑回家，并且在击中完成时传递受到的伤害。恭喜，我们有一个功能齐全的AI敌人（在下一段中添加一些改进）！而且，像往常一样，这些最新的更改都在GitHub上，所以请随意在那里详细检查所有这些更改。
- en: More polished combat – spawn points, hit reactions, and dying
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更精致的战斗 - 生成点、击中反应和死亡
- en: So now we have an AI that likes to chase down our player and try to hurt them,
    great. But at this stage, our player can do almost no interaction with that enemy.
    We'll want to make things a bit more professional by spawning the enemies from
    a spawn point actor rather than placing them directly in the level (so we can
    spawn multiple enemies, wait until they are triggered, and so on), have them react
    when they're shot (which should not interrupt their other activities, but simply
    layer on top of them with a blended animation), and of course, be able to kill
    them (and have all of this reflected when loading/saving).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个喜欢追逐我们的玩家并试图伤害他们的AI，这很好。但在这个阶段，我们的玩家几乎无法与那个敌人互动。我们将通过从生成点演员生成敌人而不是直接在级别中放置它们来使事情更加专业（这样我们就可以生成多个敌人，等待它们被触发，等等），当它们被射击时让它们做出反应（这不应该打断它们的其它活动，而只是通过混合动画叠加在它们上面），当然，能够杀死它们（并且当加载/保存时反映所有这些）。
- en: Spawn points for enemy placement
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人放置的生成点
- en: Spawn points are a valuable tool when working with most shooter games. Players
    in multiplayer games use them when respawning, and AI often rush forth from them
    in waves or in a fixed number as a challenge for the player. Here, we will make
    a quick and simple spawn point, drop an instance in the default level, and test
    that all is well. First, in the AI folder, right-click and make a new blueprint
    class of the Trigger Box type, here named Countess Spawner.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 生成点是在处理大多数射击游戏时非常有用的工具。在多人游戏中，玩家在重生时使用它们，AI通常以波或固定数量冲向前方，对玩家构成挑战。在这里，我们将快速简单地创建一个生成点，将实例放入默认级别，并测试一切是否正常。首先，在AI文件夹中，右键单击并创建一个新的蓝图类，这里命名为Countess
    Spawner。
- en: 'The logic here is that when the player overlaps the box, an instance of our
    countess is spawned where we want by using a simple scene component with a billboard
    attached (which is set to editor only and hidden in game). Then we have a bit
    of logic to spawn BP_Countess types and keep an array of those that have been
    spawned, which is updated when they die, and they will only spawn if the array
    is below a concurrent count variable:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的逻辑是，当玩家重叠盒子时，我们通过使用一个简单的场景组件和一个附加的横幅（设置为仅编辑器使用并在游戏中隐藏）在想要的位置生成我们的伯爵夫人实例。然后我们有一些逻辑来生成BP_Countess类型，并保持已生成实例的数组，当它们死亡时更新该数组，并且只有当数组低于并发计数变量时才会生成：
- en: '![](img/ad8850ea-bd10-485e-adc9-efe1e7f6cadc.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad8850ea-bd10-485e-adc9-efe1e7f6cadc.png)'
- en: As can be seen in the map, a scaled version of this was placed between some
    boxes, and its spawn location moved to the corner of the map so that when the
    player crosses those boxes a countess appears in the corner, but only up to three
    until one is killed, and then another is allowed. Note that to do this, there
    are some critical changes to our controller that must be made. First, remove the
    `BeginPlay` function and replace it with `Possess(APawn* InPawn)` (keeping the
    contents the same).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如地图所示，这个缩放版本被放置在一些盒子之间，其生成位置移动到地图的角落，以便当玩家穿过这些盒子时，在角落出现一个伯爵夫人，但最多只能有三个，直到其中一个被杀死，然后另一个被允许。注意，为了做到这一点，我们必须对我们的控制器进行一些关键更改。首先，删除`BeginPlay`函数，并用`Possess(APawn*
    InPawn)`替换它（保持内容不变）。
- en: This is because `BeginPlay` can (and will) be called potentially before the
    process of possessing a spawned pawn has occurred. There's also a null check added
    in `OnSightOverlap` for the same reason (the component may be testing hits before
    the owner pawn is set). Next, in BP_Countess itself, set its AutoPossess property
    to Placed in World or Spawned so the AI controller actually runs. Note also that
    there is a specific Spawn AI From Class blueprint node like spawn actor, but it
    does things slightly differently and since most of our work is done by our controller
    already, autoprocessing was the best option here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`BeginPlay`可能在拥有生成的兵卒的过程之前被调用（并且将会被调用）。同样，在`OnSightOverlap`中也添加了一个空检查，出于同样的原因（组件可能在设置拥有者兵卒之前测试击中）。接下来，在BP_Countess本身中，将其自动拥有属性设置为放置在世界中或已生成，以便AI控制器实际上可以运行。注意，还有一个特定的从类蓝图节点，类似于生成演员，但它以稍微不同的方式做事，并且由于我们的大部分工作已经由我们的控制器完成，因此自动处理是这里最好的选择。
- en: This should be it for our spawn points. Of course, they can always be made more
    complex with wave spawning, or random spawn locations, or timers, or whatever
    logic makes sense and is fun for the game. But the important part is that this
    can now be reused anywhere to theoretically generate tons of interesting encounters
    with various AI down the road.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该就是我们的生成点。当然，它们可以通过波生成、随机生成位置、计时器或任何对游戏有意义的逻辑和有趣的方式变得更加复杂。但重要的是，现在这可以在任何地方重用，理论上可以生成大量的有趣遭遇，涉及各种AI。
- en: Hit reactions and dying
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 击中反应和死亡
- en: 'So far you can shoot our countess as much as you want and nothing interesting
    happens. We''ll fix this with a few code changes to our projectile, and some significant
    logic we can bundle up in the melee controller. Quickly going through this, we''ll
    add a health parameter to the melee controller like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以随意射击我们的伯爵夫人，但没有任何有趣的事情发生。我们将通过修改我们的投射物的一些代码以及一些可以捆绑到近战控制器中的显著逻辑来解决这个问题。快速浏览一下，我们将向近战控制器添加一个健康参数，如下所示：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then modify the projectile''s on hit to look like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后修改投射物的击中效果，如下所示：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And in the weapon when we spawn the projectile, add this line:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在武器中生成投射物时，添加以下行：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then to get our countess to react to the hit and die, we''ll need a couple
    of things in the controller blueprint and animation blueprint. First, let''s do
    the controller:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了让我们的伯爵夫人对击中做出反应并死亡，我们需要在控制器蓝图和动画蓝图中添加一些东西。首先，让我们来做控制器：
- en: '![](img/baa079bf-42dd-488f-bd59-9b91ea653053.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baa079bf-42dd-488f-bd59-9b91ea653053.png)'
- en: 'This way, when the pawn is hit and takes damage, the controller is notified,
    the take damage function (which was created by making the logic, then right-clicking
    all those logic nodes and selecting Collapse to Function) looks like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当兵卒受到攻击并受到伤害时，控制器会收到通知，受到伤害函数（通过创建逻辑，然后右键单击所有这些逻辑节点并选择“折叠到函数”来创建）看起来是这样的：
- en: '![](img/7d9cf507-346f-4489-8f60-2f0a27db7049.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d9cf507-346f-4489-8f60-2f0a27db7049.png)'
- en: 'The Get ABP function just gets our controlled pawn, casts to a BP_Countess,
    gets its animation instance, and casts that to an ABP_Countess in an Output (return)
    node. The Hit Reacting (float) and Dying (bool) variables were also simply added
    directly to the ABP_Countess and used in two ways, as seen here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Get ABP函数只是获取我们的受控NPC，将其转换为BP_Countess，获取其动画实例，并在输出（返回）节点中将它转换为ABP_Countess。Hit
    Reacting（浮点数）和Dying（布尔值）变量也直接添加到ABP_Countess中，并按以下方式使用：
- en: '![](img/c1509ee6-0072-4fd9-b405-35541db728ab.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1509ee6-0072-4fd9-b405-35541db728ab.png)'
- en: The HitReact state machine only has one state, and all it does is play the countess'
    Hit React (fwd) animation. Inserting the APply Additive blend in our root graph
    with this variable as the weight blends it in. This was built as an additive animation,
    so you can see at this stage when she takes damage, her head jerks back, but her
    other animations continue as normal, perfect. Near the end of the animation, a
    new notification is added, and an event in the event graph for this clears the
    blend to `0.0`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: HitReact状态机只有一个状态，它所做的只是播放伯爵夫人的击中反应（正向）动画。将APply Additive混合插入我们的根图中，并将此变量作为权重，将其混合进去。这是一个加性动画，所以你可以看到在这个阶段当她受到伤害时，她的头部会猛地一跳，但她的其他动画仍然正常进行，完美。在动画的末尾，添加了一个新的通知，并在事件图中为这个事件清除混合到`0.0`。
- en: 'And dying:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以及死亡：
- en: '![](img/77b0743a-d045-45c1-9c5d-e5990eedc60f.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77b0743a-d045-45c1-9c5d-e5990eedc60f.png)'
- en: Note the one-way transition – there's no coming back from dying. This node in
    the main graph only plays the countess' Death animation, and near its end has
    another notify added. In the event graph when that event is triggered, the Try
    Get Owner Pawn is destroyed. Now, the countess takes damage, reacts, and dies,
    most of what we hope for out of an AI!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意单向转换——一旦死亡就无法返回。这个主图节点只播放伯爵夫人的死亡动画，并在其结束时添加了另一个通知。在事件图中，当该事件被触发时，尝试获取拥有者NPC的行为会被销毁。现在，伯爵夫人受到伤害，做出反应，然后死亡，这是我们希望AI能够做到的大部分事情！
- en: Notes on load/save
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载/保存说明
- en: Loading and saving the AI, in this case, is not a trivial choice. In this instance,
    I've moved all of the logic for the most part to the spawner, so saving damaged
    AI (for example) won't work if they're placed directly in the level anymore. You
    can reverse this by setting the actor save interface in the BP_Countess, but then,
    there's no way to properly fix up the spawners to have links to the AI they've
    spawned.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和保存AI，在这种情况下，不是一个简单的选择。在这种情况下，我将大部分逻辑移到了生成器，所以如果它们直接放置在级别中，损坏的AI（例如）的保存将不起作用。你可以通过在BP_Countess中设置演员保存接口来撤销这一点，但这样，就没有办法正确修复生成器以使其与它们生成的AI有链接。
- en: As a general rule, as done here, if you can have your AI regenerate its state
    from where it is spawned in the world, you're far better off than trying to save
    every aspect of exactly where it was at save time. Granted, this can lead to exploits
    (for example, an AI about to hit with a very powerful attack when saved, then
    when loaded, is back to idle and starts a normal attack), but as AI complexity
    grows, load/save complexity can become a nightmare. If at all possible, spawn
    the AI into the world and let it figure out what it should be doing from there,
    as is done here with our spawner class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，就像这里所做的那样，如果你能让你的AI从它在世界中的出生点恢复其状态，你将比试图保存它在保存时的每一个细节要好得多。当然，这可能会导致滥用（例如，一个AI在保存时即将发动一次非常强大的攻击，然后加载时又回到空闲状态并开始正常攻击），但随着AI复杂性的增加，加载/保存的复杂性可能会变得非常糟糕。如果可能的话，将AI放入世界并让它自己决定接下来应该做什么，就像我们在我们的生成器类中所做的那样。
- en: 'Our countess spawner adds two new variables, an array of locations, and an
    array of health values. These are stored on save, and set to SaveGame variables
    in the spawner''s blueprint the way we did for the state of the moving platform
    earlier, and respawned and restored on load. This does require adding the actor
    save interface to the spawner (again, like we did for the platform), and marking
    up those two variables, but also adding a new native event to the saved actor
    interface:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的伯爵生成器添加了两个新的变量，一个位置数组和一个健康值数组。这些在保存时存储，并在生成器的蓝图中将它们设置为SaveGame变量，就像我们之前为移动平台的状态所做的那样，并在加载时重新生成和恢复。这确实需要将演员保存接口添加到生成器中（再次，就像我们对平台所做的那样），并标记这两个变量，但还需要向保存的演员接口添加一个新的本地事件：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we''d call it when we save, like we do for the load version, currently
    in the `MainMenuWidget.cpp''s SaveGame` function around line 82:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在保存时调用它，就像我们为加载版本所做的那样，目前是在`MainMenuWidget.cpp`的`SaveGame`函数的大约第82行：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now in the countess spawner, triggered from these events (after the interface
    is added in class settings as before), we can add two new functions, one for loading
    its countesses and one for saving. First, let''s look at saving:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在伯爵生成器中，触发这些事件（在类设置中添加界面，就像之前一样），我们可以添加两个新功能，一个用于加载伯爵，一个用于保存。首先，让我们看看保存：
- en: '![](img/f72618f4-9ad5-443c-b3bf-46c89b2b0d76.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f72618f4-9ad5-443c-b3bf-46c89b2b0d76.png)'
- en: 'And then we have the load event:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有加载事件：
- en: '![](img/d5b9d0e7-db93-42ff-acb0-d343e798200e.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5b9d0e7-db93-42ff-acb0-d343e798200e.png)'
- en: Voila! Our countesses are in the right place, with the right health, but they
    may not be in the exact step of their AI we saved them at, but they will quickly
    adjust. One known issue here is that if an AI is saved while it's dying, it will
    need to be damaged again to start dying again, but with some special work this
    could be fixed too. But overall, we now have a fully functional AI that chases
    down the player, hurts the player, can be hurt and react to hits, dies, and be
    loaded and saved reasonably professionally.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哼！我们的伯爵夫人现在在正确的位置，拥有正确的健康状态，但她们可能不在我们保存她们时AI的精确步骤上，但她们会很快调整。这里的一个已知问题是，如果AI在死亡时被保存，它需要再次受到伤害才能再次开始死亡，但通过一些特殊的工作，这也可以得到解决。但总的来说，我们现在有一个完全功能的AI，它会追逐玩家，伤害玩家，可以受到伤害并对打击做出反应，死亡，并且可以合理地加载和保存。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'So this was another whirlwind chapter packed full of many, many changes and
    a lot of new content. From where we were before, we now have a full functioning
    enemy who looks great, performs as we might expect in a polished game, and saves
    with our progress to boot. This is another quantum leap in making a serious game.
    One last point some may be asking after all of this: doesn''t Epic have a built-in
    senses system for AI? And yes, they do, which you''re more than welcome to explore;
    but in most instances, a custom and debuggable version is typically needed, which
    we''ve now made here in solid detail. If the built-in senses and their events
    are perfect for your project, though, definitely do consider them. But in the
    overall work-effort of making an AI, making your own sensing code is probably
    one of the less demanding (and honestly more fun!) portions to write. So, now
    that we have the core of a solid game going, how do we strategize progressing
    from level to level or through a large world with a much more significant amount
    of content than these test levels? Well, that''s next!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这又是一个充满许多许多变化和新内容的风暴章节。从我们之前的位置来看，我们现在有一个功能齐全、外观出色的敌人，其表现正如我们在精良的游戏中预期的那样，并且还能保存我们的进度。这是在制作严肃游戏方面的一次又一次的飞跃。在所有这些之后，有些人可能会问：Epic有没有内置的AI感知系统？是的，他们确实有，你完全可以探索；但大多数情况下，需要一个自定义和可调试的版本，我们在这里已经详细地实现了。尽管如此，如果内置的感知及其事件对你的项目来说非常完美，那么确实可以考虑它们。但在制作AI的整体工作量中，编写自己的感知代码可能是要求较低（而且说实话更有趣！）的部分。所以，现在我们有了坚实的游戏核心，我们如何策略性地从一级跳到另一级，或者通过一个比这些测试级别有更多内容的大型世界呢？嗯，这就是下一个问题！
- en: Questions
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the three major classes needed to make a proper AI in UE4?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作UE4中的适当AI需要哪三个主要类？
- en: What purpose does the blackboard serve in AI logic?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 黑板在AI逻辑中有什么作用？
- en: How was target selection brought from C++ into our behavior tree?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标选择是如何从C++引入我们的行为树的？
- en: What is the difference between a sequencer and selector in a behavior tree?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行为树中序列器和选择器之间的区别是什么？
- en: How was the behavior tree informed it should attack and stop moving towards
    the player?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行为树是如何得知它应该攻击并停止向玩家移动的？
- en: As blueprint logic complexity grows, what's a good trick to compartmentalize
    sections of logic?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着蓝图逻辑复杂性的增长，有什么好方法来划分逻辑的各个部分？
- en: What advantages do AI spawners bring to a game's design?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AI生成器为游戏设计带来了哪些优势？
- en: What are the trade-offs of perfect AI state load/save versus a simple load/save
    and logic recovering state?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完美的AI状态加载/保存与简单的加载/保存和逻辑恢复状态之间的权衡是什么？
- en: Further reading
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Nav-mesh information:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 导航网格信息：
- en: '[https://docs.unrealengine.com/en-us/Resources/ContentExamples/NavMesh](https://docs.unrealengine.com/en-us/Resources/ContentExamples/NavMesh)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-us/Resources/ContentExamples/NavMesh](https://docs.unrealengine.com/en-us/Resources/ContentExamples/NavMesh)'
- en: '3D widgets:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 3D小部件：
- en: '[https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/InWorldWidgetInteraction](https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/InWorldWidgetInteraction)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/InWorldWidgetInteraction](https://docs.unrealengine.com/en-us/Engine/UMG/HowTo/InWorldWidgetInteraction)'
