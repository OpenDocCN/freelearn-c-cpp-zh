["```cpp\nauto iota(int start) -> Generator<int> {\n  for (int i = start; i < std::numeric_limits<int>::max(); ++i) {\n    co_yield i;\n  }\n}\nauto take_until(Generator<int>& gen, int value) -> Generator<int> {\n  for (auto v : gen) {\n    if (v == value) {\n      co_return;\n    }\n    co_yield v;\n  }\n}\nint main() {\n  auto i = iota(2);\n  auto t = take_until(i, 5);\n  for (auto v : t) {          // Pull values\n    std::cout << v << \", \";\n  }\n  return 0;\n}\n// Prints: 2, 3, 4 \n```", "```cpp\nauto tcp_echo_server() -> Task<> {\n  char data[1024];\n  for (;;) {\n    size_t n = co_await async_read(socket, buffer(data));\n    co_await async_write(socket, buffer(data, n));\n  }\n} \n```", "```cpp\nauto subroutine() {\n  // Sequence of statements ...\n\n  return;     // Stop and return control to caller\n}\nsubroutine(); // Call subroutine to start it\n// subroutine has finished \n```", "```cpp\n// Pseudo code\nauto coroutine() {\n  value = 10;  \n  await something;        // Suspend/Resume point\n  // ...\n  yield value++;          // Suspend/Resume point\n  yield value++;          // Suspend/Resume point\n  // ...\n  return;\n}\nauto res = coroutine();    // Call\nres.resume();              // Resume \n```", "```cpp\nadd 73, R1   // Add 73 to the value stored in R1 \n```", "```cpp\nmov SP, R2   // Copy the stack pointer address to R2\nmov R2, [R1] // Copy value of R2 to memory address stored in R1 \n```", "```cpp\npush R1     // Push value of R1 to the top of the stack \n```", "```cpp\npop R2      // Pop value from the stack into R2 \n```", "```cpp\njump R3     // Set the program counter to the address in R3 \n```", "```cpp\n// Pseudo code\nauto coroutine() { \n  auto x = 0;\n  yield x++;       // Suspend\n  g();             // Call some other function\n  yield x++;       // Suspend\n  return;          // Return \n}\nauto co = coroutine(); // Call subroutine to start it\n// ...                 // Coroutine is suspended\nauto a = resume(co);   // Resume coroutine to get\nauto b = resume(co);   // next value \n```", "```cpp\nauto coroutine() -> Resumable {    // Initial suspend\n  std::cout << \"3 \";\n  co_await std::suspend_always{};  // Suspend (explicit)\n  std::cout << \"5 \";\n}                                  // Final suspend then return \n```", "```cpp\nint main() {            \n  std::cout << \"1 \";\n  auto resumable = coroutine(); // Create coroutine state\n  std::cout << \"2 \";\n  resumable.resume();           // Resume\n  std::cout << \"4 \";\n  resumable.resume();           // Resume\n  std::cout << \"6 \";\n}                               // Destroy coroutine state\n// Outputs: 1 2 3 4 5 6 \n```", "```cpp\nclass Resumable {                // The return object\n  struct Promise { /*...*/ };    // Nested class, see below\n  std::coroutine_handle<Promise> h_;\n  explicit Resumable(std::coroutine_handle<Promise> h) : h_{h} {}\npublic:\n  using promise_type = Promise;\n  Resumable(Resumable&& r) : h_{std::exchange(r.h_, {})} {}\n  ~Resumable() { if (h_) { h_.destroy(); } }\n  bool resume() {\n    if (!h_.done()) { h_.resume(); }\n    return !h_.done();\n  }\n}; \n```", "```cpp\nstruct Promise {\n  Resumable get_return_object() {\n    using Handle = std::coroutine_handle<Promise>;\n    return Resumable{Handle::from_promise(*this)};\n  }\n  auto initial_suspend() { return std::suspend_always{}; }\n  auto final_suspend() noexcept { return std::suspend_always{}; }\n  void return_void() {}\n  void unhandled_exception() { std::terminate(); }\n}; \n```", "```cpp\nclass Resumable {               // The return object\n  struct Promise { /*...*/ };   // Nested class\n  std::coroutine_handle<Promise> h_;\n  explicit Resumable(std::coroutine_handle<Promise> h) : h_{h} {}\npublic:\n  using promise_type = Promise;\n  Resumable(Resumable&& r) : h_{std::exchange(r.h_, {})} {}\n  ~Resumable() { if (h_) { h_.destroy(); } }\n  bool resume() {\n    if (!h_.done()) { h_.resume(); }\n    return !h_.done();\n  }\n}; \n```", "```cpp\nstruct Promise {\n  auto get_return_object() { return Resumable{*this}; }\n  auto initial_suspend() { return std::suspend_always{}; }\n  auto final_suspend() noexcept { return std::suspend_always{}; }\n  void return_void() {}\n  void unhandled_exception() { std::terminate(); }\n}; \n```", "```cpp\nstruct std::suspend_always {\n  constexpr bool await_ready() const noexcept { return false; }\n  constexpr void await_suspend(coroutine_handle<>) const noexcept {}\n  constexpr void await_resume() const noexcept {}\n}; \n```", "```cpp\nstruct std::suspend_never {\n  constexpr bool await_ready() const noexcept { return true; }\n  constexpr void await_suspend(coroutine_handle<>) const noexcept {}\n  constexpr void await_resume() const noexcept {}\n}; \n```", "```cpp\nauto coroutine() -> Resumable {\n  std::cout << \"c1 \";\n  co_await std::suspend_always{};\n  std::cout << \"c2 \";\n}                                \nauto coro_factory() {             // Create and return a coroutine\n  auto res = coroutine();\n  return res;\n}\nint main() {\n  auto r = coro_factory();\n  r.resume();                     // Resume from main\n  auto t = std::jthread{[r = std::move(r)]() mutable {\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(2s);\n    r.resume();                   // Resume from thread\n  }};\n} \n```", "```cpp\nstruct Promise {\n  /* Same as before ... */\n  static void* operator new(std::size_t sz) {\n    std::cout << \"custom new for size \" << sz << '\\n';\n    return ::operator new(sz);\n  }\n  static void operator delete(void* ptr) {\n    std::cout << \"custom delete called\\n\";\n    ::operator delete(ptr);\n  }\n} \n```", "```cpp\nauto coroutine(const std::string& str) -> Resumable { \n  std::cout << str;\n  co_return;\n} \n```", "```cpp\nauto coro_factory() {\n  auto str = std::string{\"ABC\"};\n  auto res = coroutine(str);\n  return res;\n} \n```", "```cpp\nint main() {\n  auto coro = coro_factory();\n  coro.resume();\n} \n```", "```cpp\nauto lambda_factory() {\n  auto str = std::string{\"ABC\"};\n  auto lambda = [&str]() {         // Capture str by reference\n    std::cout << str;     \n  };\n  return lambda;                   // Ops! str in lambda becomes\n}                                  // a dangling reference\nint main() {\n  auto f = lambda_factory();\n  f();                             // Undefined behavior\n} \n```", "```cpp\nauto coroutine(std::string str) -> Resumable {  // OK, by value!\n  std::cout << str;\n  co_return;\n}\nauto coro_factory() {\n  auto str = std::string{\"ABC\"};\n  auto res = coroutine(str);\n  return res;\n}\nint main() {\n  auto coro = coro_factory();\n  coro.resume();                                 // OK!\n} \n```", "```cpp\nstruct Widget {\nauto coroutine() -> Resumable {       // A member function \n    std::cout << i_++ << \" \";         // Access data member\n    co_await std::suspend_always{};\n    std::cout << i_++ << \" \";\n  }\n  int i_{};\n};\nint main() {\n  auto w = Widget{99};\n  auto coro = w.coroutine();\n  coro.resume();\n  coro.resume();\n}\n// Prints: 99\u00a0100 \n```", "```cpp\nauto widget_coro_factory() {      // Create and return a coroutine\n  auto w = Widget{};\n  auto coro = w.coroutine();\n  return coro; \n}                                 // Object w destructs here\nint main() {\n  auto r = widget_coro_factory();\n  r.resume();                     // Undefined behavior \n  r.resume();                  \n} \n```", "```cpp\nauto lambda = [](int i) -> Resumable {\n  std::cout << i;\n  co_return;              // Make it a coroutine\n};\nauto coro = lambda(42);   // Call, creates the coroutine frame\ncoro.resume();            // Outputs: 42 \n```", "```cpp\nstruct LambdaType {\n  auto operator()(int i) -> Resumable {  // Member function\n    std::cout << i;                      // Body\n    co_return;\n  }\n};\nauto lambda = LambdaType{};\nauto coro = lambda(42);\ncoro.resume(); \n```", "```cpp\nauto coro = [i = 0]() mutable -> Resumable { \n  std::cout << i++; \n  co_await std::suspend_always{};\n  std::cout << i++;\n}();               // Invoke lambda immediately\ncoro.resume();     // Undefined behavior! Function object\ncoro.resume();     // already destructed \n```", "```cpp\nstruct LambdaType {\n  int i{0};\n  auto operator()() -> Resumable {\n    std::cout << i++; \n    co_await std::suspend_always{};\n    std::cout << i++;\n  }\n};\nauto coro = LambdaType{}(); // Invoke operator() on temporary object\ncoro.resume();              // Ops! Undefined behavior \n```", "```cpp\ntemplate <typename T>\nclass Generator {\n  struct Promise { /* ... */ };   // See below\n  struct Sentinel {};  \n  struct Iterator { /* ... */ };  // See below\n\n  std::coroutine_handle<Promise> h_;\n  explicit Generator(std::coroutine_handle<Promise> h) : h_{h} {}\npublic: \n  using promise_type = Promise;\n  Generator(Generator&& g) : h_(std::exchange(g.h_, {})) {}\n  ~Generator() { if (h_) { h_.destroy();  } }\n  auto begin() {\n    h_.resume();\n    return Iterator{h_};\n  }\n  auto end() { return Sentinel{}; }\n}; \n```", "```cpp\nstruct Iterator {\n  using iterator_category = std::input_iterator_tag;\n  using value_type = T;\n  using difference_type = ptrdiff_t;\n  using pointer = T*;\n  using reference = T&;\n\n  std::coroutine_handle<Promise> h_;  // Data member\n\n  Iterator& operator++() {\n    h_.resume();\n    return *this;\n  }\n  void operator++(int) { (void)operator++(); }\n  T operator*() const { return h_.promise().value_; }\n  T* operator->() const { return std::addressof(operator*()); }\n  bool operator==(Sentinel) const { return h_.done(); }\n}; \n```", "```cpp\nstruct Promise {\n  T value_;\n  auto get_return_object() -> Generator {\n    using Handle = std::coroutine_handle<Promise>;\n    return Generator{Handle::from_promise(*this)};\n  }\n  auto initial_suspend() { return std::suspend_always{}; }\n  auto final_suspend() noexcept { return std::suspend_always{}; }\n  void return_void() {}\n  void unhandled_exception() { throw; }\n  auto yield_value(T&& value) {\n    value_ = std::move(value);\n    return std::suspend_always{};\n  }\n  auto yield_value(const T& value) {\n    value_ = value;\n    return std::suspend_always{};\n  }\n}; \n```", "```cpp\ntemplate <typename T>\nauto seq() -> Generator<T> {\n  for (T i = {};; ++i) {\n    co_yield i;\n  }\n}\ntemplate <typename T>\nauto take_until(Generator<T>& gen, T value) -> Generator<T> {\n  for (auto&& v : gen) {\n    if (v == value) {\n      co_return;\n    }\n    co_yield v;\n  }\n}\ntemplate <typename T>\nauto add(Generator<T>& gen, T adder) -> Generator<T> {\n  for (auto&& v : gen) {\n    co_yield v + adder;\n  }\n} \n```", "```cpp\nint main() {\n  auto s = seq<int>();\n  auto t = take_until<int>(s, 10);\n  auto a = add<int>(t, 3);\n  int sum = 0;\n  for (auto&& v : a) {\n      sum += v;\n  }\n  return sum; // returns 75\n} \n```", "```cpp\nmain:  # @main\nmov  eax, 75\nret \n```", "```cpp\nint main() { \n  auto s = seq<int>();                           // Same as before\n  auto t = take_until<int>(s, 10);\n  auto a = add<int>(t, 3);\n  const auto v = std::vector{5, 6, 7};\n  auto is_subrange = std::ranges::includes(a, v); // True\n} \n```", "```cpp\nfor (auto v: lin_space(2.0f, 3.0f, 5)) {\n  std::cout << v << \", \";\n}\n// Prints: 2.0, 2.25, 2.5, 2.75, 3.0, \n```", "```cpp\nauto start = -1.0;\nauto stop = 1.0;\nstd::lerp(start, stop, 0.0);    // -1.0\nstd::lerp(start, stop, 0.5);    //  0.0\nstd::lerp(start, stop, 1.0);    //  1.0 \n```", "```cpp\ntemplate <typename T>\nauto lin_value(T start, T stop, size_t index, size_t n) {  \n  assert(n > 1 && index < n);\n  const auto amount = static_cast<T>(index) / (n - 1);\n  const auto v = std::lerp(start, stop, amount);   // C++20\n  return v;\n} \n```", "```cpp\ntemplate <typename T>\nauto lin_space(T start, T stop, size_t n) {\n  auto v = std::vector<T>{};\n  for (auto i = 0u; i < n; ++i)\n    v.push_back(lin_value(start, stop, i, n));\n  return v;\n} \n```", "```cpp\nfor (auto v : lin_space(2.0, 3.0, 5)) {\n  std::cout << v << \", \";\n}\n// Prints: 2, 2.25, 2.5, 2.75, 3, \n```", "```cpp\ntemplate <typename T, typename F>\nrequires std::invocable<F&, const T&>               // C++20 \nvoid lin_space(T start, T stop, std::size_t n, F&& f) {\n  for (auto i = 0u; i < n; ++i) {\n    const auto y = lin_value(start, stop, i, n);\n    f(y);\n  }\n} \n```", "```cpp\nauto print = [](auto v) { std::cout << v << \", \"; };\nlin_space(-1.f, 1.f, 5, print);\n// Prints: -1, -0.5, 0, 0.5, 1, \n```", "```cpp\ntemplate <typename T>\nstruct LinSpace {\n  LinSpace(T start, T stop, std::size_t n)\n      : begin_{start, stop, 0, n}, end_{n} {}\n  struct Iterator {\n    using difference_type = void;\n    using value_type = T;\n    using reference = T;\n    using pointer = T*;\n    using iterator_category = std::forward_iterator_tag;\n    void operator++() { ++i_; }\n    T operator*() { return lin_value(start_, stop_, i_, n_);}\n    bool operator==(std::size_t i) const { return i_ == i; } \n    T start_{};\n    T stop_{};\n    std::size_t i_{};\n    std::size_t n_{};\n  };\n  auto begin() { return begin_; }\n  auto end() { return end_; }\n private:\n  Iterator begin_{};\n  std::size_t end_{};\n};\ntemplate <typename T>\nauto lin_space(T start, T stop, std::size_t n) {\n  return LinSpace{start, stop, n};\n} \n```", "```cpp\ntemplate <typename T>\nauto lin_space(T start, T stop, std::size_t n) {\n  return std::views::iota(std::size_t{0}, n) |\n    std::views::transform([=](auto i) {\n      return lin_value(start, stop, i, n);\n    });\n} \n```", "```cpp\ntemplate <typename T> \nauto lin_space(T start, T stop, std::size_t n) -> Generator<T> {\n   for (auto i = 0u; i < n; ++i) {\n     co_yield lin_value(start, stop, i, n);\n   }\n } \n```", "```cpp\ntemplate <typename Range>\nauto gap_encode(Range& ids) -> Generator<int> {\n  auto last_id = 0;\n  for (auto id : ids) {\n    const auto gap = id - last_id;\n    last_id = id;\n    co_yield gap;\n  }\n} \n```", "```cpp\nint main() {\n  auto ids = std::vector{10, 11, 12, 14};\n  auto gaps = gap_encode();\n  for (auto&& gap : gaps) {\n    std::cout << gap << \", \";\n  }\n} // Prints: 10, 1, 1, 2, \n```", "```cpp\ntemplate <typename Range>\nauto gap_decode(Range& gaps) -> Generator<int> {\n  auto last_id = 0;\n  for (auto gap : gaps) {\n    const auto id = gap + last_id;\n    co_yield id;\n    last_id = id;\n  }\n} \n```", "```cpp\nauto vb_encode_num(int n) -> Generator<std::uint8_t> {\n  for (auto cont = std::uint8_t{0}; cont == 0;) {\n    auto b = static_cast<std::uint8_t>(n % 128);\n    n = n / 128;\n    cont = (n == 0) ? 128 : 0;\n    co_yield (b + cont);\n  }\n} \n```", "```cpp\ntemplate <typename Range>\nauto vb_encode(Range& r) -> Generator<std::uint8_t> {\n  for (auto n : r) {\n    auto bytes = vb_encode_num(n);\n    for (auto b : bytes) {\n      co_yield b;\n    }\n  }\n} \n```", "```cpp\ntemplate <typename Range>\nauto vb_decode(Range& bytes) -> Generator<int> {\n  auto n = 0;\n  auto weight = 1;\n  for (auto b : bytes) {\n    if (b < 128) {  // Check continuation bit\n      n += b * weight;\n      weight *= 128;\n    } \n    else {\n      // Process last byte and yield\n      n += (b - 128) * weight;\n      co_yield n;\n      n = 0;       // Reset\n      weight = 1;  // Reset\n    }\n  }\n} \n```", "```cpp\ntemplate <typename Range>\nauto compress(Range& ids) -> Generator<int> {\n  auto gaps = gap_encode(ids);\n  auto bytes = vb_encode(gaps);\n  for (auto b : bytes) {\n    co_yield b;\n  }\n} \n```", "```cpp\ntemplate <typename Range>\nauto decompress(Range& bytes) -> Generator<int> {\n  auto gaps = vb_decode(bytes);\n  auto ids = gap_decode(gaps);\n  for (auto id : ids) {\n    co_yield id;\n  }\n} \n```", "```cpp\ntemplate <typename Range>\nvoid write(const std::string& path, Range& bytes) {\n  auto out = std::ofstream{path, std::ios::out | std::ofstream::binary};\n  std::ranges::copy(bytes.begin(), bytes.end(),    \n                    std::ostreambuf_iterator<char>(out));\n}\nauto read(std::string path) -> Generator<std::uint8_t> {\n  auto in = std::ifstream {path, std::ios::in | std::ofstream::binary};\n  auto it = std::istreambuf_iterator<char>{in};\n  const auto end = std::istreambuf_iterator<char>{};\n  for (; it != end; ++it) {\n    co_yield *it;\n  }\n} \n```", "```cpp\nint main() {\n  {\n    auto documents = std::vector{367, 438, 439, 440};\n    auto bytes = compress(documents);\n    write(\"values.bin\", bytes);\n  }\n  {\n    auto bytes = read(\"values.bin\");\n    auto documents = decompress(bytes);\n    for (auto doc : documents) {\n      std::cout << doc << \", \";\n    }\n  }\n}\n// Prints: 367, 438, 439, 440, \n```"]