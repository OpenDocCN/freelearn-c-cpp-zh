- en: Service-Oriented Architecture
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: A very common architecture for distributed systems is **Service-Oriented Architecture**
    (**SOA**). It's not a new invention, as this architectural style is almost as
    old as computer networking. There are many aspects of SOA ranging from an **Enterprise
    Service Bus** (**ESB**) to cloud-native microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统的一个非常常见的架构是**面向服务的架构**（**SOA**）。这不是一个新的发明，因为这种架构风格几乎和计算机网络一样古老。SOA有许多方面，从**企业服务总线**（**ESB**）到云原生微服务。
- en: If your applications include web, mobile, or **Internet-of-Things** (**IoT**)
    interfaces, this chapter will help you understand how they can be built with a
    focus on modularity and maintainability. As most of the current systems work in
    a client-server (or other network topology) manner, learning about SOA principles
    will help you design and improve such systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序包括Web、移动或**物联网**（**IoT**）接口，本章将帮助您了解如何以模块化和可维护性为重点构建它们。由于大多数当前系统以客户端-服务器（或其他网络拓扑）方式工作，学习SOA原则将帮助您设计和改进这样的系统。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding SOA
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SOA
- en: Adopting messaging principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用消息传递原则
- en: Using web services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web服务
- en: Leveraging managed services and cloud providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用托管服务和云提供商
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Most of the examples presented in this chapter do not require any specific software.
    For an AWS API example, you will need the **AWS SDK for C++**, which can be found
    at [https://aws.amazon.com/sdk-for-cpp/](https://aws.amazon.com/sdk-for-cpp/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提出的大多数示例不需要任何特定的软件。对于AWS API示例，您将需要**AWS SDK for C++**，可以在[https://aws.amazon.com/sdk-for-cpp/](https://aws.amazon.com/sdk-for-cpp/)找到。
- en: The code present in the chapter has been placed on GitHub at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter12](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter12).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码已放在GitHub上，网址为[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter12](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter12)。
- en: Understanding Service-Oriented Arcitecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向服务的架构
- en: Service-Oriented Architecture is an example of a software design that features
    loosely coupled components that provide services to each other. The components
    use a shared communication protocol, usually over a network. In this design, services
    mean units of functionality that can be accessed outside of the originating component.
    An example of a component could be a mapping service that provides a map of the
    area in response to geographical coordinates.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构是一个特征松散耦合的组件提供服务给彼此的软件设计的例子。这些组件使用共享的通信协议，通常是通过网络。在这种设计中，服务意味着可以在原始组件之外访问的功能单元。一个组件的例子可能是一个提供地理坐标响应区域地图的映射服务。
- en: 'According to the definition, a service has four properties:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，服务具有四个属性：
- en: It is a representation of business activity with a defined outcome.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是业务活动的一种表现，具有明确定义的结果。
- en: It is self-contained.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是自包含的。
- en: It is opaque to its users.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对用户是不透明的。
- en: It may be composed of other services.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能由其他服务组成。
- en: Implementation approaches
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施方法
- en: Service-Oriented Architecture does not regulate how to approach the service
    orientation. It's a term that may be applied to many different implementations.
    There are discussions on whether some approaches actually should be considered
    to be Service-Oriented Architecture. We don't want to take part in these discussions,
    only to highlight some of the approaches that often are mentioned as SOA approaches.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构并不规定如何处理服务定位。这是一个可以应用于许多不同实现的术语。关于一些方法是否应该被视为面向服务的架构存在讨论。我们不想参与这些讨论，只是强调一些经常被提及为SOA方法的方法。
- en: Let's compare some of them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一些。
- en: Enterprise Service Bus
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业服务总线
- en: ESB is often the first association when someone says Service-Oriented Architecture.
    It's one of the oldest approaches to implementing SOA.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人提到面向服务的架构时，ESB往往是第一个联想到的。这是实现SOA的最古老方法之一。
- en: ESB draws an analogy from computer hardware architecture. Hardware architecture
    uses computer buses such as PCI to achieve modularity. This way, third-party providers
    are able to implement modules (such as graphic cards, sound cards, or I/O interfaces)
    independently of the motherboard manufacturer as long as everyone is adhering
    to the standards required by the bus.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ESB从计算机硬件架构中得到类比。硬件架构使用计算机总线，如PCI，以实现模块化。这样，第三方提供商可以独立于主板制造商实现模块（如图形卡、声卡或I/O接口），只要每个人都遵守总线所需的标准。
- en: Much like the PCI, the ESB architecture aims to build a standard, general-purpose
    way to allow for the interaction of loosely coupled services. Such services are
    expected to be developed and deployed independently. It should also be possible
    to combine heterogeneous services.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与PCI类似，ESB架构旨在构建一种标准的通用方式，以允许松散耦合服务的交互。这些服务预计将独立开发和部署。还应该可以组合异构服务。
- en: As with SOA itself, ESB is not defined by any global standard. To implement
    ESB, it is necessary to establish an additional component in the system. This
    component is the bus itself. The communication over ESB is event-driven and often
    achieved with the means of message-oriented middleware and message queues, which
    we'll discuss in later chapters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与SOA本身一样，ESB没有由任何全局标准定义。要实现ESB，需要在系统中建立一个额外的组件。这个组件就是总线本身。ESB上的通信是事件驱动的，通常是通过消息导向中间件和消息队列实现的，我们将在后面的章节中讨论。
- en: 'The Enterprise Service Bus component serves the following roles:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 企业服务总线组件扮演以下角色：
- en: Controlling the deployment and versioning of services
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制服务的部署和版本控制
- en: Maintaining service redundancy
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护服务冗余
- en: Routing messages between services
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务之间路由消息
- en: Monitoring and controlling the message exchange
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和控制消息交换
- en: Resolving contention between the components
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决组件之间的争执
- en: Providing common services, such as event handling, encryption, or message queuing
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供常见服务，如事件处理、加密或消息队列
- en: Enforcing Quality of Service (**QOS**)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制服务质量（**QOS**）
- en: 'There are both proprietary commercial products as well as open source ones
    that implement the Enterprise Service Bus functionality. Some of the most popular
    open source products are the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既有专有商业产品，也有实现企业服务总线功能的开源产品。一些最受欢迎的开源产品如下：
- en: Apache Camel
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Camel
- en: Apache ServiceMix
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache ServiceMix
- en: Apache Synapse
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Synapse
- en: JBoss ESB
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JBoss ESB
- en: OpenESB
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenESB
- en: Red Hat Fuse (based on Apache Camel)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat Fuse（基于Apache Camel）
- en: Spring Integration
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring集成
- en: 'The most popular commercial products are the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的商业产品如下：
- en: IBM Integration Bus (replacing IBM WebSphere ESB)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM集成总线（取代IBM WebSphere ESB）
- en: Microsoft Azure Service Bus
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure服务总线
- en: Microsoft BizTalk Server
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft BizTalk Server
- en: Oracle Enterprise Service Bus
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle企业服务总线
- en: SAP Process Integration
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SAP过程集成
- en: 'As with all the patterns and products that we present in this book, you will
    have to consider the strengths and weaknesses before deciding to go with a particular
    architecture. Some of the benefits of introducing Enterprise Service Bus are as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中介绍的所有模式和产品一样，您在决定采用特定架构之前，必须考虑其优势和劣势。引入企业服务总线的一些好处如下：
- en: Better scalability of services
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的服务可扩展性
- en: Distributed workload
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式工作负载
- en: Can focus on configuration rather than implementing custom integration in services
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以专注于配置而不是在服务中实现自定义集成
- en: An easier way to design loosely coupled services
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计松散耦合服务的更简单方法
- en: Services are replaceable
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是可替换的
- en: Built-in redundancy capability
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置冗余能力
- en: 'The disadvantages, on the other hand, mostly revolve around the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，缺点主要围绕以下方面：
- en: A single point of failure – the ESB component's failure means the outage of
    an entire system.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单点故障-ESB组件的故障意味着整个系统的故障。
- en: The configuration is more complex, which impacts maintenance.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置更复杂，影响维护。
- en: Message queuing, message translation, and other services provided by ESB may
    reduce performance or even become a bottleneck.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列、消息转换以及ESB提供的其他服务可能会降低性能甚至成为瓶颈。
- en: Web services
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web服务
- en: Web services are another popular implementation of Service-Oriented Architecture.
    By their definition, web services are services offered by one machine to another
    machine (or operator) where communication occurs over World Wide Web protocols.
    Even though W3C, the governing body concerning the World Wide Web, allows the
    use of other protocols such as FTP or SMTP, web services typically use HTTP as
    transport.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务是面向服务的架构的另一种流行实现。根据其定义，Web服务是一台机器向另一台机器（或操作者）提供的服务，通信是通过万维网协议进行的。尽管万维网的管理机构W3C允许使用FTP或SMTP等其他协议，但Web服务通常使用HTTP作为传输协议。
- en: Although it is possible to implement web services using proprietary solutions,
    most implementations are based on open protocols and standards. Although many
    of the approaches are often referred to as web services, they are fundamentally
    different from each other. Later in the chapter, we will describe the various
    approaches in detail. For now, let's focus on their common features.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用专有解决方案实现Web服务，但大多数实现都基于开放协议和标准。尽管许多方法通常被称为Web服务，但它们在本质上是不同的。稍后在本章中，我们将详细描述各种方法。现在，让我们专注于它们的共同特点。
- en: Benefits and disadvantages of web services
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Web服务的优缺点
- en: 'The benefits of web services are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务的好处如下：
- en: Using popular web standards
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流行的Web标准
- en: A lot of tooling
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量的工具
- en: Extensibility
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: 'Given next are the disadvantages:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是缺点：
- en: A lot of overhead.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量开销。
- en: Some implementations are too complex (for example, SOAP/WSDL/UDDI specifications).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些实现过于复杂（例如SOAP/WSDL/UDDI规范）。
- en: Messaging and streaming
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息和流
- en: We've mentioned message queues and message brokers already when covering the
    Enterprise Service Bus architecture. Other than as part of an ESB implementation,
    messaging systems may also be standalone architectural elements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍企业服务总线架构时，我们已经提到了消息队列和消息代理。除了作为ESB实现的一部分外，消息系统也可以作为独立的架构元素。
- en: Message queues
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消息队列
- en: Message queues are components used for **Inter-Process Communication** (**IPC**).
    As the name suggests, they use the queue data structure to pass messages between
    different processes. Usually, message queues are a part of **Message-Oriented
    Middleware** (**MOM**) designs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列是用于**进程间通信**（**IPC**）的组件。顾名思义，它们使用队列数据结构在不同进程之间传递消息。通常，消息队列是**面向消息的中间件**（**MOM**）设计的一部分。
- en: On the lowest level, message queues are available in UNIX specifications, both
    in System V and in POSIX. While they are interesting when implementing IPC on
    a single machine, we would like to focus on message queues that are suitable for
    distributed computing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别上，消息队列在UNIX规范中都有，包括System V和POSIX。虽然它们在单台机器上实现IPC时很有趣，但我们想要专注于适用于分布式计算的消息队列。
- en: 'There are currently three standards used in open source software that are related
    to message queuing:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在开源软件中有三种与消息队列相关的标准：
- en: '**Advanced Message Queuing Protocol** (**AMQP**), a binary protocol operating
    on the application layer of the 7-Layer OSI model. Popular implementations include
    the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高级消息队列协议**（**AMQP**），一种在7层OSI模型的应用层上运行的二进制协议。流行的实现包括以下内容：'
- en: Apache Qpid
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Qpid
- en: Apache ActiveMQ
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache ActiveMQ
- en: RabbitMQ
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ
- en: Azure Event Hubs
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure事件中心
- en: Azure Service Bus
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure服务总线
- en: '**Streaming Text Oriented Messaging Protocol** (**STOMP**), a text-based protocol
    similar to HTTP (uses verbs such as `CONNECT`, `SEND`, `SUBSCRIBE`). Popular implementations
    include the following:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**流文本定向消息协议**（**STOMP**），一种类似于HTTP的基于文本的协议（使用诸如`CONNECT`、`SEND`、`SUBSCRIBE`等动词）。流行的实现包括以下内容：'
- en: Apache ActiveMQ
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache ActiveMQ
- en: RabbitMQ
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ
- en: syslog-ng
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: syslog-ng
- en: '**MQTT**, a lightweight protocol aimed at embedded devices. Popular implementations
    include home automation solutions such as the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**MQTT**，一个面向嵌入式设备的轻量级协议。流行的实现包括以下家庭自动化解决方案：'
- en: OpenHAB
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenHAB
- en: Adafruit IO
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit IO
- en: IoT Guru
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IoT Guru
- en: Node-RED
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node-RED
- en: Home Assistant
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Home Assistant
- en: Pimatic
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pimatic
- en: AWS IoT
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS IoT
- en: Azure IoT Hub
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure IoT Hub
- en: Message brokers
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消息代理
- en: Message brokers deal with the translation, validation, and routing of messages
    in a messaging system. Like message queues, they are parts of MOM.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理处理消息系统中消息的翻译、验证和路由。与消息队列一样，它们是MOM的一部分。
- en: Using message brokers, you can minimize the application's awareness regarding
    other parts of the system. This leads to designing loosely coupled systems, as
    message brokers take all the burden related to common operations on messages.
    It is known as a **Publish-Subscribe** (**PubSub**) design pattern.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息代理，您可以最大程度地减少应用程序对系统其他部分的感知。这导致设计松散耦合的系统，因为消息代理承担了与消息上的常见操作相关的所有负担。这被称为**发布-订阅**（**PubSub**）设计模式。
- en: 'Brokers typically manage message queues for receivers but are also able to
    perform additional functions, such as the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代理通常管理接收者的消息队列，但也能执行其他功能，例如以下功能：
- en: Translating messages from one representation to another
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息从一种表示形式转换为另一种
- en: Validating the message sender, receiver, or contents
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证消息发送者、接收者或内容
- en: Routing messages to one or more destinations
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息路由到一个或多个目的地
- en: Aggregating, decomposing, and recomposing messages in transit
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合、分解和重组传输中的消息
- en: Retrieving data from external services
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部服务检索数据
- en: Augmenting and enriching messages through interaction with external services
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过与外部服务的交互增强和丰富消息
- en: Handling and responding to errors and other events
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和响应错误和其他事件
- en: Providing different routing patterns, such as PubSub
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供不同的路由模式，如发布-订阅
- en: 'Popular implementations of message brokers are the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理的流行实现包括以下内容：
- en: Apache ActiveMQ
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache ActiveMQ
- en: Apache Kafka
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Kafka
- en: Apache Qpid
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Qpid
- en: Eclipse Mosquitto MQTT Broker
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse Mosquitto MQTT Broker
- en: NATS
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NATS
- en: RabbitMQ
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ
- en: Redis
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: AWS ActiveMQ
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS ActiveMQ
- en: AWS Kinesis
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Kinesis
- en: Azure Service Bus
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Service Bus
- en: Cloud computing
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云计算
- en: Cloud computing is a broad term with a lot of different meanings. Initially,
    the term **cloud** referred to a layer of abstraction that the architecture shouldn't
    be too worried about. This could, for example, mean servers and network infrastructure
    managed by a dedicated operations team. Later, service providers started applying
    the term cloud computing to their own products that abstracted the underlying
    infrastructure with all its complexities. Instead of having to configure each
    piece of infrastructure individually, it was possible to use a simple **Application
    Programming Interface** (**API**) to set up all the necessary resources.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算是一个广义的术语，有很多不同的含义。最初，**云**这个术语指的是架构不应该过于担心的抽象层。例如，这可能意味着由专门的运维团队管理的服务器和网络基础设施。后来，服务提供商开始将云计算这个术语应用到他们自己的产品上，这些产品通过抽象底层基础设施及其所有复杂性。不必单独配置每个基础设施部分，只需使用简单的**应用程序编程接口**（**API**）即可设置所有必要的资源。
- en: 'Nowadays, cloud computing has grown to include many novel approaches to application
    architecture. It may consist of the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，云计算已经发展到包括许多新颖的应用架构方法。它可能包括以下内容：
- en: Managed services, such as databases, cache layers, and message queues
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管服务，如数据库、缓存层和消息队列
- en: Scalable workload orchestration
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的工作负载编排
- en: Container deployment and orchestration platforms
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器部署和编排平台
- en: Serverless computing platforms
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器计算平台
- en: The most important thing to remember when considering cloud adoption is that
    hosting your application in the cloud requires an architecture designed specifically
    for the cloud. Most often, it also means architecture designed specifically for
    the given cloud provider.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑云采用时最重要的一点是，将应用程序托管在云中需要专门为云设计的架构。通常还意味着专门为特定云提供商设计的架构。
- en: This means choosing a cloud provider is not just a decision about whether one
    choice is better than another at a given moment in time. It means that the future
    cost of switching a provider may be too big to warrant the move. Migration between
    providers requires architectural changes and for a working application, they may
    outweigh the savings expected from the migration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着选择云提供商不仅仅是在某一时刻做出一个选择是否比另一个更好的决定。这意味着未来切换提供商的成本可能太大，不值得搬迁。在提供商之间迁移需要架构变更，对于一个正常运行的应用程序来说，这可能会超过迁移带来的预期节省。
- en: There is also another consequence of cloud architecture design. For legacy applications,
    it means that in order to take advantage of the cloud benefits, the applications
    would first have to be rearchitected and rewritten. Migration to the cloud is
    not just a matter of copying binary and configuration files from on-premises hosting
    to virtual machines managed by a cloud provider. Such an approach would only mean
    a waste of money as cloud computing is only cost-effective if your applications
    are scalable and cloud-aware.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 云架构设计还有另一个后果。对于传统应用程序来说，这意味着为了利用云的好处，应用程序首先必须重新设计和重写。迁移到云并不仅仅是将二进制和配置文件从本地托管复制到由云提供商管理的虚拟机。这种方法只会意味着浪费金钱，因为只有当您的应用程序是可扩展的并且具备云意识时，云计算才是划算的。
- en: Cloud computing doesn't necessarily mean using external services and leasing
    machines from third-party providers. There are also solutions such as OpenStack
    that run on-premises, which allow you to leverage the benefits of cloud computing
    using the servers you already own.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算并不一定意味着使用外部服务并从第三方提供商租用机器。还有一些解决方案，比如运行在本地的OpenStack，它允许您利用已经拥有的服务器来享受云计算的好处。
- en: We will cover managed services later in this chapter. Containers, cloud-native
    design, and serverless architecture will have their own dedicated chapters later
    in the book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论托管服务。容器、云原生设计和无服务器架构将在本书的后面有专门的章节。
- en: Microservices
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务
- en: There is some debate regarding whether microservices are a part of SOA or not.
    Most of the time, the term SOA is pretty much equivalent to the ESB design. Microservices
    are in many respects the opposite of ESB. This leads to opinions that microservices
    are a distinct pattern from SOA, being the next step in the evolution of software
    architecture.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于微服务是否属于SOA存在一些争议。大多数情况下，SOA这个术语几乎等同于ESB设计。在许多方面，微服务与ESB相反。这导致了微服务是SOA的一个独特模式的观点，是软件架构演进的下一步。
- en: We believe that they are, in fact, a modern approach to SOA that aims to eliminate
    some of the problems featured in ESB. After all, microservices fit within the
    definition of Service-Oriented Architecture very well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，实际上，这些是一种现代的SOA方法，旨在消除ESB中出现的一些问题。毕竟，微服务非常符合面向服务的架构的定义。
- en: Microservices are the subject of the next chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是下一章的主题。
- en: Benefits of Service-Oriented Architecture
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向服务的架构的好处
- en: Splitting the system's functionality over multiple services has several benefits.
    First of all, each service can be maintained and deployed separately. This helps
    the team focus on a given task, without the need to understand every possible
    interaction within the system. It also enables agile development as tests only
    have to cover a particular service, not the entire system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将系统的功能分割到多个服务中有几个好处。首先，每个服务可以单独维护和部署。这有助于团队专注于特定任务，而无需了解系统内的每种可能的交互。它还实现了敏捷开发，因为测试只需覆盖特定服务，而不是整个系统。
- en: The second benefit is that the modularity of the services helps create a distributed
    system. With a network (usually based on the Internet Protocol) as a means of
    communication, services can be split between different machines to provide scalability,
    redundancy, and better resource usage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个好处是服务的模块化有助于创建分布式系统。通过网络（通常基于互联网协议）作为通信手段，服务可以分布在不同的机器之间，以提供可伸缩性、冗余性和更好的资源利用率。
- en: Implementing new features and maintaining the existing software is a difficult
    task when there are many producers and many consumers for each service. This is
    why SOA encourages the use of documented and versioned APIs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个服务有许多生产者和许多消费者时，实施新功能和维护现有软件是一项困难的任务。这就是为什么SOA鼓励使用文档化和版本化的API。
- en: Another way to make it easier for both service producers and consumers to interact
    is by using established protocols that describe how to pass data and metadata
    between different services. These protocols may include SOAP, REST, or gRPC.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使服务生产者和消费者更容易互动的方法是使用已建立的协议，描述如何在不同服务之间传递数据和元数据。这些协议可能包括SOAP、REST或gRPC。
- en: The use of APIs and standard protocols makes it easy to create new services
    that provide added value over the existing ones. Considering we have a service,
    A, that returns our geographical location and another service, B, that provides
    the current temperature for a given location, we can invoke A and use its response
    in a request to B. This way, we get the current temperature for the current location
    without implementing the entire logic on our own.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API和标准协议可以轻松创建提供超出现有服务的附加值的新服务。考虑到我们有一个返回地理位置的服务A，另一个服务B，它提供给定位置的当前温度，我们可以调用A并在请求B中使用其响应。这样，我们就可以获得当前位置的当前温度，而无需自己实现整个逻辑。
- en: All of the complexity and implementation details of both services are unknown
    to us and we treat them as **black boxes**. The maintainers of both services may
    also introduce new functionality and release new versions of the services without
    the need to inform us about it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这两个服务的所有复杂性和实现细节一无所知，并将它们视为黑匣子。这两个服务的维护者也可以引入新功能并发布新版本的服务，而无需通知我们。
- en: Testing and experimenting with Service-Oriented Architecture is also easier
    than with monolithic applications. A small change in a single place doesn't require
    the recompilation of an entire code base. It is often possible to invoke services
    in an ad hoc manner using client tools.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和实验面向服务的架构也比单片应用更容易。单个地方的小改变不需要重新编译整个代码库。通常可以使用客户端工具以临时方式调用服务。
- en: Let's return to our example with the weather and geographical location service.
    If both services are exposing a REST API, we are able to build a prototype using
    nothing more than a cURL client to send appropriate requests manually. When we
    confirm that the response is satisfactory, we may then start writing code that
    will automate the entire operation and possibly expose the results as another
    service.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的天气和地理位置服务的例子。如果这两个服务都暴露了REST API，我们可以仅使用cURL客户端手动发送适当的请求来构建原型。当我们确认响应令人满意时，我们可以开始编写代码，自动化整个操作，并可能将结果公开为另一个服务。
- en: To get the benefits of SOA, we need to remember that all of the services have
    to be loosely coupled. If services depend on each other's implementation, it means
    they are no longer loosely coupled and are tightly coupled instead. Ideally, any
    given service should be replaceable by a different analogous service without impacting
    the operation of the entire system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得SOA的好处，我们需要记住所有服务都必须松散耦合。如果服务依赖于彼此的实现，这意味着它们不再是松散耦合，而是紧密耦合。理想情况下，任何给定的服务都应该可以被不同的类似服务替换，而不会影响整个系统的运行。
- en: In our weather and location example, this means that reimplementing a location
    service in a different language (say, switching from Go to C++) should not affect
    the downstream consumers of that service as long as they use the established API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的天气和位置示例中，这意味着在不同语言中重新实现位置服务（比如，从Go切换到C++）不应影响该服务的下游消费者，只要他们使用已建立的API。
- en: It is possible to still introduce breaking changes in the API by releasing a
    new API version. A client connecting to version 1.0 would observe the legacy behavior
    while clients connecting to 2.0 would benefit from bugfixes, better performance,
    and other improvements that come at the cost of compatibility.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发布新的API版本仍然可能引入API的破坏性变化。连接到1.0版本的客户端将观察到传统行为，而连接到2.0版本的客户端将受益于错误修复，更好的性能和其他改进，这些改进是以兼容性为代价的。
- en: For services relying on HTTP, API versioning usually occurs at the URI level.
    So a version 1.0, 1.1, or 1.2 API can be accessed when calling [https://service.local/v1/customer](https://service.local/v1/customer)
    while the version 2.0 API resides at [https://service.local/v2/customer](https://service.local/v2/customer).
    An API gateway, HTTP proxy, or a load balancer is then able to route the requests
    to appropriate services.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖HTTP的服务，API版本通常发生在URI级别。因此，当调用[https://service.local/v1/customer](https://service.local/v1/customer)时，可以访问1.0、1.1或1.2版本的API，而2.0版本的API位于[https://service.local/v2/customer](https://service.local/v2/customer)。然后，API网关、HTTP代理或负载均衡器能够将请求路由到适当的服务。
- en: Challenges with SOA
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOA的挑战
- en: Introducing an abstraction layer always comes at a cost. The same rule applies
    to Service-Oriented Architecture. It's easy to see the abstraction costs when
    looking at Enterprise Service Bus, web services, or message queues and brokers.
    What may be less obvious is that microservices also come at a cost. Their cost
    is related to the **Remote Procedure Call** (**RPC**) frameworks they use and
    the resource consumption related to service redundancy and duplication of their
    functionality.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 引入抽象层总是有成本的。同样的规则适用于面向服务的体系结构。当看到企业服务总线、Web服务或消息队列和代理时，可以很容易地看到抽象成本。可能不太明显的是微服务也有成本。它们的成本与它们使用的远程过程调用（RPC）框架以及与服务冗余和功能重复相关的资源消耗有关。
- en: Another target of criticism related to SOA is the lack of uniform testing frameworks.
    Individual teams that develop the services of an application may use tooling unknown
    to other teams. Other issues related to testing are that the heterogeneous nature
    and interchangeability of components mean there is a huge set of combinations
    to test. Some combinations may introduce edge cases that are not typically observed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与SOA相关的另一个批评目标是缺乏统一的测试框架。开发应用程序服务的个人团队可能使用其他团队不熟悉的工具。与测试相关的其他问题是组件的异构性和可互换性意味着有大量的组合需要测试。一些组合可能会引入通常不会观察到的边缘情况。
- en: As the knowledge about particular services is mostly concentrated in a single
    team, it is much harder to understand how an entire application works.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关于特定服务的知识大多集中在一个团队中，因此要理解整个应用程序的工作方式要困难得多。
- en: When the SOA platform is developed during the lifetime of an application, it
    may introduce the need for all the services to update their version to target
    the recent platform development. This means that instead of introducing new features,
    developers would be focused on making sure their application functions correctly
    after the changes to the platform. In an extreme case, maintenance costs may rise
    drastically for those services that don't see new releases and are constantly
    patched to adhere to platform requirements.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的SOA平台在应用程序的生命周期内开发时，可能会引入所有服务更新其版本以针对最新平台开发的需求。这意味着开发人员不再是引入新功能，而是专注于确保他们的应用程序在对平台进行更改后能够正确运行。在极端情况下，对于那些没有看到新版本并且不断修补以符合平台要求的服务，维护成本可能会急剧上升。
- en: Service-Oriented Architecture follows Conway's law, described in [Chapter 2](6fbde08c-f8a2-475d-9984-2a9882a761b4.xhtml),
    *Architectural Styles*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的体系结构遵循康威定律，详见[第2章](6fbde08c-f8a2-475d-9984-2a9882a761b4.xhtml)，*架构风格*。
- en: Adopting messaging principles
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用消息传递原则
- en: As we've mentioned previously in this chapter, messaging has many different
    use cases, ranging from IoT and sensor networks to microservices-based distributed
    applications running in the cloud.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面提到的，消息传递有许多不同的用例，从物联网和传感器网络到在云中运行的基于微服务的分布式应用程序。
- en: One of the benefits of messaging is that it is a neutral way to connect services
    implemented using different technologies. When developing an SOA, each service
    is typically developed and maintained by a dedicated team. Teams may choose the
    tools they feel comfortable with. This applies to programming languages, third-party
    libraries, and build systems.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递的好处之一是它是一种连接使用不同技术实现的服务的中立方式。在开发SOA时，每个服务通常由专门的团队开发和维护。团队可以选择他们感觉舒适的工具。这适用于编程语言、第三方库和构建系统。
- en: Maintaining a uniform set of tools may be counter-productive as different services
    may have different needs. For example, a kiosk application may require a **Graphical
    User Interface** (**GUI**) library such as Qt. A hardware controller that is a
    part of the same application will have other requirements, possibly linking to
    the hardware manufacturer's third-party components. These dependencies may then
    impose some restrictions that cannot be satisfied for both components simultaneously
    (for example, a GUI application may require a recent compiler, while the hardware
    counterpart may be pinned to an older one). Using messaging systems to decouple
    these components lets them have separate life cycles.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 维护统一的工具集可能会适得其反，因为不同的服务可能有不同的需求。例如，一个自助应用可能需要一个像Qt这样的图形用户界面（GUI）库。作为同一应用程序的一部分的硬件控制器将有其他要求，可能链接到硬件制造商的第三方组件。这些依赖关系可能会对不能同时满足两个组件的一些限制（例如，GUI应用程序可能需要一个较新的编译器，而硬件对应可能被固定在一个较旧的编译器上）。使用消息系统来解耦这些组件让它们有单独的生命周期。
- en: 'Some use cases for messaging systems include the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 消息系统的一些用例包括以下内容：
- en: Financial operations
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金融业务
- en: Fleet monitoring
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车队监控
- en: Logistics capturing
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物流捕捉
- en: Processing sensor
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理传感器
- en: Data order fulfillment
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据订单履行
- en: Task queuing
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务排队
- en: The following sections focus on the messaging systems designed for low overhead
    and message systems with brokers used for distributed systems.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分重点介绍了为低开销和使用经纪人的消息系统设计的部分。
- en: Low-overhead messaging systems
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低开销的消息系统
- en: Low-overhead messaging systems are typically used in environments that either
    require a small footprint or low latency. These are usually sensor networks, embedded
    solutions, and IoT devices. They are less common in cloud-based and distributed
    services, but it's still possible to use them in such solutions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 低开销的消息系统通常用于需要小占地面积或低延迟的环境。这些通常是传感器网络、嵌入式解决方案和物联网设备。它们在基于云的和分布式服务中较少见，但仍然可以在这些解决方案中使用。
- en: MQTT
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MQTT
- en: '**MQTT** stands for **Message Queuing Telemetry Transport**. It is an open
    standard both under OASIS and ISO. MQTT uses the PubSub model usually over TCP/IP,
    but it can also work with other transport protocols.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**MQTT**代表**消息队列遥测传输**。它是OASIS和ISO下的开放标准。MQTT通常使用PubSub模型，通常在TCP/IP上运行，但也可以与其他传输协议一起工作。'
- en: As the name suggests, MQTT's design goals are a low-code footprint and the possibility
    of running in low-bandwidth locations. There is a separate specification called
    **MQTT-SN**, which stands for **MQTT for Sensor Networks**. It focuses on battery-powered
    embedded devices without the TCP/IP stack.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，MQTT的设计目标是低代码占用和在低带宽位置运行的可能性。还有一个名为**MQTT-SN**的单独规范，代表**传感器网络的MQTT**。它专注于没有TCP/IP堆栈的电池供电的嵌入式设备。
- en: 'MQTT uses a message broker that receives all the messages from the client and
    routes those messages to their destinations. QoS is provided on three levels:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT使用消息经纪人接收来自客户端的所有消息，并将这些消息路由到它们的目的地。QoS提供了三个级别：
- en: At most once delivery (no guarantee)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至多一次交付（无保证）
- en: At least once delivery (acknowledged delivery)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少一次交付（已确认交付）
- en: Exactly once delivery (assured delivery)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保交付一次（已确认交付）
- en: It should be no surprise that MQTT is especially popular with various IoT applications.
    It's supported by OpenHAB, Node-RED, Pimatic, Microsoft Azure IoT Hub, and Amazon
    IoT. It's also popular with instant messaging, being used in ejabberd and Facebook
    Messanger. Other use cases include carsharing platforms, logistics, and transportation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT特别受到各种物联网应用的欢迎并不奇怪。它受OpenHAB、Node-RED、Pimatic、Microsoft Azure IoT Hub和Amazon
    IoT的支持。它在即时通讯中也很受欢迎，在ejabberd和Facebook Messanger中使用。其他用例包括共享汽车平台、物流和运输。
- en: The two most popular C++ libraries supporting this standard are Eclipse Paho
    and mqtt_cpp based on C++14 and Boost.Asio. For Qt applications, there's also
    qmqtt.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此标准的两个最流行的C++库是Eclipse Paho和基于C++14和Boost.Asio的mqtt_cpp。对于Qt应用程序，还有qmqtt。
- en: ZeroMQ
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ZeroMQ
- en: ZeroMQ is a brokerless messaging queue. It supports common messaging patterns,
    such as PubSub, client/server, and several others. It is independent of a particular
    transport and may be used with TCP, WebSockets, or IPC.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ是一种无经纪人的消息队列。它支持常见的消息模式，如PubSub、客户端/服务器和其他几种。它独立于特定的传输，并可以与TCP、WebSockets或IPC一起使用。
- en: The main idea, contained in the name, is that ZeroMQ requires zero brokers and
    zero administration. It is also advocated as providing zero latency, which means
    no latency is added coming from the presence of a broker.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ的主要思想是，它需要零经纪人和零管理。它也被宣传为提供零延迟，这意味着来自经纪人存在的延迟为零。
- en: The low-level library is written in C, and it has implementations for various
    popular programming languages, including C++. The most popular implementation
    for C++ is cppzmq, which is a header-only library targeting C++11.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 低级库是用C编写的，并且有各种流行编程语言的实现，包括C++。C++的最受欢迎的实现是cppzmq，这是一个针对C++11的仅头文件库。
- en: Brokered messaging systems
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经纪人消息系统
- en: The two most popular messaging systems that don't focus on low overhead are
    AMQP-based RabbitMQ and Apache Kafka. Both are mature solutions that are extremely
    popular in a lot of different designs. Many articles focus on superiority in a
    particular area of either RabbitMQ or Apache Kafka.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最受欢迎的不专注于低开销的消息系统是基于AMQP的RabbitMQ和Apache Kafka。它们都是成熟的解决方案，在许多不同的设计中都非常受欢迎。许多文章都集中在RabbitMQ或Apache
    Kafka在特定领域的优越性上。
- en: This is a slightly incorrect point of view as both messaging systems are based
    on different paradigms. Apache Kafka focuses on streaming vast amounts of data
    and storing the stream in persistent memory to allow future replay. RabbitMQ,
    on the other hand, is often used as a message broker between different microservices
    or a task queue to handle background jobs. For this reason, routing in RabbitMQ
    is much more advanced than the one present in Apache Kafka. Kafka's primary use
    cases are data analysis and real-time processing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个略微不正确的观点，因为这两种消息系统基于不同的范例。Apache Kafka专注于流式传输大量数据并将流式存储在持久内存中，以允许将来重播。另一方面，RabbitMQ通常用作不同微服务之间的消息经纪人或用于处理后台作业的任务队列。因此，在RabbitMQ中的路由比Apache
    Kafka中的路由更先进。Kafka的主要用例是数据分析和实时处理。
- en: While RabbitMQ uses the AMQP protocol (and supports other protocols as well,
    such as MQTT and STOMP), Kafka uses its own protocol based on TCP/IP. This means
    that RabbitMQ is interoperable with other existing solutions based on these supported
    protocols. If you write an application that uses AMQP to interact with RabbitMQ,
    it should be possible to migrate it later to use Apache Qpid, Apache ActiveMQ,
    or managed solutions from AWS or Microsoft Azure.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RabbitMQ使用AMQP协议（并且还支持其他协议，如MQTT和STOMP），Kafka使用基于TCP/IP的自己的协议。这意味着RabbitMQ与基于这些支持的协议的其他现有解决方案是可互操作的。如果您编写一个使用AMQP与RabbitMQ交互的应用程序，应该可以将其稍后迁移到使用Apache
    Qpid、Apache ActiveMQ或来自AWS或Microsoft Azure的托管解决方案。
- en: The scaling concerns could also drive the choice of one message broker over
    another. The architecture of Apache Kafka allows for easy horizontal scaling,
    which means adding more machines to the existing pool of workers. RabbitMQ, on
    the other hand, was designed with vertical scaling in mind, which means adding
    more resources to the existing machine, rather than adding more machines of similar
    sizes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展问题也可能会驱使选择一个消息代理而不是另一个。Apache Kafka的架构允许轻松进行水平扩展，这意味着向现有工作机群添加更多机器。另一方面，RabbitMQ的设计考虑了垂直扩展，这意味着向现有机器添加更多资源，而不是添加更多相似大小的机器。
- en: Using web services
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web服务
- en: As mentioned earlier in the chapter, the common characteristic of web services
    is that they are based on standard web technologies. Most of the time, this will
    mean the **Hypertext Transfer Protocol** (**HTTP**) and this is the technology
    we will focus on. Although it is possible to implement web services based on different
    protocols, such services are extremely rare and therefore out of our scope.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，Web服务的共同特点是它们基于标准的Web技术。大多数情况下，这将意味着**超文本传输协议**（**HTTP**），这是我们将重点关注的技术。尽管可能实现基于不同协议的Web服务，但这类服务非常罕见，因此超出了我们的范围。
- en: Tools for debugging web services
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于调试Web服务的工具
- en: 'One of the major benefits of using HTTP as transport is the wide availability
    of tools. For the most part, testing and debugging a web service may be performed
    using nothing more than a web browser. Apart from that, there are a lot of additional
    programs that may be helpful in automation. These include the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP作为传输的一个主要好处是工具的广泛可用性。在大多数情况下，测试和调试Web服务可以使用的工具不仅仅是Web浏览器。除此之外，还有许多其他程序可能有助于自动化。这些包括以下内容：
- en: The standard Unix file downloader `wget`
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的Unix文件下载器`wget`
- en: The modern HTTP client `curl`
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代HTTP客户端`curl`
- en: Popular open source libraries such as libcurl, curlpp, C++ REST SDK, cpr (C++
    HTTP requests library), and NFHTTP
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行的开源库，如libcurl、curlpp、C++ REST SDK、cpr（C++ HTTP请求库）和NFHTTP
- en: Testing frameworks such as Selenium or Robot Framework
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试框架，如Selenium或Robot Framework
- en: Browser extensions such as Boomerang
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器扩展，如Boomerang
- en: Standalone solutions such as Postman and Postwoman
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立解决方案，如Postman和Postwoman
- en: Dedicated testing software including SoapUI and Katalon Studio
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用测试软件，包括SoapUI和Katalon Studio
- en: HTTP-based web services work by returning an HTTP response to an HTTP request
    that uses appropriate HTTP verbs (such as GET, POST, and PUT). The semantics of
    how the request and the response should look and what data they should convey
    differs from implementation to implementation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 基于HTTP的Web服务通过返回HTTP响应来处理使用适当的HTTP动词（如GET、POST和PUT）的HTTP请求。请求和响应的语义以及它们应传达的数据在不同的实现中有所不同。
- en: 'Most implementations fall into one of two categories: XML-based web services
    and JSON-based web services. JSON-based web services are currently displacing
    XML-based ones, but it is still common to find services that use XML formats.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数实现属于两类：基于XML的Web服务和基于JSON的Web服务。基于JSON的Web服务目前正在取代基于XML的Web服务，但仍然常见到使用XML格式的服务。
- en: For dealing with data encoded with either JSON or XML, additional tools such
    as xmllint, xmlstarlet, jq, and libxml2 may be required.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理使用JSON或XML编码的数据，可能需要额外的工具，如xmllint、xmlstarlet、jq和libxml2。
- en: XML-based web services
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于XML的Web服务
- en: The first web services that gained traction were primarily based on XML. **XML**
    or **eXtensible Markup Language** was at the time the interchange format of choice
    in distributed computing and in the web environment. There were several different
    approaches to designing services with an XML payload.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最初获得关注的第一个Web服务主要基于XML。**XML**或**可扩展标记语言**当时是分布式计算和Web环境中的交换格式选择。有几种不同的方法来设计带有XML有效负载的服务。
- en: It is possible that you may want to interact with existing XML-based web services
    that are developed either internally within your organization or externally. However,
    we advise you to implement new web services using more lightweight methods, such
    as JSON-based web services, RESTful web services, or gRPC.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望与已经存在的基于XML的Web服务进行交互，这些服务可能是在您的组织内部开发的，也可能是外部开发的。但是，我们建议您使用更轻量级的方法来实现新的Web服务，例如基于JSON的Web服务、RESTful
    Web服务或gRPC。
- en: XML-RPC
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML-RPC
- en: One of the first standards that emerged was called XML-RPC. The idea behind
    the project was to provide an RPC technology that would compete with the then
    prevalent **Common Object Model** (**COM**), and CORBA. The aim was to use HTTP
    as a transport protocol and make the format human-readable and human-writable
    as well as parsable to machines. To achieve that, XML was chosen as the data encoding
    format.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最早出现的标准之一被称为XML-RPC。该项目的理念是提供一种与当时盛行的**公共对象模型**（**COM**）和CORBA竞争的RPC技术。其目标是使用HTTP作为传输协议，并使格式既可读又可写，并且可解析为机器。为了实现这一点，选择了XML作为数据编码格式。
- en: When using XML-RPC, the client that wants to perform a remote procedure call
    sends an HTTP request to the server. The request may have multiple parameters.
    The server answers with a single response. The XML-RPC protocol defines several
    data types for parameters and results.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用XML-RPC时，想要执行远程过程调用的客户端向服务器发送HTTP请求。请求可能有多个参数。服务器以单个响应回答。XML-RPC协议为参数和结果定义了几种数据类型。
- en: Although SOAP features similar data types, it uses XML schema definitions, which
    make the messages much less readable than the ones in XML-RPC.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SOAP具有类似的数据类型，但它使用XML模式定义，这使得消息比XML-RPC中的消息不可读得多。
- en: Relationship to SOAP
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与SOAP的关系
- en: Since XML-RPC is no longer actively maintained, there aren't any modern C++
    implementations for the standard. If you want to interact with XML-RPC web services
    from modern code, the best way may be to use the gSOAP toolkit that supports XML-RPC
    and other XML web service standards.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于XML-RPC不再得到积极维护，因此没有现代的C++实现标准。如果您想从现代代码与XML-RPC Web服务进行交互，最好的方法可能是使用支持XML-RPC和其他XML
    Web服务标准的gSOAP工具包。
- en: The main criticism of XML-RPC was that it didn't give much value over sending
    plain XML requests and responses while making the messages significantly larger.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: XML-RPC的主要批评是它在使消息显着变大的同时，没有比发送纯XML请求和响应提供更多价值。
- en: As the standard evolved, it became SOAP. As SOAP it formed the basis for the
    W3C web services stack of protocols.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 随着标准的发展，它成为了SOAP。作为SOAP，它构成了W3C Web服务协议栈的基础。
- en: SOAP
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SOAP
- en: The original abbreviation of **SOAP** stood for **Simple Object Access Protocol**.
    The abbreviation was dropped in version 1.2 of the standard. It's an evolution
    of the XML-RPC standard.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOAP**的原始缩写是**Simple Object Access Protocol**。该缩写在标准的1.2版本中被取消。它是XML-RPC标准的演变。'
- en: 'SOAP consists of three parts:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP由三部分组成：
- en: '**The SOAP envelope**, defining the message''s structure and processing rules'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOAP信封**，定义消息的结构和处理规则'
- en: '**The SOAP header** rules defining application-specific data types (optional)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOAP头**规定应用程序特定数据类型的规则（可选）'
- en: '**The SOAP body**, which carries remote procedure calls and responses'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOAP主体**，携带远程过程调用和响应'
- en: 'Here''s an example SOAP message using HTTP as transport:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用HTTP作为传输的SOAP消息示例：
- en: '[PRE0]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The example uses standard HTTP headers and the POST method to call a remote
    procedure. One header that is unique to SOAP is the `SOAPAction`. It points to
    a URI identifying the intent of the action. It is up to the clients to decide
    how to interpret this URI.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用标准的HTTP头和POST方法来调用远程过程。SOAP特有的一个头是`SOAPAction`。它指向标识操作意图的URI。由客户端决定如何解释此URI。
- en: '`soap:Header` is optional so we leave it empty. Together with `soap:Body`,
    it is contained within `soap:Envelope`. The main procedure call takes place within
    `soap:Body`. We introduce our own XML namespace that is specific to the Dominican
    Fair application. The namespace points to the root of our domain. The procedure
    we call is `FindMerchants` and we provide three arguments: latitude, longtitude,
    and distance.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`soap:Header`是可选的，所以我们将其留空。与`soap:Body`一起，它包含在`soap:Envelope`中。主要的过程调用发生在`soap:Body`中。我们引入了一个特定于多米尼加展会应用程序的XML命名空间。该命名空间指向我们域的根。我们调用的过程是`FindMerchants`，并提供三个参数：纬度、经度和距离。'
- en: As SOAP was designed to be extensible, transport-neutral, and independent of
    the programming model, it also led to the creation of other accompanying standards.
    This means it is usually necessary to learn all the related standards and protocols
    before using SOAP.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SOAP被设计为可扩展、传输中立和独立于编程模型，它也导致了其他相关标准的产生。这意味着通常需要在使用SOAP之前学习所有相关的标准和协议。
- en: This is not a problem if your application makes extensive use of XML and your
    development team is familiar with all the terms and specifications. However, if
    all you want is to expose an API for a third party, a much easier approach would
    be to build a REST API as it is much easier to learn for both producers and consumers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序广泛使用XML，并且您的开发团队熟悉所有术语和规范，那么这不是问题。但是，如果您只是想为第三方公开API，一个更简单的方法是构建REST
    API，因为它对生产者和消费者来说更容易学习。
- en: WSDL
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WSDL
- en: '**Web Services Description Language** (**WSDL**) provides a machine-readable
    description of how services can be called and how messages should be formed. Like
    the other W3C web services standards, it is encoded in XML.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web服务描述语言**（**WSDL**）提供了服务如何被调用以及消息应该如何形成的机器可读描述。与其他W3C Web服务标准一样，它以XML编码。'
- en: It is often used with SOAP to define interfaces that the web service offers
    and how they may be used.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常与SOAP一起使用，以定义Web服务提供的接口及其使用方式。
- en: Once you define your API in WSDL, you may (and should!) use automated tooling
    to help you create code out of it. For C++, one framework with such tools is gSOAP.
    It comes with a tool named `wsdl2h`, which will generate a header file out of
    the definition. You can then use another tool, `soapcpp2`, to generate bindings
    from the interface definition to your implementation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在WSDL中定义了API，您可以（而且应该！）使用自动化工具来帮助您从中创建代码。对于C++，具有此类工具的一个框架是gSOAP。它配备了一个名为`wsdl2h`的工具，它将根据定义生成一个头文件。然后您可以使用另一个工具`soapcpp2`，将接口定义生成到您的实现中。
- en: Unfortunately, due to the verbosity of the messages, the size and bandwidth
    requirements for SOAP services are generally huge. If this is not an issue, then
    SOAP can have its uses. It allows for both synchronous and asynchronous calls,
    as well as stateful and stateless operations. If you require rigid, formal means
    of communication, SOAP can provide them. Just make sure to use version 1.2 of
    the protocol due to the many improvements it introduces. One of them is the enhanced
    security of the services. Another is the improved definition of services themselves,
    which aids interoperability, or the ability to formally define the means of transportation
    (allowing for the usage of message queues), to name just a few.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于消息的冗长，SOAP服务的大小和带宽要求通常非常巨大。如果这不是问题，那么SOAP可以有其用途。它允许同步和异步调用，以及有状态和无状态操作。如果您需要严格、正式的通信手段，SOAP可以提供。只需确保使用协议的1.2版本，因为它引入了许多改进。其中之一是服务的增强安全性。另一个是服务本身的改进定义，有助于互操作性，或者正式定义传输手段（允许使用消息队列）等，仅举几例。
- en: UDDI
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UDDI
- en: The next step after documenting the web service interfaces is service discovery,
    which allows applications to find and connect to the services implemented by other
    parties.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录Web服务接口之后的下一步是服务发现，它允许应用程序找到并连接到其他方实现的服务。
- en: '**Universal Description, Discovery, and Integration** (**UDDI**) is a registry
    for WSDL files that may be searched manually or automatically. As with the other
    technologies discussed in this section, UDDI uses an XML format.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用描述、发现和集成**（**UDDI**）是用于WSDL文件的注册表，可以手动或自动搜索。与本节讨论的其他技术一样，UDDI使用XML格式。'
- en: UDDI registry may be queried with SOAP messages for automated service discovery.
    Even though UDDI provided the logical extensions of WSDL, its adoption in the
    open was disappointing. It is still possible to find UDDI systems used internally
    by companies.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: UDDI注册表可以通过SOAP消息查询自动服务发现。尽管UDDI提供了WSDL的逻辑扩展，但其在开放中的采用令人失望。仍然可能会发现公司内部使用UDDI系统。
- en: SOAP libraries
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SOAP库
- en: Two of the most popular libraries for SOAP are **Apache Axis** and **gSOAP**.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP最流行的两个库是**Apache Axis**和**gSOAP**。
- en: Apache Axis is suitable for implementing both SOAP (including WSDL) and REST
    web services. It's worth noting that the library hasn't seen a new release for
    over a decade.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Axis适用于实现SOAP（包括WSDL）和REST Web服务。值得注意的是，该库在过去十年中没有发布新版本。
- en: gSOAP is a toolkit that allows for creating and interacting with XML-based web
    services with a focus on SOAP. It handles data binding, SOAP and WSDL support,
    JSON and RSS parsing, UDDI APIs, and several other related web services standards.
    Although it doesn't use modern C++ features, it is still actively maintained.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: gSOAP是一个工具包，允许创建和与基于XML的Web服务进行交互，重点是SOAP。它处理数据绑定、SOAP和WSDL支持、JSON和RSS解析、UDDI
    API等其他相关的Web服务标准。尽管它不使用现代C++特性，但它仍在积极维护。
- en: JSON-based web services
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于JSON的Web服务
- en: '**JSON** stands for **JavaScript Object Notation**. Contrary to what the name
    suggests, it is not limited to JavaScript. It is language-independent. Parsers
    and serializers for JSON exist in most programming languages. JSON is much more
    compact than XML.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**代表**JavaScript对象表示法**。与名称所暗示的相反，它不仅限于JavaScript。它是与语言无关的。大多数编程语言都有JSON的解析器和序列化器。JSON比XML更紧凑。'
- en: Its syntax is derived from JavaScript as it was based on a JavaScript subset.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它的语法源自JavaScript，因为它是基于JavaScript子集的。
- en: 'Supported data types for JSON are the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: JSON支持的数据类型如下：
- en: 'Number: The exact format may vary between implementations; defaults to the
    double-precision floating-point in JavaScript.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：确切的格式可能因实现而异；在JavaScript中默认为双精度浮点数。
- en: 'String: Unicode-encoded.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：Unicode编码。
- en: 'Boolean: Using `true` and `false` values.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：使用`true`和`false`值。
- en: 'Array: May be empty.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：可能为空。
- en: 'Object: A map with key-value pairs.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象：具有键值对的映射。
- en: '`null`: Representing an empty value.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`：表示空值。'
- en: 'The `Packer` configuration presented in [Chapter 9](dba66494-c6a0-40f7-a6e8-c9612e996daf.xhtml),
    *Continuous Integration/Continuous Deployment,* is an example of a JSON document:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](dba66494-c6a0-40f7-a6e8-c9612e996daf.xhtml)中介绍的`Packer`配置，即*持续集成/持续部署*，是JSON文档的一个示例：
- en: '[PRE1]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: One of the standards using JSON as a format is the JSON-RPC protocol.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON作为格式的标准之一是JSON-RPC协议。
- en: JSON-RPC
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON-RPC
- en: JSON-RPC is a JSON-encoded remote procedure call protocol similar to XML-RPC
    and SOAP. Unlike its XML predecessor, it requires little overhead. It is also
    very simple while maintaining the human-readability of XML-RPC.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC是一种基于JSON编码的远程过程调用协议，类似于XML-RPC和SOAP。与其XML前身不同，它需要很少的开销。它也非常简单，同时保持了XML-RPC的人类可读性。
- en: 'This is how our previous example expressed in a SOAP call will look with JSON-RPC
    2.0:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前的示例在SOAP调用中使用JSON-RPC 2.0的样子：
- en: '[PRE2]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This JSON document still requires proper HTTP headers, but even with the headers,
    it is still considerably smaller than the XML counterpart. The only metadata present
    is the file with the JSON-RPC version and the request ID. The `method` and `params`
    fields are pretty much self-explanatory. The same can't always be said about SOAP.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON文档仍然需要适当的HTTP标头，但即使有标头，它仍然比XML对应物要小得多。唯一存在的元数据是带有JSON-RPC版本和请求ID的文件。`method`和`params`字段几乎是不言自明的。SOAP并非总是如此。
- en: Even though the protocol is lightweight, easy to implement, and easy to use,
    it hasn't seen widespread adoption when compared to both SOAP and REST web services.
    It was released much later than SOAP and around the same time that REST services
    started to get popular. While REST quickly rose to success (possibly due to its
    flexibility), JSON-RPC failed to get similar traction.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该协议轻量级、易于实现和使用，但与SOAP和REST Web服务相比，它并没有得到广泛的采用。它发布得比SOAP晚得多，大约与REST服务开始流行的时间相同。虽然REST迅速取得成功（可能是因为其灵活性），但JSON-RPC未能获得类似的推动力。
- en: Two useful implementations for C++ are libjson-rpc-cpp and json-rpc-cxx. json-rpc-cxx
    is a modern reimplementation of the previous library.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: C++的两个有用的实现是libjson-rpc-cpp和json-rpc-cxx。json-rpc-cxx是先前库的现代重新实现。
- en: REpresentational State Transfer (REST)
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表述性状态转移（REST）
- en: An alternative approach to web services is **REpresentional State Transfer (REST).**
    Services that conform to this architectural style are often called RESTful services.
    The main difference between REST and SOAP or JSON-RPC is that REST is based almost
    entirely on HTTP and URI semantics.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务的另一种替代方法是**表述性状态转移（REST）。**符合这种架构风格的服务通常被称为RESTful服务。REST与SOAP或JSON-RPC的主要区别在于REST几乎完全基于HTTP和URI语义。
- en: 'REST is an architectural style defining a set of constraints when implementing
    web services. Services that conform to this style are called RESTful. These constraints
    are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种在实现Web服务时定义一组约束的架构风格。符合这种风格的服务称为RESTful。这些约束如下：
- en: Must use a client-server model.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须使用客户端-服务器模型。
- en: Statelessness (neither the client nor the server needs to store the state related
    to their communication).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态性（客户端和服务器都不需要存储与它们的通信相关的状态）。
- en: Cacheability (responses should be defined as cacheable or non-cacheable to benefit
    from standard web caching to improve scalability and performance).
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存性（响应应定义为可缓存或不可缓存，以从标准Web缓存中获益，以提高可伸缩性和性能）。
- en: Layered system (proxies and load balancers should by no means affect the communication
    between the client and server).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统（代理和负载均衡器绝对不能影响客户端和服务器之间的通信）。
- en: 'REST uses HTTP as the transport protocol with URIs representing resources and
    HTTP verbs that manipulate the resources or invoke operations. There is no standard
    regarding how each HTTP method should behave, but the semantics most often agreed
    on are the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: REST使用HTTP作为传输协议，URI表示资源，HTTP动词操作资源或调用操作。关于每个HTTP方法应如何行为没有标准，但最常同意的语义是以下内容：
- en: POST – Create a new resource.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST - 创建新资源。
- en: GET – Retrieve an existing resource.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET - 检索现有资源。
- en: PATCH – Update an existing resource.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PATCH - 更新现有资源。
- en: DELETE – Delete an existing resource.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DELETE - 删除现有资源。
- en: PUT – Replace an existing resource.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUT - 替换现有资源。
- en: Due to reliance on web standards, RESTful web services can reuse existing components
    such as proxies, load balancers, and the cache. Thanks to the low overhead, such
    services are also very performant and efficient.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖于Web标准，RESTful Web服务可以重用现有组件，如代理、负载均衡器和缓存。由于开销低，这样的服务也非常高效和有效。
- en: Description languages
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述语言
- en: Just like with XML-based web services, RESTful services can be described in
    both a machine and human-readable way. There are a few competing standards available,
    with OpenAPI being the most popular.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基于XML的Web服务一样，RESTful服务可以以机器和人可读的方式描述。有几种竞争标准可用，其中OpenAPI是最受欢迎的。
- en: OpenAPI
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OpenAPI
- en: OpenAPI is a specification overseen by the OpenAPI Initiative, part of the Linux
    Foundation. It used to be known as the Swagger Specification as it used to be
    a part of the Swagger framework.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI是由Linux Foundation的OpenAPI计划监督的规范。它以前被称为Swagger规范，因为它曾经是Swagger框架的一部分。
- en: The specification is language agnostic. It uses JSON or YAML input to generate
    documentation of methods, parameters, and models. This way, using OpenAPI helps
    to keep the documentation and source code up to date.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范与语言无关。它使用JSON或YAML输入来生成方法、参数和模型的文档。这样，使用OpenAPI有助于保持文档和源代码的最新状态。
- en: 'There is a good selection of tools compatible with OpenAPI, such as code generators,
    editors, user interfaces, and mock servers. The OpenAPI generator can generate
    code for C++ using either cpp-restsdk or Qt 5 for client implementation. It can
    also generate server code using Pistache, Restbed, or Qt 5 QHTTPEngine. There''s
    also a convenient OpenAPI editor available online: [https://editor.swagger.io/](https://editor.swagger.io/).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多与OpenAPI兼容的工具可供选择，例如代码生成器、编辑器、用户界面和模拟服务器。OpenAPI生成器可以使用cpp-restsdk或Qt 5生成C++代码进行客户端实现。它还可以使用Pistache、Restbed或Qt
    5 QHTTPEngine生成服务器代码。还有一个方便的在线OpenAPI编辑器可用：[https://editor.swagger.io/](https://editor.swagger.io/)。
- en: 'An API documented with OpenAPI would look like the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenAPI记录的API将如下所示：
- en: '[PRE3]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first two fields (`openapi` and `info`) are metadata describing the document.
    The `paths` field contains all of the possible paths that correspond to the resources
    and methods of the REST interface. In the preceding example, we are only documenting
    a single path (`/item`) and a single method (`GET`). This method takes `itemId`
    as a required parameter. We provide a single possible response code, which is
    `200`. A 200 response contains a body that is a JSON document itself. The value
    associated with the `example` key is the example payload of a successful response.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个字段（`openapi`和`info`）是描述文档的元数据。`paths`字段包含与REST接口的资源和方法对应的所有可能路径。在上面的示例中，我们只记录了一个路径（`/item`）和一个方法（`GET`）。此方法将`itemId`作为必需参数。我们提供了一个可能的响应代码，即`200`。200响应包含一个JSON文档作为其本身的主体。与`example`键相关联的值是成功响应的示例有效负载。
- en: RAML
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RAML
- en: A competing specification, **RAML**, stands for **RESTful API Modeling Language**.
    It uses YAML for description and enables discovery, code reuse, and pattern-sharing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一种竞争规范，RAML，代表RESTful API建模语言。它使用YAML进行描述，并实现了发现、代码重用和模式共享。
- en: The rationale behind establishing RAML was that while OpenAPI is a great tool
    to document existing APIs, it was not, at the time, the best way to design new
    APIs. Currently, the specification is being considered to become a part of the
    OpenAPI Initiative.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 建立RAML的理念是，虽然OpenAPI是一个很好的工具来记录现有的API，但在当时，它并不是设计新API的最佳方式。目前，该规范正在考虑成为OpenAPI计划的一部分。
- en: A RAML document may be converted to OpenAPI to make use of the available tooling.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: RAML文档可以转换为OpenAPI以利用可用的工具。
- en: 'Here''s an example of an API documented with RAML:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用RAML记录的API的示例：
- en: '[PRE4]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example describes the same interface documented previously with OpenAPI.
    When serialized in YAML, both OpenAPI 3.0 and RAML 2.0 look very similar. The
    main difference is that OpenAPI 3.0 requires the use of JSON schema for documenting
    structures. With RAML 2.0, you can reuse the existing **XML Schema Definition**
    (**XSD**), which makes it easier to migrate from XML-based web services or to
    include external resources.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例描述了先前使用OpenAPI记录的相同接口。当以YAML序列化时，OpenAPI 3.0和RAML 2.0看起来非常相似。主要区别在于，OpenAPI
    3.0要求使用JSON模式来记录结构。使用RAML 2.0，可以重用现有的XML模式定义（XSD），这样更容易从基于XML的Web服务迁移或包含外部资源。
- en: API Blueprint
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: API Blueprint
- en: API Blueprint presents a different approach to the preceding two specifications.
    Instead of relying on either JSON or YAML, it uses Markdown to document data structures
    and endpoints.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: API Blueprint提出了与前两个规范不同的方法。它不依赖于JSON或YAML，而是使用Markdown来记录数据结构和端点。
- en: Its approach is similar to the test-driven development methodology, as it encourages
    designing contracts before implementing features. This way, it is easier to test
    whether the implementation actually fulfills the contract.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 其方法类似于测试驱动的开发方法论，因为它鼓励在实施功能之前设计合同。这样，更容易测试实现是否真正履行了合同。
- en: Just like with RAML, it is possible to convert the API Blueprint specification
    to OpenAPI as well as the other way round. There is also a command-line interface
    and a C++ library for parsing API Blueprints, called Drafter, which you can use
    in your code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 就像RAML一样，可以将API Blueprint规范转换为OpenAPI，反之亦然。还有一个命令行界面和一个用于解析API Blueprint的C++库，名为Drafter，您可以在您的代码中使用。
- en: 'An example of a simple API documented with API Blueprint looks like the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API Blueprint记录的简单API示例如下：
- en: '[PRE5]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding, we see that a `GET` method directed at the `/item` endpoint
    should result in a response code of `200`. Below that is the JSON message that
    corresponds to the one our service will typically return.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在上文中，我们看到针对`/item`端点的`GET`方法应该产生一个`200`的响应代码。在下面是我们的服务通常会返回的JSON消息。
- en: API Blueprint allows for more natural documentation. The main disadvantage is
    that it is the least popular of the formats described so far. This means both
    the documentation and tooling are nowhere near the quality of OpenAPI.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: API Blueprint允许更自然的文档编写。主要缺点是它是迄今为止描述的格式中最不受欢迎的。这意味着文档和工具都远远不及OpenAPI的质量。
- en: RSDL
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RSDL
- en: Similar to WSDL, **RSDL** (or **RESTful Service Description Language**), is
    an XML description for web services. It is language-independent and designed to
    be both human- and machine-readable.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于WSDL，**RSDL**（或**RESTful Service Description Language**）是用于Web服务的XML描述。它与语言无关，旨在既适合人类阅读又适合机器阅读。
- en: It's much less popular than the previously presented alternatives. It is also
    much harder to read, especially compared to API Blueprint or RAML.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 它比之前介绍的替代方案要不受欢迎得多。而且，它也要难得多，特别是与API Blueprint或RAML相比。
- en: Hypermedia as the Engine of Application State
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超媒体作为应用状态的引擎
- en: Although providing a binary interface such as a *gRPC-based* one can give you
    great performance, in many cases, you'll still want to have the simplicity of
    a RESTful interface. **Hypermedia as the Engine of Application State** (**HATEOAS**)
    can be a useful principle to implement if you want an intuitive REST-based API.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管提供诸如基于*gRPC*的二进制接口可以提供出色的性能，但在许多情况下，您仍然希望拥有RESTful接口的简单性。如果您想要一个直观的基于REST的API，**超媒体作为应用状态的引擎**（**HATEOAS**）可能是一个有用的原则。
- en: Just as you would open a web page and navigate based on the hypermedia shown,
    you can write your services with HATEOAS to achieve the same thing. This promotes
    the decoupling of server and client code and allows a client to quickly know what
    requests are valid to send, which is often not the case with binary APIs. The
    discovery is dynamic and based on the hypermedia provided.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您打开网页并根据显示的超媒体导航一样，您可以使用HATEOAS编写您的服务来实现相同的功能。这促进了服务器和客户端代码的解耦，并允许客户端快速了解哪些请求是有效的，这通常不适用于二进制API。发现是动态的，并且基于提供的超媒体。
- en: If you take a typical RESTful service, when executing an operation, you get
    JSON with data such as an object's state. With HATEOAS, aside from that, you would
    get a list of links (URLs) showing you the valid operations you can run on said
    object. The links (hypermedia) are the engine of the application. In other words,
    the available actions are determined by the state of the resources. While the
    term hypermedia may sound strange in this context, it basically means linking
    to the resources, including text, images, and video.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用典型的RESTful服务，在执行操作时，您会得到包含对象状态等数据的JSON。除此之外，除此之外，您还会得到一个显示您可以在该对象上运行的有效操作的链接（URL）列表。这些链接（超媒体）是应用的引擎。换句话说，可用的操作由资源的状态确定。虽然在这种情况下，超媒体这个术语可能听起来很奇怪，但它基本上意味着链接到资源，包括文本、图像和视频。
- en: 'For example, if we have a REST method allowing us to add an item by using the
    PUT method, we could add a return parameter that links to the resource created
    that way. If we use JSON for serialization, this could take the following form:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个REST方法允许我们使用PUT方法添加一个项目，我们可以添加一个返回参数，该参数链接到以这种方式创建的资源。如果我们使用JSON进行序列化，这可能采用以下形式：
- en: '[PRE6]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is no universally accepted method of serializing HATEOAS hypermedia. On
    the one hand, it makes it easier to implement regardless of the server implementation.
    On the other hand, the client needs to know how to parse the response to find
    the relevant traversal data.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 没有普遍接受的HATEOAS超媒体序列化方法。一方面，这样做可以更容易地实现，而不受服务器实现的影响。另一方面，客户端需要知道如何解析响应以找到相关的遍历数据。
- en: One of the benefits of HATEOAS is that it makes it possible to implement the
    API changes on the server side without necessarily breaking the client code. When
    one of the endpoints gets renamed, the new endpoint is referenced in subsequent
    responses, so the client is informed where to direct further requests.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS的好处之一是，它使得可以在服务器端实现API更改，而不一定会破坏客户端代码。当一个端点被重命名时，新的端点会在随后的响应中被引用，因此客户端会被告知在哪里发送进一步的请求。
- en: 'The same mechanism may provide features such as paging or make it easy to discover
    methods available for a given object. Getting back to our item example, here''s
    a possible response we could receive after making a `GET` request:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的机制可能提供诸如分页或者使得发现给定对象可用方法变得容易的功能。回到我们的项目示例，这是我们在进行`GET`请求后可能收到的一个可能的响应：
- en: '[PRE7]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we got links to two methods responsible for modifying the stock. If the
    stock is no longer available, our response will look like this (note that one
    of the methods is no longer advertised):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了两个负责修改库存的方法的链接。如果库存不再可用，我们的响应将如下所示（请注意，其中一个方法不再被广告）：
- en: '[PRE8]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One of the significant problems related to HATEOAS is that the two design principles
    seem to be at odds with each other. Adding traversable hypermedia would be much
    easier to consume if it were always presented in the same format. The freedom
    of expression here makes it harder to write clients unaware of the server's implementation.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 与HATEOAS相关的一个重要问题是，这两个设计原则似乎相互矛盾。如果遍历超媒体总是以相同的格式呈现，那么它将更容易消费。这里的表达自由使得编写不了解服务器实现的客户端变得更加困难。
- en: Not all RESTful APIs can benefit from introducing this principle – by introducing
    HATEOAS you commit to writing clients in a specific manner so that they're able
    to benefit from this API style.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的RESTful API都能从引入这一原则中受益-通过引入HATEOAS，您承诺以特定方式编写客户端，以便它们能够从这种API风格中受益。
- en: REST in C++
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++中的REST
- en: Microsoft's C++ REST SDK is currently one of the best ways to implement RESTful
    APIs in C++ applications. Also known as cpp-restsdk, it is the library that we're
    using in this book to illustrate various examples.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft的C++ REST SDK目前是在C++应用程序中实现RESTful API的最佳方法之一。也被称为cpp-restsdk，这是我们在本书中使用的库，用于说明各种示例。
- en: GraphQL
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL
- en: A recent alternative to REST web services is GraphQL. The **QL** in the name
    stands for **Query Language**. Rather than relying on the server to serialize
    and present the necessary data, in GraphQL clients query and manipulate the data
    directly. Apart from the reversal of responsibility, GraphQL also features mechanisms
    that make it easier to work with data. Typing, static validation, introspection,
    and schemas are all parts of the specification.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: REST Web服务的一个最新替代品是GraphQL。名称中的**QL**代表**查询语言**。GraphQL客户端直接查询和操作数据，而不是依赖服务器来序列化和呈现必要的数据。除了责任的逆转，GraphQL还具有使数据处理更容易的机制。类型、静态验证、内省和模式都是规范的一部分。
- en: There are server implementations of GraphQL available for a lot of languages
    including C++. One of the popular implementations is cppgraphqlgen from Microsoft.
    There are also many tools that help with development and debugging. What's interesting
    is that you can use GraphQL to query the database directly thanks to products
    such as Hasura or PostGraphile, which add the GraphQL API on top of a Postgres
    database.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多语言的GraphQL服务器实现，包括C++。其中一种流行的实现是来自Microsoft的cppgraphqlgen。还有许多工具可帮助开发和调试。有趣的是，由于Hasura或PostGraphile等产品在Postgres数据库上添加了GraphQL
    API，您可以使用GraphQL直接查询数据库。
- en: Leveraging managed services and cloud providers
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用托管服务和云提供商
- en: Service-Oriented Architecture may be extended to the current cloud computing
    trend. While Enterprise Service Bus features services usually developed in-house,
    with cloud computing it is possible to use the services provided by one or more
    cloud providers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构可以延伸到当前的云计算趋势。虽然企业服务总线通常具有内部开发的服务，但使用云计算可以使用一个或多个云提供商提供的服务。
- en: While designing an application architecture for cloud computing, you should
    always consider the managed services offered by the provider before implementing
    any alternatives. For example, before you decide that you want to host your own
    PostgreSQL database with selected plugins, make sure you understand the trade-offs
    and costs when compared to a managed database hosting offered by your provider.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在为云计算设计应用程序架构时，您应该在实施任何替代方案之前始终考虑提供商提供的托管服务。例如，在决定是否要使用自己选择的插件托管自己的PostgreSQL数据库之前，确保您了解与提供商提供的托管数据库托管相比的权衡和成本。
- en: 'The current cloud landscape provides a lot of services designed to handle popular
    use cases such as the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的云计算环境提供了许多旨在处理流行用例的服务，例如以下内容：
- en: Storage
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Relational databases
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系数据库
- en: Document (NoSQL) databases
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档（NoSQL）数据库
- en: In-memory cache
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存缓存
- en: Email
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件
- en: Message queues
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列
- en: Container orchestration
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器编排
- en: Computer vision
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机视觉
- en: Natural language processing
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然语言处理
- en: Text-to-speech and speech-to-text
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本转语音和语音转文本
- en: Monitoring, logging, and tracing
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控、日志记录和跟踪
- en: Big data
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大数据
- en: Content delivery networks
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容传送网络
- en: Data analytics
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分析
- en: Task management and scheduling
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务管理和调度
- en: Identity management
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份管理
- en: Key and secret management
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥和秘钥管理
- en: Due to the huge choice of available third-party services, it is clear how cloud
    computing fits within Service-Oriented Architecture.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可用的第三方服务选择很多，很明显云计算如何适用于面向服务的架构。
- en: Cloud computing as an extension of SOA
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云计算作为SOA的延伸
- en: 'Cloud computing is an extension of virtual machine hosting. What differentiates
    cloud computing providers from traditional VPS providers is two things:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算是虚拟机托管的延伸。区别云计算提供商和传统VPS提供商的是两个东西：
- en: Cloud computing is available via an API, which makes it a service in itself.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算通过API可用，这使其成为一个服务本身。
- en: Besides virtual machine instances, cloud computing offers additional services
    such as storage, managed databases, programmable networking, and many others.
    All of them are also available via an API.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了虚拟机实例，云计算还提供额外的服务，如存储、托管数据库、可编程网络等。所有这些服务也都可以通过API获得。
- en: There are several ways you can use the cloud provider's API to feature in your
    application, which we will now present.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以使用云提供商的API在您的应用程序中使用，我们将在下面介绍。
- en: Using API calls directly
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接使用API调用
- en: If your cloud provider offers an API accessible in your language of choice,
    you can interact with the cloud resources directly from your application.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的云提供商提供了您选择的语言可访问的API，您可以直接从应用程序与云资源交互。
- en: 'Example: you have an application that allows users to upload their own pictures.
    This application uses the Cloud API to create a storage bucket for each newly
    registered user:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：您有一个允许用户上传自己图片的应用程序。该应用程序使用云API为每个新注册用户创建存储桶：
- en: '[PRE9]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we have a C++ function that creates an AWS S3 bucket named
    after the username provided in the parameter. This bucket is configured to reside
    in a given region. If the operation fails, we want to get the error message and
    log it using `spdlog`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个C++函数，它创建一个名为提供参数中的用户名的AWS S3存储桶。该存储桶配置为驻留在特定区域。如果操作失败，我们希望获取错误消息并使用`spdlog`记录。
- en: Using API calls through a CLI tool
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过CLI工具使用API调用
- en: 'Some operations don''t have to be performed during the runtime of your application.
    They are typically run during the deployment and therefore may be automated in
    shell scripts, for example. One such use case is invoking a CLI tool to create
    a new VPC:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有些操作不必在应用程序运行时执行。它们通常在部署期间运行，因此可以在shell脚本中自动化。一个这样的用例是调用CLI工具来创建一个新的VPC：
- en: '[PRE10]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We use the gcloud CLI tool from Google Cloud Platform to create a network called
    `database` that will be used to handle traffic from the private instances to the
    database.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Google Cloud Platform的gcloud CLI工具创建一个名为`database`的网络，该网络将用于处理来自私有实例到数据库的流量。
- en: Using third-party tools that interact with the Cloud API
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用与云API交互的第三方工具
- en: 'Let''s look at an example of running HashiCorp Packer to build a virtual machine
    instance image that is preconfigured with your application:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，运行HashiCorp Packer来构建一个预先配置了你的应用程序的虚拟机实例镜像：
- en: '[PRE11]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we provide the required credentials and region and employ
    a builder to prepare an instance from the Ubuntu image for us. The instance we
    are interested in needs to have 512 MB RAM. Then, we provide the instance first
    by sending a `.deb` package to it, and then by executing a shell command to install
    this package.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们提供了所需的凭据和区域，并使用构建器为我们准备了一个来自Ubuntu镜像的实例。我们感兴趣的实例需要有512MB的RAM。然后，我们首先通过发送一个`.deb`包给它来提供实例，然后通过执行一个shell命令来安装这个包。
- en: Accessing the cloud API
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问云API
- en: Accessing cloud computing resources via an API is one of the most important
    features that distinguish it from traditional hosting. Using an API means you
    are able to create and delete instances at will without the intervention of an
    operator. This way, it becomes very easy to implement features such as load-based
    autoscaling, advanced deployments (Canary releases or Blue-Green), and automated
    development and testing environments for an application.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通过API访问云计算资源是区别于传统托管的最重要特性之一。使用API意味着你能够随意创建和删除实例，而无需操作员的干预。这样，就可以非常容易地实现基于负载的自动扩展、高级部署（金丝雀发布或蓝绿发布）以及应用程序的自动开发和测试环境。
- en: Cloud providers usually expose their APIs as RESTful services. On top of that,
    they often also provide client libraries for several programming languages. While
    all of the three most popular providers support C++ as a client library, the support
    from smaller vendors may vary.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 云提供商通常将他们的API公开为RESTful服务。此外，他们通常还为几种编程语言提供客户端库。虽然三个最受欢迎的提供商都支持C++作为客户端库，但来自较小供应商的支持可能有所不同。
- en: If you're thinking about deploying your C++ application to the cloud and plan
    on using the Cloud API, make sure your provider has released a C++ **Software
    Development Kit** (**SDK**). It is still possible to use the Cloud API without
    an official SDK, for example, using the CPP REST SDK library, but keep in mind
    this would require a lot more work to implement.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑将你的C++应用程序部署到云上，并计划使用云API，请确保你的提供商已发布了C++ **软件开发工具包**（**SDK**）。也可以在没有官方SDK的情况下使用云API，例如使用CPP
    REST SDK库，但请记住，这将需要更多的工作来实现。
- en: 'To access the **Cloud SDK**, you will also need access control. Typically,
    there are two ways your application can be authenticated to use the Cloud API:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问**Cloud SDK**，你还需要访问控制。通常，你的应用程序可以通过两种方式进行云API的身份验证：
- en: '**By providing an API token**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过提供API令牌**'
- en: The API token should be secret and never stored as part of the version control
    system or inside a compiled binary. To prevent theft, it should also be encrypted
    at rest.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: API令牌应该是秘密的，永远不要存储在版本控制系统的一部分或编译后的二进制文件中。为了防止被盗，它也应该在静态时加密。
- en: One of the ways to pass the API token securely to the application is by means
    of a security framework such as HashiCorp Vault. It is programmable secret storage
    with built-in lease time management and key rotation.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将API令牌安全地传递给应用程序的一种方法是通过像HashiCorp Vault这样的安全框架。它是可编程的秘密存储，内置租赁时间管理和密钥轮换。
- en: '**By being hosted on an instance with appropriate access rights**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过托管在具有适当访问权限的实例上**'
- en: Many cloud providers allow giving access rights to particular virtual machine
    instances. This way, an application hosted on such an instance doesn't have to
    authenticate using a separate token. Access control is then based on the instance
    the cloud API request originates from.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 许多云提供商允许给予特定虚拟机实例访问权限。这样，托管在这样一个实例上的应用程序就不必使用单独的令牌进行身份验证。访问控制是基于云API请求的实例。
- en: This approach is easier to implement since it doesn't have to factor in the
    need for secret management. The downside is that when the instance becomes compromised,
    the access rights will be available to all of the applications running there,
    not just the application you've deployed.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更容易实现，因为它不必考虑秘密管理的需求。缺点是，当实例被入侵时，访问权限将对所有在那里运行的应用程序可用，而不仅仅是你部署的应用程序。
- en: Using the cloud CLI
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用云CLI
- en: The Cloud CLI is typically used by human operators to interact with the Cloud
    API. Alternatively, it may be used for scripting or using the Cloud API with languages
    that are officially unsupported.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 云CLI通常由人类操作员用于与云API交互。或者，它可以用于脚本编写或使用官方不支持的语言与云API交互。
- en: 'As an example, the following Bourne Shell script creates a resource group in
    the Microsoft Azure cloud and then creates a virtual machine belonging to that
    resource group:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下Bourne Shell脚本在Microsoft Azure云中创建一个资源组，然后创建属于该资源组的虚拟机：
- en: '[PRE12]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When looking for documentation on how to manage cloud resources, you will encounter
    a lot of examples using the Cloud CLI. Even if you wouldn't normally use the CLI,
    instead preferring a solution such as Terraform, having the Cloud CLI at hand
    may help you with debugging infrastructure problems.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当寻找如何管理云资源的文档时，你会遇到很多使用云CLI的例子。即使你通常不使用CLI，而更喜欢像Terraform这样的解决方案，有云CLI在手可能会帮助你调试基础设施问题。
- en: Using tools that interact with the Cloud API
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用与云API交互的工具
- en: You have already learned about the dangers of vendor lock-in when using products
    from cloud providers. Typically, each cloud provider will offer a different API
    and a different CLI to all the others. There are cases where smaller providers
    offer abstraction layers that allow accessing their products via an API similar
    to that of the well-known providers. This approach aims to help with migrating
    the application from one platform to another.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了在使用云提供商的产品时出现供应商锁定的危险。通常，每个云提供商都会为所有其他提供商提供不同的API和不同的CLI。也有一些较小的提供商提供抽象层，允许通过类似于知名提供商的API访问其产品。这种方法旨在帮助将应用程序从一个平台迁移到另一个平台。
- en: Such instances are rare, though, and in general, tools used to interact with
    services from one provider are incompatible with those from another provider.
    This is a problem not only when you consider migration from one platform to the
    next. It may also be problematic if you want to host your application on a variety
    of providers.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样的情况很少见，但通常用于与一个提供商的服务进行交互的工具与另一个提供商的工具不兼容。当您考虑从一个平台迁移到另一个平台时，这不仅是一个问题。如果您想在多个提供商上托管应用程序，这也可能会成为一个问题。
- en: For this purpose, there's a new set of tools, collectively known as **Infrastructure
    as Code** (**IaC**) tools, that offer an abstraction layer on top of different
    providers. These tools are not necessarily limited to cloud providers either.
    They're usually general-purpose and help to automate many different layers of
    your application's architecture.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，有一套新的工具，统称为**基础设施即代码**（**IaC**）工具，它们在不同提供商的顶部提供了一个抽象层。这些工具不一定仅限于云提供商。它们通常是通用的，并有助于自动化应用程序架构的许多不同层。
- en: In [Chapter 9](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=33&action=edit),
    *Continuous Integration and Continuous Deployment*, we briefly covered some of
    them.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=33&action=edit)，*持续集成和持续部署*，我们简要介绍了其中一些。
- en: Cloud-native architecture
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云原生架构
- en: New tools allow architects and developers to abstract the infrastructure even
    more and build, first and foremost, with the cloud in mind. Popular solutions
    such as Kubernetes and OpenShift are driving this trend, but the landscape consists
    of a lot of smaller players as well. The last chapter of this book is dedicated
    to cloud-native design and describes this modern approach to building applications.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 新工具使架构师和开发人员能够更加抽象地构建基础架构，首先并且主要是考虑云。流行的解决方案，如Kubernetes和OpenShift，正在推动这一趋势，但该领域还包括许多较小的参与者。本书的最后一章专门讨论了云原生设计，并描述了这种构建应用程序的现代方法。
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about different approaches to implementing
    Service-Oriented Architecture. Since a service may interact with its environment
    in different ways, there are many architectural patterns to choose from. We've
    learned about the benefits and disadvantages of the most popular ones.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了实施面向服务的体系结构的不同方法。由于服务可能以不同的方式与其环境交互，因此有许多可供选择的架构模式。我们了解了最流行的架构模式的优缺点。
- en: 'We have focused on the architectural and implementational aspects of some of
    the widely popular approaches: message queues, web services including REST, and
    using managed services and cloud platforms. Other approaches that we will dig
    even deeper into will be presented in the standalone chapters, such as microservices
    and containers.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于一些广受欢迎的方法的架构和实施方面：消息队列，包括REST的Web服务，以及使用托管服务和云平台。我们将在独立章节中更深入地介绍其他方法，例如微服务和容器。
- en: In the next chapter, we'll look into microservices.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究微服务。
- en: Questions
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the properties of a service in Service-Oriented Architecture?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向服务的体系结构中服务的属性是什么？
- en: What are some benefits of web services?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web服务的一些好处是什么？
- en: When are microservices not a good choice?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时微服务不是一个好选择？
- en: What are some of the use cases of message queues?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息队列的一些用例是什么？
- en: What are some of the benefits of choosing JSON over XML?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择JSON而不是XML有哪些好处？
- en: How does REST build on web standards?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST如何建立在Web标准之上？
- en: How do cloud platforms differ from traditional hosting?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云平台与传统托管有何不同？
- en: Further reading
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*SOA Made Simple*: [https://www.packtpub.com/product/soa-made-simple/9781849684163](https://www.packtpub.com/product/soa-made-simple/9781849684163)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SOA简化*：[https://www.packtpub.com/product/soa-made-simple/9781849684163](https://www.packtpub.com/product/soa-made-simple/9781849684163)'
- en: '*SOA Cookbook*: [https://www.packtpub.com/product/soa-cookbook/9781847195487](https://www.packtpub.com/product/soa-cookbook/9781847195487)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SOA食谱*：[https://www.packtpub.com/product/soa-cookbook/9781847195487](https://www.packtpub.com/product/soa-cookbook/9781847195487)'
