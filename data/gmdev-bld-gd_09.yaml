- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Designing the Level
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计关卡
- en: From this chapter on to the end of this book, you’ll be actively working on
    creating a point-and-click adventure game. We’ll show you the necessary steps
    to create a game in which you’ll place and command a character whose name is Clara.
    Players will be controlling her actions inside a cave that will be initially dark,
    but you’ll be able to give controls to the player to change the conditions of
    the lights. Once you figure out how to move her around in the world, you’ll also
    place trigger points in this cave so that the world reacts to Clara’s actions
    to make things interesting but also challenging. This part of this book will cover
    enough basic building blocks for you to start practicing building small-scale
    adventure games.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始到本书的结尾，你将积极投入到创建一个点击冒险游戏的过程中。我们将向你展示创建游戏的必要步骤，在这个游戏中，你将放置并指挥一个名叫克拉拉的角色。玩家将控制她在洞穴内的行动，起初洞穴是黑暗的，但你将能够给玩家控制权来改变灯光的条件。一旦你弄清楚如何在世界中移动她，你也将在这个洞穴中放置触发点，让世界对克拉拉的行动做出反应，使游戏既有趣又具有挑战性。本书的这一部分将涵盖足够的基本构建模块，让你开始练习构建小型冒险游戏。
- en: Through all these efforts, you’ll learn how to utilize different parts of Godot
    Engine, especially the ones that are pertinent to 3D workflow. Whenever it’s necessary,
    we’ll remind you of the previous chapters, where you can revisit some of the basic
    principles. This is because this part of this book will heavily rely on practical
    applications of what we have presented so far.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些努力，你将学会如何利用 Godot 引擎的不同部分，特别是与 3D 工作流程相关的部分。每当需要时，我们会提醒你回顾前面的章节，在那里你可以回顾一些基本原理。这是因为本书的这一部分将大量依赖于我们迄今为止所展示的实践应用。
- en: 'With that said, as every game has a narrative; this is ours:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，每个游戏都有一个故事；这是我们的故事：
- en: “*It was no more than a fortnight ago when Clara’s uncle had sent for her. Clara
    was sailing her boat to the coordinates her uncle gave her when she noticed a
    glimmer in the distance. After she carefully approached the spot where she noticed
    the flash, she saw that this was the entrance to a cave under the cliffs of a
    rock formation jutting out of the sea. She cautiously maneuvered the sails on
    her boat and entered the cave without a hitch. Luckily, there was enough sunlight
    for her to see a pier and she anchored the boat. She’s excited to visit her uncle.*”
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: “*不过两周前，克拉拉的叔叔派人叫她。克拉拉正驾船前往叔叔给她的坐标，这时她注意到远处有微光。在她小心翼翼地接近注意到闪光的地方后，她看到这是海中一块岩石形成的悬崖下的洞穴入口。她小心翼翼地操纵船帆，顺利地进入了洞穴。幸运的是，阳光足够她看到码头，她把船锚泊在那里。她兴奋地要去看望她的叔叔。*”
- en: Although there is a lot to do, from adjusting the lights in a cave environment
    to triggering sound and animations, we should start building the world first.
    That’s what this chapter is about.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有很多事情要做，从调整洞穴环境中的灯光到触发声音和动画，但我们应该首先构建世界。这正是本章的内容。
- en: We’ll start by composing a scene by placing models from the project folder.
    This kind of scene structure, where the players experience a particular part of
    the game world, is often called a **level** and often signifies different levels
    of difficulty or a distinctive environment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过从项目文件夹中放置模型来组成一个场景。这种场景结构，玩家在其中体验游戏世界的特定部分，通常被称为**关卡**，通常表示不同的难度级别或独特的环境。
- en: While we are arranging assets to build a level, we’ll look into creating and
    fixing materials in Godot since, sometimes, some things are not perfectly transferred
    between applications. [*Chapter 6*](B17473_06.xhtml#_idTextAnchor092), *Exporting
    Blender Assets*, and [*Chapter 7*](B17473_07.xhtml#_idTextAnchor112), *Importing
    Blender Assets into Godot*, covered the intricacies of how exchanging information
    between Godot and Blender works if you need a refresher.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在安排资源以构建关卡时，我们将探讨在 Godot 中创建和修复材料，因为有时，一些事物在应用程序之间并不能完美地传递。[*第 6 章*](B17473_06.xhtml#_idTextAnchor092)，*导出
    Blender 资产*，和 [*第 7 章*](B17473_07.xhtml#_idTextAnchor112)，*将 Blender 资产导入 Godot*，介绍了如果需要复习，Godot
    和 Blender 之间交换信息的工作原理。
- en: Although manually laying things out to create a level is alright, we could always
    benefit from using tools that will make this kind of job easier on us. Godot’s
    **GridMap** is the right tool for placing objects on a grid structure. For **GridMap**
    to work, it needs another Godot mechanism called a **MeshLibrary**. We’ll show
    you how to construct one and use it as an alternative way of building levels.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动布局创建关卡是可以的，但我们总是可以从使用使这类工作更容易的工具中受益。Godot的**GridMap**是放置对象在网格结构上的正确工具。为了**GridMap**能够工作，它需要一个名为**MeshLibrary**的另一个Godot机制。我们将向你展示如何构建一个并使用它作为构建关卡的一种替代方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating the cave
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建洞穴
- en: Constructing the missing materials
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建缺失的材料
- en: Laying models on a grid
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网格上放置模型
- en: Taking advantage of MeshLibrary
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用MeshLibrary
- en: In the end, we’ll craft a level by arranging scenes/models, completing missing
    materials, and taking advantage of **GridMap** and **MeshLibrary** for a faster
    workflow. By doing this, you’ll have the right tools under your belt to design
    levels.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过排列场景/模型、完成缺失的材料，并利用**GridMap**和**MeshLibrary**来加快工作流程来构建一个关卡。通过这样做，你将拥有设计关卡所需的正确工具。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Starting with this chapter, and continuing in the remaining chapters, you’ll
    be creating a point-and-click adventure game. Since it’d be too time-consuming
    for you to prepare all the game assets, we are providing them. We have already
    exported the glTF files from Blender. Should you need to access the originals
    for any modifications, or when a specific file is mentioned, these files can be
    found in the `Blender Models.zip` file in this book’s GitHub repository.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，接下来的章节将继续，你将创建一个点击冒险游戏。由于准备所有游戏资源会花费你太多时间，所以我们提供了它们。我们已经从Blender导出了glTF文件。如果你需要访问原始文件进行任何修改，或者当提到特定文件时，这些文件可以在本书GitHub仓库中的`Blender
    Models.zip`文件中找到。
- en: Unlike the previous chapters, which usually had `Start` and `Finish` folders
    with simple assets, we’ll switch things up a bit. This chapter will have the usual
    folders too, but they will contain the content of a Godot project. The Godot project
    in the `Start` folder will contain the barebone assets for you to start building
    the level for the game. By the end of this chapter, your game will have reached
    a stage where you can use the content from the `Finish` folder to compare what
    you have created.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节不同，它们通常包含简单的资源文件夹`Start`和`Finish`，我们将做一些改变。本章也会有常规的文件夹，但它们将包含Godot项目的资源。`Start`文件夹中的Godot项目将包含用于开始构建游戏关卡的基本资源。到本章结束时，你的游戏将达到一个阶段，你可以使用`Finish`文件夹中的内容来比较你所创建的内容。
- en: Additionally, starting with the next chapter, you’ll only have the `Finish`
    folder since you can use the finished stage in each chapter as the starting condition
    for the following chapter, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从下一章开始，你将只有`Finish`文件夹，因为你可以使用每个章节中完成的阶段作为下一章的起始条件，依此类推。
- en: We suggest that you head to this book’s GitHub repository at [https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot)
    to check out the content we have prepared for you and help Clara out in her adventures.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你访问本书的GitHub仓库[https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot)，查看我们为你准备的内容，并帮助克拉拉在她的冒险中。
- en: Creating the cave
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建洞穴
- en: 'For the first level in Clara’s adventures, we thought of a small place so that
    you don’t get overwhelmed with building a large layout. *Figure 9.1* should help
    you visualize what we are building. This is a Blender render we’ll try to recreate
    in Godot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于克拉拉冒险的第一级，我们想到了一个小地方，这样你就不至于在构建大型布局时感到不知所措。*图9.1*将帮助你可视化我们所构建的内容。这是我们将在Godot中尝试复制的Blender渲染：
- en: '![Figure 9.1 – We’ll be building this small level for Clara to discover ](img/Figure_9.1_B17473.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 我们将为克拉拉构建这个小型关卡](img/Figure_9.1_B17473.jpg)'
- en: Figure 9.1 – We’ll be building this small level for Clara to discover
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 我们将为克拉拉构建这个小型关卡
- en: Our world will consist of a dock inside a cave that has access to the sea. When
    Clara anchors her boat, she sees inside the cave. There isn’t much light to begin
    with, but as little as she can see, the dock leads to a pier with laid stone.
    She can also see that there are a bunch of boxes, barrels, and pots distributed
    here and there. Though the sconces on the walls will start unlit when the game
    runs, as shown in *Figure 9.1*, you can see that all the sconces on the walls
    are lit. This is because we want to show you a later stage in the game so that
    you can see what we are aiming for. Otherwise, it would have been a dark figure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的世界将包括一个位于洞穴内部且通往海洋的码头。当克拉拉锚定她的船时，她可以看到洞穴内部。一开始并没有多少光线，但她能看到的最少，码头通向一个铺有石头的码头。她还可以看到到处分布着一些箱子、桶和罐子。尽管墙壁上的壁灯在游戏运行时将开始未点亮，如图9.1所示，但你可以看到墙壁上的所有壁灯都是点亮的。这是因为我们想向你展示游戏的后期阶段，以便你能看到我们追求的目标。否则，它将是一个黑暗的轮廓。
- en: In [*Chapter 10*](B17473_10.xhtml#_idTextAnchor165), *Making Things Look Better
    with Lights and Shadows*, we’ll investigate how we can create a more dramatic-looking
    level by utilizing appropriate light types and enabling shadows. We covered some
    of this in the context of Blender in [*Chapter 4*](B17473_04.xhtml#_idTextAnchor060),
    *Adjusting Cameras and Lights*, but we’ll do it in the context of Godot as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B17473_10.xhtml#_idTextAnchor165)《利用光线和阴影使事物看起来更好》中，我们将探讨如何通过使用适当的灯光类型并启用阴影来创建一个更具戏剧性的级别。我们已经在[*第4章*](B17473_04.xhtml#_idTextAnchor060)《调整相机和灯光》的Blender环境中讨论了一些内容，但我们也将在Godot环境中进行操作。
- en: Level design versus game design versus visual design
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 级别设计、游戏设计和视觉设计之间的比较
- en: If you are new to game development, then some of the names you come across might
    be confusing. The word *design* is one such example since it usually implies what
    people see. However, in actuality, it means a fashion, or a formula to do or conceive
    something. Let’s discuss it in the right context.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是对游戏开发新手，那么你可能会遇到一些令人困惑的名称。单词*设计*就是这样的一个例子，因为它通常意味着人们看到的东西。然而，实际上，它意味着一种时尚，或者是一种做或构思某事的方法。让我们在正确的上下文中讨论它。
- en: We could have designed the level differently so that access to the door at the
    end of the pier would be challenging. Perhaps the light conditions are so poor
    that Clara needs some help to see an important clue. To make progress in the game,
    game design rules will define how the player will interact with the world. Perhaps
    it’s enough for the player to click game objects in the world, while other times,
    it’d be better to have an inventory and a crafting system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以设计一个不同的级别，以便在码头尽头的门处提供挑战性的通道。也许光线条件如此之差，以至于克拉拉需要一些帮助才能看到重要的线索。为了在游戏中取得进展，游戏设计规则将定义玩家如何与世界互动。也许玩家只需点击世界中的游戏对象就足够了，而有时，拥有一个库存和制作系统会更好。
- en: Lastly, the visual design has nothing to do with the previous two design concepts.
    The cave walls could still be cave walls but instead of having a low-poly and
    stylized look, they might have looked ultra-realistic, where you could feel the
    stones were damp and covered with moss. Would this have added anything to the
    game and been fun? So, all these design principles are equally important and yet
    distinct.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，视觉设计与前两个设计概念无关。洞穴墙壁仍然是洞穴墙壁，但它们可能看起来超现实主义，你可以感觉到石头是潮湿的，覆盖着苔藓。这会给游戏增添什么，并使其变得有趣？因此，所有这些设计原则同等重要，但又各不相同。
- en: The level, `Level-01.blend`, is available inside the `Blender Models.zip` file
    at the root of this book’s GitHub repository. You’ll most likely need it open
    so that you can use it as a reference when you are building the level in Godot.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该级别，`Level-01.blend`，位于本书GitHub仓库根目录下的`Blender Models.zip`文件中。你很可能需要将其打开，以便在Godot中构建级别时将其作为参考。
- en: 'We will start building the level by laying out different sections of it. Speaking
    of which, we must follow these steps to structure our first level:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始构建级别，通过布置它的不同部分。说到这一点，我们必须遵循以下步骤来构建我们的第一个级别：
- en: Create a new scene and save it as `Level-01.tscn` inside the `Scenes` folder.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scenes`文件夹中创建一个新的场景，并将其保存为`Level-01.tscn`。
- en: Place a **Spatial** node as root and rename it **Level-01**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**Spatial**节点作为根节点，并将其重命名为**Level-01**。
- en: 'Create more **Spatial** nodes inside the root node with the following node
    names:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根节点内部创建更多具有以下节点名称的**Spatial**节点：
- en: '**Floor**'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地板**'
- en: '**Columns**'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**柱子**'
- en: '**Walls**'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**墙壁**'
- en: '**Rails**'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轨道**'
- en: '**SunkWalls**'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沉没的墙壁**'
- en: '**Props**'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**道具**'
- en: '**Rocks**'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**岩石**'
- en: '**Sconces**'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**壁灯**'
- en: '**Dock**'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**码头**'
- en: 'We’ll be using these child **Spatial** nodes to store different parts of the
    level since we’ll end up having a lot of parts in this level, despite it being
    very small. The following screenshot shows the node structure after our last effort:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些子**空间**节点来存储级别的不同部分，因为在这个非常小的级别中，我们最终会有很多部分。以下截图显示了我们的最后努力后的节点结构：
- en: '![Figure 9.2 – Different structures for the level are grouped under many Spatial
    nodes ](img/Figure_9.2_B17473.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 不同级别的结构被分组在许多空间节点下](img/Figure_9.2_B17473.jpg)'
- en: Figure 9.2 – Different structures for the level are grouped under many Spatial
    nodes
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 不同级别的结构被分组在许多空间节点下
- en: 'Inside these **Spatial** nodes, we’ll place the relevant parts of the level.
    For example, the floor pieces will go inside the **Floor** node. We can put down
    our first asset easily by doing the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些**空间**节点内部，我们将放置级别的相关部分。例如，地板块将放入**地板**节点。我们可以通过以下方式轻松放置我们的第一个资产：
- en: Highlight the **Floor** node in the **Scene** tree.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**树中高亮显示**地板**节点。
- en: Press the chain icon at the top to instance another scene inside your highlighted
    node. Alternatively, you can press *Ctrl* + *Shift* + *A*.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的链形图标以在您的高亮节点内实例化另一个场景。或者，您可以按*Ctrl* + *Shift* + *A*。
- en: Type `Floor_Standard` in the **Search** section of the pop-up screen.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出窗口的**搜索**部分中输入`Floor_Standard`。
- en: Select `Floor_Standard.glb` from the **Matches** section, as shown in the following
    screenshot.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**匹配**部分选择`Floor_Standard.glb`，如图下所示。
- en: 'This will create an instance of `Floor_Standard.glb` inside the **Floor** node:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在**地板**节点内创建`Floor_Standard.glb`的实例：
- en: '![Figure 9.3 – You’ll want to use the search area to filter out the unwanted
    matches ](img/Figure_9.3_B17473.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 您需要使用搜索区域来过滤掉不需要的匹配项](img/Figure_9.3_B17473.jpg)'
- en: Figure 9.3 – You’ll want to use the search area to filter out the unwanted matches
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 您需要使用搜索区域来过滤掉不需要的匹配项
- en: You may have noticed that although we wanted to inherit a scene that should
    normally have a `.tscn` file extension, instead, we instanced a glTF file. In
    [*Chapter 7*](B17473_07.xhtml#_idTextAnchor112), *Importing Blender Assets into
    Godot*, we learned how to create scenes out of glTF files. So, we could have done
    that and created a `Floor_Standard.tscn` scene, then instanced that scene inside
    the **Floor** node as well. We took a shortcut instead. Creating scenes is useful
    when you are going to add additional elements besides the model structure itself.
    We don’t need additional elements for the floor, so it’s alright to instance just
    its glTF version.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，尽管我们原本希望继承一个应该具有`.tscn`文件扩展名的场景，但相反，我们实例化了glTF文件。在[*第7章*](B17473_07.xhtml#_idTextAnchor112)，“将Blender资源导入Godot”，我们学习了如何从glTF文件创建场景。因此，我们可以那样做，创建一个`Floor_Standard.tscn`场景，然后在该场景内部实例化**地板**节点。我们采取了捷径。创建场景在你打算添加除了模型结构本身以外的其他元素时很有用。对于地板，我们不需要额外的元素，所以只实例化其glTF版本是可以的。
- en: On the other hand, there will come a moment when we create our level when directly
    instancing glTF files won’t cut it. For example, when we tackle lights and shadows
    in the next chapter, it will make much more sense to create a scene out of the
    sconce model and add a light object to the same scene. Hence, the sconce scene
    will take care of displaying a glTF model as well as holding a light object so
    that it can programmatically be turned on or off later. If you simply want to
    display models, but don’t need anything more than that, instancing a glTF file
    is usually enough.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们创建我们的级别时，直接实例化glTF文件将不再适用。例如，在下一章处理灯光和阴影时，从烛台模型创建场景并添加一个灯光对象到同一场景中会更有意义。因此，烛台场景将负责显示glTF模型以及包含一个灯光对象，以便它可以后来编程地打开或关闭。如果您只想显示模型，而不需要更多东西，实例化glTF文件通常就足够了。
- en: 'After you add the first piece, it will be automatically selected. If it’s not,
    you can click the floor piece in the 3D view or highlight its node in the **Scene**
    tree. Once it’s been selected, you’ll see a gizmo at the center of the model that
    will let you move and rotate the piece around. The directions of your gizmo may
    look different if you have rotated your view. The following screenshot shows an
    example of what we expect to see:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第一块后，它将自动选中。如果不是，您可以在3D视图中单击地板块或在高亮节点中高亮显示**场景**树中的节点。一旦选中，您将看到一个位于模型中心的操纵杆，让您可以移动和旋转该部件。如果您的视图已经旋转，您的操纵杆方向可能看起来不同。以下截图显示了我们所期望看到的一个示例：
- en: '![Figure 9.4 – The gizmo for moving and rotating an object ](img/Figure_9.4_B17473.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 移动和旋转对象的工具](img/Figure_9.4_B17473.jpg)'
- en: Figure 9.4 – The gizmo for moving and rotating an object
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 移动和旋转对象的工具
- en: 'The floor plan we are trying to lay out consists of more standard floor pieces.
    So, an easy way to get extra pieces is to duplicate the existing pieces and move
    them aside, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图布置的平面图由更多标准的地面块组成。因此，获取额外块的一个简单方法就是复制现有的块并将它们移开，如下所示：
- en: Select the **Floor_Standard** node in the **Scene** tree.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**树中选择**Floor_Standard**节点。
- en: Duplicate it by pressing *Ctrl* + *D*.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *D*来复制它。
- en: Move the new floor piece by dragging either the blue or the red axis in the
    gizmo.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在工具中拖动蓝色或红色轴来移动新的地板块。
- en: This will add a new floor piece to the scene and move it around. We are intentionally
    ignoring the green (*Y*) axis since we don’t want the floor to have any elevation
    at this point. However, for your games, you can design levels with different height
    zones and connect them with stairs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在场景中添加一个新的地板块并将其移动。我们故意忽略绿色(*Y*)轴，因为我们不希望地板在这个时候有任何高度。然而，对于你的游戏，你可以设计具有不同高度区域的水准，并通过楼梯连接它们。
- en: 'Since our floor plan looks like a grid, it would be nice to have the floor
    pieces snap to each other. We can do this by moving the pieces in either direction
    on the *XZ* plane while limiting their movements to precise increments. To simulate
    this, delete the most recent floor piece you created, and then do the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的平面图看起来像是一个网格，所以地板块能够相互对齐会很好。我们可以通过在*XZ*平面上移动块并在精确增量上限制它们的移动来实现这一点。为了模拟这一点，删除你最近创建的最新的地板块，然后执行以下操作：
- en: Duplicate a new **Floor_Standard** node.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制一个新的**Floor_Standard**节点。
- en: Hold down *Ctrl* and use either the X or Z gizmo arrow to move the piece two
    units.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Ctrl*键，并使用X或Z工具箭头移动块两个单位。
- en: Why did we move it by two units? Because the model is designed to fit in a grid
    that’s 2 x 2 meters in size. You can open the relevant Blender file to observe
    the dimensions. We are not measuring things in Godot but it’s still respecting
    the scale and unit aspects set in Blender. That’s why we made sure the scale for
    the model was set to `1`. If you need a reminder on this, we suggest that you
    read the *Applying rotation and scale* section in [*Chapter 6*](B17473_06.xhtml#_idTextAnchor092),
    *Exporting Blender Assets*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们移动了两个单位？因为模型设计成适合一个2 x 2米大小的网格。你可以打开相关的Blender文件来观察尺寸。我们在Godot中不进行测量，但它仍然尊重Blender中设置的缩放和单位方面。这就是为什么我们确保模型的缩放设置为`1`。如果你需要提醒，我们建议你阅读[*第6章*](B17473_06.xhtml#_idTextAnchor092)的*应用旋转和缩放*部分，*导出Blender资产*。
- en: 'After implementing the latest instructions for moving pieces with the snap
    feature on, you’ll get the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施最新的带有对齐功能的移动块指令后，你将得到以下输出：
- en: '![Figure 9.5 – The new floor piece is right next to the old one ](img/Figure_9.5_B17473.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 新地板块紧挨着旧的一个](img/Figure_9.5_B17473.jpg)'
- en: Figure 9.5 – The new floor piece is right next to the old one
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 新地板块紧挨着旧的一个
- en: 'All there is left to do at this point is duplicate enough floor pieces and
    move them around by using the snap feature. Also, you’ll need to instance and
    place two new models inside the **Floor** node:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前要做的只剩下复制足够的地板块，并使用对齐功能移动它们。此外，你还需要在**地板**节点内实例化和放置两个新的模型：
- en: '`Floor_Standard_Curved_1.glb`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Floor_Standard_Curved_1.glb`'
- en: '`Floor_Standard_Curved_4.glb`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Floor_Standard_Curved_4.glb`'
- en: 'These curved floor tiles will accommodate curved walls, which means we can
    keep the architecture consistent. By duplicating enough floor tiles and adding
    the new curved pieces, and after moving the pieces around, we’ll achieve the following
    output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些弯曲的地板块可以适应弯曲的墙壁，这意味着我们可以保持建筑的一致性。通过复制足够的地板块和添加新的弯曲块，并在移动块之后，我们将实现以下输出：
- en: '![Figure 9.6 – With the two newly added types, the floor is ready ](img/Figure_9.6_B17473.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 添加了两种新类型后，地板已准备就绪](img/Figure_9.6_B17473.jpg)'
- en: Figure 9.6 – With the two newly added types, the floor is ready
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 添加了两种新类型后，地板已准备就绪
- en: All the floor pieces are now under the **Floor** node in the scene, and this
    effort completes our task of constructing the floor. We’ll follow a similar approach
    to lay the other parts of the cave under separate **Spatial** nodes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有地板块现在都位于场景中的**地板**节点下，这项工作完成了我们构建地板的任务。我们将采用类似的方法在单独的**Spatial**节点下布置洞穴的其他部分。
- en: Erecting the walls
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立墙壁
- en: The next order of business in constructing the level is putting up the wall
    sections. You can do so by instancing wall pieces under the **Walls** node, similar
    to the way you did for the floor pieces. As a substitute for providing you with
    very similar instructions, we’ll use this section to highlight a few special cases
    you may come across.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建水平面时，下一步的工作是搭建墙面部分。你可以通过在 **墙面** 节点下实例化墙面部件来完成，这与放置地板部件的方式类似。为了不重复提供非常相似的说明，我们将使用本节来突出你可能会遇到的一些特殊情况。
- en: For example, you’ll eventually want to place wall pieces that will connect at
    a corner. So, you need to rotate one of the pieces around its *Y* axis by 90 degrees.
    You can do this either by using the gizmo or by typing the exact value in the
    **Inspector** panel under **Rotation Degrees** in the **Transform** section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你最终可能想要放置一些在角落处连接的墙面部件。因此，你需要将其中一个部件绕其 *Y* 轴旋转 90 度。你可以通过使用工具或通过在 **变换**
    部分的 **检查器** 面板下输入确切的值来完成这个操作。
- en: Another situation is with the wall that has a hole in it, which lets a bunch
    of twigs creep into the dock area. This is a detail you can see on the right-hand
    side of *Figure 9.1*. We suggest using `Wall_Hole.glb` for that particular section
    of the level. Similarly, `Curve.glb` should be placed over the curved floor pieces
    we have already established.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是，墙面上有一个洞，让许多树枝爬进了码头区域。这是你在 *图 9.1* 右侧可以看到的细节。我们建议使用 `Wall_Hole.glb` 来处理该区域的水平面。同样，`Curve.glb`
    应该放置在我们已经建立的弯曲地板部件上方。
- en: 'Although a door is technically not a wall, we could assume the arch and the
    door can get along with the other wall pieces. After all, they conceptually belong
    to the same structure. So, for that section, you can utilize the following pieces:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲门不是墙面，但我们可以说拱门和门可以与其他墙面部件相协调。毕竟，它们在概念上属于同一个结构。因此，对于那个部分，你可以使用以下部件：
- en: '`Wall_ArchRound_Overgrown.glb`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wall_ArchRound_Overgrown.glb`'
- en: '`Arch_Round.glb`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Arch_Round.glb`'
- en: '`Doors_RoundArch.glb`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Doors_RoundArch.glb`'
- en: 'Lastly, when you lay out all your wall pieces, you can duplicate them and pull
    them up two units on the *Y* axis. This will make the walls the same height as
    the arch and the door. Once you’ve done this, your floor should resemble what
    you can see in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你把所有的墙面部件摆放好之后，你可以复制它们并将它们在 *Y* 轴上向上移动两个单位。这样，墙面就会和拱门和门的高度一致。完成这一步后，你的地板应该看起来就像下面截图所示：
- en: '![Figure 9.7 – The level is starting to look more like our reference picture
    ](img/Figure_9.7_B17473.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 水平面开始看起来更像我们的参考图片](img/Figure_9.7_B17473.jpg)'
- en: Figure 9.7 – The level is starting to look more like our reference picture
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 水平面开始看起来更像我们的参考图片
- en: As you may have noticed there is a gap on the floor by the curved wall piece
    near the door. We’ll fill that gap by cleverly placing two green plants soon.
    Otherwise, you’d have to prepare a floor piece for edge cases like that. Either
    way is fine and going back and forth between Blender and Godot to complete missing
    pieces is also part of the process.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，在门附近的弯曲墙面部件旁边地板上有一个缝隙。我们将通过巧妙地放置两株绿色植物来填补这个缝隙。否则，你可能需要为这种边缘情况准备一个地板部件。无论如何，都是可以的，并且来回在
    Blender 和 Godot 之间完成缺失的部分也是这个过程的一部分。
- en: Since we’ve been handling the walls, we can extend this effort by using additional
    wall pieces to simulate the section of the level that meets the seawater in the
    cave.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一直在处理墙面，我们可以通过使用额外的墙面部件来模拟水平面与洞穴中的海水相遇的部分。
- en: Sinking the walls
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉入墙面
- en: It seems the architect of this place went to great lengths to have stone bricks
    laid out to prevent mother nature from tarnishing what’s under the floor. Smart!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这个地方的建筑师费尽心思，用石砖铺就，以防止自然侵蚀地板下面的东西。真聪明！
- en: 'To accomplish what the architect had in mind, you can utilize the standard
    wall pieces to create a curtain-like structure right where the floor is connecting
    with the water. In the end, when you place these pieces inside **SunkWalls** in
    your **Scene** tree, you’ll be looking at what’s shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现建筑师的想法，你可以利用标准墙面部件在地板与水连接的地方创建一个帘幕状的结构。最终，当你将这些部件放置在 **场景** 树中的 **沉入墙面**
    下时，你会看到下面截图所示的内容：
- en: '![Figure 9.8 – The same wall pieces are used to prevent water from leaking
    under ](img/Figure_9.8_B17473.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 使用相同的墙面部件防止水从下面渗漏](img/Figure_9.8_B17473.jpg)'
- en: Figure 9.8 – The same wall pieces are used to prevent water from leaking under
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 使用相同的墙面部件防止水从下面渗漏
- en: The ebb and flow of the sea will now be kept at bay. Notice that we didn’t want
    the sunken wall parts to go all the way around the floor. This is because you
    can always limit the camera angles to not show the back parts of the structure.
    It’s a cheap way to keep the asset count low. However, if you want to give full
    freedom to the player so that they can rotate around the whole structure, you
    may want to change your level design to accommodate that. We’ll be investigating
    camera settings in [*Chapter 12*](B17473_12.xhtml#_idTextAnchor206), *Interacting
    with the World Through Camera and Character Controllers*. For now, we still need
    to finish our level.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将海浪的起伏控制在一定范围内。请注意，我们不想让沉没的墙壁部分完全围绕地面。这是因为你可以始终限制摄像机角度，不显示结构的背面。这是一种保持资产数量低廉的方法。然而，如果你想给玩家充分的自由，让他们可以围绕整个结构旋转，你可能需要改变你的关卡设计以适应这一点。我们将在[*第12章*](B17473_12.xhtml#_idTextAnchor206)中调查摄像机设置，*通过摄像机和角色控制器与世界交互*。目前，我们仍然需要完成我们的关卡。
- en: Placing the rocks
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 放置岩石
- en: Since we are currently concerned about the parts near the water, let’s add some
    rocks to the scene. In the Blender file for this level (`Level-01.blend`), you’ll
    see individual rocks. They have been organized to give the illusion of a rock
    formation. It’s perfectly fine to follow a similar approach and place specific
    rocks into your scene in Godot too, more specifically under the **Rocks** node.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前关注的是靠近水的地方，让我们在场景中添加一些岩石。在这个级别的Blender文件（`Level-01.blend`）中，你会看到单个的岩石。它们已经被组织起来，以产生岩石群落的错觉。在Godot中采用类似的方法，将特定的岩石放置到场景中也是完全可以的，更具体地说是在**岩石**节点下。
- en: 'However, there is an easier way. What if you exported the left and right rock
    formations as a single object from Blender? This is entirely possible, and that’s
    why we have prepared two files for you:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个更简单的方法。如果你从Blender中导出左右岩石群落作为一个单一物体，这是完全可能的，这就是为什么我们为你准备了两个文件：
- en: '`RocksLeft.glb`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RocksLeft.glb`'
- en: '`RocksRight.glb`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RocksRight.glb`'
- en: You can instance these two files and move the instances freely using the gizmo.
    This means you don’t have to use the snap feature. Adjust the position of the
    rocks wherever you think is best.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实例化这两个文件，并使用变换工具自由移动实例。这意味着你不需要使用快速移动功能。将岩石的位置调整到你认为最好的地方。
- en: Speaking of moving assets without using the snap feature, perhaps we can practice
    it a bit more. Since the floor looks empty, it’s time we discuss complementary
    design elements such as props.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到在不使用快速移动功能的情况下移动资产，或许我们可以多练习一下。由于地面看起来很空旷，现在是时候讨论一些补充设计元素，比如道具。
- en: Distributing props
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 道具分布
- en: A prop is an object that serves as a support element. Props are also often called
    necessary clutter since they complete a décor. Otherwise, when things look too
    sterile, it’s less pleasant to the eye and we start paying attention to repeating
    patterns or unnecessary details.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 道具是一种作为支撑元素的物体。道具也常被称为必要的杂乱，因为它们完成了装饰。否则，当东西看起来太干净时，对眼睛来说就不那么愉快了，我们开始注意到重复的图案或不必要的细节。
- en: 'Instead, we want the person who’s experiencing the scene to feel at ease. This
    is also a great way for designers to hide important elements in plain sight. To
    that end, we will use the following list of props and distribute these assets
    around the scene:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们希望体验场景的人感到舒适。这也是设计师们将重要元素隐藏在明显之处的一个好方法。为此，我们将使用以下道具列表，并将这些资产分布在整个场景中：
- en: '`Barrel.glb`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Barrel.glb`'
- en: '`Backpack.glb`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backpack.glb`'
- en: '`Bush_Round.glb`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bush_Round.glb`'
- en: '`Candles_1.glb` and `Candles_2.glb`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Candles_1.glb`和`Candles_2.glb`'
- en: '`Cart.glb`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cart.glb`'
- en: '`Crate.glb`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Crate.glb`'
- en: '`DeadTree_3.glb`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeadTree_3.glb`'
- en: '`Flag_Wall.glb`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flag_Wall.glb`'
- en: '`Pot1.glb`, `Pot2.glb`, `Pot3.glb`, and their broken versions'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pot1.glb`, `Pot2.glb`, `Pot3.glb`及其破损版本'
- en: '`Statue_Stag.glb`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Statue_Stag.glb`'
- en: 'Once you’ve finished moving the props, your scene will look as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了道具的移动，你的场景将看起来如下：
- en: '![Figure 9.9 – The props have been distributed all over the dock ](img/Figure_9.9_B17473.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 道具已经分布在整个码头周围](img/Figure_9.9_B17473.jpg)'
- en: Figure 9.9 – The props have been distributed all over the dock
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 道具已经分布在整个码头周围
- en: While you are at it, you may as well instance `Column_Round.glb`, make two more
    copies, and place them under the `Rail_Corner.glb` and `Rail_Straight.glb` could
    be placed along the edge and near the stag statue. You don’t have to be pixel-perfect
    with these objects, but if you want to be precise, you can use `Level-01.blend`
    for reference.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你忙于这件事时，你不妨实例化 `Column_Round.glb`，再复制两个，并将它们放在 `Rail_Corner.glb` 和 `Rail_Straight.glb`
    下方，这些可以沿着边缘和靠近鹿雕像放置。你不必对这些对象做到像素级精确，但如果你想更精确，可以使用 `Level-01.blend` 作为参考。
- en: Finishing the rest of the level
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成关卡的其他部分
- en: To finish off the level, we need to place the sconces and construct a pier.
    These assets are no different than the other ones you have instanced and moved
    around the level.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成关卡，我们需要放置壁灯并建造一个码头。这些资产与您在其他地方实例化和移动的资产没有不同。
- en: However, placing the dock pieces may throw you off a bit as far as positioning
    goes. You may find that the stairs piece looks slightly off dimension-wise. Sometimes,
    assets are designed to be generic, while other times, assets will be designed
    so that they can fit or connect with the other models seamlessly. Regardless,
    since it’s possible to adjust the final position in Godot, we can recover from
    these minor issues.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，放置码头部件可能会在定位方面让你有些困惑。你可能发现楼梯部件在尺寸上看起来有些不合适。有时，资产被设计成通用的，而有时，资产会被设计成可以无缝地与其他模型配合或连接。无论如何，由于在
    Godot 中可以调整最终位置，我们可以从这些小问题中恢复过来。
- en: 'To simulate how we dealt with this issue, we’ll give you the **Translation**
    values we used for the positions of both pieces:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟我们如何处理这个问题，我们将向您提供我们用于两个部件位置的**平移**值：
- en: '`4`, `-1`, `5.5`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`, `-1`, `5.5`'
- en: '`4`, `-1.5`, `8.9`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`, `-1.5`, `8.9`'
- en: Your values will most likely be different since you were undoubtedly moving
    your level pieces in directions that felt natural to you. If your numbers don’t
    match our example, don’t worry. We would like to point out the relative difference
    between the two structures. You’ll also most likely have one number that’s the
    same in one of the axes, either **X** or **Z**. Also, an educated guess on our
    end, your **Y** for the stairs will be 0.5 lower. This should result in a pier
    structure that looks like it was designed as one piece. If you want to have a
    taller pier, then you can create a copy of the stairs and move it accordingly.
    That’s the benefit of having separate pieces.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你无疑是在以对你来说自然的方式移动关卡部件，你的值可能会有所不同。如果你的数字与我们的示例不匹配，请不要担心。我们想指出两个结构之间的相对差异。你也可能有一个数字在一个轴上相同，无论是**X**还是**Z**轴。此外，我们根据经验推测，你的楼梯的**Y**值可能比我们的低
    0.5。这将导致一个看起来像是一个整体设计的码头结构。如果你想有一个更高的码头，你可以复制楼梯并相应地移动它。这就是有单独部件的好处。
- en: 'We suggest that you add the boat model under the **Docks** node in the **Scene**
    tree at this point since it could be considered as part of the docks area. This
    concludes the construction of our level. It should look as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在此处将船模型添加到**场景**树中的**码头**节点下，因为它可以被认为是码头区域的一部分。这标志着我们关卡的建设完成。它应该看起来如下：
- en: '![Figure 9.10 – The level has been reconstructed in Godot ](img/Figure_9.10_B17473.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 该关卡已在 Godot 中重建](img/Figure_9.10_B17473.jpg)'
- en: Figure 9.10 – The level has been reconstructed in Godot
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 该关卡已在 Godot 中重建
- en: Despite our claim that the level’s construction is finished, you may have noticed
    that there are a few odd looking things. We have a dock area with no water – and
    what are those ugly round things doing by the door? We’ll find out how we can
    remedy all this in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们声称关卡的建设已经完成，但你可能已经注意到有一些看起来很奇怪的东西。我们有一个没有水的码头区域——门旁边那些丑陋的圆形东西是什么？我们将在下一节中找出如何解决这个问题。
- en: Constructing the missing materials
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建缺失的材料
- en: When we were placing the props, we covered the gap near the door by placing
    a bush prop (this can be seen in *Figure 9.10*). However, there is something awkward
    about those bushes. Similarly, the arch over the door has some weird-looking dangling
    things over the stone bricks. They should be showing greenery and leaves but all
    we have is a bland, gray surface. We’ll fix these issues in this section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们放置道具时，我们通过放置灌木道具来覆盖门附近的缝隙（这可以在*图 9.10*中看到）。然而，那些灌木有点尴尬。同样，门上的拱门在石头砖块上挂着一些看起来很奇怪的东西。它们应该显示绿色植物和叶子，但我们只有一片平淡的灰色表面。我们将在本节中修复这些问题。
- en: In addition, while it made sense to export individual models from Blender and
    place them in a Godot scene, it didn’t make sense to export the water body. Even
    in Blender, that object was a plane that has been applied a shader that mimicked
    water. We’ll recreate that effect in Godot.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，虽然从Blender导出单个模型并将其放置在Godot场景中是有意义的，但导出水体就没有意义了。即使在Blender中，那个对象也是一个应用了模拟水效果的着色器的平面。我们将在Godot中重新创建那个效果。
- en: Fixing the leaves
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复叶子
- en: First, let’s describe what the problem is with the gray leaves. All the other
    models seem to have their materials displayed properly. Despite all intentions
    and efforts, certain things are never fully transferred between applications.
    This is the case with the leaves. We need to get a bit technical for a more thorough
    answer though.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们描述一下灰色叶子的问题。其他所有模型似乎都正确显示了它们的材料。尽管有所有的意图和努力，某些事情在应用程序之间永远无法完全传递。叶子就是这样。不过，为了得到更详细的答案，我们需要稍微技术化一些。
- en: 'How would you go about designing a leaf in 3D? Since a leaf has so many details
    around its edges, it’s hard to display that much detail without using enough vertices.
    To be conservative, you can use an object with the least number of vertices and
    apply a transparent leaf texture to this basic object. The following screenshot
    shows an application of this method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何设计一个3D叶子？由于叶子边缘有很多细节，如果不使用足够的顶点，很难显示那么多细节。为了保守起见，你可以使用顶点最少的对象，并将透明的叶子纹理应用到这个基本对象上。以下截图显示了这种方法的应用：
- en: '![Figure 9.11 – A transparent file is used as a texture for a rectangle shape
    ](img/Figure_9.11_B17473.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 – 一个透明的文件被用作矩形形状的纹理](img/Figure_9.11_B17473.jpg)'
- en: Figure 9.11 – A transparent file is used as a texture for a rectangle shape
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 一个透明的文件被用作矩形形状的纹理
- en: The preceding screenshot shows a very simple shader. The alpha value of the
    texture is attached to the **Alpha** socket of the shader. Also, **Blend Mode**
    under **Settings** for the material is set to **Alpha Clip**. This means that
    the alpha parts of the texture will be clipped out of the result. We need to do
    the equivalent of this in Godot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了一个非常简单的着色器。纹理的alpha值连接到了着色器的**Alpha**插槽。此外，在材料的**设置**下的**混合模式**被设置为**Alpha剪辑**。这意味着纹理的alpha部分将被从结果中裁剪出来。我们需要在Godot中做类似的事情。
- en: Unfortunately, Godot doesn’t automatically understand and turn on transparency
    for imported materials. We’ll have to do some manual work to display the leaves
    correctly. Luckily, this is also going to get you familiarized with the materials
    and their settings in the **Inspector** panel.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Godot不会自动理解并开启导入材料的透明度。我们将不得不做一些手动工作来正确显示叶子。幸运的是，这也会让你熟悉**检查器**面板中的材料和它们的设置。
- en: 'Let’s start by finding the material for the bushes. The `Models` folder is
    structured in a way to keep distinct models inside individual folders. Hence,
    expand the `Bush` folder in `Texture_Leaves.material` item. This will populate
    the **Inspector** panel with this material’s properties. There is a lot to look
    at, but we only need to tweak a few things:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从寻找灌木的材料开始。`模型`文件夹以保持不同模型分别放在单独文件夹中的方式组织。因此，在`Texture_Leaves.material`项目下扩展`灌木`文件夹。这将使**检查器**面板中出现该材料的属性。有很多东西可以查看，但我们只需要调整几个地方：
- en: Expand the **Flags** section.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展**旗帜**部分。
- en: Turn the **Transparent** setting on.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**透明**设置。
- en: Expand the **Albedo** section.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展**反照率**部分。
- en: Drag and drop `Leaf_Texture.png` from the `Textures` folder into the **Texture**
    field. As an alternative, you can click the **Texture** field and **Load** the
    necessary file.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Leaf_Texture.png`从`纹理`文件夹拖放到**纹理**字段。作为替代，你也可以点击**纹理**字段并**加载**必要的文件。
- en: 'As you may have noticed, the texture for the material was missing, so there
    was no chance for the bushes to display anything. Second of all, by turning the
    transparency on in the flags, we are asking Godot to respect the transparent parts
    of the texture file. You can switch it on and off to see the difference if you
    like. In the end, our scene will look as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，材料的纹理缺失，因此灌木无法显示任何内容。其次，通过在标志中开启透明度，我们是在要求Godot尊重纹理文件的透明部分。如果你喜欢，可以打开和关闭它来查看差异。最终，我们的场景将如下所示：
- en: '![Figure 9.12 – Our bushes are starting to look healthier again ](img/Figure_9.12_B17473.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 我们的灌木看起来又健康起来了](img/Figure_9.12_B17473.jpg)'
- en: Figure 9.12 – Our bushes are starting to look healthier again
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 我们的灌木看起来又健康起来了
- en: You can do the same thing for the arch model, which can be found in the `Architecture`
    folder inside the `Models` folder. This may look like you are repeating yourself,
    and you are right about this. Since we are keeping separate models that use the
    same Blender material inside their relevant folders, the materials are duplicated
    as well. A detailed discussion about this was provided in the *Deciding what to
    do with materials* section of [*Chapter 7*](B17473_07.xhtml#_idTextAnchor112),
    *Importing Blender Assets into Godot*. Since this is an organizational issue,
    we leave the decision to you, but you now know how to enable transparency in materials.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为拱形模型做同样的事情，该模型位于`Models`文件夹内的`Architecture`文件夹中。这看起来可能像是你在重复自己，你是对的。由于我们正在保留使用相同Blender材质的独立模型，并将它们放在相关的文件夹中，因此材质也被复制了。关于这一点，在[*第7章*](B17473_07.xhtml#_idTextAnchor112)的*决定如何处理材质*部分中提供了详细讨论，*将Blender资产导入Godot*。由于这是一个组织问题，我们把这个决定留给你，但现在你知道如何启用材质的透明度。
- en: Another missing piece in our material puzzle is the water object. We intentionally
    omitted the export for that area. To most game developers out there, writing shader
    code is entering dangerous waters. Nevertheless, that’s exactly what we’ll do.
    Hopefully, you’ll see that there is nothing to fear.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们材质拼图中缺失的另一块是水对象。我们故意省略了该区域的导出。对于大多数游戏开发者来说，编写着色器代码是进入危险水域。然而，这正是我们将要做的。希望你能看到没有什么可怕之处。
- en: Creating the water
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建水
- en: 'How do you model a body of water? The answer is not simple, and it even is
    a bit philosophical. The following is a homage to Bruce Lee’s famous philosophical
    quote on martial arts, which uses water as an analogy:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何建模水体？答案并不简单，甚至有点哲学。以下是对李小龙关于武术的著名哲学引言的致敬，其中用水作为类比：
- en: “… Be formless, shapeless, like water.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: “… 要像水一样无形无状。”
- en: You put water into a cup, it becomes the cup.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你把水倒入一个杯子，它就变成了杯子。
- en: You put water into a bottle, it becomes the bottle. …”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你把水倒入瓶子，它就变成了瓶子。…”
- en: It’s hard to imagine what vertices we should create and organize for water in
    Blender or Godot. Instead, we give qualities of water such as reflection, refraction,
    undulation, and murkiness to simple objects, such as a plane or a cube.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender或Godot中想象我们应该创建和组织哪些顶点来表示水是很困难的。相反，我们给简单的对象，如平面或立方体，赋予水的特性，如反射、折射、波动和混浊。
- en: Thus, for this effort, we usually rely on shaders instead of a 3D model. In
    this section, we are going to write a very simple water shader. In the end, you
    can either use the shader from our example or find another example on the internet.
    After all, there are a lot of examples out there, since creating a decent water
    shader usually depends on your use case, and one solution sometimes doesn’t fit
    all.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这项工作，我们通常依赖于着色器而不是3D模型。在本节中，我们将编写一个非常简单的水面着色器。最后，你可以使用我们示例中的着色器，或者在网上找到另一个示例。毕竟，那里有很多示例，因为创建一个合适的水面着色器通常取决于你的使用情况，有时一个解决方案并不适合所有人。
- en: 'Let’s start by creating a water object:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个水对象开始：
- en: Place a **MeshInstance** node under the **Dock** node and rename it **Water**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Dock**节点下放置一个**MeshInstance**节点，并将其重命名为**Water**。
- en: For this new object, assign a **PlaneMesh** to its **Mesh** property in the
    **Inspector** panel.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个新对象，在**Inspector**面板中将**Mesh**属性分配给**PlaneMesh**。
- en: Click this `20` for both **x** and **y** in **Size**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Size**中点击此处的`20`以设置**x**和**y**。
- en: '`20` for both **Subdivide Width** and **Subdivide Height**.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`20`用于**Subdivide Width**和**Subdivide Height**。'
- en: 'We’ll explain what these numbers mean soon, but here is what your **Inspector**
    panel should look like:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会解释这些数字的含义，但这里是你**Inspector**面板应该看起来像的：
- en: '![Figure 9.13 – A rather gray-looking body of water so far ](img/Figure_9.13_B17473.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – 目前看起来相当灰暗的水体](img/Figure_9.13_B17473.jpg)'
- en: Figure 9.13 – A rather gray-looking body of water so far
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 目前看起来相当灰暗的水体
- en: The preceding screenshot shows the properties of a **PlaneMesh** in the **Inspector**
    panel. We have chosen a size that made sense as far as the level’s dimensions
    are concerned. Using the gizmo, as you did for moving other objects, position
    the water object where it makes sense concerning the dock area and the overall
    scene. Once we have written our shader to make this gray object look like water,
    you may also want to adjust its **Y** position too.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了**Inspector**面板中**PlaneMesh**的属性。我们就水平面尺寸选择了合理的尺寸。使用与移动其他对象时相同的gizmo，将水对象放置在码头区域和整个场景中合理的位置。一旦我们编写了使这个灰色对象看起来像水的着色器，你可能还想调整它的**Y**位置。
- en: Additionally, perhaps coincidentally, we chose **20** as the subdivision value.
    You can divide the plane into finer pieces if you want, but a value such as 20
    will introduce enough vertices. So, yes, you have effectively created vertices
    in Godot as opposed to doing so in Blender.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也许巧合的是，我们选择了**20**作为细分值。如果你想将平面分成更细小的部分，也可以，但像20这样的值将引入足够的顶点。所以，是的，你已经在Godot中有效地创建了顶点，而不是在Blender中这样做。
- en: 'We are now ready to change the look of this gray plane. For this, we’ll create
    a material for it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以改变这个灰色平面的外观了。为此，我们将为它创建一个材质：
- en: Right-click the `res://` item in **FileSystem** and choose **New Folder**.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**FileSystem**中的`res://`项，选择**新建文件夹**。
- en: Type `Materials` and confirm.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Materials`并确认。
- en: Right-click the `Materials` folder in **FileSystem** and choose **New Resource**.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**FileSystem**中的`Materials`文件夹，选择**新建资源**。
- en: Search for **ShaderMaterial** and confirm.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索**ShaderMaterial**并确认。
- en: Save it as `Water.tres` in the upcoming **Save Resource As** screen.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在即将出现的**另存为资源**屏幕中将其保存为`Water.tres`。
- en: 'Normally, a newly created item will be displayed in the `Water.tres` in **FileSystem**
    and double-click it. You’ll see a barebones material with a white sphere as a
    preview in the **Inspector** panel. It needs a shader to get more water-like visual
    qualities. This is how you can create it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，新创建的项目将在**FileSystem**中的`Water.tres`中显示，并双击它。你会在**检查器**面板中看到一个带有白色球体预览的裸骨材质。它需要一个着色器来获得更类似水的视觉效果。以下是创建它的方法：
- en: Right-click the `Materials` folder in **FileSystem** and choose **New Resource**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**FileSystem**中的`Materials`文件夹，选择**新建资源**。
- en: Search for **Shader** and confirm.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索**Shader**并确认。
- en: Save it as `cave-water.tres` in the upcoming **Save Resource As** screen.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在即将出现的**另存为资源**屏幕中将其保存为`cave-water.tres`。
- en: 'In [*Chapter 2*](B17473_02.xhtml#_idTextAnchor032), *Building Materials and
    Shaders*, we discussed the relationship between shaders and materials, and how
    they go hand in hand. That was done in Blender, but the concept is universal.
    Hence, we’ve created a material and a shader in Godot. Now, we must associate
    the two:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B17473_02.xhtml#_idTextAnchor032)中，*建筑材料和着色器*，我们讨论了着色器和材料之间的关系，以及它们是如何相辅相成的。这是在Blender中完成的，但这个概念是通用的。因此，我们在Godot中创建了一个材料和着色器。现在，我们必须将这两个关联起来：
- en: Bring up the `Water.tres` file’s properties to the **Inspector** panel.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Water.tres`文件的属性拖放到**检查器**面板中的**着色器**属性。
- en: Drag and drop `cave-water.tres` into the **Shader** property in the **Inspector**
    panel.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`cave-water.tres`拖放到**检查器**面板中的**着色器**属性。
- en: 'The water material has now been assigned an empty shader. We’ll explain the
    shader code after you complete the following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 水材质现在已被分配了一个空着色器。在您完成以下步骤之后，我们将解释着色器代码：
- en: Double-click `cave-water.tres` in **FileSystem**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**FileSystem**中的`cave-water.tres`。
- en: 'Type the following code in the newly expanded **Shader** panel:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新展开的**着色器**面板中输入以下代码：
- en: '[PRE0]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The shader code we have written exposes a few options to the `uniform` statement.
    This is so that you can modify the material’s properties, just like you were able
    to change the settings of the leaf material earlier in the *Fixing the leaves*
    section. That one was a very elaborate shader with lots of options. Ours is a
    very simple shader with only three parameters:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的着色器代码向`uniform`语句公开了一些选项。这样，您可以修改材质的属性，就像您在*修复叶子*部分之前能够更改叶子材质的设置一样。那一个是带有许多选项的非常复杂的着色器。我们的着色器非常简单，只有三个参数：
- en: A wave pattern for creating randomness
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建随机性的波浪模式
- en: A color for the water (by default, this is a light blue color)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水的颜色（默认为浅蓝色）
- en: A height factor to control the motion of the waves (by default, this is `0.1`)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制波浪运动的高度因子（默认为`0.1`）
- en: Two of the properties have their default values. We’ll show you what you can
    pick for the wave pattern later in this section, but first, let’s explain the
    general idea behind all this since this might be the first time you are writing
    shader code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其中两个属性具有默认值。我们将在本节稍后向您展示您可以选择的波浪模式，但首先，让我们解释一下所有这些背后的基本思想，因为这可能是有你第一次编写着色器代码的时候。
- en: Built-in Godot shader functions
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的Godot着色器函数
- en: The two functions, `vertex` and `fragment`, are built-in shader functions. The
    former controls what each vertex will do, while the latter takes care of how the
    overall object will look. Godot has more default functions; we’ve provided a link
    in the *Further reading* section for you to discover.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数，`vertex`和`fragment`，是内置的着色器函数。前者控制每个顶点将执行什么操作，而后者负责整体对象的外观。Godot提供了更多默认函数；我们在**进一步阅读**部分提供了一个链接，供您探索。
- en: Since the `fragment` function looks simple enough, we’ll cover that one first.
    One of the properties we exposed, `color`, will be used in this function so that
    we can paint the object with the color we want. Consequently, we are taking the
    red, green, and blue channels of the input color and applying them to the `ALBEDO`
    property of the shader. Albedo is a scientific term for color. In some applications,
    it’s also referred to as **Diffuse** or **Base Color**, such as in Blender.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`fragment`函数看起来足够简单，我们将首先介绍它。我们公开的一个属性，`color`，将在这个函数中使用，这样我们就可以用我们想要的颜色来绘制对象。因此，我们将输入颜色的红色、绿色和蓝色通道应用到着色器的`ALBEDO`属性。Albedo是一个科学术语，表示颜色。在某些应用中，它也被称为**漫反射**或**基础颜色**，例如在Blender中。
- en: Naturally, we would like to have some translucent qualities for our water object.
    For that, we are using the input color’s alpha channel and binding it to the `ALPHA`
    property of the shader. It’s a simple but effective way to create transparency.
    Speaking of which, if you comment out the `vertex` function, you should still
    be able to see the transparency because each function is responsible for one major
    aspect. However, they complement each other when used together. So, it’s now the
    `vertex` function’s turn.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们希望我们的水对象具有一些半透明特性。为此，我们使用输入颜色的alpha通道并将其绑定到着色器的`ALPHA`属性。这是一个简单但有效的方法来创建透明度。说到这一点，如果您注释掉`vertex`函数，您仍然应该能够看到透明度，因为每个函数都负责一个主要方面。然而，当它们一起使用时，它们会相互补充。所以，现在是`vertex`函数的轮到了。
- en: It would be nice to have the body of water move up and down a bit. That’s the
    reason why we have introduced more vertices to the plane mesh by subdividing it.
    The `vertex` function will take each vertex and change its `y` value to create
    an up and down motion. The last line in the function is responsible for that.
    How much should each vertex change though? Well, that depends on your use case.
    However, we came up with a `displacement` value that seemed appropriate and yet
    exciting enough to simulate a somewhat calm water feature in this cave.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果水体的身体能够上下移动一点，那将很棒。这就是为什么我们通过细分平面网格引入了更多的顶点。`vertex`函数将取每个顶点并改变其`y`值以创建上下运动。函数中的最后一行负责这一点。每个顶点应该改变多少呢？嗯，这取决于您的用例。然而，我们找到了一个似乎合适且足够吸引人的`displacement`值，以模拟这个洞穴中某种平静的水景。
- en: While calculating `displacement`, we are using a texture and sampling some of
    its values. It’ll bring randomness to the way the vertices will move. To that
    end, we are combining the `x` and `z` values of each vertex with the `x` and `z`
    values of the incoming texture (`wave`). You could alter a combination of some
    of those properties and still get a similar result. Perhaps what’s more important
    is the use of the built-in `TIME` property, which is telling the GPU to change
    the result with each millisecond passed. Remove `TIME` from the equation and everything
    will be displaced once and sit still.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算`displacement`时，我们使用一个纹理并采样其一些值。这将给顶点的移动方式带来随机性。为此，我们将每个顶点的`x`和`z`值与传入纹理的`x`和`z`值（`wave`）相结合。您可以改变这些属性的一些组合，并仍然得到类似的结果。也许更重要的是使用内置的`TIME`属性，它告诉GPU随着每一毫秒的过去而改变结果。从方程中移除`TIME`，一切都将一次性位移并静止不动。
- en: 'Finally, we regulate the intensity of the `displacement` with a height factor
    that can be adjusted in the material settings. This concludes our water shader.
    The shader and material have already been connected, but we have yet to tell the
    **Water** node which material it should use. To do so, follow these steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在材质设置中可调整的高度因子来调节`displacement`的强度。这就完成了我们的水着色器。着色器和材质已经连接，但我们还没有告诉**水**节点它应该使用哪种材质。要这样做，请按照以下步骤操作：
- en: Select the **Water** node in the **Scene** tree.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**树中选择**水**节点。
- en: Expand the **Material** section in the **Inspector** panel. You’ll see a slot
    with a label of **0**.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中展开**材质**部分。您会看到一个标签为**0**的槽位。
- en: Drag `Water.tres` from **FileSystem** to the **0** slot.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Water.tres`从**文件系统**拖动到**0**槽位。
- en: 'Voila! The dock should now have a water object that’s modulating over time.
    Move and zoom your viewport camera in to get closer to the sunk walls to notice
    the alpha effect too. This is looking nice already, but we can take this a step
    further by applying the shader a noise texture, which will add more variation
    to the way the vertices fluctuate:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！现在码头应该有一个随时间调节的水对象。移动并缩放你的视口相机靠近下沉的墙壁，以注意到alpha效果。这看起来已经很不错了，但我们可以通过应用噪声纹理来进一步改进，这将增加顶点波动的方式的更多变化：
- en: Expand the **Shader Param** section in the material’s settings in the **Inspector**
    panel.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中展开材质设置中的**着色器参数**部分。
- en: Attach a **New NoiseTexture** for the **Wave Pattern** property.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**波浪模式**属性附加一个**新噪声纹理**。
- en: Expand this new texture and attach a **New OpenSimplexNoise** to its **Noise**
    property.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开这个新纹理，并将其**新OpenSimplexNoise**附加到其**噪声**属性。
- en: 'This will add more randomness to the way the vertices are displaced. When you
    are done with all the code bits and tweakings, your **Inspector** panel should
    look as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将增加顶点偏移的随机性。当你完成所有代码片段和调整后，你的**检查器**面板应该看起来如下：
- en: '![Figure 9.14 – Notice how the water is transparent and wavy along the sunk
    walls ](img/Figure_9.14_B17473.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 注意水在下沉墙壁上的透明度和波浪状](img/Figure_9.14_B17473.jpg)'
- en: Figure 9.14 – Notice how the water is transparent and wavy along the sunk walls
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 注意水在下沉墙壁上的透明度和波浪状
- en: It’s possible to fuss with the values of the noise to create more drastic effects,
    but we leave that to you. By controlling the height factor and color, you can
    simulate calmer or stormier water conditions as well. With that, you have created
    an important missing feature.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调整噪声的值以创建更剧烈的效果，但我们留给你自己去尝试。通过控制高度因子和颜色，你可以模拟更平静或暴风雨的水条件。有了这个，你就创建了一个重要的缺失功能。
- en: About keeping the shader separate
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 关于保持着色器独立
- en: While creating the water material, you could have used an in-memory shader for
    the material using the dropdown in the **Inspector** panel. Most Godot features
    usually start and stay this way, but we followed a different approach by creating
    a resource first and then assigning it later. Thanks to this method, you can create
    different water shaders and swap them as you need them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建水材质时，你可以在**检查器**面板的下拉菜单中使用内存着色器为材质设置。大多数Godot功能通常是这样开始并保持的，但我们采取了不同的方法，首先创建资源，然后稍后分配它。多亏了这种方法，你可以创建不同的水着色器，并在需要时进行交换。
- en: With that, we have taken care of placing all the necessary elements and even
    completing missing parts, such as fixing and/or creating new materials. However,
    while creating the layout, did it feel like you were duplicating and moving so
    many of the same assets, especially with the wall and floor pieces? We bet it
    did! So, let’s present a very helpful Godot tool with which you can lay things
    out easily if your layout is grid-based.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就处理了放置所有必要的元素，甚至完成了缺失的部分，例如修复和/或创建新材料。然而，在创建布局时，你是否感觉像是在重复和移动许多相同的资产，尤其是墙壁和地板部件？我们打赌你确实是这样！所以，让我们介绍一个非常有用的Godot工具，如果你是网格布局，你可以轻松地布置东西。
- en: Laying models on a grid
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网格上放置模型
- en: The main difference between placing objects such as candles, pots, and barrels,
    short props, and floor and wall pieces is that you can distribute the former objects
    willy-nilly. They don’t have to follow a pattern, whereas the floor and wall pieces
    must snap to each other. This kind of structure is also referred to as a grid.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 放置诸如蜡烛、罐子、桶等物体，短道具，以及地板和墙壁部件之间的主要区别在于，你可以随意分布前者的物体。它们不需要遵循模式，而地板和墙壁部件必须相互对齐。这种结构也被称为网格。
- en: To speed things up, we even chose to duplicate an existing piece instead of
    instancing a fresh one because when you create a new instance, it’d start at the
    scene origin, and you’d have to move this new piece near your current area. You
    can even select multiple tiles in a row, duplicate them, and snap these next to
    the old batch. Despite all these shortcuts, since all this sounds formulaic, perhaps
    there should be a better tool. **GridMap** to the rescue!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快速度，我们甚至选择复制一个现有的部件而不是实例化一个新的，因为当你创建一个新的实例时，它将从场景原点开始，你需要将这个新部件移动到你的当前区域附近。你甚至可以一行选择多个瓦片，复制它们，并将这些瓦片紧挨着旧的一批。尽管有所有这些快捷方式，但由于这一切听起来都很公式化，可能需要一个更好的工具。**网格图**来拯救！
- en: If you have used Godot for 2D, you may already be familiar with the **TileMap**
    node. **GridMap** is the same except it works in 3D. Thus, whereas **TileMap**
    will let you add sprites to your scene, **GridMap** will use meshes. For those
    of you who have never used a **TileMap** node, both of these mechanisms in Godot
    are responsible for using a set of tiles or meshes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用过Godot进行2D开发，你可能已经熟悉了**TileMap**节点。**GridMap**与它相同，只是它在3D中工作。因此，**TileMap**将允许你在场景中添加精灵，而**GridMap**将使用网格。对于那些从未使用过**TileMap**节点的人来说，Godot中的这两种机制都负责使用一组瓦片或网格。
- en: Benefits over manual placement
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 手动放置的优点
- en: The **GridMap** solution we are offering is not just for you to expedite the
    creation of your levels. Since the pieces are repeating, the GPU will optimize
    the rendering of said pieces and you’ll get higher frame rates. This is usually
    a very sought-after result among game developers, particularly when your levels
    grow and the number of objects you use in a scene starts to matter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的**GridMap**解决方案不仅是为了让你加快创建关卡的速度。由于这些部件是重复的，GPU将优化这些部件的渲染，你将获得更高的帧率。这对于游戏开发者来说通常是一个非常受欢迎的结果，尤其是当你的关卡变大，场景中使用的对象数量开始变得重要时。
- en: In this section, we’ll present the general settings of a **GridMap** node. Although
    this node depends on **MeshLibrary** to do its job, it makes sense to understand
    the individual settings at this point than mixing both. We’ll learn how to create
    and utilize **MeshLibrary** in the *Taking advantage of MeshLibrary* section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍**GridMap**节点的通用设置。尽管这个节点依赖于**MeshLibrary**来完成其工作，但在这一点上理解个别设置比混合两者更有意义。我们将在*利用网格库的优势*部分学习如何创建和利用**MeshLibrary**。
- en: 'To conserve and compare what we have done so far, we’ll take things a bit slowly:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存和比较我们到目前为止所做的工作，我们将放慢一些：
- en: Save `Level-01.tscn` as `Level-01-Gridmap.tscn`. The root node could still stay
    as **Level-01**.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Level-01.tscn`保存为`Level-01-Gridmap.tscn`。根节点仍然可以是**Level-01**。
- en: Add a **GridMap** node and rename it **FloorGridMap**. You can drag this new
    node and make it the first child right above the **Floor** node if you wish.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**GridMap**节点，并将其重命名为**FloorGridMap**。如果你愿意，你可以拖动这个新节点，使其成为**Floor**节点之上的第一个子节点。
- en: Turn off the **Floor** node by pressing the eye icon.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按眼睛图标关闭**Floor**节点。
- en: 'The last set of actions will introduce a **GridMap** node to the scene. It’s
    empty for now but we’ll fill it with the floor pieces when we get to know mesh
    libraries. Your scene will look as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的几个动作将向场景中引入一个**GridMap**节点。目前它是空的，但当我们了解网格库时，我们会用地板块填充它。你的场景将如下所示：
- en: '![Figure 9.15 – The missing floor pieces will soon be introduced with GridMap
    ](img/Figure_9.15_B17473.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15 – 将很快通过GridMap引入缺失的地板块](img/Figure_9.15_B17473.jpg)'
- en: Figure 9.15 – The missing floor pieces will soon be introduced with GridMap
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 将很快通过GridMap引入缺失的地板块
- en: Although we’re missing a mesh library, we have a **GridMap** node for which
    we can look at properties in the **Inspector** panel. We suggest that you select
    **FloorGridMap** now and read along. The information we’ll present here will lay
    the foundation for you to choose the settings of the future grids you’ll use.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们缺少网格库，但我们有一个**GridMap**节点，我们可以查看**检查器**面板中的属性。我们建议你现在选择**FloorGridMap**并继续阅读。我们将在这里提供的信息将为你在未来选择网格设置奠定基础。
- en: '`2` across the board for a cell. Fortunately, our floor pieces are 2 x 2 x
    2 meters as well. So, we don’t need to change those values in our case. In your
    future projects, you may have to match these values to your models’ dimensions.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个单元，全部为`2`。幸运的是，我们的地板块是2 x 2 x 2米。所以，在我们的情况下，我们不需要更改这些值。在你的未来项目中，你可能需要将这些值与你的模型尺寸相匹配。
- en: 'We’ll ignore the **Octant Size** setting in our efforts since it’s for more
    advanced cases where you can further increase optimization. What’s much more important
    perhaps is the three on/off switches for centering the meshes inside a cell on
    either axis. We’ll make use of this very soon, but the following screenshot should
    help you see what we have been discussing so far:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将忽略**八分位大小**设置，因为它是为更高级的情况而设，在那里你可以进一步增加优化。也许更重要的是，三个用于在任意轴上对齐单元内网格的中心的开/关开关。我们很快就会使用这个功能，但下面的截图应该能帮助你看到我们到目前为止所讨论的内容：
- en: '![Figure 9.16 – Each GridMap can have settings to define the dimension of the
    pieces it’ll use ](img/Figure_9.16_B17473.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16 – 每个GridMap都可以有设置来定义它将使用的部件尺寸](img/Figure_9.16_B17473.jpg)'
- en: Figure 9.16 – Each GridMap can have settings to define the dimension of the
    pieces it’ll use
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 每个网格地图都可以有设置来定义它将使用的块尺寸
- en: The preceding screenshot also shows an expanded menu and its options when you
    click the **Grid Map** button at the top of the viewport. Out of those options,
    **Cursor Rotate Y** with the *S* shortcut will probably be the one you’ll use
    the most. The floor pieces we laid out earlier in the *Creating the cave* section
    all follow the same direction. We tried to cover the floor with props to break
    the sameness but rotating a floor piece 180 degrees around the **Y** axis would
    be another solution.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图还显示了当你点击视口顶部的**网格地图**按钮时展开的菜单及其选项。在这些选项中，带有*S*快捷键的**光标旋转Y**可能是你使用最多的一个。我们在*创建洞穴*部分之前放置的地板块都遵循相同的方向。我们试图用道具覆盖地板以打破单调，但将地板块绕**Y**轴旋转180度将是一个另一种解决方案。
- en: Now that the theoretical knowledge has been established, let’s move on to practical
    applications of using **GridMap**. In the next section, we’ll create a mesh library
    that we’ll use in tandem with our **FloorGridMap** to fill in the missing floor
    pieces.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在理论知识已经建立，让我们继续探讨使用**网格地图**的实际应用。在下一节中，我们将创建一个网格库，我们将与我们的**地板网格地图**一起使用，以填补缺失的地板块。
- en: Taking advantage of MeshLibrary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用MeshLibrary
- en: When you clicked **FloorGridMap** to investigate its properties, the Godot interface
    changed slightly, and it informed you that you should assign a **MeshLibrary**
    since, without one, a **GridMap** is ineffective. In this section, we’ll show
    you what goes into creating a **MeshLibrary**. We’ll also talk about possible
    challenges you might face, not technically, but workflow-wise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**地板网格地图**以调查其属性时，Godot界面略有变化，并通知你应该分配一个**网格库**，因为没有它，**网格地图**将无效。在本节中，我们将向您展示创建**网格库**的过程。我们还将讨论你可能会面临的挑战，不是技术上的，而是工作流程上的。
- en: 'There are two ways to create a **MeshLibrary**. We’ll show you the most common
    way since the other method involves keeping meshes separately in the filesystem,
    and our project has not been set up to accommodate that scenario. Without further
    ado, this is how you create a mesh library:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建**网格库**有两种方式。我们将向您展示最常见的方法，因为另一种方法涉及在文件系统中单独保存网格，而我们的项目尚未设置以适应这种情况。无需多言，这就是创建网格库的方法：
- en: Start a new scene and save it as `Floor-MeshLibrary.tscn` in `Miscellaneous`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的场景，并将其保存为`Floor-MeshLibrary.tscn`在`Miscellaneous`中。
- en: Choose a **Spatial** node as its root.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个**空间**节点作为其根节点。
- en: Instance **Floor_Standard** under the **Spatial** node in the **Scene** panel.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**面板下**空间**节点下实例化**Floor_Standard**。
- en: Click the **Scene** button in Godot’s top menu.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Godot顶部菜单中的**场景**按钮。
- en: Expand **Convert To** and choose **MeshLibrary**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**转换为**并选择**网格库**。
- en: Save your mesh library as `Floor-MeshLibrary.tres` in `Miscellaneous`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的网格库保存为`Floor-MeshLibrary.tres`在`Miscellaneous`中。
- en: If you drag and drop the floor piece directly into the viewport, it will be
    placed somewhere in the scene while considering the perspective of where your
    mouse cursor was. The floor may, for example, look tiny because it will be far
    away from you. Zeroing the position should put the object in the center of the
    world and bring it closer. If you dropped the piece into the **Scene** tree instead,
    you won’t have this problem.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接将地板块拖放到视口中，它会根据你的鼠标光标位置在场景中的某个地方放置。例如，地板可能看起来很小，因为它离你很远。将位置归零应该将对象放置在世界的中心，并使其更靠近。如果你将块拖放到**场景**树中，就不会有这个问题。
- en: 'The following screenshot shows the state right before Godot converts your scene
    into a mesh library:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Godot将你的场景转换为网格库之前的那个状态：
- en: '![Figure 9.17 – We are converting a scene into a mesh library ](img/Figure_9.17_B17473.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17 – 我们正在将场景转换为网格库](img/Figure_9.17_B17473.jpg)'
- en: Figure 9.17 – We are converting a scene into a mesh library
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 我们正在将场景转换为网格库
- en: Now that we have a floor piece in the library, we can add one more model to
    it. The goal here is to pile up items that have similar dimensions. This may sound
    confusing, but let’s add the curved wall. Why? Because although a wall is normally
    thinner and taller, if you think of the volume the curved wall occupies, it’s
    no different than a floor piece. Its base is of similar dimensions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在库中有一个地板块了，我们可以再添加一个模型。这里的目的是堆放具有相似尺寸的物品。这可能听起来有些令人困惑，但让我们添加弯曲的墙壁。为什么？因为尽管墙壁通常更薄更高，但如果你考虑弯曲墙壁占据的体积，它与地板块并无不同。它的底部尺寸相似。
- en: 'So, assuming `Floor-MeshLibrary.tscn` is still open, here is how you can introduce
    another model to the same library:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Floor-MeshLibrary.tscn`仍然打开，以下是您如何向同一库中引入另一个模型的方法：
- en: Find the `Curve.glb` wall piece in **FileSystem**.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文件系统**中找到`Curve.glb`墙壁块。
- en: Drag and drop it over **Spatial**.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它拖放到**Spatial**上。
- en: Convert your scene into a `Miscellaneous`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的场景转换为`Miscellaneous`。
- en: This operation will add the newly introduced piece alongside the old floor piece
    and update the mesh library. Thus, an easy way to create a mesh library is to
    start a new scene, add as many models as you want, and turn this scene full of
    models into a mesh library.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作将在新引入的块和旧的地面块旁边添加，并更新网格库。因此，创建网格库的一个简单方法是从一个新的场景开始，添加尽可能多的模型，然后将这个充满模型的场景变成一个网格库。
- en: We haven’t concerned ourselves with where the pieces will go yet. We’ve just
    been selecting separate pieces as candidates to decorate a grid. Now, let’s associate
    the mesh library with **FloorGridMap** and start laying some models.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有关心这些块将去哪里。我们只是选择单独的块作为装饰网格的候选者。现在，让我们将网格库与**FloorGridMap**关联起来，并开始摆放一些模型。
- en: Using a mesh library with a grid map
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用网格地图的网格库
- en: So far, we have been preparing a mesh library to be used by **FloorGridMap**.
    We have two pieces inside this library. We’ll use the floor piece first, and then
    see if it makes sense to use the curved piece.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在准备一个用于**FloorGridMap**的网格库。这个库里面有两大块。我们将首先使用地板块，然后看看是否使用曲线块也合理。
- en: 'For a **GridMap** to work, you need to fill its **Mesh Library** property in
    the **Inspector** panel. Let’s take care of this first:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要使**网格地图**工作，您需要在**检查器**面板中填写其**网格库**属性。让我们先处理这个问题：
- en: Select **FloorGridMap** in the **Scene** tree.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**树中选择**FloorGridMap**。
- en: Drag and drop `Floor-MeshLibrary.tres` from `Miscellaneous` into the relevant
    field in the **Inspector** panel.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Floor-MeshLibrary.tres`从`Miscellaneous`拖放到**检查器**面板中的相关字段。
- en: 'This will display all the available models as thumbnails in the reserved **GridMap**
    interface, as shown here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有可用的模型作为缩略图在预留的**网格地图**界面中，如图所示：
- en: '![Figure 9.18 – The mesh library can now be used by FloorGridMap ](img/Figure_9.18_B17473.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图9.18 – 网格库现在可以被FloorGridMap使用](img/Figure_9.18_B17473.jpg)'
- en: Figure 9.18 – The mesh library can now be used by FloorGridMap
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 网格库现在可以被FloorGridMap使用
- en: All there is left to do is click one of those thumbnails – for example, **Floor_Standard**
    – and move your mouse over the viewport. You should see a preview of the selected
    model under your cursor. If you click where you can see the preview, you’ll make
    it permanent. Try this a few times.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是点击其中一个缩略图——例如，**Floor_Standard**——并将鼠标移到视图中。你应该会在光标下看到所选模型的预览。如果你点击可以看到预览的地方，它就会变成永久。试几次。
- en: Isn’t this a lot easier than laying out all the floor tiles by yourself? But
    wait a minute – you’ll most likely notice that something looks slightly odd. It’s
    as if the floor pieces are not quite where they are supposed to be. They snap
    to each other, but they don’t seem to quite respect the old coordinates. They
    are either elevated, penetrating wall pieces, or situated off the walls.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这难道不是比你自己摆放所有地板瓷砖要容易得多吗？但是等等——你很可能会注意到有些地方看起来有点奇怪。好像地板块并没有放在它们应该放的位置。它们相互吸附，但似乎并不完全尊重旧的坐标。它们要么升高，穿透墙壁块，要么位于墙壁之外。
- en: This is something you’ll regularly come across when you work with grid maps.
    The solution is easy, but keep in mind that this is not exactly a problem either.
    It depends on the origin points you set for your models. So, yes, the origin points
    are something you may have to deal with even after you have exported your models.
    As a result, you can either fix your origin points by going back inside Blender
    and re-exporting your models or use some of the options available to you in the
    **Inspector** panel.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在你使用网格地图时经常会遇到的事情。解决方案很简单，但请记住，这实际上也不是一个问题。这取决于你为你的模型设置的起点。所以，是的，起点是你可能即使导出模型后也要处理的事情。因此，你可以通过回到Blender内部重新导出你的模型来修复你的起点，或者使用**检查器**面板中提供的选项之一。
- en: 'For now, let’s try to turn the following **Cell** settings on and off:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们尝试切换以下**单元格**设置：
- en: '**Center X**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心X**'
- en: '**Center Y**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心Y**'
- en: '**Center Z**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心Z**'
- en: There is no set formula for whether these properties should be on or off. It
    depends on the models that are used in a mesh library. For example, the **Curve**
    piece in the mesh library has its origin point in one of the corners, whereas
    the floor piece has it, geometrically speaking, in the middle. Since there is
    only one **Cell** setting for the whole grid map, you must have a standard way
    of dealing with all the models of a mesh library. So, it’s not just about piling
    up a whole bunch of models haphazardly – it’s about storing them in a way that
    respects cells, hence a grid structure.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 没有固定的公式来确定这些属性是否应该开启或关闭。这取决于在网格库中使用的模型。例如，网格库中的**曲线**部件其原点位于一个角落，而地板部件从几何学上讲位于中间。由于整个网格地图只有一个**单元格**设置，你必须有一种标准的方式来处理网格库中的所有模型。因此，这不仅仅是随意堆放一堆模型——这是关于以尊重单元格的方式存储它们，从而形成一个网格结构。
- en: To visualize what we are talking about, you can try to place a **Curve** piece
    from the mesh library onto the scene. You’ll notice that you’ll have to reset
    the center settings but that this will also reset the floor pieces back to their
    controversial positions. Therefore, this is something you’ve got to plan for and
    make sure your objects share similar origin points, as well as similar dimensions.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们正在讨论的内容，你可以尝试将网格库中的**曲线**部件放置到场景中。你会注意到你需要重置中心设置，但这也会将地板部件重置到有争议的位置。因此，这是你必须计划并确保你的对象具有相似的原点以及相似尺寸的事情。
- en: Clearing a cell
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 清除单元格
- en: You already know that clicking with the left button of your mouse will place
    the previewed item from the mesh library. If you need to remove an existing cell
    from your scene, you can right-click it and move your mouse around. If you happen
    to have the same model in preview mode, removing the cell from the scene but not
    moving your cursor anywhere else may give the impression that you didn’t remove
    anything. So, remember to wiggle your mouse after you clear a cell.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道点击鼠标左键会将网格库中预览的物品放置到场景中。如果你需要从场景中移除现有的单元格，你可以右键单击它并移动鼠标。如果你恰好有相同的模型处于预览模式，从场景中移除单元格但不在其他地方移动光标可能会给人一种你没有移除任何东西的印象。所以，记得在清除单元格后晃动鼠标。
- en: The necessity of using multiple grid maps
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个网格地图的必要性
- en: Either for the reason that the dimensions of your models will be different,
    or the origin points won’t necessarily align, you’ll eventually notice that you’re
    going to need to use different grid maps in your scene. Since each grid map can
    have separate **Cell** settings, it’s entirely possible to use the same mesh library
    among all these grid maps.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要么是因为你的模型尺寸不同，要么是因为原点不一定对齐，你最终会注意到你需要在场景中使用不同的网格地图。由于每个网格地图都可以有独立的**单元格**设置，完全有可能在这些网格地图之间使用相同的网格库。
- en: In this scenario, you’ll have the convenience of creating one mesh library to
    store all similar items – for example, all the architectural elements – but only
    use some of the models for the right grid map. This beats the hard work of creating
    individual mesh libraries.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将方便地创建一个网格库来存储所有类似的项目——例如，所有建筑元素——但只为正确的网格地图使用一些模型。这比创建单独的网格库要省力得多。
- en: Wrapping up
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Using grid maps is a convenient way to distribute objects that follow a pattern.
    The decision to use it is sometimes an organic process. Most people often start
    building their level by individually placing items. This is usually when they
    aren’t using an already existing level design software. So, the process of creating
    a level happens while you are moving stuff around in a natural way, similar to
    moving furniture around instead of using a floor planner.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网格地图是将遵循模式的对象进行分布的一种便捷方式。决定使用它有时是一个自然的过程。大多数人通常从单独放置物品开始构建他们的关卡。这通常是在他们没有使用现成的关卡设计软件时。因此，创建关卡的过程是在你以自然的方式移动物品的同时发生的，类似于移动家具而不是使用平面规划器。
- en: Thus, either you decide early on or feel the need to switch to it, using grid
    maps will make your life easier. That being said, grid maps and mesh libraries
    are full of bugs in the current version of Godot. For example, adding new models
    to your mesh library scene, then exporting it as a library, won’t always update
    the existing library with new models. Sometimes, the earlier items within a library
    will be swapped with the newer models. So, it’s quite inconsistent. Hopefully,
    the fourth version of Godot will eradicate all these problems.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论是您早期决定还是感到需要切换到它，使用网格图将使您的生活更轻松。话虽如此，当前版本的Godot中网格图和网格库充满了错误。例如，将新模型添加到您的网格库场景中，然后将其导出为库，并不总是更新现有库中的新模型。有时，库中的早期项目会被较新的模型所替换。因此，它相当不一致。希望Godot的第四版将消除所有这些问题。
- en: We wanted to be comprehensive about different ways to create your levels. So,
    it felt necessary to introduce the **GridMap** node, however broken it might be.
    This way, when the community gets this tool implemented bug-free in the future,
    you know that such a convenient tool will be available and useful.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望全面介绍创建关卡的不同方法。因此，介绍**GridMap**节点似乎是必要的，尽管它可能存在缺陷。这样，当社区在未来实现这个工具且无错误时，您就会知道这样一个方便的工具将会可用且有用。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was the first out of many chapters that will help you build a game.
    To kick things off, we tackled the level design aspect of the game.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是众多帮助您构建游戏章节中的第一章。为了开始，我们处理了游戏的设计层面。
- en: This effort involved placing many elements that make up the environment Clara
    will experience. For structures that are next to each other, you learned how to
    take advantage of the snapping feature, but you can also decorate your scene carefree
    if you wish, in the case of distributing props. In the end, you had a clean scene
    structure with objects grouped under the relevant nodes in the **Scene** tree.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个努力包括放置构成克拉拉将体验的环境的许多元素。对于相邻的结构，您学习了如何利用吸附功能，但您也可以在分配道具的情况下无忧地装饰场景。最终，您拥有了一个干净的场景结构，对象被分组在**场景**树下的相关节点下。
- en: Along the way, you noticed that some of the materials were either misconfigured
    or simply missing. To fix these issues, you had to dive deeper into the **Inspector**
    settings for materials with which you remedied the transparency issue. Furthermore,
    you wrote a shader in Godot to simulate a body of water.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，您注意到一些材质要么配置不当，要么根本缺失。为了修复这些问题，您不得不深入到**检查器**设置中的材质，以解决透明度问题。此外，您在Godot中编写了一个着色器来模拟水体。
- en: Considering what you have learned so far and the likelihood that you might be
    designing more levels that have grid patterns, we presented Godot’s **GridMap**
    node. To be able to use this handy tool, you also learned how to create a **MeshLibrary**.
    Despite its benefits, this last method is broken at the moment, but it’s something
    you can employ in future versions of Godot.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到您迄今为止所学的内容以及您可能设计更多具有网格图案的关卡的可能性，我们介绍了Godot的**GridMap**节点。为了能够使用这个方便的工具，您还学习了如何创建**MeshLibrary**。尽管这种方法有其好处，但目前它是损坏的，但这是您可以在Godot的未来版本中使用的。
- en: With that, the level is complete to the point that you can start adding a few
    more elements down the road as you need them. Despite that, everything looks a
    bit bland. In the next chapter, we’ll learn how to make the level look fancier
    with lights, shadows, and environmental effects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关卡已经完成到您可以开始添加一些元素的程度，随着您的需要逐步添加。尽管如此，一切看起来有点单调。在下一章中，我们将学习如何通过灯光、阴影和环境效果使关卡看起来更华丽。
- en: Further reading
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Level design doesn’t always involve placing physical elements inside the game
    world. Sometimes, it means enticing sound design, hiding cute or interesting lore
    elements pertinent to the world and story, and adding non-player characters your
    players can relate to or simply hate. There is a whole layer of psychological
    factors to designing good levels so that you can evoke the emotions you desire
    in your players. If you want to elevate your knowledge in this domain, you are
    going to have to examine resources that are not necessarily game engine-specific.
    So, broaden your horizons! Here are a few resources that will get you started:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏关卡设计并不总是涉及在游戏世界中放置物理元素。有时，它意味着吸引人的音效设计，隐藏与世界观和故事相关的可爱或有意思的背景元素，以及添加玩家可以与之建立联系或简单地讨厌的非玩家角色。设计良好的关卡有一个完整的心理因素层面，以便你可以唤起你希望玩家感受到的情感。如果你想在这个领域提升你的知识，你将不得不检查那些不一定与游戏引擎相关的资源。所以，拓宽你的视野！以下是一些可以帮助你开始的资源：
- en: '[https://www.worldofleveldesign.com](https://www.worldofleveldesign.com)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.worldofleveldesign.com](https://www.worldofleveldesign.com)'
- en: '[https://www.pluralsight.com/courses/fundamentals-professional-level-design](https://www.pluralsight.com/courses/fundamentals-professional-level-design)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.pluralsight.com/courses/fundamentals-professional-level-design](https://www.pluralsight.com/courses/fundamentals-professional-level-design)'
- en: '[https://www.cgmasteracademy.com/courses/46-level-design-for-games/](https://www.cgmasteracademy.com/courses/46-level-design-for-games/)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.cgmasteracademy.com/courses/46-level-design-for-games/](https://www.cgmasteracademy.com/courses/46-level-design-for-games/)'
- en: '[https://www.edx.org/course/introduction-to-level-design-2](https://www.edx.org/course/introduction-to-level-design-2)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.edx.org/course/introduction-to-level-design-2](https://www.edx.org/course/introduction-to-level-design-2)'
- en: 'You had to write a water shader in this chapter. Working with shaders is often
    described as the least entertaining or the most confusing experience among game
    developers. We’ll give you two links so that you can familiarize yourself with
    this topic. The former is the official Godot documentation, which should help
    you produce more direct results in your projects, while the latter should be useful
    for more long-term needs:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要编写一个水面着色器。与着色器一起工作通常被描述为游戏开发者中最不有趣或最令人困惑的经历之一。我们将提供两个链接，以便你熟悉这个主题。前者是官方
    Godot 文档，它应该有助于你在项目中产生更直接的结果，而后者应该对长期需求更有用：
- en: '[https://docs.godotengine.org/en/stable/tutorials/shaders/](https://docs.godotengine.org/en/stable/tutorials/shaders/)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.godotengine.org/zh/stable/tutorials/shaders/](https://docs.godotengine.org/zh/stable/tutorials/shaders/)'
- en: '[https://thebookofshaders.com/](https://thebookofshaders.com/)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://thebookofshaders.com/](https://thebookofshaders.com/)'
