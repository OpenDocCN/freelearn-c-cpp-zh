- en: Creating Your Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的游戏
- en: In this chapter, we will make our project more flexible by adding game objects
    as classes instead of adding them to the `source.cpp` file. In this case, we will
    use classes to make the main character and the enemy. We will create a new rocket
    class that the player will be able to shoot at the enemy. We will then spawn enemies
    at regular intervals along with new rockets when we press a button. We will finally
    check for a collision between the rocket and the enemy and, accordingly, remove
    the enemy from the scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过将游戏对象作为类添加而不是将它们添加到 `source.cpp` 文件中来使我们的项目更加灵活。在这种情况下，我们将使用类来创建主要角色和敌人。我们将创建一个新的火箭类，玩家将能够向敌人射击。当我们按下按钮时，我们将定期生成敌人以及新的火箭。最后，我们将检查火箭和敌人之间的碰撞，并相应地从场景中移除敌人。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Starting afresh
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始
- en: Creating the `Hero` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `Hero` 类
- en: Creating the `Enemy` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `Enemy` 类
- en: Adding enemies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加敌人
- en: Creating the `Rocket` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `Rocket` 类
- en: Adding rockets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加火箭
- en: Collision detection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Starting afresh
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始
- en: Since we are going to create a new class for the main character, we will remove
    the code pertaining to the player character in the main file. Let's learn how
    to do this.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将为主要角色创建一个新的类，我们将从主文件中删除与玩家角色相关的代码。让我们学习如何做到这一点。
- en: 'Remove all player-related code from the `main.cpp` file. After doing this, the
    file should appear as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `main.cpp` 文件中删除所有与玩家相关的代码。完成此操作后，文件应如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating the Hero class
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `Hero` 类
- en: 'We will now move on to create a new class by going through the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将按照以下步骤继续创建一个新类：
- en: Select the project in the solution explorer and then right-click and select
    Add | Class. In this class name, specify the name as `Hero`. You will see the
    `.h` and `.cpp` file sections automatically populated as `Hero.h` and `Hero.cpp`
    respectively. Click on Ok.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中选择项目，然后右键单击并选择添加 | 类。在这个类名中，指定名称为 `Hero`。您将看到 `.h` 和 `.cpp` 文件部分将自动填充为
    `Hero.h` 和 `Hero.cpp`。点击确定。
- en: 'In the `Hero.h` file, add the SFML graphics header and create the `Hero` class:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Hero.h` 文件中，添加 SFML 图形头文件并创建 `Hero` 类：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `Hero` class, we will create the methods and variables that will be
    required by the class. We will also create some public properties that will be
    accessible outside the class, as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Hero` 类中，我们将创建类所需的函数和变量。我们还将创建一些公共属性，这些属性可以在类外部访问，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have the constructor and destructor, which will be respectively called
    when an object is created and destroyed. We add an `init` function to pass a texture
    name, spawn the player, and specify a mass. We are specifying a mass here because
    we will be creating some very basic physics so that when we hit the jump button,
    the player will jump up and land back down on their feet.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有构造函数和析构函数，它们将在对象创建和销毁时分别被调用。我们添加了一个 `init` 函数，用于传递纹理名称、生成玩家并指定质量。我们在这里指定质量是因为我们将创建一些非常基础的物理效果，这样当按下跳跃按钮时，玩家将跳起来并安全着地。
- en: Additionally, the `update`, `jump`, and `getSprite` functions will update the
    player position, make the player jump, and get the sprite of the player that is
    used for depicting the player character respectively.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`update`、`jump` 和 `getSprite` 函数将分别更新玩家位置、使玩家跳跃和获取用于描绘玩家角色的精灵。
- en: 'Apart from these `public` variables, we will also need some `private` variables
    that can only be accessed within the class. Add these in the `Hero` class, as
    follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了这些 `public` 变量之外，我们还需要一些只能在类内部访问的 `private` 变量。在 `Hero` 类中添加这些变量，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `private` section, we create variables for `texture`, `sprite`, and `position`
    so that we can set these values locally. We have the `int` variable called `jumpCount`
    so that we can check the number of times the player character has jumped. This
    is needed because the player can sometimes double jump, which is something we
    don't want.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `private` 部分中，我们为 `texture`、`sprite` 和 `position` 创建变量，以便我们可以本地设置这些值。我们有一个名为
    `jumpCount` 的 `int` 变量，这样我们就可以检查玩家角色跳跃的次数。这需要因为玩家有时可以双跳，这是我们不想看到的。
- en: We will also need the `float` variables to store the player's mass, the velocity
    when they jump, and the gravitational force when they fall back to the ground,
    which is a constant. The `const` keyword tells the program that it is a constant
    and under no circumstance should the value be made changeable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要`float`变量来存储玩家的质量、跳跃时的速度以及下落回地面时的重力，这是一个常数。`const`关键字告诉程序这是一个常数，在任何情况下都不应该改变其值。
- en: Lastly, we add a `bool` value to check whether the player is on the ground.
    Only when the player is on the ground can they start jumping.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个`bool`值来检查玩家是否在地面上。只有当玩家在地面上时，他们才能开始跳跃。
- en: 'Next, in the `Hero.cpp` file, we will implement the functions that we added
    in the `.h` file. At the top of the `.cpp` file, include the `Hero.h` file and
    then add the constructor and destructor:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Hero.cpp`文件中，我们将实现`.h`文件中添加的函数。在`.cpp`文件的顶部，包含`Hero.h`文件，然后添加构造函数和析构函数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `::` symbol represents the scope resolution operator. Functions that have
    the same name can be defined in two different classes. In order to access the
    methods of a particular class, the scope resolution operator is used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`::`符号代表作用域解析运算符。具有相同名称的函数可以在两个不同的类中定义。为了访问特定类的成员，使用作用域解析运算符。'
- en: 'Here, the `Hero` function is scoped to the `Hero` class:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，`Hero`函数的作用域限定在`Hero`类中：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we will set up the `init` function, as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置`init`函数，如下所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We set the position and mass to the local variable and set the grounded state
    to `false`. Then, we set the texture by calling `loadFromFile` and passing in
    the string of the texture name to it. The `c_str()` phrase returns a pointer to
    an array that contains a null-terminated sequence of characters (that is, a `C`
    string) representing the current value of the `string` object ([http://www.cplusplus.com/reference/string/string/c_str/](http://www.cplusplus.com/reference/string/string/c_str/)).
    We then set the sprite texture, position, and the origin of the sprite itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将位置和质量设置为局部变量，并将接地状态设置为`false`。然后，通过调用`loadFromFile`并传入纹理名称的字符串来设置纹理。`c_str()`短语返回一个指向包含空终止序列的字符数组的指针（即`C`字符串），表示当前`string`对象的价值（[http://www.cplusplus.com/reference/string/string/c_str/](http://www.cplusplus.com/reference/string/string/c_str/))。然后，我们设置精灵纹理、位置和精灵本身的原始位置。
- en: 'Now, we add the `update` function where we implement the logic for updating
    the player position. The player''s character cannot move left or right; instead,
    it can only move up, which is the *y* direction. When an initial velocity is applied,
    the player will jump up and then start falling down because of gravity. Add the
    `update` function to update the position of the hero, as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加了`update`函数，在其中我们实现了更新玩家位置的逻辑。玩家的角色不能左右移动；相反，它只能向上移动，即*y*方向。当施加初始速度时，玩家会向上跳起，然后由于重力开始下落。将`update`函数添加到更新英雄位置如下：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the velocity is applied to the character, the player will initially go
    up because of the force, but will then start coming down because of gravity. The
    resulting velocity acts in the downward direction, and is calculated by the following
    formula:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当速度施加到角色上时，玩家最初会因为力量而向上移动，但随后会开始下落，因为重力。结果速度向下作用，其计算公式如下：
- en: '*Velocity = Acceleration × Time*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*速度 = 加速度 × 时间*'
- en: 'We multiply the acceleration by the mass so that the player falls faster. To
    calculate the distance moved vertically, we use the following formula:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加速度乘以质量，以便玩家下落得更快。为了计算垂直移动的距离，我们使用以下公式：
- en: '*Distance = Velocity × Time*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*距离 = 速度 × 时间*'
- en: Then, we calculate the distance moved between the previous and the current frame.
    We then set the position of the sprite based on the position that we calculated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算前一个帧和当前帧之间的移动距离。然后，根据我们计算出的位置设置精灵的位置。
- en: We also have a condition to check whether the player is at one-fourth of the
    distance from the bottom of the screen. We multiply this by `768`, which is the
    height of the window, and then multiply it by `.75f`, at which point the player
    is considered to be on the ground. If that condition is satisfied, we set the
    position of the player, set the resulting velocity to `0`, set the grounded Boolean
    to `true`, and, finally, reset the jump counter to `0`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个条件来检查玩家是否在屏幕底部的四分之一距离处。我们将其乘以`768`，这是窗口的高度，然后乘以`.75f`，此时玩家被认为是站在地面上。如果满足这个条件，我们设置玩家的位置，设置结果速度为`0`，设置地面布尔值为`true`，最后将跳跃计数器重置为`0`。
- en: 'When we want to make the player jump, we call the `jump` function, which takes
    an initial velocity. We will now add the `jump` function, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们想要让玩家跳跃时，我们调用`jump`函数，该函数需要一个初始速度。我们现在将添加`jump`函数，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we first check whether `jumpCount` is less than `2` as we only want the
    player to jump twice. If `jumpCount` is less than `2`, then increase the `jumpCount`
    value by `1`, set the initial velocity, and set the grounded Boolean to `false`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查`jumpCount`是否小于`2`，因为我们只想让玩家跳跃两次。如果`jumpCount`小于`2`，则将`jumpCount`值增加`1`，设置初始速度，并将地面布尔值设置为`false`。
- en: 'Finally, we add the `getSprite` function, which simply gets the current sprite,
    as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了`getSprite`函数，该函数简单地获取当前精灵，如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Congrats! We now have our `Hero` class ready. Let''s use it in the `source.cpp`
    file by going through the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们现在有了我们的`Hero`类。让我们通过以下步骤在`source.cpp`文件中使用它：
- en: 'Include `Hero.h` at the top of the `main.cpp` file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.cpp`文件的顶部包含`Hero.h`：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, add an instance of the `Hero` class, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`Hero`类的一个实例，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `init` function, initialize the `Hero` class:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`函数中，初始化`Hero`类：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we set the texture picture; to do so, set the position to be at `.25`
    (or 25%) from the left of the screen and center it along the `y` axis. We also
    set the mass as `200`, as our character is quite chubby.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置纹理图片；为此，将位置设置为屏幕左侧的`.25`（或25%）处，并在`y`轴上居中。我们还设置了质量为`200`，因为我们的角色相当胖。
- en: 'Next, we want the player to jump when we press the up arrow key. Therefore,
    in the `updateInput` function, while polling for window events, we add the following
    code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要在按下上箭头键时让玩家跳跃。因此，在`updateInput`函数中，在轮询窗口事件时，我们添加以下代码：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we check whether a key was pressed by the player. If a key is pressed
    and the button is the up arrow on the keyboard, then we call the `hero.jump` function
    and pass in an initial velocity value of `750`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查玩家是否按下了按键。如果按键被按下，并且按钮是键盘上的上箭头，那么我们调用`hero.jump`函数，并传入初始速度值`750`。
- en: 'Next, in the `update` function, we call the `hero.update` function, as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`update`函数中，我们调用`hero.update`函数，如下所示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, in the `draw` function, we draw the hero sprite:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`draw`函数中，我们绘制英雄精灵：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can now run the game. When the player is on the ground, press the up arrow
    button on the keyboard to see the player jump. When the player is in the air,
    press the jump button again and you will see the player jump again in midair:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏了。当玩家在地面时，按下键盘上的上箭头按钮，可以看到玩家跳跃。当玩家在空中时，再次按下跳跃按钮，你将看到玩家在空中再次跳跃：
- en: '![](img/af75e5e7-b61e-49ac-ba1c-7c5fdde8c175.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af75e5e7-b61e-49ac-ba1c-7c5fdde8c175.png)'
- en: Creating the Enemy class
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`Enemy`类
- en: 'The player character looks very lonely. She is ready to cause some mayhem,
    but there is nothing to shoot right now. Let''s add some enemies to solve this
    problem:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色看起来非常孤单。她准备好制造一些混乱，但现在没有什么可以射击的。让我们添加一些敌人来解决这个问题：
- en: The enemies will be created using an enemy class; let's create a new class and
    call it `Enemy`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 敌人将通过敌人类创建；让我们创建一个新的类，并将其命名为`Enemy`。
- en: 'Just like the `Hero` class, the `Enemy` class will have a `.h` file and a `.cpp`
    file. In the `Enemy.h` file, add the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像`Hero`类一样，`Enemy`类也将有一个`.h`文件和一个`.cpp`文件。在`Enemy.h`文件中，添加以下代码：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `Enemy` class, just like the `Hero` class, also has a constructor
    and destructor. Additionally, it has an `init` function that takes in the texture
    and position; however, instead of mass, it takes in a float variable that will
    be used to set the initial velocity of the enemy. The enemy won't be affected
    by gravity and will only spawn from the right of the screen and move toward the
    left of the screen. There are also `update` and `getSprite` functions; since the
    enemy won't be jumping, there won't be a `jump` function. Lastly, in the private
    section, we create local variables for texture, sprite, position, and speed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Enemy`类，就像`Hero`类一样，也有构造函数和析构函数。此外，它有一个`init`函数，该函数接受纹理和位置；然而，它不是质量，而是一个用于设置敌人初始速度的浮点变量。敌人不会受到重力的影响，并且只会从屏幕右侧生成并向屏幕左侧移动。还有`update`和`getSprite`函数；由于敌人不会跳跃，所以没有`jump`函数。最后，在私有部分，我们创建了纹理、精灵、位置和速度的局部变量。
- en: 'In the `Enemy.cpp` file, we add the constructor, destructor, `init`, `update`,
    and `getSprite` functions:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Enemy.cpp`文件中，我们添加了构造函数、析构函数、`init`、`update`和`getSprite`函数：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Don't forget to include `Enemy.h` at the top of the main function. We then add
    the constructor and destructor. In the `init` function, we set the local speed
    and position values. Next, we load `Texture` from the file and set the texture,
    position, and origin of the enemy sprite.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在主函数顶部包含`Enemy.h`。然后我们添加构造函数和析构函数。在`init`函数中，我们设置局部速度和位置值。接下来，我们从文件中加载`Texture`并设置敌人的纹理、位置和原点。
- en: 'In the `update` and `getSprite` functions, we update the position and get the
    enemy sprite:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`和`getSprite`函数中，我们更新位置并获取敌人精灵：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have our `Enemy` class ready. Let's now see how we can use it in the game.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好了`Enemy`类。现在让我们看看如何在游戏中使用它。
- en: Adding enemies
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加敌人
- en: In the `main.cpp` class, include the `Enemy` header file. Since we want more
    than one enemy instance, we need to add a vector called `enemies` and then add
    all the newly-created enemies to it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`类中，包含`Enemy`头文件。由于我们想要多个敌人实例，我们需要添加一个名为`enemies`的向量，并将所有新创建的敌人添加到其中。
- en: 'In the context of the following code, the `vector` phrase has absolutely nothing
    to do with math, but rather with a list of objects. In fact, it is like an array
    in which we can store multiple objects. Vectors are used instead of an array because
    vectors are dynamic in nature, so it makes it easier to add and remove objects
    from the list (unlike an array, which, by comparison, is a static list). Let''s
    get started:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码的上下文中，`vector`一词与数学毫无关系，而是与对象列表有关。实际上，它就像一个数组，我们可以存储多个对象。我们使用向量而不是数组，因为向量是动态的，这使得添加和从列表中删除对象（与数组相比，数组是一个静态列表）更容易。让我们开始吧：
- en: 'We need to include `<vector>` in the `main.cpp` file, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`main.cpp`文件中包含`<vector>`，如下所示：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add a new variable called `enemies` of the `vector` type, which will
    store the `Enemy` data type in it:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为`enemies`的新变量，其类型为`vector`，它将存储`Enemy`数据类型：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In order to create a vector of a certain object type, you use the `vector` keyword,
    and inside the arrow brackets, specify the data type that the vector will hold,
    and then specify a name for the vector you have created. In this way, we can create
    a new function called `spawnEnemy()` and add a prototype for it at the top of
    the main function.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个特定对象类型的向量，你使用`vector`关键字，并在箭头括号内指定向量将持有的数据类型，然后指定你创建的向量的名称。这样，我们可以创建一个名为`spawnEnemy()`的新函数，并在主函数顶部添加其原型。
- en: When any function is written below the main function, the main function will
    not be aware that such a function exists. Therefore, a prototype will be created
    and placed above the main function. This means that the function can now be implemented
    below the main function—essentially, the prototype tells the main function that
    there is a function that will be implemented below it, and so to keep a lookout
    for it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何函数在主函数下方编写时，主函数将不知道该函数的存在。因此，将创建一个原型并将其放置在主函数上方。这意味着函数现在可以在主函数下方实现——本质上，原型告诉主函数下面将有一个函数将被实现，因此要留意它。
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we want the enemy to spawn from the right of the screen, but we also want
    the enemy to spawn at either the same height as the player, slightly higher than
    the player, or much higher than the player, so that the player will have to use
    a single jump or a double jump to attack the enemy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望敌人从屏幕的右侧生成，但我们还希望敌人以与玩家相同的高度、略高于玩家的高度或远高于玩家的高度生成，这样玩家就必须使用单跳或双跳来攻击敌人。
- en: 'To do this, we add some randomness to the game to make it less predictable.
    For this, we add the following line of code underneath the `init` function:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们在`init`函数下方添加一些随机性，使游戏不那么可预测。为此，我们添加以下代码行：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `srand` phrase is a pseudorandom number that is initialized by passing a
    seed value. In this case, we are passing in the current time as a seed value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`srand`短语是一个伪随机数，通过传递种子值进行初始化。在这种情况下，我们传递当前时间作为种子值。'
- en: For each seed value, a series of numbers will be generated. If the seed value
    is always the same, then the same series of numbers will be generated. That is
    why we pass in the time value—so that the sequence of numbers that is generated
    will be different each time. We can get the next random number in the series by
    calling the `rand` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个种子值，将生成一系列数字。如果种子值始终相同，则将生成相同的数字序列。这就是我们传递时间值的原因——以确保每次生成的数字序列都不同。我们可以通过调用`rand`函数来获取序列中的下一个随机数。
- en: 'Next, we add the `spawnEnemy` function, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加`spawnEnemy`函数，如下所示：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we first get a random number—this will create a new random number from
    `0` to `2` because of the modulo operator while getting the random location. So
    the value of `randLoc` will either be `0`, `1`, or `2` each time the function
    is called.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先获取一个随机数——这将由于获取随机位置时的模运算符而创建一个新的从`0`到`2`的随机数。因此，每次函数被调用时，`randLoc`的值将是`0`、`1`或`2`。
- en: A new `enemyPos` variable is created that will be assigned depending upon the
    `randLoc` value. We will also set the speed of the enemy depending on the `randLoc`
    value; for this, we create a new float called `speed`, which we will assign later.
    We then create a `switch` statement that takes in the `randLoc` value—this enables
    the random location to spawn the enemy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`enemyPos`变量，其值将根据`randLoc`值分配。我们还将根据`randLoc`值设置敌人的速度；为此，我们创建一个新的浮点数`speed`，稍后将其分配。然后我们创建一个`switch`语句，它接受`randLoc`值——这允许随机位置生成敌人。
- en: 'Depending upon the scenario, we can set the `enemyPosition` variable and the
    `speed` of the enemy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据场景的不同，我们可以设置敌人的`enemyPosition`变量和速度：
- en: When `randLoc` is `0`, the enemy spawns from the bottom and moves with a speed
    of `-400`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`randLoc`为`0`时，敌人从底部生成并以速度`-400`移动。
- en: When `randLoc` is `1`, the enemy spawns from the middle of the screen and moves
    at a speed of `-500`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`randLoc`为`1`时，敌人从屏幕中间生成并以速度`-500`移动。
- en: When the value of `randLoc` is `2`, then the enemy spawns from the top of the
    screen and moves at the faster speed of `-650`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`randLoc`的值为`2`时，敌人从屏幕顶部生成并以更快的速度`-650`移动。
- en: If `randLoc` is none of these values, then a message is printed out saying that
    the value of *y* is incorrect, and instead of breaking, we return to make sure
    that the enemy doesn't spawn in a random location.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`randLoc`不是这些值中的任何一个，则输出一条消息，说明`y`的值不正确，而不是中断，我们返回以确保敌人不会在随机位置生成。
- en: To print out the message to the console, we can use the `printf` function, which
    takes a string value. At the end of the string, we specify `\n`; this is a keyword
    to tell the compiler that it is the end of the line, and whatever is written after
    needs to be put in a new line, similar to when calling `std::cout`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在控制台打印消息，我们可以使用`printf`函数，它接受一个字符串值。在字符串的末尾，我们指定`\n`；这是一个关键字，告诉编译器这是行的末尾，之后写的内容需要放在新的一行，类似于调用`std::cout`。
- en: Once we know the position and speed, we can then create the enemy object itself
    and initialize it. Note that the enemy is created as a pointer; otherwise, the
    reference to the texture is lost and the texture won't display when the enemy
    is spawned. Additionally, when we create the enemy as a raw pointer with a new
    keyword, the system allocates memory, which we will have to delete later.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们知道位置和速度，我们就可以创建敌人对象本身并初始化它。请注意，敌人是以指针的形式创建的；否则，纹理的引用会丢失，当敌人生成时，纹理将不会显示。此外，当我们使用`new`关键字创建敌人作为原始指针时，系统会分配内存，我们稍后必须删除它。
- en: After the enemy is created, we add it to the `enemies` vector by calling the
    `push` function of the vectors.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敌人创建后，我们通过调用向量的`push`函数将其添加到`enemies`向量中。
- en: We want the enemy to spawn automatically at regular intervals. For this, we
    create two new variables to keep track of the current time and spawn a new enemy
    every `1.125` seconds.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望敌人以固定的时间间隔自动出生。为此，我们创建两个新变量来跟踪当前时间，并在每`1.125`秒生成一个新敌人。
- en: 'Next, create two new variables of the `float` type, called `currentTime` and
    `prevTime`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建两个新的`float`类型变量，分别称为`currentTime`和`prevTime`：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, in the `update` function, after updating the `hero` function, add the
    following lines of code in order to create a new enemy:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`update`函数中，在更新`hero`函数之后，添加以下代码行以创建一个新敌人：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we increment the `currentTime` variable. This variable will begin increasing
    as soon as the game starts so that we can track how long it has been since we
    started the game. Next, we check whether the current time is greater than or equal
    to the previous time plus `1.125` seconds, as that is when we want the new enemy
    to spawn. If it is `true`, then we call the `spawnEnemy` function, which will
    create a new enemy. We also set the previous time as equal to the current time
    so that we know when the last enemy was spawned. Good! So, now that we have enemies
    spawning in the game, we can `update` the enemies and also `draw` them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们增加`currentTime`变量。这个变量将在游戏开始后立即开始增加，以便我们可以跟踪自我们开始游戏以来已经过去了多长时间。接下来，我们检查当前时间是否大于或等于上一个时间加上`1.125`秒，因为这是我们希望新敌人出生的时间。如果是`true`，那么我们调用`spawnEnemy`函数，这将创建一个新的敌人。我们还设置上一个时间等于当前时间，这样我们就可以知道最后一个敌人是在什么时候出生的。好！所以，现在我们已经让游戏中的敌人开始出生了，我们可以`update`敌人并`draw`它们。
- en: 'In the `update` function, we also create a `for` loop to update the enemies
    and delete the enemies once they go beyond the left of the screen. To do this,
    we add the following code to the `update` function:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`函数中，我们同样创建一个`for`循环来更新敌人并删除一旦它们超出屏幕左侧的敌人。为此，我们在`update`函数中添加以下代码：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is where the use of vectors is really helpful. With vectors, we are able
    to add, delete, and insert elements in the vector. In the example here, we get
    the reference of the enemy at the location index of `i` in the vector. If that
    enemy goes offscreen and needs to be deleted, then we can just use the `erase`
    function and pass the location index from the beginning of the vector to remove
    the enemy at that index. When we reset the game, we also delete the local reference
    of the enemy we created. This will also free the memory space that was allocated
    when we created the new enemy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是向量使用非常有帮助的地方。使用向量，我们能够向向量中添加、删除和插入元素。在这个例子中，我们获取向量中位置索引为`i`的敌人的引用。如果那个敌人超出屏幕并需要被删除，那么我们只需使用`erase`函数并传递从向量开始的位置索引来删除该索引处的敌人。当我们重置游戏时，我们也删除了我们创建的敌人的局部引用。这也会释放我们创建新敌人时分配的内存空间。
- en: 'In the `draw` function, we go through each of the enemies in a `for...each`
    loop and draw them:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`函数中，我们通过一个`for...each`循环遍历每个敌人并绘制它们：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use the `for...each` loop to go through all the enemies, since the `getSprite`
    function needs to be called on all of them. Interestingly, we didn't use `for...each`
    when we had to update the enemies because with the `for` loop, we can simply use
    the index of the enemy if we have to delete it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for...each`循环遍历所有敌人，因为`getSprite`函数需要在它们所有身上调用。有趣的是，当我们需要更新敌人时我们没有使用`for...each`，因为使用`for`循环，如果我们需要删除它，我们可以简单地使用敌人的索引。
- en: 'Finally, add the `Enemy.png` file to the `Assets/graphics` folder. Now, when
    you run the game, you will see enemies spawning at different heights and moving
    toward the left of the screen:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Enemy.png`文件添加到`Assets/graphics`文件夹。现在，当你运行游戏时，你将看到敌人以不同的高度在屏幕左侧出生并移动：
- en: '![](img/8d000619-b80f-4cdd-9aa3-7c05f5092e44.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d000619-b80f-4cdd-9aa3-7c05f5092e44.png)'
- en: Creating the Rocket class
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建火箭类
- en: 'The game has enemies in it now, but the player still can''t shoot at them.
    Let''s create some rockets so that these can be launched from the player''s bazooka
    by going through the following steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中现在有敌人了，但玩家仍然不能射击它们。让我们创建一些火箭，这样它们就可以通过以下步骤从玩家的火箭筒中发射出来：
- en: 'In the project, create a new class called `Rocket`. As you can see from the
    following code block, the `Rocket.h` class is very similar to the `Enemy.h` class:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中，创建一个名为`Rocket`的新类。如以下代码块所示，`Rocket.h`类与`Enemy.h`类非常相似：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `public` section contains the `init`, `update`, and `getSprite` functions.
    The `init` function takes in the name of the texture to load, the position to
    set, and the speed at which the object is initialized. The `private` section has
    local variables for the `texture`, `sprite`, `position`, and `speed`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`部分包含`init`、`update`和`getSprite`函数。`init`函数接受要加载的纹理名称、设置的位置以及初始化对象的速度。`private`部分有`texture`、`sprite`、`position`和`speed`的局部变量。'
- en: 'In the `Rocket.cpp` file, we add the constructor and destructor, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Rocket.cpp`文件中，我们添加构造函数和析构函数，如下所示：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `init` function, we set the sp`e`ed and `position` variables. Then, we
    set the `texture` variable and initialize the sprite with the `texture` variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，我们设置`speed`和`position`变量。然后我们设置`texture`变量，并用`texture`变量初始化精灵。
- en: 'Next, we set the `position` variable and origin of the sprite, as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置精灵的`position`变量和原点，如下所示：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `update` function, the object is moved according to the `speed` variable:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`函数中，对象根据`speed`变量移动：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `getSprite` function returns the current sprite, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getSprite`函数返回当前精灵，如下所示：'
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding rockets
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加火箭
- en: 'Now that we have created the rockets, let''s learn how to add them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了火箭，让我们学习如何添加它们：
- en: 'In the `main.cpp` file, we include the `Rocket.h` class as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.cpp`文件中，我们按照如下方式包含`Rocket.h`类：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then create a new vector of `Rocket` called `rockets`, which takes in `Rocket`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个新的`Rocket`向量，称为`rockets`，它接受`Rocket`：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `update` function, after we have updated all the enemies, we update
    all the rockets. We also delete the rockets that go beyond the right of the screen:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`函数中，在我们更新了所有敌人之后，我们更新所有火箭。我们还会删除超出屏幕右边的火箭：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we draw all the rockets with the `draw` function by going through
    each rocket in the scene:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过遍历场景中的每个火箭，使用`draw`函数绘制所有火箭：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, we can actually shoot the rockets. In the `main.cpp`, class, create a new
    function called `shoot()` and add a prototype for it at the top of the main function.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们实际上可以发射火箭了。在`main.cpp`文件中，在类中创建一个名为`shoot()`的新函数，并在主函数的顶部添加它的原型：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `shoot` function, we will add the functionality to shoot the rockets.
    We will spawn new rockets and push them back to the `rockets` vector. You can
    add the `shoot` function as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`shoot`函数中，我们将添加发射火箭的功能。我们将生成新的火箭并将它们推回到`rockets`向量中。你可以按照以下方式添加`shoot`函数：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When this function is called, it creates a new `Rocket` and initializes it with
    the `Rocket.png` file, sets the position of it as equal to the position of the
    hero sprite, and then sets the velocity to `400.0f`. The rocket is then added
    to the `rockets` vector.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个函数被调用时，它创建一个新的`Rocket`，并用`Rocket.png`文件初始化它，将其位置设置为与英雄精灵的位置相同，然后将速度设置为`400.0f`。然后火箭被添加到`rockets`向量中。
- en: 'Now, in the `updateInput` function, add the following code so that when the
    down arrow key is pressed, the `shoot` function is called:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`updateInput`函数中，添加以下代码，以便当按下向下箭头键时，调用`shoot`函数：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Don''t forget to place the `rocket.png` file in the `assets` folder. Now, when
    you run the game and press the down arrow key, a rocket is fired:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记将`rocket.png`文件放置在`assets`文件夹中。现在，当你运行游戏并按下向下箭头键时，会发射一枚火箭：
- en: '![](img/f55476be-9e97-4fe2-9e6c-c0d5afdd0fc9.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f55476be-9e97-4fe2-9e6c-c0d5afdd0fc9.png)'
- en: Collision detection
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: 'For the final section of this chapter, let''s add some collision detection
    so that the rocket actually kills an enemy when they `both` come into contact
    with each other:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，让我们添加一些碰撞检测，以便当火箭和敌人`同时`接触时，火箭实际上可以消灭敌人：
- en: 'Create a new function called `checkCollision`, and then create a prototype
    for it at the top of the main function:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`checkCollision`的新函数，并在主函数的顶部创建它的原型：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This function takes two sprites so that we can check the intersection of one
    with the other. Add the following code for the function in the same place that
    we added the `shoot` function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数接受两个精灵，以便我们可以检查它们之间的交集。在添加`shoot`函数的同一位置添加以下代码来实现该函数：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Inside this `checkCollision` function, we create two local variables of the
    `FloatRect` type. We then assign the `GlobalBounds` of the sprites to each `FloatRect`
    variable named `shape1` and `shape2`. The `GlobalBounds` gets the rectangular
    region of the sprite that the object is spanning from where it is currently.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `checkCollision` 函数内部，我们创建了两个 `FloatRect` 类型的局部变量。然后，我们将精灵的 `GlobalBounds`
    分配给每个名为 `shape1` 和 `shape2` 的 `FloatRect` 变量。`GlobalBounds` 获取精灵的矩形区域，该区域从当前对象所在的位置开始。
- en: The `FloatRect` type is simply a rectangle; we can use the `intersects` function
    to check whether this rectangle intersects with another rectangle. If the first
    rectangle intersects with another rectangle, then we return `true` to say that
    there is an intersection or collision between the sprites. If there is no intersection,
    then we return `false`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`FloatRect` 类型只是一个矩形；我们可以使用 `intersects` 函数来检查这个矩形是否与另一个矩形相交。如果第一个矩形与另一个矩形相交，那么我们返回
    `true` 来表示精灵之间存在交集或碰撞。如果没有交集，则返回 `false`。'
- en: 'In the `update` function, after updating the `enemy` and `rocket` classes,
    we check the collision between each rocket and each enemy in a nested `for` loop.
    You can add the collision check as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update` 函数中，在更新 `enemy` 和 `rocket` 类之后，我们使用嵌套 `for` 循环检查每个火箭和每个敌人之间的碰撞。你可以如下添加碰撞检查：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we create a double `for` loop, call the `checkCollision` function, and
    then pass each rocket and enemy into it to check the intersection between them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个双重 `for` 循环，调用 `checkCollision` 函数，然后将每个火箭和敌人传递给它以检查它们之间的交集。
- en: If there is an intersection, we remove the rocket and enemy from the vector
    and delete them from the scene. With this, we are done with collision detection.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在交集，我们将火箭和敌人从向量中移除，并从场景中删除它们。这样，我们就完成了碰撞检测。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a separate `Hero` class so that all the code pertaining
    to the `Hero` class was in one single file. In this `Hero` class, we managed jumping
    and the shooting of the rockets in the class. Next, we created the `Enemy` class, because
    for every hero, there needs to be a villain in the story! We learned how to add
    enemies to a vector so that it is easier to loop between the enemies in order
    to update their position. We also created a `Rocket` class and managed the rockets
    using a vector. Finally, we learned how to check for collisions between the enemies
    and the rockets. This creates the foundation of the gameplay loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个单独的 `Hero` 类，以便所有与 `Hero` 类相关的代码都集中在一个单独的文件中。在这个 `Hero` 类中，我们管理跳跃和火箭的射击。接下来，我们创建了
    `Enemy` 类，因为对于每个英雄，故事中都需要一个反派！我们学习了如何将敌人添加到向量中，以便更容易地在敌人之间循环以更新它们的位置。我们还创建了一个
    `Rocket` 类，并使用向量管理火箭。最后，我们学习了如何检查敌人和火箭之间的碰撞。这为游戏循环的构建奠定了基础。
- en: In the next chapter, we will finish the game, adding sound and text to it in
    order to give audio feedback to the player and show the current score.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将完成游戏，向其中添加声音和文本，以便向玩家提供音频反馈并显示当前分数。
