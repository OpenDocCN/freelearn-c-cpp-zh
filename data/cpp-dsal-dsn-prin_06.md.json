["```cpp\n    #include <string>\n    #include <vector>\n    #include <iostream>\n    #include <set>\n    #include <map>\n    #include <queue>\n    template<typename T> class Graph;\n    ```", "```cpp\n    template<typename T>\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t src;\n    \u00a0\u00a0\u00a0\u00a0size_t dest;\n    \u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0// To compare edges, only compare their weights,\n    \u00a0\u00a0\u00a0\u00a0// and not the source/destination vertices\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight < e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight > e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template <typename T>\n    std::ostream& operator<<(std::ostream& os, const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < G.vertices(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << i << \":\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto edges = G.outgoing_edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"{\" << e.dest << \": \" << e.weight << \"}, \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Graph\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Initialize the graph with N vertices\n    \u00a0\u00a0\u00a0\u00a0Graph(size_t N) : V(N)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Return number of vertices in the graph\n    \u00a0\u00a0\u00a0\u00a0auto vertices() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return V;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return all edges in the graph\n    \u00a0\u00a0\u00a0\u00a0auto& edges() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edge_list;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_edge(Edge<T>&& e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the source and destination vertices are within range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src >= 1 && e.src <= V &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e.dest >= 1 && e.dest <= V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_list.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Vertex out of bounds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Returns all outgoing edges from vertex v\n    \u00a0\u00a0\u00a0\u00a0auto outgoing_edges(size_t v) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edge_list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src == v)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges_from_v.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so a graph be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename T>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<<(std::ostream& os, const Graph<T>& G);\n    private:\n    \u00a0\u00a0\u00a0\u00a0size_t V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Stores number of vertices in graph\n    \u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edge_list;\n    };\n    ```", "```cpp\n    template <typename T>\n    auto create_reference_graph()\n    {\n    \u00a0\u00a0\u00a0\u00a0Graph<T> G(9);\n    \u00a0\u00a0\u00a0\u00a0std::map<unsigned, std::vector<std::pair<size_t, T>>> edges;\n    \u00a0\u00a0\u00a0\u00a0edges[1] = { {2, 2}, {5, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[2] = { {1, 2}, {5, 5}, {4, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[3] = { {4, 2}, {7, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[4] = { {2, 1}, {3, 2}, {5, 2}, {6, 4}, {8, 5} };\n    \u00a0\u00a0\u00a0\u00a0edges[5] = { {1, 3}, {2, 5}, {4, 2}, {8, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[6] = { {4, 4}, {7, 4}, {8, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[7] = { {3, 3}, {6, 4} };\n    \u00a0\u00a0\u00a0\u00a0edges[8] = { {4, 5}, {5, 3}, {6, 1} };\n    \u00a0\u00a0\u00a0\u00a0for (auto& i : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& j : i.second)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.add_edge(Edge<T>{ i.first, j.first, j.second });\n    \u00a0\u00a0\u00a0\u00a0return G;\n    }\n    ```", "```cpp\n    template <typename T>\n    auto breadth_first_search(const Graph<T>& G, size_t dest)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::queue<size_t> queue;\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> visit_order;\n    \u00a0\u00a0\u00a0\u00a0std::set<size_t> visited;\n    \u00a0\u00a0\u00a0\u00a0queue.push(1); // Assume that BFS always starts from vertex ID 1\n    \u00a0\u00a0\u00a0\u00a0while (!queue.empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto current_vertex = queue.front();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.pop();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If the current vertex hasn't been visited in the past\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited.find(current_vertex) == visited.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited.insert(current_vertex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visit_order.push_back(current_vertex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto e : G.outgoing_edges(current_vertex))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.push(e.dest);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return visit_order;\n    }\n    ```", "```cpp\n    template <typename T>\n    void test_BFS()\n    {\n    \u00a0\u00a0\u00a0\u00a0// Create an instance of and print the graph\n    \u00a0\u00a0\u00a0\u00a0auto G = create_reference_graph<unsigned>();\n    \u00a0\u00a0\u00a0\u00a0std::cout << G << std::endl;\n    \u00a0\u00a0\u00a0\u00a0// Run BFS starting from vertex ID 1 and print the order\n    \u00a0\u00a0\u00a0\u00a0// in which vertices are visited.\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"BFS Order of vertices: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0auto bfs_visit_order = breadth_first_search(G, 1);\n    \u00a0\u00a0\u00a0\u00a0for (auto v : bfs_visit_order)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << v << std::endl;\n    }\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0using T = unsigned;\n    \u00a0\u00a0\u00a0\u00a0test_BFS<T>();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <string>\n    #include <vector>\n    #include <iostream>\n    #include <set>\n    #include <map>\n    #include <stack>\n    template<typename T> class Graph;\n    ```", "```cpp\n    template<typename T>\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t src;\n    \u00a0\u00a0\u00a0\u00a0size_t dest;\n    \u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0// To compare edges, only compare their weights,\n    \u00a0\u00a0\u00a0\u00a0// and not the source/destination vertices\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight < e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight > e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n     template <typename T>\n    std::ostream& operator<<(std::ostream& os, const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < G.vertices(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << i << \":\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto edges = G.outgoing_edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"{\" << e.dest << \": \" << e.weight << \"}, \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Graph\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Initialize the graph with N vertices\n    \u00a0\u00a0\u00a0\u00a0Graph(size_t N) : V(N)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Return number of vertices in the graph\n    \u00a0\u00a0\u00a0\u00a0auto vertices() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return V;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return all edges in the graph\n    \u00a0\u00a0\u00a0\u00a0auto& edges() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edge_list;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_edge(Edge<T>&& e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the source and destination vertices are within range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src >= 1 && e.src <= V &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e.dest >= 1 && e.dest <= V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_list.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Vertex out of bounds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Returns all outgoing edges from vertex v\n    \u00a0\u00a0\u00a0\u00a0auto outgoing_edges(size_t v) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edge_list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src == v)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges_from_v.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so a graph be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename T>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<< <>(std::ostream& os, const Graph<T>& G);\n    private:\n    \u00a0\u00a0\u00a0\u00a0size_t V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Stores number of vertices in graph\n    \u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edge_list;\n    };\n    ```", "```cpp\n     template <typename T>\n    auto depth_first_search(const Graph<T>& G, size_t dest)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::stack<size_t> stack;\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> visit_order;\n    \u00a0\u00a0\u00a0\u00a0std::set<size_t> visited;\n    \u00a0\u00a0\u00a0\u00a0stack.push(1); // Assume that DFS always starts from vertex ID 1\n    \u00a0\u00a0\u00a0\u00a0while (!stack.empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto current_vertex = stack.top();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.pop();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If the current vertex hasn't been visited in the past\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited.find(current_vertex) == visited.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited.insert(current_vertex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visit_order.push_back(current_vertex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto e : G.outgoing_edges(current_vertex))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If the vertex hasn't been visited, insert it in the stack.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited.find(e.dest) == visited.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.push(e.dest);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return visit_order;\n    }\n    ```", "```cpp\n    template <typename T>\n    auto create_reference_graph()\n    {\n    \u00a0\u00a0\u00a0\u00a0Graph<T> G(9);\n    \u00a0\u00a0\u00a0\u00a0std::map<unsigned, std::vector<std::pair<size_t, T>>> edges;\n    \u00a0\u00a0\u00a0\u00a0edges[1] = { {2, 0}, {5, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[2] = { {1, 0}, {5, 0}, {4, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[3] = { {4, 0}, {7, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[4] = { {2, 0}, {3, 0}, {5, 0}, {6, 0}, {8, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[5] = { {1, 0}, {2, 0}, {4, 0}, {8, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[6] = { {4, 0}, {7, 0}, {8, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[7] = { {3, 0}, {6, 0} };\n    \u00a0\u00a0\u00a0\u00a0edges[8] = { {4, 0}, {5, 0}, {6, 0} };\n    \u00a0\u00a0\u00a0\u00a0for (auto& i : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& j : i.second)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.add_edge(Edge<T>{ i.first, j.first, j.second });\n    \u00a0\u00a0\u00a0\u00a0return G;\n    }\n    ```", "```cpp\n    template <typename T>\n    void test_DFS()\n    {\n    \u00a0\u00a0\u00a0\u00a0// Create an instance of and print the graph\n    \u00a0\u00a0\u00a0\u00a0auto G = create_reference_graph<unsigned>();\n    \u00a0\u00a0\u00a0\u00a0std::cout << G << std::endl;\n    \u00a0\u00a0\u00a0\u00a0// Run DFS starting from vertex ID 1 and print the order\n    \u00a0\u00a0\u00a0\u00a0// in which vertices are visited.\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"DFS Order of vertices: \" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0auto dfs_visit_order = depth_first_search(G, 1);\n    \u00a0\u00a0\u00a0\u00a0for (auto v : dfs_visit_order)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << v << std::endl;\n    }\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0using T = unsigned;\n    \u00a0\u00a0\u00a0\u00a0test_DFS<T>();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <set>\n    #include <map>\n    #include <queue>\n    #include <limits>\n    #include <string>\n    #include <vector>\n    #include <iostream>\n    ```", "```cpp\n    template<typename T> class Graph;\n    template<typename T>\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t src;\n    \u00a0\u00a0\u00a0\u00a0size_t dest;\n    \u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0// To compare edges, only compare their weights,\n    \u00a0\u00a0\u00a0\u00a0// and not the source/destination vertices\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight < e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight > e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n     template <typename T>\n    std::ostream& operator<<(std::ostream& os, const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < G.vertices(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << i << \":\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto edges = G.outgoing_edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"{\" << e.dest << \": \" << e.weight << \"}, \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Graph\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Initialize the graph with N vertices\n    \u00a0\u00a0\u00a0\u00a0Graph(size_t N) : V(N)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Return number of vertices in the graph\n    \u00a0\u00a0\u00a0\u00a0auto vertices() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return V;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return all edges in the graph\n    \u00a0\u00a0\u00a0\u00a0auto& edges() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edge_list;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_edge(Edge<T>&& e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the source and destination vertices are within range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src >= 1 && e.src <= V &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e.dest >= 1 && e.dest <= V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_list.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Vertex out of bounds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Returns all outgoing edges from vertex v\n    \u00a0\u00a0\u00a0\u00a0auto outgoing_edges(size_t v) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edge_list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src == v)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges_from_v.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so a graph be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename T>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<< <>(std::ostream& os, const Graph<T>& G);\n    private:\n    \u00a0\u00a0\u00a0\u00a0size_t V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Stores number of vertices in graph\n    \u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edge_list;\n    };\n    ```", "```cpp\n     template <typename T>\n    auto create_reference_graph()\n    {\n    \u00a0\u00a0\u00a0\u00a0Graph<T> G(9);\n    \u00a0\u00a0\u00a0\u00a0std::map<unsigned, std::vector<std::pair<size_t, T>>> edges;\n    \u00a0\u00a0\u00a0\u00a0edges[1] = { {2, 2}, {5, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[2] = { {1, 2}, {5, 5}, {4, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[3] = { {4, 2}, {7, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[4] = { {2, 1}, {3, 2}, {5, 2}, {6, 4}, {8, 5} };\n    \u00a0\u00a0\u00a0\u00a0edges[5] = { {1, 3}, {2, 5}, {4, 2}, {8, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[6] = { {4, 4}, {7, 4}, {8, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[7] = { {3, 3}, {6, 4} };\n    \u00a0\u00a0\u00a0\u00a0edges[8] = { {4, 5}, {5, 3}, {6, 1} };\n    \u00a0\u00a0\u00a0\u00a0for (auto& i : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& j : i.second)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.add_edge(Edge<T>{ i.first, j.first, j.second });\n    \u00a0\u00a0\u00a0\u00a0return G;\n    }\n    ```", "```cpp\n    template<typename T>\n    struct Label\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t vertex_ID;\n    \u00a0\u00a0\u00a0\u00a0T distance_from_frontier;\n    \u00a0\u00a0\u00a0\u00a0Label(size_t _id, T _distance) :\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vertex_ID(_id),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance_from_frontier(_distance)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// To compare labels, only compare their distances from source\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Label<T>& l) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->distance_from_frontier < l.distance_from_frontier;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Label<T>& l) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->distance_from_frontier > l.distance_from_frontier;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator() (const Label<T>& l) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this > l;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    template <typename T>\n    auto prim_MST(const Graph<T>& G, size_t src)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::priority_queue<Label<T>, std::vector<Label<T>>, std::greater<Label<T>>> heap;\n    \u00a0\u00a0\u00a0\u00a0std::set<int> visited;\n    \u00a0\u00a0\u00a0\u00a0std::vector<T> distance(G.vertices(), std::numeric_limits<T>::max());\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> MST;\n    \u00a0\u00a0\u00a0\u00a0heap.emplace(src, 0);\n    \u00a0\u00a0\u00a0\u00a0// Search for the destination vertex in the graph\n    \u00a0\u00a0\u00a0\u00a0while (!heap.empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto current_vertex = heap.top();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0heap.pop();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If the current vertex hasn't been visited in the past\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited.find(current_vertex.vertex_ID) == visited.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Settling vertex ID \" \n    << current_vertex.vertex_ID << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MST.push_back(current_vertex.vertex_ID);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// For each outgoing edge from the current vertex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// create a label for the destination vertex and add it to the heap\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto e : G.outgoing_edges(current_vertex.vertex_ID))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto neighbor_vertex_ID = e.dest;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto new_distance_to_frontier = e.weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the new path to the vertex is shorter\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// than the previously known best path. \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If yes, update the distance \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (new_distance_to_frontier < distance[neighbor_vertex_ID])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    heap.emplace(neighbor_vertex_ID,\u00a0\u00a0new_distance_to_frontier);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[e.dest] = new_distance_to_frontier;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited.insert(current_vertex.vertex_ID);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return MST;\n    }\n    ```", "```cpp\n    template<typename T>\n    void test_prim_MST()\n    {\n    \u00a0\u00a0\u00a0\u00a0auto G = create_reference_graph<T>();\n    \u00a0\u00a0\u00a0\u00a0std::cout << G << std::endl;\n    \u00a0\u00a0\u00a0\u00a0auto MST = prim_MST<T>(G, 1);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Minimum Spanning Tree:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0for (auto v : MST)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << v << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0using T = unsigned;\n    \u00a0\u00a0\u00a0\u00a0test_prim_MST<T>();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include <string>\n    #include <vector>\n    #include <iostream>\n    #include <set>\n    #include <map>\n    #include <limits>\n    #include <queue>\n    template<typename T> class Graph;\n    ```", "```cpp\n    template<typename T>\n    struct Edge\n    {\n    \u00a0\u00a0\u00a0\u00a0size_t src;\n    \u00a0\u00a0\u00a0\u00a0size_t dest;\n    \u00a0\u00a0\u00a0\u00a0T weight;\n    \u00a0\u00a0\u00a0\u00a0// To compare edges, only compare their weights,\n    \u00a0\u00a0\u00a0\u00a0// and not the source/destination vertices\n    \u00a0\u00a0\u00a0\u00a0inline bool operator< (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight < e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0inline bool operator> (const Edge<T>& e) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return this->weight > e.weight;\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n     template <typename T>\n    std::ostream& operator<<(std::ostream& os, const Graph<T>& G)\n    {\n    \u00a0\u00a0\u00a0\u00a0for (auto i = 1; i < G.vertices(); i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << i << \":\\t\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto edges = G.outgoing_edges(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << \"{\" << e.dest << \": \" << e.weight << \"}, \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    template<typename T>\n    class Graph\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0// Initialize the graph with N vertices\n    \u00a0\u00a0\u00a0\u00a0Graph(size_t N) : V(N)\n    \u00a0\u00a0\u00a0\u00a0{}\n    \u00a0\u00a0\u00a0\u00a0// Return number of vertices in the graph\n    \u00a0\u00a0\u00a0\u00a0auto vertices() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return V;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Return all edges in the graph\n    \u00a0\u00a0\u00a0\u00a0auto& edges() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edge_list;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void add_edge(Edge<T>&& e)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the source and destination vertices are within range\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src >= 1 && e.src <= V &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e.dest >= 1 && e.dest <= V)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge_list.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Vertex out of bounds\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Returns all outgoing edges from vertex v\n    \u00a0\u00a0\u00a0\u00a0auto outgoing_edges(size_t v) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& e : edge_list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (e.src == v)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges_from_v.emplace_back(e);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return edges_from_v;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Overloads the << operator so a graph be written directly to a stream\n    \u00a0\u00a0\u00a0\u00a0// Can be used as std::cout << obj << std::endl;\n    \u00a0\u00a0\u00a0\u00a0template <typename T>\n    \u00a0\u00a0\u00a0\u00a0friend std::ostream& operator<< <>(std::ostream& os, const Graph<T>& G);\n    private:\n    \u00a0\u00a0\u00a0\u00a0size_t V;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Stores number of vertices in graph\n    \u00a0\u00a0\u00a0\u00a0std::vector<Edge<T>> edge_list;\n    };\n    ```", "```cpp\n    template <typename T>\n    auto create_reference_graph()\n    {\n    \u00a0\u00a0\u00a0\u00a0Graph<T> G(9);\n    \u00a0\u00a0\u00a0\u00a0std::map<unsigned, std::vector<std::pair<size_t, T>>> edges;\n    \u00a0\u00a0\u00a0\u00a0edges[1] = { {2, 2}, {5, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[2] = { {1, 2}, {5, 5}, {4, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[3] = { {4, 2}, {7, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[4] = { {2, 1}, {3, 2}, {5, 2}, {6, 4}, {8, 5} };\n    \u00a0\u00a0\u00a0\u00a0edges[5] = { {1, 3}, {2, 5}, {4, 2}, {8, 3} };\n    \u00a0\u00a0\u00a0\u00a0edges[6] = { {4, 4}, {7, 4}, {8, 1} };\n    \u00a0\u00a0\u00a0\u00a0edges[7] = { {3, 3}, {6, 4} };\n    \u00a0\u00a0\u00a0\u00a0edges[8] = { {4, 5}, {5, 3}, {6, 1} };\n    \u00a0\u00a0\u00a0\u00a0for (auto& i : edges)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto& j : i.second)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0G.add_edge(Edge<T>{ i.first, j.first, j.second });\n    \u00a0\u00a0\u00a0\u00a0return G;\n    }\n    ```", "```cpp\n    template <typename T>\n    auto dijkstra_shortest_path(const Graph<T>& G, size_t src, size_t dest)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::priority_queue<Label<T>, std::vector<Label<T>>, std::greater<Label<T>>> heap;\n    \u00a0\u00a0\u00a0\u00a0std::set<int> visited;\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> parent(G.vertices());\n    \u00a0\u00a0\u00a0\u00a0std::vector<T> distance(G.vertices(), std::numeric_limits<T>::max());\n    \u00a0\u00a0\u00a0\u00a0std::vector<size_t> shortest_path;\n    \u00a0\u00a0\u00a0\u00a0heap.emplace(src, 0);\n    \u00a0\u00a0\u00a0\u00a0parent[src] = src;\n    \u00a0\u00a0\u00a0\u00a0// Search for the destination vertex in the graph\n    \u00a0\u00a0\u00a0\u00a0while (!heap.empty()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto current_vertex = heap.top();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0heap.pop();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If the search has reached the destination vertex\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (current_vertex.vertex_ID == dest) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Destination \" << \n    current_vertex.vertex_ID << \" reached.\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited.find(current_vertex.vertex_ID) == visited.end()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Settling vertex \" << \n    current_vertex.vertex_ID << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// For each outgoing edge from the current vertex, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// create a label for the destination vertex and add it to the heap\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto e : G.outgoing_edges(current_vertex.vertex_ID)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto neighbor_vertex_ID = e.dest;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto new_distance_to_dest=current_vertex.distance_from_source \n    + e.weight;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Check if the new path to the destination vertex \n    // has a lower cost than any previous paths found to it, if // yes, then this path should be preferred \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (new_distance_to_dest < distance[neighbor_vertex_ID]) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0heap.emplace(neighbor_vertex_ID, new_distance_to_dest);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parent[e.dest] = current_vertex.vertex_ID;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance[e.dest] = new_distance_to_dest;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited.insert(current_vertex.vertex_ID);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Construct the path from source to the destination by backtracking \n    \u00a0\u00a0\u00a0\u00a0// using the parent indexes\n    \u00a0\u00a0\u00a0\u00a0auto current_vertex = dest;\n    \u00a0\u00a0\u00a0\u00a0while (current_vertex != src) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0shortest_path.push_back(current_vertex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_vertex = parent[current_vertex];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0shortest_path.push_back(src);\n    \u00a0\u00a0\u00a0\u00a0std::reverse(shortest_path.begin(), shortest_path.end());\n    \u00a0\u00a0\u00a0\u00a0return shortest_path;\n    }\n    ```", "```cpp\n     template<typename T>\n    void test_dijkstra()\n    {\n    \u00a0\u00a0\u00a0\u00a0auto G = create_reference_graph<T>();\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Reference graph:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0std::cout << G << std::endl;\n    \u00a0\u00a0\u00a0\u00a0auto shortest_path = dijkstra_shortest_path<T>(G, 1, 6);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"The shortest path between 1 and 6 is:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0for (auto v : shortest_path)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << v << \" \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n    }\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0using T = unsigned;\n    \u00a0\u00a0\u00a0\u00a0test_dijkstra<T>();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```"]