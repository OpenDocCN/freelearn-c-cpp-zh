- en: Introduction to Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式简介
- en: You've learned how to program, and you've probably created some simple games
    at this point, but now you want to start building something larger. Perhaps you
    have tried building an interesting project but you felt like the code was hacked
    together. Maybe you worked with a team of programmers and you couldn't see eye-to-eye
    on how to solve problems. Maybe your code didn't integrate well, or features were
    constantly being added that didn't fit with your original design. Maybe there
    wasn't a design to begin with. When building larger game projects, it's important
    that you break apart your problems, focus on writing quality code, and spend your
    time solving problems unique to your game, as opposed to common programming problems
    that already have a solution. The old advice *don't reinvent the wheel* applies
    to programming as well. One could say that instead of just being someone that
    writes code, you now need to think like a game developer or software engineer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何编程，并且可能在这个阶段已经创建了一些简单的游戏。但现在你想要开始构建更大的东西。也许你尝试构建了一个有趣的项目，但感觉代码像是拼凑起来的。也许你和一群程序员一起工作，但在解决问题时意见不一致。也许你的代码没有很好地集成，或者不断添加的功能与你的原始设计不匹配。也许一开始就没有设计。在构建大型游戏项目时，重要的是要分解你的问题，专注于编写高质量的代码，并将时间花在解决你游戏特有的问题上，而不是已经存在解决方案的常见编程问题上。老话“不要重复造轮子”同样适用于编程。可以说，你现在不仅需要像写代码的人一样思考，还需要像游戏开发者或软件工程师一样思考。
- en: Knowing how to program is very similar to knowing a language. It's one thing
    to use a language to make conversation, but it's quite different if you're trying
    to create a novel or write poetry. In much the same way as when programmers are
    writing code in their game projects, you'll need to pick the right parts of the
    language to use at the best time. To organize your code well, as well as to solve
    problems that arise time and time again, you'll need to have certain tools. These
    tools, design patterns, are exactly what this book is about.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何编程与知道一门语言非常相似。使用一门语言进行对话是一回事，但如果你试图创作小说或写诗，那就完全不同了。以同样的方式，当程序员在他们的游戏项目中编写代码时，你需要选择在最佳时机使用语言的最佳部分。为了很好地组织你的代码以及解决反复出现的问题，你需要某些工具。这些工具，即设计模式，正是本书的主题。
- en: Chapter overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: Over the course of this chapter, we will be discussing the idea of design patterns
    as well as the thought processes to be going through when deciding to use them.
    We will also be setting up our project and installing everything necessary to
    work with the Mach5 engine, which was written by one of the authors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论设计模式的概念以及在使用它们时需要考虑的思维过程。我们还将设置我们的项目，并安装与Mach5引擎一起工作所需的所有必要组件，该引擎是由本书的一位作者编写的。
- en: Your objective
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'This chapter will be split into a number of topics. It will contain a simple
    step-by-step process from beginning to end. Here is the outline of our tasks:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为几个主题。它将包含从开始到结束的简单步骤过程。以下是我们的任务大纲：
- en: What are design patterns?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: Why you should plan for change
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该为变化做准备
- en: Separating the what and how
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分“是什么”和“如何做”
- en: An introduction to interfaces
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口简介
- en: The advantages of compartmentalizing code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码模块化的优势
- en: The problems with using design patterns in games
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏中使用设计模式的问题
- en: Project setup
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置
- en: What are design patterns
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是设计模式
- en: 'Famously documented in the book *Design Patterns: Elements of Reusable Object-Oriented
    Software* by *Erich Gamma*, *John Vlissides*, *Ralph Johnson*, and *Richard Helm*,
    also known as the **Gang of Four** (**GoF** for short), design patterns are solutions
    for common programming problems. More than that, they are solutions that were
    designed and redesigned as developers tried to get more flexibility and reuse
    from their code. You don''t need to have read the Gang of Four''s book in order
    to understand this book, but after finishing you may wish to read or reread that
    book to gain additional insights.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在由Erich Gamma、John Vlissides、Ralph Johnson和Richard Helm所著的著名书籍《设计模式：可复用面向对象软件元素》中所记录的那样，这些设计模式被称为**四人帮**（简称**GoF**），是针对常见编程问题的解决方案。不仅如此，它们是在开发者试图从他们的代码中获得更多灵活性和复用性时设计和重新设计的解决方案。你不需要阅读四人帮的书籍就能理解这本书，但在阅读完毕后，你可能希望阅读或重读那本书以获得额外的见解。
- en: As the Gang of Four title suggests, design patterns are reusable, meaning the
    implemented solution can be reused in the same project, or a completely new one.
    As programmers, we want to be as efficient as possible. We don't want to spend
    time writing the same code over and over, and we shouldn't want to spend time
    solving a problem that already has an answer. An important programming principle
    to follow is the **DRY** principle, **Don't Repeat Yourself**. By using and reusing
    design patterns, we can prevent issues or silly mistakes that would cause problems
    down the road. In addition, design patterns can improve the readability of your
    code not only by breaking apart sections that you would have put together, but
    also by using solutions that other developers are (hopefully) familiar with.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如《设计模式：可复用面向对象软件的基础》这本书名所暗示的，设计模式是可复用的，这意味着实现的解决方案可以在同一个项目中重复使用，或者在一个全新的项目中使用。作为程序员，我们希望尽可能高效。我们不希望一遍又一遍地写相同的代码，也不应该希望花费时间解决已经有答案的问题。遵循的一个重要编程原则是**DRY**原则，即**不要重复自己**。通过使用和复用设计模式，我们可以防止未来可能引起问题的错误或愚蠢的错误。此外，设计模式可以通过拆分你本想组合的部分，以及使用其他开发者（希望）熟悉的解决方案，来提高你代码的可读性。
- en: When you understand and use design patterns, you can shorten the length of a
    discussion with another developer. It is much easier to tell another programmer
    that they should implement a factory than to go into a lengthy discussion involving
    diagrams and a whiteboard. In the best-case scenario, you both know about design
    patters well enough that there doesn't need to be a discussion, because the solution
    would be obvious.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你理解和运用设计模式时，你可以缩短与另一位开发者的讨论时间。告诉另一位程序员他们应该实现一个工厂，比进行涉及图表和白板的冗长讨论要容易得多。在最佳情况下，你们双方对设计模式都足够了解，以至于不需要讨论，因为解决方案会很明显。
- en: Although design patterns are important, they aren't just a library that we can
    just plug into our game. Rather, they are a level above libraries. They are methods
    for solving common problems, but the details of implementing them is always going
    to be unique to your project. However, once you have a good working knowledge
    of patterns, implementing them is easy and will feel natural. You can apply them
    when first designing your project, using them like a blueprint or starting point.
    You can also use them to rework old code if you notice that it's becoming jumbled
    (something we refer to as spaghetti code). Either way, it is worth studying patterns
    so your code quality will improve and your programming *toolbox* will grow larger.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管设计模式很重要，但它们并不是我们可以直接插入游戏的库。相反，它们位于库之上。它们是解决常见问题的方法，但实现它们的细节始终会因项目而异。然而，一旦你对模式有了良好的了解，实现它们就会变得容易，并且会感觉自然。你可以在最初设计项目时应用它们，就像使用蓝图或起点一样。你也可以在注意到旧代码变得混乱（我们称之为意大利面代码）时使用它们进行重构。无论如何，研究模式都是值得的，这样你的代码质量会提高，你的编程**工具箱**也会变得更庞大。
- en: With this *toolbox*, the number of ways to solve a problem is limited only by
    your imagination. It can sometimes be difficult to think of the *best* solution
    right off the bat. It can be difficult to know the *best* place or *best* pattern
    to use in a given situation. Unfortunately, when implemented in the wrong place,
    design patterns can create many problems, such as needlessly increasing the complexity
    of your project with little gain. As I mentioned before, software design is similar
    to writing poetry in that they are both an art. There will be advantages and disadvantages
    to the choices you make.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个**工具箱**，解决问题的方法数量仅受你想象力的限制。有时，一开始就想到**最佳**解决方案可能会有困难。在特定情况下，知道使用**最佳**位置或**最佳**模式可能会有困难。不幸的是，如果在不适当的地方实现，设计模式可能会造成许多问题，比如无谓地增加项目的复杂性，而几乎没有收益。正如我之前提到的，软件设计类似于写诗，因为它们都是一门艺术。你所做的选择都会有优点和缺点。
- en: That means in order to use patterns effectively, you first need to know what
    problem you are trying to solve in your project. Then you must know the design
    patterns well enough to understand which one will help you. Finally, you'll need
    to know the specific pattern you are using well enough so you can adapt it to
    your project and your situation. The goal of this book is to provide you with
    this in-depth knowledge so you can always use the correct tool for the job.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为了有效地使用模式，你首先需要知道你试图在项目中解决的问题是什么。然后你必须足够了解设计模式，以便理解哪一个将帮助你。最后，你需要足够了解你正在使用的特定模式，以便能够将其适应到你的项目和你的情况中。本书的目标是提供这种深入的知识，以便你总能使用正确的工具来完成工作。
- en: There are many design patterns out there, including the foundational patterns
    from the Gang of Four book, architectural patterns, and many more. We will only
    be touching on the ones that we feel are best used for game development. We feel
    it is better to supply you with deep knowledge of a select few patterns than to
    give you a primer on every possible pattern out there. If you're interested in
    learning more about all of the ones out there, feel free to visit [https://en.wikipedia.org/wiki/Software_design_pattern](https://en.wikipedia.org/wiki/Software_design_pattern).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多设计模式，包括来自《四人帮》书籍的基础模式、架构模式等等。我们只会触及我们认为最适合游戏开发的一些模式。我们认为，提供少数几个模式的深入知识，比提供所有可能模式的入门知识要好。如果你对了解更多所有这些模式感兴趣，请随时访问[https://en.wikipedia.org/wiki/Software_design_pattern](https://en.wikipedia.org/wiki/Software_design_pattern)。
- en: Why you should plan for change
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你应该为变化做准备
- en: In my many years doing game development, one thing that has always been constant
    is that a project never ends up 100% the same as it was imagined in the pre-production
    phase. Features are added and removed at a moment's notice and things that you
    think are pivotal to the game experience will get replaced with something completely
    different. Many people can be involved in game development, such as producers,
    game directors, designers, quality assurance, or even marketing, so we can never
    tell who, where, or when those changes will be made to the project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我多年的游戏开发生涯中，一直不变的是，一个项目最终总是无法与预生产阶段想象中的100%相同。功能会随时添加或删除，而你认为对游戏体验至关重要的东西可能会被完全不同的东西所取代。很多人可能参与游戏开发，比如制作人、游戏导演、设计师、质量保证，甚至是市场营销，所以我们永远无法确定谁、在哪里、何时会对项目进行更改。
- en: Since we never can tell what will be changed, it's a good practice to always
    write your code so it can be easily modified. This will involve planning ahead
    much more than you might be used to, and typically involves either a drawn flowchart,
    some form of pseudocode, or possibly both. However, this planning will get you
    much further much faster than jumping straight to coding.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们永远无法确定会发生什么变化，因此始终编写易于修改的代码是一种良好的做法。这需要比你可能习惯的更多前瞻性规划，通常涉及绘制流程图、某种形式的伪代码，或者可能是两者兼而有之。然而，这种规划将使你更快地走得更远，比直接编码要快得多。
- en: Sometimes you may be starting a project from scratch; other times you may be
    joining a game team and using an existing framework. Either way, it is important
    to start coding with a plan. Writing code is called software engineering for a
    reason. The structure of code is often likened to building or architecting. However,
    let's think in smaller terms for now. Let's say you want to build some furniture
    from IKEA.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能从零开始一个项目；其他时候你可能加入一个游戏团队并使用现有的框架。无论哪种方式，重要的是开始编码时要有计划。编写代码被称为软件工程，是有原因的。代码的结构通常被比作建筑或建筑。然而，让我们先从小处着手。假设你想从宜家组装一些家具。
- en: When you buy your furniture, you receive it unassembled with an instruction
    manual. If you were to start building it without following the instructions, it
    is possible you wouldn't finish it at all. Even if you did eventually finish,
    you may have assembled things out of order, causing much more work. It's much
    better to have a blueprint that shows you every step along the way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你购买家具时，你会收到未组装的家具和一份说明书。如果你不按照说明来开始组装，你很可能根本无法完成它。即使你最终完成了，你可能会按照错误的顺序组装东西，造成更多的工作。有一个蓝图显示每一步，这会好得多。
- en: Unfortunately, building a game is not exactly like following an instruction
    manual for furniture. In the case of games and software of any kind, the requirements
    from the client might constantly change. Our *client* might be the producer that
    has an updated timeline for us to follow. It might be our designer that just thought
    of a new feature we *must* have. It might even be our play testers. If they don't
    think the game is fun, we shouldn't just keep moving along making a bad game.
    We need to stop, think about our design, and try something new.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，制作游戏并不完全像遵循家具使用说明书。在游戏和任何类型的软件的情况下，客户的要求可能会不断变化。我们的**客户**可能是为我们提供更新时间表的制作人。它也可能是我们的设计师，他刚刚想到了我们**必须**拥有的新功能。甚至可能是我们的游戏测试员。如果他们认为游戏不好玩，我们就不应该继续制作一个糟糕的游戏。我们需要停下来，思考我们的设计，并尝试新的方法。
- en: Having a plan and knowing a project will change seem to be in opposition to
    each other. How can we have a plan if we don't know what our end product will
    be like? The answer is to plan for that change. That means writing code in such
    a way that making changes to the design is fast and easy. We want to write code
    so that changing the starting location on the second level doesn't force us to
    edit code and rebuild all the configurations of the project. Instead, it should
    be as simple as changing a text file, or better yet, letting a designer control
    everything from a tool.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个计划和知道项目会变化似乎是对立的。如果我们不知道最终产品会是什么样子，我们怎么制定计划呢？答案是计划这种变化。这意味着以这种方式编写代码，使得对设计的更改既快又简单。我们希望编写代码，以便更改第二关的起始位置不需要我们编辑代码和重建项目的所有配置。相反，它应该像更改文本文件一样简单，或者更好的是，让设计师从工具中控制一切。
- en: Writing code like this takes work and planning. We need to think about the design
    of the code and make sure it can handle change. Oftentimes this planning will
    involve other programmers. If you are working on a team, it helps if everyone
    can understand the goal of each class and how it connects with every other class.
    It is important to have some standards in place so others can start on or continue
    with the project without you there.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样的代码需要工作和计划。我们需要考虑代码的设计，并确保它能够处理变化。通常，这种规划会涉及其他程序员。如果您在一个团队中工作，如果每个人都能理解每个类的目标以及它如何与其他类连接，那就很有帮助。制定一些标准很重要，这样其他人就可以在没有您的情况下开始或继续项目。
- en: Understanding UML class diagrams
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解UML类图
- en: Software developers have their own form of blueprints as well, but they look
    different from what you may be used to. In order to create them, developers use
    a format called **Unified Markup Language**, or **UML** for short. This simple
    diagramming style was primarily created by Jim Rumbaugh, Grady Booch, and Ivar
    Jacobson and has become a standard in software development due to the fact that
    it works with any programming language. We will be using them when we need to
    display details or concepts to you via diagrams.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发者也有他们自己的蓝图形式，但它们看起来与您可能习惯的不同。为了创建这些蓝图，开发者使用一种称为**统一标记语言**（**UML**）的格式。这种简单的绘图风格最初由吉姆·鲁姆巴ugh、格雷迪·布奇和伊瓦·雅各布森创建，由于它能与任何编程语言一起工作，因此已成为软件开发的标准。当我们需要通过图表向您展示细节或概念时，我们会使用它们。
- en: 'Design patterns are usually best explained through the use of class diagrams,
    as you''re able to give a demonstration of the idea while remaining abstracted.
    Let''s consider the following class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常最好通过类图来解释，因为您可以在保持抽象的同时演示这个想法。让我们考虑以下类：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Converted to UML, it would look something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为UML，它看起来可能像这样：
- en: '![](img/00005.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00005.jpeg)'
- en: Basic UML diagrams consist of three boxes that represent classes and the data
    that they contain. The top box is the name of the class. Going down, you'll see
    the properties or variables the class will have (also referred to as the data
    members) and then in the bottom box you'll see the functions that it will have.
    A plus symbol (**+**) to the left of the property means that it is going to be
    public, while a minus symbol (**-**) means it'll be private. For functions, you'll
    see that whatever is to the right of the colon symbol (**:**) is the return type
    of the function. It can also include parentheses, which will show the input parameters
    for the functions. Some functions don't need them, so we don't need to place them.
    Also, note in this case I did add `void` as the return type for both functions,
    but that is optional.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的UML图由三个代表类及其包含的数据的框组成。上面的框是类的名称。向下看，你会看到类将拥有的属性或变量（也称为数据成员），然后在下面的框中你会看到它将拥有的函数。属性左侧的加号（**+**）表示它将是公共的，而减号（**-**）表示它将是私有的。对于函数，你会看到冒号（**:**）右侧的内容是函数的返回类型。它也可以包括括号，这将显示函数的输入参数。有些函数不需要它们，所以我们不需要放置它们。此外，请注意，在这种情况下，我确实为两个函数都添加了`void`作为返回类型，但这不是必需的。
- en: Relationships between classes
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类之间的关系
- en: Of course, that class was fairly simple. In most programs, we also have multiple
    classes and they can relate to each other in different ways. Here's a more in-depth
    example, showing the relationships between classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，那个类相当简单。在大多数程序中，我们也有多个类，并且它们可以以不同的方式相互关联。这里有一个更深入的例子，展示了类之间的关系。
- en: Inheritance
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: First of all, we have inheritance, which shows the IS-A relationship between
    classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有继承，它显示了类之间的IS-A关系。
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When an object inherits from another object, it has all of the methods and fields
    that are contained in the parent class, while also adding their own content and
    features. In this instance, we have a special `FlyingEnemy`, which has the ability
    to fly in addition to all of the functionality of the `Enemy` class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象从另一个对象继承时，它将拥有父类中包含的所有方法和字段，同时也会添加它们自己的内容和功能。在这个例子中，我们有一个特殊的`FlyingEnemy`类，它除了具有`Enemy`类的所有功能外，还具有飞行的能力。
- en: 'In UML, this is normally shown by a solid line with a hollow arrow and looks
    like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在UML中，这通常通过一条实线和一个空心箭头表示，看起来如下：
- en: '![](img/00006.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00006.jpeg)'
- en: Aggregation
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: The next idea is aggregation, which is designated by the HAS-A relationship.
    This is when a single class contains a collection of instances of other classes
    that are obtained from somewhere else in your program. These are considered to
    have a weak HAS-A relationship as they can exist outside of the confines of the
    class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个概念是聚合，这由HAS-A关系表示。这是指一个类包含从程序中的其他地方获取的其他类的实例集合。这些被认为具有弱HAS-A关系，因为它们可以存在于类的外部。
- en: 'In this case, I created a new class called `CombatEncounter` which can have
    an unlimited number of enemies that can be added to it. However when using aggregation,
    those enemies will exist before the `CombatEncounter` starts; and when it finishes,
    they will also still exist. Through code it would look something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我创建了一个名为`CombatEncounter`的新类，它可以添加无限数量的敌人。然而，当使用聚合时，那些敌人将在`CombatEncounter`开始之前存在；当它结束时，它们仍然存在。通过代码来看，它可能看起来像这样：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside of UML, it would look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在UML中，它看起来像这样：
- en: '![](img/00007.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: Composition
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: When using composition, this is a strong HAS-A relationship, and this is when
    a class contains one or more instances of another class. Unlike aggregation, these
    instances are not created on their own but, instead, are created in the constructor
    of the class and then destroyed by its destructor. Put into layman's terms, they
    can't exist separately from the whole.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用组合时，这是一个强HAS-A关系，这是指一个类包含一个或多个其他类的实例。与聚合不同，这些实例不是独立创建的，而是在类的构造函数中创建，然后由其析构函数销毁。用简单的话来说，它们不能独立于整体存在。
- en: 'In this case, we have created some new properties for the `Enemy` class, adding
    in combat skills that it can use, as in the Pokémon series. In this case, for
    every one enemy, there are four skills that the enemy will be able to have:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为`Enemy`类创建了一些新的属性，增加了它可以使用的一些战斗技能，就像《宝可梦》系列中那样。在这种情况下，对于每一个敌人，它将能够拥有四种技能：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The line in the diagram looks similar to aggregation, aside from the fact that
    the diamond is filled in:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中的线条看起来与聚合相似，除了菱形被填充了：
- en: '![](img/00008.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00008.jpeg)'
- en: Implements
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: Finally, we have implements, which we will talk about in the *Introduction to
    interfaces* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有实现，我们将在*接口介绍*部分讨论它。
- en: The advantage to this form of communication is that the ideas presented will
    work the same way no matter what programming language you're using and without
    a specific implementation. That's not to say that a specific implementation isn't
    valuable, which is why we will also include the implementation for problems in
    code as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种沟通方式的优势在于，无论您使用什么编程语言，提出的想法都会以相同的方式工作，并且不需要特定的实现。这并不是说特定的实现没有价值，这就是为什么我们也会在代码中包含问题的实现。
- en: There's a lot more information out there about UML and there are various different
    formats that different people like to use. A nice guide that I found that may
    be of interest can be found at [https://cppcodetips.wordpress.com/2013/12/23/uml-class-diagram-explained-with-c-samples/](https://en.wikipedia.org/wiki/Software_design_pattern).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于UML的信息有很多，不同的人喜欢使用各种不同的格式。我发现的一个很好的指南，可能对您有所帮助，可以在[https://cppcodetips.wordpress.com/2013/12/23/uml-class-diagram-explained-with-c-samples/](https://en.wikipedia.org/wiki/Software_design_pattern)找到。
- en: Separating the why and the how
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离“为什么”和“如何”
- en: When creating games, we have many different systems that need to be juggled
    around in order to provide the entire game experience. We need to have objects
    that are drawn to the screen, need to have realistic physics, react when they
    hit each other, animate, have gameplay behavior and, on top of all that, we then
    need to make sure that it runs well 60 times every second.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建游戏时，我们需要处理许多不同的系统，以便提供完整的游戏体验。我们需要有被绘制到屏幕上的对象，需要有逼真的物理效果，当它们相互碰撞时需要做出反应，需要动画，需要有游戏玩法行为，而且在这所有之上，我们还需要确保它每秒运行60次。
- en: Understanding the separation of concerns
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解关注点分离
- en: Each of these different aspects is a problem of its own, and trying to solve
    all of these issues at once would be quite a headache. One of the most important
    concepts to learn as a developer is the idea of compartmentalizing problems, and
    breaking them apart into simpler and simpler pieces until they're all manageable.
    In computer science, there is a design principle known as the separation of concerns
    which deals with this issue. In this aspect, a concern would be something that
    will change the code of a program. Keeping this in mind, we would separate each
    of these concerns into their own distinct sections, with as little overlap in
    functionality as possible. Alternatively, we can make it so that each section
    solves a separate concern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个这些不同的方面都是一个自身的问题，试图一次性解决所有这些问题将会非常头疼。作为一个开发者，学习的一个重要概念就是将问题分块，将它们分解成越来越简单的部分，直到它们都变得可管理。在计算机科学中，有一个被称为关注点分离的设计原则，它处理这个问题。在这个方面，一个关注点可能是指会改变程序代码的某个东西。记住这一点，我们会将这些关注点分别划分到它们各自独立的区域，尽可能减少功能上的重叠。或者，我们可以让每个区域解决一个独立的问题。
- en: Now when we mention concerns, they are a distinct feature or a distinct section.
    Keeping that in mind, it can either be something as high level as an entire class
    or as low level as a function. By breaking apart these concerns into self-contained
    pieces that can work entirely on their own, we gain some distinct advantages.
    By separating each system and making it so they do not depend on each other, we
    can alter or extend any part of our project with minimal hassle. This concept
    creates the basis for almost every single design pattern that we'll be discussing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们提到关注点时，它们是一个独特的功能或一个独特的区域。记住这一点，它可以是像整个类那样高级，也可以是像函数那样低级。通过将这些关注点分解成可以完全独立工作的自包含部分，我们获得了一些明显的优势。通过分离每个系统并确保它们不相互依赖，我们可以以最小的麻烦更改或扩展项目的任何部分。这个概念为我们将要讨论的几乎每一个设计模式奠定了基础。
- en: By using this separation effectively, we can create code that is flexible, modular,
    and easy to understand. It'll also allow us to build the project in a much more
    iterative way because each class and function has its own clearly defined purpose.
    We won't have to worry nearly as much about adding new features that would break
    previously written code because the dependencies are on the existing functional
    classes, and never the other way around. This means we can to easily expand the
    game with things like **Downloadable Content** (**DLC**). This might include new
    game types, additional players, or new enemies with their own unique artificial
    intelligence. Finally, we can take things we've already written and decouple them
    from the engine so we can use them for future projects, saving time and development
    costs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有效地使用这种分离，我们可以创建出灵活、模块化且易于理解的代码。它还将使我们能够以更迭代的模式构建项目，因为每个类和函数都有其明确定义的目的。我们不必过于担心添加新功能会破坏之前编写的代码，因为依赖关系在于现有的功能类，而不是相反。这意味着我们可以轻松地通过添加诸如**可下载内容**（**DLC**）之类的功能来扩展游戏。这可能包括新的游戏类型、额外的玩家或具有独特人工智能的新敌人。最后，我们可以将已经编写的内容与引擎解耦，以便在未来的项目中使用，节省时间和开发成本。
- en: An Introduction to interfaces
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口简介
- en: One of the main features of using design patterns is the idea of always programming
    to an interface and not to an implementation. In other words, the top of any class
    hierarchy should have an abstract class or an interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计模式的主要特点之一是始终面向接口编程，而不是面向实现。换句话说，任何类层次结构的顶部都应该有一个抽象类或接口。
- en: Polymorphism refresher
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态复习
- en: In Hollywood, lots of actors and actresses take on many different roles when
    filming movies. They can be the hero of a story, a villain, or anything else as
    they inhabit a role. No matter what role they've gotten, when they are being filmed
    they are acting even if what they do specifically can be quite different. This
    kind of behavior acts similarly to the idea of polymorphism.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在好莱坞，许多演员和女演员在拍摄电影时扮演许多不同的角色。他们可以是故事中的英雄，也可以是反派，或者任何其他角色，因为他们扮演着角色。无论他们得到什么角色，当他们被拍摄时，他们都在表演，即使他们具体做的事情可能相当不同。这种行为与多态的概念类似。
- en: Polymorphism is one of the three pillars of an object-oriented language (along
    with encapsulation and inheritance). It comes from the words *poly* meaning many
    and *morph* meaning change.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是面向对象语言的三根支柱之一（与封装和继承并列）。它来自单词*poly*（意为多）和*morph*（意为变化）。
- en: Polymorphism is a way to call different specific class functions in an inheritance
    hierarchy, even though our code only uses a single type. That single type, the
    base class reference, will be changed many ways depending on the derived type.
    Continuing with the Hollywood example, we can tell an actor to act out a role
    and, based on what they've been cast in, they will do something different.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是一种在继承层次结构中调用不同特定类函数的方法，尽管我们的代码只使用单一类型。这个单一类型，即基类引用，将根据派生类型以多种方式改变。继续使用好莱坞的例子，我们可以告诉一个演员扮演一个角色，根据他们被选中的角色，他们会做不同的事情。
- en: 'By using the `virtual` keyword on a base class function and overriding that
    function in a derived class, we can gain the ability to call that derived class
    function from a base class reference. While it may seem a bit complex at first,
    this will seem clearer with an example. For instance, if we have the following
    class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在基类函数上使用`virtual`关键字并在派生类中重写该函数，我们可以获得从基类引用调用该派生类函数的能力。虽然一开始可能看起来有些复杂，但通过示例会变得更加清晰。例如，如果我们有以下类：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I could create a derived class with its own method, without modifying the base
    class in any way. In addition, we have the ability to replace or override a method
    within a derived class without affecting the base class. Let''s say I wanted to
    change this function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以创建一个具有自己方法的派生类，而无需以任何方式修改基类。此外，我们还有能力在派生类中替换或重写方法，而不会影响基类。假设我想改变这个函数：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since a derived class can be used anywhere a base class is needed, we can refer
    to derived classes using a base class pointer or an array of pointers and call
    the correct function at runtime. Let''s have a look at the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于派生类可以在需要基类的地方使用，因此我们可以使用基类指针或指针数组来引用派生类，并在运行时调用正确的函数。让我们看看以下代码：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output of the preceding code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应代码的输出：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, even though we have an array of base class pointers, the correct
    derived class function is called. If the functions weren't marked as virtual,
    or if the derived classes didn't override the correct functions, polymorphism
    wouldn't work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，即使我们有一个基类指针数组，也会调用正确的派生类函数。如果函数没有被标记为虚拟的，或者派生类没有覆盖正确的函数，多态将不会工作。
- en: Understanding interfaces
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解接口
- en: An interface implements no functions, but simply declares the methods that the
    class will support. Then, all of the derived classes will do the implementation.
    In this way, the developer will have more freedom to implement the functions to
    fit each instance, while having things work correctly due to the nature of using
    an object-oriented language.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不实现任何函数，只是声明了类将支持的方法。然后，所有派生类都将进行实现。这样，开发者将有更多的自由来实现函数以适应每个实例，同时由于使用面向对象语言的本质，事物将正确工作。
- en: Interfaces may contain only static final variables, and they may contain only
    abstract methods, which means that they cannot be implemented within the class.
    However, we can have interfaces that inherit from other interfaces. When creating
    theses classes, we can implement whatever number of interfaces we want to. This
    allows us to make classes become even more polymorphic but, by doing so, we are
    agreeing that we will implement each of the functions defined in the interface.
    Because a class that implements an interface extends from that base class, we
    would say that it has an IS-A relationship with that type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可能只包含静态最终变量，并且可能只包含抽象方法，这意味着它们不能在类中实现。然而，我们可以有从其他接口继承的接口。在创建这些类时，我们可以实现我们想要的任意数量的接口。这使得我们能够使类变得更加多态，但通过这样做，我们同意我们将实现接口中定义的每个函数。因为实现接口的类扩展了基类，所以我们可以说它具有与该类型的IS-A关系。
- en: Now, interfaces have one disadvantage, and that's the fact that they tend to
    require a lot of coding to implement each of the different versions as needed,
    but we will talk about ways to adjust and/or fix this issue over the course of
    this book.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，接口有一个缺点，那就是它们往往需要编写大量的代码来实现每个不同版本的需求，但在这本书的过程中，我们将讨论调整和/或解决这个问题的方法。
- en: In C++, there isn't an official concept of interfaces, but you can simulate
    the behavior of interfaces by creating an abstract class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，没有官方的接口概念，但你可以通过创建一个抽象类来模拟接口的行为。
- en: 'Here''s a simple example of an interface, and an implementation of it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个接口的简单示例及其实现：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And here''s how it looks in UML:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它在UML中的样子：
- en: '![](img/00009.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: The advantages of compartmentalizing code
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码模块化的优点
- en: 'One important difference between procedural programming (think C-style) and
    object-oriented programming is the ability to encapsulate or compartmentalize
    code. Oftentimes we think of this as just data hiding: making variables private.
    In a C-style program, the functions and data are separate, but it is hard to reuse
    any one function because it might depend on other functions or other pieces of
    data in the program. In object-oriented programming, we are allowed to group the
    data and function together into reusable pieces. That means we can (hopefully)
    take a class or module and place it in a new project. This also means that since
    the data is private, a variable can be easily changed as long as the interface
    or public methods don''t change. These concepts of encapsulation are important,
    but they aren''t showing us all of the power that this provides us.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 过程式编程（例如C风格）和面向对象编程之间的重要区别是封装或模块化代码的能力。我们通常认为这只是数据隐藏：使变量私有。在C风格程序中，函数和数据是分开的，但很难重用任何一个函数，因为它可能依赖于程序中的其他函数或其他数据。在面向对象编程中，我们允许将数据和函数组合成可重用的组件。这意味着我们可以（希望）将一个类或模块放入一个新的项目中。这也意味着，由于数据是私有的，只要接口或公共方法不改变，变量就可以很容易地更改。封装的概念很重要，但它们并没有向我们展示这个提供给我们全部的力量。
- en: The goal of writing object-oriented code is to create objects that are responsible
    for themselves. Using a lot of if/else or switch statements within your code can
    be a symptom of bad design. For example, if I have three classes that need to
    read data from a text file, I have the choice of using a switch statement to read
    the data differently for each class type, or passing the text file to a class
    method and letting the class read the data itself. This is even more powerful
    when combined with the power of inheritance and polymorphism.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 编写面向对象代码的目的是创建能够自我负责的对象。在代码中使用大量的if/else或switch语句可能是设计不良的迹象。例如，如果我有三个类需要从文本文件中读取数据，我可以选择使用switch语句为每个类类型读取数据，或者将文本文件传递给一个类方法，让类自己读取数据。当与继承和多态的力量结合时，这甚至更强大。
- en: By making the classes responsible for themselves, the classes can change without
    breaking other code, and the other code can change without breaking the classes.
    We can all imagine how fragile the code would be if a game was written entirely
    in the main function. Anything that is added or removed is likely to break other
    code. Anytime a new member joined the team, they would need to understand absolutely
    every line and every variable in the game before they could be trusted to write
    anything.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让类负责自身，类可以改变而不会破坏其他代码，其他代码也可以改变而不会破坏类。我们可以想象，如果整个游戏都是用主函数编写的，代码将会多么脆弱。任何添加或删除的内容都可能破坏其他代码。每当有新成员加入团队时，他们需要完全理解游戏中的每一行代码和每一个变量，才能被信任编写任何内容。
- en: By separating code into functions or classes, we are making the code easier
    to read, test, debug, and maintain. Anyone joining the team would of course need
    to understand some pieces of the code, but it might not be necessary to understand
    all of graphics if they are working on game logic or file loading.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将代码分成函数或类，我们使代码更容易阅读、测试、调试和维护。当然，任何加入团队的人都需要理解一些代码，但如果他们正在处理游戏逻辑或文件加载，可能不需要理解所有的图形代码。
- en: Design patterns are solutions to common programming problems flexible enough
    to handle change. They do this by compartmentalizing sections of code. This isn't
    by accident. For the purposes of this book, the definition of good design is encapsulated,
    flexible, reusable code. So it should come as no surprise that these solutions
    are organized into classes or groups of classes that encapsulate the changing
    sections of your code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是针对常见编程问题的解决方案，足够灵活以应对变化。它们通过将代码部分隔离开来做到这一点。这不是偶然的。为了本书的目的，好的设计的定义是封装、灵活、可重用的代码。因此，这些解决方案被组织成类或类的组合，以封装代码中变化的部分。这并不令人惊讶。
- en: The structure of the Mach5 engine
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mach5引擎的结构
- en: Throughout this book, we will be using design patterns to solve common game
    programming problems. The best way to do this is by example, and so we will be
    examining how these problems arise and implementing the solutions using the Mach5
    engine, a 2D game engine designed in C++ by *Matt Casanova*. By looking at the
    entire source code for a game, we will be able to see how many of the patterns
    work together to create powerful and easy-to-use systems.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用设计模式来解决常见的游戏编程问题。最好的方式是通过实例来演示，因此我们将研究这些问题的产生，并使用Mach5引擎（一个由*Matt
    Casanova*设计的C++ 2D游戏引擎）来实现解决方案。通过查看游戏的全源代码，我们将能够看到许多模式是如何协同工作以创建强大且易于使用的系统的。
- en: However, before we can dive into the patterns, we should spend a little time
    explaining the structure of the engine. You don't need to understand every line
    of source code, but it is important to understand some of the core engine components
    and how they are used. This way we can better understand the problems we will
    be facing and how the solution fits together.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入探讨模式之前，我们应该花一点时间解释一下引擎的结构。你不需要理解每一行源代码，但理解一些核心引擎组件及其使用方式是很重要的。这样我们才能更好地理解我们将面临的问题以及解决方案是如何相互配合的。
- en: '![](img/00010.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00010.jpeg)'
- en: While looking at the diagram, it may seem a little confusing at first, so let's
    examine each piece of the engine separately.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看图表时，一开始可能会有些混乱，所以让我们分别检查引擎的每一部分。
- en: Mach5 core engines and systems
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mach5核心引擎和系统
- en: The meaning of engine is getting a little blurred these days. Often when people
    talk of engines they think of entire game creation tools such as Unreal or Unity.
    While these are engines, the term didn't always require a tool. Game engines such
    as Id Software's Quake Engine or Valve Corporation's Source engine existed independently
    of tools, although the latter did have tools including the Hammer Editor for creating
    levels.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天来，引擎的含义变得有些模糊。当人们谈论引擎时，他们通常指的是像 Unreal 或 Unity 这样的完整游戏创建工具。虽然这些也是引擎，但这个术语并不总是需要工具。像
    Id Software 的 Quake 引擎或 Valve Corporation 的 Source 引擎这样的游戏引擎是独立于工具存在的，尽管后者确实包括用于创建关卡的工具
    Hammer Editor。
- en: The term engine is also used to refer to components within the larger code base.
    This includes things like a rendering engine, audio engine, or physics engine.
    Even these can be created completely separate from a larger code base. Orge 3D
    is an open source 3D graphics engine, while the Havok Physics engine is proprietary
    software created by the Havok company and used in many games.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎这个术语也被用来指代更大代码库中的组件。这包括渲染引擎、音频引擎或物理引擎等。这些甚至可以完全独立于更大的代码库创建。Orge 3D 是一个开源的
    3D 图形引擎，而 Havok Physics 引擎是由 Havok 公司创建的专有软件，被许多游戏使用。
- en: So, when we talk about the engines or systems of the Mach5 engine, we are simply
    referring to groups of related code for performing a specific task.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们谈论 Mach5 引擎的引擎或系统时，我们实际上是在指执行特定任务的代码集合。
- en: The app
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序
- en: The `M5App` or application layer is a class responsible for interfacing with
    the operating system. Since we are trying to write clean, reusable code, it is
    important that we don't mix our game code with any operating system function calls.
    If we did this, our game would be difficult to port to another system. The `M5App`
    class is created in WinMain and responsible for creating and destroying every
    other system. Anytime our game needs to interact with the OS, including changing
    resolution, switching to full screen, or getting input from a device, we will
    use the `M5App` class. In our case, the operating system that we will be using
    will be Windows.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`M5App` 或应用程序层是一个负责与操作系统交互的类。由于我们试图编写干净、可重用的代码，因此我们不应该将游戏代码与任何操作系统功能调用混合。如果我们这样做，我们的游戏将难以移植到另一个系统。`M5App`
    类在 WinMain 中创建，负责创建和销毁其他每个系统。任何时候我们的游戏需要与操作系统交互，包括更改分辨率、切换到全屏或从设备获取输入时，我们都会使用
    `M5App` 类。在我们的情况下，我们将使用的操作系统将是 Windows。'
- en: The StageManager
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阶段管理器
- en: The `M5StageManager` class is responsible for controlling the logic of each
    stage. We consider things such as the main menu, credits screen, options menu,
    loading screen, and playable levels to be stages. They contain behaviors that
    control the flow of the game. Examples of stage behavior include reading game
    object data from files, spawning units after specific time intervals, or switching
    between menus and levels.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`M5StageManager` 类负责控制每个阶段的逻辑。我们考虑的主要菜单、信用屏幕、选项菜单、加载屏幕和可玩关卡都被视为阶段。它们包含控制游戏流程的行为。阶段行为的例子包括从文件中读取游戏对象数据、在特定时间间隔后生成单位，或者在菜单和关卡之间切换。'
- en: '`StageManager` is certainly not a standardized name. In other engines, this
    section of code may be called the game logic engine; however, most of our game
    logic will be separated into components so this name doesn''t fit. No matter what
    it is called, this class will control which objects need to be created for the
    current stage, as well as when to switch to the next stage or quit the game altogether.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageManager` 确实不是一个标准化的名称。在其他引擎中，这段代码可能被称为游戏逻辑引擎；然而，我们的大部分游戏逻辑将被分离成组件，所以这个名字不太合适。无论叫什么名字，这个类都将控制需要为当前阶段创建哪些对象，以及何时切换到下一个阶段或完全退出游戏。'
- en: Even though this uses the name *manager* instead of *engine*, it serves as one
    of the core systems of the game. This class controls the main game loop and manages
    the collection of user stages. In order to make a game, users must derive at least
    one class from the base `M5Stage` class and overload the virtual functions to
    implement their game logic.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个名字使用的是 *manager* 而不是 *engine*，但它仍然是游戏的核心系统之一。这个类控制着主游戏循环并管理用户关卡集合。为了制作游戏，用户必须从基类
    `M5Stage` 派生至少一个类，并重载虚拟函数以实现他们的游戏逻辑。
- en: The ObjectManager
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象管理器
- en: The `M5ObjectManager` is responsible for creating, destroying, updating, and
    searching for game objects. A game object is anything visible or invisible in
    the game. This could include the player, bullets, enemies, and triggers--the invisible
    regions in a game that cause events when collided with. The derived `M5Stage`
    classes will use the `M5ObjectManager` to create the appropriate objects for the
    stage. They can also search for specific game objects to update game logic. For
    example, a stage may search for a player object. If one doesn't exist, the manager
    will switch to the game over stage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`M5ObjectManager`负责创建、销毁、更新和搜索游戏对象。游戏对象是游戏中可见或不可见的任何东西。这可能包括玩家、子弹、敌人和触发器——在游戏中，当与之碰撞时会导致事件的不可见区域。派生的`M5Stage`类将使用`M5ObjectManager`来创建适合该阶段的对象。它们还可以搜索特定的游戏对象以更新游戏逻辑。例如，一个阶段可能会搜索玩家对象。如果没有找到，则管理器将切换到游戏结束阶段。'
- en: As seen in the previous diagram, our game will use components. This means the
    `M5ObjectManager` will be responsible for creating those as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们的游戏将使用组件。这意味着`M5ObjectManager`也将负责创建这些组件。
- en: The graphics engine
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形引擎
- en: This book isn't about creating a graphics engine but we do need one to draw
    to the screen. Similar to how the `M5App` class encapsulates important OS function
    calls, our `M5Gfx` class encapsulates our graphics API. We want to make sure there
    is a clear separation between any API calls and our game logic. This is important
    so we can port our game to another system. For example, we may want to develop
    our game for PC, XBox One, and PlayStation 4\. This will mean supporting multiple
    graphics APIs since a single API isn't available for all platforms. If our game
    logic contains API code, then those files will need to be modified for every platform.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不是关于创建图形引擎的，但我们确实需要一个来绘制到屏幕上。类似于`M5App`类封装了重要的操作系统功能调用，我们的`M5Gfx`类封装了我们的图形API。我们希望确保任何API调用和我们的游戏逻辑之间有一个清晰的分离。这对于我们可以将我们的游戏移植到另一个系统非常重要。例如，我们可能希望为PC、XBox
    One和PlayStation 4开发我们的游戏。这意味着我们需要支持多个图形API，因为并非所有平台都提供单个API。如果我们的游戏逻辑包含API代码，那么这些文件将需要为每个平台进行修改。
- en: We won't be going deep into the details of how to implement a full graphics
    engine, but we give an overview of how graphics works. Think of this as a primer
    to the world of graphics engines.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨如何实现完整的图形引擎的细节，但我们将概述图形的工作原理。将此视为图形引擎世界的入门指南。
- en: This class allows us manipulate and draw textures, as well as control the game
    camera and find the visible extents of the world. `M5Gfx` also manages two arrays
    of graphics components, one for world space and one for screen space. The most
    common use of the screen space components is for creating **User Interface** (**UI**)
    elements such as buttons.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此类允许我们操作和绘制纹理，以及控制游戏摄像机和找到世界的可见范围。`M5Gfx` 还管理两个图形组件数组，一个用于世界空间，一个用于屏幕空间。屏幕空间组件最常用的用途是创建**用户界面**（**UI**）元素，如按钮。
- en: Tools and utilities
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具和实用程序
- en: 'Besides the core engines and systems for a game, every engine should provide
    some basics tools and support code. The Mach5 engine includes a few categories
    for tools:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了游戏的核心引擎和系统之外，每个引擎都应该提供一些基本工具和支持代码。Mach5引擎包括几个工具类别：
- en: '**Debug Tools**: This includes debug asserts, message windows, and creating
    a debug console'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试工具**：这包括调试断言、消息窗口以及创建调试控制台'
- en: '**Random**: Helper functions to create random `int` or `float` from min/max
    values'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机数生成器**：从最小/最大值创建随机`int`或`float`的辅助函数'
- en: '**Math**: This includes 2D vectors and 4 x 4 matrices, as well some more general
    math helper functions'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学**：这包括2D向量和4 x 4矩阵，以及一些更通用的数学辅助函数'
- en: '**FileIO**: Support for reading and writing `.ini` files'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件输入输出**：支持读取和写入`.ini`文件'
- en: The problems with using design patterns in games
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中使用设计模式的问题
- en: Unfortunately, there are also some issues that may come into play from using
    design patterns exactly as described. It's often said that the fastest executing
    code is the code that is never called, and using design patterns will typically
    require you to add more code to your project than what you would have done otherwise.
    This will have a performance cost as well, as there will likely need to be more
    calculations done whenever you're using a part of your engine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用设计模式的方式也可能带来一些问题。常言道，执行最快的代码是那些从未被调用的代码，而使用设计模式通常需要你在项目中添加比其他方式更多的代码。这将产生性能成本，因为每次使用引擎的某个部分时，可能需要进行更多的计算。
- en: For instance, using some principles will cause some classes that you write to
    become extremely bloated with extra code. Design patterns are another form of
    complexity to add to your project. If the problem itself is simple, it can be
    a much better idea to focus on the simpler solutions before going straight into
    implementing a design pattern just because you have heard of it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用某些原则可能会导致你编写的某些类变得极其臃肿，充满了额外的代码。设计模式是向项目中添加的另一种复杂性。如果问题本身很简单，那么在直接实现设计模式之前，先关注简单的解决方案会是一个更好的主意，仅仅因为你听说过它。
- en: Sometimes it's better to follow the simple rule of **K.I.S.S**. and remember
    that it is the knowledge of the pattern that holds the most important value, not
    using the pattern itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候遵循简单的**K.I.S.S**规则会更好。并记住，掌握模式的知识比使用模式本身更有价值。
- en: Setting up the project
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Now that we''ve gotten a good understanding of why we would want to use design
    patterns, let''s get set up the game engine that we will be using over the course
    of the book: the Mach5 engine. Now in order to get started, we will need to download
    the engine as well as the software needed to run the project. Perform the following
    steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了为什么我们要使用设计模式，让我们设置我们将在这本书中使用的游戏引擎：Mach5引擎。为了开始，我们需要下载引擎以及运行项目所需的软件。执行以下步骤：
- en: 'Open up your web browser of choice and visit the following website: [https://beta.visualstudio.com/downloads/](https://beta.visualstudio.com/downloads/).
    Once there, move to the Visual Studio Community version on the left and then click
    on the Free download option, as shown in the following screenshot:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的网页浏览器并访问以下网站：[https://beta.visualstudio.com/downloads/](https://beta.visualstudio.com/downloads/)。一旦到达那里，将鼠标移到左侧的Visual
    Studio Community版本，然后点击免费下载选项，如图所示：
- en: '![](img/00011.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00011.jpeg)'
- en: 'If you get a window asking what to do with the file, go ahead and open it or
    save and then open it by clicking on the Run button:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现一个窗口询问如何处理文件，请继续打开它或保存并点击运行按钮打开它：
- en: '![](img/00012.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.jpeg)'
- en: 'From there, wait until the installer pops up, then select Custom, and then
    click on Next to start downloading the program:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，等待安装程序弹出，然后选择自定义，然后点击下一步开始下载程序：
- en: '![](img/00013.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00013.jpeg)'
- en: 'Now once you get to the Features section, uncheck whatever is selected and
    then open up the Programming Languages tab and check Visual C++. You may go ahead
    and remove the other options, as we will not be using them. Then go ahead and
    click on the Next button, then Install, and allow it to make changes to your computer:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你一旦到达功能部分，取消选择所有已选选项，然后打开编程语言选项卡并勾选Visual C++。你可以继续移除其他选项，因为我们不会使用它们。然后点击下一步按钮，然后安装，并允许它更改您的计算机：
- en: '![](img/00014.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00014.jpeg)'
- en: You may need to wait a while at this point, so go ahead and get yourself a coffee,
    and once it's finished you'll need to restart your computer. After that, go ahead
    and continue with the project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能需要等待一段时间，所以请去喝杯咖啡，一旦完成，你需要重新启动计算机。之后，请继续进行项目。
- en: 'Once you''ve finished installing, you next need to actually install the engine
    itself. With that in mind, go over to [https://github.com/mattCasanova/Mach5](https://beta.visualstudio.com/downloads/)
    and from there, click on the Clone or download section and then click on Download
    ZIP:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，接下来你需要实际安装引擎本身。考虑到这一点，转到[https://github.com/mattCasanova/Mach5](https://beta.visualstudio.com/downloads/)，并从那里点击克隆或下载部分，然后点击下载ZIP：
- en: '![](img/00015.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00015.jpeg)'
- en: Once you're finished with the download, go ahead and unzip the file to a folder
    of your choice; then open up the `Mach5-master\EngineTest` folder, double-click
    on the `EngineTest.sln` file, and start up Visual Studio.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，请将文件解压缩到您选择的文件夹中；然后打开`Mach5-master\EngineTest`文件夹，双击`EngineTest.sln`文件，并启动Visual
    Studio。
- en: You may get a login screen asking you to log in; go ahead and sign up or press
    the Not now, maybe later option on the bottom of the screen. You can then pick
    a color theme; then click Start Visual Studio.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会看到一个登录界面要求你登录；请继续并注册或点击屏幕底部的“现在不，稍后再说”选项。然后你可以选择一个颜色主题；然后点击开始Visual Studio。
- en: 'Upon starting, you may get a security warning asking if you''d still like to
    open this project. This is displayed from any Visual Studio solution that wasn''t
    made on your machine, so it wants to make sure that you know where it came from,
    but in this case the project is perfectly safe. Go ahead and uncheck the Ask me
    for every project in this solution option and then select OK:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动时，你可能会收到一个安全警告，询问你是否仍然想要打开此项目。这会从任何不在你机器上创建的 Visual Studio 解决方案中显示出来，所以它想要确保你知道它从哪里来，但在这个情况下，项目是完全安全的。请继续取消选中“在此解决方案中的每个项目都询问我”选项，然后选择“确定”：
- en: '![](img/00016.gif)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.gif)'
- en: 'Once it''s finished loading, you should finally see the Visual Studio interface,
    which should look like this:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦加载完成，你应该最终看到 Visual Studio 界面，它应该看起来像这样：
- en: '![](img/00017.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: Visual Studio is a very powerful tool and, for developers, it can be quite useful
    to learn all of the functionality that it has. We'll be discussing the features
    as we use them, but this book shouldn't be considered the end-all book on Visual
    Studio.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 是一个非常强大的工具，对于开发者来说，学习它所有的功能非常有用。我们将在使用它们时讨论这些功能，但本书不应被视为关于 Visual
    Studio 的终极指南。
- en: 'If you''re interested in learning more about the Visual Studio interface, check
    out: [https://msdn.microsoft.com/en-us/library/jj620919.aspxa](https://msdn.microsoft.com/en-us/library/jj620919.aspxa).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于 Visual Studio 界面的信息，请查看：[https://msdn.microsoft.com/en-us/library/jj620919.aspxa](https://msdn.microsoft.com/en-us/library/jj620919.aspxa)。
- en: 'The engine is built to work on 32-bit processors, so change the x64 dropdown
    to x86 and then click the Play button or press *F5*. It will then ask if you wish
    to rebuild the project. Go ahead and say Yes. If all goes well, you should eventually
    see a debug window and a gameplay window as well. After a few seconds, it should
    transition to a simple default project:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引擎是为 32 位处理器构建的，所以将 x64 下拉菜单更改为 x86，然后点击播放按钮或按 *F5*。然后它会询问你是否希望重新构建项目。请继续说“是”。如果一切顺利，你应该最终看到一个调试窗口和一个游戏窗口。几秒钟后，它应该过渡到一个简单的默认项目：
- en: '![](img/00018.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: You can play around by using the *W*, *A*, and *D* keys to move the character
    around and the *Spacebar* to shoot bullets at enemies. Once you're finished playing
    around, go ahead and hit the *Esc* key to go to the menu, and then click on the
    Quit button to leave the project and go back to the editor!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 *W*、*A* 和 *D* 键来移动角色，使用 *Spacebar* 向敌人射击子弹。一旦你玩够了，就按 *Esc* 键进入菜单，然后点击退出按钮离开项目并返回到编辑器！
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: And there we have it! In this first chapter, you've learned some fundamentals
    about design patterns and also got the Mach5 engine running on your computer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！在本章中，你了解了一些关于设计模式的基本知识，并且已经在你的电脑上运行了 Mach5 引擎。
- en: Specifically, we learned that design patterns are solutions for common programming
    problems. There are a lot of reasons why we should use them, but in order to use
    patterns effectively, you first need to know what problem you are trying to solve
    and which ones can help you in that instance, which is what this book intends
    to teach you.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们了解到设计模式是针对常见编程问题的解决方案。有很多理由我们应该使用它们，但为了有效地使用模式，你首先需要知道你正在尝试解决什么问题，以及哪些模式可以在那种情况下帮助你，这正是本书旨在教给你的内容。
- en: We learned how game development is always changing and how important it is to
    have a plan, as well as an architecture that can support those changes. With that
    in mind, we learned about various aspects of coding that will be used in the creation
    of our architecture.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到游戏开发总是不断变化，以及有一个计划以及一个能够支持这些变化的架构是多么重要。考虑到这一点，我们学习了在创建我们的架构时将要用到的各种编码方面。
- en: We dived into learning about the separation of concerns principle and how important
    it is for us to separate the what and how; making it so they do not depend on
    each other allows us to alter or extend any part of our project with minimal hassle.
    Afterwards, we explored what interfaces were and how they are useful in giving
    us a foundation we can build on. Later, we dived into the Mach5 engine, saw an
    example of how compartmentalized code worked, and the advantages of it. We also
    saw how using design patterns in games can be a great thing, as well as the problems
    that they have.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入学习了关注点分离原则及其重要性，了解如何将“是什么”和“怎么做”分开；使它们不相互依赖，这样我们就可以以最小的麻烦更改或扩展项目的任何部分。之后，我们探讨了接口是什么以及它们如何有助于为我们提供一个可以在此基础上构建的基础。后来，我们深入研究了
    Mach5 引擎，看到了一个关于模块化代码如何工作的例子，以及它的优势。我们还看到了在游戏中使用设计模式可以是一件好事，以及它们所存在的问题。
- en: Finally, we downloaded the Mach5 engine ourselves and made sure that it worked
    correctly. Moving on, in the next chapter, we will tackle our first design pattern,
    the Singleton, and see how it can be useful to us!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们亲自下载了 Mach5 引擎并确保它能够正确工作。接下来，在下一章中，我们将处理我们的第一个设计模式——单例模式，并看看它如何对我们有用！
