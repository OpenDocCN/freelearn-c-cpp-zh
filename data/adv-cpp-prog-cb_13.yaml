- en: Bonus - Using C++20 Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奖励-使用C++20功能
- en: In this chapter, you will take a quick look at some of the upcoming features
    being added to C++20\. This chapter is important because, unlike C++14 and C++17,
    C++20 adds several game-changing features to the language that will alter C++
    forever.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将快速了解一些即将添加到C++20中的功能。本章很重要，因为与C++14和C++17不同，C++20为语言添加了几个改变游戏规则的功能。
- en: It begins with an introduction to C++20 Concepts, a new mechanism for defining
    the requirements of any arbitrary type. C++20 Concepts promises to change how
    we program using templates and `auto`, providing a mechanism for defining what
    is required of a type. We will then move to C++20 Modules, a new feature that
    removes the need for `#include`, changing how we define interfaces in C++. C++
    Modules is a huge change to the language, requiring a complete overhaul of the
    entire Standard Library as well as our build tools. Next, we will take a quick
    look at `std::span` and C++ Ranges. Finally, we will briefly cover another game-changing
    addition to C++20 called Coroutines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它始于对C++20概念的介绍，这是一种定义任意类型要求的新机制。C++20概念承诺改变我们使用模板和`auto`编程的方式，提供了一种定义类型要求的机制。然后我们将转向C++20模块，这是一个新功能，消除了`#include`的需要，改变了我们在C++中定义接口的方式。C++模块是语言的巨大变化，需要完全改变整个标准库以及我们的构建工具。接下来，我们将快速查看`std::span`和C++范围。最后，我们将简要介绍C++20的另一个改变游戏规则的功能，称为协程。
- en: 'The recipes in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例如下：
- en: Looking at Concepts in C++20
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看C++20中的概念
- en: Working with Modules in C++20
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++20中的模块
- en: Introducing `std::span`, a new view on arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`std::span`，数组的新视图
- en: Working with Ranges in C++20
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++20中使用范围
- en: Learning how to use Coroutines in C++20
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在C++20中使用协程
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 19.04 with a functional internet connection.
    Note that the rest of this book uses Ubuntu 18.04\. Since we will be discussing
    C++20, which is still in development, we need the latest and greatest versions
    of GCC in this specific chapter. Before running these examples, you must install
    the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有管理访问权限，可以访问具有功能性互联网连接的运行Ubuntu 19.04的计算机。请注意，本书的其余部分使用的是Ubuntu
    18.04。由于我们将讨论仍在开发中的C++20，因此在本章中需要最新和最好的GCC版本。在运行这些示例之前，您必须安装以下内容：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是安装在Ubuntu 18.04之外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Code files for this chapter can be found at [//github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter13](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter13https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter13).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[//github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter13](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter13https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter13)找到。
- en: Looking at Concepts in C++20
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看C++20中的概念
- en: In this recipe, we will discuss an upcoming addition to C++ that promises to
    completely change the way we think about template programming called C++20 Concepts.
    C++ today largely depends on the use of SFINAE to constrain the types that apply
    to any given template function. As seen in [Chapter 4](aff3ffea-2bdd-4d69-9e32-0edae7142703.xhtml), *Using
    Templates for Generic Programming*, SFINAE is hard to write, confusing to read,
    and slow to compile. This recipe is important as template programming post-C++20
    will not only be easier to code and debug, but will also reduce the human costs
    of template programming, making it easier to read and understand.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将讨论C++20的即将添加的一个功能，它承诺彻底改变我们对模板编程的思考方式，称为C++20概念。如今，C++在很大程度上依赖于使用SFINAE来约束适用于任何给定模板函数的类型。正如在[第4章](aff3ffea-2bdd-4d69-9e32-0edae7142703.xhtml)中所见，*使用模板进行通用编程*，SFINAE很难编写，阅读起来令人困惑，编译速度慢。本教程很重要，因为C++20后的模板编程不仅更容易编码和调试，而且还将减少模板编程的人力成本，使其更易于阅读和理解。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 19.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本教程中示例所需的适当工具。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You will need to perform the following steps to try the recipe:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试本教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码被编译，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To best explain how C++20 Concepts will aid in template programming, we will
    start with a simple example of programming an interface in C++ today. Interfaces
    define a contract between the implementation of an **Application Programming Interface**
    (**API**) and the user of the API and are heavily used in object-oriented programming
    to abstract away the interface of an API from its implementation details.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地解释C++20概念如何帮助模板编程，我们将从今天在C++中编程接口的一个简单示例开始。接口在对象导向编程中被广泛使用，用于将API的接口与其实现细节分离开来。
- en: 'Let''s start with the following pure virtual interface:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下纯虚接口开始：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding pure virtual interface in C++ defines a `foo()` function. Clients
    of this API do not need to know how `foo()` is implemented. All they care about
    is the definition of the interface and the function signature of `foo()` to understand
    how `foo()` should behave. Using this interface, we can define an implementation
    of this interface, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的前述纯虚接口定义了一个`foo()`函数。这个API的客户端不需要知道`foo()`是如何实现的。他们关心的只是接口的定义和`foo()`的函数签名，以了解`foo()`应该如何行为。使用这个接口，我们可以定义一个接口的实现，如下所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As shown in the preceding example, we created a class called `A` that inherits
    the interface and override the `foo()` function to give it an implementation.
    We can do the same thing with another implementation, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们创建了一个名为`A`的类，它继承了接口并重写了`foo()`函数以给它一个实现。我们可以用另一个实现做同样的事情，如下所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As shown in the preceding example, the `B` class provides the interface with
    an alternative implementation of the interface. Clients of this interface can
    use the interface as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`B`类提供了接口的另一种实现。这个接口的客户端可以像下面这样使用接口：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The client doesn''t actually need to know anything about `A` or `B`. It simply
    includes the definition of the interface and uses the interface to access any
    specific implementation. We can use this client as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端实际上不需要知道关于`A`或`B`的任何东西。它只包括接口的定义，并使用接口来访问任何特定的实现。我们可以像下面这样使用这个客户端：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As shown in the preceding example, we first create instances of both `A` and
    `B`, and we then create two different clients that are given implementations of
    the interface for both `A` and `B`. Finally, we execute the `bar()` functions
    for each client, resulting in the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们首先创建了`A`和`B`的实例，然后创建了两个不同的客户端，它们分别给了`A`和`B`的接口实现。最后，我们执行了每个客户端的`bar()`函数，得到了以下输出：
- en: '![](img/de930bf3-bf6d-44a0-8b41-446a2d7e0f6d.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de930bf3-bf6d-44a0-8b41-446a2d7e0f6d.png)'
- en: 'As shown in the preceding screenshot, the client is unaware that the interface
    was defined in two different ways as the client only concerns itself with the
    interface. This technique is demonstrated in a lot of C++ literature, specifically
    to implement what is known as the S.O.L.I.D object-oriented design principles.
    The S.O.L.I.D design principles stand for the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，客户端并不知道接口是以两种不同的方式定义的，因为客户端只关心接口。这种技术在很多C++文献中都有展示，特别是为了实现所谓的S.O.L.I.D面向对象设计原则。S.O.L.I.D设计原则代表以下内容：
- en: '**Single responsibility principle**: This ensures that if an object must change,
    it only changes for one reason (that is, an object doesn''t provide more than
    one responsibility).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**：这确保了如果一个对象必须改变，它只会因为一个原因而改变（也就是说，一个对象不会提供多于一个的职责）。'
- en: '**Open–closed principle**: This ensures that an object can be extended without
    being modified.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**：这确保了一个对象可以被扩展而不被修改。'
- en: '**Liskov substitution principle**: This ensures that, when inheritance is used,
    subclasses implement the behavior of functions they override and not just the
    function''s signature.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**：这确保了在使用继承时，子类实现了它们重写的函数的行为，而不仅仅是函数的签名。'
- en: '**Interface segregation principle**: This ensures that an object has the smallest
    possible interface so that clients of the object are not forced to depend on APIs
    they do not use.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**：这确保了一个对象具有尽可能小的接口，这样对象的客户端就不会被迫依赖他们不使用的API。'
- en: '**Dependency inversion principle**: This ensures that objects are only dependent
    on interfaces and not on implementations.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖反转原则**：这确保了对象只依赖于接口而不依赖于实现。'
- en: The combination of these principles is designed to ensure that your use of object-oriented
    programming in C++ is easier to understand and maintain over time. One issue,
    however, with the existing literature for S.O.L.I.D and C++ is that it advocates
    for the heavy use of pure virtual interfaces, which come at a cost. Each class
    must be given an extra virtual table (that is, vTable), and all function calls
    encounter the extra overhead of virtual function overloading.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则的结合旨在确保您在C++中使用面向对象编程更容易理解和维护。然而，现有的S.O.L.I.D和C++文献存在一个问题，即它倡导大量使用纯虚接口，这是有代价的。每个类必须给出一个额外的虚表（即vTable），并且所有函数调用都会遇到虚函数重载的额外开销。
- en: 'One way to solve this is to use static interfaces (something that is not often
    talked about in existing literature). To best explain how this works, let''s start
    with the definition of our interface, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是使用静态接口（这在现有文献中很少谈到）。为了最好地解释这是如何工作的，让我们从我们接口的定义开始，如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As shown in the preceding example, we will leverage static polymorphism to
    implement our interface. The preceding class takes a type called `DERIVED` and
    casts an instance of the interface to the `DERIVED` class, calling a version of
    the `foo` function that has been overridden. The implementation of `A` now looks
    like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们将利用静态多态性来实现我们的接口。前述类采用了一个名为`DERIVED`的类型，并将接口的实例转换为`DERIVED`类，调用一个已被重写的`foo`函数的版本。现在`A`的实现看起来是这样的：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As shown in the preceding example, instead of inheriting the interface, `A`
    now inherits an interface of `A`. When the `foo()` function from the interface
    is called, the interface redirects the call to the `foo_override()` function for
    `A`. We can implement `B` using the same approach:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`A`现在不再继承接口，而是继承`A`的接口。当调用接口的`foo()`函数时，接口将调用`A`的`foo_override()`函数。我们可以使用相同的方法实现`B`：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown in the preceding example, `B` is capable of providing its own implementation
    of the interface. It should be noted that so far in this design pattern, we have
    yet to use `virtual`, meaning we have created an interface and implementations
    of that interface without the need for virtual inheritance, so there is no overhead
    associated with this design. In fact, the compiler is capable of removing the
    redirection of the call from `foo()` to `foo_override()`, ensuring that the use
    of abstraction doesn't provide any additional runtime costs compared to the use
    of pure virtual interfaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`B`能够提供自己的接口实现。需要注意的是，到目前为止，在这种设计模式中，我们还没有使用`virtual`，这意味着我们已经创建了一个接口及其实现，而不需要虚拟继承，因此这种设计没有额外的开销。事实上，编译器能够消除从`foo()`到`foo_override()`的调用重定向，确保抽象的使用不会比使用纯虚拟接口带来任何额外的运行时成本。
- en: 'Clients of `A` and `B` can be implemented as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`和`B`的客户端可以这样实现：'
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As shown in the preceding code snippet, the only difference between the client
    in this example and the one in the previous example is the fact that this client
    is a template class. Static polymorphism requires that the type of information
    about an interface is known at compile time. This tends to be fine in most designs
    as the use of pure virtual interfaces earlier was not because we wanted the ability
    to perform runtime polymorphism and type erasure, but instead to ensure that clients
    only adhere to interfaces and not implementations. In both cases, the implementation
    of each client is static and known at compile time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，这个示例中的客户端与前一个示例中的客户端唯一的区别在于这个客户端是一个模板类。静态多态性要求在编译时知道接口的类型信息。在大多数设计中，这通常是可以接受的，因为早期使用纯虚拟接口并不是因为我们想要执行运行时多态和类型擦除的能力，而是为了确保客户端只遵循接口而不是实现。在这两种情况下，每个客户端的实现都是静态的，并且在编译时已知。
- en: 'To use the client, we can use some C++17 class type deduction to ensure that
    our `main()` function remains unchanged, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用客户端，我们可以使用一些C++17的类类型推导来确保我们的`main()`函数保持不变，如下所示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Executing the preceding example results in the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述示例会得到以下结果：
- en: '![](img/417c5648-2521-4327-9b35-d507866b6af7.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/417c5648-2521-4327-9b35-d507866b6af7.png)'
- en: As shown in the preceding screenshot, the code executes the same. The only difference
    between the two approaches is the fact that one uses pure virtual inheritance,
    which comes with a runtime cost, while the second approach uses static polymorphism,
    which comes with a human cost. Specifically, the preceding example for most beginners
    is difficult to understand. In large projects with nested dependencies, the use
    of static polymorphism can be extremely difficult to understand and read.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，代码执行相同。两种方法之间唯一的区别在于一种使用纯虚拟继承，这会带来运行时成本，而第二种方法使用静态多态性，这会带来人为成本。特别是对于大多数初学者来说，前面的例子很难理解。在具有嵌套依赖关系的大型项目中，使用静态多态性可能非常难以理解和阅读。
- en: 'Another issue with the preceding example is the fact that the compiler does
    not have enough information about the interface and clients of that interface
    to provide a reasonable error message when the wrong type is given. Check out
    this example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的另一个问题是编译器对接口及其客户端的信息不足，无法在给出错误类型时提供合理的错误消息。看看这个例子：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This results in the following compiler error:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下编译器错误：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding error message is hardly useful, especially for a beginner. To
    overcome these issues, C++20 Concepts promises to provide a cleaner implementation
    of template programming moving forward. To best explain this, let''s look at how
    we would implement the interface using C++20 Concepts:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述错误消息几乎没有用，特别是对于初学者来说。为了克服这些问题，C++20 Concepts承诺提供一个更清晰的模板编程实现。为了更好地解释这一点，让我们看看如何使用C++20
    Concepts来实现接口：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As shown in the preceding example, we have defined a C++20 Concept called `interface`.
    Given a type `T`, this concept requires that `T` provides a function called `foo()`
    that takes no input and returns no output. We can then define `A` as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们定义了一个名为`interface`的C++20概念。给定一个类型`T`，这个概念要求`T`提供一个名为`foo()`的函数，不接受任何输入并且不返回任何输出。然后我们可以这样定义`A`：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As shown in the preceding code snippet, `A` no longer needs to leverage inheritance
    at all. It simply provides a `foo()` function given a normal C++ class definition.
    `B` is implemented the same way:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，`A`不再需要使用继承。它只需提供一个给定普通C++类定义的`foo()`函数。`B`的实现方式也是一样的：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once again, inheritance is no longer needed. Clients of this interface are
    implemented as in the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不再需要继承。这个接口的客户端实现如下：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As shown in the preceding example, we have defined a class that takes a template
    type `T` and calls its `foo()` function. In our static polymorphic example earlier,
    we could have implemented the client the exact same way. The problem with that
    approach is that the client would have no way of determining whether the type
    `T` adhered to the interface. Static asserts combined with SFINAE, such as `std::is_base_of()`,
    could be leveraged to solve this issue, but every object that depends on the interface
    would have to include this logic. With C++20 concepts, however, this simplicity
    can be achieved without the need for inheritance or any complicated template tricks
    such as SFINAE. So, let''s see what we can use instead of the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们定义了一个接受模板类型`T`并调用其`foo()`函数的类。在我们之前的静态多态示例中，我们可以以完全相同的方式实现客户端。但这种方法的问题在于客户端无法确定类型`T`是否遵守接口。结合SFINAE的静态断言，比如`std::is_base_of()`，可以解决这个问题，但依赖接口的每个对象都必须包含这个逻辑。然而，使用C++20概念，可以在不需要继承或任何复杂的模板技巧（如SFINAE）的情况下实现这种简单性。因此，让我们看看我们可以使用以下内容代替：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following can be used instead:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下内容代替：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The problem with C++ today with template programming is the fact that the `typename` keyword tells
    the compiler nothing about the type itself. SFINAE provides a means to solve this
    by defining certain characteristics about a type at a huge human cost as SFINAE
    is even more complicated to understand, and the resulting compiler errors when
    things go wrong are anything but useful. C++20 Concepts addresses all of these
    issues by defining the properties of a type, called a Concept, and then uses that
    concept in place of `typename`, providing the compiler with all of the information
    it needs to determine whether a given type adheres to the concept. When something
    goes wrong, the compiler can provide a simple error message about what the provided
    type is missing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当今C++模板编程的问题在于`typename`关键字并不能告诉编译器有关类型本身的任何信息。SFINAE提供了一种解决方法，通过以巨大的人力成本定义有关类型的某些特征，因为SFINAE更加复杂难以理解，当出现问题时导致的编译器错误也毫无用处。C++20概念通过定义类型的属性（称为概念），然后在`typename`的位置使用该概念，解决了所有这些问题，为编译器提供了确定给定类型是否符合概念的所有信息。当出现问题时，编译器可以提供有关所提供类型缺少什么的简单错误消息。
- en: C++20 Concepts is an exciting new feature coming soon that promises to completely
    change how we program with C++ templates, reducing the overall human costs of
    working with templates at the expense of a more complicated compiler and C++ specification.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C++20概念是一个令人兴奋的新功能，即将推出，它承诺彻底改变我们使用C++模板的方式，减少了与模板工作相关的整体人力成本，但以更复杂的编译器和C++规范为代价。
- en: Working with Modules in C++20
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++20中使用模块
- en: In this recipe, we will learn more about a new feature coming with C++20 called
    Modules. This recipe is important as C++20 Modules removes the need for `#include`
    moving forward. C++ code today is usually divided between headers and source files.
    Every source file is compiled separately and must recompile the headers that it
    includes (and any headers the included headers include), resulting in slow compile
    times, dependency order issues, and the overuse of C-style macros. Instead, optionally,
    libraries will be included using C++20 Modules, changing the way we program even
    simple applications such as "Hello World".
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习有关C++20的一个新功能，称为模块。本示例很重要，因为C++20模块消除了向前移动`#include`的需要。当今的C++代码通常在头文件和源文件之间划分。每个源文件都是单独编译的，并且必须重新编译它包含的头文件（以及包含的头文件包含的任何头文件），导致编译时间缓慢、依赖顺序问题以及对C风格宏的过度使用。相反，可以使用C++20模块来选择性地包含库，改变我们编写甚至是简单应用程序（如“Hello
    World”）的方式。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 19.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You will need to perform the following steps to try this recipe:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试本示例：
- en: 'From a new Terminal, run the following command to download the source code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中，运行以下命令下载源代码：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To compile the source code, run the following command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe. It should be noted that examples 2 and 4 in the source cannot
    be compiled since, at the time of writing, C++ Modules is not yet supported by
    GCC.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。需要注意的是，源代码中的示例2和4在撰写本文时无法编译，因为截至目前，GCC尚不支持C++模块。
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'C++20 Modules provide a new way to include the definitions of APIs used in
    C++. Let''s look at the following example of how to write a simple `Hello World`
    application in C++:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C++20模块提供了一种新的方式来包含C++中使用的API的定义。让我们看看如何在C++中编写一个简单的“Hello World”应用程序的以下示例：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To write this same application using C++20 Modules, you would do the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用C++20模块编写相同的应用程序，可以执行以下操作：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Although the difference is subtle, under the hood, a lot has changed to make
    the preceding code possible. Let''s look at a more complicated example, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管差异微妙，但在幕后，为了使前面的代码成为可能，发生了很多变化。让我们看一个更复杂的示例，如下所示：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we have defined a header file that defines a class template
    called `the_answer`. To implement this template, we must include the `string`
    library. We have also added a macro to this header to test our class. We can use
    this header as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个头文件，定义了一个名为`the_answer`的类模板。要实现这个模板，我们必须包含`string`库。我们还在这个头文件中添加了一个宏来测试我们的类。我们可以这样使用这个头文件：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As shown in the preceding code snippet, we include our header, create an instance
    of our template class, and use it to output a message. When executed, we get the
    following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们包括了我们的头文件，创建了我们模板类的一个实例，并用它输出了一条消息。执行时，我们得到了以下输出：
- en: '![](img/bdf986f5-0d0d-4ff1-a0f9-edbf1528f356.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdf986f5-0d0d-4ff1-a0f9-edbf1528f356.png)'
- en: 'Although this is a simple example showing a class template that implements
    a C++ functor, there are some issues with this code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的例子，展示了一个实现C++函数对象的类模板，但这段代码存在一些问题：
- en: The implementation of `the_answer` depends on the `string` library. This means
    that whenever you use `header.h`, you are not only including the definition of
    `the_answer`, but you are also including the complete definition of the `string`
    library, including all of its dependencies. This type of dependency chain results
    in large build time costs.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`the_answer`的实现取决于`string`库。这意味着每当你使用`header.h`时，你不仅包含了`the_answer`的定义，还包含了`string`库的完整定义，包括它的所有依赖项。这种类型的依赖链导致了大量的构建时间成本。'
- en: The `CHECK()` macro is accessible to the client as well. In C++, there is no
    way to namespace a macro, resulting in the possibility of macro collisions.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHECK()`宏也对客户端可访问。在C++中，没有办法给宏命名空间，这导致了宏冲突的可能性。'
- en: The preceding example is small, and therefore easy to compile, but suppose our
    header was `30,000` lines of template code mixed with several includes of its
    own. Now, suppose we must include our header in hundreds of source files. The
    result of this scenario would be extremely long compile times, as each time a
    source file is compiled, it must recompile the same huge header file, over and
    over and over again.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的例子很小，因此很容易编译，但假设我们的头文件有`30,000`行模板代码，混合了几个自己的包含。现在，假设我们必须在数百个源文件中包含我们的头文件。这种情况的结果将是非常长的编译时间，因为每次编译一个源文件时，它都必须一遍又一遍地重新编译相同的庞大头文件。
- en: 'To understand how C++ Modules addresses these issues, let''s look at how this
    same code would look using modules:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解C++模块如何解决这些问题，让我们看看使用模块的相同代码会是什么样子：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As shown in the preceding code snippet, our custom library includes a definition
    of string and then uses the `export` module to create a new C++ module called
    `answers`. We then define our class template with the `export` definition. Whenever
    a header is compiled (really, whenever any code is compiled), the compiler usually
    first converts that human-readable C++ syntax into something called an **Intermediate
    Representation** (**IR**). This IR is then converted into a binary assembly. The
    problem is that header files contain code (such as macros and includes) that cannot
    be converted into this type of representation, which means that, each time the
    compiler sees a header, it must convert the code into an IR and then into a binary
    every time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们的自定义库包括了字符串的定义，然后使用`export`模块创建了一个名为`answers`的新C++模块。然后我们使用`export`定义定义了我们的类模板。每当一个头文件被编译（实际上，每当任何代码被编译）时，编译器通常首先将人类可读的C++语法转换为一种叫做**中间表示**（**IR**）的东西。然后将这个IR转换为二进制汇编。问题在于头文件包含了无法转换为这种表示的代码（如宏和包含），这意味着每次编译器看到一个头文件时，它都必须将代码转换为IR，然后再转换为二进制。
- en: 'C++ Modules provides a syntax and a set of rules that enables the compiler
    to convert a header into an IR and store the results of this IR with the rest
    of the resulting object files. The compiler can use this IR as many times as needed,
    removing the need to constantly perform the code for the IR conversion process,
    repeatedly. To see how the preceding code is used, let''s look at the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++模块提供了一种语法和一组规则，使编译器能够将头文件转换为IR，并将这个IR的结果与其余的对象文件一起存储。编译器可以使用这个IR多次，无需不断执行IR转换过程的代码。要了解前面的代码如何使用，让我们看看以下内容：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As shown here, we include both the definition of `std::cout` and our `answers`
    module. The difference is that the `main()` function doesn't have to convert the
    `answers` and `std.core` definitions from C++ syntax into the compiler's IR, decreasing
    the compilation time of the `main()` source file. The `main()` source file can
    also create a macro called `CHECK()` without colliding with the same macro in
    our `answers` module as macros cannot be exported.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们包括了`std::cout`的定义和我们的`answers`模块。不同之处在于`main()`函数不必将`answers`和`std.core`的定义从C++语法转换为编译器的IR，从而减少了`main()`源文件的编译时间。`main()`源文件还可以创建一个名为`CHECK()`的宏，而不会与我们的`answers`模块中的相同宏发生冲突，因为宏无法被导出。
- en: Introducing std::span, a new view on arrays
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入std::span，数组的新视图
- en: In this recipe, we will learn how to use `std::span`, which is a new feature
    coming with C++20\. This recipe is important as `std::span` is a descendant of
    the Guideline Support Library's `gsl::span`, which is a core component of the
    library used to ensure that your C++ is Core Guideline-compliant. In this recipe,
    we will not only introduce `std::span`, but we will also explain how to use it
    in your own code and why it helps to encapsulate an array with its size as well
    as provide a convenient API for working with arrays in general.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用`std::span`，这是C++20中的一个新功能。这个示例很重要，因为`std::span`是Guideline Support
    Library的`gsl::span`的后代，它是用于确保你的C++符合核心指导方针的库的核心组件。在这个示例中，我们不仅介绍了`std::span`，还解释了如何在自己的代码中使用它，以及为什么它有助于封装一个带有大小的数组，并为处理数组提供了一个方便的API。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 19.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例的正确工具。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'You will need to perform the following steps to try the recipe:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试本示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To compile the source code, run the following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码后，您可以通过运行以下命令执行本示例中的每个示例：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用，以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we will explore what `std::span` is and why it is needed. In
    C++ (and even in C), to pass an array to a function, the following is implemented:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将探讨`std::span`是什么以及为什么需要它。在C++（甚至在C中），要将数组传递给函数，实现如下：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As shown in the preceding example, we have created a function called `foo()`
    that takes a pointer to an array as well as the size of the array. We then use
    this information to output the contents of the array to `stdout`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们创建了一个名为`foo()`的函数，该函数接受一个指向数组的指针以及数组的大小。然后我们使用这些信息将数组的内容输出到`stdout`。
- en: 'We can execute this function as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式执行此函数：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This results in the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/94681bc8-2828-4927-8427-fec635cdd27a.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94681bc8-2828-4927-8427-fec635cdd27a.png)'
- en: The problem with the preceding code is that it is not C++ Core Guideline-compliant.
    Specifically, we are forced to store the size of the array independently of the
    array itself. This can lead to issues if the array and its size become out-of-sync
    (something that is possible in large projects). The use of a pointer in relation
    to an array also prevents the use of ranged `for` loops, meaning we must manually
    traverse the array, which can also lead to potential stability issues if the `for`
    loop is not properly constructed. Lastly, we were required to calculate by hand
    the size of the array, an operation that, as shown, is prone to error, using `sizeof()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码问题在于它不符合C++核心准则。具体来说，我们被迫独立存储数组的大小。如果数组和其大小不同步（在大型项目中可能会发生），这可能会导致问题。指针与数组相关联还阻止了使用范围`for`循环，这意味着我们必须手动遍历数组，这也可能导致潜在的稳定性问题，如果`for`循环没有正确构造。最后，我们需要手动计算数组的大小，这是一个容易出错的操作，使用`sizeof()`。
- en: 'One way to solve this issue is to use a template function, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是使用模板函数，如下所示：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As shown in the preceding code snippet, we have defined a template function
    that takes a reference to an integer array of size `N`. We can then use `N` to
    traverse through this array. We can even use ranged `for` loops on the array since
    the compiler knows what the size of the array is at compile time. This code can
    be used as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们定义了一个模板函数，该函数接受大小为`N`的整数数组的引用。然后我们可以使用`N`来遍历这个数组。我们甚至可以在数组上使用范围`for`循环，因为编译器知道数组的大小是在编译时确定的。这段代码可以这样使用：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As shown here, we have made several improvements. We are no longer passing around
    pointers that could lead to `NULL` pointer violations. We are no longer calculating
    the size of the array by hand using `sizeof()`, and we no longer need to store
    the size of the array independently of the array itself. The problem with the
    preceding code is that each time the size of the array changes, we must compile
    a completely different version of the `foo()` function. If the `foo()` function
    is large, this could be a problem. This code also doesn't support dynamically
    allocated arrays (in other words, whether the array was allocated using `std::unique_ptr`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，我们进行了几项改进。我们不再传递可能导致`NULL`指针违规的指针。我们不再使用`sizeof()`手动计算数组的大小，也不再需要独立存储数组的大小。前面的代码问题在于每次数组的大小发生变化时，我们必须编译一个完全不同版本的`foo()`函数。如果`foo()`函数很大，这可能是一个问题。此代码还不支持动态分配的数组（即数组是否使用`std::unique_ptr`分配）。
- en: 'To solve this, C++20 has added the `std::span` class. Check out this example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，C++20添加了`std::span`类。查看以下示例：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As shown in the preceding code snippet, we have created the `foo()` function
    using `std::span`, which stores an array of integers. Like most other C++ containers,
    we can get the size of the array, and we can use the subscript operator to access
    individual elements of the array. To use this function, we simply call it the
    same way we did using the template function, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们使用`std::span`创建了`foo()`函数，它存储了一个整数数组。与大多数其他C++容器一样，我们可以获取数组的大小，并且可以使用下标运算符访问数组的各个元素。要使用此函数，我们只需像使用模板函数一样调用它，如下所示：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using `std::span`, we can now provide the same `foo()` function with arrays
    of different sizes, and we can even allocate the arrays using dynamic memory (in
    other words, `std::unique_ptr`) without having to re-implement the `foo()` function.
    Ranged `for` loops even work as expected:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::span`，我们现在可以为不同大小的数组提供相同的`foo()`函数，并且甚至可以使用动态内存（即`std::unique_ptr`）分配数组，而无需重新实现`foo()`函数。范围`for`循环甚至可以正常工作：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To use `foo()` with dynamic memory, we can do the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态内存和`foo()`，我们可以这样做：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As shown in the preceding example, we ran the `foo()` function with three different
    types of memory created dynamically. The first time we ran `foo()`, we allocated
    memory using `new()`/`delete()`. If you are attempting to remain C++ Core Guideline-compliant,
    you are likely not interested in this approach. The second and third approaches
    allocated the memory using `std::vector` or `std::unique_ptr`. Both have their
    inherent disadvantages:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们使用三种不同类型的动态创建的内存运行了`foo()`函数。第一次运行`foo()`时，我们使用`new()`/`delete()`分配了内存。如果您试图保持符合C++核心准则，您可能对这种方法不感兴趣。第二和第三种方法分配了使用`std::vector`或`std::unique_ptr`的内存。两者都有其固有的缺点：
- en: '`std::vector` stores its own `size()`, but also stores its capacity and, by default,
    initializes the memory.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`存储自己的`size()`，但也存储其容量，并且默认初始化内存。'
- en: '`std::unique_ptr` doesn''t store its own `size()`, and it, too, defaults initialized
    memory.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_ptr`不存储自己的`size()`，它也会默认初始化内存。'
- en: Currently, C++ does not have an array type capable of allocating a dynamic array
    of uninitialized memory while also storing the array's size (and only its size).
    `std::span`, however, can be used with some combination of the preceding approaches
    to manage an array depending on your needs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，C++没有能够分配未初始化内存的动态数组并存储数组大小（仅存储大小）的数组类型。然而，`std::span`可以与前述方法的某些组合一起使用，根据您的需求来管理数组。
- en: 'It should also be noted that when we created `std::span` in the preceding example,
    we passed it the size of the array based on the total number of elements, not
    the total number of bytes. `std::span` is capable of providing both for you, as
    follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意，在前面的示例中，当我们创建`std::span`时，我们根据元素的总数而不是字节的总数传递了数组的大小。`std::span`能够为您提供这两者，如下所示：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we run the preceding implementation of `foo()`, with the aforementioned dynamic
    memory examples, we get the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述的`foo()`实现，并使用前面提到的动态内存示例，我们会得到以下结果：
- en: '![](img/5cd2b8ea-8b69-4e72-8ea6-39e36b056750.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cd2b8ea-8b69-4e72-8ea6-39e36b056750.png)'
- en: 'Finally, we can use the span to create additional sub-spans, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用span来创建额外的子span，如下所示：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding `foo2()` function, we take a span and output all of its elements
    using a ranged `for` loop. We can then use the following to create sub-spans:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`foo2()`函数中，我们使用span并使用范围`for`循环输出其所有元素。然后我们可以使用以下方法创建子span：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The result of the `subspan()` function is another `std::span`. The difference
    is the fact that the pointer it stores internally has been advanced by `5` elements,
    and `size()` that the span stores is now `1`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`subspan()`函数的结果是另一个`std::span`。不同之处在于它内部存储的指针已经提前了`5`个元素，并且span存储的`size()`现在是`1`。'
- en: Working with Ranges in C++20
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++20中使用范围
- en: In this recipe, we will learn how to use C++ Ranges, a new feature set coming
    with C++20\. Ranges provides convenient functions for working with anything that
    mimics a range of objects or values. For example, 4, 8, 15, 16, 23, 42 is a range
    of integers. In C++ today, working with ranges can be cumbersome depending on
    what you are doing. This recipe is important as C++ ranges removes a lot of complexity
    associated with working with ranges, ensuring that your code is easier to read
    and maintain over time.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用C++ Ranges，这是C++20带来的新功能集。Ranges提供了方便的函数，用于处理模拟对象或值范围的任何内容。例如，4,
    8, 15, 16, 23, 42是一个整数范围。在当今的C++中，根据您的操作，处理范围可能会很麻烦。本教程很重要，因为C++范围消除了与处理范围相关的许多复杂性，确保您的代码随着时间的推移更容易阅读和维护。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 19.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To perform this recipe, perform the following steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请执行以下步骤：
- en: 'From a new Terminal, run the following command to download the source code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To compile the source code, run the following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译后，您可以通过运行以下命令执行本教程中的每个示例：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'C++ Ranges is a welcome addition to C++20 as it provides a simple means for
    working with any list of objects or values. To best explain how this works, let''s
    look at the following example (note that, in these recipes, we will use Ranges
    v3 while we wait for GCC to support Ranges as v3 was the implementation adopted
    by C++20):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: C++ Ranges是C++20的一个受欢迎的补充，因为它提供了一种简单的方法来处理任何对象或值列表。为了最好地解释这是如何工作的，让我们看一下以下示例（请注意，在这些示例中，我们将使用Ranges
    v3，而我们等待GCC支持Ranges，因为v3是C++20采用的实现）：
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As shown in the preceding code snippet, we have created a list of integers
    (in this specific case, we have created a simple initializer list). We then use
    the `ranges::count()` function to count the total number of times the value `42`
    shows up in the list, resulting in the following output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，我们已经创建了一个整数列表（在这种特定情况下，我们创建了一个简单的初始化列表）。然后我们使用`ranges::count()`函数来计算列表中值为`42`的出现次数，得到以下输出：
- en: '![](img/29bc917b-ce5c-4907-ac11-e21b6e099e03.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29bc917b-ce5c-4907-ac11-e21b6e099e03.png)'
- en: 'Ranges can also be used for searching:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 范围也可以用于搜索：
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As shown in the preceding example, we have created the same initializer list
    of integers and we use ranges to return an iterator. This iterator can be used
    to traverse the list or get the located value. Initializer lists already support
    iterators, and one thing that Ranges does is extend this functionality to other
    types, including simple C-style arrays:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们创建了相同的整数初始化列表，并使用ranges返回一个迭代器。这个迭代器可以用来遍历列表或获取定位的值。初始化列表已经支持迭代器，而Ranges所做的一件事是将这个功能扩展到其他类型，包括简单的C风格数组：
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding example uses a C-style array instead of an initializer list and,
    as shown, Ranges provides an iterator to work with, in the C-style array, something
    currently not possible.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用了C风格数组而不是初始化列表，并且如所示，Ranges提供了一个迭代器来处理C风格数组，这是目前不可能的。
- en: 'Ranges also provides some convenience algorithms. For example, consider the
    following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Ranges还提供了一些方便的算法。例如，考虑以下代码：
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding example, we have created a list of integers. We then loop over
    the entire range of integers and execute a lambda on this list. Although this
    could be done using traditional loops, such as the range-based loops added in
    C++11, `for_each` could simplify your logic (depending on your use case).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个整数列表。然后我们循环遍历整数的整个范围，并在这个列表上执行一个lambda。虽然这可以使用传统的循环来完成，比如C++11中添加的基于范围的循环，`for_each`可以简化您的逻辑（取决于您的用例）。
- en: 'Ranges also provides the ability to transform one list into another. Consider
    the following example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Ranges还提供了将一个列表转换为另一个列表的能力。考虑以下示例：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We will start this example by creating our own type. As shown in the preceding
    code snippet, we have a new type called `my_type` that is constructed with an
    integer and returns the integer using the `get()` function. We can then extend
    our previous examples to transform our list of integers into a list of our custom
    types, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建我们自己的类型开始这个示例。如前面的代码片段所示，我们有一个名为`my_type`的新类型，它是用一个整数构造的，并使用`get()`函数返回整数。然后我们可以扩展我们之前的示例，将我们的整数列表转换为我们自定义类型的列表，如下所示：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As shown in the preceding example, we create our initial list of integers and
    then convert this list into a second list of our custom types using the `ranges::views::transform`
    function. We can then iterate over this new list using a traditional range-based
    `for` loop.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们创建了初始的整数列表，然后使用`ranges::views::transform`函数将这个列表转换为我们自定义类型的第二个列表。然后我们可以使用传统的基于范围的`for`循环来迭代这个新列表。
- en: 'Finally, Ranges also provides some actions that let you actually modify an
    existing range. For example, consider the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Ranges还提供了一些操作，让您实际修改现有的范围。例如，考虑以下代码：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the preceding example, we use the `actions::sort` function to sort our list
    of vectors, resulting in the following output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`actions::sort`函数对我们的向量列表进行排序，得到以下输出：
- en: '![](img/2017152b-aba7-4295-99e7-bbbadae2dde7.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2017152b-aba7-4295-99e7-bbbadae2dde7.png)'
- en: As shown in the preceding example, C++20 Ranges provides us with a simple means
    to sort `std::vector` using the pipe operator instead of having to use `std::sort`,
    explicitly defining our begin and end iterators.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，C++20 Ranges为我们提供了一种简单的方法，使用管道运算符而不是使用`std::sort`来对`std::vector`进行排序，显式定义我们的起始和结束迭代器。
- en: Learning how to use Coroutines in C++20
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何在C++20中使用协程
- en: In this recipe, we will take a brief peek into an upcoming feature in C++20
    called Coroutines. Unlike some of the other features in being added to C++20,
    Coroutines are not possible in C++ today. Coroutines provide the ability to suspend
    the execution of a function and yield a result. Once the result is used, the function
    can be resumed where it left off to continue execution. This recipe is important
    as C++20 will be adding first-class support (that is, new keywords) to C++ to
    support Coroutines and it is likely that this new feature will begin to surface
    in libraries and examples in the near future.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将简要介绍C++20中即将推出的一个特性，称为协程。与C++20中正在添加的其他一些特性不同，协程在当前的C++中是不可能的。协程提供了暂停函数执行和产生结果的能力。一旦结果被使用，函数可以在离开的地方恢复执行。这个示例很重要，因为C++20将为C++添加一流支持（即新关键字）来支持协程，很可能这个新特性将在不久的将来开始出现在库和示例中。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 19.04 or higher and running the following in
    a Terminal window:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有的技术要求，包括安装Ubuntu 19.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To try this recipe, please perform the following steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个示例，请执行以下步骤：
- en: 'From a new Terminal, run the following command to download the source code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端，运行以下命令来下载源代码：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To compile the source code, run the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码被编译，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程所教授的课程的关系。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As stated earlier, Coroutines provide the ability to suspend and resume the
    execution of a function. To demonstrate how this will work in C++20, we will briefly
    look at a simple example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，协程提供了暂停和恢复函数执行的能力。为了演示这在C++20中将如何工作，我们将简要地看一个简单的例子：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the preceding example, we have created a function called `even_numbers()`
    that, given a range, returns `std::vector` of even numbers. We can then use this
    function as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了一个名为`even_numbers()`的函数，给定一个范围，返回偶数的`std::vector`。我们可以这样使用这个函数：
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This results in the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '![](img/e8884a7b-b906-4296-a575-a6701c548375.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8884a7b-b906-4296-a575-a6701c548375.png)'
- en: 'The problem with the preceding implementation is that this code requires the
    use of `std::vector` just to create a range of numbers to iterator over. With
    Coroutines, we will be able to implement this function as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面实现的问题在于这段代码需要使用`std::vector`来创建一个数字范围进行迭代。有了协程，我们将能够实现这个函数如下：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'From the preceding code, we see the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们看到了以下内容：
- en: Instead of returning `std::vector`, we now return `generator<int>`.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们不再返回`std::vector`，而是返回`generator<int>`。
- en: As we loop through each even value in our loop, we call `co_yield`. This causes
    the `even_numbers()` function to return with the value provided while saving its
    place.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在循环中遍历每个偶数值时，我们调用`co_yield`。这会导致`even_numbers()`函数返回提供的值，并保存它的位置。
- en: Once the `even_numbers()` function is resumed, it returns to where `co_yield`
    was originally executed, meaning the function can now continue its execution producing
    the next even number.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦`even_numbers()`函数被恢复，它会回到最初执行`co_yield`的地方，这意味着函数现在可以继续执行并产生下一个偶数。
- en: This process continues until the `for` loop finishes and the Coroutine returns
    the last even number.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个过程会一直持续，直到`for`循环结束并且协程返回最后一个偶数。
- en: 'To use this function, our `main()` code doesn''t change:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个函数，我们的`main()`代码不需要改变：
- en: '[PRE66]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The difference is that we are not returning `std::vector` but instead returning
    the integer provided by the Coroutine.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于我们不再返回`std::vector`，而是返回协程提供的整数。
