- en: Qt Network for Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt网络用于通信
- en: 'Networking is almost as important to mobile devices as the device being mobile.
    Without networking, data would have to be physically moved from one place to another.
    Luckily, Qt has extensive networking features in `QNetwork`. In this chapter,
    we will discuss the following APIs:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络对于移动设备来说几乎和移动设备本身一样重要。没有网络，数据就必须从物理上一个地方移动到另一个地方。幸运的是，Qt在`QNetwork`中提供了广泛的网络功能。在本章中，我们将讨论以下API：
- en: '`QNetworkReply`'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkReply`'
- en: '`QNetworkRequest`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkRequest`'
- en: '`QDnsLookup`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QDnsLookup`'
- en: '`QHostInfo`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QHostInfo`'
- en: '`QLocalServer`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QLocalServer`'
- en: '`QTcpSocket`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTcpSocket`'
- en: 'To show available Wi-Fi networks that are nearby, we will also go over the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示附近的可用Wi-Fi网络，我们还将介绍以下内容：
- en: '`QNetworkSession`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkSession`'
- en: '`QNetworkConfiguration`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkConfiguration`'
- en: You will also learn how to use Qt APIs for standard networking tasks, such as
    **Domain Name Service** (**DNS**) lookups, download and upload files, and how
    to use Qt's socket classes for communication.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何使用Qt API进行标准网络任务，例如**域名服务**（**DNS**）查找、下载和上传文件，以及如何使用Qt的套接字类进行通信。
- en: High level – request, reply, and access
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 – 请求、回复和访问
- en: Networking in Qt is quite feature-rich. Networking in Qt Quick is more behind
    the scenes than in your face. In **Qt Modeling Language** (**QML**), you can download
    remote components and use them in your application, but any other arbitrary download
    or network functionality you will have to bake yourself in the C++ backend or
    use JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中的网络功能非常丰富。Qt Quick中的网络比Qt更隐蔽。在**Qt建模语言**（**QML**）中，你可以下载远程组件并在你的应用程序中使用它们，但任何其他任意下载或网络功能你将不得不在C++后端中实现或使用JavaScript。
- en: Even though `QNetworkRequest`, `QNetworkReply`, and `QNetworkAccessManager`
    are all used to make network requests, let's split them up and see how to use
    them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`QNetworkRequest`、`QNetworkReply`和`QNetworkAccessManager`都用于制作网络请求，但让我们分开来看如何使用它们。
- en: QNetworkRequest
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkRequest
- en: '`QNetworkRequest` is a part of the access functionality. It constructs a `request`,
    which can be one of the following verbs:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkRequest`是访问功能的一部分。它构建一个`request`，可以是以下动词之一：'
- en: '`GET`: `get(...)`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: `get(...)`'
- en: '`POST`: `post(...)`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: `post(...)`'
- en: '`PUT`: `put(...)`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: `put(...)`'
- en: '`DELETE`: `deleteResource(...)`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: `deleteResource(...)`'
- en: '`HEAD`: `head(...)`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`: `head(...)`'
- en: You can also send custom verbs using `sendCustomRequest`, which takes the custom
    verb as a `QByteArray` argument.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`sendCustomRequest`发送自定义动词，它接受自定义动词作为`QByteArray`参数。
- en: 'Headers can be set as known headers using `setHeader` and can be one of the
    following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`setHeader`将头设置为已知头，可以是以下之一：
- en: '`ContentDispositionHeader`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentDispositionHeader`'
- en: '`ContentTypeHeader`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentTypeHeader`'
- en: '`ContentLengthHeader`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentLengthHeader`'
- en: '`LocationHeader`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocationHeader`'
- en: '`LastModifiedHeader`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LastModifiedHeader`'
- en: '`CookieHeader`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CookieHeader`'
- en: '`SetCookieHeader`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetCookieHeader`'
- en: '`UserAgentHeader`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserAgentHeader`'
- en: '`ServerHeader`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerHeader`'
- en: Raw or custom headers can be set with `setRawHeader`. HTTP attributes can help
    to control the request cache, redirect, and cookies. They can be set with, you
    guessed it, `setAttribute`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`setRawHeader`设置原始或自定义头。HTTP属性可以帮助控制请求缓存、重定向和cookies。它们可以用`setAttribute`设置。
- en: Let's put this into the following code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这段代码放到以下代码中。
- en: The source code can be found on the Git repository under the `Chapter05-1` directory,
    in the `cp5` branch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`Chapter05-1`目录下的`cp5`分支中的Git仓库中找到。
- en: 'To use the networking module, in the `.pro` project, add `network` to the `QT`
    variable as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用网络模块，在`.pro`项目中，将`network`添加到`QT`变量中，如下所示：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can now use Qt Networking.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Qt网络。
- en: '`QNetworkRequest` is what needs to be used to request operations from the network
    such as `get` and `put`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkRequest`是需要用于从网络请求操作的部分，例如`get`和`put`。'
- en: 'A simple implementation looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的实现如下：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`QNetworkRequest` can also take `QUrl` as its argument. `QNetworkRequest` is
    not based on `QObject`, so it has no parent, nor does it have any of its own signals.
    All communication is done through `QNetworkAccessManager`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkRequest`也可以将`QUrl`作为其参数。`QNetworkRequest`不是基于`QObject`的，因此它没有父对象，也没有任何自己的信号。所有通信都是通过`QNetworkAccessManager`完成的。'
- en: The one signal you want to connect to is the `finished` signal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要连接的一个信号是`finished`信号。
- en: 'Suppose I have some form data I need to transfer; I would need to add a standard
    header with `setHeader`. I could also add the following custom header I call `X-UUID`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一些需要传输的表单数据；我需要使用`setHeader`添加一个标准头。我还可以添加以下自定义头，我称之为`X-UUID`：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have a viable `QNetworkRequest`, we need to send it to `QNetworkAccessManager`.
    Let's take a look at how we can do that.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个有效的`QNetworkRequest`，我们需要将其发送到`QNetworkAccessManager`。让我们看看我们如何做到这一点。
- en: QNetworkAccessManager
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkAccessManager
- en: 'Bring in the manager—`QNetworkAccessManager` (**QNAM**). It is used to send
    and receive asynchronous requests over a network. Usually, there is one instance
    of QNAM in an application, as here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 引入管理器——`QNetworkAccessManager`（**QNAM**）。它用于通过网络发送和接收异步请求。通常，一个应用程序中只有一个QNAM实例，如下所示：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At its simplest, you can make a QNAM request using the `get`, `put`, `post`,
    `deleteResource`, or `head` functions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，你可以使用`get`、`put`、`post`、`deleteResource`或`head`函数来创建一个QNAM请求。
- en: QNAM uses signals to transfer data and request information and the `finished()`
    signal is used to signal when a request has finished.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: QNAM使用信号来传输数据和请求信息，而`finished()`信号用于表示请求已完成。
- en: 'Let''s add a signal handler for that, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为它添加一个信号处理程序，如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This would call your `replyFinished` slot with the data and headers within
    the `QNetworkReply` argument, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用你的`replyFinished`槽，其中包含`QNetworkReply`参数中的数据和头信息，如下所示：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, call the `get` method on `QNetworkAccessManager` as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式在`QNetworkAccessManager`上调用`get`方法：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's as simple as that to download something! QNAM will work its magic and download
    the URL.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下载东西就这么简单！QNAM将施展其魔法并下载URL。
- en: 'It is also just as easy a method to create a file upload. Of course, your web
    server needs to support the `put` method, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件上传也是同样简单的方法。当然，你的Web服务器需要支持`put`方法，如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The source code can be found on the Git repository under the `Chapter05-2` directory,
    in the `cp5` branch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter05-2`目录下的`cp5`分支中找到。
- en: 'If you need to send some query parameters in the URL, you can use `QUrlQuery`
    to construct the `form` query data, and then send the `request` as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在URL中发送一些查询参数，你可以使用`QUrlQuery`来构建`form`查询数据，然后按照以下方式发送`request`：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Form data can be uploaded with the `post` function as a `QByteArray` as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`post`函数将表单数据作为`QByteArray`上传，如下所示：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To send a multipart form data, such as form data and an image, you can use
    `QHttpMultiPart` as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送多部分表单数据，例如表单数据和图片，你可以使用`QHttpMultiPart`如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, none of these examples keeps track of the reply. `QNetworkReply`
    is returned by the `get`, `post`, and `put` methods of `QNetworkAccessManager`,
    which can be used to track download or upload progress or if there are any errors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些示例都没有跟踪回复。`QNetworkReply`是`QNetworkAccessManager`的`get`、`post`和`put`方法的返回值，可以用来跟踪下载或上传进度或是否有错误。
- en: QNetworkReply
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkReply
- en: All calls to QNAM's `get`, `post`, and so on, will return `QNetworkReply`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对QNAM的`get`、`post`等所有调用都将返回`QNetworkReply`。
- en: You will need to delete this pointer, otherwise it will leak memory, but do
    not delete it in the `finished` signal handler. You can use `deleteLater()`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要删除这个指针，否则它将导致内存泄漏，但不要在`finished`信号处理程序中删除它。你可以使用`deleteLater()`。
- en: '`QNetworkReply` has an interesting signal we would most likely need to handle.
    Let''s start with the two most important—`error` and `readyRead`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkReply`有一个有趣的信号，我们很可能需要处理。让我们从两个最重要的信号开始——`error`和`readyRead`。'
- en: 'So, let''s handle that `QNetworkReply` properly. Since we do not have the valid
    object beforehand, we need to connect the signals after the network request action.
    It seems a bit backward to me, but this is the way it needs to be and it works.
    The code is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们正确地处理那个`QNetworkReply`。由于我们事先没有有效的对象，我们需要在网络请求操作之后连接信号。这对我来说似乎有点反直觉，但这是必须这样做的方式，并且它有效。代码如下：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I am using the legacy style of signal connections, but you could and should
    write connections like the following because it allows compile time checking for
    syntax and other errors:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用传统的信号连接方式，但你也可以并应该编写如下所示的连接，因为它允许编译时检查语法和其他错误：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, now we have done a request and are waiting for a reply from the server.
    Let's look at the signal handlers one by one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经发送了一个请求，正在等待服务器的回复。让我们逐一查看信号处理程序。
- en: '`error(QNetworkReply::NetworkError)` is emitted when there is an error with
    the error code as argument. If you need a user-friendly string, you can retrieve
    that with `QNetworkReply::errorString()`. `finished()` is emitted when the request
    is finished. The reply is still open, so you can read it here: `readyRead()` .Since
    the reply is derived from `QIODevice`, it has the `readyRead` signal, which is
    emitted whenever more data is ready to read.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现错误并带有错误代码作为参数时，会发出 `error(QNetworkReply::NetworkError)`。如果您需要一个用户友好的字符串，可以使用
    `QNetworkReply::errorString()` 获取。当请求完成时，会发出 `finished()`。回复仍然打开，因此您可以在这里读取它：`readyRead()`。由于回复是从
    `QIODevice` 派生的，它具有 `readyRead` 信号，该信号在可以读取更多数据时发出。
- en: 'On large downloads, you might want to monitor the progress of the download,
    which is a common thing to do. Usually, every download has some kind of progress
    bar. `QNetworkReply` emits the `downloadProgress(qint64 bytesReceived, qint64
    bytesTotal)` signal as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在大文件下载时，您可能想要监控下载进度，这是一件常见的事情。通常，每个下载都有一个进度条。`QNetworkReply` 会发出 `downloadProgress(qint64
    bytesReceived, qint64 bytesTotal)` 信号，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is the corresponding `uploadProgress` for uploads.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上传，存在相应的 `uploadProgress`。
- en: '`preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator *authenticator)`
    gets emitted when the download needs authentication. The `QSslPreSharedKeyAuthenticator`
    object should be loaded with the pre-shader key and other details to authenticate
    the user.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当下载需要身份验证时，会发出 `preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator
    *authenticator)`。`QSslPreSharedKeyAuthenticator` 对象应加载预共享密钥和其他详细信息以验证用户。
- en: The `sslErrors(const QList<QSslError> &errors)` signal is called when **Secure
    Sockets Layer** (**SSL**) encounters problems, including certificate verification
    errors.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当 **安全套接字层** (**SSL**) 遇到问题时，会调用 `sslErrors(const QList<QSslError> &errors)`
    信号，包括证书验证错误。
- en: '`QNetworkManager` can also do simple **File Transfer Protocol** (**FTP**) transfers.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkManager` 也可以执行简单的 **文件传输协议** (**FTP**) 转发。'
- en: QFtp
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QFtp
- en: There are two ways to use FTP with Qt. `QNetworkAccessManager` has simple FTP
    `get` and `put` support, we can easily use that.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt 进行 FTP 有两种方式。`QNetworkAccessManager` 提供简单的 FTP `get` 和 `put` 支持，我们可以轻松使用它。
- en: 'FTP servers usually require some sort of username and password. We use `setUserName()`
    and `setPassword()` of `QUrl` to set these, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 服务器通常需要某种类型的用户名和密码。我们使用 `QUrl` 的 `setUserName()` 和 `setPassword()` 来设置这些，如下所示：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The source code can be found on the Git repository under the `Chapter05-5` directory,
    in the `cp5` branch.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter05-5` 目录下的 `cp5` 分支中找到。
- en: 'Once we know the file''s name, we need to add that to the `url`, as it will
    use this to write the fail, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道文件名，我们需要将其添加到 `url` 中，因为它将使用此信息写入失败，如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, set the request `url`, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置请求 `url`，如下所示：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can hook up slots to the `QNetworkReply` signals, once we call `put` on
    the QNAM, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 QNAM 上调用 `put`，我们就可以将槽连接到 `QNetworkReply` 信号。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Do not forget that `error` signal needs `QOverload` as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记 `error` 信号需要 `QOverload`，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you need to do more complicated things other than `get` and `put`, you will
    need to use something else besides `QNetworkAccessManager`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要执行除 `get` 和 `put` 之外更复杂的事情，您将需要使用除 `QNetworkAccessManager` 之外的其他东西。
- en: '`QFtp` is not included with Qt, but you can access the standalone `QFtp` module
    that was ported from Qt 4 to run with Qt 5 as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFtp` 不包含在 Qt 中，但您可以使用从 Qt 4 移植的独立 `QFtp` 模块，如下运行与 Qt 5：'
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will need to build `QFtp`, so we can open the `qtftp.pro` in Qt Creator.
    Run Build and install that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建 `QFtp`，因此可以在 Qt Creator 中打开 `qtftp.pro`。运行构建并安装它。
- en: 'Using the command line the commands would be as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行，命令如下：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will need to install this into Qt 5.12, so in Qt Creator, navigate to Projects
    | Build | Build Steps and select Add Build Step | Make. In the arguments field,
    type `install`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其安装到 Qt 5.12 中，因此请在 Qt Creator 中导航到 Projects | Build | Build Steps 并选择
    Add Build Step | Make。在参数字段中，键入 `install`。
- en: Build this and it will also install.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此文件，它也会安装。
- en: 'In the project''s `.pro` file, to tell `qmake` to use the `network` and `ftp`
    modules, add the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的 `.pro` 文件中，为了告诉 `qmake` 使用 `network` 和 `ftp` 模块，请添加以下内容：
- en: '`QT += network ftp`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`QT += network ftp`'
- en: '`QFtp` works very typically; log in, do operations, and then log out, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFtp` 的工作方式非常典型；登录，执行操作，然后登出，如下所示：'
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We connect to the `commandFinished` signal, which can tell us whether there
    was an error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们连接到 `commandFinished` 信号，它可以告诉我们是否发生了错误。
- en: The `stateChanged` signal will tell us when we are logged in and the `dataTransferProgress` signal
    will tell us when bytes are being transferred.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`stateChanged` 信号将告诉我们何时登录，而 `dataTransferProgress` 信号将告诉我们何时正在传输字节。'
- en: '`QFtp` supports other operations, including the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFtp` 支持其他操作，包括以下：'
- en: '`list`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`'
- en: '`cd`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd`'
- en: '`remove`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`'
- en: '`mkdir`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir`'
- en: '`rmdir`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmdir`'
- en: '`rename`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rename`'
- en: QNAM also touches upon my favorite part of Qt Network—Bearer Management. Let's
    move on to learning about Bearer Management.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: QNAM 还触及了我最喜欢的 Qt 网络部分——承载管理。让我们继续学习承载管理。
- en: Bearer Management of good news
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带来好消息的承载管理
- en: Bearer Management was meant to facilitate user control over the network connections.
    There are `open` and `close` functions for found connections. One thing it does
    not do is actually configure these connections. They must already be configured
    by the system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 承载管理旨在方便用户对网络连接的控制。有 `open` 和 `close` 函数用于找到的连接。它不做的一件事是实际配置这些连接。它们必须已经由系统配置。
- en: It is also meant to be able to group connections together to make it easier
    to smoothly switch between connections, such as migrating from Wi-Fi to mobile
    cellular data, somewhat like **Media Independent Handover** (**MIH**) or also
    **Unlicensed Mobile Access** (**UMA**) specification. If you are interested in
    an open source library to help with handovers, look at Open MIH at SourceForge.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它还旨在能够将连接分组，以便更容易地在连接之间平滑切换，例如从 Wi-Fi 迁移到移动蜂窝数据，有点像 **媒体无关切换**（**MIH**）或 **未授权移动接入**（**UMA**）规范。如果您对帮助切换的开源库感兴趣，请查看
    SourceForge 上的 Open MIH。
- en: At the time Qt's Bearer Management was first developed, Symbian was the most
    used and arguably the most important mobile OS. Symbian had the ability to seamlessly
    migrate connections between technologies without dropping the connection or data,
    kind of like the way mobile phone connections get migrated from cell tower to
    cell tower.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 的承载管理最初开发时，Symbian 是最常用的，可以说是最重要的移动操作系统。Symbian 有能力在不停机或丢失数据的情况下，在技术之间无缝迁移连接，有点像手机连接从基站迁移到基站的方式。
- en: Apple seems to call this Wi-Fi Assist; Samsung has Auto Network Switching.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果似乎称之为 Wi-Fi 助手；三星有自动网络切换。
- en: Years ago, mobile data connections were very expensive, so the connection was
    often closed after a specific upload or download happened. The opening and closing
    of connections was more dynamic and needed automatic controls.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，移动数据连接非常昂贵，因此一旦发生特定的上传或下载，连接通常会关闭。连接的开启和关闭更加动态，需要自动控制。
- en: At any rate, `QtConfigurationManager` will use what the system supports; it
    does not implement its own connection data migration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，`QtConfigurationManager` 将使用系统支持的功能；它不会实现自己的连接数据迁移。
- en: 'Qt has the following three main classes that make up Bearer Management:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 有以下三个主要类构成了承载管理：
- en: '`QNetworkConfiguration`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkConfiguration`'
- en: '`QNetworkConfigurationManager`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkConfigurationManager`'
- en: '`QNetworkSession`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkSession`'
- en: There is also `QBearerEngine`, which is the base class for bearer plugins.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 `QBearerEngine`，它是承载插件的基类。
- en: QNetworkConfiguration
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkConfiguration
- en: '`QNetworkConfiguration` represents a network connection configuration, such
    as a Wi-Fi connection to a particular access point with its **Service Set Identifier**
    (**SSID**) as the configuration name.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkConfiguration` 表示一个网络连接配置，例如连接到特定接入点的 Wi-Fi，其 **服务集标识符**（**SSID**）作为配置名称。'
- en: 'The network configuration can be one of the following types:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 网络配置可以是以下类型之一：
- en: '`QNetworkConfiguration::InternetAccessPoint`:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkConfiguration::InternetAccessPoint`:'
- en: This type is a typical access point, such as a Wi-Fi **Access Point** (**AP**)
    or it could represent an Ethernet or mobile network.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种类型是一个典型的接入点，例如 Wi-Fi **接入点**（**AP**）或它可能代表以太网或移动网络。
- en: '`QNetworkConfiguration::ServiceNetwork`:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkConfiguration::ServiceNetwork`:'
- en: A `ServiceNetwork` type is a group of access points known as a **Service Network
    Access Point** (**SNAP**). The system will determine which of the service networks
    is best to connect with based on criteria such as cost, speed, and availability.
    A configuration of the `QNetworkConfiguration::ServiceNetwork` type may also roam
    between its children `QNetworkConfiguration::InternetAccessPoint`.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceNetwork` 类型是一组称为 **服务网络接入点**（**SNAP**）的接入点。系统将根据成本、速度和可用性等标准确定连接到哪个服务网络最好。`QNetworkConfiguration::ServiceNetwork`
    类型的配置也可能在其子 `QNetworkConfiguration::InternetAccessPoint` 之间漫游。'
- en: '`QNetworkConfiguration::UserChoice`:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QNetworkConfiguration::UserChoice`:'
- en: This type can represent a user preferred configuration. It was used by Nokia's
    Maemo and Symbian platforms in which the system could pop up a dialog asking the
    user to choose which AP was best. None of the current bearer backends use this
    type of `QNetworkConfiguration`.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此类型可以表示用户首选的配置。它曾被诺基亚的Maemo和Symbian平台使用，其中系统可以弹出一个对话框询问用户哪个AP最好。当前的所有承载后端都不使用这种类型的`QNetworkConfiguration`。
- en: Often, we need to know the type of bearer, which is to say, what communication
    protocol the connection is using. Let's find out about `BearerType`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要知道承载类型，也就是说，连接使用的是哪种通信协议。让我们了解一下`BearerType`。
- en: QNetworkConfiguration::BearerType
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkConfiguration::BearerType
- en: 'This is an `enum` that specifies what the underlying technology of `QNetworkConfiguration`
    is and can be one of the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`enum`，指定了`QNetworkConfiguration`的底层技术，可以是以下之一：
- en: '`BearerEthernet`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BearerEthernet`'
- en: '`BearerWLAN`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BearerWLAN`'
- en: '`Bearer2G`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bearer2G`'
- en: '`BearerCDMA2000`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BearerCDMA2000`'
- en: '`BearerWCDMA`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BearerWCDMA`'
- en: '`BearerHSPA`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BearerHSPA`'
- en: '`BearerBluetooth`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BearerBluetooth`'
- en: '`BearerWiMAX`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BearerWiMAX`'
- en: '`BearerEVDO`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BearerEVDO`'
- en: '`BearerLTE`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BearerLTE`'
- en: '`Bearer3G`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bearer3G`'
- en: '`Bearer4G`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bearer4G`'
- en: 'This can be determined by calling the `bearerType()` function of the `QNetworkConfiguration`
    object, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过调用`QNetworkConfiguration`对象的`bearerType()`函数来确定，如下所示：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can open or connect.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开或连接。
- en: QNetworkConfiguration::StateFlags
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkConfiguration::StateFlags
- en: '`StateFlags` are an OR''d `||`,combination of the `StateFlag` values, which
    are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateFlags`是`StateFlag`值的OR''d `||`组合，如下所示：'
- en: '`Defined`: Known to the system but not yet configured'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Defined`: 已知于系统但尚未配置'
- en: '`Discovered`: Known and configured, can be used to `open()`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Discovered`: 已知并配置，可用于`open()`'
- en: '`Active`: Currently online'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Active`: 当前在线'
- en: 'A `QNetworkConfiguration` that has an `Active` flag will also have the `Discovered`
    and `Defined` flags as well. You can check to see whether a configuration is active
    by doing this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有`Active`标志的`QNetworkConfiguration`也将具有`Discovered`和`Defined`标志。你可以通过以下方式检查配置是否处于活动状态：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: QNetworkConfigurationManager
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkConfigurationManager
- en: '`QNetworkConfigurationManager` allows you to obtain `QNetworkConfigurations`
    of the system, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkConfigurationManager`允许你获取系统的`QNetworkConfigurations`，如下所示：'
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It's always wise to wait for the `updateCompleted` signal from `QNetworkConfigurationManager`
    before using it, to be sure the configurations are set up properly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用它之前，总是明智的等待`QNetworkConfigurationManager`的`updateCompleted`信号，以确保配置已正确设置。
- en: A default configuration is the configuration that the system defines as the
    default. It could have a state of `Active` or just `Discovered`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置是系统定义的默认配置。它可能处于`Active`状态或只是`Discovered`状态。
- en: If you need to simply determine whether the system is currently online, `manager->isOnline();`
    will return `true` if the system is considered online. Online is when it is connected
    to another device via a network, which may or may nor be the internet, and may
    or may not be routed correctly. So, it could be online, but cannot access the
    internet.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要确定系统当前是否在线，`manager->isOnline();`如果系统被认为是在线的，将返回`true`。在线是指通过网络连接到另一个设备，这可能或可能不是互联网，可能或可能不是正确路由。因此，它可能是在线的，但不能访问互联网。
- en: You may need to call `updateConfigurations()`, which will ask the system to
    update the list of configurations, and then you need to listen for the `updateCompleted`
    signal before proceeding.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要调用`updateConfigurations()`，这将要求系统更新配置列表，然后你需要监听`updateCompleted`信号才能继续。
- en: You can get all configurations known to the system with a call to `allConfigurations()`,
    or filter it to the ones that have a certain state with `allConfigurations(QNetworkConfiguration::Discovered);`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`allConfigurations()`获取系统已知的所有配置，或者通过`allConfigurations(QNetworkConfiguration::Discovered);`过滤到具有特定状态的配置。
- en: In this case, it returns a list of `Discovered` configurations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它返回一个`Discovered`配置的列表。
- en: 'You can check the system''s capabilities with a call to `capabilities()`, which
    can be one of the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`capabilities()`来检查系统的能力，它可以是以下之一：
- en: '`CanStartAndStopInterfaces`: System allows user to start and stop connections'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanStartAndStopInterfaces`: 系统允许用户启动和停止连接'
- en: '`DirectConnectionRouting`: Connection routing is bound directly to a specified
    device interface'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DirectConnectionRouting`: 连接路由直接绑定到指定的设备接口'
- en: '`SystemSessionSupport`: System keeps connection open until all sessions are
    closed'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SystemSessionSupport`: 系统保持连接打开，直到所有会话都关闭'
- en: '`ApplicationLevelRoaming`: Apps can control roaming/migrating'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationLevelRoaming`: 应用程序可以控制漫游/迁移'
- en: '`ForcedRoaming`: System will reconnect when roaming/migrating'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForcedRoaming`：系统在漫游/迁移时将重新连接'
- en: '`DataStatics`: System provides information about transmitted and received data'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataStatics`：系统提供有关已传输和接收的数据的信息'
- en: '`NetworkSessionRequired`: System requires a session'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetworkSessionRequired`：系统需要会话'
- en: QNetworkSession
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QNetworkSession
- en: '`QNetworkSession` provides a way to start and stop connections as well as providing
    management of connection sessions. In the case of instantiating `QNetworkSession`
    with a `QNetworkConfiguration` that is a `ServiceNetwork` type, it can provide
    roaming features. On most systems, roaming will entail actually disconnecting
    and then connecting a new interface and/or connection. On others, roaming can
    be seamless and without disturbing the user''s data stream.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetworkSession`提供了一种启动和停止连接以及管理连接会话的方法。在用`QNetworkConfiguration`实例化`QNetworkSession`且该配置为`ServiceNetwork`类型时，它可以提供漫游功能。在大多数系统中，漫游将涉及实际断开连接然后连接新的接口和/或连接。在其他系统中，漫游可以是无缝的，不会干扰用户的流量。'
- en: If the capabilities of `QNetworkConfigurationManager` reports that it supports
    `CanStartAndStopInterfaces`, then you use `QNetworkSession` to `open()` (connect)
    and `stop()` (close) `QNetworkConfigurations`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`QNetworkConfigurationManager`的能力报告它支持`CanStartAndStopInterfaces`，那么您可以使用`QNetworkSession`来`open()`（连接）和`stop()`（关闭）`QNetworkConfigurations`。
- en: 'The QNAM will use `QNetworkSession` when making network requests behind the
    scenes. You can use `QNetworkSession` to monitor the connection as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: QNAM在幕后进行网络请求时会使用`QNetworkSession`。您可以使用`QNetworkSession`如下监控连接：
- en: The source code can be found on the Git repository under the `Chapter05-3` directory,
    in the `cp5` branch.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter05-3`目录下的`cp5`分支中找到。
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To monitor bytes received and sent from a QNAM request, connect up to the `bytesReceived`
    and `bytesWritten` signals, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要监控从QNAM请求接收和发送的字节，连接到`bytesReceived`和`bytesWritten`信号，如下所示：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Roaming
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫游
- en: By roaming, I mean roaming between Wi-Fi and mobile data, not roaming as in
    out of the home network, which can be very expensive mobile data to use.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我提到漫游时，我指的是在Wi-Fi和移动数据之间的漫游，而不是在家庭网络之外漫游，这可能是一个非常昂贵的移动数据使用。
- en: In order to facilitate roaming, a client app can connect to the `preferredConfigurationChanged`
    signal and then begin the process by calling `migrate()` or cancel it by calling
    `ignore()`. Migrating a connection could be as simple as pausing the download,
    disconnecting and reconnecting to the new connection, and then resuming the download.
    This method is called forced roaming. It can, on some platforms, seamlessly migrate
    the data stream to the new connection, similar to what a mobile phone does when
    a call gets migrated to another cell tower.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便漫游，客户端应用可以连接到`preferredConfigurationChanged`信号，然后通过调用`migrate()`开始漫游过程，或者通过调用`ignore()`取消漫游。迁移连接可能就像暂停下载、断开连接并重新连接到新连接，然后继续下载一样简单。这种方法被称为强制漫游。在某些平台上，它可以将数据流无缝迁移到新连接，类似于手机在通话迁移到另一个基站时的操作。
- en: At this time, there are no currently supported backends that support migrating
    sessions. A system integrator could implement a backend that does true connection
    migration and handovers. It would also help if the system allows this.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有支持迁移会话的后端。系统集成商可以实现一个支持真正连接迁移和切换的后端。如果系统允许这样做，那也会有所帮助。
- en: That said, both Samsung's Android and iOS support roaming features seem to have
    caught up to where Nokia was years ago. Samsung calls it Adaptive Wi-Fi, previously
    known as Smart Network Switch. iOS calls it Wi-Fi Assist. These happen at the
    system level and allow roaming between Wi-Fi and mobile data connections. Neither
    of these platforms allows applications to control the handover.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，三星的Android和iOS的漫游功能似乎已经赶上了几年前诺基亚的水平。三星称之为自适应Wi-Fi，之前被称为智能网络切换。iOS称之为Wi-Fi
    Assist。这些都是在系统级别发生的，允许在Wi-Fi和移动数据连接之间漫游。这两个平台都不允许应用程序控制切换。
- en: QBearerEngine
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QBearerEngine
- en: 'Qt comes with the following bearer backend plugins based off of the `QBearerEngine`
    class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Qt基于`QBearerEngine`类提供了以下承载后端插件：
- en: '`Android`: Android'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Android`：Android'
- en: '`Connman`: Linux desktop & embedded, SailfishOS'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connman`：Linux桌面和嵌入式，SailfishOS'
- en: '`Corewlan`: Mac OS and iOS'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Corewlan`：Mac OS和iOS'
- en: '`Generic`: All'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Generic`：所有'
- en: '`NativeWifi`: Windows'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NativeWifi`：Windows'
- en: '`NetworkManager`: Linux'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetworkManager`：Linux'
- en: '`NLA`: Windows'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NLA`：Windows'
- en: Depending on the platform, some of these work in conjunction with the generic
    backend.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 根据平台的不同，其中一些与通用后端协同工作。
- en: Low level – of sockets and servers
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级 – 网络套接字和服务器
- en: '`QTcpSocket` and `QTcpServer` are two classes for sockets used in Qt. They
    work in much the same way as your web browser and a WWW server. These connect
    to a network address host, whereas `QLocalSocket` and `QLocalServer` connect to
    a local file descriptor.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTcpSocket` 和 `QTcpServer` 是 Qt 中用于套接字的两个类。它们的工作方式与你的网络浏览器和 WWW 服务器非常相似。它们连接到网络地址主机，而
    `QLocalSocket` 和 `QLocalServer` 连接到本地文件描述符。'
- en: Let's look at `QLocalServer` and `QLocalSocket` first.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `QLocalServer` 和 `QLocalSocket`。
- en: 'In socket server programming, the basic procedure is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字服务器编程中，基本步骤如下：
- en: Create a socket
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建套接字
- en: Set socket options
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置套接字选项
- en: Bind a socket address
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定套接字地址
- en: Listen for connections
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听连接
- en: Accept new connection
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受新连接
- en: 'Qt simplifies these steps to the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 将这些步骤简化为以下步骤：
- en: Create a socket
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建套接字
- en: Listen for connections
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听连接
- en: Accept new connection
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受新连接
- en: QLocalServer
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QLocalServer
- en: If you need communication on the same machine, then `QLocalServer` will be slightly
    more performant than using a TCP-based socket server. It can be used for **Inter-process
    communication** (**IPC**).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在同一台机器上进行通信，那么 `QLocalServer` 将比使用基于 TCP 的套接字服务器稍微高效一些。它可以用于 **进程间通信**
    (**IPC**)。
- en: First, we create the server, and then call the `listen` function with a string
    name that clients use to connect. We hook up to the `newConnection` signal, so
    we know when a new client connects.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建服务器，然后使用客户端用于连接的字符串名称调用 `listen` 函数。我们将连接到 `newConnection` 信号，这样我们就能知道何时有新的客户端连接。
- en: The source code can be found on the Git repository under the `Chapter05-5a`
    directory, in the `cp5` branch.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter05-5a` 目录下的 `cp5` 分支中找到。
- en: 'When a client tries to connect, we then send a small message using the `write`
    function, and finally `flush` the message, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端尝试连接时，我们使用 `write` 函数发送一条小消息，最后使用 `flush` 发送消息，如下所示：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It's that simple! Anytime you need to write to the client, simply use `nextPendingConnection()`
    to get the next `QLocalSocket` object and use `write` to send the data. Be sure
    to add `\r\n` to all lines you need to send, including the last line. The call
    to `flush()` is not required, but it sends the data immediately.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！任何时候你需要向客户端写入，只需使用 `nextPendingConnection()` 获取下一个 `QLocalSocket` 对象，并使用
    `write` 发送数据。确保在所有需要发送的行中添加 `\r\n`，包括最后一行。调用 `flush()` 不是必需的，但它会立即发送数据。
- en: You can keep this object around to send more messages when needed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以保留这个对象，以便在需要时发送更多消息。
- en: Our app is now waiting and listening for connections. Let's do that next.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在正在等待并监听连接。让我们接下来做这件事。
- en: QLocalSocket
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QLocalSocket
- en: '`QLocalSocket` is used to communicate with `QLocalServer`. You will want to
    connect to the `readyRead` signal. Other signals are `connected()`, `disconnected()`,
    `error(...)`, and `stateChanged(...)`, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLocalSocket` 用于与 `QLocalServer` 通信。你将想要连接到 `readyRead` 信号。其他信号包括 `connected()`、`disconnected()`、`error(...)`
    和 `stateChanged(...)`，如下所示：'
- en: The source code can be found on the Git repository under the `Chapter05-5b`
    directory, in the `cp5` branch.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter05-5b` 目录下的 `cp5` 分支中找到。
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you need state changes, you connect to `stateChanged` and will be notified
    when the following states change:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要状态变化，你将连接到 `stateChanged`，并且会在以下状态变化时收到通知：
- en: '`UnconnectedState`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnconnectedState`'
- en: '`ConnectingState`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectingState`'
- en: '`ConnectedState`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectedState`'
- en: '`ClosingState`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClosingState`'
- en: 'Now, we need to actually connect to the server, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实际连接到服务器，如下所示：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Like `QLocalServer`, `QLocalSocket` uses the `write` function to send messages
    to the server, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `QLocalServer` 类似，`QLocalSocket` 使用 `write` 函数向服务器发送消息，如下所示：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember to add the **End Of Line** (**EOL**) `\r\n` to mark the end of the
    data feed line.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 记得添加 **行结束符** (**EOL**) `\r\n` 来标记数据馈送行的结束。
- en: That is a simple local sockets based communication. Now, let's look at a TCP-based
    socket over a network.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个简单的基于本地套接字的通信。现在，让我们看看基于网络的 TCP 套接字。
- en: QTcpServer
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QTcpServer
- en: 'The `QTcpServer` API is much like `QLocalServer` and can be pretty much a drop-in
    replacement with a few small changes. Most notably, the arguments for the listen
    call are slightly different, in which you need to specify `QHostAddress` for `QTcpServer`
    instead of a `QString` name, and a port number. Here, I use `QHostAddress::Any`,
    which means it will listen on all network interfaces. If you don''t care about
    which port is used, set it to `0` as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTcpServer` API与`QLocalServer`非常相似，几乎可以无缝替换，只需进行一些小的更改。最值得注意的是，监听调用的参数略有不同，你需要为`QTcpServer`指定`QHostAddress`而不是`QString`名称和一个端口号。在这里，我使用`QHostAddress::Any`，这意味着它将在所有网络接口上监听。如果你不关心使用哪个端口，将其设置为`0`，如下所示：'
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Does it look familiar? `QHostAddress` can be an IPv4 or IPv6 address. You can
    also specify different ranges of address by using the `QHostAddress::SpecialAddress`
    `enum` as I did, which can be one of the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来熟悉吗？`QHostAddress`可以是IPv4或IPv6地址。你也可以通过使用`QHostAddress::SpecialAddress`
    `枚举`来指定不同的地址范围，就像我这样做的一样，它可以有以下之一：
- en: '`LocalHost`: `127.0.0.1`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalHost`: `127.0.0.1`'
- en: '`LocalHostIPv6`: `::1`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalHostIPv6`: `::1`'
- en: '`Broadcast`: `255.255.255.255`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Broadcast`: `255.255.255.255`'
- en: '`AnyIPv4`: `0.0.0.0`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnyIPv4`: `0.0.0.0`'
- en: '`AnyIPv6`: `::`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnyIPv6`: `::`'
- en: '`Any`: `all IPv4 and IPv6 addresses`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any`: `所有IPv4和IPv6地址`'
- en: '`QTcpServer` has an additional signal to `QLocalServer`—`acceptError`, which
    gets emitted when an error occurs during the accept phase of a new connection.
    You can also `pauseAccepting()` and `resumeAccepting()` the accepting of the connections
    in the pending connection queue.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTcpServer`有一个额外的信号`acceptError`，当新连接的接受阶段发生错误时会被触发。你还可以`pauseAccepting()`和`resumeAccepting()`待处理连接队列中的连接接受。'
- en: QTcpSocket
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QTcpSocket
- en: '`QTcpSocket` is similar to `QLocalSocket` as well. Except, among other things,
    `QTcpSocket` has `connectToHost` as a way to connect to a server, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTcpSocket`与`QLocalSocket`类似。除了其他方面之外，`QTcpSocket`有`connectToHost`作为连接到服务器的方式，如下所示：'
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make a simple `HTTP` request, we can write to the socket after we are connected,
    as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送一个简单的`HTTP`请求，我们可以在连接后向套接字写入，如下所示：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will request the `index.html` file from the server. The data can be read
    in the `readyRead` signal handler, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将请求服务器上的`index.html`文件。数据可以在`readyRead`信号处理程序中读取，如下所示：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also use the `waitForConnected`, `waitForBytesWritten`, and `waitForReadyRead`
    functions if you do not want to use this more synchronously, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用更同步的方式，你也可以使用`waitForConnected`、`waitForBytesWritten`和`waitForReadyRead`函数，如下所示：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, close the connection with the following command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令关闭连接：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: QSctpServer
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSctpServer
- en: '**SCTP** stands for **Stream Control Transmission Protocol**. `QSctpServer`
    sends messages as groups of bytes like UDP, rather than a stream of bytes like
    a TCP socket. It also ensures reliable delivery of the packets, like TCP. It can
    send several messages in parallel or at the same time. It does this by using several
    connections.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**SCTP**代表**流控制传输协议**。`QSctpServer`将消息作为字节数组组发送，就像UDP一样，而不是像TCP套接字一样发送字节数据流。它还确保数据包的可靠传输，就像TCP一样。它可以并行或同时发送多个消息。它是通过使用多个连接来做到这一点的。'
- en: '`QSctpServer` can also send a stream of bytes like TCP by setting `setMaximumChannelCount`
    to `-1`. The first thing you want to do after creating the `QSctpServer` object
    is `setMaximumChannelCount`. Setting this to `0` will let this use the number
    of channels that the client uses, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSctpServer`也可以通过将`setMaximumChannelCount`设置为`-1`来发送字节流，就像TCP一样。在创建`QSctpServer`对象后，你首先想要做的是`setMaximumChannelCount`。将其设置为`0`将允许它使用客户端使用的通道数，如下所示：'
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you intend to use TCP byte streams, you use the `nextPendingConnection()`
    function like `QTcpServer` to get a `QTcpSocket` object to communicate with. `QSctpServer`
    has the additional `nextPendingDatagramConnection()` to communicate with `QSctpSocket`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用TCP字节流，你可以像`QTcpServer`一样使用`nextPendingConnection()`函数来获取一个`QTcpSocket`对象进行通信。`QSctpServer`有额外的`nextPendingDatagramConnection()`来与`QSctpSocket`通信。
- en: 'To receive bytes in the `newConnection` signal handler, use the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`newConnection`信号处理程序中接收字节，请使用以下代码：
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: QSctpSocket
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSctpSocket
- en: '`QSctpSocket` also has controls for channel count, and as with `QSctpServer`,
    if you set the maximum channel count to `-1`, it will behave more like TCP sockets
    and send a data stream instead of message packets. The message blob is called
    a `datagram`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSctpSocket`也有对通道数的控制，并且与`QSctpServer`一样，如果你将最大通道数设置为`-1`，它将表现得更像TCP套接字，发送数据流而不是消息包。消息块被称为`datagram`。'
- en: To read and write these datagrams, use `readDatagram()` and `writeDatagram()`.
    Let's examine `QNetworkDatagram`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取和写入这些数据报，请使用 `readDatagram()` 和 `writeDatagram()`。让我们来检查 `QNetworkDatagram`。
- en: 'To construct `QNetworkDatagram`, you need a `QByteArray` that holds the data
    message, a `QHostAddress` for the destination, and optionally, a port number.
    It can be as simple as the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 `QNetworkDatagram`，您需要一个包含数据消息的 `QByteArray`，一个目标 `QHostAddress`，以及可选的端口号。它可以像以下这样简单：
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will send the `"Hello Mobile!"` message to the corresponding server.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发送 `"Hello Mobile!"` 消息到相应的服务器。
- en: QUdpSocket
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QUdpSocket
- en: '`QUdpSocket` sends datagrams such as `QSctpSocket`, but they are not reliable,
    which means it will not retry to send any datagrams. It is also connectionless
    and has a restriction on data length of 65,536 bytes.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`QUdpSocket` 发送数据报，例如 `QSctpSocket`，但它们是不可靠的，这意味着它不会重试发送任何数据报。它也是无连接的，并且对数据长度有
    65,536 字节的限制。'
- en: There are two ways to set up `QUdpSocket`—`bind(...)` and `connectToHost(...)`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `QUdpSocket` 有两种方式——`bind(...)` 和 `connectToHost(...)`。
- en: 'If you use `connectToHost`, you can use `QIODevice` `read()`, `write()`, `readAll()`
    to send and receive datagrams. Using the `bind(...)` method, you need to use `readDatagram`
    and `writeDatagram` instead, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `connectToHost`，您可以使用 `QIODevice` 的 `read()`、`write()`、`readAll()` 方法来发送和接收数据报。使用
    `bind(...)` 方法，您需要使用 `readDatagram` 和 `writeDatagram`，如下所示：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: QSslSocket
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSslSocket
- en: 'Encrypted socket communications can be handled by `QSslSocket`, which uses
    SSL to encrypt the TCP connection. The encrypted signal is emitted when the connection
    is secured, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 加密套接字通信可以通过 `QSslSocket` 处理，它使用 SSL 加密 TCP 连接。当连接安全时，将发出加密信号，如下所示：
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The source code can be found on the Git repository under the `Chapter05-6a`
    directory, in the `cp5` branch.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter05-6a` 目录下的 `cp5` 分支中找到。
- en: This will start the connection and immediately start the secure handshake procedure.
    Once the handshake is finished with no error, the encrypted signal will be emitted
    and the connection will be ready.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动连接并立即开始安全的握手过程。一旦握手完成且没有错误，将发出加密信号，连接将准备就绪。
- en: 'You will need to add key/certificate pair to `QSslSocket` to utilize the encryption
    capabilities. You can easily generate key-certificate fail pair for testing by
    using this web site: [https://www.selfsignedcertificate.com/](https://www.selfsignedcertificate.com/).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将密钥/证书对添加到 `QSslSocket` 以利用加密功能。您可以通过使用此网站轻松生成密钥证书失败对进行测试：[https://www.selfsignedcertificate.com/](https://www.selfsignedcertificate.com/)。
- en: 'Because we are using a self-signed certificate, we will need to add `ignoreSslErrors`
    in our error handling slot:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是自签名证书，因此我们需要在错误处理槽中添加 `ignoreSslErrors`：
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To add the encryption key and certificate, you need to open and read both files,
    and use the resulting `QByteArrays` to create `QSslKey` and `QSslCertificate`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加加密密钥和证书，您需要打开并读取这两个文件，并使用生成的 `QByteArrays` 创建 `QSslKey` 和 `QSslCertificate`：
- en: '[PRE43]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When you run this code, you will need to use `QFileDialog` to navigate and find
    the `localhost.key` and `localhost.cert` files in the source directory.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，您需要使用 `QFileDialog` 导航并找到源目录中的 `localhost.key` 和 `localhost.cert` 文件。
- en: Then, we use `setPrivateKey` to set the key file, and `addCaCertificate` and
    `setLocalCertificate` to add the certificate.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `setPrivateKey` 来设置密钥文件，并使用 `addCaCertificate` 和 `setLocalCertificate`
    来添加证书。
- en: To read from the socket, you can connect to the `readReady` signal like in `QTcpSocket`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要从套接字读取，您可以连接到 `readReady` 信号，就像在 `QTcpSocket` 中一样。
- en: 'To write to the socket, which transmits to the server, simply use the `write`
    function:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要向服务器发送的套接字写入，只需使用 `write` 函数：
- en: '[PRE44]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can then use `QSslSocket` to connect to `QTcpServer` that opens `QSslSocket`.
    This brings us to our next step.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `QSslSocket` 连接到打开 `QSslSocket` 的 `QTcpServer`。这带我们到下一步。
- en: QSslServer
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSslServer
- en: Ok, there is no `QSslServer` class, but since the `QSslSocket` class is just
    derived from `QTcpSocket` with some extra SSL stuff on top, you can create your
    own SSL server using the functions from `QSslSocket`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没有 `QSslServer` 类，但由于 `QSslSocket` 类只是从 `QTcpSocket` 派生而来，并在其顶部添加了一些额外的 SSL
    功能，您可以使用 `QSslSocket` 的函数创建自己的 SSL 服务器。
- en: 'You will need to generate SSL key and certificates. If they are self-signed,
    the same rules apply, in which we need to set the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要生成 SSL 密钥和证书。如果它们是自签名的，同样适用以下规则，我们需要设置以下内容：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can create an SSL server by subclassing `QTcpServer` and overriding `incomingConnection()`
    ,as follows.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过继承 `QTcpServer` 并重写 `incomingConnection()` 方法来创建一个 SSL 服务器，如下所示。
- en: The source code can be found on the Git repository under the `Chapter05-6` directory,
    in the `cp5` branch.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter05-6` 目录下的 `cp5` 分支中找到。
- en: 'We implement the `header` file with the `override` function, as well as a slot
    to connect to when the server changes into encrypted mode:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `override` 函数实现 `header` 文件，以及一个在服务器进入加密模式时连接的槽：
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the implementation of the SSL server class, pay attention to the call to
    `startServerEncryption()`. This will initiate the encryption of the `server` channels
    and create a `Server`, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SSL 服务器类的实现中，请注意对 `startServerEncryption()` 的调用。这将启动 `server` 通道的加密并创建一个 `Server`，如下所示：
- en: '[PRE47]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We also need to add the encruption key and certificate, as this uses `QSslSocket`
    like in the last section, *QSslSocket*:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加加密密钥和证书，因为这与上一节中的 `QSslSocket` 类似，*QSslSocket*：
- en: '[PRE48]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we connect to the `QSslSocket` `encrypted` signal, which signals when `QSslSocket`
    enters encrypted mode. From then on, all bytes sent or received are encrypted.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们连接到 `QSslSocket` 的 `encrypted` 信号，该信号在 `QSslSocket` 进入加密模式时发出。从那时起，所有发送或接收的字节都将被加密。
- en: 'Errors are handled by connecting to the `sslErrors(const QList<QSslError> &errors)`
    signal:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 错误通过连接到 `sslErrors(const QList<QSslError> &errors)` 信号来处理：
- en: '[PRE49]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also need to connect to the `QAbstractSocket::socketError` signal to handle
    those errors as well:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要连接到 `QAbstractSocket::socketError` 信号来处理这些错误：
- en: '[PRE50]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Other signals you will also want to connect to are the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你还希望连接的其他信号如下：
- en: '`QSslSocket::connected`'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSslSocket::connected`'
- en: '`QSslSocket::disconnected`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSslSocket::disconnected`'
- en: '`QSslSocket::encrypted`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSslSocket::encrypted`'
- en: '`QSslSocket::modeChanged`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSslSocket::modeChanged`'
- en: '`QSslSocket::stateChanged`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSslSocket::stateChanged`'
- en: Up till now, we have been using local IP addresses, but what happens when the
    server is remote and we need not just the server name, but it's IP address? Let's
    explore how we can use Qt to do domain name lookups.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用本地 IP 地址，但当服务器是远程的，我们不仅需要服务器名，还需要它的 IP 地址时会发生什么？让我们探索我们如何使用 Qt
    来执行域名查找。
- en: Lookups – look me up
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找——查找我
- en: Computer networks such as the internet rely on **Domain Name Service** (**DNS**)
    lookups. This is usually done on remote central servers, but can also be used
    locally.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机网络，如互联网，依赖于 **域名服务** (**DNS**) 查找。这通常在远程中央服务器上完成，但也可以在本地使用。
- en: There are two classes for doing network lookups—`QDnsLookup` and `QHostInfo`.
    `QHostInfo` will provide simple IP address lookups for a hostname. It is really
    just looking up an IP address using a hostname. Let's look at how we can use this.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个类用于执行网络查找——`QDnsLookup` 和 `QHostInfo`。`QHostInfo` 将为主机名提供简单的 IP 地址查找。这实际上只是使用主机名查找
    IP 地址。让我们看看我们如何使用它。
- en: QHostInfo
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QHostInfo
- en: '`QHostInfo` is a simple class to do address lookups provided by the platform
    system. It has synchronous, blocking method for lookup, or you can use signal/slots,
    as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`QHostInfo` 是平台系统提供的一个简单的用于地址查找的类。它有同步、阻塞的查找方法，或者你可以使用信号/槽，如下所示：'
- en: '[PRE51]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This method blocks until a response is received.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法会阻塞，直到收到响应。
- en: 'The `lookupHost` function does asynchronous lookups and takes a slot as an
    argument, as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookupHost` 函数执行异步查找，并接受一个槽作为参数，如下所示：'
- en: '[PRE52]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The slot we need to implement receives `QHostInfo` as an argument, as such:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的槽接收 `QHostInfo` 作为参数，如下所示：
- en: '[PRE53]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To get an address from either of these responses, do something like the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要从这些响应中的任何一个获取地址，可以执行如下操作：
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Let's now proceed to `QDnsLookup`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续到 `QDnsLookup`。
- en: QDnsLookup
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QDnsLookup
- en: '`QDnsLookup` can look up different types of records, not just IP addresses.
    The values you can use to set the type of lookup are as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDnsLookup` 可以查找不同类型的记录，而不仅仅是 IP 地址。你可以使用的值来设置查找类型如下：'
- en: '`A`: IPv4 addresses, access with `hostAddressRecords()`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A`: IPv4 地址，通过 `hostAddressRecords()` 访问'
- en: '`AAAA`: IPv6 addresses, access with `hostAddressRecords()`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAAA`: IPv6 地址，通过 `hostAddressRecords()` 访问'
- en: '`ANY`: Any record'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANY`: 任何记录'
- en: '`CNAME`: Canonical name, access with `canonicalNameRecords()`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CNAME`: 规范名称，通过 `canonicalNameRecords()` 访问'
- en: '`MX`: Mail exchange, access with `mailExchangeRecords()`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MX`: 邮件交换，通过 `mailExchangeRecords()` 访问'
- en: '`NS`: Name server, access with `nameServerRecords()`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NS`: 名称服务器，通过 `nameServerRecords()` 访问'
- en: '`PTR`: Pointer, access with `pointerRecords()`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTR`: 指针，通过 `pointerRecords()` 访问'
- en: '`SRV`: Service, access with `serviceRecords()`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRV`: 服务，通过 `serviceRecords()` 访问'
- en: '`TXT`: Text, access with `textRecords()`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TXT`: 文本，通过 `textRecords()` 访问'
- en: 'Let''s look at how this can be implemented. We connect the `QDnsLookup` signal
    named `finished` to our `lookupFinished` slot. We set the type here to `TXT` to
    access text records:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这一点。我们将名为`finished`的`QDnsLookup`信号连接到我们的`lookupFinished`槽。我们将类型设置为`TXT`以访问文本记录：
- en: '[PRE55]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The call to `lookup()` will start a lookup of the text records for the name
    that we set, which is `example.com`. We still need to handle the response, as
    follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 对`lookup()`的调用将开始对设置的名称`example.com`的文本记录进行查找。我们仍然需要处理响应，如下所示：
- en: '[PRE56]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can then use these records in the manner you need.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以按需使用这些记录。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: '`QNetwork` is quite extensive in what it can do. I have touched upon a few
    features, such as `QNetworkRequest`, `QNetworkAccessManager`, and `QNetworkReply`
    to make network requests, such as `get` and `put`. You can use Qt''s Bearer Management
    features to control the online state and `QNetworkSession` to group connections
    together to roam between connections. We discussed socket development with `QLocalSocket`,
    `QLocalServer`, `QTcpSocket`, and `QTcpServer`. You can perform host and DNS lookups
    with `QHostInfo` and `QDnsLookup`.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNetwork`的功能非常广泛。我已经提到了一些特性，例如`QNetworkRequest`、`QNetworkAccessManager`和`QNetworkReply`，它们用于发起网络请求，如`get`和`put`。你可以使用Qt的承载管理功能来控制在线状态，以及使用`QNetworkSession`将连接分组在一起，以便在连接之间漫游。我们讨论了使用`QLocalSocket`、`QLocalServer`、`QTcpSocket`和`QTcpServer`进行套接字开发。你可以使用`QHostInfo`和`QDnsLookup`进行主机和DNS查找。'
- en: Connectivity can mean a few things, and in the next chapter, we explore connectivity
    using Bluetooth **Low Energy** (**LE**).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 连接性可以意味着几件事情，在下一章中，我们将探讨使用蓝牙**低功耗**（**LE**）进行连接性。
