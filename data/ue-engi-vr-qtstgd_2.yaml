- en: Locomotion, Design, and Starting Our Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动、设计和启动我们的项目
- en: With our knowledge of the current state of VR technology and game development,
    we may now begin working on our first title. As we mentioned in [Chapter 1](926e8e71-f556-43b2-b4f8-47dc017c7a38.xhtml), *Introducing
    VR Technology in Unreal Engine 4*, *Server 17* puts the player in the role of
    an intrepid hacker in search of the truth in a corrupt dystopian future. Everyone
    has secrets, and some will pay big sums of money for the secrets of others. In
    design terms, this means we're going to create a puzzle game in which the player
    solves puzzles and uses different tools to crack open different puzzle boxes that
    represent computer servers on a network. Through the building of this simple game,
    we'll address all of the steps of VR game design with the goal of arming you with
    the tools and know-how to begin work on your own title. The first step in the
    process is design and, for that, I always turn to the Human-Centered Design process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们对当前VR技术和游戏开发的了解，我们现在可以开始着手我们的第一个项目。正如我们在[第1章](926e8e71-f556-43b2-b4f8-47dc017c7a38.xhtml)，“在虚幻引擎4中引入VR技术”，*Server
    17*让玩家扮演一位勇敢的黑客，在一个腐败的反乌托邦未来中寻找真相。每个人都有秘密，有些人愿意支付大笔金钱来换取他人的秘密。从设计角度来看，这意味着我们将创造一个解谜游戏，玩家需要解决谜题并使用不同的工具打开代表网络中计算机服务器的不同谜盒。通过构建这个简单的游戏，我们将涵盖VR游戏设计的所有步骤，目标是为你提供工具和知识，以便开始你自己的项目。这个过程的第一步是设计，为此，我总是转向以人为中心的设计过程。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Human-Centered Design process
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以人为中心的设计过程
- en: Choosing our locomotion method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择我们的移动方式
- en: Setting up new game files in Unreal Engine 4
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中设置新的游戏文件
- en: Project setup
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置
- en: The Human-Centered Design process
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以人为中心的设计过程
- en: The **Human-Centered Design** (**HCD**) process is a flexible set of design
    principles that allows for the design of pretty much anything, from shoes, to
    cars, to software. Central to HCD is the principle that the designer is thinking
    of the end user at every step of the way. Would this decision make the product
    better for my user? Would making the color customizable delight my user and make
    them more likely to use my product? By asking these questions and thinking about
    your user, you're able to create a design that's more likely to be a success with
    its target audience.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**以人为中心的设计**（**HCD**）过程是一套灵活的设计原则，允许设计几乎任何东西，从鞋子到汽车，再到软件。HCD的核心原则是设计师在每一步都考虑最终用户。这个决定是否会让我用户的产品变得更好？让颜色可定制是否会让我用户感到高兴，并使他们更有可能使用我的产品？通过提出这些问题并考虑你的用户，你能够创造出一个更有可能在其目标受众中取得成功的设计。'
- en: 'The HCD process has the following steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以人为中心的设计过程有以下步骤：
- en: '![](img/e4b8cc87-48ca-43dc-9a12-063009a6456e.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4b8cc87-48ca-43dc-9a12-063009a6456e.png)'
- en: The HCD process
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以人为中心的设计过程
- en: '**Discovery**: In this, we research the problem we''re presented with and the
    target demographic interested in our solution. We search to see whether this is
    something that someone has attempted to solve before and if so what they tried.
    We reach out to our potential users to find people who will talk to us so we can
    discover what they need from a solution.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发现**：在这个阶段，我们研究我们面临的问题和感兴趣的目标受众。我们搜索看看是否有人尝试过解决这个问题，如果是的话，他们尝试了什么。我们联系潜在用户，找到愿意与我们交谈的人，以便发现他们从解决方案中需要什么。'
- en: '**Empathy**: Here, we speak with as many potential users as possible to gather
    what they''re looking for in a solution. We want to dig deep. Why is this something
    they want or need? Are there any connections back to a memory or an emotion? For
    example, nostalgia is a powerful longing for experiences related to a person''s
    youth. It''s also one of the strongest emotions that game developers like to touch
    on.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**同理心**：在这里，我们尽可能多地与潜在用户交谈，以收集他们在解决方案中寻找的东西。我们想要深入挖掘。为什么他们想要或需要这个？是否有任何与记忆或情感的关联？例如，怀旧是对与一个人青年时期相关的经历的强烈渴望。它也是游戏开发者喜欢触及的最强烈的情感之一。'
- en: '**Ideate**: Once we know what our user wants, it''s time to brainstorm! When
    we ideate, we want to come up with as many ideas as possible. No idea is too out
    there or crazy (as long as it benefits our user).'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创意**：一旦我们知道用户想要什么，就是时候进行头脑风暴了！当我们进行创意时，我们希望尽可能多地提出想法。没有哪个想法太离谱或疯狂（只要它有利于我们的用户）。'
- en: '**Prototype**: Once we settle on an idea, we want to build a quick and easy
    version to allow our user to try it. No fancy programming or incredible art here—we
    want to create a playable version of our game, quickly and cheaply.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原型**：一旦我们确定了一个想法，我们希望快速简单地构建一个版本，让我们的用户尝试。这里没有复杂的编程或惊人的艺术——我们希望快速且低成本地创建一个可玩的游戏版本。'
- en: '**Test**: Put the prototype in front of the user and record the results! It''s
    often at this point that a product may fail. This might be caused by a problem
    with the design or something that the user didn''t understand or like. Record
    the data and learn from it!'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试**：将原型放在用户面前并记录结果！通常在这个时候，产品可能会失败。这可能是由于设计问题或用户不理解或不喜欢的某些内容。记录数据并从中学习！'
- en: '**Refine**: With the user test data in hand, we go back to the ideate phase
    and try again. You''ll likely go through this cycle several times before your
    game is complete, but if you''re checking in with your user regularly and getting
    feedback from other designers and friends, you''ll surely come up with the next
    killer app.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**精炼**：手头有了用户测试数据后，我们回到构思阶段并再次尝试。在你完成游戏之前，你可能需要经历几次这样的循环，但如果你定期与用户沟通并从其他设计师和朋友们那里获得反馈，你肯定能想出下一个杀手级应用。'
- en: 'For *Server 17*, our ideal user is someone who has never experienced VR before.
    They''re interested in a simple, yet very immersive experience that leverages
    the unique abilities of VR. They may be fans of cyberpunk movies such as *Tron*
    and *Tron: Legacy* and the *Shadowrun* series of games. Nostalgia may also come
    into play when they think about their first experience with a new piece of gaming
    hardware. It''s possible you have many friends who fit this profile that you can
    use as a reference while designing the game and we can also make use of online
    communities to gather further opinions. Once we''ve completed the **Discovery**
    and **Empathy** steps with a bit of research and some interviews with our user,
    we''re now ready to make a few design decisions regarding locomotion, or the process
    of our player moving through our game world.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*服务器17*，我们理想的用户是那些从未体验过VR的人。他们感兴趣的是简单但非常沉浸式的体验，能够利用VR的独特能力。他们可能是《银翼杀手》和《银翼杀手：遗产》以及《Shadowrun》游戏系列的粉丝。当他们回想起第一次使用新游戏硬件的经历时，怀旧感也可能发挥作用。你可能有很多符合这一特征的朋友，你可以在设计游戏时作为参考，我们还可以利用在线社区来收集更多的意见。一旦我们通过一些研究和与用户的访谈完成了**发现**和**同理心**步骤，我们现在就可以就移动方式或玩家在游戏世界中移动的过程做出一些设计决策。
- en: Choosing our locomotion method
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择我们的移动方法
- en: One of our goals as VR designers is to leverage the unique advantages of this
    new technology to create novel experiences that players want to play again and
    again. The technology is fantastic for making the player feel as if they're interacting
    in a living and breathing fantasy world they would otherwise not be able to inhabit.
    Using the hand controllers, our players can touch our world and interact with
    it in a very visceral sense. However, locomotion systems still haven't caught
    up to that level of immersion yet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为VR设计师，我们的一个目标是通过利用这项新技术的独特优势来创造玩家想要反复体验的新颖体验。这项技术非常适合让玩家感觉他们正在与一个充满生机和活力的幻想世界互动，否则他们无法居住其中。使用手柄控制器，我们的玩家可以触摸我们的世界并与它进行非常直观的互动。然而，移动系统还没有达到这种沉浸感的水平。
- en: Player locomotion in VR is still in its infancy, and, as such, there's no one
    method that has been found to work well. Many methods have been tried. There are
    vehicle simulation games, where the player remains seated in a cockpit. There
    are action/adventure games where players run through a landscape using artificial
    methods such as a thumbstick or teleportation. Others attempt to maintain immersion
    by having the player stand within a small area with everything they need readily
    accessible, allowing the player to move around naturally but at the expense of
    an expansive environment. Each method of locomotion is a trade-off between giving
    the player an immersive, natural sensation and avoiding unpleasant feelings, such
    as VR sickness.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中，玩家的移动动作还处于初级阶段，因此还没有找到一种能够有效工作的方法。已经尝试了许多方法。有车辆模拟游戏，玩家保持在驾驶舱内。还有动作/冒险游戏，玩家通过使用摇杆或传送等人工方法在景观中奔跑。其他人则试图通过让玩家站在一个狭小区域内，所有必需品都触手可及，来保持沉浸感，虽然这样牺牲了广阔的环境，但允许玩家自然地移动。每种移动方法都是给予玩家沉浸感和自然感觉与避免不愉快感觉（如VR不适感）之间的权衡。
- en: During my time as a college professor, I had the opportunity to help my students
    to design a kayaking simulator for the local museum. The students devised a locomotion
    system that allowed the player to remain seated and use a paddle with an attached
    sensor to navigate their virtual craft down the river rapids. Though the system
    worked well in testing with their peers (it felt natural and worked well for me),
    we found that it had a profoundly negative affect on several of our users at the
    museum. One of our testers even had to leave work after testing our game. After
    asking the tester some questions, it was discovered that, although the paddle
    movement of our controller felt right, the realistic physics of the boat in the
    water made it impossible for them to play. Further questioning of the test group
    showed the students that this one tester wasn't the only player who had issues.
    In the end, they had to take some artistic license with the movement of the water
    to create a more enjoyable experience and learned that our user's experience and
    enjoyment was more important than realism.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我担任大学教授期间，我有机会帮助我的学生为当地博物馆设计一个皮划艇模拟器。学生们设计了一个运动系统，允许玩家保持坐姿，并使用带有传感器的桨来操纵他们的虚拟船只在河流急流中前进。尽管这个系统在与他们的同伴测试时表现良好（感觉自然且对我而言效果良好），但我们发现它对博物馆的几位用户产生了深远的不利影响。其中一位测试者甚至在测试我们的游戏后不得不离开工作。在询问测试者一些问题后，我们发现，尽管我们的控制器上的桨运动感觉正确，但水中船只的真实物理特性使得他们无法玩游戏。进一步询问测试组显示，这位测试者并不是唯一遇到问题的玩家。最后，他们不得不在水的运动上采取一些艺术上的自由，以创造一个更愉快的体验，并了解到我们的用户体验和乐趣比现实主义更重要。
- en: 'While this lack of a best practice may be concerning to some, the designer
    in us all should see this as an exciting opportunity to innovate and create new
    systems that provide our players with the best gameplay possible. The variety
    of systems can be broken down into four major categories:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种缺乏最佳实践可能会让一些人感到担忧，但我们内心的设计师应该将其视为一个令人兴奋的机会，去创新并创造新的系统，为我们的玩家提供最佳的游戏体验。这些系统可以分解为四个主要类别：
- en: Natural
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然
- en: Artificial
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工
- en: Cockpit
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驾驶舱
- en: Physical (creative)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理（创意）
- en: Natural locomotion
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自然运动
- en: 'Not to be confused with the app of the same name, natural locomotion refers
    to a method of moving within VR that minimizes VR sickness by taking natural player
    movements, such as swinging arms and jumping, into the game world. We can see
    natural locomotion at work in the game *Tribe XR* as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与同名应用程序混淆，自然运动是指一种在VR中移动的方法，通过将自然玩家动作（如挥动手臂和跳跃）带入游戏世界来最小化VR不适。我们可以在游戏 *Tribe
    XR* 中看到自然运动的工作方式如下：
- en: '![](img/8db7f30c-fc76-412a-9dd0-8ec572963672.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8db7f30c-fc76-412a-9dd0-8ec572963672.png)'
- en: Tribe XR is an up and coming DJ app that can teach you how to mix music with
    in-game lessons
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Tribe XR 是一个新兴的DJ应用程序，可以通过游戏中的课程教你如何混音音乐
- en: This covers a variety of methods, but all seem to provide the player with a
    direct translation of their movement into player movement in the game. Though
    this method has been shown to limit player discomfort, it isn't without its drawbacks.
    This approach limits the player to the space covered by their system's sensors
    and requires designers to design with this in mind. This can mean designing the
    level specifically around the average playspace size and making sure that everything
    the player needs is well within reach. This method has been used in such games
    as *Job Simulator*, *Tribe VR*, and *Waltz of the Wizard*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了各种方法，但所有方法似乎都为玩家提供了将他们的动作直接转换为游戏中的玩家动作的直接翻译。尽管这种方法已被证明可以限制玩家的不适，但它并非没有缺点。这种方法限制了玩家只能在他们系统传感器的覆盖范围内移动，并要求设计师考虑到这一点进行设计。这可能意味着专门设计关卡以适应平均游戏空间大小，并确保玩家所需的一切都在可触及范围内。这种方法已在诸如
    *Job Simulator*、*Tribe VR* 和 *Waltz of the Wizard* 等游戏中使用。
- en: Artificial locomotion
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工运动
- en: Artificial locomotion is essentially the opposite of natural locomotion. This
    technique relies on more traditional game controls such as thumbsticks, touch
    pads, and other input methods to move the player around our game levels.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 人工运动基本上是自然运动的相反。这种技术依赖于更传统的游戏控制方式，如摇杆、触摸板和其他输入方法，以在游戏关卡中移动玩家。
- en: Despite being the best locomotion when porting traditional titles to VR (think
    *Skyrim VR* and *Fallout 4 VR*), artificial locomotion has the greatest chance
    of causing VR sickness due to vexation, or the disconnect between what our eyes
    are seeing and what the rest of the senses are experiencing. There are several
    techniques we can use to minimize this vexation. One way is to dynamically decrease
    the player's field of view while they're moving. This creates a very subtle effect
    that hides some of the player's peripheral vision when they're moving or turning.
    Another is to have the player accelerate at a consistent rate during movement.
    Consistent acceleration puts less pressure on the vestibular system—the portion
    of our brain that senses acceleration. The same principle can be applied to rotation.
    Consistent slow turning or snap turning can feel better to a player. The final
    technique I would like to mention is teleportation. Teleportation is a great way
    to allow a player to navigate large environments without VR sickness. However,
    this method doesn't feel very natural depending on the game's story and setting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在将传统游戏移植到VR时（想想*Skyrim VR*和*Fallout 4 VR*）这是最好的移动方式，但由于视觉上的困扰，即我们的眼睛所看到的与我们的其他感官所经历之间的脱节，人工移动方式最有可能导致VR不适感。我们可以使用几种技术来最小化这种困扰。一种方法是在玩家移动时动态地减小他们的视野。这产生了一种非常微妙的效果，当玩家移动或转向时，它会隐藏玩家的一些周边视野。另一种方法是让玩家在移动过程中以恒定的速率加速。恒定的加速度对前庭系统——我们大脑中感知加速度的部分——的压力更小。同样的原理也可以应用于旋转。一致的缓慢转向或突然转向对玩家来说可能感觉更好。我想提到的最后一项技术是传送。传送是一种允许玩家在没有VR不适感的情况下导航大型环境的好方法。然而，这种方法根据游戏的故事和背景可能并不感觉自然。
- en: Cockpit locomotion
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驾驶舱移动
- en: Similar to natural locomotion, cockpit locomotion allows for very natural movement
    for games such as space sims, vehicle racing, and other games that have the player
    sitting in a vehicle.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与自然移动相似，驾驶舱移动允许游戏如太空模拟、赛车和其他让玩家坐在车辆中的游戏进行非常自然的移动。
- en: 'By tricking the body into thinking that movement is similar to riding in a
    car, we can bypass many of the causes of VR sickness. The downside to this method
    is that it isn''t applicable to most situations. Games that use this method successfully
    include *Elite: Dangerous*, *Star Trek Bridge Crew*, and *Archangel: Hellfire*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '通过欺骗身体，使其认为移动类似于乘坐汽车，我们可以绕过许多VR不适感的成因。这种方法的一个缺点是它不适用于大多数情况。成功使用这种方法的游戏包括《危险精英》（*Elite:
    Dangerous*）、《星际迷航舰桥船员》（*Star Trek Bridge Crew*）和《天使：地狱之火》（*Archangel: Hellfire*）。'
- en: Physical locomotion
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理移动
- en: Physical locomotion systems refer to unique movement control schemes that tend
    to be designed for the specific game experiences they're applied to. Because of
    this, they tend to be some of the most innovative ideas that we see in the VR
    space today.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 物理移动系统指的是为特定游戏体验设计的独特移动控制方案。正因为如此，它们往往是我们在今天的VR空间中看到的最具创新性的想法之一。
- en: This type of locomotion covers purpose built movement methods such as the kayak
    paddle system built by my students, as well as hand-over-hand climbing, running
    in place while swinging the controllers, swimming motions, and flying by moving
    the player's arms. Because the player is making specific arm or body movements,
    they tend to feel a very high rate of immersion while experiencing very little
    VR sickness. These systems aren't without disadvantages. Some players may find
    the movement silly or gimmicky. They're also not usually usable outside their
    specific game. Games that have successfully implemented this type of locomotion
    include *The Climb*, *Eagle Flight*, and the spell casting mechanic found in *Waltz
    of the Wizard*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的移动涵盖了专门设计的移动方法，例如我的学生建造的皮划艇划桨系统，以及手对手攀爬、在挥动控制器的同时原地跑步、游泳动作和通过移动玩家的手臂进行飞行。由于玩家在进行特定的手臂或身体动作，他们在体验时往往感觉沉浸感非常高，同时VR不适感非常少。这些系统并非没有缺点。一些玩家可能会觉得这种移动很愚蠢或很花哨。它们通常也不能在它们特定的游戏之外使用。成功实施这种移动方式的游戏包括《攀爬》（*The
    Climb*）、《鹰之飞行》（*Eagle Flight*）和《巫师之舞》（*Waltz of the Wizard*）中的施法机制。
- en: Taking into account what we know about our user (new to VR, looking for immersive
    and visceral experiences, and fans of cyberpunk), what type or types of locomotion
    would be best here? For the new user, natural locomotion seems as though it would
    work the best, since it tends to be intuitive and works well for maintaining immersion.
    So that we aren't limiting our level design to just the player's defined play
    space, we can also choose to integrate teleportation into our control scheme.
    Despite its drawback of not being immersive, I feel that the cyberspace setting
    of our game would actually support the player teleporting around the level.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们对用户（新手VR用户，寻求沉浸和直观体验，以及赛博朋克爱好者）的了解，在这里哪种或哪些类型的移动方式会是最合适的呢？对于新手用户来说，自然移动似乎会是最有效的，因为它通常直观且有助于保持沉浸感。因此，我们不会将我们的关卡设计限制在玩家定义的游戏空间内，我们还可以选择将传送功能整合到我们的控制方案中。尽管传送的缺点是不够沉浸，但我认为我们游戏的赛博空间设置实际上会支持玩家在关卡内进行传送。
- en: With these design decisions made, it's time to launch **Unreal Engine 4** (**UE4**)
    and set up our project files!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这些设计决策后，是时候启动**虚幻引擎4**（**UE4**）并设置我们的项目文件了！
- en: Setting up new game files in UE4
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在UE4中设置新的游戏文件
- en: UE4 is a versatile collection of tools that helps you to create the game of
    your dreams. To get you started down that path, Epic Games provides a collection
    of starter projects to jump-start your games by setting up some of the most important
    features for you. This often includes player character, sample weapons, and other
    necessary files. In this book, we'll begin creating files within the Virtual Reality
    Starter project so that we can make use of some of the basic art assets that this
    project provides. Beyond that, I'll show you how to create the blueprints we'll
    need from scratch.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: UE4是一个多功能的工具集合，帮助你创建你梦想中的游戏。为了让你开始这一旅程，Epic Games提供了一系列启动项目，通过为你设置一些最重要的功能来快速启动你的游戏。这通常包括玩家角色、示例武器和其他必要的文件。在这本书中，我们将从Virtual
    Reality Starter项目开始创建文件，以便我们可以利用该项目提供的一些基本艺术资产。除此之外，我将向你展示如何从头开始创建我们需要的蓝图。
- en: Every game or software project needs to stay organized and we use **naming conventions**
    to do just that. A naming convention is a naming scheme and folder structure that
    ensures that every filename is standardized so that anyone in a particular game
    team can read a filename and understand exactly what they're looking at. You may
    have noticed it while browsing through some of the project files inside UE4\.
    Epic Games provides its naming convention on the Unreal Wiki at [https://wiki.unrealengine.com/Assets_Naming_Convention](https://wiki.unrealengine.com/Assets_Naming_Convention),
    and we'll be using it throughout this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏或软件项目都需要保持组织性，我们使用**命名约定**来做到这一点。命名约定是一种命名方案和文件夹结构，确保每个文件名都是标准化的，以便任何特定的游戏团队成员都能通过文件名确切地了解他们正在查看的内容。你可能注意到了在浏览UE4内部的一些项目文件时。Epic
    Games在其Unreal Wiki上提供了其命名约定[https://wiki.unrealengine.com/Assets_Naming_Convention](https://wiki.unrealengine.com/Assets_Naming_Convention)，并且我们将在这本书中一直使用它。
- en: 'Any new game in Unreal needs certain blueprints created to customize the project
    to fit our needs. These files include the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal中，任何新的游戏都需要创建某些蓝图来定制项目以满足我们的需求。这些文件包括以下内容：
- en: '`GameMode`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameMode`'
- en: '`GameState`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameState`'
- en: '`PlayerPawn`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerPawn`'
- en: But how do all of these files interact, and why do we need them? When UE4 launches
    a game, the engine creates two files to help it understand what the rules of the
    game are before it loads and levels or players. These are `GameMode` and `GameState`.
    `GameMode` contains the rules that make our game unique, such as the total number
    of players and how those players connect to the game, as well as default settings,
    such as the default player pawn, player controller, and game state. By creating
    our own game mode, we're taking the first step toward customizing our project.
    The `GameState` file that's loaded after the game starts is designed to track
    everything that's important to our game, such as scores, missions completed, and
    other elements that are relevant to the game as a whole. This isn't for things
    that are player-specific, as there is a different player state. I've often used
    this as a place to store data needed to build levels in a procedural generation
    game, for example. Lastly, we'll need a custom `PlayerPawn`. `PlayerPawn` is the
    player's physical representation in the game and is possessed by our player during
    the game.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但所有这些文件是如何相互作用的，为什么我们需要它们呢？当UE4启动游戏时，引擎会创建两个文件来帮助它在加载和设置关卡或玩家之前理解游戏规则。这些是`GameMode`和`GameState`。`GameMode`包含使我们的游戏独特的规则，例如玩家的总数以及这些玩家如何连接到游戏，以及默认设置，例如默认玩家
    pawn、玩家控制器和游戏状态。通过创建我们自己的游戏模式，我们迈出了定制项目的第一步。游戏开始后加载的`GameState`文件旨在跟踪对我们游戏重要的所有内容，例如得分、完成的任务以及其他与整个游戏相关的元素。这不是针对特定玩家的东西，因为有一个不同的玩家状态。我经常用它来存储需要构建生成式游戏关卡所需的数据。最后，我们还需要一个定制的`PlayerPawn`。`PlayerPawn`是玩家在游戏中的物理表示，并在游戏过程中被我们的玩家控制。
- en: Project setup
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Before we can start creating our custom project files, we need to let Unreal
    create our project base and begin to lay out our folder structure. This will keep
    our files organized as we build *Server 17*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建自定义项目文件之前，我们需要让Unreal创建我们的项目基础并开始布局我们的文件夹结构。这将保持我们在构建*Server 17*时的文件组织。
- en: 'Start by opening Unreal Engine 4.20.2 and starting a new project:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开Unreal Engine 4.20.2并开始一个新项目：
- en: '![](img/8d8d56d8-75be-4ce2-83f2-37f5d156b8a8.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d8d56d8-75be-4ce2-83f2-37f5d156b8a8.png)'
- en: The screen you're greeted with when you first open UE4
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你第一次打开UE4时看到的屏幕
- en: 'Welcome to the new project window. From here, we''ll create our project based
    on the UR template:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到新项目窗口。从这里，我们将根据UR模板创建我们的项目：
- en: Choose the new project tab from the top of the screen.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从屏幕顶部选择新的项目标签。
- en: Select the Blueprint section.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择蓝图部分。
- en: Choose the Virtual Reality template near the bottom of the list.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表底部附近选择虚拟现实模板。
- en: Change the middle project setting to Scalable 3D or 2D.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将中间的项目设置更改为可伸缩3D或2D。
- en: Ensure the project folder is in a space you can find easily. Change the name
    to `VRQuickStart`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保项目文件夹在一个容易找到的地方。将其名称更改为`VRQuickStart`。
- en: 'Smack that Create Project button, and let''s continue! Now take a look at the
    interface:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 点击那个创建项目按钮，我们继续！现在看看界面：
- en: '![](img/d149918f-85d6-4a77-9a0f-be10565488ec.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d149918f-85d6-4a77-9a0f-be10565488ec.png)'
- en: Much of the interaction with the game engine takes place in the Content Browser
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与游戏引擎的大部分交互都在内容浏览器中进行
- en: 'With our new project open, look around the interface and locate your Content
    Browser:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新项目打开后，四处看看界面并找到你的内容浏览器：
- en: It's time to get organized. One of the first steps is to create our own project
    folder similar to the `VirtualReality` and `VirtualRealityBP` folders Epic Games
    uses. Right-click on the `Content` folder inside the Content Browser and select
    New Folder from the top of the list. Name the new folder `Server17`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候整理一下了。第一步之一是创建我们自己的项目文件夹，类似于Epic Games使用的`VirtualReality`和`VirtualRealityBP`文件夹。在内容浏览器内的`Content`文件夹上右键点击，然后从列表顶部选择新建文件夹。将新文件夹命名为`Server17`。
- en: Click on our new folder to enter it. Right-click in the Content Browser and
    select New Folder. Name it `Blueprints`. This will be the home of our new blueprints.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们的新文件夹以进入它。在内容浏览器中右键点击并选择新建文件夹。将其命名为`Blueprints`。这将是我们新蓝图的家。
- en: As we continue with development, we'll add several more folders to our file
    structure to help to contain and organize our files. Remember to stick to our
    naming convention as we go, as this will be a huge help later when you're adding
    team members or coming back to your project after a leave of absence.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续开发，我们将向我们的文件结构添加几个更多文件夹，以帮助包含和组织我们的文件。记住，在继续进行时坚持我们的命名约定，因为这将在以后添加团队成员或休假后返回项目时提供巨大帮助。
- en: Creating our custom Game Mode
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的自定义游戏模式
- en: 'With our project base and our file structure established, let''s create our
    first custom file: our `GameMode` file. Click on our new `Blueprints` folder,
    and right-click to bring up the menu. From the Create Basic Asset section, choose
    Blueprint Class. This will bring up the Pick Parent Class menu, as shown in the
    following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目基础和文件结构建立之后，让我们创建我们的第一个自定义文件：我们的`GameMode`文件。点击我们的新`Blueprints`文件夹，然后右键单击以显示菜单。从创建基本资产部分，选择蓝图类。这将显示选择父类菜单，如下面的截图所示：
- en: '![](img/d76237df-1cf6-4837-ac62-a006b5c06e30.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d76237df-1cf6-4837-ac62-a006b5c06e30.png)'
- en: From the Pick Parent Class menu, we can create a new file that extends the functionality
    of a parent file
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从选择父类菜单中，我们可以创建一个扩展父文件功能的新文件
- en: 'It''s time to extend the basic `GameMode` class and tell our project to use
    our new file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候扩展基本的`GameMode`类并告诉我们的项目使用我们的新文件了：
- en: From the Pick Parent Class menu, we can extend any basic class that the engine
    has to offer. Click the Game Mode Base button, and name the new file `S17GameMode`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从选择父类菜单中，我们可以扩展引擎提供的任何基本类。点击游戏模式基类按钮，并将新文件命名为`S17GameMode`。
- en: Simply creating `GameMode` isn't enough for the engine to recognize it within
    our project. To ensure that it's used, click on the Settings button of the viewport
    and select Project settings.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地创建`GameMode`对于引擎在项目中识别它来说是不够的。为了确保它被使用，点击视口的设置按钮并选择项目设置。
- en: Alternately, we could have opened up the World Settings and navigated down to
    the Game Mode section of the menu, and then clicked the *+* button next to the
    GameMode Override. Much like doing math or most creative pursuits, there's more
    than one way to create something inside Unreal. What I'm sharing are the methods
    and processes that I've learned in my career. If you find a different way or a
    better way to do any of the things that I talk about in this book, feel free to
    share them with me and the UE4 development community!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以打开世界设置并导航到菜单中的游戏模式部分，然后点击GameMode覆盖旁边的*+*按钮。就像做数学或大多数创造性追求一样，在Unreal内部创建某物的方式不止一种。我分享的是我在职业生涯中学到的方法和过程。如果你发现不同的方式或更好的方式来做我在这本书中提到的任何事情，请随时与我以及UE4开发社区分享！
- en: 'Check out the Project settings menu:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 查看项目设置菜单：
- en: '![](img/cdc6b332-f61b-43a9-af0f-da44990607f5.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cdc6b332-f61b-43a9-af0f-da44990607f5.png)'
- en: Project settings
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设置
- en: Under the Project section of the menu, select Maps & Modes. This section of
    the menu allows you to specify the default map that opens when the editor opens,
    as well as define the default `GameMode`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单的项目部分下，选择地图和模式。此菜单部分允许您指定当编辑器打开时打开的默认地图，以及定义默认`GameMode`。
- en: In the Default Modes section of the menu, use the Default GameMode drop-down
    menu and select S17GameMode.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单的默认模式部分，使用默认游戏模式下拉菜单并选择S17GameMode。
- en: With the S17GameMode set as our default, we can now begin to create the rest
    of our custom project files. We'll come back to the Projects setting screen and
    change the defaults further once we have the rest of our pieces in place.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将S17GameMode设置为默认设置后，我们现在可以开始创建其余的自定义项目文件。一旦我们放置好所有其他部分，我们将返回到项目设置屏幕并进一步更改默认设置。
- en: Creating a GameState
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个GameState
- en: 'Where `GameMode` is great for setting our game specific rules and storing our
    mode defaults, `GameState` is there to store our important level-wide elements.
    Similar to when we created our `GameMode` class, we''ll need to extend a `GameState`
    class as the base for our custom state. Let''s go back to the Pick Parent Class
    menu:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`GameMode`非常适合设置我们的游戏特定规则和存储模式默认值，但`GameState`用于存储重要的全局元素。类似于我们创建`GameMode`类时，我们需要扩展`GameState`类作为自定义状态的基类。让我们回到选择父类菜单：
- en: '![](img/a43ddc81-0aa8-4f9f-a082-03ba06919da4.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a43ddc81-0aa8-4f9f-a082-03ba06919da4.png)'
- en: Extending GameStateBase to create our custom GameState class
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展GameStateBase以创建我们的自定义GameState类
- en: 'Yet, unlike our `GameMode`, we''re going to extend the `GameStateBase` class,
    or the class from which all `GameState` files extend:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与我们的 `GameMode` 不同，我们将扩展 `GameStateBase` 类，或者所有 `GameState` 文件都从中扩展的类：
- en: Right-click in the Content Browser and select the Blueprint Class from the Create
    Basic Asset section of the menu.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键点击，并从菜单的创建基本资产部分选择蓝图类。
- en: From the Pick Parent Class menu, we're going to skip the top portion of the
    menu that lists many of the common extended classes and select the All Classes
    collapsed menu.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择父类菜单中，我们将跳过菜单顶部列出许多常见扩展类的部分，并选择所有类折叠菜单。
- en: This will show us all of the classes that we can extend within the engine. Use
    the search box to find the GameStateBase and select it. Then, press the Select
    button at the bottom of the menu.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将显示我们可以在引擎中扩展的所有类。使用搜索框找到 GameStateBase 并选择它。然后，按菜单底部的选择按钮。
- en: Name our new game state `S17GameState`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将新游戏状态命名为 `S17GameState`。
- en: A discussion of the interaction between `GameMode`, `GameState`, and individual
    `PlayerStates` in the context of single and multiplayer games.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在单人和多人游戏背景下，讨论 `GameMode`、`GameState` 和单个 `PlayerStates` 之间的交互。
- en: Creating a custom PlayerPawn
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义玩家实体
- en: 'Now that we have two different files to help with managing the information
    and variables that will be present in our level, it''s time to build our `PlayerPawn`,
    or the physical representation of our player. `PlayerPawn` takes in information
    from the headset and hand controllers and translates that into movement and action
    within the game. Depending on how we choose to represent our player, there are
    several different directions we can go in:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个不同的文件来帮助我们管理将在我们的关卡中出现的信息和变量，是时候构建我们的 `PlayerPawn`，即我们玩家的物理表示。`PlayerPawn`
    从头戴设备和手控制器接收信息，并将其转换为游戏中的移动和动作。根据我们选择如何表示玩家，我们可以选择几个不同的方向：
- en: '**First-person format**: The player has no avatar. The hands and head float
    in the air.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一人称格式**：玩家没有化身。手和头在空中飘浮。'
- en: '**First person with arms**: Using inverse kinematics, we''re able to give the
    player arms that move with the location of the hand controllers. However, the
    head still floats.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有手臂的第一人称视角**：通过逆运动学，我们能够为玩家提供与手控制器位置移动的手臂。然而，头部仍然飘浮。'
- en: '**First person with full body**: Similar to the first person with arms setup,
    this allows the player to be represented by a full body, with inverse kinematics
    used for both the hands and the head.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有全身的第一人称视角**：类似于带有手臂的设置，这允许玩家通过全身来表示，同时使用逆运动学来处理手和头部。'
- en: '**Third person**: A full third-person character with the player looking down
    on it from a camera set above and behind the player model. This option has been
    known to limit VR sickness but at the cost of immersion. This player setup has
    been successfully used in some games when used in conjunction with a first-person
    option—for example: the first-person view is used when the player is shooting
    and performing actions, but the third-person view is used when the player is moving.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三人称视角**：一个完整的第三人称角色，玩家从设置在玩家模型上方和后面的摄像机向下看。这种选项已知会限制VR不适，但以牺牲沉浸感为代价。当与第一人称选项结合使用时，这种玩家设置在一些游戏中已被成功使用——例如：当玩家射击和执行动作时使用第一人称视角，而当玩家移动时使用第三人称视角。'
- en: For *Server 17*, the player takes on the role of a cyberpunk hacker trying to
    break into a server to find encrypted file data to steal. Set in the future, and
    the player and the server interact inside a virtual environment created by the
    player's hacking hardware. For this reason, we can represent the player using
    the basic first-person format without sacrificing the experience. This method
    will also help with keeping our game optimized.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *Server 17*，玩家扮演一个试图破解服务器以寻找加密文件数据来窃取的网络黑客。设定在未来，玩家和服务器在玩家黑客硬件创建的虚拟环境中交互。因此，我们可以使用基本的第一个视角格式来表示玩家，而不会牺牲体验。这种方法也有助于保持我们的游戏优化。
- en: 'Though we could use the Motion Controller Pawn that''s supplied with the template
    we''re using, let''s go ahead and create one from scratch. Start by creating a
    new `Pawn` class for us to use:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用模板中提供的运动控制器实体，但让我们从头开始创建一个。首先，创建一个新的 `Pawn` 类供我们使用：
- en: Right-click in the Content Browser within our `Blueprints` folder and select
    Blueprint Class from the New Basic Asset section of the menu.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `Blueprints` 文件夹内的内容浏览器中右键点击，并从菜单的新基本资产部分选择蓝图类。
- en: 'We want to create a new Pawn for our player to possess or to receive controller
    input data. Select Pawn from the menu and name it `S17PlayerPawn`. Double-click
    the new Pawn to open the interface, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望为玩家创建一个新的Pawn，以便玩家可以控制或接收控制器输入数据。从菜单中选择Pawn，并将其命名为`S17PlayerPawn`。双击新Pawn以打开界面，如下所示：
- en: '![](img/bb41e610-aa1f-4a51-b49a-5a431e9b6da9.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb41e610-aa1f-4a51-b49a-5a431e9b6da9.png)'
- en: The open Pawn class with components showing
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 打开的Pawn类及其组件显示
- en: First, we'll add a scene component to our player to act as a root object for
    our camera. In the top-left of the Blueprint interface, in the Components panel
    of the menu, click on the Add Component button and search for a Scene Component.
    Create it and name it `HMDRoot`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将向玩家添加一个场景组件，作为我们摄像机的根对象。在蓝图界面的左上角，在菜单的组件面板中，点击添加组件按钮并搜索场景组件。创建它并将其命名为`HMDRoot`。
- en: It's time to add our player camera as a child of our new Scene object. With
    `HMDRoot` selected, go back to the Add Component button and find a Camera object.
    Create it and name it `HMDCam`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候将我们的玩家摄像头添加为我们的新场景对象的孩子了。选择`HMDRoot`后，返回到添加组件按钮，找到一个摄像头对象。创建它并将其命名为`HMDCam`。
- en: Now we need to create a way to track our player's motion controllers so that
    the hands of our player character move and act appropriately. With `HMDRoot` selected,
    create a Motion Controller component with the Add Component menu and name it `MotionController_L`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建一种方法来跟踪玩家的运动控制器，以便玩家的角色手部能够适当地移动和行动。选择`HMDRoot`后，使用添加组件菜单创建一个运动控制器组件，并将其命名为`MotionController_L`。
- en: 'Repeat the preceding steps to create another Motion Controller component and
    name it `MotionController_R`. The Details panel will look like this:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤创建另一个运动控制器组件，并将其命名为`MotionController_R`。详细面板将如下所示：
- en: '![](img/3748807f-78bd-4a75-8ea4-a2d8a2f9085a.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3748807f-78bd-4a75-8ea4-a2d8a2f9085a.png)'
- en: MotionController_R settings
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运动控制器_R设置
- en: With our `MotionController_R` component selected, look over at the Details panel
    and find the Motion Controller section of the menu. Change the Motion Source option
    to Right.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`MotionController_R`组件后，查看详细面板并找到菜单中的运动控制器部分。将运动源选项更改为右侧。
- en: Programming our custom PlayerPawn
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程我们的自定义PlayerPawn
- en: 'Let''s move on to a bit of programming to ensure that our PlayerPawn is used
    and set up correctly for our player''s hardware. Unreal needs to know where to
    set the Tracking Origin, or where to set the default height of the player, which
    can vary depending on your equipment. For the HTC Vive, the default is to target
    standing VR experiences by using a tracking origin set to the floor. The Oculus
    Rift, on the other hand, is set to target sitting VR experiences by default and
    uses an eye-level tracking origin. It might be easy to simply just set things
    up for the Vive, knowing that this is the platform we''re targeting, but I want
    to create something that might be reusable outside just this project. We''ll add
    the following to our PlayerPawn''s Event Graph:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行一些编程，以确保我们的PlayerPawn被正确使用并设置以适应玩家的硬件。虚幻需要知道在哪里设置跟踪原点，或者在哪里设置玩家的默认高度，这可能会根据您的设备而有所不同。对于HTC
    Vive，默认情况下是针对站立VR体验，通过将跟踪原点设置为地板来实现。另一方面，Oculus Rift默认设置为针对坐着VR体验，并使用眼睛高度跟踪原点。虽然为Vive设置东西可能很简单，因为我们知道这是我们针对的平台，但我希望创建一些可能在这个项目之外可重用的东西。我们将在PlayerPawn的事件图中添加以下内容：
- en: '![](img/e19ad995-eea0-4a5e-9be2-13f0fff1dbfa.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e19ad995-eea0-4a5e-9be2-13f0fff1dbfa.png)'
- en: PlayerPawn Event Graph
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家Pawn事件图
- en: 'To do this, we''ll detect what hardware the player might be using and set the
    Tracking Origin based on our player''s equipment:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将检测玩家可能使用的硬件，并根据玩家的设备设置跟踪原点：
- en: Click on the Event Graph tab in the center of our `S17PlayerPawn` and drag an
    execute line out of the Event BeginPlay node.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`S17PlayerPawn`的中心点击事件图标签，并将执行线从事件开始节点拖出。
- en: Drop it and select the Switch on Name node. Switch on Name is a flow-control
    node, which means that it restricts and directs the flow of execution through
    the blueprint. This node will direct the blueprint to set the tracking origin
    based on the HMD hardware found.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放下并选择按名称切换节点。按名称切换是一个流程控制节点，这意味着它限制了并通过蓝图来指导执行流程。此节点将指导蓝图根据找到的HMD硬件设置跟踪原点。
- en: Drag off the Selection input on the Switch on Name node. Use the search box
    to find Get HMD Device Name. This node represents a function designed to fetch
    the name of the player's HMD hardware.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从按名称切换节点上的选择输入拖出。使用搜索框查找获取HMD设备名称。此节点代表一个用于获取玩家HMD硬件名称的函数。
- en: On the Switch on Name node, click the Add Pin button two times. In the Details
    panel, name the pins OculusHMD and SteamVR. Also in the Details panel, turn off
    the option has Default Pin.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“开关名称”节点上，点击添加锚点按钮两次。在详细信息面板中，将锚点命名为 OculusHMD 和 SteamVR。同样在详细信息面板中，关闭“具有默认锚点”的选项。
- en: Now let's set the criteria for each of our hardware options. Drag off the OculusHMD
    pin and search for the Set Tracking Origin node. Select it, and use the drop-down
    box on the node to select Eye Level tracking.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的每个硬件选项设置标准。将 OculusHMD 锚点拖离，并搜索设置跟踪原点节点。选择它，并使用节点上的下拉框选择眼睛水平跟踪。
- en: Drag off the SteamVR pin, and create another Set Tracking origin node. This
    time, we'll set it to Floor Level tracking.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 SteamVR 锚点拖离，并创建另一个设置跟踪原点节点。这次，我们将它设置为地板水平跟踪。
- en: Now click the Save button, so you don't lose your work.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击保存按钮，以免丢失你的工作。
- en: With our tracking origin in place, we can now go back into our project settings
    and tell `S17GameMode` to use our `S17PlayerPawn` as our Default Player Pawn.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的跟踪原点设置好之后，我们现在可以回到我们的项目设置中，告诉 `S17GameMode` 使用我们的 `S17PlayerPawn` 作为默认玩家锚点。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'At the beginning of this chapter, we learned one of the best ways to design
    with a particular type of user in mind: the HCD process. When using HCD, we always
    want to keep our player in mind as we make each design decision, ensuring that
    the game we create meets every one of our player''s expectations and is a delight
    to play. This is our goal for *Server 17*. With a few of our design decisions
    in place, we then created our project and began to customize our files by creating
    our custom `GameMode`, `GameState`, and `PlayerPawn` files.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们学习了针对特定类型用户设计的一种最佳方法：HCD 流程。在使用 HCD 时，我们总是希望在每个设计决策中都考虑到我们的玩家，确保我们创建的游戏满足我们玩家的每一个期望，并且玩起来令人愉悦。这是我们
    *Server 17* 的目标。在我们的一些设计决策确定后，我们创建了我们的项目，并开始通过创建自定义的 `GameMode`、`GameState` 和
    `PlayerPawn` 文件来自定义我们的文件。
- en: In the next chapter, we'll further flesh out the design for *Server 17* and
    look at the different types of gameplay that are popular in today's current VR
    market. Specifically, we'll focus on gameplay that takes advantage of the unique
    input methods and immersive qualities that VR has to offer and how we can apply
    those to our own game. In the end, we'll decide how our game will work and begin
    building those systems. Soon, we'll have a working prototype that we can show
    off to our players!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步完善 *Server 17* 的设计，并探讨在当今 VR 市场上流行的不同类型的游戏玩法。具体来说，我们将专注于利用 VR 提供的独特输入方法和沉浸式特性，以及我们如何将这些应用到我们自己的游戏中。最后，我们将决定我们的游戏将如何运作，并开始构建这些系统。很快，我们将有一个可以展示给玩家的工作原型！
