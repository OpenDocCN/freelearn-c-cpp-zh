["```cpp\n   Observable().     // Source Observable \n          Op1().     // First operator \n          Op2().     // Second operator \n                     ..                         \n                     .. \n          Opn().subscribe( on_datahandler, \n                            on_errorhandler, \n                            on_completehandler); \n```", "```cpp\n//----- operatorChaining1.cpp \n//----- Square and multiplication by 2 in order \n#include \"rxcpp/rx.hpp\" \nint main() \n{ \n    auto values = rxcpp::observable<>::range(1, 3). \n        map([](int x) { return x * x; }). \n        map([](int x) { return x * 2; }); \n    values.subscribe( \n        [](int v) {printf(\"OnNext: %dn\", v); }, \n        []() {printf(\"OnCompletedn\"); }); \n    return 0; \n} \n```", "```cpp\nOnNext: 2 \nOnNext: 8 \nOnNext: 18 \nOnCompleted\n```", "```cpp\n//----- operatorChaining2.cpp \n//----- Multiplication by 2 and Square in order \n#include \"rxcpp/rx.hpp\" \nint main() \n{ \n    auto values = rxcpp::observable<>::range(1, 3). \n        map([](int x) { return x * 2; }). \n        map([](int x) { return x * x; }); \n    values.subscribe( \n        [](int v) {printf(\"OnNext: %dn\", v); }, \n        []() {printf(\"OnCompletedn\"); }); \n    return 0; \n} \n```", "```cpp\nOnNext: 4 \nOnNext: 16 \nOnNext: 36 \nOnCompleted \n```", "```cpp\nF(G( H(x)) \n```", "```cpp\nx.H().G().F() \n```", "```cpp\n//----------- operatorSimple.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <iostream> \nnamespace rxu=rxcpp::util; \n#include <array> \nusing namespace rxcpp; \nusing namespace rxcpp::operators; \n// Write a Simple Reactive operator Takes an Observable<string> and \n// Prefix Hello to every item and return another Observable<string> \nobservable<std::string> helloNames(observable<std::string> src ) { \n    return src.map([](std::string s) { return \"Hello, \" + s + \"!\"; }); \n} \n```", "```cpp\nint main() { \n     std::array< std::string,4 > a={{\"Praseed\", \"Peter\", \"Sanjay\",\"Raju\"}}; \n     // Apply helloNames operator on the observable<string>  \n     // This operator cannot be part of the method chaining strategy \n     // We need to invoke it as a function  \n     // If we were implementing this operator as part of the\n     //          RxCpp observable<T> \n     //   auto values = rxcpp::observable<>:iterate(a).helloNames(); \n     auto values = helloNames(rxcpp::observable<>::iterate(a));  \n     //-------- As usual subscribe  \n     values.subscribe(  \n              [] (std::string f) { std::cout << f <<  std::endl; } ,  \n              [] () {std::cout << \"Hello World..\" << std::endl;} ); \n} \n```", "```cpp\nHello, Praseed! \nHello, Peter! \nHello, Sanjay! \nHello, Raju! \nHello World.. \n```", "```cpp\n//----------- operatorInline.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <iostream> \nnamespace rxu=rxcpp::util; \n#include <array> \nusing namespace rxcpp; \nusing namespace rxcpp::operators; \nint main() { \n     std::array< std::string,4 > a={{\"Praseed\", \"Peter\", \"Sanjay\",\"Raju\"}}; \n     auto helloNames = [] (observable<std::string> src ) { \n           return src.map([](std::string s) {  \n             return \"Hello, \" + s + \"!\";  \n             }); \n     }; \n     // type of values will be observable<string> \n     // Lazy Evaluation  \n     auto values = helloNames(rxcpp::observable<>::iterate(a));  \n     //-------- As usual subscribe  \n     values.subscribe(  \n              [] (std::string f) { std::cout << f <<  std::endl; } ,  \n              [] () {std::cout << \"Hello World..\" << std::endl;} ); \n} \n```", "```cpp\nHello, Praseed! \nHello, Peter! \nHello, Sanjay! \nHello, Raju! \nHello World.. \n```", "```cpp\n//----------- operatorCompose.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <iostream> \nnamespace rxu=rxcpp::util; \n#include <array> \nusing namespace rxcpp; \nusing namespace rxcpp::operators; \nint main() { \n     std::array< int ,4 > a={{10, 20,30,40}}; \n     // h-function (idempotent) \n     auto h = [] (observable<int> src ) { \n       return src.map([](int n ) { return n; }); \n     }; \n     // g-function \n     auto g = [] (observable<int> src ) { \n          return src.map([](int n ) { return n*2; }); \n     }; \n     // type of values will be observable<string> \n     // Lazy Evaluation ... apply h over observable<string> \n     // on the result, apply g  \n     auto values = g(h(rxcpp::observable<>::iterate(a)));  \n     //-------- As usual subscribe  \n     values.subscribe(  \n              [] (int f) { std::cout << f <<  std::endl; } ,  \n              [] () {std::cout << \"Hello World..\" << std::endl;} ); \n} \n```", "```cpp\n20 \n40 \n60 \n80 \nHello World.. \n```", "```cpp\n//------ CustomOperator1.cpp \n#include \"rxcpp/rx.hpp\" \nnamespace rx { \n    using namespace rxcpp;  \n    using namespace rxcpp::operators; \n    using namespace rxcpp::sources; \n    using namespace rxcpp::util; \n} \n\ntemplate<typename Container> \nrx::observable<std::string> helloNames(Container items) { \n    auto str = rx::observable<>::iterate(items); \n    return str. \n    filter([](std::string s){ \n        return s.length() > 5; \n    }). \n    map([](std::string s){ \n        return \"Hello, \" + s + \"!\"; \n    }). \n    //------ Translating exception \n    on_error_resume_next([](std::exception_ptr){ \n        return rx::error<std::string>(std::runtime_error(\"custom exception\")); \n    }); \n} \n```", "```cpp\nint main() { \n    //------ Create an observable composing the custom operator \n    auto names = {\"Praseed\", \"Peter\", \"Joseph\", \"Sanjay\"}; \n    auto value = helloNames(names).take(2); \n\n    auto error_handler = [=](std::exception_ptr e) { \n        try { rethrow_exception(e); } \n        catch (const std::exception &ex) { \n            std::cerr << ex.what() << std::endl; \n        } \n    }; \n\n    value. \n    subscribe( \n              [](std::string s){printf(\"OnNext: %sn\", s.c_str());}, \n              error_handler, \n              [](){printf(\"OnCompletedn\");}); \n} \n```", "```cpp\nOnNext: Hello, Praseed! \nOnNext: Hello, Joseph! \nOnCompleted\n```", "```cpp\n//------ CustomOperator1.cpp \n#include \"rxcpp/rx.hpp\" \nnamespace rx { \n    using namespace rxcpp; \n    using namespace rxcpp::operators; \n    using namespace rxcpp::sources; \n    using namespace rxcpp::util; \n} \n//------ operator to filter odd number, find square & take first three items \nstd::function<rx::observable<int>(rx::observable<int>)> getOddNumSquare() { \n    return [](rx::observable<int> item) { \n        return item. \n        filter([](int v){ return v%2; }). \n        map([](const int v) { return v*v; }). \n        take(3). \n        //------ Translating exception \n        on_error_resume_next([](std::exception_ptr){ \n            return rx::error<int>(std::runtime_error(\"custom exception\")); }); \n    }; \n} \nint main() { \n    //------ Create an observable composing the custom operator \n    auto value = rxcpp::observable<>::range(1, 7) | \n    getOddNumSquare(); \n    value. \n    subscribe( \n              [](int v){printf(\"OnNext: %dn\", v);}, \n              [](){printf(\"OnCompletedn\");}); \n} \n```", "```cpp\n//----------- CustomOperatorScheduler.cpp \n#include \"rxcpp/rx.hpp\" \ntemplate <typename Duration> \nauto generateObservable(Duration durarion) { \n    //--------- start and the period \n    auto start = rxcpp::identity_current_thread().now(); \n    auto period = durarion; \n    //--------- Observable upto 3 items \n    return rxcpp::observable<>::interval(start, period).take(3); \n} \n\nint main() { \n    //-------- Create a coordination \n    auto coordination = rxcpp::observe_on_event_loop(); \n    //-------- Instantiate a coordinator and create a worker \n    auto worker = coordination.create_coordinator().get_worker(); \n    //----------- Create an Observable (Replay ) \n    auto values = generateObservable(std::chrono::milliseconds(2)). \n        replay(2, coordination); \n    //--------------- Subscribe first time \n    worker.schedule([&](const rxcpp::schedulers::schedulable&) { \n        values.subscribe([](long v) { printf(\"#1 -- %d : %ldn\", \n            std::this_thread::get_id(), v); }, \n                         []() { printf(\"#1 --- OnCompletedn\"); }); \n    }); \n    worker.schedule([&](const rxcpp::schedulers::schedulable&) { \n        values.subscribe([](long v) { printf(\"#2 -- %d : %ldn\", \n            std::this_thread::get_id(), v); }, \n                         []() { printf(\"#2 --- OnCompletedn\"); }); }); \n    //----- Start the emission of values \n    worker.schedule([&](const rxcpp::schedulers::schedulable&) { \n        values.connect(); \n    }); \n    //------- Add blocking subscription to see results \n    values.as_blocking().subscribe(); \n    return 0; \n} \n```", "```cpp\ntemplate<class ResultType , class operator > \nauto rxcpp::operators::lift(Operator && op) -> \n                 detail::lift_factory<ResultType, operator> \n```", "```cpp\n[=](rxcpp::subscriber<T> dest){ \n         return rxcpp::make_subscriber<T>( \n                dest,rxcpp::make_observer_dynamic<T>( \n                      [=](T n){ \n                         //---- Apply an action Lambda on each items \n                         //---- typically \"action_lambda\" is declared in the \n                         //---- outside scope (captured)\n                         dest.on_next(action_lambda(n)); \n                      }, \n                      [=]( std::exception_ptr e ){dest.on_error(e);}, \n                      [=](){dest.on_completed();})); \n}; \n```", "```cpp\n//----------- operatorLiftFirst.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <iostream> \nnamespace rxu=rxcpp::util; \n#include <array> \nusing namespace rxcpp; \nusing namespace rxcpp::operators; \n\nint main() { \n     std::array< int ,4 > a={{10, 20,30,40}}; \n     //////////////////////////////////////////////////// \n     // The following Lambda will be lifted  \n     auto lambda_fn = [] ( int n ) { return n*2; }; \n     ///////////////////////////////////////////////////////////// \n     // The following Lambda expects a rxcpp::subscriber and returns \n     // a subscriber which implements on_next,on_error,on_completed \n     // The Lambda lifting happens because, we apply lambda_fn on  \n     // each item. \n     auto transform = [=](rxcpp::subscriber<int> dest){ \n         return rxcpp::make_subscriber<int>( \n                dest,rxcpp::make_observer_dynamic<int>( \n                      [=](int n){ \n                         dest.on_next(lambda_fn(n)); \n                      }, \n                      [=]( std::exception_ptr e ){dest.on_error(e);}, \n                      [=](){dest.on_completed();})); \n     }; \n     // type of values will be observable<int> \n     // Lazy Evaluation  \n     auto values = rxcpp::observable<>::iterate(a);  \n     //-------- As usual subscribe  \n     values.lift<int>(transform).subscribe(  \n              [] (int f) { std::cout << f <<  std::endl; } ,  \n              [] () {std::cout << \"Hello World..\" << std::endl;} ); \n} \n```", "```cpp\nobservable<T>::lift<T>( liftaction( lambda<T> ) )\n```", "```cpp\n//----------- operatorLiftSecond.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <iostream> \nnamespace rxu=rxcpp::util; \n#include <array> \nusing namespace rxcpp; \nusing namespace rxcpp::operators; \n///////////////////////////////////////////////// \n// The LiftAction class  ( an adapter class) converts an Action ( a Lambda ) \n// and wraps it into a form which can help us to connect \n// to an observable<T> using the observable<T>::lift<T> method.  \ntemplate<class Action> \nstruct LiftAction { \n    typedef typename std::decay<Action>::type action_type; \n    action_type action; \n\n    LiftAction(action_type t): action(t){} \n    ////////////////////////////////////// \n    // Create an Internal observer to gather  \n    // data from observable<T>  \n    // \n    template<class Subscriber> \n    struct action_observer : public  \n              rxcpp::observer_base<typename  \n              std::decay<Subscriber>::type::value_type> \n    { \n        ///////////////////////////////////////////// \n        // typedefs for  \n        //        * this_type (action_observer) \n        //        * base_type (observable_base)  \n        //        * value_type  \n        //        * dest_type \n        //        * observer_type \n        typedef action_observer<Subscriber> this_type; \n        typedef rxcpp::observer_base<typename             \n                std::decay<Subscriber>::type::value_type> base_type; \n        typedef typename base_type::value_type value_type; \n        typedef typename std::decay<Subscriber>::type dest_type; \n        typedef rxcpp::observer<value_type, this_type> observer_type; \n\n        //------ destination subscriber and action \n        dest_type dest; \n        action_type action; \n        action_observer(dest_type d, action_type t) \n            : dest(d), action(t){} \n\n        //--------- subscriber/observer methods \n        //--------  on_next implementation needs more  \n        //--------- robustness by supporting exception handling \n        void on_next(typename dest_type::value_type v) const  \n        {dest.on_next(action(v));} \n        void on_error(std::exception_ptr e) const  \n        { dest.on_error(e);} \n        void on_completed() const { \n            dest.on_completed(); \n        } \n        //--------- Create a subscriber with requisite parameter \n        //--------- types \n        static rxcpp::subscriber<value_type, observer_type>  \n                 make(const dest_type& d, const action_type& t) { \n            return rxcpp::make_subscriber<value_type> \n                 (d, observer_type(this_type(d, t))); \n        } \n    }; \n```", "```cpp\n    template<class Subscriber> \n    auto operator()(const Subscriber& dest) const \n        -> decltype(action_observer<Subscriber>::make(dest, action)) { \n        return      action_observer<Subscriber>::make(dest, action); \n    } \n}; \n////////////////////////////////////// \n// liftaction takes a Universal reference  \n// and uses perfect forwarding  \ntemplate<class Action> \nauto liftaction(Action&& p) ->  LiftAction<typename std::decay<Action>::type> \n{  \n   return  LiftAction<typename  \n           std::decay<Action>::type>(std::forward<Action>(p)); \n} \n```", "```cpp\nint main() { \n     std::array< int ,4 > a={{10, 20,30,40}}; \n     auto h = [] (observable<int> src ) { \n         return src.map([](int n ) { return n; }); \n     }; \n     auto g = [] (observable<int> src ) { \n         return src.map([](int n ) { return n*2; }); \n     }; \n     // type of values will be observable<int> \n     // Lazy Evaluation  ... the Lift operator \n     // converts a Lambda to be part of operator chaining\n     auto values = g(h(rxcpp::observable<>::iterate(a))) \n       .lift<int> (liftaction( [] ( int r ) { return 2*r; }));  \n     //-------- As usual subscribe  \n     values.subscribe(  \n              [] (int f) { std::cout << f <<  std::endl; } ,  \n              [] () {std::cout << \"Hello World..\" << std::endl;} ); \n} \n```", "```cpp\n40 \n80 \n120 \n160 \nHello World.. \n```", "```cpp\n\n//rx-eval.hpp   \n#if   !defined(RXCPP_OPERATORS_RX_EVAL_HPP)   \n#define   RXCPP_OPERATORS_RX_EVAL_HPP   \n//------------ all headers are   included here   \n#include \"../rx-includes.hpp\"   \nnamespace rxcpp {   \n    namespace operators {   \n        namespace detail {   \n          //-------------- operator   implementation goes here   \n        }\n    }\n}\n#endif   \n\n```", "```cpp\n#include \"operators/rx-eval.hpp\"   \n```", "```cpp\nstruct eval_tag {   \n    template<class Included>   \n    struct include_header{   \n          static_assert(Included::value, \n           \"missing include: please \n                   #include   <rxcpp/operators/rx-eval.hpp>\");   \n};   \n};   \n```", "```cpp\ntemplate<class... AN>   \nauto eval(AN&&... an)   const-> decltype(observable_member(eval_tag{},   \n *(this_type*)nullptr,   std::forward<AN>(an)...)){   \n        return    observable_member(eval_tag{},                 \n                   *this, std::forward<AN>(an)...);   \n}   \n```", "```cpp\nobservaable<T>::eval<T>( lambda<T>)\n```", "```cpp\n//----------- operatorComposeCustom.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <iostream> \nnamespace rxu=rxcpp::util; \n#include <array> \nusing namespace std; \nusing namespace rxcpp; \nusing namespace rxcpp::operators; \nint main() { \n     std::array< string ,4 > a={{\"Bjarne\",\"Kirk\",\"Herb\",\"Sean\"}}; \n     auto h = [] (observable<string> src ) { \n          return src.eval([](string s ) { return s+\"!\"; }); \n     }; \n     //-------- We will Lift g using eval \n     auto g = [](string s) { return \"Hello : \" + s; }; \n     // use apply h first and then call eval \n     auto values = h(rxcpp::observable<>::iterate(a)).eval(g);  \n     //-------- As usual subscribe  \n     values.subscribe(  \n              [] (string f) { std::cout << f <<  std::endl; } ,  \n              [] () {std::cout << \"Hello World..\" << std::endl;} ); \n} \n```", "```cpp\nHello : Bjarne! \nHello : Kirk! \nHello : Herb! \nHello : Sean! \nHello World.. \n```"]