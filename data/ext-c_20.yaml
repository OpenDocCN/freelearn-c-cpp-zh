- en: Chapter 20
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章
- en: Socket Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字编程
- en: 'In the previous chapter, we discussed single-host IPC and gave an introduction
    to socket programming. In this chapter, we want to complete our introduction and
    address socket programming in depth using a real client-server example: the calculator
    project.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了单主机进程间通信（IPC）并介绍了套接字编程。在这一章中，我们想要完成我们的介绍，并使用一个真实的客户端-服务器示例（计算器项目）深入探讨套接字编程。
- en: 'The order of topics in this chapter might seem a bit unusual, but the purpose
    is to give you a better understanding about various types of sockets and how they
    behave in a real project. As part of this chapter, we discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中主题的顺序可能看起来有些不寻常，但目的是让你更好地理解各种类型的套接字以及它们在实际项目中的行为。作为本章的一部分，我们讨论以下主题：
- en: Firstly, we give a review on what we explained in the previous chapter. Note
    that this review is just a short recap, and it is a must for you to read the second
    part of the previous chapter dedicated to socket programming.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们回顾一下前一章中我们解释的内容。请注意，这个回顾只是一个简短的总结，你必须阅读前一章关于套接字编程的第二部分。
- en: As part of the recap we discuss various types of sockets, stream and datagram
    sequences, and some other topics that are essential for our continuation of our
    calculator example.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为回顾的一部分，我们讨论了各种类型的套接字、流和数据报序列，以及对我们继续计算器示例至关重要的其他主题。
- en: The client-server example, the calculator project, is described and fully analyzed.
    This prepares us to continue with various components in the example and to present
    C code.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器示例，即计算器项目，被描述并全面分析。这为我们继续讨论示例中的各种组件和展示C代码做好了准备。
- en: As a critical component of the example, a serializer/deserializer library is developed.
    This library is going to represent the main protocol used between a calculator
    client and its server.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为示例的关键组件，我们开发了一个序列化/反序列化库。这个库将代表计算器客户端与其服务器之间使用的主要协议。
- en: It is crucial to understand that a calculator client and a calculator server
    must be able to communicate over any type of socket. Therefore, we present various
    types of sockets integrated within the example and as the starting point, **Unix
    domain sockets** (**UDS**) are introduced.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解这一点至关重要：计算器客户端和计算器服务器必须能够通过任何类型的套接字进行通信。因此，我们在示例中展示了各种类型的套接字，并以**Unix域套接字（UDS**）作为起点。
- en: We show in our example how they are used to establish a client-server connection
    in a single-host setup.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们展示了它们如何在单主机设置中建立客户端-服务器连接。
- en: To continue with other types of sockets, we discuss network sockets. We present
    how TCP and UDP sockets can be integrated within the calculator project.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了继续讨论其他类型的套接字，我们讨论网络套接字。我们展示了如何在计算器项目中集成TCP和UDP套接字。
- en: Let's begin the chapter with a summary of what we know about sockets and socket
    programming in general. It is highly recommended that you familiarize yourself
    with the second half of the previous chapter before delving into this chapter,
    as we assume some pre-existing knowledge here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从总结我们关于套接字和套接字编程的一般知识开始这一章。在深入本章内容之前，强烈建议你熟悉前一章的后半部分，因为我们在这里假设了一些先验知识。
- en: Socket programming review
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字编程回顾
- en: In this section, we are going to discuss what sockets are, what their various
    types are, and generally what it means if we say that we are doing socket programming.
    This is going to be a short review, but it is essential to build this basis so
    that we can continue into deeper discussion in subsequent sections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论什么是套接字，它们的各种类型是什么，以及如果我们说我们在进行套接字编程，这通常意味着什么。这将是一个简短的回顾，但这是建立这个基础所必需的，以便我们可以在后续章节中进行更深入的讨论。
- en: If you remember from the previous chapters, we have two categories of IPC techniques
    to be used by two or more processes to communicate and share data. The first category
    contains *pull-based* techniques that require an accessible *medium* (such as
    a shared memory or a regular file) to store data to and retrieve data from. The
    second category contains *push-based* techniques. These techniques require a *channel*
    to be established and the channel should be accessible by all processes. The main
    difference between these categories is regarding the way that data is retrieved
    from a medium in pull-based techniques, or a channel in push-based techniques.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得前几章的内容，我们有两种IPC技术类别，用于两个或更多进程进行通信和共享数据。第一类包含*基于拉取*的技术，这些技术需要一个可访问的*介质*（例如共享内存或常规文件）来存储数据和检索数据。第二类包含*基于推送*的技术。这些技术需要一个*通道*来建立，并且该通道应该对所有进程都是可访问的。这两类技术的主要区别在于，在基于拉取的技术中，数据是从介质中检索的方式，或者在基于推送的技术中，是从通道中检索的方式。
- en: To put it simply, in pull-based techniques, the data should be pulled or read
    from the medium, but in push-based techniques the data is pushed or delivered
    to the reader process automatically. In pull-based techniques, since the processes
    pull data from a shared medium, it is prone to race conditions if a number of
    them can write to that medium.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，在基于拉取的技术中，数据应该从介质中拉取或读取，但在基于推送的技术中，数据会自动推送到或交付给读取进程。在基于拉取的技术中，由于进程从共享介质中拉取数据，如果多个进程可以写入该介质，就容易出现竞态条件。
- en: To be more exact about push-based techniques, the data is always delivered to
    a buffer in the kernel and that buffer is accessible to the receiver process through
    using a descriptor (file or socket).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要更精确地描述基于推送的技术，数据始终被发送到内核中的一个缓冲区，并且该缓冲区可以通过使用描述符（文件或套接字）被接收进程访问。
- en: Then the receiver process can either block until some new data is available
    on that descriptor or it can *poll* the descriptor to see if the kernel has received
    some new data on that descriptor and if not, continue to some other work. The
    former approach is *blocking I/O* and the latter is *non-blocking I/O* or *asynchronous
    I/O*. In this chapter, all push-based techniques use the blocking approach.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，接收进程可以选择阻塞，直到该描述符上有可用的新数据，或者它可以*轮询*该描述符以查看内核是否在该描述符上接收到了新数据；如果没有，则继续执行其他工作。前者是*阻塞I/O*，后者是*非阻塞I/O*或*异步I/O*。在本章中，所有基于推送的技术都使用阻塞方法。
- en: We know that socket programming is a special type of IPC that belongs to the
    second category. Therefore, all socket-based IPCs are push-based. But the main
    characteristic that distinguishes socket programming from other push-based IPC
    techniques is the fact that in socket programming we use *sockets*. Sockets are
    special objects in Unix-like operating systems, even in Microsoft Windows which
    is not Unix-like, that represent *two-way channels*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，套接字编程是一种特殊的IPC（进程间通信）类型，属于第二类。因此，所有基于套接字的IPC都是基于推送的。但将套接字编程与其他基于推送的IPC技术区分开来的主要特征是，在套接字编程中我们使用*套接字*。套接字是类Unix操作系统中的一种特殊对象，甚至在非Unix-like的Microsoft
    Windows系统中，它代表*双向通道*。
- en: In other words, a single socket object can be used to both read from and write
    to the same channel. This way, two processes located at two sides of the same
    channel can have *two-way communication*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，单个套接字对象可以用来从同一个通道中读取和写入。这样，位于同一通道两端的两个进程可以实现*双向通信*。
- en: In the previous chapter, we saw that sockets are represented by socket descriptors,
    just like files that are represented by file descriptors. While socket descriptors
    and file descriptors are similar in certain ways such as I/O operation and being
    *poll-able*, they are in fact different. A single socket descriptor always represents
    a channel, but a file descriptor can represent a medium such as a regular file,
    or a channel like a POSIX pipe. Therefore, certain operations related to files
    such as seek are not supported for socket descriptors, and even for a file descriptor
    when it represents a channel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们了解到套接字由套接字描述符表示，就像文件由文件描述符表示一样。虽然套接字描述符和文件描述符在某些方面相似，例如I/O操作和可轮询性，但它们实际上是不同的。单个套接字描述符始终代表一个通道，但文件描述符可以代表一个介质，如常规文件，或者一个通道，如POSIX管道。因此，与文件相关的某些操作，如seek，不支持套接字描述符，甚至当文件描述符代表通道时也不支持。
- en: Socket-based communication can be *connection-oriented* or *connection-less*.
    In connection-oriented communication, the channel represents a *stream* of bytes being
    transmitted between two specific processes, while in connection-less communication,
    *datagrams* can be transmitted along the channel and there is no specific connection
    between two processes. A number of processes can use the same channel for sharing
    states or transmitting data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于套接字的通信可以是**面向连接**的或**无连接**的。在面向连接的通信中，通道代表两个特定进程之间传输的字节**流**，而在无连接通信中，**数据报**可以沿着通道传输，并且两个进程之间没有特定的连接。多个进程可以使用同一个通道来共享状态或传输数据。
- en: 'Therefore, we have two types of channels: *stream channels* and *datagram channels*.In
    a program, every stream channel is represented by a *stream socket* and every
    datagram channel is represented by a *datagram socket*. When setting up a channel,
    we have to decide if it should be either stream or datagram. We shortly see that
    our calculator example can support both channels.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两种类型的通道：**流通道**和**数据报通道**。在程序中，每个流通道都由一个**流套接字**表示，每个数据报通道都由一个**数据报套接字**表示。在设置通道时，我们必须决定它应该是流还是数据报。我们很快就会看到我们的计算器示例可以支持这两种通道。
- en: 'Sockets have various types. Each type of socket exists for a certain usage
    and a certain situation. Generally, we have two types of socket: UDS and network
    sockets. As you may know and as we''ve explained in the previous chapter, UDS
    can be used whenever all the processes willing to participate in an IPC are located
    on the same machine. In other words, UDS can be used only in single-host deployments.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字有多种类型。每种类型的套接字都是为了特定的用途和情况而存在的。通常，我们有两种类型的套接字：Unix域套接字（UDS）和网络套接字。正如您可能知道的那样，以及我们在上一章中解释的那样，UDS可以在所有希望参与进程间通信（IPC）的进程都位于同一台机器上时使用。换句话说，UDS只能在单主机部署中使用。
- en: In contrast, network sockets can be used in almost any deployment no matter
    how processes are deployed and where they are located. They can be all on the
    same machine, or they can be distributed throughout a network. In case of having
    a single-host deployment, UDS are preferred because they are faster, and they
    have less overhead in comparison to network sockets. As part of our calculator
    example, we provide the support for both UDS and network sockets.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，网络套接字几乎可以在任何部署中使用，无论进程如何部署以及它们位于何处。它们可以全部位于同一台机器上，也可以分布在整个网络中。在单主机部署的情况下，UDS更受欢迎，因为它们更快，并且与网络套接字相比，开销更小。作为我们计算器示例的一部分，我们提供了对UDS和网络套接字的支持。
- en: 'UDS and network sockets can represent both stream and datagram channels. Therefore,
    we have four varieties: UDS over a stream channel, UDS over a datagram channel,
    network socket over a stream channel, and finally network socket over a datagram
    channel. All these four variations are covered by our example.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: UDS和网络套接字可以代表流和数据报通道。因此，我们有四种类型：流通道上的UDS、数据报通道上的UDS、流通道上的网络套接字，以及最后是数据报通道上的网络套接字。所有这四种变化都在我们的示例中得到了涵盖。
- en: A network socket offering a stream channel is usually a TCP socket. That's because,
    most of the time, we are using TCP as the transport protocol for such a socket.
    Likewise, a network socket offering a datagram channel is usually a UDP socket.
    That's because, most of the time, we are using UDP as the transport protocol for
    such a socket. Note that UDS socket offering either stream or datagram channels
    don't have any specific names because there is no underlying transport protocol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 提供流通道的网络套接字通常是TCP套接字。这是因为，大多数情况下，我们使用TCP作为此类套接字的传输协议。同样，提供数据报通道的网络套接字通常是UDP套接字。这是因为，大多数情况下，我们使用UDP作为此类套接字的传输协议。请注意，提供流或数据报通道的UDS套接字没有特定的名称，因为没有底层传输协议。
- en: In order to write actual C code for the different types of sockets and channels,
    it is better to do it when you are working on a real example. That's basically
    why we have taken this unusual approach. This way, you'll notice the common parts
    between various types of sockets and the channels, and we can extract them as
    units of code that can be reused again. In the next section, we are going to discuss
    the calculator project and its internal structure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写针对不同类型套接字和通道的实际C代码，最好是在您处理真实示例时进行。这就是我们采取这种不寻常方法的基本原因。这样，您将注意到不同类型套接字和通道之间的共同部分，我们可以将它们提取为可重用的代码单元。在下一节中，我们将讨论计算器项目及其内部结构。
- en: Calculator project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算器项目
- en: 'We are dedicating a separate section to explain the purpose of the calculator
    project. It is a lengthy example and thus it will be helpful to have a firm grounding
    before diving into it. The project should help you to achieve the following goals:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专门用一节来解释计算器项目的目的。这是一个篇幅较长的示例，因此在深入之前有一个坚实的基础将非常有帮助。该项目应帮助你实现以下目标：
- en: Observe a fully functional example that has a number of simple and well-defined
    functionalities.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察一个具有多个简单且定义明确的功能的完全功能化示例。
- en: Extract common parts among the various types of sockets and channels and have
    them as some reusable libraries. This reduces the amount of code we write significantly,
    and from a learning point of view, it shows you the boundaries that are common
    between various types of sockets and channels.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从各种类型的套接字和通道中提取公共部分，并将它们作为一些可重用的库。这显著减少了我们需要编写的代码量，从学习的角度来看，它展示了不同类型的套接字和通道之间的共同边界。
- en: Maintain communication using a well-defined application protocol. Ordinary socket
    programming examples lack this very important feature. They generally address
    very simple, and usually one-time, communication scenarios between a client and
    its server.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用定义良好的应用程序协议来维护通信。普通的套接字编程示例缺乏这个非常重要的功能。它们通常处理客户端与其服务器之间非常简单且通常是单次通信场景。
- en: Work on an example that has all the ingredients required for a fully functional
    client-server program such as an application protocol, supporting various types
    of channels, having serializer/deserializer, and so on, giving you a different
    perspective regarding socket programming.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个示例中工作，这个示例包含了一个完全功能化的客户端-服务器程序所需的所有成分，例如应用程序协议、支持各种类型的通道、具有序列化/反序列化功能等，这为你提供了关于套接字编程的不同视角。
- en: With all that being said, we are going to present this project as our main example
    in this chapter. We do it step by step, and I will guide you through the various
    steps that culminate in a complete and working project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将把这个项目作为本章的主要示例来介绍。我们将一步一步地进行，我会引导你通过各种步骤，最终完成一个完整且可工作的项目。
- en: The first step is to come up with a relatively simple and complete application
    protocol. This protocol is going to be used between the clients and the server.
    As we explained before, without a well-defined application protocol, the two parties
    cannot communicate. They can be connected and transmit data because that's the functionality
    that the socket programming offers, but they cannot understand each other.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是提出一个相对简单且完整的应用程序协议。这个协议将在客户端和服务器之间使用。正如我们之前所解释的，如果没有一个定义良好的应用程序协议，双方就无法进行通信。他们可以连接并传输数据，因为这是套接字编程提供的功能，但他们无法相互理解。
- en: That's why we have to dedicate a bit of time to understand the application protocol
    used in the calculator project. Before talking about the application protocol,
    let's present the source hierarchy that can be seen in the project code base.
    Then, we can find the application protocol and the associated serializer/deserializer
    library much easier in the project code base.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要花一些时间来理解计算器项目中使用的应用程序协议。在讨论应用程序协议之前，让我们先展示项目代码库中可以看到的源代码层次结构。然后，我们可以在项目代码库中更容易地找到应用程序协议和相关的序列化/反序列化库。
- en: Source hierarchy
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码层次结构
- en: From a programmer's point of view, the POSIX socket programming API treats all
    the stream channels the same no matter whether the associated socket object is
    a UDS or a network socket. If you remember from the previous chapter, for stream
    channels, we had certain sequences for the listener-side and for the connector-side,
    and these sequences remain the same for different types of stream sockets.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的视角来看，POSIX套接字编程API无论关联的套接字对象是uds还是网络套接字，都同等对待所有流通道。如果你还记得上一章的内容，对于流通道，我们有监听端和连接端的特定序列，并且这些序列对于不同类型的流套接字来说是相同的。
- en: Therefore, if you are going to support various types of sockets, together with
    various types of channels, it is better to extract the common part and write it
    once. That's exactly the approach that we take regarding the calculator project
    and that's what you see in the source code. Therefore, it is expected to see various
    libraries in the project and some of them contain the common code that is reused
    by other parts of the code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您打算支持各种类型的套接字以及各种类型的通道，最好提取公共部分并一次性编写。这正是我们对待计算器项目的方法，这也是您在源代码中看到的方法。因此，预计在项目中会看到各种库，其中一些包含其他代码部分复用的公共代码。
- en: 'Now, it''s time to delve into the code base. First of all, the source code
    of the project can be found here: https://github.com/PacktPublishing/Extreme-C/tree/master/ch20-socket-programming.
    If you open the link and have a look at the code base, you see there are a number
    of directories that contain multiple source files. Obviously, we cannot demonstrate
    all of them because this would take too long, but we are going to explain important
    parts of the code. You are encouraged to look at the code and go through it, then
    try to build and run it; this will give you an idea of how the example has been
    developed.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候深入代码库了。首先，项目的源代码可以在这里找到：https://github.com/PacktPublishing/Extreme-C/tree/master/ch20-socket-programming。如果您打开链接并查看代码库，您会看到有多个包含多个源文件的目录。显然，我们无法演示所有这些目录，因为这会花费太多时间，但我们将解释代码的重要部分。我们鼓励您查看代码，并尝试构建和运行它；这将给您一个关于示例是如何开发的思路。
- en: Note that all the code relating to the examples of UDS, UDP sockets, and TCP
    sockets has been put in a single hierarchy. Next, we are going to explain the
    source hierarchy and the directories you find as part of the code base.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有与UDS、UDP套接字和TCP套接字示例相关的代码都已放入一个单独的层次结构中。接下来，我们将解释源层次结构和您在代码库中找到的目录。
- en: If you go to the root of the example and use the `tree` command to show the
    files and directories, you will find something similar to *Shell Box 20-1*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进入示例的根目录并使用`tree`命令显示文件和目录，您将找到类似于*Shell Box 20-1*的内容。
- en: 'The following shell box demonstrates how to clone the book''s GitHub repository
    and how to navigate to the root of the example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Shell Box演示了如何克隆本书的GitHub仓库以及如何导航到示例的根目录：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Shell Box 20-1: Cloning the calculator project''s code base and listing the
    files and directories'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 20-1：克隆计算器项目的代码库并列出文件和目录
- en: 'As you can see in the listing of files and directories, the calculator project
    is made up of a number of parts, some of them being libraries, and each of them
    having its own dedicated directory. Next, we explain these directories:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在文件和目录列表中所见，计算器项目由多个部分组成，其中一些是库，每个部分都有自己的专用目录。接下来，我们将解释这些目录：
- en: '`/calcser`: This is the serializer/deserializer library. It contains the serialization/deserialization-related
    source files. This library dictates the application protocol that is defined between
    a calculator client and a calculator server. This library is eventually built
    into a static library file named `libcalcser.a`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/calcser`：这是一个序列化/反序列化库。它包含与序列化/反序列化相关的源文件。这个库决定了计算器客户端和计算器服务器之间定义的应用协议。这个库最终被构建成一个名为`libcalcser.a`的静态库文件。'
- en: '`/calcsvc`: This library contains the sources for the calculation service.
    The *calculation service* is different from the server process. This service library
    contains the core functionality of the calculator and it is agnostic regarding
    being behind a server process and can be used individually as a separate standalone
    C library. This library eventually gets built into a static library file named
    `libcalcsvc.a`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/calcsvc`：这个库包含计算服务器的源代码。*计算服务*与服务器进程不同。这个服务库包含计算器的核心功能，并且与是否位于服务器进程之后无关，它可以作为一个独立的独立C库单独使用。这个库最终被构建成一个名为`libcalcsvc.a`的静态库文件。'
- en: '`/server/srvcore`: This library contains the sources that are common between
    the stream and the datagram server processes, regardless of the socket type. Therefore,
    all calculator server processes, whether using UDS or network sockets, and whether
    operating on stream or datagram channels, can rely on this common part. The final
    output of this library is a static library file named `libsrvcore.a`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/server/srvcore`: 此库包含流和数据报服务器进程之间共有的源代码，无论套接字类型如何。因此，所有计算器服务器进程，无论它们是否使用
    UDS 或网络套接字，以及无论它们是在流通道还是数据报通道上操作，都可以依赖这个通用部分。此库的最终输出是一个名为 `libsrvcore.a` 的静态库文件。'
- en: '`/server/unix/stream`: This directory contains the sources for a server program
    using stream channels behind a UDS. The final build result of this directory is
    an executable file named `unix_stream_calc_server`. This is one of the possible
    output executables in this project that we can use to bring up a calculator server,
    this one listening on a UDS to receive stream connections.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/server/unix/stream`: 此目录包含使用 UDS 后端流通道的服务器程序的源代码。此目录的最终构建结果是名为 `unix_stream_calc_server`
    的可执行文件。这是本项目中可能生成的输出可执行文件之一，我们可以使用它来启动计算器服务器，该服务器监听 UDS 以接收流连接。'
- en: '`/server/unix/datagram`: This directory contains the sources for a server program
    using datagram channels behind a UDS. The final build result of this directory
    is an executable file named `unix_datagram_calc_server`. This is one of the possible
    output executables in this project that we can use to bring up a calculator server,
    this one listening on a UDS to receive datagram messages.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/server/unix/datagram`: 此目录包含使用 UDS 后端数据报通道的服务器程序的源代码。此目录的最终构建结果是名为 `unix_datagram_calc_server`
    的可执行文件。这是本项目中可能生成的输出可执行文件之一，我们可以使用它来启动计算器服务器，该服务器监听 UDS 以接收数据报消息。'
- en: '`/server/tcp`: This directory contains the sources for a server program using
    stream channels behind a TCP network socket. The final build result of this directory
    is an executable file named `tcp_calc_server`. This is one of the possible output
    executables in this project that we can use to bring up a calculator server, this
    one listening on a TCP socket to receive stream connections.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/server/tcp`: 此目录包含使用 TCP 网络套接字后端流通道的服务器程序的源代码。此目录的最终构建结果是名为 `tcp_calc_server`
    的可执行文件。这是本项目中可能生成的输出可执行文件之一，我们可以使用它来启动计算器服务器，该服务器监听 TCP 套接字以接收流连接。'
- en: '`/server/udp`: This directory contains the sources for a server program using
    datagram channels behind a UDP network socket. The final build result of this
    directory is an executable file named `udp_calc_server`. This is one of the possible
    output executables in this project that we can use to bring up a calculator server,
    this one listening on a UDP socket to receive datagram messages.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/server/udp`: 此目录包含使用 UDP 网络套接字后端数据报通道的服务器程序的源代码。此目录的最终构建结果是名为 `udp_calc_server`
    的可执行文件。这是本项目中可能生成的输出可执行文件之一，我们可以使用它来启动计算器服务器，该服务器监听 UDP 套接字以接收数据报消息。'
- en: '`/client/clicore`: This library contains the sources that are common between
    the stream and the datagram client processes, regardless of the socket type. Therefore,
    all calculator client processes, no matter whether they are using UDS or network
    sockets, and no matter operating on stream or datagram channels, can rely on this
    common part. It would be built into a static library file named `libclicore.a`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/client/clicore`: 此库包含流和数据报客户端进程之间共有的源代码，无论套接字类型如何。因此，所有计算器客户端进程，无论它们是否使用
    UDS 或网络套接字，以及无论它们是在流通道还是数据报通道上操作，都可以依赖这个通用部分。它将被构建成一个名为 `libclicore.a` 的静态库文件。'
- en: '`/client/unix/stream`: This directory contains the sources for a client program
    using stream channels behind a UDS. The final build result of this directory is
    an executable file named `unix_stream_calc_client`. This is one of the possible
    output executables in this project that we can use to start a calculator client,
    this one connecting to a UDS endpoint and establishing a stream connection.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/client/unix/stream`: 此目录包含使用 UDS 后端流通道的客户端程序的源代码。此目录的最终构建结果是名为 `unix_stream_calc_client`
    的可执行文件。这是本项目中可能生成的输出可执行文件之一，我们可以使用它来启动计算器客户端，该客户端连接到 UDS 端点并建立流连接。'
- en: '`/client/unix/datagram`: This directory contains the sources for a client program
    using datagram channels behind a UDS. The final build result of this directory
    is an executable file named `unix_datagram_calc_client`. This is one of the possible
    output executables in this project that we can use to start a calculator client,
    this one connecting to a UDS endpoint and sending some datagram messages.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/client/unix/datagram`：此目录包含使用UDS后端数据报通道的客户端程序源代码。此目录的最终构建结果是名为`unix_datagram_calc_client`的可执行文件。这是本项目可能的输出可执行文件之一，我们可以使用它来启动计算器客户端，该客户端连接到UDS端点并发送一些数据报消息。'
- en: '`/client/tcp`: This directory contains the sources for a client program using
    stream channels behind a TCP socket. The final build result of this directory
    is an executable file named `tcp_calc_client`. This is one of the possible output
    executables in this project that we can use to start a calculator client, this
    one connecting to a TCP socket endpoint and establishing a stream connection.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/client/tcp`：此目录包含使用TCP套接字后端流通道的客户端程序源代码。此目录的最终构建结果是名为`tcp_calc_client`的可执行文件。这是本项目可能的输出可执行文件之一，我们可以使用它来启动计算器客户端，该客户端连接到TCP套接字端点并建立一个流连接。'
- en: '`/client/udp`: This directory contains the sources for a client program using
    datagram channels behind a UDP socket. The final build result of this directory
    is an executable file named `udp_calc_client`. This is one of the possible output
    executables in this project that we can use to start a calculator client, this
    one connecting to a UDP socket endpoint and sending some datagram messages.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/client/udp`：此目录包含使用UDP套接字后端数据报通道的客户端程序源代码。此目录的最终构建结果是名为`udp_calc_client`的可执行文件。这是本项目可能的输出可执行文件之一，我们可以使用它来启动计算器客户端，该客户端连接到UDP套接字端点并发送一些数据报消息。'
- en: Build the project
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建项目
- en: Now that we have gone through all the directories in the project, we need to
    show how to build it. The project uses CMake, and you should have it installed
    before moving on to build the project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了项目中的所有目录，我们需要展示如何构建它。该项目使用CMake，在构建项目之前，您应该已经安装了它。
- en: 'In order to build the project, run the following commands in the chapter''s
    root directory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建项目，在章节根目录中运行以下命令：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Shell Box 20-2: The commands to build the calculator project'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 20-2：构建计算器项目的命令
- en: Run the project
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行项目
- en: There is nothing like running a project to see for yourself how it works. Therefore,
    before delving into technical details, I want you to bring up a calculator server,
    and then a calculator client, and finally see how they talk to each other.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比亲自运行项目来看到它是如何工作的更好的了。因此，在深入研究技术细节之前，我想让您启动一个计算器服务器，然后是一个计算器客户端，最后看看它们是如何互相通信的。
- en: Before running the processes, you need to have two separate Terminals (or shells)
    in order to enter two separate commands. In the first Terminal, in order to run
    a stream server listening on UDS, type the following command.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行进程之前，您需要有两个独立的终端（或shell），以便输入两个不同的命令。在第一个终端中，为了运行监听UDS的流服务器，请输入以下命令。
- en: 'Note that you need to be in the `build` directory before entering the following
    command. The `build` directory was made as part of the previous section, *Build
    the Project*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在输入以下命令之前，您需要处于`build`目录中。`build`目录是上一节*构建项目*中创建的：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Shell Box 20-3: Running a stream server listening on a UDS'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 20-3：运行监听UDS的流服务器
- en: 'Ensure the server is running. In the second Terminal, run the stream client
    built for using UDS:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 确保服务器正在运行。在第二个终端中，运行为使用UDS构建的流客户端：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 20-4: Running the calculator client and sending some requests'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 20-4：运行计算器客户端并发送一些请求
- en: As you see in the preceding shell box, the client process has its own command
    line. It receives some commands from the user, turns them into some requests according
    to the application protocol, and sends them to the server for further processing.
    Then, it waits for the response and, as soon as it receives it, prints the result.
    Note that this command line is part of the common code written for all clients
    and therefore, no matter the channel type or socket type the client is using,
    you always see the client command line.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在先前的Shell Box中看到的那样，客户端进程有自己的命令行。它从用户那里接收一些命令，根据应用程序协议将它们转换为一些请求，并将它们发送到服务器进行进一步处理。然后，它等待响应，并在收到响应后立即打印结果。请注意，此命令行是所有客户端共同编写的通用代码的一部分，因此，无论客户端使用的是哪种通道类型或套接字类型，您总是看到客户端命令行。
- en: Now, it's time to jump into the details of the application protocol and see
    how request and response messages look like.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候深入了解应用协议，看看请求和响应消息看起来像什么。
- en: Application protocol
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用协议
- en: Any two processes willing to communicate must obey an application protocol.
    This protocol can be custom, like the calculator project, or it can be one of
    the well-known protocols like HTTP. We call our protocol the *calculator protocol*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 任何想要通信的两个进程都必须遵守一个应用协议。这个协议可以是定制的，比如计算器项目，也可以是众所周知的一些协议，如 HTTP。我们称我们的协议为 *计算器协议*。
- en: The calculator protocol is a variable-length protocol. In other words, every
    message has its own length and every message should be separated from the next
    one using a delimiter. There is only one type of request message and one type
    of response message. The protocol is also textual. It means that we use only alphanumerical
    characters together with a few other characters as valid characters in request
    and response messages. In other words, the calculator messages are human-readable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器协议是一个可变长度的协议。换句话说，每个消息都有自己的长度，每个消息都应该使用分隔符与下一个消息分开。只有一个请求消息类型和一个响应消息类型。该协议也是文本的。这意味着我们只使用字母数字字符以及一些其他字符作为请求和响应消息中的有效字符。换句话说，计算器消息是可读的。
- en: 'The request message has four fields: *request ID*, *method*, *first operand*,
    and *second operand*. Every request has a unique ID and the server uses this ID
    to relate a response to its corresponding request.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请求消息有四个字段：*请求 ID*、*方法*、*第一个操作数*和*第二个操作数*。每个请求都有一个唯一的 ID，服务器使用这个 ID 将响应与其对应的请求相关联。
- en: 'The method is an operation that can be performed by the calculator service.
    Next, you can see the `calcser/calc_proto_req.h` header file. This file describes
    the calculator protocol''s request message:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是计算器服务可以执行的操作。接下来，你可以看到 `calcser/calc_proto_req.h` 头文件。这个文件描述了计算器协议的请求消息：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 20-1 [calcser/calc_proto_req.h]: Definition of the calculator request
    object'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-1 [calcser/calc_proto_req.h]：计算器请求对象的定义
- en: As you can see, we have nine methods defined as part of our protocol. As a good
    calculator, our calculator has an internal memory, and because of that we have
    memory operations associated with addition, subtraction, and multiplication.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们定义了九种方法作为我们协议的一部分。作为一个好的计算器，我们的计算器有一个内部内存，因此我们有关加法、减法和乘法的内存操作。
- en: For example, the `ADD` method simply adds two float numbers, but the `ADDM`
    method is a variation of the `ADD` method that adds those two numbers together
    with the value stored in the internal memory, and finally it updates the value
    in the memory for further use. It is just like when you use the memory button
    on your desktop calculator. You can find that button marked as +M.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ADD` 方法只是简单地相加两个浮点数，但 `ADDM` 方法是 `ADD` 方法的变体，它将这两个数与内部存储的值相加，并最终更新内存中的值以供进一步使用。这就像你使用台式计算器的内存按钮一样。你可以找到一个标记为
    +M 的按钮。
- en: We also have a special method for reading and resetting the calculator's internal
    memory. The division method cannot be performed on the internal memory, so we
    don't have any other variation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个用于读取和重置计算器内部内存的特殊方法。除法方法不能在内部内存上执行，所以我们没有其他变体。
- en: 'Suppose that the client wants to create a request with ID `1000`, using the
    `ADD` method, and with `1.5` and `5.6` as the operands. In C, it needs to create
    an object from the `calc_proto_req_t` type (the structure declared in the preceding
    header as part of *Code Box 20-1*) and fill it with the desired values. Next,
    you can see how to do it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设客户端想要使用 `ADD` 方法创建一个 ID 为 `1000` 的请求，并且操作数为 `1.5` 和 `5.6`。在 C 语言中，需要从 `calc_proto_req_t`
    类型（在前面头文件中作为 *代码框 20-1* 部分声明）创建一个对象，并填充所需的值。接下来，你可以看到如何操作：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 20-2: Creating a calculator request object in C'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-2：在 C 语言中创建计算器请求对象
- en: 'As we explained in the previous chapter, the `req` object in the preceding
    code box needs to be serialized to a request message before being sent to the
    server. In other words, we need to serialize the preceding *request object* to
    the equivalent *request message*. The serializer in the calculator project, according
    to our application protocol, serializes the `req` object as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中解释的，前面代码框中的 `req` 对象在发送到服务器之前需要序列化为请求消息。换句话说，我们需要将前面的 *请求对象* 序列化为等效的
    *请求消息*。根据我们的应用协议，计算器项目中的序列化器将 `req` 对象序列化如下：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 20-3: The serialized message equivalent to the req object defined
    in Code Box 20-2'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-3：与代码框20-2中定义的req对象等价的序列化消息
- en: As you can see, the `#` character is used as the *field delimiter*, and the
    `$` character is used as the *message separator*. In addition, each request message
    has exactly four fields. A *deserializer* object on the other side of the channel
    uses these facts to parse the incoming bytes and revive the request object again.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`#`字符用作*字段分隔符*，而`$`字符用作*消息分隔符*。此外，每个请求消息恰好有四个字段。通道另一端的*反序列化器*对象使用这些事实来解析传入的字节并重新恢复请求对象。
- en: 'Conversely, the server process needs to serialize the response object while
    replying to a request. A calculator response object has three fields: *request
    ID*, *status*, and *result*. The request ID determines the corresponding request.
    Every request has a unique ID and this way, the server specifies the request that
    it wants to respond to.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，服务器进程在回复请求时需要序列化响应对象。计算器响应对象有三个字段：*请求ID*、*状态*和*结果*。请求ID确定相应的请求。每个请求都有一个唯一的ID，这样服务器就可以指定它想要响应的请求。
- en: 'The `calcser/calc_proto_resp.h` header file describes what a calculator response
    should look like, and you can see it in the following code box:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`calcser/calc_proto_resp.h`头文件描述了计算器响应应该是什么样子，您可以在下面的代码框中看到：'
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code Box 20-4 [calcser/calc_proto_resp.h]: Definition of the calculator response
    object'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-4 [calcser/calc_proto_resp.h]：计算器响应对象的定义
- en: 'Similarly, in order to create a *response object* for the preceding request
    object, `req`, mentioned in *Code Box 20-2*, the server process should do this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了为前面提到的*代码框20-2*中的`req`请求对象创建一个响应对象，服务器进程应该这样做：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 20-5: Creating a response object for the request object req defined
    as part of Code Box 20-2'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-5：为代码框20-2中定义的请求对象req创建响应对象
- en: 'The preceding response object is serialized as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的响应对象按以下方式序列化：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 20-6: The serialized response message equivalent to the resp object
    created in the Code Box 20-5'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-6：与代码框20-5中创建的resp对象等价的序列化响应消息
- en: Again, we use `#` as the field delimiter and `$` as the message separator. Note
    that the status is numerical, and it indicates the success or failure of the request.
    In the case of failure, it is a non-zero number, and its meaning is described
    in the response header file, or to be exact, in the calculator protocol.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用`#`作为字段分隔符，`$`作为消息分隔符。请注意，状态是数值型的，它表示请求的成功或失败。在失败的情况下，它是一个非零数字，其含义在响应头文件中描述，或者更确切地说，在计算器协议中描述。
- en: Now, it is time to talk a bit more about the serialization/deserialization library
    and what its internals look like.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更详细地谈谈序列化/反序列化库及其内部结构了。
- en: Serialization/deserialization library
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化/反序列化库
- en: In the previous section, we described how the request and response messages
    look like. In this section, we are going to talk a bit more about the serializer
    and deserializer algorithms used in the calculator project. We are going to use
    the `serializer` class, with `calc_proto_ser_t` as its attribute structure, for
    providing the serialization and deserialization functionalities.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们描述了请求和响应消息的格式。在本节中，我们将更详细地讨论计算器项目中使用的序列化和反序列化算法。我们将使用`serializer`类，其属性结构为`calc_proto_ser_t`，以提供序列化和反序列化功能。
- en: 'As said before, these functionalities are provided to other parts of the project
    as a static library named `libcalcser.a`. Here, you can see the public API of
    the `serializer` class found in `calcser/calc_proto_ser.h`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些功能作为名为`libcalcser.a`的静态库提供给项目的其他部分。在这里，您可以看到`calcser/calc_proto_ser.h`中找到的`serializer`类的公共API：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 20-7 [calcser/calc_proto_ser.h]: The public interface of the Serializer
    class'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-7 [calcser/calc_proto_ser.h]：序列化器类的公共接口
- en: Apart from the constructor and destructor functions required for creating and
    destroying a serializer object, we have a pair of functions that should be used
    by the server process, and another pair of functions that should be used by the
    client process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建和销毁序列化器对象所需的构造函数和析构函数之外，我们还有一对应由服务器进程使用的函数，以及另一对应由客户端进程使用的函数。
- en: On the client side, we serialize the request object and we deserialize the response
    message. Meanwhile on the server side, we deserialize the request message and
    we serialize the response object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们序列化请求对象，并反序列化响应消息。同时，在服务器端，我们反序列化请求消息，并序列化响应对象。
- en: 'In addition to serialization and deserialization functions, we have three *callback
    functions*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了序列化和反序列化函数之外，我们还有三个 *回调函数*：
- en: A callback for receiving a request object that has been deserialized from the
    underlying channel
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收从底层通道反序列化的请求对象的回调
- en: A callback for receiving a response object that has been deserialized from the
    underlying channel
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收从底层通道反序列化的响应对象的回调
- en: A callback for receiving the error when a serialization or a deserialization
    has failed
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收序列化或反序列化失败时错误的回调
- en: These callbacks are used by client and server processes to receive incoming
    requests and responses and also the errors that are found during serialization
    and deserialization of a message.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调由客户端和服务器进程用于接收传入的请求和响应，以及序列化和反序列化消息过程中发现的错误。
- en: Now, let's have a deeper look at serialization/deserialization functions for
    the server side.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地看看服务器端的序列化/反序列化函数。
- en: Server-side serializer/deserializer functions
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端序列化/反序列化函数
- en: We have two functions for the server process to serialize a response object
    and deserialize a request message. We begin with the response serialization function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个函数用于服务器进程序列化响应对象和反序列化请求消息。我们首先从响应序列化函数开始。
- en: 'The following code box contains the code for the response serialization function
    `calc_proto_ser_server_serialize`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含响应序列化函数 `calc_proto_ser_server_serialize` 的代码：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 20-8 [calcser/calc_proto_ser.c]: The server-side response serializer
    function'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-8 [calcser/calc_proto_ser.c]：服务器端响应序列化函数
- en: 'As you can see, `resp` is a pointer to a response object that needs to be serialized.
    This function returns a `buffer_t object`, which is declared as follows as part
    of the `calc_proto_ser.h` header file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`resp` 是一个指向需要序列化的响应对象的指针。此函数返回一个 `buffer_t` 对象，该对象在 `calc_proto_ser.h`
    头文件中声明如下：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 20-9 [calcser/calc_proto_ser.h]: The definition of buffer_t'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-9 [calcser/calc_proto_ser.h]：`buffer_t` 的定义
- en: The serializer code is simple and it consists mainly of a `sprintf` statement
    that creates the response string message. Now, let's look at the request deserializer
    function. Deserialization is usually more difficult to implement, and if you go
    to the code base and follow the function calls, you see how complicated it can
    be.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化代码很简单，主要由一个创建响应字符串消息的 `sprintf` 语句组成。现在，让我们看看请求反序列化函数。反序列化通常更难实现，如果您查看代码库并跟踪函数调用，您会看到它可以多么复杂。
- en: '*Code Box 20-9* contains the request deserialization function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码框 20-9* 包含请求反序列化函数：'
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 20-9 [calcser/calc_proto_ser.c]: The server-side request deserialization
    function'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-9 [calcser/calc_proto_ser.c]：服务器端请求反序列化函数
- en: The preceding function seems to be simple, but in fact it uses the `_deserialize`
    and `_parse_req_and_notify` private functions. These functions are defined in
    the `calc_proto_ser.c` file, which contains the actual implementation of the `Serializer`
    class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数看起来很简单，但实际上它使用了 `_deserialize` 和 `_parse_req_and_notify` 私有函数。这些函数在 `calc_proto_ser.c`
    文件中定义，该文件包含 `Serializer` 类的实际实现。
- en: It would be intense and beyond the scope of this book to bring in and discuss
    the code we have for the mentioned private functions, but to give you an idea,
    especially for when you want to read the source code, the deserializer uses a
    *ring buffer* with a fixed length and tries to find `$` as the message separator.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们为提到的私有函数编写的代码引入并讨论可能会非常复杂，超出了本书的范围，但为了给您一个概念，尤其是当您想阅读源代码时，反序列化器使用一个固定长度的
    *环形缓冲区* 并尝试找到 `$` 作为消息分隔符。
- en: Whenever it finds `$`, it calls the function pointer, which in this case points
    to the `_parse_req_and_notify` function (the third argument passed in the `_deserialize`
    function). The `_parse_req_and_notify` function tries to extract the fields and
    resurrect the request object. Then, it notifies the registered *observer*, in
    this case the server object that is waiting for a request through the callback
    functions, to proceed with the request object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每当它找到`$`时，它就会调用函数指针，在这个例子中，它指向`_parse_req_and_notify`函数（在`_deserialize`函数中传入的第三个参数）。`_parse_req_and_notify`函数试图提取字段并恢复请求对象。然后，它通知已注册的*观察者*，在这种情况下是等待通过回调函数接收请求的服务器对象，以继续处理请求对象。
- en: Now, let's look at the functions used by the client side.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看客户端使用的函数。
- en: Client-side serializer/deserializer functions
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端序列化/反序列化函数
- en: Just as for the server side, we have two functions on the client side. One for
    serializing the request object, and the other one meant to deserialize the incoming
    response.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像服务器端一样，客户端也有两个函数。一个用于序列化请求对象，另一个用于反序列化传入的响应。
- en: 'We begin with the request serializer. You can see the definition in *Code Box
    20-10*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从请求序列化器开始。你可以在*代码框 20-10*中看到其定义：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code Box 20-10 [calcser/calc_proto_ser.c]: The client-side request serialization
    function'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-10 [calcser/calc_proto_ser.c]：客户端请求序列化函数
- en: As you can see, it accepts a request object and returns a `buffer` object, totally
    similar to the response serializer on the server side. It even uses the same technique;
    a `sprintf` statement for creating the request message.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它接受一个请求对象并返回一个`buffer`对象，与服务器端响应序列化器完全相同。它甚至使用了相同的技巧；使用`sprintf`语句创建请求消息。
- en: '*Code Box 20-11* contains the response deserializer function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码框 20-11* 包含响应反序列化函数：'
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Code Box 20-11 [calcser/calc_proto_ser.c]: The client-side response deserialization
    function'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-11 [calcser/calc_proto_ser.c]：客户端响应反序列化函数
- en: As you can see, the same mechanism is employed, and some similar private functions
    have been used. It is highly recommended to read these sources carefully, in order
    to get a better understanding of how the various parts of the code have been put
    together to have the maximum reuse of the existing parts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用了相同的机制，并且使用了一些类似的私有函数。强烈建议仔细阅读这些源代码，以便更好地理解代码的各个部分是如何组合在一起以实现最大程度的代码复用。
- en: We won't go any deeper than this into the `Serializer` class; it's up to you
    to dig into the code and finds out how it works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨`Serializer`类；深入代码并找出它是如何工作的，这取决于你。
- en: Now that we have the serializer library, we can proceed and write our client
    and server programs. Having a library that serializes objects and deserializes
    messages based on an agreed application protocol is a vital step in writing multi-process
    software. Note that it doesn't matter if the deployment is single-host or contains
    multiple hosts; the processes should be able to understand each other, and proper
    application protocols should have been defined.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了序列化库，我们可以继续编写客户端和服务器程序。拥有一个基于协议序列化对象和反序列化消息的库是编写多进程软件的重要一步。请注意，部署是单主机还是包含多个主机无关紧要；进程应该能够相互理解，并且应该已经定义了适当的应用程序协议。
- en: 'Before jumping to code regarding socket programming, we have to explain one
    more thing: the calculator service. It is at the heart of the server process and
    it does the actual calculation.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到关于套接字编程的代码之前，我们还需要解释一件事：计算器服务。它是服务器进程的核心，并执行实际的计算。
- en: Calculator service
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算器服务
- en: The calculator service is the core logic of our example. Note that this logic
    should work independently of the underlying IPC mechanism. The upcoming code shows
    the declaration of the calculator service class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器服务是我们示例的核心逻辑。请注意，这个逻辑应该独立于底层IPC机制工作。下面的代码显示了计算器服务类的声明。
- en: 'As you can see, it is designed in such a way that it can be used even in a
    very simple program, with just a `main` function, such that it doesn''t even do
    any IPC at all:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它被设计成即使在非常简单的程序中也可以使用，只需要一个`main`函数，以至于它甚至不做任何IPC操作：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Code Box 20-12 [calcsvc/calc_service.h]: The public interface of the calculator
    service class'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-12 [calcsvc/calc_service.h]：计算器服务类的公共接口
- en: As you can see, the preceding class even has its own error types. The input
    arguments are pure C types, and it is in no way dependent on IPC-related or serialization-related
    classes or types. Since it is isolated as a standalone logic, we compile it into
    an independent static library named `libcalcsvc.a`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的类甚至有自己的错误类型。输入参数是纯C类型，并且它完全不依赖于IPC相关或序列化相关的类或类型。由于它是作为一个独立的逻辑单元隔离的，我们将其编译成一个名为`libcalcsvc.a`的独立静态库。
- en: Every server process must use the calculator service objects in order to do
    the actual calculations. These objects are usually called the *service objects*.
    Because of this, the final server program must get linked against this library.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务器进程都必须使用计算器服务对象来进行实际的计算。这些对象通常被称为*服务对象*。因此，最终的服务器程序必须与这个库链接。
- en: 'An important note before we go further: if, for a specific client, the calculations
    don''t need a specific context, then having just one service object is enough.
    In other words, if a service for a client doesn''t require us to remember any
    state from the previous requests of that client, then we can use a *singleton*
    service object. We call this a *stateless service object*.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前的一个重要注意事项：如果对于特定的客户端，计算不需要特定的上下文，那么只需要一个服务对象就足够了。换句话说，如果一个客户端的服务不需要我们记住该客户端之前请求的任何状态，那么我们可以使用一个*单例*服务对象。我们称之为*无状态服务对象*。
- en: Conversely, if handling the current request demands knowing something from the
    previous requests, then for every client, we need to have a specific service object.
    This is the case regarding our calculator project. As you know, the calculator
    has an internal memory that is unique for each client. Therefore, we cannot use
    the same object for two clients. These objects are known as *stateful service
    objects*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果处理当前请求需要了解之前请求中的某些信息，那么对于每个客户端，我们需要有一个特定的服务对象。这种情况适用于我们的计算器项目。正如您所知，计算器有一个针对每个客户端独特的内部存储。因此，我们不能为两个客户端使用同一个对象。这些对象被称为*有状态的服务对象*。
- en: To summarize what we said above, for every client, we have to create a new service
    object. This way, every client has its own calculator with its own dedicated internal
    memory. Calculator service objects are stateful and they need to load some state
    (the value of the internal memory).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总结我们上面所说的，对于每个客户端，我们必须创建一个新的服务对象。这样，每个客户端都有自己的计算器，并拥有自己专用的内部存储。计算器服务对象是有状态的，并且需要加载一些状态（内部存储的值）。
- en: Now, we are in a good position to move forward and talk about various types
    of sockets, with examples given in the context of the calculator project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们处于一个很好的位置来继续前进，讨论各种类型的套接字，并在计算器项目的上下文中给出示例。
- en: Unix domain sockets
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix域套接字
- en: From the previous chapter, we know that if we are going to establish a connection
    between two processes on the same machine, UDS are one of the best options. In
    this chapter, we expanded our discussion and talked a bit more about push-based
    IPC techniques, as well as stream and datagram channels. Now it's time to gather
    our knowledge from previous and current chapters and see UDS in action.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，我们知道如果我们打算在同一台机器上的两个进程之间建立连接，UDS是最佳选择之一。在这一章中，我们扩展了我们的讨论，并更多地讨论了基于推的IPC技术，以及流和数据报通道。现在，是时候将之前和当前章节的知识结合起来，看看UDS的实际应用了。
- en: In this section, we have four subsections dedicated to processes being on the
    listener side or the connector side and operating on a stream or a datagram channel.
    All of these processes are using UDS. We go through the steps they should take
    to establish the channel, based on the sequences we discussed in the previous
    chapter. As the first process, we start with the listener process operating on
    a stream channel. This would be the *stream server*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们有四个小节专门讨论在监听器侧或连接器侧的进程，并在流或数据报通道上操作。所有这些进程都在使用UDS。我们根据上一章讨论的序列，逐步说明它们建立通道的步骤。作为第一个进程，我们从在流通道上操作的监听器进程开始。这将是一个*流服务器*。
- en: UDS stream server
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDS流服务器
- en: If you remember from the previous chapter, we had a number of sequences for
    listener and connector sides in a transport communication. A server stands in
    the position of a listener. Therefore, it should follow the listener sequence.
    More specifically, since we are talking about stream channels in this section,
    it should follow a stream listener sequence.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得上一章的内容，我们为传输通信中的监听器和连接器端有多个序列。服务器位于监听器的位置。因此，它应该遵循监听器序列。更具体地说，由于我们本节讨论的是流通道，它应该遵循流监听器序列。
- en: As part of that sequence, the server needs to create a socket object first.
    In our calculator project, the stream server process willing to receive connections
    over a UDS must follow the same sequence.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作为该序列的一部分，服务器需要首先创建一个socket对象。在我们的计算器项目中，愿意通过UDS接收连接的流服务器进程必须遵循相同的序列。
- en: 'The following piece of code is located in the main function of the calculator
    server program, and as can be seen in *Code Box 20-13*, the process firstly creates
    a `socket` object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段位于计算器服务器程序的主函数中，如*代码框20-13*所示，该过程首先创建了一个`socket`对象：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Code Box 20-13 [server/unix/stream/main.c]: Creating a stream UDS object'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框20-13 [server/unix/stream/main.c]: 创建流UDS对象'
- en: As you can see, the `socket` function is used to create a socket object. This
    function is included from `<sys/socket.h>`, which is a POSIX header. Note that
    this is just a socket object, and yet it is not determined whether this is going
    to be a client socket or a server socket. Only the subsequent function calls determine
    this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`socket`函数用于创建一个socket对象。此函数包含在`<sys/socket.h>`中，这是一个POSIX头文件。请注意，这只是一个socket对象，而且尚未确定它将是一个客户端socket还是一个服务器socket。只有后续的函数调用才能确定这一点。
- en: As we explained in the previous chapter, every socket object has three attributes.
    These attributes are determined by the three arguments passed to the `socket`
    function. These arguments specify the address family, the type, and the protocol
    used on that socket object respectively.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中解释的，每个socket对象都有三个属性。这些属性由传递给`socket`函数的三个参数确定。这些参数分别指定了在该socket对象上使用的地址族、类型和协议。
- en: 'According to the stream listener sequence and especially regarding the UDS
    after creating the socket object, the server program must bind it to a *socket
    file*. Therefore, the next step is to bind the socket to a socket file. *Code
    Box 20-14* has been used in the calculator project to bind the socket object to
    a file located at a predetermined path specified by the `sock_file` character
    array:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据流监听器序列，特别是关于创建socket对象之后的UDS，服务器程序必须将其绑定到一个*socket文件*。因此，下一步是将socket绑定到socket文件。计算器项目中使用了*代码框20-14*来将socket对象绑定到由`sock_file`字符数组指定的预定义路径上的文件：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Code Box 20-14 [server/unix/stream/main.c]: Binding a stream UDS object to
    a socket file specified by the sock_file char array'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框20-14 [server/unix/stream/main.c]: 将流UDS对象绑定到由sock_file字符数组指定的socket文件'
- en: The preceding code has two steps. The first step is to create an instance, named
    `addr`, of the type `struct sockaddr_un` and then initialize it by pointing it
    to a socket file. In the second step, the `addr` object is passed to the `bind`
    function in order to let it know which socket file should be *bound* to the socket
    object. The `bind` function call succeeds only if there is no other socket object
    bound to the same socket file. Therefore, with UDS, two socket objects, probably
    being in different processes, cannot be bound to the same socket file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有两个步骤。第一步是创建一个名为`addr`的`struct sockaddr_un`类型的实例，然后通过将其指向socket文件来初始化它。第二步是将`addr`对象传递给`bind`函数，以便让它知道应该将哪个socket文件*绑定*到socket对象。只有当没有其他socket对象绑定到相同的socket文件时，`bind`函数调用才会成功。因此，在UDS中，两个socket对象，可能位于不同的进程中，不能绑定到同一个socket文件。
- en: '**Note**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: In Linux, UDS can be bound to *abstract socket addresses*. They are useful mainly
    when there is no filesystem mounted to be used for having a socket file. A string
    starting with a null character, `\0`, can be used to initialize the address structure,
    `addr` in the preceding code box, and then the provided name is bound to the socket
    object inside the kernel. The provided name should be unique in the system and
    no other socket object should be bound to it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，UDS可以绑定到*抽象socket地址*。当没有文件系统挂载用于创建socket文件时，它们非常有用。一个以空字符`\0`开头的字符串可以用来初始化前面的代码框中的地址结构`addr`，然后提供的名称绑定到内核中的socket对象。提供的名称在系统中应该是唯一的，并且不应该有其他socket对象绑定到它。
- en: On a further note about the socket file path, the length of the path cannot
    exceed 104 bytes on most Unix systems. However, in Linux systems, this length
    is 108 bytes. Note that the string variable keeping the socket file path always
    include an extra null character at the end as a `char` array in C. Therefore,
    effectively, 103 and 107 bytes can be used as part of the socket file path depending
    on the operating system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关于套接字文件路径的进一步说明，在大多数Unix系统中，路径长度不能超过104字节。然而，在Linux系统中，这个长度是108字节。请注意，用于保存套接字文件路径的字符串变量始终包含一个额外的空字符，作为C中的`char`数组。因此，实际上，根据操作系统，可以使用103和107字节作为套接字文件路径的一部分。
- en: If the `bind` function returns `0`, it means that the binding has been successful,
    and you can proceed with configuring the size of the *backlog*; the next step
    in the stream listener sequence after binding the endpoint.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`bind`函数返回`0`，则表示绑定成功，您可以继续配置backlog的大小；这是绑定端点后流监听序列的下一步。
- en: 'The following code shows how the backlog is configured for the stream calculator
    server listening on a UDS:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何为监听UDS的流计算服务器配置backlog：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Code Box 20-15 [server/unix/stream/main.c]: Configuring the size of the backlog
    for a bound stream socket'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-15 [server/unix/stream/main.c]：配置已绑定流套接字的backlog大小
- en: The `listen` function configures the size of the backlog for an already bound
    socket. As we have explained in the previous chapter, when a busy server process
    cannot accept any more incoming clients, a certain number of these clients can
    wait in the backlog until the server program can process them. This is an essential
    step in preparing a stream socket before accepting the clients.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen`函数配置已绑定套接字的backlog大小。正如我们在上一章中解释的，当繁忙的服务器进程无法接受更多传入客户端时，一定数量的这些客户端可以在backlog中等待，直到服务器程序可以处理它们。这是在接受客户端之前准备流套接字的一个基本步骤。'
- en: 'According to what we have in the stream listener sequence, after having the
    stream socket bound and having its backlog size configured, we can start accepting
    new clients. *Code Box 20-16* shows how new clients can be accepted:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在流监听序列中的内容，在流套接字绑定并配置其backlog大小后，我们可以开始接受新客户端。*代码框20-16*展示了如何接受新客户端：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Code Box 20-16 [server/unix/stream/main.c]: Accepting new clients on a stream
    listener socket'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-16 [server/unix/stream/main.c]：在流监听套接字上接受新客户端
- en: The magic is the `accept` function, which returns a new socket object whenever
    a new client is received. The returned socket object refers to the underlying
    stream channel between the server and the accepted client. Note that every client
    has its own stream channel, and hence its own socket descriptor.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法在于`accept`函数，每当接收到新的客户端时，它都会返回一个新的套接字对象。返回的套接字对象指向服务器和已接受客户端之间的底层流通道。请注意，每个客户端都有自己的流通道，因此也有自己的套接字描述符。
- en: Note that if the stream listener socket is blocking (which it is by default),
    the `accept` function would block the execution until a new client is received.
    In other words, if there is no incoming client, the thread calling the `accept`
    function is blocked behind it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果流监听套接字是阻塞的（默认情况下是阻塞的），`accept`函数将阻塞执行，直到接收到新的客户端。换句话说，如果没有传入客户端，调用`accept`函数的线程将阻塞在其后面。
- en: 'Now, it''s time to see the above steps together in just one place. The following
    code box shows the stream server from the calculator project, which listens on
    a UDS:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个地方看到上述步骤。以下代码框展示了计算器项目中的流服务器，它监听UDS：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Code Box 20-17 [server/unix/stream/main.c]: The main function of the stream
    calculator service listening on a UDS endpoint'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-17 [server/unix/stream/main.c]：监听UDS端点的流计算服务的主函数
- en: It should be easy to find the code blocks that perform the aforementioned steps
    in initializing a server socket. The only thing that is missing is the client-accepting
    code. The actual code for accepting new clients is put in a separate function
    that is called `accept_forever`. Note that this function is blocking and blocks
    the main thread until the server stops.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很容易找到执行初始化服务器套接字上述步骤的代码块。唯一缺少的是客户端接受代码。接受新客户端的实际代码放在一个单独的函数中，该函数名为`accept_forever`。请注意，此函数是阻塞的，它会阻塞主线程直到服务器停止。
- en: 'In the following code box, you can see the definition of the `accept_forever`
    function. The function is part of the server common library located in the `srvcore`
    directory. This function should be there because its definition remains the same
    for other stream sockets such as TCP sockets. Therefore, we can reuse the existing
    logic instead of writing it again:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码框中，你可以看到 `accept_forever` 函数的定义。该函数是位于 `srvcore` 目录的服务器通用库的一部分。这个函数应该在那里，因为它的定义对于其他流套接字（如
    TCP 套接字）也是相同的。因此，我们可以重用现有的逻辑，而不是再次编写它：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Code Box 20-18 [server/srvcore/stream_server_core.c]: The function accepting
    new clients on a stream socket listening on a UDS endpoint'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-18 [server/srvcore/stream_server_core.c]：在监听 UDS 端点的流套接字上接受新客户端的函数
- en: As you can see in the preceding code box, upon accepting a new client, we spawn
    a new thread that is in charge of handling the client. This effectively entails
    reading bytes from the client's channel, passing the read bytes into the deserializer,
    and producing proper responses if a request has been detected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码框中所见，在接收新客户端后，我们启动了一个新的线程来处理客户端。这实际上包括从客户端的通道读取字节，将读取的字节传递给反序列化器，并在检测到请求时产生适当的响应。
- en: Creating a new thread for every client is usually the pattern for every server
    process that operates on a blocking stream channel, no matter what the type of
    socket is. Therefore, in such use cases, multithreading and all the surrounding
    topics become enormously important.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个客户端创建一个新的线程通常是每个在阻塞流通道上操作的服务器进程的通用模式，无论套接字类型如何。因此，在这种情况下，多线程及其相关主题变得极其重要。
- en: '**Note**:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Regarding non-blocking stream channels, a different approach known as *event
    loop* is usually used.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关于非阻塞流通道，通常使用一种称为 *事件循环* 的不同方法。
- en: 'When you have the socket object of a client, you can use it for reading from
    the client, as well writing to the client. If we follow the path that we''ve taken
    so far in the `srvcore` library, the next step is to look into the companion function
    of a client''s thread; `client_handler`. The function can be found next to the
    `accept_forever` in the code base. Next, you can see the code box containing the function''s
    definition:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有客户端的套接字对象时，你可以用它来从客户端读取，也可以向客户端写入。如果我们遵循在 `srvcore` 库中迄今为止所采取的路径，下一步是查看客户端线程的伴随函数；`client_handler`。该函数可以在代码库中
    `accept_forever` 旁边找到。接下来，你可以看到包含函数定义的代码框：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code Box 20-19 [server/srvcore/stream_server_core.c]: The companion function
    of the client-handling thread'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-19 [server/srvcore/stream_server_core.c]：处理客户端线程的伴随函数
- en: There are many details regarding the preceding code, but there are a few important
    ones that I want to mention. As you see, we are using the `read` function to read
    chunks from the client. If you remember, the `read` function accepts a file descriptor
    but here we are passing a socket descriptor. This shows, despite the differences
    between file descriptors and socket descriptors, regarding I/O functions, we can
    use the same API.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码有很多细节，但有一些重要的细节我想提一下。正如你所见，我们正在使用 `read` 函数从客户端读取数据块。如果你记得，`read` 函数接受一个文件描述符，但在这里我们传递的是一个套接字描述符。这表明，尽管在
    I/O 函数方面文件描述符和套接字描述符之间存在差异，我们仍然可以使用相同的 API。
- en: In the preceding code, we read chunks of bytes from the input and we pass them
    to the deserializer by calling the `calc_proto_ser_server_deserialize` function.
    It is possible to call this function three or four times before having a request
    fully deserialized. This is highly dependent on the chunk size that you read from
    the input and the length of the messages transmitting on the channel.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从输入读取字节数据，并通过调用 `calc_proto_ser_server_deserialize` 函数将它们传递给反序列化器。在完全反序列化一个请求之前，可能需要调用这个函数三到四次。这高度依赖于从输入读取的字块大小以及通过通道传输的消息长度。
- en: On a further note, every client has its own serializer object. This is also
    true for the calculator service object. These objects are created and destroyed
    as part of the same thread.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，每个客户端都有自己的序列化对象。这也适用于计算器服务对象。这些对象作为同一线程的一部分被创建和销毁。
- en: 'And as the last note about the preceding code box, we are using a function
    to write responses back to the client. The function is `stream_write_response`
    and it is meant to be used on a stream socket. This function can be found in the
    same file as the preceding code boxes. Next, you can see the definition of this
    function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码框的最后一点，我们正在使用一个函数将响应写回客户端。该函数是`stream_write_response`，它旨在在流套接字上使用。这个函数可以在前面的代码框所在的同一文件中找到。接下来，你可以看到这个函数的定义：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code Box 20-20 [server/srvcore/stream_server_core.c]: The function used for
    writing the responses back to the client'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 20-20 [server/srvcore/stream_server_core.c]: 用于将响应写回客户端的函数'
- en: As you see in the preceding code, we are using the `write` function to write
    a message back to the client. As we know, the `write` function can accept file
    descriptors, but it seems socket descriptors can also be used. So, it clearly
    shows that the POSIX I/O API works for both file descriptors and socket descriptors.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，我们正在使用`write`函数将消息写回客户端。正如我们所知，`write`函数可以接受文件描述符，但似乎套接字描述符也可以使用。所以，这清楚地表明
    POSIX I/O API 对文件描述符和套接字描述符都有效。
- en: The above statement is also true about the `close` function. As you can see,
    we have used it to terminate a connection. It is enough to pass the socket descriptor
    while we know that it works for file descriptors as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句也适用于`close`函数。正如你所见，我们已用它来终止一个连接。当我们知道它对文件描述符也有效时，传递套接字描述符就足够了。
- en: Now that we have gone through some of the most important parts of the UDS stream
    server and we have an idea of how it operates, it is time to move on and discuss
    the UDS stream client. For sure, there are plenty places in the code that we haven't
    discussed but you should dedicate time and go through them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 UDS 流服务器的一些最重要的部分，并对它的操作有了大致的了解，是时候继续讨论 UDS 流客户端了。当然，代码中还有很多我们没有讨论的地方，但你应该花时间仔细研究它们。
- en: UDS stream client
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDS 流客户端
- en: Like the server program described in the previous section, the client also needs
    to create a socket object first. Remember that we need to follow the stream connector
    sequence now. It uses the same piece of code as server does, with exactly the
    same arguments, to indicate that it needs a UDS. After that, it needs to connect
    to the server process by specifying a UDS endpoint, similarly to how the server
    did. When the stream channel is established, the client process can use the opened
    socket descriptor to read from and write to the channel.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中描述的服务器程序一样，客户端也需要首先创建一个套接字对象。记住，我们现在需要遵循流连接器序列。它使用与服务器完全相同的代码，使用完全相同的参数来指示它需要一个
    UDS。之后，它需要通过指定 UDS 端点来连接到服务器进程，就像服务器那样。当流通道建立后，客户端进程可以使用打开的套接字描述符来读取和写入通道。
- en: 'Next, you can see the `main` function of the stream client connecting to a
    UDS endpoint:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到连接到 UDS 端点的流客户端的`main`函数：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Code Box 20-21 [client/unix/stream/main.c]: The main function of the stream
    client connecting to a UDS endpoint'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 20-21 [client/unix/stream/main.c]: 连接到 UDS 端点的流客户端的主函数'
- en: As you can see, the first part of the code is very similar to the server code
    but afterward, the client calls `connect` instead of `bind`. Note that the address
    preparation code is exactly the same as that of the server.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码的第一部分与服务器代码非常相似，但之后，客户端调用`connect`而不是`bind`。请注意，地址准备代码与服务器完全相同。
- en: When `connect` returns successfully, it has already associated the `conn_sd`
    socket descriptor to the opened channel. Therefore, from now on, `conn_sd` can
    be used to communicate with the server. We pass it to the `stream_client_loop`
    function, which brings up the client's command line and does the rest of the actions
    performed by the client. It is a blocking function that runs the client until
    it quits.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当`connect`成功返回时，它已经将`conn_sd`套接字描述符关联到打开的通道。因此，从现在开始，`conn_sd`可以用来与服务器通信。我们将其传递给`stream_client_loop`函数，该函数启动客户端的命令行并执行客户端执行的其他操作。它是一个阻塞函数，运行客户端直到它退出。
- en: 'Note that the client also uses `read` and `write` functions to transmit messages
    back and forth from and to the server. *Code Box 20-22* contains the definition
    of the `stream_client_loop` function, which is part of the client common library
    that is used by all stream clients, regardless of the socket type and is shared
    between UDS and TCP sockets. As you see, it uses the `write` function to send
    a serialized request message to the server:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，客户端也使用`read`和`write`函数在服务器之间来回传输消息。*代码框20-22*包含了`stream_client_loop`函数的定义，这是客户端通用库的一部分，所有流客户端都会使用它，无论套接字类型如何，并且UDS和TCP套接字之间是共享的。正如你所见，它使用`write`函数向服务器发送一个序列化的请求消息：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Code Box 20-22 [client/clicore/stream_client_core.c]: The function executing
    a stream client'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-22 [client/clicore/stream_client_core.c]：执行流客户端的函数
- en: As you can see in the preceding code, every client process has only one serializer
    object and it makes sense. This is opposite to the server process, where every
    client had a separate serializer object.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码中所见，每个客户端进程只有一个序列化对象，这是有道理的。这与服务器进程相反，其中每个客户端都有一个单独的序列化对象。
- en: More than that, the client process spawns a separate thread for reading the
    responses from the server side. That's because reading from the server process
    is a blocking task and it should be done in a separate flow of execution.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，客户端进程为从服务器端读取响应启动了一个单独的线程。这是因为从服务器进程读取是一个阻塞任务，应该在单独的执行流中完成。
- en: As part of the main thread, we have the client's command line, which receives
    inputs from a user through the Terminal. As you see, the main thread joins the
    reader thread upon exiting and it waits for its completion.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为主线程的一部分，我们有客户端的命令行，它通过终端接收用户的输入。正如你所见，主线程在退出时加入读取线程，并等待其完成。
- en: On a further note regarding the preceding code, the client process uses the
    same I/O API for reading from and writing to the stream channel. Like we said
    before, the `read` and `write` functions are used and the usage of the `write`
    function can be seen in *Code Box 20-22*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面代码的进一步说明，客户端进程使用相同的I/O API从流通道读取和写入。正如我们之前所说的，使用了`read`和`write`函数，`write`函数的使用可以在*代码框20-22*中看到。
- en: In the following section, we talk about datagram channels but still using the
    UDS for that purpose. We start with the datagram server first.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将讨论数据报通道，但仍然使用UDS来完成这个目的。我们首先从数据报服务器开始。
- en: UDS datagram server
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDS数据报服务器
- en: If you remember from the previous chapter, datagram processes had their own
    listener and connector sequences regarding transport transmission. Now it's time
    to demonstrate how a datagram server can be developed based on UDS.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得上一章的内容，数据报进程在传输传输方面有自己的监听器和连接器序列。现在，是时候展示如何基于UDS开发数据报服务器了。
- en: 'According to the datagram listener sequence, the process needs to create a
    socket object first. The following code box demonstrates that:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据报监听器序列，进程首先需要创建一个套接字对象。以下代码框展示了这一点：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Code Box 20-23 [server/unix/datagram/main.c]: Creating a UDS object meant to
    operate on a datagram channel'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-23 [server/unix/datagram/main.c]：创建一个用于数据报通道的UDS对象
- en: You see that we have used `SOCK_DGRAM` instead of `SOCK_STREAM`. This means
    that the socket object is going to operate on a datagram channel. The other two
    arguments remain the same.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们使用了`SOCK_DGRAM`而不是`SOCK_STREAM`。这意味着套接字对象将操作在数据报通道上。其他两个参数保持不变。
- en: As the second step in the datagram listener sequence, we need to bind the socket
    to a UDS endpoint. As we said before, this is a socket file. This step is exactly
    the same as for the stream server, and therefore we don't bother to demonstrate
    it below and you can see it in *Code Box 20-14*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据报监听器序列的第二步，我们需要将套接字绑定到UDS端点。正如我们之前所说的，这是一个套接字文件。这一步与流服务器完全相同，因此我们在这里不展示它，你可以在*代码框20-14*中看到它。
- en: For a datagram listener process, these steps were the only ones to be performed,
    and there is no backlog associated to a datagram socket to be configured. More
    than that, there is no client-accepting phase because we can't have stream connections
    on some dedicated 1-to-1 channels.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据报监听器进程，这些步骤是唯一需要执行的，并且与数据报套接字相关的配置没有队列。更重要的是，没有客户端接受阶段，因为我们不能在某些专用的1-to-1通道上有流连接。
- en: 'Next, you can see the `main` function of the datagram server listening on a
    UDS endpoint, as part of the calculator project:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到数据报服务器在UDS端点监听的`main`函数，这是计算器项目的一部分：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Code Box 20-24 [server/unix/datagram/main.c]: The main function of the datagram
    server listening on a UDS endpoint'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-24 [server/unix/datagram/main.c]：监听 UDS 端点的数据报服务器的主函数
- en: As you know, datagram channels are connection-less, and they don't operate like
    stream channels. In other words, there cannot be a dedicated 1-to-1 connection
    between two processes. Therefore, the processes can only transmit datagrams along
    the channel. A client process can only send some individual and independent datagrams
    and likewise, the server process can only receive datagrams and send back some
    other datagrams as responses.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，数据报通道是无连接的，它们的工作方式不像流通道。换句话说，两个进程之间不能有一个专用的 1-to-1 连接。因此，进程只能通过通道传输数据报。客户端进程只能发送一些单独和独立的
    数据报，同样，服务器进程只能接收数据报并作为响应发送其他数据报。
- en: So, the crucial thing about a datagram channel is that the request and response
    messages should be fit into a single datagram. Otherwise, they cannot be split
    between two datagrams and the server or client cannot handle the message. Fortunately,
    our messages in the calculator project are mostly short enough to be fit into
    a single datagram.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数据报通道的关键之处在于请求和响应消息应该适合在一个数据报中。否则，它们不能被分成两个数据报，服务器或客户端也无法处理这些消息。幸运的是，计算器项目中的消息大多数足够短，可以适合在一个数据报中。
- en: 'The size of a datagram is highly dependent on the underlying channel. For example,
    regarding datagram UDS this is quite flexible because it happens through the kernel,
    but regarding UDP sockets, you are bound to the configuration of the network.
    Regar[ding the UDS the following link can give you a better idea of how to set
    the correct size: https://stackov](https://stackoverflow.com/questions/21856517/whats-the-practical-limit-on-the-size-of-single-packet-transmitted-over-domain)erflow.com/questions/21856517/whats-the-practical-limit-on-the-size-of-single-packet-transmitted-over-domain.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报的大小高度依赖于底层通道。例如，对于数据报 UDS 来说，这是相当灵活的，因为它通过内核进行，但对于 UDP 套接字，你将受到网络配置的限制。关于
    UDS，以下链接可以给你一个更好的想法，了解如何设置正确的大小：[https://stackoverflow.com/questions/21856517/whats-the-practical-limit-on-the-size-of-single-packet-transmitted-over-domain](https://stackoverflow.com/questions/21856517/whats-the-practical-limit-on-the-size-of-single-packet-transmitted-over-domain)。
- en: Another difference that we can mention regarding datagram and stream sockets
    is the I/O API that is used to transmit data along them. While the `read` and
    `write` functions can still be used for datagram sockets just like the stream
    sockets, we use other functions for reading from and sending to a datagram channel.
    The `recvfrom` and `sendto` functions are usually used.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据报和流套接字，我们可以提到的另一个区别是用于在它们之间传输数据的 I/O API。虽然 `read` 和 `write` 函数仍然可以像流套接字一样用于数据报套接字，但我们使用其他函数从数据报通道读取和发送。通常使用
    `recvfrom` 和 `sendto` 函数。
- en: That's because in stream sockets the channel is dedicated, and when you write
    to a channel both ends are determined. Regarding datagram sockets, we have only
    one channel that is being used by many parties. Therefore, we can lose track of
    the process owning a specific datagram. These functions can keep track of and
    send the datagram back to the desired process.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在流套接字中，通道是专用的，当你向一个通道写入时，两端都是确定的。至于数据报套接字，我们只有一个通道被许多方使用。因此，我们可能会失去对特定数据报的所有权。这些函数可以跟踪并将数据报发送回期望的过程。
- en: 'Next, you can find the definition for the `serve_forever` function used in
    *Code Box 20-24* at the end of the `main` function. This function belongs to the
    server common library and is specific to datagram servers, regardless of the socket
    type. You can clearly see how the `recvfrom` function has been used:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以在 `main` 函数的末尾找到 *代码框 20-24* 中使用的 `serve_forever` 函数的定义。这个函数属于服务器通用库，并且专门用于数据报服务器，无论套接字类型如何。你可以清楚地看到
    `recvfrom` 函数是如何被使用的：
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Code Box 20-25 [server/srvcore/datagram_server_core.c]: The function handling
    the datagrams found in the server common library, and dedicated to the datagram
    servers'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-25 [server/srvcore/datagram_server_core.c]：处理服务器通用库中找到的数据报的函数，并专门用于数据报服务器
- en: As you see in the preceding code box, the datagram server is a single-threaded
    program and there is no multithreading around it. More than that, it operates
    on every datagram individually and independently. It receives a datagram, deserializes
    its content and creates the request object, handles the request through the service
    object, serializes the response object and puts it in a new datagram, and sends
    it back to the process owning the original datagram. It does the same cycle over
    and over again for every incoming datagram.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的代码框中看到的，数据报服务器是一个单线程程序，并且在其周围没有多线程。不仅如此，它对每个数据报进行单独和独立的操作。它接收一个数据报，反序列化其内容并创建请求对象，通过服务对象处理请求，序列化响应对象并将其放入一个新的数据报中，然后将它发送回拥有原始数据报的进程。对于每个传入的数据报，它都会重复进行相同的周期。
- en: Note that every datagram has its own serializer object and its own service object.
    We could design this in a way that we had only one serializer and one service
    object for all the datagrams. This might be something interesting for you to think
    about with regard to how it is possible and why that might not be possible for
    the calculator project. This is a debatable discussion and you might receive different
    opinions from various people.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个数据报都有自己的序列化对象和自己的服务对象。我们可以设计成只有一个序列化对象和一个服务对象适用于所有数据报。这可能对您思考如何实现以及为什么这可能不适合计算器项目是有趣的。这是一个有争议的讨论，您可能会从不同的人那里得到不同的观点。
- en: 'Note that in *Code Box 20-25*, we store the client address of a datagram upon
    receiving it. Later, we can use this address to write directly back to that client.
    It is worth having a look at how we write back the datagram to the sender client.
    Just like the stream server, we are using a function for this purpose. *Code Box
    20-26* shows the definition of the `datagram_write_resp` function. The function
    is in the datagram servers'' common library next to the `serve_forever` function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在*代码框20-25*中，我们在接收到数据报时存储了数据报的客户端地址。稍后，我们可以使用这个地址直接向该客户端写入。看看我们如何将数据报写回发送客户端是值得一看的。就像流服务器一样，我们为此使用了一个函数。*代码框20-26*显示了`datagram_write_resp`函数的定义。该函数位于数据报服务器公共库中，紧邻`serve_forever`函数：
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Code Box 20-26 [server/srvcore/datagram_server_core.c]: The function writing
    datagrams back to the clients'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框20-26 [server/srvcore/datagram_server_core.c]：将数据报写回客户端的函数
- en: You can see that we use the sorted client address and we pass it to the `sendto`
    function together with the serialized response message. The rest is taken care
    of by the operating system and the datagram is sent back directly to the sender
    client.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们使用了排序后的客户端地址，并将其与序列化的响应消息一起传递给`sendto`函数。其余的由操作系统处理，数据报直接发送回发送客户端。
- en: Now that we know enough about the datagram server and how the socket should
    be used, let's look at the datagram client, which is using the same type of socket.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经足够了解数据报服务器以及如何使用套接字，让我们来看看数据报客户端，它使用的是相同类型的套接字。
- en: UDS datagram client
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDS数据报客户端
- en: From a technical point of view, stream clients and datagram clients are very
    similar. It means that you should see almost the same overall structure but with
    some differences regarding transmitting datagrams instead of operating on a stream
    channel.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，流客户端和数据报客户端非常相似。这意味着您应该看到几乎相同的整体结构，但在处理数据报而不是流通道时有一些差异。
- en: But there is a big difference between them, and this is quite unique and specific
    to datagram clients connecting to UDS endpoints.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们之间有一个很大的差异，这是相当独特且专门针对连接到UDS端点的数据报客户端的。
- en: The difference is that the datagram client is required to bind a socket file,
    just like the server program, in order to receive the datagrams directed at it.
    This is not true for datagram clients using network sockets, as you will see shortly.
    Note that the client should bind a different socket file, and not the server's
    socket file.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于，数据报客户端需要绑定一个套接字文件，就像服务器程序一样，以便接收指向它的数据报。对于使用网络套接字的数据报客户端来说，情况并非如此，您很快就会看到。请注意，客户端应绑定不同的套接字文件，而不是服务器的套接字文件。
- en: The main reason behind this difference is the fact that the server program needs
    an address to send the response back to, and if the datagram client doesn't bind
    a socket file, there is no endpoint bound to the client socket file. But regarding
    network sockets, a client always has a corresponding socket descriptor that is
    bound to an IP address and a port, so this problem cannot occur.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异背后的主要原因是服务器程序需要一个地址来发送响应，如果数据报客户端没有绑定套接字文件，则没有端点绑定到客户端套接字文件。但是，对于网络套接字来说，客户端始终有一个对应的套接字描述符，它绑定到一个IP地址和一个端口，因此这个问题不会发生。
- en: 'If we put aside this difference, we can see how similar the code is. In *Code
    Box 20-26* you can see the `main` function of the datagram calculator client:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略这个差异，我们可以看到代码是多么相似。在*代码框 20-26*中，你可以看到数据报计算器客户端的`main`函数：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Code Box 20-26 [server/srvcore/datagram_server_core.c]: The function writing
    datagrams back to the clients'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 20-26 [server/srvcore/datagram_server_core.c]: 将数据报文写回客户端的函数'
- en: As we explained earlier, and as can be seen in the code, the client is required
    to bind a socket file. And of course, we have to call a different function to
    start the client loop, at the end of the `main` function. The datagram client
    calls the `datagram_client_loop` function.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所解释的，并且可以从代码中看到，客户端需要绑定一个套接字文件。当然，我们不得不在`main`函数的末尾调用一个不同的函数来启动客户端循环。数据报客户端调用`datagram_client_loop`函数。
- en: If you look at the function `datagram_client_loop`, you still see many similarities
    between the stream client and the datagram client. Despite the small differences,
    a big difference is using the `recvfrom` and `sendto` functions instead of the
    `read` and `write` functions. The same explanation given for these functions as
    part of the previous section, still holds true for the datagram client.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`datagram_client_loop`函数，你仍然会在流客户端和数据报客户端之间看到许多相似之处。尽管存在一些小的差异，但一个大的差异是使用`recvfrom`和`sendto`函数而不是`read`和`write`函数。在上一节中对这些函数的解释，对于数据报客户端仍然适用。
- en: Now it's time to talk about network sockets. As you will see, the `main` function
    in the client and server programs is the only code that changes when moving from
    UDS to network sockets.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论网络套接字了。正如你将看到的，客户端和服务器程序中的`main`函数是唯一在从UDS转换为网络套接字时发生变化的代码。
- en: Network sockets
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络套接字
- en: The other socket address family that is widely used is `AF_INET`. It simply
    refers to any channel established on top of a network connection. Unlike the UDS
    stream and datagram sockets, which have no protocol name assigned to them, there
    are two well-known protocols on top of network sockets. TCP sockets establish
    a stream channel between every two processes, and UDP sockets establish a datagram
    channel that can be used by a number of processes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个广泛使用的套接字地址族是`AF_INET`。它简单地指代在网络上建立的所有通道。与没有分配协议名称的UDS流和数据报套接字不同，网络套接字之上存在两个知名协议。TCP套接字在两个进程之间建立流通道，而UDP套接字建立的数据报通道可以被多个进程使用。
- en: In the following sections, we are going to explain how to develop programs using
    TCP and UDP sockets and see real some examples as part of the calculator project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将解释如何使用TCP和UDP套接字开发程序，并作为计算器项目的一部分展示一些真实示例。
- en: TCP server
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP服务器
- en: 'A program using a TCP socket to listen and accept a number of clients, in other
    words a TCP server, is different from a stream server listening on a UDS endpoint
    in two ways: firstly, it specifies a different address family, `AF_INET` instead
    of `AF_UNIX`, when calling the `socket` function. And secondly, it uses a different
    structure for the socket address required for binding.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TCP套接字监听和接受多个客户端的程序，换句话说，是一个TCP服务器，它在两个方面的不同之处在于：首先，在调用`socket`函数时指定了不同的地址族，即`AF_INET`而不是`AF_UNIX`；其次，它使用了一个不同的结构来绑定所需的套接字地址。
- en: Despite these two differences, everything else would be the same for a TCP socket
    in terms of I/O operation. We should note that a TCP socket is a stream socket,
    therefore the code written for a stream socket using UDS should work for a TCP
    socket as well.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这两个差异，但从I/O操作的角度来看，TCP套接字的其他一切都将与UDP套接字相同。我们应该注意，TCP套接字是一个流套接字，因此为流套接字编写的代码也应该适用于TCP套接字。
- en: 'If we go back to the calculator project, we expect to see the differences just
    in the `main` functions where we create the socket object and bind it to an endpoint.
    Other than that, the rest of the code should remain unchanged. In fact, this is
    what we actually see. The following code box contains the `main` function of the
    TCP calculator server:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到计算器项目，我们期望看到的主要区别仅在于我们创建套接字对象并将其绑定到端点处的 `main` 函数。除此之外，其余的代码应该保持不变。事实上，这正是我们所看到的。以下代码框包含了
    TCP 计算器服务器的 `main` 函数：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Code Box 20-27 [server/tcp/main.c]: The main function of the TCP calculator
    client'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-27 [server/tcp/main.c]：TCP 计算器客户端的 `main` 函数
- en: If you compare the preceding code with the `main` function seen in *Code Box
    20-17*, you will notice the differences we explained earlier. Instead of using
    the `sockaddr_un` structure, we are using the `sockaddr_in` structure for the
    bound endpoint address. The `listen` function is used the same, and even the same
    `accept_forever` function has been called to handle the incoming connections.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将前面的代码与 *代码框 20-17* 中看到的 `main` 函数进行比较，您将注意到我们之前解释过的差异。我们不是使用 `sockaddr_un`
    结构，而是使用 `sockaddr_in` 结构来为绑定端点地址。`listen` 函数的使用相同，甚至调用了相同的 `accept_forever` 函数来处理传入的连接。
- en: As a final note, regarding I/O operations on a TCP socket, since a TCP socket
    is a stream socket, it inherits all the properties from a stream socket; therefore,
    it can be used just like any other stream socket. In other words, the same `read`,
    `write`, and `close` functions can be used.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的说明，关于 TCP 套接字上的 I/O 操作，由于 TCP 套接字是一个流套接字，它继承了流套接字的所有属性；因此，它可以像任何其他流套接字一样使用。换句话说，相同的
    `read`、`write` 和 `close` 函数都可以使用。
- en: Let's now talk about the TCP client.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈 TCP 客户端。
- en: TCP client
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP 客户端
- en: Again, everything should be very similar to the stream client operating on a
    UDS. The differences mentioned in the previous section are still true for a TCP
    socket on a connector side. The changes are again limited to the `main` function.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一切应该与在 UDS 上运行的流客户端非常相似。上一节中提到的差异对于连接器侧的 TCP 套接字仍然适用。变化再次仅限于 `main` 函数。
- en: 'Next, you can see the `main` function of the TCP calculator client:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以查看 TCP 计算器客户端的 `main` 函数：
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Code Box 20-27 [server/tcp/main.c]: The main function of the TCP calculator
    server'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-27 [server/tcp/main.c]：TCP 计算器服务器的 `main` 函数
- en: The changes are very similar to the ones we saw for the TCP server program.
    A different address family and a different socket address structure have been
    used. Apart from that, the rest of the code is the same, and we therefore do not
    need to discuss the TCP client in detail.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 变化与我们在 TCP 服务器程序中看到的变化非常相似。使用了不同的地址族和不同的套接字地址结构。除此之外，其余的代码相同，因此我们不需要详细讨论 TCP
    客户端。
- en: Since TCP sockets are stream sockets, we can use the same common code for handling
    the new clients. You can see this by calling the `stream_client_loop` function,
    which is part of the client common library in the calculator project. Now, you
    should get the idea of why we extracted two common libraries, one for the client
    programs and one for the server programs, in order to write less code. When we
    can use the same code for two different scenarios, it is always best to extract
    it as a library and reuse it in the scenarios.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TCP 套接字是流套接字，我们可以使用相同的通用代码来处理新客户端。您可以通过调用 `stream_client_loop` 函数来看到这一点，该函数是计算器项目中的客户端通用库的一部分。现在，您应该明白为什么我们提取了两个通用库，一个用于客户端程序，一个用于服务器程序，以便编写更少的代码。当我们可以在两种不同的场景中使用相同的代码时，将其提取为库并在场景中重用总是最好的。
- en: Let's look at UDP server and client programs; we will see that they are more
    or less similar to what we saw regarding TCP programs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 UDP 服务器和客户端程序；我们会发现它们与我们所看到的 TCP 程序大致相似。
- en: UDP server
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP 服务器
- en: UDP sockets are network sockets. Other than that, they are datagram sockets.
    Therefore, we expect to observe a high degree of similarity between the code we
    wrote for the TCP server together with the code we wrote for the datagram server
    operating on a UDS.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 套接字是网络套接字。除此之外，它们是数据报套接字。因此，我们预计将观察到我们在 TCP 服务器代码和数据报服务器代码（在 UDS 上操作）中编写的代码之间的高度相似性。
- en: 'In addition, the main difference between a UDP socket and a TCP socket, regardless
    of being used in a client or server program, is the fact that the socket type
    is `SOCK_DGRAM` for the UDP socket. The address family remains the same, because
    both of them are network sockets. The following code box contains the main function
    of the calculator UDP server:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无论在客户端还是服务器程序中使用，UDP 套接字与 TCP 套接字的主要区别在于 UDP 套接字的套接字类型是 `SOCK_DGRAM`。地址族保持不变，因为它们都是网络套接字。以下代码框包含了计算器
    UDP 服务器的主体函数：
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Code Box 20-28 [server/udp/main.c]: The main function of the UDP calculator
    server'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-28 [server/udp/main.c]：UDP 计算器服务器的主体函数
- en: Note that UDP sockets are datagram sockets. Therefore, all the code written
    for datagram sockets operating on UDS is still valid for them. For instance, we
    have to use the `recvfrom` and `sendto` functions to work with UDP sockets. So,
    as you can see, we have used the same `serve_forever` function to serve incoming
    datagrams. This function is part of the server common library meant to contain
    the datagram-related code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，UDP 套接字是数据报套接字。因此，为在 UDS 上操作的数据报套接字编写的所有代码仍然适用于它们。例如，我们必须使用 `recvfrom` 和
    `sendto` 函数来处理 UDP 套接字。所以，如您所见，我们使用了相同的 `serve_forever` 函数来服务传入的数据报。这个函数是服务器通用库的一部分，旨在包含与数据报相关的代码。
- en: We've said enough regarding the UDP server's code. Let's see what the UDP client's
    code looks like.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 UDP 服务器代码，我们已经说得够多了。让我们看看 UDP 客户端代码的样子。
- en: The UDP client
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP 客户端
- en: 'UDP client code is very similar to the TCP client code, but it uses a different
    socket type and it calls a different function for handling the incoming messages,
    which is the same function that the datagram client based on UDS used. You can
    see the following `main` function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 客户端代码与 TCP 客户端代码非常相似，但它使用不同的套接字类型，并调用不同的函数来处理传入的消息，这个函数与基于 UDS 的数据报客户端使用的函数相同。您可以看到以下
    `main` 函数：
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Code Box 20-28 [client/udp/main.c]: The main function of the UDP calculator
    client'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 20-28 [client/udp/main.c]：UDP 计算器客户端的主体函数
- en: That was the final concept for this chapter. In this chapter, we went through
    the various well-known socket types and together with that, we showed how the
    listener and connector sequences for both stream and datagram channels can be
    implemented in C.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 那是本章的最后一个概念。在本章中，我们探讨了各种众所周知的套接字类型，并展示了如何在 C 中实现流和数据报通道的监听器和连接器序列。
- en: There are many things in the calculator project that we didn't even talk about.
    Therefore, it is highly recommended to go through the code, find those places,
    and try to read and understand it. Having a fully working example can help you
    to examine the concepts in real applications.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器项目中有很多我们没有讨论的事情。因此，强烈建议您阅读代码，找到那些地方，并尝试阅读和理解它。一个完全工作的示例可以帮助您在真实应用中检验这些概念。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we went through the following topics:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了以下主题：
- en: We introduced various types of communications, channels, mediums, and sockets
    as part of our review of IPC techniques.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在回顾 IPC 技术时介绍了各种类型的通信、通道、介质和套接字。
- en: We explored a calculator project by describing its application protocol and
    the serialization algorithm that it uses.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过描述其应用协议和所使用的序列化算法来探索了一个计算器项目。
- en: We demonstrated how UDS can be used to establish a client-server connection,
    and we showed how they are used in the calculator project.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们演示了如何使用 UDS 建立客户端-服务器连接，并展示了它们在计算器项目中的应用。
- en: We discussed the stream and datagram channels established using Unix domain
    sockets, separately.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们分别讨论了使用 Unix 域套接字建立的流和数据报通道。
- en: We demonstrated how TCP and UDP sockets can be used to make a client-server
    IPC channel, and we used them in the calculator example.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们演示了如何使用 TCP 和 UDP 套接字来创建客户端-服务器 IPC 通道，并在计算器示例中使用了它们。
- en: The next chapter is about integrating of C with other programming languages.
    By doing so, we can have a C library loaded and used in another programming language
    like Java. As part of the next chapter, we cover integration with C++, Java, Python,
    and Golang.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 C 语言与其他编程语言的集成。通过这种方式，我们可以在其他编程语言（如 Java）中加载并使用 C 库。作为下一章的一部分，我们将涵盖与
    C++、Java、Python 和 Golang 的集成。
