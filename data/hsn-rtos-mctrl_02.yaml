- en: Introducing Real-Time Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍实时系统
- en: Real-time systems come in a wide variety of implementations and use cases. This
    book focuses on how to use a **real-time OS** (**RTOS**) to create real-time applications
    on a **microcontroller unit** (**MCU**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 实时系统有各种各样的实现和使用案例。本书侧重于如何使用**实时操作系统**（**RTOS**）在**微控制器单元**（**MCU**）上创建实时应用程序。
- en: In this chapter, we'll start with an overview of what an RTOS is and get an
    idea of the wide range of systems that can have real-time requirements. From there,
    we'll look at some of the different ways of achieving real-time performance, along
    with an overview of the types of systems (such as hardware, firmware, and software)
    that may be used. We'll wrap up by discussing when it is advisable to use an RTOS
    in an MCU application and when it might not be necessary at all.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从RTOS（实时操作系统）的概述开始，了解具有实时要求的广泛系统。从那里，我们将探讨实现实时性能的不同方法，以及可能使用的系统类型（如硬件、固件和软件）的概述。我们将通过讨论在MCU应用中使用RTOS何时是可取的，以及何时可能根本不必要的来结束本章。
- en: 'In a nutshell, we will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在本章中我们将涵盖以下主题：
- en: What is "real-time" anyway?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，“实时”究竟是什么呢？
- en: Defining RTOS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义RTOS
- en: Deciding when to use an RTOS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定何时使用RTOS
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no software or hardware requirements for this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有软件或硬件要求。
- en: What is real-time anyway?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，什么是“实时”呢？
- en: Any system that has a deterministic response to a given event can be considered
    "real-time." If a system is considered to *fail* when it doesn't meet a timing
    requirement, it must be real-time. How failure is defined (and the consequences
    of a failed system) can vary widely. It is extremely important to realize that
    real-time requirements can vary widely, both in the speed of the timing requirement
    and also the severity of consequences if the required real-time deadlines are
    not met.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对给定事件有确定响应的系统都可以被认为是“实时”的。如果一个系统在未满足时间要求时被认为是*失败*的，那么它必须是实时的。失败的定义（以及系统失败的影响）可能会有很大的不同。认识到实时要求可能会有很大的变化，无论是时间要求的速度还是未满足所需实时截止日期的严重后果，这一点极为重要。
- en: The ranges of timing requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间要求范围
- en: To illustrate the range of timing requirements that can be encountered, let's
    consider a few different systems that acquire readings from **analog-to-digital
    converters** (**ADCs**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明可能遇到的定时要求范围，让我们考虑几个不同的系统，这些系统从**模拟-数字转换器**（**ADCs**）获取读数。
- en: The first system we'll look at is a control system that is set up to control
    the temperature of a soldering iron (as seen in the following diagram). The parts
    of the system we're concerned with are the MCU, ADC, sensor, and heater.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先研究的是一个控制温度的烙铁（如下图表所示）的控制系统。我们关注的系统部分是MCU、ADC、传感器和加热器。
- en: 'The MCU is responsible for the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MCU负责以下工作：
- en: Taking readings from a temperature sensor via the ADC
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ADC从温度传感器读取数据
- en: Running a closed-loop control algorithm (to maintain a constant temperature
    at the soldering iron tip)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行闭环控制算法（以保持烙铁尖端恒定温度）
- en: Adjusting the output of the heater as needed
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要调整加热器的输出
- en: 'These can be seen in the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在以下图表中看到：
- en: '![](img/ea010fc5-197f-4bea-8d35-ce732103a532.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea010fc5-197f-4bea-8d35-ce732103a532.png)'
- en: 'Since the temperature of the tip doesn''t change incredibly quickly, the MCU
    may only need to acquire 50 ADC samples per second (50 Hz). The control algorithm
    responsible for adjusting the heater (to maintain a constant temperature) runs
    at an even slower pace, 5 Hz:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于烙铁尖端的温度变化并不快，MCU可能只需要每秒获取50个ADC样本（50 Hz）。负责调整加热器（以保持恒定温度）的控制算法运行速度更慢，为5 Hz：
- en: '![](img/eaaf41cd-d497-4f8f-8ebc-a0101442c36d.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eaaf41cd-d497-4f8f-8ebc-a0101442c36d.png)'
- en: 'The ADC will assert a hardware line, signaling a conversion has been completed
    and is ready for the MCU to transfer the reading to its internal memory. The MCU
    reading the ADC has up to 20 ms to transfer data from the ADC to internal memory
    before a new reading needs to be taken (as seen in the following diagram). The
    MCU also needs to be running the control algorithm to calculate the updated values
    for the heater output at 5 Hz (200 ms). Both of these cases (although not particularly
    fast) are examples of real-time requirements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ADC将激活一个硬件线路，表示转换已完成，并准备好将读数传输到MCU的内部存储。读取ADC的MCU有最多20毫秒的时间将数据从ADC传输到内部存储，然后需要取新的读数（如以下图所示）。MCU还需要运行控制算法，以计算加热器输出的更新值，频率为5Hz（200毫秒）。这两个案例（尽管不是特别快）都是实时要求的例子：
- en: '![](img/51fb4dec-6cc4-41d6-b2b4-5e91edb1fab2.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51fb4dec-6cc4-41d6-b2b4-5e91edb1fab2.png)'
- en: Now, on the other end of the ADC reading spectrum, we could have a high bandwidth
    network analyzer or oscilloscope that is going to be reading an ADC at a rate
    of tens of GHz! The raw ADC readings will likely be converted into the frequency
    domain and graphically displayed on a high-resolution front panel dozens of times
    a second. A system like this requires huge amounts of processing to be performed
    and must adhere to extremely tight timing requirements, if it is to function properly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在ADC读取频谱的另一端，我们可能有一个高带宽网络分析仪或示波器，它将以每秒数十吉赫兹的速率读取ADC！原始的ADC读数很可能会被转换到频域，并以每秒数十次的速度在高清前面板上图形化显示。这样的系统需要执行大量的处理，并且必须严格遵守极严格的时序要求，才能正常工作。
- en: Somewhere in the middle of the spectrum, you'll find systems such as closed-loop
    motion controllers, which will typically need to execute their PID control loops
    between hundreds of Hz to tens of kHz in order to provide stability in a fast-moving
    system. So, *how fast* is real-time? Well, as you can see from the ADC examples
    alone, it depends.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在频谱的中间部分，你会找到如闭环运动控制器这样的系统，这些系统通常需要在数百Hz到数十kHz之间执行其PID控制回路，以便在快速移动的系统提供稳定性。那么，**实时**有多快呢？好吧，正如你仅从ADC的例子中就能看到的，这取决于。
- en: In some of the previous cases, such as the oscilloscope or soldering iron, failure
    to meet a timing requirement results in poor performance or incorrect data being
    reported. In the case of the soldering iron, this might be poor temperature control
    (which could cause damage to components). For the test equipment, missing deadlines
    could cause erroneous readings, which is a failure. This may not seem like a big
    deal to some people, but for the users of that equipment, who are relying on the
    accuracy of the data being reported, it is likely to matter a great deal. Some
    laboratory equipment that is used in standard verification provides checks for
    product conformance. If there is an undetected malfunction in the equipment that
    results in an inaccurate measurement, an incorrect value could be reported. It
    may be possible for a suspect test to be rerun. Eventually, however, if retesting
    is required too often and reliable readings can't be counted on, then the test
    equipment will start to become suspect and viewed as unreliable and sales will
    decline—all because a real-time requirement wasn't being consistently met.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些先前的情况中，例如示波器或烙铁，未能满足时序要求会导致性能不佳或报告错误数据。在烙铁的情况下，这可能是温度控制不佳（这可能会损坏组件）。对于测试设备，错过截止日期可能会导致错误的读数，这是一种失败。对于一些人来说，这可能不是什么大问题，但对于依赖报告数据准确性的设备用户来说，这可能是非常重要的。一些用于标准验证的实验室设备提供了产品符合性的检查。如果设备中存在未检测到的故障，导致测量不准确，可能会报告错误值。可能可以重新运行可疑的测试。然而，如果需要频繁重新测试，并且无法保证可靠的读数，那么测试设备将开始变得可疑，被视为不可靠，销量将下降——所有这一切都是因为未能持续满足实时要求。
- en: In other systems, such as the flight control of a UAV or motion control in industrial
    process control, failing to run the control algorithm in a timely manner could
    result in something more physically catastrophic, such as a crash. In this case,
    the consequences are potentially life-threatening.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他系统中，例如无人机飞行控制或工业过程控制中的运动控制，未能及时运行控制算法可能会导致更严重的物理灾难，例如坠毁。在这种情况下，后果可能是致命的。
- en: Thankfully, there are steps that can be taken to avoid all of these failure
    scenarios.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以采取一些步骤来避免所有这些故障场景。
- en: The ways of guaranteeing real-time behavior
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保证实时行为的方法
- en: One of the easiest ways to ensure a system does what it is meant to do is to
    make sure it is as simple as possible while still meeting the requirements. This
    means resisting the urge to over-complicate a simple task. If a toaster is meant
    to toast a slice of bread, don't put a display on it and make it tell you the
    weather too; just have it turn on a heating element for the right amount of time.
    This simple task has been accomplished for years without requiring any code or
    programmable devices whatsoever.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 确保系统按预期工作的一种最简单的方法是确保它在满足要求的同时尽可能简单。这意味着抵制过度复杂化简单任务的冲动。如果烤面包机是用来烤一片面包的，那么不要在上面安装显示屏并让它告诉你天气；只需让它打开加热元件适当的时间即可。这个简单的任务多年来一直无需任何代码或可编程设备就能完成。
- en: As programmers, if we come across a problem, we have a tendency to immediately
    reach for the nearest MCU and start coding. However, some functions of a product
    (especially true if a product has electro-mechanical components) are best handled
    without code at all. A car window doesn't really need an MCU with a polling loop
    to run, turning on motors through drivers and watching sensors for feedback to
    shut them off. This task can actually be handled by a few mechanical switches
    and diodes. If a feedback-reporting mechanism is required for a given system—such
    as an error that needs to be asserted in the case of a stuck window—then there
    may be no choice but to use a more complex solution. However, our goal as engineers
    should always be the same—solve the problem as simply as possible, without adding
    additional complexity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，如果我们遇到一个问题，我们往往会立即伸手去拿最近的微控制器单元并开始编码。然而，某些产品的功能（尤其是如果产品具有机电组件）最好在不使用代码的情况下处理。汽车窗户实际上不需要带有轮询循环的微控制器来运行，通过驱动器打开电机，并监视传感器以获取反馈来关闭它们。这项任务实际上可以通过几个机械开关和二极管来处理。如果需要为给定的系统提供反馈报告机制——例如，在窗户卡住的情况下需要断言的错误——那么可能别无选择，只能使用更复杂的解决方案。然而，作为工程师，我们的目标始终应该是相同的——尽可能简单地解决问题，不要增加额外的复杂性。
- en: If a problem can be solved by hardware alone, then explore that possibility
    with the team first, before breaking out the MCU. If a problem can be handled
    by using a simple *while* loop to perform some polling of the sensor status, then
    simply poll the sensor for the status; there may be no need to start coding **interrupt
    service routines** (**ISRs**). If the functionality of the device is single-purposed,
    there are many cases where a full-blown RTOS can simply get in the way—so don't
    use one!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个问题可以通过硬件独立解决，那么首先与团队一起探索这个可能性，然后再考虑使用微控制器单元（MCU）。如果一个问题可以通过使用简单的 *while*
    循环来执行一些传感器状态的轮询来处理，那么只需轮询传感器的状态即可；可能没有必要开始编写 **中断服务例程**（**ISRs**）。如果设备的功能是单一用途的，那么在许多情况下，一个完整的实时操作系统（RTOS）可能会起到反作用——所以不要使用它！
- en: Types of real-time systems
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时系统的类型
- en: There are many different ways of achieving real-time behavior. The following
    section is a discussion on the various types of real-time systems you might encounter.
    Also note that it is possible to have combinations of the following systems working
    together as subsystems. These different subsystems can occur at a product, board,
    or even chip level (this approach is discussed in [Chapter 16](19872ca7-d0fe-44e7-a4fc-1bdbfda87e59.xhtml)*,
    Multi-Processor and Multi-Core Systems*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实现实时行为有许多不同的方法。以下部分是关于你可能会遇到的各种实时系统的讨论。此外，请注意，以下系统可以作为子系统一起工作。这些不同的子系统可以在产品、板或甚至芯片级别出现（这种方法在[第16章](19872ca7-d0fe-44e7-a4fc-1bdbfda87e59.xhtml)*多处理器和多核系统*）中讨论）。
- en: Hardware
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: The original real-time system, hardware, is still the go-to for extremely tight
    tolerance and/or fast timing requirements. It can be implemented with discrete
    digital logic, analog components, programmable logic, or an **application-specific
    integrated component** (**ASIC**). **Programmable logic devices** (**PLDs**),
    **complex programmable logic devices** (**CPLDs**), and **field-programmable gate
    arrays** (**FPGAs**) are the various members of the programmable logic device
    portion of this solution. Hardware-based real-time systems can cover anything
    from analog filters, closed loop control, and simple state machines to complex
    video codecs. When implemented with power saving in mind, ASICs can be made to
    consume less power than an MCU-based solution. In general, hardware has the advantage
    of performing operations in parallel and *instantly* (this is, of course, an over-simplification),
    as opposed to a single-core MCU, which only gives the illusion of parallel processing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的实时系统，硬件，仍然是对于极严格公差和/或快速时序要求的首选。它可以采用离散数字逻辑、模拟组件、可编程逻辑或**应用特定集成电路**（**ASIC**）。**可编程逻辑器件**（**PLDs**）、**复杂可编程逻辑器件**（**CPLDs**）和**现场可编程门阵列**（**FPGAs**）是这个解决方案中可编程逻辑器件部分的各个成员。基于硬件的实时系统可以涵盖从模拟滤波器、闭环控制、简单的状态机到复杂的视频编解码器等任何内容。如果考虑到节能，ASIC可以比基于MCU的解决方案消耗更少的电力。一般来说，硬件的优势在于并行执行操作和**瞬间**（当然，这是一个过于简化的说法），而单核MCU只能提供并行处理的假象。
- en: 'The downsides for real-time hardware development generally include the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实时硬件开发的缺点通常包括以下内容：
- en: The inflexibility of non-programmable devices.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非可编程设备的僵化性。
- en: The expertise required is generally less commonly available than software/firmware
    developers.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的专业知识通常不如软件/固件开发者常见。
- en: The cost of full-featured programmable devices (for example, large FPGAs).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全功能可编程设备（例如，大型FPGAs）的成本。
- en: The high cost of developing a custom ASIC.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发定制ASIC的高成本。
- en: Bare-metal firmware
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯硬件固件
- en: Bare-metal firmware is considered (for our purposes) to be any firmware that
    isn't built *on top of* a preexisting kernel/scheduler of some type. Some engineers
    take this a step further, arguing that true bare-metal firmware can't use any
    preexisting libraries (such as vendor supply hardware abstraction libraries)—there
    is some merit to this view as well. A bare-metal implementation has the advantage
    that the user's code has *total* control of *all* aspects of the hardware. The
    only way for the main loop code execution to be interrupted is if an interrupt
    fires. In this case, the only way for anything else to take control of the CPU
    is for the existing ISR to finish or for another higher-priority interrupt to
    fire.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 纯硬件固件（就我们的目的而言）被认为是任何不是建立在某种预存在内核/调度器之上的固件。一些工程师更进一步，认为真正的纯硬件固件不能使用任何预存在的库（例如供应商提供的硬件抽象库）——这种观点也有一定的合理性。纯硬件实现的优势在于用户的代码对硬件的所有方面都有**完全**的控制。主循环代码执行被中断的唯一方式是如果发生中断。在这种情况下，其他任何东西要控制CPU的唯一方式是现有的中断服务例程（ISR）完成或发生另一个更高优先级的中断。
- en: Bare-metal firmware solutions excel when there is a small number of relatively
    simple tasks to perform—or one monolithic task. If the firmware is kept focused
    and best practices are followed, deterministic performance is generally easy to
    measure and guarantee due to the relatively small number of interactions between
    ISRs (or in some cases, a lack of ISRs). In some extreme cases for heavily loaded
    MCUs (or MCUs that are highly constrained in ROM/RAM), bare-metal is the only
    option.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要执行的任务数量少且相对简单时，或者有一个单一的任务时，纯硬件固件解决方案表现优异。如果固件保持专注并遵循最佳实践，由于ISR（或在某些情况下，ISR的缺乏）之间的交互相对较少，确定性的性能通常容易测量和保证。在某些极端情况下，对于负载很重的MCU（或ROM/RAM高度受限的MCU），纯硬件是唯一的选择。
- en: As bare-metal implementations get to be more elaborate when dealing with events
    asynchronously, they start to overlap with functionality provided by an RTOS.
    An important consideration to keep in mind is that by using an RTOS—rather than
    attempting to roll your own thread-safe system—you automatically benefit from
    all of the testing the RTOS provider has put in. You'll also have the opportunity
    to use code that has the power of hindsight behind it—all of the RTOSes available
    today have been around for several years. The authors have been adapting and adding
    functionality the entire time to make them robust and flexible for different applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当裸机实现处理异步事件变得更加复杂时，它们开始与RTOS提供的功能重叠。需要记住的一个重要考虑因素是，通过使用RTOS——而不是尝试自己构建线程安全的系统——您可以自动受益于RTOS提供商所进行的所有测试。您还将有机会使用具有事后诸葛亮能力的代码——今天可用的所有RTOS都已经存在了几年。作者一直在适应和添加功能，使它们对不同应用具有鲁棒性和灵活性。
- en: RTOS-based firmware
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于RTOS的固件
- en: Firmware that runs a scheduling kernel on an MCU is RTOS-based firmware. The
    introduction of the scheduler and some RTOS-primitives allows tasks to operate
    under the illusion they have the processor to themselves (discussed in detail
    in [Chapter 2](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml), *Understanding RTOS
    Tasks*). Using an RTOS enables the system to remain responsive to the most important
    events while performing other complex tasks *in the background*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在微控制器（MCU）上运行调度内核的固件是基于RTOS的固件。调度器的引入和一些RTOS原语使得任务可以在拥有处理器的感觉下运行（详细讨论见[第2章](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml)，*理解RTOS任务*）。使用RTOS可以使系统在执行其他复杂任务的同时，对最重要的事件保持响应。
- en: There are a few downsides to all of these tasks running. Inter-dependencies
    can arise between tasks sharing data—if not handled properly, the dependency will
    cause a task to block unexpectedly. Although there are provisions for handling
    this, it does add complexity to the code. Interrupts will generally use task signaling
    to take care of the interrupt as quickly as possible and defer as much processing
    to a task as possible. If handled properly, this solution is excellent for keeping
    complex systems responsive, despite many complex interactions. However, if handled
    improperly, this design paradigm can lead to more timing jitter and less determinism.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务同时运行有一些缺点。共享数据的任务之间可能会出现相互依赖性——如果处理不当，依赖性会导致任务意外阻塞。尽管有处理这种情况的措施，但它确实增加了代码的复杂性。中断通常使用任务信号来尽快处理中断，并将尽可能多的处理推迟到任务中。如果处理得当，这种解决方案对于保持复杂系统响应性是极好的，尽管存在许多复杂的交互。然而，如果处理不当，这种设计范式可能导致更多的时间抖动和更少的确定性。
- en: RTOS-based software
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于RTOS的软件
- en: Software running on a *full* OS that contains a **memory management unit** (**MMU**)
    and **central processing unit** (**CPU**) is considered RTOS-based software. Applications
    that are implemented with this approach can be highly complex, requiring many
    different interactions between various internal and external systems. The advantage
    of using a full OS is all of the capability that comes along with it—both hardware
    and software.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含**内存管理单元**（**MMU**）和**中央处理单元**（**CPU**）的**完整**操作系统上运行的软件被认为是基于实时操作系统（RTOS）的软件。采用这种方法实现的应用程序可能非常复杂，需要各种内部和外部系统之间进行许多不同的交互。使用完整操作系统的优点是它所附带的所有能力——包括硬件和软件。
- en: On the hardware side, there are generally more CPU cores available running at
    higher clock rates. There can be gigabytes of RAM and persistent memory available.
    Adding peripheral hardware can be as simple as the addition of a card (provided
    there are pre-existing drivers).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件方面，通常有更多的CPU核心可用，运行在更高的时钟频率上。可能有数GB的RAM和持久性内存可用。添加外围硬件可能就像添加一张卡一样简单（前提是有现成的驱动程序）。
- en: On the software side, there is a plethora of open source and vendor proprietary
    solutions for networking stacks, UI development, file handling, and so on. Underneath
    all of this capability and options, the kernel is still implemented in such a
    way that the critical tasks won't be blocked for an indefinite period of time,
    which is possible with a traditional OS. Because of this, getting deterministic
    performance is still within reach, just like with RTOS firmware.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件方面，有大量的开源和供应商专有解决方案用于网络堆栈、UI开发、文件处理等。在所有这些能力和选项之下，内核的实现方式仍然确保关键任务不会无限期地被阻塞，这是传统操作系统所能实现的。正因为如此，获得确定性的性能仍然在掌握之中，就像RTOS固件一样。
- en: Carefully crafted OS software
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精心打造的操作系统软件
- en: Similar to RTOS-based software, a standard OS has all of the libraries and features
    a developer could ask for. What's missing, however, is a strict focus on meeting
    timing requirements. Generally speaking, systems implemented with a traditional
    OS are going to have much less deterministic behavior (and none that can be truly
    counted on in a safety-critical situation). If there is a lax real-time requirement
    without catastrophic consequences, if a wishy-washy deadline isn't met on time,
    a standard OS can be made to work, as long as care is taken in choosing what software
    stacks are running and their resource use is kept in check. The Linux kernel with
    `PREEMPT_RT` patches is a good example of this type of real-time system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于实时操作系统（RTOS）的软件类似，标准操作系统拥有开发者可能需要的所有库和功能。然而，它缺少的是对满足时序要求的严格关注。一般来说，使用传统操作系统实现的系统将具有更少的确定性行为（在安全关键情况下，没有任何行为是可以真正依赖的）。如果没有灾难性的后果，如果软实时要求宽松，如果截止日期不按时完成，标准操作系统仍然可以工作，只要在选择运行的软件栈及其资源使用上保持谨慎。带有`PREEMPT_RT`补丁的Linux内核就是这种实时系统的良好例子。
- en: So, now that all of the options for achieving a real-time system have been laid
    out, it's time to define exactly what we mean when we say RTOS, specifically an
    MCU-based RTOS.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经概述了实现实时系统的所有选项，是时候定义当我们说RTOS时，具体是指基于微控制器（MCU）的RTOS了。
- en: Defining RTOS
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义RTOS
- en: 'OSes (such as Windows, Linux, and macOS) were created as a way to provide a
    consistent programming environment that abstracted away the underlying hardware
    to make it easier to write and maintain computer programs. They provide the application
    programmer with many different *primitives* (such as threads and mutexes) that
    can be used to create more complex behavior. For example, it is possible to create
    a multi-threaded program that provides protected access to shared data:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（如Windows、Linux和macOS）被创建作为一种提供一致编程环境的方式，它抽象了底层硬件，使得编写和维护计算机程序变得更容易。它们为应用程序程序员提供了许多不同的**原语**（如线程和互斥锁），可以用来创建更复杂的行为。例如，可以创建一个多线程程序，它提供了对共享数据的受保护访问：
- en: '![](img/55cac298-4735-4ae8-98da-d247f5eef970.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55cac298-4735-4ae8-98da-d247f5eef970.png)'
- en: 'The preceding application doesn''t *implement* thread and mutex primitives,
    it only makes use of them. The actual implementations of threads and mutexes are
    handled by the OS. This has a few advantages:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的应用程序并没有**实现**线程和互斥锁原语，它只是使用了它们。线程和互斥锁的实际实现由操作系统处理。这有几个优点：
- en: The application code is less complex.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序代码更简单。
- en: It is easier to understand—the same primitives are used regardless of the programmer,
    making it easier to understand code created by different people.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更易于理解——无论程序员是谁，都使用相同的原语，这使得理解不同人编写的代码变得更容易。
- en: The is better hardware portability—with the proper precautions, the code can
    be run on any hardware supported by the OS without modification.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的硬件可移植性——在适当的预防措施下，代码可以在操作系统支持的任何硬件上运行而无需修改。
- en: In the preceding example, a *mutex* is used to ensure that only one thread can
    access the s*hared data* at a time. In the case of a general-purpose OS, each
    thread will happily wait for the mutex to become available indefinitely before
    moving on to access the shared data. This is where RTOSes diverge from general-purpose
    OSes. In an RTOS, all blocking system calls are time-bound. Instead of waiting
    for the mutex indefinitely, an RTOS allows a maximum delay to be specified. For
    example, if Thread 1 attempts to acquire Mutex and still doesn't have it after
    100 ms, or 1 second, it will continue waiting for the mutex to become available.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用了一个**互斥锁**来确保一次只有一个线程可以访问共享数据。在通用操作系统中，每个线程都会无限期地等待互斥锁变为可用，然后才继续访问共享数据。这就是RTOS与通用操作系统不同的地方。在RTOS中，所有阻塞的系统调用都有时间限制。而不是无限期地等待互斥锁，RTOS允许指定最大延迟。例如，如果线程1尝试获取互斥锁，在100毫秒或1秒后仍然没有获取到，它将继续等待互斥锁变为可用。
- en: In an RTOS implementation, the maximum amount of time to wait for Mutex to become
    available is specified. If Thread 1 specifies that it must acquire the mutex within
    100 ms and still hasn't received the mutex after 101 ms, Thread 1 will receive
    a notification that the mutex hasn't been acquired in time. This timeout is specified
    to help create a deterministic system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时操作系统（RTOS）的实现中，指定了等待互斥锁（Mutex）可用的最大时间。如果线程1指定必须在100毫秒内获取互斥锁，但在101毫秒后仍未收到互斥锁，线程1将收到一个通知，表明互斥锁没有及时获取。这个超时是为了帮助创建一个确定性系统。
- en: Any OS that provides a deterministic way of executing a given piece of code
    can be considered a real-time OS. This definition of RTOS covers a fairly large
    number of systems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 任何提供以确定性方式执行给定代码的OS都可以被认为是实时操作系统。这种RTOS的定义涵盖了相当大数量的系统。
- en: 'There are a couple of characteristics that tend to differentiate one RTOS application
    from another: how often *not* meeting a real-time deadline is acceptable and the
    severity of not meeting a real-time deadline. The different ranges of RTOS applications
    are usually lumped into three categories—hard, firm, and soft real-time systems.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特性往往区分了一个RTOS应用程序与另一个：不满足实时截止日期的频率和严重性。RTOS应用程序的不同范围通常被归纳为三个类别——硬实时、稳定实时和软实时系统。
- en: Don't get too hung up on the differences between firm and soft real-time systems.
    The definitions for these terms don't even have unanimous agreement from within
    our industry. What *does* matter is that you know your system's requirements and
    design a solution to meet them!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于纠结于稳定和软实时系统之间的差异。这些术语的定义甚至在我们行业内都没有达成一致意见。真正重要的是，你要了解你系统的需求，并设计一个解决方案来满足它们！
- en: The severity of a failure is generally deemed *safety-critical* if a failure
    will cause the loss of life or significant property. There are hard real-time
    systems that have nothing to do with safety.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个故障会导致生命丧失或重大财产损失，那么该故障的严重性通常被认为是**安全关键**的。有一些硬实时系统与安全性无关。
- en: Hard real-time systems
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬实时系统
- en: A hard real-time system must meet its deadline 100% of the time. If the system
    does not meet a deadline, then it is considered to have failed. This doesn't necessarily
    mean a failure will hurt someone if it occurs in a hard real-time system—only
    that the system *has* failed if it misses a single deadline.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 硬实时系统必须100%地按时完成其截止日期。如果系统没有按时完成截止日期，那么它被认为已经失败。这并不一定意味着如果在一个硬实时系统中发生故障会伤害到人——只是如果它错过了一个截止日期，那么系统**已经**失败了。
- en: Some examples of hard real-time systems can be found in medical devices, such
    as pacemakers and control systems with extremely tightly controlled parameters.
    In the case of a pacemaker, if the pacemaker misses a deadline to administer an
    electrical pulse at the right moment in time, it might kill the patient (this
    is why pacemakers are defined as safety-critical systems).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 硬实时系统的例子可以在医疗设备中找到，例如起搏器和具有极严格参数控制的控制系统。在起搏器的例子中，如果起搏器错过在正确时间点发放电脉冲的截止日期，它可能会杀死患者（这就是为什么起搏器被定义为安全关键系统）。
- en: In contrast, if a motion control system on a **computer numerical control**
    (**CNC**) milling machine doesn't react to a command in time, it might plunge
    a tool into the wrong part of the part being machined, ruining it. In these cases
    that we have mentioned, one failure caused a loss of life, while the other turned
    some metal into scrap—but both were failures caused by a single missed deadline.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果一个计算机数控（**CNC**）铣床上的运动控制系统没有及时响应一个命令，它可能会将工具插入到正在加工的部件的错误部分，从而损坏它。在我们提到的这些情况下，一个故障导致了生命丧失，而另一个将一些金属变成了废料——但两者都是由一个错过截止日期的单个故障引起的。
- en: Firm real-time systems
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳定实时系统
- en: As opposed to hard real-time systems, firm real-time systems need to hit their
    deadlines *nearly* all of the time. If video and audio lose synchronization momentarily,
    it probably won't be considered a system failure, but will likely upset the consumer
    of the video.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬实时系统相反，稳定实时系统需要几乎每次都能按时完成其截止日期。如果视频和音频暂时失去同步，这可能不会被视为系统故障，但很可能会让视频的消费者感到不满。
- en: In most control systems (similar to the soldering iron in a previous example),
    a few samples that are read slightly outside of their specified time are unlikely
    to completely destroy system control. If a control system has an ADC that automatically
    takes a new sample, if the MCU doesn't read the new sample in time, it will be
    overwritten by a new one. This can occur occasionally, but if it happens too often
    or too frequently, the temperature stability will be ruined. In a particularly
    demanding system, it may only take a few missed samples before the entire control
    system is *out of spec*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数控制系统中（类似于之前例子中的烙铁），一些稍微超出指定时间读取的样本不太可能完全破坏系统控制。如果一个控制系统有一个自动获取新样本的ADC，如果MCU没有及时读取新样本，它将被新的一个覆盖。这种情况偶尔会发生，但如果它发生得太频繁，温度稳定性就会被破坏。在一个特别要求高的系统中，可能只需要错过几个样本，整个控制系统就会*超出规格*。
- en: Soft real-time systems
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软实时系统
- en: Soft real-time systems are the most lax when it comes to how often the system
    must meet its deadlines. These systems often offer only a *best-effort* promise
    for keeping deadlines.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 软实时系统在系统必须满足其截止日期的频率方面最为宽松。这些系统通常只提供*尽力而为*的承诺来保持截止日期。
- en: Cruise control in a car is a good example of a soft real-time system because
    there are no hard specifications or expectations of it. Drivers typically don't
    expect their speed to converge to within +/- *x* mph/kph of the set speed. They
    expect that given *reasonable* circumstances, such as no large hills, the control
    system will eventually get them *close* to their desired speed *most of the time*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车上的巡航控制是一个软实时系统的良好例子，因为它没有硬性规格或期望。驾驶员通常不会期望他们的速度收敛到设定速度的±*x*英里/小时/公里。他们期望在*合理*的情况下，例如没有大坡，控制系统最终会让他们*接近*他们期望的速度*大多数时候*。
- en: The range of RTOSes
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTOSes的范围
- en: RTOSes range in their functionality, as well as the architecture and size of
    the processor they're best suited to. On the smaller side, we have smaller 8–32-bit
    MCU-focused RTOSes, such as FreeRTOS, Keil RTX, Micrium µC, ThreadX, and many
    more.  This class of RTOS is suitable for use on microcontrollers and provides
    a compact real-time kernel as the most basic offering. When moving from MCUs to
    32- and 64-bit application processors, you'll tend to find RTOSes such as Wind
    River VxWorks and Wind River Linux, Green Hills' Integrity OS, and even Linux
    with `PREEMPT_RT` kernel extensions. These full-blown OSes offer a large selection
    of software, providing solutions for both real-time scheduling requirements as
    well as general computing tasks. Even with the OSes we've just rattled off, we've
    only scratched the surface of what's available. There are free and paid solutions
    (some costing well over USD$10,000) at all levels of RTOSes, big and small.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: RTOSes的功能、架构以及它们最适合的处理器的大小各不相同。在较小的方面，我们有针对小型8-32位MCU的RTOSes，如FreeRTOS、Keil
    RTX、Micrium µC、ThreadX以及更多。这类RTOS适用于微控制器，并提供一个紧凑的实时内核作为最基本的服务。当从MCU转向32位和64位应用处理器时，你往往会发现RTOSes，如Wind
    River VxWorks和Wind River Linux、Green Hills的Integrity OS，甚至带有`PREEMPT_RT`内核扩展的Linux。这些完整的操作系统提供了大量的软件，为实时调度需求以及一般计算任务提供解决方案。即使是我们刚刚提到的操作系统，我们也只是触及了表面。在RTOSes的所有级别，无论是大是小，都有免费和付费的解决方案（一些成本超过10,000美元）。
- en: So, why would you choose to pay for a solution when there is something available
    for free? The main differentiating factors between freely available RTOS solutions
    and paid solutions are safety approvals, middleware, and customer support.  Because RTOSes
    provide a highly deterministic execution environment, they are often used in complex
    safety-critical applications. By *safety critical,* we generally mean a system
    whose failure could harm people or cause significant damage. These systems require
    deterministic operation because they must behave in a predictable way all the
    time. Guaranteeing the code responds to events within a fixed amount of time is
    a significant step toward ensuring they behave consistently. Most of these safety-critical
    applications are regulated and have their own sets of governing bodies and standards,
    such as DO-178B and DO-178C for aircraft or IEC 61508 SIL 3 and ISO 26262 ASILD
    for industrial applications. To make safety-critical certifications more affordable,
    designers will typically either keep code for these systems extremely simple (so
    it is possible to prove mathematically that the system will function consistently
    and nothing can go wrong) or turn to a commercial RTOS solution, which has been
    through certification already, as a starting point. WITTENSTEIN SafeRTOS is a
    derivative of FreeRTOS that carries approvals for industrial, medical, and automotive
    use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么你会选择为解决方案付费，当有免费的东西可用时呢？免费可用的 RTOS 解决方案和付费解决方案之间的主要区别因素是安全认证、中间件和客户支持。因为
    RTOS 提供了一个高度确定的执行环境，它们通常用于复杂的安全关键应用。我们通常所说的 *安全关键* 是指一个系统，其故障可能会伤害人员或造成重大损害。这些系统需要确定性的操作，因为它们必须始终以可预测的方式行事。保证代码在固定时间内对事件做出响应是确保它们行为一致的重要步骤。大多数这些安全关键应用都受到监管，并有自己的监管机构和标准，例如飞机的
    DO-178B 和 DO-178C 或工业应用的 IEC 61508 SIL 3 和 ISO 26262 ASILD。为了使安全关键认证更加经济实惠，设计人员通常会保持这些系统的代码极其简单（这样就可以从数学上证明系统将始终如一地运行，不会出错），或者将商业
    RTOS 解决方案作为起点，这些解决方案已经通过了认证。WITTENSTEIN SafeRTOS 是 FreeRTOS 的一个分支，已经获得了工业、医疗和汽车使用的认证。
- en: Middleware can also be an extremely important component in complex systems. Middleware
    is code that runs between the *user code* (code that *you, *the application programmer,
    write) and lower layers, such as the RTOS or bare metal (no RTOS). Another value
    proposition of paid solutions is that the ecosystem offers a suite of pre-integrated
    high-quality middleware (such as filesystems, networking stacks, GUI frameworks,
    industrial protocols, and so on) that minimizes development and reduces overall
    project risk. The reason for using middleware, rather than *rolling your own*,
    is to reduce the amount of original code being written by an in-house development
    team. This reduces both the risk and the total time spent by the team—so it can
    be a worth-while investment, depending on factors such as project complexity and
    schedule requirements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件也可以是复杂系统中极其重要的组成部分。中间件是介于 *用户代码*（即你，*应用开发者*编写的代码）和底层，例如实时操作系统（RTOS）或裸机（无RTOS）之间的代码。付费解决方案的另一个价值主张是，生态系统提供了一套预先集成的、高质量的中件（例如文件系统、网络堆栈、GUI
    框架、工业协议等），这最大限度地减少了开发工作并降低了整体项目风险。使用中间件而不是 *自行开发* 的原因是为了减少内部开发团队编写的原始代码量。这减少了团队的风险和总耗时——因此，这可以是一项值得的投资，这取决于项目复杂性和时间要求等因素。
- en: Paid solutions will also typically come with some level of customer support
    directly from the firmware vendor. Engineers are expensive to hire and keep on
    staff. There's nothing a manger dreads more than walking into a room full of engineers
    who are puzzling over their tools, rather than working on the *real* problems
    that need to be solved. Having expert help that is an email or phone call away
    can increase a team's productivity dramatically, which leads to a shorter turnaround
    and a happier workplace for everyone.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 付费解决方案通常还会附带来自固件供应商的一些级别的客户支持。工程师的雇佣和保留成本很高。经理最害怕的事情之一就是走进一个房间里满是工程师在困惑他们的工具，而不是解决需要解决的
    *真正* 问题。拥有专家帮助，只需一封电子邮件或一个电话就能得到，可以显著提高团队的生产力，这导致周转时间缩短，每个人都更加快乐。
- en: FreeRTOS has both paid support and training options, as well as paid middleware
    solutions, that can be integrated. However, there are also open source and/or
    freely available middleware components available, some of which will be discussed
    in this book.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS提供付费支持和培训选项，以及付费的中间件解决方案，可以集成。然而，也有开源和/或免费提供的中间件组件，其中一些将在本书中讨论。
- en: The RTOS used in this book
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书使用的RTOS
- en: 'With all of the options available, you might be wondering: why is it that this
    book is only covering one RTOS on a single model of MCU? There are a few reasons,
    one being that most of the concepts we''ll cover are applicable to nearly any
    RTOS available, in the same way that good coding habits transcend the language
    you happen to be coding. By focusing on a single implementation of an RTOS with
    a single MCU, we''ll be able to dive into topics in more depth than would have
    been possible if all of the alternatives were also attempted to be discussed.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可用的选项中，你可能想知道：为什么这本书只介绍了一种在单个MCU型号上的RTOS？有几个原因，其中之一是，我们将涵盖的大部分概念几乎适用于任何可用的RTOS，就像良好的编码习惯超越了你所使用的语言一样。通过专注于单个MCU上的RTOS的单个实现，我们将能够比如果尝试讨论所有替代方案更深入地探讨主题。
- en: FreeRTOS is one of the most popular RTOS implementations for MCUs and is very
    widely available. It has been around for over 15 years and has been ported to
    dozens of platforms . If you've ever spoken to a true low-level embedded systems
    engineer who is familiar with RTOS programming, they've certainly heard of FreeRTOS
    and have likely used it at least once. By focusing our attention on FreeRTOS,
    you'll be well-positioned to quickly migrate your knowledge of FreeRTOS to other
    hardware or to transition to another RTOS, if the situation calls for it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS是针对MCU最流行的RTOS实现之一，并且非常广泛可用。它已经存在超过15年，并且已经移植到数十个平台。如果你曾经与一个真正熟悉RTOS编程的低级嵌入式系统工程师交谈过，他们肯定听说过FreeRTOS，并且很可能至少使用过一次。通过关注FreeRTOS，你将能够快速地将你对FreeRTOS的知识迁移到其他硬件，或者如果情况需要，过渡到另一个RTOS。
- en: The other reason we're using FreeRTOS? Well, it's FREE! FreeRTOS is distributed
    under the MIT license. See [https://www.freertos.org/a00114.html](https://www.freertos.org/a00114.html)
    for more details on licensing and other FreeRTOS derivatives, such as SAFERTOS
    and OpenRTOS.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用FreeRTOS的另一个原因？嗯，它是免费的！FreeRTOS在MIT许可下分发。有关许可和其他FreeRTOS衍生产品（如SAFERTOS和OpenRTOS）的更多详细信息，请参阅[https://www.freertos.org/a00114.html](https://www.freertos.org/a00114.html)。
- en: 'The following is a diagram showing where FreeRTOS sits in a typical ARM firmware
    stack. *Stack* refers to all of the different *layers* of firmware components
    that make up the system and how they are *stacked* on top of one another. A *user*
    in this context refers to the programmer using FreeRTOS (rather than the end user
    of the embedded system):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了FreeRTOS在典型ARM固件堆栈中的位置。"堆栈"指的是构成系统的所有不同的**层**的固件组件以及它们是如何一层层堆叠的。这里的"用户"指的是使用FreeRTOS的程序员（而不是嵌入式系统的最终用户）：
- en: '![](img/df5dcef3-c4c4-427e-94ea-a40748fd8064.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df5dcef3-c4c4-427e-94ea-a40748fd8064.png)'
- en: 'Some noteworthy items are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得注意的项目如下：
- en: User code is able to access the same FreeRTOS API, regardless of the underlying
    hardware port implementation.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户代码能够访问相同的FreeRTOS API，无论底层硬件端口实现如何。
- en: FreeRTOS does not prevent User code from using vendor-supplied drivers, CMSIS,
    or raw hardware registers.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS不会阻止用户代码使用供应商提供的驱动程序、CMSIS或原始硬件寄存器。
- en: Having a standardized API that is consistent across hardware means code can
    be easily migrated between hardware targets, without being constantly rewritten.
    The ability to have code talk directly to hardware also provides the means to
    write *extremely* efficient code when necessary (at the expense of portability).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个在硬件上保持一致的标准化API意味着代码可以轻松地在硬件目标之间迁移，而无需不断重写。能够让代码直接与硬件通信也提供了在必要时编写**极其**高效代码的手段（以牺牲可移植性为代价）。
- en: Now that we know what an RTOS is, let's have a closer look at when it is appropriate
    to use an RTOS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了RTOS是什么，让我们更详细地看看何时使用RTOS是合适的。
- en: Deciding when to use an RTOS
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定何时使用RTOS
- en: Occasionally, when someone first learns of the term *real-time OS*, they mistakenly
    believe that an RTOS is the only way to achieve real-time behavior in an embedded
    system. While this is certainly understandable (especially given the name) it
    couldn't be further from the truth. Sometimes, it is best to think of an RTOS
    as a *potential* solution, rather than *the *solution to be used for everything. Generally
    speaking, for an MCU-based RTOS to be the ideal solution for a given problem,
    it needs to have a *Goldilocks-*level of complexity—not too simple, but not too
    complicated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当某人第一次听说**实时操作系统**这个术语时，他们可能会错误地认为RTOS是唯一实现嵌入式系统中实时行为的方法。虽然这当然是可以理解的（尤其是考虑到这个名字），但这与事实相去甚远。有时，最好将RTOS视为一个**潜在**的解决方案，而不是用于所有事情的**解决方案**。一般来说，对于一个基于MCU的RTOS要成为特定问题的理想解决方案，它需要具有**金发姑娘**级别的复杂性——既不太简单，也不太复杂。
- en: If there is an *extremely* simple problem, such as monitoring two states and
    triggering an alert when they are both present, the solution could be a straightforward
    hardware solution (such as an AND gate). In this case, there may be no reason
    to complicate things further, since the AND gate solution is going to be very
    fast, with high determinism and extreme reliability. It will also require very
    little development time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在一个**极其**简单的问题，例如监控两个状态并在它们都存在时触发警报，解决方案可能是一个直接的硬件解决方案（例如AND门）。在这种情况下，可能没有必要进一步复杂化问题，因为AND门解决方案将会非常快，具有高确定性和极端可靠性。它也将需要非常少的发展时间。
- en: Now, consider a case where there are only one or two tasks to be performed,
    such as controlling the speed of a motor and watching an encoder to ensure the
    correct distance is traversed. This could certainly be implemented in discrete
    analog and digital hardware, but having a configurable distance would add some
    complexity. Additionally, tuning the control loop coefficients would likely require
    twiddling the potentiometer settings (possibly for each individual board), which
    is undesirable in some or most cases, by today's manufacturing standards. So,
    on the hardware solution side, we're left with a CPLD or FPGA to implement the
    motion control algorithm and track the distance traveled. This happens to be a
    very good fit for either, since it is potentially small enough to fit into a CPLD,
    but in some cases, the cost of an FPGA might be unacceptable. This problem is
    also handled by MCUs regularly. If existing in-house resources don't have the
    expertise required with hardware languages or toolchains, then a bare-metal MCU
    firmware solution is probably a good fit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一个只有一两个任务需要执行的情况，例如控制电机的速度并监控编码器以确保正确地行进了正确的距离。这当然可以通过离散的模拟和数字硬件实现，但具有可配置的距离会增加一些复杂性。此外，调整控制回路系数可能需要调整电位计设置（可能每个单独的板都需要），这在某些或大多数情况下，按照今天的制造标准是不理想的。因此，在硬件解决方案方面，我们只剩下CPLD或FPGA来实现运动控制算法并跟踪行进距离。这恰好非常适合两者，因为它可能足够小，可以放入CPLD，但在某些情况下，FPGA的成本可能无法接受。这个问题也经常由MCU处理。如果现有的内部资源没有与硬件语言或工具链相关的专业知识，那么裸机MCU固件解决方案可能是一个不错的选择。
- en: Let's say the problem is more complicated, such as a device that controls several
    different actuators, reads data from a range of sensors, and stores those values
    in local storage. Perhaps the device also needs to sit on some sort of network,
    such as Ethernet, Wi-Fi, **controller area network** (**CAN**), and so on. An
    RTOS can solve this type of problem quite well. The fact that there are many different
    tasks that need to be completed, more or less asynchronously to one another, makes
    it very easy to argue that the additional complexity the RTOS brings will pay
    off. The RTOS helps us to ensure the lower priority, more complex tasks, such
    as networking and the filesystem stacks, won't interfere with the more time-critical
    tasks (such as controlling actuators and reading sensors). In many cases, there
    may be some form of control system that generally benefits from being run at well-defined
    intervals in time—a strength of the RTOS.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设问题更加复杂，例如一个控制多个不同执行器的设备，从一系列传感器读取数据，并将这些值存储在本地存储中。也许该设备还需要连接到某种网络，如以太网、Wi-Fi、**控制器局域网络**（**CAN**）等。实时操作系统可以很好地解决这个问题。需要完成许多不同的任务，这些任务或多或少是异步的，这使得很容易论证实时操作系统带来的额外复杂性是值得的。实时操作系统帮助我们确保低优先级、更复杂的任务（如网络和文件系统堆栈）不会干扰更时间敏感的任务（如控制执行器和读取传感器）。在许多情况下，可能存在某种控制系统，通常从时间上定义良好的间隔运行中获益——这是实时操作系统的优势。
- en: Now, consider a similar system to the previous one, but now there are multiple
    networking requirements, such as serving a web page, dealing with user authentication
    in a complex enterprise environment, and pushing files to various shared directories
    that require different network-based file protocols. This level of complexity *can*
    be achieved with an RTOS, but again, depending on the available team resources,
    this might be better left to a full-blown OS to handle (either RTOS or general-purpose),
    since many of the complex software stacks required already exist. Sometimes, a
    multi-core approach might be taken, with one of the cores running an RTOS and
    the other running a general-purpose OS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一个与之前类似的系统，但现在有多个网络要求，例如提供网页服务、在复杂的企业环境中处理用户身份验证，以及将文件推送到需要不同网络文件协议的多个共享目录。这种复杂程度*可以*通过实时操作系统实现，但同样，根据可用的团队资源，这可能会更好留给一个完整的操作系统来处理（无论是实时操作系统还是通用操作系统），因为许多所需的复杂软件栈已经存在。有时，可能会采用多核方法，其中一个核心运行实时操作系统，而另一个核心运行通用操作系统。
- en: By now, it is probably obvious that there is no definitive way to determine
    exactly which real-time solution is correct for *all* cases. Each project and
    team will have their own unique requirements, backgrounds, skill-sets, and contexts
    that set the stage for this decision. There are many factors that go into selecting
    a solution to a problem; it is important to keep an open mind and to choose the
    solution that is best for your team and project at that point in time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，可能已经很清楚，没有一种确定的方法可以精确地确定哪种实时解决方案适用于*所有*情况。每个项目和团队都会有他们自己独特的需求、背景、技能组合和情境，这些都为这一决策奠定了基础。选择解决方案时需要考虑许多因素；保持开放的心态，并选择最适合您团队和当时项目的解决方案是很重要的。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered how to identify real-time requirements, as well
    as the different platforms available for implementing real-time systems. At this
    point, you should have an appreciation for both the wide range of systems that
    can have real-time requirements, as well as the variety of ways there are to meet
    those real-time requirements.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何识别实时需求，以及实现实时系统的不同平台。到现在，您应该对可能具有实时需求的广泛系统以及满足这些实时需求的各种方式有所认识。
- en: In the next chapter, we'll start digging into MCU-based real-time firmware by
    taking a closer look at two different programming models—super loops and RTOS
    tasks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过更深入地研究两种不同的编程模型——超级循环和实时操作系统任务，来开始探讨基于MCU的实时固件。
- en: Questions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    with on this chapter''s material. You will find the answers in the *Assessments* section
    of the appendix:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所总结，以下是一些问题，供您测试对本章材料的理解。您将在附录的*评估*部分找到答案：
- en: Does a system with real-time requirements always need to be extremely fast?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有实时要求的系统是否总是需要非常快？
- en: Is an RTOS always required for real-time systems?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实时系统是否总是需要实时操作系统？
- en: Is firmware the only way to satisfy real-time requirements?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固件是否是满足实时性要求的唯一途径？
- en: What is a real-time system?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是实时系统？
- en: Name 3–4 types of real-time systems.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举3-4种实时系统的类型。
- en: When is it appropriate to use an RTOS to meet real-time requirements?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下使用实时操作系统（RTOS）来满足实时性要求是合适的？
