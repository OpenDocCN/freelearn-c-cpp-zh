["```cpp\n#include <cpprest/http_client.h> \n#include <cpprest/filestream.h> \n//----- Some standard C++ headers emitted for brevity\n#include \"cpprest/json.h\" \n#include \"cpprest/http_listener.h\" \n#include \"cpprest/uri.h\" \n#include \"cpprest/asyncrt_utils.h\" \n//////////////////////////////////////////////// \n// A Simple HTTP Client to Demonstrate  \n// REST SDK Client programming model \n// The Toy sample shows how one can read  \n// contents of a web page \n// \nusing namespace utility;  // Common utilities like string conversions \nusing namespace web;      // Common features like URIs. \nusing namespace web::http;// Common HTTP functionality \nusing namespace web::http::client;// HTTP client features \nusing namespace concurrency::streams;// Asynchronous streams \n\nint main(int argc, char* argv[]) \n{ \n   auto fileStream = std::make_shared<ostream>(); \n   // Open stream to output file. \n   pplx::task<void> requestTask =  \n              fstream::open_ostream(U(\"google_home.html\")). \n         then([=](ostream outFile) \n   { \n         *fileStream = outFile; \n         // Create http_client to send the request. \n         http_client client(U(\"http://www.google.com\")); \n         // Build request URI and start the request. \n          uri_builder builder(U(\"/\")); \n         return client.request(methods::GET, builder.to_string()); \n\n   }).then([=](http_response response) \n   { \n         printf(\"Received response status code:%un\",  \n                                    response.status_code()); \n             return response.body(). \n                           read_to_end(fileStream->streambuf()); \n   }).then([=](size_t){ \n         return fileStream->close(); \n   }); \n\n   // We have not started execution, just composed \n   // set of tasks in a Continuation Style \n   // Wait for all the outstanding I/O to complete  \n   // and handle any exceptions, If any  \n   try { \n         //-- All Taskss will get triggered here \n         requestTask.wait(); \n   } \n   catch (const std::exception &e) { \n         printf(\"Error exception:%sn\", e.what()); \n   } \n   //---------------- pause for a key  \n   getchar(); \n   return 0; \n} \n```", "```cpp\n///////////////////////////////// \n//  A Simple Web Application with C++ REST SDK \n//  We can use Postman Or Curl to test the Server \nusing namespace std; \nusing namespace web; \nusing namespace utility; \nusing namespace http; \nusing namespace web::http::experimental::listener; \n///////////////////////////// \n// SimpleServer is a Wrapper over  \n// http_listener class available with C++ REST SDK \nclass SimpleServer \n{ \npublic: \n\n   SimpleServer(utility::string_t url); \n   ~SimpleServer() {} \n   pplx::task<void> Open() { return m_listener.open(); } \n   pplx::task<void> Close() { return m_listener.close(); } \n\nprivate: \n   //--- Handlers for HTTP verbs \n   void HandleGet(http_request message); \n   void HandlePut(http_request message); \n   void HandlePost(http_request message); \n   void HandleDelete(http_request message); \n   //--------------- The  HTTP listener class \n   http_listener m_listener; \n};\n```", "```cpp\n////////////////////////////////// \n// The Constructor Binds HTTP verbs to instance methods \n// Based on the naming convention, we can infer what is happening \nSimpleServer::SimpleServer(utility::string_t url) : m_listener(url) \n{ \n   m_listener.support(methods::GET, std::bind(&SimpleServer::HandleGet, \n               this, std::placeholders::_1)); \n   m_listener.support(methods::PUT, std::bind(&SimpleServer::HandlePut, \n               this, std::placeholders::_1)); \n   m_listener.support(methods::POST, std::bind(&SimpleServer::HandlePost,  \n               this, std::placeholders::_1)); \n   m_listener.support(methods::DEL, std::bind(&SimpleServer::HandleDelete,  \n                this, std::placeholders::_1)); \n\n} \n```", "```cpp\n///////////////////////////////////// \n// For this implementation, what we do is  \n// spit the HTTP request details on the Server Console \n// and return 200 OK and a String which indicates  Success of Operations  \nvoid SimpleServer::HandleGet(http_request message){ \n   ucout << message.to_string() << endl; \n   message.reply(status_codes::OK,L\"GET Operation Succeeded\"); \n} \nvoid SimpleServer::HandlePost(http_request message){ \n   ucout << message.to_string() << endl; \n   message.reply(status_codes::OK, L\"POST Operation Succeeded\"); \n}; \n\nvoid SimpleServer::HandleDelete(http_request message){ \n   ucout << message.to_string() << endl; \n   message.reply(status_codes::OK, L\"DELETE Operation Succeeded\"); \n} \nvoid SimpleServer::HandlePut(http_request message){ \n   ucout << message.to_string() << endl; \n   message.reply(status_codes::OK, L\"PUT Operation Succeeded\"); \n}; \n```", "```cpp\n//////////////////////////////// \n// A Smart Pointer for Server Instance... \n// \nstd::unique_ptr<SimpleServer> g_http; \n////////////////////////////////////////////////// \n// STart the Server with the Given URL \n// \nvoid StartServer(const string_t& address) \n{ \n   // Build our listener's URI from the address given \n   // We just append DBDEMO/ to the base URL \n   uri_builder uri(address); \n   uri.append_path(U(\"DBDEMO/\")); \n   auto addr = uri.to_uri().to_string(); \n   ///////////////////////////////// \n   // Create an Instance of the Server and Invoke Wait to  \n   // start the Server... \n   g_http = std::unique_ptr<SimpleServer>(new SimpleServer(addr)); \n   g_http->Open().wait(); \n   //---- Indicate the start and spit URI to the Console \n   ucout << utility::string_t(U(\"Listening for requests at: \")) <<  \n                addr << std::endl; \n\n   return; \n} \n\n//////////////////////////////////////// \n// Simply Closes the Connection... Close returns  \n// pplx::task<void> ...we need to Call wait to invoke the  \n// operation... \nvoid ShutDown(){ \n   g_http->Close().wait(); \n   return; \n} \n/////////////////////////////// \n// EntryPoint function \nint wmain(int argc, wchar_t *argv[]) \n{ \n   utility::string_t port = U(\"34567\"); \n   if (argc == 2){ port = argv[1];} \n   //--- Create the Server URI base address \n   utility::string_t address = U(\"http://localhost:\"); \n   address.append(port); \n   StartServer(address); \n   std::cout << \"Press ENTER to exit.\" << std::endl; \n   //--- Wait Indefenintely, Untill some one has  \n   // pressed a key....and Shut the Server down \n   std::string line; \n   std::getline(std::cin, line); \n   ShutDown(); \n   return 0; \n} \n```", "```cpp\n    curl -X PUT http://localhost:34567/DBDEMO/ \n          -H \"Content-Type: application/json\" -d '{\"SimpleContent\":\"Value\"}'\n    curl -X GET \n          -H \"Content-Type: application/json\"      http://localhost:34567/DBDEMO/\n\n```", "```cpp\nPUT Operation Succeeded\nGET Operation Succeeded\n```", "```cpp\n/////////////////////////////////// \n// A Simple Program to demonstrate  \n// the usage of libcurl library \n// \n#include <stdio.h> \n#include <curl/curl.h> \n/////////////////////// \n// Entrypoint for the program \n//  \nint main(void) \n{ \n  CURL *curl; \n  CURLcode res; \n  /////////////////////////// \n  // Initialize the library \n  // \n  curl = curl_easy_init(); \n  if(curl) { \n    //----------- Set the URL  \n    curl_easy_setopt(curl, CURLOPT_URL,  \n                     \"http://example.com\"); \n    ////////////////////////////////////////// \n    // To support URL re-direction, we need to configure \n    // the lib curl library with CURLOPT_FOLLOWLOCATION \n    //  \n    curl_easy_setopt(curl,  \n               CURLOPT_FOLLOWLOCATION, 1L); \n\n    /////////////////////////////////////////////////// \n    // Now that, we have setup the options necessary, \n    // invoke the operation to pull data  \n    // \n    res = curl_easy_perform(curl); \n\n    if(res != CURLE_OK) { \n      //----- if error, print the error on console \n      cout << \"curl_easy_perform() failed: \" \n              << curl_easy_strerror(res) << endl; \n    } \n    curl_easy_cleanup(curl); \n  } \n  return 0; \n} \n```", "```cpp\n\n///////////////////////////////// \n// A Simple program to pull HTTP content  \n// using a Rx wrapper on top of the Libcurl \n// \n// \n#include <iostream> \n#include <stdio.h> \n#include <stdlib.h> \n#include <map> \n#include <chrono> \nusing namespace std; \nusing namespace std::chrono; \n//////////////////////// \n// include Curl Library and  \n// Rxcpp library  \n// \n#include <curl/curl.h> \n#include <rxcpp/rx.hpp> \nusing namespace rxcpp; \nusing namespace rxcpp::rxo; \nusing namespace rxcpp::rxs; \n////////////////////////// \n// include the modified rxcurl library from  \n// Kirk Shoop's Twitter Analysis app \n// \n#include \"rxcurl.h\" \nusing namespace rxcurl; \nint main() { \n     ///////////////////////////////////// \n     // \n     // Create a factory object to create  \n     // HTTP request.  The http_request structure \n     // is defined in rxcurl.h \n     string url = \"http://example.com\"; \n     auto factory = create_rxcurl(); \n     auto request  = factory.create(http_request{url, \"GET\",{}, {}}) | \n            rxo::map([](http_response r){ \n                return r.body.complete; \n            });\n```", "```cpp\n struct http_request{ \n       string url; \n       string method; \n       std::map<string, string> headers; \n       string body; \n     }; \n```", "```cpp\n\n     //////////////////////////////////////// \n     // make a blocking call to the url.. \n     observable<string>   response_message; \n     request.as_blocking().subscribe([&] (observable<string> s) { \n               response_message = s.sum(); \n     } ,[] () {}); \n```", "```cpp\n     /////////////////////////////// \n     // retrieve the html content form the site  \n     string html; \n     response_message.as_blocking().subscribe( [&html] ( string temp ) {          \n                   html = temp; \n     }, [&html] () { } ); \n     //------------ Print to the Console... \n     cout << html << endl; \n} \n```", "```cpp\n{ \n { \"name\":\"John\" }, \n { \"age\":35 }, \n { \n   \"spouse\":{ \"name\":\"Joanna\",  \n              \"age\":30,  \n              \"city\":\"New York\" } \n }, \n { \n    \"siblings\":[\"Bob\", \"Bill\", \"Peter\" ] \n }, \n { \"employed\":true } \n} \n```", "```cpp\n/////////////////////////////////// \n// A Console Application to demonstrate JSON API \n// available as part of the C++ SDK \nusing namespace std; \nusing namespace web; \nusing namespace utility; \nusing namespace http; \nusing namespace web::http::experimental::listener; \n/////////////////////////////////////// \n// Define a Simple struct to demonstrate the  \n// Working of JSON API \nstruct EMPLOYEE_INFO{ \n   utility::string_t name; \n   int age; \n   double salary; \n   ///////////////////////////////// \n   // Convert a JSON Object to a C++ Struct \n   // \n   static EMPLOYEE_INFO JSonToObject(const web::json::object & object){ \n         EMPLOYEE_INFO result; \n         result.name = object.at(U(\"name\")).as_string(); \n         result.age = object.at(U(\"age\")).as_integer(); \n         result.salary = object.at(U(\"salary\")).as_double(); \n         return result; \n   }\n```", "```cpp\n   /////////////////////////////////////////// \n   // Convert a C++ struct to a Json Value \n   // \n   web::json::value ObjectToJson() const{ \n         web::json::value result = web::json::value::object(); \n         result[U(\"name\")] = web::json::value::string(name); \n         result[U(\"age\")] = web::json::value::number(age); \n         result[U(\"salary\")] = web::json::value::number(salary); \n         return result; \n   } \n}; \n```", "```cpp\n///////////////////////////////////////// \n// Create a Json Object group and Embed and  \n// Array in it... \nvoid MakeAndShowJSONObject(){ \n   // Create a JSON object (the group) \n   json::value group; \n   group[L\"Title\"] = json::value::string(U(\"Native Developers\")); \n   group[L\"Subtitle\"] =  \n              json::value::string(U(\"C++ devekioers on Windws/GNU LINUX\")); \n   group[L\"Description\"] =  \n               json::value::string(U(\"A Short Description here \")); \n   // Create a JSON object (the item) \n   json::value item; \n   item[L\"Name\"] = json::value::string(U(\"Praseed Pai\")); \n   item[L\"Skill\"] = json::value::string(U(\"C++ / java \")); \n   // Create a JSON object (the item) \n   json::value item2; \n   item2[L\"Name\"] = json::value::string(U(\"Peter Abraham\")); \n   item2[L\"Skill\"] = json::value::string(U(\"C++ / C# \")); \n   // Create the items array \n   json::value items; \n   items[0] = item; \n   items[1] = item2; \n   // Assign the items array as the value for the Resources key \n   group[L\"Resources\"] = items; \n   // Write the current JSON value to wide char string stream \n   utility::stringstream_t stream; \n   group.serialize(stream); \n   // Display the string stream \n   std::wcout << stream.str(); \n} \n\nint wmain(int argc, wchar_t *argv[]) \n{ \n   EMPLOYEE_INFO dm; \n   dm.name = L\"Sabhir Bhatia\"; \n   dm.age = 50; \n   dm.salary = 10000; \n   wcout << dm.ObjectToJson().serialize() << endl; \n```", "```cpp\n      utility::string_t port =  \n           U(\"{\"Name\": \"Alex Stepanov\",\"Age\": 55,\"salary\":20000}\");; \n      web::json::value json_par; \n      json::value obj = json::value::parse(port); \n      wcout << obj.serialize() << endl; \n```", "```cpp\n   MakeAndShowJSONObject(); \n   getchar(); \n   return 0; \n} \n```", "```cpp\n// MicroServiceController.cpp : Defines the entry point for the console application. \n#include <cpprest/http_client.h> \n#include <cpprest/filestream.h> \n//------------- Omitted some standard C++ headers for terse code listing\n#include \"cpprest/json.h\" \n#include \"cpprest/http_listener.h\" \n#include \"cpprest/uri.h\" \n#include \"cpprest/asyncrt_utils.h\" \n\n#ifdef _WIN32 \n#ifndef NOMINMAX \n#define NOMINMAX \n#endif \n#include <Windows.h> \n#else \n# include <sys/time.h> \n#endif \n\nusing namespace std; \nusing namespace web; \nusing namespace utility; \nusing namespace http; \nusing namespace web::http::experimental::listener; \n\n////////////////////////////// \n// \n// The following code dumps a json to the Console... \nvoid  DisplayJSON(json::value const & jvalue){ \n   wcout << jvalue.serialize() << endl; \n} \n\n/////////////////////////////////////////////// \n// A Workhorse routine to perform an action on the request data type \n// takes a lambda as parameter along with request type \n// The Lambda should contain the action logic...whether it is \n// GET, PUT,POST or DELETE \n// \nvoid RequeatWorker( http_request& request, \nfunction<void(json::value const &, json::value &)> handler) { \n   auto result = json::value::object(); \n   request.extract_json().then([&result,\n        &handler](pplx::task<json::value> task)    {      \n        try{ \n            auto const & jvalue = task.get(); \n            if (!jvalue.is_null()) \n                  handler(jvalue, result); // invoke the lambda \n         } \n         catch (http_exception const & e) { \n               //----------- do exception processsing  \n               wcout << L\"Exception ->\" << e.what() << endl; \n         } \n   }).wait(); \n    request.reply(status_codes::OK, result); \n} \n```", "```cpp\n///////////////////////////////////////// \n// A Mock data base Engine which Simulates a key/value DB \n// In Real life, one should use an Industrial strength DB \n// \nclass HttpKeyValueDBEngine { \n   ////////////////////////////////// \n   //----------- Map , which we save,retrieve,  update and  \n   //----------- delete data  \n   map<utility::string_t, utility::string_t> storage; \npublic: \n   HttpKeyValueDBEngine() { \n         storage[L\"Praseed\"]= L\"45\"; \n         storage[L\"Peter\"] = L\"28\"; \n         storage[L\"Andrei\"] = L\"50\"; \n   } \n```", "```cpp\n   //////////////////////////////////////////////////////// \n   // GET - ?Just Iterates through the Map and Stores \n   // the data in a JSon Object. IT is emitted to the  \n   // Response Stream \n   void GET_HANDLER(http_request& request) { \n         auto resp_obj = json::value::object(); \n         for (auto const & p : storage) \n             resp_obj[p.first] = json::value::string(p.second); \n         request.reply(status_codes::OK, resp_obj); \n   } \n```", "```cpp\n   ////////////////////////////////////////////////// \n   // POST - Retrieves a Set of Values from the DB \n   // The PAyload should be in [\"Key1\" , \"Key2\"...,\"Keyn\"] \n   // format \n   void POST_HANDLER(http_request& request) {       \n       RequeatWorker(request, [&](json::value const & jvalue, \n                                          json::value & result){ \n         //---------- Write to the Console for Diagnostics \n         DisplayJSON(jvalue); \n             for (auto const & e : jvalue.as_array()){ \n               if (e.is_string()){ \n                     auto key = e.as_string(); \n                     auto pos = storage.find(key); \n                    if (pos == storage.end()){ \n                        //--- Indicate to the Client that Key is not found \n                         result[key] = json::value::string(L\"notfound\"); \n                     } \n                     else { \n                     //------------- store the key value pair in the result \n                     //------------- json. The result will be send back to  \n                     //------------- the client \n                     result[pos->first] = json::value::string(pos->second); \n                     } \n               } \n         } \n         });      \n   } \n```", "```cpp\n   //////////////////////////////////////////////////////// \n   // PUT - Updates Data, If new KEy is found  \n   //       Otherwise, Inserts it \n   // REST Payload should be in  \n   //      { Key1..Value1,...,Keyn,Valuen}  format \n   // \n   // \n   void PUT_HANDLER(http_request& request) { \n         RequeatWorker( request, \n               [&](json::value const & jvalue, json::value & result){ \n               DisplayJSON(jvalue); \n               for (auto const & e : jvalue.as_object()){ \n                     if (e.second.is_string()){ \n                           auto key = e.first; \n                           auto value = e.second.as_string(); \n                           if (storage.find(key) == storage.end())\n                           { \n                                 //--- Indicate to the client that we have \n                                 //--- created a new record \n                                 result[key] = \n                                   json::value::string(L\"<put>\"); \n                           } \n                           else { \n                                 //--- Indicate to the client that we have \n                                 //--- updated a new record \n                                 result[key] = \n                                    json::value::string(L\"<updated>\"); \n                           } \n                           storage[key] = value; \n                     } \n               } \n         });    \n   } \n```", "```cpp\n   /////////////////////////////////////////////////// \n   // DEL - Deletes a Set of Records \n   // REST PayLoad should be in \n   //      [ Key1,....,Keyn] format \n   // \n   void DEL_HANDLER(http_request& request) \n   { \n      RequeatWorker( request,\n         [&](json::value const & jvalue, json::value & result) \n         { \n               //--------------- We aggregate all keys into this set \n               //--------------- and delete in one go \n               set<utility::string_t> keys; \n               for (auto const & e : jvalue.as_array()){ \n                     if (e.is_string()){ \n                           auto key = e.as_string(); \n                           auto pos = storage.find(key); \n                           if (pos == storage.end()){ \n                                 result[key] = \n                                    json::value::string(L\"<failed>\"); \n                           } \n                           else { \n                                 result[key] = \n                                    json::value::string(L\"<deleted>\"); \n                                 //---------- Insert in to the delete list \n                                 keys.insert(key); \n                           } \n                     } \n               } \n               //---------------Erase all \n               for (auto const & key : keys) \n                     storage.erase(key); \n         }); \n   } \n};\n```", "```cpp\n/////////////////////////////////////////////// \n// \n// Instantiates the Global instance of key/value DB \nHttpKeyValueDBEngine g_dbengine; \n```", "```cpp\nclass RestDbServiceServer{ \npublic: \n   RestDbServiceServer(utility::string_t url); \n   pplx::task<void> Open() { return m_listener.open(); } \n   pplx::task<void> Close() { return m_listener.close(); } \nprivate: \n   void HandleGet(http_request message); \n   void HandlePut(http_request message); \n   void HandlePost(http_request message); \n   void HandleDelete(http_request message); \n   http_listener m_listener; \n}; \nRestDbServiceServer::RestDbServiceServer(utility::string_t url) : m_listener(url) \n{ \n    m_listener.support(methods::GET,  \n       std::bind(&RestDbServiceServer::HandleGet, this, std::placeholders::_1)); \n    m_listener.support(methods::PUT,  \n       std::bind(&RestDbServiceServer::HandlePut, this, std::placeholders::_1)); \n    m_listener.support(methods::POST,  \n       std::bind(&RestDbServiceServer::HandlePost, this, std::placeholders::_1)); \n    m_listener.support(methods::DEL,  \n        std::bind(&RestDbServiceServer::HandleDelete, \n        this,std::placeholders::_1)); \n}\n```", "```cpp\nvoid RestDbServiceServer::HandleGet(http_request message) \n{g_dbengine.GET_HANDLER(message);}; \nvoid RestDbServiceServer::HandlePost(http_request message) \n{g_dbengine.POST_HANDLER(message);}; \nvoid RestDbServiceServer::HandleDelete(http_request message) \n{g_dbengine.DEL_HANDLER(message);} \nvoid RestDbServiceServer::HandlePut(http_request message) \n{g_dbengine.PUT_HANDLER(message);}; \n//---------------- Create an instance of the Server  \nstd::unique_ptr<RestDbServiceServer> g_http; \nvoid StartServer(const string_t& address) \n{ \n   uri_builder uri(address); \n   uri.append_path(U(\"DBDEMO/\")); \n   auto addr = uri.to_uri().to_string(); \n   g_http = std::unique_ptr<RestDbServiceServer>(new RestDbServiceServer(addr)); \n   g_http->Open().wait(); \n   ucout << utility::string_t(U(\"Listening for requests at: \")) << \n               addr << std::endl; \n   return; \n} \nvoid ShutDown(){ \n      g_http->Close().wait(); \n      return; \n} \n/////////////////////////////// \n// The EntryPoint function \nint wmain(int argc, wchar_t *argv[]){ \n   utility::string_t port = U(\"34567\"); \n   if (argc == 2){port = argv[1];} \n   utility::string_t address = U(\"http://localhost:\"); \n   address.append(port); \n   StartServer(address); \n   std::cout << \"Press ENTER to exit.\" << std::endl; \n   std::string line; \n   std::getline(std::cin, line); \n   ShutDown(); \n   return 0; \n}\n```", "```cpp\n#include <iostream> \n#include <stdio.h> \n#include <iostream> \n#include <stdio.h> \n#include <stdlib.h> \n#include <map> \n#include <chrono> \nusing namespace std; \nusing namespace std::chrono; \n//////////////////////// \n// include Curl Library and  \n// Rxcpp library  \n// \n#include <curl/curl.h> \n#include <rxcpp/rx.hpp> \nusing namespace rxcpp; \nusing namespace rxcpp::rxo; \nusing namespace rxcpp::rxs; \n////////////////////////// \n// include the modified rxcurl library from  \n// Kirk Shoop's Twitter Analysis app \n// \n#include \"rxcurl.h\" \nusing namespace rxcurl; \nrxcurl::rxcurl factory; \n```", "```cpp\nstring HttpCall( string url ,  \n               string method, \n               std::map<string,string> headers, \n               string  body  ) {         \n\n     auto request  = factory.create(http_request{url,method,\n                     headers,body}) | \n                     rxo::map([](http_response r){ \n                          return r.body.complete; \n                     });      \n```", "```cpp\n     //////////////////////////////////////// \n     // make a blocking call to the url.. \n     observable<string>   response_message; \n     request.as_blocking().subscribe([&] (observable<string> s) { \n               response_message = s.sum(); \n     } ,[] () {printf(\"\");});\n```", "```cpp\n\n     /////////////////////////////// \n     // \n     // retrieve the html content form the site  \n     string html; \n     response_message.as_blocking().subscribe( [&html] ( string temp ) {          \n                   html = temp; \n     }, [] () { printf(\"\"); } ); \n     return html; \n} \n///////////////////////// \n// The EntryPoint... \n// \nint main() { \n\n     /////////////////////////////////// \n     // set the url and create the rxcurl object \n     string url = \"http://localhost:34567/DBDEMO/\"; \n     factory = create_rxcurl(); \n     ///////////////////////////////// \n     // default header values \n     std::map<string,string> headers; \n     headers[\"Content-Type\"] = \"application/json\"; \n     headers[\"Cache-Control\"] = \"no-cache\"; \n\n     //------- invoke GET to retrieve the contents \n     string html = HttpCall( url,\"GET\",headers, \"\" ); \n     cout << html << endl; \n\n     //------- Retrieve values for the following  \n     string body = string(\"[\"Praseed\"]rn\"); \n     html = HttpCall( url,\"POST\", headers,body); \n     cout << html << endl; \n     //--------- Add new Values using PUT \n     body = string(\"rn{\"Praveen\": \"29\",\"Rajesh\" :\"41\"}rn\"); \n     html = HttpCall( url,\"PUT\", headers,body); \n     cout << html << endl; \n     //-------- See whether values has been added \n     html = HttpCall( url,\"GET\",headers, \"\" ); \n     cout << \"-------------------------current database state\" << endl; \n     cout << html << endl; \n     //--------------- DELETE a particular record \n     body = string(\"[\"Praseed\"]rn\"); \n     html = HttpCall( url,\"DELETE\", headers,body); \n     cout << \"Delleted...\" << html << endl; \n     html = HttpCall( url,\"GET\",headers, \"\" ); \n     cout << \"-------------------------current database state\" << endl; \n     cout << html << endl; \n} \n```"]