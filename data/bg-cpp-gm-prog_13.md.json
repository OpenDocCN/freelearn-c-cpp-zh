["```cpp\nclass Soldier \n{ \n   private: \n      // How much damage can the soldier take \n      int m_Health; \n      int m_Armour; \n      int m_Range; \n      int m_ShotPower; \n\n   Public: \n      void setHealth(int h); \n      void setArmour(int a);   \n      void setRange(int r); \n      void setShotPower(int p); \n}; \n\n```", "```cpp\nclass Sniper : public Soldier \n{ \npublic: \n   // A constructor specific to Sniper \n   Sniper::Sniper(); \n}; \n\n```", "```cpp\n// In Sniper.cpp \nSniper::Sniper() \n{ \n   setHealth(10); \n   setArmour(10);  \n   setRange(1000); \n   setShotPower(100); \n} \n\n```", "```cpp\nvoid feed(Animal& a) \n{ \n   a.decreaseHunger(); \n} \n\n```", "```cpp\nClass Animal \n   private: \n      // Private stuff here \n\n   public: \n\n      void virtual makeNoise() = 0; \n\n      // More public stuff here \n}; \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n\nusing namespace sf; \n\nclass PlayableCharacter \n{ \nprotected: \n   // Of course we will need a sprite \n   Sprite m_Sprite; \n\n   // How long does a jump last \n   float m_JumpDuration; \n\n   // Is character currently jumping or falling \n   bool m_IsJumping; \n   bool m_IsFalling; \n\n   // Which directions is the character currently moving in \n   bool m_LeftPressed; \n   bool m_RightPressed; \n\n   // How long has this jump lasted so far \n   float m_TimeThisJump; \n\n   // Has the player just initialted a jump \n   bool m_JustJumped = false; \n\n   // Private variables and functions come next \n\n```", "```cpp\nprivate: \n   // What is the gravity \n   float m_Gravity; \n\n   // How fast is the character \n   float m_Speed = 400; \n\n   // Where is the player \n   Vector2f m_Position; \n\n   // Where are the characters various body parts? \n   FloatRect m_Feet; \n   FloatRect m_Head; \n   FloatRect m_Right; \n   FloatRect m_Left; \n\n   // And a texture \n   Texture m_Texture; \n\n   // All our public functions will come next \n\n```", "```cpp\npublic: \n\n   void spawn(Vector2f startPosition, float gravity); \n\n   // This is a pure virtual function \n   bool virtual handleInput() = 0; \n   // This class is now abstract and cannot be instanciated \n\n   // Where is the player \n   FloatRect getPosition(); \n\n   // A rectangle representing the position  \n   // of different parts of the sprite \n   FloatRect getFeet(); \n   FloatRect getHead(); \n   FloatRect getRight(); \n   FloatRect getLeft(); \n\n   // Send a copy of the sprite to main \n   Sprite getSprite(); \n\n   // Make the character stand firm \n   void stopFalling(float position); \n   void stopRight(float position); \n   void stopLeft(float position); \n   void stopJump(); \n\n   // Where is the center of the character \n   Vector2f getCenter(); \n\n   // We will call this function once every frame \n   void update(float elapsedTime); \n\n};// End of the class \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"PlayableCharacter.h\" \n\nvoid PlayableCharacter::spawn(Vector2f startPosition, float gravity) \n{ \n   // Place the player at the starting point \n   m_Position.x = startPosition.x; \n   m_Position.y = startPosition.y; \n\n   // Initialize the gravity \n   m_Gravity = gravity; \n\n   // Move the sprite in to position \n   m_Sprite.setPosition(m_Position); \n\n} \n\n```", "```cpp\nvoid PlayableCharacter::update(float elapsedTime) \n{ \n\n   if (m_RightPressed) \n   { \n      m_Position.x += m_Speed * elapsedTime; \n   } \n\n   if (m_LeftPressed) \n   { \n      m_Position.x -= m_Speed * elapsedTime; \n   } \n\n   // Handle Jumping \n   if (m_IsJumping) \n   { \n      // Update how long the jump has been going \n      m_TimeThisJump += elapsedTime; \n\n      // Is the jump going upwards \n      if (m_TimeThisJump < m_JumpDuration) \n      { \n         // Move up at twice gravity \n         m_Position.y -= m_Gravity * 2 * elapsedTime; \n      } \n      else \n      { \n         m_IsJumping = false; \n         m_IsFalling = true; \n      } \n\n   } \n\n   // Apply gravity \n   if (m_IsFalling) \n   { \n      m_Position.y += m_Gravity * elapsedTime; \n   } \n\n   // Update the rect for all body parts \n   FloatRect r = getPosition(); \n\n   // Feet \n   m_Feet.left = r.left + 3; \n   m_Feet.top = r.top + r.height - 1; \n   m_Feet.width = r.width - 6; \n   m_Feet.height = 1; \n\n   // Head \n   m_Head.left = r.left; \n   m_Head.top = r.top + (r.height * .3); \n   m_Head.width = r.width; \n   m_Head.height = 1; \n\n   // Right \n   m_Right.left = r.left + r.width - 2; \n   m_Right.top = r.top + r.height * .35; \n   m_Right.width = 1; \n   m_Right.height = r.height * .3; \n\n   // Left \n   m_Left.left = r.left; \n   m_Left.top = r.top + r.height * .5; \n   m_Left.width = 1; \n   m_Left.height = r.height * .3; \n\n   // Move the sprite into position \n   m_Sprite.setPosition(m_Position); \n\n} \n\n```", "```cpp\nFloatRect PlayableCharacter::getPosition() \n{ \n   return m_Sprite.getGlobalBounds(); \n} \n\nVector2f PlayableCharacter::getCenter() \n{ \n   return Vector2f( \n      m_Position.x + m_Sprite.getGlobalBounds().width / 2, \n      m_Position.y + m_Sprite.getGlobalBounds().height / 2 \n      ); \n} \n\nFloatRect PlayableCharacter::getFeet() \n{ \n   return m_Feet; \n} \n\nFloatRect PlayableCharacter::getHead() \n{ \n   return m_Head; \n} \n\nFloatRect PlayableCharacter::getLeft() \n{ \n   return m_Left; \n} \n\nFloatRect PlayableCharacter::getRight() \n{ \n   return m_Right; \n} \n\nSprite PlayableCharacter::getSprite() \n{ \n   return m_Sprite; \n} \n\n```", "```cpp\nvoid PlayableCharacter::stopFalling(float position) \n{ \n   m_Position.y = position - getPosition().height; \n   m_Sprite.setPosition(m_Position); \n   m_IsFalling = false; \n} \n\nvoid PlayableCharacter::stopRight(float position) \n{ \n\n   m_Position.x = position - m_Sprite.getGlobalBounds().width; \n   m_Sprite.setPosition(m_Position); \n} \n\nvoid PlayableCharacter::stopLeft(float position) \n{ \n   m_Position.x = position + m_Sprite.getGlobalBounds().width; \n   m_Sprite.setPosition(m_Position); \n} \n\nvoid PlayableCharacter::stopJump() \n{ \n   // Stop a jump early  \n   m_IsJumping = false; \n   m_IsFalling = true; \n} \n\n```", "```cpp\n#pragma once \n#include \"PlayableCharacter.h\" \n\nclass Thomas : public PlayableCharacter \n{ \npublic: \n   // A constructor specific to Thomas \n   Thomas::Thomas(); \n\n   // The overridden input handler for Thomas \n   bool virtual handleInput(); \n\n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Thomas.h\" \n#include \"TextureHolder.h\" \n\nThomas::Thomas() \n{ \n   // Associate a texture with the sprite \n   m_Sprite = Sprite(TextureHolder::GetTexture( \n      \"graphics/thomas.png\")); \n\n   m_JumpDuration = .45; \n} \n\n```", "```cpp\n\n// A virtual function \nbool Thomas::handleInput() \n{ \n   m_JustJumped = false; \n\n   if (Keyboard::isKeyPressed(Keyboard::W)) \n   { \n\n      // Start a jump if not already jumping \n      // but only if standing on a block (not falling) \n      if (!m_IsJumping && !m_IsFalling) \n      { \n         m_IsJumping = true; \n         m_TimeThisJump = 0; \n         m_JustJumped = true; \n      } \n   } \n   else \n   { \n      m_IsJumping = false; \n      m_IsFalling = true; \n\n   } \n   if (Keyboard::isKeyPressed(Keyboard::A)) \n   { \n      m_LeftPressed = true; \n   } \n   else \n   { \n      m_LeftPressed = false; \n   } \n\n   if (Keyboard::isKeyPressed(Keyboard::D)) \n   { \n      m_RightPressed = true; \n   } \n   else \n   { \n      m_RightPressed = false; \n   } \n\n   return m_JustJumped; \n} \n\n```", "```cpp\n#pragma once \n#include \"PlayableCharacter.h\" \n\nclass Bob : public PlayableCharacter \n{ \npublic: \n   // A constructor specific to Bob \n   Bob::Bob(); \n\n   // The overriden input handler for Bob \n   bool virtual handleInput(); \n\n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Bob.h\" \n#include \"TextureHolder.h\" \n\nBob::Bob() \n{ \n   // Associate a texture with the sprite \n   m_Sprite = Sprite(TextureHolder::GetTexture( \n      \"graphics/bob.png\")); \n\n   m_JumpDuration = .25; \n} \n\n```", "```cpp\nbool Bob::handleInput() \n{ \n   m_JustJumped = false; \n\n   if (Keyboard::isKeyPressed(Keyboard::Up)) \n   { \n\n      // Start a jump if not already jumping \n      // but only if standing on a block (not falling) \n      if (!m_IsJumping && !m_IsFalling) \n      { \n         m_IsJumping = true; \n         m_TimeThisJump = 0; \n         m_JustJumped = true; \n      } \n\n   } \n   else \n   { \n      m_IsJumping = false; \n      m_IsFalling = true; \n\n   } \n   if (Keyboard::isKeyPressed(Keyboard::Left)) \n   { \n      m_LeftPressed = true; \n\n   } \n   else \n   { \n      m_LeftPressed = false; \n   } \n\n   if (Keyboard::isKeyPressed(Keyboard::Right)) \n   { \n\n      m_RightPressed = true;; \n\n   } \n   else \n   { \n      m_RightPressed = false; \n   } \n\n   return m_JustJumped; \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n#include \"TextureHolder.h\" \n#include \"Thomas.h\"\n#include \"Bob.h\" \n\nusing namespace sf; \n\nclass Engine \n{ \nprivate: \n   // The texture holder \n   TextureHolder th; \n\n // Thomas and his friend, Bob\n   Thomas m_Thomas;\n   Bob m_Bob; \n\n   const int TILE_SIZE = 50; \n   const int VERTS_IN_QUAD = 4; \n   ... \n   ... \n\n```", "```cpp\nvoid Engine::input() \n{ \n   Event event; \n   while (m_Window.pollEvent(event)) \n   { \n      if (event.type == Event::KeyPressed) \n      { \n         // Handle the player quitting \n         if (Keyboard::isKeyPressed(Keyboard::Escape)) \n         { \n            m_Window.close(); \n         } \n\n         // Handle the player starting the game \n         if (Keyboard::isKeyPressed(Keyboard::Return)) \n         { \n            m_Playing = true; \n         } \n\n         // Switch between Thomas and Bob \n         if (Keyboard::isKeyPressed(Keyboard::Q)) \n         { \n            m_Character1 = !m_Character1; \n         } \n\n         // Switch between full and split-screen \n         if (Keyboard::isKeyPressed(Keyboard::E)) \n         { \n            m_SplitScreen = !m_SplitScreen; \n         } \n      } \n   } \n\n // Handle input specific to Thomas\n   if(m_Thomas.handleInput())\n   {\n     // Play a jump sound\n   }\n\n   // Handle input specific to Bob\n   if(m_Bob.handleInput())\n   {\n     // Play a jump sound\n   } \n} \n\n```", "```cpp\nvoid Engine::update(float dtAsSeconds) \n{ \n if (m_NewLevelRequired)\n   {\n     // These calls to spawn will be moved to a new\n     // loadLevel() function soon\n     // Spawn Thomas and Bob\n     m_Thomas.spawn(Vector2f(0,0), GRAVITY);\n     m_Bob.spawn(Vector2f(100, 0), GRAVITY); \n\n     // Make sure spawn is called only once\n     m_TimeRemaining = 10;\n     m_NewLevelRequired = false;\n   } \n\n   if (m_Playing) \n   { \n      // Count down the time the player has left \n      m_TimeRemaining -= dtAsSeconds; \n\n      // Have Thomas and Bob run out of time? \n      if (m_TimeRemaining <= 0) \n      { \n         m_NewLevelRequired = true; \n      } \n\n   }// End if playing \n\n} \n\n```", "```cpp\nvoid Engine::update(float dtAsSeconds) \n{ \n   if (m_NewLevelRequired) \n   { \n      // These calls to spawn will be moved to a new \n      // LoadLevel function soon \n      // Spawn Thomas and Bob \n      m_Thomas.spawn(Vector2f(0,0), GRAVITY); \n      m_Bob.spawn(Vector2f(100, 0), GRAVITY); \n\n      // Make sure spawn is called only once \n      m_NewLevelRequired = false; \n   } \n\n   if (m_Playing) \n   { \n // Update Thomas\n      m_Thomas.update(dtAsSeconds);\n\n      // Update Bob\n      m_Bob.update(dtAsSeconds); \n\n      // Count down the time the player has left \n      m_TimeRemaining -= dtAsSeconds; \n\n      // Have Thomas and Bob run out of time? \n      if (m_TimeRemaining <= 0) \n      { \n         m_NewLevelRequired = true; \n      } \n\n   }// End if playing \n\n} \n\n```", "```cpp\nvoid Engine::update(float dtAsSeconds) \n{ \n   if (m_NewLevelRequired) \n   { \n      // These calls to spawn will be moved to a new \n      // LoadLevel function soon \n      // Spawn Thomas and Bob \n      m_Thomas.spawn(Vector2f(0,0), GRAVITY); \n      m_Bob.spawn(Vector2f(100, 0), GRAVITY); \n\n      // Make sure spawn is called only once \n      m_NewLevelRequired = false; \n   } \n\n   if (m_Playing) \n   { \n      // Update Thomas \n      m_Thomas.update(dtAsSeconds); \n\n      // Update Bob \n      m_Bob.update(dtAsSeconds); \n\n      // Count down the time the player has left \n      m_TimeRemaining -= dtAsSeconds; \n\n      // Have Thomas and Bob run out of time? \n      if (m_TimeRemaining <= 0) \n      { \n         m_NewLevelRequired = true; \n      } \n\n   }// End if playing \n\n // Set the appropriate view around the appropriate character\n   if (m_SplitScreen)\n   {\n     m_LeftView.setCenter(m_Thomas.getCenter());\n     m_RightView.setCenter(m_Bob.getCenter());\n   }\n   else\n   {\n     // Centre full screen around appropriate character\n     if (m_Character1)\n     {\n        m_MainView.setCenter(m_Thomas.getCenter());\n     }\n     else\n     {\n        m_MainView.setCenter(m_Bob.getCenter());\n     }\n   } \n} \n\n```", "```cpp\nvoid Engine::draw() \n{ \n   // Rub out the last frame \n   m_Window.clear(Color::White); \n\n   if (!m_SplitScreen) \n   { \n      // Switch to background view \n      m_Window.setView(m_BGMainView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_MainView \n      m_Window.setView(m_MainView);     \n\n // Draw thomas\n     m_Window.draw(m_Thomas.getSprite());\n\n     // Draw bob\n     m_Window.draw(m_Bob.getSprite()); \n   } \n   else \n   { \n      // Split-screen view is active \n\n      // First draw Thomas' side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGLeftView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_LeftView \n      m_Window.setView(m_LeftView); \n\n // Draw bob\n     m_Window.draw(m_Bob.getSprite());\n\n     // Draw thomas\n     m_Window.draw(m_Thomas.getSprite()); \n\n      // Now draw Bob's side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGRightView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_RightView \n      m_Window.setView(m_RightView); \n\n // Draw thomas\n     m_Window.draw(m_Thomas.getSprite());\n\n     // Draw bob\n     m_Window.draw(m_Bob.getSprite()); \n\n   } \n\n   // Draw the HUD \n   // Switch to m_HudView \n   m_Window.setView(m_HudView); \n\n   // Show everything we have just drawn \n   m_Window.display(); \n} \n\n```", "```cpp\nm_Bob.spawn(Vector2f(0,0), 0); \n\n```"]