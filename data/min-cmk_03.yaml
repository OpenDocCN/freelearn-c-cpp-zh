- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Hello, CMake!
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello, CMake!
- en: We’re now going to start using CMake. We’ll first introduce the commands we
    run frequently from the terminal and then those we write in our CMake scripts.
    We’ll do this by starting with a *Hello, CMake!* application (a throwback to everyone’s
    favorite *Hello, World!* program) bootstrapped with a minimal CMake script, examining
    each CMake command we use in depth. These commands will soon become second nature
    and make building your code effortless.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始使用 CMake。首先，我们将介绍在终端中频繁使用的命令，然后是我们在 CMake 脚本中编写的命令。我们将通过启动一个*Hello, CMake!*
    应用程序（回顾每个人最喜欢的 *Hello, World!* 程序），并用一个最小的 CMake 脚本进行引导，深入探讨我们使用的每个 CMake 命令。很快，这些命令将成为你的第二天性，让你轻松构建代码。
- en: CMake has a rich feature set, but luckily there’s a pretty small amount to learn
    to start becoming productive. There are lots of options to handle complex use
    cases; most of which we fortunately don’t need to worry about for the moment.
    It’s good to know they’re there, but don’t feel you need to learn all there is
    to know about the commands or CMake language at the outset. There’s plenty of
    time for that as your project matures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 拥有丰富的功能集，但幸运的是，开始时只需要学习很少的内容就能提高生产力。它有很多选项可以处理复杂的使用场景；不过幸运的是，暂时我们不需要担心这些。知道它们在那儿就好，但不要觉得一开始就需要了解所有有关命令或
    CMake 语言的知识。随着项目的推进，你将有足够的时间去学习这些。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using CMake from the command line
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行使用 CMake
- en: Examining our first `CMakeLists.txt` file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们的第一个 `CMakeLists.txt` 文件
- en: CMake generators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 生成器
- en: Project next steps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目下一步
- en: Adding another file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加另一个文件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along, please ensure you have met the requirements outlined in [*Chapter
    1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*. These include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上进度，请确保你已满足[*第 1 章*](B21152_01.xhtml#_idTextAnchor019)《入门》的要求。包括以下内容：
- en: A Windows, Mac, or Linux machine with an up-to-date **operating** **system**
    (**OS**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有最新 **操作系统** (**OS**) 的 Windows、Mac 或 Linux 机器
- en: A working C/C++ compiler (a system default is recommended for each platform
    if you don’t already have this)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作中的 C/C++ 编译器（如果你还没有，建议使用每个平台的系统默认编译器）
- en: 'The code examples in this chapter can be found by following this link: [https://github.com/PacktPublishing/Minimal-](https://github.com/PacktPublishing/Minimal-CMake)CMake.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以通过以下链接找到：[https://github.com/PacktPublishing/Minimal-](https://github.com/PacktPublishing/Minimal-CMake)CMake。
- en: Using CMake from the command line
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行使用 CMake
- en: Before delving into the contents of our first CMake script, let’s clone the
    repository holding the code examples from the book. This can be performed by opening
    a terminal session and running the following commands.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解第一个 CMake 脚本的内容之前，先克隆书中代码示例的仓库。可以通过打开终端并运行以下命令来执行此操作。
- en: Linux/macOS
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux/macOS
- en: 'Run these commands if you’re working on Linux/macOS:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Linux/macOS 上工作，请运行以下命令：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’re now set up to explore the book repository on macOS or Linux.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好在 macOS 或 Linux 上探索书中的代码仓库。
- en: Windows
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: 'Run these commands is you’re working on Windows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Windows 上工作，请运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’re now set up to explore the book repository on Windows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好在 Windows 上探索书中的代码仓库。
- en: Exploring the repository
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索仓库
- en: 'With the repository cloned, navigate to the first code example of [*Chapter
    2*](B21152_02.xhtml#_idTextAnchor032):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆仓库后，导航到[*第 2 章*](B21152_02.xhtml#_idTextAnchor032)的第一个代码示例：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From here, type `ls` (if you’re on Windows and not using Git Bash or equivalent,
    substitute `ls` with `dir`). The contents of the folder displayed are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，输入 `ls`（如果你在 Windows 上且没有使用 Git Bash 或类似工具，请将 `ls` 替换为 `dir`）。显示的文件夹内容如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `CMakeLists.txt` file shows we’re at the root of the CMake project. All
    CMake projects have this file at their root, and it’s from here that we can ask
    CMake to generate build files for our platform.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt` 文件显示我们处于 CMake 项目的根目录。所有 CMake 项目在其根目录都有这个文件，正是从这里我们可以要求 CMake
    为我们的平台生成构建文件。'
- en: Invoking CMake
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用 CMake
- en: 'Let’s run our first CMake command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行第一个 CMake 命令：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is one of the most important CMake commands you’ll come to know and love.
    It is often the first command you’ll run after cloning a repository that’s using
    CMake. When running this command, you should see output resembling the following
    (macOS output shown below):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将会学会并喜爱的最重要的 CMake 命令之一。它通常是在克隆一个使用 CMake 的仓库后你第一个运行的命令。运行这个命令时，你应该看到类似以下的输出（下面是
    macOS 输出）：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s briefly dissect the command we used (`cmake -B build`). The first part
    of the command (`cmake`) is the CMake executable. If we call this with no arguments,
    CMake doesn’t have enough information to know what we’d like to do; we’ll just
    see usage instructions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要分析一下我们使用的命令（`cmake -B build`）。命令的第一部分（`cmake`）是 CMake 可执行文件。如果我们在没有任何参数的情况下调用它，CMake
    无法获取足够的信息来知道我们想要做什么；我们只会看到用法说明：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our case, we want CMake to produce build files for our target platform. To
    achieve this, we use the `-B` option to specify a folder to hold the build files.
    The name and location of the folder are arbitrary (we could just as easily have
    written `cmake -B my-built-files` or `cmake -B ../../build-output`), but `build`
    (located at the root of the project) is an often-used convention.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们希望 CMake 为我们的目标平台生成构建文件。为此，我们使用 `-B` 选项来指定一个文件夹来存放构建文件。该文件夹的名称和位置是任意的（我们可以写
    `cmake -B my-built-files` 或 `cmake -B ../../build-output`），但通常会使用位于项目根目录下的 `build`
    文件夹作为约定。
- en: As we don’t want to commit these files to source control, it’s common to add
    some variation of `build` to our `.gitignore` file so we don’t accidentally start
    tracking these files (some projects choose to use `bin` instead; however, this
    tends to be less common). This approach is a variation of what is known as an
    `cmake .` from your source folder). Doing this increases the risk of build files
    being accidentally added to source control and makes managing different build
    types cumbersome.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想将这些文件提交到源代码控制中，通常会在 `.gitignore` 文件中添加某种形式的 `build`，这样我们就不会不小心开始跟踪这些文件（有些项目选择使用
    `bin` 代替；不过，这种做法相对较少见）。这种做法是从源代码文件夹中使用 `cmake .` 的变体。如果这样做，增加了构建文件被意外添加到源代码控制中的风险，并且使得管理不同的构建类型变得繁琐。
- en: Explicitly specify the source directory
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 显式指定源目录
- en: If CMake is not invoked from the same folder as the `CMakeLists.txt` file, it’s
    possible to supply a separate command-line argument, `-S`, and a path to where
    that file lives (this can be particularly useful when invoking CMake from a build
    automation script such as GitHub Actions without having to change directory).
    You can make this explicit when in the same folder by using `cmake -S . -B build`,
    but it’s technically redundant and omitting it is perfectly fine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CMake 不是从与 `CMakeLists.txt` 文件相同的文件夹中调用的，可以提供一个单独的命令行参数 `-S`，并指定该文件所在的路径（当从构建自动化脚本如
    GitHub Actions 调用 CMake 时，这一点尤其有用，这样就不需要切换目录）。如果在相同的文件夹中，您可以通过使用 `cmake -S . -B
    build` 来显式指定，但这在技术上是多余的，省略它是完全可以的。
- en: Both a good and bad thing about CMake is that it’s made quite a lot of guesses
    and assumptions on our behalf behind the scenes that are not obvious without closer
    inspection. Later in the chapter, we’ll cover the more important options, but
    suffice it to say CMake has chosen some sensible defaults, which we might want
    to adjust later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 的一大优点和一大缺点是，它在幕后为我们做出了很多猜测和假设，这些假设在没有仔细检查的情况下并不显而易见。稍后在本章中，我们将介绍更重要的选项，但可以简单地说，CMake
    选择了一些合理的默认设置，我们可能需要稍后进行调整。
- en: Building with CMake
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CMake 构建
- en: 'We have now generated some build files (the details of which aren’t important),
    but we haven’t built anything yet. As far as we need to understand right now,
    using CMake is a two-step process (the first step *technically* can be decomposed
    into two further steps, called *configure* and *generate*, but both happen when
    you run `cmake -B build`, so we can treat them as one for now). The build step
    requires a new command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经生成了一些构建文件（具体细节不重要），但还没有进行构建。就我们当前需要理解的部分，使用 CMake 是一个两步过程（第一步*严格来说*可以分解为两个进一步的步骤，称为*配置*和*生成*，但这两个步骤都会在运行
    `cmake -B build` 时完成，所以我们现在可以将它们视为一个步骤）。构建步骤需要一个新命令：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding command handles invoking the underlying build system created by
    CMake in the first step. We use `--build` as the command, and `build` is just
    the folder we specified in the earlier command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令处理了在第一步中由 CMake 调用的底层构建系统。我们使用 `--build` 作为命令，而 `build` 只是我们在先前命令中指定的文件夹。
- en: A build system can be thought of as a piece of software that orchestrates several
    lower-level applications (such as a compiler and linker) to produce an output
    of some kind on the target platform (usually an application or a library). In
    the case of macOS and Linux, the default underlying build system will be Make.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统可以被看作是一种软件，它协调多个低级应用程序（例如编译器和链接器）在目标平台上生成某种输出（通常是应用程序或库）。在 macOS 和 Linux
    的情况下，默认的底层构建系统将是 Make。
- en: '`CMakeLists.txt`) and map it to Make commands (as well as a host of other build
    systems we’ll soon learn about).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`）并将其映射到 Make 命令（以及我们即将学习的其他许多构建系统）。'
- en: Invoking build systems directly
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用构建系统
- en: If you know the underlying build system is Make, you could, if you wanted, run
    `make -C build`, which will have the same effect as `cmake --build build`. Unfortunately,
    this isn’t portable (it would not work nicely if we had a build script that chose
    a different build system on another platform). Sticking to CMake commands keeps
    a consistent level of abstraction and doesn’t risk coupling us to a specific build
    system in the future.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道底层的构建系统是 Make，你可以选择运行 `make -C build`，它的效果与 `cmake --build build` 相同。不幸的是，这并不具有可移植性（如果我们有一个构建脚本，在其他平台上选择了不同的构建系统，它将无法很好地工作）。坚持使用
    CMake 命令可以保持一致的抽象层次，避免将来与特定的构建系统耦合。
- en: The situation on Windows is a little different and worth covering now. `cmake
    -B build` and `cmake --build build` will still generate build files for us, and
    build our code, but the underlying build system is going to be different. On Windows,
    the likelihood (especially if you followed the steps described in [*Chapter 1*](B21152_01.xhtml#_idTextAnchor019),
    *Getting Started*) is Visual Studio/MSBuild project files will have been generated
    and then built.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 上的情况略有不同，现在值得讨论。`cmake -B build` 和 `cmake --build build` 仍然会为我们生成构建文件并构建我们的代码，但底层的构建系统会有所不同。在
    Windows 上，尤其是如果你按照 [*第一章*](B21152_01.xhtml#_idTextAnchor019) 中的步骤，*入门*，生成的可能是
    Visual Studio/MSBuild 项目文件，并且这些文件随后会被构建。
- en: An obstacle when switching between Windows and macOS/Linux is that the two separate
    build systems(Make and Visual Studio) have slightly different behavior (this is
    an unfortunate coincidence). Make is referred to as what is called **single-config**,
    while Visual Studio is **multi-config**. We haven’t yet touched on what configs
    are, but let’s see what the observable differences are to start.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 和 macOS/Linux 之间切换时的一个障碍是这两个独立的构建系统（Make 和 Visual Studio）具有稍微不同的行为（这是一种不幸的巧合）。Make
    被称为**单配置**，而 Visual Studio 是**多配置**。我们尚未涉及配置的概念，但让我们先看看它们之间的可观察差异。
- en: 'On macOS or Linux, after running the two CMake commands (configure and build),
    we can launch our executable by running the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 或 Linux 上，运行了两个 CMake 命令（配置和构建）后，我们可以通过运行以下命令启动我们的可执行文件：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The reward is a variation on the standard *Hello,* *World!* program:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励是标准的 *Hello,* *World!* 程序的变体：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As alluded to previously, this unfortunately won’t work on Windows. Instead,
    we must specify the configuration directory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，不幸的是，这在 Windows 上无法正常工作。相反，我们必须指定配置目录：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this small modification, we’ll see `Hello, CMake!` printed on Windows.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小的修改，我们将在 Windows 上看到 `Hello, CMake!` 被打印出来。
- en: We will cover configurations and the difference between single-config and multi-config
    in more detail later in the chapter, but for now, we know they exist and what
    the main differences are.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更详细地讨论配置以及单配置和多配置之间的差异，但现在，我们知道它们的存在及其主要差异。
- en: One other useful tip is once you’ve run the configure command (`cmake -B build`),
    you don’t have to run it again, even when making changes to your `CMakeLists.txt`
    file. Simply running `cmake --build build` will cause CMake to check whether there
    are any changes and run the configure step again automatically. This saves having
    to repeatedly run two commands every time a change is made.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的提示是，一旦你运行了配置命令（`cmake -B build`），即使修改了 `CMakeLists.txt` 文件，也不必再次运行它。只需运行
    `cmake --build build`，CMake 会检查是否有任何更改，并自动重新运行配置步骤。这避免了每次更改时反复运行两个命令。
- en: Examining our first CMakeLists.txt file
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的第一个 CMakeLists.txt 文件
- en: 'Now that we’ve used CMake to build our project, let’s take a look at the commands
    present in the `CMakeLists.txt` file at the root of the project:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经使用 CMake 构建了我们的项目，让我们看看位于项目根目录下的 `CMakeLists.txt` 文件中的命令：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code is about the minimum you can get away with when crafting
    a CMake project. There are a few more optional parameters available for `project`
    that we’ll cover later, and we might be able to get away with not specifying the
    specific language version with `target_compile_features` (the downside to this
    is we’re then dependent on whatever the compiler defaults on our platform are,
    which might not always be what we want. This also risks making our `CMakeLists.txt`
    file less portable as we could end up with a different default on another platform/compiler).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码是制作 CMake 项目时可以采用的最低配置。`project` 还有一些其他可选参数，我们稍后会讲到，我们或许能够在不指定 `target_compile_features`
    的语言版本的情况下进行设置（这样做的弊端是我们就会依赖平台上编译器的默认设置，而这些设置可能并非我们想要的。这也有可能使我们的 `CMakeLists.txt`
    文件在跨平台时变得不太便携，因为不同平台或编译器的默认设置可能不同）。
- en: UPPERCASE or lowercase commands
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大写或小写命令
- en: Out in the wild it is not uncommon to see CMake commands written in all uppercase
    (e.g. `ADD_EXECUTABLE` instead of `add_executable`). In early versions of CMake,
    uppercase commands were required, but today CMake commands are actually case insensitive
    (`aDD_eXecuTAble` would technically work, but is not something to emulate). The
    more modern approach prefers using lowercase commands which is the style used
    throughout this book. It’s worth briefly mentioning that CMake variables (as opposed
    to commands) are case-sensitive, and by convention are usually uppercase.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际使用中，看到 CMake 命令全大写（例如 `ADD_EXECUTABLE` 而不是 `add_executable`）并不罕见。在 CMake
    的早期版本中，命令必须使用大写字母，但今天 CMake 命令实际上是大小写不敏感的（`aDD_eXecuTAble` 技术上可以工作，但不推荐模仿）。现代的做法倾向于使用小写命令，这是本书中贯穿使用的风格。值得简要提到的是，CMake
    变量（与命令不同）是区分大小写的，并且通常按照惯例使用大写字母。
- en: Let’s walk through each statement one by one to understand what it does and
    why it’s needed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析每一行语句，了解它的作用以及为什么需要它。
- en: Setting a minimum version
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置最低版本
- en: 'Let’s first look at how to set the minimum (or oldest) version of CMake that
    can be used with our project:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们来看一下如何设置可以与我们项目一起使用的最低（或最旧）版本的 CMake：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Every `CMakeLists.txt` file must start with the preceding line to indicate
    to CMake when it runs, what the minimum version of CMake needed is to execute
    the file. The later the version, the more features will be available (as well
    as warnings about things that may have been deprecated or removed from earlier
    versions of CMake). There’s a balance to be struck between specifying a high version,
    which will have all the latest features, and a slightly older version that more
    people will likely be using (will have installed on their system). For example,
    if someone with an older version of CMake attempts to generate our project, they’ll
    see this error message when attempting to configure:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `CMakeLists.txt` 文件必须以前述语句开始，以告诉 CMake 在运行时，执行文件所需的最低 CMake 版本号是什么。版本越高，可用的功能就越多（同时也会有警告，提示可能已经被弃用或从旧版本中删除的内容）。在指定较高版本（拥有所有最新功能）和略旧版本（更多人可能使用的版本）的之间，需要取得平衡。例如，如果某个使用旧版本
    CMake 的人尝试生成我们的项目，当他们尝试配置时，会看到以下错误消息：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you’re working on an application that you or a small team will be building,
    specifying the latest and greatest (no earlier than the version you have installed,
    in our case `3.28`) is fine, and a good idea. If, on the other hand, you’re creating
    a library that you’d like to make easy for other projects to adopt, going for
    something a bit older will likely make usage easier (if you’re able to forgo some
    of the newer features). For example, in our case, we could easily drop the required
    version number to `3.5` and have things work just fine (even though we’re actually
    running `3.28`). If, however, we drop the version number to `2.8`, we’ll see this
    warning:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个你自己或一个小团队将要构建的应用程序，指定最新的版本（至少是你已经安装的版本，在我们的例子中是 `3.28`）是可以的，也是个好主意。另一方面，如果你正在创建一个希望其他项目轻松采用的库，选择一个稍微旧一点的版本可能会更容易使用（如果你能够放弃一些新功能的话）。例如，在我们的例子中，我们可以轻松将所需版本号降至
    `3.5`，而一切仍然能够正常工作（即使我们实际使用的是 `3.28`）。然而，如果我们将版本号降至 `2.8`，就会看到这个警告：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It’s important to gradually bump up the version number over time to keep `CMakeLists.txt`
    files compatible with the latest changes and improvements to CMake. One such example
    was a change made between CMake `3.19` and `3.20`. Up until CMake `3.20`, when
    listing files in `target_sources`, it was possible to omit the file extension
    of a referenced file. So, we’d use the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，逐渐增加版本号是很重要的，这样可以保持 `CMakeLists.txt` 文件与 CMake 最新的更改和改进兼容。一个例子是 CMake
    `3.19` 和 `3.20` 之间的变化。在 CMake `3.20` 之前，在列出 `target_sources` 中的文件时，可以省略引用文件的扩展名。所以我们会使用如下代码：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the same as the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下代码是相同的：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If CMake couldn’t find a perfect match, it would attempt to append a list of
    potential extensions to see whether one would fit. This behavior was error-prone
    and could lead to potential bugs, so it was fixed. If you attempt to configure
    a project with a version of CMake greater than or equal to `3.20` when the required
    version is `3.19` or less, you’ll see the following warning message:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CMake 找不到完全匹配的文件，它会尝试附加一个潜在的扩展列表，看看是否有适合的扩展。这个行为容易出错，并可能导致潜在的 bug，因此被修复了。如果你尝试使用版本大于或等于
    `3.20` 的 CMake 配置一个项目，而该项目的要求版本是 `3.19` 或更低版本，你将看到以下警告信息：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We haven’t covered policies yet, so we’ll skip over the details for now, but
    essentially they are a way for the CMake maintainers to avoid breaking changes
    for projects as new versions of CMake are rolled out.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涉及到策略，所以暂时跳过详细信息，但本质上它们是 CMake 维护者为了避免在发布新版本的 CMake 时破坏项目兼容性的一种方式。
- en: 'If you were to update `cmake_minimum_required(VERSION 3.19)` to `cmake_minimum_required(VERSION
    3.20)` without adding an explicit extension to the `main` file, then attempting
    to configure would produce a hard error instead:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `cmake_minimum_required(VERSION 3.19)` 更新为 `cmake_minimum_required(VERSION
    3.20)`，但没有为 `main` 文件添加显式的扩展名，那么尝试配置时将产生一个硬错误：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This was a bit of a digression, but the idea is to highlight why `cmake_minimum_required`
    is so important and must be included. In general, it’s always better to be explicit
    when it comes to CMake, rather than relying on implicit behavior that may change
    depending on the platform or a future release.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点偏题，但目的是强调为什么 `cmake_minimum_required` 非常重要，必须包括。通常来说，涉及 CMake 时最好是明确指定，而不是依赖于可能会根据平台或未来版本变化的隐式行为。
- en: Naming the project
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为项目命名
- en: 'Let’s next look at how to give our project a name:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看如何给我们的项目命名：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`project` is the second required command that all `CMakeLists.txt` files must
    provide. If you omit it, you get this helpful error message:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`project` 是所有 `CMakeLists.txt` 文件必须提供的第二个必需命令。如果你省略它，你会得到一个有用的错误信息：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `project` command allows you to give a meaningful name to the top-level
    project, which may well be a collection of libraries and/or applications. The
    `project` command provides a host of additional options that can be useful to
    specify. In our example, we’ve provided `LANGUAGES C` to let CMake know what type
    of source files the project contains. This is optional but good practice, as it
    stops CMake from doing unnecessary work. If we hadn’t specified C only in this
    case, CMake would have searched for both C and C++ compilers (CXX is used to refer
    to C++ in CMake scripts to avoid ambiguity with the `+` operator in various contexts).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`project` 命令允许你为顶级项目指定一个有意义的名称，该项目可能是一个库和/或应用程序的集合。`project` 命令提供了许多附加选项，这些选项可能在指定时非常有用。在我们的示例中，我们提供了
    `LANGUAGES C` 来让 CMake 知道项目包含哪种类型的源文件。这是可选的，但通常是良好的实践，因为它可以防止 CMake 做不必要的工作。如果我们没有在此情况下仅指定
    C，CMake 将会搜索 C 和 C++ 编译器（CMake 脚本中使用 CXX 来表示 C++，以避免与不同上下文中的 `+` 运算符产生歧义）。'
- en: 'Other `project` options include the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 `project` 选项包括：
- en: '`VERSION`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VERSION`'
- en: '`DESCRIPTION`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DESCRIPTION`'
- en: '`HOMEPAGE_URL`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HOMEPAGE_URL`'
- en: Your mileage may vary on how useful these are. For small, local projects, they’re
    likely overkill, but if a project is gaining traction and beginning to be used
    more widely, then adding these can be helpful for new users. To learn more about
    the CMake `project` command, please refer to [https://cmake.org/cmake/help/latest/command/project.html#options](https://cmake.org/cmake/help/latest/command/project.html#options).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项的有用性可能因项目而异。对于小型本地项目，它们可能过于复杂，但如果一个项目开始获得关注并被更广泛使用，那么添加这些选项对于新用户可能是有帮助的。如需了解更多关于
    CMake `project` 命令的信息，请参阅 [https://cmake.org/cmake/help/latest/command/project.html#options](https://cmake.org/cmake/help/latest/command/project.html#options)。
- en: Declaring the application
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明应用程序
- en: 'With the minimum version set and our project named, we can ask CMake to create
    our first executable file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好最低版本要求并命名我们的项目后，我们可以请求 CMake 创建我们的第一个可执行文件：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`add_executable` is important as this is the first line to do something specific
    for our project. Calling this will create what CMake refers to as a **target**.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_executable` 很重要，因为这是我们项目中执行特定操作的第一行代码。调用此命令将创建 CMake 所称的 **目标**。'
- en: A target is usually an executable (shown here) or a library (you can also create
    special custom target commands). CMake provides commands to get and set values
    directly on targets without affecting each other, or the global CMake state. Targets
    are an incredibly useful concept and make it possible to encapsulate a set of
    properties and behaviors together. Think of targets as an individual unit in a
    CMake project. They make it easy to have multiple executables or libraries all
    with unique properties that can depend on one another. We’ll be using targets
    a lot throughout the rest of this book.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目标通常是一个可执行文件（如这里所示）或一个库（你还可以创建特殊的自定义目标命令）。CMake 提供了命令来直接获取和设置目标的值，而不会相互影响，或影响全局的
    CMake 状态。目标是一个非常有用的概念，它使得可以将一组属性和行为封装在一起。可以把目标看作是 CMake 项目中的一个独立单元。它们使得我们能够轻松拥有多个可执行文件或库，并且每个都具有独特的属性，并且可以相互依赖。我们将在本书的其余部分频繁使用目标。
- en: In the preceding `add_executable` example, we’ve used an existing CMake variable
    that was created for us behind the scenes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `add_executable` 示例中，我们使用了一个已经为我们创建的现有 CMake 变量。
- en: 'There are two important questions to address:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个重要的问题需要解决：
- en: How did we know to use `PROJECT_NAME`?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是如何知道要使用 `PROJECT_NAME` 的？
- en: Why did we need to use `${}` around `PROJECT_NAME`?
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要在 `PROJECT_NAME` 周围使用 `${}`？
- en: 'The answer to the first question can be answered by visiting [https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html).
    This page is a helpful resource that enumerates all current CMake variables. If
    we scroll down the page, we’ll find **PROJECT_NAME** ([https://cmake.org/cmake/help/latest/variable/PROJECT_NAME.html](https://cmake.org/cmake/help/latest/variable/PROJECT_NAME.html))
    and see the following description:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题的答案可以通过访问 [https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html)
    来解决。这个页面是一个有用的资源，列出了所有当前的 CMake 变量。如果我们向下滚动页面，我们会找到 **PROJECT_NAME** ([https://cmake.org/cmake/help/latest/variable/PROJECT_NAME.html](https://cmake.org/cmake/help/latest/variable/PROJECT_NAME.html))，并看到如下描述：
- en: This is the name given to the most recently called `project()` command in the
    current directory scope or above.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前目录范围或更高范围内最近调用的 `project()` 命令所赋予的名称。
- en: In our simple example, this is sufficient to use as the name for the target
    we’re creating, as the target and project are essentially one and the same. In
    the future, when creating larger CMake projects that may contain multiple targets,
    it is a better idea to create a separate variable (e.g., `${MY_EXECUTABLE}`) for
    the target name, or simply use a literal (e.g., `my_executable`). We’ll cover
    defining variables shortly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，使用这个作为我们正在创建的目标的名称是足够的，因为目标和项目本质上是同一个东西。未来，在创建可能包含多个目标的较大 CMake 项目时，最好为目标名称创建一个单独的变量（例如，`${MY_EXECUTABLE}`），或者直接使用字面值（例如，`my_executable`）。我们稍后会讲解如何定义变量。
- en: 'The second question we haven’t yet answered is about the slightly strange `${}`
    syntax. CMake variables follow a similar pattern to system environment variables,
    which you have likely encountered in some form before. To access the value stored
    in the variable, we need to surround it with `${}` to effectively dereference
    or unwrap the value stored within. As a quick example, if we type `echo PATH`
    from our terminal, we’ll see `PATH` printed. If we, however, type `echo ${PATH}`
    (or `echo %PATH%` on Windows), we’ll see the contents of the `PATH` variable (on
    macOS, this is something like `/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin...`).
    Things are the same in CMake. As a quick test, let’s add a debugging statement
    to confirm the value of `PROJECT_NAME`. We can do this by adding the following
    command to the bottom of our `CMakeLists.txt` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未回答的第二个问题是关于稍微奇怪的 `${}` 语法。CMake 变量遵循与系统环境变量类似的模式，你可能以前以某种形式遇到过这些变量。为了访问存储在变量中的值，我们需要用
    `${}` 将其括起来，以有效地取消引用或解包存储的值。举个简单的例子，如果我们在终端中输入 `echo PATH`，我们将看到打印出的 `PATH`。然而，如果我们输入
    `echo ${PATH}`（或者在 Windows 上输入 `echo %PATH%`），我们将看到 `PATH` 变量的内容（在 macOS 上，这通常是类似
    `/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin...` 的内容）。CMake 也是一样。做个简单的测试，让我们添加一个调试语句来确认
    `PROJECT_NAME` 的值。我们可以通过在 `CMakeLists.txt` 文件的底部添加以下命令来实现：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we run `cmake -B build`, we’ll see `PROJECT_NAME: minimal-cmake` printed
    to the console.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们运行 `cmake -B build` 时，我们将在控制台中看到 `PROJECT_NAME: minimal-cmake` 被打印出来。'
- en: One small advantage to using `${PROJECT_NAME}` for our target is we’re keeping
    our `CMakeLists.txt` file short and concise, and not introducing any additional
    complexity. The other advantage is should we decide to change the name of our
    project, we only need to make this change in one place (adhering to the generally
    sound advice `${PROJECT_NAME}` will automatically reflect the new value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `${PROJECT_NAME}` 作为我们的目标名的一个小优势是，我们保持了 `CMakeLists.txt` 文件的简洁性，没有引入额外的复杂性。另一个优势是，如果我们决定更改项目的名称，我们只需要在一个地方进行更改（遵循通常的建议，`${PROJECT_NAME}`
    会自动反映新值）。
- en: Adding source files
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加源文件
- en: 'Let’s now understand how to specify the files we’d like to build:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们理解如何指定我们要构建的文件：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With a target now defined using `add_executable`, we can refer to that target
    via the name (in our case `${PROJECT_NAME}`, which unwraps to `minimal-cmake`)
    in other target-specific commands. These commands are helpfully prefixed with
    `target_` to make them easier to spot. The huge advantage of these commands compared
    to earlier CMake commands is they eliminate a host of potential issues and confusion
    around the scope of CMake commands. In the past, it would be easy for a setting
    defined in one `CMakeLists.txt` file to leak into another one inadvertently, often
    with agonizing consequences. By being more disciplined around the use of targets,
    we can specify properties and settings specific to that target, which then won’t
    affect any others.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过 `add_executable` 定义了一个目标后，我们可以通过该目标的名称（在我们的例子中是 `${PROJECT_NAME}`，它解包为
    `minimal-cmake`）在其他与目标相关的命令中引用它。这些命令通常以 `target_` 为前缀，方便我们识别。与之前的 CMake 命令相比，这些命令的巨大优势在于它们消除了大量潜在问题和关于
    CMake 命令作用范围的混淆。在过去，某个 `CMakeLists.txt` 文件中定义的设置可能会无意中泄露到另一个文件中，往往带来痛苦的后果。通过更加规范地使用目标，我们可以为该目标指定特定的属性和设置，从而避免影响其他目标。
- en: Regarding the `target_sources` command, this is where we specify the source
    files we would like to build for this target. The argument preceding `main.c`
    controls the visibility or scope of the source file. In most cases, we want to
    use `PRIVATE` here so only this target builds the source file. The other scope
    arguments are `PUBLIC` (used by this target and other targets that depend on it)
    and `INTERFACE` (used only by dependent targets). We’ll return to these keywords
    in the future (when we cover libraries) as they appear across all the `target_`
    commands and have several uses.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `target_sources` 命令，这是我们为目标指定要构建的源文件的地方。紧跟在 `main.c` 之前的参数控制源文件的可见性或作用范围。在大多数情况下，我们希望在这里使用
    `PRIVATE`，以便只有这个目标构建源文件。其他作用范围参数有 `PUBLIC`（该目标和依赖它的其他目标使用）和 `INTERFACE`（仅供依赖的目标使用）。我们将在以后回到这些关键字（当我们讨论库时），因为它们出现在所有的
    `target_` 命令中，并且有多种用途。
- en: Setting language features
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置语言特性
- en: 'Finally, let’s ensure we’re explicit about the version of the language we’re
    using:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们确保明确指定我们正在使用的语言版本：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last command in our `CMakeLists.txt` file is `target_compile_features`.
    This is a convenient way to specify the language version we’d like to use, which
    in this case is `C17`. It is possible to be more granular and pick specific language
    features (e.g., `c_restrict`) but picking a language version is clear and concise.
    It’s possible to review available modes and features for C here: [https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_C_KNOWN_FEATURES.html](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_C_KNOWN_FEATURES.html)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `CMakeLists.txt` 文件中的最后一条命令是 `target_compile_features`。这是指定我们希望使用的语言版本的便捷方法，在本例中为
    `C17`。我们也可以更精细地选择特定的语言特性（例如，`c_restrict`），但选择语言版本更加清晰简洁。你可以在这里查看 C 语言的可用模式和特性：[https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_C_KNOWN_FEATURES.html](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_C_KNOWN_FEATURES.html)
- en: We could also go the other way and instead use `set(CMAKE_C_STANDARD 17)`. This
    applies this setting across the entire project. We may want this behavior but,
    in our case, we’re sticking with a more target-centric approach so only the `minimal-cmake`
    target is affected.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以选择另一种方式，使用 `set(CMAKE_C_STANDARD 17)`。这会在整个项目中应用此设置。我们可能希望这种行为，但在我们的情况下，我们坚持采用更具目标导向的方法，因此只有
    `minimal-cmake` 目标会受到影响。
- en: 'That more or less covers everything we need as far as CMake is concerned when
    it comes to building small applications. This on its own is surprisingly useful
    as we now have a completely portable way to run our code on Windows, macOS, and
    Linux. This makes code easier to share and collaborate on. If a user or fellow
    developer on another platform wants to check out our project, so long as they
    have CMake (and most likely Git) installed, they can do it with a few commands.
    If, on the other hand, you shared an Xcode, Visual Studio, or even Make project,
    this would require a lot more work on their part. The great news is even if a
    user does want to use Visual Studio or Xcode to test or modify the code, they
    still can. This brings us to the next important part of using CMake: generators.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就构建小型应用程序而言，这大致涵盖了我们在使用 CMake 时所需的一切。单独来看，这已经非常有用，因为我们现在有了一种完全便携的方式，可以在 Windows、macOS
    和 Linux 上运行我们的代码。这使得代码更容易共享和协作。如果其他平台的用户或开发者想查看我们的项目，只要他们安装了 CMake（很可能还需要 Git），他们可以通过几条命令轻松完成。如果你分享的是
    Xcode、Visual Studio，甚至是 Make 项目，他们就需要做更多的工作。好消息是，即使用户希望使用 Visual Studio 或 Xcode
    来测试或修改代码，他们仍然可以这样做。这将我们引向了使用 CMake 的下一个重要部分：生成器。
- en: CMake generators
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMake 生成器
- en: 'In the *Invoking CMake* section, we glossed over what was happening when we
    ran `cmake -B build`. When we run `cmake -B build`, we’re asking CMake to generate
    build files for us, but what build files? CMake will do its best to pick the platform
    default; this is Visual Studio on Windows and Make on macOS and Linux. A list
    of all potential generators can be found by visiting [https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html)
    or by running the `cmake --help` command (the default generator is displayed with
    an asterisk). To check what generator is being used if you’re unsure, you can
    open the `CMakeCache.txt` file inside the `build/` folder and search for `CMAKE_GENERATOR`.
    There you should find a line such as the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *调用 CMake* 部分，我们略过了运行 `cmake -B build` 时发生了什么。当我们运行 `cmake -B build` 时，我们要求
    CMake 为我们生成构建文件，但到底是什么构建文件呢？CMake 会尽力选择平台的默认值；在 Windows 上是 Visual Studio，而在 macOS
    和 Linux 上是 Make。所有潜在生成器的列表可以通过访问 [https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html)
    或运行 `cmake --help` 命令找到（默认生成器会用星号标出）。如果你不确定正在使用哪个生成器，可以打开 `build/` 文件夹中的 `CMakeCache.txt`
    文件并搜索 `CMAKE_GENERATOR`。你应该能找到类似下面的行：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: cmake -B build -G Ninja
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: cmake -B build -G Ninja
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: cmake -B build -G <new-generator> --fresh
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: cmake -B build -G <new-generator> --fresh
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: cmake -B build -DCMAKE_BUILD_TYPE=Debug
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: cmake -B build -DCMAKE_BUILD_TYPE=Debug
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: cmake -B build-debug -G Ninja -DCMAKE_BUILD_TYPE=Debug
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: cmake -B build-debug -G Ninja -DCMAKE_BUILD_TYPE=Debug
- en: cmake -B build-release -G Ninja -DCMAKE_BUILD_TYPE=Release
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: cmake -B build-release -G Ninja -DCMAKE_BUILD_TYPE=Release
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'cmake -B build -G "Visual Studio 17 2022" # Windows'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'cmake -B build -G "Visual Studio 17 2022" # Windows'
- en: The year can be omitted for brevity
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了简洁起见，年份可以省略。
- en: 'cmake -B build -G "Visual Studio 17" # Windows'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'cmake -B build -G "Visual Studio 17" # Windows'
- en: 'cmake -B build -G Xcode # macOS'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'cmake -B build -G Xcode # macOS'
- en: 'cmake -B build -G "Ninja Multi-Config" # Linux'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'cmake -B build -G "Ninja Multi-Config" # Linux'
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: cmake --build build --config Debug
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build --config Debug
- en: cmake --build build --config Release
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build --config Release
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '****************************************'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '****************************************'
- en: '*********@******************************'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*********@******************************'
- en: '*******@*@******************************'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*******@*@******************************'
- en: '********@@******************************'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '********@@******************************'
- en: '****************************************'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '****************************************'
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: target_sources(${PROJECT_NAME} PRIVATE main.c cmake --build build again (it
    is not necessary to reconfigure).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: target_sources(${PROJECT_NAME} PRIVATE main.c cmake --build build again (不需要重新配置)。
- en: Forgetting to add a file
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 忘记添加一个文件
- en: 'It’s useful to know if we don’t add `array.c` to our `CMakeLists.txt` file,
    but do add usage code for `array`, and then try and compile (`cmake --build build`).
    Things will compile, but we’ll hit everyone’s favorite issue: linker errors. The
    following output illustrates this:'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们没有将 `array.c` 添加到 `CMakeLists.txt` 文件中，而是添加了对 `array` 的使用代码，并尝试编译（`cmake
    --build build`），那会很有用。编译是可以通过的，但我们会遇到大家都熟悉的问题：链接器错误。以下输出展示了这一点：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is because the linker can’t find the implementation of the functions listed
    (e.g., `_array_size`). The output file, `array.c.o` on macOS/Linux and `array.c.obj`
    or `array.obj` on Windows, won’t have been created (you can see whether these
    files exist by going to `build/CMakeFiles/minimal-cmake_game-of-life.dir/Debug`
    if using the Ninja Multi-Config generator, other generators will place it in a
    similar location).
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为链接器找不到列出的函数的实现（例如，`_array_size`）。输出文件，在 macOS/Linux 上是 `array.c.o`，在 Windows
    上是 `array.c.obj` 或 `array.obj`，不会被创建（你可以通过进入 `build/CMakeFiles/minimal-cmake_game-of-life.dir/Debug`
    来查看这些文件是否存在，如果使用的是 Ninja Multi-Config 生成器，其他生成器会将其放在类似位置）。
- en: This is definitely an early gotcha when using CMake (creating the files but
    forgetting to add them to `CMakeLists.txt`).
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是使用 CMake 时常见的早期问题（创建了文件但忘记将它们添加到 `CMakeLists.txt` 中）。
- en: To GLOB or not to GLOB
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是否使用 GLOB
- en: 'At this point, it’s worth mentioning a topic that comes up often with CMake,
    and that is whether to explicitly mention files to build, as in the preceding
    example, or use a technique to `GLOB` (effectively search) all source files in
    each folder hierarchy. As with everything in software engineering and computer
    science, there are trade-offs. There may be a set of circumstances where it’s
    simpler and quicker to use `GLOB`. This might look something like the following:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到这个时候，值得提到一个常常在 CMake 中出现的话题，那就是是否像前面的例子一样明确列出要构建的文件，还是使用一种 `GLOB`（有效地搜索）每个文件夹层级中的所有源文件的技术。就像软件工程和计算机科学中的一切一样，这里面有权衡。有些情况下，使用
    `GLOB` 会更简单快捷。这可能看起来像下面这样：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This may work well for you and your environment, but it comes with a set of
    risks. Before the advent of `CONFIGURE_DEPENDS` (added in CMake `3.12`), there
    would be problems if you added a source file (for example, by pulling the latest
    code from a version control system) without configuring. In this case, CMake would
    fail to build if running `cmake --build build`. Specifying `CONFIGURE_DEPENDS`
    avoids this, but there are no guarantees it works with all generators, and for
    larger projects, it may cause performance problems. The maintainers of CMake still
    recommend explicitly specifying the source files you want to build, which we follow
    throughout this book. It reduces the risk of inadvertently building a file you
    don’t want to and the changes to a `CMakeLists.txt` file are useful to track in
    version control. The linker error mentioned previously is frustrating to begin
    with, but you quickly adjust, and adding new files will soon become second nature.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能在你和你的环境中运行得很好，但也有一系列风险。在 `CONFIGURE_DEPENDS`（CMake `3.12` 中新增）出现之前，如果你添加了源文件（例如，从版本控制系统中拉取最新代码）而没有进行配置，运行
    `cmake --build build` 时会遇到问题。在这种情况下，CMake 构建会失败。指定 `CONFIGURE_DEPENDS` 可以避免这种情况，但不能保证它与所有生成器兼容，对于更大的项目，可能会引发性能问题。CMake
    的维护者仍然建议明确指定要构建的源文件，这是我们在本书中一直遵循的做法。它减少了不小心构建不想要的文件的风险，并且对 `CMakeLists.txt` 文件所做的更改有助于在版本控制中跟踪。前面提到的链接器错误一开始确实让人沮丧，但你很快就会适应，添加新文件也会变得自然而然。
- en: With the new `array.c` file added, we can change our update function to use
    the new logic and improve the performance of our code (`ch2/part-3` has a slightly
    more exciting board configuration that’s worth having a look at too).
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在添加了新的 `array.c` 文件后，我们可以更改更新函数以使用新的逻辑，并提高代码的性能（`ch2/part-3` 中有一个稍微更激动人心的棋盘配置，值得一看）。
- en: Referencing interface files in target_sources
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 target_sources 中引用接口文件
- en: 'The last thing worth mentioning is what about `array.h`? As we are including
    this file relatively in `main.c` (using `#include "array/array.h"` and not `#include
    <array/array.h>`), we do not need to explicitly mention any include directories
    in our `CMakeLists.txt` file (this will be more important when we come to libraries).
    If you are using a generator that produces some kind of project or solution that
    you can open in a separate tool (for example, an integrated development environment
    such as Visual Studio or Xcode), then you can you add `array.h` to `target_sources`
    in the following manner:'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一个值得提及的点是`array.h`怎么办？由于我们在`main.c`中相对引用了这个文件（使用`#include "array/array.h"`而不是`#include
    <array/array.h>`），我们不需要在`CMakeLists.txt`文件中明确提到任何包含目录（当我们涉及到库时，这一点会更重要）。如果你使用的是一种生成工具，能够生成一个可以在独立工具中打开的项目或解决方案（例如集成开发环境，如Visual
    Studio或Xcode），那么你可以像下面这样将`array.h`添加到`target_sources`中：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will cause it to show up in the project view, which might be useful from
    a maintenance standpoint; however, it’s not strictly required to build the code.
    As we will be using Visual Studio Code and the folder project view in most examples,
    we’ll omit header files for brevity. There is one other benefit to specifying
    header files and that is if a file is deleted accidentally, or can’t be fetched
    from source control, CMake will fail early at the configure step, instead of when
    building. The added maintenance cost may be worthwhile, especially on larger teams.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，它会出现在项目视图中，这对于维护可能很有用；不过，它并不是构建代码所必需的。由于我们在大多数示例中将使用Visual Studio Code和文件夹项目视图，为了简洁起见，我们会省略头文件。指定头文件还有一个好处，那就是如果文件被意外删除，或者无法从源控制中获取，CMake会在配置步骤中提前失败，而不是在构建时。增加的维护成本可能是值得的，特别是在团队较大的情况下。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结
- en: Incredible work getting this far; we’ve covered a lot of ground! We started
    by getting familiar with using CMake from the terminal (`cmake -B build` and `cmake
    --build build` should be well and truly etched into your memory). We then walked
    through a simple `CMakeLists.txt` file, examining the most important commands
    and why they’re needed. After that, we delved into generators and examined some
    of the differences between single- and multi-config generators, and how to specify
    the build type in each case. We finally looked at the seed of our project, an
    implementation of Conway’s *Game of Life*, and how we can incrementally add more
    files to an existing project as we expand the functionality.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非常棒，你已经走到了这一步；我们已经覆盖了很多内容！我们从熟悉如何通过终端使用CMake开始（`cmake -B build`和`cmake --build
    build`应该已经深深记在你的脑海中了）。接着，我们通过一个简单的`CMakeLists.txt`文件，检查了最重要的命令以及它们为何需要。然后，我们深入探讨了生成器，研究了单配置生成器和多配置生成器之间的一些差异，以及如何在每种情况下指定构建类型。最后，我们看了我们项目的种子，康威的*生命游戏*实现，并了解了如何在扩展功能时，逐步向现有项目中添加更多文件。
- en: In the next chapter, we will look at how we can bring external dependencies
    into our project. This will allow us to augment and improve the functionality
    of our application and the maintainability of our code. This is where CMake really
    shines, helping us integrate with existing libraries without needing to implement
    everything ourselves from scratch.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将外部依赖项引入我们的项目。这将使我们能够增强和改善应用程序的功能以及代码的可维护性。这正是CMake的强大之处，它帮助我们集成现有的库，而无需从头开始实现一切。
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
