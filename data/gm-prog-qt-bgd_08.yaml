- en: Chapter 8. Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 脚本
- en: '*In this chapter, you will learn how to bring scripting facilities to your
    programs. You will gain knowledge of how to use a language based on JavaScript
    to implement the logic and details of your game without having to rebuild the
    main game engine. Although the environment we are going to focus on blends best
    with Qt applications, if you don''t like JavaScript you will be given suggestions
    about other languages that you can use to make your games scriptable.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在本章中，你将学习如何将脚本功能引入你的程序。你将了解如何使用基于JavaScript的语言来实现游戏逻辑和细节，而无需重建主游戏引擎。虽然我们将关注的这个环境与Qt应用程序结合得最好，但如果不喜欢JavaScript，你将得到关于你可以使用的其他语言的建议，以使你的游戏可脚本化。*'
- en: Why script?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用脚本？
- en: You might ask yourself, why should I use any scripting language if I can implement
    everything I need in C++? There are a number of benefits to providing a scripting
    environment to your games. Most modern games really consist of two parts. One
    of them is the main game engine that implements the core of the game (data structures,
    processing algorithms, and the rendering layer) and exposes an API to the other
    component, which provides details, behavior patterns, and action flows for the
    game. This other component is usually written in a scripting language. The main
    benefit of this is that story designers can work independently from the engine
    developers and they don't have to rebuild the whole game just to modify some of
    its parameters or check whether the new quest fits well into the existing story.
    This makes the development much quicker compared to the monolithic approach. Another
    benefit is that this development opens the game to modding—skilled end users can
    extend or modify the game to provide some added value to the game. It's also a
    way to make additional money on the game by implementing extensions on it on top
    of the existing scripting API without having to redeploy the complete game binary
    to every player or to expose new scripting endpoints to boost the creativity of
    the modders even more. Finally, you can reuse the same game driver for other games
    and just replace the scripts to obtain a totally different product.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，既然我可以用C++实现所有需要的功能，为什么还要使用任何脚本语言呢？为你的游戏提供脚本环境有许多好处。大多数现代游戏实际上由两部分组成。其中一部分是主游戏引擎，它实现了游戏的核心（数据结构、处理算法和渲染层），并向其他组件提供了一个API，该组件为游戏提供详细信息、行为模式和动作流程。这个其他组件通常是用脚本语言编写的。这样做的主要好处是，故事设计师可以独立于引擎开发者工作，他们不需要重建整个游戏，只需修改一些参数或检查新任务是否与现有故事很好地融合。这使得开发速度比单体方法快得多。另一个好处是，这种开发使游戏开放给模组化——有技能的最终用户可以扩展或修改游戏，为游戏提供一些增值服务。这也是通过在现有的脚本API上实现扩展来为游戏赚取额外收入的一种方式，而无需重新部署完整的游戏二进制文件给每个玩家，或者向模组开发者暴露新的脚本端点以进一步增强他们的创造力。最后，你可以重用相同的游戏驱动程序为其他游戏，只需替换脚本即可获得一个完全不同的产品。
- en: Qt provides two implementations of a JavaScript-based scripting environment.
    In this chapter, we will be focusing on Qt Script. In the docs, you can see that
    the module is marked as "deprecated"; however, it currently provides a richer
    API (albeit with slower execution) than the other implementation. After we describe
    Qt Script, we will have a brief look at the other implementation as well. We will
    not discuss the details of the JavaScript language itself, as there are many good
    books and websites available out there where you can learn JavaScript. Besides,
    the JavaScript syntax is very similar to that of C, and you shouldn't have any
    problems understanding the scripts that we use in this chapter even if you haven't
    seen any JavaScript code before.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了两种基于JavaScript的脚本环境实现。在本章中，我们将重点关注Qt Script。在文档中，你可以看到该模块被标记为“已弃用”；然而，它目前提供的API（尽管执行速度较慢）比其他实现更丰富。在描述Qt
    Script之后，我们还将简要地看看另一种实现。我们不会讨论JavaScript语言本身的细节，因为有许多优秀的书籍和网站可供学习JavaScript。此外，JavaScript的语法与C非常相似，即使你之前没有见过任何JavaScript代码，你也不应该有任何问题理解我们本章中使用的脚本。
- en: The basics of Qt Script
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Script的基础
- en: To use Qt Script in your programs, you have to enable the script module for
    your projects by adding the `QT += script` line to the project file.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要在程序中使用Qt Script，你必须通过在项目文件中添加`QT += script`行来为你的项目启用脚本模块。
- en: Evaluating JavaScript expressions
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估JavaScript表达式
- en: 'C++ compilers do not understand JavaScript. Therefore, to execute any script,
    you need to have a running interpreter that will parse the script and evaluate
    it. In Qt, this is done with the `QScriptEngine` class. This is a Qt Script runtime
    that handles the execution of script code and manages all the resources related
    to scripts. It provides the `evaluate()` method, which can be used to execute
    JavaScript expressions. Let''s look at a "Hello World" program in Qt Script:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编译器不理解 JavaScript。因此，要执行任何脚本，你需要有一个正在运行的解释器，该解释器将解析脚本并评估它。在 Qt 中，这是通过 `QScriptEngine`
    类来完成的。这是一个 Qt 脚本运行时，它处理脚本代码的执行并管理所有与脚本相关的资源。它提供了 `evaluate()` 方法，可以用来执行 JavaScript
    表达式。让我们看看 Qt 脚本中的“Hello World”程序：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This program is very simple. First, it creates an application object that is
    required for the script environment to function properly, and then it just instantiates
    `QScriptEngine` and invokes evaluate to execute the script source given to it
    as a parameter. After building and running the program, you will see a well-known
    `Hello World!` printed to the console.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序非常简单。首先，它创建了一个应用程序对象，这是脚本环境正常工作所必需的，然后它只是实例化 `QScriptEngine` 并调用 `evaluate`
    来执行作为参数传递给它的脚本源代码。构建并运行程序后，你将在控制台看到熟悉的 `Hello World!`。
- en: 'If you don''t get any output, then this probably means that the script didn''t
    get executed properly, possibly because of an error in the script''s source code.
    To verify that, we can extend our simple program to check whether there were any
    problems with the execution of the script. For this, we can query the engine state
    with `hasUncaughtExceptions()`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有获得任何输出，那么这很可能意味着脚本没有正确执行，可能是由于脚本源代码中的错误。为了验证这一点，我们可以扩展我们的简单程序来检查脚本执行过程中是否出现了任何问题。为此，我们可以使用
    `hasUncaughtExceptions()` 查询引擎状态：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The highlighted code checks whether there is an exception and if yes, it fetches
    the exception object. You can see that its type is `QScriptValue`. This is a special
    type that is used to exchange data between the script engine and the C++ world.
    It is somewhat similar to `QVariant` in the way that it is really a facade for
    a number of primitive types that the script engine uses internally. One of the
    types is the type holding errors. We can check whether a script value object is
    an error using its `isError()` method, but in this case, we don''t do that since
    `uncaughtException()` is meant to return error objects. Instead, we immediately
    convert the error to a string representation and dump it to the console using
    `qDebug()`. For example, if you omit the closing single quote in the script source
    text and run the program, the following message will be displayed:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码检查是否存在异常，如果存在，则获取异常对象。你可以看到它的类型是 `QScriptValue`。这是一个特殊类型，用于在脚本引擎和 C++ 世界之间交换数据。它在某种程度上类似于
    `QVariant`，因为它实际上是一个用于脚本引擎内部使用的多个原始类型的包装器。其中一种类型是包含错误的类型。我们可以使用其 `isError()` 方法检查脚本值对象是否为错误，但在这个例子中，我们不这样做，因为
    `uncaughtException()` 的目的是返回错误对象。相反，我们立即将错误转换为字符串表示形式，并使用 `qDebug()` 将其输出到控制台。例如，如果你在脚本源文本中省略了关闭的单引号并运行程序，将显示以下消息：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`QScriptEngine::evaluate()` also returns `QScriptValue`. This object represents
    the result of the evaluated script. You can make a script calculate some value
    for you that you can later use in your C++ code. For example, the script can calculate
    the amount of damage done to a creature when it is hit with a particular weapon.
    Modifying our code to use the result of the script is very simple. All that is
    required is to store the value returned by `evaluate()` and then it can be used
    elsewhere in the code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`QScriptEngine::evaluate()` 同样返回 `QScriptValue`。此对象代表已评估脚本的输出结果。你可以让脚本为你计算一些值，这些值你可以在之后的
    C++ 代码中使用。例如，脚本可以计算当生物被特定武器击中时造成的伤害量。修改我们的代码以使用脚本的结果非常简单。所需做的只是存储 `evaluate()`
    返回的值，然后它就可以在代码的其他地方使用：'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Time for action – creating a Qt Script editor
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建一个 Qt 脚本编辑器
- en: 'Let''s do a simple exercise and create a graphical editor to write and execute
    scripts. Start by creating a new GUI project and implement a main window composed
    of two plain text edit widgets (`ui->codeEditor` and `ui->logWindow`) that are
    separated using a vertical splitter. One of the edit boxes will be used as an
    editor to input code and the other will be used as a console to display script
    results. Then, add a menu and toolbar to the window and create actions to open
    (`ui->actionOpen`) and save (`ui->actionSave`) the document, create a new document
    (`ui->actionNew`), execute the script (`ui->actionExecute`), and to quit the application
    (`ui->actionQuit`). Remember to add them to the menu and toolbar. As a result,
    you should receive a window similar to the one shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个简单的练习，创建一个图形编辑器来编写和执行脚本。首先创建一个新的 GUI 项目，实现一个由两个纯文本编辑小部件（`ui->codeEditor`
    和 `ui->logWindow`）组成的窗口，这两个小部件通过垂直分隔符分开。其中一个编辑框将用作输入代码的编辑器，另一个将用作显示脚本结果的控制台。然后，向窗口添加菜单和工具栏，并创建打开（`ui->actionOpen`）、保存（`ui->actionSave`）、创建新文档（`ui->actionNew`）、执行脚本（`ui->actionExecute`）和退出应用程序（`ui->actionQuit`）的操作。请记住将它们添加到菜单和工具栏中。结果，您应该得到以下截图所示的窗口：
- en: '![Time for action – creating a Qt Script editor](img/8874OS_08_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![执行动作 – 创建 Qt 脚本编辑器](img/8874OS_08_01.jpg)'
- en: 'Connect the quit action to the `QApplication::quit()` slot. Then, create an
    `openDocument()` slot and connect it to the appropriate action. In the slot, use
    `QFileDialog::getOpenFileName()` to ask the user for a document path as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将退出操作连接到 `QApplication::quit()` 插槽。然后，创建一个 `openDocument()` 插槽并将其连接到相应的操作。在插槽中，使用
    `QFileDialog::getOpenFileName()` 请求用户输入文档路径，如下所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a similar fashion, implement the **Save** and **Save As** action handlers.
    Lastly, create the `open(const QString &filePath)` slot, make it read the document,
    and put its contents into the code editor:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式实现 **保存** 和 **另存为** 操作处理程序。最后，创建 `open(const QString &filePath)` 插槽，使其读取文档并将内容放入代码编辑器：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `windowFilePath` property of `QWidget` can be used to associate a file with
    a window. You can then use it in actions related to using the file—when saving
    a document, you can check whether this property is empty and ask the user to provide
    a filename. Then, you can reset this property when creating a new document or
    when the user provides a new path for the document.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWidget` 的 `windowFilePath` 属性可以用来将文件与窗口关联。然后，您可以在与文件使用相关的操作中使用它——在保存文档时，您可以检查此属性是否为空，并要求用户提供文件名。然后，在创建新文档或用户为文档提供新路径时，您可以重置此属性。'
- en: At this point, you should be able to run the program and use it to create scripts
    and save and reload them in the editor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该能够运行程序并使用它来创建脚本，并在编辑器中保存和重新加载它们。
- en: 'Now, to execute the scripts, add a `QScriptEngine m_engine` member variable
    to the window class. Create a new slot, call it `run`, and connect it to the execute
    action. Put the following code in the body of the slot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了执行脚本，向窗口类中添加一个名为 `QScriptEngine m_engine` 的成员变量。创建一个新的插槽，命名为 `run`，并将其连接到执行操作。在插槽的主体中放入以下代码：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Build and run the program. To do so, enter the following script in the editor:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行程序。为此，在编辑器中输入以下脚本：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save the script in a file called `factorial.js` and then run it. You should
    get an output as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本保存到名为 `factorial.js` 的文件中，然后运行它。你应该得到以下截图所示的输出：
- en: '![Time for action – creating a Qt Script editor](img/8874OS_08_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![执行动作 – 创建 Qt 脚本编辑器](img/8874OS_08_02.jpg)'
- en: 'Next, replace the script with the following one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将脚本替换为以下内容：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the script should yield the following result:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本应该得到以下结果：
- en: '![Time for action – creating a Qt Script editor](img/8874OS_08_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![执行动作 – 创建 Qt 脚本编辑器](img/8874OS_08_03.jpg)'
- en: '*What just happened?*'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `run()` method clears the log window and evaluates the script using the
    method that we learned earlier in this chapter. If the evaluation is successful,
    it prints the result in the log window, which is what we see in the first screenshot
    shown in the previous section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 方法清除日志窗口并使用我们在本章前面学到的方法评估脚本。如果评估成功，它将在日志窗口中打印结果，这就是我们在上一节中看到的第一个截图。'
- en: In the second attempt, we made an error in the script using a nonexistent variable.
    Evaluating such code results in an exception. In addition to reporting the actual
    error, we also use `uncaughtExceptionLineNumber()` to report the line that caused
    the problem. Next, we call the engine's `uncaughtExceptionBacktrace()` method,
    which returns a list of strings containing the backtrace (a stack of function
    calls) of the problem, which we also print on the console.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次尝试中，我们在脚本中使用了一个不存在的变量，导致错误。评估此类代码会导致异常。除了报告实际错误外，我们还使用`uncaughtExceptionLineNumber()`来报告导致问题的行号。接下来，我们调用引擎的`uncaughtExceptionBacktrace()`方法，该方法返回一个包含问题回溯（函数调用栈）的字符串列表，我们也将它打印在控制台上。
- en: 'Let''s try another script. The following code defines the local variable `fun`,
    which is assigned an anonymous function that returns a number:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个脚本。以下代码定义了一个局部变量`fun`，它被分配了一个返回数字的匿名函数：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can then call `fun()` like a regular function as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像调用常规函数一样调用`fun()`，如下所示：
- en: '![What just happened?](img/8874OS_08_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/8874OS_08_04.jpg)'
- en: 'Now, let''s look at what happens if we delete the definition of `fun` from
    the script, but still keep the invocation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们从脚本中删除`fun`的定义，但仍然保留调用会发生什么。
- en: '![What just happened?](img/8874OS_08_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/8874OS_08_05.jpg)'
- en: We still get the same result even though we didn't define what fun means! This
    is because the `QScriptEngine` object keeps its state across `evaluate()` invocations.
    If you define a variable in a script, it is kept in the current context of the
    engine. The next time `evaluate()` is called, it executes the script in the same
    context as before; therefore, all variables defined earlier are still valid. Sometimes,
    this is a desired behavior; however, a malicious script can wreck the context,
    which can cause trouble for subsequent evaluations in the engine. Therefore, it
    is usually better to make sure that the engine is left in a clean state after
    a script is done with the execution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有定义`fun`的含义，我们仍然得到相同的结果！这是因为`QScriptEngine`对象在`evaluate()`调用之间保持其状态。如果你在脚本中定义了一个变量，它将被保留在引擎的当前上下文中。下次调用`evaluate()`时，它将在与之前相同的上下文中执行脚本；因此，之前定义的所有变量仍然有效。有时，这种行为是期望的；然而，恶意脚本可能会破坏上下文，这可能会给引擎后续的评估造成麻烦。因此，通常在脚本执行完毕后，确保引擎处于干净的状态会更好。
- en: Time for action – sandboxed script evaluation
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 限制环境的脚本评估
- en: 'The next task for us is to modify our script editor so that it cleans up after
    the execution of each script. As was said, each script is executed in the current
    context of the engine, so the task of solving the problem boils down to making
    sure that each script executes in a separate context. Incorporate the following
    code in the `run()` method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是修改我们的脚本编辑器，以便在每次脚本执行后进行清理。如前所述，每个脚本都是在引擎的当前上下文中执行的，因此解决问题的任务归结为确保每个脚本都在一个单独的上下文中执行。在`run()`方法中包含以下代码：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the program and repeat the last test to see that `fun` no longer persists
    across executions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并重复最后一个测试，以查看`fun`不再在执行之间持续存在。
- en: '*What just happened?*'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'When a function is called, a new execution context is pushed to the top of
    the stack. When the engine tries to resolve an object, it first looks for the
    object in the topmost context (which is the context of the function call). If
    it is not found, the engine looks into the next context on the stack and then
    the next until it finds the object or reaches the bottom of the stack. When the
    function returns, the context is popped from the stack and all variables defined
    there are destroyed. You can see how this works using the following script:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被调用时，一个新的执行上下文会被推送到栈顶。当引擎尝试解析一个对象时，它首先在最高上下文中寻找该对象（即函数调用的上下文）。如果找不到，引擎会检查栈中的下一个上下文，然后是下一个，直到找到对象或到达栈底。当函数返回时，上下文从栈中弹出，并销毁其中定义的所有变量。你可以使用以下脚本查看这是如何工作的：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When `bar` is called, a new context is added to the stack. The script requests
    for the `foo` object, which is not present in the current context, so the engine
    looks into the surrounding context and finds a definition of `foo`. In our code,
    we follow this behavior by explicitly creating a new context using `pushContext()`
    and then removing it with `popContext()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`bar`时，会在栈中添加一个新的上下文。脚本请求`foo`对象，但当前上下文中不存在该对象，因此引擎会检查周围上下文并找到`foo`的定义。在我们的代码中，我们通过显式地使用`pushContext()`创建一个新的上下文，然后使用`popContext()`移除它来遵循这种行为。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can retrieve the current context object with `currentContext()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`currentContext()`检索当前上下文对象。
- en: 'The context has two important objects associated with it: the `activation`
    object and the `this` object. The former defines an object where all local variables
    are stored as the object''s properties. If you set any properties on the object
    before invoking a script, they will be directly available to the script:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文有两个与其相关的重要对象：`activation`对象和`this`对象。前者定义了一个对象，其中所有局部变量都作为对象的属性存储。如果你在调用脚本之前在对象上设置了任何属性，它们将直接对脚本可用：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `this` object works in a similar fashion—it determines the object to be
    used when the script refers to an object called `this`. Any properties defined
    in C++ are accessible from the script and the other way round:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`对象以类似的方式工作——它确定当脚本引用名为`this`的对象时要使用哪个对象。任何在C++中定义的属性都可以从脚本中访问，反之亦然：'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Integrating Qt and Qt Script
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Qt和Qt Script
- en: So far, we were only evaluating some standalone scripts that could make use
    of the features built in JavaScript. Now, it is time to learn to use data from
    your programs in the scripts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只评估了一些可以充分利用JavaScript内置功能的独立脚本。现在，是时候学习如何在脚本中使用程序中的数据了。
- en: This is done by exposing different kinds of entities to and from scripts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将不同类型的实体暴露给脚本来完成的。
- en: Exposing objects
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露对象
- en: 'The simplest way to expose data to Qt Script is to take advantage of Qt''s
    meta-object system. Qt Script is able to inspect `QObject` instances and detect
    their properties and methods. To use them in scripts, the object has to be visible
    to the script execution context. The easiest way to make this happen is to add
    it to the engine''s global object or to some context''s activation object. As
    you remember, all data between the script engine and C++ is exchanged using the
    `QScriptValue` class, so first we have to obtain a script value handle for the
    C++ object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据暴露给Qt Script的最简单方法就是利用Qt的元对象系统。Qt Script能够检查`QObject`实例并检测它们的属性和方法。为了在脚本中使用它们，对象必须对脚本执行上下文可见。最简单的方法是将它添加到引擎的全局对象或某个上下文的激活对象中。正如你所记得的，脚本引擎和C++之间的所有数据交换都使用`QScriptValue`类，所以首先我们必须为C++对象获取一个脚本值句柄：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`QScriptEngine::newQObject()` creates a script wrapper for an existing `QObject`
    instance. We then set the wrapper as a property of the global object called `pushButton`.
    This makes the button available in the global context of the engine as a JavaScript
    object. All the properties defined with `Q_PROPERTY` are available as properties
    of the object and every slot is accessible as a method of that object. Using this
    approach, you can share an existing object between the C++ and JavaScript worlds:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`QScriptEngine::newQObject()`为现有的`QObject`实例创建一个脚本包装器。然后我们将包装器设置为名为`pushButton`的全局对象的属性。这使得按钮在引擎的全局上下文中作为JavaScript对象可用。所有使用`Q_PROPERTY`定义的属性都作为对象的属性可用，每个槽都可以作为该对象的方法访问。使用这种方法，你可以在C++和JavaScript世界之间共享现有对象：'
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are cases when you want to provide a rich interface for a class to manipulate
    it from within C++ easily, but to have a strict control over what can be done
    using scripting, you want to prevent scripters from using some of the properties
    or methods of the class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你希望为类提供一个丰富的接口，以便在C++中轻松操作它，但同时又想严格控制使用脚本可以执行的操作，因此你想阻止脚本编写者使用类的一些属性或方法。
- en: For methods, this is quite easy—just don't make them slots. Remember that you
    can still use them as slots if you use the `connect()` variant, which takes a
    function pointer as an argument.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法，这相当简单——只需不要将它们作为槽位。记住，如果你使用`connect()`变体，它接受一个函数指针作为参数，你仍然可以将它们用作槽位。
- en: 'For properties, you can mark a property as accessible or inaccessible from
    scripts using the `SCRIPTABLE` keyword in the `Q_PROPERTY` declaration. By default,
    all properties are scriptable, but you can forbid their exposure to scripts by
    setting `SCRIPTABLE` to `false` as shown in the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性，你可以在`Q_PROPERTY`声明中使用`SCRIPTABLE`关键字将属性标记为从脚本中可访问或不可访问。默认情况下，所有属性都是可脚本化的，但你可以通过将`SCRIPTABLE`设置为`false`来禁止它们对脚本的暴露，如下面的示例所示：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Time for action – employing scripting for npc AI
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用脚本为NPC AI
- en: Let's implement a script serving as **artificial** **intelligence** (**AI**)
    for a nonplayer character in a simple Dungeons & Dragons game. The engine will
    periodically execute the script, exposing two objects to it—the creature and the
    player. The script will be able to query the properties of the player and invoke
    functions on the creature.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个脚本，作为简单龙与地下城游戏中非玩家角色的**人工智能**（AI）。该引擎将定期执行脚本，向它暴露两个对象——生物和玩家。脚本将能够查询玩家的属性并在生物上调用函数。
- en: 'Let''s create a new project. We''ll start by implementing the C++ class for
    creatures in our game world. Since both the NPC and player are living entities,
    we can have a common base class for them. In [Chapter 4](ch04.html "Chapter 4. Qt
    Core Essentials"), *Qt Core Essentials*, we already had a data structure for players,
    so let''s use that as a base by equipping our entities with similar attributes.
    Implement `LivingEntity` as a subclass of `QObject` with the following properties:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的项目。我们将从实现我们游戏世界中生物的C++类开始。由于NPC和玩家都是生物实体，我们可以为它们有一个共同的基类。在[第4章](ch04.html
    "第4章。Qt核心基础")中，*Qt核心基础*，我们已经有一个玩家的数据结构，所以让我们使用它作为基类，通过为我们的实体配备类似的属性来实现。将`LivingEntity`实现为`QObject`的子类，具有以下属性：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can see that this interface is read only—you cannot modify any of the properties
    using the `LivingEntity` class. Of course, we still need methods to change those
    values; so, implement them in the `public` interface of the class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个接口是只读的——你不能使用`LivingEntity`类修改任何属性。当然，我们仍然需要方法来改变这些值；因此，在类的`public`接口中实现它们：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you implement these methods, be sure to emit proper signals when you modify
    property values. Let''s add more methods that correspond to the actions that a
    creature can take:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现这些方法时，确保在修改属性值时发出适当的信号。让我们添加更多与生物可以执行的动作相对应的方法：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The last four methods are simple to implement; for the first three methods,
    use the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后四个方法实现起来很简单；对于前三个方法，使用以下代码：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Essentially, if the creature chooses to wait, it regains one hit point. If it
    dodges, this increases its chances to avoid damage when attacked. If it attacks
    another creature, this inflicts damage based on its own attack and the opponent's
    defensive score.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，如果生物选择等待，它将恢复一个生命值。如果它闪避，这增加了它在被攻击时避免伤害的机会。如果它攻击另一个生物，这将根据它自己的攻击力和对手的防御分数造成伤害。
- en: 'The next step is to implement the subclasses of `LivingEntity` so that we can
    manipulate the objects from Qt Script. To do this, implement the `NPC` class as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现`LivingEntity`的子类，这样我们就可以使用Qt脚本操作对象。为此，按照以下方式实现`NPC`类：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What remains is to create a simple game engine to test our work. To do this,
    start by adding a `reset()` method to `LivingEntity` that will reset the armor
    bonus before every turn. Then, implement the `GameEngine` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是创建一个简单的游戏引擎来测试我们的工作。为此，首先在`LivingEntity`中添加一个`reset()`方法，在每个回合开始前重置护甲加成。然后，实现`GameEngine`类：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, write the main function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编写主函数：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can test the application using the following script:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下脚本测试应用程序：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*What just happened?*'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We created two classes of objects: `LivingCreature`, which is the basic API
    to read data about a creature, and NPC, which provides a richer API. We obtained
    this effect by redeclaring the existing functions as slots. This is possible even
    when the methods are not virtual, as when slots are executed using Qt''s meta-object
    system, they are always treated as if they were virtual methods—a declaration
    in the derived class always shadows the declaration in the parent class. Having
    the two classes, we exposed their instances to the scripting environment, and
    we use a timer to call a user-defined script every second. Of course, this is
    a very simple approach to scripting, which can easily be abused if the user calls
    multiple action functions in the script, for example, by calling `attack()` many
    times in one script, the creature can perform multiple strikes on the opponent.
    Speaking of `attack()`, note that it takes a `LivingCreature` pointer as its parameter.
    In the script, we fed it with the player object that corresponds to the needed
    type in C++. The conversion is done by Qt Script automatically. Therefore, you
    can define methods by taking `QObject` pointers and using them with `QObject`
    instances that are exposed to scripts. In a similar fashion, you can define functions
    by taking `QVariant` or `QScriptValue` and passing any value to them in the script.
    If the script engine is able to convert the given value to the requested type,
    it will do so.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两种对象类别：`LivingCreature`，这是读取生物数据的基API，以及NPC，它提供了一个更丰富的API。我们通过重新声明现有函数为槽来实现这种效果。即使方法不是虚拟的，这也是可能的，因为当槽使用Qt的元对象系统执行时，它们总是被视为虚拟方法——派生类中的声明总是覆盖父类中的声明。有了这两个类，我们将它们的实例暴露给了脚本环境，并使用计时器每秒调用一个用户定义的脚本。当然，这是一种非常简单的脚本方法，如果用户在脚本中调用多个动作函数，例如在一个脚本中多次调用`attack()`，生物可以对对手进行多次攻击。说到`attack()`，请注意它接受一个`LivingCreature`指针作为其参数。在脚本中，我们用对应于C++中所需类型的玩家对象来填充它。转换由Qt
    Script自动完成。因此，你可以通过使用`QObject`指针并使用它们与暴露给脚本的`QObject`实例来定义方法。以类似的方式，你可以通过使用`QVariant`或`QScriptValue`并使用脚本中的任何值来传递它们来定义函数。如果脚本引擎能够将给定的值转换为请求的类型，它将这样做。
- en: Have a go hero – extending the Dungeons & Dragons game
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试成为英雄 - 扩展龙与地下城游戏
- en: 'Here is a number of ideas that can be used to extend our small game. The first
    is to add a script execution for the player as well so that it tries to defend
    against the creature. For that, you''ll need to expose the creature''s data using
    the `LivingCreature` API so that it is read only and exposes the player using
    a read-write interface. There are many ways to obtain it; the easiest is to provide
    two public `QObject` interfaces that operate on a shared pointer as shown in the
    following diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以用来扩展我们小型游戏的想法。第一个是为玩家添加脚本执行，以便它试图防御生物。为此，你需要使用`LivingCreature` API公开生物的数据，使其只读，并使用读写接口公开玩家。有许多方法可以做到这一点；最简单的方法是提供两个公共`QObject`接口，它们在共享指针上操作，如下面的图所示：
- en: '![Have a go hero – extending the Dungeons & Dragons game](img/8874OS_08_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![尝试成为英雄 - 扩展龙与地下城游戏](img/8874OS_08_06.jpg)'
- en: The API already contains methods to move creatures. You can extend the fighting
    rules to take into consideration the distance between opponents and their relative
    orientation (for example, striking from behind usually yields more damage than
    when standing face-to-face with the enemy). You can even introduce ranged combat.
    Extend the `LivingCreature` interface with the properties and methods that manipulate
    the creature's inventory. Allow the creature to change its active weapon.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: API已经包含了移动生物的方法。你可以扩展战斗规则，考虑对手之间的距离和它们之间的相对方向（例如，从背后攻击通常比面对面攻击造成更多伤害）。你甚至可以引入远程战斗。通过扩展`LivingCreature`接口，添加操作生物存货的属性和方法。允许生物更改其活动武器。
- en: 'The final modification that you can apply is to prevent cheating, using the
    mechanism described earlier. Instead of executing an action immediately, mark
    which action the script has chosen (along with its parameters) and only execute
    that action after the script finishes executing, for example, like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以应用的最后一种修改是防止作弊，使用前面描述的机制。不是立即执行动作，而是标记脚本选择的动作（及其参数），然后在脚本执行完毕后执行该动作，例如，如下所示：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Another approach to this would be to assign action points to each creature's
    every turn and allow the creature to spend them on different actions. If there
    are not enough points left to execute an action, the script is notified about
    this and the action fails.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是给每个生物的每一回合分配行动点，并允许生物将它们用于不同的行动。如果没有足够的点来执行行动，脚本会通知这一点，并且行动失败。
- en: Exposing functions
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露函数
- en: Until now, we have been exporting objects to scripts and calling their properties
    and methods. However, there is also a way to call standalone C++ functions from
    scripts as well as call functions written in JavaScript from within C++ code.
    Let's have a look at how this works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是在导出对象到脚本中，并调用它们的属性和方法。然而，也有一种方法可以从脚本中调用独立的C++函数，以及从C++代码中调用JavaScript编写的函数。让我们看看这是如何工作的。
- en: Exposing C++ functions to scripts
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将C++函数暴露给脚本
- en: 'You can expose a standalone function to Qt Script with the help of the `QScriptEngine::newFunction()`
    call. It returns `QScriptValue` as any function in JavaScript, is also an object,
    and can be represented by `QScriptValue`. In C++, if a function accepts three
    parameters, you have to pass exactly three parameters when calling it. In JavaScript,
    this is different—you can always pass any number of parameters to a function,
    and it is the function''s responsibility to do a proper argument validation. Therefore,
    the actual function that is exported should be wrapped in another function that
    will do what JavaScript expects from it before calling the actual function. The
    wrapper function needs to have an interface that is compatible with what `newFunction()`
    expects. It should take two parameters: the script context and the script engine,
    and it should return `QScriptValue`. The `context` contains all the information
    regarding the parameters of the function, including their count. Let''s try wrapping
    a function that takes two integers and returns their sum:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`QScriptEngine::newFunction()`调用将独立函数暴露给Qt脚本。它返回`QScriptValue`，就像JavaScript中的任何函数一样，也是一个对象，可以用`QScriptValue`表示。在C++中，如果一个函数接受三个参数，那么在调用它时必须传递正好三个参数。在JavaScript中，这不同——您始终可以向函数传递任意数量的参数，并且这是函数的责任进行适当的参数验证。因此，实际导出的函数应该被包装在另一个函数中，该函数将在调用实际函数之前执行JavaScript期望的操作。包装函数需要有一个与`newFunction()`期望兼容的接口。它应该接受两个参数：脚本上下文和脚本引擎，并且应该返回`QScriptValue`。`context`包含有关函数参数的所有信息，包括它们的数量。让我们尝试包装一个接受两个整数并返回它们的和的函数：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have the wrapper, we can create a function object for it and export
    it to the scripting environment in exactly the same way as we export regular objects—by
    making it a property of the script''s global object:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了包装器，我们可以为它创建一个函数对象，并以与导出常规对象相同的方式将其导出到脚本环境中——通过将其作为脚本的全局对象的属性：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second argument to `newFunction()` defines how many arguments the function
    expects and is retrievable with the function object''s length property. This is
    just for your information, as the caller can pass as many arguments as he/she
    wants. Try evaluating the following script after exporting the sum function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`newFunction()`的第二个参数定义了函数期望的参数数量，并且可以通过函数对象的长度属性来获取。这只是供你了解的信息，因为调用者可以传递尽可能多的参数。尝试在导出求和函数之后评估以下脚本：'
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can make use of such behavior and extend the functionality of our `sum`
    function by making it return a sum of all the parameters passed to it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这种行为，通过使`sum`函数返回所有传递给它的参数的总和来扩展其功能：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, you can call the sum with any number of arguments:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以用任意数量的参数调用求和函数：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This brings us to an interesting question: can the function have different
    functionality depending on how many parameters you pass to it? The answer is positive;
    you can implement the function in any way you want, with the whole power of C++
    at hand. There is a specific case for JavaScript when such behavior makes particular
    sense. This is when the function is supposed to work as a getter and setter for
    a property. Getters and setters are functions that are called when the script
    wants to retrieve or set the value of a property in some object. By attaching
    getters and setters to objects, you can control where the value is stored (if
    at all) and how it is retrieved. This opens the possibility of adding properties
    to the exported Qt objects that have not been declared with the `Q_PROPERTY` macro:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个有趣的问题：函数的功能是否可以根据传递给它的参数数量而有所不同？答案是肯定的；你可以以任何你想要的方式实现函数，利用 C++ 的全部功能。对于
    JavaScript，当这种行为特别有意义时，有一个特定的案例。这就是当函数应该作为属性的获取器和设置器工作时。获取器和设置器是在脚本想要检索或设置某个对象的属性值时调用的函数。通过将获取器和设置器附加到对象上，你可以控制值存储的位置（如果有的话）以及如何检索它。这为向导出的
    Qt 对象添加未使用 `Q_PROPERTY` 宏声明的属性打开了可能性：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s analyze this code; here, we expose an instance of `CustomObject` to
    the script engine in a standard way. We also set the object''s value property
    to a function, passing an additional value to `setProperty()`, which contains
    a set of flags that tell the scripting environment how it should treat the property.
    In this case, we tell it that the passed value should be used as a getter and
    setter for the property. Let''s see how the function itself is implemented:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这段代码；在这里，我们以标准方式将 `CustomObject` 的一个实例暴露给脚本引擎。我们还设置了对象的值属性为一个函数，通过传递额外的值给
    `setProperty()`，其中包含一组标志，告诉脚本环境如何处理该属性。在这种情况下，我们告诉它传递的值应用作属性的获取器和设置器。让我们看看函数本身是如何实现的：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, we ask the function the context for the value representing the object
    that the function is called on. Then, we extract a `CustomObject` pointer from
    it using `qobject_cast`. Next, we check the number of arguments to the function
    call. In the case of a setter, the function is passed one parameter—the value
    to be set to the property. In such a situation, we use a C++ method of the object
    to apply that value to the object. Otherwise, (no arguments are passed) the function
    is used as a getter and we return the value after fetching it with the C++ method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要求函数提供表示被调用函数的对象的值的上下文。然后，我们使用 `qobject_cast` 从其中提取一个 `CustomObject` 指针。接下来，我们检查函数调用的参数数量。在设置器的情况下，函数传递一个参数——要设置到属性中的值。在这种情况下，我们使用对象的
    C++ 方法来应用该值。否则，（没有传递参数）函数用作获取器，我们使用 C++ 方法获取值后返回。
- en: Exposing script functions to C++
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将脚本函数暴露给 C++
- en: 'In the same way as C++ functions are exported to Qt Script with the use of
    `QScriptValue`, JavaScript functions can be imported to C++. You can ask for a
    script value representing a function like any other property. The following code
    asks the engine for the `Math.pow()` function, which performs the power operation
    on its arguments:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `QScriptValue` 将 C++ 函数导出为 Qt Script 的方式相同，JavaScript 函数也可以导入到 C++ 中。你可以像请求任何其他属性一样请求表示函数的脚本值。以下代码请求引擎的
    `Math.pow()` 函数，该函数对其参数执行幂运算：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Having `QScriptValue` represent a function, you can invoke it using the value''s
    `call()` method and pass any parameters as a list of script values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让 `QScriptValue` 表示一个函数，你可以使用值的 `call()` 方法来调用它，并将任何参数作为脚本值列表传递：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first parameter to `call()` is the value that is to be used as the `this`
    object of the function. In this particular case, we pass an empty object since
    the function is standalone—it does not make any use of its environment. There
    are situations, however, when you will want to set an existing object here, for
    example, to allow a function to directly access the existing properties or define
    new properties of an object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()` 的第一个参数是要用作函数的 `this` 对象的值。在这个特定的情况下，我们传递一个空对象，因为该函数是独立的——它没有使用其环境。然而，有些情况下，你可能想要在这里设置一个现有的对象，例如，允许函数直接访问现有的属性或定义对象的新的属性。'
- en: Let's use the newly learned functionality to improve our Dungeons & Dragons
    game in order to use a richer set of scripting functionality that is based on
    JavaScript functions and properties. The script used will contain a set of functions
    written in JavaScript that are going to be stored in the program and called in
    various situations. We'll be focusing here only on the scripting part. You will
    surely be able to fill in the C++ gaps yourself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用新学的功能来改进我们的《龙与地下城》游戏，以便使用基于JavaScript函数和属性的更丰富的脚本功能集。使用的脚本将包含一组用JavaScript编写的函数，这些函数将被存储在程序中并在各种情况下调用。在这里，我们只关注脚本部分。你肯定能够自己填补C++的空白。
- en: Time for action – storing the script
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 存储脚本
- en: 'The first task is to read the script, extract the needed functions from it,
    and store them in a safe place. Then, load the project for the game and add a
    new class with the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是阅读脚本，从中提取所需的函数，并将它们存储在安全的地方。然后，加载游戏项目并添加一个包含以下代码的新类：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The reading method can have the same content as the original `readScriptFromFile`
    method. The evaluate method looks as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 读取方法可以与原始的`readScriptFromFile`方法具有相同的内容。评估方法如下：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Modify the `GameEngine` class to make use of the new code (remember to add
    the `m_ai` class member):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`GameEngine`类以使用新代码（记得添加`m_ai`类成员）：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the program by feeding it the following script:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下脚本运行程序：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*What just happened?*'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `AIScript` object contains information about the AI for a single entity.
    The `start()` method now loads a script from the file and evaluates it. The script
    is expected to define a number of functions that are then retrieved from the activation
    object and stored in the `AIScript` object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`AIScript`对象包含单个实体的AI信息。`start()`方法现在从文件中加载脚本并评估它。脚本预计将定义多个函数，然后从激活对象中检索并存储在`AIScript`对象中。'
- en: Time for action – providing an initialization function
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 提供初始化函数
- en: 'The task for this exercise is to make it possible for the AI to initialize
    itself by invoking the `init()` function. Let''s get right down to business. Extend
    the `AIScript` structure with yet another field:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的任务是使AI能够通过调用`init()`函数来初始化自己。让我们直接进入正题。将另一个字段扩展到`AIScript`结构中：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This object will represent the AI itself. The script will be able to store
    data or define functions in it. Add the following code to the class as well:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象将代表AI本身。脚本将能够存储数据或在其中定义函数。同时也要在类中添加以下代码：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a call to `initialize()` at the end of `start()`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start()`的末尾添加对`initialize()`的调用：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, run the program using the following `init()` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下`init()`函数运行程序：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*What just happened?*'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In initialize, we prepare the script object with an empty JavaScript object
    and we call the function stored in `initFunction`, passing the script object as
    this. The function prints a debug statement and defines two properties in this
    object—one is a function to calculate the Manhattan distance and the other is
    an empty array where we will store a history of actions that the AI has taken.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化中，我们使用一个空的JavaScript对象准备脚本对象，并调用存储在`initFunction`中的函数，将脚本对象作为`this`传递。该函数打印一个调试语句，并在该对象中定义两个属性——一个是计算曼哈顿距离的函数，另一个是空的数组，我们将在这里存储AI所采取的行动历史。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Manhattan distance is a metric to calculate the distance between objects; this
    is much faster to calculate than the real Euclidean distance. It is based on the
    assumption that when traversing a large city with a grid of buildings, one can
    only follow streets that go along those buildings and take 90 degree turns. The
    Manhattan distance between positions is then the number of crossings one has to
    walk through to get from the source to the destination. In C++ and Qt, you can
    compute this distance easily using the `manhattanLength()` method in the `QPoint`
    class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 曼哈顿距离是一种计算物体之间距离的度量标准；这比计算实际的欧几里得距离要快得多。它基于这样的假设：当穿越一个由建筑网格组成的大城市时，人们只能沿着那些建筑物的街道行走，并作90度转弯。两个位置之间的曼哈顿距离就是一个人必须走过的交叉路口数量，才能从源点到达目的地。在C++和Qt中，你可以使用`QPoint`类中的`manhattanLength()`方法轻松计算这个距离。
- en: Time for action – implementing the heartbeat event
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 实现心跳事件
- en: 'The heart of AI is the heartbeat function that is executed at equal intervals
    of time to allow the AI to decide about the actions of the object. The script
    that is executed will have access to the creature that it operates on as well
    as its environment. It can also use anything that it defines in the `this` object.
    Now, add a heartbeat function to `AIScript`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: AI的核心是心跳函数，它在相等的时间间隔内执行，以允许AI决定对象的行为。执行的脚本将能够访问它操作的生物以及其环境。它还可以使用在`this`对象中定义的任何内容。现在，向`AIScript`添加一个心跳函数：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Bring the timer back, set it to `start()`, and also enable the running heartbeat
    functionality from within the timer event:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将计时器恢复，设置为`start()`，并在计时器事件中启用运行心跳功能：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the program, giving it the following `heartbeat` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，给它以下`heartbeat`函数：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*What just happened?*'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In `heartbeat`, we proceed in similar way as with `init`, but here, we pass
    the creature that the AI works on as a parameter of the function and we set the
    other entity as the enemy property of the `this` object, which makes it accessible
    to the function. After the call we remove the enemy property from the this object.
    The function itself performs an attack on the enemy and pushes an entry to the
    script object history. Unlike a direct invocation of evaluate when making a function
    call we don't have to push and pop an execution context as it is done for us automatically
    during `QScriptValue::call`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`heartbeat`中，我们以与`init`类似的方式进行，但在这里，我们将AI工作的生物作为函数的参数传递，并将其他实体设置为`this`对象的敌人属性，使其对函数可访问。调用后，我们从`this`对象中删除敌人属性。该函数本身对敌人进行攻击，并将条目推送到脚本对象历史记录。与在函数调用时直接调用evaluate不同，我们不需要推送和弹出执行上下文，因为这是在`QScriptValue::call`期间自动为我们完成的。
- en: Have a go hero – defending against attacks
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试成为英雄——防御攻击
- en: You may have noticed that we left out the defend script. Try extending the game
    by calling a script whenever the subject is attacked by the opponent. In the script,
    allow the creature to take different defensive stances, such as evading, blocking,
    or parrying attacks. Make each action have a different influence on the outcome
    of the strike. Also, apply all the modifications that you made to the original
    game. Try expanding on the code that was already written by providing additional
    hooks where scripts are run and adding new actions and objects. How about adding
    more enemies to the game? What about organizing a contest for the best AI algorithm?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们省略了防御脚本。尝试通过在主体被对手攻击时调用脚本来扩展游戏。在脚本中，允许生物采取不同的防御姿态，例如躲避、阻挡或格挡攻击。让每个动作对攻击结果产生不同的影响。此外，应用你对原始游戏所做的所有修改。尝试通过提供额外的钩子来扩展已编写的代码，在脚本运行时添加新动作和对象。给游戏添加更多敌人怎么样？组织一场最佳AI算法竞赛如何？
- en: Using signals and slots in scripts
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在脚本中使用信号和槽
- en: Qt Script also offers the capability to use signals and slots. The slot can
    be either a C++ method or a JavaScript function. The connection can be made either
    in C++ or in the script.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Qt脚本还提供了使用信号和槽的能力。槽可以是C++方法或JavaScript函数。连接可以在C++或脚本中进行。
- en: 'First, let''s see how to establish a connection within a script. When a `QObject`
    instance is exposed to a script, the object''s signals become the properties of
    the wrapping object. These properties have a `connect` method that accepts a function
    object that is to be called when the signal is emitted. The receiver can be a
    regular slot or a JavaScript function. To connect the `clicked()` signal of an
    object called `button` to a `clear()` slot of another object called `lineEdit`,
    you can use the following statement:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何在脚本内部建立连接。当一个`QObject`实例暴露给脚本时，对象信号成为包装对象的属性。这些属性有一个`connect`方法，它接受一个函数对象，当信号被发射时将被调用。接收者可以是常规槽或JavaScript函数。要将名为`button`的对象的`clicked()`信号连接到名为`lineEdit`的另一个对象的`clear()`槽，可以使用以下语句：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If the receiver is a standalone function called `clearLineEdit`, the call becomes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收者是名为`clearLineEdit`的独立函数，调用变为：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can also connect a signal to an anonymous function that was defined directly
    in the connection statement:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将信号连接到一个直接在连接语句中定义的匿名函数：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There is additional syntax available where you can define the `this` object
    for the function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有额外的语法可用，其中可以定义函数的`this`对象：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you need to disconnect a signal from within a script, just replace `connect`
    with `disconnect`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在脚本内部断开信号，只需将`connect`替换为`disconnect`：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Emitting signals from within the script is also easy—just call the signal as
    a function and pass to it any necessary parameters:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中发出信号也很简单——只需将信号作为函数调用，并传递任何必要的参数：
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To create a signal-slot connection on the C++ side where the receiver is a
    script function, instead of a regular `connect()` statement, use `qScriptConnect()`.
    Its first two parameters are identical with the regular call and the two other
    parameters correspond to a script value that represents an object that is to act
    as the `this` object and a script value that represents a function to be called:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 C++ 端创建一个接收器为脚本函数的信号-槽连接，而不是使用常规的 `connect()` 语句，请使用 `qScriptConnect()`。它的前两个参数与常规调用相同，另外两个参数对应于表示将作为
    `this` 对象的对象的脚本值和表示要调用的函数的脚本值：
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this particular example, we pass an invalid object as the third parameter.
    In such a case, the `this` object will point to the engine's global object.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们将一个无效的对象作为第三个参数传递。在这种情况下，`this` 对象将指向引擎的全局对象。
- en: As for disconnecting signals, of course, there is `qScriptDisconnect()` available.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 至于断开信号，当然，有 `qScriptDisconnect()` 可用。
- en: Have a go hero – triggering defense using signals and slots
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——使用信号和槽触发防御
- en: As a task for yourself, try modifying the Dungeons & Dragons game so that the
    defend script function is not called manually by the script engine, but instead
    is invoked using a signal-slot connection. Have a creature emit the `attacked()`
    signal when it is attacked, and let the script connect a handler to that signal.
    Use a variant of connect that defines the `this` object for the connection.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项任务，尝试修改《龙与地下城》游戏，使得防御脚本函数不是由脚本引擎手动调用，而是通过信号-槽连接来调用。当生物被攻击时，让生物发出 `attacked()`
    信号，并让脚本连接一个处理程序到该信号。使用定义了连接 `this` 对象的连接变体。
- en: Creating Qt objects in scripts
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在脚本中创建 Qt 对象
- en: Using existing objects from scripts sometimes is not enough to get a rich scripting
    experience. It is also useful to be able to create new Qt objects from within
    scripts and even return them to C++ so that they can be used by the game engine.
    There are two ways to approach this problem. Before we describe them, it is important
    to understand how JavaScript instantiates objects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本中有时使用现有的对象并不足以获得丰富的脚本体验。同时能够从脚本中创建新的 Qt 对象，甚至将它们返回到 C++ 中以便游戏引擎使用，也是非常有用的。解决这个问题有两种方法。在我们描述它们之前，了解
    JavaScript 如何实例化对象是很重要的。
- en: JavaScript has no notion of classes. It constructs objects using prototypes—a
    prototype is an object whose properties are cloned into the new object. The object
    is constructed by invoking a constructor, which can be any function. When you
    invoke a function using the keyword new, the engine creates a new empty object,
    sets its constructor property to the function serving as the constructor, sets
    the object prototype to the function's prototype, and finally, invokes the function
    in the context of the new object, making that function act as a factory function
    for objects with a particular set of properties. Therefore, to construct objects
    of the type `QLineEdit`, there needs to be a function that can be called as a
    constructor for objects that behave like Qt's widget to enter a single line of
    text.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 没有类这个概念。它使用原型来构建对象——原型是一个其属性被克隆到新对象中的对象。对象通过调用构造函数来构建，构造函数可以是任何函数。当你使用关键字
    new 调用一个函数时，引擎会创建一个新的空对象，将其构造函数属性设置为作为构造函数的函数，将对象原型设置为该函数的原型，并最终在新的对象上下文中调用该函数，使该函数作为具有特定属性集的对象的工厂函数。因此，要构建
    `QLineEdit` 类型的对象，需要有一个可以作为类似 Qt 小部件对象行为的构造函数的函数。
- en: 'We already know that functions can be stored in `QScriptValue` objects. There
    are two ways to obtain a function that can act as a constructor for Qt objects.
    First, we can implement it ourselves:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道函数可以存储在 `QScriptValue` 对象中。有两种方法可以获得可以作为 Qt 对象构造函数的函数。首先，我们可以自己实现它：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We did three things here. First, we defined a function that instantiates `QPushButton`
    with a parent passed as the first argument to the function, wraps the object in
    `QScriptValue` (with an extra parameter noting that the environment responsible
    for deleting the object should be determined by the parent object), and that returns
    `QScriptValue` to the caller. Secondly, we wrapped the function itself into `QScriptValue`
    as we already did earlier with other functions. Finally, we set the function as
    a property of the global object of the engine so that it is always accessible.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们做了三件事。首先，我们定义了一个函数，该函数使用作为函数第一个参数传递的父对象实例化 `QPushButton`，将对象包装在 `QScriptValue`
    中（带有一个额外的参数，指出负责删除对象的环境应由父对象确定），并将 `QScriptValue` 返回给调用者。其次，我们将该函数本身包装在 `QScriptValue`
    中，就像我们之前对其他函数所做的那样。最后，我们将该函数设置为引擎的全局对象的一个属性，以便始终可以访问。
- en: 'The second way to obtain a constructor function is to make use of Qt''s meta-object
    system. You can use the following macro to define a constructor function very
    similar to what we have written manually:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 获取构造函数的第二种方式是利用 Qt 的元对象系统。你可以使用以下宏来定义一个与手动编写的非常相似的构造函数：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, you can use the `QScriptEngine::scriptValueFromQMetaObject()` template
    method to get a script value wrapping that function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用 `QScriptEngine::scriptValueFromQMetaObject()` 模板方法来获取包装该函数的脚本值：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Lastly, you can set the obtained script value as a constructor in the script
    engine just like before. Here is a complete code to make push buttons creatable
    from within the scripts:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以像之前一样将获得的脚本值设置为脚本引擎中的构造函数。以下是一个完整的代码示例，用于在脚本中创建可创建的按钮：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Error recovery and debugging
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误恢复和调试
- en: 'The only error recovery we''ve talked about so far is checking whether a script
    has ended up with an error and executing a script in a dedicated context to prevent
    polluting the namespace with local variables that are not used anymore. This is
    already a lot; however, we can do more. First, we can take care of preventing
    pollution of the global namespace. Pushing and popping the execution context does
    not prevent a script from modifying the engine''s global object, and we should
    prevent situations when a script, for example, replaces the `Math` object or the
    print function. The solution is to provide your own global object in place of
    the original one. There are two easy ways to do this. First, you can use the class
    called `QScriptValueIterator` to copy all the properties of the global object
    to a new object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的唯一错误恢复是检查脚本是否最终出现错误，并在专用上下文中执行脚本以防止将不再使用的局部变量污染命名空间。这已经很多了；然而，我们还可以做更多。首先，我们可以注意防止全局命名空间的污染。推送和弹出执行上下文并不能阻止脚本修改引擎的全局对象，我们应该防止脚本，例如，替换
    `Math` 对象或打印函数的情况。解决方案是提供自己的全局对象来替代原始的一个。有两种简单的方法可以做到这一点。首先，你可以使用名为 `QScriptValueIterator`
    的类来复制全局对象的所有属性到一个新对象：
- en: '[PRE57]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Alternatively, you can set the original global object as an internal prototype
    of the new object:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将原始的全局对象设置为新对象的内部原型：
- en: '[PRE58]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Either way, you will then need to replace the original global object with the
    temporary one:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，你都需要用临时对象替换原始的全局对象：
- en: '[PRE59]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The other big thing to do when talking about error recovery is to provide debugging
    capabilities for scripts. Luckily, Qt contains a built-in component to debug scripts.
    If you build your project with the `QT+=scripttools` option, you will gain access
    to the `QScriptEngineDebugger` class. To start using the debugger with a script
    engine, you need to attach and bind them:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论错误恢复时，另一件要做的大事是为脚本提供调试功能。幸运的是，Qt 包含一个内置的脚本调试组件。如果你使用 `QT+=scripttools` 选项构建项目，你将能够访问
    `QScriptEngineDebugger` 类。要开始使用脚本引擎的调试器，你需要将它们附加并绑定：
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Whenever an uncaught exception occurs, the debugger will kick in and show its
    window:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生未捕获的异常时，调试器将启动并显示其窗口：
- en: '![Error recovery and debugging](img/8874OS_08_07.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![错误恢复和调试](img/8874OS_08_07.jpg)'
- en: You can then set breakpoints in the script, inspect variables or the call stack,
    and continue or break the execution. A good idea is to incorporate the debugger
    in your game so that script designers can use it when developing scripts. Of course,
    the debugger should not be running with the release version of the game.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在脚本中设置断点，检查变量或调用栈，并继续或中断执行。一个好的想法是将调试器集成到你的游戏中，以便脚本设计者在开发脚本时可以使用它。当然，调试器不应该在游戏的发布版本中运行。
- en: Extensions
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展
- en: '`QScriptEngine` has the ability to import extensions that provide additional
    functionality to the scripting environment (for example, a library of utility
    functions that can be used in different parts of the game without having to redefine
    them here and there) using the `importExtension()` method. The extension can be
    implemented in JavaScript by providing a set of files that contain scripts, making
    the extension or in C++ by subclassing `QScriptExtensionPlugin`. Now, we will
    focus on the second approach. Here is how a simple C++ extension looks:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`QScriptEngine` 具有使用 `importExtension()` 方法导入扩展的能力，这些扩展为脚本环境提供附加功能（例如，可以在游戏的不同部分使用而无需在这里和那里重新定义的实用函数库）。扩展可以通过提供包含脚本的文件集以
    JavaScript 实现或通过从 `QScriptExtensionPlugin` 派生以 C++ 实现。现在，我们将关注第二种方法。以下是一个简单的 C++
    扩展的示例：'
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The extension defined here is simple—it only attaches one property to the engine''s
    global object, which has a name property returning as a text string. You should
    put the resulting library in a subdirectory called `Simple` in a script subdirectory
    of a directory where your application looks for plugins (for example, the application
    where your application binary is placed). Then, you can import the plugin using
    `importExtension()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处定义的扩展很简单——它只向引擎的全局对象附加一个属性，该属性返回一个文本字符串的名称属性。你应该将生成的库放在一个名为 `Simple` 的子目录中，该子目录位于应用程序查找插件的脚本子目录中的目录（例如，放置应用程序二进制文件的应用程序）。然后，你可以使用
    `importExtension()` 导入插件：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Refer to the *Deploying Plugins* section of the Qt reference manual for more
    information about where you can put plugins and how you can tell Qt where to look
    for them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有关插件放置位置以及如何告诉 Qt 在何处查找它们的信息，请参阅 Qt 参考手册中的 *部署插件* 部分。
- en: The other Qt JavaScript environment
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 Qt JavaScript 环境
- en: 'As mentioned at the beginning of this chapter, Qt provides two environments
    to use JavaScript. We already talked about Qt Script; now it is time for us to
    tell you about its counterpart: `QJSEngine`. The newer JavaScript engine in Qt,
    which is also used for QML, about which you will learn in the next chapter. It
    has a different internal architecture than Qt Script, but most of what we have
    taught you also applies to `QJSEngine`. The main difference is that the root classes
    are named differently. Have a look at the following table, which shows equivalent
    classes for the two engines:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，Qt 提供了两个环境来使用 JavaScript。我们已经讨论了 Qt Script；现在是时候告诉我们它的对应物：`QJSEngine`。Qt
    中较新的 JavaScript 引擎，它也用于 QML（你将在下一章中学习），它具有与 Qt Script 不同的内部架构，但我们所教授的大部分内容也适用于
    `QJSEngine`。主要区别在于根类的命名不同。请查看以下表格，其中显示了两个引擎的等效类：
- en: '| QtScript | QJSEngine |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| QtScript | QJSEngine |'
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `QScriptEngine` | `QJSEngine` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `QScriptEngine` | `QJSEngine` |'
- en: '| `QScriptValue` | `QJSValue` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `QScriptValue` | `QJSValue` |'
- en: '| `QScriptContext` | `–` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `QScriptContext` | `–` |'
- en: The `QJSEngine` class is the equivalent of `QScriptEngine`. It also has an `evaluate()`
    method that is used to evaluate scripts. This method can create objects, wrap
    `QObject` instances, and use `QJSValue` (the equivalent of `QScriptValue`) to
    store values used in scripts in a way that they can be accessed from C++. You
    can also see that there is no equivalent to `QScriptContext` and thus its functionality
    is not available in the implementation based on `QJSEngine`. Another missing component
    is the integrated engine debugger. Also, at the time of writing, there is no easy
    way to export your own classes to the `QJSEngine`-based JavaScript environment
    to allow the creation of instances of those classes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`QJSEngine` 类相当于 `QScriptEngine`。它还有一个 `evaluate()` 方法，用于评估脚本。此方法可以创建对象，包装
    `QObject` 实例，并使用 `QJSValue`（相当于 `QScriptValue`）以这种方式存储脚本中使用的值，以便可以从 C++ 访问它们。你还可以看到没有
    `QScriptContext` 的等效项，因此其功能在基于 `QJSEngine` 的实现中不可用。另一个缺失的组件是集成引擎调试器。此外，在撰写本文时，没有简单的方法可以将自己的类导出到基于
    `QJSEngine` 的 JavaScript 环境中，以允许创建这些类的实例。'
- en: Alternatives to JavaScript
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 的替代方案
- en: Qt Script is an environment that is designed to be part of the Qt world. Since
    not everyone knows or likes JavaScript, we will present another language that
    can easily be used to provide scripting environments for games that are created
    with Qt. Just be aware that this is not going to be an in-depth description of
    the environment—we will just show you the basics that can provide foundations
    for your own research.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 脚本是一个设计成 Qt 世界一部分的环境。由于不是每个人都了解或喜欢 JavaScript，我们将介绍另一种可以轻松用于为使用 Qt 创建的游戏提供脚本环境的语言。只是请注意，这不会是对环境的深入描述——我们只会展示一些基础知识，这些知识可以为你的研究提供基础。
- en: Python
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python
- en: 'A popular language used for scripting is Python. There are two variants of
    Qt bindings that are available for Python: PySide and PyQt. PySide is the official
    binding that is available under LGPL, but currently, it only work with Qt 4\.
    PyQt is a third-party library that is available under GPL v3 and commercial licenses
    that have variants for Qt 4 as well as Qt 5\. Note that PyQt is not available
    under LGPL, so for commercial closed-source products you need to obtain a commercial
    license from Riverbank Computing!'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 用于脚本的一种流行语言是 Python。Python 有两种可用于 Python 的 Qt 绑定：PySide 和 PyQt。PySide 是官方绑定，可在
    LGPL 下使用，但目前仅适用于 Qt 4。PyQt 是一个第三方库，可在 GPL v3 和商业许可证下使用，有适用于 Qt 4 和 Qt 5 的变体。请注意，PyQt
    不在 LGPL 下可用，因此对于商业闭源产品，你需要从 Riverbank Computing 获得商业许可证！
- en: These bindings allow you to use the Qt API from within Python—you can write
    a complete Qt application using just Python. However, to call Python code from
    within C++, you will need a regular Python interpreter. Luckily, it is very easy
    to embed such an interpreter in a C++ application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定允许你在 Python 中使用 Qt API——你可以仅使用 Python 编写一个完整的 Qt 应用程序。然而，要从 C++ 中调用 Python
    代码，你需要一个标准的 Python 解释器。幸运的是，在 C++ 应用程序中嵌入这样的解释器非常简单。
- en: 'First, you will need Python installed along with its development package. For
    example, for Debian-based systems, it is easiest to simply install the `libpythonX.Y-dev`
    (or a newer) package, where `X` and `Y` stand for the version of Python:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装 Python 以及其开发包。例如，对于基于 Debian 的系统，最简单的方法是简单地安装 `libpythonX.Y-dev`（或更新的版本）包，其中
    `X` 和 `Y` 代表 Python 的版本：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, you need to tell your program to link it against the library:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要告诉你的程序链接到这个库：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To call Python code from within a Qt app, the simplest way is to use the following
    code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Qt 应用程序中调用 Python 代码，最简单的方法是使用以下代码：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This code initializes a Python interpreter, then invokes a script by passing
    it directly as a string, and finally, it shuts down the interpreter before invoking
    Qt's event loop. Such code makes sense only for simple scripting. In real life,
    you'd want to pass some data to the script or fetch the result. For that, we have
    to write some more code. As the library exposes the C API only, let's write a
    nice Qt wrapper for it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码初始化一个 Python 解释器，然后通过直接传递字符串来调用脚本，最后在调用 Qt 的事件循环之前关闭解释器。这样的代码只适用于简单的脚本。在现实生活中，你可能会想向脚本传递一些数据或获取结果。为此，我们必须编写更多的代码。由于库仅公开
    C API，让我们为它编写一个漂亮的 Qt 封装器。
- en: Time for action – writing a Qt wrapper for embedding Python
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候编写一个用于嵌入 Python 的 Qt 封装器了
- en: 'As the first task, we will implement the last program using an object-oriented
    API. Create a new console project and add the following class to it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个任务，我们将使用面向对象的 API 实现最后一个程序。创建一个新的控制台项目，并向其中添加以下类：
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, add a `main()` function as shown in the following snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加一个 `main()` 函数，如下面的代码片段所示：
- en: '[PRE67]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally open the `.pro` file and tell Qt to link with the Python library. In
    case of Linux you can use `pkg-config` by adding two lines to the file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后打开 `.pro` 文件，并告诉 Qt 链接到 Python 库。在 Linux 的情况下，你可以通过向文件中添加两行来使用 `pkg-config`：
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You might need to install Python library using a call equivalent to `apt-get
    install libpython3.4-dev`. For Windows you need to manually pass information to
    the compiler:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要使用类似于 `apt-get install libpython3.4-dev` 的调用安装 Python 库。对于 Windows，你需要手动将信息传递给编译器：
- en: '[PRE69]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '*What just happened?*'
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created a class called `QtPython` that wraps the Python C API for us.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `QtPython` 的类，它为我们封装了 Python C API。
- en: Tip
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Never use a `Q` prefix to call your custom classes, as this prefix is reserved
    for official Qt classes. This is to make sure that your code will never have a
    name clash with future code added to Qt. The Qt prefix on the other hand is meant
    to be used with classes that are extensions to Qt. You probably still shouldn't
    use it, but the probability of a name clash is much smaller and yields a lesser
    impact than clashes with an official class. It is best to come up with your own
    prefix (such as `Qxy`, where `x` and `y` are your initials).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用 `Q` 前缀来调用你的自定义类，因为这个前缀是为官方 Qt 类保留的。这是为了确保你的代码永远不会与 Qt 中将来添加的代码发生名称冲突。另一方面，Qt
    前缀是用来与 Qt 的扩展类一起使用的。你可能仍然不应该使用它，但名称冲突的概率要小得多，影响也较小。最好想出一个自己的前缀（例如 `Qxy`，其中 `x`
    和 `y` 是你的首字母）。
- en: The class constructor creates a Python interpreter and the class destructor
    destroys it. We use `Py_InitializeEx(0)`, which has the same functionality as
    `Py_Initialize()`, but it does not apply C signal handlers, as this is not something
    we would want when embedding Python. Prior to this, we use `Py_SetProgramName()`
    to inform the interpreter of our context. We also defined a `run()` method, taking
    `QString` and returning `void`. It uses `qPrintable()`, which is a convenience
    function that extracts a C string pointer from a `QString` object, which is then
    fed into `PyRun_SimpleString()`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数创建一个 Python 解释器，类析构函数销毁它。我们使用 `Py_InitializeEx(0)`，它具有与 `Py_Initialize()`
    相同的功能，但它不会应用 C 信号处理器，因为在嵌入 Python 时我们不会想要这样做。在此之前，我们使用 `Py_SetProgramName()` 通知解释器我们的上下文。我们还定义了一个
    `run()` 方法，它接受 `QString` 并返回 `void`。它使用 `qPrintable()`，这是一个便利函数，它从 `QString` 对象中提取一个
    C 字符串指针，然后将其输入到 `PyRun_SimpleString()`。
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Never store the output of `qPrintable()` as it returns an internal pointer to
    a temporary byte array (this is equivalent to calling `toLocal8Bit().constData()`
    on a string). It is safe to use directly, but the byte array is destroyed immediately
    afterwards; thus, if you store the pointer in a variable, the data may not be
    valid later when you try using that pointer.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要存储 `qPrintable()` 的输出，因为它返回一个指向临时字节数组的内部指针（这相当于在字符串上调用 `toLocal8Bit().constData()`）。它可以安全地直接使用，但字节数组随后立即被销毁；因此，如果你将指针存储在变量中，当你在稍后尝试使用该指针时，数据可能不再有效。
- en: The hardest work when using embedded interpreters is to convert values between
    C++ and the types that the interpreter expects. With Qt Script, the `QScriptValue`
    type was used for this. We can implement something similar for our Python scripting
    environment.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌入式解释器时最困难的工作是将值在 C++ 和解释器期望的类型之间进行转换。在 Qt Script 中，使用了 `QScriptValue` 类型来完成这项工作。我们可以为我们的
    Python 脚本环境实现类似的功能。
- en: Time for action – converting data between C++ and Python
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 在 C++ 和 Python 之间转换数据
- en: 'Create a new class and call it `QtPythonValue`. Then, add the following code
    to it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，并将其命名为 `QtPythonValue`。然后，向其中添加以下代码：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, let''s modify the `main()` function to test our new code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们修改 `main()` 函数以测试我们的新代码：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When you run the program, you will see that the conversion between C++ and Python
    works correctly in both directions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会看到 C++ 和 Python 之间的转换在两个方向上都是正确的。
- en: '*What just happened?*'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'The `QtPythonValue` class wraps a `PyObject` pointer (through the `m_value`
    member), providing a nice interface to convert between what the interpreter expects
    and our Qt types. Let''s see how this is done. First, take a look at the three
    private methods: two versions of `incRef()` and one `decRef()`. `PyObject` contains
    an internal reference counter that counts the number of handles on the contained
    value. When that counter drops to `0`, the object can be destroyed. Our three
    methods use adequate Python C API calls to increase or decrease the counter in
    order to prevent memory leaks and keep Python''s garbage collector happy.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtPythonValue` 类封装了一个 `PyObject` 指针（通过 `m_value` 成员），提供了一个良好的接口，用于在解释器期望的类型和我们的
    Qt 类型之间进行转换。让我们看看这是如何实现的。首先，看一下三个私有方法：两个版本的 `incRef()` 和一个 `decRef()`。`PyObject`
    包含一个内部引用计数器，它计算包含值的句柄数量。当计数器降至 `0` 时，对象可以被销毁。我们的三个方法使用适当的 Python C API 调用来增加或减少计数器，以防止内存泄漏并使
    Python 的垃圾回收器保持满意。'
- en: The second important aspect is that the class defines a private constructor
    that takes a `PyObject` pointer, effectively creating a wrapper over the given
    value. The constructor is private; however, the `QtPython` class is declared as
    a friend of `QtPythonValue`, which means that only `QtPython` and `QtPythonValue`
    can instantiate values by passing `PyObject` pointers to it. Now, let's have a
    look at public constructors.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要方面是，该类定义了一个私有构造函数，它接受一个`PyObject`指针，实际上是在给定值上创建了一个包装器。构造函数是私有的；然而，`QtPython`类被声明为`QtPythonValue`的朋友，这意味着只有`QtPython`和`QtPythonValue`可以通过传递`PyObject`指针来实例化值。现在，让我们看看公共构造函数。
- en: The default constructor creates an object pointing to a `None` value, which
    is Python's equivalent to the C++ null. The copy constructor and assignment operator
    are pretty standard, taking care of bookkeeping of the reference counter. Then,
    we have two constructors—one taking `int` and the other taking a `QString` value.
    They use appropriate Python C API calls to obtain a `PyObject` representation
    of the value. Note that these calls already increase the reference count for us,
    so we don't have to do it ourselves.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数创建了一个指向`None`值的对象，这是Python中C++空值的等价物。复制构造函数和赋值运算符相当标准，负责管理引用计数。然后，我们有两个构造函数——一个接受`int`类型，另一个接受`QString`值。它们使用适当的Python
    C API调用来获取值的`PyObject`表示形式。请注意，这些调用已经为我们增加了引用计数，所以我们不需要自己操作。
- en: The code ends with a destructor that decreases the reference counter and three
    methods that provide safe conversions from `QtPythonValue` to appropriate Qt/C++
    types.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以一个析构函数结束，该析构函数减少引用计数，以及三个提供从`QtPythonValue`到适当Qt/C++类型安全转换的方法。
- en: Have a go hero – implementing the remaining conversions
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大胆尝试英雄——实现剩余的转换
- en: 'Now, you should be able to implement other constructors and conversions for
    `QtPythonValue` that operates on the `float`, `bool`, or even on `QDate` and `QTime`
    types. Try implementing them yourself. If needed, have a look at [https://docs.python.org/3/](https://docs.python.org/3/)
    to find appropriate calls that you should use. We''ll give you a head start by
    providing a skeleton implementation of how to convert `QVariant` to `QtPythonValue`.
    This is especially important because Python makes use of two types whose equivalents
    are not available in C++, namely, tuples and dictionaries. We will need them later,
    so having a proper implementation is crucial. Here is the code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够实现`QtPythonValue`的其他构造函数和转换，它操作的是`float`、`bool`类型，甚至是`QDate`和`QTime`类型。尝试自己实现它们。如果需要，查看[https://docs.python.org/3/](https://docs.python.org/3/)以找到您应该使用的适当调用。我们将通过提供一个如何将`QVariant`转换为`QtPythonValue`的骨架实现来给您一个先手。这尤其重要，因为Python使用了两种在C++中不可用的类型，即元组和字典。我们稍后会需要它们，所以有一个合适的实现是至关重要的。以下是代码：
- en: '[PRE72]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The highlighted code shows how to create a tuple (which is a list of arbitrary
    elements) from `QVariantList` and how to create a dictionary (which is an associative
    array) from `QVariantMap`. Try adding constructors by taking `QStringList`, `QVariantList`,
    and `QVariantMap` directly and returning tuples or a dictionary, respectively.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码显示了如何从`QVariantList`创建一个元组（这是一个任意元素的列表），以及如何从`QVariantMap`创建一个字典（这是一个关联数组）。尝试通过直接接受`QStringList`、`QVariantList`和`QVariantMap`并分别返回元组和字典来添加构造函数。
- en: We have written quite a lot of code now, but so far there is no way of binding
    any data from our programs with Python scripting. Let's change that.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经编写了相当多的代码，但到目前为止，还没有方法将我们的程序中的任何数据绑定到Python脚本。让我们改变这一点。
- en: Time for action – calling functions and returning values
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动——调用函数和返回值
- en: 'The next task is to provide ways to invoke Python functions and return values
    from scripts. Let''s start by providing a richer `run()` API. Implement the following
    method in the `QtPython` class:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是提供调用Python函数和从脚本中返回值的方法。让我们首先提供一个更丰富的`run()` API。在`QtPython`类中实现以下方法：
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We''ll also need a functionality to import Python modules. Add the following
    methods to the class:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个导入Python模块的功能。向类中添加以下方法：
- en: '[PRE74]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The last piece of the code is to extend `QtPythonValue` with this code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分是扩展`QtPythonValue`的以下代码：
- en: '[PRE75]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, you can modify `main()` to test the new functionality:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以将`main()`修改为测试新功能：
- en: '[PRE76]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: You can replace `/home` with a directory of your choice. Then, you can run the
    program.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`/home`替换为您选择的目录。然后，您就可以运行程序了。
- en: '*What just happened?*'
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We did two tests in the last program. First, we used the new `run()` method,
    passing to it the code that is to be executed and two dictionaries that define
    the current execution context—the first dictionary contains global symbols and
    the second contains local symbols. The dictionaries come from Python's `__main__`
    module (which among other things, defines the `print` function). The `run()` method
    may modify the contents of the two dictionaries—the first call defines the tuple
    called `foo` and the second call prints it to the standard output.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个程序中，我们进行了两次测试。首先，我们使用了新的 `run()` 方法，向它传递要执行的代码和两个定义当前执行上下文的字典——第一个字典包含全局符号，第二个包含局部符号。这些字典来自
    Python 的 `__main__` 模块（它定义了 `print` 函数等）。`run()` 方法可能会修改这两个字典的内容——第一次调用定义了一个名为
    `foo` 的元组，第二次调用将其打印到标准输出。
- en: The second test calls a function from an imported module; in this case, we call
    two functions from the `os` module—the first function, `chdir`, changes the current
    working directory and the other called `getcwd` returns the current working directory.
    The convention is that we should pass a tuple to `call()`, where we pass the needed
    parameters. The first function takes a string as a parameter, therefore, we pass
    a `QStringList` object, assuming that there is a `QtPythonValue` constructor that
    converts `QStringList` to a tuple (you need to implement it if you haven't done
    it already). Since the second function does not take any parameters, we pass an
    empty tuple to the call. In the same way, you can provide your own modules and
    call functions from them, query the results, inspect dictionaries, and so on.
    This is a pretty good start for an embedded Python interpreter. Remember that
    a proper component should have some error checking code to avoid crashing the
    whole application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次测试调用了一个导入模块中的函数；在这种情况下，我们调用 `os` 模块中的两个函数——第一个函数 `chdir` 改变当前工作目录，另一个函数 `getcwd`
    返回当前工作目录。惯例是我们应该向 `call()` 函数传递一个元组，其中我们传递所需的参数。第一个函数接受一个字符串作为参数，因此我们传递一个 `QStringList`
    对象，假设存在一个 `QtPythonValue` 构造函数，它将 `QStringList` 转换为元组（如果你还没有实现它，你需要实现它）。由于第二个函数不接受任何参数，我们向调用传递一个空元组。同样，你也可以提供自己的模块并从中调用函数，查询结果，检查字典等。这对于一个嵌入式
    Python 解释器来说是一个很好的开始。记住，一个合适的组件应该有一些错误检查代码来避免整个应用程序崩溃。
- en: You can extend the functionality of the interpreter in many ways. You can even
    use PyQt5 to use Qt bindings in scripts, combining Qt/C++ code with Qt/Python
    code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过许多方式扩展解释器的功能。你甚至可以使用 PyQt5 在脚本中使用 Qt 绑定，将 Qt/C++ 代码与 Qt/Python 代码结合在一起。
- en: Have a go hero – wrapping Qt objects into Python objects
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试将 Qt 对象包装成 Python 对象——英雄出马
- en: At this point, you should be experienced enough to try and implement a wrapper
    for the `QObject` instances to expose signals and slots to Python scripting. If
    you decide to pursue the goal, [https://docs.python.org/3/](https://docs.python.org/3/)
    will be your best friend, especially the section about extending Python with C++.
    Remember that `QMetaObject` provides information about the properties and methods
    of Qt objects and `QMetaObject::invokeMethod()` allows you to execute a method
    by its name. This is not an easy task, so don't be hard on yourself if you are
    not able to complete it. You can always return to it once you gain more experience
    in using Qt and Python.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经足够有经验去尝试实现一个 `QObject` 实例的包装器，以便将信号和槽暴露给 Python 脚本。如果你决定追求这个目标，[https://docs.python.org/3/](https://docs.python.org/3/)
    将是你的最佳朋友，特别是关于使用 C++ 扩展 Python 的部分。记住，`QMetaObject` 提供了有关 Qt 对象属性和方法的信息，`QMetaObject::invokeMethod()`
    允许你通过名称执行方法。这不是一个容易的任务，所以如果你没有能够完成它，不要对自己太苛刻。一旦你获得了更多使用 Qt 和 Python 的经验，你总是可以回过头来做这件事。
- en: Before you head on to the next chapter, try testing your knowledge about scripting
    in Qt.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进入下一章之前，试着测试一下你对 Qt 脚本知识的掌握。
- en: Pop quiz – scripting
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——脚本
- en: Q1\. Which is the method that you can use to execute JavaScript statements?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 你可以使用哪个方法来执行 JavaScript 语句？
- en: '`QScriptEngine::run()`'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QScriptEngine::run()`'
- en: '`QScriptEngine::evaluate()`'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QScriptEngine::evaluate()`'
- en: '`QScriptProgram::execute()`'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QScriptProgram::execute()`'
- en: Q2\. What is the name of the class that serves as a bridge to exchange data
    between Qt Script and C++?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 哪个类的名称用作在 Qt 脚本和 C++ 之间交换数据的桥梁？
- en: '`QScriptContext`'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QScriptContext`'
- en: '`QScriptValue`'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QScriptValue`'
- en: '`QVariant`'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QVariant`'
- en: Q3\. What is the name of the class that serves as a bridge that is used to exchange
    data between Python and C++?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 哪个类的名称用作在 Python 和 C++ 之间交换数据的桥梁？
- en: '`PyValue`'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PyValue`'
- en: '`PyObject`'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PyObject`'
- en: '`QVariant`'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QVariant`'
- en: Q4\. How do execution contexts work?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 执行上下文是如何工作的？
- en: They mark some variables as "executable" to prevent rogue code from being executed.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们将一些变量标记为“可执行”，以防止恶意代码被执行。
- en: They allow executing scripts in parallel, improving their speed.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们允许并行执行脚本，从而提高它们的速度。
- en: They contain all the variables defined within a function invocation so that
    a set of variables visible from within a script can be modified without affecting
    the global environment (called sandboxing).
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们包含函数调用中定义的所有变量，这样一组在脚本内部可见的变量就可以被修改，而不会影响全局环境（称为沙盒）。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that providing a scripting environment to your
    games opens up new possibilities. Implementing a functionality using scripting
    languages is usually faster than doing the full write-compile-test cycle with
    C++ and you can even use the skills and creativity of your users who have no understanding
    of the internals of your game engine to make your games better and more feature-rich.
    You were shown how to use Qt Script, which blends the C++ and JavaScript worlds
    together by exposing Qt objects to JavaScript and making cross-language signal-slot
    connections. If you're not a JavaScript fan, you learned the basics of scripting
    with Python. There are other scripting languages available (for example Lua) and
    many of them can be used together with Qt. Using the experience gained in this
    chapter, you should even be able to bring other scripting environments to your
    programs, as most embeddable interpreters offer similar approaches to that of
    Python.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到为你的游戏提供脚本环境可以开启新的可能性。使用脚本语言实现功能通常比使用 C++ 的完整编写-编译-测试周期要快，你甚至可以使用那些不了解你游戏引擎内部结构的用户的技能和创造力来使你的游戏更好、功能更丰富。你已经看到了如何使用
    Qt Script，它通过将 Qt 对象暴露给 JavaScript 并实现跨语言信号-槽连接，将 C++ 和 JavaScript 世界融合在一起。如果你不是
    JavaScript 的粉丝，你也学习了使用 Python 的脚本基础知识。还有其他脚本语言可供选择（例如 Lua），许多语言都可以与 Qt 一起使用。利用本章获得的经验，你应该甚至能够将其他脚本环境带到你的程序中，因为大多数可嵌入的解释器都提供了与
    Python 类似的方法。
- en: In the next chapter, you will be introduced to an environment very much like
    Qt Script in the way that it is heavily based on JavaScript. However, the purpose
    of using it is completely different—we will be using it to bleed edge-fancy graphics.
    Welcome to the world of Qt Quick.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解到一个非常类似于 Qt Script 的环境，因为它在 JavaScript 上有很重的依赖。然而，使用它的目的完全不同——我们将用它来实现前沿的复杂图形。欢迎来到
    Qt Quick 的世界。
