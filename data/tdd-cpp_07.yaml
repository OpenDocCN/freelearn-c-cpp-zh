- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Test Setup and Teardown
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试设置和拆卸
- en: Have you ever worked on a project where you needed to prepare your work area
    first? Once ready, you can finally do some work. Then, after a while, you need
    to clean up your area. Maybe you use the area for other things and can’t just
    leave your project sitting around or it would get in the way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经在一个项目中工作过，需要首先准备你的工作区域？一旦准备好，你就可以开始工作了。然后，过了一段时间，你需要清理你的区域。也许你会用这个区域做其他事情，不能只是让你的项目闲置在那里，否则会妨碍你。
- en: Sometimes, tests can be a lot like that. They might not take up table space,
    but sometimes they can require an environment setup or some other results to be
    ready before they can run. Maybe a test makes sure that some data can be deleted.
    It makes sense that the data should exist first. Should the test be responsible
    for creating the data that it is trying to delete? It would be better to wrap
    up the data creation inside its own function. But what if you need to test several
    different ways to delete the data? Should each test create the data? They could
    call the same setup function.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，测试可能就像那样。它们可能不占用表空间，但有时它们在运行之前可能需要设置环境或准备一些其他结果。也许一个测试确保某些数据可以被删除。数据首先存在是有意义的。测试是否应该负责创建它试图删除的数据？最好是将数据创建封装在其自己的函数中。但如果你需要测试几种不同的删除数据方式呢？每个测试是否都应该创建数据？它们可以调用相同的设置函数。
- en: If multiple tests need to perform similar preparation and cleanup work, not
    only is it redundant to write the same code into each test, but it also hides
    the real purpose of the tests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个测试需要执行类似的前期准备和后期清理工作，不仅将相同的代码写入每个测试是冗余的，而且还会隐藏测试的真实目的。
- en: This chapter is going to allow tests to run preparation and cleanup code so
    that they can focus on what needs to be tested. The preparation work is called
    **setup**. And the cleanup is called **teardown**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将允许测试运行准备和清理代码，以便它们可以专注于需要测试的内容。准备工作称为**设置**。清理工作称为**拆卸**。
- en: We’re following a TDD approach, so that means we’ll start with some simple tests,
    get them working, and then enhance them for more functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循TDD（测试驱动开发）方法，这意味着我们将从一些简单的测试开始，让它们工作，然后增强它们以实现更多功能。
- en: Initially, we’ll let a test run the setup code and then the teardown at the
    end. Multiple tests can use the same setup and teardown, but the setup and teardown
    will be run each time for each test.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将让测试运行设置代码，然后在结束时进行拆卸。多个测试可以使用相同的设置和拆卸，但设置和拆卸将针对每个测试单独运行。
- en: Once that is working, we’ll enhance the design to let a group of tests share
    setup and teardown code that runs just once before and after the group of tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个功能工作，我们将增强设计，让一组测试在测试组之前和之后只运行一次共享的设置和拆卸代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Supporting test setup and teardown
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持测试设置和拆卸
- en: Enhancing test setup and teardown for multiple tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为多个测试增强测试设置和拆卸
- en: Handling errors in setup and teardown
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理设置和拆卸过程中的错误
- en: By the end of the chapter, the tests will be able to have both individual setup
    and teardown code along with setup and teardown code that encapsulates groups
    of tests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，测试将能够拥有单独的设置和拆卸代码，以及封装测试组的设置和拆卸代码。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code in this chapter uses standard C++, which builds on any modern C++
    20, or later, compiler and standard library. The code is based on and continues
    from the previous chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都使用标准C++，它基于任何现代C++ 20或更高版本的编译器和标准库。代码基于前几章并继续发展。
- en: 'You can find all of the code for this chapter at the following GitHub repository:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下GitHub仓库中找到本章的所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
- en: Supporting test setup and teardown
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持测试设置和拆卸
- en: In order to support test setup and teardown, we only need to arrange for some
    code to run before a test begins and for some code to run after a test finishes.
    For the setup, we might be able to simply call a function near the beginning of
    the test. The setup doesn’t actually have to run before the test, as long as it
    runs before the test needs the setup results. What I mean is that the unit test
    library doesn’t really need to run the setup before a test begins. As long as
    the test itself runs the setup at the very beginning of the test, then we get
    the same overall result. This would be the simplest solution. It’s not really
    a new solution at all, though. A test can already call other functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持测试设置和拆卸，我们只需要安排在测试开始前运行一些代码，并在测试完成后运行一些代码。对于设置，我们可能只需在测试开始附近调用一个函数。设置实际上不必在测试之前运行，只要它在测试需要设置结果之前运行即可。我的意思是，单元测试库实际上不需要在测试开始前运行设置。只要测试本身在测试开始时运行设置，我们就能得到相同的结果。这将是最简单的解决方案。但这并不是一个全新的解决方案。测试已经可以调用其他函数。
- en: The biggest problem I see with simply declaring a standalone function and calling
    it at the start of a test is that the intent can get lost. What I mean is that
    it’s up to the test author to make sure that a function called within a test is
    clearly defined to be a setup function. Because functions can be named anything,
    unless it has a good name, just calling a function is not enough to identify the
    intention to have a setup.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到简单地声明一个独立函数并在测试开始时调用它的最大问题是意图可能会丢失。我的意思是，测试作者必须确保在测试中调用的函数明确定义为设置函数。因为函数可以有任意的名称，除非有一个好名字，仅仅调用一个函数是不够的，无法识别出设置的意图。
- en: What about the teardown? Can this also be a simple function call? Because the
    teardown code should always be run at the end of a test, the test author would
    have to make sure that the teardown runs even when an exception is thrown.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于拆卸呢？这也可以是一个简单的函数调用吗？因为拆卸代码应该在测试结束时始终运行，测试作者必须确保即使在抛出异常的情况下，拆卸也会运行。
- en: For these reasons, the test library should provide some help with the setup
    and teardown. How much help and what that help will look like is something we
    need to decide. Our goal is to keep the tests simple and make sure that all the
    edge cases are handled.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，测试库应该提供一些帮助来进行设置和拆卸。我们需要决定的是帮助的程度以及这种帮助将如何体现。我们的目标是保持测试简单，并确保处理所有边缘情况。
- en: 'Following a TDD approach, which was first explained in [*Chapter 3*](B18567_03.xhtml#_idTextAnchor031)*,
    The TDD Process*, we should do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按照在[*第3章*](B18567_03.xhtml#_idTextAnchor031)*中首次解释的TDD方法，即《TDD过程》，我们应该做以下事情：
- en: First, think about what the desired solution should be.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，思考理想解决方案应该是什么。
- en: Write some tests that use the solution to make sure it will meet our expectations.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一些使用该解决方案的测试，以确保它将满足我们的期望。
- en: Build the project and fix the build errors without worrying about getting tests
    to pass yet.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建项目并修复构建错误，无需担心测试是否通过。
- en: Implement a basic solution with passing tests.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个基本的解决方案，并通过测试。
- en: Enhance the solution and improve the tests.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高解决方案并改进测试。
- en: One option to help with setup and teardown would be to add new parameters to
    the `TEST` and `TEST_EX` macros. This would make the setup and teardown part of
    the test declaration. But is this necessary? If possible, we should avoid relying
    on these macros. They’re already complicated enough without adding more features
    if we can avoid it. Modifying the macros shouldn’t be needed for test setup and
    teardown.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助设置和拆卸的一个选项可能是向`TEST`和`TEST_EX`宏添加新参数。这将使设置和拆卸部分成为测试声明的一部分。但这是必要的吗？如果可能，我们应该避免依赖于这些宏。如果可以避免，它们已经足够复杂，无需添加更多功能。修改宏通常不需要用于测试设置和拆卸。
- en: Another possible solution is to create a method in the `TestBase` class like
    we did to set the expected failure reason in [*Chapter 3*](B18567_03.xhtml#_idTextAnchor031),
    *The TDD Process*. Would this work? To answer that, let’s think about what the
    setup and teardown code should do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的解决方案是在`TestBase`类中创建一个方法，就像我们在[*第3章*](B18567_03.xhtml#_idTextAnchor031)*《TDD过程》*中设置预期失败原因时做的那样。这会起作用吗？为了回答这个问题，让我们思考设置和拆卸代码应该做什么。
- en: The setup should get things ready for the test. This likely means that the test
    will need to refer to data or resources such as files that the setup code prepares.
    It might not seem like much of a setup if the test doesn’t get something it can
    use, but who knows? Maybe the setup does something related but unnoticed by the
    test code. The main point I’m getting at is that the setup code could do almost
    anything. It might require its own arguments to customize. Or it might be able
    to run without any input at all. It might generate something that the test uses
    directly. Or it might work behind the scenes in a way that is useful but unknown
    to the test.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设置应该为测试做好准备。这很可能意味着测试将需要引用设置代码准备的数据或资源，例如文件。如果测试得不到可以使用的东西，可能看起来设置并不重要，但谁知道呢？也许设置做了与测试代码无关但未注意到的相关操作。我主要想说的是，设置代码几乎可以执行任何事情。它可能需要自己的参数来定制。或者，它可能能够在没有任何输入的情况下运行。它可能生成测试直接使用的内容。或者，它可能在幕后以对测试有用的方式工作，但对测试代码来说是未知的。
- en: Also, the teardown might need to refer to whatever was set up so that it can
    be undone. Or maybe the teardown just cleans everything up without worrying about
    where it came from.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，拆解可能需要参考之前设置的内容，以便能够撤销。或者，拆解可能只是清理一切，而不关心它们来自何处。
- en: Calling a method in `TestBase` to register and run the setup and teardown seems
    like it might make the interaction with the test code more complicated because
    we would need a way to share the setup results. All we really want is to run the
    setup, gain access to whatever the setup provides, and then run the teardown at
    the end of the test. There’s an easy way to do this that allows whatever interaction
    is needed between the setup, teardown, and the rest of the test code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TestBase`中调用方法以注册和运行设置和拆解似乎可能会使与测试代码的交互变得更加复杂，因为我们需要一种方式来共享设置结果。我们真正想要的只是运行设置，获取设置提供的内容，然后在测试结束时运行拆解。有一种简单的方法可以实现这一点，允许设置、拆解和其余测试代码之间所需的任何交互。
- en: 'Let’s start by creating a new `.cpp` file in the `tests` folder called `Setup.cpp`.
    The project structure will look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`tests`文件夹中创建一个新的`.cpp`文件开始，命名为`Setup.cpp`。项目结构将如下所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is a test in `Setup.cpp` that we can use to get started:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个在`Setup.cpp`中的测试，我们可以用它开始：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The test uses three functions: `createTestEntry`, `updateTestEntryName`, and
    `deleteTestEntry`. The comment explains what the test might be called and what
    it would do if this was a test for an actual project instead of a test for the
    test library. The idea of the test is to call `createTestEntry` to set up some
    data, try to update the name with an empty string to ensure that is not allowed,
    and then call `deleteTestEntry` to tear down the data created at the beginning
    of the test. You can see that the setup provides an identity called `id`, which
    is needed by the test and by the teardown.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用三个函数：`createTestEntry`、`updateTestEntryName`和`deleteTestEntry`。注释解释了测试可能被调用的名称以及如果这是一个实际项目的测试而不是测试库的测试，它将执行的操作。测试的思路是调用`createTestEntry`来设置一些数据，尝试使用空字符串更新名称以确保不允许这样做，然后调用`deleteTestEntry`来拆解测试开始时创建的数据。你可以看到设置提供了一个名为`id`的标识符，这是测试和拆解所需的。
- en: The test expects the call to `updateTestEntryName` to fail because of the empty
    name. This will result in an exception being thrown. We’re just going to throw
    an int here, but in an actual project, the exception type would normally be something
    else. The exception will cause the teardown call to `deleteTestEntry` to be skipped.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 测试期望`updateTestEntryName`的调用因名称为空而失败，这将导致抛出异常。我们在这里只是抛出一个整数，但在实际项目中，异常类型通常是其他类型。异常将导致跳过拆解调用`deleteTestEntry`。
- en: Additionally, the test could use confirmations to verify its own results if
    needed. And a failed confirmation will also throw an exception. We need to make
    sure that the teardown code is run in all cases. Right now, it will always be
    skipped because the whole purpose of the test is to expect an exception to be
    thrown from `updateTestEntryName`. But other tests might still skip the teardown
    if they fail a confirmation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果需要，测试可以使用确认来验证其结果。如果确认失败，也会抛出异常。我们需要确保在所有情况下都运行拆解代码。目前，它总是会跳过，因为整个测试的目的就是期望从`updateTestEntryName`抛出异常。但其他测试如果确认失败，可能仍然会跳过拆解。
- en: Even if we fix the problem that `deleteTestEntry` doesn’t get called, we still
    have a test that’s unclear. What’s really being tested? The only thing in this
    test that should stand out as the intent of the test is the call to `updateTestEntryName`.
    The calls to `createTestEntry` and `deleteTestEntry` only hide the real purpose
    of the test. And if we add a `try/catch` block to make sure that `deleteTestEntry`
    gets called, then the real purpose will only be hidden further.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使解决了`deleteTestEntry`没有被调用的这个问题，测试仍然不够清晰。真正要测试的是什么？在这个测试中，唯一应该突出显示为测试意图的是对`updateTestEntryName`的调用。对`createTestEntry`和`deleteTestEntry`的调用只是隐藏了测试的真实目的。如果我们添加一个`try/catch`块来确保`deleteTestEntry`被调用，那么真实目的只会被进一步隐藏。
- en: 'The three functions in the test are the type of functions that would be found
    in a project. We don’t have a separate project, so they can be placed in `Setup.cpp`
    because they are helper functions for our purposes. They look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的三个函数是那种在项目中可能会找到的函数类型。我们没有单独的项目，所以它们可以放在`Setup.cpp`中，因为它们是我们目的的辅助函数。它们看起来是这样的：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `id` parameter name is commented out because the helper functions don’t
    use them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`参数名称被注释掉了，因为辅助函数没有使用它们。'
- en: 'We can wrap up the calls to `createTestEntry` and `deleteTestEntry` in the
    constructor and destructor of a class. This helps simplify the test and ensures
    that the teardown code gets called. The new test looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类的构造函数和析构函数中包装`createTestEntry`和`deleteTestEntry`的调用。这有助于简化测试并确保调用拆解代码。新的测试看起来像这样：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `TempEntry` class contains the setup and teardown calls along with the
    identifier needed by the test and the teardown. It can go in `Setup.cpp` right
    after the three helper methods:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`TempEntry`类包含设置和拆解调用以及测试和拆解所需的标识符。它可以在三个辅助方法之后直接放入`Setup.cpp`中：'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Writing a class like this is a great way to make sure code gets executed when
    an instance goes out of scope, and we can use it to make sure that the teardown
    code always gets run at the end of the test. It’s simple and can maintain its
    own state such as the identifier. Additionally, it only needs a single line to
    create an instance at the beginning of the test so that it doesn’t distract from
    what the test is trying to do.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样的类是确保实例超出作用域时代码被执行的绝佳方式，我们可以用它来确保在测试结束时总是运行拆解代码。它很简单，可以维护自己的状态，例如标识符。此外，它只需要在测试开始时创建一个实例的单行代码，这样就不会分散测试试图做的事情。
- en: You can go this route anytime you have a specific need that the library code
    doesn’t meet. But is there a way that the test library can help make this even
    better?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当库代码不能满足特定需求时，你可以随时采取这种做法。但是，测试库是否有方法可以使这变得更好？
- en: I’ve seen classes that let you pass lambdas or functions to the constructor
    that do something similar. The constructor will call the first function right
    away and will call the second when the instance gets destroyed. That’s just like
    what the `TempEntry` class does except for one detail. `TempEntry` also manages
    the identity that is needed by the teardown code. None of the lambda solutions
    I can think of are as clean as a class written just for this purpose, such as
    `TempEntry`. But maybe we can still improve this a little more.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过一些类，允许你将lambda或函数传递给构造函数，执行类似操作。构造函数会立即调用第一个函数，并在实例被销毁时调用第二个函数。这就像`TempEntry`类所做的那样，除了一个细节。`TempEntry`还管理拆解代码所需的身份。我想到的所有lambda解决方案都没有像专门为此目的编写的类（如`TempEntry`）那样干净。但也许我们还可以再改进一点。
- en: The problem with `TempEntry` is that it’s not clear what is the setup and what
    is the teardown. It’s also not clear in the test that the first line that creates
    a `TempEntry` class has anything to do with setup and teardown. Sure, a little
    studying will let you realize that the setup is in the constructor and the teardown
    is in the destructor. It would be nice if we had methods called `setup` and `teardown`
    and if the test itself clearly identified the use of the setup and teardown code
    being run.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`TempEntry`的问题在于，它不清楚什么是设置和什么是拆解。在测试中，第一条创建`TempEntry`类的语句与设置和拆解有什么关系也不清楚。当然，稍微研究一下会让你意识到设置在构造函数中，拆解在析构函数中。如果我们可以有名为`setup`和`teardown`的方法，并且测试本身清楚地标识了正在运行的设置和拆解代码的使用，那就太好了。'
- en: One solution that comes to mind would be a base class that calls virtual `setup`
    and `teardown` methods. But we can’t use normal inheritance because we need to
    call them from the constructor and destructor. Instead, we can use a design pattern
    called *policy-based design*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个想到的解决方案可能是调用虚拟`setup`和`teardown`方法的基本类。但我们不能使用正常的继承，因为我们需要在构造函数和析构函数中调用它们。相反，我们可以使用一个称为*基于策略的设计*的设计模式。
- en: 'A *policy class* implements one or more methods that a derived class will make
    use of. The methods that the derived class use are called the *policy*. It’s like
    inheritance only backward. We’ll turn the `TempEntry` class into a policy class
    that implements the `setup` and `teardown` methods by modifying it like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*策略类*实现了一个或多个派生类将使用的方法。派生类使用的方法被称为*策略*。这就像继承的反向。我们将通过如下修改将`TempEntry`类转变为一个实现`setup`和`teardown`方法的策略类：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The only real change was to turn the constructor into the `setup` method and
    the destructor into the `teardown` method. That’s only because we were using those
    methods previously to do the work. Now we have a class that is clear and easy
    to understand. But how will we use it? We no longer have the setup code running
    automatically when the class is constructed and the teardown code that runs on
    destruction. We’ll need to create another class, and this one can go in `Test.h`
    because it will be used for all the setup and teardown needs for all the tests.
    Add this template class inside the `MereTDD` namespace in `Test.h` like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正的变化是将构造函数转变为`setup`方法，将析构函数转变为`teardown`方法。这仅仅是因为我们之前使用这些方法来做这项工作。现在我们有一个清晰且易于理解的类。但我们如何使用它呢？我们不再有在类构造时自动运行的设置代码和在析构时运行的清理代码。我们需要创建另一个类，这个类可以放在`Test.h`中，因为它将用于所有测试的设置和清理需求。在`Test.h`中`MereTDD`命名空间内添加如下模板类：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `SetupAndTeardown` class is where we tie the calls to `setup` and `teardown`
    back into the constructor and destructor. You can use any class you want for the
    policy as long as that class implements the two `setup` and `teardown` methods.
    Also, a nice benefit is that because of the public inheritance, you have access
    to other methods you define in the policy class. We use this to still be able
    to call the `id` method. A policy-based design lets you extend the interface to
    whatever you need as long as you implement the policy. In this example, the policy
    is just the two `setup` and `teardown` methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupAndTeardown`类是我们将`setup`和`teardown`的调用与构造函数和析构函数重新连接的地方。只要那个类实现了两个`setup`和`teardown`方法，你可以使用任何你想要的类作为策略。还有一个很好的好处是，由于公有继承，你可以访问策略类中定义的其他方法。我们使用这一点仍然能够调用`id`方法。基于策略的设计让你能够扩展接口到你需要的样子，只要实现了策略。在这个例子中，策略只是两个`setup`和`teardown`方法。'
- en: One other thing about using a policy-based design, and specifically about the
    inheritance, is that this pattern goes against the *is-a* relationship of object-oriented
    design. If we were using public inheritance in a normal way, then we could say
    that `SetupAndTeardown` is a `TempEntry` class. In this case, that doesn’t make
    sense. That’s okay because we’re not going to use this pattern to create instances
    that can be substituted for one another. We use public inheritance just so that
    we can call methods such as `id` inside the policy class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于策略的设计，特别是关于继承的问题，还有一个其他方面，那就是这种模式与面向对象设计的“is-a”关系相悖。如果我们以正常的方式使用公有继承，那么我们可以说`SetupAndTeardown`是`TempEntry`类。在这种情况下，这显然没有意义。没关系，因为我们不会使用这种模式来创建可以互相替换的实例。我们使用公有继承只是为了能够在策略类内部调用诸如`id`这样的方法。
- en: 'Now that we have all this, what does the test look like? The test can now use
    the `SetupAndTeardown` class like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有这些，测试看起来会是什么样子？现在测试可以使用`SetupAndTeardown`类，如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a big improvement because of the following list of reasons:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为以下列出的原因而有一个很大的改进：
- en: It’s clear at the beginning of the test that we have setup code and teardown
    code attached to the test
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试的开始阶段就很清楚，测试代码中附带了设置代码和清理代码。
- en: The teardown code will be run at the end of the test, and we don’t need to complicate
    the test code with a try/catch block
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理代码将在测试结束时运行，我们不需要通过try/catch块来复杂化测试代码。
- en: We don’t need to mix calls to `setup` and `teardown` into the rest of the test
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要将`setup`和`teardown`的调用与测试的其他部分混合。
- en: We can interact with the setup results through methods that we write such as
    the `id` method
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过我们编写的诸如`id`方法这样的方法与设置结果进行交互。
- en: Anytime you need setup and/or teardown code within a test, all you have to do
    is write a class that implements the `setup` and `teardown` methods. If there
    is no work needed by one of these methods, then leave the method empty. However,
    both methods need to exist because they are the policy. Implementing the policy
    methods is what creates a policy class. Then, add an instance of `MereTDD:SetupAndTeardown`
    that uses the policy class as its template parameter. The test should declare
    the `SetupAndTeardown` instance at the beginning of the test in order to get the
    most benefit from this design.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时需要在测试中编写设置和/或拆除代码，你只需要编写一个实现`setup`和`teardown`方法的类。如果其中一个方法不需要执行任何操作，则可以留空该方法。然而，两个方法都必须存在，因为它们是策略。实现策略方法就是创建策略类。然后，添加一个使用策略类作为模板参数的`MereTDD:SetupAndTeardown`实例。测试应该在测试开始时声明`SetupAndTeardown`实例，以便从这种设计中获得最大好处。
- en: While we can declare the setup and teardown code that runs at the beginning
    and end of each test like this, we’ll need a different solution to share the setup
    and teardown code so that the setup runs before a group of tests and the teardown
    code runs after the group of tests complete. The next section will enhance the
    setup and teardown to meet this expanded need.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以像这样声明在每个测试开始和结束时运行的设置和拆除代码，但我们需要一个不同的解决方案来共享设置和拆除代码，以便设置在测试组之前运行，而拆除代码在测试组完成后运行。下一节将增强设置和拆除功能以满足这一扩展需求。
- en: Enhancing test setup and teardown for multiple tests
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个测试的测试设置和拆除增强
- en: Now that we have the ability to set things up for a test and cleanup after a
    test, we can do things such as preparing temporary data in the setup that a test
    needs in order to run and then removing the temporary data in the teardown after
    a test has run. If there are many different tests using data like this, they can
    each create similar data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了为测试设置事物并在测试后清理的能力，我们可以在设置中准备测试所需的临时数据，以便运行测试，然后在测试运行后拆除设置中的临时数据。如果有许多不同的测试使用此类数据，它们可以各自创建类似的数据。
- en: But what if we need to set up something for a whole group of tests, and then
    tear it down after all the tests finish? I’m talking about something that remains
    in place across multiple tests. For the temporary data, maybe we need to prepare
    a place to hold the data. If the data is stored inside a database, this would
    be a good time to open the database and make sure the necessary tables are ready
    to hold the data that each test will be creating. Even the connection to the database
    itself can remain open and used by the tests. And once all the data tests are
    done, then the teardown code can close the database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们需要为整个测试组设置某些东西，然后在所有测试完成后将其拆除呢？我指的是在多个测试中保持不变的东西。对于临时数据，可能我们需要准备一个地方来存储数据。如果数据存储在数据库中，那么现在是打开数据库并确保必要的表已经准备好以存储每个测试将创建的数据的好时机。甚至数据库连接本身也可以保持打开状态，供测试使用。一旦所有数据测试完成，那么拆除代码就可以关闭数据库。
- en: The scenario applies to many different situations. If you are testing something
    related to files on a hard drive, then you might want to ensure the proper directories
    are ready so that the files can be created. The directories can be set up before
    any of the file tests begin, and the tests only need to worry about creating the
    files they will be testing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景适用于许多不同的情况。如果你正在测试与硬盘上的文件相关的东西，那么你可能想确保适当的目录已经准备好，以便创建文件。这些目录可以在任何文件测试开始之前设置，而测试只需要担心创建它们将要测试的文件。
- en: If you are testing a web service, maybe it makes sense to make sure that your
    tests have a valid and authenticated login before they begin. It might not make
    sense for each test to repeat the login steps each time. Unless, of course, that’s
    the purpose of the test.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在测试一个网络服务，那么在测试开始前确保测试有一个有效的和经过身份验证的登录可能是有意义的。可能没有必要让每个测试每次都重复登录步骤。除非，当然，这是测试的目的。
- en: The main idea here is that while it’s good to have some code run as setup and
    teardown for each test, it can also be good to have different setup and teardown
    code run only once for a group of tests. That’s what this section is going to
    explore.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是，虽然让一些代码在每个测试中作为设置和拆除运行是好的，但也可以让不同的设置和拆除代码只为测试组运行一次。这正是本节将要探讨的内容。
- en: We’ll call a group of tests that are related by common setup and teardown code
    that runs once for the entire group a *test suite*. Tests don’t have to belong
    to a test suite, but we’ll create an internal and hidden test suite to group all
    of the individual tests that don’t have a specific suite of their own.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称由共同的设置和拆解代码关联的一组测试为*测试套件*。测试不必属于测试套件，但我们将创建一个内部和隐藏的测试套件来分组所有没有特定套件的单独测试。
- en: We were able to add setup and teardown code to an individual test completely
    within that test because the setup and teardown code within a test is just like
    calling a couple of functions. However, in order to support setup and teardown
    for a test suite, we’re going to have to do work outside of the tests. We need
    to make sure that the setup code runs before any of the related tests run. And
    then run the teardown code after all of the related tests are complete.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够在单个测试中完全添加设置和拆解代码，因为测试中的设置和拆解代码就像调用几个函数一样。然而，为了支持测试套件的设置和拆解，我们可能需要在测试之外做一些工作。我们需要确保设置代码在相关测试运行之前运行。然后，在所有相关测试完成后运行拆解代码。
- en: A test project that contains and runs all the tests should be able to support
    multiple test suites. This means that a test will need some way to identify what
    test suite it belongs to. Also, we’ll need some way to declare the setup and teardown
    code for a test suite.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 包含并运行所有测试的测试项目应该能够支持多个测试套件。这意味着测试需要一种方式来识别它所属的测试套件。此外，我们还需要一种方式来声明测试套件的设置和拆解代码。
- en: 'The idea works like this: we’ll declare and write some code to be a test suite
    setup. Or maybe we can let the setup code be optional if the only thing needed
    is the teardown code. Then, we’ll declare and write some code for the teardown.
    The teardown should also be optional. Either the setup or the teardown, or both,
    need to be defined in order to have a valid test suite. And each test needs some
    way to identify the test suite it belongs to. When running all the tests in the
    project, we need to run them in the proper order so that the test suite setup
    runs first, followed by all the tests in the test suite, and then followed by
    the test suite teardown.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是这样的：我们将声明并编写一些代码作为测试套件的设置。或者，如果我们只需要拆解代码，也许我们可以让设置代码是可选的。然后，我们将声明并编写一些拆解代码。拆解代码也应该可选。无论是设置、拆解，还是两者都要定义，才能有一个有效的测试套件。每个测试都需要一种方式来识别它所属的测试套件。当运行项目中的所有测试时，我们需要按照正确的顺序运行它们，以便测试套件设置首先运行，然后是测试套件中的所有测试，最后是测试套件的拆解。
- en: How will we identify test suites? The test library automatically generates unique
    names for each test, and these names are hidden from the test author. We could
    use names for the test suites, too, but let the test author specify what the name
    should be for each test suite. That seems understandable and should be flexible
    enough to handle any situation. We’ll let the test author provide a simple string
    name for each test suite.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何识别测试套件？测试库会自动为每个测试生成唯一的名称，并且这些名称对测试作者来说是隐藏的。我们也可以为测试套件使用名称，但让测试作者指定每个测试套件的名称。这似乎是可理解的，并且应该足够灵活以处理任何情况。我们将让测试作者为每个测试套件提供一个简单的字符串名称。
- en: When dealing with names, one edge case that always comes up is what to do about
    duplicate names. We’ll need to decide. We could either detect duplicate names
    and stop the tests with an error, or we could stack the setup and teardown so
    that they all run.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理名称时，一个经常出现的边缘情况是处理重复名称的问题。我们需要做出决定。我们可以检测重复名称并停止测试以显示错误，或者我们可以堆叠设置和拆解，以便它们都运行。
- en: 'Did we have this duplicate problem with the individual test setup and teardown?
    Not really because the setup and teardown weren’t named. But what happens if a
    test declares multiple instances of `SetupAndTeardown`? We actually didn’t consider
    that possibility in the previous section. In a test, it might look like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否在单个测试的设置和拆解中遇到了这个问题？实际上并没有，因为设置和拆解没有命名。但是，如果一个测试声明了多个`SetupAndTeardown`实例会发生什么？我们实际上在前一节中没有考虑这种可能性。在一个测试中，它可能看起来像这样：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is an interesting ability to have multiple setup and teardown instances and
    should help simplify and let you reuse the setup and teardown code. Instead of
    creating special setup and teardown policy classes that do many things, this will
    let them be stacked so that they can be more focused. Maybe one test only needs
    a single piece of data set up and torn down at the end while another test needs
    two. Instead of creating two different policy classes, this ability will let the
    first test declare a single `SetupAndTeardown` instance, while the second test
    reuses the same policy class by declaring two.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个设置和清理实例的能力是很有趣的，这应该有助于简化并允许你重用设置和清理代码。而不是创建执行许多操作的特定设置和清理策略类，这将允许它们堆叠起来，以便更加专注。也许一个测试只需要在最后设置和清理单个数据集，而另一个测试则需要两个。而不是创建两个不同的策略类，这种能力将允许第一个测试声明一个单独的
    `SetupAndTeardown` 实例，而第二个测试通过声明两个来重用相同的策略类。
- en: Now that we allow individual test setup and teardown code to be composed, why
    not allow the test suite setup and teardown to be composed, too? This seems reasonable
    and might even simplify the test library code. How is that possible?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在允许单个测试设置和清理代码的组合，为什么不允许测试套件的设置和清理代码的组合呢？这似乎是合理的，甚至可能简化测试库代码。这是如何实现的呢？
- en: Well, now that we know about the ability, we can plan for it and will likely
    be able to avoid writing code to detect and throw errors instead. If we notice
    two or more test suite setup definitions with the same name, we can add them to
    a collection instead of treating the situation as a special error case.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，既然我们已经了解了这种能力，我们就可以为此进行规划，并可能避免编写检测和抛出错误的代码。如果我们注意到两个或更多具有相同名称的测试套件设置定义，我们可以将它们添加到集合中，而不是将这种情况视为一个特殊错误情况。
- en: If we do have multiple setup and teardown definitions with the same name, let’s
    not rely on any particular order between them. They could be defined in different
    `.cpp` files just like how the tests can be split between different `.cpp` files.
    This will simplify the code because we can add them to a collection as we find
    them without worrying about a particular order.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实有多个具有相同名称的设置和清理定义，我们就不应该依赖于它们之间的任何特定顺序。它们可以像测试一样被分割到不同的 `.cpp` 文件中。这将简化代码，因为我们可以在找到它们时将它们添加到集合中，而不用担心特定的顺序。
- en: The next thing to consider is how to define the test suite setup and teardown
    code. They probably can’t be simple functions because they need to register themselves
    with the test library. The registration is needed so that when a test gives a
    suite name, we will know what the name means. The registration seems very similar
    to how the tests register themselves. We should be able to add an extra string
    for the suite name. Additionally, the tests will need this new suite name even
    if they are not part of a specific test suite. We’ll use an empty suite name for
    tests that want to run outside of any test suite.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要考虑的是如何定义测试套件的设置和清理代码。它们可能不能是简单的函数，因为它们需要与测试库进行注册。注册是必要的，这样当测试提供一个套件名称时，我们将知道这个名称的含义。注册看起来与测试进行自我注册的方式非常相似。我们应该能够为套件名称添加一个额外的字符串。此外，即使测试不是特定测试套件的一部分，它们也需要这个新的套件名称。我们将使用空套件名称为想要在测试套件之外运行的测试。
- en: The registration will need to let tests register themselves with a suite name
    even if the setup and teardown code for that suite name hasn’t yet been registered.
    This is because tests can be defined in multiple `.cpp` files, and we have no
    way of knowing in what order the initialization code will register the tests and
    test suite setup and teardown code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注册时需要让测试自己使用套件名称进行注册，即使该套件名称的设置和清理代码尚未注册。这是因为测试可以定义在多个 `.cpp` 文件中，我们无法知道初始化代码将按什么顺序注册测试和测试套件的设置和清理代码。
- en: There’s one more important requirement. We have a way to interact with the setup
    results in individual test setup and teardown code. We’ll need this ability in
    the test suite setup and teardown, too. Let’s say that the test suite setup needs
    to open a database connection that will be used for all of the tests in the suite.
    The tests will need some way to know about the connection. Additionally, the test
    suite teardown will need to know about the connection if it wants to close the
    connection. Maybe the test suite setup also needs to create a database table.
    The tests will need the name of that table in order to use it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个更重要的要求。我们有一种方式可以与单个测试设置和清理代码中的设置结果进行交互。在测试套件设置和清理中，我们也将需要这种能力。假设测试套件设置需要打开一个数据库连接，该连接将被套件中的所有测试使用。测试需要某种方式来了解这个连接。此外，如果测试套件清理想要关闭连接，它也需要了解这个连接。也许测试套件设置还需要创建一个数据库表。测试将需要该表的名字以便使用它。
- en: 'Let’s create a couple of helper functions in `Setup.cpp` that will simulate
    creating and dropping a table. They should look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Setup.cpp`中创建几个辅助函数，以模拟创建和删除表的操作。它们应该看起来像这样：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, in the `Setup.cpp` file, we can make our first test suite setup and teardown
    look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Setup.cpp`文件中，我们可以使我们的第一个测试套件设置和清理看起来像这样：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This looks a lot like the policy class used in the previous section to define
    the `setup` and `teardown` methods and to provide an interface to access any additional
    methods or data provided by the setup code. That’s because this is going to be
    a policy class, too. And we might as well make the policies the same no matter
    if the setup and teardown code is being used for an individual test or an entire
    test suite.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常像上一节中用来定义`setup`和`teardown`方法以及提供访问由设置代码提供的任何额外方法或数据的策略类。这是因为这也将是一个策略类。我们不妨让策略保持一致，无论设置和清理代码是用于单个测试还是整个测试套件。
- en: When we declare that a test has setup and teardown code for just that test,
    we declare an instance of `MereTDD::SetupAndTeardown` that is specialized with
    a policy class. This is enough to run the setup code right away and to make sure
    that the teardown code is run at the end of the test. But in order to gain access
    to the other information, it’s important to give the `SetupAndTeardown` instance
    a name. The setup and teardown code is fully defined and accessible through the
    local named instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个测试只有设置和清理代码时，我们声明了一个使用策略类的特化`MereTDD::SetupAndTeardown`的实例。这足以立即运行设置代码并确保在测试结束时运行清理代码。但为了获取其他信息，给`SetupAndTeardown`实例一个名字是很重要的。设置和清理代码完全定义并通过本地命名实例可访问。
- en: However, with the test suite setup and teardown, we need to put the instances
    of the policy class into a container. The container will want everything inside
    it to be of a single type. The setup and teardown instances can no longer be simple
    local named variables in a test. Yet, we still need a named type because that’s
    how a test in the test suite can access the resources provided by the setup code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在测试套件设置和清理中，我们需要将策略类的实例放入容器中。容器希望它内部的所有内容都是单一类型。设置和清理实例不能再是测试中的简单本地命名变量。然而，我们仍然需要一个命名类型，因为这是测试套件中的测试访问设置代码提供的资源的方式。
- en: We need to figure out two things. The first is where to create instances of
    test suite setup and teardown code. And the second is how to reconcile the need
    for a container to have everything be of a single type with the need for the tests
    to be able to refer to named instances of specific types that can be different
    from one policy class to another.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要弄清楚两件事。第一是创建测试套件设置和清理代码实例的位置。第二是如何协调容器需要所有内容都是单一类型的需求与测试能够引用特定类型的命名实例的需求，这些实例可能因策略类而异。
- en: The first problem is the easiest to solve because we need to consider lifetime
    and accessibility. The test suite setup and teardown instances need to exist and
    be valid for multiple tests within a test suite. They can’t exist as local variables
    within a single test. They need to be somewhere that they will remain valid for
    multiple tests. They could be local instances inside of `main` – that would solve
    the lifetime issue. But then they would only be accessible to `main`. The test
    suite setup and teardown instances will need to be global. Only then will they
    exist for the duration of the test application and be accessible to multiple tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题最容易解决，因为我们需要考虑生命周期和可访问性。测试套件的设置和销毁实例需要在测试套件内的多个测试中存在并有效。它们不能作为单个测试中的局部变量存在。它们需要在一个将保持对多个测试有效的地方。它们可以是`main`内部的局部实例——这将解决生命周期问题。但这样它们就只能被`main`访问。测试套件的设置和销毁实例需要是全局的。只有这样，它们才能在整个测试应用程序期间存在，并且可以被多个测试访问。
- en: For the second problem, we’re going to first declare an interface that the collection
    will use to hold all the test suite setup and teardown instances. And the test
    library will also use this same interface when it needs to run the setup and teardown
    code. The test library needs to treat everything the same because it doesn’t know
    anything about the specific policy classes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题，我们首先将声明一个接口，该接口将用于存储所有测试套件的设置和销毁实例。测试库在需要运行设置和销毁代码时也将使用此相同的接口。测试库需要将所有内容视为相同，因为它对特定的策略类一无所知。
- en: 'We’ll come back to all of this later. Before we get too far, we need to consider
    what our proposed usage will look like. We are still following a TDD approach,
    and while it’s good to think of all the requirements and what is possible, we’re
    far enough along to have a good idea of what a test suite setup and teardown usage
    would look like. We even have the policy class ready and defined. Add this to
    `Setup.cpp` as the intended usage we’re going to implement:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到所有这些。在我们走得太远之前，我们需要考虑我们的预期使用方式。我们仍然遵循TDD方法，虽然考虑所有需求和可能的情况是好的，但我们已经足够深入，可以有一个关于测试套件设置和销毁使用的良好想法。我们甚至已经有了准备好的策略类和定义。将以下内容添加到`Setup.cpp`中，作为我们将要实现的预期使用：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are a few things to explain with the preceding code. You can see that
    it declares two instances of `MereTDD::TestSuiteSetupAndTeardown`, each specialized
    with the `TempTable` policy class. These are global variables with a specific
    type, so the tests will be able to see them and use the methods in the policy
    class for each. You can use a different policy class for each if you want. Or
    if you use the same policy class, then there should normally be some difference.
    Otherwise, why have two instances? For creating temp tables, as this example shows,
    each table would likely have a unique random name and be able to use the same
    policy class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要通过前面的代码进行解释。你可以看到它声明了两个`MereTDD::TestSuiteSetupAndTeardown`的实例，每个实例都专门使用`TempTable`策略类。这些是具有特定类型的全局变量，因此测试将能够看到它们并使用策略类中的方法。如果你想的话，可以为每个实例使用不同的策略类。或者，如果你使用相同的策略类，那么通常应该有一些差异。否则，为什么有两个实例？对于创建临时表，正如这个示例所示，每个表可能都有一个唯一的随机名称，并且能够使用相同的策略类。
- en: The constructor needs two strings. The first is the name of the setup and teardown
    code. We’re going to treat test suite setup and teardown code as if it was a test
    itself. We’ll include the test suite setup and teardown pass or fail results in
    the test application summary and identify it with the name provided to the constructor.
    The second string is the name of the test suite. This can be anything except for
    an empty string. We’ll treat an empty test suite name as a special value for all
    the tests that do not belong to a test suite.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数需要两个字符串。第一个是设置和销毁代码的名称。我们将测试套件的设置和销毁代码视为一个测试本身。我们将测试套件的设置和销毁通过或失败的结果包含在测试应用程序摘要中，并用构造函数提供的名称来标识它。第二个字符串是测试套件的名称。这可以是任何内容，但不能是空字符串。我们将空测试套件名称视为不属于任何测试套件的测试的特殊值。
- en: In this example, both instances of `TestSuiteSetupAndTeardown` use the same
    suite name. This is okay and supported, as we decided earlier. Anytime there are
    multiple test suite setup and teardown instances with the same name, they will
    all be run before the test suite begins.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`TestSuiteSetupAndTeardown`的两个实例使用相同的套件名称。这是可以接受的，也是支持的，因为我们之前决定。任何有多个具有相同名称的测试套件设置和销毁实例时，它们都将运行在测试套件开始之前。
- en: The reason for a new `TestSuiteSetupAndTeardown` test library class instead
    of reusing the existing `SetupAndTeardown` class will become clear later. It needs
    to merge a common interface together with the policy class. The new class also
    makes it clear that this setup and teardown are for a test suite.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用新的`TestSuiteSetupAndTeardown`测试库类而不是重用现有的`SetupAndTeardown`类将在稍后变得清晰。它需要合并一个通用接口与策略类。新的类也清楚地表明，这个设置和清理是为测试套件而设的。
- en: Then come the tests. We need a new macro called `TEST_SUITE` so that the name
    of the test suite can be specified. Other than the test suite name, the macro
    will behave almost the same as the existing `TEST` macro. We’ll need a new macro
    for tests belonging to a test suite that also expects an exception. We’ll call
    that one `TEST_SUITE_EX`; it behaves similarly to `TEST_EX` except for the additional
    test suite name.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是测试。我们需要一个新的宏`TEST_SUITE`，以便可以指定测试套件名称。除了测试套件名称外，该宏的行为几乎与现有的`TEST`宏相同。我们还需要一个新的宏来表示属于测试套件且期望异常的测试。我们将称其为`TEST_SUITE_EX`；它的行为类似于`TEST_EX`，但增加了测试套件名称。
- en: There are a lot of changes needed in `Test.h` to support test suites. Most of
    the changes are related to how the tests are registered and run. We have a base
    class for tests called `TestBase`, which does the registration by pushing a pointer
    to `TestBase` to a vector. Because we also need to register test suite setup and
    teardown code and run tests grouped by their test suite, we’ll need to change
    this. We’ll keep `TestBase` as the base class for all tests. But it will now be
    a base class for test suites, too.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Test.h`中需要进行许多更改以支持测试套件。大多数更改都与测试的注册和运行方式相关。我们有一个名为`TestBase`的测试基类，它通过将`TestBase`指针推送到向量中来执行注册。由于我们还需要注册测试套件的设置和清理代码，并按测试套件分组运行测试，因此我们需要对此进行更改。我们将保持`TestBase`作为所有测试的基类。但现在它也将成为测试套件的基类。
- en: 'The collection of tests will need to change to a map so that the tests can
    be accessed by their test suite name. Tests without a test suite will still have
    a suite name. It will just be empty. Additionally, we need to find the test suite
    setup and teardown code by the suite name, too. We’ll need two collections: one
    map for the tests and one map for the test suite setup and teardown code. And
    because we need to refactor the existing registration code out of `TestBase`,
    we’ll create a class called `Test` that will be used for the tests and a class
    called `TestSuite` that will be used for the test suite setup and teardown code.
    Both the `Test` and `TestSuite` classes will derive from `TestBase`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 测试集合需要更改为映射，以便可以通过测试套件名称访问测试。没有测试套件的测试仍然有一个套件名称。它将只是空的。此外，我们还需要通过套件名称查找测试套件的设置和清理代码。我们需要两个集合：一个映射用于测试，一个映射用于测试套件的设置和清理代码。由于我们需要将现有的注册代码从`TestBase`中重构出来，我们将创建一个名为`Test`的类，用于测试，以及一个名为`TestSuite`的类，用于测试套件的设置和清理代码。`Test`和`TestSuite`类都将从`TestBase`派生。
- en: 'The maps will be accessed with the existing `getTests` function that will be
    modified to use a map and a new `getTestSuites` function. First, include a map
    at the top of `Test.h`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用现有的`getTests`函数来访问映射，该函数将被修改为使用映射并添加一个新的`getTestSuites`函数。首先，在`Test.h`的顶部包含一个映射：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, further down, change the part that forward-declares the `TestBase` class
    and implements the `getTests` function to look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在更下面，将前向声明`TestBase`类和实现`getTests`函数的部分修改如下：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The key to each map will be the test suite name as a string. The value will
    be a vector of either pointers to `Test` or pointers to `TestSuite`. When we register
    a test or test suite setup and teardown code, we will do so by the test suite
    name. The first registration for any test suite name will need to set up an empty
    vector. Once the vector has been set up, the test can be pushed to the end of
    the vector just like it was done previously. And the test suite setup and teardown
    code will do the same thing. To make this process easier, we’ll create a couple
    of helper methods that can go in `Test.h` right after the `getTestSuites` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个映射的键将是测试套件名称的字符串。值将是`Test`或`TestSuite`指针的向量。当我们注册测试或测试套件设置和清理代码时，我们将通过测试套件名称进行注册。对于任何测试套件名称的第一个注册，需要设置一个空向量。一旦向量已经设置，测试就可以像之前一样推送到向量的末尾。测试套件的设置和清理代码也将执行相同操作。为了使这个过程更容易，我们将在`Test.h`中`getTestSuites`函数之后创建几个辅助方法：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next is the refactored `TestBase` class, which has been modified to add a test
    suite name, stop doing the test registration, remove the expected failure reason,
    and remove the running code. Now the `TestBase` class will only hold data that
    is common between the tests and the test suite setup and teardown code. The class
    looks like this after the changes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是重构后的 `TestBase` 类，它已经被修改以添加测试套件名称，停止进行测试注册，移除预期失败原因，并移除运行代码。现在 `TestBase`
    类将只包含测试和测试套件设置和清理代码之间的公共数据。修改后的类如下：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The functionality that was pulled out of the previous `TestBase` class goes
    into a new derived class, called `Test`, which looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的 `TestBase` 类中提取的功能现在进入了一个新的派生类，称为 `Test`，看起来是这样的：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Test` class is shorter because a lot of the basic information now lives
    in the `TestBase` class. Also, we used to have a `TestExBase` class, which needs
    to be changed slightly. It will now be called `TestEx` and looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test` 类更短，因为现在很多基本信息都存储在 `TestBase` 类中。此外，我们曾经有一个 `TestExBase` 类，需要稍作修改。现在它将被称为
    `TestEx`，看起来是这样的：'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The only thing that has really changed with `TestEx` is the name and the base
    class name.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestEx` 类真正改变的是名称和基类名称。'
- en: Now, we can get to the new `TestSuite` class. This will be the common interface
    that will be stored in the map and serve as the common interface for running the
    setup and teardown code by the test library.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进入新的 `TestSuite` 类。这将是一个将被存储在映射中并作为测试库运行设置和清理代码的公共接口的通用接口。
- en: 'The class looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类看起来是这样的：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `TestSuite` class doesn’t have a `runEx` method like the `Test` class. Test
    suites exist to group tests and to prepare an environment for a test to use, so
    it doesn’t make sense to write setup code that is expected to throw an exception.
    A test suite doesn’t exist to test anything. It exists to prepare for one or more
    tests that will use the resources that the `suiteSetup` method gets ready. Also,
    the teardown code is not intended to test anything. The `suiteTeardown` code is
    just supposed to clean up whatever was set up. If there are any exceptions during
    test suite setup and teardown, we want to know about them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestSuite` 类没有像 `Test` 类那样的 `runEx` 方法。测试套件的存在是为了分组测试并为测试提供一个使用环境，因此编写预期会抛出异常的设置代码是没有意义的。测试套件的存在不是为了测试任何东西。它存在是为了准备一个或多个将使用
    `suiteSetup` 方法准备好的资源的测试。同样，清理代码也不打算测试任何东西。`suiteTeardown` 代码只是用来清理设置的内容。如果在测试套件设置和清理过程中发生任何异常，我们希望知道它们。'
- en: Additionally, the `TestSuite` class does not have a `run` method like the `Test`
    class because we need to clearly define what the setup is versus what the teardown
    is. There is no single block of code to run. There are now two separate blocks
    of code to run, one at setup time and one at teardown time. So, while a `Test`
    class is designed to run something, a `TestSuite` class is designed to prepare
    a group of tests with a setup and then clean up after the tests with a teardown.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`TestSuite` 类没有像 `Test` 类那样的 `run` 方法，因为我们需要明确区分设置和清理。没有单一的代码块可以运行。现在有两个独立的代码块需要运行，一个在设置时运行，一个在清理时运行。因此，虽然
    `Test` 类的设计是用来运行某些内容的，但 `TestSuite` 类的设计是用来准备一组测试，通过设置来准备环境，然后在测试后通过清理来清理环境。
- en: You can see that the `TestSuite` constructor registers the test suite setup
    and teardown code by calling `addTestSuite`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`TestSuite` 构造函数通过调用 `addTestSuite` 来注册测试套件的设置和清理代码。
- en: We have a function called `runTests` that currently goes through all the tests
    and runs them. If we put the code to actually run a single test inside a new function,
    we can simplify the code that goes through all of the tests and then displays
    the summary. This will be important because we’ll need to run more than tests
    in the new design. We’ll also need to run the test suite setup and teardown code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `runTests` 的函数，它目前遍历所有测试并运行它们。如果我们把运行单个测试的代码放在一个新的函数中，我们可以简化遍历所有测试并显示总结的代码。这将是重要的，因为在新设计中我们需要运行更多的测试。我们还需要运行测试套件的设置和清理代码。
- en: 'Here is a helper function to run a single test:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个辅助函数来运行单个测试：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code is almost identical to what was in `runTests`. Slight changes
    have been made to the beginning output that displays the test name. This is to
    help distinguish a test from the setup and teardown code. The helper function
    also takes references to the record-keeping counts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码几乎与`runTests`中的代码相同。对测试名称显示的开始输出进行了一些细微的更改，这是为了帮助区分测试与设置和清理代码。辅助函数还接收记录计数器的引用。
- en: 'We can create another helper function to run the setup and teardown code. This
    function will perform almost the same steps for setup and teardown. The main difference
    is which method to call on the `TestSuite` pointer, either `suiteSetup` or `suiteTeardown`.
    The helper function looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建另一个辅助函数来运行设置和清理代码。此函数将执行几乎相同的设置和清理步骤。主要区别在于调用`TestSuite`指针的方法，即`suiteSetup`或`suiteTeardown`。辅助函数看起来如下：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function is slightly simpler than the helper function to run a test. That’s
    because we don’t need to worry about missed exceptions or expected failures. It
    does almost the same thing. It tries to run either the setup or teardown, catch
    exceptions, and update the pass or fail counts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数比运行测试的辅助函数稍微简单一些。那是因为我们不需要担心遗漏的异常或预期的失败。它几乎做了同样的事情。它尝试运行设置或清理，捕获异常，并更新通过或失败的计数。
- en: 'We can use the two helper functions, `runTest` and `runSuite`, inside the `runTests`
    function, which will need to be modified like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`runTests`函数内部使用两个辅助函数`runTest`和`runSuite`，该函数需要按照以下方式修改：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The initial statement that gets displayed shows how many test suites are being
    run. Why does the code look at the size of the tests instead of the size of the
    test suites? Well, that’s because the tests include everything, tests with a test
    suite and those tests without a test suite that get run under a made-up suite
    called `Single Tests`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的初始语句显示了正在运行的测试套件数量。为什么代码查看测试的大小而不是测试套件的大小？嗯，那是因为测试包括了所有内容，包括有测试套件的测试以及在没有测试套件的测试，这些测试在名为`Single
    Tests`的虚构套件下运行。
- en: The primary loop in this function looks at every item in the test map. Previously,
    these were the pointers to the tests. Now each entry is a test suite name and
    a vector of test pointers. This lets us go through the tests that are already
    grouped by the test suite that each test belongs to. An empty test suite name
    represents the single tests that have no test suite.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数中的主要循环检查测试映射中的每个项目。之前，这些是测试的指针。现在每个条目都是一个测试套件名称和测试指针的向量。这使得我们可以遍历每个测试所属的测试套件已经分组的测试。空测试套件名称代表没有测试套件的单个测试。
- en: If we find a test suite that is not empty, then we need to make sure that there
    exists at least one entry in the test suite with a matching suite name. If not,
    then this is an error in the test project and no further tests will be run.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个非空测试套件，那么我们需要确保至少有一个条目与测试套件的名称匹配。如果没有，那么这是测试项目中的错误，并且不会运行进一步的测试。
- en: If the test project registers a test with a suite name, then it must also register
    the setup and teardown code for that suite. Assuming we have the setup and teardown
    code for the suite, each registered setup is run and checked for an error. If
    there is an error setting up the test suite, then only the tests in that suite
    will be skipped.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试项目注册了一个带有套件名称的测试，那么它还必须为该套件注册设置和清理代码。假设我们已经有该套件的设置和清理代码，每个注册的设置都会运行并检查是否有错误。如果设置测试套件时出现错误，则只会跳过该套件中的测试。
- en: Once all the test suite setup code is run, then the tests are run for that suite.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行完所有测试套件的设置代码，那么就会为该套件运行测试。
- en: And after all the tests for the suite are run, then all the test suite teardown
    code is run.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行完套件的所有测试之后，然后运行所有测试套件的清理代码。
- en: 'There are two more parts to enable all this. The first is the `TestSuiteSetupAndTeardown`
    class, which goes into `Test.h` right after the existing `SetupAndTeardown` class.
    It looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用所有这些功能，还有两个部分。第一部分是`TestSuiteSetupAndTeardown`类，它位于`Test.h`中，紧接现有的`SetupAndTeardown`类之后。它看起来如下：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the class that is used in a test `.cpp` file to declare a test suite
    setup and teardown instance with a specific policy class. This class uses multiple
    inheritances to bridge the policy class and the common `TestSuite` interface class.
    When the `runSuite` function calls either `suiteSetup` or `suiteTeardown` through
    a pointer to `TestSuite`, these virtual methods will end up calling the override
    methods in this class. Each one just calls the `setup` or `teardown` methods in
    the policy class to do the actual work.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在测试`.cpp`文件中使用，用于声明具有特定策略类的测试套件设置和清理实例的类。这个类使用多重继承来连接策略类和常见的`TestSuite`接口类。当`runSuite`函数通过指向`TestSuite`的指针调用`suiteSetup`或`suiteTeardown`时，这些虚拟方法最终会调用这个类中的重写方法。每个方法只是调用策略类中的`setup`或`teardown`方法来完成实际工作。
- en: 'The last change to explain is the macros. We need two additional macros to
    declare a test that belongs to a test suite without an expected exception and
    with an expected exception. The macros are called `TEST_SUITE` and `TEST_SUITE_EX`.
    There are minor changes needed in the existing `TEST` and `TEST_EX` macros because
    of the refactoring of the `TestBase` class. The existing macros need to be updated
    to use the new `Test` and `TestEx` classes instead of `TestBase` and `TestExBase`.
    Additionally, the existing macros need to now pass an empty string for the test
    suite name. I’ll show the new macros here because they are so similar except for
    the difference in the test suite name. The `TEST_SUITE` macro looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解释的最后一种更改是宏。我们需要两个额外的宏来声明一个属于测试套件但没有预期异常和有预期异常的测试。这些宏被称为`TEST_SUITE`和`TEST_SUITE_EX`。由于`TestBase`类的重构，现有的`TEST`和`TEST_EX`宏需要做些小的修改。现有的宏需要更新，以使用新的`Test`和`TestEx`类而不是`TestBase`和`TestExBase`。此外，现有的宏现在需要传递一个空字符串作为测试套件名称。我将在这里展示新的宏，因为它们非常相似，除了测试套件名称的不同。`TEST_SUITE`宏看起来是这样的：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The macro now accepts a `suiteName` parameter that gets passed to the instance
    as the suite name. And the `TEST_SUITE_EX` macro looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的宏接受一个`suiteName`参数，该参数作为套件名称传递给实例。而`TEST_SUITE_EX`宏看起来是这样的：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The new suite macros are so similar to the modified non-suite macros that I
    tried to change the non-suite macros to call the suite macros with an empty suite
    name. But I could not figure out how to pass an empty string to another macro.
    The macros are short, so I left them with similar code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 新的套件宏与修改后的非套件宏非常相似，所以我尝试将非套件宏改为使用空套件名称调用套件宏。但我无法找出如何将空字符串传递给另一个宏。这些宏很短，所以我保留了它们相似的代码。
- en: 'That’s all of the changes needed to enable the test suites. The summary output
    looks a little different now after these changes. Building and running the test
    project produces the following output. It’s a bit long because we have 30 tests
    now. So, I’m not showing the entire output. The first part looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是启用测试套件所需的所有更改。这些更改后，总结输出看起来略有不同。构建和运行测试项目会产生以下输出。因为它现在有30个测试，所以输出有点长。因此，我不会显示整个输出。第一部分看起来是这样的：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, you can see that there are two test suites. One is named `Suite 1` and
    contains two tests plus the suite setup and teardown, and the other is unnamed
    and contains all the other tests that do not belong to a test suite. The first
    part of the output happens to be the single tests. The rest of the summary output
    shows the test suite and looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到有两个测试套件。一个是名为`Suite 1`的套件，包含两个测试以及套件设置和清理，另一个是无名的，包含所有不属于测试套件的其它测试。输出的一部分恰好是单个测试。总结输出的其余部分显示了测试套件，看起来是这样的：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each test suite is introduced in the summary output with the suite name followed
    by all the tests in that suite. For an actual suite, you can see the setup and
    teardown that surround all the tests. Each setup and teardown is run as if it
    was a test.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试套件都在总结输出中以套件名称开头，后面跟着该套件中的所有测试。对于实际的套件，你可以看到围绕所有测试的设置和清理。每个设置和清理都像测试一样运行。
- en: And the end shows the pass and fail counts just like before.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它显示的通过和失败计数与之前一样。
- en: In this section, I briefly explained some of the error handling for the setup
    and teardown code, but it needs more. The main purpose of this section was to
    get the setup and teardown working for the test suites. Part of that required
    a bit of error handling such as what to do when a test declares that it belongs
    to a suite that doesn’t exist. The next section will go deeper into this.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我简要地解释了一些设置和清理代码的错误处理，但还需要更多。本节的主要目的是让设置和清理代码为测试套件工作。其中一部分需要一些错误处理，比如当测试声明它属于一个不存在的套件时应该怎么做。下一节将更深入地探讨这个问题。
- en: Handling errors in setup and teardown
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理设置和清理过程中的错误
- en: Bugs can be found anywhere in code, and that includes inside the setup and teardown
    code. So, how should these bugs be handled? In this section, you’ll see that there
    is no single way to deal with bugs in setup and teardown. It’s more important
    that you be aware of the consequences so that you can write better tests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可以在代码的任何地方找到，包括设置和清理代码中。那么，应该如何处理这些错误呢？在本节中，您将看到处理设置和清理代码中的错误没有唯一的方法。更重要的是，您应该意识到后果，以便您可以编写更好的测试。
- en: Let’s start at the beginning. We’ve already sidestepped a whole class of problems
    related to multiple setup and teardown declarations. We decided that these would
    simply be allowed instead of trying to prevent them. So, a test can have as many
    setup and teardown declarations as it wants. Additionally, a test suite can declare
    as many instances of setup and teardown as needed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开始的地方开始。我们已经避开了与多个设置和清理声明相关的一类问题。我们决定简单地允许这些声明而不是试图阻止它们。因此，一个测试可以有任意多的设置和清理声明。此外，测试套件也可以声明任意多的设置和清理实例。
- en: 'However, just because multiple instances are allowed doesn’t mean that there
    won’t be any problems. The code that creates the test data entries is a good example.
    I thought about fixing the problem in the code but left it so that I can explain
    the problem here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管允许了多个实例，但这并不意味着不会有问题。创建测试数据条目的代码就是一个很好的例子。我考虑在代码中修复这个问题，但留了下来，以便在这里解释问题：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The problem is hinted at in the preceding comment. It says that real code would
    return the row identifier. Since this is a test helper function that has no connection
    to an actual database, it simply returns a constant value of 100.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在先前的注释中有所暗示。它提到真正的代码会返回行标识符。由于这是一个与实际数据库没有关联的测试辅助函数，它只是简单地返回一个常量值100。
- en: You’ll want to avoid your setup code doing anything that can conflict with additional
    setup code. A row identity in a database will not conflict because the database
    will return a different ID each time data is inserted. But what about other fields
    that get populated in the data? You might have constraints in your table, for
    example, where a name must be unique. If you create a fixed test name in one setup,
    then you won’t be able to use the same name in another.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望避免设置代码执行任何可能与其他设置代码冲突的操作。数据库中的行标识符不会冲突，因为每次插入数据时数据库都会返回不同的ID。但是，其他在数据中填充的字段呢？例如，您可能在表中设置了约束，其中名称必须是唯一的。如果您在一个设置中创建了一个固定的测试名称，那么您将无法在另一个设置中使用相同的名称。
- en: Even if you have different fixed names in different setup blocks so they won’t
    cause conflicts, you can still run into problems if the test data doesn’t get
    cleaned up properly. You might find that your tests run okay the first time and
    then fail thereafter because the fixed names already exist in the database.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您在不同的设置块中有不同的固定名称，它们不会引起冲突，但如果测试数据没有得到适当的清理，您仍然会遇到问题。您可能会发现第一次运行测试时一切正常，然后之后失败，因为固定的名称已经在数据库中存在。
- en: 'I recommend that you randomize your test data. Here is the other example that
    creates a test table:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您随机化您的测试数据。以下是一个创建测试表的另一个示例：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The comment in the preceding code also mentions creating a random name. It’s
    fine to use a fixed prefix, but consider making the digits at the end random instead
    of fixed. This won’t completely solve the problem of colliding data. It’s always
    possible that random numbers will turn out to be the same. But doing this together
    with a good cleanup of the test data should help eliminate most cases of conflicting
    setups.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 先前代码中的注释也提到了创建一个随机名称。使用固定的前缀是可以的，但考虑将末尾的数字设置为随机而不是固定的。这不会完全解决数据冲突的问题。随机数字可能会变成相同的。但是，与良好的测试数据清理一起做，应该有助于消除大多数冲突设置的情况。
- en: Another problem has already been handled in the test library code. And that
    is what to do when a test declares that it belongs to a test suite and that test
    suite does not have any setup and teardown code defined.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题已经在测试库代码中得到了处理。那就是当测试声明它属于某个测试套件，而该测试套件没有定义任何设置和拆卸代码时应该怎么做。
- en: This is treated as a fatal error in the test application itself. The moment
    a required test suite setup and teardown registration cannot be found, the test
    application exits and does not run any more tests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这在测试应用程序本身中被视为一个致命错误。一旦找不到所需的测试套件设置和拆卸注册，测试应用程序将退出并且不再运行任何更多测试。
- en: The fix is simple. Make sure you always define test suite setup and teardown
    code for all test suites that the tests use. It’s okay to have a test suite setup
    and teardown code registered that is never used by any test. But the moment a
    test declares that it belongs to a test suite, then that suite becomes required.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 修复很简单。确保为所有测试使用的测试套件始终定义测试套件设置和拆卸代码。即使注册的测试套件设置和拆卸代码从未被任何测试使用，这也是可以的。但是，一旦测试声明它属于某个测试套件，那么该套件就变得是必需的。
- en: 'Now, let’s talk about exceptions in setup and teardown code. This includes
    confirmations because a failed `CONFIRM` macro results in an exception being thrown.
    It’s okay to add confirmations to set up code like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈设置和拆卸代码中的异常。这包括确认，因为失败的`CONFIRM`宏会导致抛出异常。将确认添加到如下设置代码中是可以的：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Currently, this will cause the setup to fail because the identity is fixed
    to always be a value of 100\. And the confirmation tries to make sure that the
    value is 10\. Because the test setup code is called as if it was a regular function
    call, the result of this failed confirmation will be the same as any other failed
    confirmation in the test itself. The test will fail, and the summary will show
    where and why the failure happened. The summary looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这会导致设置失败，因为身份被固定为始终是100的值。而确认尝试确保该值为10。由于测试设置代码被调用时就像是一个常规函数调用，这次失败的确认结果将与测试本身中任何其他失败的确认相同。测试将失败，总结将显示失败发生的位置和原因。总结看起来像这样：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, putting confirmations in the teardown code is not recommended. And
    throwing exceptions from the teardown code is not recommended – especially for
    test teardown code because test teardown code is run from inside a destructor.
    So, moving the confirmation to the teardown code like this will not work the same
    way:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将确认放入拆卸代码是不推荐的。从拆卸代码中抛出异常也是不推荐的——特别是对于测试拆卸代码，因为测试拆卸代码是在析构函数内部运行的。所以，将确认移动到如下拆卸代码中不会以相同的方式工作：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will result in an exception being thrown during the destruction of the
    `SetupAndTeardown` class that uses the `TempEntry` policy class. The entire test
    application will be terminated like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致在使用`TempEntry`策略类`SetupAndTeardown`类析构时抛出异常。整个测试应用程序将像这样终止：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The problem is not as severe in the test suite teardown code because that teardown
    code is run by the test library after all the tests in the suite have been completed.
    It is not run as part of a class destructor. It’s still good advice to follow
    about not throwing any exceptions in the teardown code at all.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试套件拆卸代码中，问题并不那么严重，因为该拆卸代码是在套件中的所有测试完成后由测试库运行的。它不是作为类析构函数的一部分运行的。仍然建议在拆卸代码中不要抛出任何异常。
- en: Treat your teardown code as an opportunity to clean up the mess left behind
    by the setup and the tests. Normally, it should not contain anything that needs
    to be tested.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的拆卸代码视为清理设置和测试留下的混乱的机会。通常，它不应该包含任何需要测试的内容。
- en: 'The test suite setup code is a little different from the test setup code. While
    an exception in the test setup code causes the test to stop running and fail,
    an exception thrown in a test suite setup will cause all the tests in that suite
    to be skipped. Adding this confirmation to the test suite setup will trigger an
    exception:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件设置代码与测试设置代码略有不同。虽然测试设置代码中的异常会导致测试停止运行并失败，但在测试套件设置中抛出的异常会导致该套件中的所有测试被跳过。将此确认添加到测试套件设置将触发异常：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And the output summary shows that the entire test suite has been disrupted
    like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 并且输出总结显示整个测试套件像这样被干扰：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding message says that the test suite will be skipped.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的消息表示测试套件将被跳过。
- en: All the error handling that went into the test library for both test setup and
    teardown and test suite setup and teardown is largely untested itself. What I
    mean is that we added an extra feature to the test library to support any expected
    failures. And I did not do the same thing for expected failures in the setup and
    teardown code. I felt that the extra complexity needed to handle expected failures
    in the setup and teardown code was not worth the benefit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试库中为测试设置和清理以及测试套件设置和清理所进行的所有错误处理在很大程度上都没有经过测试。我的意思是，我们为测试库添加了一个额外的功能来支持任何预期的失败。我没有为设置和清理代码中的预期失败做同样的事情。我觉得处理设置和清理代码中预期失败所需的额外复杂性不值得其带来的好处。
- en: We’re using TDD to help guide the design of the software and to improve the
    quality of the software. But TDD doesn’t completely remove the need for some manual
    testing of edge conditions that are too difficult to test in an automated manner
    or that are just not feasible to test.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用TDD（测试驱动开发）来指导软件的设计并提高软件的质量。但TDD并不能完全消除对某些边缘条件的手动测试需求，这些条件在自动化测试中太难测试，或者根本不可行。
- en: So, will there be a test to make sure that the test library really does terminate
    when a required test suite is not registered? No. That seems like the kind of
    test that is best handled through manual testing. There might be situations you’ll
    encounter that are similar, and you’ll have to decide how much effort is needed
    to write a test and whether the effort is worth the cost.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是否会有一个测试来确保当所需的测试套件未注册时，测试库确实会终止？不会。这似乎是最好通过手动测试来处理的那种测试。你可能会遇到类似的情况，你将不得不决定编写测试所需的努力程度，以及这种努力是否值得成本。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter completes the minimum functionality needed in a unit testing library.
    We’re not done developing the testing library, but it now has enough features
    to be useful to another project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了单元测试库中所需的最小功能。我们还没有完成测试库的开发，但现在它已经具有足够的功能，可以用于其他项目。
- en: You learned about the issues involved with adding setup and teardown code and
    the benefits provided. The primary benefit is that tests can now focus on what
    is important to be tested. Tests are easier to understand when everything needed
    to run the test is no longer cluttering the test and the cleanup is handled automatically.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了添加设置和清理代码所涉及的问题以及提供的优势。主要优势是，测试现在可以专注于需要测试的重要部分。当不再有杂乱无章的测试代码和自动处理的清理时，测试更容易理解。
- en: There are two types of setup and teardown. One is local to the test; it can
    be reused in other tests but local means that the setup runs at the beginning
    of the test and the teardown happens at the end of the test. Another test that
    shares the same setup and teardown will repeat the setup and teardown in that
    other test.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和清理有两种类型。一种是局部于测试的；它可以在其他测试中重用，但局部意味着设置在测试开始时运行，清理在测试结束时发生。另一个共享相同设置和清理的测试将重复在该其他测试中的设置和清理。
- en: The other type of setup and teardown is actually shared by multiple tests. This
    is the test suite setup and teardown; its setup runs before any of the tests in
    the suite begin, and its teardown runs after all the tests in the suite are complete.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的设置和清理实际上是由多个测试共享的。这是测试套件的设置和清理；它的设置在套件中的任何测试开始之前运行，它的清理在套件中的所有测试完成后运行。
- en: For the local tests, we were able to integrate them into the tests fairly easily
    without much impact on the test library. We used a policy-based design to make
    writing the setup and teardown code easy. And the design lets the test code access
    the resources prepared in the setup.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于局部测试，我们能够相当容易地将它们集成到测试中，对测试库的影响不大。我们使用基于策略的设计来简化设置和清理代码的编写。而且，该设计允许测试代码访问设置中准备好的资源。
- en: The test suite setup and teardown was more elaborate and needed extensive support
    from the test library. We had to change the way tests were registered and run.
    But at the same time, we simplified the code and made it better. The test suite
    setup and teardown design uses the same policy that the local setup and teardown
    uses, which makes the whole design consistent.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件的设置和清理更为复杂，需要从测试库中获得广泛的支持。我们不得不改变测试注册和运行的方式。但与此同时，我们简化了代码，并使其更好。测试套件的设置和清理设计采用了与局部设置和清理相同的策略，这使得整个设计保持一致。
- en: And you also learned a few tips about how to handle errors in the setup and
    teardown code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学到了一些关于如何处理设置和清理代码中错误的小技巧。
- en: The next chapter will continue to give you guidance and tips on how to write
    better tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续为您提供如何编写更好测试的指导和建议。
