- en: Chapter 2.  Discovering QMake Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。探索 QMake 秘密
- en: This chapter addresses the issue of creating a cross-platform application that
    relies on platform-specific code. We will see the impact of qmake on the compilation
    of your project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了创建依赖特定平台代码的跨平台应用程序的问题。我们将看到 qmake 对项目编译的影响。
- en: You will learn how to create a system monitoring application that retrieves
    the average CPU load and the memory used from Windows, Linux, and Mac. For this
    kind of OS dependent application, architecture is the key to keeping your application
    reliable and maintainable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何创建一个系统监控应用程序，该程序可以从 Windows、Linux 和 Mac 中检索平均 CPU 负载和内存使用情况。对于这类依赖于操作系统的应用程序，架构是保持应用程序可靠和可维护的关键。
- en: At the end of this chapter, you will be able to create and organize a cross-platform
    application that uses platform-specific code and displays Qt Charts widgets. Moreover,
    qmake will not be a mystery anymore.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够创建和组织一个使用特定平台代码并显示 Qt 图表小部件的跨平台应用程序。此外，qmake 将不再是一个谜。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Platform-specific code organization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定平台代码组织
- en: Design patterns, strategy, and singleton
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式、策略和单例
- en: Abstract class and pure virtual function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类和纯虚函数
- en: Qt Charts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 图表
- en: The qmake tool
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: qmake 工具
- en: Designing a cross-platform project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计跨平台项目
- en: We want to display some visual gauges and chart widgets, so create a new **Qt
    widgets Application** called `ch02-sysinfo`. As already discussed in [Chapter
    1](part0014.xhtml#aid-DB7S1 "Chapter 1.  Get Your Qt Feet Wet"), *Get Your Qt
    Feet Wet*, Qt Creator will generate some files for us: `main.cpp`, `MainWindow.h`, `MainWindow.cpp`,
    and `MainWindow.ui`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要显示一些可视化仪表和图表小部件，因此创建一个新的 **Qt 小部件应用程序**，名为 `ch02-sysinfo`。正如在 [第 1 章](part0014.xhtml#aid-DB7S1
    "第 1 章。初识 Qt") 中所讨论的，“初识 Qt”，Qt Creator 将为我们生成一些文件：`main.cpp`、`MainWindow.h`、`MainWindow.cpp`
    和 `MainWindow.ui`。
- en: Before diving into the C++ code, we must think about the software's architecture.
    This project will handle multiple desktop platforms. Thanks to the combination
    of C++ and Qt, most of the source code will be common to all targets. However,
    to retrieve both the CPU and memory usage from the OS (operating system), we will
    use some platform-specific code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入 C++ 代码之前，我们必须考虑软件的架构。本项目将处理多个桌面平台。得益于 C++ 和 Qt 的结合，大部分源代码将适用于所有目标。然而，为了从操作系统（操作系统）中检索
    CPU 和内存使用情况，我们将使用一些特定平台的代码。
- en: 'To successfully achieve this task, we will use two design patterns:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功完成这项任务，我们将使用两种设计模式：
- en: '**Strategy pattern**: This is an interface that describes functionalities (for
    example, retrieve CPU usage), and specific behaviors (retrieve CPU usage on Windows/Mac
    OS/Linux) will be performed into subclasses that implement this interface.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略模式**：这是一个描述功能（例如，检索 CPU 使用情况）的接口，具体行为（在 Windows/Mac OS/Linux 上检索 CPU 使用情况）将在实现此接口的子类中执行。'
- en: '**Singleton pattern**: This pattern guarantees a single instance for a given
    class. This instance will be easily accessible with a unique access point.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例模式**：此模式确保给定类只有一个实例。此实例将通过一个唯一的访问点轻松访问。'
- en: 'As you can see in the following diagram, the class `SysInfo` is our interface
    with the strategy pattern, and is also a singleton. The specific behavior from
    the strategy pattern is performed in the classes `SysInfoWindowsImpl`, `SysInfoMacImpl`,
    and `SysInfoLinuxImpl`, subclassing `SysInfo`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下图中所见，类 `SysInfo` 是我们与策略模式的接口，也是一个单例。策略模式的具体行为在 `SysInfoWindowsImpl`、`SysInfoMacImpl`
    和 `SysInfoLinuxImpl` 类中执行，这些类是 `SysInfo` 的子类：
- en: '![Designing a cross-platform project](img/image00360.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![设计跨平台项目](img/image00360.jpeg)'
- en: The UI part will only know and use the `SysInfo` class. The platform-specific
    implementation class is instantiated by the `SysInfo` class, and the caller doesn't
    need to know anything about the `SysInfo` child classes. As the `SysInfo` class
    is a singleton, access will be easier for all widgets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: UI 部分只知道并使用 `SysInfo` 类。特定平台的实现类由 `SysInfo` 类实例化，调用者不需要了解 `SysInfo` 子类的任何信息。由于
    `SysInfo` 类是单例，对所有小部件的访问将更加容易。
- en: 'Let''s begin by creating the `SysInfo` class. On Qt Creator, you can create
    a new C++ class from the contextual menu, accessible with a right click on the
    project name in the hierarchy view. Then click on the **Add new** option, or from
    the menu, go to **File** | **New file or project** | **Files and classes**. Then
    perform the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建`SysInfo`类开始。在Qt Creator中，你可以通过在层次视图中的项目名称上右键单击的上下文菜单创建一个新的C++类。然后点击**添加新项**选项，或者从菜单中，转到**文件**
    | **新建文件或项目** | **文件和类**。然后执行以下步骤：
- en: Go to **C++ Class** | **Choose**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**C++类** | **选择**。
- en: Set the **Class** name field to `SysInfo`. As this class does not inherit from
    another class, we do not need to use the `Base` class field.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**类名**字段设置为`SysInfo`。由于这个类没有从其他类继承，我们不需要使用**基类**字段。
- en: Click on **Next**, then **Finish** to generate an empty C++ class.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**，然后**完成**以生成一个空的C++类。
- en: 'We will now specify our interface by adding three pure virtual functions: `init()`, `cpuLoadAverage()`,
    and `memoryUsed()`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加三个纯虚函数来指定我们的接口：`init()`、`cpuLoadAverage()`和`memoryUsed()`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each of these functions has specific roles:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数各自有特定的角色：
- en: '`init()`: This function allows the derived class to perform any initialization
    process depending on the OS platform'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()`：这个函数允许派生类根据操作系统平台执行任何初始化过程。'
- en: '`cpuLoadAverage()`: This function calls some OS-specific code to retrieve the
    average CPU load and returns it as a percentage value'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpuLoadAverage()`：这个函数调用一些特定于操作系统的代码来获取平均CPU负载，并以百分比的形式返回。'
- en: '`memoryUsed()`: This function calls some OS-specific code to retrieve the memory
    used and returns it as a percentage value'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memoryUsed()`：这个函数调用一些特定于操作系统的代码来获取内存使用情况，并以百分比的形式返回。'
- en: The `virtual` keyword indicates that the function can be overridden in a derived
    class. The `= 0` syntax means that this function is pure virtual, and must be
    overridden in any concrete derived class. Moreover, this makes `SysInfo` an abstract
    class that cannot be instantiated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual`关键字表示该函数可以在派生类中被覆盖。`= 0`语法表示这个函数是纯虚的，必须在任何具体的派生类中覆盖。此外，这使得`SysInfo`成为一个抽象类，不能被实例化。'
- en: We also added an empty virtual destructor. This destructor must be virtual to
    ensure that any deletion of an instance of a derived class--from a base class
    pointer--will call the derived class destructor and not only the base class destructor.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个空的虚析构函数。这个析构函数必须是虚的，以确保从基类指针删除派生类的实例时，将调用派生类析构函数，而不仅仅是基类析构函数。
- en: 'Now that our `SysInfo` class is an abstract class and ready to be derived,
    we will describe three implementations: Windows, Mac OS, and Linux. You can also
    perform only one implementation if you would rather not use the other two. We
    will not make any judgment on this. The `SysInfo` class will be transformed into
    a singleton after adding the implementations.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`SysInfo`类是一个抽象类，并准备好被派生，我们将描述三种实现：Windows、Mac OS和Linux。如果你不想使用其他两个，你也可以只执行一个实现。我们不会对此做出任何评判。在添加实现后，`SysInfo`类将被转换成一个单例。
- en: Adding the Windows implementation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Windows实现
- en: Remember the UML diagram at the beginning of this chapter? The `SysInfoWindowsImpl`
    class is one of the classes derived from the `SysInfo` class. The main purpose
    of this class is to encapsulate the Windows-specific code to retrieve CPU and
    memory usage.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记得本章开头提到的UML图吗？`SysInfoWindowsImpl`类是`SysInfo`类派生出的一个类。这个类的主要目的是封装获取CPU和内存使用情况的Windows特定代码。
- en: 'It''s time to create the `SysInfoWindowsImpl` class. To do that, you need to
    perform the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建`SysInfoWindowsImpl`类了。为了做到这一点，你需要执行以下步骤：
- en: Right click on the `ch02-sysinfo` project name in the hierarchy view.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次视图中的`ch02-sysinfo`项目名称上右键单击。
- en: Click on **Add New** | **C++ Class** | **Choose**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加新项** | **C++类** | **选择**。
- en: Set the **Class name** field to `SysInfoWindowsImpl`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**类名**字段设置为`SysInfoWindowsImpl`。
- en: Set the **Base class** field to **<Custom>** and write under the `SysInfo` class.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**基类**字段设置为**<Custom>**，并在`SysInfo`类下编写。
- en: Click on **Next** then **Finish** to generate an empty C++ class.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**然后**完成**以生成一个空的C++类。
- en: 'These generated files are a good starting point, but we must tune them:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成的文件是一个好的起点，但我们必须调整它们：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing to do is to add the `include` directive to our parent class, `SysInfo`.
    You can now override virtual functions defined in the base class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是向我们的父类`SysInfo`添加`include`指令。现在你可以覆盖基类中定义的虚函数。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Qt Tip**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt小贴士**'
- en: Put your cursor on a derived class name (after the keyword `class`) and press *Alt*
    + *Enter* (Windows / Linux) or *Command* + *Enter* (Mac) to automatically insert
    virtual functions of the base class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的光标放在派生类名称（在 `class` 关键字之后）上，然后按 *Alt* + *Enter*（Windows / Linux）或 *Command*
    + *Enter*（Mac）来自动插入基类的虚拟函数。
- en: The `override` keyword comes from C++11\. It ensures that the function is declared
    as virtual in the base class. If the function signature marked as `override` does
    not match any parent class' `virtual` function, a compile-time error will be displayed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`override` 关键字来自 C++11。它确保函数在基类中被声明为虚拟的。如果标记为 `override` 的函数签名与任何父类的 `virtual`
    函数不匹配，将显示编译时错误。'
- en: 'Retrieving the current memory used on Windows is easy. We will begin with this
    feature in the `SysInfoWindowsImpl.cpp` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上检索当前使用的内存很容易。我们将从 `SysInfoWindowsImpl.cpp` 文件中的这个功能开始：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don't forget to include the `windows.h` file so that we can use the Windows
    API! Actually, this function retrieves the total and the available physical memory.
    A simple subtraction gives us the amount of memory used. As required by the base
    class `SysInfo`, this implementation will return the value as a `double` type;
    for example, the value `23.0` for 23% memory used on a Windows OS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记包含 `windows.h` 文件，这样我们就可以使用 Windows API！实际上，这个函数检索总物理内存和可用物理内存。简单的减法给出了使用的内存量。根据基类
    `SysInfo` 的要求，此实现将返回值作为 `double` 类型；例如，Windows 操作系统上使用 23% 的内存值为 `23.0`。
- en: 'Retrieving the total memory used is a good start, but we cannot stop now. Our
    class must also retrieve the CPU load. The Windows API can be messy sometimes.
    To make our code more readable, we will create two private helper functions. Update
    your `SysInfoWindowsImpl.h` file to match the following snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 检索总使用的内存是一个好的开始，但我们不能就此停止。我们的类还必须检索 CPU 负载。Windows API 有时可能会很混乱。为了使我们的代码更易于阅读，我们将创建两个私有辅助函数。更新您的
    `SysInfoWindowsImpl.h` 文件以匹配以下片段：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s analyze these changes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这些变化：
- en: 'The `cpuRawData()` is the function that will perform the Windows API call to
    retrieve system timing information and return values in a generic format. We will
    retrieve and return three values: the amount of time that the system has spent
    in idle, in Kernel, and in User mode.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpuRawData()` 是一个将执行 Windows API 调用来检索系统计时信息并以通用格式返回值的函数。我们将检索并返回三个值：系统在空闲、内核和用户模式中花费的时间量。'
- en: The `convertFileTime()` function is our second helper. It will convert a Windows `FILETIME
    struct` syntax to a `qulonglong` type. The `qulonglong` type is a Qt `unsigned
    long long int`. This type is guaranteed by Qt to be 64-bit on all platforms. You
    can also use the typedef `quint64`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convertFileTime()` 函数是我们的第二个辅助函数。它将 Windows 的 `FILETIME` 结构语法转换为 `qulonglong`
    类型。`qulonglong` 类型是 Qt 的 `unsigned long long int`。Qt 保证在所有平台上都是 64 位的。您也可以使用 typedef
    `quint64`。'
- en: The `mCpuLoadLastValues` is a variable that will store system timing (idle,
    Kernel, and User) at a given moment.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mCpuLoadLastValues` 是一个变量，它将存储在某一时刻的系统计时（空闲、内核和用户）。'
- en: Don't forget to include the `<QtGlobal>` tag to use the `qulonglong` type, and
    the `<QVector>` tag to use the `QVector` class.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记包含 `<QtGlobal>` 标签以使用 `qulonglong` 类型，以及 `<QVector>` 标签以使用 `QVector` 类。
- en: The syntax `typedef struct _FILETIME FILETIME` is a kind of forward declaration
    for `FILENAME` syntax. As we only use a reference, we can avoid including the `<windows.h>`
    tag in our file `SysInfoWindowsImpl.h` and keep it in the CPP file.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法 `typedef struct _FILETIME FILETIME` 是对 `FILENAME` 语法的某种前置声明。由于我们只使用引用，我们可以在我们的文件
    `SysInfoWindowsImpl.h` 中避免包含 `<windows.h>` 标签，并将其保留在 CPP 文件中。
- en: 'We can now switch to the file `SysInfoWindowsImpl.cpp` and implement these
    functions to finish the CPU load average feature on Windows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以切换到文件 `SysInfoWindowsImpl.cpp` 并实现这些函数，以完成 Windows 上的 CPU 平均负载功能：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the `init()` function is called, we store the return value from the `cpuRawData()`
    function in our class variable `mCpuLoadLastValues`. It will be helpful for the `cpuLoadAverage()`function
    process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `init()` 函数时，我们将 `cpuRawData()` 函数的返回值存储在我们的类变量 `mCpuLoadLastValues` 中。这将对
    `cpuLoadAverage()` 函数的处理有所帮助。
- en: 'You may be wondering why we do not perform this task in the initialization
    list of the constructor. That is because when you call a function from the initialization
    list, the object is not yet fully constructed! In some circumstances, it may be
    unsafe because the function can try to access a member variable that has not been
    constructed yet. However, in this `ch02-sysinfo` project, the `cpuRawData` function
    does not use any member variables, so you are safe, if you really want to do it. Add
    the `cpuRawData()` function to the `SysInfoWindowsImpl.cpp` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不在这个构造函数的初始化列表中执行这个任务。那是因为当你从初始化列表中调用一个函数时，对象还没有完全构造完成！在某些情况下，这可能是不安全的，因为函数可能会尝试访问尚未构造的成员变量。然而，在这个
    `ch02-sysinfo` 项目中，`cpuRawData` 函数没有使用任何成员变量，所以如果你真的想这么做，你可以安全地将 `cpuRawData()`
    函数添加到 `SysInfoWindowsImpl.cpp` 文件中：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here we are: the Windows API call to the `GetSystemTimes` function! This function
    will give us the amount of time that the system has spent idle, and in the Kernel
    and User modes. Before filling the `QVector` class, we convert each value with
    our helper `convertFileTime` described in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是：调用 `GetSystemTimes` 函数的 Windows API！这个函数会给我们提供系统空闲、内核模式和用户模式下所花费的时间量。在填充
    `QVector` 类之前，我们使用以下代码中描述的辅助函数 `convertFileTime` 将每个值进行转换：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Windows structure `FILEFTIME` stores 64-bit information on two 32-bit parts
    (low and high). Our function `convertFileTime` uses the Windows structure `ULARGE_INTEGER`
    to correctly build a 64-bit value in a single part before returning it as a `qulonglong`
    type. Last but not least, the `cpuLoadAverage()` implementation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Windows结构 `FILEFTIME` 在两个32位部分（低和高）上存储64位信息。我们的函数 `convertFileTime` 使用Windows结构
    `ULARGE_INTEGER` 在返回之前正确地在单个部分中构建一个64位值，然后将其作为 `qulonglong` 类型返回。最后但同样重要的是，`cpuLoadAverage()`
    的实现：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are three important points to note here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个需要注意的重要点：
- en: Keep in mind that a sample is an absolute amount of time, so subtracting two
    different samples will give us instantaneous values that can be processed to get
    the current CPU load.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，样本是一个绝对的时间量，所以减去两个不同的样本将给出瞬时值，这些值可以被处理以获取当前的CPU负载。
- en: The first sample comes from our member variable `mCpuLoadLastValues`, probed
    the first time by the `init()` function. The second one is retrieved when the `cpuLoadAverage()`
    function is called. After initializing the samples, the `mCpuLoadLastValues` variable
    can store the new sample that will be used for the next call.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个样本来自我们的成员变量 `mCpuLoadLastValues`，它是在 `init()` 函数第一次探测时获取的。第二个样本是在调用 `cpuLoadAverage()`
    函数时检索到的。初始化样本后，`mCpuLoadLastValues` 变量可以存储将被用于下一次调用的新样本。
- en: The `percent` equation can be a little tricky because the Kernel value retrieved
    from the Windows API also contains the idle value.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percent` 方程可能有点棘手，因为从Windows API检索到的内核值也包含了空闲值。'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to learn more about the Windows API, take a look at the MSDN documentation
    at [https://msdn.microsoft.com/library](https://msdn.microsoft.com/library).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Windows API的信息，请查看MSDN文档，链接为[https://msdn.microsoft.com/library](https://msdn.microsoft.com/library)。
- en: 'The final step to finish the Windows implementation is to edit the file `ch02-sysinfo.pro`
    so that it resembles the following snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完成Windows实现的最后一步是编辑文件 `ch02-sysinfo.pro`，使其类似于以下片段：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we did in the `ch01-todo` project, we also use C++14 with the `ch02-sysinfo`
    project. The really new point here is that we removed the files `SysInfoWindowsImpl.cpp`
    and `SysInfoWindowsImpl.h` from the common `SOURCES` and `HEADERS` variables.
    Indeed, we added them into a `windows` platform scope. When building for other
    platforms, those files will not be processed by qmake. That is why we can safely
    include a specific header such as `windows.h` in the source file `SysInfoWindowsImpl.cpp`
    without harming the compilation on other platforms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 `ch01-todo` 项目中所做的那样，我们也在 `ch02-sysinfo` 项目中使用了C++14。这里真正的新点是，我们将文件 `SysInfoWindowsImpl.cpp`
    和 `SysInfoWindowsImpl.h` 从公共的 `SOURCES` 和 `HEADERS` 变量中移除。实际上，我们将它们添加到了 `windows`
    平台作用域中。当为其他平台构建时，这些文件将不会被qmake处理。这就是为什么我们可以在 `SysInfoWindowsImpl.cpp` 源文件中安全地包含特定的头文件，如
    `windows.h`，而不会损害其他平台的编译。
- en: Adding the Linux implementation
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Linux实现
- en: Let's make the Linux implementation of our `ch02-sysinfo` project. If you have
    already done the Windows implementation, it will be a piece of cake! If you have
    not, you should take a look at it. Some information and tips will not be repeated
    in this part, such as how to create a `SysInfo` implementation class, keyboard
    shortcuts, and details about the `SysInfo` interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现我们的 `ch02-sysinfo` 项目的 Linux 版本。如果你已经完成了 Windows 版本的实现，这将是一件轻而易举的事情！如果你还没有，你应该看看它。本部分中不会重复一些信息和技巧，例如如何创建
    `SysInfo` 实现类、键盘快捷键以及 `SysInfo` 接口的详细信息。
- en: 'Create a new C++ class called `SysInfoLinuxImpl` that inherits from the `SysInfo`
    class, and insert virtual functions from the base class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 C++ 类 `SysInfoLinuxImpl`，它继承自 `SysInfo` 类，并插入基类中的虚拟函数：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will start by implementing the `memoryUsed()` function in the file `SysInfoLinuxImpl.cpp`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在文件 `SysInfoLinuxImpl.cpp` 中实现 `memoryUsed()` 函数：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function uses Linux-specific API. After adding the required includes, you
    can use the Linux `sysinfo()` function that returns information on the overall
    system statistics. With the total memory and the total memory used, we can easily
    return the `percent` value. Note that swap memory has been taken into account.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用 Linux 特定的 API。在添加所需的包含文件后，你可以使用返回整体系统统计信息的 Linux `sysinfo()` 函数。有了总内存和已用内存，我们可以轻松地返回
    `percent` 值。请注意，交换内存已被考虑在内。
- en: 'The CPU load feature is a little more complex than the memory feature. Indeed,
    we will retrieve from Linux the total amount of time the CPU spent performing
    different kinds of work. That is not exactly what we want. We must return the
    instantaneous CPU load. A common way to get it is to retrieve two sample values
    in a short period of time and use the difference to get the instantaneous CPU
    load:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 负载功能比内存功能稍微复杂一些。实际上，我们将从 Linux 检索 CPU 执行不同类型工作的总耗时。这并不是我们想要的。我们必须返回瞬时 CPU
    负载。获取它的常见方法是在短时间内检索两个样本值，并使用差异来获取瞬时 CPU 负载：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this implementation, we will only add one helper function and one member
    variable:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们只添加一个辅助函数和一个成员变量：
- en: 'The `cpuRawData()` is a function that will perform the Linux API call to retrieve
    system timing information and return values in a `QVector` class of `qulonglong`
    type. We retrieve and return four values containing the time the CPU has spent
    on the following: normal processes in User mode, nice processes in User mode,
    processes in Kernel mode, and idle.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpuRawData()` 是一个将执行 Linux API 调用来检索系统时间信息并以 `qulonglong` 类型的 `QVector` 返回值的函数。我们检索并返回四个值，包含
    CPU 在以下方面的耗时：用户模式下的普通进程、用户模式下的优先进程、内核模式下的进程和空闲时间。'
- en: The `mCpuLoadLastValues` is a variable that will store a sample of system timing
    at a given moment.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mCpuLoadLastValues` 是一个变量，它将存储在给定时刻的系统时间样本。'
- en: 'Let''s go to the `SysInfoLinuxImpl.cpp` file to update it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到 `SysInfoLinuxImpl.cpp` 文件来更新它：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As discussed before, the `cpuLoadAverage` function will need two samples to
    be able to compute an instantaneous CPU load average. Calling the `init()` function
    allows us to set `mCpuLoadLastValues` for the first time:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`cpuLoadAverage` 函数需要两个样本才能计算瞬时 CPU 负载平均值。调用 `init()` 函数允许我们第一次设置 `mCpuLoadLastValues`：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To retrieve the CPU raw information on a Linux system, we chose to parse information
    available in the `/proc/stat` file. All we need is available on the first line,
    so a single `readLine()` is enough. Even though Qt provides some useful features,
    sometimes the C standard library functions are simpler. This is the case here;
    we are using `std::sscanf` to extract variables from a string. Now let''s look
    at the `cpuLoadAvearge()` body:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 系统上检索 CPU 的原始信息，我们选择解析 `/proc/stat` 文件中可用的信息。所有需要的信息都在第一行，所以只需要一个 `readLine()`
    就足够了。尽管 Qt 提供了一些有用的功能，但有时 C 标准库函数更简单。这里就是这样；我们正在使用 `std::sscanf` 从字符串中提取变量。现在让我们看看
    `cpuLoadAverage()` 函数的实现：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is where the magic happens. In this last function, we put all the puzzle
    pieces together. This function uses two samples of the CPU raw data. The first
    sample comes from our member variable `mCpuLoadLastValues`, set the first time
    by the `init()` function. The second sample is requested by the `cpuLoadAverage()`
    function. Then the `mCpuLoadLastValues` variable will store the new sample that
    will be used as the first sample on the next `cpuLoadAverage()` function call.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了魔法。在这个最后的函数中，我们将所有的拼图碎片组合在一起。这个函数使用了两个 CPU 原始数据样本。第一个样本来自我们的成员变量 `mCpuLoadLastValues`，它由
    `init()` 函数首次设置。第二个样本由 `cpuLoadAverage()` 函数请求。然后 `mCpuLoadLastValues` 变量将存储新的样本，该样本将在下一次
    `cpuLoadAverage()` 函数调用时用作第一个样本。
- en: 'The `percent` equation should be easy to understand:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`percent` 方程应该很容易理解：'
- en: '`overall` is equal to user + nice + kernel'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overall` 等于 user + nice + kernel'
- en: '`total` is equal to overall + idle'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total` 等于 overall + idle'
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can find more information about `/proc/stat` in the Linux Kernel documentation
    at [https://www.kernel.org/doc/Documentation/filesystems/proc.txt](https://www.kernel.org/doc/Documentation/filesystems/proc.txt).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Linux 内核文档中找到更多关于 `/proc/stat` 的信息，请参阅 [https://www.kernel.org/doc/Documentation/filesystems/proc.txt](https://www.kernel.org/doc/Documentation/filesystems/proc.txt)。
- en: 'Like the other implementations, the last thing to do is to edit the `ch02-sysinfo.pro`
    file like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他实现一样，最后要做的就是编辑 `ch02-sysinfo.pro` 文件，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this Linux scope condition in the `ch02-sysinfo.pro` file, our Linux-specific
    files will not be processed by the `qmake` command on other platforms.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ch02-sysinfo.pro` 文件中，使用这个 Linux 范围条件，我们的 Linux 特定文件将不会被其他平台上的 `qmake` 命令处理。
- en: Adding the Mac OS implementation
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Mac OS 实现
- en: 'Let''s take a look at the Mac implementation of the `SysInfo` class. Start
    by creating a new C++ class named `SysInfoMacImpl` that inherits from the `SysInfo`
    class. Override `SysInfo` virtual functions and you should have a `SysInfoMacImpl.h`
    file like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `SysInfo` 类的 Mac 实现。首先创建一个名为 `SysInfoMacImpl` 的新 C++ 类，它继承自 `SysInfo`
    类。覆盖 `SysInfo` 虚拟函数，您应该有一个类似于这样的 `SysInfoMacImpl.h` 文件：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first implementation we will do will be the `memoryUsed()` function, in
    the `SysInfoMacImpl.cpp` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一个实现将是 `memoryUsed()` 函数，在 `SysInfoMacImpl.cpp` 文件中：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We start by including the different headers for the Mac OS kernel. Then we initialize
    `machPort` with the call to the `mach_host_self()` function. A `machPort` is a
    kind of special connection to the kernel that enables us to request information
    about the system. We then proceed to prepare other variables so that we can retrieve
    virtual memory statistics with `host_statistics64()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含 Mac OS 内核的不同头文件。然后通过调用 `mach_host_self()` 函数初始化 `machPort`。`machPort`
    是一种特殊的连接到内核的方式，使我们能够请求有关系统的信息。然后我们继续准备其他变量，以便我们可以使用 `host_statistics64()` 函数检索虚拟内存统计信息。
- en: 'When the `vmStats` class is filled with the information needed, we extract
    the relevant data: the `freeMemory` and the `totalMemoryUsed`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `vmStats` 类填充了所需的信息时，我们提取相关数据：`freeMemory` 和 `totalMemoryUsed`。
- en: 'Note that Mac OS has a peculiar way of managing its memory: it keeps a lot
    of memory in cache, ready to be flushed when needed. This implies that our statistics
    can be misled; we see the memory as used, whereas it was simply kept "just in
    case".'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Mac OS 有一种独特的内存管理方式：它保留了很多内存在缓存中，以便在需要时刷新。这意味着我们的统计数据可能会误导；我们看到内存被使用，而实际上它只是被保留“以防万一”。
- en: The percentage calculation is straightforward; we still return a min/max clamped
    value to avoid any crazy values in our future graph.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比计算很简单；我们仍然返回一个 min/max 压缩值，以避免未来图表中出现任何疯狂值。
- en: 'Next comes the `cpuLoadAverage()` implementation. The pattern is always the
    same; take samples at regular intervals and compute the growth on this interval.
    Therefore, we have to store intermediate values to be able to calculate the difference
    with the next sample:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `cpuLoadAverage()` 的实现。模式始终相同；在固定间隔内取样本并计算该间隔的增长。因此，我们必须存储中间值，以便能够计算与下一个样本的差异：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the pattern used is strictly equivalent to the Linux implementation.
    You can even copy-paste the body of the `cpuLoadAverage()` function from the `SysInfoLinuxImpl.cpp`
    file. They do exactly the same thing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用的模式严格等同于 Linux 实现。您甚至可以直接复制粘贴 `SysInfoLinuxImpl.cpp` 文件中 `cpuLoadAverage()`
    函数的主体。它们执行的是完全相同的事情。
- en: Now, the implementation is different for the `cpuRawData()` function. We load `cpuInfo`
    and `cpuCount` with `host_statistics()` and then we loop through each CPU to have
    the `totalUser`, `totalUserNice`, `totalSystem`, and `totalIdle` functions filled.
    Finally, we append all this data to the `rawData` object before returning it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于`cpuRawData()`函数的实现是不同的。我们使用`host_statistics()`函数加载`cpuInfo`和`cpuCount`，然后我们遍历每个CPU，使`totalUser`、`totalUserNice`、`totalSystem`和`totalIdle`函数得到填充。最后，我们在返回之前将所有这些数据追加到`rawData`对象中。
- en: 'The very last part is to compile the `SysInfoMacImpl` class only on Mac OS.
    Modify the `.pro` file to have the following body:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是将`SysInfoMacImpl`类仅在Mac OS上编译。修改`.pro`文件，使其具有以下内容：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Transforming SysInfo into a singleton
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SysInfo转换为单例
- en: 'Promises are made to be kept: we will now transform the `SysInfo` class into
    a singleton. C++ offers many ways to implement the singleton design pattern. We
    will explain one of them here. Open the `SysInfo.h` file and make the following
    changes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺必须遵守：我们现在将`SysInfo`类转换为单例。C++提供了许多实现单例设计模式的方法。我们在这里将解释其中的一种。打开`SysInfo.h`文件并做出以下更改：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The singleton must guarantee that there will be only one instance of the class
    and that this instance will be easily accessible from a single access point.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 单例必须保证只有一个类的实例，并且这个实例可以从单个访问点轻松访问。
- en: So the first thing to do is to change the visibility of the constructor to `protected`.
    This way, only this class and the child classes will be allowed to call the constructor.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先要做的是将构造函数的可见性更改为`protected`。这样，只有这个类及其子类才能调用构造函数。
- en: Since only one instance of the object must exist, allowing the copy constructor
    and the assignment operator is nonsense. One way to solve the problem is to make
    them `private`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于必须只有一个对象实例存在，允许复制构造函数和赋值运算符是没有意义的。解决这个问题的方法之一是将它们设置为`private`。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**C++ tip**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++技巧**'
- en: Since C++11, you can define a function as deleted with the syntax void `myFunction()
    = delete`. Any use of a deleted function will display a compile-time error. It's
    another way to prevent the use of the copy constructor and the assignment operator
    with a singleton.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，你可以使用语法`void myFunction() = delete`定义一个已删除的函数。任何使用已删除函数的操作都将显示编译时错误。这是防止使用单例的复制构造函数和赋值运算符的另一种方法。
- en: The last change is the "unique access point" with a `static` function instance
    that will return a reference of the `SysInfo` class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改是“唯一访问点”，它有一个`static`函数实例，将返回`SysInfo`类的引用。
- en: 'It is now time to commit singleton changes to the `SysInfo.cpp` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将单例更改提交到`SysInfo.cpp`文件中：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here you can see another Qt cross-OS trick. Qt provides some macro `Q_OS_WIN`, `Q_OS_LINUX`,
    or `Q_OS_MAC`. A Qt OS macro will be defined only on the corresponding OS. By
    combining these macros with a conditional preprocessor directive`#ifdef`, we can
    always include and instantiate the correct `SysInfo` implementation on all OSes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到另一个Qt跨平台技巧。Qt提供了一些宏`Q_OS_WIN`、`Q_OS_LINUX`或`Q_OS_MAC`。只有对应操作系统的Qt OS宏才会被定义。通过将这些宏与条件预处理器指令`#ifdef`结合使用，我们可以在所有操作系统上始终包含和实例化正确的`SysInfo`实现。
- en: Declaring the `singleton` variable as a static variable in the `instance()`
    function is a way to make a singleton in C++. We tend to prefer this version because
    you do not need to worry about the singleton memory management. The compiler will
    handle the instantiation the first time as well as the destruction. Moreover,
    since C++11 this method is thread safe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将`singleton`变量声明为`instance()`函数中的静态变量是C++中创建单例的一种方法。我们倾向于选择这个版本，因为你不需要担心单例的内存管理。编译器将处理第一次实例化和销毁。此外，自C++11以来，这种方法是线程安全的。
- en: Exploring Qt Charts
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Qt图表
- en: The core part is ready. It's now time to create a UI for this project, and Qt
    Charts can help us with this task. Qt Charts is a module that provides a set of
    easy-to-use chart components, such as line chart, area chart, spline chart, pie
    chart, and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 核心部分已经准备好了。现在是时候为这个项目创建一个用户界面了，Qt Charts可以帮助我们完成这个任务。Qt Charts是一个模块，它提供了一套易于使用的图表组件，例如折线图、面积图、样条图、饼图等等。
- en: Qt Charts was previously a commercial-only Qt module. Since Qt 5.7, the module
    is now included in Qt on GPLv3 license for open source users. If you are stuck
    on Qt 5.6, you can build the module by yourself from sources. More information
    can be found at [https://github.com/qtproject/qtcharts](https://github.com/qtproject/qtcharts).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Charts 之前是一个仅限商业的 Qt 模块。从 Qt 5.7 开始，该模块现在包含在 Qt 中，对于开源用户，它是在 GPLv3 许可证下。如果你卡在
    Qt 5.6 上，你可以从源代码构建该模块。更多信息可以在 [https://github.com/qtproject/qtcharts](https://github.com/qtproject/qtcharts)
    找到。
- en: 'The aim now is to create two Qt widgets, `CpuWidget` and `MemoryWidget`, to
    display nice Qt charts of the CPU and the memory used. These two widgets will
    share a lot of common tasks, so we will first create an abstract class, `SysInfoWidget`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的目标是创建两个 Qt 控件，`CpuWidget` 和 `MemoryWidget`，以显示 CPU 和内存使用的漂亮的 Qt 图表。这两个控件将共享许多共同的任务，因此我们首先创建一个抽象类，`SysInfoWidget`：
- en: '![Exploring Qt Charts](img/image00361.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![探索 Qt 图表](img/image00361.jpeg)'
- en: Then the two actual widgets will inherit from the `SysInfoWidget` class and
    perform their specific tasks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这两个实际的控件将从 `SysInfoWidget` 类继承并执行它们特定的任务。
- en: 'Create a new C++ class called `SysInfoWidget` with `QWidget` as a base class.
    Some enhancements must be processed in the `SysInfoWidget.h` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `SysInfoWidget` 的新 C++ 类，以 `QWidget` 作为基类。在 `SysInfoWidget.h` 文件中必须处理一些增强：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `QChartView` is the generic widget that can display many types of chart.
    This class will handle the layout and display the `QChartView`. A `QTimer` will
    call the slot function `updateSeries()` regularly. As you can see, this is a pure
    virtual slot. That is the reason why the `SysInfoWidget` class is abstract. The
    slot `updateSeries()` will be overridden by child classes to retrieve a system
    value and define how the chart should be drawn. Note that the parameters `startDelayMs`
    and `updateSeriesDelayMs` have default values that can be customized by the caller
    if required.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`QChartView` 是一个通用的控件，可以显示多种类型的图表。这个类将处理布局并显示 `QChartView`。一个 `QTimer` 将会定期调用
    `updateSeries()` 槽函数。正如你所见，这是一个纯虚槽。这就是为什么 `SysInfoWidget` 类是抽象的。`updateSeries()`
    槽函数将被子类覆盖以检索系统值并定义图表应该如何绘制。请注意，参数 `startDelayMs` 和 `updateSeriesDelayMs` 有默认值，如果需要，调用者可以自定义这些值。'
- en: 'We can now proceed to the `SysInfoWidget.cpp` file to correctly prepare this `SysInfoWidget`
    class before creating the child widgets:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到 `SysInfoWidget.cpp` 文件，在创建子控件之前正确准备这个 `SysInfoWidget` 类：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: All tasks in the `SysInfoWidget` constructor are common tasks required by the
    child widgets, `CpuWidget`, and `MemoryWidget`. The first step is the `mRefreshTimer`
    initialization to define the timer interval and the slot to call whenever a timeout
    signal is triggered. Then the static function `QTimer::singleShot()` will start
    the real timer after a delay defined by `startDelayMs`. Here again, Qt combined
    with lambda functions will give us a powerful code in just a few lines. The next
    part enables the antialiasing to smooth the chart drawing. We hide the chart's
    legend to get a minimalist display. The last part handles the layout to display
    the `QChartView` widget in our `SysInfoWidget` class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`SysInfoWidget` 构造函数中的所有任务都是子控件 `CpuWidget` 和 `MemoryWidget` 所需要的共同任务。第一步是初始化
    `mRefreshTimer` 以定义计时器间隔和每当超时信号被触发时调用的槽函数。然后，静态函数 `QTimer::singleShot()` 将在 `startDelayMs`
    定义的延迟后启动真正的计时器。在这里，Qt 结合 lambda 函数将只使用几行代码就给我们一个强大的功能。下一部分启用了抗锯齿以平滑图表绘制。我们隐藏图表的图例以获得简约的显示。最后一部分处理布局以在
    `SysInfoWidget` 类中显示 `QChartView` 控件。'
- en: CpuWidget using QCharts
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 QCharts 的 CpuWidget
- en: 'Now that the base class `SysInfoWidget` is ready, let''s implement its first
    child class: `CpuWidget`. We will now use the Qt Charts API to display a good-looking
    widget. The average CPU load will be displayed in a pie graph with a hole in the
    center, like a partly eaten donut where the eaten part is the percentage of the
    CPU used. The first step is to add a new C++ class named `CpuWidget` and make
    it inherit `SysInfoWidget`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基类 `SysInfoWidget` 已经准备好了，让我们实现它的第一个子类：`CpuWidget`。我们将现在使用 Qt Charts API
    来显示一个好看的控件。平均 CPU 负载将以一个中心有洞的饼图显示，就像一个部分被吃掉的甜甜圈，被吃掉的部分是 CPU 使用率的百分比。第一步是添加一个名为
    `CpuWidget` 的新 C++ 类，并使其继承 `SysInfoWidget`：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the constructor, the only parameter needed is a `QWidget* parent`. Since
    we provided default values for the `startDelayMs` and `updateSeriesDelayMs` variables
    in `SysInfoWidget` class, we get the best possible behavior; there is no need
    to remember it when subclassing `SysInfoWidget`, but it is still easy to override
    it if need be.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，唯一需要的参数是 `QWidget* parent`。由于我们在 `SysInfoWidget` 类中为 `startDelayMs` 和
    `updateSeriesDelayMs` 变量提供了默认值，我们得到了最佳的行为；在子类化 `SysInfoWidget` 时不需要记住它，但如果需要，仍然可以轻松地覆盖它。
- en: 'The next step is to override the `updateSeries()` function from the `SysInfoWidget`
    class and start using the Qt Charts API:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是重写 `SysInfoWidget` 类中的 `updateSeries()` 函数并开始使用 Qt Charts API：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since we overrode the `SysInfoWidget::updateSeries()` slot, we have to include
    the `Q_OBJECT` macro to allow `CPUWidget` to respond to the `SysInfoWidgetmRefreshTimer::timeout()`
    signal.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们重写了 `SysInfoWidget::updateSeries()` 插槽，我们必须包含 `Q_OBJECT` 宏，以便 `CPUWidget`
    能够响应 `SysInfoWidgetmRefreshTimer::timeout()` 信号。
- en: We include `QPieSeries` from the Qt Charts module so that we can create a member `QPieSeries*`
    named `mSeries`. The `QPieSeries` is a subclass of `QAbstractSeries`, which is
    the base class of all Qt Charts series (`QLineSeries`, `QAreaSeries`, `QPieSeries`,
    and so on). In Qt Charts, a `QAbstractSeries` subclass holds the data you want
    to display and defines how it should be drawn, but it does not define where the
    data should be displayed inside your layout.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Qt Charts 模块中包含 `QPieSeries`，以便我们可以创建一个名为 `mSeries` 的成员 `QPieSeries*`。`QPieSeries`
    是 `QAbstractSeries` 的子类，它是所有 Qt Charts 系列的基类（`QLineSeries`、`QAreaSeries`、`QPieSeries`
    等）。在 Qt Charts 中，`QAbstractSeries` 子类持有你想要显示的数据，并定义了它应该如何绘制，但它不定义数据应该在哪里显示在你的布局中。
- en: 'We can now proceed to `CpuWidget.cpp` to investigate how we can tell Qt where
    the drawing takes place:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到 `CpuWidget.cpp` 文件，调查我们如何告诉 Qt 绘图的位置：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All Qt Charts classes are defined in the `QtCharts` namespace. This is why we
    start with `using namespace QtCharts`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Qt Charts 类都是在 `QtCharts` 命名空间中定义的。这就是为什么我们以 `using namespace QtCharts` 开始。
- en: 'First, we initialize `mSeries` in the constructor initializer list. We then
    proceed to configure it. We carve the donut with `mSeries->setHoleSize(0.35)`
    and we append two data sets to `mSeries`: a fake `CPU Load` and `Cpu Free`, which
    are expressed in percentages. The `mSeries` function is now ready to be linked
    to the class managing its drawing: `QChart`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在构造函数初始化列表中初始化 `mSeries`，然后继续配置它。我们使用 `mSeries->setHoleSize(0.35)` 切割甜甜圈，并将两个数据集添加到
    `mSeries`：一个是假的 `CPU Load` 和 `Cpu Free`，它们以百分比表示。现在 `mSeries` 函数已经准备好与负责其绘制的类链接：`QChart`。
- en: 'The `QChart` class is retrieved from the `SysInfoWidget::chartView()` function.
    When calling `chart->addSeries(mSeries)`, `chart` takes the ownership of `mSeries`
    and will draw it according to the series type--in our case, a `QPieSeries`. `QChart`
    is not a `QWidget`: it is a subclass of `QGraphicsWidget`. `QGraphicsWidget` can
    be described as a lighter `QWidget` with some differences (its coordinates and
    geometry are defined with `doubles` or `floats` instead of `integers`, a subset
    of `QWidget` attributes are supported: custom drag, drop framework, and so on).
    The `QGraphicsWidget` class is designed to be added in a `QGraphicsScene` class,
    a high-performance Qt component used to draw hundreds of items on screen at the
    same time.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`QChart` 类是从 `SysInfoWidget::chartView()` 函数中检索的。当调用 `chart->addSeries(mSeries)`
    时，`chart` 接管了 `mSeries` 的所有权，并将根据系列类型绘制它——在我们的例子中，是一个 `QPieSeries`。`QChart` 不是一个
    `QWidget`：它是 `QGraphicsWidget` 的子类。`QGraphicsWidget` 可以被描述为一个比 `QWidget` 更轻量级的组件，有一些不同（它的坐标和几何形状使用
    `doubles` 或 `floats` 而不是 `integers` 定义，支持 `QWidget` 属性的子集：自定义拖放框架等）。`QGraphicsWidget`
    类被设计为添加到 `QGraphicsScene` 类中，这是一个高性能的 Qt 组件，用于同时绘制屏幕上的数百个项。'
- en: In our `SysInfo` application, the `QChart` has to be displayed in a `QVBoxLayout`
    in `SysInfoWidget`. Here, the `QChartView` class comes in very handy. It lets
    us add `chart` in a `QWidget` layout.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `SysInfo` 应用程序中，`QChart` 必须在 `SysInfoWidget` 中的 `QVBoxLayout` 中显示。在这里，`QChartView`
    类非常有用。它允许我们在 `QWidget` 布局中添加 `chart`。
- en: 'Up to now, `QPieSeries` has seemed rather abstract. Let''s add it to the `MainWindow`
    file to see how it looks:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`QPieSeries` 似乎相当抽象。让我们将它添加到 `MainWindow` 文件中，看看它的样子：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We simply declare `mCpuWidget` in the `MainWindow.h` file, initialize it, and
    add it to `MainWindow->centralWidget->layout`. If you now run the application,
    you should see something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在 `MainWindow.h` 文件中声明 `mCpuWidget`，初始化它，并将其添加到 `MainWindow->centralWidget->layout`。如果你现在运行应用程序，你应该看到类似这样的内容：
- en: '![CpuWidget using QCharts](img/image00362.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QCharts 的 CpuWidget](img/image00362.jpeg)'
- en: Even though it looks cool, this donut is a bit static and does not reflect the
    CPU usage. Thanks to the architecture we built with the `SysInfo` and `SysInfoWidget`
    classes, the remaining part will be implemented swiftly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来很酷，但这个甜甜圈有点静态，并不能反映CPU的使用情况。多亏了我们用`SysInfo`和`SysInfoWidget`类构建的架构，接下来的部分将迅速实现。
- en: 'Switch back to the `CpuWidget.cpp` file and implement the `updateSeries()`
    function with the following body:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回`CpuWidget.cpp`文件，并实现具有以下主体的`updateSeries()`函数：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we get a reference to our `SysInfo` singleton. We then retrieve the current
    average CPU load in the `cpuLoadAverage` variable. We have to feed this data to
    our `mSeries`. The `mSeries` object is a `QPieCharts`, which implies that we just
    want a snapshot of the current CPU average load. Past history is not meaningful
    with this kind of graph; that's why we clear the `mSeries` data with the `mSeries->clear()`
    syntax, and append the `cpuLoadAverage` variable and then the free part (`100.0
    - cpuLoadAverage`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取对`SysInfo`单例的引用。然后我们在`cpuLoadAverage`变量中检索当前的CPU平均负载。我们必须将此数据提供给我们的`mSeries`。`mSeries`对象是一个`QPieCharts`，这意味着我们只想获取当前CPU平均负载的快照。与这种类型的图表相比，过去的历史没有意义；这就是为什么我们使用`mSeries->clear()`语法清除`mSeries`数据，并附加`cpuLoadAverage`变量以及空闲部分（`100.0
    - cpuLoadAverage`）。
- en: 'The nice thing to note is that, in the `CpuWidget` class, we don''t have to
    worry about refreshing. All the work is done in the `SysInfoWidget` subclass with
    all the whistles and bells of the `QTimer` class. In a `SysInfoWidget` subclass,
    we only have to concentrate on the valuable specific code: what data should be
    displayed and what kind of graph is used to display it. If you look at the whole `CpuWidget`
    class, it is very short. The next `SysInfoWidget` subclass, `MemoryWidget`, will
    also be very concise, as well as quick to implement.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在`CpuWidget`类中，我们无需担心刷新问题。所有的工作都在`SysInfoWidget`子类中完成，该子类使用了`QTimer`类的所有功能和铃声。在`SysInfoWidget`子类中，我们只需专注于有价值的特定代码：应该显示哪些数据以及使用什么类型的图表来显示它。如果你查看整个`CpuWidget`类，它非常简短。下一个`SysInfoWidget`子类，`MemoryWidget`，也将非常简洁，并且易于实现。
- en: Memory using Qcharts
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qcharts进行内存使用
- en: 'Our second `SysInfoWidget` is a `MemoryWidget` class. This widget will display
    a history of the data so that we can see how the memory consumption evolves over
    time. To display this data, we will use a `QLineSeries` class from the Qt Chart
    module. Create the `MemoryWidget` class and follow the same pattern we used for `CpuWidget`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个`SysInfoWidget`是一个`MemoryWidget`类。这个小部件将显示数据的历史记录，以便我们可以看到内存消耗随时间的变化。为了显示这些数据，我们将使用来自Qt
    Chart模块的`QLineSeries`类。创建`MemoryWidget`类，并遵循我们为`CpuWidget`使用的相同模式：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead of a being a `QPieSeries*`, `mSeries` is a type of `QLineSeries*` which
    will be linked to the `chart` object in a very similar fashion to `MemoryWidget.cpp`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与`QPieSeries*`不同，`mSeries`是一种`QLineSeries*`类型，它将以与`MemoryWidget.cpp`非常相似的方式链接到`chart`对象：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `mSeries` data is, as usual, initialized in the initializer list. The `mPointPositionX`
    is an `unsigned long long` (using the Qt notation `qint64`) variable that will
    track the last X position of our data set. This huge value is used to make sure
    that `mPointPositionX` never overflows.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`mSeries`数据，如往常一样，在初始化列表中初始化。`mPointPositionX`是一个`unsigned long long`（使用Qt表示法`qint64`）变量，它将跟踪数据集的最后一个X位置。这个巨大的值用于确保`mPointPositionX`永远不会溢出。'
- en: We then use an intermediate `areaSeries` that takes ownership of `mSeries` upon
    its initialization in `QAreaSeries* areaSeries = new QareaSeries(mSeries)`. `areaSeries`
    is then added to the `chart` object at `chart->addSeries(areaSeries)`. We do not
    want to display a single line in our `QChart`; instead we want to display an area
    that represents the used memory percentage. That is why we use an `areaSeries`
    type. Nonetheless, we will still update the `mSeries` data when adding new points
    to the dataset in the `updateSeries()` function. The `areaSeries` type will automatically
    handle them and deliver them to the `chart` object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个中间的`areaSeries`，它在`QAreaSeries* areaSeries = new QareaSeries(mSeries)`初始化时接管`mSeries`的所有权。然后`areaSeries`被添加到`chart`对象中，在`chart->addSeries(areaSeries)`处。我们不想在`QChart`中显示单一线条；相反，我们想显示一个表示已使用内存百分比的区域。这就是为什么我们使用`areaSeries`类型。尽管如此，我们仍然会在`updateSeries()`函数中向数据集添加新点时更新`mSeries`数据。`areaSeries`类型将自动处理它们并将它们传递给`chart`对象。
- en: 'After `chart->addSeries(areaSeries)`, we configure the chart display:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chart->addSeries(areaSeries)`之后，我们配置图表显示：
- en: The `chart->createDefaultAxes()` function creates an *X* and *Y* axis based
    on the `areaSeries` type. If we used a 3D series, the `createDefaultAxes()` function
    would have added a *Z* axis.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chart->createDefaultAxes()` 函数基于 `areaSeries` 类型创建一个 *X* 和 *Y* 轴。如果我们使用 3D
    系列，`createDefaultAxes()` 函数将添加一个 *Z* 轴。'
- en: Hide the *X* axis tick values with `chart->axisX()->setVisible(false)` (intermediate
    values displayed at the bottom of the axis). In our `MemoryWidget` class, this
    information is not relevant.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `chart->axisX()->setVisible(false)`（在轴底部显示中间值）隐藏 *X* 轴的刻度值。在我们的 `MemoryWidget`
    类中，这个信息是不相关的。
- en: To define the number of points we want to display--the size of the display history--we
    call `chart->axisX()->setRange(0, CHART_X_RANGE_MAX)`. Here we use a constant
    to make it easier to modify this value afterwards. Seeing the value at the top
    of the file, we avoid having to skim through `MemoryWidget.cpp`, searching where
    this value is used to update it.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了定义我们想要显示的点数——显示历史的大小——我们调用 `chart->axisX()->setRange(0, CHART_X_RANGE_MAX)`。在这里，我们使用一个常量以便以后更容易修改这个值。看到文件顶部的值，我们避免了在
    `MemoryWidget.cpp` 中搜索这个值用于更新的需要。
- en: '`chart->axisY()->setRange(0, 100)` defines the maximum range of the *Y* axis,
    which is a percentage, based on the value returned by the `SysInfo::memoryUsed()`
    function.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chart->axisY()->setRange(0, 100)` 定义了 *Y* 轴的最大范围，这是一个百分比，基于 `SysInfo::memoryUsed()`
    函数返回的值。'
- en: 'The chart is now properly configured. We now have to feed it by filling the
    `updateSeries()` body:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图表现在已正确配置。我们现在必须通过填充 `updateSeries()` 主体来给它提供数据：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We first retrieve the latest memory percentage used and append it to `mSeries`
    at the *X* coordinate `mPointPositionX` (we post-increment it for the next `updateSeries()`
    call) and *Y* coordinate `memoryUsed`. As we want to keep a history of `mSeries`, `mSeries->clear()`
    is never called. However, what will happen when we add more than `CHART_X_RANGE_COUNT`
    points? The visible "window" on the chart is static and the points will be added
    outside. This means that we will see the memory usage only for the first `CHART_X_RANGE_MAX`
    points and then, nothing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检索最新的内存使用百分比，并将其追加到 `mSeries` 的 *X* 坐标 `mPointPositionX`（我们后增量它以供下一次 `updateSeries()`
    调用使用）和 *Y* 坐标 `memoryUsed`。由于我们想保留 `mSeries` 的历史记录，`mSeries->clear()` 从未调用。然而，当我们添加超过
    `CHART_X_RANGE_COUNT` 个点时会发生什么？图表上的可见“窗口”是静态的，点将被添加到外部。这意味着我们只能看到前 `CHART_X_RANGE_MAX`
    个点的内存使用情况，然后就没有了。
- en: Fortunately, `QChart` provides a function to scroll inside the view to move
    the visible window. We start to handle this case only when the dataset is bigger
    than the visible window, meaning `if (mSeries->count() > CHART_X_RANGE_COUNT)`.
    We then remove the point at the index 0 with `mSeries->remove(0)` to ensure that
    the widget will not store an infinite dataset. A SysInfo application that monitors
    the memory usage and has itself a memory leak is a bit sad.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`QChart` 提供了一个在视图中滚动以移动可见窗口的功能。我们只有在数据集大于可见窗口时才开始处理这种情况，即 `if (mSeries->count()
    > CHART_X_RANGE_COUNT)`。然后我们使用 `mSeries->remove(0)` 移除索引 0 处的点，以确保小部件不会存储无限的数据集。一个监控内存使用并自身存在内存泄漏的
    SysInfo 应用程序有点令人沮丧。
- en: The syntax `chart->scroll(chart->plotArea().width() / CHART_X_RANGE_MAX, 0)`
    will then scroll to the latest point on the *X* axis and nothing on *Y*. The `chart->scroll(dx,
    dy)` expects coordinates expressed in our series coordinates. That is the reason
    why we have to retrieve the `char->plotArea()` divided by `CHART_X_RANGE_MAX`
    , the *X* axis unit.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 语法 `chart->scroll(chart->plotArea().width() / CHART_X_RANGE_MAX, 0)` 将滚动到 *X*
    轴上的最新点，而 *Y* 轴上没有点。`chart->scroll(dx, dy)` 期望使用我们的系列坐标表示的坐标。这就是为什么我们必须检索 `char->plotArea()`
    除以 `CHART_X_RANGE_MAX`，即 *X* 轴单位。
- en: 'We can now add the `MemoryWidget` class in `MainWindow`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 `MainWindow` 中添加 `MemoryWidget` 类：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: "Just as we did for `CPUWidget`, add a new member named `mMemoryWidget` to `MainWindow`\
    \ and add it to the `centralWidget` layout with the `uiâ\x86\x92centralWidget->layout()->addWidget(&mMemoryWidget)`\
    \ syntax."
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: "正如我们在 `CPUWidget` 中所做的那样，向 `MainWindow` 添加一个名为 `mMemoryWidget` 的新成员，并使用 `uiâ\x86\
    \x92centralWidget->layout()->addWidget(&mMemoryWidget)` 语法将其添加到 `centralWidget`\
    \ 布局中。"
- en: 'Compile, run the application, and wait a few seconds. You should see something
    close to this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 编译、运行应用程序，并等待几秒钟。你应该看到类似以下内容：
- en: '![Memory using Qcharts](img/image00363.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Qcharts 的内存使用情况](img/image00363.jpeg)'
- en: 'The `MemoryWidget` class works fine, but it looks a bit dull. We can customize
    it very easily with Qt. The goal is to have a bold line at the top of the memory
    area and a nice gradient from top to bottom. We just have to modify the `areaSeries`
    class in the `MemoryWidget.cpp` file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemoryWidget` 类运行良好，但看起来有点单调。我们可以用 Qt 非常容易地自定义它。目标是让内存区域顶部有一条粗线，从上到下有一个漂亮的渐变。我们只需修改
    `MemoryWidget.cpp` 文件中的 `areaSeries` 类：'
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `QPen pen` function is a part of the `QPainter` API. It is the foundation
    on which Qt relies to do most of the GUI drawing. This includes the whole `QWidget`
    API (`QLabel`, `QPushButton`, `QLayout`, and so on). For the `pen`, we just have
    to specify its color and width, and then apply it to the `areaSeries` class with `areaSeries->setPen(pen)`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPen pen` 函数是 `QPainter` API 的一部分。它是 Qt 依赖以进行大多数 GUI 绘图的基础。这包括整个 `QWidget`
    API (`QLabel`、`QPushButton`、`QLayout` 等)。对于 `pen`，我们只需指定其颜色和宽度，然后通过 `areaSeries->setPen(pen)`
    应用到 `areaSeries` 类。'
- en: 'The principle is the same for the gradient. We define the starting point (`QPointF(0,
    0)`) and the final point (`QPointF(0, 1)`) before specifying the color at each
    end of the vertical gradient. The `QGradient::ObjectBoundingMode` parameter defines
    how the start/final coordinates are mapped to the object. With the `QAreaSeries`
    class, we want the gradient coordinates to match the whole `QareaSeries` class.
    These coordinates are normalized coordinates, meaning that `0` is the start and `1`
    is the end of the shape:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渐变，原理相同。我们在指定垂直渐变每端的颜色之前，定义了起点 (`QPointF(0, 0)`) 和终点 (`QPointF(0, 1)`)。`QGradient::ObjectBoundingMode`
    参数定义了如何将起始/终点坐标映射到对象上。使用 `QAreaSeries` 类时，我们希望渐变坐标与整个 `QareaSeries` 类匹配。这些坐标是归一化坐标，意味着
    `0` 是形状的起点，`1` 是终点：
- en: The `[0.0]` coordinates will point to the top left corner of the `QAreaSeries`
    class
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0.0]` 坐标将指向 `QAreaSeries` 类的左上角'
- en: The `[1.0]` coordinates will point to the bottom left corner of the `QAreaSeries`
    class
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1.0]` 坐标将指向 `QAreaSeries` 类的左下角'
- en: 'A last build and run, and the `SysInfo` application will look like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后进行构建和运行，`SysInfo` 应用程序将看起来像这样：
- en: '![Memory using Qcharts](img/image00364.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Qcharts 的内存使用情况](img/image00364.jpeg)'
- en: A memory leak or starting a virtual machine is a great way to make your memory
    go crazy
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏或启动虚拟机是让你的内存变得疯狂的好方法
- en: The `SysInfo` application is now finished, and we even added some visual polish.
    You can explore the `QGradient` classes and the `QPainter` API if you want to
    further customize the widget to your taste.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`SysInfo` 应用程序现在已经完成，我们甚至添加了一些视觉上的润色。如果你想进一步自定义小部件以符合你的口味，可以探索 `QGradient`
    类和 `QPainter` API。'
- en: The .pro file in depth
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`.pro` 文件深入解析'
- en: When you click on the **Build** button, what exactly is Qt Creator doing? How
    does Qt handle the compilation of the different platforms with a single `.pro`
    file? What does the `Q_OBJECT` macro imply exactly? We will dig into each of these
    questions in the following sections. Our example case will be the `SysInfo` application
    we just completed, and we will study what Qt is doing under the hood.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 **构建** 按钮时，Qt Creator 实际上在做什么？Qt 如何处理单个 `.pro` 文件对不同平台的编译？`Q_OBJECT` 宏的确切含义是什么？我们将在接下来的章节中深入探讨这些问题。我们的示例案例将是刚刚完成的
    `SysInfo` 应用程序，我们将研究 Qt 在底层做了什么。
- en: 'We can start this study by digging into the `.pro` file. It is the main entry
    point in compiling any Qt project. Basically, a `.pro` file is a `qmake` project
    file describing the sources and headers used by the project. It is a platform-agnostic
    definition of a `Makefile`. First, we can cover the different `qmake` keywords
    used in the `ch02-sysinfo` application:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过深入研究 `.pro` 文件开始这项研究。它是编译任何 Qt 项目的入口点。基本上，`.pro` 文件是一个 `qmake` 项目文件，描述了项目使用的源文件和头文件。它是对
    `Makefile` 的平台无关定义。首先，我们可以涵盖在 `ch02-sysinfo` 应用程序中使用的不同 `qmake` 关键字：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Each of these functions has specific roles:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的每一个都有特定的作用：
- en: '`#`: This is the prefix needed to comment on a line. Yes, we generated the
    project on 2016-03-24-crazy, huh?'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#`：这是在行上注释所需的前缀。是的，我们是在 2016-03-24-crazy 日期生成的项目，对吧？'
- en: '`QT`: This is a list of the Qt modules used in the project. In the platform-specific
    Makefile, each of the values will include the module headers and the corresponding
    library link.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QT`：这是项目中使用的 Qt 模块的列表。在特定平台的 Makefile 中，每个值都将包括模块头文件和相应的库链接。'
- en: '`CONFIG`: This is a list of configuration options for the project. Here, we
    configure the support of C++14 in the Makefile.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG`：这是项目配置选项的列表。在这里，我们在 Makefile 中配置了对 C++14 的支持。'
- en: '`TARGET`: This is the name of the target output file.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET`: 这是目标输出文件的名称。'
- en: '`TEMPLATE`: This is the project template used when generating the `Makefile.app`
    tells `qmake` to generate a Makefile targeted for a binary. If you are building
    a library, use the `lib` value.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEMPLATE`: 这是生成`Makefile.app`时使用的项目模板，它告诉qmake生成一个针对二进制的Makefile。如果你正在构建一个库，请使用`lib`值。'
- en: 'In the `ch02-sysinfo` application, we started to use platform-specific compilation
    rules using the intuitive scope mechanism:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch02-sysinfo`应用程序中，我们开始使用平台特定的编译规则，利用直观的作用域机制：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you had to do this with a `Makefile`, you would probably lose some hair
    before doing it right (being bald is not an excuse). This syntax is simple yet
    powerful, and is also used for conditional statements. Let''s say you wanted to
    build some files on debug only. You would have written the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须使用`Makefile`来做这件事，你可能在做对之前会掉一些头发（光头不是借口）。此语法简单而强大，也用于条件语句。假设你只想在调试模式下构建一些文件。你会写出以下内容：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Nesting the `debug` scope inside `windows` is the equivalent of `if (windows
    && debug)`. The scoping mechanism is even more flexible; you can have the OR Boolean
    operator condition with this syntax:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`windows`作用域内嵌套`debug`相当于`if (windows && debug)`。作用域机制更加灵活；你可以使用此语法来具有OR布尔运算符条件：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can even have else if/else statements:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以有else if/else语句：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this code snippet, we also see the use of the `+=` operator. The qmake tool
    provides a wide range of operators to modify the behavior of variables:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们也可以看到`+=`运算符的使用。qmake工具提供了一系列运算符来修改变量的行为：
- en: '`=`: This operator sets the variable to the value. The syntax `SOURCES = SysInfoWindowsImpl.cpp`
    would have assigned the single`SysInfoWindowsImpl.cpp` value to the `SOURCES`
    variable.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`: 此运算符将变量设置为指定的值。例如，`SOURCES = SysInfoWindowsImpl.cpp`会将单个`SysInfoWindowsImpl.cpp`值赋给`SOURCES`变量。'
- en: '`+=`: This operator adds the value to a list of values. This is what we commonly
    use in `HEADERS`, `SOURCES`, `CONFIG`, and so on.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+=`: 此运算符将值添加到值的列表中。这是我们通常在`HEADERS`、`SOURCES`、`CONFIG`等中使用的。'
- en: '`-=`: This operator removes the value from the list. You can, for example,
    add a `DEFINE = DEBUG_FLAG` syntax in the common section and in a platform-specific
    scope (say a Windows release) remove it with the `DEFINE -= DEBUG_FLAG` syntax.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-=`: 此运算符从列表中删除值。例如，你可以在通用部分添加`DEFINE = DEBUG_FLAG`语法，在平台特定的作用域（例如Windows发布版）中，使用`DEFINE
    -= DEBUG_FLAG`语法将其删除。'
- en: '`*=`: This operator adds the value to the list only if it is not already present.
    The `DEFINE *= DEBUG_FLAG` syntax adds the `DEBUG_FLAG` value only once.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*=`: 此运算符只有在值尚未存在于列表中时才将其添加到列表中。`DEFINE *= DEBUG_FLAG`语法只将`DEBUG_FLAG`值添加一次。'
- en: '`~=`: This operator replaces any values that match a regular expression with
    the specified value, `DEFINE ~= s/DEBUG_FLAG/debug`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~=`: 此运算符将匹配正则表达式的任何值替换为指定的值，例如`DEFINE ~= s/DEBUG_FLAG/debug`。'
- en: 'You can also define variables in the `.pro` file and reuse them in different
    places. We can simplify this with the use of the qmake `message()` function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`.pro`文件中定义变量，并在不同的地方重用它们。我们可以通过使用qmake的`message()`函数来简化这一点：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you build the project, you will see your platform-specific message each time
    you build the project in the **General Messages** tab (you can access this tab
    from **Window** | **Output Panes** | **General Messages**). Here, we defined a `COMPILE_MSG`
    variable and referenced it when calling `message($$COMPILE_MSG windows)`. This
    offers interesting possibilities when you need to compile external libraries from
    your `.pro` file. You can then aggregate all the sources in a variable, combine
    it with the call to a specific compiler, and so on.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建项目，你将在每次在**常规消息**选项卡（你可以从**窗口** | **输出面板** | **常规消息**访问此选项卡）构建项目时看到你的平台特定消息。在这里，我们定义了一个`COMPILE_MSG`变量，并在调用`message($$COMPILE_MSG
    windows)`时引用它。当你需要从`.pro`文件编译外部库时，这提供了有趣的可能性。然后你可以将所有源聚合到一个变量中，将其与对特定编译器的调用结合起来，等等。
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If your scope-specific statement is a single line, you can use the following
    syntax to describe it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的作用域特定语句是一行，你可以使用以下语法来描述它：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Besides `message()`, there are a few other helpful functions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`message()`之外，还有一些其他有用的函数：
- en: '`error(string)`: This function displays the string and exits the compilation
    immediately.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error(string)`: 此函数显示字符串并立即退出编译。'
- en: '`exists(filename)`: This function tests the existence of the `filename`. qmake
    also provides the `!` operator, which means you can write `!exist(myfile) { ...
    }`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists(filename)`: 这个函数检查 `filename` 的存在。qmake 还提供了 `!` 操作符，这意味着你可以写 `!exist(myfile)
    { ... }`。'
- en: '`include(filename)`: This function includes the content of another `.pro` file.
    It gives you the ability to slice your `.pro` files into more modular components.
    This will prove very useful when you have multiple `.pro` files for a single big
    project.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include(filename)`: 这个函数包含另一个 `.pro` 文件的内容。它赋予你将 `.pro` 文件切割成更多模块化组件的能力。当你有一个大项目需要多个
    `.pro` 文件时，这将非常有用。'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the built-in functions are described at [http://doc.qt.io/qt-5/qmake-test-function-reference.html](http://doc.qt.io/qt-5/qmake-test-function-reference.html).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内置函数的描述请见 [http://doc.qt.io/qt-5/qmake-test-function-reference.html](http://doc.qt.io/qt-5/qmake-test-function-reference.html)。
- en: Under the hood of qmake
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: qmake 内部结构
- en: As we said earlier, qmake is the foundation of the Qt framework compilation
    system. In Qt Creator, when you click on the **Build** button, qmake is invoked.
    Let's study what qmake is exactly doing by calling it ourselves on the **CLI**
    (**Command Line Interface**).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，qmake 是 Qt 框架编译系统的基础。在 Qt Creator 中，当你点击 **构建** 按钮时，会调用 qmake。让我们通过在
    **命令行界面 (CLI**) 上自己调用它来研究 qmake 究竟在做什么。
- en: 'Create a temporary directory where you will store the generated files. We are
    working on a Linux box, but this is transposable on any OS. We chose `/tmp/sysinfo`.
    Using the CLI, navigate to this new directory and execute the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个临时目录，你将在其中存储生成的文件。我们正在使用一个 Linux 机器，但这可以在任何操作系统上实现。我们选择了 `/tmp/sysinfo`。使用
    CLI，导航到这个新目录并执行以下命令：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This command will execute qmake in the `-makefile` mode to generate a Makefile
    based on your `sysinfo.pro` file. If you skim through the Makefile content, you
    will see many things we covered earlier in the `.pro` section. The link to Qt
    modules, headers of different modules, inclusion of the headers and sources files
    of your project, and so on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将以 `-makefile` 模式执行 qmake，根据你的 `sysinfo.pro` 文件生成一个 Makefile。如果你浏览 Makefile
    的内容，你会看到我们在 `.pro` 部分之前提到过的很多东西。Qt 模块的链接、不同模块的头部文件、包含你的项目头部和源文件，等等。
- en: Now, let's build this Makefile by simply typing the `make` command.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过简单地输入 `make` 命令来构建这个 Makefile。
- en: 'This command will generate the binary `ch02-sysinfo` (based on the `TARGET`
    value of the `.pro` file). If you look at the list of files now present in `/tmp/sysinfo`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将生成二进制文件 `ch02-sysinfo`（基于 `.pro` 文件的 `TARGET` 值）。如果你现在查看 `/tmp/sysinfo`
    中现有的文件列表：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now this is very interesting, we find all our sources compiled in the usual
    `.o` extension (`SysInfo.o`, `SysInfoWidget.o`, and so on) but there are also
    a lot of other files prefixed with `moc_`. Here lies another keystone of the Qt
    framework: the Meta Object Compiler.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在非常有趣，我们发现所有的源文件都编译成了常规的 `.o` 扩展名（`SysInfo.o`、`SysInfoWidget.o` 等），但还有很多以 `moc_`
    为前缀的其他文件。这里隐藏着 Qt 框架的另一个基石：元对象编译器。
- en: Every time you use the signal/slot system, you have to include the macro `Q_OBJECT`
    in your header. Each time you emit a signal or receive one in a slot and you did
    not write any specific code to handle it, Qt took care of it. This is done by
    generating an intermediate implementation of your class (the `moc_*.cpp` file)
    containing everything Qt needs to properly handle your signals and slots.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你使用信号/槽系统时，你都必须在你的头文件中包含宏 `Q_OBJECT`。每次你从一个槽中发出信号或在槽中接收信号，而你并没有编写任何特定的代码来处理它时，Qt
    会为你处理。这是通过生成一个包含 Qt 需要正确处理你的信号和槽的所有内容的中间实现（`moc_*.cpp` 文件）来完成的。
- en: 'A picture is worth a thousand words. Here is the complete compilation pipeline
    for a standard qmake project:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一图胜千言。以下是标准 qmake 项目的完整编译流程：
- en: '![Under the hood of qmake](img/image00365.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![qmake 内部结构](img/image00365.jpeg)'
- en: 'The blue boxes refer to commands and the wavy boxes are documents (sources
    or final binary). Let''s walk through the steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色框代表命令，波浪形框是文档（源文件或最终二进制文件）。让我们一步步走过这些步骤：
- en: The `qmake` command is executed with the project `.pro` file. It generates a
    Makefile based on the project file.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`qmake` 命令与项目 `.pro` 文件一起执行。它根据项目文件生成一个 Makefile。'
- en: The `make` command is executed, which will call other commands to generate intermediate
    files.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `make` 命令，这将调用其他命令来生成中间文件。
- en: The `uic` command stands for User Interface Compiler. It takes all the `.ui`
    files (which are basically an XML description of your interface) and generates
    the corresponding `ui_*.h` header that you include in your own `.cpp` (in our `ch02-sysinfo`
    project, it is in `MainWindow.cpp`).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`uic`命令代表用户界面编译器。它接受所有的`.ui`文件（基本上是界面的XML描述），并生成相应的`ui_*.h`头文件，你需要在你的`.cpp`文件中包含它（在我们的`ch02-sysinfo`项目中，它在`MainWindow.cpp`中）。'
- en: The `moc` command takes every class containing the `Q_OBJECT` macro (paired
    with the superclass `QObject`) and generates the intermediate `moc_*.cpp` files,
    which include everything needed to make the signal/slot framework work.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`moc`命令接受包含`Q_OBJECT`宏（与超类`QObject`配对）的每个类，并生成中间的`moc_*.cpp`文件，这些文件包括使信号/槽框架工作所需的一切。'
- en: The `g++` command is executed, compiling all your sources' files and intermediate `moc`
    files into `.o` files before finally linking everything in the binary `ch02-sysinfo`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`g++`命令，在将所有源文件和中间`moc`文件编译成`.o`文件之前，最终将所有内容链接到二进制文件`ch02-sysinfo`中。
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that if you add a `Q_OBJECT` macro after the creation of a class, sometimes
    the compiler will complain about your signals and slots. To fix this, simply run
    the `qmake` command from **Build** | **Run qmake**. You can now see that this
    stems from the fact that the Makefile has to be regenerated to include the generation
    of the new intermediate `moc` file.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果在创建类之后添加`Q_OBJECT`宏，有时编译器会对你的信号和槽进行抱怨。为了解决这个问题，只需从**构建** | **运行qmake**运行`qmake`命令。现在你可以看到，这是因为Makefile需要重新生成以包含生成新的中间`moc`文件的事实。
- en: Generally, source code generation is regarded as bad practice in the developer
    community. Qt has been criticized on this topic for a long time. We always fear
    that the machines does some kind of voodoo behind our back. Unfortunately, C++
    does not offer any practical way of doing code introspection (namely reflection),
    and the signal and slots mechanism needs some kind of metadata about your class
    to resolve your signals and slots. This could have been done partly with the C++
    template system, but this solution seemed to Qt to be much less readable, portable,
    usable, and robust. You also need an excellent compiler support for templates.
    This cannot be assumed in the wild world of C++ compilers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在开发者社区中，源代码生成被视为不良实践。Qt长期以来一直在这个问题上受到批评。我们总是担心机器在我们背后做一些巫术。不幸的是，C++没有提供任何实际的方法来进行代码自省（即反射），而信号和槽机制需要关于你的类的某些元数据来解析你的信号和槽。这可以通过C++模板系统部分实现，但Qt认为这种解决方案的可读性、可移植性、可用性和鲁棒性都较差。你还需要一个优秀的编译器对模板的支持。在C++编译器的广阔世界中，这不能被假设。
- en: The `moc` system is now fully mature. There are some very specific edge cases
    where it could bring trouble (some have reported problems in very specific situations
    with Visual Studio), but even so, we think that the gain of this feature largely
    outweighs the possibly encountered issues. The signal/slot system is a marvel
    to work with, and if you look at the beginnings of Qt, the system has been present
    from the very first releases. Adding the functor notation in Qt 5 (which gives
    a compile time check of the validity of your `connect()`) combined with C++11 `lambas`
    makes it a real delight.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`moc`系统现在已经完全成熟。有一些非常具体的边缘情况可能会带来麻烦（有些人报告了在Visual Studio中非常特定的情况下的问题），但即便如此，我们认为这个功能的收益远远超过了可能遇到的问题。信号/槽系统是一个令人惊叹的工作系统，如果你看看Qt的早期版本，该系统从最初的发布起就已经存在。Qt
    5中添加的函数表示法（它提供了`connect()`有效性的编译时检查）与C++11的`lambdas`结合，使其变得非常愉快。'
- en: Beneath Q_OBJECT and signals/slots
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`Q_OBJECT`和信号/槽之下
- en: The Qt building system should be clearer now. Still, the `Q_OBJECT` macro and
    the signal/slot/emit keywords are still black boxes. Let's dive into `Q_OBJECT`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Qt的构建系统应该更清晰了。尽管如此，`Q_OBJECT`宏以及信号/槽/emit关键字仍然是黑盒。让我们深入探讨`Q_OBJECT`。
- en: 'The truth lies in the source code; `Q_OBJECT` is defined in the file `qobjectdefs.h`
    (in Qt 5.7):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 真相在于源代码中；`Q_OBJECT`在文件`qobjectdefs.h`（在Qt 5.7中）中定义：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This macro defines some static functions and a `static QMetaObject`. The body
    of these static functions is implemented in the generated `moc` file. We will
    not drown you in the gory details of the `QMetaObject` class. The role of this
    class is to store all the metainformation for the `QObject` subclass. It also
    maintains a correspondence table between the signals and slots of your class,
    and to the signals and slots of any connected class. Each signal and each slot
    is assigned with a unique index:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏定义了一些静态函数和一个`static QMetaObject`。这些静态函数的正文在生成的`moc`文件中实现。我们不会让你陷入`QMetaObject`类的细节。这个类的作用是存储`QObject`子类的所有元信息。它还维护了你类中的信号和槽与任何连接类中的信号和槽之间的对应表。每个信号和每个槽都被分配了一个唯一的索引：
- en: The `metaObject()` function returns the `&staticMetaObject` for a normal Qt
    class and a `dynamicMetaObject` when working with QML objects.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metaObject()`函数对于正常的Qt类返回`&staticMetaObject`，而在与QML对象一起工作时返回`dynamicMetaObject`。'
- en: The `qt_metacast()` function performs a dynamic cast using the name of the class.
    This function is required because Qt does not rely on standard C++ **RTTI** (**Runtime
    Type Information**) to retrieve meta data about an object or a class.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qt_metacast()`函数使用类的名称执行动态转换。这个函数是必需的，因为Qt不依赖于标准C++ **RTTI**（**运行时类型信息**）来检索关于对象或类的元数据。'
- en: The `qt_metacall()`directly calls an internal signal or slot by its index. Because
    an index is used rather than a pointer, there is no pointer dereferencing, and
    the generated switch case can be heavily optimized by the compiler (the compiler
    can directly include the `jump` instruction to the specific case very early on,
    avoiding a lot of branch evaluation). Thus, the execution of the signal/slot mechanism
    is quite fast.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qt_metacall()`直接通过索引调用内部信号或槽。因为使用了索引而不是指针，所以没有指针解引用，编译器可以对生成的switch case进行大量优化（编译器可以直接在早期包含`jump`指令到特定的case，避免大量的分支评估）。因此，信号/槽机制的执行非常快。'
- en: Qt also adds non-standard C++ keywords to manage the signal/slot mechanism,
    namely  `signals`, `slots`, and `emit`. Let's see what is behind each one and
    see how everything fits inside a `connect()` function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Qt还添加了非标准的C++关键字来管理信号/槽机制，即`signals`、`slots`和`emit`。让我们看看每个关键字背后的含义，并看看如何在`connect()`函数中安排一切。
- en: 'The `slots` and `signals` keywords are also defined in `qobjectdefs.h`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`slots`和`signals`关键字也在`qobjectdefs.h`中定义：'
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That is right: `slots` points to nothing and the `signals` keyword is just
    a placeholder for the `public` keyword. All your `signals`/`slots` are just...
    functions. The `signals` keyword is forced to be `public` to make sure that your
    signal functions are visible outside of your class (what is the point of a `private
    signal` anyway?). The Qt magic is simply the ability to emit a `signal` keyword
    to any connected `slot` keyword without knowing the detail of the class implementing
    this `slot`. Everything is done through the `QMetaObject` class implementation
    in the `moc` file. When a `signal` keyword is emitted, the function `QMetaObject::activate()`
    is called with the changed value and the signals index.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此：`slots`指向空值，而`signals`关键字只是`public`关键字的占位符。你所有的`signals`/`slots`仅仅是...函数。`signals`关键字被强制设置为`public`，以确保你的信号函数在类外部可见（毕竟`private
    signal`有什么意义呢？）。Qt的魔法仅仅是能够向任何连接的`slot`关键字发出`signal`关键字，而不需要知道实现该`slot`的类的细节。所有的事情都是通过`moc`文件中`QMetaObject`类实现来完成的。当`signal`关键字被发出时，会调用`QMetaObject::activate()`函数，并传递改变后的值和信号索引。
- en: 'The last definition to study is `emit`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要研究的是`emit`的定义：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So many definitions of nothing, it is almost absurd! The `emit` keyword is completely
    useless from a code perspective; `moc` plainly ignores it and nothing particular
    happens with it afterwards. It is merely a hint for the developer to notice he
    is working with signal/slots rather than plain functions.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如此多的无意义定义，几乎可以说是荒谬的！从代码的角度来看，`emit`关键字完全无用；`moc`明显忽略它，之后也没有发生任何特别的事情。它仅仅是对开发者的一种提示，让他注意到他正在处理信号/槽而不是普通函数。
- en: 'To trigger a `slot`, you must connect your `signal` keyword to it using the `QObject::connect()`
    function. This function creates a new `Connection` instance that is defined in `qobject_p.h`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发一个`槽`，你必须使用`QObject::connect()`函数将你的`signal`关键字连接到它。这个函数创建了一个新的`Connection`实例，该实例在`qobject_p.h`中定义：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Connection` instance stores a pointer to the signal emitter class (`sender`),
    the slot receiver class (`receiver`), and the indexes of the connected `signal`
    and `slot` keywords. When a signal is emitted, every connected slot must be called.
    To be able to do this, every `QObject` has a linked list of `Connection` instances
    for each of its `signal`, and the same linked list of `Connection` for each of
    its `slot` keywords.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection` 实例存储了对信号发射类（`sender`）、槽接收类（`receiver`）以及连接的 `signal` 和 `slot`
    关键字的索引的指针。当信号被发射时，每个连接的槽都必须被调用。为了能够做到这一点，每个 `QObject` 都有一个链表，其中包含其每个 `signal`
    的 `Connection` 实例，以及每个 `slot` 关键字的相同 `Connection` 链表。'
- en: 'This pair of linked lists allows Qt to properly walk through each dependent
    `slot`/`signal` couple to trigger the right functions using the indexes. The same
    reasoning is used to handle the `receiver` destruction: Qt walks through the double
    linked list and removes the object from where it was connected.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这对链表允许 Qt 正确遍历每个依赖的 `slot`/`signal` 对，使用索引来触发正确的函数。同样的推理用于处理 `receiver` 的销毁：Qt
    遍历双链表并从连接处移除对象。
- en: This walk happens in the famous UI thread, where the whole message loop is processed
    and every connected signal/slot is triggered according to the possible events
    (mouse, keyboard, network, and so on). Because the `QThread` class inherits the `QObject`,
    any `QThread` can use the signal/slot mechanism. Additionally, the `signals` keyword
    can be posted to other threads where they will be processed in the receiving threads'
    event loop.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个遍历发生在著名的 UI 线程中，在那里处理整个消息循环，并根据可能的事件（鼠标、键盘、网络等）触发每个连接的信号/槽。因为 `QThread` 类继承自
    `QObject`，所以任何 `QThread` 都可以使用信号/槽机制。此外，`signals` 关键字可以发送到其他线程，它们将在接收线程的事件循环中处理。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a cross-platform `SysInfo` application. We covered
    the singleton and the strategy pattern to have a neat code organization with platform-specific
    code. You learned to use the Qt Charts module to display system information in
    real time. Finally, we took a deep dive into the `qmake` command to see how Qt
    implements the signal/slot mechanism, and to see what is hidden behind Qt-specific
    keywords (`emit`, `signals`, and `slots`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个跨平台的 `SysInfo` 应用程序。我们介绍了单例模式和策略模式，以实现具有平台特定代码的整洁代码组织。你学习了如何使用 Qt
    Charts 模块实时显示系统信息。最后，我们深入研究了 `qmake` 命令，以了解 Qt 如何实现信号/槽机制，以及 Qt 特定关键字（`emit`、`signals`
    和 `slots`）背后隐藏的内容。
- en: By now, you should have a clear picture of how Qt works and how you can tackle
    a cross-platform application. In the next chapter, we will look at how you can
    split a bigger project in order to keep your sanity as a maintainer. We will study
    a fundamental pattern in Qt--the Model/View--and discover how to use a database
    with Qt.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对 Qt 的工作原理以及如何处理跨平台应用程序有了清晰的了解。在下一章中，我们将探讨如何将更大的项目拆分，以保持作为维护者的理智。我们将研究
    Qt 的一个基本模式——模型/视图，并发现如何使用 Qt 与数据库交互。
