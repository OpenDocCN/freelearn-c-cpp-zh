- en: Programming Linux/Unix Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程Linux/Unix系统
- en: The goal of this chapter is to explain the foundations of programming on Linux/Unix-based
    systems. This will provide a more complete picture of how a program executes on
    a Unix/Linux system, how to write more efficient code, and where to look when
    hard-to-find bugs arise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是解释在Linux/Unix系统上编程的基础知识。这将提供一个更完整的图景，说明程序在Unix/Linux系统上如何执行，如何编写更高效的代码，以及在出现难以找到的错误时应该去哪里寻找。
- en: To that end, this chapter starts by taking a comprehensive look at the Linux
    ABI, or more specifically, the System V ABI. In this section, we will review everything
    from the register and stack layout, to the System V calling conventions and ELF
    binary object specification.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，本章首先全面审视Linux ABI，或者更具体地说，System V ABI。在本节中，我们将从寄存器和栈布局到System V调用约定和ELF二进制对象规范进行全面审查。
- en: The next section will briefly cover the Linux filesystem, including the standard
    layout and permissions. We will then provide a comprehensive review of Unix processes
    and how to program them, including considerations such as forking new processes
    and interprocess communication.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将简要介绍Linux文件系统，包括标准布局和权限。然后，我们将全面审查Unix进程以及如何对它们进行编程，包括考虑到创建新进程和进程间通信等方面。
- en: Finally, this chapter will conclude with a brief overview of Unix-based signals
    and how to work with them (both sending them and receiving them).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章将简要概述基于Unix的信号以及如何处理它们（发送和接收）。
- en: 'In this chapter, we will address the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: The Linux ABI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux ABI
- en: The Unix filesystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix文件系统
- en: Unix process APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix进程API
- en: Unix signal APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix信号API
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to follow the examples in this chapter, you must have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中的示例，您必须具备以下条件：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all the code in this chapter, including the examples and code snippets,
    go to the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter05).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请转到以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter05)。
- en: The Linux ABI
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux ABI
- en: In this section, we will discuss the Linux ABI (which is actually called the
    **System V ABI**), as well as the ELF standard and its use in Linux/Unix.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Linux ABI（实际上称为**System V ABI**），以及ELF标准及其在Linux/Unix中的使用。
- en: We will also dive into some of the details associated with ELF files, how to
    read and interpret them, and some of the implications of specific components within
    an ELF file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将深入探讨与ELF文件相关的一些细节，如何读取和解释它们，以及ELF文件中特定组件的一些含义。
- en: The System V ABI
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System V ABI
- en: Unix System V was one of the first versions of Unix available, and largely defined
    Unix for years. Under the hood, System V leveraged the System V ABI. As Linux
    and BSD (Unix-like operating systems) became more widely used, the popularity
    of System V declined. However, the System V ABI remained popular, as operating
    systems such as Linux adopted this specification for Intel-based PCs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Unix System V是最早可用的Unix版本之一，并在很大程度上定义了多年的Unix。在内部，System V利用了System V ABI。随着Linux和BSD（类Unix操作系统）的广泛使用，System
    V的流行度下降了。然而，System V ABI仍然很受欢迎，因为诸如Linux之类的操作系统采用了这一规范用于基于Intel的个人电脑。
- en: In this chapter, we will focus on the System V ABI for Intel platforms on the
    Linux operating system. It should be noted, however, that other architectures
    and operating systems might use different ABIs. For example, ARM has its own ABI,
    which is largely based on System V (and, oddly, the Itanium 64 specification),
    but has several key differences.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注Linux操作系统上Intel平台的System V ABI。然而，需要注意的是，其他架构和操作系统可能使用不同的ABI。例如，ARM有自己的ABI，它在很大程度上基于System
    V（奇怪的是，还有Itanium 64规范），但有一些关键的区别。
- en: The goal of this section is to expose the inner workings of a single Unix ABI,
    which in turn should make learning other ABIs easier, if needed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是揭示单个Unix ABI的内部工作原理，从而使必要时学习其他ABI更容易。
- en: Most of the specifications discussed in this chapter can be found at the following
    link: [https://refspecs.linuxfoundation.org/](https://refspecs.linuxfoundation.org/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的大部分规范可以在以下链接找到：[https://refspecs.linuxfoundation.org/](https://refspecs.linuxfoundation.org/)。
- en: 'The System V ABI defines most of the low-level details of a program (which
    in turn define the interfaces for system programming), including:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: System V ABI定义了程序的大部分低级细节（从而定义了系统编程的接口），包括：
- en: The register layout
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器布局
- en: The stack frame
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈帧
- en: Function prologs and epilogs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数前言和尾声
- en: The calling convention (that is, parameter passing)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用约定（即参数传递）
- en: Exception handling
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Virtual memory layout
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟内存布局
- en: Debugging
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: The binary object format (in this case, ELF)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制对象格式（在本例中为ELF）
- en: Program loading and linking
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序加载和链接
- en: In [Chapter 2](5fbe5888-ed33-49fb-8b28-1688ce9e0087.xhtml), *Learning the C,
    C++17, and POSIX Standards*, we discussed the details of program linking and dynamic
    loading, and we devoted an entire section to the binary object format (ELF).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](5fbe5888-ed33-49fb-8b28-1688ce9e0087.xhtml)中，*学习C、C++17和POSIX标准*，我们讨论了程序链接和动态加载的细节，并专门讨论了二进制对象格式（ELF）。
- en: The following is a brief description of the remaining details of the System
    V specification, with respect to the Intel 64-bit architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于Intel 64位架构的System V规范的其余细节的简要描述。
- en: The register layout
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄存器布局
- en: For the purpose of keeping this topic simple, we will focus on Intel 64-bit.
    A whole book could be written on the different register layouts for each ABI,
    operating system, and architecture combination.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个话题，我们将专注于英特尔64位。每个ABI、操作系统和架构组合的不同寄存器布局都可以写成一本书。
- en: The Intel 64-bit architecture (which is usually referred to as AMD64, as AMD
    actually wrote it) defines several registers, of which a few have defined meanings
    within the instruction set.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔64位架构（通常称为AMD64，因为AMD实际上编写了它）定义了几个寄存器，其中一些在指令集中有定义的含义。
- en: The instruction pointer `rip` defines a program's current location in executable
    memory. Specifically, as a program executes, it executes from the location stored
    in `rip`, and each time an instruction is retired, `rip` advances to the next
    instruction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 指令指针`rip`定义了程序在可执行内存中的当前位置。具体来说，当程序执行时，它从`rip`中存储的位置执行，并且每次指令执行完毕，`rip`都会前进到下一条指令。
- en: The stack pointer and the base pointer (`rsp` and `rbp` respectively) are used
    to define the current location in the stack, as well as the location of the beginning
    of a stack frame (we will provide more information on this later).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈指针和基指针（分别为`rsp`和`rbp`）用于定义堆栈中的当前位置，以及堆栈帧的开始位置（我们将在后面提供更多信息）。
- en: The following are the remaining general-purpose registers. These have different
    meanings, which will be discussed in the rest of this section: `rax`, `rbx`, `rcx`,
    `rdx`, `rdi`, `rsi`, `r8`, `r9`, `r10`, `r11`, `r12`, `r13`, `r14`, and `r15`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是剩余的通用寄存器。它们有不同的含义，将在本节的其余部分中讨论：`rax`、`rbx`、`rcx`、`rdx`、`rdi`、`rsi`、`r8`、`r9`、`r10`、`r11`、`r12`、`r13`、`r14`和`r15`。
- en: It should be noted before we continue that there are several other registers
    defined on the system that have very specific purposes, including floating-point
    registers and wide registers (which are used by special instructions designed
    to speed up certain types of calculations; for example, SSE and AVX). These are
    out of scope for the purpose of this discussion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，应该指出系统上还定义了几个具有非常具体目的的寄存器，包括浮点寄存器和宽寄存器（这些寄存器由专门设计用于加速某些类型计算的特殊指令使用；例如，SSE和AVX）。这些超出了本讨论的范围。
- en: Finally, some of the registers end with letters, while others end with numbers,
    because versions of Intel's x86 processors only had letter-based registers, and
    the only true, general-purpose registers were AX, BX, CX, and DX.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些寄存器以字母结尾，而另一些以数字结尾，因为英特尔的x86处理器版本只有基于字母的寄存器，真正的通用寄存器只有AX、BX、CX和DX。
- en: When 64-bit was introduced by AMD, the number of general-purpose registers doubled,
    and to keep things simple, the register names were given numbers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当AMD引入64位时，通用寄存器的数量翻了一番，为了保持简单，寄存器名称被赋予了数字。
- en: The stack frame
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈帧
- en: 'The stack frame is used to store the return address of each function, and to
    store function parameters and stack-based variables. It is a resource used heavily
    by all program, and it takes the following form:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈帧用于存储每个函数的返回地址，并存储函数参数和基于堆栈的变量。它是所有程序都大量使用的资源，它采用以下形式：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The stack frame is nothing more than an array of memory that grows from top
    to bottom. That is to say, on an Intel PC, pushing to the stack *subtracts* from
    the stack pointer, while popping from the stack *adds* to the stack pointer—which
    means that memory actually grows down (assuming your view is that memory grows
    upward as an address increases, as in the previous diagram).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈帧只不过是一个从顶部向底部增长的内存数组。也就是说，在英特尔PC上，向堆栈推送会从堆栈指针中*减去*，而从堆栈弹出会向堆栈指针中*加上*，这意味着内存实际上是向下增长的（假设您的观点是随着地址增加，内存向上增长，就像前面的图表中一样）。
- en: 'The System V ABI states that the stack is made up of stack *frames*. Each frame
    looks like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: System V ABI规定堆栈由堆栈*帧*组成。每个帧看起来像下面这样：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each frame represents a function call, and starts with any arguments to a function
    beyond the first six being called (the first six arguments are passed as registers—this will
    be discussed in more detail later). Finally, the return address is pushed to the
    stack, and the function is called.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个帧代表一个函数调用，并以超过前六个参数的任何参数开始调用函数（前六个参数作为寄存器传递，这将在后面更详细地讨论）。最后，返回地址被推送到堆栈中，然后调用函数。
- en: Memory after the return address belongs to variables that are scoped to the
    function itself. This is why we call variables defined in a function *stack-based
    variables*. The remaining stack is used by functions that will be called in the
    future. Each time one function calls another, the stack grows, while each time
    a function returns, the stack shrinks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 返回地址后的内存属于函数本身范围内的变量。这就是为什么我们称在函数中定义的变量为*基于堆栈的变量*。剩下的堆栈将被未来将要调用的函数使用。每当一个函数调用另一个函数时，堆栈就会增长，而每当一个函数返回时，堆栈就会缩小。
- en: It is the job of the operating system to manage the size of the stack, ensuring
    that it always has enough memory. For example, if an application is trying to
    use too much memory, the operating system will kill the program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的工作是管理堆栈的大小，确保它始终有足够的内存。例如，如果应用程序尝试使用太多内存，操作系统将终止该程序。
- en: Finally, it should be noted that on most CPU architectures, special instructions
    are provided that return from a function call and automatically pop the return
    address of the stack. In the case of Intel, the `call` instruction will jump to
    a function and push the current `rip` to the stack as the return address, and
    then `ret` will pop the return address from the stack and jump the address that
    was popped.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应该指出，在大多数CPU架构上，提供了特殊指令，用于从函数调用返回并自动弹出堆栈的返回地址。在英特尔的情况下，`call`指令将跳转到一个函数并将当前的`rip`推送到堆栈作为返回地址，然后`ret`将从堆栈中弹出返回地址并跳转到被弹出的地址。
- en: Function prologs and epilogs
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数前言和尾声
- en: Each function comes with a stack frame that, as stated previously, stores function
    parameters, function variables, and return addresses. The code that manages these
    resources is called the function's *prolog* (beginning) and *epilog* (ending).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都带有一个堆栈帧，如前所述，存储函数参数、函数变量和返回地址。管理这些资源的代码称为函数的*前导*（开始）和*结尾*（结束）。
- en: 'To better explain this, let''s create a simple example and examine the resulting
    binary:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释这一点，让我们创建一个简单的例子并检查生成的二进制文件：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we disassemble the resulting binary, we get the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们反汇编生成的二进制文件，我们得到以下结果：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our test function, the first two instructions are the function's prolog.
    The prolog is pushing the current stack frame (which is the previous function's
    stack frame), and then setting the current stack pointer to `rbp`, which is in
    turn creating a new stack frame.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试函数中，前两条指令是函数的前导。前导是推送当前堆栈帧（即前一个函数的堆栈帧），然后将当前堆栈指针设置为`rbp`，从而创建一个新的堆栈帧。
- en: From there, the next two instructions are using the unused portion of the stack
    to create the variables `i` and `j`. Finally, the resulting stack-based variables
    are loaded into registers, and the result is added and returned in `rax` (which
    is the return register for most ABIs defined for Intel).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两条指令使用堆栈的未使用部分来创建变量`i`和`j`。最后，将结果加载到寄存器中，并在`rax`中添加并返回结果（这是为英特尔定义的大多数ABI的返回寄存器）。
- en: The function's epilog is the final two instructions in this example. Specifically,
    the location of the previous stack frame (which was pushed to the stack in the
    prolog) is popped from the stack and stored in `rbp`, effectively changing to
    the previous stack frame, and then the `ret` instruction is used to return to
    the previous function (just after the function call).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的结尾是这个例子中的最后两条指令。具体来说，先前的堆栈帧的位置（在前导中推送到堆栈中）从堆栈中弹出并存储在`rbp`中，有效地切换到先前的堆栈帧，然后使用`ret`指令返回到先前的函数（就在函数调用之后）。
- en: A keen eye might have noticed that space was not reserved on the stack by moving
    `rsp` for the variables `i` and `j`. This is because the 64-bit version of the
    System V ABI defines what is called the **red zone**. The red zone only applies
    to leaf functions (in our case, the test function is a leaf function, meaning
    it doesn't call any other functions).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的眼睛可能已经注意到，通过移动`rsp`来为变量`i`和`j`保留了堆栈上的空间。这是因为System V ABI的64位版本定义了所谓的**红区**。红区仅适用于叶函数（在我们的例子中，测试函数是一个叶函数，意味着它不调用任何其他函数）。
- en: Leaf functions will never grow the stack any further, which means that the remaining
    stack can be used by the function without having to advance the stack pointer,
    as all remaining memory is fair game.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 叶函数永远不会进一步增加堆栈，这意味着剩余的堆栈可以被函数使用，而无需推进堆栈指针，因为所有剩余的内存都是公平竞争的。
- en: When system programming, this can sometimes be a problem if you are programming
    in the kernel. Specifically, if an interrupt fires (using the current stack pointer
    as its stack), corruption can occur if the stack was not properly reserved, therefore
    the interrupt would corrupt a leaf function's stack-based variables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程时，如果在内核中编程，有时可能会出现问题。具体来说，如果中断触发（使用当前堆栈指针作为其堆栈），如果堆栈没有正确保留，可能会导致损坏，因此中断会破坏基于堆栈的叶函数的变量。
- en: 'To overcome this, the red zone must be turned off using the `-mno-red-zone` flag
    with GCC. For example, if we compile the previous example with this flag, we get
    the following binary output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，必须使用GCC的`-mno-red-zone`标志关闭红区。例如，如果我们使用这个标志编译前面的例子，我们得到以下二进制输出：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As shown, the resulting binary is very similar to the original. There are two
    major differences, however. The first is the `sub` instruction, which is used
    to move the stack pointer, which in turn reserves stack space instead of using
    the red zone.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，生成的二进制文件与原始文件非常相似。然而，有两个主要区别。第一个是`sub`指令，用于移动堆栈指针，从而保留堆栈空间，而不是使用红区。
- en: The second difference is the use of the `leave` instruction. This instruction
    pops `rbp` just as in the previous example, but also restores the stack pointer,
    which has been moved to make space for stack-based variables. In this example,
    the `leave` and `ret` instructions are the new epilog.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是使用`leave`指令。这条指令像前面的例子一样弹出`rbp`，但也恢复了堆栈指针，这个指针已经移动以为基于堆栈的变量腾出空间。在这个例子中，`leave`和`ret`指令是新的结尾。
- en: The calling convention
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用约定
- en: A calling convention dictates which registers are *volatile*, which registers
    are *non-volatile*, which registers are used for parameter passing and in which
    order, and which register is used to return the result of a function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 调用约定规定了哪些寄存器是*易失性*的，哪些寄存器是*非易失性*的，哪些寄存器用于参数传递以及顺序，以及哪个寄存器用于返回函数的结果。
- en: A non-volatile register is a register that is restored to its original value
    just prior to a function leave (that is, in its epilog). The System V ABI defines
    `rbx`, `rbp`, `r12`, `r13`, `r14`, and `r15` as non-volatile. By contrast, a volatile register
    is one that a called function can change at will, without having to restore its
    value on return.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 非易失性寄存器是在函数结束之前恢复到其原始值的寄存器（即在其结尾）。System V ABI将`rbx`、`rbp`、`r12`、`r13`、`r14`和`r15`定义为非易失性寄存器。相比之下，易失性寄存器是被调用函数可以随意更改的寄存器，无需在返回时恢复其值。
- en: 'To demonstrate this, let''s look at the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们看下面的例子：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in the previous example, the `__libc_csu_init()` function (which is
    used by `libc` to initialize) touches `r12`, `r13`,`r14`, and `r15`. As such,
    it must push the original values of these registers to the stack before performing
    its initialization procedure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，`__libc_csu_init()`函数（被`libc`用于初始化）会触及`r12`、`r13`、`r14`和`r15`。因此，在执行初始化过程之前，它必须将这些寄存器的原始值推送到堆栈中。
- en: In addition, in the middle of this code, the compiler stores `rdx` in `r15`. As
    will be shown later, the compiler is preserving the third argument to the function.
    Just based on this code, we know that this function takes at least three arguments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这段代码的中间，编译器将`rdx`存储在`r15`中。稍后将会展示，编译器正在保留函数的第三个参数。仅仅根据这段代码，我们知道这个函数至少需要三个参数。
- en: 'A quick Google search will reveal that this function has the following signature:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 快速的谷歌搜索会显示这个函数有以下签名：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since this function touches *non-volatile *registers, it must restore these
    registers to their original values before leaving. Let''s look at the function''s
    epilog:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个函数触及了*非易失性*寄存器，它必须在离开之前将这些寄存器恢复到它们的原始值。让我们看一下函数的尾声：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As shown previously, the `__libc_csu_init()` function restores all the non-volatile registers
    before leaving. This means that, somewhere in the middle of the function, `rbx`
    was also clobbered (with its original value being pushed to the stack beforehand).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，`__libc_csu_init()`函数在离开之前恢复所有非易失性寄存器。这意味着，在函数的中间某处，`rbx`也被破坏了（原始值先被推送到堆栈上）。
- en: In addition to volatile and non-volatile registers being defined, System V's
    calling convention also defines which registers are used to pass function parameters.
    Specifically, the registers `rdi`, `rsi`, `rdx`, `rcx`, `r8`, and `r9` are used
    to pass parameters (in the order provided).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义易失性和非易失性寄存器之外，System V的调用约定还定义了用于传递函数参数的寄存器。具体来说，寄存器`rdi`、`rsi`、`rdx`、`rcx`、`r8`和`r9`用于传递参数（按照提供的顺序）。
- en: 'To demonstrate this, let''s look at the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们看下面的例子：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the previous example, we created a test function that takes two arguments,
    adds them together, and returns the result. Let''s now look at the resulting binary
    for the `main()` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个接受两个参数，将它们相加并返回结果的测试函数。现在让我们看一下`main()`函数的生成二进制文件：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first thing the `main()` function does is provide its prolog (as described
    in previous chapters, the `main()` function is not the first function to execute,
    and thus, a prolog and epilog are needed just like any other function).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的第一件事是提供其前言（如前几章所述，`main()`函数不是第一个执行的函数，因此，就像任何其他函数一样，需要前言和尾声）。'
- en: The `main()` function then reserves space on the stack for the return value
    of the `test()` function, and fills in `esi` and `edi` with the parameters being
    passed to `test()` just before calling `test()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`main()`函数在堆栈上为`test()`函数的返回值保留空间，并在调用`test()`之前用传递给`test()`的参数填充`esi`和`edi`。
- en: The `call` instruction, as previously stated, pushes the return address onto
    the stack and then jumps to the `test()` function. The result of the `test()`
    function is stored on the stack (an operation that would be removed if optimization
    were enabled), and then `0` is placed in `eax` just before returning.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`call`指令将返回地址推送到堆栈上，然后跳转到`test()`函数。`test()`函数的结果存储在堆栈上（如果启用了优化，这个操作将被移除），然后在返回之前将`eax`中放入`0`。
- en: As we can see, we did not provide our `main` function with a return value. This
    is because, if no return value is provided, the compiler will automatically insert
    a return `0` for us, which is what we see in this code, as `rax` is the return
    register for System V.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们没有为`main`函数提供返回值。这是因为，如果没有提供返回值，编译器将自动为我们插入返回`0`，这就是我们在这段代码中看到的，因为`rax`是System
    V的返回寄存器。
- en: 'Now let''s look at the test function binary:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下测试函数的二进制文件：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `test` function sets up a prolog, and then stores the function's parameters
    on the stack (an operation that would be removed with optimizations turned on).
    The stack variables are then placed into volatile registers (to prevent them from
    having to be saved and restored), the registers are added together, and the result
    is stored in `eax`. Finally, the function returns with an epilog.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`函数设置前言，然后将函数的参数存储在堆栈上（如果启用了优化，这个操作将被移除）。然后将堆栈变量放入易失性寄存器中（以防止它们需要被保存和恢复），然后将寄存器相加，并将结果存储在`eax`中。最后，函数通过尾声返回。'
- en: 'As stated previously, the return register for System V is `rax`, which means
    that every function that returns a value will do so using `rax`. To return more
    than one value, `rdx` can also be used. For example, see the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，System V的返回寄存器是`rax`，这意味着每个返回值的函数都将使用`rax`来返回。要返回多个值，也可以使用`rdx`。例如，看下面的例子：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous example, we create a `test` function that returns a structure
    that has two 64-bit integers. We choose two 64-bit integers because if we used
    regular ints, the compiler would attempt to store the contents of the struct in
    a single 64-bit register.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个返回包含两个64位整数的结构的`test`函数。我们选择了两个64位整数，因为如果我们使用常规的int，编译器将尝试将结构的内容存储在一个64位寄存器中。
- en: 'The resulting binary for the `test()` function is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`test()`函数的生成二进制文件如下：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As previously shown, the `test` function stores the results in `rax` and `rdx`
    before returning. If more than 128 bits of data are returned, both the `main()`
    function and the `test()` function get way more complicated. This is because stack
    space must be reserved by the `main()` function, and then the `test()` function
    must leverage this stack space to return the results of the function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，`test`函数在返回之前将结果存储在`rax`和`rdx`中。如果返回的数据超过128位，那么`main()`函数和`test()`函数都会变得更加复杂。这是因为`main()`函数必须保留堆栈空间，然后`test()`函数必须利用这个堆栈空间来返回函数的结果。
- en: The specific details of how this works are beyond the scope of this book, but,
    in short, the address of the stack space reserved for the return value actually
    becomes the first argument to the function, all of which is defined by the System
    V ABI.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的具体细节超出了本书的范围，但简而言之，为返回值保留的堆栈空间的地址实际上成为函数的第一个参数，所有这些都是由System V ABI定义的。
- en: It should be noted that the examples make heavy use of registers that are prefixed
    with `e` rather than `r`. This is because `e` denotes a 32-bit register, while `r` denotes
    a 64-bit register. The reason `e` versions are used so much is that we leverage
    integer-based literals such as `1`, `2`, and `42`. These are all of type `int`, as
    defined by the C and C++ specifications (as stated in previous chapters), which,
    by default on an Intel 64 bit CPU, is a 32-bit value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，示例大量使用以`e`为前缀而不是`r`的寄存器。这是因为`e`表示32位寄存器，而`r`表示64位寄存器。之所以这么多使用`e`版本，是因为我们利用基于整数的文字，如`1`、`2`和`42`。这些都是`int`类型，根据C和C++规范（如前几章所述），在Intel
    64位CPU上默认是32位值。
- en: Exception handling and debugging
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理和调试
- en: C++ exceptions provide a way to return an error to a `catch` handler somewhere
    in the call stack. We will cover C++ exceptions in great detail in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml),
    *Error - Handling with Exceptions*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: C++异常提供了一种在调用堆栈的某个地方返回错误到`catch`处理程序的方法。我们将在[第13章](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml)中详细介绍C++异常，*异常处理*。
- en: 'For now, we will work with the following simple example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下简单的例子：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous example, we create a simple `test()` function that takes an
    input. If the input is equal to `42`, we throw an exception. This will cause the
    function to return (and every calling function to continue to return) until a
    `try` or `catch` block is encountered. Any code executed in the `try` portion
    of the block will execute the `catch` portion of the block if an exception is
    thrown.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个简单的`test()`函数，它接受一个输入。如果输入等于`42`，我们会抛出一个异常。这将导致函数返回（并且每个调用函数继续返回），直到遇到`try`或`catch`块。在块的`try`部分执行的任何代码都将在抛出异常时执行块的`catch`部分。
- en: It should be noted that the return value of the called function is not considered
    or used. This provides a means to throw an error at any point in the execution
    of a call stack of functions, and catch possible errors at any point (most likely
    when the error can be safely handled or the program can be safely aborted).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，被调用函数的返回值不被考虑或使用。这提供了一种在调用函数调用堆栈的任何点抛出错误，并在任何点捕获可能的错误的方法（最有可能在错误可以安全处理或程序可以安全中止时）。
- en: 'As shown in the preceding example, the first attempt to execute the `test()`
    function succeeds, and the `attempt #1: passed` string is output to `stdout`.
    The second attempt to execute the `test()` function fails when the function throws
    an exception, and as a result, the `attempt #2: passed` string is not output to
    `stdout` as this code is never executed. Instead, the `catch` block is executed,
    which handles the error (by ignoring it).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '如前面的例子所示，第一次尝试执行`test()`函数成功，并且将`attempt #1: passed`字符串输出到`stdout`。第二次尝试执行`test()`函数失败，因为函数抛出异常，结果，`attempt
    #2: passed`字符串不会输出到`stdout`，因为这段代码永远不会执行。相反，将执行`catch`块，该块处理错误（忽略它）。'
- en: The details of exception handling (and debugging) are exceptionally difficult
    (pun intended), and therefore the goal of this section is to explain how the System
    V specification dictates the ABI associated with exception (and debugging) support.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理（和调试）的细节非常困难（故意的双关语），因此本节的目标是解释System V规范如何规定与异常（和调试）支持相关的ABI。
- en: I provide more detail about the inner workings of C++ exceptions in the following
    video, recorded at CppCon: [https://www.youtube.com/watch?v=uQSQy-7lveQ](https://www.youtube.com/watch?v=uQSQy-7lveQ).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我在以下视频中提供了有关C++异常内部工作原理的更多细节，该视频是在CppCon上录制的：[https://www.youtube.com/watch?v=uQSQy-7lveQ](https://www.youtube.com/watch?v=uQSQy-7lveQ)。
- en: 'At the end of this section, the following should be clear:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结束时，以下内容应该是清楚的：
- en: C++ exceptions are expensive to execute, and therefore should never be used
    for control flow (only error handling).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++异常执行起来很昂贵，因此不应该用于控制流（仅用于错误处理）。
- en: C++ exceptions consume a lot of space in the executable and if they are not
    used, the `-fno-exceptions` flag should be passed to GCC to reduce the overall
    size of the resulting code. This also means that no library facilities that could
    possibly throw an exception should be used.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++异常在可执行文件中占用大量空间，如果不使用，应该传递`-fno-exceptions`标志给GCC，以减少生成代码的总体大小。这也意味着不应该使用可能引发异常的库设施。
- en: To support the previous example, the stack has to be *unwound*. That is, for
    the program to jump to the `catch` block, the non-volatile registers need to be
    set to appear as though the `test()` function was never executed in the first
    place. To do this, we, in a way, execute the `test()` function in reverse, using
    a set of instructions provided by the compiler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持前面的例子，堆栈必须被*展开*。也就是说，为了程序跳转到`catch`块，非易失性寄存器需要被设置，以使得`test()`函数看起来从未执行过。为了做到这一点，我们以某种方式以编译器提供的一组指令的方式，以相反的方式执行`test()`函数。
- en: 'Before we get into the details of this information, let''s first look at the
    assembly code associated with our previous example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解这些信息之前，让我们先看一下与我们之前的例子相关的汇编代码：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To keep this easy to understand, the previous code has been simplified. Let's
    start at the top. The first thing this function does is set up the function prolog
    (that is, the stack frame), and then reserve some space on the stack. Once this
    is done, the code moves `0x1` into `edi`, which passes a `1` to the `test()` function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持易于理解，上述代码已经简化。让我们从头开始。这个函数的第一件事是设置函数前言（即堆栈帧），然后在堆栈上保留一些空间。完成这些操作后，代码将`0x1`移动到`edi`中，这将传递`1`给`test()`函数。
- en: 'Next, the `test()` function is called. Next, some stuff happens (the details
    are not important), and then `std::cout` is called (which attempts to output the `attempt
    #1: passed` string to `stdout`). This process is repeated for `test(42)` as well.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，调用`test()`函数。然后发生一些事情（细节不重要），然后调用`std::cout`（尝试将`attempt #1: passed`字符串输出到`stdout`）。这个过程对`test(42)`也是一样的。'
- en: The next bit of code is where the `main()` function gets interesting. `mov $0x0,%eax` sets
    `eax` to `0`, which, as we know, is the return register. This code sets up the
    return value for the `main()` function, but what is interesting is that the next
    instruction does a relative jumps to `c90` in the `main()` function, which is
    the `add $0x8,%rsp` code. This is the beginning of the epilog of the function,
    which cleans up the stack and restores the non-volatile registers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码是`main()`函数变得有趣的地方。`mov $0x0,%eax`将`eax`设置为`0`，正如我们所知，这是返回寄存器。这段代码设置了`main()`函数的返回值，但有趣的是，下一条指令相对跳转到`main()`函数中的`c90`，也就是`add
    $0x8,%rsp`代码。这是函数的结尾的开始，它清理堆栈并恢复非易失性寄存器。
- en: The code in between is our `catch` block. This is the code that is executed
    if an exception is thrown. If an exception is not thrown, the `jmp c90` code is
    executed, which skips the `catch` block.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的代码是我们的`catch`块。这是在抛出异常时执行的代码。如果没有抛出异常，就会执行`jmp c90`代码，跳过`catch`块。
- en: 'The `test` function is far more simple:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`函数要简单得多：'
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `test` function, the function prolog is set up, and stack space is reserved
    (which would likely be removed if optimizations were enabled). The input is then
    compared to `42`, and if they are not equal (as shown by the use of `jne`), the
    function jumps to the epilog and returns. If they are equal, a C++ exception is
    allocated and thrown.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test`函数中，函数的前言被设置，堆栈空间被保留（如果启用了优化，这可能会被移除）。然后将输入与`42`进行比较，如果它们不相等（通过使用`jne`来表示），函数就会跳转到结尾并返回。如果它们相等，就会分配并抛出一个C++异常。
- en: The important thing to note here is that the `__cxa_throw()` function does not
    return, which means that the function's epilog is never executed. The reason for
    this is that, when an exception is thrown, the programmer is stating that the
    remaining portion of the function cannot execute, and instead, `__cxa_throw()`
    needs to jump to a `catch` block in the call stack (in this case, in the `main()`
    function), or terminate the program if a `catch` block cannot be found.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要一点是，`__cxa_throw()`函数不会返回，这意味着函数的结尾部分永远不会被执行。原因是，当抛出异常时，程序员表示函数的剩余部分无法执行，而是需要`__cxa_throw()`跳转到调用堆栈中的`catch`块（在这种情况下是在`main()`函数中），或者如果找不到`catch`块，则终止程序。
- en: Since the function's epilog is never executed, the non-volatile registers need
    to be restored to their original state somehow. This brings us to the DWARF specification,
    and the `.eh_frame` table that is embedded in the application itself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数的结尾从未被执行，非易失性寄存器需要以某种方式恢复到它们的原始状态。这就引出了DWARF规范和嵌入在应用程序中的`.eh_frame`表。
- en: As will be shown later on in this chapter, most Unix-based applications are
    compiled to a binary format called **ELF**. Any ELF application that was compiled
    with C++ exception support contains a special table called the `.eh_frame` table
    (this stands for exception handling framework).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章后面将要展示的，大多数基于Unix的应用程序都是编译成一种名为**ELF**的二进制格式。任何使用C++异常支持编译的ELF应用程序都包含一个特殊的表，叫做`.eh_frame`表（这代表异常处理框架）。
- en: 'For example, if you run `readelf` on the previous application, you will see
    the `.eh_frame` table, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在之前的应用程序上运行`readelf`，你会看到`.eh_frame`表，如下所示：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The DWARF specification (which doesn't officially stand for anything) provides
    all the information needed to debug an application. When debugging is enabled
    by GCC, several debugging tables are added to the application to assist GDB.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: DWARF规范（官方上没有特定的含义）提供了调试应用程序所需的所有信息。当GCC启用调试时，会向应用程序添加几个调试表，以帮助GDB。
- en: The DWARF specification is also used to define the instructions needed to reverse
    the stack; in other words, to execute a function in reverse with respect to the
    contents of the non-volatile registers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: DWARF规范也用于定义反转堆栈所需的指令；换句话说，以相对于非易失性寄存器的内容执行函数的反向操作。
- en: 'Let''s look at the contents of the `.eh_frame` table using `readelf`, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`readelf`来查看`.eh_frame`表的内容，如下所示：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An entire book could be written on what this code does, but the goal here is
    to keep this simple. For every single function in the program (which could be
    hundreds of thousands of functions for programs with a lot of code), a block like
    the previous one is provided in `.eh_frame`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码的功能可以写一整本书，但这里的目标是保持简单。对于程序中的每个函数（对于代码量很大的程序可能有数十万个函数），`.eh_frame`中都提供了类似上面的一个块。
- en: The preceding block (which was located by matching addresses found using `objdump`)
    is the **Frame Description Entry** (**FDE**) for our `test()` function. This FDE
    describes how to reverse the stack using DWARF instructions, which are compressed
    instructions designed to be as small as possible (to reduce the size of the `.eh_frame` table).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块（通过使用`objdump`找到的地址匹配）是我们`test()`函数的**Frame Description Entry**（FDE）。这个FDE描述了如何使用DWARF指令反转堆栈，这些指令是为了尽可能小（以减小`.eh_frame`表的大小）而压缩的指令。
- en: The FDE provides the stack reversal instructions based on the location of the
    throw. That is to say, as a function executes, it continues to touch the stack.
    If more than one throw is present in a function, it is possible that more of the
    stack has been touched in between each throw, which means that more stack reversal
    instructions are needed to properly return the stack back to normal.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: FDE根据抛出的位置提供了堆栈反转指令。也就是说，当一个函数执行时，它会继续触及堆栈。如果一个函数中存在多个抛出，那么在每次抛出之间可能会触及更多的堆栈，这意味着需要更多的堆栈反转指令来正确地将堆栈恢复到正常状态。
- en: Once a function's stack has been reversed, the next function in the call stack
    needs to be reversed. This process continues until a `catch` block is located.
    The problem is that the `.eh_frame` table is a list of these FDEs, which means
    that reversing the stack is an `O(N^2)` operation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数的堆栈被反转，调用堆栈中的下一个函数也需要被反转。这个过程会一直持续，直到找到一个`catch`块。问题在于`.eh_frame`表是这些FDE的列表，这意味着反转堆栈是一个`O(N^2)`的操作。
- en: 'Optimizations have been carried out, including the use of a hash table, but
    two things remain true:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 已经进行了优化，包括使用哈希表，但仍然有两个事实是真实的：
- en: Reversing the stack is a slow process.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转堆栈是一个缓慢的过程。
- en: Using C++ exceptions takes up a lot of space. This is because each function
    defined in the code not only has to contain the code for that function, it must
    also contain an FDE that tells the code how to unwind the stack in the event that
    an exception is fired.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++异常会占用大量空间。这是因为代码中定义的每个函数不仅必须包含该函数的代码，还必须包含一个FDE，告诉代码如何在触发异常时展开堆栈。
- en: Virtual memory layout
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟内存布局
- en: Virtual memory layout is also provided by the System V specification. In the
    next section, we will discuss the details of the ELF format, which will provide
    more information about the virtual memory layout and how it can be changed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存布局也是由System V规范提供的。在下一节中，我们将讨论ELF格式的细节，这将提供关于虚拟内存布局以及如何更改它的更多信息。
- en: Executable and Linkable Format (ELF)
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可执行和可链接格式（ELF）
- en: The **Executable and Linkable Format** (**ELF**) is the main format used in
    most Unix-based operating systems, including Linux. Every ELF file begins with
    the hex number `0x7F`, and continues with the `ELF` string.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**可执行和可链接格式**（**ELF**）是大多数基于Unix的操作系统中使用的主要格式，包括Linux。每个ELF文件以十六进制数`0x7F`开头，然后是`ELF`字符串。'
- en: 'For example, let''s look at the following program:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一下以下程序：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we look at a `hexdump` of the resulting `a.out` ELF file, we see the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看生成的`a.out` ELF文件的`hexdump`，我们会看到以下内容：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As shown, the `ELF` string is at the very beginning.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，`ELF`字符串位于开头。
- en: 'Every ELF file contains an ELF header, which describes some of the critical
    components of the ELF file itself. The following can be used to view an ELF file''s
    header:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ELF文件都包含一个ELF头，描述了ELF文件本身的一些关键组件。以下命令可用于查看ELF文件的头部：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As shown, the ELF file that we compiled was linked to an ELF-64 file that adheres
    to the Unix System V ABI for Intel 64-bit. Near the bottom of the header, you
    might notice the mention of program headers and section headers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们编译的ELF文件链接到了一个符合Unix System V ABI for Intel 64-bit的ELF-64文件。在头部的底部附近，您可能会注意到程序头和部分头的提及。
- en: 'Every ELF file can be viewed in terms of either its segments or its sections.
    To visualize this, let''s look at an ELF file from both points of view, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ELF文件都可以从其段或其部分的角度来查看。为了可视化这一点，让我们从两个角度来看一个ELF文件，如下所示：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As previously shown, each ELF file is composed of sections. The sections are
    then grouped into segments, which are used to define which sections need to be
    loaded, and how (for example, some sections need to be loaded as read-write, others
    as read-execute, or, in some sub-optimal cases, read-write-execute).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，每个ELF文件由部分组成。然后将这些部分分组成段，用于定义需要加载哪些部分，以及如何加载（例如，一些部分需要以读写方式加载，其他部分需要以读取-执行方式加载，或者在一些次优化的情况下，以读写-执行方式加载）。
- en: ELF sections
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF部分
- en: 'To see a list of all of the sections, use the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有部分的列表，请使用以下命令：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will result in the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![](img/67f0afe1-ea22-4452-8757-fa904e0870b8.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67f0afe1-ea22-4452-8757-fa904e0870b8.png)'
- en: 'As shown, even in a simple example, there are several sections. Some of these
    sections contain information that has already been talked about in previous chapters:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，即使在一个简单的例子中，也有几个部分。其中一些部分包含了在前几章中已经讨论过的信息：
- en: '`eh_frame/.eh_frame_hdr`: These contain the FDE information for reversing the
    stack when dealing with exceptions, as just discussed. The `eh_frame_hdr` section
    contains additional information for improving the performance of C++ exceptions,
    including a hash table that can be used to locate an FDE instead of looping through
    the list of FDEs (which would be an `O(n^2)` operation otherwise).'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eh_frame/.eh_frame_hdr`：这些包含了在处理异常时反转堆栈的FDE信息，正如刚才讨论的。`eh_frame_hdr`部分包含了用于改进C++异常性能的其他信息，包括一个哈希表，用于定位FDE，而不是循环遍历FDE列表（否则将是一个`O(n^2)`操作）。'
- en: '`.init_array/.fini_array/.init/.fini`: These contain the constructors and destructors
    that are executed by the code, including any libraries that are linked to your
    code (as discussed, there could be many libraries linked to your application under
    the hood). It should also be noted that these sections contain code capable of
    performing runtime relocations, which must be executed at the very beginning of
    any application to ensure that code is properly linked and relocated.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.init_array/.fini_array/.init/.fini`：这些包含了代码执行的构造函数和析构函数，包括任何链接到您的代码的库（如前所述，在底层可能链接到您的应用程序的库很多）。还应该注意，这些部分包含能够执行运行时重定位的代码，必须在任何应用程序的开头执行，以确保代码被正确链接和重定位。'
- en: '`.dynsym`: This contains all the symbols used for dynamic linking. As discussed
    earlier, if GCC is used, these symbols will all contain C runtime linking names,
    whereas if G++ is used, they will also contain mangled names. We will explore
    this section in more detail shortly.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dynsym`：这包含了用于动态链接的所有符号。如前所述，如果使用GCC，这些符号将全部包含C运行时链接名称，而如果使用G++，它们还将包含有缠结的名称。我们将很快更详细地探讨这一部分。'
- en: A lot can be learned from the output of the sections in `readelf`. For example,
    the addresses all start with `0`, and not some address in higher memory. This
    means the application was compiled using the `-pie` flag during linking, which
    means that the application is relocatable. Specifically, **Position Independent
    Executable** (**PIE**) (and as such, the ELF file) contains the `.plt` and `.got` sections
    that are used to relocate the executable in memory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从`readelf`的部分输出中可以学到很多东西。例如，所有地址都以`0`开头，而不是一些更高内存中的地址。这意味着应用程序在链接期间使用了`-pie`标志进行编译，这意味着应用程序是可重定位的。具体来说，**位置无关可执行文件**（**PIE**）（因此ELF文件）包含了`.plt`和`.got`部分，用于在内存中重定位可执行文件。
- en: 'This can also be seen from the inclusion of the `.rela.xxx` sections, which
    contain the actual relocation commands used by the ELF loader to relocate the
    executable in memory. To prove that this application was compiled using the `-pie` flag,
    let''s look at the application''s compilation flags:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以从`.rela.xxx`部分的包含中看出，其中包含了ELF加载器用于在内存中重新定位可执行文件的实际重定位命令。为了证明这个应用程序是使用`-pie`标志编译的，让我们看看应用程序的编译标志：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As previously shown, the `-pie` flag was provided.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，提供了`-pie`标志。
- en: Another thing to note is that the sections start at address `0` and progress,
    but, at some point, the address jumps to `0x200000` and continues from there.
    This means that the application is 2 MB aligned, which is typical for 64-bit applications
    as they have a much larger address space to work with.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的一点是，部分从地址`0`开始并继续，但是在某个时候，地址跳到`0x200000`并从那里继续。这意味着应用程序是2MB对齐的，这对于64位应用程序来说是典型的，因为它们有更大的地址空间可供使用。
- en: As will be shown, the point at which the jump to `0x200000` starts is the beginning
    of a new program segment in the ELF file, and denotes a change in the permissions
    of the sections being loaded.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如将要展示的，跳转到`0x200000`的点是ELF文件中一个新程序段的开始，并且表示正在加载的部分权限的改变。
- en: 'There are some notable sections that should also be pointed out:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些值得指出的显著部分：
- en: '`.text`: This contains most, if not all, of the code associated with the program.
    This section is usually located in a segment marked as read-execute, and, ideally,
    is not given write permissions.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`：这包含了与程序相关的大部分（如果不是全部）代码。这个部分通常位于标记为读取-执行的段中，并且理想情况下不具有写权限。'
- en: '`.data`: This contains global variables that are initialized to a value other
    than `0`. As shown, this section exists in the ELF file itself, and, for this
    reason, these types of variables should be used sparingly as they increase the
    size of the resulting ELF file (which reduces the load time of the application
    and consumes additional space on the disk). It should also be noted that some
    compilers will place uninitialized variables in this section—so, if a variable
    should be `0`, initialize it as such.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`：这包含了初始化为非`0`值的全局变量。如前所示，这个部分存在于ELF文件本身中，因此这些类型的变量应该谨慎使用，因为它们会增加生成的ELF文件的大小（这会减少应用程序的加载时间，并在磁盘上占用额外的空间）。还应该注意，一些编译器会将未初始化的变量放在这个部分中，所以如果一个变量应该是`0`，就要初始化为`0`。'
- en: '`.bss`: This section contains all the global variables that should be initialized
    to `0` (assuming C and C++ is used). This section is always the last section to
    be loaded (that is to say, it is the last section marked by a segment), and does
    not actually exist in the ELF file itself. Instead, when an ELF file is loaded
    into memory, the size of the ELF file is extended to include the total size of
    this section, and the extra memory is initialized to `0` by the ELF loader (or
    the C runtime).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bss`：这个部分包含所有应该初始化为`0`的全局变量（假设使用C和C++）。这个部分总是最后一个被加载的部分（也就是说，它是由段标记的最后一个部分），并且实际上并不存在于ELF文件本身。相反，当一个ELF文件被加载到内存中时，ELF加载器（或C运行时）会扩展ELF文件的大小以包括这个部分的总大小，并且额外的内存会被初始化为`0`。'
- en: '`.dynstr/.strtab`: These tables contain the strings that are used for symbol
    names (that is, variable and function names). The `.dynstr` table contains all
    the strings that are needed during dynamic linking, while the `.strtab` section
    contains all the symbols in the program. The key point here is that the strings
    show up twice. The use of `static` in front of a variable or function prevents
    the variable''s symbol from showing up in the `.dynsym` section, which in turn
    means it will not show up in the `.dynstr` section. The downside of this is that
    the variable cannot be seen during dynamic linking, which means that, if another
    library attempts to use `extern` on that variable, it will fail. By default, all
    variables and functions should be labeled `static` unless you intend them to be
    externally assessable, reducing the total size of the file on disk and in memory.
    This also speeds up linking time, as it reduces the size of the `.dynsym` section,
    which is used for dynamic linking.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dynstr/.strtab`：这些表包含用于符号名称（即变量和函数名称）的字符串。`.dynstr`表包含在动态链接期间需要的所有字符串，而`.strtab`部分包含程序中的所有符号。关键点在于这些字符串出现了两次。在变量或函数前使用`static`可以防止变量的符号出现在`.dynsym`部分中，这意呈现它不会出现在`.dynstr`部分中。这样做的缺点是，变量在动态链接期间无法被看到，这意味着如果另一个库尝试在该变量上使用`extern`，它将失败。默认情况下，所有变量和函数都应该被标记为`static`，除非你打算让它们在外部可访问，这样可以减少磁盘和内存上文件的总大小。这也加快了链接时间，因为它减少了`.dynsym`部分的大小，该部分用于动态链接。'
- en: 'To further examine how strings are stored in an ELF file, let''s create a simple
    example with a string that is easy to look up, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步研究字符串在ELF文件中的存储方式，让我们创建一个简单的示例，其中包含一个易于查找的字符串。
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As previously shown, this example outputs `The answer is: 42` to `stdout`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所示，这个示例将`The answer is: 42`输出到`stdout`。'
- en: 'Let''s now look for this string in the ELF file itself, using the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在ELF文件本身中查找这个字符串，使用以下内容：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As previously shown, the string exists in our program and is located at `0x905`.
    Now let''s look at the ELF sections for this application:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，字符串存在于我们的程序中，并位于`0x905`。现在让我们看看这个应用程序的ELF部分：
- en: '![](img/fcc4439a-6d77-4f9a-bcec-68eef8587dee.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcc4439a-6d77-4f9a-bcec-68eef8587dee.png)'
- en: If we look at the addresses within the sections, we can see that the string
    exists in a section called `.rodata`, which contains *constant* data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看部分内的地址，我们可以看到字符串存在于一个名为`.rodata`的部分中，其中包含*常量*数据。
- en: 'Now let''s look at the assembly for this application using `objdump`, which
    disassembles the code in the `.text` section, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`objdump`查看这个应用程序的汇编，它会反汇编`.text`部分中的代码，如下所示：
- en: '![](img/d337e6cc-1f27-4d30-ad68-91757a0181bf.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d337e6cc-1f27-4d30-ad68-91757a0181bf.png)'
- en: As previously shown, the code loads `rsi` with the address of the string (at
    `0x905`), which is the second parameter, just prior to calling `std::cout`. It
    should be noted that, as before, this application was compiled using the `-pie` command,
    which means that the application itself will be relocated. This ultimately means
    that the address of the string will not be at `0x905`, but instead will be at `#
    + 0x905`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，代码在调用 `std::cout` 之前将 `rsi` 加载为字符串的地址（在 `0x905` 处），这是第二个参数。需要注意的是，与之前一样，这个应用是使用
    `-pie` 命令编译的，这意味着应用本身将被重定位。这最终意味着字符串的地址不会在 `0x905` 处，而是在 `# + 0x905` 处。
- en: To prevent the need for a relocation entry (that is, an entry in the **Global
    Offset Table** (**GOT**)), the program uses an instruction pointer relative offset.
    In this case, the instruction to load `rsi` is at `0x805`, and the offset `0x100`
    is used, which in turn returns `0x905 + rip`. This means that, no matter where
    in memory the application is loaded, the code can locate the string without a
    relocation entry being needed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要重定位条目（即**全局偏移表**（GOT）中的条目），程序使用了指令指针相对偏移。在这种情况下，加载 `rsi` 的指令位于 `0x805`
    处，使用了偏移量 `0x100`，从而返回 `0x905 + rip`。这意味着无论应用程序在内存中的哪个位置，代码都可以找到字符串，而无需需要重定位条目。
- en: ELF segments
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF 段
- en: As previously stated, ELF segments group the sections into loadable components,
    and describe how and where to load the ELF file in memory. The ideal ELF loader
    would only have to read ELF segments to load an ELF file, and (in the case of
    a relocatable ELF file) also have to load the dynamic sections and relocation
    sections.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所述，ELF 段将各个部分分组为可加载的组件，并描述了如何在内存中加载 ELF 文件的位置和方式。理想的 ELF 加载器只需要读取 ELF 段来加载
    ELF 文件，并且（对于可重定位的 ELF 文件）还需要加载动态部分和重定位部分。
- en: 'To see an ELF''s segments, use the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 ELF 的段，请使用以下代码：
- en: '![](img/4e2653f5-0f64-41f8-a955-a58831c7612a.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e2653f5-0f64-41f8-a955-a58831c7612a.png)'
- en: As shown previously, the simple example has several program segments. The first
    segment describes the program header (which defines the segments) and, for the
    most part, can be ignored.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，简单示例有几个程序段。第一个段描述了程序头（定义了段），在很大程度上可以忽略。
- en: The second segment tells the ELF loader which relocator it is expecting to use.
    Specifically, the program that is described in this segment is used for lazy relocations.
    When a program is dynamically linked, the symbols in the GOT and **Procedure Linkage
    Table** (**PLT**) contain the actual address in memory for each symbol, and the
    code references the entries in this table instead of directly referencing a symbol.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个段告诉 ELF 加载器它期望使用哪个重定位器。具体来说，这个段中描述的程序用于延迟重定位。当程序动态链接时，GOT 和**过程链接表**（PLT）中的符号包含每个符号在内存中的实际地址，代码引用这个表中的条目，而不是直接引用一个符号。
- en: This is necessary, as the compiler has no way of knowing the location of a symbol
    in another library, so the ELF loader fills in the location of each symbol by
    loading the GOT and PLT for symbols that exist in other libraries (or symbols
    that are not marked as static).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必要的，因为编译器无法知道另一个库中符号的位置，因此 ELF 加载器通过加载其他库中存在的符号的 GOT 和 PLT 来填充每个符号的位置（或者没有标记为静态的符号）。
- en: The problem is that a large program can have hundreds or thousands of these
    GOT or PLT entries and, as a result, loading a program could take a long time.
    What makes this problem even worse is that a lot of symbols from external libraries
    may never be called, which means the ELF loader would need to fill in an entry
    in the GOT or PLT with a symbol location that is not even needed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于一个大型程序可能有数百甚至数千个这些 GOT 或 PLT 条目，因此加载一个程序可能需要很长时间。更糟糕的是，许多外部库的符号可能永远不会被调用，这意味着
    ELF 加载器需要填充一个不需要的符号位置的 GOT 或 PLT 条目。
- en: To overcome these issues, the ELF loader loads the GOT and PLT with the location
    of a lazy loader, instead of the symbol itself. The lazy loader (which is the
    program you see in the second segment) loads the location of a symbol once it
    is used for the first time, reducing program load times.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，ELF 加载器将 GOT 和 PLT 加载为懒加载器的位置，而不是符号本身的位置。懒加载器（就是你在第二个段中看到的程序）在第一次使用符号时加载符号的位置，从而减少程序加载时间。
- en: The third segment, marked as `LOAD`, tells the ELF loader to load the following
    portion of the ELF file into memory. As shown in the previous output, this segment
    contains several sections, all of which are marked as read-execute. For example,
    the `.text` section exists in this section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个段标记为 `LOAD`，告诉 ELF 加载器将 ELF 文件的下一部分加载到内存中。如前面的输出所示，这个段包含几个部分，所有这些部分都标记为读取-执行。例如，`.text`
    部分存在于这个段中。
- en: All the ELF loader has to do is follow the instructions by loading the portion
    of the ELF file marked by the segment into the virtual address provided (with
    the memory size provided).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 加载器所需做的就是按照段标记的指示将 ELF 文件的部分加载到提供的虚拟地址（以及提供的内存大小）中。
- en: The fourth segment is the same as the third, but instead of the read-execute
    sections being marked, the read-write sections are marked, including sections
    such as `.data`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个段与第三个相同，但标记的不是读取-执行部分，而是标记的读取-写入部分，包括 `.data` 等部分。
- en: It should be noted that the offset in memory to load the fourth segment increases
    by `0x200000`. As previously stated, this is because the program is 2 MB aligned.
    More specifically, Intel 64-bit CPUs support 4 KB, 2 MB, and 1 GB pages.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，加载第四个段的内存偏移增加了 `0x200000`。正如之前所述，这是因为程序是 2 MB 对齐的。更具体地说，英特尔 64 位 CPU
    支持 4 KB、2 MB 和 1 GB 页面。
- en: Since the first loadable segment is marked read-execute, the second loadable
    segment cannot be on the same page as the first (otherwise, it too would have
    to be marked read-execute). As a result, the second loadable segment is designed
    to start on the next available page, which in this case, is 2 MB in memory. This
    allows the operating system to mark the first loadable segment as read-execute
    and the second loadable segment as read-write, and the CPU can enforce these permissions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个可加载段标记为读-执行，第二个可加载段不能在同一页上（否则，它也必须标记为读-执行）。因此，第二个可加载段被设计为从下一个可用页面开始，这种情况下是内存中的2MB。这允许操作系统将第一个可加载段标记为读-执行，第二个可加载段标记为读-写，并且CPU可以强制执行这些权限。
- en: The next segment defines the location of the dynamic section, which is used
    by the ELF loader to perform dynamic relocations. This is necessary because the
    executable was compiled using `-pie`. It should be noted that the ELF loader could
    scan the ELF sections to find this data, but the goal of the program segments
    is to define all of the information needed to load an ELF file without the need
    for scanning the sections. Sadly, in practice, this is not always true, but, ideally,
    this should be the case.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分定义了动态部分的位置，ELF加载器用于执行动态重定位。这是必要的，因为可执行文件是使用`-pie`编译的。需要注意的是，ELF加载器可以扫描ELF部分以找到这些数据，但程序段的目标是定义加载ELF文件所需的所有信息，而无需扫描部分。不幸的是，在实践中，这并不总是正确的，但理想情况下应该是这样。
- en: The *notes* segment can safely be ignored. The following segments provide the
    ELF loader with the location of the exception information (as described); the
    permissions for the stack that the executable expects; which, ideally, would always
    be read-write and not read-write-execute, and the location of the read-only section,
    which can have its permissions changed to read-only once loaded.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*notes*部分可以安全地忽略。以下部分为ELF加载器提供了异常信息的位置（如描述）；可执行文件期望的堆栈权限，理想情况下应该始终是读写而不是读写执行；以及只读部分的位置，加载后可以更改其权限为只读。'
- en: The Unix filesystem
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix文件系统
- en: The Unix filesystem, which is used by most Unix-based operating systems, including
    Linux, consists of a virtual filesystem tree, which is the frontend to the user
    and applications. The tree starts with the root (that is, `/`), and all files,
    devices, and other resources are located within this single root directory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Unix文件系统被大多数基于Unix的操作系统使用，包括Linux，它由一个虚拟文件系统树组成，这是用户和应用程序的前端。树从根目录（即`/`）开始，所有文件、设备和其他资源都位于这个单一的根目录中。
- en: From there, a physical filesystem is usually mapped onto the virtual filesystem,
    providing a mechanism by which files are stored and retrieved. It should be noted
    that this physical filesystem does not have to be a disk; it could also be RAM
    or some other type of storage device.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，物理文件系统通常映射到虚拟文件系统，提供了一种存储和检索文件的机制。需要注意的是，这个物理文件系统不一定是一个磁盘；它也可以是RAM或其他类型的存储设备。
- en: 'To perform this mapping, the operating system has a mechanism for instructing
    the OS to perform this mapping. On Linux, this is done using `/etc/fstab`, as
    follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这种映射，操作系统有一个机制指示OS执行这种映射。在Linux上，这是通过`/etc/fstab`完成的，如下所示：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As shown in this example, the root filesystem maps to a specific physical device
    (denoted with a UUID), which contains an `ext4` filesystem. In addition, within
    this root filesystem, another physical partition is mapped to `/boot/efi` and
    contains a VFAT filesystem.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，根文件系统映射到一个特定的物理设备（用UUID表示），其中包含一个`ext4`文件系统。此外，在这个根文件系统中，另一个物理分区映射到`/boot/efi`，包含一个VFAT文件系统。
- en: What this means is that all access to the virtual filesystem defaults to the
    `ext4` partition, while access to anything below `/boot/efi` is redirected to
    a separate VFAT partition that contains files specific to UEFI (which is the specific
    BIOS being used in the textbox used to write this book).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对虚拟文件系统的所有访问都默认为`ext4`分区，而对`/boot/efi`下的任何内容的访问都会被重定向到一个包含特定于UEFI的文件的单独的VFAT分区（这是用于编写本书的文本框中使用的特定BIOS）。
- en: Any node within the virtual filesystem can be remapped to any device or resource.
    The brilliance behind this design is that applications do not need to be concerned
    with what type of device the virtual filesystem is currently mapping, as long
    as the application has permissions for the portion of the filesystem it is trying
    to access, and has the ability to open a file and read and write to it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟文件系统中的任何节点都可以重新映射到任何设备或资源。这种设计的精妙之处在于，应用程序不需要关心虚拟文件系统当前映射的设备类型，只要应用程序对它正在尝试访问的文件系统部分有权限，并且有能力打开文件并读写它。
- en: 'For example, let''s look at the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看以下内容：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On most Linux-based systems, a file called `/dev/null` exists. This file doesn''t
    actually map to a real file. Instead, the virtual filesystem maps this file to
    a device driver that ignores all writes and returns nothing when read. For example,
    see the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数基于Linux的系统上，存在一个名为`/dev/null`的文件。这个文件实际上并不映射到一个真实的文件。相反，虚拟文件系统将这个文件映射到一个忽略所有写入并在读取时返回空的设备驱动程序。例如，参见以下内容：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Most Linux-based systems also provide a `/dev/zero`, which returns all zeros
    when read, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于Linux的系统还提供了`/dev/zero`，当读取时返回所有的零，如下所示：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There is also `/dev/random`, which returns a random number when read, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`/dev/random`，当读取时返回一个随机数，如下所示：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As discussed previously, in [Chapter 2](5fbe5888-ed33-49fb-8b28-1688ce9e0087.xhtml),
    *Learning the C, C++17, and POSIX Standards*, the layout of the filesystem that
    POSIX defines is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在[第2章](5fbe5888-ed33-49fb-8b28-1688ce9e0087.xhtml)中，*学习C、C++17和POSIX标准*，POSIX定义的文件系统布局如下：
- en: '`/bin`: for binaries used by all users'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /bin：用于所有用户使用的二进制文件
- en: '`/boot`: for files needed to boot the operating system'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`：用于引导操作系统所需的文件'
- en: '`/dev`: for physical and virtual devices'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：用于物理和虚拟设备'
- en: '`/etc`: for configuration files needed by the operating system'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：操作系统需要的配置文件'
- en: '`/home`: for user-specific files'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home`：用于特定用户文件'
- en: '`/lib`: for libraries needed by executables'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：用于可执行文件所需的库'
- en: '`/mnt` and `/media`: used as temporary mount points'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mnt`和`/media`：用作临时挂载点'
- en: '`/sbin`: for system-specific binaries'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`：用于系统特定的二进制文件'
- en: '`/tmp`: for files that are deleted on reboot'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`：用于在重启时删除的文件'
- en: '`/usr`: for user-specific versions of the preceding folders'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`：用于前述文件夹的特定用户版本'
- en: Typically, the files under `/boot` point to a physical partition that is different
    to the root partition, the `/dev` folder contains files that are mapped to devices
    (rather than files that are stored and retrieved on a disk), and `/mnt` or `/media`
    is used to mount temporary devices such as USB storage devices and CD-ROMs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`/boot`下的文件指向与根分区不同的物理分区，`/dev`文件夹包含映射到设备的文件（而不是存储和检索在磁盘上的文件），`/mnt`或`/media`用于挂载临时设备，如USB存储设备和CD-ROM。
- en: On some systems, `/home` could be mapped to a completely separate hard drive,
    allowing the user to completely format and reinstall the root filesystem (that
    is, to reinstall the OS), without losing any personal files or configurations.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些系统上，`/home`可能被映射到一个完全独立的硬盘驱动器，允许用户完全格式化和重新安装根文件系统（即重新安装操作系统），而不会丢失任何个人文件或配置。
- en: 'The Unix filesystem also maintains an entire set of permissions that define
    who is allowed to read, write, and execute files. See the following example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Unix文件系统还维护了一整套权限，定义了谁被允许读取、写入和执行文件。参见以下示例：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The filesystem defines the permissions for the file's owner, the file's group,
    and others (users who are neither the owner nor part of the file's group).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统定义了文件所有者、文件组和其他人（既不是所有者也不是文件组成员）的权限。
- en: The first column in the preceding example defines a file's permissions. The
    `d` defines whether or not a node is a directory or a file. The first of the three
    characters define the read/write/execute permissions for a file's owner, while
    the second defines the permissions for a file's group, and finally, the third
    defines the permissions for others.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的第一列定义了文件的权限。`d`定义了节点是目录还是文件。前三个字符定义了文件所有者的读/写/执行权限，第二个定义了文件组的权限，最后一个定义了其他用户的权限。
- en: The third column in the preceding example defines the name of the owner, while
    the second column defines the name of the group (which, in most cases, is also
    the owner).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的第三列定义了所有者的名称，而第二列定义了组的名称（在大多数情况下也是所有者）。
- en: Using this permission model, the Unix filesystem can control access to any file
    or directory for any given user, a group of users, and everyone else.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种权限模型，Unix文件系统可以控制任何给定用户、一组用户和其他所有人对任何文件或目录的访问。
- en: Unix processes
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix进程
- en: A process on a Unix-based system is a userspace application executed and scheduled
    by the operating system. In this book, we will refer to processes and userspace
    applications interchangeably.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Unix系统上的进程是由操作系统执行和调度的用户空间应用程序。在本书中，我们将进程和用户空间应用程序互换使用。
- en: As will be shown, most Unix-based processes that are running at any given time
    are children of some other parent process, and each kernel implements processes
    under the hood differently, but the same basic commands for creating and managing
    processes are provided by all Unix operating systems.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如将要展示的，大多数在任何给定时间运行的基于Unix的进程都是某些其他父进程的子进程，每个内核在底层实现进程的方式可能不同，但所有Unix操作系统都提供了相同的基本命令来创建和管理进程。
- en: In this section, we will discuss how to create and manage Unix-based processes
    using commonly-seen POSIX interfaces.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用常见的POSIX接口创建和管理基于Unix的进程。
- en: The fork() function
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fork()函数
- en: On a Unix-based system, the `fork()` function is used to create processes. The
    `fork()` function is a relatively simple system call provided by the operating
    system that takes the current process, and creates a duplicate child version of
    the process. Everything about the parent and child processes is the same, including
    opened file handles, memory, and so on, with the key difference being that the
    child process has a new process ID.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Unix的系统上，`fork()`函数用于创建进程。`fork()`函数是操作系统提供的一个相对简单的系统调用，它接受当前进程，并创建进程的一个重复子版本。父进程和子进程的一切都是相同的，包括打开的文件句柄、内存等，唯一的区别是子进程有一个新的进程ID。
- en: In [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml), *Learning to Program
    POSIX and C++ Threads*, we will discuss threads (which are more commonly used
    for system programming than processes). Both threads and processes are scheduled
    by the operating system; the main difference between a thread and a process is
    that a child and parent process do not have access to one another's memory, while
    threads do.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml)中，《学习编程POSIX和C++线程》，我们将讨论线程（在系统编程中比进程更常用）。线程和进程都由操作系统调度；线程和进程的主要区别在于子进程和父进程无法访问彼此的内存，而线程可以。
- en: Even though `fork()` creates a new process with the same resources and memory
    layout, the memory that is shared between the parent and child processes are marked
    as copy-on-write. This means that, as the parent and child process executes, any
    attempt to write to memory that might have been shared causes the child process
    to create its own copies of memory that only it can write to. As a result, the
    parent process is unable to see modifications to the memory made by the child.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`fork()`创建了一个具有相同资源和内存布局的新进程，父进程和子进程之间共享的内存被标记为写时复制。这意味着，当父进程和子进程执行时，任何尝试写入可能已经共享的内存的操作会导致子进程创建自己的内存副本，只有它自己可以写入。结果是，父进程无法看到子进程对内存所做的修改。
- en: This is not true for threads, as threads maintain the same memory layout and
    are not marked as copy-on-write. As a result, a thread is capable of seeing the
    changes made to the memory by another thread (or parent process).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于线程来说并不是这样，因为线程保持相同的内存布局，不会被标记为写时复制。因此，一个线程能够看到另一个线程（或父进程）对内存所做的更改。
- en: 'Let''s look at the following example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we use the `fork()` system call to create a duplicate process.
    The duplicate, child, process outputs `Hello World` to `stdout` using `std::cout`.
    As shown, the result of this example is that `Hello World` is output twice.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`fork()`系统调用创建一个重复的进程。重复的子进程使用`std::cout`向`stdout`输出`Hello World`。如示例所示，这个例子的结果是`Hello
    World`被输出两次。
- en: 'The `fork()` system call returns the process ID in the parent process for the
    child, and in the child `0`, is returned. If an error occurs, `-1` is returned
    and `errno` is set to the appropriate error code. See the following example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork()`系统调用在父进程中返回子进程的进程ID，在子进程中返回`0`。如果发生错误，将返回`-1`并将`errno`设置为适当的错误代码。看下面的例子：'
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, the parent process outputs `Hello` while the child process
    outputs `World`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，父进程输出`Hello`，而子进程输出`World`。
- en: 'To examine how shared memory is handled between the parent and child process,
    as described, let''s look at the following example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查父进程和子进程之间如何处理共享内存，让我们看下面的例子：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we output the `The answer is:` string for both the parent and
    child processes. Both processes have access to a global variable called `data`, which
    is initialized to `0`. The difference is that the parent process sets the `data`
    variable to `42` and the child does not.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为父进程和子进程输出`The answer is:`字符串。两个进程都可以访问一个名为`data`的全局变量，它被初始化为`0`。不同之处在于父进程将`data`变量设置为`42`，而子进程没有。
- en: 'The parent process completes its job before the operating system schedules
    the child process, and, as a result, `The answer is: 42` is output to `stdout`
    first.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '父进程在操作系统调度子进程之前完成了它的工作，因此`The answer is: 42`首先被输出到`stdout`。'
- en: Once the child process has a chance to execute, it too outputs this string,
    but the answer is `0` and not `42`. This is because, as far as the child is concerned,
    the data variable was never set. Both the child process and the parent process
    have access to their own memory (at least, the memory that is written), and as
    such, `42` was set in the memory for the parent, not the child.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦子进程有机会执行，它也输出这个字符串，但答案是`0`而不是`42`。这是因为对于子进程来说，数据变量从未被设置过。父进程和子进程都可以访问自己的内存（至少是写入的内存），因此`42`是在父进程的内存中设置的，而不是子进程的。
- en: On most Unix-based operating systems, the first process to execute is `init`,
    which starts the rest of the processes on the system using `fork()`. This means
    the `init` process is the root-level parent for userspace applications (sometimes
    referred to as the grandparent). As such, the `fork()` system call can be used
    to create complex trees of processes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数基于Unix的操作系统中，第一个执行的进程是`init`，它使用`fork()`启动系统上的其他进程。这意味着`init`进程是用户空间应用程序的根级父进程（有时被称为祖父）。因此，`fork()`系统调用可以用来创建复杂的进程树。
- en: 'See the following example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding example, we execute the `fork()` system call twice, which
    generates three additional processes. To understand why three processes are created
    instead of two, let''s make a simple modification to the example, to highlight
    the tree structure that is created, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们两次执行`fork()`系统调用，生成了三个额外的进程。为了理解为什么会创建三个进程而不是两个，让我们对例子进行简单修改，以突出所创建的树结构，如下所示：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, we execute `fork()` twice, as previously, with the main difference
    being that we output the ID for each process that is created. The parent process
    executes `fork()`, outputs the ID, executes `fork()` again, and then outputs the
    ID again before executing.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们像之前一样两次执行`fork()`，唯一的区别是我们输出每个创建的进程的ID。父进程执行`fork()`，输出ID，再次执行`fork()`，然后再次输出ID后执行。
- en: Since the IDs are not `0` (in fact, they are `14181` and `14182`), we know that
    this is the parent process, and, as expected, it creates two child processes.
    The next IDs that are shown are `0` and `14183`. This is the first child process
    (`14181`), which occurs at the first call to `fork()` by the parent.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ID不是`0`（实际上是`14181`和`14182`），我们知道这是父进程，并且如预期的那样，它创建了两个子进程。接下来显示的ID是`0`和`14183`。这是第一个子进程（`14181`），它出现在父进程第一次调用`fork()`时。
- en: This child process then continues to create its own child process (which has
    the ID `14183`, as stated). The parent process and the child process each created
    an additional process (`14182` and `14183`) when the second `fork()` was executed,
    which both output `0` for `id2`. This accounts for the last two outputs.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这个子进程继续创建它自己的子进程（ID为`14183`）。当第二次执行`fork()`时，父进程和子进程分别创建了一个额外的进程（`14182`和`14183`），它们都为`id2`输出了`0`。这解释了最后两个输出。
- en: It should be noted that this example might need to be executed several times
    to get a clean result, as each additional child process increases the chance that
    one child process will execute at the same time as the other child processes,
    corrupting the output. As processes do not share memory, implementing methods
    to synchronize the output in an example like this is non-trivial.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这个例子可能需要执行多次才能得到一个干净的结果，因为每个额外的子进程增加了一个子进程与其他子进程同时执行的机会，从而破坏了输出。由于进程不共享内存，在这样的例子中实现同步输出的方法并不简单。
- en: 'The use of `fork()` creates *n*^2 processes, with *n* being the total number
    of times `fork()` is called. For example, if `fork()` were called three times
    instead of two, as in the simplified preceding example, we would expect `Hello
    World` to output eight times instead of four, as shown here:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fork()`创建*n*^2个进程，其中*n*是调用`fork()`的总次数。例如，如果`fork()`被调用三次而不是两次，就像在简化的前面的例子中一样，我们期望`Hello
    World`输出的次数是八次而不是四次，如下所示：
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In addition to the exponential growth of processes shown, some processes might
    choose to create a child while others might not, resulting in a complex process
    tree structure.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示的进程呈指数增长外，一些进程可能选择创建子进程，而另一些可能不会，导致复杂的进程树结构。
- en: 'See the following example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, the parent process creates child processes, while each child
    process does nothing. This results in the `The answer is 42` string being output
    to `stdout` solely by the parent process.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，父进程创建子进程，而每个子进程都不做任何事情。这导致`The answer is 42`字符串仅由父进程输出到`stdout`。
- en: The wait() function
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: wait()函数
- en: As stated, each process is executed by the operating system in whatever order
    the operating system chooses. As a result, it is possible that the parent process
    could finish its execution prior to the child process completing. On some operating
    systems, this could result in corruption, as some operating systems require the
    parent process to be alive for the child process to successfully complete.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，操作系统以操作系统选择的任何顺序执行每个进程。因此，父进程在子进程完成之前可能会完成执行。在某些操作系统上，这可能会导致损坏，因为某些操作系统要求父进程在子进程成功完成之前保持活动状态。
- en: 'To handle this, POSIX provides the `wait()` function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，POSIX提供了`wait()`函数：
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, we create a child process that outputs `child` to `stdout`.
    Meanwhile, the parent outputs `parent` to `stdout` and then executes the `wait()`
    function, which tells the parent to wait for a child to complete its execution.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个子进程，将`child`输出到`stdout`。与此同时，父进程将`parent`输出到`stdout`，然后执行`wait()`函数，告诉父进程等待子进程完成执行。
- en: We pass `nullptr` to the `wait()` function, as that tells the `wait()` function
    that we are not interested in an error code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`nullptr`传递给`wait()`函数，因为这告诉`wait()`函数我们对错误代码不感兴趣。
- en: The `wait()` function waits for *any* child process to complete. It doesn't
    wait for a *specific* child process to complete. As a result, if more than one
    child process has been created, `wait()` must be executed more than once.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()`函数等待*任何*子进程完成。它不等待*特定*子进程完成。因此，如果创建了多个子进程，必须多次执行`wait()`。'
- en: 'See the following example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, we create eight child processes. As previously stated,
    the total number of processes created is 2^(the number of times `fork` is called).
    In this example, however, we are interested in making sure that the grandparent,
    which is the root parent process, is the last process to finish executing.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了八个子进程。如前所述，创建的进程总数是2^(调用`fork`的次数)。然而，在这个例子中，我们希望确保祖父进程，也就是根父进程，是最后一个完成执行的进程。
- en: Remember that, when we call `fork()` like this, the first call creates the first
    child. The second call to `fork()` makes another child, but the first child now
    becomes a parent as it calls `fork()`. The same happens (but even more so) when
    we call `fork()` a third time. The grandparent is the root parent process.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们像这样调用`fork()`时，第一次调用创建第一个子进程。第二次调用`fork()`创建另一个子进程，但第一个子进程现在成为父进程，因为它调用`fork()`。当我们第三次调用`fork()`时，同样的事情发生了（甚至更多）。祖父进程是根父进程。
- en: Regardless of which process is the grandparent process, we want to ensure that
    all child processes finish before their parents do. To accomplish this, we record
    the process ID each time `fork()` is executed. For child processes, this ID is
    set to `0`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪个进程是祖父进程，我们都希望确保所有子进程在其父进程之前完成。为了实现这一点，我们记录每次执行`fork()`时的进程ID。对于子进程，此ID设置为`0`。
- en: The next thing we do is enter a `while(1)` loop, and then call `wait()`. The
    `wait()` function will exit as soon as a child process is complete. Once the process
    is complete, we output which child process exited to `stdout`. If the process
    ID that we get from `wait()` is `-1`, we know that no more child processes exist,
    and we can exit the `while(1)` loop.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入一个`while(1)`循环，然后调用`wait()`。`wait()`函数将在子进程完成时退出。进程完成后，我们输出退出到`stdout`的子进程。如果我们从`wait()`获取的进程ID是`-1`，我们知道没有更多的子进程存在，我们可以退出`while(1)`循环。
- en: Finally, if none of the process IDs are equal to `0`, we know that the process
    is the grandparent, and we output when it exits just to show that it is the last
    process to exit.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果没有一个进程ID等于`0`，我们知道该进程是祖父，我们输出它何时退出，只是为了显示它是最后一个退出的进程。
- en: Since the `wait()` function will not return `0`, we know that when a child process
    exits, we will only ever output the child process that exited within our `while(1)`
    loop. As shown, we see that one child with `id1` exits, two children with `id2`
    exit, and four children with `id3` exit. This is as expected, based on the math
    that we performed previously.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`wait()`函数不会返回`0`，我们知道当子进程退出时，我们只会在我们的`while(1)`循环中输出退出的子进程。如所示，我们看到一个带有`id1`的子进程退出，两个带有`id2`的子进程退出，以及四个带有`id3`的子进程退出。这与我们之前执行的数学计算一致。
- en: It should also be noted that this example ensures that all child processes are
    completed before the parent completes. This means that the grandparent must wait
    for its children to complete. Since the child processes of the grandparent also
    create their own processes, the grandparent must first wait for the parent process
    to complete, which must wait in turn for its children to complete.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意，这个例子确保所有子进程在父进程之前完成。这意味着祖父必须等待其子进程完成。由于祖父的子进程也创建自己的进程，因此祖父必须首先等待父进程完成，而父进程必须依次等待其子进程完成。
- en: This results in a cascading effect of child processes completing before their
    parents, all the way until the grandparent process finally completes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了子进程在其父进程之前完成的级联效应，一直到最终完成祖父进程。
- en: 'Finally, it should also be noted that, although parents have to wait for their
    children to complete, it doesn''t mean that all children with `id3` will exit
    before children with `id2` exit. This is because one half of the child tree could
    complete without issue before the other half completes, or in any order. As a
    result, it''s possible to get outputs like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还应该注意，尽管父进程必须等待子进程完成，但这并不意味着所有带有`id3`的子进程将在带有`id2`的子进程之前退出。这是因为子树的一半可能在另一半完成之前或以任何顺序完成而没有问题。因此，可能会得到这样的输出：
- en: '[PRE41]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this example, the last `child #3` to complete was the process that was created
    by the last call to `fork()` by the grandparent process.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，最后完成的`child #3`是由祖父进程最后一次调用`fork()`创建的进程。'
- en: Interprocess communication (IPC)
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程间通信（IPC）
- en: 'In one of our preceding examples, we demonstrated how `fork()` can be used
    to create a child process from a parent process, as shown here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的一个例子中，我们演示了如何使用`fork()`从父进程创建一个子进程，如下所示：
- en: '[PRE42]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The reason we see `parent` output before `child` in this example is merely the
    result of the operating system taking longer to start the child process than it
    takes to output from the child process. If the parent process were to take longer,
    `child` would output first.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到`parent`在`child`之前输出仅仅是因为操作系统启动子进程的时间比从子进程输出的时间长。如果父进程需要更长的时间，`child`将首先输出。
- en: 'See the following example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见以下示例：
- en: '[PRE43]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is identical to the previous example, with the exception that a `sleep()`
    command was added to the parent process, which tells the operating system to yield
    the execution of the parent for one second. As a result, the child process has
    plenty of time to execute, resulting in `child` being output first.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的例子相同，唯一的区别是在父进程中添加了一个`sleep()`命令，告诉操作系统暂停父进程的执行一秒钟。结果，子进程有足够的时间来执行，导致`child`首先输出。
- en: To prevent the child from executing first, we need to set up a communication
    channel between the parent and child process so that the child process knows to
    wait for the parent to finish outputting to `stdout` before the child does. This
    is called **synchronization**.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止子进程先执行，我们需要在父进程和子进程之间建立一个通信通道，以便子进程知道在父进程完成向`stdout`输出之前等待。这被称为**同步**。
- en: For more information about synchronization, how to handle it, and the issues
    that arise from synchronization, such as deadlock and race conditions, please
    see the *Further reading* section in this chapter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有关同步、如何处理同步以及同步引起的死锁和竞争条件等问题的更多信息，请参见本章的*进一步阅读*部分。
- en: In this section, the mechanism we will use to synchronize the parent and child
    process is called **Interprocess communication** (**IPC**). It should be noted
    before we continue that creating multiple processes and using IPC to synchronize
    them is a heavy-handed way of creating and coordinating more than one task on
    the operating system. Unless separate processes are absolutely needed, a better
    approach is to use threading, a topic that we cover in great detail in [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml),
    *Learning to Program POSIX and C++ Threads*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将用来同步父进程和子进程的机制称为**进程间通信**（**IPC**）。在继续之前，应该注意到，创建多个进程并使用IPC来同步它们是在操作系统上创建和协调多个任务的一种笨重的方式。除非绝对需要单独的进程，更好的方法是使用线程，这是我们在[第12章](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml)中详细介绍的一个主题，*学习编程POSIX和C++线程*。
- en: 'There are several different types of IPC that can be leveraged in a Unix system.
    Here, we will cover two of the most popular methods:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix系统中有几种不同类型的IPC可以利用。在这里，我们将介绍两种最流行的方法：
- en: Unix pipes
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix管道
- en: Unix shared memory
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix共享内存
- en: Unix pipes
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix管道
- en: A pipe is a mechanism for sending information from one process to another. In
    its simplest form, a pipe is a file (in RAM) that one process can write to, and
    the other can read from. The file starts out empty, and no bytes can be read from
    the pipe until bytes are written to it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一种从一个进程向另一个进程发送信息的机制。在其最简单的形式中，管道是一个文件（在RAM中），一个进程可以向其写入，另一个进程可以从中读取。文件最初为空，直到有字节写入它，才能从管道中读取字节。
- en: 'Let''s look at the following example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This example is similar to the previous example, with the addition of a Unix
    pipe. This is used to ensure that even if the parent takes a while to execute,
    the parent outputs to `stdout` before the child executes. To accomplish this,
    we create a class that leverages **Resource Acquisition Is Initialization** (**RAII**)
    to encapsulate the Unix pipe, ensuring that the details of the C APIs are properly
    abstracted and the handles that are opened to support Unix pipes are closed when
    the `mypipe` class loses scope.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与之前的例子类似，增加了一个Unix管道。这是为了确保即使父进程需要一段时间来执行，父进程在子进程执行之前输出到`stdout`。为了实现这一点，我们创建了一个类，利用**资源获取即初始化**（**RAII**）来封装Unix管道，确保正确抽象C
    API的细节，并在`mypipe`类失去作用域时关闭支持Unix管道的句柄。
- en: 'The first thing we do in the class is to open the pipe, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在课上做的第一件事是打开管道，如下所示：
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The pipe itself is an array of two file handles. The first handle is used to
    read from the pipe, while the second handle is used to write to the pipe. The
    `pipe()` function will return `-1` if an error occurs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 管道本身是两个文件句柄的数组。第一个句柄用于从管道中读取，而第二个句柄用于向管道中写入。如果发生错误，`pipe()`函数将返回`-1`。
- en: 'It should be noted that if the `pipe()` function succeeds, the result is two
    file handles that should be closed when they are no longer used. To support this,
    we close the file handles that were opened in the destructor of the class, so
    that when the pipe loses scope, the pipe is closed, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果`pipe()`函数成功，结果是两个文件句柄，当不再使用时应该关闭。为了支持这一点，我们在类的析构函数中关闭打开的文件句柄，这样当管道失去作用域时，管道就关闭了，如下所示：
- en: '[PRE46]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We then provide a `read()` function as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们提供一个`read()`函数，如下所示：
- en: '[PRE47]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `read()` function creates a buffer that can be read to, and we read from
    the pipe and place the results in the buffer. Notice how we read from the first
    file handle, as stated.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()`函数创建一个可以读取的缓冲区，我们从管道中读取并将结果放入缓冲区。注意我们从第一个文件句柄中读取，如所述。'
- en: It should be noted that the `read()` and `write()` functions that we leverage
    here will be covered in detail in [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning
    to Program File Input/Output*. For now, it is important to note that the `read()`
    function, in this case, is a blocking function, and will not return until data
    is read from the pipe. If an error occurs (for example, the pipe is closed), `-1`
    will be returned.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们在这里利用的`read()`和`write()`函数将在[第8章](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml)中详细介绍，*学习文件输入/输出编程*。现在，重要的是要注意，`read()`函数在这种情况下是一个阻塞函数，直到从管道中读取数据才会返回。如果发生错误（例如，管道关闭了），将返回`-1`。
- en: To account for this, we only return the data that is read from the pipe if actual
    bytes are read; otherwise, we return a null string, which can be used by the user
    of this class to detect an error (or we could use a C++ exception, as covered
    in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml), *Error - Handling
    with Exceptions*).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们只在从管道中读取实际字节时返回数据；否则，我们返回一个空字符串，用户可以用这个类来检测错误（或者我们可以使用C++异常，如[第13章](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml)中所述的异常处理）。
- en: 'Finally, we also add a `write()` function to the pipe, as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还添加了一个`write()`函数到管道，如下所示：
- en: '[PRE48]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `write()` function is far simpler, writing to the write side of the pipe
    using the `write()` Unix function.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`write()`函数更简单，使用`write()` Unix函数写入管道的写端。'
- en: 'In the parent process we do the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在父进程中我们做以下事情：
- en: '[PRE49]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first thing we do is sleep for one second, which ensures that the parent
    takes a long time to execute. If synchronization were not used, the child process
    would output to `stdout` before the parent process as a result of the use of this
    `sleep()` function.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要做的是睡一秒钟，这样可以确保父进程需要很长时间才能执行。如果不使用同步，子进程会在父进程之前输出到`stdout`，这是由于使用了`sleep()`函数的结果。
- en: The next thing we do is to output to `stdout` and then write the `done` message to
    the pipe. Finally, we wait for the child process to finish before exiting.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是输出到`stdout`，然后将`done`消息写入管道。最后，我们等待子进程完成后再退出。
- en: 'The child process does the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程做以下事情：
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As stated, the `read()` function is a blocking function, which means that it
    will not return until data is read from the file handle (or an error occurs).
    We assume that no errors will occur, and store the resulting string in a variable
    called `msg`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，`read()`函数是一个阻塞函数，这意味着它在从文件句柄中读取数据（或发生错误）之前不会返回。我们假设不会发生错误，并将结果字符串存储在一个名为`msg`的变量中。
- en: Since the `read()` function is blocking, the child process will wait until the
    parent process outputs to `stdout`, and then writes to the pipe. No matter what
    the parent process does before the write to the pipe, the child process will wait.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`read()`函数是阻塞的，子进程会等待父进程输出到`stdout`，然后写入管道。无论父进程在写入管道之前做了什么，子进程都会等待。
- en: Once the call to `read()` returns, we output to `stdout` *child* and the message
    that was sent by the parent, and exit.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`read()`调用返回，我们输出到`stdout` *child* 和父进程发送的消息，然后退出。
- en: Using this simple example, we are able to send information from one process
    to another. In this case, we use this communication to synchronize the parent
    and child processes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的例子，我们能够从一个进程发送信息到另一个进程。在这种情况下，我们使用这种通信来同步父进程和子进程。
- en: Unix shared memory
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix共享内存
- en: Unix shared memory is another popular form of IPC. Unlike Unix pipes, Unix shared
    memory provides a buffer that can be read and written to by both processes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Unix共享内存是另一种流行的IPC形式。与Unix管道不同，Unix共享内存提供了一个可以被两个进程读写的缓冲区。
- en: 'Let''s examine the following example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看下面的例子：
- en: '[PRE51]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding example, we create the following function which is responsible
    for opening the shared memory between the parent and child processes:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了以下函数，负责在父进程和子进程之间打开共享内存：
- en: '[PRE52]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This function starts by creating a unique key, which is used by the operating
    system to associate the shared memory between the parent and child processes.
    Once this key is generated, `shmget()` is used to open the shared memory.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先创建一个唯一的键，操作系统用它来关联父进程和子进程之间的共享内存。一旦生成了这个键，就使用`shmget()`来打开共享内存。
- en: '`0x1000` tells `shmget()` that we would like to open 4 KB of memory, and `0666
    | IPC_CREATE` is used to tell `shmget()` that we would like to open the memory
    with read and write permissions, and create the shared memory file if it doesn''t
    exist.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x1000`告诉`shmget()`我们想要打开4KB的内存，`0666 | IPC_CREATE`用于告诉`shmget()`我们想要以读写权限打开内存，并在不存在时创建共享内存文件。'
- en: The result of `shmget()` is a handle that can be used by `shmat()` to return
    a pointer to the shared memory.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`shmget()`的结果是一个句柄，可以被`shmat()`使用来返回指向共享内存的指针。'
- en: It should be noted that a more complete example would wrap this shared memory
    in a class so that RAII can be used as well as leveraging the GSL to properly
    protect the buffer that is shared between both processes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，一个更完整的例子会将这个共享内存封装在一个类中，这样RAII也可以被使用，并且利用GSL来正确保护两个进程之间共享的缓冲区。
- en: 'In the parent process, we do the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在父进程中，我们做以下事情：
- en: '[PRE53]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As in the previous example, the parent sleeps for one second before outputting
    to `stdout`. Next, the parent gets the shared memory region, and writes `42` to
    the buffer. Finally, the parent waits for the child to complete before exiting.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，父进程在输出到`stdout`之前睡眠一秒。接下来，父进程获取共享内存区域，并向缓冲区写入`42`。最后，父进程在退出之前等待子进程完成。
- en: 'The child process does the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程执行以下操作：
- en: '[PRE54]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As shown, the child process gets the shared memory buffer and waits for the
    buffer to have the value `42`. Once it does, which means the parent process has
    finished outputting to `stdout`, the child outputs to `stdout` and exits.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，子进程获取共享内存缓冲区，并等待缓冲区的值为`42`。一旦这样做了，也就是说父进程已经完成了对`stdout`的输出，子进程就会输出到`stdout`并退出。
- en: The exec() function
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`exec()`函数'
- en: Up until this point, all the child processes that we have created were copies
    of the parent process, with the same code and memory structure. Although this
    can be done, it is far less likely, as POSIX threads provide the same functionality
    without the issues with shared memory and IPC. POSIX threads will be discussed
    in more detail in [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml), *Learning
    to Program POSIX and C++ Threads*.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一点，我们创建的所有子进程都是父进程的副本，具有相同的代码和内存结构。虽然这是可以做到的，但这种情况不太可能发生，因为POSIX线程提供了相同的功能，而且没有共享内存和IPC的问题。POSIX线程将在[第12章](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml)中更详细地讨论，*学习编程POSIX和C++线程*。
- en: 'Instead, it is more likely that calls to `fork()` will be followed by calls
    to `exec()`. The `exec()` system call is used to override the existing process
    with a completely new process. See the following example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，更有可能的是对`fork()`的调用后面跟着对`exec()`的调用。`exec()`系统调用用全新的进程覆盖现有的进程。看下面的例子：
- en: '[PRE55]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding example, we make a call to `execl()`, which is a specific version
    of the `exec()` family of system calls. The `execl()` system call executes the
    first argument to the function, and passes the remaining arguments to the process
    as `argv[]`. The last argument always has to be `nullptr`, just as the last argument
    in `argv[]` is always `nullptr`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们调用了`execl()`，这是`exec()`系统调用系列的一个特定版本。`execl()`系统调用执行函数的第一个参数，并将剩余的参数作为`argv[]`传递给进程。最后一个参数总是必须是`nullptr`，就像`argv[]`中的最后一个参数总是`nullptr`一样。
- en: The call to `exec()` (and friends) replaces the current process with the new
    process being executed. As a result, the call to output `Hello World` to `stdout`
    is not called. This is because this call is part of the `a.out` program, not the
    `ls` program, and since `exec()` replaces the current process with the new executable,
    the output never occurs.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 对`exec()`（和相关函数）的调用会用新执行的进程替换当前进程。因此，对`stdout`输出`Hello World`的调用不会被执行。这是因为这个调用是`a.out`程序的一部分，而不是`ls`程序的一部分，而且由于`exec()`用新的可执行文件替换了当前进程，输出就永远不会发生。
- en: This is why `fork()` and `exec()` are usually called together. The call to `fork()`
    creates a new process, while the call to `exec()` takes that new process and executes
    the desired program as that new process.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`fork()`和`exec()`通常一起调用的原因。`fork()`的调用创建了一个新的进程，而`exec()`的调用将新的进程作为新的进程执行所需的程序。
- en: 'This is how the `system()` system call works:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`system()`系统调用的工作原理：
- en: '[PRE56]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When calling `system()`, the `ls` executable is run, and the `system()` function
    waits until the executable is complete. Once it is complete, the execution continues
    and the call to output `Hello World` to `stdout` is made.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`system()`时，`ls`可执行文件被运行，`system()`函数会等待直到可执行文件完成。一旦完成，执行就会继续，对`stdout`输出`Hello
    World`的调用就会被执行。
- en: This is because the `system()` call forks a new process and runs `exec()` from
    that new process. The parent process runs `wait()` and returns when the child
    process is complete.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`system()`调用会fork一个新的进程，并从新的进程中运行`exec()`。父进程运行`wait()`，并在子进程完成时返回。
- en: 'To demonstrate this, we can make our own version of the system call, as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们可以制作我们自己的系统调用版本，如下所示：
- en: '[PRE57]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the `mysystem()` function, we execute `fork()` to create a new child process
    and then execute `execlp()` to execute `ls`. (The call to `execlp()` will be explained
    later.)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mysystem()`函数中，我们执行`fork()`来创建一个新的子进程，然后执行`execlp()`来执行`ls`。（对`execlp()`的调用将在后面解释。）
- en: The parent process calls `wait()`, and waits for the newly-created child process
    to complete. Once it is complete, the call to `mysystem()` finishes, allowing
    the output of `Hello World` to execute.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程调用`wait()`，并等待新创建的子进程完成。一旦完成，对`mysystem()`的调用就结束了，允许`Hello World`的输出执行。
- en: It should be noted that there are a couple of improvements that would make this
    function more complete. The actual `system()` function passes arguments to the
    `exec()` call, which our version does not.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，有一些改进可以使这个函数更完整。实际的`system()`函数会将参数传递给`exec()`调用，而我们的版本没有。
- en: The `wait()` call doesn't check to make sure that the child process that completed
    was the process that was forked either. Instead, the call to `wait()` should loop
    until the child process that was forked actually completes.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()`调用不会检查已完成的子进程是否是被fork的进程。相反，`wait()`的调用应该循环，直到被fork的子进程实际完成。'
- en: 'To pass arguments to the child process, we can do the following using `execl()`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向子进程传递参数，我们可以使用`execl()`进行以下操作：
- en: '[PRE58]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, we execute `/bin/ls` and pass `-al` to the process.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们执行`/bin/ls`并将`-al`传递给进程。
- en: The second argument, which is `ls`, is the same as `argv[0]`, which is always
    the name of the process. And just as with `argv[argc] == nullptr`, our last argument
    is `nullptr`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数`ls`与`argv[0]`相同，它总是进程的名称。就像`argv[argc] == nullptr`一样，我们的最后一个参数也是`nullptr`。
- en: 'As mentioned earlier, there are different versions of `exec()`. See the following
    example:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`exec()`有不同的版本。看下面的例子：
- en: '[PRE59]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `execle()` version does the same thing as `execl()`, but also provides the
    ability to pass in environment variables. In this case, we provide `ls` with the
    process-specific environment variables `ENV1` and `ENV2`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`execle()`版本与`execl()`执行相同的操作，但还提供了传递环境变量的能力。在这种情况下，我们为`ls`提供了进程特定的环境变量`ENV1`和`ENV2`。'
- en: 'The `execl()` function so far have taken an absolute path to `ls`. Instead
    of using the absolute path, the `PATH` environment variable can be used to locate
    the executable, as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`execl()`函数已经采用了`ls`的绝对路径。可以使用`PATH`环境变量来定位可执行文件，而不是使用绝对路径，如下所示：
- en: '[PRE60]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The call to `execlp()` locates `ls` using `PATH`, instead of using an absolute
    path.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`execlp()`调用使用`PATH`来定位`ls`，而不是使用绝对路径。'
- en: 'Alternatively, the `exec()` family also provides the ability to detail the
    `argv[]` arguments using a variable, instead of directly as a function argument
    to `exec()`, as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`exec()`系列还提供了使用变量详细说明`argv[]`参数的能力，而不是直接作为`exec()`的函数参数，如下所示：
- en: '[PRE61]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As shown here, the `execv()` calls allow you to define `argv[]` as a separate
    variable.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，`execv()`调用允许你将`argv[]`定义为一个单独的变量。
- en: One issue with the `execv()` family of calls is that `argv[]` is technically
    an array of pointers to C-style strings, which take the form `const char *` in
    C++. However, calls to `execv()` and friends take `char**`, not `const char**`,
    which means that `const_cast` is needed to convert the arguments.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`execv()`系列调用的一个问题是`argv[]`在技术上是指向C风格字符串的指针数组，在C++中采用`const char *`的形式。然而，`execv()`和相关函数的调用需要`char**`而不是`const
    char**`，这意味着需要使用`const_cast`来转换参数。'
- en: 'The `execv()` family also provides the ability to pass in environment variables,
    just like `execl()`, as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`execv()`系列还提供了像`execl()`一样传递环境变量的能力，如下所示：'
- en: '[PRE62]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding example, we pass in the `argv[]` arguments and the environment
    variables using `execve()`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`execve()`传递了`argv[]`参数和环境变量。
- en: 'Finally, it is also possible to use the path to locate the executable, instead
    of using an absolute value, as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也可以使用路径来定位可执行文件，而不是使用绝对值，如下所示：
- en: '[PRE63]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this example, the `PATH` environment variable is used to locate `ls`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`PATH`环境变量用于定位`ls`。
- en: Output redirection
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出重定向
- en: In this chapter, we have outlined all the system calls that are needed to write
    your own shell. You can now create your own processes, load an arbitrary executable,
    and wait for the process to complete.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经概述了编写自己的shell所需的所有系统调用。现在你可以创建自己的进程，加载任意可执行文件，并等待进程完成。
- en: There are still a couple of things needed to create a complete shell. One of
    these is Unix signals, which will be discussed shortly; the other is capturing
    the output of a child process.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个完整的shell还需要一些东西。其中之一是Unix信号，这将很快讨论；另一个是捕获子进程的输出。
- en: To do this, we will leverage a Unix pipe for IPC and tell the child process
    to redirect its output to this pipe so that the parent process can receive it.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将利用Unix管道进行IPC，并告诉子进程将其输出重定向到此管道，以便父进程可以接收它。
- en: 'See the following example:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下示例：
- en: '[PRE64]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding example, we use the same Unix pipe class that we created in
    the previous example. The difference, however, is that the child process will
    not write to the Unix pipe, but will output to `stdout`. So, we need to redirect
    the output of `stdout` to our Unix pipe.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了与前一个例子中创建的相同的Unix管道类。然而，不同之处在于子进程不会写入Unix管道，而是输出到`stdout`。因此，我们需要将`stdout`的输出重定向到我们的Unix管道。
- en: 'To do this, we replace the `write()` function with `redirect()`, as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将`write()`函数替换为`redirect()`，如下所示：
- en: '[PRE65]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this `redirect()` function, we tell the operating system to redirect all
    writes to `stdout` that are made to our pipe (the write side of the pipe). As
    a result, when the child process writes to `stdout`, the writes are redirected
    to the read side of the pipe for the parent process.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`redirect()`函数中，我们告诉操作系统将所有写入我们的管道的`stdout`的写入重定向（管道的写入端）。因此，当子进程写入`stdout`时，写入被重定向到父进程的读取端的管道。
- en: As a result, the pipe handles for the child process are no longer needed (and
    are closed before executing the child process).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不再需要子进程的管道句柄（并且在执行子进程之前关闭）。
- en: 'The rest of the example is similar to our call to our custom `mysystem()` call,
    as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的其余部分与我们对自定义`mysystem()`调用的调用类似，如下所示：
- en: '[PRE66]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: A child process is created. Before we execute the `ls` command, we redirect
    the output of the child process. The parent process, just like `mysystem()`, waits
    for the child process to complete, and then reads the contents of the pipe.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个子进程。在执行`ls`命令之前，我们重定向了子进程的输出。父进程，就像`mysystem()`一样，等待子进程完成，然后读取管道的内容。
- en: To create your own complete shell, a lot more functionality would be needed,
    including providing asynchronous access to a child process's output for both `stdout`
    and `stderr`, the ability to execute processes in the foreground and background,
    parsing arguments, and so on. However, the bulk of the concepts that are needed
    have been provided here.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的完整shell，需要更多的功能，包括为`stdout`和`stderr`提供对子进程输出的异步访问的能力，执行前台和后台的进程，解析参数等。然而，这里提供了所需概念的大部分。
- en: In the next section, we will discuss how Unix signals work.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Unix信号的工作原理。
- en: Unix signals
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix信号
- en: Unix signals provide the ability to interrupt a given process, and allow a child
    to receive this interruption and handle it any way they wish.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Unix信号提供了中断给定进程的能力，并允许子进程接收此中断并以任何希望的方式处理它。
- en: Specifically, Unix signals provide the user with the ability to handle specific
    types of control flow and errors that might occur, such as a Terminal attempting
    to close your program, or a segmentation fault that might be recoverable.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，Unix信号提供了处理特定类型的控制流和可能发生的错误的能力，比如终端试图关闭你的程序，或者可能是可恢复的分段错误。
- en: 'See the following example:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下示例：
- en: '[PRE67]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding example, we create a process that executes forever, outputting
    `Hello World` every second. To stop this application, we must use the `CTRL+C`
    command, which tells the shell to terminate the process. This is done using a
    Unix signal.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个永远执行的进程，每秒输出`Hello World`。要停止这个应用程序，我们必须使用`CTRL+C`命令，这告诉shell终止进程。这是使用Unix信号完成的。
- en: 'We can trap this signal as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样捕获这个信号：
- en: '[PRE68]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this example, we create a loop that outputs `Hello World` to `stdout` every
    second, and does so 10 times. We then install a signal handler using the `signal()`
    function. This signal handler tells the operating system that we would like to
    call the `handler()` function any time `SIGINT` is called.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个循环，每秒向`stdout`输出`Hello World`，并且这样做了10次。然后我们使用`signal()`函数安装了一个信号处理程序。这个信号处理程序告诉操作系统，我们希望在调用`SIGINT`时调用`handler()`函数。
- en: As a result, now, if we use `CTRL+C`, the signal handler is called instead,
    and we see `handler called` output to `stdout`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，如果我们使用`CTRL+C`，信号处理程序将被调用，我们会在`stdout`上看到`handler called`的输出。
- en: It should be noted that, since we successfully handled `SIGINT`, using `CTRL+C`
    no longer kills the process, which is why we used a `for()` loop instead of a
    `while(1)` loop. You could also use `CTRL+/` to send `SIGSTOP` instead of `SIGINT`,
    which would also kill the application in the preceding example.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，由于我们成功处理了`SIGINT`，使用`CTRL+C`不再会终止进程，这就是为什么我们使用`for()`循环而不是`while(1)`循环。您也可以使用`CTRL+/`来发送`SIGSTOP`，而不是`SIGINT`，这也会终止前面例子中的应用程序。
- en: 'Another way to overcome this would be to use a global variable capable of stopping
    the loop, as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种克服这个问题的方法是使用一个能够停止循环的全局变量，如下所示：
- en: '[PRE69]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This example is identical to our previous example, except that we use a `while()`
    loop, which loops until the `loop` variable is `false`. In our signal handler,
    we set the `loop` variable to `true`, which stops the loop. This works because
    the signal handler is not executed in the same thread as the `while()` loop.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与我们之前的例子相同，只是我们使用了一个`while()`循环，该循环一直循环，直到`loop`变量为`false`为止。在我们的信号处理程序中，我们将`loop`变量设置为`true`，这会停止循环。这是因为信号处理程序不会在与`while()`循环相同的线程中执行。
- en: This is important to understand, as deadlock, corruption, and race conditions
    can occur when using signal handlers if these types of issues are not addressed.
    For more information on threading, see [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml),* Learning
    to Program POSIX and C++ Threads*.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很重要，因为如果不解决这些问题，使用信号处理程序时可能会出现死锁、损坏和竞争条件。有关线程的更多信息，请参见[第12章](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml)，*学习编程POSIX和C++线程*。
- en: 'Finally, before we conclude, the `kill()` function can be used to send a signal
    to a child process, as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们结束之前，`kill()`函数可以用来向子进程发送信号，如下所示：
- en: '[PRE70]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this example, we created our `mysystem()` function call again, but this time,
    in the parent, we killed the child process after two seconds instead of waiting
    for it to complete. We then compiled our `while(1)` example and renamed it `b.out`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们再次创建了我们的`mysystem()`函数调用，但这次在父进程中，我们在两秒后杀死了子进程，而不是等待它完成。然后我们编译了我们的`while(1)`例子，并将其重命名为`b.out`。
- en: We then executed the child process, which will execute forever, or until the
    parent sends the `kill` command.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行了子进程，它将永远执行，或者直到父进程发送`kill`命令。
- en: Summary
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we provided a comprehensive overview of the Linux (System V)
    ABI. We discussed the register and stack layout, the System V calling convention,
    and the ELF specification.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们全面介绍了Linux（System V）ABI。我们讨论了寄存器和堆栈布局，System V调用约定以及ELF规范。
- en: We then reviewed the Unix filesystem, including the standard filesystem layout
    and permissions.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回顾了Unix文件系统，包括标准文件系统布局和权限。
- en: Next, we reviewed how to work with Unix processes, including common functions
    such as `fork()`, `exec()`, and `wait()`, as well as IPC.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍如何处理Unix进程，包括常见函数，如`fork()`、`exec()`和`wait()`，以及IPC。
- en: Finally, this chapter concluded with a brief overview of Unix-based signals
    and how to work with them.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章简要概述了基于Unix的信号以及如何处理它们。
- en: In the next chapter, we will provide a comprehensive look at console input and
    output using C++.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将全面介绍使用C++进行控制台输入和输出。
- en: Questions
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the first return register for the System V architecture (64-bit) on
    Intel?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System V架构（64位）在Intel上的第一个返回寄存器是什么？
- en: What is the first argument register for the System V architecture (64-bit) on
    Intel?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System V架构（64位）在Intel上的第一个参数寄存器是什么？
- en: When pushing to the stack on Intel, do you add or subtract the stack pointer?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Intel上将数据推送到堆栈时，您是添加还是减去堆栈指针？
- en: What is the difference between segments and sections in ELF?
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ELF中段和节之间有什么区别？
- en: What is stored in the `.eh_frame` section in an ELF file?
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ELF文件的`.eh_frame`部分中存储了什么？
- en: What is the difference between `fork()` and `exec()`?
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fork()`和`exec()`之间有什么区别？'
- en: When creating a Unix pipe, which file handle is the write file handle? The first,
    or the second?
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建Unix管道时，写文件句柄是第一个还是第二个？
- en: What is the return value of the `wait()` system call?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wait()`系统调用的返回值是什么？'
- en: Further reading
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c-multithreading-cookbook](https://www.packtpub.com/application-development/c-multithreading-cookbook)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c-multithreading-cookbook](https://www.packtpub.com/application-development/c-multithreading-cookbook)'
