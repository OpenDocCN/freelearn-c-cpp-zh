["```cpp\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <wiringPi.h>\n\nusing namespace std::literals::chrono_literals;\nconst int kLedPin = 0;\n\nint main (void)\n{\n  if (wiringPiSetup () <0) {\n    throw std::runtime_error(\"Failed to initialize wiringPi\");\n  }\n\n  pinMode (kLedPin, OUTPUT);\n  while (true) {\n    digitalWrite (kLedPin, HIGH);\n    std::cout << \"LED on\" << std::endl;\n    std::this_thread::sleep_for(500ms) ;\n    digitalWrite (kLedPin, LOW);\n    std::cout << \"LED off\" << std::endl;\n    std::this_thread::sleep_for(500ms) ;\n  }\n  return 0 ;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(gpio)\nadd_executable(gpio gpio.cpp)\ntarget_link_libraries(gpio wiringPi)\n```", "```cpp\n$ cd gpio && cmake . && make && sudo ./gpio\n```", "```cpp\ntarget_link_libraries(gpio wiringPi)\n```", "```cpp\nif (wiringPiSetup () < 0) {\n    throw std::runtime_error(\"Failed to initialize wiringPi\");\n}\n```", "```cpp\n    digitalWrite (kLedPin, HIGH);\n```", "```cpp\n digitalWrite (kLedPin, LOW);\n    std::cout << \"LED off\" << std::endl;\n std::this_thread::sleep_for(500ms) ;\n```", "```cpp\nconst int kLedPin = 0;\n```", "```cpp\n#include <chrono>\n#include <thread>\n\n#include <wiringPi.h>\n\nusing namespace std::literals::chrono_literals;\n\nconst int kLedPin = 0;\n\nvoid Blink(std::chrono::microseconds duration, int percent_on) {\n    digitalWrite (kLedPin, HIGH);\n    std::this_thread::sleep_for(\n            duration * percent_on / 100) ;\n    digitalWrite (kLedPin, LOW);\n    std::this_thread::sleep_for(\n            duration * (100 - percent_on) / 100) ;\n}\n```", "```cpp\nint main (void)\n{\n  if (wiringPiSetup () <0) {\n    throw std::runtime_error(\"Failed to initialize wiringPi\");\n  }\n\n  pinMode (kLedPin, OUTPUT);\n\n  int count = 0;\n  int delta = 1;\n  while (true) {\n    Blink(10ms, count);\n    count = count + delta;\n    if (count == 101) {\n      delta = -1;\n    } else if (count == 0) {\n      delta = 1;\n    }\n  }\n  return 0 ;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(pwm)\nadd_executable(pwm pwm.cpp)\ntarget_link_libraries(pwm wiringPi)\n```", "```cpp\n$ cd pwm && cmake . && make && sudo ./pwm\n```", "```cpp\nvoid Blink(std::chrono::microseconds duration, int percent_on)\n```", "```cpp\n    digitalWrite (kLedPin, HIGH);\n    std::this_thread::sleep_for(\n            duration * percent_on / 100);\n```", "```cpp\n    digitalWrite (kLedPin, LOW);\n    std::this_thread::sleep_for(\n            duration * (100 - percent_on) / 100);\n```", "```cpp\n  int count = 0;\n```", "```cpp\n  int delta = 1;\n```", "```cpp\n    if (count == 101) {\n      delta = -1;\n    } else if (count == 0) {\n      delta = 1;\n    }\n```", "```cpp\n    Blink(10ms, count);\n```", "```cpp\n#include <iostream>\n#include <system_error>\n\n#include <time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <linux/rtc.h>\n```", "```cpp\nclass Rtc {\n  int fd;\n  public:\n    Rtc() {\n      fd = open(\"/dev/rtc\", O_RDWR);\n      if (fd < 0) {\n        throw std::system_error(errno,\n            std::system_category(),\n            \"Failed to open RTC device\");\n      }\n    }\n\n    ~Rtc() {\n      close(fd);\n    }\n\n    time_t GetTime(void) {\n      union {\n        struct rtc_time rtc;\n        struct tm tm;\n      } tm;\n      int ret = ioctl(fd, RTC_RD_TIME, &tm.rtc);\n      if (ret < 0) {\n        throw std::system_error(errno,\n            std::system_category(),\n            \"ioctl failed\");\n      }\n      return mktime(&tm.tm);\n    }\n};\n```", "```cpp\nint main (void)\n{\n  Rtc rtc;\n  time_t t = rtc.GetTime();\n  std::cout << \"Current time is \" << ctime(&t)\n            << std::endl;\n\n  return 0 ;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(rtc)\nadd_executable(rtc rtc.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\n  fd = open(\"/dev/rtc\", O_RDWR);\n```", "```cpp\n    ~Rtc() {\n      close(fd);\n    }\n```", "```cpp\n      if (fd < 0) {\n        throw std::system_error(errno,\n            std::system_category(),\n            \"Failed to open RTC device\");\n      }\n```", "```cpp\n      union {\n        struct rtc_time rtc;\n        struct tm tm;\n      } tm;\n```", "```cpp\n  int ret = ioctl(fd, RTC_RD_TIME, &tm.rtc);\n```", "```cpp\n  return mktime(&tm.tm);\n```", "```cpp\n  Rtc rtc;\n  time_t t = rtc.GetTime();\n```", "```cpp\n  std::cout << \"Current time is \" << ctime(&t)\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <thread>\n\n#include <gpiod.h>\n#include <gpiod.hpp>\n\nusing namespace std::literals::chrono_literals;\n\nconst int kLedPin = 17;\n\nint main (void)\n{\n\n  gpiod::chip chip(\"gpiochip0\");\n  auto line = chip.get_line(kLedPin);\n  line.request({\"test\",\n                 gpiod::line_request::DIRECTION_OUTPUT, \n                 0}, 0);\n\n  while (true) {\n    line.set_value(1);\n    std::cout << \"ON\" << std::endl;\n    std::this_thread::sleep_for(500ms);\n    line.set_value(0);\n    std::cout << \"OFF\" << std::endl;\n    std::this_thread::sleep_for(500ms);\n  }\n\n  return 0 ;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(gpiod)\nadd_executable(gpiod gpiod.cpp)\ntarget_link_libraries(gpiod gpiodcxx)\n```", "```cpp\n$ sudo apt-get install gpiod-dev\n```", "```cpp\n$ cd gpiod && cmake . && make && sudo ./gpiod\n```", "```cpp\n  gpiod::chip chip(\"gpiochip0\");\n```", "```cpp\n  auto line = chip.get_line(kLedPin);\n```", "```cpp\nconst int kLedPin = 17;\n```", "```cpp\n  line.request({\"test\",\n                 gpiod::line_request::DIRECTION_OUTPUT, \n                 0}, 0);\n```", "```cpp\n    line.set_value(1);\n    std::cout << \"ON\" << std::endl;\n    std::this_thread::sleep_for(500ms);\n    line.set_value(0);\n    std::cout << \"OFF\" << std::endl;\n    std::this_thread::sleep_for(500ms);\n```", "```cpp\n#include <thread>\n#include <system_error>\n\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <linux/i2c-dev.h>\n\nusing namespace std::literals::chrono_literals;\n\nenum class Function : uint8_t {\n  clear = 0x01,\n  home = 0x02,\n  entry_mode_set = 0x04,\n  display_control = 0x08,\n  cursor_shift = 0x10,\n  fn_set = 0x20,\n  set_ddram_addr = 0x80\n};\n\nconstexpr int En = 0b00000100;\nconstexpr int Rs = 0b00000001;\n\nconstexpr int kDisplayOn = 0x04;\nconstexpr int kEntryLeft = 0x02;\nconstexpr int kTwoLine = 0x08;\nconstexpr int kBacklightOn = 0x08;\n```", "```cpp\nclass Lcd {\n  int fd;\n\n  public:\n    Lcd(const char* device, int address) {\n      fd = open(device, O_RDWR);\n      if (fd < 0) {\n        throw std::system_error(errno,\n            std::system_category(),\n            \"Failed to open RTC device\");\n      }\n      if (ioctl(fd, I2C_SLAVE, address) < 0) {\n        close(fd);\n        throw std::system_error(errno,\n            std::system_category(),\n            \"Failed to aquire bus address\");\n      }\n      Init();\n    }\n\n    ~Lcd() {\n      close(fd);\n    }\n\n    void Clear() {\n      Call(Function::clear);\n      std::this_thread::sleep_for(2000us);\n    }\n\n    void Display(const std::string& text,\n                 bool second=false) {\n      Call(Function::set_ddram_addr, second ? 0x40 : 0);\n      for(char c : text) {\n        Write(c, Rs);\n      }\n    }\n```", "```cpp\nprivate:\n\n    void SendToI2C(uint8_t byte) {\n if (write(fd, &byte, 1) != 1) {\n throw std::system_error(errno,\n std::system_category(),\n \"Write to i2c device failed\");\n }\n    }\n\n    void SendToLcd(uint8_t value) {\n      value |= kBacklightOn;\n      SendToI2C(value);\n      SendToI2C(value | En);\n      std::this_thread::sleep_for(1us);\n      SendToI2C(value & ~En);\n      std::this_thread::sleep_for(50us);\n    }\n\n    void Write(uint8_t value, uint8_t mode=0) {\n      SendToLcd((value & 0xF0) | mode);\n      SendToLcd((value << 4) | mode);\n    }\n```", "```cpp\n    void Init() {\n      // Switch to 4-bit mode\n      for (int i = 0; i < 3; i++) {\n        SendToLcd(0x30);\n        std::this_thread::sleep_for(4500us);\n      }\n      SendToLcd(0x20);\n\n      // Set display to two-line, 4 bit, 5x8 character mode\n      Call(Function::fn_set, kTwoLine);\n      Call(Function::display_control, kDisplayOn);\n      Clear();\n      Call(Function::entry_mode_set, kEntryLeft);\n      Home();\n    }\n\n    void Call(Function function, uint8_t value=0) {\n      Write((uint8_t)function | value);\n    }\n\n    void Home() {\n      Call(Function::home);\n      std::this_thread::sleep_for(2000us);\n    }\n};\n```", "```cpp\nint main (int argc, char* argv[])\n{\n  Lcd lcd(\"/dev/i2c-1\", 0x27);\n  if (argc > 1) {\n    lcd.Display(argv[1]);\n    if (argc > 2) {\n      lcd.Display(argv[2], true);\n    }\n  }\n  return 0 ;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(i2c)\nadd_executable(i2c i2c.cpp)\n```", "```cpp\nsudo raspi-config\n```", "```cpp\n$ cd i2c && cmake . && make && ./i2c Hello, world!\n```", "```cpp\nfd = open(device, O_RDWR);\n```", "```cpp\nif (ioctl(fd, I2C_SLAVE, address) < 0) {\n```", "```cpp\n      if (write(fd, &byte, 1) != 1) {\n        throw std::system_error(errno,\n            std::system_category(),\n            \"Write to i2c device failed\");\n      }\n```", "```cpp\n      SendToI2C(value);\n      SendToI2C(value | En);\n      std::this_thread::sleep_for(1us);\n      SendToI2C(value & ~En);\n      std::this_thread::sleep_for(50us);\n```", "```cpp\n      SendToLcd((value & 0xF0) | mode);\n      SendToLcd((value << 4) | mode);\n```", "```cpp\n    void Call(Function function, uint8_t value=0) {\n      Write((uint8_t)function | value);\n    }\n```", "```cpp\n  Lcd lcd(\"/dev/i2c-1\", 0x27);\n```", "```cpp\n    lcd.Display(argv[1]);\n    if (argc > 2) {\n      lcd.Display(argv[2], true);\n    }\n```"]