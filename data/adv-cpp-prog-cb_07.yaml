- en: Debugging and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和测试
- en: In this chapter, you will learn how to properly test and debug your C++ applications.
    This is important because without good testing and debugging, it is highly likely
    that your C++ applications will contain hard-to-detect bugs that will reduce their
    overall reliability, stability, and security.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何正确测试和调试您的C++应用程序。这很重要，因为没有良好的测试和调试，您的C++应用程序很可能包含难以检测的错误，这将降低它们的整体可靠性、稳定性和安全性。
- en: This chapter will start with a comprehensive overview of unit testing, which
    is the act of testing code at the unit level, and will also look at how to leverage
    existing libraries to speed up the process of writing tests. Next, it will demonstrate
    how to use the ASAN and UBSAN dynamic analysis tools to check for memory corruption
    and undefined behavior. Lastly, the chapter will conclude with a quick look at
    how to leverage the `NDEBUG` macro in your own code for adding debug logic when
    attempting to resolve issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从全面概述单元测试开始，这是在单元级别测试代码的行为，并且还将介绍如何利用现有库加快编写测试的过程。接下来，它将演示如何使用ASAN和UBSAN动态分析工具来检查内存损坏和未定义行为。最后，本章将简要介绍如何在自己的代码中利用`NDEBUG`宏来添加调试逻辑以解决问题。
- en: 'This chapter contains the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下教程：
- en: Getting to grips with unit testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握单元测试
- en: Working with ASAN, the address sanitizer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ASAN，地址检查器
- en: Working with UBSAN, the undefined behavior sanitizer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UBSAN，未定义行为检查器
- en: Using `#ifndef NDEBUG` to conditionally execute additional checks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`#ifndef NDEBUG`条件性地执行额外的检查
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, you must have installed the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有管理访问权限的计算机，该计算机运行Ubuntu 18.04，并具有功能正常的互联网连接。在运行这些示例之前，您必须安装以下内容：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是安装在Ubuntu 18.04以外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Code files for the chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter07](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter07).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter07](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter07)找到。
- en: Getting to grips with unit testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握单元测试
- en: In this recipe, we will learn how to unit test our C++ code. There are several
    different ways to ensure that your C++ code executes with reliability, stability,
    security, and to specification.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何对我们的C++代码进行单元测试。有几种不同的方法可以确保您的C++代码以可靠性、稳定性、安全性和规范性执行。
- en: Unit testing, which is the act of testing your code at the fundamental unit
    level, is a key component of any testing strategy. This recipe is important not
    only because it will teach you how to unit test your code, but because it will
    also explain why unit testing is so critical, as well as how to speed up the process
    of unit testing your C++ using existing libraries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是在基本单元级别测试代码的行为，是任何测试策略的关键组成部分。这个教程很重要，不仅因为它将教会您如何对代码进行单元测试，还因为它将解释为什么单元测试如此关键，以及如何利用现有库加快对C++代码进行单元测试的过程。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本教程中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Go through the following steps to work through the recipe:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程所教授的课程的关系。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Simply writing your C++ application and hoping it works as expected without
    any testing is guaranteed to result in reliability-, stability-, and security-related
    bugs. This recipe is important because testing your applications prior to release
    ensures that your applications execute as expected, ultimately saving you time
    and money in the future.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅编写您的C++应用程序，并希望它按预期工作而不进行任何测试，肯定会导致可靠性、稳定性和安全性相关的错误。这个教程很重要，因为在发布之前测试您的应用程序可以确保您的应用程序按预期执行，最终为您节省时间和金钱。
- en: There are several different ways to test your code, including system-level,
    integration, long-term stability, and static and dynamic analysis, among others.
    In this recipe, we will focus on **unit testing**. Unit testing breaks an application
    up into functional **units **and tests each unit to ensure that it executes as
    expected. Typically, in practice, each function and object (that is, class) is
    a unit that should be tested independently.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方法可以测试您的代码，包括系统级、集成、长期稳定性以及静态和动态分析等。在这个教程中，我们将专注于**单元测试**。单元测试将应用程序分解为功能**单元**，并测试每个单元以确保其按预期执行。通常，在实践中，每个函数和对象（即类）都是一个应该独立测试的单元。
- en: There are several different theories as to how unit testing should be performed,
    with entire books written on the subject. Some believe that every line of code
    within a function or object should be tested, leveraging coverage tools to ensure
    compliance, while others believe that unit testing should be requirement-driven,
    using a black-box approach. A common development process called **test-driven
    development** states that all tests, including unit tests, should be written before
    any source code is written, whereas **behavioral-driven development** takes test-driven
    development a step further with a specific, story-driven approach to unit testing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的理论，关于如何执行单元测试，整本书都是关于这个主题的。有些人认为应该测试函数或对象中的每一行代码，利用覆盖率工具来确保合规性，而另一些人认为单元测试应该是需求驱动的，采用黑盒方法。一种常见的开发过程称为**测试驱动开发**，它规定所有测试，包括单元测试，都应该在编写任何源代码之前编写，而**行为驱动开发**则进一步采用特定的、以故事为驱动的方法来进行单元测试。
- en: Every testing model has its pros and cons, and which method you choose will
    be based on the type of application you are writing, the type of software development
    process you adhere to, and any policies you may or may not be required to follow.
    Regardless of this choice, unit testing will likely be a part of your testing
    scheme, and this recipe will provide the foundation for how to unit test your
    C++ applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每种测试模型都有其优缺点，您选择的方法将基于您正在编写的应用程序类型、您遵循的软件开发过程类型以及您可能需要或不需要遵循的任何政策。不管您做出什么选择，单元测试可能会成为您测试方案的一部分，这个示例将为您提供如何对C++应用程序进行单元测试的基础。
- en: Although unit testing can be done with standard C++ (for example, this is how
    `libc++` is unit tested), unit-test libraries help to simplify this process. In
    this recipe, we will leverage the `Catch2` unit-test library, which can be found
    at
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用标准的C++进行单元测试（例如，这就是`libc++`进行单元测试的方法），但单元测试库有助于简化这个过程。在这个示例中，我们将利用`Catch2`单元测试库，可以在以下网址找到
- en: '[https://github.com/catchorg/Catch2.git](https://github.com/catchorg/Catch2.git).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/catchorg/Catch2.git](https://github.com/catchorg/Catch2.git)。'
- en: 'Although we will be reviewing Catch2, the principles that are being discussed
    apply to most of the unit-test libraries that are available, or even standard
    C++, if you choose not to use a helper library. To leverage Catch2, simply execute
    the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将回顾Catch2，但正在讨论的原则适用于大多数可用的单元测试库，甚至适用于标准的C++，如果您选择不使用辅助库。要利用Catch2，只需执行以下操作：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can also use CMake's `ExternalProject_Add`, as we did in our examples on
    GitHub to leverage a local copy of the library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用CMake的`ExternalProject_Add`，就像我们在GitHub上的示例中所做的那样，来利用库的本地副本。
- en: 'To find out how to use Catch2, let''s look at the following simple example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用Catch2，让我们看下面这个简单的例子：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When this is run, we see the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，我们看到以下输出：
- en: '![](img/82b7302a-7165-4cf8-92f1-83a6491e786f.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82b7302a-7165-4cf8-92f1-83a6491e786f.png)'
- en: In the preceding example, we start by defining `CATCH_CONFIG_MAIN`. This tells
    the Catch2 library that we want it to create the `main()` function for us. This
    must be defined before we include the Catch2 `include` statement, which we did
    in the preceding code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先定义了`CATCH_CONFIG_MAIN`。这告诉Catch2库我们希望它为我们创建`main()`函数。这必须在我们包含Catch2`include`语句之前定义，这是我们在前面的代码中所做的。
- en: 'The next step is to define a test case. Each unit is broken up into test cases
    that test the unit in question. The granularity of each test case is up to you:
    some choose to have a single test case for each unit being tested, while others,
    for example, choose to have a test case for each function being tested. The `TEST_CASE()`
    takes a string that allows you to provide a description of the test case, which
    is helpful when a test fails as Catch2 will output this string to help you identify
    where in your test code the failure occurred. The last step in our simple example
    is to use the `CHECK()` macro. This macro performs a specific test. Each `TEST_CASE()`
    will likely have several `CHECK()` macros designed to provide the unit with a
    specific input and then validate the resulting output.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义一个测试用例。每个单元都被分解成测试单元，测试所讨论的单元。每个测试用例的粒度由您决定：有些人选择为每个被测试的单元设置一个单独的测试用例，而其他人，例如，选择为每个被测试的函数设置一个测试用例。`TEST_CASE()`接受一个字符串，允许您提供测试用例的描述，当测试失败时，这对于帮助您确定测试代码中失败发生的位置是有帮助的，因为Catch2将输出这个字符串。我们简单示例中的最后一步是使用`CHECK()`宏。这个宏执行一个特定的测试。每个`TEST_CASE()`可能会有几个`CHECK()`宏，旨在为单元提供特定的输入，然后验证生成的输出。
- en: Once compiled and executed, the unit-test library will provide some output text
    describing how to execute tests. In this case, the library states that all of
    the tests passed, which is the desired outcome.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译和执行，单元测试库将提供一些输出文本，描述如何执行测试。在这种情况下，库说明所有测试都通过了，这是期望的结果。
- en: 'To better understand how to leverage unit testing in your own code, let''s
    look at the following, more complicated example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何在自己的代码中利用单元测试，让我们看下面这个更复杂的例子：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Like the previous example, we include Catch2 with the `CATCH_CONFIG_MAIN` macro
    and then define a single test case with a description. In this example, we are
    testing the ability to sort a vector, so this is the description we provide. The
    first thing we do in our test is to create a vector of integers with a predefined
    list of integers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面的例子一样，我们使用`CATCH_CONFIG_MAIN`宏包含Catch2，然后定义一个带有描述的单个测试用例。在这个例子中，我们正在测试对向量进行排序的能力，所以这是我们提供的描述。我们在测试中要做的第一件事是创建一个包含预定义整数列表的整数向量。
- en: The next thing we do is use the `REQUIRE()` macro to test, making sure that
    the vector has `6` elements in the vector. The `REQUIRE()` macro is similar to
    the `CHECK()` as both check to make sure that the statement inside the macro is
    true. The difference is that the `CHECK()` macro will report an error and then
    continue execution while the `REQUIRE()` macro will stop the execution, halting
    the unit test. This is useful to ensure that the unit test is properly constructed
    based on any assumptions that the test might be making. The use of `REQUIRE()`
    is important as unit tests mature over time, and other programmers add to and
    modify the unit tests, ensuring that bugs are not introduced into the unit tests
    over time, as there is nothing worse than having to test and debug your unit tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们使用`REQUIRE()`宏进行测试，确保向量中有`6`个元素。`REQUIRE()`宏类似于`CHECK()`，因为两者都检查宏内部的语句是否为真。不同之处在于，`CHECK()`宏将报告错误，然后继续执行，而`REQUIRE()`宏将停止执行，中止单元测试。这对于确保单元测试基于测试可能做出的任何假设正确构建是有用的。随着时间的推移，单元测试的成熟度越来越重要，其他程序员会添加和修改单元测试，以确保单元测试不会引入错误，因为没有比测试和调试单元测试更糟糕的事情了。
- en: The `SECTION()` macro is used to further break up our tests with better descriptions
    and provide the ability to add common setup code for each test. In the preceding
    example, we are testing the `sort()` function for a vector. The `sort()` function
    can sort in different directions, which this unit test must validate. Without
    the `SECTION()` macro, if a test failed, it would be difficult to know whether
    the failure was from sorting in ascending or descending order. Furthermore, the
    `SECTION()` macro ensures that each test doesn't affect the results of other tests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`SECTION()`宏用于进一步分解我们的测试，并提供添加每个测试的常见设置代码的能力。在前面的示例中，我们正在测试向量的`sort()`函数。`sort()`函数可以按不同的方向排序，这个单元测试必须验证。如果没有`SECTION()`宏，如果测试失败，将很难知道失败是由于按升序还是按降序排序。此外，`SECTION()`宏确保每个测试不会影响其他测试的结果。'
- en: 'Finally, we use the `CHECK()` macro to ensure that the `sort()` function worked
    as expected. Unit tests should check for exceptions as well. In the following
    example, we will ensure that exceptions are thrown properly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`CHECK()`宏来确保`sort()`函数按预期工作。单元测试也应该检查异常。在下面的示例中，我们将确保异常被正确抛出：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As with the previous example, we define the `CATCH_CONFIG_MAIN` macro, add the
    includes that we require, and define a single `TEST_CASE()`. We also define a
    `foo()` function that is thrown if the input to the `foo()` function is invalid.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，我们定义了`CATCH_CONFIG_MAIN`宏，添加了我们需要的包含文件，并定义了一个`TEST_CASE()`。我们还定义了一个`foo()`函数，如果`foo()`函数的输入无效，则会抛出异常。
- en: In our test case, we first test the `foo()` function with a valid input. Since
    the `foo()` function doesn't have an output (that is, the function returns `void`),
    we check to ensure that the function has executed properly by ensuring that no
    exception has been thrown using the `CHECK_NOTHROW()` macro. It should be noted
    that, like the `CHECK()` macro, the `CHECK_NOTHROW()` macro has the equivalent
    `REQUIRE_NOTHROW()`, which will halt the execution if the check fails.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试用例中，我们首先使用有效的输入测试`foo()`函数。由于`foo()`函数没有输出（即函数返回`void`），我们通过使用`CHECK_NOTHROW()`宏来确保函数已经正确执行，确保没有抛出异常。值得注意的是，与`CHECK()`宏一样，`CHECK_NOTHROW()`宏有等效的`REQUIRE_NOTHROW()`，如果检查失败，将停止执行。
- en: Finally, we ensure that the `foo()` function throws an exception when its input
    is invalid. There are several different ways to do this. The `CHECK_THROWS()`
    macro simply ensures that an exception has been thrown. The `CHECK_THROWS_AS()`
    macro ensures that not only has an exception been thrown, but that the exception
    is of the `std::runtime_error` type. Both must be true for the test to pass. Finally,
    the `CHECK_THROWS_WITH()` macro ensures that an exception has thrown and that
    the `what()` string returned what we expect from the exception matches. As with
    the other version of `CHECK()` macros, there are also `REQUIRE()` versions of
    each of these macros.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们确保`foo()`函数在其输入无效时抛出异常。有几种不同的方法可以做到这一点。`CHECK_THROWS()`宏只是确保抛出了异常。`CHECK_THROWS_AS()`宏确保不仅抛出了异常，而且异常是`std::runtime_error`类型。这两者都必须为测试通过。最后，`CHECK_THROWS_WITH()`宏确保抛出异常，并且异常的`what()`字符串返回与我们期望的异常匹配。与其他版本的`CHECK()`宏一样，每个宏也有`REQUIRE()`版本。
- en: Although the Catch2 library provides macros that let you dive into the specific
    details of each exception type, it should be noted that the generic `CHECK_THROWS()`
    macro should be used unless the exception type and string are specifically defined
    in your API requirements—for example, the `at()` function is defined by the specification
    to always return an `std::out_of_range` exception when the index is invalid. In
    this case, the `CHECK_THROWS_AS()` macro should be used to ensure that the `at()`
    function matches the specification. The string that this exception returns is
    not specified as part of the specification, and therefore, the `CHECK_THROWS_WITH()`
    should be avoided. This is important, as a common mistake when writing unit tests
    is to write unit tests that are over-specified. Over-specified unit tests must
    often be updated when the code under test is updated, which is not only costly,
    but prone to error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Catch2库提供了宏，让您深入了解每种异常类型的具体细节，但应该注意，除非异常类型和字符串在您的API要求中明确定义，否则应该使用通用的`CHECK_THROWS()`宏。例如，规范中定义了`at()`函数在索引无效时始终返回`std::out_of_range`异常。在这种情况下，应该使用`CHECK_THROWS_AS()`宏来确保`at()`函数符合规范。规范中未指定此异常返回的字符串，因此应避免使用`CHECK_THROWS_WITH()`。这很重要，因为编写单元测试时常见的错误是编写过度规范的单元测试。过度规范的单元测试通常在被测试的代码更新时必须进行更新，这不仅成本高，而且容易出错。
- en: Unit tests should be detailed enough to ensure that the unit executes as expected
    but generic enough to ensure that modifications to the source code do not require
    updates to the unit tests themselves, unless the API's requirements change, resulting
    in a set of unit tests that age well while still providing the necessary tests
    for ensuring reliability, stability, security, and even compliance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该足够详细，以确保单元按预期执行，但又足够通用，以确保对源代码的修改不需要更新单元测试本身，除非API的要求发生变化，从而产生一组能够长期使用的单元测试，同时仍然提供确保可靠性、稳定性、安全性甚至合规性所必需的测试。
- en: Once you have a set of unit tests to validate that each unit executes as expected,
    the next step is to ensure that the unit tests are executed whenever the code
    is modified. This can be done manually or it can be done automatically by a **continuous
    integration** (**CI**) server, such as TravisCI; however, when you decide to do
    this, ensure that the unit test returns the proper error code. In the previous
    examples, the unit test itself exited with `EXIT_SUCCESS` when the unit tests
    passed and printed a simple string stating that all of the tests passed. For most
    CIs, this is enough, but in some cases it might be useful to have Catch2 output
    the results in a format that can be easily parsed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一组单元测试来验证每个单元是否按预期执行，下一步就是确保在修改代码时执行这些单元测试。这可以手动完成，也可以由**持续集成**（**CI**）服务器自动完成，例如TravisCI；然而，当您决定这样做时，请确保单元测试返回正确的错误代码。在前面的例子中，当单元测试通过并打印简单的字符串表示所有测试都通过时，单元测试本身退出时使用了`EXIT_SUCCESS`。对于大多数CI来说，这已经足够了，但在某些情况下，让Catch2以易于解析的格式输出结果可能是有用的。
- en: 'For example, consider the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s run this with the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下方式运行：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we do this, then we get the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们会得到以下结果：
- en: '![](img/181d1cbf-5814-44ae-8f95-b7577da6c8e5.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/181d1cbf-5814-44ae-8f95-b7577da6c8e5.png)'
- en: In the preceding example, we created a simple test case (the same as our first
    example in this recipe), and instructed Catch2 to output the results of the test
    to XML using the `-r xml` option. Catch2 has several different output formats,
    including XML and JSON.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个简单的测试用例（与本配方中的第一个例子相同），并指示Catch2使用`-r xml`选项将测试结果输出为XML。Catch2有几种不同的输出格式，包括XML和JSON。
- en: 'In addition to output formats, Catch2 can also be used to benchmark our code.
    For example, consider the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了输出格式之外，Catch2还可以用来对我们的代码进行基准测试。例如，考虑以下代码片段：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, we create a simple test case that sorts a vector
    with predefined vector numbers. We then sort this list inside a `BENCHMARK()`
    macro, which results in the following output when executed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了一个简单的测试用例，对预定义的向量数字进行排序。然后我们在`BENCHMARK()`宏中对这个列表进行排序，当执行时会得到以下输出：
- en: '![](img/6ba0ee12-7624-4e52-897e-5182f5487f0e.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ba0ee12-7624-4e52-897e-5182f5487f0e.png)'
- en: As shown in the preceding screenshot, Catch2 executed the function several times,
    taking on average `197` nanoseconds to sort the vector. The `BENCHMARK()` macro
    is useful to ensure that the code not only executes as expected with the proper
    outputs given specific inputs, but also that the code executes given a specific
    amount of time. Paired with a more detailed output format, such as XML or JSON,
    this type of information can be used to ensure that as the source code is modified,
    the resulting code executes in the same amount of time or faster.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，Catch2执行了该函数多次，平均花费`197`纳秒来对向量进行排序。`BENCHMARK()`宏对于确保代码不仅按预期执行并给出特定输入的正确输出，而且还确保代码在特定时间内执行非常有用。配合更详细的输出格式，比如XML或JSON，这种类型的信息可以用来确保随着源代码的修改，生成的代码执行时间保持不变或更快。
- en: To better understand how unit testing can truly improve your C++, we will conclude
    this recipe with two additional examples designed to provide more realistic scenarios.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解单元测试如何真正改进您的C++，我们将用两个额外的例子来结束这个配方，这些例子旨在提供更真实的场景。
- en: 'In the first example, we will create a **vector**. Unlike an `std::vector`,
    which in C++ is a dynamic, C-style array, a vector in mathematics is a point in
    *n*-dimensional space (in our example, we limit this to 2D space), with a magnitude
    that is the distance between the point and the origin (that is, 0,0). We implement
    this vector in our example as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们将创建一个**向量**。与C++中的`std::vector`不同，它是一个动态的C风格数组，数学中的向量是*n*维空间中的一个点（在我们的例子中，我们将其限制为2D空间），其大小是点与原点（即0,0）之间的距离。我们在示例中实现这个向量如下：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first thing we do (besides the usual macros and includes) is to define
    a class with `x` and `y` coordinates:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通常的宏和包含之外，我们要做的第一件事是定义一个带有`x`和`y`坐标的类：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we add some helper functions and constructors. The default constructor
    makes a vector with no direction or magnitude as *x* and *y* are set to the origin.
    In order to create vectors that have a direction and magnitude, we also provide
    another constructor that allows you to provide the vector''s initial *x* and *y*
    coordinates. To get the vector''s direction, we provide getters that return the
    vector''s *x* and *y* values. Finally, we provide two helper functions. The first
    helper function **translates **the vector, which in mathematics is another term
    for changing a vector''s *x* and *y* coordinates given another vector. The final
    helper function returns the vector''s magnitude, which is the length of the vector''s
    hypotenuse if the vector''s *x* and *y* values were used to construct a triangle
    (that is, we must use Pythagoras''s theorem to calculate a vector''s magnitude).
    Next, we move on to adding operators, which we do as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一些辅助函数和构造函数。默认构造函数创建一个没有方向或大小的向量，因为*x*和*y*被设置为原点。为了创建具有方向和大小的向量，我们还提供了另一个构造函数，允许您提供向量的初始*x*和*y*坐标。为了获取向量的方向，我们提供了返回向量*x*和*y*值的getter。最后，我们提供了两个辅助函数。第一个辅助函数**translates**向量，在数学上是改变向量的*x*和*y*坐标的另一个术语。最后一个辅助函数返回向量的大小，即如果向量的*x*和*y*值用于构造三角形的斜边的长度（也就是说，我们必须使用勾股定理来计算向量的大小）。接下来，我们继续添加运算符，具体如下：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We add some equivalence operators, which can be used to check whether two vectors
    are equal. We also define a vector that represents the origin, which is a vector
    whose *x* and *y* values are 0.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些等价运算符，用于检查两个向量是否相等。我们还定义了一个表示原点的向量，其*x*和*y*值都为0。
- en: 'To test this vector, we add the following tests:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个向量，我们添加了以下测试：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first test ensures that a default constructed vector is in fact the origin.
    Our next test ensures that our global **origin **vector is the origin. This is
    important because we should not assume that the origin is constructed by default—that
    is, it is possible for someone in the future to accidentally change the origin
    to something other than `0,0`. This test case ensures that the origin is in fact
    `0,0`, so that in the future, if someone accidentally changes this, this test
    will fail. Since the origin must result in *x* and *y* both being 0, this test
    is not over-specified.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试确保默认构造的向量实际上是原点。我们的下一个测试确保我们的全局**origin**向量是原点。这很重要，因为我们不应该假设原点是默认构造的，也就是说，未来有人可能会意外地将原点更改为`0,0`之外的其他值。这个测试用例确保原点实际上是`0,0`，这样在未来，如果有人意外更改了这个值，这个测试就会失败。由于原点必须导致*x*和*y*都为0，所以这个测试并没有过度规定。
- en: Next, we test both the translate and magnitude functions. In the magnitude test
    case, we use the `Approx()` macro. This is needed because the magnitude that is
    returned is a floating point, whose size and precision depend on the hardware,
    and is irrelevant to our test. The `Approx()` macro allows us to state the level
    of precision to which we want to validate the result of the `magnitude()` function,
    which uses the `epsilon()` modifier to actually state the precision. In this case,
    we only wish to validate to one decimal point.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试translate和magnitude函数。在magnitude测试用例中，我们使用`Approx()`宏。这是因为返回的大小是一个浮点数，其大小和精度取决于硬件，并且与我们的测试无关。`Approx()`宏允许我们声明要验证`magnitude()`函数结果的精度级别，该函数使用`epsilon()`修饰符来实际声明精度。在这种情况下，我们只希望验证到小数点后一位。
- en: The last test case is used to demonstrate how all inputs to these functions
    should be tested. If a function takes an integer, then valid, invalid, and extreme
    inputs should all be tested. In this case, we are passing `INT_MAX` for both *x*
    and *y*. The resulting `magnitude()` function does not provide a valid result.
    This is because the process of calculating the magnitude overflows the integer
    type. This type of error should either be accounted for in the code (that is,
    you should check for possible overflows and throw an exception) or the API's specification
    should call out these types of issues (that is, the C++ specification would likely
    state that the result of this type of input is undefined). Either way, if a function
    takes an integer, then all possible integer values should be tested, and this
    process should be repeated for all input types.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试用例用于演示这些函数的所有输入应该被测试。如果一个函数接受一个整数，那么应该测试所有有效的、无效的和极端的输入。在这种情况下，我们为*x*和*y*都传递了`INT_MAX`。结果的`magnitude()`函数没有提供有效的结果。这是因为计算大小的过程溢出了整数类型。这种类型的错误应该在代码中考虑到（也就是说，您应该检查可能的溢出并抛出异常），或者API的规范应该指出这些类型的问题（也就是说，C++规范可能会声明这种类型输入的结果是未定义的）。无论哪种方式，如果一个函数接受一个整数，那么所有可能的整数值都应该被测试，并且这个过程应该对所有输入类型重复。
- en: 'The results of this test are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的结果如下：
- en: '![](img/64400718-2c26-405a-9f0f-f9581dec0119.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64400718-2c26-405a-9f0f-f9581dec0119.png)'
- en: As shown in the preceding screenshot, the unit fails the last test. As stated
    previously, to fix this issue, the magnitude function should be changed to either
    throw when an overflow occurs, find a way to prevent the overflow, or remove the
    test and state that such input is undefined.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，该单元测试未通过最后一个测试。如前所述，为了解决这个问题，magnitude函数应该被更改为在发生溢出时抛出异常，找到防止溢出的方法，或者删除测试并声明这样的输入是未定义的。
- en: In our final example, we will demonstrate how to handle functions that do not
    return a value, but instead, manipulate an input.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个例子中，我们将演示如何处理不返回值而是操作输入的函数。
- en: 'Let''s start this example by creating a class that writes to a file and another
    class that uses the first class to write a string to said file, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个写入文件的类和另一个使用第一个类将字符串写入该文件的类来开始这个例子，如下所示：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As shown in the preceding code, the first class writes to a file called `test.txt`,
    while the second class takes the first class as an input and uses it to write
    a string to the file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，第一个类写入一个名为`test.txt`的文件，而第二个类将第一个类作为输入，并使用它来向文件中写入一个字符串。
- en: 'We test the second class as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试第二个类如下：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The problem with the preceding test is that we do not have any `CHECK()` macros.
    This is because, other than `CHECK_NOTHROW()`, we have nothing to check. In this
    test, we are testing to make sure that the `the_answer{}` class calls `file{}`
    classes and the `write()` function properly. We could open the `test.txt` file
    and check to make sure that it was written with the right string, but this is
    a lot of work. This type of check would also be over-specifying as we are not
    testing the `file{}` class—we are only testing the `the_answer{}` class. If in
    the future we decide that the `file{}` class should write to a network file and
    not a file on disk, the unit test would have to change.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面测试的问题在于我们没有任何`CHECK()`宏。这是因为除了`CHECK_NOTHROW()`之外，我们没有任何需要检查的东西。在这个测试中，我们测试以确保`the_answer{}`类调用`file{}`类和`write()`函数正确。我们可以打开`test.txt`文件并检查它是否用正确的字符串写入，但这是很多工作。这种类型的检查也会过度指定，因为我们不是在测试`file{}`类，我们只是在测试`the_answer{}`类。如果将来我们决定`file{}`类应该写入网络文件而不是磁盘上的文件，单元测试将不得不改变。
- en: 'To overcome this issue, we can leverage a concept called **mocking**. A `Mock` class
    is a class that pretends to be the class that is inputted, providing the unit
    test with **seams **that allow the unit test to verify the result of a test. This
    is different from a `Stub`, which provides fake input. Sadly, C++ does not have
    good support for mocking when compared to other languages. Helper libraries, such
    as GoogleMock, attempt to fix this issue at the expense of requiring all of your
    mockable classes to contain a vTable (that is, inheriting pure virtual base classes)
    and define each mockable class twice (once in your code and a second time in your
    test, using a set of APIs defined by Google). This is far from optimal. Libraries
    such as Hippomocks attempt to address these issues at the expense of some vTable
    black magic that only works in certain environments and is nearly impossible to
    debug when things go wrong. Although Hippomocks is likely one of the best options
    (that is, until C++ enables native mocking), the following example is another
    method for mocking using standard C++, with its only downside being verbosity:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们可以利用一个叫做**mocking**的概念。`Mock`类是一个假装是输入类的类，为单元测试提供了**seams**，允许单元测试验证测试的结果。这与`Stub`不同，后者提供了虚假的输入。不幸的是，与其他语言相比，C++对mocking的支持并不好。辅助库，如GoogleMock，试图解决这个问题，但需要所有可mock的类都包含一个vTable（即继承纯虚拟基类）并在你的代码中定义每个可mock的类两次（一次在你的代码中，一次在你的测试中，使用Google定义的一组API）。这远非最佳选择。像Hippomocks这样的库试图解决这些问题，但需要一些vTable黑魔法，只能在某些环境中工作，并且当出现问题时几乎不可能进行调试。尽管Hippomocks可能是最好的选择之一（即直到C++启用本地mocking），但以下示例是使用标准C++进行mocking的另一种方法，唯一的缺点是冗长：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As with our previous example, we create two classes. The first class writes
    to a file while the second class uses the first class to write a string to said
    file. The difference is that we added the `VIRTUAL` macro. When the code is compiled
    into our application, `VIRTUAL` is set to nothing, meaning that it is removed
    from the code by the compiler. When the code is compiled in our test, however,
    it is set to `virtual`, which tells the compiler to give the class a vTable. Since
    this is only done during our tests, the added overhead is fine.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的示例一样，我们创建了两个类。第一个类写入一个文件，而第二个类使用第一个类向该文件写入一个字符串。不同之处在于我们添加了`VIRTUAL`宏。当代码编译到我们的应用程序中时，`VIRTUAL`被设置为空，这意味着它被编译器从代码中移除。然而，当代码在我们的测试中编译时，它被设置为`virtual`，这告诉编译器给类一个vTable。由于这只在我们的测试期间完成，所以额外的开销是可以接受的。
- en: 'Now that our class supports inheritance in our test case, we can create a subclassed
    version of our `file{}` class as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的类在我们的测试用例中支持继承，我们可以创建我们的`file{}`类的一个子类版本如下：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding class defines our mock. Instead of writing to a file, our mock
    checks to see whether a specific string is written to our fake file and sets a
    global variable to `true` or `false`, depending on the results of the test.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类定义了我们的mock。我们的mock不是写入文件，而是检查特定的字符串是否被写入我们的假文件，并根据测试的结果设置一个全局变量为`true`或`false`。
- en: 'We can then test our `the_answer{}` class as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以测试我们的`the_answer{}`类如下：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When this is executed, we get the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此操作时，我们会得到以下结果：
- en: '![](img/289a2554-23b1-4e41-9c45-6bc8b34eb163.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/289a2554-23b1-4e41-9c45-6bc8b34eb163.png)'
- en: As shown in the preceding screenshot, we can now check to make sure that our
    class writes to the file as expected. It should be noted that we use the `REQUIRE()`
    macro to ensure that the mock is in the `false` state prior to executing our test.
    This ensures that if our actual test registered as having passed, that it actually
    has passed, instead of registering as a pass because of a bug in our test logic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们现在可以检查我们的类是否按预期写入文件。值得注意的是，我们使用`REQUIRE()`宏来确保在执行我们的测试之前，mock处于`false`状态。这确保了如果我们的实际测试被注册为通过，那么它确实已经通过，而不是因为我们测试逻辑中的错误而被注册为通过。
- en: Working with ASAN, the address sanitizer
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ASAN，地址消毒剂
- en: In this recipe, we will learn how to leverage Google's **address sanitizer**
    (**ASAN**)—which is a dynamic analysis tool—to check for memory corruption errors
    in our code. This recipe is important because it provides a simple means to ensure
    that your code is both reliable and stable, with a minimal number of changes to
    your build system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何利用谷歌的**地址消毒剂**（**ASAN**）——这是一个动态分析工具——来检查代码中的内存损坏错误。这个示例很重要，因为它提供了一种简单的方法来确保你的代码既可靠又稳定，而对你的构建系统的更改数量很少。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本食谱中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Go through the following steps to follow the recipe:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行该食谱：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To compile the source code, run the following:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码后，可以通过运行以下命令执行本食谱中的每个示例：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the next section, we will go through each of these examples and explain what
    each example program does and how it relates to the lessons that are being taught
    in this recipe.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本食谱中所教授的课程的关系。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Google''s address sanitizer is a set of modifications to the GCC and LLVM compilers,
    as well as a set of libraries that must be linked into your application when testing.
    To accomplish this, we must add the following compiler flags when compiling code
    for testing (but do not add these flags to production releases):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Google的地址消毒剂是对GCC和LLVM编译器的一组修改，以及一组必须在测试时链接到应用程序中的库。为了实现这一点，我们在编译用于测试的代码时必须添加以下编译器标志（但不要将这些标志添加到生产版本中）：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The most important flag to pay attention to here is the `-fsanitize=address` flag,
    which tells the compiler to enable ASAN. The rest of the flags are required by
    the sanitizer to function properly, with the most notable flags being `-g` and
    `-01`. The `-g` flag enables debugging and the `-O1` flag sets the optimization
    level to 1 to provide some performance improvements. Note that once the ASAN tool
    is enabled, the compiler will automatically attempt to link to the ASAN libraries,
    which must be present on your machine.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要特别注意的最重要的标志是`-fsanitize=address`标志，它告诉编译器启用ASAN。其余的标志是卫生间所需的，最值得注意的标志是`-g`和`-01`。`-g`标志启用调试，`-O1`标志将优化级别设置为1，以提供一些性能改进。请注意，一旦启用ASAN工具，编译器将自动尝试链接到ASAN库，这些库必须存在于您的计算机上。
- en: To demonstrate how this sanitizer works, let's look at a few examples.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个消毒剂是如何工作的，让我们看几个例子。
- en: Memory leak error
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存泄漏错误
- en: '`AddressSanitizer` is a dynamic analysis tool that is designed to identify
    memory corruption errors. It is similar to Valgrind, but is built directly into
    your executable. The easiest example to demonstrate this with (and sadly one of
    the most common types of errors) is a memory leak, which is shown in the following
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddressSanitizer`是一种动态分析工具，旨在识别内存损坏错误。它类似于Valgrind，但直接内置到您的可执行文件中。最容易用一个示例来演示这一点（也是最常见的错误类型之一）是内存泄漏，如下所示：'
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This results in the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/4cdecfde-c17e-47ba-b109-8dd637af2a5d.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cdecfde-c17e-47ba-b109-8dd637af2a5d.png)'
- en: In the preceding example, we allocate an integer in our program using the `new`
    operator, but we will never free this allocated memory prior to exiting the program.
    The ASAN tool is capable of detecting this issue and outputs an error when the
    application completes its execution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们在程序中使用`new`运算符分配了一个整数，但在退出程序之前我们将永远不会释放这个分配的内存。ASAN工具能够检测到这个问题，并在应用程序完成执行时输出错误。
- en: Memory deleted twice
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存两次删除
- en: 'The ability to detect memory leaks is extremely helpful, but it is not the
    only type of error that can be detected by ASAN. Another common type of error
    is deleting memory twice. For example, consider the following code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 检测内存泄漏的能力非常有帮助，但这并不是ASAN能够检测到的唯一类型的错误。另一种常见的错误类型是多次删除内存。例如，考虑以下代码片段：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When executed, we see the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们看到以下输出：
- en: '![](img/01d887f8-4fcc-4efc-8691-67831ec8b13a.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01d887f8-4fcc-4efc-8691-67831ec8b13a.png)'
- en: In the preceding example, we allocate an integer using the `new` operator and
    then `delete` the integer using the delete operator. Since the pointer to the
    previously allocated memory is still in our `p` variable, we can delete it again,
    which we do before we exit the program. On some systems, this would generate a
    segmentation fault as it is undefined behavior. The ASAN tool is capable of detecting
    this issue and outputs an error message stating that a `double-free` error has
    occurred.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用`new`运算符分配了一个整数，然后使用删除运算符删除了该整数。由于先前分配的内存的指针仍然在我们的`p`变量中，我们可以再次删除它，这是我们在退出程序之前所做的。在某些系统上，这将生成一个分段错误，因为这是未定义的行为。ASAN工具能够检测到这个问题，并输出一个错误消息，指出发生了`double-free`错误。
- en: Accessing invalid memory
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问无效内存
- en: 'Another type of error is attempting to access memory that was never allocated.
    This is usually caused by the code attempting to dereference a null pointer, but
    it could also occur when a pointer is corrupt, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种错误类型是尝试访问从未分配的内存。这通常是由代码尝试对空指针进行解引用引起的，但也可能发生在指针损坏时，如下所示：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This results in the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/ebd30496-bc91-49e1-b20c-1e5f580db297.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebd30496-bc91-49e1-b20c-1e5f580db297.png)'
- en: In the preceding example, we create a pointer to an integer and then provide
    it with a corrupt value of `42` (which is not a valid pointer). We then attempt
    to dereference the corrupt pointer, which results in a segmentation fault. It
    should be noted that the ASAN tool is capable of detecting this issue, but it
    is not capable of providing any useful information. This is because the ASAN tool
    is a library that hooks into memory allocation routines, keeping track of each
    allocation and how the allocations are used. If an allocation never occurs, it
    will not have any information about what happened above and beyond what a typical
    Unix signal handler could already provide, something that other dynamic analysis
    tools, such as Valgrind, are better suited to handle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个指向整数的指针，然后为它提供了一个损坏的值`42`（这不是一个有效的指针）。然后我们尝试对损坏的指针进行解引用，结果导致分段错误。应该注意的是，ASAN工具能够检测到这个问题，但它无法提供任何有用的信息。这是因为ASAN工具是一个库，它钩入内存分配例程，跟踪每个分配以及分配的使用方式。如果一个分配从未发生过，它将不会有任何关于发生了什么的信息，除了典型的Unix信号处理程序已经提供的信息，其他动态分析工具，比如Valgrind，更适合处理这些情况。
- en: Using memory after deleting it
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在删除后使用内存
- en: 'To further demonstrate how the address sanitizer works, let''s look at the
    following example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步演示地址消毒剂的工作原理，让我们看看以下示例：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we execute this, we see the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个时，我们会看到以下内容：
- en: '![](img/c01185c7-a10c-4464-be43-c60816cfcd63.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c01185c7-a10c-4464-be43-c60816cfcd63.png)'
- en: The preceding example allocates an integer and then deletes the integer. We
    then attempt to use the previously deleted memory. Since this memory location
    was originally allocated, ASAN has the address cached. When the dereference to
    the previously deleted memory occurs, ASAN is capable of detecting the issue as
    a `heap-use-after-free` error. It is only capable of detecting this issue because
    the memory was previously allocated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例分配了一个整数，然后删除了这个整数。然后我们尝试使用先前删除的内存。由于这个内存位置最初是分配的，ASAN已经缓存了地址。当对先前删除的内存进行解引用时，ASAN能够检测到这个问题，作为`heap-use-after-free`错误。它之所以能够检测到这个问题，是因为这块内存先前被分配过。
- en: Deleting memory that was never allocated
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除从未分配的内存
- en: 'As a final example, let''s look at the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，让我们看看以下内容：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This results in the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下结果：
- en: '![](img/ed7e5106-c3d4-478f-8085-45a6ed4f62fb.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed7e5106-c3d4-478f-8085-45a6ed4f62fb.png)'
- en: In the preceding example, we create an integer to a pointer and then provide
    it with a corrupt value again. Unlike our previous example, in this example, we
    attempt to delete the corrupt pointer, which results in a segmentation fault.
    Once again, ASAN is able to detect this issue, but doesn't have any useful information
    as an allocation never occurred.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个指向整数的指针，然后再次为它提供了一个损坏的值。与我们之前的示例不同，在这个示例中，我们尝试删除这个损坏的指针，结果导致分段错误。再一次，ASAN能够检测到这个问题，但由于从未发生过分配，它没有任何有用的信息。
- en: It should be noted that the C++ Core Guidelines—which is a coding standard for
    modern C++—are incredibly helpful at preventing the types of issues that we previously
    described. Specifically, the Core Guidelines state that `new()`, `delete()`, `malloc()`,
    `free()`, and friends should never be used directly, but instead, `std::unique_ptr`
    and `std::shared_ptr` should be used for *all memory allocations*. These APIs
    allocate and free memory for you, automatically. If we look at the previous examples
    again, it is easy to see how using these APIs to allocate memory instead of using
    `new()` and `delete()` manually can prevent these types of issues from occurring
    as most of the preceding examples were all related to the invalid use of `new()`
    and `delete()`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，C++核心指南——这是一个现代C++的编码标准——在防止我们之前描述的问题类型方面非常有帮助。具体来说，核心指南规定`new()`、`delete()`、`malloc()`、`free()`和其他函数不应该直接使用，而应该使用`std::unique_ptr`和`std::shared_ptr`来进行*所有内存分配*。这些API会自动为您分配和释放内存。如果我们再次看一下前面的示例，很容易看出，使用这些API来分配内存而不是手动使用`new()`和`delete()`可以防止这些问题发生，因为大多数前面的示例都与无效使用`new()`和`delete()`有关。
- en: Working with UBSAN, the undefined behavior sanitizer
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UBSAN，未定义行为消毒剂
- en: In this recipe, we will learn how to use the UBSAN dynamic analysis tool with
    our C++ applications, which is capable of detecting undefined behavior. There
    are many different types of errors that can be introduced in our applications,
    and undefined behavior is likely the most common type, as the C and C++ specifications
    define several instances where undefined behavior is possible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在我们的C++应用程序中使用UBSAN动态分析工具，它能够检测未定义的行为。在我们的应用程序中可能会引入许多不同类型的错误，未定义的行为很可能是最常见的类型，因为C和C++规范定义了几种可能发生未定义行为的情况。
- en: This recipe is important because it will teach you how to enable this simple
    feature and how it can be used in your applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方很重要，因为它将教会你如何启用这个简单的功能，以及它如何在你的应用程序中使用。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本配方中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Go through the following steps to work through the recipe:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行配方：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端，运行以下命令来下载源代码：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To compile the source code, run the following:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译后，可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the next section, we will go through each of these examples and explain what
    each example program does and how it relates to the lessons being taught in this
    recipe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个讲解这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The UBSAN tool is capable of detecting several types of undefined behavior,
    including the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: UBSAN工具能够检测到几种类型的未定义行为，包括以下内容：
- en: Out-of-bounds errors
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越界错误
- en: Floating-point errors
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点错误
- en: Division by zero
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除零
- en: Integer overflows
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数溢出
- en: Null-pointer dereferencing
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空指针解引用
- en: Missing returns
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少返回值
- en: Signed-/unsigned-conversion errors
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号/无符号转换错误
- en: Unreachable code
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可达代码
- en: 'In this recipe, we will look at a couple of these examples, but to start, we
    must first enable the UBSAN tool in our application. To do this, we must enable
    the following flag in our application''s build system:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看一些这样的例子，但首先，我们必须在我们的应用程序中启用UBSAN工具。为此，我们必须在应用程序的构建系统中启用以下标志：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This flag will tell GCC or LLVM to use the UBSAN tool, which adds additional
    logic to our application as well as links to a UBSAN library. It should be noted
    that the UBSAN tool grows in its capability over time. For this reason, both GCC
    and LLVM have different levels of support for UBSAN. To get the most out of this
    tool, your application should be compiled against both GCC and LLVM, and you should
    use the most up-to-date compiler possible for both of these.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标志将告诉GCC或LLVM使用UBSAN工具，它会向我们的应用程序添加额外的逻辑，并链接到UBSAN库。值得注意的是，UBSAN工具的功能会随着时间的推移而增强。因此，GCC和LLVM对UBSAN的支持水平不同。为了充分利用这个工具，你的应用程序应该同时针对GCC和LLVM进行编译，并且应该尽可能使用最新的编译器。
- en: Divide-by-zero errors
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除零错误
- en: 'One of the easiest examples to demonstrate with UBSAN is the divide-by-zero
    error, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UBSAN最容易演示的一个例子是除零错误，如下所示：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When this is run, we see the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，我们看到以下内容：
- en: '![](img/698ed489-e92b-4080-a0dc-fb224466ddf7.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/698ed489-e92b-4080-a0dc-fb224466ddf7.png)'
- en: In the preceding example, we create two integers (a numerator and a denominator)
    with the denominator set to `0`. We then divide the numerator and the denominator
    resulting in a divide-by-zero error, which UBSAN detects and outputs as the program
    crashes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了两个整数（一个分子和一个分母），分母设置为`0`。然后我们对分子和分母进行除法运算，导致除零错误，UBSAN检测到并在程序崩溃时输出。
- en: Null-pointer dereferences
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空指针解引用
- en: 'A more common type of problem in C++ is a null-pointer dereference, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中更常见的问题类型是空指针解引用，如下所示：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This results in the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下结果：
- en: '![](img/61d56d5b-161b-470f-8181-68dafa5ab7ab.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61d56d5b-161b-470f-8181-68dafa5ab7ab.png)'
- en: In the preceding example, we create a pointer to an integer and set it to `0`
    (that is, a `NULL` pointer). We then dereference the `NULL` pointer and set its
    value, resulting in a segmentation fault, which UBSAN is capable of detecting
    as the program crashes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个指向整数的指针，并将其设置为`0`（即`NULL`指针）。然后我们对`NULL`指针进行解引用并设置其值，导致分段错误，UBSAN能够检测到程序崩溃。
- en: Out-of-bounds errors
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 越界错误
- en: 'Both of the preceding examples could have been detected using a Unix signal
    handler. In the next example, we will access an array out of bounds, which is
    undefined in the C++ specification and is a lot more difficult to detect:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个示例都可以使用Unix信号处理程序来检测。在下一个示例中，我们将访问一个超出边界的数组，这在C++规范中是未定义的，而且更难以检测：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When executed, we get the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下结果：
- en: '![](img/19eaa37d-90b8-4910-bc6a-bc96ec98f7dd.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19eaa37d-90b8-4910-bc6a-bc96ec98f7dd.png)'
- en: As shown in the preceding example, we create an array with `6` elements and
    then attempt to access the 10th element in the array, which doesn't exist. Attempting
    to access this element in the array is not guaranteed to generate a segmentation
    fault. Regardless, UBSAN is capable of detecting this type of error and outputs
    the issue to `stderr` on exiting.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的示例所示，我们创建了一个有6个元素的数组，然后尝试访问数组中的第10个元素，这个元素并不存在。尝试访问数组中的这个元素并不一定会生成分段错误。不管怎样，UBSAN能够检测到这种类型的错误，并在退出时将问题输出到`stderr`。
- en: Overflow errors
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 溢出错误
- en: 'Finally, we can also detect signed integer overflow errors, which are undefined in
    C++, but highly unlikely to generate a crash, and instead will cause the program
    to enter a corrupt state (often producing endless loops, out-of-bounds errors,
    and so on). Consider the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以检测有符号整数溢出错误，这在C++中是未定义的，但极不可能导致崩溃，而是会导致程序进入一个损坏的状态（通常产生无限循环、越界错误等）。考虑以下代码：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This results in the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下结果：
- en: '![](img/0db50c0b-0249-4600-9a72-c62b3fc591b0.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0db50c0b-0249-4600-9a72-c62b3fc591b0.png)'
- en: As shown in the preceding example, we create an integer and set it to its maximum
    value. We then attempt to increase this integer, which would normally flip the
    integer's sign, an error that UBSAN is capable of detecting.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的示例所示，我们创建了一个整数，并将其设置为最大值。然后我们尝试增加这个整数，这通常会翻转整数的符号，这是UBSAN能够检测到的错误。
- en: 'Using #ifndef NDEBUG to conditionally execute additional checks'
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用#ifndef NDEBUG条件执行额外检查
- en: In this recipe, we will learn how to leverage the `NDEBUG` macro, which stands
    for *no debug*. This recipe is important because most build systems automatically
    define this macro when a *release* or *production* build is compiled, which can
    be leveraged to disable debug logic when such a build is created.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何利用`NDEBUG`宏，它代表*no debug*。这个示例很重要，因为大多数构建系统在编译*发布*或*生产*版本时会自动定义这个宏，这可以用来在创建这样的构建时禁用调试逻辑。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本配方中的示例。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Go through the following steps to work through the recipe:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来完成这个配方：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令来下载源代码：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To compile the source code, run the following:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本配方中的每个示例：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本配方中所教授的课程的关系。
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `NDEBUG` macro originates from C and was used to change the behavior of
    the `assert()` function. The `assert()` function can be written as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`NDEBUG`宏源自C语言，用于更改`assert()`函数的行为。`assert()`函数可以编写如下：'
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As shown in the preceding code, if the `__assert()` function is given a Boolean
    that evaluates to `false` (written in C, this is an integer that is equal to `0`),
    an error message is outputted to `stderr` and the application is aborted. The
    `NDEBUG` macro is then used to determine whether the `assert()` function exists,
    and if the application is in release mode, then all of the assert logic is removed,
    reducing the size of the application. When using CMake, we can enable the `NDEBUG`
    flag using the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，如果`__assert()`函数得到一个求值为`false`的布尔值（在C中，这是一个等于`0`的整数），则会向`stderr`输出错误消息，并中止应用程序。然后使用`NDEBUG`宏来确定`assert()`函数是否存在，如果应用程序处于发布模式，则会删除所有断言逻辑，从而减小应用程序的大小。在使用CMake时，我们可以使用以下命令启用`NDEBUG`标志：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will automatically define the `NDEBUG` macro and enable optimizations.
    To prevent this macro from being defined, we can do the opposite:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动定义`NDEBUG`宏并启用优化。要防止定义此宏，我们可以做相反的操作：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding CMake code will *not* define the `NDEBUG` macro, and instead will
    enable debugging, as well as disable most optimizations (although this depends
    on the compiler).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的CMake代码将*不*定义`NDEBUG`宏，而是启用调试，并禁用大多数优化（尽管这取决于编译器）。
- en: 'In our own code, the `assert` macro can be used as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自己的代码中，`assert`宏可以如下使用：
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This results in the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/285a3fe5-641d-4c56-8521-9fe0e4ffbceb.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/285a3fe5-641d-4c56-8521-9fe0e4ffbceb.png)'
- en: As shown in the preceding example, we create an application that uses the `assert()`
    macro to check a false statement, which results in the application aborting.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们创建了一个应用程序，该应用程序使用`assert()`宏来检查一个错误的语句，结果是应用程序中止。
- en: 'Although the `NDEBUG` macro is used by the `assert()` function, you can also
    use it yourself as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`NDEBUG`宏被`assert()`函数使用，但您也可以自己使用它，如下所示：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As shown in the preceding code, if the application is not compiled in *release* mode
    (that is, if the `NDEBUG` macro is not defined on the command line when compiling),
    then the application will output to `stdout`. This same logic can be used throughout
    your code to create your own debug macros and functions to ensure that your debug
    logic is removed in *release* mode, allowing you to add as much debug logic as
    you need without modifying the resulting application that you deliver to your
    customers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，如果应用程序未以*release*模式编译（即在编译时未在命令行上定义`NDEBUG`宏），则应用程序将输出到`stdout`。您可以在整个代码中使用相同的逻辑来创建自己的调试宏和函数，以确保在*release*模式下删除调试逻辑，从而可以根据需要添加任意数量的调试逻辑，而无需修改交付给客户的最终应用程序。
