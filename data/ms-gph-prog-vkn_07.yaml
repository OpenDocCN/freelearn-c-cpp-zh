- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Rendering Many Lights with Clustered Deferred Rendering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集群延迟渲染渲染许多光源
- en: Until now, our scene has been lit by a single point light. While this has worked
    fine so far as we focused our attention more on laying the foundations of our
    rendering engine, it’s not a very compelling and realistic use case. Modern games
    can have hundreds of lights in a given scene, and it’s important that the lighting
    stage is performed efficiently and within the budget of a frame.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的场景一直是由一个点光源照亮的。虽然到目前为止这已经足够好了，因为我们更关注于构建渲染引擎的基础，但这并不是一个非常吸引人和逼真的用例。现代游戏在给定场景中可以拥有数百个光源，并且高效地执行照明阶段并在帧预算内完成是非常重要的。
- en: In this chapter, we will first describe the most common techniques that are
    used both in deferred and forward shading. We will highlight the pros and cons
    of each technique so that you can determine which one best fits your needs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先描述在延迟和前向着色中常用的最常见技术。我们将突出每种技术的优缺点，以便您可以确定哪种最适合您的需求。
- en: Next, we are going to provide an overview of our G-buffer setup. While the G-buffer
    has been in place from the very beginning, we haven’t covered its implementation
    in detail. This is a good time to go into more detail, as the choice of a deferred
    renderer will inform our strategy for clustered lighting.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将概述我们的G缓冲区设置。虽然G缓冲区从一开始就存在，但我们还没有详细讨论其实现。现在是深入了解的好时机，因为延迟渲染器的选择将影响我们聚类照明的策略。
- en: Finally, we are going to describe our clustering algorithm in detail and highlight
    the relevant sections of the code. While the algorithm itself is not too complex,
    there are a lot of details that are important to get a stable solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将详细描述我们的聚类算法，并突出代码中的相关部分。虽然算法本身并不复杂，但有很多细节对于获得稳定的解决方案非常重要。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要主题：
- en: A brief history of clustered lighting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成照明的简史
- en: Our G-buffer setup and implementation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的G缓冲区设置和实现
- en: Implementing clustered lighting using screen tiles and Z-binning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用屏幕瓦片和Z分箱实现集群照明
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: By the end of the chapter you will have a solid understanding of our G-buffer
    implementation. You will also learn how to implement a state of the art light
    clustering solution that can handle hundreds of lights.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对我们G缓冲区实现有一个稳固的理解。您还将学习如何实现一个能够处理数百个光源的尖端光聚类解决方案。
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter7](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter7).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下网址找到：[https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter7](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter7)。
- en: A brief history of clustered lighting
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成照明的简史
- en: In this section, we are going to explore the background of how clustered lighting
    came to be and how it has evolved over the years.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨集群照明是如何产生的以及它是如何随着时间演变的背景。
- en: In real-time applications, until the early 2000s, the most common way to handle
    lighting was by using the so-called **forward rendering**, a technique that renders
    each object on the screen with all the information needed, including light information.
    The problem with this approach is that it would limit the number of lights that
    could be processed to a low number, such as 4 or 8, a number that in the early
    2000s would be enough.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时应用中，直到2000年代初，处理照明最常见的方式是使用所谓的**前向渲染**，这是一种在每个屏幕对象上渲染所有所需信息的技术，包括光照信息。这种方法的缺点是它将能够处理的光源数量限制在一个很低的数字，例如4或8，在2000年代初这个数字已经足够了。
- en: 'The concept of Deferred Rendering, and more specifically, shading the same
    pixel only once, was already pioneered by Michael Deering and colleagues in a
    seminal paper called *The triangle processor and normal vector shader: a VLSI
    system for high performance graphics* in 1988, even though the term *deferred*
    was still not used.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '延迟渲染的概念，以及更具体地说，只对同一个像素进行一次着色，早在1988年由迈克尔·德林及其同事在一篇开创性的论文《三角形处理器和法线向量着色器：一种用于高性能图形的VLSI系统》（*The
    triangle processor and normal vector shader: a VLSI system for high performance
    graphics*）中就已经被提出，尽管当时还没有使用“延迟”这个术语。'
- en: Another key concept, the **G-buffer**, or **geometric buffer**, was pioneered
    by Takafumi Saito and Tokiichiro Takahashi in another pioneering paper, *Comprehensible
    Rendering of 3D Shapes*. In this paper, the authors cache depth and normals for
    each pixel to post-process the image – in this case, to add visual aids and comprehensibility
    to the image.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键概念，**G缓冲区**或**几何缓冲区**，是由Saito Takafumi和Takahashi Tokiichiro在另一篇开创性的论文《3D形状的可理解渲染》中提出的。在这篇论文中，作者为每个像素缓存深度和法线以进行后处理图像——在这种情况下，是为了向图像添加视觉辅助和可理解性。
- en: Although the first commercial game with a deferred renderer was *Shrek* in 2001
    on the original Xbox, it became increasingly popular with the game *Stalker* and
    its accompanying paper, *Deferred Shading in Stalker* ([https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker)),
    and exploded in popularity with the CryEngine presentation at Siggraph 2010 called
    *Reaching the Speed of* *Light* ([http://advances.realtimerendering.com/s2010/Kaplanyan-CryEngine3%28SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course%29.pdf](http://advances.realtimerendering.com/s2010/Kaplanyan-CryEngine3%28SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course%29.pdf)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第一款具有延迟渲染器的商业游戏是2001年在原始Xbox上的《Shrek》，但随着游戏《Stalker》及其配套论文《Stalker中的延迟着色》([https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker))的流行，以及2010年Siggraph上CryEngine演示的《达到光速》([http://advances.realtimerendering.com/s2010/Kaplanyan-CryEngine3%28SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course%29.pdf](http://advances.realtimerendering.com/s2010/Kaplanyan-CryEngine3%28SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course%29.pdf))，它变得越来越受欢迎。
- en: In the late 2000s/early 2010s, Deferred Rendering was all the rage, and basically,
    all engines were implementing some variations of it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代末/2010年代初，延迟渲染非常流行，基本上，所有引擎都在实现它的某种变体。
- en: Forward rendering made a comeback in 2012 when AMD launched a demo called *Leo*
    in which, thanks to the new *Compute Shaders* technology, they introduced the
    light list for each screen space tile and created *Forward+*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当AMD在2012年推出名为“Leo”的演示时，前向渲染在2012年卷土重来，得益于新的**计算着色器**技术，他们为每个屏幕空间瓦片引入了光列表并创建了**Forward+**。
- en: 'The AMD Leo paper can be found here: [https://takahiroharada.files.wordpress.com/2015/04/forward_plus.pdf](https://takahiroharada.files.wordpress.com/2015/04/forward_plus.pdf).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: AMD Leo 论文可以在这里找到：[https://takahiroharada.files.wordpress.com/2015/04/forward_plus.pdf](https://takahiroharada.files.wordpress.com/2015/04/forward_plus.pdf).
- en: 'A few weeks after that paper, the first commercial game to use Forward+ was
    *Dirt Showdown*, but only the PC version, as consoles still did not have support
    for APIs that would help in that area: [https://web.archive.org/web/20210621112015/https://www.rage3d.com/articles/gaming/codemaster_dirt_showdown_tech_review/](https://web.archive.org/web/20210621112015/https://www.rage3d.com/articles/gaming/codemaster_dirt_showdown_tech_review/).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在那篇论文发表后的几周，第一款使用Forward+的商业游戏是《Dirt Showdown》，但仅限于PC版本，因为游戏机仍然没有支持该领域的API：[https://web.archive.org/web/20210621112015/https://www.rage3d.com/articles/gaming/codemaster_dirt_showdown_tech_review/](https://web.archive.org/web/20210621112015/https://www.rage3d.com/articles/gaming/codemaster_dirt_showdown_tech_review/)。
- en: With this, the Forward+ technology came back into usage, as the light limitations
    were gone, and it added a lot of algorithmic exploration in different areas (such
    as post-process anti-aliasing for a deferred depth prepass).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着，前向+技术重新得到应用，因为光限制已经消失，并且它在不同领域增加了许多算法探索（例如，用于延迟深度预处理的后期处理抗锯齿）。
- en: In the following years, more refined subdivision algorithms were developed,
    with tiles becoming clusters and moving from simple 2D screen space tiles to fully
    frustum-shaped 3D clusters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几年里，开发了更精细的细分算法，瓦片变成了簇，从简单的2D屏幕空间瓦片发展到完全的视锥体形状的3D簇。
- en: This became famous with the *Just Cause 3* paper by Emil Persson, [https://www.humus.name/Articles/PracticalClusteredShading.pdf](https://www.humus.name/Articles/PracticalClusteredShading.pdf),
    and the concept was further enhanced by others for both deferred and forward rendering
    ([https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf](https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念随着Emil Persson的《Just Cause 3》论文而闻名，[https://www.humus.name/Articles/PracticalClusteredShading.pdf](https://www.humus.name/Articles/PracticalClusteredShading.pdf)，其他人进一步增强了这个概念，用于延迟和前向渲染([https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf](https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf))。
- en: Clustering has been a great idea, but the memory consumption of having a 3D
    grid can be big, especially with the increasing rendering resolutions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类是一个很好的想法，但拥有3D网格的内存消耗可能很大，尤其是在渲染分辨率不断提高的情况下。
- en: The current state of the art of clustering comes from Activision, which is our
    chosen solution, and we will see it in detail in the *Implementing light clusters*
    section of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当前聚类技术的先进状态来自Activision，这是我们选择解决方案，我们将在本章的“实现轻量级聚类”部分详细看到它。
- en: Now that we have provided a brief historical overview of real-time light rendering
    techniques, we are going to go into more depth about the differences between forward
    and Deferred Rendering in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提供了实时光照渲染技术的简要历史概述，我们将在下一节更深入地探讨前向渲染和延迟渲染之间的区别。
- en: Differences between forward and deferred techniques
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前向和延迟技术之间的区别
- en: 'After talking about the history of forward and Deferred Rendering techniques,
    we want to highlight the key differences and talk about their common problem:
    **light assignment**.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了前向渲染和延迟渲染技术的历史之后，我们想强调它们的关键区别，并讨论它们共同的问题：**光照分配**。
- en: 'The main advantages of forward rendering are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前向渲染的主要优点如下：
- en: Total freedom when rendering materials
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染材料时的完全自由
- en: Same rendering path for opaque and transparent objects
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不透明和透明对象相同的渲染路径
- en: Support for **Multi Sampled** **Anti-Aliasing** (**MSAA**)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持**多采样抗锯齿**（**MSAA**）
- en: Lower memory bandwidth within the GPU
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU内的内存带宽较低
- en: 'The main disadvantages of forward rendering are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前向渲染的主要缺点如下：
- en: A depth prepass could be necessary to reduce the number of fragments shaded.
    Without this preprocessing step, scenes that contain a large number of objects
    could waste a lot of processing time by shading fragments for objects that are
    not visible. For this reason, a pass that only writes to the depth buffer is executed
    at the beginning of a frame.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能需要深度预处理步骤来减少着色片段的数量。如果没有这个预处理步骤，包含大量对象的场景可能会浪费大量处理时间，因为它们着色了不可见对象的片段。因此，在帧开始时执行一个仅写入深度缓冲区的步骤。
- en: The `depth-test` function is then set to equal so that only the fragments for
    the visible objects will be shaded. Depending on the complexity of your scene,
    this pre-pass could be expensive, and in some cases, simplified geometry is used
    to reduce the cost of this pass at the expense of slightly less accurate results.
    You must also be careful and ensure that the Early-Z test is not disabled in the
    graphics pipeline.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`深度测试`函数设置为相等，这样只有可见对象的片段才会着色。根据场景的复杂度，这个预处理步骤可能会很昂贵，在某些情况下，使用简化几何体来降低此步骤的成本，但会略微降低结果的准确性。你还必须小心，并确保在图形管线中未禁用早期Z测试。
- en: This happens when writing to the depth buffer from a fragment shader or when
    a fragment shader contains a discard instruction.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在从片段着色器写入深度缓冲区时，或者当片段着色器包含丢弃指令时。
- en: The complexity of shading a scene is the number of objects (*N*) multiplied
    by the number of lights (*L*). All the lights must be processed for each object
    as we don’t know in advance which lights affect a given fragment.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景着色的复杂性是对象数量（*N*）乘以光照数量（*L*）。由于我们事先不知道哪些光照会影响给定的片段，因此必须为每个对象处理所有光照。
- en: Shaders become increasingly more complex, having to do a lot of operations and
    thus having a very high GPU register pressure (number of registers used), impacting
    performance.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器变得越来越复杂，需要执行大量操作，因此GPU寄存器压力（使用的寄存器数量）非常高，影响性能。
- en: Deferred Rendering (sometimes referred to as **deferred shading**) was introduced
    primarily to decouple the rendering of the geometry and the light computations.
    In Deferred Rendering, we create multiple render targets. Usually, we have a render
    target for albedo, normals, PBR parameters (roughness, metalness, and occlusion
    – see [*Chapter 2*](B18395_02.xhtml#_idTextAnchor030), *Improving Resources Management,*
    for more details), and depth.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟渲染（有时被称为**延迟着色**）主要是为了解耦几何形状的渲染和光照计算。在延迟渲染中，我们创建多个渲染目标。通常，我们有一个用于漫反射、法线、PBR参数（粗糙度、金属度和遮挡
    - 见[*第2章*](B18395_02.xhtml#_idTextAnchor030)，*改进资源管理*，了解更多详情）和深度的渲染目标。
- en: Once these render targets have been created, for each fragment we process the
    lights in the scene. We still have the same problem as before, since we still
    don’t know which lights affect a given shader; however, our scene complexity has
    gone from *N x L* to *N +* *L*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了这些渲染目标，对于每个片段，我们处理场景中的灯光。我们仍然面临之前的问题，因为我们仍然不知道哪些灯光影响给定的着色器；然而，我们的场景复杂度已从*N
    x L*变为*N + L*。
- en: 'The main advantages of deferred shading are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟着色的主要优势如下：
- en: Decreased shading complexity
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低着色复杂性
- en: No need for a depth pre-pass
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需深度预遍历
- en: Less complex shaders, as writing information on the G-buffer and processing
    lights are separate operations
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较简单的着色器，因为将信息写入G缓冲区和处理灯光是分开的操作
- en: 'However, there are some disadvantages to this approach, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也有一些缺点，如下：
- en: '**High memory usage**: We listed three render targets that have to be stored
    in memory. With increasing resolutions of modern games, these start to add up,
    especially when more render targets are needed for other techniques – for example,
    motion vectors for **Temporal Anti-Aliasing** (**TAA**), which will be discussed
    in a later chapter. For this reason, developers tend to compress some of this
    data, which helps to reduce the amount of memory required by the G-buffer.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高内存使用**：我们列出了三个必须存储在内存中的渲染目标。随着现代游戏分辨率的提高，这些开始累积，尤其是在需要更多渲染目标用于其他技术时——例如，用于**时间反走样**（**TAA**）的运动矢量，这将在后面的章节中讨论。因此，开发者倾向于压缩一些数据，这有助于减少G缓冲区所需的内存量。'
- en: '**Loss of normals precision**: Normals are usually encoded as full floats (or
    possibly as 16-bit floats) as part of the geometry. To save memory when writing
    the normals render target, these values get compressed to 8 bits, significantly
    reducing the accuracy of these values.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线精度损失**：法线通常作为完整浮点数（或可能作为16位浮点数）作为几何的一部分进行编码。在写入法线渲染目标时为了节省内存，这些值被压缩到8位，显著降低了这些值的精度。'
- en: To further reduce memory usage, developers take advantage of the fact that normals
    are normalized. This allows us to store only two values and reconstruct the third.
    There are other techniques that can be used to compress normals, which will be
    referenced in the *Further reading* section. We will explain in detail the one
    we use in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步减少内存使用，开发者利用法线是归一化的这一事实。这允许我们只存储两个值并重建第三个值。还有其他可以用来压缩法线的技术，这些将在*进一步阅读*部分中提及。我们将在下一节中详细解释我们使用的技术。
- en: Transparent objects need a separate pass and need to be shaded using a forward
    technique.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明物体需要一个单独的遍历，并且需要使用前向技术进行着色。
- en: Special materials need to have all their parameters packed into the G-buffer.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊材质需要将所有参数打包到G缓冲区中。
- en: 'As you probably noticed, one problem is common to both techniques: we have
    to go through all the lights when processing an individual object or fragment.
    We are now going to describe the two most common techniques that are used to solve
    this issue: tiles and clusters.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到的，这两个技术都存在一个共同问题：在处理单个对象或片段时，我们必须遍历所有灯光。我们现在将描述两种最常用的解决此问题的技术：瓦片和簇。
- en: Light tiles
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光瓦片
- en: One approach to reducing the number of lights processed for a given fragment
    is to create a grid in screen space and determine which lights affect a given
    tile. When rendering the scene, we determine which tile the fragment we are shading
    belongs to and we iterate only over the lights that cover that tile.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 减少给定片段处理灯光数量的一个方法是在屏幕空间中创建一个网格，并确定哪些灯光影响给定的瓦片。在渲染场景时，我们确定我们正在着色的片段属于哪个瓦片，并且只遍历覆盖该瓦片的灯光。
- en: The following figure shows the debug visualization for a light in the scene
    (the green sphere) and the screen area that it covers (in yellow). We will use
    this data to determine which tiles are affected by a given light.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了场景中一个灯光（绿色球体）及其覆盖的屏幕区域（黄色）。我们将使用这些数据来确定哪些瓦片受到给定灯光的影响。
- en: '![Figure 7.1 – The area covered by a point light in screen space](img/B8395_07_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 屏幕空间中点光源覆盖的区域](img/B8395_07_01.jpg)'
- en: Figure 7.1 – The area covered by a point light in screen space
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 屏幕空间中点光源覆盖的区域
- en: Building the tiles can be done on the CPU or with a compute shader on the GPU.
    Tile data can be stored in a flat array; we will explain this data structure in
    more detail later in the chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦片的构建可以在CPU上完成，也可以在GPU上的计算着色器中完成。瓦片数据可以存储在一个扁平数组中；我们将在本章后面更详细地解释这个数据结构。
- en: Traditional light tiles require a depth pre-pass to determine the minimum and
    maximum *Z* values. This approach can suffer from depth discontinuities; however,
    the final data structure is usually densely packed, meaning we are not wasting
    memory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 传统光源瓦片需要深度预遍历来确定最小和最大 *Z* 值。这种方法可能会出现深度不连续性；然而，最终的数据结构通常是密集排列的，这意味着我们没有浪费内存。
- en: Light clusters
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光簇
- en: Light clusters subdivide the frustum in a 3D grid. As for tiles, lights are
    assigned to each cell, and at render time, we only iterate over the lights that
    a given fragment belongs to.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 光簇将视锥体细分为3D网格。至于瓦片，光源被分配到每个单元格，在渲染时，我们只遍历给定片段所属的灯光。
- en: 'The following figure illustrates the shape of the clusters for one of the camera
    axes. Each cluster is composed of a smaller frustum:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了相机轴之一簇的形状。每个簇由一个较小的视锥体组成：
- en: '![Figure 7.2 – The frustum clusters covered by a point light](img/B8395_07_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 被点光源覆盖的视锥体簇](img/B8395_07_02.jpg)'
- en: Figure 7.2 – The frustum clusters covered by a point light
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 被点光源覆盖的视锥体簇
- en: Lights can be stored in a 3D grid (a 3D texture, for instance) or more complex
    data structures – for example, a **Bounded Volume Hierarchy** (**BVH**) or octree.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 光源可以存储在3D网格中（例如，3D纹理）或更复杂的数据结构中——例如，**边界体积层次**（**BVH**）或八叉树。
- en: To build light clusters, we don’t need a depth pre-pass. Most implementations
    build **Axis Aligned Bounding Boxes** (**AABBs**) for each light and project them
    into clip space. This approach allows easy 3D lookups and, depending on the amount
    of memory that can be allocated for the data structure, it’s possible to achieve
    quite accurate results.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构建光簇时，我们不需要深度预遍历。大多数实现为每个光源构建**轴对齐边界框**（**AABBs**），并将它们投影到裁剪空间。这种方法允许轻松的3D查找，并且根据可以分配给数据结构的内存量，可以实现相当准确的结果。
- en: In this section, we have highlighted the advantages and disadvantages of both
    forward and Deferred Rendering. We have introduced tiling and clustering techniques
    that can help reduce the number of lights that need to be processed for each fragment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们强调了前向和延迟渲染的优缺点。我们介绍了可以帮助减少每个片段需要处理的灯光数量的分块和聚类技术。
- en: In the next section, we are going to provide an overview of our G-buffer implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将概述我们的G缓冲区实现。
- en: Implementing a G-buffer
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现G缓冲区
- en: 'From the beginning of this project, we decided we would implement a deferred
    renderer. It’s one of the more common approaches, and some of the render targets
    will be needed in later chapters for other techniques:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个项目的开始，我们就决定要实现一个延迟渲染器。这是更常见的方法之一，其中一些渲染目标将在后面的章节中用于其他技术：
- en: The first step in setting up multiple render targets in Vulkan is to create
    the framebuffers – the textures that will store the G-buffer data – and the render
    pass.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Vulkan中设置多个渲染目标的第一步是创建帧缓冲区——存储G缓冲区数据的纹理——和渲染通道。
- en: This step is automated, thanks to the frame graph (see [*Chapter 4*](B18395_04.xhtml#_idTextAnchor064)*,
    Implementing a Frame Graph*, for details); however, we want to highlight our use
    of a new Vulkan extension that simplifies render pass and framebuffer creation.
    The extension is `VK_KHR_dynamic_rendering`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步骤是自动化的，归功于帧图（参见[*第4章*](B18395_04.xhtml#_idTextAnchor064)*，实现帧图*，详情）；然而，我们想强调我们使用了一个简化渲染通道和帧缓冲区创建的新Vulkan扩展。该扩展是`VK_KHR_dynamic_rendering`。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This extension has become part of the core specification in Vulkan 1.3, so it’s
    possible to omit the `KHR` suffix on the data structures and API calls.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展已成为Vulkan 1.3的核心规范的一部分，因此可以在数据结构和API调用中省略`KHR`后缀。
- en: 'With this extension, we don’t have to worry about creating the render pass
    and framebuffers ahead of time. We’ll start by analyzing the changes required
    when creating a pipeline:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个扩展，我们不必担心提前创建渲染通道和帧缓冲区。我们将首先分析创建管道时所需的变化：
- en: '[PRE0]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have to populate a `VkPipelineRenderingCreateInfoKHR` structure with the
    number of attachments we are going to use and their format. We also need to specify
    the depth and stencil formats, if used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须填充一个`VkPipelineRenderingCreateInfoKHR`结构，其中包含我们将要使用的附件数量及其格式。我们还需要指定深度和模板格式，如果使用的话。
- en: Once this structure has been filled, we chain it to the `VkGraphicsPipelineCreateInfo`
    structure. When using this extension we don’t populate the `VkGraphicsPipelineCreateInfo::renderPass`
    member.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦填充了这个结构，我们就将其链接到 `VkGraphicsPipelineCreateInfo` 结构。当使用此扩展时，我们不填充 `VkGraphicsPipelineCreateInfo::renderPass`
    成员。
- en: 'At render time, instead of calling `vkCmdBeginRenderPass`, we call a new API,
    `vkCmdBeginRenderingKHR`. We start by creating an array to hold our `attachments`
    details:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染时，我们不是调用 `vkCmdBeginRenderPass`，而是调用一个新的 API，`vkCmdBeginRenderingKHR`。我们首先创建一个数组来保存我们的
    `attachments` 详细信息：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we populate each entry with the details of each attachment:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为每个条目填充每个附加的详细信息：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have to fill a similar data structure for the `depth` attachment:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须填充一个类似的数据结构用于 `depth` 附加：
- en: '[PRE41]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we fill the `VkRenderingInfoKHR` structure that will be passed to
    `vkCmdBeginRenderingKHR`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们填充 `VkRenderingInfoKHR` 结构，该结构将被传递给 `vkCmdBeginRenderingKHR`：
- en: '[PRE63]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Once we are done rendering, we are going to call `vkCmdEndRenderingKHR` instead
    of `vkCmdEndRenderPass`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦渲染完成，我们将调用 `vkCmdEndRenderingKHR` 而不是 `vkCmdEndRenderPass`。
- en: Now that we have set up our render targets, we are going to describe how they
    are used in our G-buffer shader. Our G-buffer has four render targets plus the
    depth buffer. As we mentioned in the previous section, there is no need for a
    depth pre-pass, although you might notice this was enabled in some of the earlier
    chapters for testing purposes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了渲染目标，我们将描述它们在我们 G 缓冲区着色器中的使用。我们的 G 缓冲区有四个渲染目标加上深度缓冲区。正如我们在上一节中提到的，不需要深度预传递，尽管您可能会注意到在早期的一些章节中为了测试目的已经启用了它。
- en: 'The first step is to declare multiple outputs in the fragment shader:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在片段着色器中声明多个输出：
- en: '[PRE81]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The location index must correspond to the order in which the attachments have
    been specified when calling `vkCmdBeginRenderingKHR` (or when creating the render
    pass and framebuffer objects). Writing to a given render target is done simply
    by writing to one of the variables we just declared:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 位置索引必须与调用 `vkCmdBeginRenderingKHR`（或创建渲染通道和帧缓冲区对象）时附加的顺序相对应。向给定的渲染目标写入是通过写入我们刚刚声明的变量之一来完成的：
- en: '[PRE82]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As we mentioned in the previous section, we must be conscious of memory usage.
    As you might have noticed, we only store two channels for normals. We use an octahedral
    encoding that allows storing only two values. We can reconstruct the full normal
    in the lighting pass.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，我们必须注意内存使用。如您所注意到的，我们只为法线存储两个通道。我们使用八面体编码，只允许存储两个值。我们可以在照明通道中重建完整的法线。
- en: 'Here’s the encoding function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是编码函数：
- en: '[PRE83]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And here is the decoding function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以及解码函数：
- en: '[PRE84]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The following table illustrates the data arrangement of our G-buffer pass:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了我们 G 缓冲区传递的数据排列：
- en: '![Table 7.1 – G-buffer memory layout](img/B18395_07_Table_01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![表 7.1 – G 缓冲区内存布局](img/B18395_07_Table_01.jpg)'
- en: Table 7.1 – G-buffer memory layout
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 – G 缓冲区内存布局
- en: 'Here are the screenshots for our render targets:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们渲染目标的截图：
- en: '![Figure 7.3 – From top to bottom: albedo, normals, and combined occlusion
    (red), roughness (green), and metalness (blue)](img/B8395_07_03.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 从上到下：反射率、法线和组合遮挡（红色）、粗糙度（绿色）和金属度（蓝色）](img/B8395_07_03.jpg)'
- en: 'Figure 7.3 – From top to bottom: albedo, normals, and combined occlusion (red),
    roughness (green), and metalness (blue)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 从上到下：反射率、法线和组合遮挡（红色）、粗糙度（绿色）和金属度（蓝色）
- en: 'We could probably reduce the number of render targets further: we know that
    in the G-buffer pass, we are only shading opaque objects, so we don’t need the
    alpha channel. Also, nothing prevents us from mixing data for different render
    targets – for instance, we could have something like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能进一步减少渲染目标的数量：我们知道在 G 缓冲区传递中，我们只对不透明对象进行着色，因此不需要 alpha 通道。也没有什么阻止我们混合不同渲染目标的数据——例如，我们可能有以下内容：
- en: '`r`, `g`, `b`, and `normal_1`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`、`g`、`b` 和 `normal_1`'
- en: '`normal_2`, `roughness`, `metalness`, and `occlusion`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`normal_2`、`roughness`、`metalness` 和 `occlusion`'
- en: '`emissive`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emissive`'
- en: We can also try to use different texture formats (**R11G11B10**, for example)
    to increase the accuracy of our data. We encourage you to experiment with different
    solutions and find the one that works best for your use case!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试使用不同的纹理格式（例如 **R11G11B10**）来提高我们数据精度。我们鼓励您尝试不同的解决方案，并找到最适合您用例的方法！
- en: In this section, we have introduced a new Vulkan extension that simplifies the
    creation and use of the render pass and framebuffer. We also provided details
    on the implementation of our G-buffer and highlighted potential optimizations.
    In the next section, we are going to look at the light clustering solution that
    we have implemented.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一个新的Vulkan扩展，该扩展简化了渲染通道和帧缓冲区的创建和使用。我们还提供了我们G缓冲区实现的详细信息，并强调了潜在的优化。在下一节中，我们将查看我们已实现的光簇解决方案。
- en: Implementing light clusters
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现光簇
- en: 'In this section, we are going to describe our implementation of the light clustering
    algorithm. It’s based on this presentation: [https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf](https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf).
    The main (and very smart) idea is to separate the *XY* plane from the *Z* range,
    combining the advantages of both tiling and clustering approaches. The algorithms
    are organized as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述我们的光簇算法实现。它基于这个演示：[https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf](https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf)。主要（并且非常聪明）的想法是将
    *XY* 平面与 *Z* 范围分开，结合了瓦片和聚类方法的优点。算法组织如下：
- en: We sort the lights by their depth value in camera space.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按相机空间中的深度值对灯光进行排序。
- en: We then divide the depth range into bins of equal size, although a logarithmic
    subdivision might work better depending on your depth range.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将深度范围划分为大小相等的箱，尽管根据您的深度范围，对数划分可能更好。
- en: Next, we assign the lights to each bin if their bounding box falls within the
    bin range. We only store the minimum and maximum light index for a given bin,
    so we only need 16 bits for each bin, unless you need more than 65,535 lights!
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果它们的边界框在箱范围内，我们将灯光分配给每个箱。我们只为给定箱存储最小和最大光索引，因此每个箱只需要16位，除非你需要超过65,535个灯光！
- en: We then divide the screen into tiles (8x8 pixels, in our case) and determine
    which lights cover a given tile. Each tile will store a bitfield representation
    for the active lights.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将屏幕划分为瓦片（在我们的例子中是8x8像素）并确定哪些灯光覆盖了给定的瓦片。每个瓦片将存储活动灯光的位字段表示。
- en: Given a fragment that we want to shade, we determine the depth of the fragment
    and read the bin index.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们想要着色的片段，我们确定片段的深度并读取箱索引。
- en: Finally, we iterate from the minimum to the maximum light index in that bin
    and read the corresponding tile to see whether the light is visible, this time
    using *x* and *y* coordinates to retrieve the tile.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从该箱中的最小光索引迭代到最大光索引，并读取相应的瓦片以查看光是否可见，这次使用 *x* 和 *y* 坐标来检索瓦片。
- en: This solution provides a very efficient way to loop through the active lights
    for a given fragment.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案为遍历给定片段的活动灯光提供了一种非常有效的方法。
- en: CPU lights assignment
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU灯光分配
- en: 'We’ll now look at the implementation. During each frame, we perform the following
    steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看实现过程。在每一帧中，我们执行以下步骤：
- en: 'We start by sorting the lights by their depth value:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先根据它们的深度值对灯光进行排序：
- en: '[PRE85]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: We compute the minimum and maximum point of the light sphere from the camera’s
    point of view. Notice that we use a closer `far` depth plane to gain precision
    in the depth range.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从相机的视角计算光球的最小和最大点。请注意，我们使用较近的 `far` 深度平面以在深度范围内获得精度。
- en: 'To avoid having to sort the light list, we only sort the light indices:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免对灯光列表进行排序，我们只对光索引进行排序：
- en: '[PRE117]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This optimization allows us to upload the light array only once, while we only
    need to update the light indices.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化使我们只需上传一次光数组，而只需更新光索引。
- en: 'Next, we proceed with the tile assignment. We start by defining our bitfield
    array and some helper variables that will be used to compute the index within
    the array:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们进行瓦片分配。我们首先定义我们的位字段数组和一些辅助变量，这些变量将用于在数组中计算索引：
- en: '[PRE128]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'We then transform the light position in camera space:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将相机空间中的光位置进行转换：
- en: '[PRE134]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: If the light is behind the camera, we don’t do any further processing.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果光在相机后面，我们不做任何进一步的处理。
- en: 'Next, we compute the corners of the AABB projected to clip space:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们计算AABB的角点在裁剪空间中的投影：
- en: '[PRE150]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'We then proceed to determine the size of the quad in screen space:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续确定屏幕空间中四边形的尺寸：
- en: '[PRE173]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: If the light is not visible on the screen, we move to the next light.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果光在屏幕上不可见，我们移动到下一个光。
- en: 'The final step is to set the bit for the light we are processing on all the
    tiles it covers:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在所有覆盖的瓦片上为正在处理的灯光设置位：
- en: '[PRE197]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: We then upload all the light tiles and bin data to the GPU.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将所有光瓦片和区间数据上传到GPU。
- en: 'At the end of this computation, we will have a bin table containing the minimum
    and maximum light ID for each depth slice. The following table illustrates an
    example of the values for the first few slices:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个计算结束时，我们将有一个包含每个深度切片的最小和最大光ID的区间表。以下表格展示了前几个切片的值示例：
- en: '![Table 7.2 – Example of the data contained in the depth bins](img/B18395_07_Table_02.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![表7.2 – 深度区间中包含的数据示例](img/B18395_07_Table_02.jpg)'
- en: Table 7.2 – Example of the data contained in the depth bins
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2 – 深度区间中包含的数据示例
- en: 'The other data structure we computed is a 2D array, where each entry contains
    a bitfield tracking the active lights for the corresponding screen tile. The following
    table presents an example of the content of this array:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算的其他数据结构是一个二维数组，其中每个条目包含一个位字段，用于跟踪对应屏幕瓦片的活动光。以下表格展示了这个数组的内容示例：
- en: '![Table 7.3 – Example of the bitfield values tracking the active lights per
    tile](img/B18395_07_Table_03.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![表7.3 – 每个瓦片跟踪活动光值的位字段值示例](img/B18395_07_Table_03.jpg)'
- en: Table 7.3 – Example of the bitfield values tracking the active lights per tile
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3 – 每个瓦片跟踪活动光值的位字段值示例
- en: In the preceding example, we have divided the screen into a 4x4 grid, and each
    tile entry has a bit set for every light that covers that tile. Note that each
    tile entry can be composed of multiple 32-bit values depending on the number of
    lights in the scene.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将屏幕划分为4x4的网格，每个瓦片条目都有一个位被设置，以表示覆盖该瓦片的光。请注意，每个瓦片条目可以由多个32位值组成，具体取决于场景中的光数量。
- en: In this section, we provided an overview of the algorithm we have implemented
    to assign lights to a given cluster. We then detailed the steps to implement the
    algorithm. In the next section, we are going to use the data we have just obtained
    to process lights on the GPU.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了我们实现的光分配给给定聚类的算法。然后我们详细说明了实现算法的步骤。在下一节中，我们将使用我们刚刚获得的数据在GPU上处理光。
- en: GPU light processing
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPU光处理
- en: 'Now that we have all the data we need on the GPU, we can use it in our lighting
    computation:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在GPU上有了所有需要的数据，我们可以在光照计算中使用它：
- en: 'We start by determining which depth bin our fragment belongs to:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先确定我们的片段属于哪个深度区间：
- en: '[PRE217]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'We extract the minimum and maximum light index, as they are going to be used
    in the light computation loop:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提取最小和最大光索引，因为它们将在光计算循环中使用：
- en: '[PRE226]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'We first determine the address in the tile bitfield array. Next, we check whether
    there are any lights in this depth bin:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先确定在瓦片位字段数组中的地址。接下来，我们检查这个深度区间中是否有光：
- en: '[PRE231]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'If `max_light_id` is `0`, it means we didn’t store any lights in this bin,
    so no lights will affect this fragment. Next, we loop over the lights for this
    depth bin:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`max_light_id`为`0`，这意味着我们没有在这个区间存储任何光，因此没有光会影响这个片段。接下来，我们遍历这个深度区间的光：
- en: '[PRE234]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'After we compute the word and bit index, we determine which lights from the
    depth bin also cover the screen tile:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们计算单词和位索引后，我们确定深度区间中的哪些光也覆盖了屏幕瓦片：
- en: '[PRE238]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: This concludes our light clustering algorithm. The shader code also contains
    an optimized version that makes use of the subgroup instructions to improve register
    utilization. There are plenty of comments to explain how it works.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的光聚类算法。着色器代码还包含了一个优化的版本，它利用子组指令来提高寄存器利用率。代码中有很多注释来解释它是如何工作的。
- en: We covered a fair amount of code in this section, so don’t worry if some things
    were not clear on the first read. We started by describing the steps of the algorithm.
    We then explained how the lights are sorted in depth bins and how we determine
    the lights that cover a given tile on the screen. Finally, we showed how these
    data structures are used in the lighting shader to determine which lights affect
    a given fragment.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了相当多的代码，所以如果你在第一次阅读时对某些内容不太清楚，请不要担心。我们首先描述了算法的步骤。然后解释了光如何在深度区间中排序，以及我们如何确定覆盖屏幕上给定瓦片的光。最后，我们展示了这些数据结构如何在光照着色器中用来确定哪些光照影响给定的片段。
- en: 'Note that this technique can be used both in forward and Deferred Rendering.
    Now that we have a performant lighting solution, one element is sorely missing
    from our scene: shadows! This will be the topic for the next chapter.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这项技术既可用于前向渲染，也可用于延迟渲染。现在我们已经有了一个性能良好的光照解决方案，但我们的场景中仍然缺少一个重要元素：阴影！这将是下一章的主题。
- en: Summary
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have implemented a light clustering solution. We started
    by explaining forward and Deferred Rendering techniques and their main advantages
    and shortcomings. Next, we described two approaches to group lights to reduce
    the computation needed to shade a single fragment.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了一个光聚类解决方案。我们首先解释了前向和延迟渲染技术及其主要优点和缺点。接下来，我们描述了两种将灯光分组以减少单个片段着色所需计算的方法。
- en: We then outlined our G-buffer implementation by listing the render targets that
    we use. We detailed our use of the `VK_KHR_dynamic_rendering` extension, which
    allows us to simplify the render pass and framebuffer use. We also highlighted
    the relevant code in the G-buffer shader to write to multiple render targets,
    and we provided the implementation for our normal encoding and decoding. In closing,
    we suggested some optimizations to further reduce the memory used by our G-buffer
    implementation.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过列出我们使用的渲染目标来概述了我们的G缓冲区实现。我们详细说明了我们使用`VK_KHR_dynamic_rendering`扩展的情况，该扩展使我们能够简化渲染通道和帧缓冲区的使用。我们还突出了G缓冲区着色器中写入多个渲染目标的相应代码，并提供了我们正常编码和解码的实现。最后，我们提出了一些优化建议，以进一步减少我们G缓冲区实现使用的内存。
- en: In the last section, we described the algorithm we selected to implement light
    clustering. We started by sorting the lights by their depth value into depth bins.
    We then proceeded to store the lights that affect a given screen tile using a
    bitfield array. Finally, we made use of these two data structures in our lighting
    shader to reduce the number of lights that need to be evaluated for each fragment.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们描述了我们选择的实现光聚类的算法。我们首先按深度值对灯光进行排序，将其放入深度桶中。然后，我们使用位字段数组存储影响给定屏幕瓦片的灯光。最后，我们在光照着色器中使用了这两个数据结构，以减少每个片段需要评估的灯光数量。
- en: Optimizing the lighting stage of any game or application is paramount to maintaining
    interactive frame rates. We described one possible solution, but other options
    are available, and we suggest you experiment with them to find the one that best
    suits your use case!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 优化任何游戏或应用程序的照明阶段对于保持交互式帧率至关重要。我们描述了一个可能的解决方案，但还有其他选项可用，我们建议您尝试它们，以找到最适合您用例的解决方案！
- en: 'Now that we have added many lights, the scene still looks flat as there''s
    one important element missing: shadows. That''s the topic for the next chapter!'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了许多灯光，但场景仍然看起来很平，因为还缺少一个重要元素：阴影。这就是下一章的主题！
- en: Further reading
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Some history about the first Deferred Rendering in the *Shrek* game, 2001:
    [https://sites.google.com/site/richgel99/the-early-history-of-deferred-shading-and-lighting](https://sites.google.com/site/richgel99/the-early-history-of-deferred-shading-and-lighting)'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于2001年《怪物史莱克》游戏中第一次延迟渲染的一些历史：[https://sites.google.com/site/richgel99/the-early-history-of-deferred-shading-and-lighting](https://sites.google.com/site/richgel99/the-early-history-of-deferred-shading-and-lighting)
- en: 'Stalker Deferred Rendering paper: [https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker)'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stalker延迟渲染论文：[https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker)
- en: 'This is one of the first papers that introduced the concept of clustered shading:
    [http://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf](http://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf)'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一篇最早介绍聚类着色概念的论文：[http://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf](http://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf)
- en: 'These two presentations are often cited as the inspiration for many implementations:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个演示经常被引用为许多实现的灵感来源：
- en: '[https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf](https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf)'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf](https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf)'
- en: '[http://www.humus.name/Articles/PracticalClusteredShading.pdf](http://www.humus.name/Articles/PracticalClusteredShading.pdf)'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.humus.name/Articles/PracticalClusteredShading.pdf](http://www.humus.name/Articles/PracticalClusteredShading.pdf)'
- en: 'In this chapter, we only covered point lights, but in practice, many other
    types of lights are used (spotlights, area lights, polygonal lights, and a few
    others). This article describes a way to determine the visibility of a spotlight
    approximated by a cone:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们只涵盖了点光源，但在实践中，还使用了许多其他类型的灯光（聚光灯、区域灯光、多边形灯光等）。本文描述了一种确定由圆锥近似的光聚光灯可见性的方法：
- en: '[https://bartwronski.com/2017/04/13/cull-that-cone/](https://bartwronski.com/2017/04/13/cull-that-cone/)'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bartwronski.com/2017/04/13/cull-that-cone/](https://bartwronski.com/2017/04/13/cull-that-cone/)'
- en: 'These presentations describe variants of the clustering techniques we described
    in this chapter:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些演示介绍了我们在本章中描述的聚类技术的变体：
- en: '[https://www.intel.com/content/dam/develop/external/us/en/documents/lauritzen-deferred-shading-siggraph-2010-181241.pdf](https://www.intel.com/content/dam/develop/external/us/en/documents/lauritzen-deferred-shading-siggraph-2010-181241.pdf)'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.intel.com/content/dam/develop/external/us/en/documents/lauritzen-deferred-shading-siggraph-2010-181241.pdf](https://www.intel.com/content/dam/develop/external/us/en/documents/lauritzen-deferred-shading-siggraph-2010-181241.pdf)'
- en: '[https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf](https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf)'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf](https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf)'
- en: '[https://www.ea.com/frostbite/news/parallel-graphics-in-frostbite-current-future](https://www.ea.com/frostbite/news/parallel-graphics-in-frostbite-current-future)'
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.ea.com/frostbite/news/parallel-graphics-in-frostbite-current-future](https://www.ea.com/frostbite/news/parallel-graphics-in-frostbite-current-future)'
