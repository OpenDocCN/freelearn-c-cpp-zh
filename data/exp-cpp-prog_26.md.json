["```cpp\n      #include <iostream>\n      #include <optional>\n      #include <algorithm>\n      #include <functional>\n      #include <iterator>\n      #include <map>\n      #include <vector>\n      #include <string>\n\n      using namespace std;\n```", "```cpp\n      template <typename T>\n      class trie\n      {\n          map<T, trie> tries;\n```", "```cpp\n      public:\n          template <typename It>\n          void insert(It it, It end_it) {\n              if (it == end_it) { return; }\n              tries[*it].insert(next(it), end_it);\n          }\n```", "```cpp\n          template <typename C>\n          void insert(const C &container) {\n              insert(begin(container), end(container));\n          }\n```", "```cpp\n          void insert(const initializer_list<T> &il) {\n              insert(begin(il), end(il));\n          }\n```", "```cpp\n          void print(vector<T> &v) const {\n              if (tries.empty()) {\n                  copy(begin(v), end(v), \n                       ostream_iterator<T>{cout, \" \"});\n                  cout << 'n';\n              }\n              for (const auto &p : tries) {\n                  v.push_back(p.first);\n                  p.second.print(v);\n                  v.pop_back();\n              }\n          }\n```", "```cpp\n          void print() const {\n              vector<T> v;\n              print(v);\n          }\n```", "```cpp\n          template <typename It>\n          optional<reference_wrapper<const trie>> \n          subtrie(It it, It end_it) const {\n              if (it == end_it) { return ref(*this); }\n              auto found (tries.find(*it));\n              if (found == end(tries)) { return {}; }\n\n              return found->second.subtrie(next(it), end_it);\n          }\n```", "```cpp\n          template <typename C>\n          auto subtrie(const C &c) { \n              return subtrie(begin(c), end(c));\n          }\n      };\n```", "```cpp\n      int main()\n      {\n          trie<string> t;\n\n          t.insert({\"hi\", \"how\", \"are\", \"you\"});\n          t.insert({\"hi\", \"i\", \"am\", \"great\", \"thanks\"});\n          t.insert({\"what\", \"are\", \"you\", \"doing\"});\n          t.insert({\"i\", \"am\", \"watching\", \"a\", \"movie\"});\n```", "```cpp\n          cout << \"recorded sentences:n\";\n          t.print();\n```", "```cpp\n          cout << \"npossible suggestions after \"hi\":n\";\n\n          if (auto st (t.subtrie(initializer_list<string>{\"hi\"})); \n              st) {\n              st->get().print();\n          }\n      }\n```", "```cpp\n      $ ./trie \n      recorded sentences:\n      hi how are you \n      hi i am great thanks \n      i am watching a movie \n      what are you doing \n\n      possible suggestions after \"hi\":\n      how are you \n      i am great thanks \n```", "```cpp\ntemplate <typename It>\nvoid trie::insert(It it, It end_it) {\n    if (it == end_it) { return; }\n    tries[*it].insert(next(it), end_it);\n}\n```", "```cpp\ntemplate <typename It>\noptional<reference_wrapper<const trie>> \nsubtrie(It it, It end_it) const {\n    if (it == end_it) { return ref(*this); }\n    auto found (tries.find(*it));\n    if (found == end(tries)) { return {}; }\n\n    return found->second.subtrie(next(it), end_it);\n}\n```", "```cpp\n      #include <iostream>\n      #include <optional>\n      #include <algorithm>\n      #include <functional>\n      #include <iterator>\n      #include <map>\n      #include <list>\n      #include <string>\n      #include <sstream>\n      #include <fstream>  \n\n      using namespace std;\n```", "```cpp\n      template <typename T>\n      class trie\n      {\n          map<T, trie> tries;\n\n      public:\n          template <typename It>\n          void insert(It it, It end_it) {\n              if (it == end_it) { return; }\n              tries[*it].insert(next(it), end_it);\n          }\n\n          template <typename C>\n          void insert(const C &container) {\n              insert(begin(container), end(container));\n          }\n\n          void insert(const initializer_list<T> &il) {\n              insert(begin(il), end(il));\n          }\n\n          void print(list<T> &l) const {\n              if (tries.empty()) {\n                  copy(begin(l), end(l), \n                       ostream_iterator<T>{cout, \" \"});\n                  cout << 'n';\n              }\n              for (const auto &p : tries) {\n                  l.push_back(p.first);\n                  p.second.print(l);\n                  l.pop_back();\n              }\n          }\n\n          void print() const {\n              list<T> l;\n              print(l);\n          }\n\n          template <typename It>\n          optional<reference_wrapper<const trie>>\n          subtrie(It it, It end_it) const {\n              if (it == end_it) { return ref(*this); }\n              auto found (tries.find(*it));\n              if (found == end(tries)) { return {}; }\n\n      return found->second.subtrie(next(it), end_it);\n          }\n\n          template <typename C>\n          auto subtrie(const C &c) const { \n              return subtrie(begin(c), end(c));\n          }\n      };\n```", "```cpp\n      static void prompt()\n      {\n          cout << \"Next input please:n > \";\n      }\n```", "```cpp\n      int main()\n      {\n          trie<string> t;\n\n          fstream infile {\"db.txt\"};\n          for (string line; getline(infile, line);) {\n              istringstream iss {line};\n              t.insert(istream_iterator<string>{iss}, {});\n          }\n```", "```cpp\n          prompt();\n          for (string line; getline(cin, line);) {\n              istringstream iss {line};\n```", "```cpp\n              if (auto st (t.subtrie(istream_iterator<string>{iss}, {})); \n                  st) {\n                  cout << \"Suggestions:n\";\n                  st->get().print();\n              } else {\n                  cout << \"No suggestions found.n\";\n              }\n```", "```cpp\n              cout << \"----------------n\";\n              prompt();\n          }\n      }\n```", "```cpp\n      do ghosts exist\n      do goldfish sleep\n      do guinea pigs bite\n      how wrong can you be\n      how could trump become president\n      how could this happen to me\n      how did bruce lee die\n      how did you learn c++\n      what would aliens look like\n      what would macgiver do\n      what would bjarne stroustrup do\n      ...\n```", "```cpp\n      hi how are you \n      hi i am great thanks \n      do ghosts exist\n      do goldfish sleep\n      do guinea pigs bite\n      how wrong can you be\n      how could trump become president\n      how could this happen to me\n      how did bruce lee die\n      how did you learn c++\n      what would aliens look like\n      what would macgiver do\n      what would bjarne stroustrup do\n      what would chuck norris do\n      why do cats like boxes\n      why does it rain\n      why is the sky blue\n      why do cats hate water\n      why do cats hate dogs\n      why is c++ so hard\n```", "```cpp\n      $ ./word_suggestion \n      Next input please:\n       > what would\n      Suggestions:\n      aliens look like \n      bjarne stroustrup do \n      chuck norris do \n      macgiver do \n      ----------------\n      Next input please:\n       > why do\n      Suggestions:\n      cats hate dogs \n      cats hate water \n      cats like boxes \n      ----------------\n      Next input please:\n       > \n```", "```cpp\nfstream infile {\"db.txt\"};\nfor (string line; getline(infile, line);) {\n    istringstream iss {line};\n    t.insert(istream_iterator<string>{iss}, {});\n}\n```", "```cpp\ncsignal fourier_transform(const csignal &s) { \n    csignal t(s.size()); \n    const double pol {-2.0 * M_PI / s.size()};\n\n    for (size_t k {0}; k < s.size(); ++k) { \n        for (size_t j {0}; j < s.size(); ++j) { \n            t[k] += s[j] * polar(1.0, pol * k * j); \n        }\n    } \n    return t; \n}\n```", "```cpp\n      #include <iostream>\n      #include <complex>\n      #include <vector>\n      #include <algorithm>\n      #include <iterator>\n      #include <numeric>\n      #include <valarray>\n      #include <cmath>      \n\n      using namespace std;\n```", "```cpp\n      using cmplx   = complex<double>;\n      using csignal = vector<cmplx>;\n```", "```cpp\n      class num_iterator {\n          size_t i;\n      public:\n          explicit num_iterator(size_t position) : i{position} {}\n\n          size_t operator*() const { return i; }\n\n          num_iterator& operator++() {\n              ++i;\n              return *this;\n          }\n\n          bool operator!=(const num_iterator &other) const {\n              return i != other.i;\n          }\n      };\n```", "```cpp\n      csignal fourier_transform(const csignal &s, bool back = false)\n      {\n          csignal t (s.size());\n```", "```cpp\n          const double pol {2.0 * M_PI * (back ? -1.0 : 1.0)};\n          const double div {back ? 1.0 : double(s.size())};\n```", "```cpp\n          auto sum_up ([=, &s] (size_t j) {\n              return [=, &s] (cmplx c, size_t k) {\n                  return c + s[k] * \n                      polar(1.0, pol * k * j / double(s.size()));\n              };\n          });\n```", "```cpp\n          auto to_ft ([=, &s](size_t j){\n              return accumulate(num_iterator{0}, \n                                num_iterator{s.size()}, \n                                cmplx{},\n                                sum_up(j))\n                  / div;\n          });\n```", "```cpp\n          transform(num_iterator{0}, num_iterator{s.size()}, \n                    begin(t), to_ft);\n\n          return t;\n      }\n```", "```cpp\n      static auto gen_cosine (size_t period_len){\n          return [period_len, n{0}] () mutable { \n              return cos(double(n++) * 2.0 * M_PI / period_len); \n          };\n      }\n```", "```cpp\n      static auto gen_square_wave (size_t period_len)\n      {\n          return [period_len, n{period_len*7/4}] () mutable {\n              return ((n++ * 2 / period_len) % 2) * 2 - 1.0;\n          };\n      }\n```", "```cpp\n      template <typename F>\n      static csignal signal_from_generator(size_t len, F gen)\n      {\n          csignal r (len);\n          generate(begin(r), end(r), gen);\n          return r;\n      }\n```", "```cpp\n      static void print_signal (const csignal &s)\n      {\n          auto real_val ([](cmplx c) { return c.real(); });\n          transform(begin(s), end(s), \n                    ostream_iterator<double>{cout, \" \"}, real_val);\n          cout << 'n';\n      }\n```", "```cpp\n      int main()\n      {\n          const size_t sig_len {100};\n```", "```cpp\n          auto cosine      (signal_from_generator(sig_len, \n                 gen_cosine(     sig_len / 2)));\n          auto square_wave (signal_from_generator(sig_len,\n                 gen_square_wave(sig_len / 2)));\n```", "```cpp\n          auto trans_sqw (fourier_transform(square_wave));\n\n          fill (next(begin(trans_sqw), 10), prev(end(trans_sqw), 10), 0);\n          auto mid (fourier_transform(trans_sqw, true));\n```", "```cpp\n          print_signal(cosine);\n          print_signal(fourier_transform(cosine));\n\n          print_signal(mid);\n          print_signal(trans_sqw);\n\n          print_signal(square_wave);\n          print_signal(fourier_transform(square_wave));\n      }\n```", "```cpp\nfor (size_t k {0}; k < s.size(); ++k) {\n    for (size_t j {0}; j < s.size(); ++j) {\n        t[k] += s[j] * polar(1.0, pol * k * j / double(s.size()));\n    }\n}\n```", "```cpp\ntransform(num_iterator{0}, num_iterator{s.size()}, ...\n    accumulate((num_iterator0}, num_iterator{s.size()}, ...\n        c + s[k] * polar(1.0, pol * k * j / double(s.size()));\n```", "```cpp\nstatic auto gen_cosine (size_t period_len)\n{\n    return [period_len, n{0}] () mutable {\n        return cos(double(n++) * 2.0 * M_PI / period_len);\n    };\n}\n```", "```cpp\ntemplate <typename F>\nstatic auto signal_from_generator(size_t len, F gen)\n{\n    csignal r (len);\n    generate(begin(r), end(r), gen);\n    return r;\n}\n```", "```cpp\n      #include <iostream>\n      #include <cmath>\n      #include <algorithm>\n      #include <numeric>\n      #include <vector>\n      #include <iterator>      \n\n      using namespace std;\n```", "```cpp\n      int main()\n      {\n          const size_t sig_len {100};\n          vector<double> as (sig_len); // a for analog\n          vector<int>    ds (sig_len); // d for digital\n```", "```cpp\n          auto sin_gen ([n{0}] () mutable { \n              return 5.0 * sin(n++ * 2.0 * M_PI / 100); \n          });\n\n          generate(begin(as), end(as), sin_gen);\n          copy(begin(as), end(as), begin(ds));\n```", "```cpp\n          copy(begin(as), end(as), \n               ostream_iterator<double>{cout, \" \"});\n          cout << 'n';\n          copy(begin(ds), end(ds), \n               ostream_iterator<double>{cout, \" \"});\n          cout << 'n';\n```", "```cpp\n          cout << inner_product(begin(as), end(as), begin(ds), \n                                0.0, std::plus<double>{},\n                                [](double a, double b) { \n                                    return pow(a - b, 2); \n                                }) \n               << 'n';\n      }\n```", "```cpp\ntemplate<class InIt1, class InIt2, class T, class F, class G>\nT inner_product(InIt1 it1, InIt1 end1, InIt2 it2, T val,\n                F bin_op1, G bin_op2)\n{\n    while (it1 != end1) {\n        val = bin_op1(val, bin_op2(*it1, *it2));\n        ++it1;\n        ++it2;\n    }\n    return value;\n}\n```", "```cpp\n      #include <iostream>\n      #include <algorithm>\n      #include <iterator>\n      #include <complex>\n      #include <numeric>\n      #include <vector>      \n\n      using namespace std;\n```", "```cpp\n      using cmplx = complex<double>;\n```", "```cpp\n      static auto scaler(int min_from, int max_from, \n                         double min_to, double max_to)\n      {\n          const int    w_from   {max_from - min_from};\n          const double w_to     {max_to - min_to};\n          const int    mid_from {(max_from - min_from) / 2 + min_from};\n          const double mid_to   {(max_to - min_to) / 2.0 + min_to};\n\n          return [=] (int from) {\n              return double(from - mid_from) / w_from * w_to + mid_to;\n          };\n      }\n```", "```cpp\n      template <typename A, typename B>\n      static auto scaled_cmplx(A scaler_x, B scaler_y)\n      {\n          return [=](int x, int y) {\n              return cmplx{scaler_x(x), scaler_y(y)};\n          };\n      }\n```", "```cpp\n      static auto mandelbrot_iterations(cmplx c)\n      {\n          cmplx z {};\n          size_t iterations {0};\n          const size_t max_iterations {1000};\n          while (abs(z) < 2 && iterations < max_iterations) {\n              ++iterations;\n              z = pow(z, 2) + c;\n          }\n          return iterations;\n      }\n```", "```cpp\n      int main()\n      {\n          const size_t w {100};\n          const size_t h {40};\n\n          auto scale (scaled_cmplx(\n              scaler(0, w, -2.0, 1.0),\n              scaler(0, h, -1.0, 1.0)\n          ));\n```", "```cpp\n          auto i_to_xy ([=](int i) { return scale(i % w, i / w); });\n```", "```cpp\n          auto to_iteration_count ([=](int i) { \n              return mandelbrot_iterations(i_to_xy(i));\n          });\n```", "```cpp\n          vector<int> v (w * h);\n          iota(begin(v), end(v), 0);\n          transform(begin(v), end(v), begin(v), to_iteration_count);\n```", "```cpp\n          auto binfunc ([w, n{0}] (auto output_it, int x) mutable {\n              *++output_it = (x > 50 ? '*' : ' ');\n              if (++n % w == 0) { ++output_it = 'n'; }\n              return output_it;\n          });\n```", "```cpp\n          accumulate(begin(v), end(v), ostream_iterator<char>{cout}, \n                     binfunc);\n      }\n```", "```cpp\nvector<int> v (w * h);\niota(begin(v), end(v), 0);\ntransform(begin(v), end(v), begin(v), to_iteration_count);\n```", "```cpp\n      #include <iostream>\n      #include <string>\n      #include <algorithm>\n      #include <iterator>\n      #include <list>      \n\n      using namespace std;\n```", "```cpp\n      template <typename InIt, typename OutIt, typename T, typename F>\n      InIt split(InIt it, InIt end_it, OutIt out_it, T split_val, \n                 F bin_func)\n      {\n          while (it != end_it) {\n              auto slice_end (find(it, end_it, split_val));\n              *out_it++ = bin_func(it, slice_end);\n\n              if (slice_end == end_it) { return end_it; }\n              it = next(slice_end);\n          }\n          return it;\n      }\n```", "```cpp\n      int main()\n      {\n          const string s {\"a-b-c-d-e-f-g\"};\n```", "```cpp\n          auto binfunc ([](auto it_a, auto it_b) {\n              return string(it_a, it_b);\n          });\n```", "```cpp\n          list<string> l;\n          split(begin(s), end(s), back_inserter(l), '-', binfunc);\n```", "```cpp\n          copy(begin(l), end(l), ostream_iterator<string>{cout, \"n\"});\n      }\n```", "```cpp\n      $ ./split \n      a\n      b\n      c\n      d\n      e\n      f\n      g\n```", "```cpp\ntemplate <typename InIt, typename OutIt, typename T, typename F>\nInIt split(InIt it, InIt end_it, OutIt out_it, T split_val, F bin_func)\n{\n    while (it != end_it) {\n        auto slice_end (find(it, end_it, split_val));\n        *out_it++ = bin_func(it, slice_end);\n\n        if (slice_end == end_it) { return end_it; }\n        it = next(slice_end);\n    }\n    return it;\n}\n```", "```cpp\n[](auto it_a, auto it_b) {\n    return string(it_a, it_b);\n}\n```", "```cpp\nstring s {\"a-b-c-d-e-f-g\"};\nlist<string> l;\n\nauto binfunc ([](auto it_a, auto it_b) {\n    return string(it_a, it_b);\n});\n\ncopy(split_iterator{begin(s), end(s), \u2018-\u2018, binfunc},{}, back_inserter(l));\n```", "```cpp\n      #include <iostream>\n      #include <algorithm>\n      #include <string>\n      #include <functional>      \n\n      using namespace std;\n```", "```cpp\n      template <typename It, typename F>\n      pair<It, It> gather(It first, It last, It gather_pos, F predicate)\n      {\n          return {stable_partition(first, gather_pos, not_fn(predicate)),\n                  stable_partition(gather_pos, last, predicate)};\n      }\n```", "```cpp\n      template <typename It>\n\n      void gather_sort(It first, It last, It gather_pos)\n\n      {\n\n        using T = typename std::iterator_traits<It>::value_type;\n\n        stable_sort(first, gather_pos, greater<T>{});\n\n        stable_sort(gather_pos, last, less<T>{});\n\n      }\n```", "```cpp\n      int main()\n      {\n          auto is_a ([](char c) { return c == 'a'; });\n          string a {\"a_a_a_a_a_a_a_a_a_a_a\"};\n```", "```cpp\n          auto middle (begin(a) + a.size() / 2);\n\n          gather(begin(a), end(a), middle, is_a);\n          cout << a << 'n';\n```", "```cpp\n          gather(begin(a), end(a), begin(a), is_a);\n          cout << a << 'n';\n```", "```cpp\n          gather(begin(a), end(a), end(a), is_a);\n          cout << a << 'n';\n```", "```cpp\n          // This will NOT work as naively expected\n          gather(begin(a), end(a), middle, is_a);\n          cout << a << 'n';\n```", "```cpp\n          string b {\"_9_2_4_7_3_8_1_6_5_0_\"};\n          gather_sort(begin(b), end(b), begin(b) + b.size() / 2, \n                      less<char>{});\n          cout << b << 'n';\n      }\n```", "```cpp\n      $ ./gather \n      _____aaaaaaaaaaa_____\n      aaaaaaaaaaa__________\n      __________aaaaaaaaaaa\n      __________aaaaaaaaaaa\n      _____9743201568______\n```", "```cpp\n      #include <iostream>\n      #include <string>\n      #include <algorithm>      \n\n      using namespace std;\n```", "```cpp\n      template <typename It>\n      It remove_multi_whitespace(It it, It end_it)\n      {\n          return unique(it, end_it, [](const auto &a, const auto &b) {\n              return isspace(a) && isspace(b);\n          });\n      }\n```", "```cpp\n      int main()\n      {\n          string s {\"fooo     bar    t   baz\"};\n\n          cout << s << 'n';\n```", "```cpp\n          s.erase(remove_multi_whitespace(begin(s), end(s)), end(s));\n\n          cout << s << 'n';\n      }\n```", "```cpp\n      $ ./remove_consecutive_whitespace \n      fooo     bar        baz\n      fooo bar baz\n```", "```cpp\ntemplate<typename It, typename P>\nIt unique(It it, It end, P p)\n{\n    if (it == end) { return end; }\n\n    It result {it};\n    while (++it != end) {\n        if (!p(*result, *it) && ++result != it) {\n            *result = std::move(*it);\n        }\n    }\n    return ++result;\n}\n```", "```cpp\ns.erase(remove_multi_whitespace(begin(s), end(s)), end(s));\n```", "```cpp\n      #include <iostream>\n      #include <string>\n      #include <algorithm>\n      #include <sstream>\n      #include <tuple>      \n\n      using namespace std;\n```", "```cpp\n      template <typename It>\n      tuple<It, char, size_t> occurrences(It it, It end_it)\n      {\n          if (it == end_it) { return {it, '?', 0}; }\n\n          const char c {*it};\n          const auto diff (find_if(it, end_it, \n                           [c](char x) { return c != x; }));\n\n          return {diff, c, distance(it, diff)};\n      }\n```", "```cpp\n      string compress(const string &s)\n      {\n          const auto end_it (end(s));\n          stringstream r;\n\n          for (auto it (begin(s)); it != end_it;) {\n              const auto [next_diff, c, n] (occurrences(it, end_it));\n              r << c << n;\n              it = next_diff;\n          }\n\n          return r.str();\n      }\n```", "```cpp\n      string decompress(const string &s)\n      {\n          stringstream ss{s};\n          stringstream r;\n\n          char c;\n          size_t n;\n          while (ss >> c >> n) { r << string(n, c); }\n\n          return r.str();\n      }\n```", "```cpp\n      int main()\n      { \n          string s {\"aaaaaaaaabbbbbbbbbccccccccccc\"};\n          cout << compress(s) << 'n';\n          cout << decompress(compress(s)) << 'n';\n      }\n```", "```cpp\n      $ ./compress\n      a9b9c11\n      aaaaaaaaabbbbbbbbbccccccccccc\n```", "```cpp\nwhile (ss >> c >> n) { r << string(n, c); }\n```", "```cpp\nfor (auto it (begin(s)); it != end_it;) { \n    const auto [next_diff, c, n] (occurrences(it, end_it)); \n    r << c << n; \n    it = next_diff; \n}\n```"]