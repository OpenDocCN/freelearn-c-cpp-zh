- en: '*Chapter 9*: High-Performance C++'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：高性能C++'
- en: In this chapter, we switch focus from the optimal use of the hardware resources
    to the optimal application of a particular programming language. While everything
    we have learned so far can be applied, usually quite straightforwardly, to any
    program in any language, this chapter deals with C++ features and idiosyncrasies.
    You will learn which features of the C++ language are likely to cause performance
    problems and how to avoid them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把重点从硬件资源的最佳使用转移到特定编程语言的最佳应用。尽管到目前为止我们学到的一切都可以应用于任何语言的任何程序，但本章涉及C++的特性和特殊性。你将学会哪些C++语言特性可能会导致性能问题，以及如何避免它们。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Efficiency and overhead of the C++ language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++语言的效率和开销
- en: Learning to notice likely inefficiencies in the use of C++ language constructs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会注意C++语言结构的可能低效性
- en: Avoiding inefficient C++ code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免低效的C++代码
- en: Optimizing memory access and conditional operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化内存访问和条件操作
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Again, you will need a C++ compiler and a micro-benchmarking tool, such as the
    **Google Benchmark** library we used in the previous chapter (found at [https://github.com/google/benchmark](https://github.com/google/benchmark)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你需要一个C++编译器和一个微基准测试工具，比如我们在上一章中使用的**Google Benchmark**库（在[https://github.com/google/benchmark](https://github.com/google/benchmark)找到）。
- en: The code accompanying this chapter can be found at [https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter09](https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter09).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter09](https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter09)找到。
- en: 'You will also need a way to examine the assembly code generated by the compiler:
    many development environments have an option to display assembly; GCC and Clang
    can write out the assembly instead of the object code; debuggers and other tools
    can generate assembly from the object code (disassemble it). It''s a matter of
    personal preference which tool you use.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一种方法来检查编译器生成的汇编代码：许多开发环境都有显示汇编的选项；GCC和Clang可以将汇编写出来而不是目标代码；调试器和其他工具可以从目标代码生成汇编（反汇编）。你可以根据个人喜好选择使用哪种工具。
- en: What is the efficiency of a programming language?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程语言的效率是什么？
- en: Programmers often talk about a language being efficient or otherwise. C++, in
    particular, has been developed with the explicit goal of efficiency and, at the
    same time, has a reputation in some circles of being inefficient. How can this
    be?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常谈论一种语言是否高效。特别是C++，它的开发明确目标是效率，同时在某些领域却有低效的声誉。这是怎么回事呢？
- en: '*Efficiency* can mean different things in different contexts or to different
    people. For example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*效率*在不同的上下文或不同的人看来可能有不同的含义。例如：'
- en: 'C++ design follows the principle of **zero overhead**: with a handful of exceptions,
    you don’t pay any runtime cost for any feature you do not use just because it
    is present in the language. In this sense, it is as efficient as a language can
    be.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++的设计遵循**零开销**的原则：除了少数例外，如果你不使用某个特性，你就不需要为它付出任何运行时成本，即使它存在于语言中。从这个意义上说，它是一种高效的语言。
- en: You obviously have to pay something for the language features you do use, at
    least if they translate into some runtime work. C++ is very good about not requiring
    any runtime code for doing work that can be done during compilation (although
    the implementations of the compilers and the standard libraries vary in their
    efficiency). An efficient language does not add any overhead to the code that
    must be generated to carry out the requested work, and again, C++ is quite good
    here, with one major caveat we will discuss next.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，你必须为你使用的语言特性付出一些代价，至少如果它们转化为一些运行时工作的话。C++非常擅长不需要任何运行时代码来执行编译时可以完成的工作（尽管编译器和标准库的实现在效率上有所不同）。一种高效的语言不会给必须生成的代码增加任何开销，而在这方面，C++做得相当不错，但我们将在下面讨论一个主要的警告。
- en: 'If the preceding is true, how did C++ earn the label of *inefficient* from
    those who hold this opinion? Now we come to yet another perspective on efficiency:
    how easy is it to write efficient code in this language? Or, how easy is it to
    do something that seems natural but, in fact, is a very inefficient way of solving
    the problem? A closely related problem is the one we alluded to in the last paragraph:
    C++ is very efficient in doing exactly what you asked it to do. But it is not
    always easy to express exactly what you want in the language, and, again, the
    natural way of writing the code sometimes imposes additional requirements or constraints
    that the programmer did not want and may not be aware of. These constraints have
    runtime costs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前面的观点是正确的，那么为什么C++会被认为是*低效*的？现在我们来看另一个效率的角度：在这种语言中编写高效的代码有多容易？或者，用一种看似自然但实际上是解决问题的非常低效的方式有多容易？一个密切相关的问题是我们在上一段提到的：C++在做你要求它做的事情时非常高效。但是在语言中表达你想要的并不总是容易的，而且，编写代码的自然方式有时会施加额外的要求或约束，程序员可能并不想要，也可能不知道。这些约束会产生运行时成本。
- en: 'From the point of view of the language designer, the last problem is not a
    language inefficiency: you asked the machine to do X and Y, it costs time to do
    X and Y, we’re not doing anything beyond what you asked us to do. But from the
    point of view of the programmer, this is an inefficient language if the programmer
    only wanted to do X but didn’t care about Y.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从语言设计师的角度来看，最后一个问题并不是语言的低效性：你让机器做X和Y，做X和Y需要时间，我们并没有做超出你要求我们做的事情。但从程序员的角度来看，如果程序员只想做X而不关心Y，这就是一种低效的语言。
- en: 'It is the goal of this chapter to help you write code that clearly expresses
    what you want the machine to do. The purpose is two-fold: you may think that your
    primary *audience* is the compiler: by precisely describing what you want and
    what the compiler is free to change, you give the compiler the freedom to generate
    more efficient code. But the same can be said about the readers of your program:
    they can only infer what you expressed in the code, not what you intended to express.
    Is it safe to optimize your code if it changes certain aspects of its behavior?
    Was this behavior intentional or an accident of the implementation that can be
    altered? Once again, we are reminded that programming is primarily a way of communicating
    with our peers, and only then with the machines.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是帮助您编写清晰表达您想让机器执行的代码。目的是双重的：您可能认为您的主要*受众*是编译器：通过精确描述您想要的内容以及编译器可以自由更改的内容，您给予编译器生成更有效代码的自由。但对于您程序的读者也可以这样说：他们只能推断您在代码中表达的内容，而不是您打算表达的内容。如果优化代码会改变其行为的某些方面，这样做是否安全？这种行为是有意的还是实现的意外可以改变的？我们再次被提醒，编程主要是与我们的同行交流的一种方式，然后才是与机器交流。
- en: We will start with the simpler inefficiencies that seem easy to avoid, but they
    crop up even in the code of programmers who have mastered other aspects of the
    language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从看似容易避免的简单低效开始，但即使是掌握了语言的其他方面的程序员的代码中也会出现这些问题。
- en: Unnecessary copying
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不必要的复制
- en: 'Unnecessary copying of objects is probably *C++ inefficiency #1*. The main
    reason is that it’s easy to do and hard to notice. Consider the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的不必要复制可能是*C++效率问题#1*。主要原因是这样做很容易，很难注意到。考虑以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How many copies of the vector `v` are made in this program? The answer depends
    on the details of the functions `make_v()` and `do_work()` as well as the compiler
    optimizations. This tiny example covers several language subtleties that we will
    now discuss.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，向量`v`被复制了多少次？答案取决于函数`make_v()`和`do_work()`的细节以及编译器的优化。这个小例子涵盖了我们将要讨论的几个语言细微差别。
- en: Copying and argument passing
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制和参数传递
- en: 'We are going to start with the second function, `do_work()`. What matters here
    is the declaration: if the function takes the argument by reference, `const` or
    not, then no copies are made.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第二个函数`do_work()`开始。这里重要的是声明：如果函数通过引用，`const`或不是，接受参数，那么不会进行复制。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the function uses pass-by-value, then a copy must be made:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数使用按值传递，那么必须进行复制：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Copying a vector is an expensive operation if the vector is large: all the
    data in the vector must be copied. This is one expensive function call. If the
    work itself does not require a copy of the vector, then it’s also extremely inefficient.
    For example, if all we need is to compute the sum (or some other function) of
    all the elements in the vector, we do not need a copy. While it may seem undesirable,
    at first glance, that the call itself does not tell us whether the copy is made,
    it is how it should be. The decision to make the copy belongs to the implementer
    of the function and can be made only after considering the requirements and the
    choice of the algorithm. For the previously mentioned problem of accumulating
    the sum of all elements, the correct decision is clearly to pass the vector by
    (`const`) reference as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向量很大，复制向量是一个昂贵的操作：必须复制向量中的所有数据。这是一个昂贵的函数调用。如果工作本身不需要向量的副本，那么它也是极其低效的。例如，如果我们只需要计算向量中所有元素的和（或其他函数），我们不需要复制。虽然乍一看似乎不太理想，调用本身并不告诉我们是否进行了复制，但这就是应该的。是否进行复制的决定属于函数的实现者，并且只有在考虑要求和算法选择之后才能做出。对于前面提到的累加所有元素和的问题，正确的决定显然是通过（const）引用传递向量如下：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using pass-by-value, in this case, is such a blatant inefficiency that it may
    be considered a bug, but it happens more often than you’d think. In particular,
    it happens in template code where the author considered only small, lightweight
    data types, but the code ends up being used wider than expected.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用按值传递是如此明显的低效，以至于它可能被认为是一个错误，但它发生的频率比你想象的要多。特别是在模板代码中，作者只考虑了小型、轻量级的数据类型，但代码最终被更广泛地使用。
- en: 'On the other hand, if we need to create a copy of the arguments as a part of
    fulfilling the requirements on the function, using parameter passing is as good
    of a way as any:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们需要创建参数的副本作为满足函数要求的一部分，使用参数传递是一个很好的方式：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we need to apply a so-called clamping loop to the data before processing
    it further. Assuming we read the clamped values many times, calling `std::min()`
    for every access may be less efficient than creating a cached copy of the result.
    We could make an explicit copy as well, and it may be slightly more efficient,
    but this kind of optimization should not be left to speculation; it can be definitively
    answered only by a benchmark.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要在进一步处理数据之前应用所谓的夹紧循环。假设我们多次读取夹紧的值，为每次访问调用`std::min()`可能不如创建结果的缓存副本效率高。我们也可以做一个显式的复制，这可能稍微更有效，但这种优化不应该留给猜测；只有通过基准测试才能得到明确的答案。
- en: 'C++11 introduced **move semantics** as a partial answer to unnecessary copying.
    In our case, we observe that if the function argument is an r-value, we can use
    it any way we want, including altering it (the caller has no way of accessing
    the object after the call completes). The usual way to take advantage of the move
    semantics is to overload the function with an r-value reference version:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了**移动语义**作为不必要复制的部分答案。在我们的例子中，我们观察到如果函数参数是一个r值，我们可以以任何方式使用它，包括改变它（调用完成后，调用者无法访问对象）。利用移动语义的常规方式是用r值引用版本重载函数：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, if the object itself is move-enabled, our simple pass-by-value version
    shines in the new light. Refer to the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果对象本身是可移动的，我们简单的按值传递版本在新的光芒下闪耀。参考以下代码：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first call to `do_work()` uses an l-value argument, so a local copy is made
    inside the function (the argument is passed by value!). The second call uses an
    r-value or an unnamed temporary. Since the vector has a move constructor, the
    function argument is moved (not copied!) into its parameter, and moving vectors
    is very fast. Now with a single implementation of the function, without any overloads,
    we can handle both the r-value and the l-value arguments efficiently.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对`do_work()`的第一次调用使用了一个l-value参数，因此在函数内部进行了一个本地复制（参数是按值传递的！）。第二次调用使用了一个r-value或一个无名临时对象。由于向量具有移动构造函数，函数参数被移动（而不是复制！）到其参数中，移动向量非常快。现在，通过一个函数的单一实现，没有任何重载，我们可以高效地处理r-value和l-value参数。
- en: Now we have seen the two extreme examples. In the first case, a copy of the
    argument was not needed, and creating one was pure inefficiency. In the second
    case, making a copy was a reasonable implementation. Not every situation falls
    into one of these extremes, as we are about to see.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了两个极端的例子。在第一种情况下，不需要参数的复制，创建一个纯粹是低效的。在第二种情况下，进行复制是一个合理的实现。并不是每种情况都属于这两个极端之一，正如我们将要看到的那样。
- en: Copying as an implementation technique
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为实现技术的复制
- en: 'There is also the middle ground where the chosen implementation needs a copy
    of the argument, but the implementation itself is not optimal. As an example,
    consider the following function that needs to print the vector in the sorted order:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种中间地带，选择的实现需要参数的复制，但实现本身并不是最佳的。例如，考虑下面需要按排序顺序打印向量的函数：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For a vector of integers, this is probably the best way. We sort the container
    itself and print it in order. Since we are not supposed to modify the original
    container, we need a copy, and, again, there is nothing wrong with exploiting
    the compiler to make one.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数向量，这可能是最佳的方式。我们对容器本身进行排序，并按顺序打印它。由于我们不应该修改原始容器，我们需要一个副本，再次利用编译器进行复制也没有问题。
- en: 'But what if the elements of the vector were not integers but some large objects?
    In this case, copying the vector takes a lot of memory, and sorting it takes a
    lot of time spent copying large objects. In this case, a better implementation
    may be to create and sort a vector of pointers without moving the original objects:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果向量的元素不是整数，而是一些大对象呢？在这种情况下，复制向量需要大量内存，并且对大对象进行排序需要大量时间。在这种情况下，更好的实现可能是创建并对指针向量进行排序，而不移动原始对象：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since we have learned by now to never guess about performance, the intuition
    needs to be confirmed by a benchmark. Since sorting an already sorted vector does
    not require any copying, we want a fresh, unsorted vector for every iteration
    of the benchmark, like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经学会了永远不要猜测性能，直觉需要通过基准测试来确认。由于对已排序的向量进行排序不需要进行任何复制，我们希望在基准测试的每次迭代中都有一个新的、未排序的向量，如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Of course, we should disable the actual printing since we are not interested
    in benchmarking the I/O. On the other hand, we should benchmark copying the vector
    without sorting, just so we know what portion of the measured time is spent in
    setting up the test.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该禁用实际的打印，因为我们不关心对I/O进行基准测试。另一方面，我们应该对向量进行复制而不进行排序的基准测试，这样我们就知道测量时间的哪一部分用于设置测试。
- en: 'The benchmark confirms that, for integers, it is faster to copy the entire
    vector and sort a copy:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试证实，对于整数来说，复制整个向量并对副本进行排序更快：
- en: '![Figure 9.1 – Benchmark of sorting a vector of integers, copying versus pointer
    indirection'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 - 对整数向量进行排序的基准测试，复制与指针间接'
- en: '](img/Figure_9.1_B16229.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B16229.jpg)'
- en: Figure 9.1 – Benchmark of sorting a vector of integers, copying versus pointer
    indirection
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 - 对整数向量进行排序的基准测试，复制与指针间接
- en: 'Note that if the vector is small and all the data fits in the low-level cache,
    the processing is very fast either way, and there is little speed difference.
    If the objects are large and expensive to copy, the indirection becomes relatively
    more efficient:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果向量很小且所有数据都适合低级缓存，那么处理速度无论如何都非常快，速度几乎没有差异。如果对象很大且复制成本很高，那么间接引用相对更有效：
- en: '![Figure 9.2 – Benchmark of sorting a vector of large objects, copying versus
    pointer indirection'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 - 对大对象向量进行排序的基准测试，复制与指针间接'
- en: '](img/Figure_9.2_B16229.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B16229.jpg)'
- en: Figure 9.2 – Benchmark of sorting a vector of large objects, copying versus
    pointer indirection
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 - 对大对象向量进行排序的基准测试，复制与指针间接
- en: There is yet another special case when copying objects is necessary for the
    implementation; we will consider it next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现时，还有另一种特殊情况需要复制对象；我们将在下面考虑这种情况。
- en: Copying to store data
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制以存储数据
- en: 'In C++, we can encounter another particular case of data copying. It happens
    most often in class constructors where the object must store a copy of the data,
    so a long-term copy with a lifetime exceeding that of the constructor call must
    be created. Consider this example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们可能会遇到另一种数据复制的特殊情况。它最常发生在类构造函数中，其中对象必须存储数据的副本，因此必须创建一个超出构造函数调用寿命的长期复制。考虑以下示例：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here the intent is to make a copy. The inefficiency would be to make multiple
    intermediate copies or make an unnecessary copy. The standard way to accomplish
    this is to take the object by `const` reference and make a copy inside the class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的意图是进行复制。低效的做法是进行多次中间复制或进行不必要的复制。实现这一点的标准方法是通过`const`引用获取对象，并在类内部进行复制：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the argument of the constructor is an l-value, this is as efficient as it
    can be. However, if the argument is an r-value (a temporary), we would prefer
    to move it into the class and make no copies at all. This requires an overload
    for the constructor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数的参数是一个l-value，这是它可以达到的最高效率。但是，如果参数是一个r-value（临时对象），我们更希望将其移动到类中，并且根本不进行复制。这需要为构造函数进行重载：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The downside is the need to code two constructors, but it gets worse if the
    constructor takes several arguments, and each one needs to be copied or moved.
    Following this pattern, we would need 6 constructor overloads to handle 3 parameters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是需要编写两个构造函数，但如果构造函数需要多个参数，并且每个参数都需要被复制或移动，情况会变得更糟。按照这种模式，我们需要6个构造函数重载来处理3个参数。
- en: 'The alternative is to pass all parameters by value and *move* from the parameter,
    check the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过值传递所有参数并*从参数中*移动，检查以下代码：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is very important to remember that the parameter `v` is now an x-value (an
    object in a moved-from state), and it should not be used in the body of the constructor.
    If the argument is an l-value, a copy is made to construct the parameter `v`,
    then moved into the class. If the argument is an r-value, it is moved into the
    parameter `v` and again moved into the class. This pattern works great if the
    objects are cheap to move. However, if the objects are expensive to move or have
    no move constructors at all (so they are copied instead), we end up doing two
    copies instead of one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要记住，参数`v`现在是一个x值（处于移动状态的对象），不应该在构造函数的主体中使用。如果参数是l值，将进行一次复制以构造参数`v`，然后移动到类中。如果参数是r值，则将其移动到参数`v`中，然后再移动到类中。如果对象移动起来很便宜，这种模式效果很好。但是，如果对象移动起来很昂贵，或者根本没有移动构造函数（因此会被复制），我们最终会做两次复制而不是一次。
- en: So far, we have focused on the problem of getting data into functions and objects.
    But copying can also occur when we need to return the results. The considerations
    there are completely different and need to be examined separately.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经专注于将数据传递给函数和对象的问题。但是在需要返回结果时，也可能发生复制。这些考虑是完全不同的，需要单独进行检查。
- en: Copying of return values
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值的复制
- en: 'Our example at the very beginning of this section included both kinds of copying.
    In particular, this line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节开头的示例中包括了两种复制。特别是这一行：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It implies that the resulting vector `v` is created from another vector, the
    one returned by the function `make_v`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着生成的向量`v`是从另一个向量创建的，即函数`make_v`返回的向量：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In theory, more than one copy can be made here: the local variable `vtmp` is
    copied into the (unnamed) return value of the function `make_v`, which is, in
    turn, copied into the final result `v`. In practice, this is not going to happen.
    First of all, the unnamed temporary return value of `make_v` is moved, not copied,
    into `v`. But, most likely, even this is not going to happen. If you try this
    code with your own class instead of `std::vector`, you will see that neither a
    copy nor a move constructor is used:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这里可能会产生多个副本：局部变量`vtmp`被复制到函数`make_v`的（无名）返回值中，然后又被复制到最终结果`v`中。实际上，这是不会发生的。首先，函数`make_v`的无名临时返回值被移动而不是复制到`v`中。但是，最有可能的是，这也不会发生。如果您尝试使用自己的类而不是`std::vector`来运行此代码，您会发现既没有使用复制构造函数也没有使用移动构造函数：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This program prints something like the following (on most compilers, a certain
    level of optimization must be turned on):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序打印出类似以下内容的东西（在大多数编译器上，必须打开一定级别的优化）：
- en: '![Figure 9.3 – The output of the program returning an object by value'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 - 程序返回对象的输出'
- en: '](img/Figure_9.3_B16229.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B16229.jpg)'
- en: Figure 9.3 – The output of the program returning an object by value
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 - 程序返回对象的输出
- en: 'As you can see, only one object was constructed and destroyed. This is the
    result of the compiler optimization. The specific optimization that is used here
    is known as `ctmp`, the unnamed temporary return value, and the final result `c`
    – are all of the same type. Furthermore, it is impossible for any code we write
    to observe any two of these variables at the same time. Therefore, without changing
    any observable behavior, the compiler can use the same memory location for all
    three variables. Before calling the function, the compiler needs to allocate the
    memory where the eventual result `c` will be constructed. The address of this
    memory is passed into the function by the compiler, where it is used to construct
    the local variable `ctmp` at the same location. As a result, when the function
    `makeC` ends, there is nothing to return at all: the result is already where it
    should be. This is the RVO in a nutshell.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，只构造和销毁了一个对象。这是编译器优化的结果。这里使用的特定优化被称为`ctmp`，无名临时返回值和最终结果`c` - 都是相同类型。此外，我们编写的任何代码都不可能同时观察到这三个变量中的任何两个。因此，在不改变任何可观察行为的情况下，编译器可以使用相同的内存位置来存储所有三个变量。在调用函数之前，编译器需要分配内存，用于构造最终结果`c`的位置。编译器将这个内存地址传递给函数，在函数中用于在相同位置构造局部变量`ctmp`。结果是，当函数`makeC`结束时，根本没有什么需要返回的：结果已经在应该的地方。这就是RVO的要点。
- en: While RVO seems simple, it has several subtleties.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管RVO看起来很简单，但它有几个微妙之处。
- en: 'First, remember that this is an optimization. This means that the compiler
    usually does not have to do it (if yours doesn’t, you need a better compiler).
    However, it is a very special kind of optimization. In general, the compiler can
    do whatever it wants to your program as long as it does not change the observable
    behavior. The observable behavior includes input and output and accessing volatile
    memory. This optimization, however, has resulted in an observable change: the
    expected output of the copy constructor and the matching destructor is nowhere
    to be seen. Indeed, this is one exception from the otherwise ironclad rule: *the
    compiler is allowed to eliminate calls to copy or move constructors and the corresponding
    destructors even if these functions have side effects that include observable
    behavior*. This exception is not limited to RVO. The implication is that, in general,
    you cannot count on copy and move constructors to be called just because you wrote
    some code that appears to do a copy. This is known as **copy elision** (or **move
    elision**, for move constructors).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要记住这是一种优化。这意味着编译器通常不必这样做（如果你的编译器不这样做，你需要一个更好的编译器）。然而，这是一种非常特殊的优化。一般来说，只要不改变可观察行为，编译器可以对你的程序做任何它想做的事情。可观察行为包括输入和输出以及访问易失性内存。然而，这种优化导致了可观察行为的改变：拷贝构造函数和匹配的析构函数的预期输出都不见了。事实上，这是一个例外，违背了通常的规则：*即使这些函数具有包括可观察行为在内的副作用，编译器也允许消除对拷贝或移动构造函数以及相应析构函数的调用*。这个例外并不局限于RVO。这意味着，一般来说，你不能指望拷贝和移动构造函数会被调用，只因为你写了一些看起来像是在进行拷贝的代码。这就是所谓的**拷贝省略**（或**移动省略**，对于移动构造函数）。
- en: 'Second, remember (again) that this is an optimization. The code must compile
    before it can be optimized. If your object does not have any copy or move constructors,
    this code will not compile, and we will never get to the optimization step that
    is going to remove all calls to these constructors. This is easy to see if we
    delete all copy and move constructors in our example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，要记住（再次）这是一种优化。在进行优化之前，代码必须能够编译。如果你的对象没有任何拷贝或移动构造函数，这段代码将无法编译，我们将永远无法进行将删除所有这些构造函数调用的优化步骤。如果我们在示例中删除所有拷贝和移动构造函数，这一点很容易看出：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The compilation will now fail. The exact error message depends on the compiler
    and the C++ standard level; in C++17, it is going to look something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编译现在会失败。确切的错误消息取决于编译器和C++标准级别；在C++17中，它会看起来像这样：
- en: '![Figure 9.4 – Compilation output of Clang using C++17 or C++20'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 - 使用C++17或C++20的Clang编译输出'
- en: '](img/Figure_9.4_B16229.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B16229.jpg)'
- en: Figure 9.4 – Compilation output of Clang using C++17 or C++20
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 - 使用C++17或C++20的Clang编译输出
- en: 'There is one special case where our program would compile even with deleted
    copy and move operations. Let us make a slight change to the `makeC` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊情况，即使删除了拷贝和移动操作，我们的程序也会编译。让我们对`makeC`函数进行一些微小的更改：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Nothing changes in C++11 or C++14; however, in C++17 and above, this code compiles
    fine. Note the slight difference from the previous version: the returned object
    used to be an l-value, it had a name. Now it’s an r-value, an unnamed temporary.
    This makes all the difference: while the **named RVO** (**NRVO**) is still an
    optimization, the unnamed RVO is mandatory since C++17 and is no longer considered
    to be a copy elision. Instead, the standard says that no copy or move is requested
    in the first place.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: C++11或C++14中没有任何变化；然而，在C++17及以上版本中，这段代码可以成功编译。请注意与之前版本的细微差别：返回的对象以前是一个l-value，它有一个名字。现在它是一个r-value，一个没有名字的临时对象。这造成了很大的不同：虽然**命名返回值优化**（NRVO）仍然是一种优化，但自C++17以来，无名的返回值优化是强制性的，不再被视为拷贝省略。相反，标准规定首先不会请求任何拷贝或移动。
- en: 'Finally, you may wonder if the function must be inlined in order for the compiler
    to know where the return value is while it compiles the function itself. With
    a simple test, you can convince yourself that this is not so: even if the function
    `makeC` is in a separate compilation unit, RVO still takes place. The compiler,
    therefore, must send the address of the result to the function at the call point.
    You can do something similar yourself if you do not return the result from the
    function at all but instead pass the reference to the result as an additional
    argument. Of course, that object has to be constructed first, while the compiler-generated
    optimization does not need an extra constructor call.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能会想知道编译器是否必须内联函数，以便在编译函数本身时知道返回值的位置。通过简单的测试，你可以确信这并非如此：即使函数`makeC`在一个单独的编译单元中，RVO仍然会发生。因此，编译器必须在调用点将结果的地址发送给函数。如果你根本不从函数中返回结果，而是将结果的引用作为额外的参数传递，你也可以自己做类似的事情。当然，该对象必须首先被构造，而编译器生成的优化不需要额外的构造函数调用。
- en: 'You may find a recommendation to not rely on RVO but to enforce the move of
    the return value instead:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现有人建议不要依赖RVO，而是强制移动返回值：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The argument goes that if RVO does not happen, your program will take the performance
    penalty of the copying operation, while the move operation is cheap anyway. However,
    this argument is wrong. To understand why, look carefully at the error message
    in *Figure 9.4*: the compiler complains that the move constructor is deleted even
    though `ctmp` is an l-value and should be copied. This is not a compiler bug but
    reflects the behavior required by the standard: in the context where the return-value
    optimization is possible, but the compiler decides not to do it, the compiler
    must first try to find a `move` constructor to return the result. If the `move`
    constructor is not found, the second lookup is performed; this time, the compiler
    is looking for a copy constructor. In both cases, the compiler is really performing
    overload resolution since there can be many copy or `move` constructors. Thus,
    there is no reason to write an explicit move: the compiler will do one for us.
    But what is the harm, then? The harm is that using the explicit move disables
    RVO; you have asked for a move, so you are going to get one. While a move may
    require very little work, RVO is no work at all, and no work is always faster
    than some work.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有人认为，如果RVO没有发生，你的程序将承受复制操作的性能损失，而移动操作无论如何都很便宜。然而，这个观点是错误的。要理解为什么，请仔细看*图9.4*中的错误消息：尽管`ctmp`是一个l值并且应该被复制，编译器却抱怨移动构造函数被删除。这不是编译器的错误，而是标准所要求的行为：在返回值优化可能发生的情况下，但编译器决定不这样做时，编译器必须首先尝试找到一个`move`构造函数来返回结果。如果找不到`move`构造函数，就会进行第二次查找；这一次，编译器会寻找一个复制构造函数。在这两种情况下，编译器实际上是在执行重载解析，因为可能有许多复制或`move`构造函数。因此，没有理由写一个显式的移动：编译器会为我们做一个。那么，有什么害处呢？害处在于使用显式移动会禁用RVO；你要求进行移动，所以你会得到一个。虽然移动可能需要很少的工作，但RVO根本不需要工作，没有工作总是比一些工作更快。
- en: 'What happens if we delete the `move` constructor but not the copy constructor?
    The compilation still fails in the case where it was failing with both constructors
    deleted. This is, again, a subtle point of the language: declaring a deleted member
    function is not the same as not declaring any. If the compiler performs the overload
    resolution for a `move` constructor, it will find one, even if this constructor
    is deleted. The compilation fails because the overload resolution selected a deleted
    function as the best (or the only) overload. If you want to force the use of the
    copy constructor (in the name of science, of course), you have to not declare
    any `move` constructors at all.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们删除`move`构造函数但不删除复制构造函数会发生什么？即使在两个构造函数都被删除的情况下编译仍然失败。这是语言的一个微妙之处：声明一个已删除的成员函数并不等同于不声明任何成员函数。如果编译器执行`move`构造函数的重载解析，它会找到一个，即使这个构造函数被删除了。编译失败是因为重载解析选择了一个已删除的函数作为最佳（或唯一）重载。如果你想强制使用复制构造函数（当然是为了科学），你必须根本不声明任何`move`构造函数。
- en: 'By now, you must see the danger of accidentally copying an object and ruining
    your program’s performance hiding behind every dark corner of your code. What
    can you do to avoid unintentional copying? We will have some suggestions in a
    moment, but first, let us return to one approach that we already used briefly:
    the use of pointers.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一定已经看到了意外复制对象并破坏程序性能的危险隐藏在你的代码的每一个黑暗角落。你能做些什么来避免意外复制？我们马上会有一些建议，但首先，让我们回到我们已经简要使用过的一个方法：使用指针。
- en: Using pointers to avoid copying
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指针来避免复制
- en: One way to avoid copying objects when passing them around is to pass pointers
    instead. This is easiest if we don’t have to manage the object’s lifetime. If
    a function needs access to an object but does not need to delete it, passing the
    object by reference or by a raw pointer is the best way (the reference, in this
    context, is really just a pointer that cannot be null).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递对象时避免复制对象的一种方法是传递指针。如果我们不必管理对象的生命周期，这是最容易的。如果一个函数需要访问一个对象但不需要删除它，通过引用或原始指针传递对象是最好的方式（在这种情况下，引用实际上只是一个不能为null的指针）。
- en: 'Similarly, we can return an object from a function using a pointer, but this
    needs more care. First of all, the object must be allocated on the heap. You must
    never return pointers or references to local variables. Refer to the following
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用指针从函数返回对象，但这需要更多的注意。首先，对象必须在堆上分配。你绝对不能返回指向局部变量的指针或引用。参考以下代码：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Second, the caller is now responsible for deleting the object, so every caller
    of your function must know how the object was constructed (operator `new` is not
    the only way to construct objects, just the most common one). The best solution
    here is to return a smart pointer:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，调用者现在负责删除对象，因此你的函数的每个调用者都必须知道对象是如何构造的（`new`操作符不是构造对象的唯一方式，只是最常见的一种）。这里最好的解决方案是返回一个智能指针：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that such a factory function should return unique pointers even if the
    caller may use shared pointers to manage the object’s lifetime: it is easy and
    cheap to move from the unique pointer to the shared one.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这样的工厂函数应该返回独特的指针，即使调用者可能使用共享指针来管理对象的生命周期：从独特指针移动到共享指针是简单且便宜的。
- en: 'Speaking of shared pointers, they are often used to pass around objects whose
    lifetime is managed by smart pointers. Unless the intent is to pass the ownership
    of the object as well, this is again an example of unnecessary and inefficient
    copying. Copying shared pointers is not cheap. So, what do we do if we have an
    object managed by a shared pointer and a function that needs to operate on this
    object without taking ownership of it? We use raw pointers:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 说到共享指针，它们经常用于传递由智能指针管理生命周期的对象。除非意图是传递对象的所有权，否则这又是一个不必要和低效的复制的例子。复制共享指针并不便宜。那么，如果我们有一个由共享指针管理的对象和一个需要在不获取所有权的情况下对该对象进行操作的函数，我们使用原始指针：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The declarations of the functions `do_work1()` and `do_work2()` tell us about
    the programmer’s intent: both functions operate the object without deleting it.
    The first function modifies the object; the second does not. Both functions expect
    to be called without the object and will handle this special case (otherwise,
    the arguments would be passed by reference).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`do_work1()`和`do_work2()`的声明告诉我们程序员的意图：两个函数都在不删除对象的情况下操作对象。第一个函数修改对象；第二个函数不修改。这两个函数都期望在没有对象的情况下被调用，并将处理这种特殊情况（否则，参数将被按引用传递）。
- en: Similarly, you can create containers of raw pointers as long as the lifetime
    of the objects is managed elsewhere. If you want the container to manage the lifetime
    of its elements but do not want to store the objects in the container, a container
    of unique pointers will do the job.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以创建原始指针的容器，只要对象的生命周期在其他地方管理。如果你希望容器管理其元素的生命周期，但又不想将对象存储在容器中，唯一指针的容器就可以胜任。
- en: Now it is time for some general guidelines that will help you avoid unnecessary
    copying and the inefficiencies it can cause.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候提出一些通用的准则，帮助你避免不必要的拷贝和由此引起的低效率。
- en: How to avoid unnecessary copying
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何避免不必要的拷贝
- en: Perhaps the most important thing you can do to reduce accidental, unintentional
    copying is to ensure that all your data types are movable if moving can be implemented
    cheaper than copying. If you have container libraries or other reusable code,
    make sure it is move-enabled as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要减少意外的、无意的拷贝，你可以做的最重要的事情也许是确保所有的数据类型都是可移动的，如果移动的成本比拷贝更低的话。如果你有容器库或其他可重用的代码，确保它也是可移动的。
- en: 'The next suggestion is somewhat hamfisted, but it can save you a lot of debugging
    time: if you have types that are expensive to copy, make them non-copyable to
    begin with. Declare the copy and assignment operations as deleted. If the classes
    support a fast move, provide move operations instead. This will, of course, prevent
    any copying, intentional or not. Hopefully, intentional copying is rare, and you
    can implement a special member function like `clone()` that will create a copy
    of the object. At least this way, all the copying is explicit and visible in your
    code. If the class is neither copyable nor movable, you will not be able to use
    it with STL containers; however, a container of unique pointers is a fine alternative.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个建议有些粗糙，但可以节省大量的调试时间：如果你有昂贵的类型需要拷贝，最好一开始就将它们设置为不可拷贝。声明拷贝和赋值操作为删除。如果类支持快速移动，提供移动操作。当然，这将阻止任何拷贝，无论是有意还是无意的。希望有意的拷贝很少，你可以实现一个特殊的成员函数，比如`clone()`，它将创建对象的副本。至少这样，所有的拷贝都是显式的，并且在你的代码中是可见的。如果类既不可拷贝也不可移动，你将无法将其与STL容器一起使用；然而，使用唯一指针的容器是一个很好的替代方案。
- en: When passing parameters to functions, use references or pointers whenever possible.
    If the function needs to make a copy of the argument, consider passing by value
    and moving from the parameter instead. Remember that this works well only for
    move-enabled types, and see the first guideline.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在向函数传递参数时，尽可能使用引用或指针。如果函数需要对参数进行拷贝，请考虑按值传递并从参数中移动。记住，这仅适用于可移动类型，并参考第一个准则。
- en: 'Everything we said about passing function arguments can be applied to temporary
    local variables as well (after all, function parameters are basically temporary
    local variables in the function scope). These should be references unless you
    need a copy. This does not apply to the built-in types like integers or pointers:
    they are cheaper to copy than to access indirectly. In template code, you don’t
    have the luxury of knowing whether the type is large or small, so use references
    and rely on compiler optimizations to avoid unnecessary indirect access to built-in
    types.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于传递函数参数的所有说法也适用于临时局部变量（毕竟，函数参数基本上就是函数范围内的临时局部变量）。除非你需要一个拷贝，否则这些应该是引用。这不适用于像整数或指针这样的内置类型：它们比间接访问更便宜。在模板代码中，你无法知道类型是大还是小，所以使用引用，并依赖于编译器优化来避免对内置类型的不必要的间接访问。
- en: 'When returning values from functions, your first preference should be to rely
    on RVO and copy elision. Only when you find that the compiler does not perform
    this optimization and that it matters in your particular case should you consider
    alternatives. These alternatives are: using functions with output arguments and
    using factory functions that construct the results in dynamically allocated memory
    and return owning smart pointers such as `std::unique_ptr`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当从函数返回值时，你首选应该依赖于RVO和拷贝省略。只有当你发现编译器没有执行这种优化，并且在你的特定情况下这很重要时，你才应该考虑其他选择。这些替代方案包括：使用带有输出参数的函数和使用在动态分配内存中构造结果并返回拥有智能指针（如`std::unique_ptr`）的工厂函数。
- en: 'Finally, review your algorithms and the implementation with an eye out for
    unnecessary copying: remember that ill-intentioned copying is just as bad for
    the performance as unintentional copying.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，审查你的算法和实现，留意不必要的拷贝：记住，恶意的拷贝对性能的影响和无意的拷贝一样糟糕。
- en: We are done with the first bane of efficiency in C++ programs, the gratuitous
    copying of objects. The close second is poor memory management.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了C++程序中效率的第一个问题，即不必要的对象拷贝。接下来的问题是糟糕的内存管理。
- en: Inefficient memory management
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低效的内存管理
- en: The subject of memory management in C++ can merit a book all of its own. There
    are dozens if not hundreds of papers dedicated just to the issue of the STL allocators.
    In this chapter, we will focus on several problems that tend to affect performance
    the most. Some have simple solutions; for others, we will describe the issue and
    outline the possible solution approaches.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的内存管理这个主题可能值得一本专门的书。有数十甚至数百篇论文专门讨论STL分配器的问题。在本章中，我们将专注于影响性能最大的几个问题。有些问题有简单的解决方案；对于其他问题，我们将描述问题并概述可能的解决方案。
- en: 'There are two types of memory-related problems that you may run into in the
    context of performance. The first one is using too much memory: your program either
    runs out of memory or doesn’t meet the memory use requirements. The second problem
    occurs when your program becomes memory-bound: its performance is limited by the
    speed of memory access. Often, in these cases, the runtime of the program is directly
    related to how much memory it uses, and reducing the memory use also makes the
    program run faster.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能的背景下，你可能会遇到两种与内存相关的问题。第一个是使用过多的内存：你的程序要么耗尽内存，要么不满足内存使用要求。第二个问题是当你的程序变得受限于内存：其性能受到内存访问速度的限制。通常情况下，程序的运行时间与其内存使用量直接相关，减少内存使用也会使程序运行更快。
- en: The material presented in this section is helpful mostly for programmers who
    deal with memory-bound programs or programs that allocate memory frequently and/or
    in large quantities. We begin with the performance impact of the memory allocations
    themselves.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍的材料对于处理受限于内存的程序或频繁分配大量内存的程序的程序员来说是有帮助的。我们首先从内存分配本身的性能影响开始。
- en: Unnecessary memory allocations
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不必要的内存分配
- en: 'One of the most common performance problems related to memory use is that of
    unnecessary memory allocation. Here is a very common problem, described in C++-like
    pseudocode:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与内存使用相关的最常见的性能问题之一是不必要的内存分配。这里是一个非常常见的问题，用类似C++的伪代码描述：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A well-written program would use an RAII class to manage deallocations, but
    we wanted to make allocations and deallocations explicit for clarity. The allocations
    are usually concealed inside objects that manage their own memory, such as STL
    containers. It is not uncommon for such a program to spend most of its time in
    memory allocation and deallocation functions (such as `malloc()` and `free()`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个写得很好的程序会使用RAII类来管理释放，但为了清晰起见，我们希望明确地进行分配和释放。分配通常隐藏在管理自己内存的对象内部，比如STL容器。这样的程序大部分时间都花在内存分配和释放函数上（比如`malloc()`和`free()`）。
- en: 'We can see the effect on performance on a very simple benchmark:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到性能对一个非常简单的基准测试的影响：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here the *work* is represented by initializing a character string, and the
    `random_number()` function returns random integer values (it could be just `rand()`,
    but the benchmark is *cleaner* if we precompute and store random numbers to avoid
    benchmarking the random number generator). You may also need to trick the compiler
    into not optimizing away the results: if the usual `benchmark::DoNotOptimize()`
    does not suffice, you may have to insert a print statement with the condition
    that never happens (but the compiler does not know it) like `rand() < 0`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*工作*是通过初始化一个字符串来表示，`random_number()`函数返回随机整数值（它可以只是`rand()`，但如果我们预先计算并存储随机数以避免对随机数生成器进行基准测试，那么基准测试就会更*干净*）。你可能还需要欺骗编译器，使其不要优化结果：如果通常的`benchmark::DoNotOptimize()`不够用，你可能需要插入一个带有永远不会发生的条件的打印语句（但编译器不知道）比如`rand()
    < 0`。
- en: 'The numbers we get from the benchmark are meaningless by themselves: we need
    to compare them with something. In our case, the baseline is easy to figure out:
    we must do the same work but none of the allocations. This can be accomplished
    by moving the allocation and the deallocation out of the loop since we know the
    maximum memory size:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基准测试中得到的数字本身是没有意义的：我们需要将它们与某些东西进行比较。在我们的情况下，基准很容易找到：我们必须做同样的工作，但没有任何分配。这可以通过将分配和释放移出循环来实现，因为我们知道最大内存大小：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The performance difference you will observe in such a benchmark depends greatly
    on the operating system and the system libraries, but you’re likely to see something
    like this (we used strings of random sizes up to 1 KB):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的基准测试中，你观察到的性能差异在很大程度上取决于操作系统和系统库，但你可能会看到类似这样的情况（我们使用了最多1KB的随机大小的字符串）：
- en: '![Figure 9.5 – Performance impact of the allocation-deallocation pattern'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5-分配-释放模式的性能影响'
- en: '](img/Figure_9.5_B16229.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.5_B16229.jpg)'
- en: Figure 9.5 – Performance impact of the allocation-deallocation pattern
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5-分配-释放模式的性能影响
- en: It should be noted that the memory allocations in a micro-benchmark are typically
    more efficient than in the context of a large program where the memory allocation
    pattern is much more complex, so the real-world effect of frequent allocations
    and deallocations is likely to be even larger. Even in our small benchmark, the
    implementation that allocates memory every time runs at 40% of the speed of the
    version that allocates the maximum possible amount of memory just once.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，在微基准测试中，内存分配通常比在大型程序的上下文中更有效率，因为内存分配模式要复杂得多，因此频繁分配和释放的实际影响可能更大。即使在我们的小基准测试中，每次分配内存的实现速度只有分配最大可能内存量一次版本的40%。
- en: 'Of course, when the maximum amount of the memory we need during the computation
    is known in advance, preallocating it and reusing it from one iteration to the
    next is an easy solution. This solution generalizes to many containers as well:
    for a vector or deque, we can reserve the memory before the start of the iterations
    and take advantage of the fact that resizing the container does not shrink its
    capacity.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们在计算过程中需要的最大内存量事先知道时，预先分配并在下一次迭代中重复使用是一个简单的解决方案。这个解决方案也适用于许多容器：对于向量或双端队列，我们可以在迭代开始之前预留内存，并利用调整容器大小不会减小其容量的特性。
- en: 'The solution is only slightly more complex when we do not know the maximum
    memory size in advance. This situation can be handled with a grow-only buffer.
    Here is a simple buffer that can be grown but never shrinks:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们事先不知道最大内存大小时，解决方案只是稍微复杂一些。这种情况可以用一个只增长不缩小的缓冲区来处理。这是一个简单的缓冲区，可以增长但永远不会缩小：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Again, this code is useful for demonstration and exploration. In a real program,
    you are likely to use STL containers or your own library classes, but they all
    should have the capability to increase the memory capacity. We can compare the
    performance of this grow-only buffer with that of the fixed-size preallocated
    buffer by trivially modifying our benchmark:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这段代码对于演示和探索是有用的。在一个真实的程序中，你可能会使用STL容器或你自己的库类，但它们都应该有增加内存容量的能力。我们可以通过简单修改我们的基准测试来比较这个仅增长缓冲区与固定大小预分配缓冲区的性能：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, in a real program, you are likely to get better results with a smarter
    memory growth strategy (grow by somewhat more than requested, so you don’t have
    to grow memory as often – most STL containers employ some form of this strategy).
    But, for our demonstration, we want to keep things as simple as possible. On the
    same machine, the results of the benchmark are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在一个真实的程序中，通过更智能的内存增长策略（略微超过请求的增长，这样你就不必经常增长内存 - 大多数STL容器都采用某种形式的这种策略）你可能会得到更好的结果。但是，对于我们的演示，我们希望尽可能地保持简单。在同一台机器上，基准测试的结果如下：
- en: '![Figure 9.6 – Performance of a grow-only buffer (compare with Figure 9.5)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 - 仅增长缓冲区的性能（与图9.5进行比较）'
- en: '](img/Figure_9.6_B16229.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.6_B16229.jpg)'
- en: Figure 9.6 – Performance of a grow-only buffer (compare with Figure 9.5)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 - 仅增长缓冲区的性能（与图9.5进行比较）
- en: The grow-only buffer is slower than a fixed-size buffer but much faster than
    allocating and deallocating memory every time. Again, a better growth policy would
    make this buffer even faster, close to the speed of the fixed-size buffer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 增长型缓冲区比固定大小缓冲区慢，但比每次分配和释放内存要快得多。再次强调，更好的增长策略会使这个缓冲区变得更快，接近固定大小缓冲区的速度。
- en: 'This is not the entire story: the importance of good memory management is even
    greater in multi-threaded programs because the calls to the system memory allocator
    do not scale well and may involve a global lock. Running our benchmark on the
    same machine using 8 threads produces these results:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部：在多线程程序中，良好的内存管理的重要性更大，因为对系统内存分配器的调用不会很好地扩展，并且可能涉及全局锁。在同一台机器上使用8个线程运行我们的基准测试产生了以下结果：
- en: '![Figure 9.7 – Performance impact of the allocation-deallocation pattern in
    a multi-threaded program'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 - 多线程程序中分配-释放模式的性能影响'
- en: '](img/Figure_9.7_B16229.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.7_B16229.jpg)'
- en: Figure 9.7 – Performance impact of the allocation-deallocation pattern in a
    multi-threaded program
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 - 多线程程序中分配-释放模式的性能影响
- en: Here, the penalty for frequent allocations is even greater (the grow-only buffer
    shows the cost of the remaining allocations as well and would really benefit from
    a smarter growth policy).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，频繁分配的惩罚更大（仅增长缓冲区显示了剩余分配的成本，并且真的会受益于更智能的增长策略）。
- en: 'The bottom line is: interact with the OS as little as possible. If you have
    a loop that needs to allocate and deallocate memory on each iteration, allocate
    once before the loop instead. If the allocations are of the same size, or you
    know the maximum allocation size upfront, make one allocation of this size and
    hold it (of course, if you use several buffers or containers, you should not try
    to shoehorn them into a single allocation, but preallocate each one). If you do
    not know the maximum size, use a data structure that can grow, but do not shrink
    or release the memory until the work is done.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是：尽量减少与操作系统的交互。如果你有一个需要在每次迭代中分配和释放内存的循环，那么在循环之前分配一次。如果分配的大小相同，或者你事先知道最大分配大小，那么就分配这个大小并保持它（当然，如果你使用多个缓冲区或容器，你不应该试图把它们塞进一个单一的分配中，而是预先分配每一个）。如果你不知道最大大小，使用一个可以增长但不会缩小或释放内存直到工作完成的数据结构。
- en: The recommendation to avoid interacting with the OS is particularly important
    in multi-threaded programs, and we will now make some more general comments on
    the use of memory in concurrent programs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 避免与操作系统交互的建议在多线程程序中尤为重要，现在我们将对并发程序中内存使用进行一些更一般的评论。
- en: Memory management in concurrent programs
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发程序中的内存管理
- en: 'The memory allocator provided by the operating system is a solution that balances
    many requirements: on a given machine, there is only one OS but many different
    programs with their own unique needs and memory use patterns. The developers tried
    very hard to make it not fail miserably in any reasonable use case; the flip side
    is that it’s rarely the best possible solution for any use case, too. Often, it’s
    good enough, especially if you follow the recommendation of requesting memory
    frequently.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提供的内存分配器是一个平衡多种需求的解决方案：在一台给定的机器上，只有一个操作系统，但有许多不同的程序，它们有自己独特的需求和内存使用模式。开发人员非常努力地使它在任何合理的用例中都不会失败；另一方面，它很少是任何用例的最佳解决方案。通常情况下，它足够好，特别是如果你遵循频繁请求内存的建议。
- en: Memory allocation becomes more inefficient in concurrent programs. The primary
    reason is that any memory allocator has to maintain a fairly complex internal
    data structure to track allocated and free memory. In high-performance allocators,
    the memory is subdivided into multiple arenas to group allocations of similar
    size together. This increases performance at the cost of complexity. The result
    is that this management of the internal data has to be protected by a lock if
    multiple threads are allocating and deallocating memory at once. This is a global
    lock, one for the entire program, and it can limit the scaling of the entire program
    if the allocator is called often.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发程序中，内存分配变得更加低效。主要原因是任何内存分配器都必须维护一个相当复杂的内部数据结构来跟踪分配和释放的内存。在高性能分配器中，内存被划分为多个区域，以将相似大小的分配组合在一起。这增加了性能，但也增加了复杂性。结果是，如果多个线程同时分配和释放内存，那么这些内部数据的管理必须受到锁的保护。这是一个全局锁，适用于整个程序，如果分配器经常被调用，它可能会限制整个程序的扩展。
- en: 'The most common solution to this problem is to use an allocator with thread-local
    caches, such as the popular `malloc()` replacement library TCMalloc. These allocators
    reserve some amount of memory for each thread: when a thread needs to allocate
    memory, it is taken from the thread-local memory arena first. This does not need
    a lock since only one thread interacts with that arena. Only if the arena is empty
    does the allocator have to take the lock and allocate from the memory shared between
    all threads. Similarly, when a thread deallocates the memory, it is added to the
    thread-specific arena, again without any locking.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的最常见解决方案是使用具有线程本地缓存的分配器，比如流行的`malloc()`替代库TCMalloc。这些分配器为每个线程保留一定数量的内存：当一个线程需要分配内存时，首先从线程本地内存区域中取出。这不需要锁，因为只有一个线程与该区域交互。只有当该区域为空时，分配器才必须获取锁，并从所有线程共享的内存中分配。同样，当一个线程释放内存时，它会被添加到特定于线程的区域，而无需任何锁定。
- en: The thread-local caches are not without their share of problems.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 线程本地缓存并非没有问题。
- en: 'First of all, they tend to use more memory overall: if one thread frees a lot
    of memory and another thread allocates a lot of memory, the recently freed memory
    does not become available to the other thread (it’s local to the thread that released
    it). So more memory is allocated while unused memory is available for other threads.
    To limit this memory waste, the allocators typically do not allow the per-thread
    arena to grow above some predefined limit. Once the limit is reached, the thread-local
    memory is returned to the main arena shared between all threads (this operation
    requires a lock).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们往往会使用更多的内存：如果一个线程释放了大量内存，另一个线程分配了大量内存，那么最近释放的内存对于其他线程是不可用的（它是本地的）。因此，分配更多的内存，而未使用的内存对其他线程是可用的。为了限制这种内存浪费，分配器通常不允许每个线程的区域增长超过某个预定义的限制。一旦达到限制，线程本地内存就会返回到所有线程共享的主要区域（这个操作需要一个锁）。
- en: The second problem is that these allocators work well if each allocation is
    owned by one thread, that is, the same thread allocates and deallocates memory
    at each address. If one thread allocates some memory, but another thread has to
    deallocate it, this *cross-thread* deallocation is difficult because the memory
    must be transferred from the thread-local arena of one thread to that of the other
    (or to the shared arena). A simple benchmark shows that the performance of cross-thread
    deallocation with the standard allocators like `malloc()` or TCMalloc is at least
    an order of magnitude worse than that of thread-owned memory. This is likely to
    be true with any allocator that utilizes thread-local caches, and so memory transfers
    between threads should be avoided whenever possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，如果每个分配都由一个线程拥有，也就是说，同一个线程在每个地址分配和释放内存，那么这些分配器就能很好地工作。如果一个线程分配了一些内存，但另一个线程必须释放它，这种*跨线程*的释放是困难的，因为内存必须从一个线程的本地区域转移到另一个线程的本地区域（或共享区域）。简单的基准测试显示，使用标准分配器（如`malloc()`或TCMalloc）进行跨线程释放的性能至少比线程拥有的内存差一个数量级。这很可能对任何利用线程本地缓存的分配器都是如此，因此应尽量避免线程之间的内存转移。
- en: 'So far, we were talking about transferring memory from one thread to another
    for the purpose of deallocating it. What about simply using memory that was allocated
    by another thread? The performance of such memory access depends greatly on the
    hardware capabilities. For a simple system with few CPUs, this is likely a non-issue.
    But larger systems have multiple memory banks, and the connection between the
    CPU and the memory is not symmetric: each memory bank is closer to one CPU. This
    is known as the **non-uniform memory architecture** (**NUMA**). The performance
    impact of NUMA varies widely from *doesn’t matter* to *twice as fast*. There are
    ways to tune the performance of the NUMA memory system as well as making the program
    memory management sensitive to NUMA details, but beware that you are likely tuning
    the performance to a particular machine: there is very little that can be said
    about the performance of NUMA systems in general.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了将内存从一个线程转移到另一个线程以便释放的问题。那么简单地使用另一个线程分配的内存呢？这种内存访问的性能在很大程度上取决于硬件能力。对于一个具有少量CPU的简单系统，这可能不是问题。但更大的系统有多个内存银行，CPU和内存之间的连接不对称：每个内存银行更接近一个CPU。这被称为**非一致内存架构**（**NUMA**）。NUMA的性能影响因*不重要*到*快两倍*而变化很大。有方法可以调整NUMA内存系统的性能，以及使程序内存管理对NUMA细节敏感，但要注意，你可能在调整性能以适应特定的机器：关于NUMA系统的性能几乎没有什么可以说的。
- en: We are now returning to the issue of using memory more efficiently since it
    is universally helpful for performance in concurrent and serial programs alike.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到了更有效地使用内存的问题，因为这对并发和串行程序的性能都是有益的。
- en: Avoiding memory fragmentation
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免内存碎片化
- en: 'One issue that plagues many programs is an inefficient interaction with the
    memory allocation system. Let us say that the program needs to allocate 1 KB of
    memory. This chunk of memory is carved out from some larger memory arena, marked
    as used by the allocator, and the address is returned to the caller. More memory
    allocations follow, so the memory after our 1 KB chunk is now used too. Then the
    program returns the first allocation and immediately asks for 2 KB of memory.
    There is a 1 KB free chunk, but it’s not large enough to service this new request.
    There may be another 1 KB chunk somewhere else, but as long as the two chunks
    are not right next to each other, they are not useful for the purpose of the 2
    KB allocation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个困扰许多程序的问题是与内存分配系统的低效交互。假设程序需要分配1 KB的内存。这块内存是从某个较大的内存区域中划分出来的，由分配器标记为已使用，并将地址返回给调用者。随后进行更多的内存分配，所以我们1
    KB的内存块之后的内存现在也被使用了。然后程序释放第一个分配的内存，并立即请求2 KB的内存。有1 KB的空闲块，但不足以满足这个新的请求。可能在其他地方有另一个1
    KB的块，但只要这两个块不相邻，它们对于2 KB的分配就没有用处：
- en: '![Figure 9.8 – Memory fragmentation: 2 KB of free memory exists but is not
    useful for a single 2 KB allocation'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 - 内存碎片化：存在2 KB的空闲内存，但对于单个2 KB的分配是无用的'
- en: '](img/Figure_9.8_B16229.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.8_B16229.jpg)'
- en: 'Figure 9.8 – Memory fragmentation: 2 KB of free memory exists but is not useful
    for a single 2 KB allocation'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 - 内存碎片化：存在2 KB的空闲内存，但对于单个2 KB的分配是无用的
- en: This situation is known as `malloc()`, but for programs that churn through memory
    quickly, more extreme measures may be required.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况被称为`malloc()`，但对于快速消耗内存的程序，可能需要更极端的措施。
- en: 'One such measure is a block allocator. The idea is that all memory is allocated
    in blocks of fixed size, such as 64 KB. You should not allocate single blocks
    of this size from the OS one at a time but instead allocate larger chunks of fixed
    size (say, 8 MB) and subdivide them into the smaller blocks (64 KB in our example).
    The memory allocator that handles these requests is the primary allocator in your
    program, the one that interacts directly with `malloc()`. Because it allocates
    blocks of just one size, it can be very simple, and we can focus on the most efficient
    implementation (thread-local cache for concurrent programs, low latency for real-time
    systems, and so on). Of course, you do not want to deal with these 64 KB blocks
    everywhere in your code. That is the job of secondary allocators, as shown in
    the following *Figure 9.9*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种措施是块分配器。其思想是所有内存都以固定大小的块分配，比如64 KB。你不应该一次从操作系统中分配这么大的单个块，而是应该分配更大的固定大小的块（比如8
    MB），然后将它们细分为更小的块（在我们的例子中是64 KB）。处理这些请求的内存分配器是程序中的主要分配器，直接与`malloc()`交互。因为它只分配一个大小的块，所以它可以非常简单，我们可以专注于最有效的实现（并发程序的线程本地缓存，实时系统的低延迟等）。当然，你不希望在代码的各个地方都处理这些64
    KB的块。这是次要分配器的工作，如下图*图9.9*所示：
- en: '![Figure 9.9 – Fixed-size block allocation'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 - 固定大小块分配'
- en: '](img/Figure_9.9_B16229.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.9_B16229.jpg)'
- en: Figure 9.9 – Fixed-size block allocation
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 - 固定大小块分配
- en: 'You can have an allocator that further subdivides the 64 KB blocks into smaller
    allocations. Particularly efficient is a uniform allocator (an allocator for just
    one size): for example, if you want to allocate memory for single 64-bit integers,
    you can do so without any memory overhead (by comparison, `malloc()` usually requires
    at least 16 bytes of overhead per allocation). You can also have containers that
    allocate memory in 64 KB blocks and use it to store the elements. You will not
    be using vectors since they require a single large, contiguous allocation. The
    array-like container you want here is the deque that allocates memory in fixed-size
    blocks. You can, of course, have nodal containers as well. You can use the STL
    containers if the STL allocator interface is sufficient for your needs; otherwise,
    you may have to write your own container library.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有一个分配器进一步将64 KB的块细分为更小的分配。特别高效的是统一分配器（只分配一个大小的分配器）：例如，如果你想为单个64位整数分配内存，你可以做到没有任何内存开销（相比之下，`malloc()`通常至少需要16字节的开销）。你还可以有容器分配内存在64
    KB的块中并用它来存储元素。你不会使用向量，因为它们需要单个大的连续分配。你想要的类似数组的容器是deque，它分配内存在固定大小的块中。当然，你也可以有节点容器。如果STL分配器接口满足你的需求，你可以使用STL容器；否则，你可能需要编写自己的容器库。
- en: 'The key advantage of the fixed-size block allocation is that it does not suffer
    from fragmentation: all allocations from `malloc()` are of the same size, so are
    all allocations from the primary allocator. Any time a memory block is returned
    to the allocator, it can be reused to satisfy the next request for memory. Refer
    to the following figure:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小块分配的关键优势在于它不会受到碎片化的影响：从`malloc()`分配的所有分配都是相同大小的，因此主分配器的所有分配也是如此。每当一个内存块被返回给分配器，它都可以被重用来满足下一个内存请求。参考下图：
- en: '![Figure 9.10 – Memory reuse in fixed-size allocators'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10 - 固定大小分配器中的内存重用'
- en: '](img/Figure_9.10_B16229.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_B16229.jpg)'
- en: Figure 9.10 – Memory reuse in fixed-size allocators
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 - 固定大小分配器中的内存重用
- en: 'That first-in-first-out property is also an advantage: the last 64 KB memory
    block is likely to be from the most recently used memory and is still hot in the
    cache. Reusing this block immediately improves memory reference locality and,
    therefore, makes more efficient use of the cache. The allocator manages the blocks
    returned to it as a simple free list (*Figure 9.10*). These free lists can be
    maintained per thread to avoid locking, although they will likely need periodic
    rebalancing to avoid the situation where one thread has accumulated many free
    blocks while another thread is allocating new memory.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先进先出的特性也是一个优势：最后的64 KB内存块很可能是最近使用的内存，仍然在缓存中。立即重用这个块可以改善内存引用局部性，因此更有效地利用缓存。分配器将返回给它的块管理为一个简单的空闲列表（*图9.10*）。这些空闲列表可以按线程维护，以避免锁定，尽管它们可能需要定期重新平衡，以避免一个线程积累了许多空闲块，而另一个线程正在分配新的内存。
- en: Of course, the allocators that subdivide our 64 KB blocks into smaller sizes
    are still susceptible to fragmentation unless they are also uniform (fixed-size)
    allocators. It is, however, easier to write a self-defragmenting allocator if
    it has to deal with a small memory range (one block) and few different sizes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，将我们的64 KB块细分为更小尺寸的分配器仍然容易受到碎片化的影响，除非它们也是统一（固定大小）的分配器。然而，如果它必须处理一个小的内存范围（一个块）和少量不同的大小，编写自动整理分配器会更容易。
- en: It is likely that the entire program is affected by the decision to use block
    memory allocation. For example, allocating large numbers of small data structures
    such that each one uses a fraction of the 64 KB block and leaves the rest unused
    becomes prohibitively expensive. On the other hand, a data structure that itself
    is a collection of smaller data structures (a container) such that it packs many
    smaller objects into one block becomes easier to write. One can even write compressed
    containers that compress each block for keeping the data long-term, then decompress
    them one block at a time for access.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能整个程序都受到使用块内存分配的影响。例如，分配大量小数据结构，使得每个数据结构使用64 KB块的一部分并且剩下的部分未使用会变得非常昂贵。另一方面，一个数据结构本身是一组较小的数据结构（一个容器），这样它可以将许多较小的对象打包到一个块中，变得更容易编写。甚至可以编写压缩容器，用于长期保留数据，然后逐块解压缩以进行访问。
- en: The block size itself is not set in stone, either. Some applications will be
    more efficient with smaller blocks where less memory is wasted if a block is left
    partially unused. Others can benefit from larger blocks that require fewer allocations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 块大小本身也不是一成不变的。一些应用程序使用较小的块会更有效，因为如果块部分未使用，则浪费的内存较少。其他应用则可以从需要较少分配的较大块中受益。
- en: The literature on application-specific allocators is extensive. For example,
    slab allocators are a generalization of the block allocators we have just seen;
    they manage multiple allocation sizes efficiently. There are many other types
    of custom memory allocators, and most of them can be used in a C++ program. Using
    an allocator that is well-suited for a specific application often brings dramatic
    performance improvements, usually at the cost of severely restricting the programmer’s
    freedom in the implementation of the data structures.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 应用特定分配器的文献非常丰富。例如，板块分配器是我们刚刚看到的块分配器的一般化；它们有效地管理多种分配大小。还有许多其他类型的自定义内存分配器，其中大多数可以在C++程序中使用。使用适合特定应用的分配器通常会带来显著的性能改进，通常以严重限制程序员在数据结构实现中的自由为代价。
- en: The next common reason for inefficiency is more subtle and much harder to deal
    with.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 效率不高的另一个常见原因更微妙，也更难处理。
- en: Optimization of conditional execution
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件执行的优化
- en: After the unnecessary computations and inefficient use of memory, the next *easiest*
    way to write inefficient code that fails to utilize a large fraction of available
    computing resources is probably code that does not pipeline well. We have seen
    the importance of CPU pipelining in [*Chapter 3*](B16229_03_Epub_AM.xhtml#_idTextAnchor047),
    *CPU Architecture, Resources, and Performance Implications*. We have also learned
    there that the worst disruptor of pipelining is usually a conditional operation,
    especially the one that the hardware branch predictor fails to guess.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在不必要的计算和内存使用效率低下之后，编写未能充分利用可用计算资源大部分的低效代码的*最简单*方法可能是无法进行良好流水线处理的代码。我们已经在[*第3章*](B16229_03_Epub_AM.xhtml#_idTextAnchor047)，*CPU架构、资源和性能影响*中看到了CPU流水线处理的重要性。我们还了解到，最大的流水线破坏者通常是条件操作，特别是硬件分支预测器无法猜测的条件操作。
- en: 'Unfortunately, optimizing conditional code for better pipelining is one of
    the hardest C++ optimizations. It should be undertaken only if the profiler shows
    poor branch prediction. Note, however, that the number of mispredicted branches
    does not have to be large to be considered “poor”: a good program will typically
    have less than 0.1% of mispredicted branches. The misprediction rate of 1% is
    quite large. It is also quite difficult to predict the effect of source code optimizations
    without examining the compiler output (the machine code).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，优化条件代码以获得更好的流水线是最困难的C++优化之一。只有在分析器显示预测不良的分支时才应该进行优化。但是，请注意，预测不准的分支数量不必很大才能被认为是“不良的”：一个好的程序通常会有不到0.1%的预测不准的分支。1%的错误预测率是相当大的。而且，要在不检查编译器输出（机器代码）的情况下预测源代码优化的效果也是相当困难的。
- en: 'If the profiler shows a badly predicted conditional operation, the next step
    is to determine which condition is being mispredicted. We have already seen some
    examples in [*Chapter 3*](B16229_03_Epub_AM.xhtml#_idTextAnchor047), *CPU Architecture,
    Resources, and Performance Implications*. For example, this code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分析器显示有一个预测不良的条件操作，下一步是确定哪个条件被错误预测。我们已经在[*第3章*](B16229_03_Epub_AM.xhtml#_idTextAnchor047)，*CPU架构、资源和性能影响*中看到了一些例子。例如，这段代码：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'may yield one or more badly predicted branches even when the overall result
    is predictable. This has to do with the definition of the Boolean logic in C++:
    the operators `||` and `&&` are *short-circuited*: the expression is evaluated
    left to right until the result becomes known. For example, if `a[i]` is `true`,
    the code must not access array elements `b[i]` and `c[i]`. Sometimes, this is
    necessary: the logic of the implementation may be such that these elements don’t
    exist. But often, the Boolean expressions introduce unnecessary branches for no
    reason. The preceding `if()` statement requires 3 conditional operations. On the
    other hand, this statement:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 即使整体结果是可预测的，也可能产生一个或多个预测不良的分支。这与C++中布尔逻辑的定义有关：操作符`||`和`&&`是*短路*的：表达式从左到右进行评估，直到结果变为已知。例如，如果`a[i]`是`true`，则代码不得访问数组元素`b[i]`和`c[i]`。有时，这是必要的：实现的逻辑可能是这些元素不存在。但通常，布尔表达式会因无故引入不必要的分支。前面的`if()`语句需要3个条件操作。另一方面，这个语句：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: is equivalent to the last one if the values `a`, `b`, and `c` are non-negative
    but require a single conditional operation. Again, this is not the kind of optimization
    you should be doing preemptively unless you have measurements that confirm the
    need for it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于最后一个，如果值`a`、`b`和`c`是非负的，但需要进行单个条件操作。同样，这不是您应该预先进行的优化类型，除非您有测量结果证实需要进行优化。
- en: 'Here is another example. Consider this function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子。考虑这个函数：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It is very inefficient if the value of `b` is unpredictable. Much better performance
    is just a simple change away:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`b`的值是不可预测的，那么效率非常低。只需进行简单的更改，性能就会大大提高：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This improvement can be confirmed with a simple benchmark of the original,
    conditional, implementation versus the branchless one:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改进可以通过对原始的有条件的实现与无分支实现进行简单的基准测试来确认：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the branchless implementation is almost 3 times faster.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，无分支实现几乎快了3倍。
- en: 'It is important not to go overboard with this type of optimization. It must
    always be driven by the measurements, for several reasons:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过度追求这种类型的优化是很重要的。它必须始终受到测量的驱动，有几个原因：
- en: The branch predictors are quite complex, and our intuition about what they can
    and cannot handle is almost always wrong.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支预测器非常复杂，我们对它们能够处理和不能处理的直觉几乎总是错误的。
- en: The compiler optimizations can often change the code significantly, so, without
    measuring or examining the machine code, even our expectations of the existence
    of a branch can be wrong.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器优化通常会显著改变代码，因此，即使我们对分支的存在有期望，没有测量或检查机器代码，我们的期望也可能是错误的。
- en: Even if the branch is mispredicted, the performance impact can vary, so it is
    impossible to be sure without the measurement.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使分支被错误预测，性能影响也会有所不同，所以没有测量是不可能确定的。
- en: 'For example, it is almost never useful to manually optimize this very common
    code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，手动优化这种非常常见的代码几乎从来都不是有用的：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It looks like conditional code, and if the sign of `x` is random, the prediction
    is impossible. However, it is very likely that the profiler will not show a large
    number of mispredicted branches here. The reason is that most compilers will not
    implement this line using a conditional jump. On x86, some compilers will use
    the CMOVE instruction, which does a *conditional move*: it moves the value from
    one of two source registers to the destination, depending on the condition. The
    *conditional* nature of this instruction is benign: remember that the problem
    with conditional code is that the CPU does not know in advance which instruction
    to execute next. With a conditional move implementation, the sequence of instructions
    is perfectly linear, and their order is predetermined, so there is nothing to
    guess.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像是有条件的代码，如果`x`的符号是随机的，那么预测是不可能的。然而，很可能分析器不会显示出大量的错误预测分支。原因是大多数编译器不会使用条件跳转来实现这一行。在x86上，一些编译器会使用CMOVE指令，它执行*条件移动*：根据条件，它将两个源寄存器中的一个值移动到目的地。这个指令的*条件*性质是良性的：记住有条件的代码的问题在于CPU无法提前知道下一条指令要执行什么。有了条件移动的实现，指令序列是完全线性的，它们的顺序是预先确定的，所以没有什么需要猜测的。
- en: 'Another common example that is unlikely to benefit from a branchless optimization
    is a conditional function call:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的例子，不太可能从无分支优化中受益的是有条件的函数调用：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A branchless implementation is possible using an array of function pointers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用函数指针数组实现无分支。
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the functions were originally inlined, replacing them with an indirect function
    call is a performance killer. If they weren’t, this change likely does almost
    nothing: jumping to another function whose address is not known during compilation
    has an effect very similar to a mispredicted branch, so this code causes the CPU
    to flush the pipeline either way.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数最初是内联的，用间接函数调用替换它们会导致性能下降。如果它们不是，这种改变可能几乎没有任何作用：跳转到另一个在编译期间不知道地址的函数，其效果与错误预测的分支非常相似，因此这段代码无论如何都会导致CPU刷新流水线。
- en: The bottom line is, optimizing for branch prediction is a very advanced step.
    The results can be a spectacular improvement or a spectacular failure (or just
    some wasted time), so it is important to be guided by performance measurements
    at every step.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，优化分支预测是一个非常高级的步骤。结果可能是显著的改进，也可能是显著的失败（或者只是浪费时间），因此在每一步都要受到性能测量的指导是很重要的。
- en: We have now learned a lot about many kinds of potential inefficiencies in C++
    programs and ways to improve them. We conclude with some overall guidelines for
    optimizing your code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学到了很多关于C++程序中许多潜在的低效性以及改进它们的方法。我们总结一些优化代码的整体指导方针。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have covered the first of the two large areas of C++ efficiency
    from the language standpoint: avoiding inefficient language constructs, which
    boils down to not doing unnecessary work. Many optimization techniques we have
    studied dovetail with the material we studied earlier, such as the efficiency
    of accessing memory and avoiding false sharing in concurrent programs.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了C++效率的两个大领域中的第一个：避免低效的语言构造，这归结为不做不必要的工作。我们学习过的许多优化技术与我们早期学习的材料相契合，比如访问内存的效率以及在并发程序中避免虚假共享。
- en: 'The big dilemma every programmer faces is how much work should be invested
    upfront into writing efficient code and what should be left to incremental optimization.
    Let us begin by saying that high performance begins at the design stage: designing
    the architecture and the interfaces that do not lock in poor performance and inefficient
    implementations is the most important effort in developing high-performance software.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员面临的一个大困境是应该投入多少工作来编写高效的代码，以及什么应该留给增量优化。让我们首先说，高性能始于设计阶段：设计架构和接口，不锁定低性能和低效实现是开发高性能软件中最重要的工作。
- en: Beyond that, the distinction should be made between **premature optimization**
    and **unnecessary pessimization**. Creating temporary variables to avoid aliasing
    is premature unless you have performance measurement data showing that the function
    you are optimizing contributes greatly to the overall execution time (or unless
    it improves readability, which is a different matter). Passing large vectors by
    value until the profiler tells you to change it is just making your code slower
    for no reason, so it should be avoided from the start.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，应该区分**过早优化**和**不必要的性能下降**。为了避免别名问题而创建临时变量是过早的，除非你有性能测量数据表明你正在优化的函数对整体执行时间有很大贡献（或者除非它提高了可读性，这是另一回事）。直到分析器告诉你要改变为止，通过值传递大向量只会使你的代码变慢而没有理由，因此应该从一开始就避免。
- en: 'The line between the two is not always clear, so you must weigh several factors.
    You must consider the impact of the change on the program: does it make the code
    harder to read, more complex, or more difficult to test? Generally, you don’t
    want to risk making more bugs for the sake of performance unless the measurements
    tell you that you have to. On the other hand, sometimes more readable or more
    straightforward code is also more efficient code, then the optimization cannot
    be considered premature.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的界限并不总是清晰的，因此你必须权衡几个因素。你必须考虑改变对程序的影响：它是否使代码更难阅读，更复杂，或者更难测试？通常情况下，你不想冒着为了性能而增加更多bug的风险，除非测量告诉你你必须这样做。另一方面，有时更可读或更直接的代码也是更高效的代码，那么优化就不能被认为是过早的。
- en: The second major area of C++ efficiency has to do with helping the compiler
    generate more efficient code. We will cover this in the next chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: C++效率的第二个主要领域与帮助编译器生成更高效的代码有关。我们将在下一章中介绍这个问题。
- en: Questions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When is passing even large objects by value acceptable?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么时候通过值传递甚至大对象是可以接受的？
- en: When using resource-owning smart pointers, how should we invoke functions that
    operate on the objects?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用资源拥有智能指针时，我们应该如何调用操作对象的函数？
- en: What is the return value optimization, and where is it used?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是返回值优化，它在哪里使用？
- en: Why does inefficient memory management affect not just memory consumption but
    also runtime?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么低效的内存管理不仅影响内存消耗，还影响运行时间？
- en: What is the A-B-A problem?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是A-B-A问题？
