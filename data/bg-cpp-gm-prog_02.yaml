- en: Chapter 2. Variables, Operators, and Decisions – Animating Sprites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。变量、运算符和决策 - 动画精灵
- en: In this chapter we will do quite a bit more drawing on the screen and to achieve
    this we will need to learn some of the basics of C++.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在屏幕上进行更多的绘图，为了实现这一点，我们需要学习一些C++的基础知识。
- en: 'Here is what is in store:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有什么：
- en: Learning all about C++ variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习所有关于C++变量的知识
- en: Seeing how to manipulate the values stored in variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何操作变量中存储的值
- en: Adding a static tree, ready for the player to chop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个静态树，准备好供玩家砍伐
- en: Drawing and animating a bee and three clouds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制和动画一个蜜蜂和三朵云
- en: C++ variables
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++变量
- en: '**Variables** are the way that our C++ games store and manipulate values. If
    we want to know how much health the player has then we need a variable. Perhaps
    you want to know how many zombies are left in the current wave? That is a variable
    as well. If you need to remember the name of the player who got a particular high
    score, you guessed it, we need a variable for that. Is the game over or still
    playing? Yep, that''s a variable too.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**是我们的C++游戏存储和操作值的方式。如果我们想知道玩家有多少生命值，那么我们就需要一个变量。也许你想知道当前波中还剩下多少僵尸？那也是一个变量。如果您需要记住获得特定高分的玩家的名字，你猜对了，我们也需要一个变量。游戏结束了还是还在进行？是的，那也是一个变量。'
- en: Variables are named identifiers to locations in memory. So we might name a variable
    `numberOfZombies` and that variable could refer to a place in the memory that
    stores a value representing the number of zombies that are left in the current
    wave.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是内存中位置的命名标识符。因此，我们可以将一个变量命名为`numberOfZombies`，该变量可以指向存储表示当前波中剩余僵尸数量的值的内存位置。
- en: The way that computer systems address locations in memory is complex. Programming
    languages use variables to give a human-friendly way to manage our data in memory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统寻址内存位置的方式是复杂的。编程语言使用变量以人性化的方式管理我们在内存中的数据。
- en: Our brief discussion about variables implies that there must be different types
    of variable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对变量的简要讨论意味着必须有不同类型的变量。
- en: Types of variable
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量类型
- en: There are a wide variety of C++ variable types (see the next tip about variables).
    It would easily be possible to spend an entire chapter discussing them. What follows
    is a table of the most commonly used types in this book. Then we will look at
    how to actually use each of these variable types.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++有各种各样的变量类型（请参阅有关变量的下一个提示）。很容易花一个整章的时间来讨论它们。接下来是本书中最常用的类型的表格。然后我们将看看如何实际使用每种变量类型。
- en: '| **Type** | **Examples of values** | **Explanation** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **值的示例** | **解释** |'
- en: '| Int | `-42`, `0`, `1`, `9826`, and so on. | Integer whole numbers. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Int | `-42`，`0`，`1`，`9826`，等等。 | 整数整数。'
- en: '| Float | `-1.26f`, `5.8999996f`, `10128.3f` | Floating point values with precision
    up to 7 digits. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Float | `-1.26f`，`5.8999996f`，`10128.3f` | 浮点值，精度高达7位数字。|'
- en: '| Double | `925.83920655234`, `1859876.94872535` | Floating point values with
    precision up to 15 digits. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Double | `925.83920655234`，`1859876.94872535` | 浮点值，精度高达15位数字。'
- en: '| Char | `a`, `b`, `c`, `1`, `2`, `3` (a total of 128 symbols including `?`,
    `~`, `#`, and so on...) | Any symbol from the ASCII table (see next tip about
    variables). |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Char | `a`，`b`，`c`，`1`，`2`，`3`（包括`?`，`~`，`#`等共128个符号） | ASCII表中的任何符号（请参阅有关变量的下一个提示）。'
- en: '| Bool | True or false | Bool stands for Boolean and can be only `true` or
    `false`. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Bool | 真或假 | Bool代表布尔值，只能是`true`或`false`。'
- en: '| String | Hello everyone! I am a string. | Any text value from a single letter
    or digit up to perhaps an entire book. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| String | 大家好！我是一个字符串。 | 从单个字母或数字到整本书的任何文本值。'
- en: The compiler must be told what type a variable is, so that it can allocate the
    right amount of memory for it. It is good practice to use the best and most appropriate
    type for each and every variable you use. In practice, however, you will often
    get away with promoting a variable. Perhaps you need a floating-point number with
    just five significant digits? The compiler won't complain if you store it as a
    `double`. However, if you try to store a `float` or a `double` in an `int`, it
    will change/cast the value to fit the `int`. As we progress through the book,
    I clarify what is the best variable type to use in each case, and we will even
    see a few instances where we deliberately convert/cast between variable types.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器必须告诉变量是什么类型，以便为其分配正确的内存量。对于您使用的每个变量，使用最佳和最合适的类型是一个良好的实践。然而，在实践中，您通常可以提升一个变量。也许您只需要一个具有五个有效数字的浮点数？如果您将其存储为`double`，编译器不会抱怨。然而，如果您尝试将`float`或`double`存储在`int`中，它将更改/转换值以适应`int`。随着我们在书中的进展，我将澄清在每种情况下使用的最佳变量类型是什么，我们甚至会看到一些有意转换/转换变量类型的情况。
- en: A few extra details worth noticing, in the table above, include the `f` postfix
    next to all the `float` values. This `f` tells the compiler that the value is
    a `float` type not a `double`. A floating-point value without the `f` prefix is
    assumed to be a `double`. See the next tip about variables for more about this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的表中，还有一些额外的细节值得注意，包括所有`float`值旁边的`f`后缀。这个`f`告诉编译器该值是`float`类型而不是`double`。没有`f`前缀的浮点值被假定为`double`。有关此内容的更多信息，请参阅有关变量的下一个提示。
- en: As mentioned previously, there are many more types. If you want to find out
    more about types see the next tip about variables.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，还有许多其他类型。如果您想了解更多关于类型的信息，请参阅有关变量的下一个提示。
- en: Constants
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量
- en: 'Sometimes we need to make sure that a value can never be changed. To achieve
    this we can declare and initialize a **constant** using the `const` keyword:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要确保一个值永远不会被改变。为了实现这一点，我们可以使用`const`关键字声明和初始化一个**常量**：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is conventional to declare constants in all upper case. The value of the
    preceding constants can never be altered. We will see some constants in action
    in [Chapter 4](ch04.html "Chapter 4.  Loops, Arrays, Switch, Enumerations, and
    Functions – Implementing Game Mechanics"): *Loops, Arrays, Switch, Enumerations,
    and Functions - Implementing Game Mechanics*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯上，常量的声明都是大写的。前面常量的值永远不能被改变。我们将在[第4章](ch04.html "第4章。循环、数组、开关、枚举和函数 - 实现游戏机制")中看到一些常量的实际应用：*循环、数组、开关、枚举和函数
    - 实现游戏机制*。
- en: User-defined types
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的类型
- en: 'User-defined types are way more advanced than the types we have just seen.
    When we talk about user-defined types in C++ we are usually talking about classes.
    We briefly talked about classes and their related objects in the previous chapter.
    We can write code in a separate file, sometimes in two separate files. From these
    we will then be able to declare, initialize, and use them. We will leave how we
    define/create our own types until [Chapter 6](ch06.html "Chapter 6.  Object-Oriented
    Programming, Classes, and SFML Views"): *Object-Oriented Programming, Classes,
    and SFML Views*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的类型比我们刚刚看到的类型要先进得多。当我们在C++中谈论用户定义的类型时，通常是指类。我们在上一章中简要讨论了类及其相关对象。我们可以在一个单独的文件中编写代码，有时甚至是在两个单独的文件中。然后我们将能够声明、初始化和使用它们。我们将把如何定义/创建我们自己的类型留到[第6章](ch06.html
    "第6章。面向对象编程、类和SFML视图")：*面向对象编程、类和SFML视图*。
- en: Declaring and initializing variables
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明和初始化变量
- en: So far we know that variables are for storing the data/values that our games
    need in order to work. For example, a variable could represent the number of lives
    a player has or the player's name. We also know that there is a wide selection
    of different types of values that these variables can represent, such as `int`,
    `float`, `bool`, and so on. Of course what we haven't seen yet is how we would
    actually go about using a variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道变量用于存储游戏中需要的数据/值。例如，一个变量可以表示玩家拥有的生命值或玩家的姓名。我们还知道这些变量可以表示各种不同类型的值，比如`int`、`float`、`bool`等。当然，我们还没有看到如何实际使用变量。
- en: There are two stages for creating and preparing a new variable. The stages are
    called **declaration** and **initialization**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和准备新变量有两个阶段。这两个阶段称为**声明**和**初始化**。
- en: Declaring variables
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'We can declare variables in C++ like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在C++中这样声明变量：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Initializing variables
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化变量
- en: 'Now we have declared the variables with meaningful names, we can initialize
    those same variables with appropriate values, like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用有意义的名称声明了变量，我们可以用适当的值初始化这些变量，就像这样：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Declaring and initializing in one step
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一步声明和初始化
- en: 'When it suits us, we can combine the declaration and initialization steps into
    one:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当适合我们时，我们可以将声明和初始化步骤合并为一步：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Variables tip**As promised, here is the tip on variables. If you want to
    see a complete list of C++ types then check this web page: [http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm](http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm).
    If you want a deeper discussion on floats, doubles, and the `f` postfix then read
    this: [http://www.cplusplus.com/forum/beginner/24483/](http://www.cplusplus.com/forum/beginner/24483/).
    And if you want to know the ins and out of  ASCII character codes then there is
    some more information here: [http://www.cplusplus.com/doc/ascii/](http://www.cplusplus.com/doc/ascii/).
    Note that these links are for the curious reader and we have already discussed
    enough in order to proceed.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量提示**正如承诺的那样，这是关于变量的提示。如果你想看到完整的C++类型列表，那么请查看这个网页：[http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm](http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm)。如果你想深入讨论浮点数、双精度和`f`后缀，那么请阅读这篇文章：[http://www.cplusplus.com/forum/beginner/24483/](http://www.cplusplus.com/forum/beginner/24483/)。如果你想了解ASCII字符代码的方方面面，那么这里有更多信息：[http://www.cplusplus.com/doc/ascii/](http://www.cplusplus.com/doc/ascii/)。请注意，这些链接是给好奇的读者的，我们已经讨论了足够的内容以便继续进行。'
- en: Declaring and initializing user-defined types
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明和初始化用户定义的类型
- en: We have already seen examples of how we declare and initialize some SFML defined
    types. Because the way we can create/define these types (classes) is so flexible,
    the way we declare and initialize them is also highly varied. Here are a couple
    of reminders for declaring and initializing user-defined types, from the previous
    chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何声明和初始化一些SFML定义的类型的示例。由于我们可以创建/定义这些类型（类）的方式非常灵活，因此我们声明和初始化它们的方式也是多种多样的。以下是前一章中关于声明和初始化用户定义的类型的一些提醒。
- en: 'Create an object of type `VideoMode`, called `vm`, and initialize it with two
    `int` values, `1920` and `1080`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类型为`VideoMode`的对象，名为`vm`，并用两个`int`值`1920`和`1080`进行初始化：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create an object of type `Texture`, called `textureBackground` but don''t do
    any initialization:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类型为`Texture`的对象，名为`textureBackground`，但不进行任何初始化：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that it is possible (in fact very likely) that even though we are not suggesting
    any specific values with which to initialize `textureBackground`, some variables
    may be set up internally. Whether or not an object needs/has the option of giving
    initialization values at this point is entirely dependent on how the class is
    coded and is almost infinitely flexible. This further suggests that when we get
    to write our own classes there will be some complexity. Fortunately, it also means
    we will have significant power to design our types/classes, so they are just what
    we need to make our games! Add this huge flexibility to SFML-designed classes
    and the potential for our games is almost limitless.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使我们没有建议使用哪些特定值来初始化`textureBackground`，某些变量可能已在内部设置。对象是否需要/具有在此时给出初始化值的选项完全取决于类的编码方式，几乎是无限灵活的。这进一步表明，当我们开始编写自己的类时，会有一些复杂性。幸运的是，这也意味着我们将有重大的权力来设计我们的类型/类，使它们正是我们需要的来制作我们的游戏！将这种巨大的灵活性添加到SFML设计的类中，我们的游戏的潜力几乎是无限的。
- en: We will see a few more user-created types/classes provided by SFML in this chapter
    too and loads more throughout the book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将看到SFML提供的一些用户创建的类型/类，以及本书中的更多内容。
- en: Manipulating variables
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作变量
- en: At this point we know exactly what variables are, the main types, and how to
    declare and initialize them, but we still can't do that much with them. We need
    to manipulate our variables, add them, take them away, multiply, divide, and test
    them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们确切地知道了变量是什么，主要类型是什么，以及如何声明和初始化它们，但我们仍然不能做太多事情。我们需要操作我们的变量，加上它们，减去它们，乘以它们，除以它们，并测试它们。
- en: First we will deal with how we can manipulate them and later we will look at
    how and why we test them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理如何操作它们，稍后我们将看看我们如何以及为什么测试它们。
- en: C++ arithmetic and assignment operators
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++算术和赋值运算符
- en: 'In order to manipulate variables, C++ has a range of **arithmetic operators**
    and **assignment operators**. Fortunately, most arithmetic and assignment operators
    are quite intuitive to use, and those that aren''t are quite easy to explain.
    To get us started, let''s look at a table of arithmetic operators followed by
    a table of assignment operators that we will regularly use throughout this book:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作变量，C++有一系列**算术运算符**和**赋值运算符**。幸运的是，大多数算术和赋值运算符使用起来相当直观，而那些不直观的则很容易解释。为了让我们开始，让我们先看一张算术运算符表，然后是一张我们将在本书中经常使用的赋值运算符表：
- en: '| **Arithmetic operator** | **Explanation** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **算术运算符** | **解释** |'
- en: '| `+` | The addition operator can be used to add together the values of two
    variables or values. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法运算符可用于将两个变量或值的值相加。|'
- en: '| `-` | The subtraction operator can be used to take away the value of one
    variable or value from another variable or value. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法运算符可用于从另一个变量或值中减去一个变量或值的值。|'
- en: '| `*` | The multiplication operator can multiply the value of variables and
    values. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法运算符可以将变量和值的值相乘。|'
- en: '| `/` | The division operator can divide the value of variables and values.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法运算符可以除以变量和值的值。|'
- en: '| `%` | The modulo operator divides a value or variable by another value or
    variable to find the remainder of the operation. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取模运算符将一个值或变量除以另一个值或变量，以找到操作的余数。|'
- en: 'And now for the assignment operators:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是赋值运算符的时候了：
- en: '| **Assignment operators** | **Explanation** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **赋值运算符** | **解释** |'
- en: '| `=` | We have already seen this one. It is *the* assignment operator. We
    use it to initialize/set a variable''s value. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 我们已经见过这个了。这是*赋值*运算符。我们用它来初始化/设置变量的值。|'
- en: '| `+=` | Add the value on the right-hand side to the variable on the left.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `+=` | 将右侧的值加到左侧的变量上。|'
- en: '| **`-=`** | Take away the value on the right-hand side from the variable on
    the left. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **`-=`** | 从左侧的变量中减去右侧的值。|'
- en: '| `*=` | Multiply by the value on the right-hand side by the variable on the
    left. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `*=` | 将右侧的值乘以左侧的变量。|'
- en: '| `/=` | Divide the value on the right-hand side by the variable on the left.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `/=` | 将右侧的值除以左侧的变量。|'
- en: '| `++` | **Increment** operator; add 1 to a variable |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `++` | **递增**运算符；将变量加1|'
- en: '| `--` | **Decrement** operator; take away 1 from a variable |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `--` | **递减**运算符；从变量中减去1|'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, all the above operators except for `=, --` and `++` are called
    **compound assignment operators** because they comprise more than one operator.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，除了`=, --`和`++`之外，上述所有运算符都被称为**复合赋值运算符**，因为它们包含多个运算符。
- en: Now that we have seen a good range of arithmetic and assignment operators we
    can actually see how to manipulate our variables by combining operators, variables,
    and values to form **expressions**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经看到了一系列算术和赋值运算符，我们实际上可以看到如何通过组合运算符、变量和值来操作我们的变量形成**表达式**。 '
- en: Getting things done with expressions
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过表达式完成任务
- en: '**Expressions** are combinations of variables, operators, and values. Using
    expressions we can arrive at a result. Furthermore, as we will soon see, we can
    use an expression in a test. These tests can be used to decide what our code should
    do next. First, let''s look at some simple expressions we might see in our game
    code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**是变量、运算符和值的组合。使用表达式，我们可以得出一个结果。此外，正如我们很快将看到的那样，我们可以在测试中使用表达式。这些测试可以用来决定我们的代码接下来应该做什么。首先，让我们看一些可能在游戏代码中看到的简单表达式：'
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: or
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Take a look at the addition operator, used in conjunction with the assignment
    operator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下加法运算符，与赋值运算符一起使用：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: or
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that it is perfectly acceptable to use the same variable on both sides
    of an operator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在运算符的两侧使用相同的变量是完全可以接受的。
- en: 'Take a look at the subtraction operator in conjunction with the assignment
    operator. This next code subtracts the value on the right side of the subtraction
    operator from the value on the left. It is usually used in conjunction with the
    assignment operator, for example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下减法运算符与赋值运算符的结合。下面的代码从减法运算符右侧的值中减去左侧的值。它通常与赋值运算符一起使用，例如：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: or
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is how we might use the division operator. This next code divides the
    number on the left by the number on the right. Again, it is usually used with
    the assignment operator, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可能使用除法运算符的方式。下面的代码将左边的数字除以右边的数字。同样，它通常与赋值运算符一起使用，如下所示：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: or
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Obviously, in the previous example, the variable `recycledValueOfBlock` will
    need to be of the type `float` to accurately store the answer to a calculation
    like that.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在前面的例子中，变量`recycledValueOfBlock`需要是`float`类型，以准确存储这样的计算结果。
- en: 'Perhaps unsurprisingly, we could use the multiplication operator like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 也许并不令人惊讶，我们可以像这样使用乘法运算符：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: or
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As an aside, have you ever wondered how C++ got its name? C++ is an extension
    of the C language. Its inventor, Bjarne Stroustrup**,** originally called it *C
    with classes* but the name evolved. If you are interested, read the C++ story
    at : [http://www.cplusplus.com/info/history/](http://www.cplusplus.com/info/history/).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，你是否曾经想过C++是怎么得到它的名字的？C++是C语言的扩展。它的发明者Bjarne Stroustrup最初称其为*C with classes*，但名称发生了变化。如果您感兴趣，请阅读C++的故事：[http://www.cplusplus.com/info/history/](http://www.cplusplus.com/info/history/)。
- en: Now, let's take a look at the increment operator in action. This is a really
    neat way to add `1` to the value of one of our game's variables.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看增量运算符的运行情况。这是一个非常巧妙的方法，可以将`1`添加到我们游戏变量的值中。
- en: 'Take a look at this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这段代码：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It gives the same result as this code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生了与这段代码相同的结果：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The decrement operator `--` is, you guessed it, a really neat way to subtract
    `1` from something:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 递减运算符`--`，你猜对了，是从某个数值中减去`1`的一个非常巧妙的方法：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is the same as this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这与这个是一样的：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s look at a few more operators in action and then we can get back to building
    the Timber!!! game:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些操作符的运行情况，然后我们可以继续构建Timber!!!游戏：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now it's time to add some more sprites to our game.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向我们的游戏添加一些更多的精灵了。
- en: Adding clouds, a tree, and a buzzing bee
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加云，树和嗡嗡蜜蜂
- en: First we will add a tree. This is going to be really easy. The reason it's easy
    is because the tree doesn't move. We will use exactly the same procedure that
    we used in the previous chapter when we drew the background.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将添加一棵树。这将非常容易。之所以容易是因为树不会移动。我们将使用与我们在上一章绘制背景时完全相同的过程。
- en: Preparing the tree
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备树
- en: 'Add the following highlighted code. Notice the un-highlighted code, which is
    the code that we have already written. This should help you identify that the
    new code should be typed immediately after we set the position of the background,
    but before the start of the main game loop. We will recap what is actually going
    on in the new code after you have added it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下面突出显示的代码。注意未突出显示的代码，这是我们已经编写的代码。这应该帮助您确定新代码应该在设置背景位置之后立即输入，但在主游戏循环开始之前。在您添加新代码之后，我们将回顾新代码的实际情况：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The five lines of code (excluding the comment) that we just added do the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的五行代码（不包括注释）做了以下事情：
- en: First, we create an object of the type `Texture` called `textureTree`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`textureTree`的`Texture`类型对象。
- en: Next, we load a graphic into the texture from the `tree.png` graphics file.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们从`tree.png`图形文件中将图形加载到纹理中。
- en: Next, we declare an object of the type `Sprite` called `spriteTree`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们声明了一个名为`spriteTree`的`Sprite`类型对象。
- en: Now, we associate `textureTree` with `spriteTree`. Whenever we draw `spriteTree`
    it will show the `textureTree` texture, which is a neat tree graphic.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们将`textureTree`与`spriteTree`关联起来。每当我们绘制`spriteTree`时，它将显示`textureTree`纹理，这是一个漂亮的树形图形。
- en: Finally we set the position of the tree using the coordinates `810` on the x
    axis and 0 on the y axis.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用x轴上的坐标`810`和y轴上的坐标0设置了树的位置。
- en: Let's move on to the bee object, which is handled in an almost identical manner.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续处理蜜蜂对象，这几乎是以相同的方式处理的。
- en: Preparing the bee
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备蜜蜂
- en: 'The difference between this next code and the tree code is small but important.
    As the bee needs to move, we also declare two bee-related variables. Add the highlighted
    code in the place shown, and see if you can work out how we might use the variables
    `beeActive` and `beeSpeed`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码与树代码之间的差异很小但很重要。由于蜜蜂需要移动，我们还声明了两个与蜜蜂相关的变量。在所示的位置添加突出显示的代码，并看看我们如何使用变量`beeActive`和`beeSpeed`：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create a bee in exactly the same way we created a background and a tree.
    We use a `Texture` and a `Sprite`, and associate the two. Note that in the previous
    bee code there was some new code we haven't seen before. There is a `bool` variable
    for determining whether or not the bee is active. Remember that a `bool` variable
    can be either `true` or `false`. We initialize `beeActive` to `false`, for now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建蜜蜂的方式与我们创建背景和树的方式完全相同。我们使用`Texture`和`Sprite`，并将两者关联起来。请注意，在以前的蜜蜂代码中，有一些我们以前没有见过的新代码。有一个用于确定蜜蜂是否活动的`bool`变量。请记住，`bool`变量可以是`true`或`false`。我们暂时将`beeActive`初始化为`false`。
- en: Next, we declare a new `float` variable called `beeSpeed`. This will hold the
    speed, in pixels per second, at which our bee will fly across the screen.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个名为`beeSpeed`的新`float`变量。这将保存我们的蜜蜂在屏幕上飞行的速度，以像素为单位每秒。
- en: Soon we will see how we use these two new variables to move the bee. Before
    we do, let's set up some clouds in an almost identical manner.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 很快我们将看到如何使用这两个新变量来移动蜜蜂。在我们这样做之前，让我们以几乎相同的方式设置一些云。
- en: Preparing the clouds
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备云
- en: 'Add the highlighted code shown next. Study the new code and try and work out
    what it will do:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下面显示的突出显示的代码。研究新代码，尝试弄清楚它将做什么：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only thing about the code we have just added that might seem a little odd
    is that we have only one object of the type `Texture`. It's completely normal
    for multiple `Sprite` objects to share a texture. Once a `Texture` is stored in
    the GPU memory it can be associated with a `Sprite` object very quickly. It is
    only the initial loading of the graphic in the `loadFromFile` code that is a relatively
    slow operation. Of course, if we wanted three different-shaped clouds then we
    would need three textures.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码中唯一有点奇怪的是，我们只有一个`Texture`类型的对象。多个`Sprite`对象共享一个纹理是完全正常的。一旦`Texture`存储在GPU内存中，它就可以与`Sprite`对象快速关联。只有在`loadFromFile`代码中加载图形的初始操作相对较慢。当然，如果我们想要三个不同形状的云，那么我们就需要三个纹理。
- en: Apart from the minor texture issue, the code we have just added is nothing new
    compared to the bee. The only difference is that there are three cloud sprites,
    three `bool` variables to determine if each cloud is active and three `float`
    variables to hold the speed for each cloud.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了轻微的纹理问题，我们刚刚添加的代码与蜜蜂相比并没有什么新的。唯一的区别是有三个云精灵，三个用于确定每朵云是否活动的`bool`变量和三个用于保存每朵云速度的`float`变量。
- en: Drawing the tree, the bee, and the clouds
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制树、蜜蜂和云
- en: 'Finally we can draw them all onto the screen by adding this highlighted code
    in the drawing section:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过在绘图部分添加这个突出显示的代码将它们全部绘制到屏幕上：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Drawing the three clouds, the bee, and the tree is done in exactly the same
    way that the background was drawn. Notice, however, the order in which we draw
    the different objects to the screen. We must draw all the graphics after the background
    or they will be covered, and we must draw the clouds before the tree or they will
    look a bit odd drifting in front of the tree. The bee would look OK either in
    front or behind the tree. I opted to draw the bee in front of the tree so that
    it can try and distract our lumberjack, a bit like a real bee might.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制三朵云、蜜蜂和树的方式与绘制背景的方式完全相同。然而，请注意我们绘制不同对象到屏幕的顺序。我们必须在背景之后绘制所有图形，否则它们将被覆盖，而且我们必须在树之前绘制云，否则它们在树前飘来飘去会看起来有点奇怪。蜜蜂无论在树前还是树后看起来都可以。我选择在树前画蜜蜂，这样它就可以试图分散我们的伐木工的注意力，有点像真正的蜜蜂可能会做的。
- en: Run Timber!!! and gaze in awe at the tree, three clouds, and a bee, which don't
    do anything! They look like they are lining up for a race, where the bee goes
    backwards.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Timber!!!并对树、三朵云和一只蜜蜂感到敬畏，它们什么都不做！它们看起来像是在为比赛排队，蜜蜂倒着飞。
- en: '![Drawing the tree, the bee, and the clouds](img/image_02_001-300x169.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![绘制树、蜜蜂和云](img/image_02_001-300x169.jpg)'
- en: Using what we know about operators, we could try and move the graphics around
    that we have just added, but there are a couple of problems. Firstly, real clouds
    and bees move in a non-uniform manner. They don't have a set speed or location.
    Although their location and speed are determined by factors such as wind speed
    or how much of a hurry the bee might be in, to the casual observer the path they
    take, and their speed, appear random.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们对运算符的了解，我们可以尝试移动我们刚刚添加的图形，但有一些问题。首先，真实的云和蜜蜂以不均匀的方式移动。它们没有固定的速度或位置。尽管它们的位置和速度是由风速或蜜蜂可能的匆忙程度等因素决定的，但对于一般观察者来说，它们所采取的路径和速度似乎是随机的。
- en: Random numbers
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机数
- en: '**Random numbers** are useful for lots of reasons in games. Perhaps you could
    use them for determining what card the player is dealt, or how much damage within
    a certain range is subtracted from an enemy''s health. As hinted at, we will use
    random numbers to determine the starting location and the speed of the bee and
    the clouds.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机数**在游戏中有很多用途。也许你可以用它们来确定玩家得到的是什么牌，或者从敌人的健康中减去多少范围内的伤害。正如暗示的那样，我们将使用随机数来确定蜜蜂和云的起始位置和速度。'
- en: Generating random numbers in C++
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C++中生成随机数
- en: To generate random numbers we will need to use some more C++ functions, two
    more to be precise. Don't add any code to the game yet. Let's just take a look
    at the syntax and the steps required with some hypothetical code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成随机数，我们需要使用更多的C++函数，确切地说是两个。现在不要向游戏中添加任何代码。让我们只看一下语法和一些假设代码所需的步骤。
- en: 'Computers can''t actually pick random numbers. They can only use algorithms/calculations
    to pick a number that *appears* to be random. So that this algorithm doesn''t
    constantly return the same value, we must **seed** the random number generator.
    The seed can be any integer number, although it must be a different seed each
    time you require a unique random number. Take a look at this code, which seeds
    the random number generator:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机实际上不能选择随机数。它们只能使用算法/计算来选择一个*看起来*是随机的数字。为了使这个算法不断返回相同的值，我们必须**种子**随机数生成器。种子可以是任何整数，尽管每次需要一个唯一的随机数时，它必须是一个不同的种子。看一下这段代码，它种子了随机数生成器：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code above gets the time from the PC using the `time` function like this
    `time(0)`. The call to the `time` function is enclosed as the value to be sent
    to the `srand` function. The result of this is that the current time is used as
    the seed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用`time`函数从PC获取时间，就像这样`time(0)`。对`time`函数的调用被封装为要发送到`srand`函数的值。其结果是当前时间被用作种子。
- en: The previous code is made to look a little more complicated because of the slightly
    unusual-looking `(int)` syntax. What this does is convert/cast the value returned
    from `time` to an `int`. This is required by the `srand` function in this situation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于略显不寻常的`(int)`语法，前面的代码看起来有点复杂。这样做的目的是将从`time`返回的值转换/转型为`int`。在这种情况下，这是`srand`函数所必需的。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A conversion from one type to another is called a **cast**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从一种类型转换为另一种类型称为**转换**。
- en: 'So, in summary, this is what happens in the previous line of code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，前一行代码发生了什么：
- en: It gets the time using `time`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`time`获取时间
- en: It converts it to type `int`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将其转换为类型`int`
- en: It sends this resulting value to `srand`, which seeds the random number generator
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将这个结果值发送给`srand`，用于生成随机数
- en: The time is, of course, always changing. This makes the `time` function a great
    way to seed the random number generator. However, think about what might happen
    if we seed the random number generator more than once and in such quick succession
    that `time` returns the same value? We will see and solve this problem when we
    animate our clouds.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，时间是不断变化的。这使得`time`函数成为种子随机数生成器的好方法。然而，想想如果我们多次并且在很短的时间内种子随机数生成器，以至于`time`返回相同的值会发生什么？当我们给云动画时，我们将看到并解决这个问题。
- en: 'At this stage we can create a random number between a range, and save it to
    a variable for later use:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以创建一个在范围内的随机数，并将其保存到一个变量中以备后用：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice the odd-looking way we assign a value to `number`. By using the Modulo
    operator `%` and the value of `100`, we are asking for the remainder, after dividing
    the number returned from `rand` by `100`. When you divide by `100`, the highest
    number you can possibly have as a remainder is 99\. The lowest number possible
    is 0\. Therefore the previous code will generate a number between 0 and 99 inclusive.
    This knowledge will be really useful for generating a random speed and starting
    location for our bees and clouds.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们分配一个值给`number`的奇怪方式。通过使用取模运算符`%`和值`100`，我们要求在将`rand`返回的数字除以`100`后得到余数。当你除以`100`时，你可能得到的最大数字是99。最小的可能数字是0。因此，前面的代码将生成一个在0到99之间的数字。这个知识对于为我们的蜜蜂和云生成随机速度和起始位置将非常有用。
- en: We will do this soon, but we first need to learn how to make decisions in C++.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会做到这一点，但我们首先需要学习如何在C++中做出决定。
- en: Making decisions with if and else
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if和else做决定
- en: 'The C++ `if` and `else` keywords are what enable us to make decisions. Actually,
    we have already seen `if` in action in the previous chapter when we detected,
    in each frame, whether the player had pressed the ***Esc***  key:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: C++的`if`和`else`关键字是让我们做决定的关键。实际上，在上一章中，当我们在每一帧中检测到玩家是否按下了***Esc***键时，我们已经看到了`if`的作用：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So far we have seen how we can use arithmetic and assignment operators to create
    expressions. Now we can see some new operators.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用算术和赋值运算符来创建表达式。现在我们可以看到一些新的运算符。
- en: Logical operators
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: '**Logical operators** are going to help us make decisions by building expressions
    that can be tested for a value of either true or false. At first this might seem
    like quite a narrow choice and insufficient for the kind of choices that might
    be needed in an advanced PC game. Once we dig a little deeper, we will see that
    we can actually make all the required decisions we will need, with just a few
    logical operators.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑运算符**将通过构建可以测试为真或假的表达式来帮助我们做出决定。起初，这可能看起来像是一个非常狭窄的选择，不足以满足高级PC游戏中可能需要的选择。一旦我们深入挖掘，我们将看到我们实际上可以只用几个逻辑运算符就能做出所有需要的决定。'
- en: Here is a table of the most useful logical operators. Take a look at them and
    their associated examples, and then we will see how to put them to use.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '下面是一个最有用的逻辑运算符的表格。看一下它们及其相关的例子，然后我们将看看如何使用它们。 '
- en: '| **Logical operator** | **Name and example** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **名称和例子** |'
- en: '| `==` | The **comparison operator** tests for equality and is either true
    or false. An expression such as `(10 == 9)`, for example, is false. 10 is obviously
    not equal to 9. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `==` | **比较运算符**测试相等性，要么为真，要么为假。例如，表达式`(10 == 9)`是假的。10显然不等于9。|'
- en: '| `!` | This is the logical **NOT** operator. The expression `(! (2 + 2 ==
    5))`. This is true because `2 + 2` is NOT `5` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 这是逻辑**非**运算符。表达式`(! (2 + 2 == 5))`。这是真的，因为`2 + 2`不等于`5`。|'
- en: '| `!=` | This is another comparison operator but is different to the `=` comparison
    operator. This tests if something is **NOT equal**. For example, the expression
    `(10 != 9)` is true. `10` is not equal to `9`. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 这是另一个比较运算符，但与`=`比较运算符不同。这测试是否**不相等**。例如，表达式`(10 != 9)`是真的。`10`不等于`9`。|'
- en: '| `>` | Another comparison operator - actually there are a few more as well.
    This tests if something is greater than something else. The expression `(10 >
    9)` is true. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 另一个比较运算符 - 实际上还有几个。这测试某物是否大于其他某物。表达式`(10 > 9)`是真的。|'
- en: '| `<` | You guessed it. This tests for values less than. The expression `(10
    < 9)` is false. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 你猜对了。这测试小于的值。表达式`(10 < 9)`是假的。|'
- en: '| `>=` | This operator tests for whether one value is greater than or equal
    to the other, and if either is true, the result is true. For example, the expression
    `(10 >= 9)` is true. The expression `(10 >= 10)` is also true. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 这个运算符测试一个值是否大于或等于另一个值，如果其中一个为真，结果就为真。例如，表达式`(10 >= 9)`是真的。表达式`(10
    >= 10)`也是真的。|'
- en: '| `<=` | Like the previous operator, this one tests for two conditions, but
    this time less than or equal to. The expression `(10 <= 9)` is false. The expression
    `(10 <= 10)` is true. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 像前一个运算符一样，这个运算符测试两个条件，但这次是小于或等于。表达式`(10 <= 9)`是假的。表达式`(10 <= 10)`是真的。|'
- en: '| `&&` | This operator is known as logical **AND**. It tests two or more separate
    parts of an expression and both parts must be true in order for the result to
    be true. Logical AND is usually used in conjunction with the other operators to
    build more complex tests. The expression `((10 > 9) && (10 < 11))` is true because
    both parts are true, so the expression is true. The expression `((10 > 9) && (10
    < 9))` is false because only one part of the expression is true and the other
    is false. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 这个运算符称为逻辑**与**。它测试表达式的两个或多个单独部分，两个部分都必须为真，结果才为真。逻辑AND通常与其他运算符一起用于构建更复杂的测试。表达式`((10
    > 9) && (10 < 11))`是真的，因为两个部分都为真，所以表达式为真。表达式`((10 > 9) && (10 < 9))`是假的，因为表达式的一部分为真，另一部分为假。|'
- en: '| `&#124;&#124;` | This operator is called logical **OR,** and it is just like
    logical AND except that at least one, of two or more parts of an expression, needs
    to be true for the expression to be true. Let''s look at the last example we used
    above but replace the `&&` with `&#124;&#124;`. The expression `((10 > 9) &#124;&#124;
    (10 < 9))` is now true because one part of the expression is true. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 这个运算符称为逻辑**或**，它与逻辑AND类似，只是表达式的两个或多个部分中至少有一个为真，表达式才为真。让我们看看我们上面使用的最后一个例子，但用`&#124;&#124;`替换`&&`。表达式`((10
    > 9) &#124;&#124; (10 < 9))`现在为真，因为表达式的一部分为真。|'
- en: Let's meet the C++ `if` and `else` keywords which will enable us to put all
    these logical operators to good use.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来认识一下C++的`if`和`else`关键字，它们将使我们能够充分利用所有这些逻辑运算符。
- en: C++ if and else
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++的if和else
- en: Let's make the previous examples less abstract. Meet the C++ `if` keyword. We
    will use `if` and a few operators along with a small story to demonstrate their
    use. Next follows a made-up military situation that will hopefully be less abstract
    than the previous examples.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把之前的例子变得不那么抽象。见识一下C++的`if`关键字。我们将使用`if`和一些运算符以及一个小故事来演示它们的用法。接下来是一个虚构的军事情况，希望它比之前的例子更具体。
- en: If they come over the bridge, shoot them!
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果他们过桥了，就射击他们！
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a C++ program to convey his last orders for after
    he has died. The troops must hold one side of a bridge while awaiting reinforcements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 队长垂危，知道他剩下的部下经验不足，决定编写一个C++程序，在他死后传达他的最后命令。部队必须在等待增援时守住桥的一侧。
- en: 'The first command the captain wants to make sure his troops understand is this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 队长想要确保他的部队理解的第一个命令是：
- en: '*"If they come over the bridge, shoot them!"*'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “如果他们过桥了，就射击他们！”
- en: 'So, how do we simulate this situation in C++? We need a `bool` variable: `isComingOverBridge`.
    The next bit of code assumes that the `isComingOverBridge` variable has been declared
    and initialized to either `true` or `false`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在C++中模拟这种情况呢？我们需要一个`bool`变量：`isComingOverBridge`。下一段代码假设`isComingOverBridge`变量已经被声明并初始化为`true`或`false`。
- en: 'We can then use `if` like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样使用`if`：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the `isComingOverBridge` variable is equal to `true`, the code inside the
    opening and closing curly braces `{...}` will run. If not, the program continues
    after the `if` block and without running the code within it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isComingOverBridge`变量等于`true`，则大括号`{...}`内的代码将运行。如果不是，则程序在`if`块之后继续运行，而不运行其中的代码。
- en: Or do this instead
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 或者做这个
- en: The captain also wants to tell his troops to stay put, if the enemy is not coming
    over the bridge.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 队长还想告诉他的部队，如果敌人没有过桥就待在原地。
- en: Now we can introduce another C++ keyword, `else`. When we want to explicitly
    do something when the `if` does not evaluate to `true`, we can use `else`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以介绍另一个C++关键字，`else`。当`if`的评估结果不为`true`时，我们可以使用`else`来明确执行某些操作。
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we could write this code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要告诉部队如果敌人没有过桥就待在原地，我们可以写下这段代码：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The captain then realized that the problem wasn''t as simple as he first thought.
    What if the enemy comes over the bridge, but has too many troops? His squad would
    be overrun and slaughtered. So, he came up with this code (we''ll use some variables
    as well this time.):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后队长意识到问题并不像他最初想的那么简单。如果敌人过桥，但是人数太多怎么办？他的小队将被压垮和屠杀。所以，他想出了这段代码（这次我们也会使用一些变量。）：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The above code has three possible paths of execution. The first one is if the
    enemy is coming over the bridge, and the friendly troops are greater in number:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码有三种可能的执行路径。第一种是如果敌人从桥上过来，友军人数更多：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second is if the enemy troops are coming over the bridge but outnumber
    the friendly troops:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种是如果敌军正在过桥，但人数超过友军：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then the third and final possible outcome, which will execute if neither of
    the others is `true`, is captured by the final `else`, without an `if` condition.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后第三种可能的结果，如果其他两种都不为`true`，则由最终的`else`捕获，没有`if`条件。
- en: Reader challenge
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读者挑战
- en: 'Can you spot a flaw with the preceding code? One that might leave a bunch of
    inexperienced troops in complete disarray? The possibility of the enemy troops
    and friendly troops being exactly equal in number has not been handled explicitly,
    and would therefore be handled by the final `else`. The final `else` is meant
    for when there are no enemy troops. I guess any self-respecting captain would
    expect his troops to fight in this situation. He could change the first `if` statement
    to accommodate this possibility:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现上述代码的一个缺陷吗？这可能会让一群经验不足的部队陷入完全混乱的状态吗？敌军和友军人数完全相等的可能性没有被明确处理，因此将由最终的`else`处理。最终的`else`是用于没有敌军的情况。我想任何有自尊心的队长都会期望他的部队在这种情况下战斗。他可以改变第一个`if`语句以适应这种可能性：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And finally, the captain''s last concern was that, if the enemy came over the
    bridge waving the white flag of surrender and were promptly slaughtered, then
    his men would end up as war criminals. The C++ code needed was obvious. Using
    the `wavingWhiteFlag` Boolean variable he wrote this test:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，队长最后关心的是，如果敌人拿着白旗过桥投降，然后被立即屠杀，那么他的士兵最终会成为战争罪犯。显而易见的是需要C++代码。使用`wavingWhiteFlag`布尔变量，他写下了这个测试：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But the issue of where to put this code was less clear. In the end, the captain
    opted for the following nested solution and for changing the test for `wavingWhiteFlag`
    to logical NOT, like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但是放置这段代码的问题并不太清楚。最后，队长选择了以下嵌套解决方案，并将`wavingWhiteFlag`的测试更改为逻辑非，就像这样：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This demonstrates that we can nest `if` and `else` statements inside one another
    to create quite deep and detailed decisions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们可以嵌套`if`和`else`语句以创建相当深入和详细的决策。
- en: We could go on making more and more complicated decisions with `if` and `else`
    but what we have seen is more than sufficient as an introduction. It is probably
    worth pointing out that, very often there is more than one way to arrive at a
    solution to a problem. The right way will usually be the way that solves the problem
    in the clearest and simplest manner.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用`if`和`else`做出更复杂的决定，但我们已经看到的足够作为介绍。值得指出的是，通常解决问题的方法不止一种。通常正确的方法是以最清晰和最简单的方式解决问题。
- en: We are getting closer to having all the C++ knowledge we need to be able to
    animate our clouds and bee. We have one final animation issue to discuss and then
    we can get back to the game.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接近拥有所有我们需要的C++知识，以便能够为我们的云和蜜蜂制作动画。我们还有一个最后的动画问题要讨论，然后我们可以回到游戏中。
- en: Timing
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: Before we can move the bee and the clouds, we need to consider timing. As we
    already know, the main game loop executes over and over again, until the player
    presses the ***Esc***  key.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们移动蜜蜂和云之前，我们需要考虑时间。正如我们已经知道的，主游戏循环一遍又一遍地执行，直到玩家按下***Esc***键。
- en: We have also learnt that C++ and SFML are exceptionally fast. In fact, my ageing
    laptop executes a simple game loop (such as the current one) at around five thousand
    times per second.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学到了C++和SFML非常快。事实上，我的老旧笔记本电脑每秒执行一个简单的游戏循环（比如当前的循环）大约有五千次。
- en: The frame-rate problem
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧率问题
- en: Let's consider the speed of the bee. For the purpose of discussion we could
    pretend that we are going to move it at 200 pixels per second. On a screen that
    is 1920 pixels wide, it would take, very approximately, 10 seconds to cross the
    entire width, because 10 x 200 is 2000 (near enough to 1920).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下蜜蜂的速度。为了讨论的目的，我们可以假装我们要以每秒200像素的速度移动它。在一个宽度为1920像素的屏幕上，它大约需要10秒才能横穿整个宽度，因为10乘以200等于2000（接近1920）。
- en: Furthermore, we know that we can position any of our sprites with `setPosition(...,...)`.
    We just need to put the x and the y coordinates in the parentheses.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们知道我们可以用`setPosition(...,...)`来定位我们的精灵中的任何一个。我们只需要把x和y坐标放在括号里。
- en: 'In addition to setting the position of a sprite, we can also **get** the position
    of a sprite. To get the horizontal x coordinate of the bee, for example, we would
    use this code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置精灵的位置，我们还可以**获取**精灵的位置。例如，要获取蜜蜂的水平x坐标，我们将使用这段代码：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The current x coordinate of the bee is now stored in `currentPosition`. To
    move the bee to the right, we could then add the appropriate fraction of 200 (our
    intended speed) divided by 5000 (the approximate frames per second on my laptop)
    to `currentPosition` like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 蜜蜂的当前x坐标现在存储在`currentPosition`中。要将蜜蜂向右移动，我们可以将200（我们预期的速度）除以5000（我笔记本电脑上的近似帧率）的适当分数添加到`currentPosition`中，就像这样：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we could use `setPosition` to move our bee. It would smoothly move from
    left to right by 200 divided by 5000 pixels each frame. But there are two big
    problems with this approach.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`setPosition`来移动我们的蜜蜂。它将每帧平滑地从左到右移动200除以5000像素。但是这种方法有两个大问题。
- en: '**Frame rate** is the number of times per second that our game loop is processed.
    That is, the number of times that we handle the player''s input, update the game
    objects, and draw them onto the screen. We will expand on and discuss frame rate
    implications now and throughout the rest of the book.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧率**是我们的游戏循环每秒处理的次数。也就是说，我们处理玩家的输入、更新游戏对象并将它们绘制到屏幕上的次数。我们将在本书的其余部分扩展并讨论帧率的影响。'
- en: The frame rate on my laptop might not always be constant. The bee might look
    like it is intermittently **boosting** its way across the screen.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我的笔记本电脑上的帧率可能并不总是恒定的。蜜蜂可能看起来像是断断续续地在屏幕上**加速**。
- en: And of course, we want a wider audience for our game than just my laptop! Every
    PC's frame rate will vary, at least slightly. If you have a really old PC, the
    bee will appear to be weighed down with lead and if you have the latest gaming
    rig it will probably be something of a blurry turbo bee.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望我们的游戏能够吸引更广泛的受众，而不仅仅是我的笔记本电脑！每台PC的帧率都会有所不同，至少会略有不同。如果你有一台非常老旧的PC，蜜蜂看起来会像被铅压住，如果你有最新的游戏设备，它可能会是一个模糊的涡轮蜜蜂。
- en: Fortunately, this problem is the same for every game and SFML has provided a
    solution. The easiest way to understand the solution is to implement it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题对每个游戏来说都是一样的，SFML提供了一个解决方案。理解解决方案的最简单方法是实施它。
- en: The SFML frame-rate solution
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFML帧率解决方案
- en: 'We will now measure and use the frame rate to control our game. To get started
    with implementing this, add this code just before the main game loop:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将测量并使用帧率来控制我们的游戏。要开始实施这个，只需在主游戏循环之前添加这段代码：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the previous code we declare an object of the type `Clock` and we name it
    `clock`. The class name starts with a capital letter and the object name (that
    we will actually use) starts with a lower-case letter. The object name is arbitrary
    but `clock` seems like an appropriate name for, well, a clock. We will add some
    more time-related variables here soon as well.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个`Clock`类型的对象，并将其命名为`clock`。类名以大写字母开头，对象名（我们实际使用的）以小写字母开头。对象名是任意的，但`clock`似乎是一个合适的名字，嗯，一个时钟的名字。我们很快也会在这里添加一些与时间相关的变量。
- en: 'Now in the update section of our game code add this highlighted code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的游戏代码的更新部分添加这个突出显示的代码：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `clock.restart()` function, as you might expect, restarts the clock. We
    want to restart the clock each and every frame so that we can time how long each
    and every frame takes. In addition, however, it returns the amount of time that
    has elapsed since the last time we restarted the clock.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock.restart()`函数，正如你所期望的那样，重新启动时钟。我们希望每一帧都重新启动时钟，以便我们可以计算每一帧花费的时间。此外，它返回自上次我们重新启动时钟以来经过的时间。'
- en: As a result of this, in the previous code, we are declaring an object of the
    type `Time,` called `dt,` and using it to store the value returned by the `clock.restart()`
    function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的代码中，我们声明了一个`Time`类型的对象，称为`dt`，并使用它来存储`clock.restart()`函数返回的值。
- en: Now, we have a `Time` object, called `dt`, which holds the amount of time that
    elapsed since the last time we updated the scene and restarted the clock. Maybe
    you can see where this is going.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`dt`的`Time`对象，它保存了自上次更新场景并重新启动时经过的时间。也许你能看出这是怎么回事。
- en: Let's add some more code to the game and then we will see what we can do with
    `dt`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向游戏添加一些更多的代码，然后我们将看看我们可以用`dt`做些什么。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`dt` stands for **delta time**, the time between two updates.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`dt`代表**增量时间**，即两次更新之间的时间。'
- en: Moving the clouds and the bee
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动云和蜜蜂
- en: Let's use the elapsed time since the last frame, to breathe life into the bee
    and the clouds. This will solve the problem of having a consistent frame rate
    across different PCs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用自上一帧以来经过的时间，为蜜蜂和云注入生命。这将解决在不同PC上拥有一致的帧速率的问题。
- en: Giving life to the bee
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给蜜蜂注入生命
- en: 'The first thing we want to do is to set up the bee at a certain height and
    a certain speed. We only want to do this when the bee is inactive. So we wrap
    the next code in an `if` block. Examine and add the highlighted code, then we
    will discuss it:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是在特定高度和特定速度下设置蜜蜂。我们只想在蜜蜂不活动时才这样做。因此，我们将下一个代码放在一个`if`块中。检查并添加下面突出显示的代码，然后我们将讨论它：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, if the bee is not active, just like it won''t be when the game first starts,
    `if(!beeActive)` will be `true` and the code above will do the following things,
    in this order:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果蜜蜂不活动，就像游戏刚开始时一样，`if(!beeActive)`将为`true`，上面的代码将按照以下顺序执行以下操作：
- en: Seed the random number generator
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给随机数生成器设定种子
- en: Get a random number between 199 and 399 and assign the result to `beeSpeed`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个在199和399之间的随机数，并将结果赋给`beeSpeed`
- en: Seed the random number generator again
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次给随机数生成器设定种子
- en: Get a random number between 499 and 999 and assign the result to a new `float`
    variable called `height`
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在499和999之间获取一个随机数，并将结果赋给一个名为`height`的新的`float`变量
- en: Set the position of the bee to `2000` on the x axis (just off-screen to the
    right) and to whatever `height` equals on the y axis
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将蜜蜂的位置设置为x轴上的`2000`（刚好在屏幕右侧）和y轴上等于`height`的值
- en: Set `beeActive` to true
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`beeActive`设置为true
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that the `height` variable is the first variable we have ever declared
    inside the game loop. Furthermore, because it was declared inside an `if` block,
    it is actually "invisible" outside the `if` block. This is fine for our use because
    once we have set the height of the bee we don''t need it any more. This phenomenon,
    which affects variables, is called **scope**. We will explore this more fully
    in [Chapter 4](ch04.html "Chapter 4.  Loops, Arrays, Switch, Enumerations, and
    Functions – Implementing Game Mechanics"): *Loops, Arrays, Switch, Enumerations,
    and Functions - Implementing Game Mechanics*.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`height`变量是我们在游戏循环内声明的第一个变量。此外，因为它是在`if`块内声明的，所以在`if`块外部实际上是“不可见”的。对于我们的用途来说，这是可以接受的，因为一旦我们设置了蜜蜂的高度，我们就不再需要它了。这种影响变量的现象称为**作用域**。我们将在[第4章](ch04.html
    "第4章。循环、数组、开关、枚举和函数 - 实现游戏机制")中更全面地探讨这一点：*循环、数组、开关、枚举和函数 - 实现游戏机制*。
- en: If we run the game, nothing will actually happen to the bee yet, but now the
    bee is active we can write some code that runs when `beeActive` is `true`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行游戏，蜜蜂实际上还不会发生任何事情，但现在蜜蜂是活跃的，我们可以编写一些代码，当`beeActive`为`true`时运行。
- en: 'Add the following highlighted code, which, as you can see, executes whenever
    `beeActive` is `true`. This is because it follows with an `else` after the `if(!beeActive)`
    block:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下面突出显示的代码，可以看到，这段代码在`beeActive`为`true`时执行。这是因为在`if(!beeActive)`块之后有一个`else`：
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the `else` block the following things happen.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`块中发生以下事情。
- en: The bee position is changed using the following criteria. The `setPosition`
    function uses the `getPosition` function to get the current x coordinate of the
    bee. It then adds `beeSpeed * dt.asSeconds()` to that coordinate.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下标准更改蜜蜂的位置。`setPosition`函数使用`getPosition`函数获取蜜蜂当前的x坐标。然后将`beeSpeed * dt.asSeconds()`添加到该坐标。
- en: The `beeSpeed` variable value is many pixels per second and was randomly assigned
    in the previous `if` block. The value of `dt.asSeconds()` will be a fraction of
    1 that represents how long the previous frame of the animation took.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`beeSpeed`变量的值是每秒多个像素，并且是在先前的`if`块中随机分配的。`dt.asSeconds()`的值将是一个小于1的分数，表示动画上一帧的持续时间。'
- en: 'Assume that the bee''s current x coordinate is 1000\. Now suppose a fairly
    basic PC loops at 5000 frames per second. This would mean that `dt.asSeconds`
    would be 0.0002\. And further suppose that `beeSpeed` was set to the maximum 399
    pixels per second. Then the code that determines the value that `setPosition`
    uses for the x coordinate can be explained like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 假设蜜蜂当前的x坐标是1000。现在假设一个相当基本的PC以每秒5000帧的速度循环。这意味着`dt.asSeconds`将是0.0002。再假设`beeSpeed`被设置为最大的399像素每秒。那么决定`setPosition`用于x坐标的值的代码可以解释如下：
- en: '[PRE42]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So the new position on the x axis for the bee would be 999.9202\. We can see
    that the bee is, very smoothly drifting to the left, at well under a pixel per
    frame. If the frame rate fluctuates then the formula will produce a new value
    to suit. If we run the same code on a PC that only achieves 100 frames per second
    or a PC that achieves a million frames per second, the bee will move at the same
    speed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，蜜蜂在x轴上的新位置将是999.9202。我们可以看到，蜜蜂非常平稳地向左飘移，每帧不到一个像素。如果帧速率波动，那么公式将产生一个新的值来适应。如果我们在每秒只能达到100帧或者每秒能达到一百万帧的PC上运行相同的代码，蜜蜂将以相同的速度移动。
- en: The `setPosition` function uses `getPosition().y` to keep the bee in exactly
    the same y coordinate throughout this cycle of being active.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPosition`函数使用`getPosition().y`来确保蜜蜂在整个活动周期内保持完全相同的y坐标。'
- en: 'The final code in the `else` block we just added is this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的`else`块中的最终代码是这样的：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code tests each and every frame (when `beeActive` is `true`), whether the
    bee has disappeared off the left-hand side of the screen. If the `getPosition`
    function returns less than -100, it will certainly be out of view of the player.
    When this has occurred, `beeActive` is set to `false` and, on the next frame,
    a new bee will be set flying at a new random height and a new random speed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在每一帧（当`beeActive`为`true`时）测试，蜜蜂是否已经从屏幕的左侧消失。如果`getPosition`函数返回小于-100，那么它肯定已经超出了玩家的视野。当发生这种情况时，`beeActive`被设置为`false`，在下一帧，一个新的蜜蜂将以新的随机高度和新的随机速度飞行。
- en: Try running the game and watch our bee dutifully fly from right to left and
    then come back to the right again at a new height and speed. It's almost like
    a new bee every time.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏，看着我们的蜜蜂忠实地从右到左飞行，然后再次回到右侧，高度和速度都不同。几乎就像每次都是一只新的蜜蜂。
- en: Tip
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Of course a real bee would stick around for ages and pester you while you're
    trying to concentrate on chopping the tree. We will make some smarter game characters
    in the next project.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，真正的蜜蜂会在你专心砍树时黏在你身边，让你烦恼很久。在下一个项目中，我们将制作一些更聪明的游戏角色。
- en: Now we will get the clouds moving in a very similar way.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将以非常相似的方式让云移动。
- en: Blowing the clouds
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 吹云
- en: 'The first thing we want to do is set up the first cloud at a certain height
    and a certain speed. We only want to do this when the cloud is inactive. So we
    wrap the next code in an `if` block. Examine and add the highlighted code, just
    after the code we added for the bee, then we will discuss it. It is almost identical
    to the code we used for the bee:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是在特定高度和特定速度设置第一朵云。只有在云处于非活动状态时才想要这样做。因此，我们将下一个代码包装在`if`块中。在我们为蜜蜂添加代码之后，检查并添加突出显示的代码，然后我们将讨论它。它几乎与我们用于蜜蜂的代码完全相同：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The only difference between the code we have just added and the bee code is
    that we work on a different sprite and use different ranges for our random numbers.
    Also, we use `*10` to the result returned by time(0) so we are always guaranteed
    to get a different seed for each of the clouds. When we code the other cloud movement
    next you will see that we use `*20` and`*30` respectively.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码与蜜蜂代码之间唯一的区别是我们使用不同的精灵并为我们的随机数使用不同的范围。此外，我们使用`*10`来对time(0)返回的结果进行操作，以便确保每个云都得到不同的种子。当我们下一步编写其他云移动代码时，您将看到我们分别使用`*20`和`*30`。
- en: 'Now we can take action when the cloud is active. We will do so in the `else`
    block. As with the `if` block, the code is identical to that of the bee, except
    that all the code works on the cloud and not the bee:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在云处于活动状态时采取行动。我们将在`else`块中这样做。与`if`块一样，代码与蜜蜂的代码完全相同，只是所有代码都作用于云而不是蜜蜂：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we know what to do, we can duplicate the same code for the second and third
    clouds. Add this highlighted code that handles the second and third clouds, immediately
    after the code for the first cloud:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道该怎么做了，我们可以复制相同的代码用于第二和第三朵云。在第一朵云的代码之后立即添加处理第二和第三朵云的突出代码：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now you can run the game and the clouds will randomly and continuously drift
    across the screen, and the bee will buzz from right to left before re-spawning
    once more back on the right.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行游戏，云将随机连续地在屏幕上漂移，蜜蜂将在从右到左飞行后重新出现在右侧。
- en: '![Blowing the clouds](img/image_02_002-300x169.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![吹云](img/image_02_002-300x169.jpg)'
- en: Tip
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Does all this cloud and bee handling seem a little bit repetitious? We will
    see how we could save lots of typing and make our code more readable. In C++ there
    are ways of handling multiple instances of the same type of variable or object.
    These are called **arrays** and we will learn about them in [Chapter 4](ch04.html
    "Chapter 4.  Loops, Arrays, Switch, Enumerations, and Functions – Implementing
    Game Mechanics"): *Loops, Arrays, Switch, Enumerations, and Functions - Implementing
    Game Mechanics*. At the end of the project, once we have learnt about arrays,
    we will discuss how we could improve our cloud code.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些云和蜜蜂处理似乎有点重复？我们将看看如何节省大量输入并使我们的代码更易读。在C++中，有处理相同类型的变量或对象的多个实例的方法。这些被称为**数组**，我们将在[第4章](ch04.html
    "第4章。循环、数组、开关、枚举和函数-实现游戏机制")中学习：*循环、数组、开关、枚举和函数-实现游戏机制*。在项目结束时，一旦我们学习了数组，我们将讨论如何改进我们的云代码。
- en: Take a look at a few frequently asked questions related to the topics in this
    chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看与本章主题相关的一些常见问题解答。
- en: FAQ
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) Why do we set the bee to inactive when it gets to -100? Why not just zero
    because zero is the left-hand side of the window?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 问：为什么我们在蜜蜂到达-100时将其设置为非活动状态？为什么不是零，因为零是窗口的左侧？
- en: A) The bee graphic is 60 pixels wide and its origin is at the top left pixel.
    So when the bee is drawn with its origin at x equals zero, the entire bee graphic
    is still on screen for the player to see. By waiting until it is at -100, we can
    be sure it is definitely out of the player's view.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 答：蜜蜂的图形宽60像素，其原点位于左上像素。因此，当蜜蜂以x等于零的原点绘制时，整个蜜蜂图形仍然在屏幕上供玩家看到。等到它到达-100时，我们可以确信它肯定已经超出了玩家的视野。
- en: Q) How do I know how fast my game loop is?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 问：我怎么知道我的游戏循环有多快？
- en: 'A) To measure this we will need to learn a few more things. We will add the
    ability to measure and display the current frame rate in [Chapter 5](ch05.html
    "Chapter 5. Collisions, Sound, and End Conditions – Making the Game Playable"):
    *Collisions, Sound, and End Conditions - Making the Game Playable*.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 答：为了衡量这一点，我们需要学习更多的东西。我们将在[第5章](ch05.html "第5章。碰撞、声音和结束条件-使游戏可玩")中添加测量和显示当前帧速率的功能：*碰撞、声音和结束条件-使游戏可玩*。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we learnt that a variable is a named storage location in memory,
    in which we can keep values of a specific type. Types include `int`, `float`,
    `double`, `bool`, `String`, and `char`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到变量是内存中的命名存储位置，我们可以在其中保存特定类型的值。类型包括`int`、`float`、`double`、`bool`、`String`和`char`。
- en: We can declare and initialize all the variables we need, to store the data for
    our game. Once we have our variables, we can manipulate them using the arithmetic
    and assignment operators and use them in tests with the logical operators. Used
    in conjunction with the `if` and `else` keywords, we can branch our code dependent
    upon the current situation in the game.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明和初始化我们需要的所有变量，以存储我们游戏的数据。一旦我们有了变量，我们就可以使用算术和赋值运算符来操作它们，并使用逻辑运算符在测试中使用它们。与`if`和`else`关键字一起使用，我们可以根据游戏中的当前情况分支我们的代码。
- en: Using all this new knowledge, we animated some clouds and a bee. In the next
    chapter we will continue to use these skills to add a **Heads Up Display**(**HUD**)
    and add more input options for the player, as well as representing time visually
    via a time bar.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 利用所有这些新知识，我们制作了一些云和一只蜜蜂的动画。在下一章中，我们将继续使用这些技能，为玩家添加**HUD**（**抬头显示**）并增加更多的输入选项，同时通过时间条来直观地表示时间。
