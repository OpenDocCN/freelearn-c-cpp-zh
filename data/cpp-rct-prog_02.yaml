- en: A Tour of Modern C++ and its Key Idioms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代C++及其关键习语之旅
- en: 'The classic C++ programming language was standardized in 1998 and it was followed
    by a small revision (mostly corrections) in 2003\. To support advanced abstractions,
    developers relied on the Boost ([http://www.boost.org](http://www.boost.org))
    library and other public domain libraries. Thanks to the next wave of standardization,
    the language (from C++ 11 onward) was enhanced, and now developers can encode
    most widely used abstractions (supported by other languages) without relying on
    external libraries. Even threads and file-system interfaces, which came squarely
    under the aegis of libraries, are now part of the standard language. Modern C++
    (which stands for C++ versions 11/14/17 ) contains superb additions to the language
    and its libraries, that make C++ the de-facto choice for writing industrial strength
    production software. The features covered in this chapter are the minimum set
    of features that a programmer has to understand to work with Reactive Programming
    constructs in general and RxCpp in particular. The primary objective of this chapter
    is to cover the most important additions to the language which makes implementing
    Reactive Programming constructs easier without resorting to esoteric language
    techniques. Constructs such as Lambda functions, automatic type inference, rvalue
    references, move semantics, and language level concurrency are some of the constructs
    which the authors of this book feel that every  C++ programmer should know. In
    this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的C++编程语言在1998年被标准化，随后在2003年进行了一次小的修订（主要是更正）。为了支持高级抽象，开发人员依赖于Boost ([http://www.boost.org](http://www.boost.org))库和其他公共领域库。由于下一波标准化的到来，语言（从C++
    11开始）得到了增强，现在开发人员可以在不依赖外部库的情况下编码大多数其他语言支持的抽象。甚至线程和文件系统接口，原本属于库的范畴，现在已成为标准语言的一部分。现代C++（代表C++版本11/14/17）包含了对语言和其库的出色增强，使得C++成为编写工业级生产软件的事实选择。本章涵盖的功能是程序员必须了解的最小功能集，以便使用响应式编程构造，特别是RxCpp。本章的主要目标是介绍语言的最重要的增强功能，使得实现响应式编程构造更加容易，而不需要使用神秘的语言技术。本章将涵盖以下主题：
- en: Key concerns for C++ programming language design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++编程语言设计的关键问题
- en: Some enhancements to C++ for writing better code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些用于编写更好代码的C++增强功能
- en: Better memory management through rvalue references and move semantics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过右值引用和移动语义实现更好的内存管理
- en: Better object lifetime management using an enhanced set of smart pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用增强的智能指针实现更好的对象生命周期管理
- en: Behavioral parameterization using Lambda functions and expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lambda函数和表达式进行行为参数化
- en: Function Wrappers (the `std::function` type)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数包装器（`std::function`类型）
- en: Miscellaneous features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他功能
- en: Writing Iterators and Observers (to put everything together)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写迭代器和观察者（将所有内容整合在一起）
- en: The key concerns of the C++ programming language
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++编程语言的关键问题
- en: 'As far as developers are concerned, the three key concerns that C++ programming
    language designers keep in mind were (and still are) as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 就开发人员而言，C++编程语言设计者关注的三个关键问题是（现在仍然是）：
- en: Zero Cost Abstraction - No performance penalty for higher level abstraction
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零成本抽象 - 高级抽象不会带来性能惩罚
- en: Expressivity - A **user defined type** (**UDT**) or class should be as expressive
    as built-in types
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表现力 - 用户定义类型（UDT）或类应该与内置类型一样具有表现力
- en: Substitutability - A UDT can be substituted wherever built-in-types are expected
    (as in generic data structures and algorithms)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可替代性 - UDT可以在期望内置类型的任何地方替代（如通用数据结构和算法）
- en: We will discuss these briefly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要讨论这些内容。
- en: Zero cost abstraction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零成本抽象
- en: The C++ programming language has always helped developers to write code that
    exploits the microprocessor (on which generated code runs) and also raise the
    level of abstraction when it matters. While raising the abstraction, the designers
    of the language have always tried to minimize (almost eliminate) their performance
    overhead. This is called Zero Cost Abstraction or Zero Overhead Cost Abstraction.
    The only notable penalty you pay is the cost of indirect calls (through function
    pointers) while dispatching virtual functions. Despite adding tons of features
    to the language, the designers have maintained the "Zero Cost Abstraction" guarantee
    implied by the language from its inception.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: C++编程语言一直帮助开发人员编写利用微处理器的代码（生成的代码运行在微处理器上），并在需要时提高抽象级别。在提高抽象级别的同时，语言的设计者们一直试图最小化（几乎消除）性能开销。这被称为零成本抽象或零开销成本抽象。你所付出的唯一显著代价是间接调用的成本（通过函数指针）来分派虚拟函数。尽管向语言添加了大量功能，设计者们仍然保持了语言从一开始就暗示的“零成本抽象”保证。
- en: Expressivity
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表现力
- en: 'C++ helps a developer to write user defined types or classes that can be as
    expressive as the built-in types of the programming languages. This enables one
    to write a arbitrary-precision arithmetic class (monikered as `BigInteger`/`BigFloat`
    in some languages), which contains all the features of a double or float. For
    the sake of explanation, we have defined a `SmartFloat` class that wraps IEEE
    double precision floating point numbers and most of the operators available to
    the double data type is overloaded. The following code snippets show that one
    can write types that mimic the semantics of built-in types such as int, float,
    or double:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: C++帮助开发人员编写用户定义类型或类，可以像编程语言的内置类型一样具有表现力。这使得可以编写任意精度算术类（在某些语言中被称为`BigInteger`/`BigFloat`），其中包含了双精度或浮点数的所有特性。为了说明，我们定义了一个`SmartFloat`类，它包装了IEEE双精度浮点数，并重载了大多数双精度数据类型可用的运算符。以下代码片段显示，可以编写模仿内置类型（如int、float或double）语义的类型：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `SmartFloat` class wraps a double value and has defined some constructors
    and assignment operators to initialize instances properly. In the following snippet,
    we will define some operators that help to increment the value. Both the prefix
    and postfix variants of operators are defined:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`SmartFloat`类包装了一个double值，并定义了一些构造函数和赋值运算符来正确初始化实例。在下面的代码片段中，我们将定义一些操作符来增加值。前缀和后缀变体的操作符都已定义：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code snippets implement increment operators (both prefix and postfix)
    and are meant for demonstration purposes only. In a real-world class, we will
    check for floating point overflow and underflow to make the code more robust.
    The whole purpose of wrapping a type is to write robust code!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段实现了增量运算符（前缀和后缀），仅用于演示目的。在真实的类中，我们将检查浮点溢出和下溢，以使代码更加健壮。包装类型的整个目的是编写健壮的代码！
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code snippets implement C++ style assignment operators and once
    again, to make the listing short, we have not checked whether any floating point
    overflow or underflow is there. We do not handle exceptions as well here to keep
    the listing brief.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段实现了C++风格的赋值运算符，再次为了简洁起见，我们没有检查是否存在任何浮点溢出或下溢。我们也没有处理异常，以保持清单的简洁。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code implements relational operators and most of the semantics
    associated with double precision floating points have been implemented as shown:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实现了关系运算符，并且大部分与双精度浮点数相关的语义都已经实现如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For the sake of completeness, we have implemented conversion operators to `int`
    and `double`. We will write two functions to aggregate values stored in an array.
    The first function expects an array of `double` as parameter and the second one
    expects a `SmartFloat` array as parameter. The code is identical in both routines
    and only the type changes. Both will produce the same result:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们已经实现了到`int`和`double`的转换运算符。我们将编写两个函数来聚合存储在数组中的值。第一个函数期望一个`double`数组作为参数，第二个函数期望一个`SmartFloat`数组作为参数。两个例程中的代码是相同的，只是类型不同。两者将产生相同的结果：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The C++ language helps us write expressive types that augment the semantics
    of basic types. The expressiveness of the language also helps one to write good
    value types and reference types using a myriad of techniques supported by the
    language. With support for operator overloading, conversion operators, placement
    new, and other related techniques, the language has taken the class design to
    a higher level compared to other languages of its time. But, with power comes
    responsibility and the language sometimes gives you enough rope to shoot yourself
    in the foot.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言帮助我们编写富有表现力的类型，增强基本类型的语义。语言的表现力还帮助我们使用语言支持的多种技术编写良好的值类型和引用类型。通过支持运算符重载、转换运算符、放置new和其他相关技术，与其同时代的其他语言相比，该语言已将类设计提升到了一个更高的水平。但是，能力与责任并存，有时语言会给你足够的自由让你自食其果。
- en: Substitutability
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可替代性
- en: 'In the previous example, we saw how a user-defined type can be used to express
    all the operations done on a built-in type. Another goal of C++ is to write code
    in a generic manner where we can substitute a user-defined class that mimics the
    semantics of one of the built-in types such as `float`, `double`, `int`, and so
    on:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了如何使用用户定义的类型来表达对内置类型进行的所有操作。C++的另一个目标是以一种通用的方式编写代码，其中我们可以替换一个模拟内置类型（如`float`、`double`、`int`等）语义的用户定义类：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The C++ programming language supports different programming paradigms and the
    three principles outlined previously are just some of them. The language gives
    support for constructs that can help create robust types (domain-specific) for
    writing better code. These three principles gave us a powerful and fast programming
    language for sure. Modern C++did add a lot of new abstractions to make the life
    of a programmer easier. But the three design principles outlined previously have
    not been sacrificed in any way  to achieve those objectives. This was partly possible
    because of the meta programming support the language had due to the inadvertent
    Turing completeness of the template mechanism. Read about **template meta programming**
    (**TMP**) and Turing Completeness  with the help of your favorite search engine.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'C++编程语言支持不同的编程范式，前面概述的三个原则只是其中的一些。该语言支持可以帮助创建健壮类型（特定领域）以编写更好代码的构造。这三个原则确实为我们带来了一个强大而快速的编程语言。现代C++确实添加了许多新的抽象，以使程序员的生活更加轻松。但是，为了实现这些目标，之前概述的三个设计原则并没有以任何方式被牺牲。这在一定程度上是可能的，因为语言由于模板机制的无意中图灵完备性而具有元编程支持。使用您喜欢的搜索引擎阅读有关**模板元编程**（**TMP**）和图灵完备性的内容。 '
- en: Enhancements to C++ for writing better code
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++增强以编写更好的代码
- en: The programming language universe has changed a lot in the last decade and those
    changes should reflect in the  C++ programming language in its new avatar. Most
    of the innovations in Modern C++ involve handling advanced abstractions and the
    introduction of functional programming constructs to support language level concurrency.
    Most modern languages have got a garbage collector and a run-time manages these
    complexities. The C++ programming language does not have automatic garbage collection
    as part of the language standard. The C++ programming languages with its implicit
    guarantee of Zero cost abstraction (you do not pay for what you do not use) and
    maximum run-time performance, has to resort to a lot of compile-time tricks and
    meta programming techniques to achieve the abstraction level supported by a language
    such as C#, Java, or Scala. Some of them are outlined in the following sections
    and you can delve into these topics yourself. The website [http://en.cppreference.com](http://en.cppreference.com)
    is a good site for advancing your knowledge of the C++ programming language.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年里，编程语言的世界发生了很大变化，这些变化应该反映在C++编程语言的新版本中。现代C++中的大部分创新涉及处理高级抽象，并引入函数式编程构造以支持语言级并发。大多数现代语言都有垃圾收集器，运行时管理这些复杂性。C++编程语言没有自动垃圾收集作为语言标准的一部分。C++编程语言以其隐式的零成本抽象保证（你不用为你不使用的东西付费）和最大的运行时性能，必须依靠大量的编译时技巧和元编程技术来实现C#、Java或Scala等语言支持的抽象级别。其中一些在以下部分中概述，你可以自行深入研究这些主题。网站[http://en.cppreference.com](http://en.cppreference.com)是提高你对C++编程语言知识的一个好网站。
- en: Type deduction and inference
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断和推理
- en: 'The Modern C++ language compiler does a wonderful job of deducing types from
    the expressions and statements specified by the programmers. Most modern programming
    languages do have support for type inference and so does Modern C++. This is an
    idiom borrowed from Functional Programming languages such as Haskell and ML. Type
    inferences are already available with the C# and Scala programming languages.
    We will write a small program to kick-start us with type inference:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++语言编译器在程序员指定的表达式和语句中推断类型方面做得非常出色。大多数现代编程语言都支持类型推断，现代C++也是如此。这是从Haskell和ML等函数式编程语言借鉴来的习惯用法。类型推断已经在C#和Scala编程语言中可用。我们将编写一个小程序来启动我们的类型推断：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `auto` keyword specifies that the type of the variable will be deduced
    by the compiler based on initialization and the return values of functions specified
    in the expression. In this particular example, we do not gain much. As our declarations
    get more complicated, it is better to let the compiler do the type inference.
    Our code listings will use auto to simplify the code throughout the book. Now,
    let us write a simple program to make the idea even more clear:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`关键字指定变量的类型将根据初始化和表达式中指定的函数的返回值由编译器推导出来。在这个特定的例子中，我们并没有获得太多。随着我们的声明变得更加复杂，最好让编译器进行类型推断。我们的代码清单将使用auto来简化整本书的代码。现在，让我们编写一个简单的程序来更清楚地阐明这个想法：'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code demonstrates the use of type inference while writing Modern
    C++ code. The C++ programming language also has a new keyword that helps to query
    the type of expression given as arguments. The general form of the keyword is
    `decltype(<expr>)`. The following program helps to demonstrate the use of this
    particular keyword:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了在编写现代C++代码时使用类型推断。C++编程语言还有一个新关键字，用于查询给定参数的表达式的类型。关键字的一般形式是`decltype(<expr>)`。以下程序有助于演示这个特定关键字的用法：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `decltype` is a compile-time construct and it helps to specify the type
    of a variable (the compiler will do the hard work to figure it out) and also helps
    us to force a type on a variable (see the preceding `fancy()` function).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype`是一个编译时构造，它有助于指定变量的类型（编译器将进行艰苦的工作来找出它），并且还可以帮助我们强制变量的类型（参见前面的`fancy()`函数）。'
- en: Uniform initialization of variables
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的统一初始化
- en: 'Classic C++ had some kind of ad-hoc syntax for the initialization of variables.
    Modern C++ supports uniform initialization (we have already seen examples in the
    type inference section). The language provides helper classes to developers to
    support uniform initialization for their custom types:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 经典C++对变量的初始化有一些特定的ad-hoc语法。现代C++支持统一初始化（我们已经在类型推断部分看到了示例）。语言为开发人员提供了辅助类，以支持他们自定义类型的统一初始化：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding listing shows how one can enable initialization lists for a custom
    class created by a programmer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的清单显示了如何使程序员创建的自定义类启用初始化列表。
- en: Variadic templates
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变模板
- en: 'In C++ 11 and above, there is support for variadic templates as part of the
    standard language. A variadic template is a template class or template function
    that takes a variable number in a template argument. In classic C++, template
    instantiation happens with a fixed number of parameters. Variadic templates are
    supported both at class level and function level. In this section, we will deal
    with variadic functions as they are used extensively in writing functional-style
    programs, compile-time programming (meta programming), and pipeable functions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++ 11及以上版本中，标准语言支持可变模板。可变模板是一个接受可变数量的模板参数的模板类或模板函数。在经典C++中，模板实例化发生在固定数量的参数中。可变模板在类级别和函数级别都得到支持。在本节中，我们将处理可变函数，因为它们在编写函数式程序、编译时编程（元编程）和可管道函数中被广泛使用：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, the compiler synthesizes a function based on the number
    of arguments passed. The compiler understands that `add` is a variadic function
    and generates the code by recursively unpacking the parameters during compile
    time. Compile time recursion will stop when the compiler has processed all the
    parameters. The base case version is a hint to the compiler to stop recursion.
    The next program shows how variadic templates and perfect forwarding can be used
    to write a function that takes an arbitrary number of parameters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，编译器根据传递的参数数量合成一个函数。编译器理解`add`是一个可变参数函数，并通过在编译时递归展开参数来生成代码。编译时递归将在编译器处理完所有参数时停止。基本情况版本是一个提示编译器停止递归的方法。下一个程序展示了可变模板和完美转发如何用于编写接受任意数量参数的函数：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The three variants of `EmitConsole` print the argument to the console. We have
    functions for printing `int`, `double`, and `string`. Using these functions as
    a base case, we will write a function that uses universal references and perfect
    forwarding to write functions that take arbitrary values:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmitConsole` 的三个变体将参数打印到控制台。我们有打印`int`、`double`和`string`的函数。利用这些函数作为基本情况，我们将编写一个使用通用引用和完美转发的函数，以编写接受任意值的函数：'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rvalue references
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 右值引用
- en: 'If you have been programming in C++ for a long time, you might be familiar
    with the fact that C++ references help you to alias a variable and you can do
    assignment to the references to reflect the mutation in the variable aliased.
    The kinds of reference supported by C++ were called lvalue references (as they
    were references to variables that can come in the left side of the assignment).
    The following code snippets show the use of lvalue references:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你长时间在C++中编程，你可能知道C++引用可以帮助你给变量取别名，并且可以对引用进行赋值以反映变量别名的变化。C++支持的引用类型称为左值引用（因为它们是引用可以出现在赋值的左侧的变量的引用）。以下代码片段展示了左值引用的用法：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`int&` is an instance of lvalue references. In Modern C++, there is the notion
    of rvalue references. rvalue is defined as anything that is not an lvalue, the
    kind of stuff that can appear on the right side of the assignment. In classic
    C++, there was no notion of an rvalue references. Modern C++ introduced it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`int&` 是左值引用的一个实例。在现代C++中，有右值引用的概念。右值被定义为任何不是左值的东西，可以出现在赋值的右侧。在经典的C++中，没有右值引用的概念。现代C++引入了它：'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Rvalue references are indicted by two `&&`. The following program will clearly
    demonstrate the use of rvalue references while invoking functions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 右值引用由两个`&&`表示。以下程序将清楚地演示了在调用函数时使用右值引用：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The real power of rvalue references is visible in the case of memory management.
    The C++ programming language has got the notion of Copy constructor and Assignment
    operators. They mostly copy the source object contents. With the help of rvalue references,
    one can avoid expensive copying by swapping pointers, as rvalue references are
    temporaries or intermediate expressions. The following section demonstrates this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 右值引用的真正威力在于内存管理方面。C++编程语言具有复制构造函数和赋值运算符的概念。它们大多数情况下是复制源对象的内容。借助右值引用，可以通过交换指针来避免昂贵的复制，因为右值引用是临时的或中间表达式。下一节将演示这一点。
- en: Move semantics
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动语义
- en: 'The C++ programming language implicitly warrants a Copy Constructor, Assignment
    Operator, and a Destructor (some times virtual) with every class designed by us.
    This is meant to do resource management while cloning an object or while assigning
    to an existing object. Sometimes it is very expensive to copy an object and the
    movement of ownership (through pointers) helps in writing fast code. Modern C++
    has got a facility to provide a Move Constructor and a Move assignment operator
    to help developers avoid copying large objects, during the creation of a new object
    or assignment to a new object. Rvalue references can act as a hint to the compiler
    that, when temporary objects are involved, a move version of a constructor or
    a move version of assignment is better suited for the context:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C++编程语言隐式地为我们设计的每个类提供了一个复制构造函数、赋值运算符和一个析构函数（有时是虚拟的）。这是为了在克隆对象或对现有对象进行赋值时进行资源管理。有时复制对象是非常昂贵的，通过指针的所有权转移有助于编写快速的代码。现代C++提供了移动构造函数和移动赋值运算符的功能，以帮助开发人员避免复制大对象，在创建新对象或对新对象进行赋值时。右值引用可以作为一个提示，告诉编译器在涉及临时对象时，构造函数的移动版本或赋值的移动版本更适合于上下文：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `std::move` function can be used to indicate (while passing parameters)
    that the candidate object is movable and the compiler will invoke appropriate
    methods (move assignment or move constructor ) to optimize the cost associated
    with memory management. Basically, `std::move` is a `static_cast` to an rvalue
    reference.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::move` 函数可用于指示（在传递参数时）候选对象是可移动的，编译器将调用适当的方法（移动赋值或移动构造函数）来优化与内存管理相关的成本。基本上，`std::move`
    是对右值引用的`static_cast`。'
- en: Smart pointers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能指针
- en: 'Managing object lifetimes has been a problematic area for the C++ programming
    language. If the developer is not careful, the program can leak memory and will
    slow down performance. Smart pointers are wrapper classes around a raw pointer
    where operators such as dereferencing (*) and referencing (->) are overloaded.
    Smart pointers can do object lifetime management, act as a limited form of garbage
    collection, free memory, and so on. The Modern C++ language has:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象生命周期一直是C++编程语言的一个问题。如果开发人员不小心，程序可能会泄漏内存并降低性能。智能指针是围绕原始指针的包装类，其中重载了解引用(*)和引用(->)等操作符。智能指针可以进行对象生命周期管理，充当有限形式的垃圾回收，释放内存等。现代C++语言具有：
- en: '`unique_ptr<T>`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_ptr<T>`'
- en: '`shared_ptr<T>`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_ptr<T>`'
- en: '`weak_ptr<T>`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weak_ptr<T>`'
- en: 'A `unique_ptr<T>` is a wrapper for a raw pointer where there is exclusive ownership
    with the wrapper. The following code snippet will demonstrate the use of `<unique_ptr>`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr<T>`是一个具有独占所有权的原始指针的包装器。以下代码片段将演示`<unique_ptr>`的使用：'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`std::shared_ptr` is a smart pointer that uses reference counting to keep track
    of references made to a particular instance of an object. The underlying object
    is destroyed when the last remaining `shared_ptr` pointing to it is destroyed
    or reset:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr`是一个智能指针，它使用引用计数来跟踪对对象实例的引用。当指向它的最后一个`shared_ptr`被销毁或重置时，底层对象将被销毁：'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`std:weak_ptr` is a container for a raw pointer. It is created as a copy of
    a `shared_ptr`. The existence or destruction of `weak_ptr` copies of a `shared_ptr`
    have no effect on the `shared_ptr` or its other copies. After all copies of a
    `shared_ptr` have been destroyed, all `weak_ptr` copies become empty. The following
    program demonstrates a mechanism that helps us to detect defunct pointers using
    `weak_ptr`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`std:weak_ptr`是一个原始指针的容器。它是作为`shared_ptr`的副本创建的。`weak_ptr`的存在或销毁对`shared_ptr`或其其他副本没有影响。在所有`shared_ptr`的副本被销毁后，所有`weak_ptr`的副本都变为空。以下程序演示了使用`weak_ptr`来检测失效指针的机制：'
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Classic C++ had a smart pointer type called `auto_ptr` and it has been removed
    from the language standard. One needs to use `unique_ptr` instead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 经典C++有一个名为`auto_ptr`的智能指针类型，已从语言标准中删除。需要使用`unique_ptr`代替。
- en: Lambda functions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数
- en: One of the major additions to the C++ language is Lambda functions and Lambda
    expressions. They are anonymous functions that the programmer can define at the
    call site to perform some logic. This simplifies the logic and code readability
    also increases in a remarkable manner.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言的一个主要增强是Lambda函数和Lambda表达式。它们是程序员可以在调用站点定义的匿名函数，用于执行一些逻辑。这简化了逻辑，代码的可读性也以显着的方式增加。
- en: 'Rather than defining what a Lambda function is, let us write a piece of code
    that helps us count the number of positive numbers in a `vector<int>`. In this
    case, we need to filter out the negative values and count the rest. We will use
    an STL `count_if` to write the code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与其定义Lambda函数是什么，不如编写一段代码来帮助我们计算`vector<int>`中正数的数量。在这种情况下，我们需要过滤掉负值并计算剩下的值。我们将使用STL
    `count_if`来编写代码：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code snippet, the variable filter is assigned an anonymous
    function and we are using the filter in the `count_if STL` function. Now, let
    us write a simple Lambda function that we will specify at the function call site.
    We will be using STL accumulate to aggregate the values inside a vector:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，变量filter被赋予了一个匿名函数，并且我们在`count_if STL`函数中使用了filter。现在，让我们编写一个简单的Lambda函数，在函数调用时指定。我们将使用STL
    accumulate来聚合向量中的值：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Functors and Lambdas
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数对象和Lambda
- en: 'In classic C++, while using STL, we extensively use Function Objects or Functors
    by overloading Function Operators to write transformation filters and perform
    reduction on STL containers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的C++中，使用STL时，我们广泛使用函数对象或函数符号，通过重载函数运算符来编写转换过滤器和对STL容器执行减少操作：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following program clearly demonstrates the usage of Lambda by writing a
    toy sort program. We will show how we can use Function Objects and Lambdas to
    write equivalent code. The code is written in a generic manner, but it makes an
    assumption that numbers are expected (`double`, `float`, `integer`, or a user
    defined equivalent):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序清楚地演示了通过编写一个玩具排序程序来使用Lambda。我们将展示如何使用函数对象和Lambda来编写等效的代码。该代码以一种通用的方式编写，但假设数字是预期的（`double`，`float`，`integer`或用户定义的等效类型）：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`Cmp` and `Swap` are generic functions that will be used to compare adjacent
    elements and swap elements, respectively, while performing the sort operation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cmp`和`Swap`是通用函数，将用于比较相邻元素和交换元素，同时执行排序操作：'
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Armed with Cmp and Swap, writing a bubble sort is a simple affair. We need
    to have a nested loop where we will compare two elements and if Cmp returns true,
    we will invoke Swap to exchange values:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Cmp和Swap，编写冒泡排序就变得简单了。我们需要有一个嵌套循环，在其中我们将比较两个元素，如果Cmp返回true，我们将调用Swap来交换值：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding routine, we define the comparison and swap function as Lambdas.
    The Lambda function is  a mechanism to specify a piece of code or expression inline,
    often called anonymous functions. The definition can be given in a syntax specified
    by the C++ language, and can  be assigned to a variable, passed as a parameter
    , or returned from a function.  In the preceding function, the variables `CmpLambda`
    and `SwapLambda` are examples of anonymous functions specified in Lambda syntax.
    The body of the Lambda functions is not much different from the preceding function
    version. To learn more about Lambda functions and expression, you can consult
    the page at [http://en.cppreference.com/w/cpp/language/lambda](http://en.cppreference.com/w/cpp/language/lambda).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例程中，我们将比较和交换函数定义为Lambda。Lambda函数是一种在调用站点内指定代码或表达式的机制，通常称为匿名函数。定义可以使用C++语言指定的语法，并且可以赋值给变量，作为参数传递，或者从函数返回。在上面的函数中，变量`CmpLambda`和`SwapLambda`是Lambda语法中指定的匿名函数的示例。Lambda函数的主体与之前的函数版本没有太大的不同。要了解有关Lambda函数和表达式的更多信息，可以参考[http://en.cppreference.com/w/cpp/language/lambda](http://en.cppreference.com/w/cpp/language/lambda)页面。
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Print` routine just cycles through the elements in the container and prints
    the contents to the console:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print`例程只是循环遍历容器中的元素，并将内容打印到控制台：'
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Composition, currying, and partial function application
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合、柯里化和部分函数应用
- en: 'One advantage of Lambdas is you can compose two functions together to create
    a composition of functions as you do in mathematics (read about function composition
    in the context of mathematics and functional programming  using favorite search
    engine). The following program demonstrates the idea. This is a toy implementation
    and writing a general-purpose implementation is beyond the scope of this chapter:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Lambdas的一个优点是你可以将两个函数组合在一起，创建函数的组合，就像你在数学中所做的那样（在数学和函数式编程的上下文中阅读有关函数组合的内容，使用喜欢的搜索引擎）。以下程序演示了这个想法。这是一个玩具实现，撰写通用实现超出了本章的范围：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`Compose` is a variadic template function and the compiler generates code by
    recursively expanding the `Compose` arguments until all the arguments are processed.
    In the preceding code, we have used `[=]` to indicate to the compiler that we
    should capture all variables referenced in the body of the Lambda by value. You
    can study more about Closure and Variable Capture in the context of functional
    programming. The C++ language gives flexibility to `Capture` variables by value
    (as well as using `[&]`) or by specifying variables to be captured explicitly
    (such as `[&var]`).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Compose`是一个可变模板函数，编译器通过递归扩展`Compose`参数生成代码，直到处理完所有参数。在前面的代码中，我们使用`[=]`指示编译器应该按值捕获Lambda体中引用的所有变量。您可以在函数式编程的上下文中学习更多关于闭包和变量捕获的内容。C++语言允许通过值（以及使用`[&]`）或通过显式指定要捕获的变量（如`[&var]`）来灵活地`Capture`变量。'
- en: The functional programming paradigm is based on a mathematical formalism called
    Lambda calculus invented by Alonzo Church, an American mathematician. The Lambda
    calculus supports only unary functions and currying is a technique that breaks
    a multiple argument function into a series of function evaluations that take one
    argument at a time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程范式基于由美国数学家阿隆佐·邱奇发明的一种数学形式主义，称为Lambda演算。Lambda演算仅支持一元函数，柯里化是一种将多参数函数分解为一系列一次接受一个参数的函数评估的技术。
- en: 'Using Lambdas and writing functions in a specific manner, we can simulate currying
    in C++:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lambdas和以特定方式编写函数，我们可以在C++中模拟柯里化：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The partial function application involves the conversion of functions with multiple
    arguments into a fixed number of arguments. If the fixed number of arguments is
    less than the arity (parameter count) of the function, a new function will be
    returned that expects the rest of the parameters. When all parameters are received,
    the function will be invoked. We can treat the partial application as some form
    of memorization where parameters are cached until we receive all of them to invoke
    them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数应用涉及将具有多个参数的函数转换为固定数量的参数。如果固定数量的参数少于函数的arity（参数计数），则将返回一个新函数，该函数期望其余的参数。当接收到所有参数时，将调用该函数。我们可以将部分应用视为某种形式的记忆化，其中参数被缓存，直到我们接收到所有参数以调用它们。
- en: In the following code snippets, we have used  constructs like template parameter
    pack and variadic templates. A template parameter pack is a template parameter
    that accepts zero or more template arguments (non-types, types, or templates).
    A function parameter pack is a function parameter that accepts zero or more function
    arguments. A template with at least one parameter pack is called a variadic template.
    A good idea about parameter pack and variadic templates is necessary for understanding
    `sizeof...`  constructs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们使用了模板参数包和可变模板。模板参数包是一个接受零个或多个模板参数（非类型、类型或模板）的模板参数。函数参数包是一个接受零个或多个函数参数的函数参数。至少有一个参数包的模板称为可变模板。对参数包和可变模板的良好理解对于理解`sizeof...`构造是必要的。
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Function wrappers
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数包装器
- en: 'Function wrappers are classes that can wrap any functions, function objects,
    or Lambdas into a copiable object. The type of the wrapper depends upon the function
    prototype of the class. `std::function(<prototype>)` from the `<functional>` header
    represents a function wrapper:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 函数包装器是可以包装任何函数、函数对象或Lambdas成可复制对象的类。包装器的类型取决于类的函数原型。来自`<functional>`头文件的`std::function(<prototype>)`表示一个函数包装器：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We will be using `std::function` in our code extensively in the coming sections,
    as it helps to drag function calls as data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将广泛使用`std::function`，因为它有助于将函数调用作为数据进行处理。
- en: Composing functions together with the pipe operator
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道运算符将函数组合在一起
- en: 'The Unix operating system''s command line shell allows the standard output
    of one function to be piped into the another to form a filter chain. Later, this
    feature became part of every command line shell offered as part of most operating
    systems. While writing functional style code, when we combine methods through
    functional composition, the code becomes hard to read because of deep nesting.
    Now, with Modern C++ we can overload the pipe (`|`) operator to allow chaining
    several functions together, like we do commands in a Unix shell or Windows PowerShell
    console. That is why someone re-christened the LISP language as Lots of Irritating
    and Silly Parentheses. The RxCpp library uses the `|` operator extensively to
    compose functions together. The following code helps us understand how one can
    create pipeable functions. We will take a look at how this can be implemented
    in principle. The code given here is only good for expository purposes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Unix操作系统的命令行shell允许将一个函数的标准输出管道到另一个函数，形成一个过滤器链。后来，这个特性成为大多数操作系统提供的每个命令行shell的一部分。在编写函数式风格的代码时，当我们通过函数组合来组合方法时，由于深层嵌套，代码变得难以阅读。现在，使用现代C++，我们可以重载管道（`|`）运算符，以允许将多个函数链接在一起，就像我们在Unix
    shell或Windows PowerShell控制台中执行命令一样。这就是为什么有人重新将LISP语言称为许多令人恼火和愚蠢的括号。RxCpp库广泛使用`|`运算符来组合函数。以下代码帮助我们了解如何创建可管道化的函数。我们将看一下这个原则上如何实现。这里给出的代码仅用于解释目的：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code creates a set of Callable classes and it will be used as
    part of a compositional chain of functions. Now, we need to create a mechanism
    to convert an arbitrary function to a closure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一组Callable类，并将其用作函数组合链的一部分。现在，我们需要创建一种机制，将任意函数转换为闭包：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, we can create an instance of `PipableClosure` with a unary function as
    a parameter and chain (or compose) together a series of invocations to the closure.
    The preceding code snippet should print three on the console. We have also created
    a `PipableBinaryClosure` instance to string together both unary and binary functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个带有一元函数作为参数的`PipableClosure`实例，并将一系列调用链接（或组合）到闭包中。前面的代码片段应该在控制台上打印出三。我们还创建了一个`PipableBinaryClosure`实例，以串联一元和二元函数。
- en: Miscellaneous features
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项功能
- en: So far, we have covered the most important semantic changes to the language
    beginning with the C++ 11 standard. The purpose of this chapter is to highlight
    key changes that might be useful in writing idiomatic Modern C++ programs. The
    C++ 17 standard added some more stuff into the language. We will be highlighting
    a few more features of the language to wrap up this discussion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了从C++ 11标准开始的语言中最重要的语义变化。本章的目的是突出一些可能有助于编写现代C++程序的关键变化。C++ 17标准在语言中添加了一些新内容。我们将突出语言的一些其他特性来结束这个讨论。
- en: Fold expressions
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 折叠表达式
- en: 'The C++ 17 standard added support for fold expressions to ease the generation
    of variadic functions. The Compiler does pattern matching and generates the code
    by inferring the intent of the programmer. The following code snippet demonstrates
    the idea:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 17标准增加了对折叠表达式的支持，以简化可变函数的生成。编译器进行模式匹配，并通过推断程序员的意图生成代码。以下代码片段演示了这个想法：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The expected output on the console is as follows
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台上的预期输出如下
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Variant type
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变体类型
- en: 'A geeky definition of variant would be "type safe union". We can give a list
    of types as a template argument while defining variants. At any given time, the
    object will hold only one type of data out of the template argument list. `std::bad_variant_access`
    will be thrown if we try to access an index that does not hold the current value.
    The following code does not handle this exception:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 变体的极客定义将是“类型安全的联合”。在定义变体时，我们可以将一系列类型作为模板参数。在任何给定时间，对象将仅保存模板参数列表中的一种数据类型。如果我们尝试访问不包含当前值的索引，将抛出`std::bad_variant_access`异常。以下代码不处理此异常：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Other important topics
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他重要主题
- en: Modern C++ supports features such as language-level concurrency, memory guarantees,
    and asynchronous executions, which are covered in the next two chapters. The language
    offers support for optional data types and the `std::any` type. One of the most
    important feature is parallel versions of most of the STL algorithms.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++支持诸如语言级并发、内存保证和异步执行等功能，这些功能将在接下来的两章中介绍。该语言支持可选数据类型和`std::any`类型。其中最重要的功能之一是大多数STL算法的并行版本。
- en: Range-based for loops and observables
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于范围的for循环和可观察对象
- en: 'In this section, we will implement range-based for loops on a custom type written
    by us to help you understand how all the things mentioned earlier in this chapter
    can be put together to write programs that support modern idioms. We will  implement
    a class that returns a series of numbers within a bound and will implement infrastructure
    support for the iteration of the values based on range-based for loops. First,
    we write the  "Iterable/Iterator" (aka "Enumerable/Enumerable") version by leveraging
    the range-based for loops.  After some tweaks, the implementation will be transformed
    to Observable/Observer (the key interface of Reactive Programming) patterns: The
    implementation of Observable/Observer pattern here is just for elucidation purpose
    and  should not be considered as an Industrial strength implementation of these
    patterns.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现自己编写的自定义类型上的基于范围的for循环，以帮助您了解如何将本章中提到的所有内容组合起来编写支持现代习语的程序。我们将实现一个返回在范围内的一系列数字的类，并将实现基于范围的for循环的值的迭代的基础设施支持。首先，我们将利用基于范围的for循环编写“Iterable/Iterator”（又名“Enumerable/Enumerable”）版本。经过一些调整，实现将转变为Observable/Observer（响应式编程的关键接口）模式：此处Observable/Observer模式的实现仅用于阐明目的，不应被视为这些模式的工业级实现。
- en: 'The following `iterable` class is a nested class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`iterable`类是一个嵌套类：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code implements an inner class derived from `std::iterator` to
    take care of the requirements for a type to be enumerable through range-based
    for loops. We will now write two public methods, (`begin()` and `end()`), so consumers
    of the class can use range-based for loops:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实现了一个内部类，该类派生自`std::iterator`，以满足类型通过基于范围的for循环进行枚举的要求。现在我们将编写两个公共方法（`begin()`和`end()`），以便类的使用者可以使用基于范围的for循环：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can write code to consume the preceding class as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写代码来使用前面的类：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the previous chapter, we defined the `IEnumerable<T>` interface. The idea
    was to stick with the documentation of Reactive eXtensions. The iterable class
    is very similar to the `IEnumerable<T>` implementation in the previous chapter.
    As outlined in the previous chapter, the preceding class can be made push based,
    if we tweak the code a bit. Let us write an `OBSERVER` class that contains three
    methods. We will be using Function Wrappers available with standard library to
    define the methods:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们定义了`IEnumerable<T>`接口。这个想法是遵循Reactive eXtensions的文档。可迭代类与上一章中的`IEnumerable<T>`实现非常相似。正如在上一章中概述的那样，如果我们稍微调整代码，前面的类可以变为推送型。让我们编写一个包含三个方法的`OBSERVER`类。我们将使用标准库提供的函数包装器来定义这些方法：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `ObservableRange` class given here contains a `vector<T>` that stores the
    list of subscribers. When a new number is generated, the event will be notified
    to all subscribers. If we dispatch the notification call from an asynchronous
    method, the consumer is decoupled from the producer of the range stream. We have
    not implemented the `IObserver/IObserver<T>` interface for the following class,
    but we can subscribe to notifications through subscribe methods:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的`ObservableRange`类包含一个存储订阅者列表的`vector<T>`。当生成新数字时，事件将通知所有订阅者。如果我们从异步方法中分派通知调用，消费者将与范围流的生产者解耦。我们还没有为以下类实现`IObserver/IObserver<T>`接口，但我们可以通过订阅方法订阅通知：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will store the list of subscribers in an `std::vector` as an `std::pair`.
    The first value in the `std::pair` is the reference to the `OBSERVER` and the
    second value in the `std::pair` is an integer that uniquely identifies the subscriber. 
    Consumers are supposed to unsubscribe by using the ID returned by the subscribe
    method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以`std::pair`的形式将订阅者列表存储在`std::vector`中。`std::pair`中的第一个值是对`OBSERVER`的引用，`std::pair`中的第二个值是唯一标识订阅者的整数。消费者应该使用订阅方法返回的ID来取消订阅：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about programming language features that a C++ programmer
    should be comfortable with while writing Reactive programs, or for that matter
    any kind of programs. We talked about type inference, Variadic templates, rvalue
    references and move semantics, Lambda functions, elementary Functional programming,
    pipeable operators, and implementation of Iterators and observers. In the next
    chapter, we will  learn about concurrent programming support provided by the C++
    programming language.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了C++程序员在编写响应式程序或其他类型的程序时应该熟悉的编程语言特性。我们谈到了类型推断、可变模板、右值引用和移动语义、Lambda函数、基本的函数式编程、可管道化的操作符以及迭代器和观察者的实现。在下一章中，我们将学习C++编程语言提供的并发编程支持。
