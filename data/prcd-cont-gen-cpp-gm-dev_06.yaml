- en: Chapter 6. Procedurally Generating Art
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。程序生成艺术
- en: A game's art is one of its defining features. It's usually what first attracts
    us, and it is one of the driving forces behind keeping us hooked; great aesthetics
    go a long way. Given that, we want to ensure that this is an area that is as rich,
    diverse, and immersive as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的艺术是其定义特征之一。通常是我们首先吸引我们的东西，也是让我们着迷的驱动力之一；出色的美学效果可以走很远。鉴于此，我们希望确保这个领域尽可能丰富、多样和沉浸。
- en: However, art is financially expensive and time-consuming to produce. Not only
    that, it's also expensive at the hardware level! Game textures can hit 4K in size,
    and creating a thousand 4K textures and storing them on traditional game media
    is no easy task. Thankfully, a wide range of procedural generation techniques
    can be employed when creating art to help combat some of these issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，艺术在财务上昂贵且耗时。不仅如此，在硬件层面也很昂贵！游戏纹理可以达到4K大小，创建一千个4K纹理并将它们存储在传统游戏媒体上并不容易。幸运的是，在创建艺术时可以采用各种程序生成技术来帮助解决其中的一些问题。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How procedural generation is used with art
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序生成如何与艺术结合使用
- en: The benefits and drawbacks of procedurally generated art
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序生成艺术的优缺点
- en: Using SFML sprite modifiers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SFML精灵修改器
- en: Saving modified sprites
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存修改后的精灵
- en: Programmatically creating sprites
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过程序创建精灵
- en: How procedural generation is used with art
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序生成如何与艺术结合使用
- en: Game art is a great candidate for procedural generation. It's expensive to create
    manually, both in terms of developer investment and on a hardware level, and is
    open to be manipulated programmatically. However, like everything, it has a range
    of benefits and drawbacks. So, let's take a look at them before we get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏艺术是程序生成的一个很好的候选对象。手工创建它在开发者投入和硬件层面上都很昂贵，并且可以通过程序进行操纵。然而，像一切事物一样，它有一系列的优点和缺点。因此，在我们开始之前，让我们先来看看它们。
- en: Using sprite effects and modifiers
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用精灵效果和修改器
- en: Perhaps the simplest way in which procedural generation can be used with game
    art is through the manipulation of existing sprites and models using built-in
    functions. For example, most game engines and frameworks will offer some functionality
    to edit graphics, such as the color, alpha, and scale modifiers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成可以与游戏艺术结合的最简单方式可能是通过使用内置函数来操纵现有的精灵和模型。例如，大多数游戏引擎和框架都会提供一些编辑图形的功能，如颜色、透明度和比例修改器。
- en: 'Combining these functions with **Random Number Generator** (**RNG**) is an
    easy and quick way to start producing randomized game art. For example, **Simple
    and Fast Multimedia Library** (**SFML**) offers the functionality to change both
    the color and size of a sprite. Even if we just use these functions, we can generate
    a wide range of different textures during runtime. This is shown in the following
    screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些功能与随机数生成器（RNG）结合使用是开始生成随机游戏艺术的一种简单快速的方法。例如，Simple and Fast Multimedia Library（SFML）提供了改变精灵颜色和大小的功能。即使只使用这些功能，我们也可以在运行时生成各种不同的纹理。如下截图所示：
- en: '![Using sprite effects and modifiers](img/B04920_06_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![使用精灵效果和修改器](img/B04920_06_01.jpg)'
- en: Combining multiple textures
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合多个纹理
- en: A step up from the simple modification of existing textures is the combining
    of multiple textures to create new ones. Throw in some RNG, and you can create
    a large number of sprites with very little effort. We'll use this technique in
    this chapter to give our enemies random armor!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单修改现有纹理的方式升级，是将多个纹理组合在一起创建新的纹理。加入一些随机数生成器，你就可以轻松地创建大量的精灵。在本章中，我们将使用这种技术为我们的敌人随机生成盔甲！
- en: 'We''ll start with a base enemy sprite, randomly choose some armor, and draw
    it on top of the original image to create a random sprite! More on that later,
    but for now, here''s what it will look like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个基本的敌人精灵开始，随机选择一些盔甲，并将其绘制在原始图像上，以创建一个随机精灵！稍后再详细介绍，但现在先看看它会是什么样子：
- en: '![Combining multiple textures](img/B04920_06_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![组合多个纹理](img/B04920_06_02.jpg)'
- en: Creating textures from scratch
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从头开始创建纹理
- en: The most complex way of creating procedural textures is by using algorithms
    to create them from scratch. Algorithms such as Perlin noise can be used to create
    a natural looking texture base which can then be used to create a wide range of
    procedural textures using techniques such as image multiplication.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建程序纹理的最复杂方式是使用算法从头开始创建它们。诸如Perlin噪声之类的算法可以用来创建自然外观的纹理基础，然后可以使用诸如图像乘法之类的技术来创建各种程序纹理。
- en: 'For example, a base Perlin noise texture, a white noise texture, and a flat
    color can be combined to create a procedural texture, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以将基本的Perlin噪声纹理、白噪声纹理和纯色结合起来创建程序纹理，如下所示：
- en: '![Creating textures from scratch](img/B04920_06_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![从头开始创建纹理](img/B04920_06_03.jpg)'
- en: With this approach, changes in the algorithm that generates the first two textures
    will result in a different final texture. This technique can be employed to create
    endless unique textures for a game without creating storage problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，对生成第一和第二个纹理的算法进行更改将导致不同的最终纹理。这种技术可以用来为游戏创建无尽的独特纹理，而不会产生存储问题。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This type of procedural image creation is beyond the scope of the book. If you
    wish to delve into this further, read up on texture synthesis and algorithms such
    as Perlin noise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的程序图像创建超出了本书的范围。如果你希望进一步深入了解，请阅读有关纹理合成和Perlin噪声等算法的资料。
- en: Creating complex animations
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建复杂的动画
- en: The growth of computing power has also given rise to procedural animation. Traditionally,
    an animated game asset, such as a character, would be animated in a 3D animation
    package by an animator. This animation routine would then be loaded during runtime
    by the game engine and applied to a given model to make it move.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 计算能力的增长也催生了程序动画。传统上，动画游戏资源，如角色，会由动画师在3D动画软件中制作动画。然后，游戏引擎在运行时加载这个动画例程，并应用于给定的模型以使其移动。
- en: As computers are now able to perform more calculations that ever, procedural
    animation is becoming more popular. Ragdoll bodies are used in lots of game now,
    which is a great example of procedural animation. Instead of a set animation routine
    being played, information about the body, such as its weight, velocity, and rigidity,
    is used to calculate what position the body should be in to create realistic and
    dynamic movement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算机现在能够进行比以往更多的计算，程序动画变得越来越受欢迎。现在很多游戏中都使用布娃娃身体，这是程序动画的一个很好的例子。与播放一组固定的动画例程不同，身体的信息，如重量、速度和刚度，被用来计算身体应该处于的位置，以创建逼真和动态的运动。
- en: The benefits of procedurally generated art
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序生成艺术的好处
- en: The procedural generation of game art brings with it a range of benefits to
    us as developers and the people who play our games. From its versatility, to being
    cost-effective and a time-saver, let's take a look at a few of these benefits.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏艺术的程序生成为我们开发人员和玩家带来了一系列好处。从其多功能性，到成本效益和节省时间，让我们来看看其中的一些好处。
- en: Versatility
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多功能性
- en: The main benefit of procedurally generating game art is **versatility**. Game
    art is expensive to produce, and as a result imposes limits on what can feasibly
    be created for a given project. It would be nice to have an artist create thousands
    of textures for our games, but it's not feasible. Instead, we can create a handful
    resources, employ procedural techniques to turn these resources into thousands
    of individual possible textures, and bring variety and diversity to games.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成游戏艺术的主要好处是多功能性。游戏艺术的制作成本很高，因此对于给定项目来说，会有一定的限制。虽然让艺术家为我们的游戏创建成千上万种纹理会很好，但这是不可行的。相反，我们可以创建一些资源，利用程序技术将这些资源转化为成千上万种可能的纹理，并为游戏带来多样性和丰富性。
- en: Cheap to produce
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 廉价生产
- en: Expanding on the previous point, since we do not have to pay artists to manually
    create all of these textures, procedural generation saves us both time and money.
    In the example that we're going to work on in this chapter, we're going to provide
    our enemies with random armor. There will be three types of armor, each with three
    tiers, and the combination of which armor the enemy has will also be random. The
    number of possible combinations there is huge, and having an artist create them
    manually would be costly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的观点上进行扩展，由于我们不必支付艺术家手工创建所有这些纹理，程序生成为我们节省了时间和金钱。在本章中，我们将要处理的示例是为我们的敌人提供随机护甲。将有三种类型的护甲，每种有三个等级，敌人所拥有的护甲的组合也将是随机的。可能的组合数量是巨大的，让艺术家手工创建它们将是昂贵的。
- en: It requires little storage
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它需要很少的存储空间
- en: Continuing with the example of giving our enemies armor, even if we could get
    an artist to produce all the sprites manually, how are they going to be stored?
    While this is less of an issue for online games, as there's usually no imposed
    limit on the game and download size, games that ship on traditional media, such
    as a disk, have to use the space wisely. Textures are an expensive resource in
    this regard. Therefore, creating a handful of resources and programmatically creating
    a texture from them alleviates these issues.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以给予敌人护甲的例子，即使我们可以让艺术家手工制作所有的精灵，它们将如何被存储？虽然对于在线游戏来说这不是太大的问题，因为游戏和下载大小通常没有限制，但是那些需要传统媒体（如光盘）发行的游戏必须明智地利用空间。在这方面，纹理是一种昂贵的资源。因此，创建一些资源并通过程序从中创建纹理可以缓解这些问题。
- en: The drawbacks of procedurally generated art
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序生成艺术的缺点
- en: With the good comes the bad, and procedurally generated art is no exception.
    Though it is flexible and saves space, it does come with a few drawbacks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好处与坏处并存，程序生成的艺术也不例外。虽然它灵活并节省空间，但它也有一些缺点。
- en: Lack of control
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏控制
- en: One of the first drawbacks is application agnostic, and is a drawback of procedural
    generation as a whole; the loss of control that comes with it. If you're generating
    art procedurally you lose the touch that a skilled artist can give it. The content
    can lack character and feel very rigid due to being the result of a deterministic
    process, not a creative one. A good procedural algorithm can mitigate this to
    a certain extent, but it's hard to generate content that feels and looks as natural
    as a talented artist would make it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个缺点是应用程序不可知的，这是程序生成的一个整体缺点；它带来的失控。如果你通过程序生成艺术，你会失去一个熟练艺术家所能赋予的触感。内容可能缺乏特色，由于是确定性过程的结果，而不是创造性的过程，可能会感觉非常僵硬。一个好的程序算法可以在一定程度上缓解这个问题，但很难生成感觉和看起来像一个有才华的艺术家所创作的自然内容。
- en: Repeatability
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重复性
- en: Another potential problem with procedurally generating art is that things may
    appear very repeated and unnatural. Content will be produced through an algorithm,
    and variation in the output is a result of the variance in the terms used. Given
    that, each algorithm has a spectrum of content that can be produced. If the operating
    range of the algorithm is too small, textures will be repeated and may feel unnatural
    and reused, despite procedural generation being used to mitigate that very thing!
    It's all in the quality of the algorithm and how it's used.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成艺术的另一个潜在问题是，事物可能会显得非常重复和不自然。内容将通过算法产生，输出的变化是使用术语的差异的结果。鉴于此，每个算法都有可能产生的内容范围。如果算法的操作范围太小，纹理将会重复，并且可能会感到不自然和重复使用，尽管程序生成被用来缓解这个问题！这完全取决于算法的质量和使用方式。
- en: Performance heavy
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能重
- en: Procedurally creating art usually involves lots of reading and copying textures,
    which are generally expensive operations, especially if you're working with high-resolution
    textures. Using the enemy armor example as a use case, if we were to create the
    sprites manually, we would just have to load the texture, which is a single operation.
    If we create a sprite procedurally, we have to load each component, edit them,
    and re-render them to create a new texture.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成艺术通常涉及大量的读取和复制纹理，这些通常是昂贵的操作，特别是如果你使用高分辨率纹理。以敌人盔甲为例，如果我们手动创建精灵，我们只需要加载纹理，这是一个单一的操作。如果我们程序生成一个精灵，我们必须加载每个组件，编辑它们，并重新渲染它们以创建一个新的纹理。
- en: Using SFML sprite modifiers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SFML精灵修改器
- en: Now that we've identified a number of strengths and weaknesses of procedurally
    generating art, get started! The first naïve approach that we'll look at is simply
    using `sprite` modifiers such as `color` and `alpha` to alter the existing sprites.
    With this method we'll be using the built-in sprite modifiers that SFML offers.
    Most engines and frameworks will have functions that are similar to these, and
    if not, you can just make them yourself!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了程序生成艺术的一些优点和缺点，开始吧！我们将首先看一下的天真方法是简单地使用`sprite`修改器，如`color`和`alpha`来改变现有的精灵。使用这种方法，我们将使用SFML提供的内置精灵修改器。大多数引擎和框架都会有类似的函数，如果没有，你也可以自己创建！
- en: How colors work in SFML
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFML中颜色的工作原理
- en: 'Let''s start with the simplest way of procedurally generating a sprite, generating
    a unique color for it during runtime. A color in SFML is simply a set of four
    `uint8` values, with one for each color channel and one for an alpha:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的程序生成精灵的方法开始，在运行时为它生成一个独特的颜色。在SFML中，颜色简单地是四个`uint8`值的集合，每个颜色通道一个，还有一个alpha通道：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Every `sf::Sprite` in SFML has a `sf::Color` member variable. This color value
    is multiplied with the color values of the pixels in the texture to arrive at
    the final color. The following image demonstrates this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SFML中的每个`sf::Sprite`都有一个`sf::Color`成员变量。这个颜色值与纹理中像素的颜色值相乘，得到最终的颜色。下图演示了这一点：
- en: '![How colors work in SFML](img/B04920_06_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![SFML中颜色的工作原理](img/B04920_06_04.jpg)'
- en: In the preceding image, we can see the original image on the far left. Also,
    we can see the resulting images when the sprite has various colors set.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到最左边的原始图像。此外，我们还可以看到精灵设置了各种颜色时的结果图像。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the best results, it's best to start with a monochromatic gray base texture
    so that the color modulation arrives at the correct color.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳效果，最好从单色灰色基础纹理开始，以便颜色调制到达正确的颜色。
- en: 'The `sf::Color` type also has an *alpha* value, which is used to determine
    the opacity of the object. The lower the alpha channel, the more transparent the
    object. With this value, you can change how opaque an object is, as shown in the
    following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Color`类型还有一个*alpha*值，用于确定对象的不透明度。alpha通道越低，对象就越透明。通过这个值，你可以改变对象的不透明度，如下图所示：'
- en: '![How colors work in SFML](img/B04920_06_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![SFML中颜色的工作原理](img/B04920_06_05.jpg)'
- en: With this understanding of how SFML deals with color, let's put it into action
    by generating a random sprite for the slime character, setting both its color
    and alpha pragmatically.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了SFML如何处理颜色，让我们通过为史莱姆角色生成一个随机精灵，并在程序中设置它的颜色和alpha值来将其付诸实践。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To learn more about how SFML deals with color, read the SFML documentation that
    is found at [http://www.sfml-dev.org/learn.php](http://www.sfml-dev.org/learn.php).
    For more in-depth information, head to the OpenGL documentation, in the the graphics
    API SFML uses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于SFML如何处理颜色的信息，请阅读[http://www.sfml-dev.org/learn.php](http://www.sfml-dev.org/learn.php)上找到的SFML文档。要了解更多详细信息，请前往SFML使用的图形API
    OpenGL文档。
- en: Creating sprites of a random color
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建随机颜色的精灵
- en: In SFML, sprite objects have a member function called `setColor()`. This function
    takes an `sf::Color` object and sets it as the value to be multiplied with the
    sprite's texture when drawn. We know that `sf::Color` is essentially just four
    `uint8` values, with each having a range of 0 to 255\. Given that, to generate
    a random color, we can either generate random values for these color channels,
    or randomly select one of the built-in pre-defined colors of SFML.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在SFML中，精灵对象有一个名为`setColor()`的成员函数。这个函数接受一个`sf::Color`对象，并将其设置为在绘制时与精灵纹理相乘的值。我们知道`sf::Color`本质上只是四个`uint8`值，每个值的范围是0到255。鉴于此，要生成一个随机颜色，我们可以为这些颜色通道生成随机值，或者随机选择SFML预定义颜色中的一个。
- en: The slime enemy is a great candidate for this, as it will look great in many
    colors and the base sprite is a dull gray color. Multiplying a color with this
    sprite will work well. When we set the slime sprite, we'll give it a random color
    using both methods. Let's start with selecting a pre-defined color.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 史莱姆敌人是一个很好的选择，因为它在许多颜色下都会看起来很棒，而基础精灵是一种沉闷的灰色。将颜色与这个精灵相乘将起到很好的效果。当我们设置史莱姆精灵时，我们将使用这两种方法随机给它一个颜色。让我们从选择预定义颜色开始。
- en: Selecting a preset color at random
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机选择预设颜色
- en: 'SFML comes with the following pre-defined colors:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SFML带有以下预定义颜色：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are defined in `Color.hpp` and cover the most popular colors. The first
    problem is that we need some way of selecting one at random. To do this, we can
    create an enumerator of matching color values, generate a random index, and then
    use that to match the enumerator value with the matching predefined color. This
    will become clearer as we look at the code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在`Color.hpp`中定义，并涵盖了最受欢迎的颜色。首先的问题是我们需要一种随机选择的方法。为此，我们可以创建一个匹配颜色值的枚举器，生成一个随机索引，然后使用它来将枚举器值与匹配的预定义颜色相匹配。当我们看代码时，这将变得更清晰。
- en: 'We''ll start by adding the following enumerator definition to the `Util.h`
    file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`Util.h`文件中添加以下枚举器定义：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For each of the predefined colors, we've added a corresponding value to the
    `enum`, ensuring that it ends with `COUNT`. With this defined, we just need to
    calculate a number between 0 and `COLOR::COUNT` and then use it in a `switch`
    statement. It's a method that we've used a few times now so we should be familiar
    with it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个预定义颜色，我们已经为`enum`添加了相应的值，确保它以`COUNT`结尾。有了这个定义，我们只需要计算0到`COLOR::COUNT`之间的数字，然后在`switch`语句中使用它。这是我们现在已经使用了几次的方法，所以我们应该对它很熟悉。
- en: 'Jumping to the constructor of the slime enemy, we''ll start by generating a
    random index:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到史莱姆敌人的构造函数，我们将从生成一个随机索引开始：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we will simply switch the `colorIndex` value and set the corresponding
    color:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要切换`colorIndex`值并设置相应的颜色：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should be continued for each value of the enumerator that we defined.
    Now, you will see that every slime enemy that is spawned into the game has a different
    predefined color:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该对我们定义的每个枚举值进行继续。现在，你会看到每个生成到游戏中的史莱姆敌人都有不同的预定义颜色：
- en: '![Selecting a preset color at random](img/B04920_06_06.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: 随机选择预设颜色
- en: Generating a color at random
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机生成颜色
- en: The second option, which gives us much more control, is to generate our own
    colors at random. This method gives us a much wider range of possibilities, as
    well as provides us access to the alpha channel; however, we lose some control.
    When selecting from predefined colors, we know that we'll always end up with a
    pleasant-looking color, which is something that we can't guarantee when generating
    our own values for each channel. Regardless of this, let's look at how we'll do
    it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项，给了我们更多的控制权，就是随机生成我们自己的颜色。这种方法给了我们更广泛的可能性范围，同时也让我们可以访问alpha通道；然而，我们失去了一些控制。当从预定义颜色中选择时，我们知道我们最终会得到一种令人愉悦的颜色，这是我们无法保证当为每个通道生成我们自己的值时。尽管如此，让我们看看我们将如何做。
- en: We know that `sf:color` has four channels (r, g, b, and a), and each value lies
    between 0 and 255\. To generate a random color, we need to generate values for
    the r, g, and b channels; a is for the alpha channel, and it will allow us to
    alter the opacity of the sprite.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`sf:color`有四个通道（r、g、b和a），每个值都在0到255之间。为了生成随机颜色，我们需要为r、g和b通道生成值；a是alpha通道，它将允许我们改变精灵的不透明度。
- en: 'To start, we''ll define the variables and generate a random value for the r,
    g, and b channels, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义变量并为r、g和b通道生成随机值，如下所示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the alpha channel, we want to be a bit more precise with the number generation.
    An alpha value of 0 would be way too low; we''d barely see the sprite. For this
    reason, we''ll generate a number in the range of 100 to 255, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于alpha通道，我们希望在数字生成方面更加精确。alpha值为0太低了；我们几乎看不到精灵。因此，我们将生成一个在100到255范围内的数字，如下所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have these values, we need to create an `sf::color` object, passing
    the `r`, `g`, `b`, and `a` values in the `color` constructor:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些值，我们需要创建一个`sf::color`对象，将`r`、`g`、`b`和`a`值传递给`color`构造函数：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The final step is to make a call to `sf::sprite::setColor()`, passing the new
    color. The complete code is as follows and should reside in the constructor of
    the slime enemy:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用`sf::sprite::setColor()`，传递新的颜色。完整的代码如下，应该放在史莱姆敌人的构造函数中：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we run the game, we should get three very different colored slimes,
    each with a varying degree of opacity, as shown in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行游戏，我们应该会得到三个非常不同颜色的史莱姆，每个都有不同程度的不透明度，如下截图所示：
- en: '![Generating a color at random](img/B04920_06_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: 随机生成颜色
- en: Creating sprites of a random size
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成随机颜色
- en: The final sprite modifier that we'll play with is scale. Using the `sf::Sprite::setScale()`
    function, we can set both the horizontal and vertical scale of the sprite. The
    default scale is 1, so if we scale using a value of 2, the sprite will be twice
    as big. Likewise, if we set a scale of 0.5, it will be half as big. Given this,
    we need to generate floats that are just either side of 1\. A range of 0.5 to
    1.5 should give us enough variance in size!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要玩耍的最后一个精灵修改器是缩放。使用`sf::Sprite::setScale()`函数，我们可以设置精灵的水平和垂直缩放。默认缩放为1，所以如果我们使用值为2进行缩放，精灵将变大一倍。同样，如果我们设置为0.5的缩放，它将变小一半。鉴于此，我们需要生成接近1的浮点数。0.5到1.5的范围应该给我们足够的大小差异！
- en: 'So, we need to generate a float, but the `std::rand()` function will only generate
    an integer value. Don''t worry! There is a simple trick that we can use to get
    a float out of it! We simply need to generate a number between 5 and 15 and then
    divide it by ten to get the float value:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要生成一个浮点数，但`std::rand()`函数只会生成一个整数值。别担心！我们可以使用一个简单的技巧来得到一个浮点数！我们只需要生成一个5到15之间的数字，然后除以10得到浮点值：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that the random scale value is generated, we now just need to call me `sf::sprite::setScale()`
    function and use the `scale` variable as the scaling value. The complete code
    is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在随机比例值已经生成，我们现在只需要调用`sf::sprite::setScale()`函数，并使用`scale`变量作为缩放值。完整的代码如下：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On running the game, you will now see that the slime enemies have different
    colors and they vary in size too:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏后，你会看到史莱姆敌人有不同的颜色，它们的大小也不同：
- en: '![Creating sprites of a random size](img/B04920_06_08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: 生成随机大小的精灵
- en: Saving modified sprites
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存修改后的精灵
- en: In our game we're going to be generating new sprites each time the game is run.
    We want each run to be unique, so once we've generated a sprite and used it we
    can let it go. However sometimes, you might want to keep hold of a sprite. For
    example, you might want to create a randomized NPC and keep the same character
    throughout the entire game.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，每次运行游戏时，我们都将生成新的精灵。我们希望每次运行都是独一无二的，所以一旦我们生成了一个精灵并使用它，我们就可以让它离开。然而有时，你可能想保留一个精灵。例如，你可能想创建一个随机的NPC并在整个游戏中保持相同的角色。
- en: The two data types that we've used to create images so far are `sf::Sprite`
    and `sf::Texture`. These classes let us interact with images through a set of
    predefined member functions. It's great for standard drawing and simple image
    manipulation, but we don't get access to the raw image information. This is where
    `sf::Image` comes into play!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们用来创建图像的两种数据类型是`sf::Sprite`和`sf::Texture`。这些类让我们通过一组预定义的成员函数与图像交互。它非常适用于标准绘图和简单的图像操作，但我们无法访问原始图像信息。这就是`sf::Image`发挥作用的地方！
- en: Passing a texture into an image
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将纹理传递到图像
- en: '`Sf::Image` is a class that is used to load, manipulate, and save images. Unlike
    the other data types, `sf::Image` provides us with the raw image data, allowing
    us to interact with every pixel in the image. We''ll use more of this functionality
    later, but for now, we''re interested in the `sf::Image::saveToFile` function.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sf::Image`是一个用于加载、操作和保存图像的类。与其他数据类型不同，`sf::Image`为我们提供了原始图像数据，允许我们与图像中的每个像素交互。我们稍后将使用更多这方面的功能，但现在，我们对`sf::Image::saveToFile`函数感兴趣。'
- en: With this function, we can save an image in a file; we just need to our the
    texture into that image. Luckily, there's a function to do just that! The `sf::Texture`
    class has a function named `copyToImage` that copies the raw image data from a
    texture into an image. So, we should be able to copy the texture to an image and
    save it, right? Well, let's try it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个函数，我们可以将图像保存到文件；我们只需要将纹理放入图像中。幸运的是，有一个函数可以做到这一点！`sf::Texture`类有一个名为`copyToImage`的函数，它将纹理中的原始图像数据复制到图像中。所以，我们应该能够将纹理复制到图像并保存它，对吗？好吧，让我们试试看。
- en: 'In `Slime::Slime`, let''s add the following debug code after we''ve modified
    the sprite:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Slime::Slime`中，在我们修改了精灵之后，让我们添加以下调试代码：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you take a look at the file that we created and compare it to the original
    image, you will see something odd:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下我们创建的文件并将其与原始图像进行比较，你会发现有些奇怪的地方：
- en: '![Passing a texture into an image](img/B04920_06_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![保存图像到文件](img/B04920_06_10.jpg)'
- en: The modifications that we make to the sprite do not edit the texture. Instead,
    modifications are made every time we draw the object. When we output the texture
    like this, we simply output the same sprite that we put in! To save the changes
    that were made through sprite modifications, we need to utilize the `sf::RenderTexture`
    class as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对精灵所做的修改不会编辑纹理。相反，每次绘制对象时都会进行修改。当我们像这样输出纹理时，我们只是输出了放入的相同精灵！为了保存通过精灵修改所做的更改，我们还需要利用`sf::RenderTexture`类。
- en: Drawing to a RenderTexture class
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制到RenderTexture类
- en: Since sprite modifications aren't applied to the texture, we need to somehow
    capture the sprite once it has been rendered. Again, SFML comes to the rescue
    with its `sf::RenderTexture` class. This class allows us to render into a texture
    as opposed to the screen, solving the issue of modifications not been applied
    to the texture.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于精灵修改不会应用到纹理上，我们需要以某种方式捕捉一旦渲染完成的精灵。再次，SFML通过其`sf::RenderTexture`类来解决这个问题。这个类允许我们渲染到纹理而不是屏幕，解决了修改不会应用到纹理上的问题。
- en: To start, we need to create an `sf::RenderTexture` object. For this, we need
    to know the size of the area that we'll be drawing to, and there's something that
    we need to keep in mind here. We're making changes to the size of the object.
    So, if we just get the size of the texture, it will either be too big or too small.
    Instead, we need to get the size of the texture and multiply it by the same scale
    value that we apply to the sprite.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个`sf::RenderTexture`对象。为此，我们需要知道我们将要绘制的区域的大小，并且在这里有一些需要记住的事情。我们正在改变对象的大小。因此，如果我们只是获取纹理的大小，它要么太大要么太小。相反，我们需要获取纹理的大小并将其乘以我们应用于精灵的相同比例值。
- en: 'Let''s get some code written to make things clearer. We''ll start by creating
    the `sf::RenderTarget` object, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码来使事情更清晰。我们将首先创建`sf::RenderTarget`对象，如下所示：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we will get the size of the texture and multiply it by the same
    scale that we modified the sprite by.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们将获取纹理的大小并将其乘以我们修改精灵的相同比例。
- en: 'Finally, we will draw the object to the render view, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将对象绘制到渲染视图中，如下所示：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Saving an image to a file
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存图像到文件
- en: From this point onwards, the code is the same as our first attempt, but with
    a slight modification. Because the sprite is animated, we change both its origin
    and the `textureRect` properties to cut it into subsections in order to animate
    the character. This needs reverting in order to see the entire texture. Also,
    when we call `sf::Texture::copyToImage`, the sprite gets flipped vertically. Before
    we save the file, we need to flip it back.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，代码与我们的第一次尝试相同，但有一点修改。因为精灵是动画的，我们改变了它的原点和`textureRect`属性，以将其切割成子部分以便动画角色。为了看到整个纹理，这需要恢复。此外，当我们调用`sf::Texture::copyToImage`时，精灵会垂直翻转。在保存文件之前，我们需要将其翻转回来。
- en: 'Here is the complete code example that is used to save the modified slime texture:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于保存修改后slime纹理的完整代码示例：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget to delete this code when you're done as it is expensive to save
    files and it messes up the animation!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后不要忘记删除这段代码，因为保存文件很昂贵，而且会搞乱动画！
- en: 'Now, if you run the game and take a look at the file, you will see the modifications
    that we made:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏并查看文件，你会看到我们所做的修改。
- en: '![Saving an image to a file](img/B04920_06_10.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![将纹理传递到图像](img/B04920_06_09.jpg)'
- en: Creating enemy sprites procedurally
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以程序方式创建敌人精灵
- en: 'Having the ability to render to `sf::RenderTexture` and store the results opens
    up a world of possibilities. One of these is combining multiple sprites to create
    new, more versatile ones. We can draw to an `sf::RenderTexture` class multiple
    times, and the sprites will overlap. This is an incredibly useful technique that
    can be used to generate a vast amount of sprite variations without all the work.
    This is shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有渲染到`sf::RenderTexture`并存储结果的能力打开了无限的可能性。其中之一是组合多个精灵以创建新的、更多功能的精灵。我们可以多次绘制到`sf::RenderTexture`类，并且精灵将重叠。这是一种非常有用的技术，可以用来生成大量的精灵变化，而无需进行大量工作。这在以下截图中显示：
- en: '![Creating enemy sprites procedurally](img/B04920_06_11.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![创建敌人精灵的过程](img/B04920_06_11.jpg)'
- en: Using this approach, we'll create random armor for our enemies. We'll have three
    pieces of armor; head, torso, and legs. For each of these, we'll also have three
    variations; bronze, silver, and gold. This alone gives us a large number of possible
    combinations. Then, let's consider that we need this for each character, of which
    we have two, and each character has eight sprites. That's an enormous number of
    textures. It's totally out of the question to create all of them manually.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们将为我们的敌人创建随机盔甲。我们将有三件盔甲；头部、躯干和腿部。对于每个部分，我们还将有三种变化；青铜、银和金。这本身就给我们提供了大量可能的组合。然后，让我们考虑到我们需要这个对于每个角色，我们有两个，每个角色有八个精灵。这是一个巨大的纹理数量。完全不可能手动创建所有这些。
- en: Breaking sprites into components
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将精灵分解为组件
- en: The armor sprites that we will create are going to be laid right on top of the
    default enemy animations. The most important thing to consider here is that their
    sizes and position will line up when drawn on top of one another.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的盔甲精灵将直接放在默认的敌人动画上。在这里需要考虑的最重要的事情是，当它们在彼此上方绘制时，它们的大小和位置将对齐。
- en: 'When creating an `sf::RenderTexture` class, we define a size. Everything drawn
    to it will then be positioned relative to the top left corner of this area. If
    our sprites have different sizes, when we start drawing, they will be misaligned.
    The following examples have had their backgrounds darkened so that we can see
    this. In the first example, the sprites have been cropped, and we can see that
    this makes them misaligned when laid over one another:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个`sf::RenderTexture`类时，我们定义一个大小。然后绘制到它的一切将相对于这个区域的左上角定位。如果我们的精灵大小不同，当我们开始绘制时，它们将不对齐。以下示例已经将它们的背景变暗，以便我们可以看到这一点。在第一个示例中，精灵已经被裁剪，我们可以看到这使它们在彼此上方叠放时不对齐：
- en: '![Breaking sprites into components](img/B04920_06_12.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![将精灵分解为组件](img/B04920_06_12.jpg)'
- en: 'In the second example, the sprites are of the same size and are both positioned
    relative to the sprite over which they will be drawn. As a result, they will line
    up nicely:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，精灵的大小相同，并且都相对于它们将被绘制在其上的精灵定位。因此，它们将很好地对齐：
- en: '![Breaking sprites into components](img/B04920_06_13.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![将精灵分解为组件](img/B04920_06_13.jpg)'
- en: We're going to create armor for each enemy, so for each enemy animation, we
    need to create a matching armor sprite. This has already been done to save time,
    and you'll notice that there's only gray versions of these sprites. To save yet
    more time, we'll change the colors using the sprite modifiers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个敌人创建盔甲，因此对于每个敌人动画，我们需要创建一个匹配的盔甲精灵。这已经完成了以节省时间，您会注意到这些精灵只有灰色版本。为了节省更多时间，我们将使用精灵修改器来改变颜色。
- en: 'Here''s an example of an armor overlay sprite on the skeleton walking sprite
    strip:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是骷髅行走精灵条上的盔甲叠加精灵的示例：
- en: '![Breaking sprites into components](img/B04920_06_14.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![将精灵分解为组件](img/B04920_06_14.jpg)'
- en: The draw setup
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制设置
- en: Before we write any code regarding generating armor, we need change the way
    the `Humanoid` class handles its textures. Since the textures that we'll create
    are unique to each instance of the class and will only be used once, there's no
    use filling the **Texture** manager with them. Instead, we'll create an array
    of our own textures and override the default draw behavior to use the new ones!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何关于生成盔甲的代码之前，我们需要改变`Humanoid`类处理其纹理的方式。由于我们将创建的纹理对于类的每个实例都是独一无二的，并且只会被使用一次，所以没有必要将**Texture**管理器填满它们。相反，我们将创建自己的纹理数组，并覆盖默认的绘制行为以使用新的纹理！
- en: 'We''ll start by defining an array of textures in `Humanoid.h`, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在`Humanoid.h`中定义纹理数组开始，如下所示：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, in the `Humanoid` constructor, we need to fill this array with the default
    enemy textures. This is because we're going to override the default draw behavior
    to use the array of modified sprites over the default ones. A modified sprite
    is only created when armor is generated. Therefore, we need to ensure that we
    have the default sprites to fall back to. We will fill up the array with default
    sprites and then override them if we generate armor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Humanoid`构造函数中，我们需要用默认的敌人纹理填充这个数组。这是因为我们将覆盖默认的绘制行为以使用修改后的精灵数组覆盖默认的精灵。只有在生成盔甲时才会创建修改后的精灵。因此，我们需要确保我们有默认的精灵作为后备。我们将用默认精灵填充数组，然后如果我们生成盔甲，就覆盖它们。
- en: 'Add the following code to `Humanoid::Humanoid`. Then, our prep work is done
    and we can get started:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Humanoid::Humanoid`中。然后，我们的准备工作就完成了，我们可以开始了：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Randomly selecting sprite components
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机选择精灵组件
- en: We have three possible pieces of armor that our enemies can have; head, torso,
    and legs, and we want our enemies to have a mix of these types. So, let's give
    each of them a 1 in 5 chance of been spawned on the enemy. This means that enemies
    with more gear are less likely to spawn, which is just what we want; a fully kitted
    out skeleton should be a rare spawn!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的敌人可以拥有三种可能的盔甲部件；头部、躯干和腿部，我们希望我们的敌人拥有这些类型的混合。因此，让我们给每个敌人一次生成这些部件的机会。这意味着拥有更多装备的敌人生成的可能性更小，这正是我们想要的；一个全副武装的骷髅应该是一个罕见的生成！
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget about the balance of game mechanics. When creating procedural systems,
    it's easy to focus on the tech and let the balance take a backseat. Always keep
    this in mind when designing your systems. You can visit [http://www.paranoidproductions.com/](http://www.paranoidproductions.com/),
    which contains lots of great information on this subject.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记游戏机制的平衡。在创建程序化系统时，很容易专注于技术，而忽视平衡。设计系统时一定要牢记这一点。您可以访问[http://www.paranoidproductions.com/](http://www.paranoidproductions.com/)，这里包含了很多关于这个主题的信息。
- en: Let's get started by creating a function for all this behavior to go in. The
    armor is designed to fit over both the goblin and the skeleton sprites. Therefore,
    we can place it in the `Humanoid` class and generate armor for both variants!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个函数，将所有这些行为放进去。护甲是设计用来覆盖哥布林和骷髅精灵的。因此，我们可以将它放在`Humanoid`类中，并为两种变体生成护甲！
- en: 'Let''s declare the `Humanoid::GenerateArmor` function, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明`Humanoid::GenerateArmor`函数，如下所示：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first thing that we need to do is create the `sf::RenderTexture` objects
    that we''ll draw to. We''re going to use two textures for each sprite: one for
    the armor and one for the final image. We''ll draw the armor first and then draw
    that over the default enemy sprites to create the final textures.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建我们将要绘制的`sf::RenderTexture`对象。我们将为每个精灵使用两个纹理：一个用于护甲，一个用于最终图像。我们将首先绘制护甲，然后将其绘制在默认敌人精灵上，以创建最终纹理。
- en: 'Let''s give the new function a body and set up the objects:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给新函数一个主体并设置对象：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now add the code to choose which pieces of armor our enemy will have.
    We said we''d give each item a 20 percent chance of spawning. Hence, we need to
    generate a number from 0 to 4 (inclusive). There''s a 20 percent chance that the
    result of this will be 0\. Therefore, we can use this to determine whether that
    item of armor should spawn:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加代码来选择敌人将拥有哪些护甲。我们说过每个物品都有20%的生成几率。因此，我们需要生成一个从0到4（包括4）的数字。这样一来，结果为0的概率就是20%。因此，我们可以使用这个来确定是否应该生成该护甲物品：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we randomly choose the pieces of armor, if any, that our enemy will
    have, we can turn our attention to creating different armor tiers by editing the
    sprites. There is a lot of code that is required to achieve this. So from this
    point onwards, we'll focus only on the helmet option.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经随机选择了敌人将拥有的护甲物品（如果有的话），我们可以将注意力转向通过编辑精灵来创建不同的护甲等级。这需要大量的代码来实现。因此，从这一点开始，我们将只关注头盔选项。
- en: Loading the default armor textures
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载默认护甲纹理
- en: 'To begin, we need to load the default armor textures. Each enemy has eight
    possible animation states, meaning we will need to load all the eight helmet counterparts.
    We''ll do this in a way that is similar to how we load the default sprites in
    the constructor, creating an array of textures and using the enumerator of animation
    states as the index, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要加载默认的护甲纹理。每个敌人有八种可能的动画状态，这意味着我们需要加载所有八种头盔对应的纹理。我们将以与在构造函数中加载默认精灵类似的方式来做，创建一个纹理数组，并使用动画状态的枚举作为索引，如下所示：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the default sprites loaded, we can now choose which armor tier they belong
    to, and therefore, what color we need to apply to them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 默认精灵加载完毕后，我们现在可以选择它们属于哪种护甲等级，因此，我们需要对它们应用什么颜色进行选择。
- en: Choosing the armor tier
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择护甲等级
- en: There will be three tiers of armor for each type, namely gold, silver, and bronze.
    So, we need to decide which tier to use. We could take a naive approach and generate
    a number from 0 and 2, but that's not ideal. Each tier would have the same chance
    of spawning, which is 33 percent.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型将有三种护甲等级，即黄金、白银和青铜。因此，我们需要决定使用哪种等级。我们可以采取一种天真的方法，从0到2生成一个数字，但这并不理想。每个等级的生成机会都是相同的，即33%。
- en: Let's be a bit cannier with how we select the armor tier, making silver rarer
    than bronze, and gold rarer still. To do this, we'll still use the `std::rand()`
    function, but we'll be smarter in how we use the result. First, we need to decide
    the possibilities of each spawning. Let's say that we want 50 percent of it to
    be bronze, 35 percent of it to be silver, and 15 percent of it to be gold.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在选择护甲等级时更加狡猾，使白银比青铜更加稀有，黄金更加稀有。为了做到这一点，我们仍然会使用`std::rand()`函数，但我们会更加聪明地使用结果。首先，我们需要决定每种生成的可能性。假设我们希望其中50%是青铜，35%是白银，15%是黄金。
- en: 'These percentages seem good and are nice to work with as they total 100\. To
    replicate their chances, we need to generate a number from 1 to 100, and we can
    use it to get the desired percentages:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些百分比看起来不错，很好处理，因为它们总和为100。为了复制它们的机会，我们需要生成一个从1到100的数字，并且我们可以用它来获得期望的百分比：
- en: There is a 50 percent chance that we will generate a number between 1 and 50
    as it represents half of the total possible range (50/100)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有50%的机会生成一个介于1到50之间的数字，因为它代表了总可能范围的一半（50/100）
- en: There is a 35 percent chance that we'll generate a number in the range of 51
    to 85, as this range includes 35 values out of the possible 100 (35/100)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有35%的机会生成一个在51到85范围内的数字，因为这个范围包括了100个可能值中的35个（35/100）
- en: Finally, there is a 15 percent chance that we'll generate a number in the range
    of 86 to 100, as this range includes 15 values out of the possible 100 (15/100)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有15%的机会生成一个在86到100范围内的数字，因为这个范围包括了100个可能值中的15个（15/100）
- en: 'Let''s add the following code to our function, continuing from the previous
    code to load the default textures:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下代码添加到我们的函数中，继续从上一段代码加载默认纹理：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We used `std::rand() % 100 + 1`, and not `std::rand() % 100`. While they both
    technically do the same thing, the first generates a number from 1 to 100, while
    the later generates a number from 0 to 99\. The first makes it simpler for us
    to work with.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`std::rand() % 100 + 1`，而不是`std::rand() % 100`。虽然它们在技术上做的是一样的事情，但第一个生成了一个从1到100的数字，而后一个生成了一个从0到99的数字。第一个使我们更容易处理。
- en: We create a simple `if` statement that defines each of the ranges that we identified
    earlier. However, by the time we come to the `if` statement of gold, there is
    no need as we've already defined the other ranges. Therefore, we now know that
    anything that's left falls in the range of 86 to 100\. We can therefore simply
    use an `else` statement, saving us an evaluation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的`if`语句，定义了我们之前确定的每个范围。然而，当我们来到金色的`if`语句时，就没有必要了，因为我们已经定义了其他范围。因此，我们现在知道剩下的任何东西都在86到100的范围内。因此，我们可以简单地使用一个`else`语句，节省了一个评估。
- en: At this stage we've randomly selected a helmet, loaded the default sprites,
    and chosen a tier.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经随机选择了一个头盔，加载了默认精灵，并选择了一个阶级。
- en: Rendering the armor textures
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染盔甲纹理
- en: The next step is to edit the armor textures and overly them on the default enemy
    textures. Currently, we only have a gray sprite for each armor type. We need to
    use the sprite modification skills that we learned earlier in the chapter to create
    the bronze and gold versions. We can keep the gray as silver!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编辑盔甲纹理并将其覆盖在默认敌人纹理上。目前，每种盔甲类型我们只有一个灰色精灵。我们需要使用本章前面学到的精灵修改技巧来创建青铜和金色版本。我们可以将灰色保留为银色！
- en: 'The pipeline required to do this is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作所需的流程如下：
- en: Load the default helmet texture
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载默认头盔纹理
- en: Edit the color using the `tierColor` variable that we set earlier
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们之前设置的`tierColor`变量编辑颜色
- en: Draw the modified armor texture in the `armorTextures` array
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`armorTextures`数组中绘制修改后的盔甲纹理
- en: 'We need to do this for every animation that the enemy has. So, we will encapsulate
    `armorTextures` array within a `for` loop, iterating over each value of the `ANIMATION_STATE`
    enumerator, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对敌人的每个动画都这样做。因此，我们将`armorTextures`数组封装在一个`for`循环中，迭代`ANIMATION_STATE`枚举的每个值，如下所示：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `armorTextures` array now contains all the helmet sprites, and their color
    has been set to a random tier value. We now need to do the exact same thing for
    the torso and legs, drawing the same `armorTextures` array again so that we can
    build up the armor texture. This is left as an exercise for you at the end of
    the chapter. For now, let's look at how to put this together to create the final
    texture.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`armorTextures`数组现在包含所有头盔精灵，并且它们的颜色已经设置为随机的阶级值。现在我们需要对躯干和腿做完全相同的事情，再次绘制相同的`armorTextures`数组，以便我们可以构建盔甲纹理。这留作本章末尾的练习。现在，让我们看看如何将这些组合在一起创建最终纹理。'
- en: Rendering the final textures
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染最终纹理
- en: Now that the armor textures are created, we will need to render them on top
    of the default enemy textures to create the final images. We created copies of
    all the default textures in the constructor, so all that we need to do is draw
    our newly created armor textures on top them and save that as the final texture.
    One thing to remember is that the `sf::Texture::copyToImage` function flips an
    image vertically. Hence, right before we save the final version, we need to flip
    it back.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在盔甲纹理已经创建，我们需要将它们渲染在默认敌人纹理的上方，以创建最终图像。我们在构造函数中创建了所有默认纹理的副本，所以我们只需要在上面绘制我们新创建的盔甲纹理，然后保存为最终纹理。需要记住的一件事是`sf::Texture::copyToImage`函数会垂直翻转图像。因此，在保存最终版本之前，我们需要将其翻转回来。
- en: 'Let''s add this final bit of code. This code needs to go after all the armor
    has been generated, so will be the final block of code in the `Humanoid::GenerateArmor`
    function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加这最后一部分代码。这段代码需要放在所有盔甲已生成的后面，因此将是`Humanoid::GenerateArmor`函数中的最后一块代码：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this function now complete, all that''s left is to make a call to it at
    the end of our constructor:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个函数已经完成，剩下的就是在我们的构造函数末尾调用它：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Overriding the default draw behavior
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖默认绘制行为
- en: The animation code for our objects lies in the base class `Object`. When the
    texture needs to be updated, it goes to the `m_textureIDs` variable and fetches
    the correct texture from the `TextureManager` class. Since we have created our
    own textures and stored them in the new `m_textures` array, we need to override
    this default behavior to provide our own textures.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对象的动画代码位于基类`Object`中。当纹理需要更新时，它会去`m_textureIDs`变量中获取正确的纹理，从`TextureManager`类中。由于我们已经创建了自己的纹理并将它们存储在新的`m_textures`数组中，我们需要覆盖这个默认行为以提供我们自己的纹理。
- en: 'To start with we need to override the update function by adding the following
    declaration to `Humanoid.h`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过在`Humanoid.h`中添加以下声明来覆盖更新函数：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We still need to call the parent''s implementation, as that''s where the animation
    logic lies. However, as soon as that''s done, we need to jump in and provide our
    own texture before it''s drawn. Luckily, that''s very easy to do:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要调用父类的实现，因为那里是动画逻辑所在。但是，一旦完成了这一点，我们需要在绘制之前提供我们自己的纹理。幸运的是，这很容易做到：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Debugging and testing
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试和测试
- en: Before we run the game, let's add a little bit of debug code to see our work
    in action. Previously, we covered how to save textures to image files. So, let's
    use that here to save all the procedural sprites that we will create.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行游戏之前，让我们添加一些调试代码来看看我们的工作。之前，我们介绍了如何将纹理保存为图像文件。所以，让我们在这里使用它来保存我们将创建的所有程序精灵。
- en: 'Let''s update the loop that creates the final textures using the following
    code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码更新创建最终纹理的循环：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'All that this code does is save the textures to the resource folder if a piece
    of armor is generated. If you run the game a few times, remember that there is
    only a 20 percent chance that each skeleton will call this code, and head to the
    `resources` folder, you will see the following sprites:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码所做的一切就是在生成一件盔甲时将纹理保存到资源文件夹中。如果你运行游戏几次，记住每个骷髅只有20%的几率调用这段代码，并前往`resources`文件夹，你会看到以下精灵：
- en: '![Debugging and testing](img/B04920_06_15.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![调试和测试](img/B04920_06_15.jpg)'
- en: These are the procedural sprites! In my case, it's a skeleton with a random
    piece of armor of a random tier that we didn't have to draw. We drew the constituent
    parts, did some programmatic editing, and put them together programmatically!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是程序生成的精灵！在我的例子中，它是一个骷髅，带有一个我们不必绘制的随机层级的随机一部分盔甲。我们绘制了组成部分，进行了一些程序编辑，并以编程方式将它们组合在一起！
- en: 'Well, after all that, it''s time to test the code. If all is well, when you
    run the game, you should see some skeletons and goblins with helmets! Remember
    that each enemy only has a 20 percent change of having a helmet. You may have
    to run the game a few times to see it if you get unlucky:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，经过这一切，是时候测试代码了。如果一切顺利，当你运行游戏时，你应该会看到一些带头盔的骷髅和哥布林！请记住，每个敌人只有20%的几率戴着头盔。如果你运气不好，可能需要运行几次游戏才能看到它：
- en: '![Debugging and testing](img/B04920_06_16.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![调试和测试](img/B04920_06_16.jpg)'
- en: Before moving forward, you can remove the debug code that we just added to save
    sprites. This was purely for debugging purposes. One of the exercises at the end
    of this chapter is to complete the code and add the same behavior for the torso
    and leg armor options, but feel free to take this further. Experiment!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可以删除我们刚刚添加的用于保存精灵的调试代码。这纯粹是为了调试目的。本章末尾的练习之一是完成代码，并为躯干和腿部盔甲选项添加相同的行为，但请随意进一步进行。实验！
- en: Editing the game tiles
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑游戏瓦片
- en: The final system that we're going to look at is going to lay the groundwork
    for something that is coming later in the book. We're going to create a system
    to make each floor of the dungeon a unique environment, implementing what we know
    about sprite modification on the game tiles.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的最终系统将为本书后面要介绍的内容奠定基础。我们将创建一个系统，使地牢的每一层都成为一个独特的环境，实现我们对游戏瓦片的精灵修改的了解。
- en: The goal of the game is to progress through as many floors as you can, getting
    the highest possible score. In [Chapter 9](ch09.html "Chapter 9. Procedural Dungeon
    Generation"), *Procedural Dungeon Generation*, we're going to look at how to generate
    dungeons procedurally, and after every five floors, we'll change the theme. Let's
    create the function that we will use later in the book to accomplish this.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是尽可能通过尽可能多的楼层，获得尽可能高的分数。在[第9章](ch09.html "第9章。程序生成地牢")中，*程序生成地牢*，我们将看看如何程序生成地牢，并且在每五层之后，我们将改变主题。让我们创建一个函数，以后在书中使用它来完成这个目标。
- en: The best way to solve this is to add a function to the `Level` object that sets
    the color of all the tile sprites. This will be a public function as we'll be
    calling it from the main game class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最佳方法是向`Level`对象添加一个函数，设置所有瓦片精灵的颜色。这将是一个公共函数，因为我们将从主游戏类中调用它。
- en: 'Let''s start by defining the `sf::color` function in the `Level` header, as
    follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`Level`头文件中定义`sf::color`函数开始，如下所示：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The definition for this function is very simple. It simply iterates over all
    the sprites in the grid, setting their color to the parameter that was passed:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的定义非常简单。它只是迭代网格中的所有精灵，将它们的颜色设置为传递的参数：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this in place, we're actually done. That's all there is to it! We'll use
    this function later in this chapter, but let's just test it while we're here.
    We initialize the `Level` object in `Game.cpp`, so once we've loaded the textures,
    we can call the `Level::SetColor` function and set the theme of the level.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们实际上已经完成了。就是这样！我们将在本章后面使用这个函数，但让我们在这里测试一下。我们在`Game.cpp`中初始化`Level`对象，所以一旦我们加载了纹理，我们就可以调用`Level::SetColor`函数，并设置关卡的主题。
- en: 'Let''s update the `Game::Initialize` function with the following test code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下测试代码更新`Game::Initialize`函数：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With this, we can see what the levels will look like once we implement the
    function properly later.. Let''s run the game and see what happens:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以看到一旦我们正确实现了功能，关卡会是什么样子。让我们运行游戏，看看会发生什么：
- en: '![Editing the game tiles](img/B04920_06_17.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![编辑游戏瓦片](img/B04920_06_17.jpg)'
- en: The `Level` tiles now have an ambient color applied to all the sprites that
    make up the environment, allowing us to create a unique look and feel for our
    levels. Like I previously mentioned, we'll use this system later when we generate
    random levels programmatically. For now, we can remove the debug code and sit
    tight knowing that the system is ready for use!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Level`瓦片现在都有一个应用于构成环境的所有精灵的环境颜色，这样我们就可以为我们的关卡创建独特的外观和感觉。就像我之前提到的，我们将在以后以编程方式生成随机关卡时使用这个系统。现在，我们可以删除调试代码，坐等系统准备好使用！'
- en: Exercises
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work through. They are not imperative to the rest of
    the book, but working through them will help you to assess your strengths and
    weaknesses in the material covered:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你测试本章内容的知识，这里有一些练习，你应该通过它们进行练习。它们对于本书的其余部分并不是必要的，但通过它们的练习，可以帮助你评估自己在所涵盖材料中的优势和劣势：
- en: Give the goblin enemy a slightly random color and scale every time one is spawned.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给哥布林敌人一个稍微随机的颜色和比例，每次生成一个。
- en: Finish the code to generate armor procedurally for the humanoid by completing
    the condition for the torso and leg armor.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过完成躯干和腿部盔甲的条件，完成为人形生物程序生成盔甲的代码。
- en: Try to generate armor in a more succinct manner. We're using two textures; maybe
    there's a way to use only one. See if you can improve the function.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试以更简洁的方式生成盔甲。我们使用了两种纹理；也许有一种方法只使用一种。看看你能否改进这个函数。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to generate game art procedurally. We took a
    naïve approach to start, simply using RNG with built-in sprite modifiers, and
    moved on to algorithmically generating our own images. Generating procedural art
    is a vast topic, and you could write a book on the subject. Hopefully, this chapter
    has introduced you to the topic nicely.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何程序生成游戏艺术。我们采取了一个天真的方法开始，简单地使用内置的精灵修改器和随机数生成器，然后算法地生成我们自己的图像。生成程序艺术是一个广阔的主题，你可以写一本关于这个主题的书。希望这一章对你介绍了这个主题。
- en: In the next chapter, we're going to look at art's cousin, audio. With our art
    now procedurally generated we'll use similar techniques to create variance in
    sounds. We'll also use SFML's audio functions to create specialized 3D sound and
    thus bring more depth to the levels.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下艺术的表兄弟音频。现在我们的艺术是通过程序生成的，我们将使用类似的技术来创造声音的变化。我们还将使用SFML的音频功能来创建专门的3D声音，从而为关卡带来更多的深度。
