- en: Networking and Interprocess Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和进程间通信
- en: 'Processes run individually and work independently in their respective address
    spaces. However, they sometimes need to communicate with each other to pass on
    information. For processes to cooperate, they need to be able to communicate with
    each other as well as synchronize their actions. Here are the types of communication
    that take place between processes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进程各自独立运行并在各自的地址空间中工作。然而，它们有时需要相互通信以传递信息。为了使进程能够协作，它们需要能够相互通信并同步它们的行为。以下是进程间发生的通信类型：
- en: '**Synchronous communication**: Such communication doesn''t allow the process
    to continue with any other work until the communication is over'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步通信**：这种通信不允许进程在通信完成前继续进行任何其他工作'
- en: '**Asynchronous communication**: In this communication, the process can continue
    doing other tasks, and so it supports multitasking and results in better efficiency'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步通信**：在这种通信中，进程可以继续执行其他任务，因此它支持多任务处理，并导致更高的效率'
- en: '**Remote Procedure Call** (**RPC**): This is a protocol that uses client service
    techniques for communication where the client cannot do anything, that is, it
    is suspended until it gets a response from the server'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程过程调用**（**RPC**）：这是一个使用客户端服务技术进行通信的协议，其中客户端无法执行任何操作，也就是说，它被挂起，直到从服务器收到响应'
- en: 'These communications can be unidirectional or bidirectional. To enable any
    form of communication between processes, the following popular **interprocess
    communication** (**IPC**) mechanisms are used: pipes, FIFOs (named pipes), sockets,
    message queues, and shared memory. Pipes and FIFO enable unidirectional communication,
    whereas sockets, message queues, and shared memory enable bidirectional communication.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通信可以是单向的或双向的。为了在进程之间启用任何形式的通信，以下常用的**进程间通信**（**IPC**）机制被使用：管道、FIFOs（命名管道）、套接字、消息队列和共享内存。管道和FIFOs允许单向通信，而套接字、消息队列和共享内存则允许双向通信。
- en: 'In this chapter, we will learn how to make the following recipes so that we
    can establish communication between processes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何制作以下食谱，以便我们可以在进程之间建立通信：
- en: Communicating between processes using pipes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道在进程间通信
- en: Communicating between processes using FIFO
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FIFO在进程间通信
- en: Communicating between the client and server using socket programming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用套接字编程在客户端和服务器之间通信
- en: Communicating between processes using a UDP socket
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UDP套接字在进程间通信
- en: Passing a message from one process to another using the message queue
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息队列从一个进程向另一个进程传递消息
- en: Communicating between processes using shared memory
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享内存在进程间通信
- en: Let's begin with the first recipe!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个食谱开始！
- en: Communicating between processes using pipes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道在进程间通信
- en: 'In this recipe, we will learn how to write data into a pipe from its writing
    end and then how to read that data from its reading end. This can happen in two
    ways:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何从其写入端将数据写入管道，然后如何从其读取端读取该数据。这可以通过两种方式发生：
- en: One process, both writing and reading from the pipe
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个进程，既从管道中写入又从中读取
- en: One process writing and another process reading from the pipe
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个进程写入，另一个进程从管道中读取
- en: Before we begin with the recipes, let's quickly review the functions, structures, and
    terms that are used in successful interprocess communication.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始介绍食谱之前，让我们快速回顾一下在成功的进程间通信中使用的函数、结构和术语。
- en: Creating and to connecting processes
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和连接进程
- en: The most commonly used functions and terms for communication between processes
    are `pipe`, `mkfifo`, `write`, `read`, `perror`, and `fork.`
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用于进程间通信的最常用函数和术语是`pipe`、`mkfifo`、`write`、`read`、`perror`和`fork`。
- en: pipe()
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pipe()
- en: A pipe is used for connecting two processes. The output from one process can
    be sent as an input to another process. The flow is unidirectional, that is, one
    process can write to the pipe and another process can read from the pipe. Writing
    and reading are done in an area of main memory, which is also known as a virtual
    file. Pipes have a **First in First out** (**FIFO**) or a queue structure, that
    is, what is written first will be read first.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 管道用于连接两个进程。一个进程的输出可以作为另一个进程的输入发送。流是单向的，也就是说，一个进程可以写入管道，另一个进程可以从中读取。写入和读取是在主内存的一个区域进行的，这也可以称为虚拟文件。管道具有**先进先出**（**FIFO**）或队列结构，即先写入的将被先读取。
- en: A process should not try to read from the pipe before something is written into
    it, otherwise it will suspend until something is written into the pipe.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进程不应该在向管道写入内容之前尝试从管道读取，否则它将挂起，直到向管道写入内容。
- en: 'Here is its syntax:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其语法：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `arr[0]` is the file descriptor for the read end of the pipe, and `arr[1]`
    is the file descriptor for the write end of the pipe.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`arr[0]` 是管道读取端的文件描述符，而 `arr[1]` 是管道写入端的文件描述符。
- en: The function returns `0` on success and `-1` on error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在成功时返回 `0`，在出错时返回 `-1`。
- en: mkfifo()
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mkfifo()
- en: 'This function creates a new FIFO special file. Here is its syntax:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建一个新的 FIFO 特殊文件。以下是其语法：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `filename` represents the filename, along with its complete path, and `permission` represents
    the permission bits of the new FIFO file. The default permissions are read and
    write permission for the owner, group, and others, that is, (0666).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`filename` 代表文件名及其完整路径，而 `permission` 代表新 FIFO 文件的权限位。默认权限是所有者、组和其他人的读写权限，即
    (0666)。
- en: The function returns `0` on successful completion; otherwise, it returns `-1`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在成功完成后返回 `0`；否则，返回 `-1`。
- en: write()
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: write()
- en: 'This function is used for writing into the specified file or pipe whose descriptor
    is supplied. Here is its syntax:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于将数据写入指定的文件或管道（其描述符在方法中提供）。以下是其语法：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It writes the *n* number of bytes into the file that's being pointed to by the
    file pointer, `fp`, from the buffer, `buf`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它将 *n* 个字节写入由文件指针 `fp` 指向的文件，来自缓冲区 `buf`。
- en: read()
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: read()
- en: 'This function reads from the specified file or pipe whose descriptor is supplied
    in the method. Here is its syntax:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从指定的文件或管道（其描述符在方法中提供）读取。以下是其语法：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It tries to read up to *n* number of bytes from a file that's being pointed
    to by a descriptor, `fp`. The bytes that are read are then assigned to the buffer, `buf`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它尝试从由描述符 `fp` 指向的文件读取最多 *n* 个字节。读取的字节随后分配给缓冲区 `buf`。
- en: perror()
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: perror()
- en: This displays an error message indicating the error that might have occurred
    while invoking a function or system call. The error message is displayed to `stderr`,
    that is, the standard error output stream. This is basically the console.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示一个错误消息，指示在调用函数或系统调用时可能发生的错误。错误消息显示在 `stderr`，即标准错误输出流。这基本上是控制台。
- en: 'Here is its syntax:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其语法：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The error message that is displayed is optionally preceded by the message that's
    represented by `str`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的错误消息可以由代表 `str` 的消息先行。
- en: fork()
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fork()
- en: This is used for creating a new process. The newly created process is called
    the child process, and it runs concurrently with the parent process. After executing
    the `fork` function, the execution of the program continues and the instruction
    following the `fork` function is executed by the parent as well as the child process.
    If the system call is successful, it will return a process ID of the child process
    and returns a `0` to the newly created child process. The function returns a negative
    value if the child process is not created.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于创建新进程。新创建的进程称为子进程，它与父进程并发运行。在执行 `fork` 函数后，程序的执行继续，`fork` 函数之后的指令由父进程和子进程同时执行。如果系统调用成功，它将返回子进程的进程
    ID，并将 `0` 返回给新创建的子进程。如果子进程未创建，函数返回负值。
- en: Now, let's start with the first recipe for enabling communication between processes
    using pipes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从第一个使用管道实现进程间通信的配方开始。
- en: One process, both writing and reading from the pipe
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个进程，既从管道写入又从管道读取
- en: Here, we will learn how writing and reading from the pipe are done by a single
    process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将学习单个进程如何通过管道进行读写操作。
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Define an array of size `2` and pass it as an argument to the `pipe` function.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个大小为 `2` 的数组，并将其作为参数传递给 `pipe` 函数。
- en: Invoke the `write` function and write your chosen string into the pipe through
    the `write` end of the array. Repeat the procedure for the second message.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `write` 函数并将选定的字符串写入管道的 `write` 端。为第二条消息重复此过程。
- en: Invoke the `read` function to read the first message from the pipe. Invoke the
    `read` function again to read the second message.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `read` 函数从管道读取第一条消息。再次调用 `read` 函数以读取第二条消息。
- en: 'The `readwritepipe.c` program for writing into the pipe and reading from it
    thereafter is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`readwritepipe.c` 程序用于写入管道并随后从管道读取，如下所示：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's go behind the scenes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We defined a macro, `max`, of size of `50`, a string, `str`, of size `max`,
    and an array, `pp`, with size `2` . We will invoke the `pipe` function to connect
    two processes and pass the `pp` array to it. The index location, `pp[0]`, will
    get the file descriptor for the reading end of the pipe and `pp[1]` will get the
    file descriptor for the write end of the pipe. The program will exit if the `pipe`
    function does not execute successfully.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个大小为 `50` 的宏 `max`，一个大小为 `max` 的字符串 `str`，以及一个大小为 `2` 的数组 `pp`。我们将调用 `pipe`
    函数连接两个进程并将 `pp` 数组传递给它。索引位置 `pp[0]` 将获取管道的读取端文件描述符，而 `pp[1]` 将获取管道的写入端文件描述符。如果
    `pipe` 函数没有成功执行，程序将退出。
- en: You will be prompted to enter the first message to be written into the pipe.
    The text that's entered by you will be assigned to the string variable, `str`.
    Invoke the `write` function and the string in `str` will be written into the pipe, `pp`.
    Repeat the procedure for the second message. The second text that's entered by
    you will also be written into the pipe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示输入将要写入管道的第一个消息。你输入的文本将被分配给字符串变量 `str`。调用 `write` 函数，`str` 中的字符串将被写入管道 `pp`。重复此过程以写入第二个消息。你输入的第二个文本也将被写入管道。
- en: Obviously, the second text will be written behind the first text in the pipe.
    Now, invoke the `read` function to read from the pipe. The text that was entered
    first in the pipe will be read and assigned to the string variable, `str`, and
    is consequently displayed on the screen. Again, invoke the `read` function and
    the second text message in the pipe will be read from its read end and assigned
    to the string variable, `str`, and then displayed on the screen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，第二个文本将在管道中第一个文本之后写入。现在，调用 `read` 函数从管道读取。管道中首先输入的文本将被读取并分配给字符串变量 `str`，然后显示在屏幕上。再次调用
    `read` 函数，管道中的第二个文本消息将从其读取端读取并分配给字符串变量 `str`，然后显示在屏幕上。
- en: 'Let''s use GCC to compile the `readwritepipe.c` program, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `readwritepipe.c` 程序，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you get no errors or warnings, this means that the `readwritepipe.c` program
    has been compiled into an executable file, `readwritepipe.exe`. Let''s run this
    executable file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着 `readwritepipe.c` 程序已被编译成可执行文件 `readwritepipe.exe`。让我们运行这个可执行文件：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding program, the main thread does the job of writing and reading
    from the pipe. But what if we want one process to write into the pipe and another
    process to read from the pipe?  Let's find out how we can make that happen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，主线程负责从管道写入和读取。但如果我们想一个进程向管道写入，另一个进程从管道读取怎么办？让我们看看如何实现这一点。
- en: One process writing into the pipe and another process reading from the pipe
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个进程向管道写入，另一个进程从管道读取
- en: In this recipe, we will use the fork system call to create a child process.
    Then, we will write into the pipe using the child process and read from the pipe
    through the parent process, thereby establishing communication between two processes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `fork` 系统调用创建一个子进程。然后，我们将使用子进程向管道写入，并通过父进程从管道读取，从而在两个进程之间建立通信。
- en: How to do it…
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Define an array of size `2`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个大小为 `2` 的数组。
- en: Invoke the `pipe` function to connect the two processes and pass the array we
    defined previously to it.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `pipe` 函数连接两个进程并将我们之前定义的数组传递给它。
- en: Invoke the `fork` function to create a new child process.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `fork` 函数创建一个新的子进程。
- en: Enter the message that is going to be written into the pipe. Invoke the `write`
    function using the newly created child process.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入将要写入管道的消息。使用新创建的子进程调用 `write` 函数。
- en: The parent process invokes the `read` function to read the text that's been
    written into the pipe.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父进程调用 `read` 函数读取已写入管道的文本。
- en: 'The `pipedemo.c` program for writing into the pipe through a child process
    and reading from the pipe through the parent process is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过子进程向管道写入并通过父进程从管道读取的 `pipedemo.c` 程序如下：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's go behind the scenes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Define a macro `max`, of size `50` and two string variables, `wstr` and `rstr`,
    of size `max`. The `wstr` string will be used for writing into the pipe and `rstr`
    will be used for reading from the pipe. Define an array, `pp`, of size `2`, which
    will be used for storing the file descriptors of the read and write ends of the
    pipe. Define a variable, `p`, of the `pid_t` data type, which will be used for
    storing a process ID.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个大小为 `50` 的宏 `max` 和两个大小为 `max` 的字符串变量 `wstr` 和 `rstr`。`wstr` 字符串将用于向管道写入，而
    `rstr` 将用于从管道读取。定义一个大小为 `2` 的数组 `pp`，它将用于存储管道的读写端文件描述符。定义一个 `pid_t` 数据类型的变量 `p`，它将用于存储进程
    ID。
- en: We will invoke the `pipe` function to connect the two processes and pass the
    `pp` array to it. The index location `pp[0]` will get the file descriptor for
    the reading end of the pipe, while `pp[1]` will get the file descriptor for the
    write end of the pipe. The program will exit if the `pipe` function does not execute
    successfully.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用 `pipe` 函数来连接两个进程，并将 `pp` 数组传递给它。`pp[0]` 索引位置将获取管道的读取端文件描述符，而 `pp[1]` 将获取管道的写入端文件描述符。如果
    `pipe` 函数没有成功执行，程序将退出。
- en: Then, we will invoke the `fork` function to create a new child process. You
    will be prompted to enter the message to be written into the pipe. The text you
    enter will be assigned to the string variable `wstr`. When we invoke the `write`
    function using the newly created child process, the string in the `wstr` variable
    will be written into the pipe, `pp`. Thereafter, the parent process will invoke
    the `read` function to read the text that's been written into the pipe. The text
    that's read from the pipe will be assigned to the string variable `rstr` and will
    consequently be displayed on the screen.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将调用 `fork` 函数来创建一个新的子进程。你将被提示输入要写入管道的消息。你输入的文本将被分配给字符串变量 `wstr`。当我们使用新创建的子进程调用
    `write` 函数时，`wstr` 变量中的字符串将被写入管道 `pp`。之后，父进程将调用 `read` 函数来读取写入管道的文本。从管道读取的文本将被分配给字符串变量
    `rstr`，并随后在屏幕上显示。
- en: 'Let''s use GCC to compile the `pipedemo.c` program, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `pipedemo.c` 程序，如下所示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you get no errors or warnings, this means that the `pipedemo.c` program
    has been compiled into an executable file, `pipedemo.exe`. Let''s run this executable
    file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着 `pipedemo.c` 程序已经被编译成一个可执行文件，名为 `pipedemo.exe`。让我们运行这个可执行文件：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Voila! We've successfully communicated between processes using pipes. Now, let's
    move on to the next recipe!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用管道在进程之间进行了通信。现在，让我们继续下一个菜谱！
- en: Communicating between processes using FIFO
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FIFO 在进程之间进行通信
- en: 'In this recipe, we will learn how two processes communicate using a named pipe,
    also known as FIFO. This recipe is divided into the following two parts:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习两个进程如何使用命名管道（也称为 FIFO）进行通信。这个菜谱分为以下两个部分：
- en: Demonstrating how data is written into a FIFO
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何将数据写入 FIFO
- en: Demonstrating how data is read from a FIFO
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何从 FIFO 读取数据
- en: The functions and terms we learned in the previous recipe will also be applicable
    here.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的菜谱中学到的函数和术语也适用于此处。
- en: Writing data into a FIFO
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 FIFO 写入数据
- en: As the name suggests, we will learn how data is written into a FIFO in this
    recipe.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，在这个菜谱中，我们将学习如何将数据写入 FIFO。
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Invoke the `mkfifo` function to create a new FIFO special file.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `mkfifo` 函数来创建一个新的 FIFO 特殊文件。
- en: Open the FIFO special file in write-only mode by invoking the `open` function.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `open` 函数以只写模式打开 FIFO 特殊文件。
- en: Enter the text to be written into the FIFO special file.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入要写入 FIFO 特殊文件的文本。
- en: Close the FIFO special file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 FIFO 特殊文件。
- en: 'The `writefifo.c` program for writing into a FIFO is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 用于向 FIFO 写入数据的 `writefifo.c` 程序如下：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's go behind the scenes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后。
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's assume we have defined a string called `str` of size `255`. We will invoke
    the `mkfifo` function to create a new FIFO special file. We will create the FIFO
    special file with the name `FIFOPipe` with read and write permissions for owner,
    group, and others.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经定义了一个大小为 `255` 的字符串 `str`。我们将调用 `mkfifo` 函数来创建一个新的 FIFO 特殊文件。我们将使用名为 `FIFOPipe`
    的名称创建 FIFO 特殊文件，并为所有者、组和其他用户设置读写权限。
- en: We will open this FIFO special file in write-only mode by invoking the `open`
    function. Then, we will assign the file descriptor of the opened FIFO special
    file to the `fw` variable. You will be prompted to enter the text that is going
    to be written into the file. The text you enter will be assigned to the `str`
    variable, which in turn will be written into the special FIFO file when you invoke
    the `write` function. Finally, close the FIFO special file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用`open`函数以只写模式打开这个FIFO特殊文件。然后，我们将打开的FIFO特殊文件的文件描述符分配给`fw`变量。你将被提示输入要写入文件的文本。你输入的文本将被分配给`str`变量，然后当调用`write`函数时，它将被写入特殊的FIFO文件。最后，关闭FIFO特殊文件。
- en: 'Let''s use GCC to compile the `writefifo.c` program, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`writefifo.c`程序，如下所示：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you get no errors or warnings, this means that the `writefifo.c` program
    has compiled into an executable file, `writefifo.exe`. Let''s run this executable
    file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`writefifo.c`程序已编译成可执行文件`writefifo.exe`。让我们运行这个可执行文件：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If your program does not prompts for the string that means it is waiting for
    the other end of the FIFO to open. That is, you need to run the next recipe, *Reading
    data from a FIFO,* on the second Terminal screen. Please press *Alt+F2* on Cygwin
    to open the next terminal screeen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序没有提示输入字符串，这意味着它正在等待FIFO的另一端打开。也就是说，你需要在第二个终端屏幕上运行下一个菜谱，*从FIFO读取数据*。请在Cygwin上按*Alt+F2*打开下一个终端屏幕。
- en: Now, let's check out the other part of this recipe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查这个菜谱的另一个部分。
- en: Reading data from a FIFO
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从FIFO读取数据
- en: In this recipe, we will see how we can read data from a FIFO.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何从FIFO读取数据。
- en: How to do it…
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Open the FIFO special file in read-only mode by invoking the `open` function.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`open`函数以只读模式打开FIFO特殊文件。
- en: Read the text from the FIFO special file using the `read` function.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`read`函数从FIFO特殊文件中读取文本。
- en: Close the FIFO special file.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭FIFO特殊文件。
- en: 'The `readfifo.c` program for reading from the named pipe (FIFO) is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从命名管道（FIFO）读取的`readfifo.c`程序如下：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's go behind the scenes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will start by defining a macro called `BUFFSIZE` of size `255` and a string
    called `str` of size `BUFFSIZE`, that is, 255 characters. We will open the FIFO
    special file named `FIFOPipe` in read-only mode by invoking the `open` function.
    The file descriptor of the opened FIFO special file will be assigned to the `fr` variable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个名为`BUFFSIZE`的宏，其大小为`255`，以及一个名为`str`的字符串，其大小也是`BUFFSIZE`，即255个字符。我们将通过调用`open`函数以只读模式打开名为`FIFOPipe`的FIFO特殊文件。打开的FIFO特殊文件的文件描述符将被分配给`fr`变量。
- en: Using the `read` function, the text from the FIFO special file will be read
    and assigned to the `str` string variable. The text that's read from the FIFO
    special file will then be displayed on the screen. Finally, the FIFO special file
    will be closed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`read`函数，从FIFO特殊文件中读取的文本将被分配到`str`字符串变量。从FIFO特殊文件中读取的文本将被显示在屏幕上。最后，关闭FIFO特殊文件。
- en: 'Now, press *Alt + F2* to open a second Terminal window. In the second Terminal
    window, let''s use GCC to compile the `readfifo.c` program, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按*Alt + F2*打开第二个终端窗口。在第二个终端窗口中，让我们使用GCC编译`readfifo.c`程序，如下所示：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you get no errors or warnings, this means that the `readfifo.c` program
    has compiled into an executable file, `readfifo.exe`. Let''s run this executable
    file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`readfifo.c`程序已编译成可执行文件`readfifo.exe`。让我们运行这个可执行文件：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The moment you run the `readfifo.exe` file, you will find, that on the previous
    Terminal screen where `writefifo.c` program was run will prompt you to enter a
    string. The moment you enter a string on that Terminal and press *Enter* key,
    you will get the output from the `readfifo.c` program.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`readfifo.exe`文件时，你会在之前运行`writefifo.c`程序的终端屏幕上发现，会提示你输入一个字符串。当你在这个终端上输入一个字符串并按*Enter*键时，你会得到`readfifo.c`程序的输出。
- en: Voila! We've successfully communicated between processes using a FIFO. Now,
    let's move on to the next recipe!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用FIFO在进程之间进行了通信。现在，让我们继续下一个菜谱！
- en: Communicating between the client and server using socket programming
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字编程在客户端和服务器之间进行通信
- en: 'In this recipe, we will learn how data from the server process is sent to the
    client process. This recipe is divided into the following parts:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习服务器进程的数据是如何发送到客户端进程的。这个菜谱分为以下几部分：
- en: Sending data to the client
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向客户端发送数据
- en: Reading data that's been sent from the server
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取从服务器发送的数据
- en: Before we begin with the recipes, let's quickly review the functions, structures, and
    terms that are used in successful client-server communication.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始介绍食谱之前，让我们快速回顾一下在成功的客户端-服务器通信中使用的函数、结构和术语。
- en: Client-server model
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器模型
- en: Different models are used for IPC, but the most popular one is the client-server
    model. In this model, whenever the client needs some information, it connects
    to another process called the server. But before establishing the connection,
    the client needs to know whether the server already exists, and it should know
    the address of the server.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IPC，使用不同的模型，但最流行的是客户端-服务器模型。在这个模型中，每当客户端需要某些信息时，它会连接到另一个称为服务器的进程。但在建立连接之前，客户端需要知道服务器是否已经存在，并且它应该知道服务器的地址。
- en: On the other hand, the server is meant to serve the needs of the client and
    does not need to know the address of the client prior to the connection. To establish
    a connection, a basic construct called a socket is required, and both the connecting
    processes must establish their own sockets. The client and the server need to
    follow certain procedures to establish their sockets.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，服务器旨在满足客户端的需求，在建立连接之前不需要知道客户端的地址。为了建立连接，需要一个基本构造，称为套接字，并且连接的进程必须各自建立自己的套接字。客户端和服务器需要遵循某些程序来建立它们的套接字。
- en: To establish a socket on the client side, a socket is created with the `socket`
    function system call. Thereafter, that socket is connected to the server's address
    using the `connect` function system call, followed by sending and receiving data
    by invoking the `read` function and `write` function system calls.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端建立套接字时，使用`socket`函数系统调用来创建一个套接字。之后，使用`connect`函数系统调用来将该套接字连接到服务器的地址，然后通过调用`read`函数和`write`函数系统调用来发送和接收数据。
- en: To establish a socket on the server side, again, a socket is created with the
    `socket` function system call and then the socket is bonded to an address using
    the `bind` function system call. Thereafter, the `listen` function system call
    is invoked to listen for the connections. Finally, the connection is accepted
    by invoking the `accept` function system call.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端建立套接字时，再次使用`socket`函数系统调用来创建一个套接字，然后使用`bind`函数系统调用来将该套接字绑定到一个地址。之后，调用`listen`函数系统调用来监听连接。最后，通过调用`accept`函数系统调用来接受连接。
- en: struct sockaddr_in structure
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`struct sockaddr_in`结构'
- en: 'This structure references the socket''s elements that are used for keeping
    addresses. The following are the built-in members of this structure:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构引用了用于保持地址的套接字元素。以下是该结构的内置成员：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we have the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '`sin_family`: Represents an address family. The valid options are `AF_INET`,
    `AF_UNIX`, `AF_NS`, and `AF_IMPLINK`. In most applications, the address family
    that''s used is `AF_INET`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_family`：表示一个地址族。有效的选项有`AF_INET`、`AF_UNIX`、`AF_NS`和`AF_IMPLINK`。在大多数应用程序中，使用的地址族是`AF_INET`。'
- en: '`sin_port`: Represents the 16-bit service port number.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_port`：表示16位服务端口号。'
- en: '`sin_addr`: Represents a 32-bit IP address.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_addr`：表示32位IP地址。'
- en: '`sin_zero`: This is not used and is usually set to `NULL`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin_zero`：这个成员不使用，通常设置为`NULL`。'
- en: '`struct in_addr` comprise one member, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct in_addr`包含一个成员，如下所示：'
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `s_addr` is used to represent the address in network byte order.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`s_addr`用于表示网络字节序中的地址。
- en: socket()
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`socket()`'
- en: 'This function creates an endpoint for communication. To establish communication,
    every process needs a socket at the end of the communication line. Also, the two
    communicating processes must have the same socket type and both should be in the
    same domain. Here is the syntax for creating a socket:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建了一个通信端点。为了建立通信，每个进程需要在通信线的末端有一个套接字。此外，两个通信进程必须具有相同的套接字类型，并且它们都应该在同一个域中。以下是创建套接字的语法：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `domain` represents the communication domain in which a socket is to be
    created. Basically, the `address family` or `protocol family` is specified, which
    will be used in the communication.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`domain`表示要创建套接字的通信域。基本上，指定了`地址族`或`协议族`，这将用于通信。
- en: 'A few of the popular `address family` are listed as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的`地址族`如下所示：
- en: '`AF_LOCAL`: This is used for local communication.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_LOCAL`：这用于本地通信。'
- en: '`AF_INET`: This is used for IPv4 internet protocols.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_INET`：这用于IPv4互联网协议。'
- en: '`AF_INET6`: This is used for IPv6 internet protocols.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_INET6`：这用于IPv6互联网协议。'
- en: '`AF_IPX`: This is used for protocols that use standard **IPX** (short for **Internetwork
    Packet Exchange**) socket addressing.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_IPX`: 这用于使用标准**IPX**（即**Internetwork Packet Exchange**）套接字地址的协议。'
- en: '`AF_PACKET`: This is used for packet interface.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AF_PACKET`: 这用于数据包接口。'
- en: '`type`: Represents the type of socket to be created. The following are the
    popular socket types:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 表示要创建的套接字类型。以下是一些流行的套接字类型：'
- en: '`SOCK_STREAM`: Stream sockets communicate as a continuous stream of characters
    using a **Transmission Control Protocol (TCP)**. TCP is a reliable stream-oriented
    protocol. So, the `SOCK_STREAM` type provides reliable, bidirectional, and connection-based
    byte streams.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_STREAM`: 流套接字使用**传输控制协议 (TCP**)作为字符的连续流进行通信。TCP是一种可靠的面向流的协议。因此，`SOCK_STREAM`类型提供了可靠、双向和基于连接的字节流。'
- en: '`SOCK_DGRAM`: Datagram sockets read the entire messages at once using a **User
    Datagram Protocol (UDP)**. UDP is an unreliable, connectionless, and message-oriented
    protocol. These messages are of a fixed maximum length.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_DGRAM`: 数据报套接字使用**用户数据报协议 (UDP**)一次性读取整个消息。UDP是一种不可靠的、无连接的、面向消息的协议。这些消息具有固定的最大长度。'
- en: '`SOCK_SEQPACKET`: Provides reliable, bidirectional, and connection-based transmission
    paths for datagrams.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_SEQPACKET`: 为数据报提供可靠、双向和基于连接的传输路径。'
- en: '`protocol`: Represents the protocol to be used with the socket. A `0` value
    is specified so that you can use the default protocol that''s suitable for the
    requested socket type.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protocol`: 表示与套接字一起使用的协议。指定一个`0`值，以便您可以使用适合请求的套接字类型的默认协议。'
- en: You can replace the `AF_` prefix in the preceding list with `PF_` for `protocol family`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将前面列表中的`AF_`前缀替换为`PF_`以表示`协议族`。
- en: On successful execution, the `socket` function returns a file descriptor that
    can be used to manage sockets.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行后，`socket`函数返回一个文件描述符，可以用来管理套接字。
- en: memset()
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: memset()
- en: 'This is used to fill a block of memory with the specified value. Here is its
    syntax:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于使用指定的值填充内存块。以下是它的语法：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `ptr` points at the memory address to be filled, `v` is the value to be
    filled in the memory block, and `n` is the number of bytes to be filled, starting
    at the location of the pointer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ptr`指向要填充的内存地址，`v`是要填充到内存块中的值，而`n`是要填充的字节数，从指针的位置开始。
- en: htons()
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: htons()
- en: This is used to convert the unsigned short integer from host to network byte
    order.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于将主机无符号短整数转换为网络字节序。
- en: bind()
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bind()
- en: 'A socket that is created with the `socket` function remains in the assigned
    address family. To enable the socket to receive connections, an address needs
    to be assigned to it. The `bind` function assigns the address to the specified
    socket. Here is its syntax:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`socket`函数创建的套接字保持在分配的地址族中。为了使套接字能够接收连接，需要为其分配一个地址。`bind`函数将地址分配给指定的套接字。以下是它的语法：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `fdsock` represents the file descriptor of the socket, `structaddr` represents
    the `sockaddr` structure that contains the address to be assigned to the socket,
    and `lenaddr` represents the size of the address structure that's pointed to by `structaddr`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fdsock`代表套接字的文件描述符，`structaddr`代表包含要分配给套接字的地址的`sockaddr`结构，而`lenaddr`代表由`structaddr`指向的地址结构的大小。
- en: listen()
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: listen()
- en: 'It listens for connections on a socket in order to accept incoming connection
    requests. Here is its syntax:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它在套接字上监听连接，以便接受传入的连接请求。以下是它的语法：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `sockfd` represents the file descriptor of the socket, and `lenque` represents
    the maximum length of the queue of pending connections for the given socket. An
    error will be generated if the queue is full.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sockfd`代表套接字的文件描述符，而`lenque`代表给定套接字的挂起连接队列的最大长度。如果队列已满，将生成错误。
- en: If the function is successful it returns zero, otherwise it returns `-1`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数成功，它返回零，否则返回`-1`。
- en: accept()
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: accept()
- en: 'It accepts a new connection on the listening socket, that is, the first connection
    from the queue of pending connections is picked up. Actually, a new socket is
    created with the same socket type protocol and address family as the specified
    socket, and a new file descriptor is allocated for that socket. Here is its syntax:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受监听套接字上的新连接，即从挂起的连接队列中选取的第一个连接。实际上，会创建一个新的套接字，其套接字类型协议和地址族与指定的套接字相同，并为该套接字分配一个新的文件描述符。以下是它的语法：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we need to address the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要解决以下问题：
- en: '`socket`: Represents the file descriptor of the socket waiting for the new
    connection. This is the socket that is created when the `socket` function is bound to
    an address with the `bind` function, and has invoked the `listen` function successfully.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`：表示等待新连接的套接字的文件描述符。这是当 `socket` 函数通过 `bind` 函数绑定到地址并成功调用 `listen` 函数时创建的套接字。'
- en: '`address`: The address of the connecting socket is returned through this parameter.
    It is a pointer to a `sockaddr` structure, through which the address of the connecting
    socket is returned.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`：通过此参数返回连接套接字的地址。它是一个指向 `sockaddr` 结构的指针，通过该结构返回连接套接字的地址。'
- en: '`len`: Represents the length of the supplied `sockaddr` structure. When returned,
    this parameter contains the length of the address returned in bytes.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len`：表示提供的 `sockaddr` 结构的长度。返回时，此参数包含以字节为单位返回的地址长度。'
- en: send()
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: send()
- en: 'This is used for sending the specified message to another socket. The socket
    needs to be in a connected state before you can invoke this function. Here is
    its syntax:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于将指定的消息发送到另一个套接字。在调用此函数之前，套接字需要处于连接状态。以下是其语法：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, `fdsock` represents the file descriptor of the socket through which a
    message is to be sent, `buf` points to the buffer that contains the message to
    be sent, `length` represents the length of the message to be sent in bytes, and `flags` specifies
    the type of message to be sent. Usually, its value is kept at `0`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fdsock` 代表要发送消息的套接字的文件描述符，`buf` 指向包含要发送消息的缓冲区，`length` 代表以字节为单位要发送的消息长度，而
    `flags` 指定要发送的消息类型。通常，其值保持为 `0`。
- en: connect()
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: connect()
- en: 'This initiates a connection on a socket. Here is its syntax:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这在套接字上初始化一个连接。以下是其语法：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `fdsock` represents the file descriptor of the socket onto which the connection
    is desired, `addr` represents the structure that contains the address of the socket,
    and `len` represents the size of the structure `addr` that contains the address.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fdsock` 代表要建立连接的套接字的文件描述符，`addr` 代表包含套接字地址的结构，而 `len` 代表包含地址的结构 `addr`
    的大小。
- en: recv()
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: recv()
- en: 'This is used to receive a message from the connected socket. The socket may
    be in connection mode or connectionless mode. Here is its syntax:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于从已连接的套接字接收消息。套接字可以是连接模式或无连接模式。以下是其语法：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, `fdsock` represents the file descriptor of the socket from which the message
    has to be fetched, `buf` represents the buffer where the message that is received
    is stored, `len` specifies the length in bytes of the buffer that's pointed to
    by the `buf` argument, and `flags` specifies the type of message being received. Usually, its
    value is kept at `0`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fdsock` 代表必须从中获取消息的套接字的文件描述符，`buf` 代表存储接收到的消息的缓冲区，`len` 指定由 `buf` 参数指向的缓冲区的长度，而
    `flags` 指定正在接收的消息类型。通常，其值保持为 `0`。
- en: We can now begin with the first part of this recipe – how to send data to the
    client.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始本食谱的第一部分——如何向客户端发送数据。
- en: Sending data to the client
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向客户端发送数据
- en: In this part of the recipe, we will learn how a server sends desired data to
    the client.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分的食谱中，我们将学习服务器如何将所需数据发送到客户端。
- en: How to do it…
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Define a variable of type `sockaddr_in`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `sockaddr_in` 类型的变量。
- en: Invoke the `socket` function to create a socket. The port number that's specified
    for the socket is `2000`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `socket` 函数创建套接字。为套接字指定的端口号是 `2000`。
- en: Call the `bind` function to assign an IP address to it.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `bind` 函数为其分配一个 IP 地址。
- en: Invoke the `listen` function.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `listen` 函数。
- en: Invoke the `accept` function.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `accept` 函数。
- en: Invoke the `send` function to send the message that was entered by the user
    to the socket.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `send` 函数将用户输入的消息发送到套接字。
- en: The socket at the client end will receive the message.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端端的套接字将接收消息。
- en: 'The server program, `serverprog.c`, for sending a message to the client is
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息到客户端的服务器程序 `serverprog.c` 如下所示：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's go behind the scenes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后发生了什么。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We will start by defining a string of size `255`, and a `server_Address` variable
    of type `sockaddr_in`. This structure references the socket's elements. Then,
    we will invoke the `socket` function to create a socket by the name of `serverSocket`.
    A socket is an endpoint for communication. The address family that's supplied
    for the socket is `AF_INET`, and the socket type selected is the stream socket
    type, since the communication that we want is of a continuous stream of characters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个大小为 `255` 的字符串和一个类型为 `sockaddr_in` 的 `server_Address` 变量。这个结构引用了套接字的元素。然后，我们将调用
    `socket` 函数以 `serverSocket` 的名称创建套接字。套接字是通信的端点。为套接字提供的地址族是 `AF_INET`，选择的套接字类型是流套接字类型，因为我们想要的通信是字符的连续流。
- en: The address family that's specified for the socket is `AF_INET`, and is used
    for IPv4 internet protocols. The port number that's specified for the socket is
    `2000`. Using the `htons` function, the short integer `2000` is converted into
    the network byte order before being applied as a port number. The fourth parameter,
    `sin_zero`, of the `server_Address` structure is set to `NULL` by invoking the
    `memset` function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为套接字指定的地址族是 `AF_INET`，用于 IPv4 互联网协议。为套接字指定的端口号是 `2000`。使用 `htons` 函数，将短整数 `2000`
    转换为网络字节序，然后作为端口号应用。`server_Address` 结构的第四个参数 `sin_zero` 通过调用 `memset` 函数设置为 `NULL`。
- en: To enable the created `serverSocket` to receive connections, call the `bind`
    function to assign an address to it. Using the `sin_addr` member of the `server_Address`
    structure, a 32-bit IP address will be applied to the socket. Because we are working
    on the local machine, the localhost address `127.0.0.1` will be assigned to the
    socket. Now, the socket can receive the connections. We will invoke the `listen`
    function to enable the `serverSocket` to accept incoming connection requests.
    The maximum pending connections that the socket can have is 5.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使创建的 `serverSocket` 能够接收连接，请调用 `bind` 函数为其分配一个地址。使用 `server_Address` 结构的 `sin_addr`
    成员，将一个 32 位 IP 地址应用到套接字上。因为我们是在本地机器上工作，所以将本地主机地址 `127.0.0.1` 分配给套接字。现在，套接字可以接收连接。我们将调用
    `listen` 函数使 `serverSocket` 能够接受传入的连接请求。套接字可以有的最大挂起连接数是 5。
- en: You will be prompted to enter the text that is to be sent to the client. The
    text you enter will be assigned to the `str` string variable. By invoking the
    `accept` function, we will enable the `serverSocket` to accept a new connection.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示输入要发送给客户端的文本。你输入的文本将被分配给 `str` 字符串变量。通过调用 `accept` 函数，我们将使 `serverSocket`
    能够接受新的连接。
- en: The address of the connection socket will be returned through the structure
    of type `sockaddr_in`. The socket that is returned and that is ready to accept
    a connection is named `toSend`. We will invoke the `send` function to send the
    message that's entered by you. The socket at the client end will receive the message.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 连接套接字的地址将通过类型为 `sockaddr_in` 的结构返回。返回并准备好接受连接的套接字被命名为 `toSend`。我们将调用 `send`
    函数发送你输入的消息。客户端的套接字将接收这条消息。
- en: 'Let''s use GCC to compile the `serverprog.c` program, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `serverprog.c` 程序，如下所示：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you get no errors or warnings, this means that the `serverprog.c` program
    has compiled into an executable file, `serverprog.exe`. Let''s run this executable
    file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到错误或警告，这意味着 `serverprog.c` 程序已编译成可执行文件，名为 `serverprog.exe`。让我们运行这个可执行文件：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, let's look at the other part of this recipe.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个说明的另一个部分。
- en: Reading data that's been sent from the server
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取从服务器发送的数据
- en: In this part of the recipe, we will learn how data that's been sent from the
    server is received and displayed on the screen.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分的说明中，我们将学习从服务器发送的数据是如何接收并在屏幕上显示的。
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Define a variable of type `sockaddr_i`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类型为 `sockaddr_i` 的变量。
- en: Invoke the `socket` function to create a socket. The port number that's specified
    for the socket is `2000`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `socket` 函数创建套接字。为套接字指定的端口号是 `2000`。
- en: Invoke the `connect` function to initiate a connection to the socket.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `connect` 函数初始化与套接字的连接。
- en: Because we are working on the local machine, the localhost address `127.0.0.1`
    is assigned to the socket.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们是在本地机器上工作，所以将本地主机地址 `127.0.0.1` 分配给套接字。
- en: Invoke the `recv` function to receive the message from the connected socket.
    The message that's read from the socket is then displayed on the screen.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `recv` 函数从已连接的套接字接收消息。从套接字读取的消息随后将在屏幕上显示。
- en: 'The client program, `clientprog.c`, for reading a message that''s sent from
    the server is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序 `clientprog.c` 用于读取从服务器发送的消息如下：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's go behind the scenes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们幕后看看。
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: So, we have defined a string of size `255` and a variable called `client_Address`
    of type `sockaddr_in`. We will invoke the `socket` function to create a socket
    by the name of `clientSocket`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个大小为 `255` 的字符串和一个名为 `client_Address` 的 `sockaddr_in` 类型的变量。我们将调用 `socket`
    函数创建一个名为 `clientSocket` 的套接字。
- en: The address family that's supplied for the socket is `AF_INET` and is used for
    IPv4 internet protocols, and the socket type that's selected is stream socket
    type. The port number that's specified for the socket is `2000`. By using the `htons`
    function, the short integer `2000` is converted into the network byte order before
    being applied as a port number.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为套接字提供的地址族是 `AF_INET`，用于 IPv4 互联网协议，所选的套接字类型是流式套接字类型。指定的套接字端口号是 `2000`。通过使用
    `htons` 函数，将短整数 `2000` 转换为网络字节序，然后作为端口号应用。
- en: We will set the fourth parameter, `sin_zero`, of the `client_Address` structure
    to `NULL` by invoking the `memset` function. We will initiate the connection to
    the `clientSocket` by invoking the connect function. By using the `sin_addr` member
    of the `client_Address` structure, a 32-bit IP address is applied to the socket.
    Because we are working on the local machine,  the localhost address `127.0.0.1`
    is assigned to the socket. Finally, we will invoke the `recv` function to receive
    the message from the connected `clientSocket`. The message that's read from the
    socket will be assigned to the `str` string variable, which will then be displayed
    on the screen.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用 `memset` 函数将 `client_Address` 结构的第四个参数 `sin_zero` 设置为 `NULL`。我们将通过调用
    `connect` 函数初始化 `clientSocket` 的连接。通过使用 `client_Address` 结构的 `sin_addr` 成员，将一个
    32 位 IP 地址应用到套接字上。因为我们是在本地机器上工作，所以将本地主机地址 `127.0.0.1` 分配给套接字。最后，我们将调用 `recv` 函数从已连接的
    `clientSocket` 接收消息。从套接字读取的消息将被分配给 `str` 字符串变量，然后显示在屏幕上。
- en: 'Now, press *Alt + F2* to open a second Terminal window. Here, let''s use GCC
    to compile the `clientprog.c` program, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按 *Alt + F2* 打开第二个终端窗口。在这里，我们将使用 GCC 编译 `clientprog.c` 程序，如下所示：
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you get no errors or warnings, this means that the `clientprog.c` program
    has compiled into an executable file, `clientprog.exe`. Let''s run this executable
    file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误或警告，这意味着 `clientprog.c` 程序已编译成可执行文件，名为 `clientprog.exe`。让我们运行这个可执行文件：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Voila! We've successfully communicated between the client and server using socket
    programming. Now, let's move on to the next recipe!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用套接字编程在客户端和服务器之间进行了通信。现在，让我们继续下一个菜谱！
- en: Communicating between processes using a UDP socket
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UDP 套接字进行进程间通信
- en: 'In this recipe, we will learn how two-way communication is implemented between
    a client and a server using a UDP socket. This recipe is divided into the following
    parts:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何使用 UDP 套接字在客户端和服务器之间实现双向通信。本菜谱分为以下几部分：
- en: Awaiting a message from the client and sending a reply using a UDP socket
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待客户端的消息并使用 UDP 套接字发送回复
- en: Sending a message to the server and receiving the reply from the server using
    the UDP socket
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UDP 套接字向服务器发送消息并从服务器接收回复
- en: Before we begin with these recipes, let's quickly review the functions, structures, and
    terms that are used in successful interprocess communication using a UDP socket.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始这些菜谱之前，让我们快速回顾一下在成功使用 UDP 套接字进行进程间通信时使用的函数、结构和术语。
- en: Using a UDP socket for server-client communication
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UDP 套接字进行服务器-客户端通信
- en: In the case of communication with UDP, the client does not establish a connection
    with the server but simply sends a datagram. The server does not have to accept
    a connection; it simply waits for datagrams to be sent from the client. Every
    datagram contains the address of the sender, enabling the server to identify the
    client on the basis of where the datagram is sent from.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 UDP 进行通信的情况下，客户端不需要与服务器建立连接，而是简单地发送一个数据报。服务器不需要接受连接；它只需等待客户端发送数据报。每个数据报都包含发送者的地址，使服务器能够根据数据报是从哪里发送的来识别客户端。
- en: For communication, the UDP server first creates a UDP socket and binds it to
    the server address. Then, the server waits until the datagram packet arrives from
    the client. Once it has arrived, the server processes the datagram packet and
    sends a reply to the client. This procedure keeps on repeating.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通信，UDP服务器首先创建一个UDP套接字并将其绑定到服务器地址。然后，服务器等待来自客户端的数据报文到达。一旦到达，服务器处理数据报文并向客户端发送回复。这个过程会不断重复。
- en: On the other hand, the UDP client, for communication, creates a UDP socket,
    sends a message to the server, and waits for the server's response. The client
    will keep repeating the procedure if they want to send more messages to the server,
    otherwise the socket descriptor will close.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，UDP客户端为了通信，创建一个UDP套接字，向服务器发送消息，并等待服务器的响应。如果客户端想要向服务器发送更多消息，则会不断重复此过程，否则套接字描述符将关闭。
- en: bzero()
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`bzero()`'
- en: 'This places *n* zero-valued bytes in the specified area. Here it its syntax:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在指定的区域放置*n*个零值字节。其语法如下：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, `r` is the area that's pointed to by `r` and `n` is the n number of zero
    values bytes that are placed in the area that was pointed to by `r`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`r`是指向`r`的区域，`n`是要放置在由`r`指向的区域中的零值字节的数量。
- en: INADDR_ANY
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`INADDR_ANY`'
- en: This is an IP address that is used when we don't want to bind a socket to any
    specific IP. Basically, while implementing communication, we need to bind our
    socket to an IP address. When we don't know the IP address of our machine, we
    can use the special IP address `INADDR_ANY`. It allows our server to receive packets
    that have been targeted by any of the interfaces.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在不想将套接字绑定到任何特定IP时使用的IP地址。基本上，在实现通信时，我们需要将我们的套接字绑定到IP地址。当我们不知道我们机器的IP地址时，我们可以使用特殊的IP地址`INADDR_ANY`。它允许我们的服务器接收被任何接口针对的数据包。
- en: sendto()
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sendto()`'
- en: 'This is used to send a message on the specified socket. The message can be
    sent in connection mode as well as in connectionless mode. In the case of connectionless mode,
    the message is sent to the specified address. Here it its syntax:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于在指定的套接字上发送消息。消息可以在连接模式以及无连接模式下发送。在无连接模式下，消息发送到指定的地址。其语法如下：
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we need to address the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要处理以下内容：
- en: '`fdsock`: Specifies the file descriptor of the socket.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fdsock`：指定套接字的文件描述符。'
- en: '`buff`: Points to a buffer that contains the message to be sent.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buff`：指向包含要发送消息的缓冲区。'
- en: '`len`: Specifies the length of the message in bytes.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len`：指定消息的字节数。'
- en: '`flags`: Specifies the type of the message that is being transmitted. Usually, its
    value is kept as 0.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：指定正在传输的消息类型。通常，其值保持为0。'
- en: '`recv_addr`: Points to the `sockaddr` structure that contains the receiver''s
    address. The length and format of the address depends on the address family that''s
    been assigned to the socket.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recv_addr`：指向包含接收者地址的`sockaddr`结构。地址的长度和格式取决于分配给套接字的地址族。'
- en: '`recv_len`: Specifies the length of the `sockaddr` structure that''s pointed
    to by the `recv_addr` argument.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recv_len`：指定由`recv_addr`参数指向的`sockaddr`结构的长度。'
- en: On successful execution, the function returns the number of bytes sent, otherwise
    it returns `-1`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行后，函数返回发送的字节数，否则返回`-1`。
- en: recvfrom()
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`recvfrom()`'
- en: 'This is used to receive a message from a connection-mode or connectionless-mode
    socket. Here it its syntax:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于从连接模式或无连接模式的套接字接收消息。其语法如下：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we need to address the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要处理以下内容：
- en: '`fdsock`: Represents the file descriptor of the socket.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fdsock`：表示套接字的文件描述符。'
- en: '`buffer`: Represents the buffer where the message is stored.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`：表示存储消息的缓冲区。'
- en: '`length`: Represents the number of bytes of the buffer that are pointed to
    by the `buffer` parameter.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：表示由`buffer`参数指向的缓冲区中的字节数。'
- en: '`flags`: Represents the type of message that''s received.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：表示接收到的消息类型。'
- en: '`address`: Represents the `sockaddr` structure in which the sending address
    is stored. The length and format of the address depend on the address family of
    the socket.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`：表示存储发送地址的`sockaddr`结构。地址的长度和格式取决于套接字的地址族。'
- en: '`address_len`: Represents the length of the `sockaddr` structure that''s pointed
    to by the address parameter.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address_len`：表示由地址参数指向的`sockaddr`结构的长度。'
- en: The function returns the length of the message that's written to the buffer,
    which is pointed to by the buffer argument.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回写入缓冲区的消息长度，该缓冲区由缓冲区参数指向。
- en: 'Now, we can begin with the first part of this recipe: preparing a server to
    wait for and reply to a message from the client using a UDP socket.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始这个配方的第一部分：使用UDP套接字准备服务器等待并回复客户端的消息。
- en: Await a message from the client and sending a reply using a UDP socket
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UDP套接字等待客户端消息并发送回复
- en: In this part of the recipe, we will learn how a server waits for the message
    from the client and how, on receiving a message from the client, it replies to
    the client.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分的配方中，我们将学习服务器如何等待客户端的消息，以及当收到客户端的消息时，它如何回复客户端。
- en: How to do it…
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Define two variables of type `sockaddr_in`. Invoke the `bzero` function to initialize
    the structure.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个类型为`sockaddr_in`的变量。调用`bzero`函数初始化结构体。
- en: Invoke the `socket` function to create a socket. The address family that's supplied
    for the socket is `AF_INET`, and the socket type that's selected is datagram type.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`socket`函数创建套接字。为套接字提供的地址族是`AF_INET`，选择的套接字类型是数据报类型。
- en: Initialize the members of the `sockaddr_in` structure to configure the socket.
    The port number that's specified for the socket is `2000`. Use `INADDR_ANY`, a special
    IP address, to assign an IP address to the socket.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`sockaddr_in`结构体的成员以配置套接字。为套接字指定的端口号是`2000`。使用特殊IP地址`INADDR_ANY`为套接字分配IP地址。
- en: Call the `bind` function to assign the address to it.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`bind`函数将地址分配给它。
- en: Call the `recvfrom` function to receive the message from the UDP socket, that
    is, from the client machine. A null character, `\0`, is added to the message that's
    read from the client machine and is displayed on the screen. Enter the reply that
    is to be sent to the client.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`recvfrom`函数从UDP套接字接收消息，即从客户端机器接收。在从客户端机器读取的消息中添加一个空字符`\0`，并在屏幕上显示。输入要发送给客户端的回复。
- en: Invoke the `sendto` function to send the reply to the client.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`sendto`函数将回复发送给客户端。
- en: 'The server program, `udps.c`, for waiting for a message from the client and
    sending a reply to it using a UDP socket is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 等待客户端消息并发送回复的UDP套接字服务器程序`udps.c`如下所示：
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's go behind the scenes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看背后的情况。
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by defining two strings by the names of `msgReceived` and `msgforclient`,
    both of which are of size `255`. These two strings will be used to receive the
    message from and send a message to the client, respectively. Then, we will define
    two variables, `server_Address` and `client_Address`, of type `sockaddr_in`. These
    structures will referenc the socket's elements and store the server's and client's
    addresses, respectively. We will invoke the `bzero` function to initialize the
    `server_Address` structure, that is, zeros will be filled in for all of the members
    of the `server_Address` structure.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义两个名为`msgReceived`和`msgforclient`的字符串，它们的大小都是`255`。这两个字符串将用于接收来自客户端的消息和向客户端发送消息。然后，我们将定义两个类型为`sockaddr_in`的变量，`server_Address`和`client_Address`。这些结构将引用套接字元素并分别存储服务器和客户端的地址。我们将调用`bzero`函数初始化`server_Address`结构体，即`server_Address`结构体的所有成员都将填充零。
- en: The server, as expected, waits for the datagram from the client. So, the following
    text message is displayed on the screen: `Waiting for the message from the client`.
    We invoke the `socket` function to create a socket by the name of `UDPSocket`.
    The address family that's supplied for the socket is `AF_INET`, and the socket
    type that's selected is datagram. The members of the `server_Address` structure
    are initialized to configure the socket.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器如预期的那样等待来自客户端的数据报。因此，屏幕上显示以下文本消息：“等待来自客户端的消息”。我们通过调用名为`UDPSocket`的`socket`函数创建套接字。为套接字提供的地址族是`AF_INET`，选择的套接字类型是数据报。`server_Address`结构体的成员被初始化以配置套接字。
- en: Using the `sin_family ` member, the address family that's specified for the
    socket is `AF_INET`, which is used for IPv4 internet protocols. The port number
    that's specified for the socket is `2000`. Using the `htons` function, the short
    integer `2000` is converted into the network byte order before being applied as
    a port number. Then, we use a special IP address, `INADDR_ANY`, to assign an IP
    address to the socket. Using the `htonl` function, the `INADDR_ANY` will be converted
    into the network byte order before being applied as the address to the socket.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sin_family`成员，指定给套接字的地址族是`AF_INET`，它用于IPv4互联网协议。指定给套接字的端口号是`2000`。使用`htons`函数，将短整数`2000`转换为网络字节序，然后作为端口号应用。然后，我们使用一个特殊的IP地址`INADDR_ANY`来为套接字分配IP地址。使用`htonl`函数，将`INADDR_ANY`转换为网络字节序，然后作为套接字的地址应用。
- en: To enable the created socket, `UDPSocket`, to receive connections, we will call
    the `bind` function to assign the address to it. We will call the `recvfrom` function
    to receive the message from the UDP socket, that is, from the client machine.
    The message that's read from the client machine is assigned to the `msgReceived`
    string, which is supplied in the `recvfrom` function. A null character, `\0`,
    is added to the `msgReceived` string and is displayed on the screen. Thereafter,
    you will be prompted to enter the reply to be sent to the client. The reply that's
    entered is assigned to `msgforclient`. By invoking the `sendto` function, the
    reply is sent to the client. After sending the message, the following message
    is displayed to the screen: `Reply to the client sent`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使创建的套接字`UDPSocket`能够接收连接，我们将调用`bind`函数将地址分配给它。我们将调用`recvfrom`函数从UDP套接字接收消息，即从客户端机器接收。从客户端机器读取的消息被分配给`msgReceived`字符串，该字符串在`recvfrom`函数中提供。在`msgReceived`字符串中添加一个空字符`\0`，并在屏幕上显示。之后，您将被提示输入要发送给客户端的回复。输入的回复被分配给`msgforclient`。通过调用`sendto`函数，将回复发送给客户端。发送消息后，屏幕上显示以下消息：`Reply
    to the client sent`。
- en: Now, let's look at the other part of this recipe.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看本食谱的另一个部分。
- en: Sending a message to the server and receiving the reply from the server using
    the UDP socket
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UDP套接字向服务器发送消息并从服务器接收回复
- en: As the name suggests, in this recipe we will show you how the client sends a
    message to the server and then receives a reply from the server using the UDP
    socket.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所暗示的，在本食谱中，我们将向您展示客户端如何通过UDP套接字向服务器发送消息，然后从服务器接收回复。
- en: How to do it…
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Execute the first three steps from the previous part of this recipe. Assign
    the localhost IP address, `127.0.0.1`, as the address to the socket.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行本食谱前一部分的前三个步骤。将本地主机IP地址`127.0.0.1`分配给套接字地址。
- en: Enter the message to be sent to the server. Invoke the `sendto` function to
    send the message to the server.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入要发送给服务器的消息。调用`sendto`函数将消息发送到服务器。
- en: Invoke the `recvfrom` function to get the message from the server. The message
    that's received from the server is then displayed on the screen.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`recvfrom`函数从服务器获取消息。从服务器接收到的消息随后在屏幕上显示。
- en: Close the descriptor of the socket.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭套接字的描述符。
- en: 'The client program, `udpc.c`, to send a message to the server and to receive
    the reply using a UDP socket is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序`udpc.c`用于通过UDP套接字向服务器发送消息并接收回复，如下所示：
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, let's go behind the scenes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first part of this recipe, we have already defined two strings by the
    names of `msgReceived` and `msgforclient`, both of which are of size `255`. We
    have also defined two variables, `server_Address` and `client_Address`, of type
    `sockaddr_in`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的第一部分中，我们已经通过`msgReceived`和`msgforclient`这两个名称定义了两个字符串，它们的大小都是`255`。我们还定义了两个变量`server_Address`和`client_Address`，它们的类型为`sockaddr_in`。
- en: Now, you will be prompted to enter a message that is to be sent to the server.
    The message you enter will be assigned to the `msgforserver` string. Then, we
    will invoke the `bzero` function to initialize the `client_Address` structure,
    that is, zeros will be filled in for all the members of the `client_Address` structure.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将被提示输入要发送给服务器的消息。您输入的消息将被分配给`msgforserver`字符串。然后，我们将调用`bzero`函数初始化`client_Address`结构，即`client_Address`结构的所有成员都将填充零。
- en: Next, we will initialize the members of the `client_Address` structure to configure
    the socket. Using the `sin_family ` member, the address family that's specified
    for the socket is `AF_INET`, which is used for IPv4 internet protocols. The port
    number that's specified for the socket is `2000`. By using the `htons` function,
    the short integer, `2000`, is converted into the network byte order before being
    applied as a port number. Then, we will assign the localhost IP address, `127.0.0.1`,
    as the address to the socket. We will invoke the `inet_addr` function on the localhost
    address to convert the string containing the address in standard IPv4 dotted decimal
    notation into an integer value (suitable to be used as an internet address) before
    is it applied to the `sin_addr` member of the `client_Address` structure.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将初始化`client_Address`结构的成员以配置套接字。使用`sin_family `成员，为套接字指定的地址族是`AF_INET`，用于IPv4互联网协议。为套接字指定的端口号是`2000`。通过使用`htons`函数，将短整数`2000`转换为网络字节顺序，然后将其作为端口号应用。然后，我们将本地主机IP地址`127.0.0.1`分配给套接字。我们将对本地主机地址调用`inet_addr`函数，将包含地址的标准IPv4点分十进制表示法字符串转换为整数值（适合用作互联网地址），然后再将其应用于`client_Address`结构的`sin_addr`成员。
- en: We will invoke the `socket` function to create a socket by the name of `UDPSocket`.
    The address family that's supplied for the socket is `AF_INET`, and the socket
    type that's selected is datagram.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`socket`函数以`UDPSocket`为名称创建一个套接字。为套接字提供的地址族是`AF_INET`，选择的套接字类型是数据报。
- en: Next, we will invoke the `sendto` function to send the message that's been assigned
    to the `msgforserver` string to the server. Similarly, we will invoke the `recvfrom`
    function to get the message from the server. The message that's received from
    the server is assigned to the `msgReceived` string, which is then displayed on
    the screen. Finally, the descriptor of the socket is closed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用`sendto`函数将分配给`msgforserver`字符串的消息发送到服务器。同样，我们将调用`recvfrom`函数从服务器获取消息。从服务器接收到的消息分配给`msgReceived`字符串，然后显示在屏幕上。最后，关闭套接字描述符。
- en: 'Let''s use GCC to compile the `udps.c` program, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC来编译`udps.c`程序，如下所示：
- en: '[PRE38]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you get no errors or warnings, this means that the `udps.c` program has
    compiled into an executable file, `udps.exe`. Let''s run this executable file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误或警告，这意味着`udps.c`程序已编译成可执行文件，`udps.exe`。让我们运行这个可执行文件：
- en: '[PRE39]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, press *Alt + F2* to open a second Terminal window. Here, let''s use GCC
    again to compile the `udpc.c` program, as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按*Alt + F2* 打开第二个终端窗口。在这里，让我们再次使用GCC来编译`udpc.c`程序，如下所示：
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you get no errors or warnings, this means that the `udpc.c` program has
    compiled into an executable file, `udpc.exe`. Let''s run this executable file:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误或警告，这意味着`udpc.c`程序已编译成可执行文件，`udpc.exe`。让我们运行这个可执行文件：
- en: '[PRE41]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output on the server will give us the following output:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上的输出将给出以下输出：
- en: '[PRE42]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once the reply is sent from the server, on the client window, you will get
    the following output:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器发送回复，在客户端窗口，您将得到以下输出：
- en: '[PRE43]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To run the recipes that demonstrate IPC using shared memory and message queue,
    we need to run Cygserver. If you are running these programs on Linux, then you
    can skip this section. Let's see how Cygserver is run.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行演示使用共享内存和消息队列进行IPC的食谱，我们需要运行Cygserver。如果您在Linux上运行这些程序，则可以跳过本节。让我们看看Cygserver是如何运行的。
- en: Running Cygserver
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Cygserver
- en: 'Before executing the command to run the Cygwin server, we need to configure
    Cygserver and install it as a service. To do so, you need to run the `cygserver.conf`
    script on the Terminal. The following is the output you get by running the script:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行运行Cygwin服务器命令之前，我们需要配置Cygserver并将其安装为服务。为此，您需要在终端上运行`cygserver.conf`脚本。以下是运行脚本后的输出：
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, Cygserver will have been configured and installed as a service. The next
    step is to run the server. To run Cygserver, you need to use the following command:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Cygserver已经配置并作为服务安装。下一步是运行服务器。要运行Cygserver，您需要使用以下命令：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that Cygserver is running, we can make a recipe to demonstrate IPC using
    shared memory and message queues.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Cygserver正在运行，我们可以制作一个食谱来演示使用共享内存和消息队列进行IPC。
- en: Passing a message from one process to another using the message queue
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用消息队列从一个进程向另一个进程传递消息
- en: 'In this recipe, we will learn how communication between two processes is established
    using the message queue. This recipe is divided into the following parts:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用消息队列在两个进程之间建立通信。这个食谱分为以下几部分：
- en: Writing a message into the message queue
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息写入消息队列
- en: Reading a message from the message queue
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从消息队列中读取消息
- en: Before we begin with these recipes, let's quickly review the functions, structures, and
    terms that are used in successful interprocess communication using shared memory
    and message queues.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始这些食谱之前，让我们快速回顾一下在成功使用共享内存和消息队列进行进程间通信时使用的函数、结构和术语。
- en: Functions used in IPC using shared memory and message queues
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用共享内存和消息队列进行进程间通信中使用的函数
- en: The most commonly used functions and terms for IPC using shared memory and message
    queues are `ftok`, `shmget`, `shmat`, `shmdt`, `shmctl`, `msgget`, `msgrcv`, and
    `msgsnd`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用共享内存和消息队列进行进程间通信中最常用的函数和术语是 `ftok`、`shmget`、`shmat`、`shmdt`、`shmctl`、`msgget`、`msgrcv`
    和 `msgsnd`。
- en: ftok()
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ftok()
- en: 'This generates an IPC key on the basis of the supplied filename and ID. The
    filename can be provided along with its complete path. The filename must refer
    to an existing file. Here is the syntax:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这基于提供的文件名和ID生成一个IPC键。可以提供文件及其完整路径。文件必须引用一个现有文件。以下是它的语法：
- en: '[PRE46]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `ftok` function will generate the same key value if the same filename (with same path)
    and the same ID is supplied. Upon successful completion, `ftok` will return a
    key, otherwise it will return `-1`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供相同的文件名（具有相同的路径）和相同的ID，则 `ftok` 函数将生成相同的关键值。成功完成后，`ftok` 将返回一个键，否则返回 `-1`。
- en: shmget()
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shmget()
- en: 'This allocates a shared memory segment and returns the shared memory identifier
    that''s associated with the key. Here is its syntax:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这分配了一个共享内存段，并返回与键关联的共享内存标识符。以下是它的语法：
- en: '[PRE47]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we need to address the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要解决以下问题：
- en: '`key`: This is (usually) the value that is returned by invoking the `ftok`
    function. You can also set the value of the key as `IPC_PRIVATE` if you don''t
    want the shared memory to be accessed by other processes.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`: 这通常是调用 `ftok` 函数返回的值。如果您不想其他进程访问共享内存，也可以将键的值设置为 `IPC_PRIVATE`。'
- en: '`size`: Represents the size of the desired shared memory segment.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`: 表示所需共享内存段的大小。'
- en: '`shmflg`: This can be any of the following constants:'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shmflg`: 这可以是以下任何常量：'
- en: '`IPC_CREAT`: This creates a new segment if no shared memory identifier exists
    for the specified key. If this flag is not used, the function returns the shared
    memory segment associated with the key.'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_CREAT`: 如果指定的键不存在共享内存标识符，则此操作将创建一个新的段。如果未使用此标志，则函数返回与键关联的共享内存段。'
- en: '`IPC_EXCL`: This makes the `shmget` function fail if the segment already exists
    with the specified key.'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_EXCL`: 如果指定的键已经存在段，则使 `shmget` 函数失败。'
- en: On successful execution, the function returns the shared memory identifier in
    the form of a non-negative integer, otherwise it returns `-1`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行成功，该函数以非负整数的格式返回共享内存标识符，否则返回 `-1`。
- en: shmat()
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shmat()
- en: 'This is used to attach a shared memory segment to the given address space.
    That is, the shared memory identifier that''s received by invoking the `shmgt` function
    needs to be associated with the address space of a process. Here is its syntax:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于将共享内存段附加到给定的地址空间。也就是说，通过调用 `shmgt` 函数接收到的共享内存标识符需要与进程的地址空间相关联。以下是它的语法：
- en: '[PRE48]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we need to address the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要解决以下问题：
- en: '`shidtfr`: Represents the memory identifier of the shared memory segment.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shidtfr`: 表示共享内存段的内存标识符。'
- en: '`addr`: Represents the address space where the segment needs to be attached.
    If `shmaddr` is a null pointer, the segment is attached at the first available
    address or selected by the system.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addr`: 表示需要附加段的地址空间。如果 `shmaddr` 是空指针，则段将附加到第一个可用的地址或由系统选择。'
- en: '`flag`: This is attached as a read-only memory if the flag is `SHM_RDONLY`;
    otherwise, it is readable and writable.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flag`: 如果标志为 `SHM_RDONLY`，则将其附加为只读内存；否则，它是可读可写的。'
- en: If successfully executed, the function attaches the shared memory segment and
    returns the segment's start address, otherwise it returns `-1`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功执行，该函数将附加共享内存段并返回段的起始地址，否则返回 `-1`。
- en: shmdt()
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shmdt()
- en: 'This detaches the shared memory segment. Here is its syntax:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这将共享内存段分离。以下是它的语法：
- en: '[PRE49]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, `addr` represents the address at which the shared memory segment is located.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`addr` 表示共享内存段所在的地址。
- en: shmctl()
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`shmctl()`'
- en: 'This is used for performing certain control operations on the specified shared
    memory segment. Here is its syntax:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于在指定的共享内存段上执行某些控制操作。以下是它的语法：
- en: '[PRE50]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, we have to address the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须处理以下问题：
- en: '`shidtr`: Represents the identifier of the shared memory segment.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shidtr`：表示共享内存段的标识符。'
- en: '`cmd`: This can have any of the following constants:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`：可以具有以下常量之一：'
- en: '`IPC_STAT`: This copies the content of the `shmid_ds` data structure associated
    with the shared memory segment represented by `shidtr` into the structure that''s
    pointed to by `buf`'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_STAT`：这会将与由`shidtr`表示的共享内存段关联的`shmid_ds`数据结构的内容复制到由`buf`指向的结构中。'
- en: '`IPC_SET`: This writes the content of the structure that''s pointed to by `buf` into
    the `shmid_ds` data structure, which is associated with the memory segment that''s
    represented by `shidtr`'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_SET`：这会将由`buf`指向的结构的内容写入与由`shidtr`表示的内存段关联的`shmid_ds`数据结构。'
- en: '`IPC_RMID`: This removes the shared memory identifier that''s specified by `shidtr` from
    the system and destroys the shared memory segment and `shmid_ds` data structure
    associated with it'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_RMID`：这将从系统中删除由`shidtr`指定的共享内存标识符，并销毁与其相关的共享内存段和`shmid_ds`数据结构。'
- en: '`buf`: This is a pointer to a `shmid_ds` structure.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf`：这是指向`shmid_ds`结构的指针。'
- en: If successfully executed, the function returns `0`, otherwise it returns `-1`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功执行，函数返回`0`，否则返回`-1`。
- en: msgget()
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`msgget()`'
- en: 'This is used for creating a new message queue, and for accessing an existing
    queue that is related to the specified key. If this is executed successfully,
    the function returns the identifier of the message queue:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于创建新的消息队列，以及访问与指定键相关联的现有队列。如果执行成功，则函数返回消息队列的标识符：
- en: '[PRE51]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we have to address the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须处理以下问题：
- en: '`key`: This is a unique key value that is retrieved by invoking the `ftok`
    function.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`：这是一个由调用`ftok`函数检索的唯一键值。'
- en: '`flag`: This can be any of the following constants:'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flag`：可以是以下常量中的任何一个：'
- en: '`IPC_CREAT`: Creates the message queue if it doesn''t already exist and returns
    the message queue identifier for the newly created message queue. If the message
    queue already exists with the supplied key value, it returns its identifier.'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_CREAT`：如果消息队列不存在，则创建它并返回新创建的消息队列的标识符。如果消息队列已存在且提供了相应的键值，则返回其标识符。'
- en: '`IPC_EXCL`: If both `IPC_CREAT` and `IPC_EXCL` are specified and the message
    queue does not exist, then it is created. However, if it already exists, then
    the function will fail.'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_EXCL`：如果同时指定了`IPC_CREAT`和`IPC_EXCL`，并且消息队列不存在，则创建它。然而，如果它已经存在，则函数将失败。'
- en: msgrcv()
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`msgrcv()`'
- en: 'This is used for reading a message from a specified message queue whose identifier
    is supplied. Here is its syntax:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于从指定的消息队列中读取消息，该队列的标识符由用户提供。以下是它的语法：
- en: '[PRE52]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, we have to address the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须处理以下问题：
- en: '`msqid`: Represents the message queue identifier of the queue from which the
    message needs to be read.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msqid`：表示需要从其中读取消息的队列的消息队列标识符。'
- en: '`msgstruc`: This is the user-defined structure into which the read message
    is placed. The user-defined structure must contain two members. One is usually
    named `mtype`, which must be of type long int that specifies the type of the message,
    and the second is usually called `mesg`, which should be of `char` type to store
    the message.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msgstruc`：这是一个用户定义的结构，用于放置读取的消息。用户定义的结构必须包含两个成员。一个是通常命名为`mtype`的成员，它必须是长整型，用于指定消息的类型，另一个通常称为`mesg`，它应该是`char`类型，用于存储消息。'
- en: '`msgsize`: Represents the size of text to be read from the message queue in
    terms of bytes. If the message that is read is larger than `msgsize`, then it
    will be truncated to `msgsize` bytes.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msgsize`：表示从消息队列中读取的文本大小，以字节为单位。如果读取的消息大于`msgsize`，则它将被截断为`msgsize`字节。'
- en: '`typemsg`: Specifies which message on the queue needs to be received:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typemsg`：指定需要接收队列上的哪个消息：'
- en: If `typemsg` is `0`, the first message on the queue is received
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`typemsg`为`0`，则接收队列上的第一个消息。
- en: If `typemsg` is greater than `0`, the first message whose `mtype` field is equal
    to `typemsg` is received
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`typemsg`大于`0`，则接收第一个`mtype`字段等于`typemsg`的消息。
- en: If `typemsg` is less than `0`, a message whose `mtype` field is less than or
    equal to `typemsg` is received
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`typemsg`小于`0`，则接收`mtype`字段小于或等于`typemsg`的消息。
- en: '`flag`: Determines the action to be taken if the desired message is not found
    in the queue. It keeps its value of `0` if you don''t want to specify the `flag`.
    The `flag` can have any of the following values:'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flag`: 决定了在队列中找不到所需消息时要采取的操作。如果你不想指定`flag`，则保持其值为`0`。`flag`可以具有以下任何值：'
- en: '`IPC_NOWAIT`: This makes the `msgrcv` function fail if there is no desired
    message in the queue, that is, it will not make the caller wait for the appropriate
    message on the queue. If `flag` is not set to `IPC_NOWAIT, it` will make the caller
    wait for an appropriate message on the queue instead of failing the function.'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPC_NOWAIT`: 如果队列中没有所需的消息，则使`msgrcv`函数失败，即它不会使调用者等待队列中的适当消息。如果`flag`未设置为`IPC_NOWAIT`，它将使调用者等待队列中的适当消息而不是使函数失败。'
- en: '`MSG_NOERROR`: This allows you to receive text that is larger than the size
    that''s specified in the `msgsize` argument. It simply truncates the text and
    receives it. If this `flag` is not set, on receiving the larger text, the function
    will not receive it and will fail the function.'
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSG_NOERROR`: 这允许你接收比在`msgsize`参数中指定的尺寸更大的文本。它简单地截断文本并接收它。如果此`flag`未设置，则在接收较大文本时，函数将不会接收它并使函数失败。'
- en: If the function is executed successfully, the function returns the number of
    bytes that were actually placed into the text field of the structure that is pointed
    to by `msgstruc`. On failure, the function returns a value of `-1`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数执行成功，则函数返回实际放置在由`msgstruc`指向的结构体的文本字段中的字节数。在失败的情况下，函数返回`-1`。
- en: msgsnd()
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`msgsnd()`'
- en: 'This is used for sending or delivering a message to the queue. Here is its
    syntax:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于向队列发送或投递消息。以下是它的语法：
- en: '[PRE53]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, we have to address the following:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须解决以下问题：
- en: '`msqid`: Represents the queue identifier of the message that we want to send.
    The queue identifier is usually retrieved by invoking the `msgget` function.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msqid`: 表示我们想要发送的消息的队列标识符。队列标识符通常通过调用`msgget`函数来获取。'
- en: '`msgstruc`: This is a pointer to the user-defined structure. It is the `mesg` member
    that contains the message that we want to send to the queue.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msgstruc`: 这是一个指向用户定义的结构体的指针。它是包含我们想要发送到队列的消息的`mesg`成员。'
- en: '`msgsize`: Represents the size of the message in bytes.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msgsize`: 表示消息的字节数。'
- en: '`flag`: Determines the action to be taken on the message. If the `flag` value
    is set to `IPC_NOWAIT` and if the message queue is full, the message will not
    be written to the queue, and the control is returned to the calling process. But
    if `flag` is not set and the message queue is full, then the calling process will
    suspend until a space becomes available in the queue. Usually, the value of `flag`
    is set to `0`.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flag`: 决定了对消息采取的操作。如果`flag`值设置为`IPC_NOWAIT`，并且消息队列已满，则消息不会被写入队列，控制权将返回给调用进程。但如果`flag`未设置且消息队列已满，则调用进程将挂起，直到队列中有空间可用。通常，`flag`的值设置为`0`。'
- en: If this is executed successfully, the function returns `0`, otherwise it returns
    `-1`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行成功，则函数返回`0`，否则返回`-1`。
- en: 'We will now begin with the first part of this recipe: writing a message into
    the queue.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始本配方的第一部分：将消息写入队列。
- en: Writing a message into the message queue
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将消息写入消息队列
- en: In this part of the recipe, we will learn how a server writes a desired message
    into the message queue.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分的配方中，我们将学习服务器如何将所需的消息写入消息队列。
- en: How to do it…
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Generate an IPC key by invoking the `ftok` function. A filename and ID are supplied
    while creating the IPC key.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`ftok`函数生成一个IPC键。在创建IPC键时提供文件名和ID。
- en: Invoke the `msgget` function to create a new message queue. The message queue
    is associated with the IPC key that was created in step 1.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`msgget`函数创建一个新的消息队列。消息队列与步骤1中创建的IPC键相关联。
- en: Define a structure with two members, `mtype` and `mesg`. Set the value of the `mtype` member
    to 1.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个成员的结构，`mtype`和`mesg`。将`mtype`成员的值设置为1。
- en: Enter the message that's going to be added to the message queue. The string
    that's entered is assigned to the `mesg` member of the structure that we defined
    in step 3.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入将要添加到消息队列的消息。输入的字符串被分配给我们在步骤3中定义的结构体的`mesg`成员。
- en: Invoke the `msgsnd` function to send the entered message into the message queue.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`msgsnd`函数将输入的消息发送到消息队列。
- en: 'The `messageqsend.c` program for writing the message to the message queue is
    as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息写入消息队列的`messageqsend.c`程序如下：
- en: '[PRE54]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Let's go behind the scenes.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后。
- en: How it works...
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will start by generating an IPC key by invoking the `ftok` function. The
    filename and ID are supplied while creating the IPC key are `messagefile` and
    `a`, respectively. The generated key is assigned to the key variable. Thereafter,
    we will invoke the `msgget` function to create a new message queue. The message
    queue is associated with the IPC key we just created using the `ftok` function.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过调用`ftok`函数来生成一个IPC密钥。在创建IPC密钥时提供的文件名和ID分别是`messagefile`和`a`。生成的密钥被分配给密钥变量。之后，我们将调用`msgget`函数来创建一个新的消息队列。该消息队列与使用`ftok`函数创建的IPC密钥相关联。
- en: Next, we will define a structure by the name of `msgstruc` with two members,
    `mtype` and `mesg`. The `mtype` member helps in determining the sequence number
    of the message that is going to be sent or received from the message queue. The
    `mesg` member contains the message that is going to be read or written into the
    message queue. We will define a variable called `msgbuf` of the `msgstruc` structure
    type. The value of the `mtype` member is set to `1`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个名为`msgstruc`的结构，包含两个成员，`mtype`和`mesg`。`mtype`成员有助于确定从消息队列发送或接收的消息的序列号。`mesg`成员包含要读取或写入消息队列的消息。我们将定义一个名为`msgbuf`的变量，其类型为`msgstruc`结构。`mtype`成员的值被设置为`1`。
- en: You will be prompted to enter the message that is going to be added to the message
    queue. The string you enter is assigned to the `mesg` member of the `msgbuf` structure.
    The `msgsnd` function is invoked to send the message you entered into the message
    queue. Once the message is written into the message queue, a text message is displayed
    on the screen as confirmation.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示输入要添加到消息队列的消息。你输入的字符串被分配给`msgbuf`结构的`mesg`成员。调用`msgsnd`函数将你输入的消息发送到消息队列。一旦消息被写入消息队列，屏幕上就会显示一条文本消息作为确认。
- en: Now, let's move on to the other part of this recipe.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续本配方的另一部分。
- en: Reading a message from the message queue
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从消息队列中读取消息
- en: In this part of the recipe, we will learn how the message that was written into
    the message queue is read and displayed on the screen.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分的配方中，我们将学习如何读取写入消息队列的消息并将其显示在屏幕上。
- en: How to do it…
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Invoke the `ftok` function to generate an IPC key. The filename and ID are supplied
    while creating the IPC key. These must be the same as what were applied while
    generating the key for writing the message in the message queue.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`ftok`函数来生成一个IPC密钥。在创建IPC密钥时提供的文件名和ID。这些必须与在消息队列中写入消息时生成密钥时使用的相同。
- en: Invoke the `msgget` function to access the message queue that is associated
    with the IPC key. The message queue that's associated with this key already contains
    a message that we wrote through the previous program.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`msgget`函数访问与IPC密钥相关联的消息队列。与该密钥相关联的消息队列已经包含了我们通过前面的程序写入的消息。
- en: Define a structure with two members, `mtype` and `mesg`.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个成员的结构，`mtype`和`mesg`。
- en: Invoke the `msgrcv` function to read the message from the associated message
    queue. The structure that was defined in Step 3 is passed to this function.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`msgrcv`函数从相关消息队列中读取消息。在步骤3中定义的结构被传递给此函数。
- en: The read message is then displayed on the screen.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取的消息随后显示在屏幕上。
- en: 'The `messageqrecv.c` program for reading a message from the message queue is
    as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从消息队列中读取消息的`messageqrecv.c`程序：
- en: '[PRE55]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let's go behind the scenes.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后。
- en: How it works...
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we will invoke the `ftok` function to generate an IPC key. The filename
    and ID that are supplied while creating the IPC key are `messagefile` and `a`,
    respectively. These filenames and ID must be the same as the ones that were applied
    while generating the key for writing the message in the message queue. The generated
    key is assigned to the key variable.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将调用`ftok`函数来生成一个IPC密钥。在创建IPC密钥时提供的文件名和ID分别是`messagefile`和`a`。这些文件名和ID必须与在消息队列中写入消息时生成密钥时使用的相同。生成的密钥被分配给密钥变量。
- en: Thereafter, we will invoke the `msgget` function to access the message queue
    that is associated with the IPC key. The identifier of the accessed message queue
    is assigned to the `msqid` variable. The message queue that's associated with
    this key already contains the message that we wrote in the previous program.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将调用`msgget`函数来访问与IPC密钥相关联的消息队列。访问的消息队列的标识符被分配给`msqid`变量。与该密钥相关联的消息队列已经包含了我们之前程序中写入的消息。
- en: Then, we will define a structure by the name `msgstruc` with two members, `mtype`
    and `mesg`. The `mtype` member is for determining the sequence number of the message
    to be read from the message queue. The `mesg` member will be used for storing
    the message that is read from the message queue. We will then define a variable
    called `rcvbuffer` of the `msgstruc` structure type. We will invoke the `msgrcv`
    function to read the message from the associated message queue.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义一个名为`msgstruc`的结构，它有两个成员，`mtype`和`mesg`。`mtype`成员用于确定要从中读取的消息队列的序列号。`mesg`成员将用于存储从消息队列中读取的消息。然后，我们将定义一个名为`rcvbuffer`的变量，其类型为`msgstruc`结构。我们将调用`msgrcv`函数从相关的消息队列中读取消息。
- en: The message identifier, `msqid`, is passed to the function, along with the `rcvbuffer` – the
    structure whose `mesg` member will store the read message. After successful execution
    of the `msgrcv` function, the `mesg` member of the `rcvbuffer` containing the
    message from the message queue will be displayed on screen.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 消息标识符`msqid`被传递给函数，以及`rcvbuffer`——其`mesg`成员将存储读取的消息。在`msgrcv`函数成功执行后，`rcvbuffer`中的`mesg`成员将显示在屏幕上，包含来自消息队列的消息。
- en: 'Let''s use GCC to compile the `messageqsend.c` program, as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`messageqsend.c`程序，如下所示：
- en: '[PRE56]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you get no errors or warnings, this means that the `messageqsend.c` program
    has compiled into an executable file, `messageqsend.exe`. Let''s run this executable
    file:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误或警告，这意味着`messageqsend.c`程序已编译成可执行文件，名为`messageqsend.exe`。让我们运行这个可执行文件：
- en: '[PRE57]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, press *Alt + F2* to open a second Terminal screen. On this screen, you
    can compile and run the script for reading the message from the message queue.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按*Alt + F2*打开第二个终端屏幕。在这个屏幕上，你可以编译和运行从消息队列读取消息的脚本。
- en: 'Let''s use GCC to compile the `messageqrecv.c` program, as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`messageqrecv.c`程序，如下所示：
- en: '[PRE58]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you get no errors or warnings, this means that the `messageqrecv.c` program
    has compiled into an executable file, `messageqrecv.exe`. Let''s run this executable
    file:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误或警告，这意味着`messageqrecv.c`程序已编译成可执行文件，名为`messageqrecv.exe`。让我们运行这个可执行文件：
- en: '[PRE59]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Voila! We've successfully passed a message from one process to another using
    the message queue. Let's move on to the next recipe!
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功通过消息队列将消息从一个进程传递到另一个进程。让我们继续下一个菜谱！
- en: Communicating between processes using shared memory
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享内存进行进程间通信
- en: 'In this recipe, we will learn how communication between two processes is established
    using shared memory. This recipe is divided into the following parts:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用共享内存在两个进程之间建立通信。这个菜谱分为以下部分：
- en: Writing a message into shared memory
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息写入共享内存
- en: Reading a message from shared memory
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从共享内存中读取消息
- en: We will start with the first one, that is, *Writing a message into shared memory*.
    The functions we learned in the previous recipe will also be applicable here.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第一个开始，也就是*将消息写入共享内存*。我们在前面的菜谱中学到的函数也适用于这里。
- en: Writing a message into shared memory
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将消息写入共享内存
- en: In this part of this recipe, we will learn how a message is written into shared
    memory.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱的这一部分，我们将学习如何将消息写入共享内存。
- en: How to do it…
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Invoke the `ftok` function to generate an IPC key by supplying a filename and
    an ID.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供文件名和ID调用`ftok`函数以生成IPC密钥。
- en: Invoke the `shmget` function to allocate a shared memory segment that is associated
    with the key that was generated in step 1.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`shmget`函数分配与步骤1中生成的密钥关联的共享内存段。
- en: The size that's specified for the desired memory segment is `1024`. Create a
    new memory segment with read and write permissions.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所需的内存段指定的尺寸是`1024`。创建一个新的具有读写权限的内存段。
- en: Attach the shared memory segment to the first available address in the system.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将共享内存段附加到系统中的第一个可用地址。
- en: Enter a string that is then assigned to the shared memory segment.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个字符串，然后将其分配给共享内存段。
- en: The attached memory segment will be detached from the address space.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加的内存段将从地址空间中分离。
- en: 'The `writememory.c` program for writing data into the shared memory is as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据写入共享内存的`writememory.c`程序如下所示：
- en: '[PRE60]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Let's go behind the scenes.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后。
- en: How it works...
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By invoking the `ftok` function, we generate an IPC key with the filename `sharedmem`
    (you can change this) and an ID of `a`. The generated key is assigned to the key
    variable. Thereafter, invoke the `shmget` function to allocate a shared memory
    segment that is associated with the supplied key generated using the `ftok` function.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`ftok`函数，我们使用文件名`sharedmem`（你可以更改此名称）和ID为`a`生成一个IPC密钥。生成的密钥被分配给键变量。之后，调用`shmget`函数来分配一个与使用`ftok`函数生成的提供的密钥相关联的共享内存段。
- en: The size that's specified for the desired memory segment is `1024`. Create a
    new memory segment with read and write permissions and assign the shared memory
    identifier to the `shmid` variable. Then, attach the shared memory segment to
    the first available address in the system.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为所需内存段指定的尺寸是`1024`。创建一个新的具有读写权限的内存段，并将共享内存标识符分配给`shmid`变量。然后，将共享内存段连接到系统中的第一个可用地址。
- en: Once the memory segment is attached to the address space, the segment's start
    address is assigned to the `str` variable. You will be asked to enter a string.
    The string you enter will be assigned to the shared memory segment through the
    `str` variable. Finally, the attached memory segment is detached from the address
    space.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦内存段连接到地址空间，段的开头地址就被分配给`str`变量。你将被要求输入一个字符串。你输入的字符串将通过`str`变量分配给共享内存段。最后，连接的内存段从地址空间中分离出来。
- en: Let's move on to the next part of this recipe, *Reading a message from shared
    memory*.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续本配方的下一部分，*从共享内存中读取消息*。
- en: Reading a message from shared memory
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取共享内存中的消息
- en: In this part of the recipe, we will learn how the message that was written into
    shared memory is read and displayed on screen.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分的配方中，我们将学习如何读取写入共享内存的消息并将其显示在屏幕上。
- en: How to do it…
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Invoke the `ftok` function to generate an IPC key. The filename and ID that
    are supplied should be the same as those in the program for writing content into
    shared memory.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`ftok`函数生成一个IPC密钥。提供的文件名和ID应与写入共享内存的程序中的相同。
- en: Invoke the `shmget` function to allocate a shared memory segment. The size that's
    specified for the allocated memory segment is `1024` and is associated with the
    IPC key that was generated in step 1\. Create the memory segment with read and
    write permissions.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`shmget`函数分配一个共享内存段。为分配的内存段指定的尺寸是`1024`，并与步骤1中生成的IPC密钥相关联。创建具有读写权限的内存段。
- en: Attach the shared memory segment to the first available address in the system.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将共享内存段连接到系统中的第一个可用地址。
- en: The content from the shared memory segment is read and displayed on screen.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从共享内存段读取内容并在屏幕上显示。
- en: The attached memory segment is detached from the address space.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接的内存段从地址空间中分离出来。
- en: The shared memory identifier is removed from the system, followed by destroying
    the shared memory segment.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从系统中删除共享内存标识符，然后销毁共享内存段。
- en: 'The `readmemory.c` program for reading data from shared memory is as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从共享内存中读取数据的`readmemory.c`程序：
- en: '[PRE61]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let's go behind the scenes.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解幕后。
- en: How it works...
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will invoke the `ftok` function to generate an IPC key. The filename and
    ID that are supplied for generating the key are `sharedmem` (any name) and `a`,
    respectively. The generated key is assigned to the `key` variable. Thereafter,
    we will invoke the `shmget` function to allocate a shared memory segment. The
    size that's specified for the allocated memory segment is `1024` and is associated
    with the IPC key that was generated earlier.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`ftok`函数生成一个IPC密钥。用于生成密钥的文件名和ID分别是`sharedmem`（可以是任何名称）和`a`。生成的密钥被分配给`key`变量。之后，我们将调用`shmget`函数来分配一个与之前生成的密钥相关联的共享内存段。该分配的内存段尺寸为`1024`。
- en: We will create the new memory segment with read and write permissions and assign
    the fetched shared memory identifier to the `shmid` variable. The shared memory
    segment is then attached to the first available address in the system. This is
    done so that we can access the text that was written in the shared memory segment
    through the previous program.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的具有读写权限的内存段，并将获取的共享内存标识符分配给`shmid`变量。然后，将共享内存段连接到系统中的第一个可用地址。这样做是为了我们可以通过先前的程序访问共享内存段中写入的文本。
- en: So, after the memory segment is attached to the address space, the segment's
    start address is assigned to the `str` variable. Now, we can read the content
    that's been written in the shared memory through the previous program in the current
    program. The content from the shared memory segment is read through the `str` string
    and displayed on screen.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在内存段附加到地址空间之后，段的首地址被分配给了`str`变量。现在，我们可以在当前程序中通过之前的程序写入共享内存的内容。共享内存段的内容通过`str`字符串读取，并在屏幕上显示。
- en: Thereafter, the attached memory segment is detached from the address space.
    Finally, the shared memory identifier `shmid` is removed from the system and the
    shared memory segment is destroyed.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，附加的内存段从地址空间中分离出来。最后，共享内存标识符`shmid`从系统中移除，共享内存段被销毁。
- en: 'Let''s use GCC to compile the `writememory.c` program, as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC来编译`writememory.c`程序，具体如下：
- en: '[PRE62]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you get no errors or warnings, this means that the `writememory.c` program
    has compiled into an executable file, `writememory.exe`. Let''s run this executable
    file:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误或警告，这意味着`writememory.c`程序已经编译成了一个可执行文件，名为`writememory.exe`。现在我们来运行这个可执行文件：
- en: '[PRE63]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, press *Alt + F2* to open a second Terminal window. In this window, let''s
    use GCC to compile the `readmemory.c` program, as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按*Alt + F2*打开第二个终端窗口。在这个窗口中，让我们使用GCC来编译`readmemory.c`程序，具体如下：
- en: '[PRE64]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you get no errors or warnings, this means that the `readmemory.c` program
    has compiled into an executable file, `readmemory.exe`. Let''s run this executable
    file:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误或警告，这意味着`readmemory.c`程序已经编译成了一个可执行文件，名为`readmemory.exe`。现在我们来运行这个可执行文件：
- en: '[PRE65]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Voila! We've successfully communicated between processes using shared memory.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用共享内存在不同进程之间进行了通信。
