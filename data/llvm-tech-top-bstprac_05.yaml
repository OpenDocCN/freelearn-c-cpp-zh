- en: '*Chapter 4*: TableGen Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：TableGen 开发'
- en: '**TableGen** is a **domain-specific language** (**DSL**) that was originally
    developed in **Low-Level Virtual Machine** (**LLVM**) to express processors''
    **instruction set architecture** (**ISA**) and other hardware-specific details,
    similar to the **GNU Compiler Collection''s** (**GCC''s**) **Machine Description**
    (**MD**). Thus, many people learn TableGen when they''re dealing with LLVM''s
    backend development. However, TableGen is not just for describing hardware specifications:
    it is a *general DSL* useful for any tasks that involve non-trivial *static and
    structural data*. LLVM has also been using TableGen on parts outside the backend.
    For example, Clang has been using TableGen for its command-line options management.
    People in the community are also exploring the possibility to implement **InstCombine**
    rules (LLVM''s **peephole optimizations**) in TableGen syntax.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**TableGen** 是一种最初在 **低级虚拟机**（**LLVM**）中开发的 **领域特定语言**（**DSL**），用于表达处理器的 **指令集架构**（**ISA**）和其他硬件特定细节，类似于
    **GNU 编译器集合**（**GCC**）的 **机器描述**（**MD**）。因此，许多人在处理 LLVM 的后端开发时会学习 TableGen。然而，TableGen
    不仅用于描述硬件规范：它是一种 *通用 DSL*，适用于任何涉及非平凡 *静态和结构化数据* 的任务。LLVM 也已经在后端之外的部分使用了 TableGen。例如，Clang
    一直在使用 TableGen 来管理其命令行选项。社区中的人们也在探索在 TableGen 语法中实现 **InstCombine** 规则（LLVM 的
    **窥孔优化**）的可能性。'
- en: Despite TableGen's universality, the language's core syntax has never been widely
    understood by many new developers in this field, creating lots of copy-and-pasted
    boilerplate TableGen code in LLVM's code base since they're not familiar with
    the language *itself*. This chapter tries to shed a little bit of light on this
    situation and show the way to apply this amazing technique to a wide range of
    applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 TableGen 具有通用性，但该语言的核心语法从未被许多新开发者广泛理解，因此在 LLVM 的代码库中产生了大量的复制粘贴的样板 TableGen
    代码，因为他们对语言本身不熟悉。本章试图为这种状况提供一些启示，并展示如何将这项惊人的技术应用于广泛的领域。
- en: The chapter starts with an introduction to common and important TableGen syntax,
    which prepares you for writing a delicious donut recipe in TableGen as a practice,
    culminating in a demonstration of TableGen's universality in the second part.
    Finally, the chapter will end with a tutorial to develop a custom *emitter*, or
    a **TableGen backend**, to convert those nerdy sentences in the TableGen recipe
    into normal plaintext descriptions that can be put in the kitchen.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从介绍常见的和重要的 TableGen 语法开始，为你准备在 TableGen 中编写美味的甜甜圈配方作为实践，最终在第二部分展示 TableGen
    的通用性。最后，本章将以一个教程结束，介绍如何开发自定义 *发射器* 或 **TableGen 后端**，将 TableGen 配方中的那些古怪句子转换为可以放入厨房的正常纯文本描述。
- en: 'Here is the list of the sections we will be covering:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要涵盖的部分列表：
- en: Introduction to TableGen syntax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TableGen 语法介绍
- en: Writing a donut recipe in TableGen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 TableGen 中编写甜甜圈配方
- en: Printing a recipe via the TableGen backend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 TableGen 后端打印配方
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter focuses on one tool in the `utils` folder: `llvm-tblgen`. To build
    it, launch the following command:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍 `utils` 文件夹中的一个工具：`llvm-tblgen`。要构建它，请运行以下命令：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you chose to build `llvm-tblgen` in `LLVM_OPTIMIZED_TABLEGEN` CMake variable
    introduced in the first chapter, you might want to change that setting since it's
    always better to have a debug version of `llvm-tblgen` in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了在第一章中引入的 `LLVM_OPTIMIZED_TABLEGEN` CMake 变量中构建 `llvm-tblgen`，你可能想要更改这个设置，因为在这个章节中始终拥有
    `llvm-tblgen` 的调试版本会更好。
- en: 'All of the source code in this chapter can be found in this GitHub repository:
    [https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter04](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter04).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的源代码都可以在这个 GitHub 仓库中找到：[https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter04](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter04)。
- en: Introduction to TableGen syntax
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TableGen 语法介绍
- en: This section serves as a quick tour of all the important and common TableGen
    syntax, providing all the essential knowledge to get hands-on, writing a donut
    recipe in TableGen in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节提供了一个对所有重要和常见 TableGen 语法的快速浏览，提供了所有必要的知识，以便在下一节中通过 TableGen 编写甜甜圈配方。
- en: TableGen is a domain-specific programming language used for modeling custom
    data layouts. Despite being a programming language, it does something quite different
    from conventional languages. **Conventional programming languages** usually describe
    *actions* performed on the (input) data, how they interact with the environment,
    and how they generate results, regardless of the programming paradigms (imperative,
    functional, event-driven…) you adopt. TableGen, in contrast, barely describes
    any actions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen 是一种用于建模自定义数据布局的特定领域编程语言。尽管它是一种编程语言，但它所做的与传统的语言大不相同。**传统编程语言**通常描述对（输入）数据执行的操作、它们与环境如何交互以及它们如何生成结果，无论你采用哪种编程范式（命令式、函数式、事件驱动…）。相比之下，TableGen
    几乎不描述任何操作。
- en: 'TableGen is designed only to describe structural **static data**. First, developers
    define the layout—which is essentially just a table with many fields—of their
    desired data structure. They then need to fill data into those layouts *right
    away* as most of the fields are populated/initialized. The latter part is probably
    what makes TableGen unique: many programming languages or frameworks provide ways
    to design your domain-specific data structures (for example, Google''s **Protocol
    Buffers**), but in those scenarios, data is usually filled in **dynamically**,
    mostly in the code that consumes the DSL part.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen 仅设计用于描述结构化的 **静态数据**。首先，开发者定义他们所需数据结构的布局——本质上只是一个包含许多字段的表格。然后，他们需要立即将这些数据填充到布局中，因为大多数字段都是填充/初始化的。后者可能是
    TableGen 独特之处：许多编程语言或框架提供设计特定领域数据结构的方法（例如，Google 的 **Protocol Buffers**），但在那些场景中，数据通常是在消耗
    DSL 部分的代码中 **动态** 填充的。
- en: '`TABLE`; and in TableGen, it''s `class`, which will be introduced later on
    in this section. However, SQL provides much more functions other than crafting
    the layout. It can also query (actually, that''s where its name came from: **Structured
    Query Language**) and update data dynamically, which are absent in TableGen. However,
    later in this chapter, you will see that TableGen provides a nice framework to
    flexibly process and *interpret* this TableGen-defined data.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`TABLE`; 在 TableGen 中则是 `class`，这部分将在本节稍后介绍。然而，SQL 提供了比仅仅构建布局多得多的功能。它还可以动态地查询（实际上，这也是其名称的由来：**结构化查询语言**）和更新数据，这是
    TableGen 所不具备的。然而，在本章的后面部分，你将看到 TableGen 提供了一个灵活处理和 *解释* 这些 TableGen 定义的框架。'
- en: 'We''ll now introduce four important TableGen constructions, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍四个重要的 TableGen 构造，如下所示：
- en: Layout and records
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局和记录
- en: Bang operators
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破折号运算符
- en: Multiclass
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多类
- en: The **Directed-Acyclic Graph** (**DAG**) data type
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有向无环图**（**DAG**）数据类型'
- en: Layout and records
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局和记录
- en: 'Given the fact that TableGen is just a more fancy and expressive way to describe
    structural data, it''s pretty straightforward to think that there is a primitive
    representation for the data''s `class` syntax, as shown in the following code
    snippet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TableGen 只是一种更花哨、更易于表达的方式来描述结构化数据，因此很容易想到存在一种原始的数据 `class` 语法表示，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As shown here, a class is similar to a struct in C and many other programming
    languages, which only contains a group of data fields. Each field has a type,
    which can be any of the primitive types (`int`, `string`, `bit`, and so on) or
    another user-defined `class` type. A field can also assign a default value such
    as `John Smith`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，一个类类似于 C 语言和其他许多编程语言中的结构体，它只包含一组数据字段。每个字段都有一个类型，可以是任何原始类型（`int`、`string`、`bit`
    等）或另一个用户定义的 `class` 类型。字段还可以分配一个默认值，例如 `John Smith`。
- en: 'After looking a layout, it''s time to create an instance (or a **record**,
    in TableGen''s terms), out of it, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看布局之后，是时候创建一个实例（或 TableGen 术语中的 **记录**）了，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `john_smith` is a record using `Person` as a template so that it also
    has two fields—`Name` and `Age`—with the `Name` field filled with the value `John
    Smith`. This looks pretty straightforward, but recall that TableGen should define
    static data and that *most* fields should be filled with values. Also, in this
    case, the `Age` field is still left uninitialized. You can populate its value
    by *overriding* with a bracket closure and statements within, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`john_smith` 是一个使用 `Person` 作为模板的记录，因此它也有两个字段——`Name` 和 `Age`——其中 `Name`
    字段填充了值 `John Smith`。这看起来相当直接，但请记住 TableGen 应该定义静态数据，并且 *大多数* 字段应该填充值。此外，在这种情况下，`Age`
    字段仍然未被初始化。你可以通过以下方式用括号闭合和其中的语句来 *覆盖* 它的值：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can even define new fields specifically for the `john_smith` record, as
    follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以专门为`john_smith`记录定义新字段，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just be aware that you can only override fields (using the `let` keyword) that
    have been declared, just as with many other programming languages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您只能覆盖已声明的字段（使用`let`关键字），就像在许多其他编程语言中一样。
- en: Bang operators
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bang操作符
- en: 'Bang operators are a group of functions performing simple tasks such as basic
    arithmetic or casting on values in TableGen. Here is a simple example of converting
    kilograms to grams:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Bang操作符是一组执行基本任务（如基本算术或值转换）的函数。以下是一个将千克转换为克的简单示例：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Common operators include arithmetic and bitwise operators (to name but a few),
    and some of these are outlined here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 常见操作符包括算术和位运算符（仅举几例），其中一些在此概述：
- en: '`!add(a, b)`: For arithmetic addition'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!add(a, b)`: 用于算术加法'
- en: '`!sub(a, b)`: For arithmetic subtraction'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!sub(a, b)`: 用于算术减法'
- en: '`!mul(a, b)`: For arithmetic multiplication'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!mul(a, b)`: 用于算术乘法'
- en: '`!and(a, b)`: For logical `AND` operations'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!and(a, b)`: 用于逻辑`AND`运算'
- en: '`!or(a, b)`: For logical `OR` operations'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!or(a, b)`: 用于逻辑`OR`运算'
- en: '`!xor(a, b)`: For logical `XOR` operations'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!xor(a, b)`: 用于逻辑`XOR`运算'
- en: 'We also use conditional operators, and a few are outlined here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用条件操作符，这里概述了一些：
- en: '`!ge(a, b)`: Returns 1 if `a >= b`, and 0 otherwise'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!ge(a, b)`: 如果`a >= b`，则返回1，否则返回0'
- en: '`!gt(a, b)`: Returns 1 if `a > b`, and 0 otherwise'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!gt(a, b)`: 如果`a > b`，则返回1，否则返回0'
- en: '`!le(a, b)`: Returns 1 if `a <= b`, and 0 otherwise'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!le(a, b)`: 如果`a <= b`，则返回1，否则返回0'
- en: '`!lt(a, b)`: Returns 1 if `a < b`, and 0 otherwise'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!lt(a, b)`: 如果`a < b`，则返回1，否则返回0'
- en: '`!eq(a, b)`: Returns 1 if `a == b`, and 0 otherwise'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!eq(a, b)`: 如果`a == b`，则返回1，否则返回0'
- en: 'Other interesting operators include the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有趣的操作符包括以下内容：
- en: '`!cast<type>(x)`: This operator performs type casting on the `x` operand, according
    to the `type` parameter. In cases where the type is a numerical type, such as
    with `int` or `bits`, this performs normal arithmetic type casting. In some special
    cases, we have the following scenarios:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!cast<type>(x)`: 此操作符根据`type`参数对操作数`x`进行类型转换。在类型是数值类型的情况下，例如`int`或`bits`，这会执行正常的算术类型转换。在某些特殊情况下，我们有以下场景：'
- en: If `type` is string and `x` is a record, this returns the record's name.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`type`是字符串且`x`是记录，则返回记录的名称。
- en: If `x` is a string, it is treated as the name of a record. TableGen will look
    up all the record definitions so far and cast the one with the name of `x` and
    return it with a type that matches the `type` parameter.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`x`是字符串，它被视为记录的名称。TableGen将查找迄今为止的所有记录定义，并返回具有`x`名称的记录，其类型与`type`参数匹配。
- en: '`!if(pred, then, else)`: This operator returns the `then` expression if `pred`
    is 1, and returns the `else` expression otherwise.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!if(pred, then, else)`: 如果`pred`为1，则此操作符返回`then`表达式，否则返回`else`表达式。'
- en: '`!cond(cond1 : val1, cond2 : val2, …, condN : valN)`: This operator is an enhanced
    version of the `!if` operator. It will continuously evaluate `cond1…condN` until
    one of the expressions returns 1, before returning its associated `val` expression.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!cond(cond1 : val1, cond2 : val2, …, condN : valN)`: 这个操作符是`!if`操作符的增强版本。它将连续评估`cond1…condN`，直到其中一个表达式返回1，然后返回其关联的`val`表达式。'
- en: Note
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike functions, which are evaluated during runtime, bang operators are more
    like *macros*, which are evaluated during build time—or in TableGen's terminology,
    when those syntaxes are processed by TableGen backends.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与函数不同，函数是在运行时评估的，而Bang操作符更像*宏*，它们是在构建时评估的——或者用TableGen的术语来说，当这些语法被TableGen后端处理时。
- en: Multiclass
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多类
- en: 'There are many cases where we want to define multiple records at once. For
    example, the following snippet tries to create *auto part* records for multiple
    cars:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们希望一次性定义多个记录。例如，以下代码片段尝试为多辆汽车创建*自动部件*记录：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can further simplify these by using the `multiclass` syntax, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`multiclass`语法进一步简化这些操作，如下所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When creating record instances, use the `defm` syntax instead of `def`, as
    follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建记录实例时，使用`defm`语法而不是`def`，如下所示：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Thus, at the end, it will still generate records with names such as `car1_fuel_tank`,
    `car1_engine`, `car2_fuel_tank`, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终它仍然会生成具有`car1_fuel_tank`、`car1_engine`、`car2_fuel_tank`等名称的记录。
- en: 'Despite having `class` in its name, `multiclass` has nothing to do with a class.
    Instead of describing the layout of a record, `multiclass` acts as a template
    to *generate* records. Inside a `multiclass` template are the prospective records
    to be created and the records'' name *suffix* after the template is expanded.
    For example, the `defm car1 : Car<1>` directive in the preceding snippet will
    eventually be expanded into three `def` directives, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管其名称中包含 `class`，但 `multiclass` 与类无关。`multiclass` 不是描述记录布局的，而是作为一个模板来 *生成*
    记录。在 `multiclass` 模板内部是预期创建的记录以及模板展开后的记录名称 *后缀*。例如，前述片段中的 `defm car1 : Car<1>`
    指令最终将被展开成三个 `def` 指令，如下所示：'
- en: '`def car1_fuel_tank : AutoPart<1>;`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def car1_fuel_tank : AutoPart<1>;`'
- en: '`def car1_engine : AutoPart<1>;`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def car1_engine : AutoPart<1>;`'
- en: '`def car1_wheels : AutoPart<!mul(1, 4)>;`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def car1_wheels : AutoPart<!mul(1, 4)>;`'
- en: As you can see in the preceding list, the name suffixes we found inside `multiclass`
    (for instance, `_fuel_tank`) was concatenated with the name appearing after `defm`—c`ar1`
    in this case. Also, the `quantity` template argument from `multiclass`, was also
    instantiated into every expanded record.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的列表所示，我们在 `multiclass` 中找到的名称后缀（例如，`_fuel_tank`）与 `defm` 后出现的名称连接在一起—在本例中是
    `car1`。此外，`multiclass` 的 `quantity` 模板参数也被实例化到每个展开的记录中。
- en: In short, `multiclass` tries to extract common parameters from multiple record
    instances and make it possible to create them at once.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`multiclass` 尝试从多个记录实例中提取公共参数，并使其能够一次性创建它们。
- en: The DAG data type
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DAG 数据类型
- en: 'In addition to conventional data types, TableGen has a pretty unique first-class
    type: the `dag` type that is used for expressing DAG instances. To create a DAG
    instance, you can use the following syntax:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统数据类型外，TableGen 还有一个相当独特的第一类类型：用于表示 DAG 实例的 `dag` 类型。要创建 DAG 实例，你可以使用以下语法：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the `operator` can only be a record instance, operands (`operand1`…`operandN`)
    can have arbitrary types. Here is an example of trying to model an arithmetic
    expression, `x * 2 + y + 8 * z`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `operator` 只能是记录实例，但操作数（`operand1`…`operandN`）可以具有任意类型。以下是一个尝试建模算术表达式 `x
    * 2 + y + 8 * z` 的示例：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Optionally, you can associate `operator` and/or each operand with a *tag*,
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以将 `operator` 和/或每个操作数与一个 *tag* 关联，如下所示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A tag always starts with a dollar sign, `$`, followed by a user-defined tag
    name. These tags provide a *logical* description of each `dag` component and can
    be useful when processing DAGs in the TableGen backend.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 标签始终以美元符号 `$` 开头，后跟用户定义的标签名称。这些标签为每个 `dag` 组件提供了一种 *逻辑* 描述，并在 TableGen 后端处理
    DAG 时可能很有用。
- en: In this section, we have gone through the principal components of the TableGen
    language and introduced some essential syntax. In the next section, we are going
    to get hands-on, writing a delicious donut recipe using TableGen.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 TableGen 语言的主体组件并介绍了一些基本语法。在下一节中，我们将亲自动手，使用 TableGen 编写美味的甜甜圈配方。
- en: Writing a donut recipe in TableGen
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 TableGen 中编写甜甜圈配方
- en: 'With the knowledge from previous sections, it''s time to write our own donut
    recipe! We''ll proceed as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节的知识基础上，现在是时候编写我们自己的甜甜圈配方了！我们将按以下步骤进行：
- en: 'The first file to create is `Kitchen.td`. It defines the environment for cooking,
    including measuring units, equipment, and procedures, to name but a few aspects.
    We are going to start with the measuring units, as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要创建的文件是 `Kitchen.td`。它定义了烹饪环境，包括测量单位、设备和程序等。我们将从测量单位开始，如下所示：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, the `Text` field is the textual format showing on the recipe, and `Imperial`
    is just a Boolean flag marking whether this unit is imperial or metric. Each weight
    or volume unit will be a record inheriting from this class—have a look at the
    following code snippet for an example of this:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`Text` 字段是显示在配方上的文本格式，而 `Imperial` 只是一个布尔标志，表示此单位是英制还是公制。每个重量或体积单位都将是一个继承自该类的记录—请查看以下代码片段以了解此例：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are plenty of measuring units we want to create, but the code is already
    pretty lengthy. A way to simplify and make it more readable is by using `class`
    template arguments, as follows:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们想要创建许多测量单位，但代码已经相当长。一种简化并使其更易于阅读的方法是使用 `class` 模板参数，如下所示：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In contrast to C++'s template arguments, the template arguments in TableGen
    only accept concrete values. They're just an alternative way to assign values
    to fields.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 C++ 的模板参数不同，TableGen 中的模板参数仅接受具体值。它们只是为字段赋值的一种替代方式。
- en: 'Since TableGen doesn''t support floating-point numbers, we need to define some
    way to express numberings, such as `Integral` and `DecimalPoint` fields mentioned,
    the value represented by this `FixedPoint` class is equal to the following formula:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 TableGen 不支持浮点数，我们需要定义一种方法来表示编号，例如提到的 `Integral` 和 `DecimalPoint` 字段，这个 `FixedPoint`
    类表示的值等于以下公式：
- en: '*Integral * 10^(-DecimalPoint)*'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`*Integral * 10^(-DecimalPoint)*`'
- en: 'Since ¼, ½, and ¾ are apparently commonly used in measuring (especially for
    imperial units such as a US cup), it''s probably a good idea to use a helper class
    to create them, as follows:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 ¼、½ 和 ¾ 在测量中显然是常用的（尤其是对于像美国杯这样的英制单位），使用一个辅助类来创建它们可能是个好主意，如下所示：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To implement `NplusQuarter`, especially the conversion from the `NplusQuarter`
    class template parameters to that of `FixedPoint`, we need some simple arithmetic
    calculations, which is where TableGen''s bang operators come into place, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现 `NplusQuarter`，特别是将 `NplusQuarter` 类模板参数转换为 `FixedPoint` 的转换，我们需要进行一些简单的算术计算，这正是
    TableGen 的感叹号运算符发挥作用的地方，如下所示：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: num_quarter{8…6,4,2…0}
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`num_quarter{8…6,4,2…0}`'
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: num_quarter{1…7}
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`num_quarter{1…7}`'
- en: '[PRE18]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the measuring units and number format, we can finally deal with the ingredients
    needed for this recipe. First, let''s use a separated file, `Ingredients.td`,
    to store all the ingredient records. To use all the things mentioned earlier,
    we can import `Kitchen.td` by using the `include` syntax, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用测量单位和数字格式，我们最终可以处理这个食谱所需的成分。首先，让我们使用一个单独的文件，`Ingredients.td`，来存储所有成分记录。要使用前面提到的所有内容，我们可以使用
    `include` 语法导入 `Kitchen.td`，如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, a base class of all ingredients is created to carry some common fields,
    as follows:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，创建一个所有成分的基类来携带一些常用字段，如下所示：
- en: '[PRE20]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'class Milk<cup_unit put at the template argument for IngredientBase tells us
    that milk is measured by a US cup unit, and its quantity is to be determined later
    by the Milk class template arguments. When writing a recipe, each required ingredient
    is represented by a record created from one of these ingredient `class` types:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`class Milk<cup_unit put at the template argument for IngredientBase tells
    us that milk is measured by a US cup unit, and its quantity is to be determined
    later by the Milk class template arguments. When writing a recipe, each required
    ingredient is represented by a record created from one of these ingredient `class`
    types:`'
- en: '[PRE21]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Some ingredients, however, always come together—for example, lemon peel and
    lemon juice, egg yolk, and egg white. That is, if you have two egg yolks, then
    there must be two servings of egg white. However, if we need to create a record
    and assign a quantity for each of the ingredients one by one, there will be a
    lot of duplicate code. A more elegant way to solve this problem is by using TableGen's
    `multiclass` syntax.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些成分总是同时出现——例如，柠檬皮和柠檬汁、蛋黄和蛋白。也就是说，如果你有两个蛋黄，那么就必须有两个蛋白的份量。然而，如果我们需要逐个创建记录并为每种成分分配数量，将会产生大量的重复代码。解决这个问题的更优雅的方法是使用
    TableGen 的 `multiclass` 语法。
- en: 'Taking the following egg example, assume we want to create `WholeEgg`, `EggWhite`,
    and `EggYolk` records at once with the same quantity, and define the `multiclass`
    first:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以以下蛋黄为例，假设我们想一次性创建 `WholeEgg`、`EggWhite` 和 `EggYolk` 记录，并使用相同的数量，首先定义 `multiclass`：
- en: '[PRE23]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'defm egg_ingredient : Egg<3>;'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`defm egg_ingredient : Egg<3>;`'
- en: '[PRE24]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we need a way to describe the steps to make a donut. Many recipes
    have some preparation steps that don''t need to be done in a specific order. Take
    the donut recipe here, for example: preheating the oil can be done at any time
    before the donuts are ready to be fried. Thus, it might be a good idea to express
    baking steps in a `dag` type.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一种方法来描述制作甜甜圈的过程。许多食谱都有一些不需要按特定顺序完成的准备步骤。以这里的甜甜圈食谱为例：在甜甜圈准备好油炸之前，可以随时预热油。因此，用
    `dag` 类型表达烘焙步骤可能是个好主意。
- en: 'Let''s first create the `class` to represent a baking step, as follows:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们首先创建一个 `class` 来表示烘焙步骤，如下所示：
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'def Action is just a class used for describing movements. The following snippet
    represents the fact that step_mixing2 is using the outcome from step_mixing (maybe
    a raw dough) and mixing it with butter:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def Action is just a class used for describing movements. The following snippet
    represents the fact that step_mixing2 is using the outcome from step_mixing (maybe
    a raw dough) and mixing it with butter:`'
- en: '[PRE26]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'def step_mixing2 : Step<(mix:dag tags have no immediate effect in TableGen
    code, except affecting how TableGen backends handle the current record—for example,
    if we have a string type field, CustomFormat, in the Step class, as follows:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`def step_mixing2 : Step<(mix:dag tags have no immediate effect in TableGen
    code, except affecting how TableGen backends handle the current record—for example,
    if we have a string type field, CustomFormat, in the Step class, as follows:`'
- en: '[PRE27]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And that wraps up this section of this chapter. In the next section, the goal
    is to develop a custom TableGen backend to take the TableGen version recipe here
    as input and print out a normal plaintext recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就结束了本章的这一部分。在下一节中，目标是开发一个自定义的TableGen后端，以这里作为输入的TableGen版本配方，并打印出正常的纯文本配方。
- en: Printing a recipe via the TableGen backend
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过TableGen后端打印配方
- en: Following up on the last part of the previous section, after composing the donut
    recipe in TableGen's syntax, it's time to print out a *normal* recipe from that
    via a custom-built TableGen backend.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的最后部分之后，在TableGen语法中组成甜甜圈配方后，就到了通过自定义构建的TableGen后端打印出一个**正常**配方的时候了。
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please don''t confuse a **TableGen backend** with a **LLVM backend**: the former
    converts (or transpiles) TableGen files into an *arbitrary textual content*, C/C++
    header files being the most common form. An LLVM backend, on the other hand, lowers
    LLVM **intermediate representations** (**IR**) into low-level assembly code.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要将**TableGen后端**与**LLVM后端**混淆：前者将（或转换）TableGen文件转换为**任意文本内容**，C/C++头文件是最常见的形式。另一方面，LLVM后端将LLVM**中间表示**（**IR**）转换为低级汇编代码。
- en: 'In this section, we''re developing the TableGen backend to print the donut
    we composed in the previous section into content, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们正在开发TableGen后端，将我们在上一节中组成的甜甜圈配方打印成内容，如下所示：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, we will give an overview of `llvm-tblgen`, the program for driving the
    TableGen translation process. Then, we will show you how to develop our recipe-printing
    TableGen backend. Finally, we'll show you how to integrate our backend into the
    `llvm-tblgen` executable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将概述`llvm-tblgen`，这是驱动TableGen翻译过程的程序。然后，我们将向您展示如何开发我们的配方打印TableGen后端。最后，我们将向您展示如何将我们的后端集成到`llvm-tblgen`可执行文件中。
- en: TableGen's high-level workflow
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TableGen的高级工作流程
- en: 'The TableGen backend takes in-memory representation (in the form of C++ objects)
    of the TableGen code we just learned and transforms it into arbitrary `llvm-tblgen`
    executable, whose workflow can be illustrated by this diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen后端接受我们刚刚学到的TableGen代码的内存表示（以C++对象的形式），并将其转换成任意的`llvm-tblgen`可执行文件，其工作流程可以用这张图来表示：
- en: '![Figure 4.1 – Workflow of llvm-tblgen'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – llvm-tblgen的工作流程'
- en: '](img/Figure_4.1_B14590.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B14590.jpg)'
- en: Figure 4.1 – Workflow of llvm-tblgen
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – llvm-tblgen的工作流程
- en: 'TableGen code''s in-memory representation (which consists of C++ types and
    APIs) plays an important role in the TableGen backend development. Similar to
    LLVM IR, it is organized *hierarchically*. Starting from the top level, here is
    a list of its hierarchy, where each of the items is a C++ class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen代码的内存表示（由C++类型和API组成）在TableGen后端开发中起着重要作用。类似于LLVM IR，它是**层次化**组织的。从顶层开始，以下是它的层次结构列表，其中每个项目都是一个C++类：
- en: '`RecordKeeper`: A collection (and owner) of all `Record` objects in the current
    translation unit.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RecordKeeper`：当前翻译单元中所有`Record`对象的集合（和所有者）。'
- en: '`Record`: Represents a record or a `class`. The enclosing fields are represented
    by `RecordVal`. If it''s a `class`, you can also access its template arguments.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Record`：表示一个记录或一个`class`。封装的字段由`RecordVal`表示。如果它是一个`class`，你也可以访问它的模板参数。'
- en: '`RecordVal`: Represents a *pair* of record fields and their initialized value,
    along with supplementary information such as the field''s type and source location.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RecordVal`：表示记录字段及其初始化值的一个**对**，以及补充信息，如字段类型和源位置。'
- en: '`Init`: Represents the initialized value of a field. It is a parent class of
    `many`, which represents different types of initialized values—For example, `IntInit`
    for integer values and `DagInit` for DAG values.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Init`：表示字段的初始化值。它是`many`的父类，代表不同类型的初始化值——例如，`IntInit`用于整数值和`DagInit`用于DAG值。'
- en: 'To give you a little task on the practical aspect of a TableGen backend, here
    is the skeleton of it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您在TableGen后端的实际方面有一个小任务，以下是它的框架：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This emitter basically takes a `RecordKeeper` object (passed in by the constructor)
    as the input and prints the output into the `raw_ostream` stream—the function
    argument of `SampleEmitter::run`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个发射器基本上将一个`RecordKeeper`对象（由构造函数传入）作为输入，并将输出打印到`raw_ostream`流中——`SampleEmitter::run`函数的参数。
- en: In the next section, we're going to show you how to set up the development environment
    and get hands- on, writing a TableGen backend.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向您展示如何设置开发环境并动手编写一个TableGen后端。
- en: Writing the TableGen backend
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写TableGen后端
- en: In this section, we're showing you the steps of writing a backend to print out
    recipes written in TableGen. Let's start with the setup.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何编写后端以打印出用 TableGen 编写的食谱的步骤。让我们从设置开始。
- en: Project setup
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'To get started, LLVM has already provided a skeleton for writing a TableGen
    backend. So, please copy the `llvm/lib/TableGen/TableGenBackendSkeleton.cpp` file
    from the LLVM Project''s source tree into the `llvm/utils/TableGen` folder, as
    follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，LLVM 已经为编写 TableGen 后端提供了一个骨架。因此，请将 `llvm/lib/TableGen/TableGenBackendSkeleton.cpp`
    文件从 LLVM 项目的源树复制到 `llvm/utils/TableGen` 文件夹中，如下所示：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then, refactor the c`SkeletonEmitter` class into `RecipePrinter`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `SkeletonEmitter` 类重构为 `RecipePrinter`。
- en: '`RecipePrinter` has the following workflow:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecipePrinter` 有以下工作流程：'
- en: Collect all baking steps and ingredient records.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集所有烘焙步骤和成分记录。
- en: Print individual ingredients in textual formats using individual functions to
    print measuring units, temperature, equipment, and so on in textual formats.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单独的函数以文本格式打印单个成分，使用单独的函数以文本格式打印测量单位、温度、设备等。
- en: Linearize the DAG of all baking steps.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性化所有烘焙步骤的 DAG。
- en: Print each linearized baking step using a function to print custom formatting.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个用于打印自定义格式的函数来打印每个线性化的烘焙步骤。
- en: We're not going to cover all the implementation details since lots of backend
    codes are actually not directly related to TableGen (text formatting and string
    processing, for example). Therefore, the following subsections only focus on how
    to retrieve information from TableGen's in-memory objects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖所有实现细节，因为许多后端代码实际上与 TableGen 并不直接相关（例如文本格式化和字符串处理）。因此，以下子节仅关注如何从 TableGen
    的内存对象中检索信息。
- en: Getting all the baking steps
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取所有烘焙步骤
- en: 'In the TableGen backend, a TableGen record is represented by the `Record` C++
    class. When we want to retrieve all the records derived from a specific TableGen
    `class`, we can use one of the functions of `RecordKeeper`: `getAllDerivedDefinitions`.
    For instance, let''s say we want to fetch all the baking steps records that derived
    from the `Step` TableGen class in this case. Here is how we do with `getAllDerivedDefinitions`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TableGen 后端中，TableGen 记录由 `Record` C++ 类表示。当我们想要检索从特定 TableGen `class` 派生的所有记录时，我们可以使用
    `RecordKeeper` 的一个函数：`getAllDerivedDefinitions`。例如，假设我们想要获取从本例中 `Step` TableGen
    类派生的所有烘焙步骤记录。以下是使用 `getAllDerivedDefinitions` 的方法：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This gives us a list of `Record` pointers that represent all of the `Step` records.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个表示所有 `Step` 记录的 `Record` 指针列表。
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the rest of this section, we will use `Record` in this format (with Courier
    font face) to refer to the C++ counterpart of a TableGen record.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将使用（带有Courier字体外观）的 `Record` 格式来引用 TableGen 记录的 C++ 对应物。
- en: Retrieving field values
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索字段值
- en: 'Retrieving field values from `Record` is probably the most basic operation.
    Let''s say we''re working on a method for printing `Unit` record objects introduced
    earlier, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Record` 中检索字段值可能是最基本操作。假设我们正在编写一个用于打印之前引入的 `Unit` 记录对象的方法，如下所示：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Record` class provides some handy functions, such as `getValueAsString`,
    to retrieve the value of a field and try to convert it into a specific type so
    that you don''t need to retrieve the `RecordVal` value of a specific field (in
    this case, the `Text` field) before getting the real value. Similar functions
    include the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record` 类提供了一些方便的函数，例如 `getValueAsString`，用于检索字段的值并尝试将其转换为特定类型，这样您就不需要在获取实际值之前检索特定字段（在这种情况下，是
    `Text` 字段）的 `RecordVal` 值。类似函数包括以下内容：'
- en: '`Record* getValueAsDef(StringRef FieldName)`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Record* getValueAsDef(StringRef FieldName)`'
- en: '`bool getValueAsBit(StringRef FieldName)`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool getValueAsBit(StringRef FieldName)`'
- en: '`int64_t getValueAsInt(StringRef FieldName)`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int64_t getValueAsInt(StringRef FieldName)`'
- en: '`DagInit* getValueAsDag(StringRef FieldName)`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DagInit* getValueAsDag(StringRef FieldName)`'
- en: In addition to these utility functions, we sometimes just want to check if a
    specific field exists in a record. In such cases, call `Record::getValue(StringRef
    FieldName)` and check if the returned value is null. But just be aware that not
    every field *needs* to be initialized; you may still need to check if a field
    exists, but is uninitialized. When that happens, let `Record::isValueUnset` help
    you.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些实用函数之外，我们有时只想检查记录中是否存在特定字段。在这种情况下，调用 `Record::getValue(StringRef FieldName)`
    并检查返回的值是否为 null。但请注意，并非每个字段*都需要*初始化；您可能仍然需要检查字段是否存在，但未初始化。当这种情况发生时，让 `Record::isValueUnset`
    帮助您。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: TableGen actually uses a special `Init` class, `UnsetInit`, to represent an
    uninitialized value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen实际上使用一个特殊的`Init`类，`UnsetInit`来表示一个未初始化的值。
- en: Type conversion
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: '`Init` represents initialization values, but most of the time we''re not directly
    working with it but with one of its children''s classes.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Init`代表初始化值，但大多数时候我们并不是直接与它工作，而是与它的子类之一工作。'
- en: 'For example, `StepOrIngredient` is an `Init` type object that represents either
    a `Step` record or an ingredient record. It would be easier for us to convert
    it to its underlying `DefInit` object since `DefInit` provides richer functionalities.
    We can use the following code to typecast the `Init` type `StepOrIngredient` into
    a `DefInit` type object:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`StepOrIngredient`是一个代表`Step`记录或成分记录的`Init`类型对象。由于`DefInit`提供了更丰富的功能，将其转换为底层的`DefInit`对象会更容易。我们可以使用以下代码将`Init`类型的`StepOrIngredient`转换为`DefInit`类型对象：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can also use `isa<…>(…)` to check its underlying type first, or `dyn_cast<…>(…)`
    if you don't want to receive an exception when the conversion fails.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`isa<…>(…)`来首先检查其底层类型，或者如果您不希望在转换失败时接收异常，可以使用`dyn_cast<…>(…)`。
- en: '`Record` represents a TableGen record, but it would be better if we can find
    out its parent class, which further tells us the field''s information.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record`代表一个TableGen记录，但如果我们能找到它的父类，这将进一步告诉我们字段的信息会更好。'
- en: 'For example, after getting the underlying `Record` object for `SIDef`, we can
    use the `isSubClassOf` function to tell if that `Record` is a baking step or ingredient,
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在获取`SIDef`的底层`Record`对象之后，我们可以使用`isSubClassOf`函数来判断该`Record`是否是一个烘焙步骤或成分，如下所示：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Knowing what the underlying TableGen class actually is can help us to print
    that record in its own way.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 了解底层TableGen类实际上是什么可以帮助我们以它自己的方式打印出该记录。
- en: Handling DAG values
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理DAG值
- en: 'Now, we are going to print out the `Step` records. Recall that we used the
    `dag` type to represent the action and the ingredients required for a baking step.
    Have a look at the following code example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将打印出`Step`记录。回想一下，我们使用`dag`类型来表示烘焙步骤的动作和所需的成分。看看下面的代码示例：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, the highlighted `dag` is stored in the `Action` field of the `Step` TableGen
    class. So, we use `getValueAsDag` to retrieve that field as a `DagInit` object,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，高亮的`dag`存储在`Step` TableGen类的`Action`字段中。因此，我们使用`getValueAsDag`来检索该字段作为`DagInit`对象，如下所示：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`DagInit` is just another class derived from `Init`, which wasintroduced earlier.
    It contains some DAG-specific APIs. For example, we can iterate through all of
    its operands and get their associated `Init` object using the `getArg` function,
    as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`DagInit`是另一个从`Init`派生出来的类，它是在之前引入的。它包含一些DAG特定的API。例如，我们可以通过`getArg`函数遍历所有的操作数并获取它们关联的`Init`对象，如下所示：'
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Furthermore, we can use the `getArgNameStr` function to retrieve the token
    (if there is any), which is always represented in string type in the TableGen
    backend, associated with a specific operand, as illustrated in the following code
    snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`getArgNameStr`函数来检索令牌（如果有的话），在TableGen后端中，令牌总是以字符串类型表示，与特定的操作数相关联，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If `ArgTok` is empty, this means there is no token associated with that operand.
    To get the token associated with the operator, we can use the `getNameStr` API.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ArgTok`为空，这意味着没有与该操作数关联的令牌。要获取与操作符关联的令牌，我们可以使用`getNameStr` API。
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Both `DagInit::getArgNameStr` and `DagInit::getNameStr` return the token string
    *without* the leading dollar sign.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`DagInit::getArgNameStr`和`DagInit::getNameStr`都返回不带前导美元符号的令牌字符串。'
- en: This section has shown you some of the most important aspects of working with
    TableGen directives' in-memory C++ representation, which is the building block
    of writing a TableGen backend. In the next section, we will show you the final
    step to put everything together and run our custom TableGen backend.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您展示了使用TableGen指令内存中C++表示的一些最重要的方面，这是编写TableGen后端的基本构建块。在下一节中，我们将向您展示将所有东西组合在一起并运行自定义TableGen后端的最后一步。
- en: Integrating the RecipePrinter TableGen backend
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成RecipePrinter TableGen后端
- en: After finishing the `utils/TableGen/RecipePrinter.cpp` file, it's time to put
    everything together.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`utils/TableGen/RecipePrinter.cpp`文件后，是时候将所有东西组合在一起了。
- en: As mentioned before, a TableGen backend is always associated with the `llvm-tblgen`
    tool, which is also the only interface to use the backend. `llvm-tblgen` uses
    simple command-line options to choose a backend to use.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个 TableGen 后端总是与 `llvm-tblgen` 工具相关联，这也是使用后端的唯一接口。`llvm-tblgen` 使用简单的命令行选项来选择要使用的后端。
- en: 'Here is an example of choosing one of the backends, `IntrInfoEmitter`, to generate
    a C/C++ header file from a `TableGen` file that carries instruction set information
    of `X86`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个选择其中一个后端，`IntrInfoEmitter`，从包含 `X86` 指令集信息的 `TableGen` 文件生成 C/C++ 头文件的例子：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s now see how to integrate `RecipePrinter` source file to `TableGen` backend:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将 `RecipePrinter` 源文件集成到 `TableGen` 后端：
- en: 'To link the `RecipePrinter` source file into `llvm-tblgen` and add a command-line
    option to select it, we''re going to use `utils/TableGen/TableGenBackends.h` first.
    This file only contains a list of TableGen backend entry functions, which are
    functions that take a `raw_ostream` output stream and the `RecordKeeper` object
    as arguments. We''re also putting our `EmitRecipe` function into the list, as
    follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 `RecipePrinter` 源文件链接到 `llvm-tblgen` 并添加一个命令行选项来选择它，我们首先使用 `utils/TableGen/TableGenBackends.h`。此文件仅包含一个
    TableGen 后端入口函数列表，这些函数接受一个 `raw_ostream` 输出流和 `RecordKeeper` 对象作为参数。我们还把我们的 `EmitRecipe`
    函数放入列表中，如下所示：
- en: '[PRE42]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, inside `llvm/utils/TableGen/TableGen.cpp`, we''re first adding a new
    `ActionType` enum element and the selected command-line option, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `llvm/utils/TableGen/TableGen.cpp` 中，我们首先添加一个新的 `ActionType` 枚举元素和选定的命令行选项，如下所示：
- en: '[PRE43]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After that, go to the `LLVMTableGenMain` function and insert the function call
    to `EmitRecipe`, as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，转到 `LLVMTableGenMain` 函数并插入对 `EmitRecipe` 函数的调用，如下所示：
- en: '[PRE44]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, don''t forget to update `utils/TableGen/CMakeLists.txt`, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，别忘了更新 `utils/TableGen/CMakeLists.txt`，如下所示：
- en: '[PRE45]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That''s all there is to it! You can now run the following command:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这些了！你现在可以运行以下命令：
- en: '[PRE46]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: =======Ingredients=======
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: =======成分=======
- en: 1\. oil 500 ml
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1\. 油 500 毫升
- en: 2\. flour 300 g
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2\. 面粉 300 克
- en: 3\. milk 1.25 cup
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3\. 牛奶 1.25 杯
- en: 4\. whole egg 1
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4\. 全蛋 1 个
- en: 5\. yeast 1.50 tsp
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5\. 酵母 1.50 茶匙
- en: 6\. butter 3.50 tbsp
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 6\. 黄油 3.50 汤匙
- en: 7\. sugar 2.0 tbsp
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 7\. 糖 2.0 汤匙
- en: 8\. salt 0.50 tsp
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8\. 盐 0.50 茶匙
- en: 9\. vanilla extract 1.0 tsp
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9\. 香草提取物 1.0 茶匙
- en: =======Instructions=======
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: =======说明=======
- en: 1\. use deep fryer to heat oil until 160 C
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1\. 使用深 fryer 将油加热至 160 C
- en: 2\. use mixer to mix flour, milk, whole egg, yeast, butter, sugar, salt, and
    vanilla extract. stir in low speed.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2\. 使用搅拌器将面粉、牛奶、全蛋、酵母、黄油、糖、盐和香草提取物混合。以低速搅拌。
- en: 3\. use mixer to mix outcome from (step 2). stir in medium speed.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3\. 使用搅拌器将步骤 2 的结果混合均匀，以中速搅拌。
- en: 4\. use bowl to ferment outcome from (step 3).
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4\. 使用碗将步骤 3 的结果发酵。
- en: 5\. use rolling pin to flatten outcome from (step 4).
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5\. 使用擀面杖将步骤 4 的结果擀平。
- en: 6\. use cutter to cut outcome from (step 5).
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 6\. 使用刀将步骤 5 的结果切割。
- en: 7\. use deep fryer to fry outcome from (step 1) and outcome from (step 6).
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 7\. 使用深 fryer 炸步骤 1 和步骤 6 的结果。
- en: '[PRE47]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this section, we have learned how to build a custom TableGen backend to transform
    a recipe written in TableGen into normal plaintext format. Things we learned here
    include how `llvm-tblgen`, the driver of translating TableGen code, works; how
    to use the TableGen backend's C++ APIs to operate TableGen directive's in-memory
    representation; and how to integrate our custom backend into `llvm-tblgen` in
    order to run it. Combining the skills you learned in this chapter and in the previous
    one, you can create a complete and standalone toolchain that implements your custom
    logic, using TableGen as a solution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何构建一个定制的 TableGen 后端，将用 TableGen 编写的配方转换为普通纯文本格式。我们学到的内容包括 `llvm-tblgen`，TableGen
    代码的驱动程序，是如何工作的；如何使用 TableGen 后端的 C++ API 操作 TableGen 指令的内存表示；以及如何将我们的自定义后端集成到
    `llvm-tblgen` 中以运行它。结合本章和上一章中学到的技能，你可以创建一个完整且独立的工具链，实现你的自定义逻辑，使用 TableGen 作为解决方案。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced TableGen, a powerful DSL for expressing structural
    data. We have shown you its universality in solving a variety of tasks, albeit
    it originally being created for compiler development. Through the lens of writing
    a donut recipe in TableGen, we have learned its core syntax. The following section
    on developing a custom TableGen backend taught you how to use C++ APIs to interact
    with in-memory TableGen directives parsed from the source input, giving you the
    power to create a complete and standalone TableGen toolchain to implement your
    own custom logic. Learning how to master TableGen can not only help your development
    in LLVM-related projects but also gives you more options to solve structural data
    problems in arbitrary projects.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 TableGen，这是一种用于表达结构化数据的强大 DSL。我们展示了它在解决各种任务中的通用性，尽管它最初是为编译器开发而创建的。通过在
    TableGen 中编写甜甜圈食谱的例子，我们学习了其核心语法。接下来的关于开发自定义 TableGen 后端的部分教了你如何使用 C++ API 与从源输入解析的内存中
    TableGen 指令交互，这赋予了你创建一个完整且独立的 TableGen 工具链以实现你自己的自定义逻辑的能力。学习如何掌握 TableGen 不仅可以帮助你在
    LLVM 相关项目中进行开发，还为你提供了更多在任意项目中解决结构化数据问题的选择。
- en: This section marks the end of the first part—an introduction to all kinds of
    useful supporting components in the LLVM project. Starting from the next chapter,
    we will move into the core compilation pipeline of LLVM. The first important topic
    we will cover is Clang, LLVM's official frontend for C-family programming languages.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本节标志着第一部分的结束——介绍了 LLVM 项目中各种有用的支持组件。从下一章开始，我们将进入 LLVM 的核心编译管道。我们将首先覆盖的第一个重要主题是
    Clang，它是 LLVM 为 C 家族编程语言提供的官方前端。
- en: Further reading
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'This LLVM page provides a good reference on the TableGen syntax: [https://llvm.org/docs/TableGen/ProgRef.html](https://llvm.org/docs/TableGen/ProgRef.html)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 LLVM 页面提供了关于 TableGen 语法的好参考：[https://llvm.org/docs/TableGen/ProgRef.html](https://llvm.org/docs/TableGen/ProgRef.html)
- en: 'This LLVM page provides a good reference on developing a TableGen backend:
    [https://llvm.org/docs/TableGen/BackGuide.html](https://llvm.org/docs/TableGen/BackGuide.html)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 LLVM 页面提供了关于开发 TableGen 后端的好参考：[https://llvm.org/docs/TableGen/BackGuide.html](https://llvm.org/docs/TableGen/BackGuide.html)
