["```cpp\n#include <pthread.h>\n#include <iostream>\n\nstruct ThreadInfo\n{\n    pthread_mutex_t lock;\n    int counter;\n};\n\nvoid* increment(void *arg)\n{\n    ThreadInfo* info = static_cast<ThreadInfo*>(arg);\n    pthread_mutex_lock(&info->lock);\n\n    std::cout << \"Thread Started ... \" << std::endl;\n    for (int i = 0; i < 100000; ++i)\n        info->counter++;\n    std::cout << \"Thread Finished ... \" << std::endl;\n\n    pthread_mutex_unlock(&info->lock);\n    return nullptr;\n}\n```", "```cpp\nint main()\n{\n    ThreadInfo thInfo;\n    thInfo.counter = 0;\n    if (pthread_mutex_init(&thInfo.lock, nullptr) != 0)\n    {\n        std::cout << \"pthread_mutex_init failed!\" << std::endl;\n        return 1;\n    }\n```", "```cpp\n    pthread_t t1;\n    if (pthread_create(&t1, nullptr, &increment, &thInfo) != 0)\n    {\n        std::cout << \"pthread_create for t1 failed! \" << std::endl;\n        return 2;\n    }\n\n    pthread_t t2;\n    if (pthread_create(&t2, nullptr, &increment, &thInfo) != 0)\n    {\n        std::cout << \"pthread_create for t2 failed! \" << std::endl;\n        return 3;\n    }\n```", "```cpp\n    pthread_join(t1, nullptr);\n    pthread_join(t2, nullptr);\n    std::cout << \"Threads elaboration finished. Counter = \" \n              << thInfo.counter << std::endl;\n    pthread_mutex_destroy(&thInfo.lock);\n    return 0;\n```", "```cpp\n#include <pthread.h>\n#include <semaphore.h>\n#include <iostream>\n\nstruct ThreadInfo\n{\n    sem_t sem;\n    int counter;\n};\n\nvoid* increment(void *arg)\n{\n    ThreadInfo* info = static_cast<ThreadInfo*>(arg);\n    sem_wait(&info->sem);\n\n    std::cout << \"Thread Started ... \" << std::endl;\n    for (int i = 0; i < 100000; ++i)\n        info->counter++;\n    std::cout << \"Thread Finished ... \" << std::endl;\n\n    sem_post(&info->sem);\n    return nullptr;\n}\n```", "```cpp\nint main()\n{\n    ThreadInfo thInfo;\n    thInfo.counter = 0;\n    if (sem_init(&thInfo.sem, 0, 1) != 0)\n    {\n        std::cout << \"sem_init failed!\" << std::endl;\n        return 1;\n    }\n```", "```cpp\npthread_t t1;\nif (pthread_create(&t1, nullptr, &increment, &thInfo) != 0)\n{\n    std::cout << \"pthread_create for t1 failed! \" << std::endl;\n    return 2;\n}\n\npthread_t t2;\nif (pthread_create(&t2, nullptr, &increment, &thInfo) != 0)\n{\n    std::cout << \"pthread_create for t2 failed! \" << std::endl;\n    return 3;\n}\n```", "```cpp\n    pthread_join(t1, nullptr);\n    pthread_join(t2, nullptr);\n\n    std::cout << \"posixSemaphore:: Threads elaboration\n        finished. Counter = \" \n              << thInfo.counter << std::endl;\n    sem_destroy(&thInfo.sem);\n    return 0;\n}\n```", "```cpp\n#include <pthread.h>\n#include <semaphore.h>\n#include <iostream>\n#include <vector>\n\nconstexpr auto MAX_ITEM_IN_QUEUE = 5;\n\nstruct QueueInfo\n{\n    sem_t mutex;\n    sem_t full;\n    sem_t empty;\n    std::vector<int> queue;\n};\n```", "```cpp\nvoid* producer(void *arg)\n{\n    QueueInfo* info = (QueueInfo*)arg;\n    std::cout << \"Thread Producer Started ... \" << std::endl;\n    for (int i = 0; i < 1000; i++)\n    {\n        sem_wait(&info->full);\n\n        sem_wait(&info->mutex);\n        info->queue.push_back(i);\n        std::cout << \"Thread Producer Started ... size = \" \n                  << info->queue.size() << std::endl;\n        sem_post(&info->mutex);\n\n        sem_post(&info->empty);\n    }\n    std::cout << \"Thread Producer Finished ... \" << std::endl;\n    return nullptr;\n}\n```", "```cpp\nvoid* consumer(void *arg)\n{\n    QueueInfo* info = (QueueInfo*)arg;\n    std::cout << \"Thread Consumer Started ... \" << std::endl;\n    for (int i = 0; i < 1000; i++)\n    {\n        sem_wait(&info->empty);\n\n        sem_wait(&info->mutex);\n        if (!info->queue.empty())\n        {\n            int b = info->queue.back();\n            info->queue.pop_back();\n        }\n        sem_post(&info->mutex);\n\n        sem_post(&info->full);\n    }\n    std::cout << \"Thread Consumer Finished ... \" << std::endl;\n    return nullptr;\n}\n```", "```cpp\nint main()\n{\n    QueueInfo thInfo;\n    if (sem_init(&thInfo.mutex, 0, 1) != 0 ||\n        sem_init(&thInfo.full, 0, MAX_ITEM_IN_QUEUE) != 0 ||\n        sem_init(&thInfo.empty, 0, 0) != 0)\n    {\n        std::cout << \"sem_init failed!\" << std::endl;\n        return 1;\n    }\n\n    pthread_t producerPthread;\n    if (pthread_create(&producerPthread, nullptr, &producer, \n        &thInfo) != 0)\n    {\n        std::cout << \"pthread_create for producer failed! \"\n            << std::endl;\n        return 2;\n    }\n    pthread_t consumerPthread;\n    if (pthread_create(&consumerPthread, nullptr, &consumer, \n        &thInfo) != 0)\n    {\n        std::cout << \"pthread_create for consumer failed! \"\n           << std::endl;\n        return 3;\n    }\n```", "```cpp\n    pthread_join(producerPthread, nullptr);\n    pthread_join(consumerPthread, nullptr);\n\n    sem_destroy(&thInfo.mutex);\n    sem_destroy(&thInfo.full);\n    sem_destroy(&thInfo.empty);\n    return 0;\n}\n```", "```cpp\n#include <iostream>\n#include <mutex>\n#include <thread>\n\nstruct ThreadInfo\n{\n    std::mutex mutex;\n    int counter;\n};\n\nvoid increment(ThreadInfo &info)\n{\n    std::lock_guard<std::mutex> lock(info.mutex);\n    std::cout << \"Thread Started ... \" << std::endl;\n\n    for (int i = 0; i < 100000; ++i)\n        info.counter++;\n\n    std::cout << \"Thread Finished ... \" << std::endl;\n}\n```", "```cpp\nint main()\n{\n    ThreadInfo thInfo;\n\n    std::thread t1 (increment, std::ref(thInfo));\n    std::thread t2 (increment, std::ref(thInfo));\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Threads elaboration finished. Counter = \" \n              << thInfo.counter << std::endl;\n    return 0;\n}\n```", "```cpp\n#include <iostream>\n#include <mutex>\n#include <thread>\nstruct ThreadInfo\n{\n    std::mutex mutex;\n    int counter;\n};\n\nvoid increment(ThreadInfo &info)\n{\n    std::unique_lock<std::mutex> lock(info.mutex);\n    std::cout << \"Thread Started ... \" << std::endl;\n    // This is a test so in a real scenario this is not be needed.\n    // it is to show that the developer here has the possibility to \n    // unlock the mutex manually.\n    // if (info.counter < 0)\n    // {\n    //    lock.unlock();\n    //    return;\n    // }\n    for (int i = 0; i < 100000; ++i)\n        info.counter++;\n    std::cout << \"unique_lock:: Thread Finished ... \" << std::endl;\n}\n```", "```cpp\nint main()\n{\n    ThreadInfo thInfo;\n\n    std::thread t1 (increment, std::ref(thInfo));\n    std::thread t2 (increment, std::ref(thInfo));\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"Unique_lock:: Threads elaboration finished. \n        Counter = \" \n              << thInfo.counter << std::endl;\n    return 0;\n}\n```", "```cpp\n#include <chrono>\nusing std::chrono::milliseconds;\n\nstd::timed_mutex timedMutex;\nstd::unique_lock<std::timed_mutex> lock {timedMutex, std::defer_lock};\nlock.try_lock_for(milliseconds{5});\n```", "```cpp\n#include <iostream>\n#include <future>\n\nstruct Item\n{\n    int age;\n    std::string nameCode;\n    std::string surnameCode;\n};\n\nvoid asyncProducer(std::promise<Item> &prom);\nvoid asyncConsumer(std::future<Item> &fut);\n```", "```cpp\nint main()\n{\n    std::promise<Item> prom;\n    std::future<Item> fut = prom.get_future();\n\n    std::async(asyncProducer, std::ref(prom));\n    std::async(asyncConsumer, std::ref(fut));\n\n    return 0;\n}\n```", "```cpp\nvoid asyncConsumer(std::future<Item> &fut)\n{\n    std::cout << \"Consumer ... got the result \" << std::endl;\n    Item item = fut.get();\n    std::cout << \"Age = \" << item.age << \" Name = \"\n        << item.nameCode\n              << \" Surname = \" << item.surnameCode << std::endl;\n}\n```", "```cpp\nvoid asyncProducer(std::promise<Item> &prom)\n{\n    std::cout << \"Producer ... computing \" << std::endl;\n\n    Item item;\n    item.age = 35;\n    item.nameCode = \"Jack\";\n    item.surnameCode = \"Sparrow\";\n\n    prom.set_value(item);\n}\n```", "```cpp\n#include <iostream>\n#include <queue>\n#include <condition_variable>\n#include <thread>\n\nstruct Item\n{\n    int age;\n    std::string name;\n    std::string surname;\n};\n\nstd::queue<Item> queue;\nstd::condition_variable cond;\nstd::mutex mut;\n\nvoid producer();\nvoid consumer();\n```", "```cpp\nint main()\n{\n    std::thread t1 (producer);\n    std::thread t2 (consumer);\n\n    t1.join();\n    t2.join();\n    return 0;\n}\n```", "```cpp\nvoid consumer()\n{\n    std::cout << \"Consumer ... \" << std::endl;\n    while(true)\n    {\n        std::unique_lock<std::mutex> lck{mut};\n        std::cout << \"Consumer ... loop ... START\" << std::endl;\n        cond.wait(lck);\n        // cond.wait(lck, []{ return !queue.empty();});\n        auto item = queue.front();\n        queue.pop();\n        std::cout << \"Age = \" << item.age << \" Name = \" \n                  << item.name << \" Surname = \" << item.surname\n                    << std::endl;\n        std::cout << \"Queue Size = \" << queue.size() << std::endl;\n        std::cout << \"Consumer ... loop ... END\" << std::endl;\n        lck.unlock();\n    }\n}\n```", "```cpp\nvoid producer()\n{\n    while(true)\n    {\n        Item item;\n        item.age = 35;\n        item.name = \"Jack\";\n        item.surname = \"Sparrow\";\n        std::lock_guard<std::mutex> lock {mut};\n        std::cout << \"Producer ... loop ... START\" << std::endl;\n        queue.push(item);\n        cond.notify_one();\n        std::cout << \"Producer ... loop ... END\" << std::endl;\n    }\n}\n```"]