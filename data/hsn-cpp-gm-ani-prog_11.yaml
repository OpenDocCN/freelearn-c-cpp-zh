- en: '*Chapter 11*: Optimizing the Animation Pipeline'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：优化动画管线'
- en: By now, you have written an entire animation system that can load a standard
    file format, gLTF, and perform skinning on either the CPU or GPU. The animation
    system performs well enough for most simple animations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经编写了一个完整的动画系统，可以加载标准文件格式gLT，并在CPU或GPU上执行皮肤。动画系统对于大多数简单的动画表现得足够好。
- en: In this chapter, you will explore the ways to optimize the animation system
    to make it faster and less resource-intensive. This involves exploring alternative
    ways to perform skinning, improving the speed of sample animation clips, and revisiting
    how matrix palettes are generated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将探讨优化动画系统的方法，使其更快且资源消耗更少。这涉及探索执行皮肤的替代方法，提高采样动画片段的速度，并重新审视如何生成矩阵调色板。
- en: Each of these topics is explored on its own, and you can choose to implement
    as few or as many of these optimizations as you wish. All of them are simple and
    can be used to replace a less optimal version of the pipeline with ease.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题都是单独探讨的，您可以选择实现尽可能少或尽可能多的这些优化。所有这些都很简单，可以轻松地用来替换不太优化的管线版本。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Pre-generating the skin matrix
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预生成皮肤矩阵
- en: Storing the skin pallette in a texture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将皮肤调色板存储在纹理中
- en: Faster sampling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的采样
- en: The Pose palette generation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姿势调色板生成
- en: Exploring `Pose::GetGlobalTransform`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索`Pose::GetGlobalTransform`
- en: Pre-generating the skin matrix
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预生成皮肤矩阵
- en: One of the bigger problems with `mat4` object takes up four uniform slots and
    the skinned vertex shader currently has two matrix arrays that have 120 elements
    each. That comes to a total of 960 uniform slots, which is excessive.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`mat4`对象的一个较大问题是占用了四个统一槽位，而经过处理的顶点着色器目前有两个具有120个元素的矩阵数组。总共是960个统一槽位，这是过多的。'
- en: 'What happens with those two matrix arrays in the vertex shader? They get multiplied
    together, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器中的这两个矩阵数组会发生什么？它们会相互相乘，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One easy optimization here is to combine the `pose * invBindPose` multiplication
    so that the shader only needs one array. This does mean that some of the skinning
    process is moved back to the CPU, but this change clears up 480 uniform slots.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个简单优化是将`pose * invBindPose`相乘，以便着色器只需要一个数组。这确实意味着一些皮肤过程被移回到了CPU，但这个改变清理了480个统一槽位。
- en: Generating the skin matrix
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成皮肤矩阵
- en: Generating the skin matrix doesn't need an API call—it's simple. Generate a
    matrix palette from the current animated pose using the `GetMatrixPalette` function
    of the `Pose` class. Then, multiply each matrix in the palette by the inverse
    bind pose matrix of the same index.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 生成皮肤矩阵不需要API调用-它很简单。使用`Pose`类的`GetMatrixPalette`函数从当前动画姿势生成矩阵调色板。然后，将调色板中的每个矩阵与相同索引的逆绑定姿势矩阵相乘。
- en: 'It''s the responsibility of the code that displays the mesh to calculate these
    matrices. For example, a simple update loop might look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显示网格的代码负责计算这些矩阵。例如，一个简单的更新循环可能如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code sample, an animation clip was sampled into a pose. The
    pose was converted into a vector of matrices. Each matrix in that vector was then
    multiplied by the inverse bind pose matrix of the same index. The resulting vector
    of matrices is the combined skin matrix.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，动画片段被采样到一个姿势中。姿势被转换为矩阵向量。该向量中的每个矩阵然后与相同索引的逆绑定姿势矩阵相乘。结果的矩阵向量就是组合的皮肤矩阵。
- en: If the mesh is CPU skinned, this is a good place to call the `CPUSkin` function.
    This function needs to be re-implemented to work with a combined skin matrix.
    If the mesh is GPU skinned, the shader needs to be edited so that it only uses
    one matrix array, and the rendering code needs to be updated to only pass one
    uniform array.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网格是CPU皮肤，这是调用`CPUSkin`函数的好地方。这个函数需要重新实现以适应组合的皮肤矩阵。如果网格是GPU皮肤，需要编辑着色器以便只使用一个矩阵数组，并且需要更新渲染代码以便只传递一个统一数组。
- en: In the following section, you will explore how to re-implement the `CPUSkin`
    function so that it works with the combined skin matrix. This will speed up the
    CPU skinning process a little bit.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，您将探讨如何重新实现`CPUSkin`函数，使其与组合的皮肤矩阵一起工作。这将稍微加快CPU皮肤过程。
- en: CPU skinning
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU皮肤
- en: You need a new skinning method that respects the pre-multiplied skin matrix.
    This function takes a reference to a vector of matrices. Each position is transformed
    by the combined skin matrix of all four of the bones that affect it. Those four
    results are then scaled and added together.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一种新的皮肤方法，该方法尊重预乘的皮肤矩阵。此函数接受一个矩阵向量的引用。每个位置都由影响它的四个骨骼的组合皮肤矩阵进行变换。然后，这四个结果被缩放并相加。
- en: 'Add the following CPU skinning function to `Mesh.cpp`. Don''t forget to add
    the function declaration to `Mesh.h`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下CPU皮肤函数添加到`Mesh.cpp`。不要忘记将函数声明添加到`Mesh.h`中：
- en: 'Start implementing the `CPUSkin` function by making sure the mesh is valid.
    A valid mesh has at least one vertex. Make sure that the `mSkinnedPosition` and
    `mSkinnedNormal` vectors are large enough to hold all the vertices:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过确保网格有效来开始实现`CPUSkin`函数。有效的网格至少有一个顶点。确保`mSkinnedPosition`和`mSkinnedNormal`向量足够大，可以容纳所有顶点：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, loop through every vertex in the mesh:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，循环遍历网格中的每个顶点：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Transform each vertex by the animated pose four times—once for each joint that
    influences the vertex. To find the skinned vertex, scale each of the transformed
    vertices by the appropriate weight and add together the results:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个顶点按动画姿势变换四次，即每个影响顶点的关节变换一次。要找到经过处理的顶点，请将每个变换后的顶点按适当的权重进行缩放并将结果相加：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Find the skinned normal of the vertex in the same way:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式找到顶点的经过处理的法线：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finish off the function by uploading the skinned vertex positions and the skinned
    vertex normals to the position and normal attributes:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将经过处理的顶点位置和经过处理的顶点法线上传到位置和法线属性来完成函数：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The core skinning algorithm remains the same; the only thing that changes is
    how the transformed position is generated. Instead of having to combine the animated
    pose and the inverse bind pose, this function can now just use the already-combined
    matrix.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 核心的皮肤算法保持不变；唯一改变的是如何生成变换后的位置。现在，这个函数可以直接使用已经组合好的矩阵，而不必再组合动画姿势和逆绑定姿势。
- en: In the next section, you will explore how to move this skinning function into
    a vertex shader. Combining the animated and inverse bind poses is still done on
    the CPU, but skinning the actual vertices can be implemented in a vertex shader.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将探索如何将这个皮肤函数移入顶点着色器。动画和逆绑定姿势的组合仍然在CPU上完成，但实际顶点的皮肤可以在顶点着色器中实现。
- en: GPU skinning
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPU皮肤
- en: Implementing pre-multiplied skin-matrix skinning in a vertex shader is simple.
    Replace the input uniforms for the pose and inverse bind pose with the new pre-multiplied
    skin pose. Generate the skin matrix using this new uniform array. That's all there
    is to it—the rest of the skinning pipeline remains unchanged.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中实现预乘皮肤矩阵皮肤很简单。用新的预乘皮肤姿势替换姿势和逆绑定姿势的输入统一变量。使用这个新的统一数组生成皮肤矩阵。就是这样——其余的皮肤流程保持不变。
- en: 'Create a new file, `preskinned.vert`, to implement the new pre-skinned vertex
    shader in. Copy the contents of `skinned.vert` into this new file. Follow these
    steps to modify the new shader:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`preskinned.vert`，来实现新的预皮肤顶点着色器。将`skinned.vert`的内容复制到这个新文件中。按照以下步骤修改新的着色器：
- en: 'The old skinned vertex shader has uniforms for pose and inverse bind pose.
    Both uniforms are arrays of matrices. Remove these uniforms:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧的皮肤顶点着色器具有姿势和逆绑定姿势的统一变量。这两个统一变量都是矩阵数组。删除这些统一变量：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Replace them with the new `animated` uniform. This is a single array of matrices
    and each element in the array contains the `animated` pose and the inverse bind
    pose matrices multiplied together:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用新的`animated`统一替换它们。这是一个矩阵数组，数组中的每个元素都包含`animated`姿势和逆绑定姿势矩阵相乘的结果。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, find where the skin matrix is generated. The code for generating the
    skin matrix looks like this:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，找到生成皮肤矩阵的位置。生成皮肤矩阵的代码如下：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace this with the new `animated` uniform. For each joint that affects the
    vertex, scale the `animated` uniform matrix by the appropriate weight and sum
    the results:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用新的`animated`统一替换这个。对于影响顶点的每个关节，按适当的权重缩放`animated`统一矩阵并求和结果：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The rest of the shader stays the same. The only thing you need to update is
    the uniforms that the shader takes and how the `skin` matrix is generated. When
    rendering, the `animated` matrix can be set as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的其余部分保持不变。您需要更新的唯一内容是着色器接受的统一变量以及如何生成`skin`矩阵。在渲染时，`animated`矩阵可以设置如下：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may have noticed that the CPU skinning implementation and the GPU skinning
    implementation are different. The CPU implementation transforms the vertex four
    times, then scales and sums the results. The GPU implementation scales and sums
    the matrices and only transforms the vertex once. Both implementations are valid
    and they both produce the same results.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到CPU皮肤实现和GPU皮肤实现是不同的。CPU实现将顶点转换四次，然后缩放和求和结果。GPU实现缩放和求和矩阵，只转换顶点一次。这两种实现都是有效的，它们都产生相同的结果。
- en: In the following section, you will explore how to avoid using uniform matrix
    arrays for skinning.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，您将探索如何避免使用统一矩阵数组进行皮肤。
- en: Storing the skin palette in a texture
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在纹理中存储皮肤调色板
- en: Pre-generating the skin matrix cuts the number of uniform slots that the skinned
    shader needs in half, but it's possible to reduce the number of uniform slots
    needed to just one. This can be done by encoding the pre-generated skin matrix
    in a texture and reading that texture in the vertex shader instead of in a uniform
    array.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 预生成的皮肤矩阵可以减少所需的统一槽数量，但可以将所需的统一槽数量减少到一个。这可以通过在纹理中编码预生成的皮肤矩阵并在顶点着色器中读取该纹理来实现。
- en: So far in this book, you have only dealt with the `RGB24` and `RGBA32` textures.
    In these formats, the three or four components of a pixel are encoded using 8
    bits per component. This can only hold 256 unique values. These textures do not
    provide the amount of precision needed to store floating-point numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，您只处理了`RGB24`和`RGBA32`纹理。在这些格式中，每个像素的三个或四个分量使用每个分量8位编码。这只能容纳256个唯一值。这些纹理无法提供存储浮点数所需的精度。
- en: There is another texture format that can be useful here—a `FLOAT32` texture.
    With this texture format, each component of a vector gets a full 32-bit floating-point
    number to back it, giving you full precision. This texture can be sampled with
    a special sampler function that doesn't normalize the data. The `FLOAT32` texture
    can be treated as a buffer that the CPU can write to and the GPU can read from.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一种可能有用的纹理格式——`FLOAT32`纹理。使用这种纹理格式，向量的每个分量都得到一个完整的32位浮点数支持，给您完整的精度。这种纹理可以通过一个特殊的采样器函数进行采样，该函数不对数据进行归一化。`FLOAT32`纹理可以被视为CPU可以写入而GPU可以读取的缓冲区。
- en: The benefit of this method is that the number of required uniform slots becomes
    just one—the uniform slot that is needed is the sampler for the `FLOAT32` texture.
    The downside is speed. Having to sample a texture for every vertex is more expensive
    than a quick uniform array lookup. Remember, each of these sample lookups needs
    to return several 32-bit floating-point numbers. That is a lot of data to transfer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处是所需的统一槽数量变成了一个——所需的统一槽是`FLOAT32`纹理的采样器。缺点是速度。对每个顶点进行纹理采样比快速统一数组查找更昂贵。请记住，每次采样查找都需要返回几个32位浮点数。这是大量的数据要传输。
- en: We will not cover the implementation of a texture to store the skin matrices
    here, as there is a large section dedicated to that topic in *Chapter 15*, *Rendering
    Large Crowds with Instancing*, which includes the full code implementation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里涵盖存储皮肤矩阵的纹理的实现，因为在*第15章*“使用实例渲染大规模人群”中有一个专门讨论这个主题的大节，其中包括完整的代码实现。
- en: Faster sampling
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的采样
- en: 'The current animation-clip sampling code performs well, so long as each animation
    lasts under 1 second. With multiple minute-long animation clips, such as a cutscene,
    the animation system''s performance starts to suffer. Why does the performance
    worsen with longer animations? The culprit is the following bit of code in the
    `Track::FrameIndex` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的动画剪辑采样代码表现良好，只要每个动画持续时间不超过1秒。但是，对于多个长达一分钟的动画剪辑，比如过场动画，动画系统的性能开始受到影响。为什么随着动画时间的增长性能会变差呢？罪魁祸首是`Track::FrameIndex`函数中的以下代码：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The presented loop goes through every frame in the track. If an animation has
    a lot of frames, the performance starts to get worse. Remember, this bit of code
    is executed for each animated component of each animated bone in an animation
    clip.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的循环遍历了轨道中的每一帧。如果动画有很多帧，性能就会变差。请记住，这段代码是针对动画剪辑中每个动画骨骼的每个动画组件执行的。
- en: This function currently does a linear search, but it can be optimized with a
    more efficient search. Since time only ever increases, performing a binary search
    is a natural optimization to use here. However, binary search isn't the best optimization.
    It's possible to turn this loop into a constant lookup.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数目前进行的是线性搜索，但可以通过更有效的搜索进行优化。由于时间只会增加，执行二分搜索是一个自然的优化。然而，二分搜索并不是最好的优化方法。可以将这个循环转换为常量查找。
- en: Sampled animations have a uniform cost to play back, regardless of length. They
    time every frame at a known sampling interval, and finding the correct frame index
    is just a matter of normalizing the provided time and moving it into the sampled
    interval range. Unfortunately, sampling an animation such as this takes up a lot
    of memory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 采样动画的播放成本是统一的，不受长度的影响。它们在已知的采样间隔时间内计时每一帧，并且找到正确的帧索引只是将提供的时间归一化并将其移动到采样间隔范围内。不幸的是，这样的动画采样占用了大量内存。
- en: What if you still sampled the animation track at given intervals, but instead
    of containing a full pose, each interval points to the keyframes that are to its
    left and right? With this approach, the additional memory overhead is minimal
    and finding the correct frame is constant.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然按照给定的间隔对动画轨道进行采样，但是每个间隔不再包含完整的姿势，而是指向其左右的关键帧呢？采用这种方法，额外的内存开销是最小的，找到正确的帧是恒定的。
- en: Optimizing the Track class
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化Track类
- en: There are two ways to handle optimizing the `Track` class. You can either create
    a new class that has most of the `Track` class's functionality and maintains a
    lookup table for known sample times or extend the `Track` class. This section
    takes the latter approach—we will extend the `Track` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以优化`Track`类。你可以创建一个具有大部分`Track`类功能并维护已知采样时间的查找表的新类，或者扩展`Track`类。本节采用后一种方法——我们将扩展`Track`类。
- en: The `FastTrack` subclass contains a vector of unsigned integers. The `Track`
    class is sampled at uniform time intervals. For each time interval, the frame
    on the left of the play head (the frame right before time) is recorded into this
    vector.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`FastTrack`子类包含一个无符号整数向量。`Track`类以统一的时间间隔进行采样。对于每个时间间隔，播放头左侧的帧（即时间之前的帧）被记录到这个向量中。'
- en: 'All new code is added to the existing `Track.h` and `Track.cpp` files. Follow
    these steps to implement the `FastTrack` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新代码都添加到现有的`Track.h`和`Track.cpp`文件中。按照以下步骤实现`FastTrack`类：
- en: 'Find the `FrameIndex` member function of the `Track` class and mark it as `virtual`.
    This change allows the new subclass to re-implement the `FrameIndex` function.
    The updated declaration should look like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`Track`类的`FrameIndex`成员函数，并将其标记为`virtual`。这个改变允许新的子类重新实现`FrameIndex`函数。更新后的声明应该是这样的：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new class, `FastTrack`, that inherits from `Track`. The `FastTrack`
    class contains a vector of unsigned integers—the overloaded `FrameIndex` function
    and a function to populate the vector of unsigned integers:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新类`FastTrack`，它继承自`Track`。`FastTrack`类包含一个无符号整数向量，重载的`FrameIndex`函数和一个用于填充无符号整数向量的函数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To make the `FastTrack` class easier to work with, use typedef to create aliases
    for scalar, vector and quaternion types:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`FastTrack`类更易于使用，使用typedef为标量、向量和四元数类型创建别名：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the .`cpp` file, add a template declaration for the scalar, vector, and
    quaternion fast tracks:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中，为标量、向量和四元数的快速轨道添加模板声明：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the `FastTrack` class is a subclass of `Track`, the existing APIs all
    work unchanged. The performance gain from implementing track sampling this way
    is greater when the animation in question has more frames. In the next section,
    you will learn how to build the index lookup table.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FastTrack`类是`Track`的子类，现有的API都可以不变地工作。通过以这种方式实现轨道采样，当涉及的动画帧数更多时，性能提升更大。在下一节中，你将学习如何构建索引查找表。
- en: Implementing UpdateIndexLookupTable
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现UpdateIndexLookupTable
- en: The `UpdateIndexLookupTable` function is responsible for populating the `mSampledFrames`
    vector. This function needs to sample the animation at fixed time intervals and
    record the frame before the animation time for each interval.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateIndexLookupTable`函数负责填充`mSampledFrames`向量。这个函数需要以固定的时间间隔对动画进行采样，并记录每个间隔的动画时间之前的帧。'
- en: 'How many samples should the `FastTrack` class contain? This question is very
    context-dependent as different games have different requirements. For the context
    of this book, 60 samples per second should be enough:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`FastTrack`类应包含多少个样本？这个问题非常依赖于上下文，因为不同的游戏有不同的要求。对于本书的上下文来说，每秒60个样本应该足够了：'
- en: 'Start implementing the `UpdateIndexLookupTable` function by making sure that
    the track is valid. A valid track will have at least two frames:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过确保轨道有效来开始实现`UpdateIndexLookupTable`函数。有效的轨道至少有两帧：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, find the number of samples that are needed. Since the class has `60`
    samples for every second of animation, multiply the duration by `60`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，找到所需的样本数。由于每秒动画类有`60`个样本，将持续时间乘以`60`：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For each sample, find the time of the sample along the track. To find the time,
    multiply the normalized iterator by the animation duration and add the start time
    of the animation to it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个样本，找到沿着轨道的样本时间。要找到时间，将标准化迭代器乘以动画持续时间，并将动画的起始时间加上去：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, it''s time to find the frame index for each given time. Find the frame
    that comes before the sampling time for this iteration and record it in the `mSampledFrames`
    vector. If the sampled frame is the last frame, return the index right before
    the last index. Remember, the `FrameIndex` function should never return the last
    frame:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候为每个给定的时间找到帧索引了。找到在此迭代中采样时间之前的帧，并将其记录在`mSampledFrames`向量中。如果采样帧是最后一帧，则返回最后一个索引之前的索引。请记住，`FrameIndex`函数永远不应返回最后一帧：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `UpdateIndexLookupTable` function is intended to be called at load time.
    It could be optimized to be faster by remembering the last used index of the inner
    `j` loop since, on each `i` iteration, the frame index only increases. In the
    next section, you will learn how to implement `FrameIndex` to use the `mSampledFrames`
    vector.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateIndexLookupTable`函数旨在在加载时调用。通过记住内部`j`循环的上次使用的索引，可以优化它，因为在每次`i`迭代时，帧索引只会增加。在下一节中，您将学习如何实现`FrameIndex`以使用`mSampledFrames`向量。'
- en: Implementing FrameIndex
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现FrameIndex
- en: 'The `FrameIndex` function is responsible for finding the frame right before
    a given time. The optimized `FastTrack` class uses a lookup array instead of looping
    through every frame of the track. All input times have a very similar performance
    cost. Follow these steps to override the `FrameIndex` function in the `FastTrack`
    class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameIndex`函数负责找到给定时间之前的帧。优化的`FastTrack`类使用查找数组而不是循环遍历轨道的每一帧。所有输入时间的性能成本非常相似。按照以下步骤重写`FastTrack`类中的`FrameIndex`函数：'
- en: 'Start implementing the `FrameIndex` function by making sure that the track
    is valid. A valid track must have at least two or more frames:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过确保轨道有效来开始实现`FrameIndex`函数。有效的轨道必须至少有两帧或更多：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, make sure the requested sample time falls between the start and end times
    of the track. If the track is looping, use `fmodf` to keep it in a valid range:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保请求的采样时间落在轨道的起始时间和结束时间之间。如果轨道循环，使用`fmodf`来保持在有效范围内：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the track is not looping, clamp to the first or next to last frame:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果轨道不循环，将其夹紧到第一帧或倒数第二帧：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Find the normalized sample time and frame index. The frame index is the normalized
    sample time scaled by the number of samples. If the index is invalid, return `-1`;
    otherwise, return the frame that the index points to:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到标准化的采样时间和帧索引。帧索引是标准化的采样时间乘以样本数。如果索引无效，则返回`-1`；否则返回索引指向的帧：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `FrameIndex` function is almost always called with a valid time since it's
    a protected helper function. This means the time it takes to find the index of
    a frame is uniform, regardless of the number of frames in the track. In the next
    section, you will learn how to convert an unoptimized `Track` class into an optimized
    `FastTrack` class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameIndex`函数几乎总是在有效时间调用，因为它是一个受保护的辅助函数。这意味着找到帧索引所需的时间是均匀的，不管轨道中有多少帧。在下一节中，您将学习如何将未优化的`Track`类转换为优化的`FastTrack`类。'
- en: Converting tracks
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换轨道
- en: 'Now that `FastTrack` exists, how do you create it? You could either create
    a new load function that loads a `FastTrack` class instead of `Track`. Alternatively,
    you could create a function that converts an existing `Track` class into a `FastTrack`
    class. This chapter takes the latter approach. Follow these steps to create a
    function that converts the `Track` objects into the `FastTrack` objects:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`FastTrack`存在了，如何创建它呢？您可以创建一个新的加载函数，加载`FastTrack`类而不是`Track`。或者，您可以创建一个将现有的`Track`类转换为`FastTrack`类的函数。本章采用后一种方法。按照以下步骤创建一个将`Track`对象转换为`FastTrack`对象的函数：
- en: 'Declare the `OptimizeTrack` function in `FastTrack.h`. The function is templated.
    It takes the same template types as `Track`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FastTrack.h`中声明`OptimizeTrack`函数。该函数是模板化的。它接受与`Track`相同的模板类型：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Declare the template specializations of the `OptimizeTrack` function for all
    three types that track to `FastTrack.cpp`. This means declaring specializations
    that work with the scalar, vector 3, and quaternion tracks:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FastTrack.cpp`中声明`OptimizeTrack`函数的模板特化，以适用于跟踪到`FastTrack`的所有三种类型。这意味着声明适用于标量、三维向量和四元数轨道的特化：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To implement the `OptimizeTrack` function, resize the resulting track so that
    it is the same size as the input track and match the interpolation. The overloaded
    `[]` operator function can be used to copy the per-frame data:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`OptimizeTrack`函数，调整结果轨道的大小，使其与输入轨道的大小相同并匹配插值。可以使用重载的`[]`运算符函数来复制每帧的数据：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It's not enough to just optimize the `Track` class into `FastTrack`. The `TransformTrack`
    class needs to change as well. It needs to contain the new, optimized `FastTrack`
    class. In the next section, you will change the `TransformTrack` class so that
    it is templated and can contain either `Track` or `FastTrack`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅将`Track`类优化为`FastTrack`还不够。`TransformTrack`类也需要改变。它需要包含新的、优化的`FastTrack`类。在下一节中，您将更改`TransformTrack`类，使其成为模板，并且可以包含`Track`或`FastTrack`。
- en: Creating FastTransformTrack
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建FastTransformTrack
- en: Higher-level structures that use the `Track` class, such as `TransformTrack`,
    need to accommodate for the new `FastTrack` subclass. The `FastTrack` class has
    the same signature as the `Track` class. Because the signature of the class is
    the same, it's easy to template the `TransformTrack` class so that it can use
    either of these classes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Track`类的高级结构，如`TransformTrack`，需要适应新的`FastTrack`子类。`FastTrack`类与`Track`类具有相同的签名。因为类的签名相同，很容易将`TransformTrack`类模板化，以便它可以使用这两个类中的任何一个。
- en: 'In this section, you will rename the `TransformTrack` class to `TTransformTrack`
    and template the class. Then, you will `typedef` template specializations as `TransformTrack`
    and `FastTransformTrack`. This way, the `TransformTrack` class stays the same
    and the optimized transform track uses all the same code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将把`TransformTrack`类的名称更改为`TTransformTrack`并对类进行模板化。然后，您将将模板特化typedef为`TransformTrack`和`FastTransformTrack`。这样，`TransformTrack`类保持不变，优化的变换轨迹使用相同的代码：
- en: 'Change the name of the `TransformTrack` class to `TTransformTrack` and template
    the class. The template takes two arguments—the type of vector track and the type
    of quaternion track to use. Update the `mPosition`, `mRotation`, and `mScale`
    tracks to use the new templated types:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TransformTrack`类的名称更改为`TTransformTrack`并对类进行模板化。模板接受两个参数——要使用的矢量轨迹的类型和四元数轨迹的类型。更新`mPosition`、`mRotation`和`mScale`轨迹以使用新的模板类型：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Typedef this class into `TransformTrack`, with `VectorTrack` and `QuaternionTrack`
    for arguments. Typedef it again into `FastTransformTrack`, with `FastVectorTrack`
    and `FastQuaternionTrack` as template arguments:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个类typedef为`TransformTrack`，使用`VectorTrack`和`QuaternionTrack`作为参数。再次将其typedef为`FastTransformTrack`，使用`FastVectorTrack`和`FastQuaternionTrack`作为模板参数：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare the optimization function that converts `TransformTrack` into `FastTransformTrack`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明将`TransformTrack`转换为`FastTransformTrack`的优化函数：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add template specifications for both `typedef` functions in `TransformTrack.cpp`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TransformTrack.cpp`中为`typedef`函数添加模板规范：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the `OptimizeTransformTrack` function. Copy the track ID, then copy
    the individual tracks by value:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`OptimizeTransformTrack`函数。复制轨迹ID，然后通过值复制各个轨迹：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because `OptimizeTransformTrack` copies the actual track data by value, it can
    be a little slow. This function is intended to be called during initialization.
    In the next section, you will template the `Clip` class, similar to how you did
    with the `Transform` class, to create `FastClip`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`OptimizeTransformTrack`通过值复制实际轨迹数据，所以它可能会有点慢。这个函数打算在初始化时调用。在下一节中，您将对`Clip`类进行模板化，类似于您对`Transform`类的操作，以创建`FastClip`。
- en: Creating FastClip
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建FastClip
- en: 'The user of this animation system interacts with the `Clip` objects. To accommodate
    the new `FastTrack` class, the `Clip` class is similarly templated and split into
    `Clip` and `FastClip`. You will implement a function to convert the `Clip` objects
    into the `FastClip` objects. Follow these steps to template the `Clip` class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画系统的用户与`Clip`对象进行交互。为了适应新的`FastTrack`类，`Clip`类同样被模板化并分成了`Clip`和`FastClip`。您将实现一个函数来将`Clip`对象转换为`FastClip`对象。按照以下步骤对`Clip`类进行模板化：
- en: 'Change the name of the `Clip` class to `TClip` and template the class. The
    template only takes one type—the type of transform track that the `TClip` class
    contains. Change the type of `mTracks` and the return type of `[] operator` so
    that it is the template type:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Clip`类的名称更改为`TClip`并对类进行模板化。模板只接受一种类型——`TClip`类包含的变换轨迹的类型。更改`mTracks`的类型和`[]
    operator`的返回类型，使其成为模板类型：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Typedef  `TClip` with a `TransformTrack` type as `Clip`. Typedef `TClip` with
    a `FastTransformTrack` type as `FastClip`. This way, the `Clip` class doesn''t
    change and the `FastClip` class can reuse all the existing code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TransformTrack`类型将`TClip`typedef为`Clip`。使用`FastTransformTrack`类型将`TClip`typedef为`FastClip`。这样，`Clip`类不会改变，而`FastClip`类可以重用所有现有的代码：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Declare a function to convert a `Clip` object into a `FastClip` object:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个将`Clip`对象转换为`FastClip`对象的函数：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Declare template specializations of these typedefed classes in `Clip.cpp`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Clip.cpp`中声明这些typedef类的模板特化：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To implement the `OptimizeClip` function, copy the name and looping value of
    the input clip. For each joint in the clip, call the `OptimizeTransformTrack`
    function on its track. Don''t forget to calculate the duration of the new `FastClip`
    object before returning a copy of it:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`OptimizeClip`函数，复制输入剪辑的名称和循环值。对于剪辑中的每个关节，调用其轨迹上的`OptimizeTransformTrack`函数。在返回副本之前，不要忘记计算新的`FastClip`对象的持续时间：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As with the rest of the conversion functions, `OptimizeClip` is only intended
    to be called at initialization time. In the following section, you will explore
    how to optimize the `Pose` palette generation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他转换函数一样，`OptimizeClip`只打算在初始化时调用。在接下来的部分，您将探讨如何优化`Pose`调色板的生成。
- en: The Pose palette generation
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 姿势调色板生成
- en: 'The final optimization you should think about is the process of generating
    a matrix palette from `Pose`. If you look at the `Pose` class, the following bit
    of code converts a pose into a linear array of matrices:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该考虑的最终优化是从`Pose`生成矩阵调色板的过程。如果您查看`Pose`类，下面的代码将一个姿势转换为矩阵的线性数组：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By itself, this function isn't too bad, but the `GetGlobalTransform` function
    loops through every joint all the way up the specified joints transform chain
    until the root joint. This means the function wastes a considerable amount of
    time finding matrices for transforms that it has already found the matrices for
    during a previous iteration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 单独看，这个函数并不太糟糕，但`GetGlobalTransform`函数会循环遍历每个关节，一直到根关节的指定关节变换链。这意味着该函数会浪费大量时间来查找在上一次迭代期间已经找到的变换矩阵。
- en: To fix this, you need to make sure that the order of the joints in the `Pose`
    class is ascending. That is, all the parent joints must have a lower index than
    their child joints in the `mJoints` array.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，您需要确保`Pose`类中关节的顺序是升序的。也就是说，所有父关节在`mJoints`数组中的索引必须低于它们的子关节。
- en: Once this order is set, you can iterate through all the joints and know that
    the parent matrix of the joint at the current index has already been found. This
    is because all the parent elements have a lower index than their children. To
    combine the local matrix of this joint with the global matrix of its parent joint,
    you just have to multiply the previously found world matrix and local matrix together.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了这个顺序，你可以遍历所有的关节，并知道当前索引处的关节的父矩阵已经找到。这是因为所有的父元素的索引都比它们的子节点小。为了将该关节的局部矩阵与其父关节的全局矩阵合并，你只需要将之前找到的世界矩阵和局部矩阵相乘。
- en: There is no guarantee that the input data can be trusted to have the joints
    listed in this specific order. To fix this, you need to write some code to re-arrange
    the joints of a `Pose` class. In the next section, you will learn how to improve
    the `GetMatrixPalette` function so that it uses the optimized method if it can
    and falls back to the unoptimized method if it can't.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不能保证输入数据可以信任地按照特定顺序列出关节。为了解决这个问题，你需要编写一些代码来重新排列`Pose`类的关节。在下一节中，你将学习如何改进`GetMatrixPalette`函数，使其在可能的情况下使用优化的方法，并在不可能的情况下退回到未优化的方法。
- en: Changing the GetMatrixPalette function
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变GetMatrixPalette函数
- en: In this section, you will modify the `GetMatrixPalette` function to pre-cache
    global matrices if the parent index of the current joint is lower than the joint.
    If this assumption is ever broken, the function needs to fall back into the slower
    calculation mode.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将修改`GetMatrixPalette`函数，以便在当前关节的父索引小于关节时预缓存全局矩阵。如果这个假设被打破，函数需要退回到更慢的计算模式。
- en: There will be two loops in the `GetMatrixPalette` function. The first loop finds
    and stores the global matrix of a transform. If the joint parent has a smaller
    index than the joint, the optimized method is used. If the joint's parent isn't
    smaller, the first loop breaks out and gives the second loop a chance to run.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMatrixPalette`函数中将有两个循环。第一个循环找到并存储变换的全局矩阵。如果关节的父节点索引小于关节，就使用优化的方法。如果关节的父节点不小，第一个循环中断，并给第二个循环一个运行的机会。'
- en: 'In this second loop, each joint falls back to calling the slow `GetWorldTransform`
    function to find its world transforms. This loop is the fallback code used if
    the optimized loop fails. If the optimized loop executes all the way, this second
    loop isn''t executed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个循环中，每个关节都会退回到调用缓慢的`GetWorldTransform`函数来找到它的世界变换。如果优化的循环执行到最后，这个第二个循环就不会执行：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This change adds very minimal overhead to the `GetMatrixPalette` function but
    quickly makes up for that. It makes the matrix palette calculations run fast,
    if possible, but still execute if not possible. In the following section, you
    will learn how to re-arrange the joints of a loaded model to make the `GetMatrixPalette`
    function always take the fast path.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变对`GetMatrixPalette`函数的开销非常小，但很快就能弥补。它使得矩阵调色板计算运行快速，如果可能的话，但即使不可能也会执行。在接下来的部分，你将学习如何重新排列加载模型的关节，以便`GetMatrixPalette`函数始终采用快速路径。
- en: Reordering joints
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新排序关节
- en: Not all models will be well formatted; because of this, they won't all be able
    to take advantage of the optimized `GetMatrixPalette` function. In this section,
    you will learn how to re-arrange the bones of a model so that it can take advantage
    of the optimized `GetMatrixPalette` function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的模型都会格式良好；因此，它们不都能够利用优化的`GetMatrixPalette`函数。在本节中，你将学习如何重新排列模型的骨骼，以便它可以利用优化的`GetMatrixPalette`函数。
- en: Create a new file, `RearrangeBones.h`. Use a dictionary whose keyvalue pairs
    are bone indices to remapped bone indices. The `RearrangeSkeleton` function generates
    this dictionary and rearranges the bind, inverse bind, and rest poses in the skeleton.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`RearrangeBones.h`。使用一个字典，其键值对是骨骼索引和重新映射的骨骼索引。`RearrangeSkeleton`函数生成这个字典，并重新排列骨骼的绑定、逆绑定和静止姿势。
- en: 'Once the `RearrangeSkeleton` function has generated `BoneMap`, you can use
    it to process any meshes or animation clips that affect the current skeleton.
    Follow these steps to re-order the joints so that a skeleton can always take advantage
    of the optimized `GetMatrixPalette` path:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`RearrangeSkeleton`函数生成了`BoneMap`，你可以使用它来处理任何影响当前骨骼的网格或动画片段。按照以下步骤重新排序关节，以便骨骼始终可以利用优化的`GetMatrixPalette`路径：
- en: 'Add the following function declarations to the `RearrangeBones.h` file:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数声明添加到`RearrangeBones.h`文件中：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Begin implementing the `RearrangeSkeleton` function in a new file, `ReearrangeBones.cpp`.
    First, create references to the rest and bind poses, then make sure that the skeleton
    that you are re-arranging isn''t empty. If it is empty, just return an empty dictionary:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件`ReearrangeBones.cpp`中开始实现`RearrangeSkeleton`函数。首先，创建对静止和绑定姿势的引用，然后确保你要重新排列的骨骼不是空的。如果是空的，就返回一个空的字典：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, create a two-dimensional integer array (a vector of vectors of integers).
    Each element of the outer vector represents one bone and the indices of this vector
    and the `mJoints` array in the bind or rest poses are parallel. The inner vector
    represents all the children that the joint at the index of the outer vector contains.
    Loop through every joint in the rest pose:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个二维整数数组（整数向量的向量）。外部向量的每个元素代表一个骨骼，该向量和绑定或静止姿势中的`mJoints`数组的索引是平行的。内部向量表示外部向量索引处的关节包含的所有子节点。循环遍历静止姿势中的每个关节：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If a joint has a parent, add the index of the joint to the parent''s vector
    of children nodes. If a node is a root node (so it has no parent), add it directly
    to the process list. This list will be used later to traverse the map depth:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个关节有父节点，将该关节的索引添加到父节点的子节点向量中。如果一个节点是根节点（没有父节点），直接将其添加到处理列表中。稍后将使用该列表来遍历地图深度：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To figure out how to re-order bones, you need to keep two maps—one that maps
    from the old configuration to the new one and one that maps from the new configuration
    back to the old one:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要弄清楚如何重新排序骨骼，你需要保留两个映射——一个从旧配置映射到新配置，另一个从新配置映射回旧配置：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For each element, if it contains children, add the children to the process
    list. This way, all the joints are processed and the joints higher up in the transform
    hierarchy are processed first:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个元素，如果它包含子元素，则将子元素添加到处理列表中。这样，所有的关节都被处理，层次结构中较高的关节首先被处理：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Set the current index of the forward map to the index of the joint that is
    being processed. The current index of the forward map is an atomic counter. Do
    the same thing for the backward map, but switch the key-value pair around. Don''t
    forget to add the null node (`-1`) to both maps:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将正向映射的当前索引设置为正在处理的关节的索引。正向映射的当前索引是一个原子计数器。对于反向映射也是同样的操作，但是要交换键值对。不要忘记将空节点（`-1`）添加到两个映射中：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that the maps are filled in, you need to build new rest and bind poses
    whose bones are in the correct order. Loop through every joint in the original
    rest and bind poses and copy their local transforms to the new poses. Do the same
    thing for the joint names:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在映射已经填充，您需要构建新的静止和绑定姿势，使其骨骼按正确的顺序排列。循环遍历原始静止和绑定姿势中的每个关节，并将它们的本地变换复制到新的姿势中。对于关节名称也是同样的操作：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finding the new parent joint ID for each joint requires two mapping steps.
    First, map the current index to the bone in the original skeleton. This returns
    the parent of the original skeleton. Map this parent index back to the new skeleton.
    This is why there are two dictionaries, to make this mapping fast:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个关节找到新的父关节ID需要两个映射步骤。首先，将当前索引映射到原始骨架中的骨骼。这将返回原始骨架的父关节。将此父索引映射回新骨架。这就是为什么有两个字典，以便进行快速映射：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the new rest and bind poses are found and the joint names have been re-arranged
    accordingly, write this data back to the skeleton by calling the public `Set`
    method. The `Set` method of the skeleton also calculates the inverse bind pose
    matrix palette:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到新的静止和绑定姿势，并且关节名称已经相应地重新排列，通过调用公共的`Set`方法将这些数据写回骨架。骨架的`Set`方法还会计算逆绑定姿势矩阵调色板：
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `RearrangeSkeleton` function re-arranges the bones in a skeleton so that
    the skeleton can take advantage of the optimized version of `GetMatrixPalette`.
    Rearranging the skeleton is not enough. Since the joint indices moved, any clips
    or meshes that reference this skeleton are now broken. In the next section, you
    will implement helper functions to re-arrange the joints in a clip.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`RearrangeSkeleton`函数重新排列骨架中的骨骼，以便骨架可以利用`GetMatrixPalette`的优化版本。重新排列骨架是不够的。由于关节索引移动，引用该骨架的任何剪辑或网格现在都是损坏的。在下一节中，您将实现辅助函数来重新排列剪辑中的关节。'
- en: Reordering clips
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新排序剪辑
- en: 'To rearrange an animation clip, loop through all the tracks in the clip. For
    each track, find the joint ID, then convert that joint ID using the (backward)
    bone map that was returned by the `RearrangeSkeleton` function. Write the modified
    joint ID back into the tack:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新排列动画剪辑，循环遍历剪辑中的所有轨道。对于每个轨道，找到关节ID，然后使用`RearrangeSkeleton`函数返回的（反向）骨骼映射转换该关节ID。将修改后的关节ID写回到轨道中：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you have implemented the `FastClip` optimization from earlier in this chapter,
    the `RearrangeClip` function should still work since it is a subclass of `Clip`.
    In the next section, you will learn how to re-arrange the joints in a mesh, which
    will be the last step needed to use this optimization.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前在本章中实现了`FastClip`优化，`RearrangeClip`函数应该仍然有效，因为它是`Clip`的子类。在下一节中，您将学习如何重新排列网格中的关节，这将是使用此优化所需的最后一步。
- en: Reordering meshes
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新排序网格
- en: To rearrange the joints that affect the skinning of a mesh, loop through every
    vertex of the mesh and remap all four of the joint indices stored in the influences
    attribute of that vertex. The weights of the joint don't need to be edited since
    the joint itself didn't change; only its index in the array changed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新排列影响网格蒙皮的关节，循环遍历网格的每个顶点，并重新映射该顶点的影响属性中存储的四个关节索引。关节的权重不需要编辑，因为关节本身没有改变；只是其数组中的索引发生了变化。
- en: 'Changing the mesh in this way only edits the CPU copy of the mesh. Call `UpdateOpenGLBuffers`
    to upload the new attribute to the GPU as well:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式更改网格只会编辑网格的CPU副本。调用`UpdateOpenGLBuffers`将新属性上传到GPU：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With the `RearrangeMesh` function implemented, you can load a skeleton, then
    call the `RearrangeSkeleton` function and store the bone map it returns. Using
    this bone map, you can also fix any meshes or animation clips that reference the
    skeleton with the `RearrangeClip` and `RearrangeMesh` functions. After an asset
    is processed in this way, `GetMatrixPalette` always takes the optimized path.
    In the next section, you will explore caching transforms in a hierarchy.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了`RearrangeMesh`函数后，您可以加载一个骨架，然后调用`RearrangeSkeleton`函数并存储它返回的骨骼映射。使用这个骨骼映射，您还可以使用`RearrangeClip`和`RearrangeMesh`函数修复引用骨架的任何网格或动画剪辑。经过这种方式处理后，`GetMatrixPalette`始终采用优化路径。在下一节中，您将探索在层次结构中缓存变换。
- en: Exploring Pose::GetGlobalTransform
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Pose::GetGlobalTransform
- en: One of the things that makes the `GetGlobalTransform` function of the `Pose`
    class is that it always calculates the world transform. Consider a situation where
    you request the world transform of a node, then immediately after, the world transform
    of its parent node. The original request calculates and uses the world transform
    of the parent node, but as soon as the next request is made, that same transform
    is calculated again.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pose`类的`GetGlobalTransform`函数的一个特点是它总是计算世界变换。考虑这样一种情况，您请求一个节点的世界变换，然后立即请求其父节点的世界变换。原始请求计算并使用父节点的世界变换，但一旦下一个请求被发出，同样的变换就会再次计算。'
- en: The solution to this is to add two new arrays to the `Pose` class. One is a
    vector of world space transforms and the other contains dirty flags. Any time
    a joint's local transform is set, the dirty flag of the joint needs to be set
    to `true`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是向`Pose`类添加两个新数组。一个是世界空间变换的向量，另一个包含脏标志。每当设置关节的本地变换时，关节的脏标志需要设置为`true`。
- en: When a world transform is requested, the dirty flag of the transform and all
    its parents is checked. If there is a dirty transform in that chain, the world
    transform is re-calculated. If the dirty flag is not set, the cached world transform
    is returned.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求世界变换时，会检查变换及其所有父级的脏标志。如果该链中有脏变换，则重新计算世界变换。如果脏标志未设置，则返回缓存的世界变换。
- en: You will not implement this optimization in this chapter. This optimization
    adds a significant amount of memory to each instance of the `Pose` class. Except
    for cases of inverse kinematics, the `GetGlobalTransform` function is rarely used.
    For skinning, the `GetMatrixPalette` function is used to retrieve world space
    matrices and that function is already optimized.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会实现这个优化。这个优化会给`Pose`类的每个实例增加大量的内存。除了逆向运动学的情况，`GetGlobalTransform`函数很少被使用。对于蒙皮，`GetMatrixPalette`函数用于检索世界空间矩阵，而该函数已经被优化过了。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you explored how to optimize an animation system for several
    scenarios. These optimizations reduce the number of uniforms that a vertex skinning
    shader requires, speeding up the sampling of animations with many keyframes and
    generating the matrix palette of a pose faster.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你探索了如何针对几种情况优化动画系统。这些优化减少了顶点蒙皮着色器所需的统一变量数量，加快了具有许多关键帧的动画的采样速度，并更快地生成了姿势的矩阵调色板。
- en: Keep in mind that there is no one-size-fits-all solution. If all the animations
    in a game have a few keyframes, the added overhead of optimizing animation sampling
    with a lookup table might not be worth the additional memory. However, changing
    the sampling function to use a binary search might be worth it. Similar pros and
    cons exist for each optimization strategy; you must pick what makes sense for
    your particular use case.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，没有一种大小适合所有的解决方案。如果游戏中的所有动画都只有几个关键帧，那么通过查找表优化动画采样所增加的开销可能不值得额外的内存。然而，改变采样函数以使用二分查找可能是值得的。每种优化策略都存在类似的利弊；你必须选择适合你特定用例的方案。
- en: When looking at the sample code for this chapter, `Chapter11/Sample00` contains
    the code for this chapter in its entirety. `Chapter11/Sample01` shows how to use
    pre-skinned meshes, `Chapter11/Sample02` shows how to use the `FastTrack` class
    for faster sampling, and `Chapter11/Sample03` shows how to rearrange bones for
    faster palette generation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看本章的示例代码时，`Chapter11/Sample00`包含了本章的全部代码。`Chapter11/Sample01`展示了如何使用预蒙皮网格，`Chapter11/Sample02`展示了如何使用`FastTrack`类进行更快的采样，`Chapter11/Sample03`展示了如何重新排列骨骼以加快调色板的生成。
- en: In the next chapter, you will explore how to blend animations to switch between
    two animations smoothly. The chapter will also explore the blending techniques
    for modifying existing animations by additive blending.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索如何混合动画以平滑地切换两个动画。本章还将探讨修改现有动画的混合技术。
