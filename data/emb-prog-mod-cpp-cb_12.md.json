["```cpp\n#include <iostream>\n\nint Receive(int input, std::string& output) {\n  if (input < 0) {\n    return -1;\n  }\n\n  output = \"Hello\";\n  return 0;\n}\n```", "```cpp\nstd::string Receive(int input, int& error) {\n  if (input < 0) {\n    error = -1;\n    return \"\";\n  }\n  error = 0;\n  return \"Hello\";\n}\n```", "```cpp\nstd::pair<int, std::string> Receive(int input) {\n  std::pair<int, std::string> result;\n  if (input < 0) {\n    result.first = -1;\n  } else {\n    result.second = \"Hello\";\n  }\n  return result;\n}\n```", "```cpp\nvoid Display(const char* prefix, int err, const std::string& result) {\n  if (err < 0) {\n    std::cout << prefix << \" error: \" << err << std::endl;\n  } else {\n    std::cout << prefix << \" result: \" << result << std::endl;\n  }\n}\n```", "```cpp\nvoid Test(int input) {\n  std::string outputResult;\n  int err = Receive(input, outputResult);\n  Display(\" Receive 1\", err, outputResult);\n\n  int outputErr = -1;\n  std::string result = Receive(input, outputErr);\n  Display(\" Receive 2\", outputErr, result);\n\n  std::pair<int, std::string> ret = Receive(input);\n  Display(\" Receive 3\", ret.first, ret.second);\n}\n```", "```cpp\nint main() {\n  std::cout << \"Input: -1\" << std::endl;\n  Test(-1);\n  std::cout << \"Input: 1\" << std::endl;\n  Test(1);\n\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(errcode)\nadd_executable(errcode errcode.cpp)\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nint Receive(int input, std::string& output)\n```", "```cpp\nstd::string Receive(int input, int& error)\n```", "```cpp\nstd::pair<int, std::string> Receive(int input)\n```", "```cpp\n  std::cout << \"Input: -1\" << std::endl;\n  Test(-1);\n  std::cout << \"Input: 1\" << std::endl;\n  Test(1);\n```", "```cpp\n#include <iostream>\n#include <system_error>\n#include <fcntl.h>\n#include <unistd.h>\n```", "```cpp\nclass Device {\n  int fd;\n\n  public:\n    Device(const std::string& deviceName) {\n      fd = open(deviceName.c_str(), O_RDWR);\n      if (fd < 0) {\n        throw std::system_error(errno, std::system_category(),\n                                \"Failed to open device file\");\n      }\n    }\n\n    ~Device() {\n      close(fd);\n    }\n\n```", "```cpp\n    void Send(const std::string& data) {\n      size_t offset = 0;\n      size_t len = data.size();\n      while (offset < data.size() - 1) {\n        int sent = write(fd, data.data() + offset, \n                         data.size() - offset);\n        if (sent < 0) {\n          throw std::system_error(errno, \n                                  std::system_category(),\n                                  \"Failed to send data\");\n        }\n        offset += sent;\n      }\n    }\n};\n```", "```cpp\nint main() {\n  try {\n    Device serial(\"/dev/ttyUSB0\");\n    serial.Send(\"Hello\");\n  } catch (std::system_error& e) {\n    std::cout << \"Error: \" << e.what() << std::endl;\n    std::cout << \"Code: \" << e.code() << \" means \\\"\" \n              << e.code().message()\n              << \"\\\"\" << std::endl;\n  }\n\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(except)\nadd_executable(except except.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\n  throw std::system_error(errno, std::system_category(),\n                          \"Failed to open device file\");\n```", "```cpp\nthrow std::system_error(errno, std::system_category(),\n                         \"Failed to send data\");\n}\n```", "```cpp\nDevice serial(\"/dev/ttyUSB0\");\nserial.Send(\"Hello\");\n```", "```cpp\n  } catch (std::system_error& e) {\n    std::cout << \"Error: \" << e.what() << std::endl;\n    std::cout << \"Code: \" << e.code() << \" means \\\"\" << e.code().message()\n        << \"\\\"\" << std::endl;\n  }\n```", "```cpp\n#include <iostream>\n\nclass Error {\n  int code;\n\n  public:\n    Error(int code): code(code) {\n      std::cout << \" Error instance \" << code << \" was created\"\n                << std::endl;\n    }\n    Error(const Error& other): code(other.code) {\n      std::cout << \" Error instance \" << code << \" was cloned\"\n                << std::endl;\n    }\n    ~Error() {\n      std::cout << \" Error instance \" << code << \" was destroyed\"\n                << std::endl;\n    }\n};\n```", "```cpp\nvoid CatchByValue() {\n  std::cout << \"Catch by value\" << std::endl;\n  try {\n    throw Error(1);\n  }\n  catch (Error e) {\n    std::cout << \" Error caught\" << std::endl;\n  }\n}\n```", "```cpp\nvoid CatchByPointer() {\n  std::cout << \"Catch by pointer\" << std::endl;\n  try {\n    throw new Error(2);\n  }\n  catch (Error* e) {\n    std::cout << \" Error caught\" << std::endl;\n  }\n}\n```", "```cpp\nvoid CatchByReference() {\n  std::cout << \"Catch by reference\" << std::endl;\n  try {\n    throw Error(3);\n  }\n  catch (const Error& e) {\n    std::cout << \" Error caught\" << std::endl;\n  }\n}\n```", "```cpp\nint main() {\n  CatchByValue();\n  CatchByPointer();\n  CatchByReference();\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(catch)\nadd_executable(catch catch.cpp)\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nclass Error {\n  int code;\n```", "```cpp\nthrow Error(1);\n```", "```cpp\ncatch (Error e) {\n```", "```cpp\nthrow new Error(2);\n```", "```cpp\ncatch (Error* e) {\n```", "```cpp\ncatch (const Error& e) {\n```", "```cpp\n#include <iostream>\n#include <stdint.h>\n\nclass Complex {\n  char* ptr;\n\n  public:\n    Complex(size_t size) noexcept {\n      try {\n        ptr = new(std::nothrow) char[size];\n        if (ptr) {\n          std::cout << \"Successfully allocated \"\n                    << size << \" bytes\" << std::endl;\n        } else {\n          std::cout << \"Failed to allocate \"\n                    << size << \" bytes\" << std::endl;\n        }\n      } catch (...) {\n        // Do nothing\n      }\n    }\n```", "```cpp\n    ~Complex() {\n      try {\n        if (ptr) {\n          delete[] ptr;\n          std::cout << \"Deallocated memory\" << std::endl;\n        } else {\n          std::cout << \"Memory was not allocated\" \n                    << std::endl;\n        }\n      } catch (...) {\n        // Do nothing\n      }\n    }\n\n    bool IsValid() const { return nullptr != ptr; }\n};\n```", "```cpp\nComplex small(100);\nComplex large(SIZE_MAX);\nint main() {\n  std::cout << \"Small object is \" \n            << (small.IsValid()? \"valid\" : \"invalid\")\n            << std::endl;\n  std::cout << \"Large object is \" \n            << (large.IsValid()? \"valid\" : \"invalid\")\n            << std::endl;\n\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(static)\nadd_executable(static static.cpp)\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nptr = new(std::nothrow) char[size];\n```", "```cpp\n} catch (...) {\n        // Do nothing\n}\n```", "```cpp\nComplex(size_t size) noexcept {\n```", "```cpp\nbool IsValid() const { return nullptr != ptr; }\n```", "```cpp\n try {\n        if (ptr) {\n delete[] ptr;\n          std::cout << \"Deallocated memory\" << std::endl;\n        } else {\n          std::cout << \"Memory was not allocated\" << std::endl;\n        }\n      } catch (...) {\n        // Do nothing\n      }\n```", "```cpp\nComplex small(100);\nComplex large(SIZE_MAX);\n```", "```cpp\n  std::cout << \"Small object is \" << (small.IsValid()? \"valid\" : \"invalid\")\n            << std::endl;\n  std::cout << \"Large object is \" << (large.IsValid()? \"valid\" : \"invalid\")\n            << std::endl;\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <thread>\n\n#include <unistd.h>\n\nusing namespace std::chrono_literals;\n```", "```cpp\nclass Watchdog {\n  std::chrono::seconds seconds;\n\n  public:\n    Watchdog(std::chrono::seconds seconds):\n      seconds(seconds) {\n        feed();\n    }\n\n    ~Watchdog() {\n      alarm(0);\n    }\n\n    void feed() {\n      alarm(seconds.count());\n    }\n};\n```", "```cpp\nint main() {\n  Watchdog watchdog(2s);\n  std::chrono::milliseconds delay = 700ms;\n  for (int i = 0; i < 10; i++) {\n    watchdog.feed();\n    std::cout << delay.count() << \"ms delay\" << std::endl;\n    std::this_thread::sleep_for(delay);\n    delay += 300ms;\n  }\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(watchdog)\nadd_executable(watchdog watchdog.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++14\")\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nWatchdog(std::chrono::seconds seconds):\n```", "```cpp\nfeed();\n```", "```cpp\nvoid feed() {\n  alarm(seconds.count());\n}\n```", "```cpp\nalarm(0);\n```", "```cpp\ndelay += 300ms;\n```", "```cpp\nWatchdog watchdog(2s);\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <system_error>\n#include <thread>\n\n#include <unistd.h>\n#include <poll.h>\n#include <signal.h>\n\nusing namespace std::chrono_literals;\n```", "```cpp\nenum class Health : uint8_t {\n  Ok,\n  Unhealthy,\n  ShutDown\n};\n```", "```cpp\nclass Heartbeat {\n  int channel[2];\n  std::chrono::milliseconds delay;\n\n  public:\n    Heartbeat(std::chrono::milliseconds delay):\n        delay(delay) {\n      int rv = pipe(channel);\n      if (rv < 0) {\n        throw std::system_error(errno,         \n                                std::system_category(),\n                                \"Failed to open pipe\");\n      }\n    }\n\n```", "```cpp\n    void Report(Health status) {\n      int rv = write(channel[1], &status, sizeof(status));\n      if (rv < 0) {\n        throw std::system_error(errno, \n                        std::system_category(),\n                        \"Failed to report health status\");\n      }\n    }\n```", "```cpp\n    bool Monitor() {\n      struct pollfd fds[1];\n      fds[0].fd = channel[0];\n      fds[0].events = POLLIN;\n      bool takeover = true;\n      bool polling = true;\n      while(polling) {\n        fds[0].revents = 0;\n        int rv = poll(fds, 1, delay.count());\n        if (rv) {\n          if (fds[0].revents & (POLLERR | POLLHUP)) {\n            std::cout << \"Polling error occured\" \n                      << std::endl;\n            takeover = false;\n            polling = false;\n            break;\n          }\n\n          Health status;\n          int count = read(fds[0].fd, &status, \n                           sizeof(status));\n          if (count < sizeof(status)) {\n            std::cout << \"Failed to read heartbeat data\" \n                      << std::endl;\n            break;\n          }\n          switch(status) {\n            case Health::Ok:\n              std::cout << \"Active process is healthy\" \n                        << std::endl;\n              break;\n            case Health::ShutDown:\n              std::cout << \"Shut down signalled\" \n                        << std::endl;\n              takeover = false;\n              polling = false;\n              break;\n            default:\n              std::cout << \"Unhealthy status reported\" \n                        << std::endl;\n              polling = false;\n              break;\n          }\n        } else if (!rv) {\n          std::cout << \"Timeout\" << std::endl;\n          polling = false;\n        } else {\n          if (errno != EINTR) {\n            std::cout << \"Error reading heartbeat data, retrying\" << std::endl;\n          }\n        }\n      }\n      return takeover;\n    }\n};\n```", "```cpp\nvoid Worker(Heartbeat& hb) {\n  for (int i = 0; i < 5; i++) {\n    hb.Report(Health::Ok);\n    std::cout << \"Processing\" << std::endl;\n    std::this_thread::sleep_for(100ms);\n  }\n  hb.Report(Health::Unhealthy);\n}\n\nint main() {\n  Heartbeat hb(200ms);\n  if (fork()) {\n    if (hb.Monitor()) {\n      std::cout << \"Taking over\" << std::endl;\n      Worker(hb);\n    }\n  } else {\n    Worker(hb);\n  }\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(heartbeat)\nadd_executable(heartbeat heartbeat.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++14\")\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nenum class Health : uint8_t {\n  Ok,\n  Unhealthy,\n  ShutDown\n};\n```", "```cpp\n  int channel[2];\n  std::chrono::milliseconds delay;\n```", "```cpp\n int rv = pipe(channel);\n      if (rv < 0) {\n        throw std::system_error(errno,         \n                                std::system_category(),\n                                \"Failed to open pipe\");\n\n```", "```cpp\nint rv = write(channel[1], &status, sizeof(status));\n```", "```cpp\n      struct pollfd fds[1];\n      fds[0].fd = channel[0];\n      fds[0].events = POLLIN | POLLERR | POLLHUP;\n```", "```cpp\n      bool takeover = true;\n      bool polling = true;\n```", "```cpp\n        int rv = poll(fds, 1, delay.count());\n```", "```cpp\n            case Health::ShutDown:\n              std::cout << \"Shut down signalled\"\n                        << std::endl;\n takeover = false;\n polling = false;\n```", "```cpp\n              std::cout << \"Unhealthy status reported\"\n                        << std::endl;\n polling = false;\n```", "```cpp\n        } else if (!rv) {\n          std::cout << \"Timeout\" << std::endl;\n          polling = false;\n```", "```cpp\n bool Monitor() {\n```", "```cpp\nvoid Worker(Heartbeat& hb) {\n```", "```cpp\nhb.Report(Health::Ok);\n```", "```cpp\n  hb.Report(Health::Unhealthy);\n```", "```cpp\n  Heartbeat hb(200ms);\n```", "```cpp\n    if (hb.Monitor()) {\n      std::cout << \"Taking over\" << std::endl;\n      Worker(hb);\n    }\n```", "```cpp\n#include <iostream>\n#include <chrono>\n#include <thread>\n\nusing namespace std::chrono_literals;\n\nbool debounce(std::chrono::milliseconds timeout, bool (*handler)(void)) {\n  bool prev = handler();\n  auto ts = std::chrono::steady_clock::now();\n  while (true) {\n    std::this_thread::sleep_for(1ms);\n    bool value = handler();\n    auto now = std::chrono::steady_clock::now();\n    if (value == prev) {\n      if (now - ts > timeout) {\n        break;\n      }\n    } else {\n      prev = value;\n      ts = now;\n    }\n  }\n  return prev;\n}\n```", "```cpp\nint main() {\n  bool result = debounce(10ms, []() {\n    return true;\n  });\n  std::cout << \"Result: \" << result << std::endl;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(debounce)\nadd_executable(debounce debounce.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++14\")\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nbool debounce(std::chrono::milliseconds timeout, bool (*handler)(void)) {\n```", "```cpp\nauto now = std::chrono::steady_clock::now();\n    if (value == prev) {\n      if (now - ts > timeout) {\n        break;\n      }\n```", "```cpp\n} else {\n      prev = value;\n      ts = now;\n    }\n```", "```cpp\nstd::this_thread::sleep_for(1ms);\n```", "```cpp\n  bool result = debounce(10ms, []() {\n return true;\n });\n```"]