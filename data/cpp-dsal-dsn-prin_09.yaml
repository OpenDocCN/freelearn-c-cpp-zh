- en: 9\. Dynamic Programming II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 动态规划II
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，你将能够：
- en: Describe how problems can be solved in polynomial versus non-deterministic polynomial
    time and the effect this has on our ability to develop efficient algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述如何在多项式与非确定性多项式时间内解决问题，以及这对我们开发高效算法的影响
- en: Implement solutions for both the 0-1 and unbounded variants of the knapsack
    problem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现0-1和无界变体的背包问题的解决方案
- en: Apply the concept of state space reduction to dynamic programming problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态空间缩减的概念应用于动态规划问题
- en: Determine every shortest path in a weighted graph using approaches that have
    been optimized by the dynamic programming paradigm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态规划范式优化的方法确定加权图中的每条最短路径
- en: In this chapter, we will build upon our understanding of the dynamic programming
    approach and examine how it can be used to optimize the problems we discussed
    in the previous chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将建立在对动态规划方法的理解之上，并研究如何优化我们在上一章中讨论的问题。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: From the previous chapter, you should have a basic understanding of dynamic
    programming, as well as an effective set of strategies for finding a dynamic programming
    (DP) solution for an unfamiliar problem. In this chapter, we will develop this
    understanding further by exploring relationships between problems, particularly
    in terms of how the basic DP logic for one problem can be modified to find the
    approach to another. We will also discuss the concept of state space reduction,
    which allows us to exploit certain aspects of a problem to further optimize a
    working DP solution by decreasing the number of dimensions and/or operations required
    to find the result. We will conclude this chapter by revisiting the topic of graphs
    to demonstrate how the DP approach can be applied to the shortest-path problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，你应该对动态规划有一个基本的理解，以及一套有效的策略，用于找到一个陌生问题的动态规划（DP）解决方案。在本章中，我们将通过探讨问题之间的关系来进一步发展这一理解，特别是在基本DP逻辑如何被修改以找到另一个问题的解决方案方面。我们还将讨论状态空间缩减的概念，这使我们能够利用问题的某些方面来进一步优化工作的DP解决方案，减少找到结果所需的维度和/或操作的数量。我们将通过重新讨论图的主题来结束本章，以展示DP方法如何应用于最短路径问题。
- en: An Overview of P versus NP
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: P与NP的概述
- en: In *Chapter 8*, *Dynamic Programming I,* we demonstrated the significant gains
    in efficiency that dynamic programming can offer over other approaches, but it
    may not yet be clear how dramatic the difference can be. It is important to appreciate
    the extent to which the complexity of certain problems will scale as the input
    bounds increase because then we can understand the situations in which DP is not
    just preferable, but necessary.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章*，*动态规划I*中，我们展示了动态规划相对于其他方法所能提供的显著效率提升，但可能还不清楚差异有多大。重要的是要意识到某些问题的复杂性将随着输入边界的增加而扩展，因为这样我们就能理解DP不仅仅是可取而且是必要的情况。
- en: 'Consider the following problem:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题：
- en: '*"Given the terms and operators of a Boolean formula, determine whether or
    not it evaluates to TRUE."*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*"给定布尔公式的术语和运算符，确定它是否求值为TRUE。"*'
- en: 'Take a look at the following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下例子：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This problem is conceptually very simple to solve. All that is required to
    get the correct result is a linear evaluation of the given formula. However, imagine
    that, instead, the problem was stated this way:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在概念上非常简单解决。只需要对给定的公式进行线性评估即可得到正确的结果。然而，想象一下，问题是这样陈述的：
- en: '*"Given the variables and operators of a Boolean formula, determine whether
    there exists an assignment of TRUE/FALSE to each variable so that the formula
    will evaluate to TRUE."*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 给定布尔公式的变量和运算符，确定是否存在对每个变量的TRUE/FALSE赋值，使得公式求值为TRUE。
- en: 'Take a look at the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下例子：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note:'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: If you are unfamiliar with logic symbols, `¬` denotes `NOT`, hence `(1 ¬ 1)
    = FALSE`, and `(1 ¬ 0) = TRUE`. Also, `∧` denotes `AND`, while `∨` denotes `OR`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉逻辑符号，`¬`表示`NOT`，因此`(1 ¬ 1) = FALSE`，`(1 ¬ 0) = TRUE`。另外，`∧`表示`AND`，而`∨`表示`OR`。
- en: The basic underlying concept remains the same, but the difference between these
    two problems is immense. In the original problem, the complexity of finding the
    result was dependent only on one factor—the length of the formula—but stated this
    way, there seems to be no obvious approach to solving it that does not require
    searching every possible binary subset of variable assignments until a solution
    is found.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的概念仍然是相同的，但这两个问题之间的差异是巨大的。在原始问题中，找到结果的复杂性仅取决于一个因素——公式的长度——但是以这种方式陈述，似乎没有明显的方法来解决它，而不需要搜索每个可能的变量赋值的二进制子集，直到找到解决方案。
- en: 'Now, let''s consider another problem:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个问题：
- en: '*"Given a graph where every vertex is assigned one of three possible colors,
    determine whether no two adjacent vertices are the same color."*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*"给定一个图，其中每个顶点被分配了三种可能的颜色，确定相邻的两个顶点是否是相同的颜色。"*'
- en: 'Like our first example, this is quite simple to implement—traverse every vertex
    of the graph, compare its color to each of its neighbors, and return false only
    if a matching pair of adjacent colors is found. But now, imagine that the problem
    is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们的第一个例子一样，这个问题实现起来非常简单——遍历图的每个顶点，将其颜色与每个邻居的颜色进行比较，只有在找到相邻颜色匹配对时才返回false。但现在，想象一下问题是这样的：
- en: '*"Given a graph where every vertex is assigned one of three possible colors,
    determine whether it is possible to color its vertices so that no two neighbors
    share the same color."*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*"给定一个图，其中每个顶点被分配了三种可能的颜色之一，确定是否可能对其顶点进行着色，以便没有两个相邻的顶点共享相同的颜色。"*'
- en: Again, this is a very different scenario.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是一个非常不同的情景。
- en: The first versions of these problems are commonly classified as **P**, which
    simply means that there's a way to solve them in **polynomial time**. When we
    describe a problem as having a time complexity of *O(n)*, *O(n**2**)*, *O(log
    n)*, and so on, we are describing a problem within the *P* class. However, the
    restated forms—at least as far as anyone has currently been able to prove—have
    no existing methods for finding a solution that are not essentially exponential
    in their worst-case complexity. Therefore, we classify their complexity as **NP**,
    or **non-deterministic polynomial time**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的第一个版本通常被归类为**P**，这意味着有一种方法可以在**多项式时间**内解决它们。当我们将问题描述为*O(n)*、*O(n**2**)*、*O(log
    n)*等时间复杂度时，我们描述的是*P*类中的问题。然而，重新表述的形式——至少目前为止据证明——没有现有的方法可以在其最坏情况下找到解决方案，因此我们将它们的复杂性分类为**NP**，或**非确定性多项式时间**。
- en: 'The relationship between these classes of problems is a subject of considerable
    debate. The particular matter of interest is that the complexity of computation
    that''s required to *verify* their solutions is "easy," whereas the complexity
    of *producing* solutions is "hard". This demonstrates one of the most widely discussed
    unsolved problems in programming: does the fact that the verification of solutions
    is in class *P* imply that there is also an approach for producing solutions in
    polynomial time? In other words, does *P = NP*? While the generally postulated
    answer to this question is no (*P ≠ NP*), this has yet to be proven, and doing
    so (regardless of what the answer actually is) would be a truly revolutionary
    advance in the study of algorithms and computation.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题类别之间的关系是一个备受争议的话题。特别感兴趣的问题是，*验证*它们的解决方案所需的计算复杂度是“简单”的，而*生成*解决方案的复杂度是“困难”的。这展示了编程中最广泛讨论的未解决问题之一：验证解决方案在*P*类中是否意味着也存在一种方法可以在多项式时间内生成解决方案？换句话说，*P
    = NP*吗？虽然对这个问题的普遍假设答案是否定的（*P ≠ NP*），但这还没有被证明，而且无论实际答案是什么，证明它都将是算法和计算研究中真正革命性的进展。
- en: 'Arguably the most interesting group of problems in NP are known as **NP-complete**
    because they share a remarkable trait: should a solution be discovered that solves
    any one of these problems efficiently (that is, in polynomial time), that solution
    can, in fact, be modified to solve all of the other problems in *NP* efficiently.
    In other words, if a polynomial solution for the first example (known as the **Boolean
    satisfiability problem**, or **SAT**) was found, some variant of the same logic
    could also be used to solve the second example (known as the **graph-coloring
    problem**), and vice versa.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，NP中最有趣的一组问题被称为**NP-complete**，因为它们共享一个显著的特征：如果发现了一个有效地解决任何一个这些问题的解决方案（即在多项式时间内），实际上可以修改该解决方案以有效地解决*NP*中的所有其他问题。换句话说，如果第一个示例（称为**布尔可满足性问题**或**SAT**）的多项式解决方案被找到，同样的逻辑的某个变体也可以用来解决第二个示例（称为**图着色问题**），反之亦然。
- en: 'Keep in mind that not every exponentially complex problem fits into this classification.
    Consider the problem of determining the next best move in a chess game. You may
    describe the recursive logic as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，并非每个指数级复杂的问题都符合这个分类。考虑一下在国际象棋游戏中确定下一步最佳移动的问题。您可以将递归逻辑描述如下：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The complexity of finding solutions is unquestionably exponential. However,
    this problem does not meet the criteria of *NP*-completeness because the basic
    act of verifying whether a certain move is the best requires the same degree of
    complexity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找解决方案的复杂度无疑是指数级的。然而，这个问题不符合*NP*-完全性的标准，因为验证某个移动是否是最佳移动的基本行为需要相同程度的复杂性。
- en: 'Compare this example to the problem of solving a Sudoku puzzle:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将此示例与解决数独难题的问题进行比较：
- en: '![Figure 9.1: A solved Sudoku puzzle](img/C14498_09_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：一个解决的数独难题](img/C14498_09_01.jpg)'
- en: 'Figure 9.1: A solved Sudoku puzzle'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.1：一个解决的数独难题
- en: Verification requires scanning each row and column of the matrix and determining
    that each of the nine outlined 3 x 3 squares contains every digit from 1 – 9,
    and that no row or column contains the same number more than once. A straightforward
    implementation of this could use three collections of nine sets, each containing
    `{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }`, the first of these collections representing the
    numbers in each row, the second representing the numbers in each column, and the
    third representing the numbers in each 3 x 3 square. As each cell is scanned,
    we would check that the number it contains is in each set that corresponds to
    that cell; if it is, it is removed from the set. Otherwise, the result is *FALSE*.
    Once every cell has been considered, the result equals *TRUE* if every set is
    empty. Since this approach only requires us to iterate through the matrix once,
    we can conclude that it can be solved in polynomial time. However, assuming the
    puzzle that's provided is incomplete and the task is to determine whether a solution
    exists, we would have to recursively consider each combination of digits for each
    cell until a valid solution is found, leading to a worst-case complexity of *O(9**n**)*,
    with *n* equal to the number of empty squares in the original grid; thus, we can
    conclude that solving a Sudoku puzzle is in *NP*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 验证需要扫描矩阵的每一行和每一列，并确定每个九个3 x 3方格中都包含1-9的每个数字，且没有行或列包含相同的数字超过一次。这个问题的一个直接实现可以使用三个包含`{1,
    2, 3, 4, 5, 6, 7, 8, 9}`的集合，第一个集合表示每行中的数字，第二个表示每列中的数字，第三个表示每个3 x 3方格中的数字。当扫描每个单元格时，我们将检查它包含的数字是否在对应的集合中；如果是，就从集合中移除。否则，结果为*FALSE*。一旦每个单元格都被考虑过，如果每个集合都为空，则结果为*TRUE*。由于这种方法只需要我们遍历矩阵一次，我们可以得出结论，它可以在多项式时间内解决。然而，假设提供的难题是不完整的，任务是确定是否存在解决方案，我们将不得不递归地考虑原始网格中每个空单元格的每个数字组合，直到找到有效的解决方案，导致最坏情况下的复杂度为*O(9**n**)*，其中*n*等于原始网格中的空单元格数；因此，我们可以得出结论，解决数独难题属于*NP*。
- en: Reconsidering the Subset Sum Problem
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新考虑子集和问题
- en: In the previous chapter, we discussed the subset sum problem, which we saw possessed
    exponential complexity in the worst cases. Let's consider the two ways this problem
    can be expressed – in terms of the relative difficulty of finding a solution and
    verifying the validity of a solution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了子集和问题，我们发现在最坏的情况下具有指数复杂度。让我们考虑这个问题可以用两种方式来表达-在找到解决方案的相对困难和验证解决方案的有效性方面。
- en: 'Let''s consider the problem of verifying the validity of a solution:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑验证解决方案的问题：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's no question that the complexity of verification is linear regarding
    the length of each subset—add up all the numbers and compare the sum to the target—which
    puts it squarely in the P class. We found some seemingly efficient methods for
    handling the complexity of finding solutions that we may assume to have a polynomial-time
    complexity of *O(N × M)*, where *N* is the size of the set and *M* is the target
    sum. This would appear to disqualify this problem as being *NP*-complete. However,
    this is actually not the case because *M* is not the size of the input, but rather
    its magnitude. Remember that computers represent integers in binary, and integers
    requiring a greater number of bits to represent them will also require a greater
    amount of time to process. Thus, every time the maximum value of M is doubled,
    it will essentially require twice the amount of time to compute.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，验证的复杂性与每个子集的长度成正比-将所有数字相加并将总和与目标进行比较-这使得它完全属于P类。我们找到了一些看似有效的处理解决方案复杂性的方法，我们可以假设它们具有*O(N×M)*的多项式时间复杂度，其中*N*是集合的大小，*M*是目标总和。这似乎排除了这个问题是*NP*完全的。然而，实际情况并非如此，因为*M*不是输入的大小，而是它的大小。请记住，计算机用二进制表示整数，需要更多位来表示的整数也需要更多时间来处理。因此，每当M的最大值加倍时，计算它实际上需要两倍的时间。
- en: So, unfortunately, our DP solution does not qualify as having polynomial complexity.
    We, therefore, define our approach to this problem as running in `pseudo-polynomial
    time`, and we can conclude that the subset sum problem is in fact *NP*-complete.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不幸的是，我们的DP解决方案不符合多项式复杂性。因此，我们将我们对这个问题的方法定义为运行在“伪多项式时间”中，并且我们可以得出结论，子集和问题实际上是*NP*完全的。
- en: The Knapsack Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背包问题
- en: 'Now, let''s reconsider the knapsack problem we looked at in *Chapter 5*, *Greedy
    Algorithms*, which we could describe as the subset sum problem''s "big brother."
    It asks the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新考虑我们在*第5章*“贪婪算法”中看到的背包问题，我们可以将其描述为子集和问题的“大哥”。它提出了以下问题：
- en: '*"Given a knapsack of limited capacity and a collection of weighted items of
    different values, what set of items can be contained within the knapsack that
    produces the greatest combined value without exceeding the capacity?"*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: “给定一个容量有限的背包和一系列不同价值的加权物品，可以在背包中包含哪些物品，以产生最大的组合价值而不超过容量？”
- en: This problem is also a characteristic example of *NP*-completeness, and as such,
    it shares many close ties to the other problems in this class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题也是*NP*完全性的一个典型例子，因此它与这个类中的其他问题有许多紧密联系。
- en: 'Consider the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this data, we can produce the following subsets:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些数据，我们可以产生以下子集：
- en: '![Figure 9.2: All possible subsets for the given 0-1 knapsack problem](img/C14498_09_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：给定0-1背包问题的所有可能子集](img/C14498_09_02.jpg)'
- en: 'Figure 9.2: All possible subsets for the given 0-1 knapsack problem'
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.2：给定0-1背包问题的所有可能子集
- en: This definitely appears to be familiar territory. Could this require little
    more than a slight modification to the subset sum algorithm?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对看起来很熟悉。这是否需要对子集和算法进行轻微修改？
- en: 0-1 Knapsack – Extending the Subset Sum Algorithm
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 0-1背包-扩展子集和算法
- en: You may recall from our discussions in *Chapter 6*, *Graph Algorithms I*, that
    the previous example is that of the 0-1 knapsack problem. Here, we noticed another
    clear parallel between the current algorithm and the state logic we used to solve
    the subset sum problem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得我们在*第6章*“图算法I”中的讨论，先前的例子就是0-1背包问题。在这里，我们注意到当前算法与我们用来解决子集和问题的状态逻辑之间存在另一个明显的并行。
- en: 'In the subset sum problem, we concluded that for every element, `x`, at index
    `i` in `set`, we can do the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在子集和问题中，我们得出结论，对于集合中索引为i的每个元素“x”，我们可以执行以下操作：
- en: Add the value of `x` to a previously found subset sum.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“x”的值添加到先前找到的子集和中。
- en: Leave the subset sum as is.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子集和保持不变。
- en: 'This implies that a DP table entry for a new sum, `y`, at index `i + 1` can
    be marked `TRUE` if it is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可以将新总和“y”的DP表条目标记为“TRUE”，如果它如下所示：
- en: An existing sum, `x`, in the previous row of the table, that is, `DP(i, x)`
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表中上一行中的现有总和“x”，即“DP(i, x)”
- en: The combined sum of `x` with the current element at `set[i]`, that is, `DP(i,
    x + set[i])`
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“x”与集合[i]中的当前元素的组合和，即“DP(i, x + set[i])”
- en: In other words, whether or not a sum could be formed with a subset spanning
    the first `i` elements in the set was dependent on whether it had already been
    found earlier, or whether it could be found by adding the value of the current
    element to another previously found sum.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，是否可以使用跨越集合中前i个元素的子集来形成总和取决于它是否已经被找到，或者是否可以通过将当前元素的值添加到先前找到的总和中找到。
- en: 'In the current problem, we can observe that for every item, `x`, at index `i`
    in `set` with weight `w`, we can do either of the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前问题中，我们可以观察到对于集合中索引为i的每个项目“x”和权重“w”，我们可以执行以下操作之一：
- en: Add the value of `x` to a previously found subset sum of the item values, as
    long as the combined total of the corresponding items' weights with `w` is less
    than or equal to the maximum capacity.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“x”的值添加到先前找到的项目值的子集和中，只要相应项目的权重与“w”的组合总和小于或等于最大容量。
- en: Leave the subset sum as is.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子集和保持不变。
- en: 'This, in turn, implies that the maximum value sum, `y`, that can be found at
    index `i + 1` of the set of items with a combined weight `W` can be either of
    the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来意味着可以在具有组合重量`W`的物品集合的索引`i+1`处找到的最大值和`y`可以是以下两者之一：
- en: An existing maximum value sum, `x`, that had been found within the previous
    `i` items and had a combined weight of `w`
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先前`i`个物品中找到的现有最大值和`x`，并且组合重量为`w`
- en: The combined sum of `x` with the value of the item at index `i`, assuming the
    weight of the item does not exceed capacity when added to `w`
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`的组合和与索引`i`处的物品的值，假设将物品的重量添加到`w`时不超过容量'
- en: Stated differently, the maximum value sum that can be formed with a subset of
    items spanning the first `i` items and having a combined weight of `w` is either
    equal to the maximum sum corresponding to weight `w` for the previous `i – 1`
    items or the sum produced by adding the current item's value to the total value
    of a previously found subset.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，可以用前`i`个物品的子集形成的最大值和，且组合重量为`w`，要么等于前`i-1`个物品的重量`w`对应的最大和，要么等于将当前物品的值添加到先前找到的子集的总值中产生的和。
- en: 'In pseudocode, we expressed the table-filling scheme for the subset sum problem
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在伪代码中，我们表达了子集和问题的填表方案如下：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The equivalent logic for the 0-1 knapsack problem would be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 0-1背包问题的等效逻辑将如下所示：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we can see that the general algorithmic concepts are practically identical:
    we are traversing a two-dimensional search space bounded by the size of the set
    and the maximum sum of the set''s elements and determining whether new subset
    sums can be found. The difference is that we are not merely recording whether
    or not a certain subset sum exists, but rather, we are collecting the maximum
    corresponding value sums associated with each subset of items and organizing them
    according to their total combined weights. We''ll take a look at its implementation
    in the following exercise.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一般的算法概念实际上是基本相同的：我们正在遍历一个二维搜索空间，其边界由集合的大小和集合元素的最大和确定，并确定是否可以找到新的子集和。不同之处在于，我们不仅仅记录某个子集和是否存在，而是收集与每个物品子集相关的最大对应值和，并根据它们的总组合重量进行组织。我们将在下一个练习中看一下它的实现。
- en: 'Exercise 41: 0-1 Knapsack Problem'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习41：0-1背包问题
- en: 'We will now implement the preceding logic using the tabulated bottom-up approach.
    Let''s get started:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用表格化的自底向上方法实现前面的逻辑。让我们开始吧：
- en: 'We will begin by including the following headers:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先包括以下标题：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our first step will be to handle the input. We will need to declare two integers,
    `items` and `capacity`, which represent the total number of items to choose from
    and the weight limit of the knapsack. We will also need two arrays, `value` and
    `weight`, where we will store the data corresponding to each item:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步将是处理输入。我们需要声明两个整数`items`和`capacity`，它们分别表示可供选择的物品总数和背包的重量限制。我们还需要两个数组`value`和`weight`，我们将在其中存储与每个物品对应的数据：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we will define the function `Knapsack_01()`, which has parameters corresponding
    to the input and returns an integer:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义函数`Knapsack_01()`，它具有与输入对应的参数，并返回一个整数：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our DP table will be two-dimensional and will correspond quite closely to the
    table we used in the subset sum problem. In the subset sum table, the first dimension''s
    size was initialized to one greater than the length of the set, while the second
    dimension''s size was initialized to one greater than the maximum sum of all the
    elements in the set. Here, our first dimension''s size will equivalently be initialized
    to `items + 1`; likewise, the second dimension''s size will be initialized to
    `capacity + 1`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的DP表将是二维的，并且将与我们在子集和问题中使用的表非常接近。在子集和表中，第一维的大小初始化为比集合的长度大一，而第二维的大小初始化为比集合中所有元素的最大和大一。在这里，我们的第一维的大小将等效地初始化为`items
    + 1`；同样，第二维的大小将初始化为`capacity + 1`：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will need to iterate across the length of both dimensions starting from
    `1`. At the beginning of each iteration of the outer loop, we will define two
    variables, `currentWeight` and `currentValue`, that correspond to the elements
    in `weight[i-1]` and `values[i-1]`, respectively:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从`1`开始迭代两个维度的长度。在外部循环的每次迭代开始时，我们将定义两个变量`currentWeight`和`currentValue`，它们分别对应于`weight[i-1]`和`values[i-1]`中的元素：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we will implement our tabulation scheme:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现我们的表格化方案：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the end of our function, we return the final element of the table:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的函数结束时，我们返回表的最后一个元素：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we add a call to `main()` and print the output:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加一个对`main()`的调用并打印输出：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s try running our program using the following input:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用以下输入运行我们的程序：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output should be as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, a relatively efficient DP solution to the knapsack problem is
    little more than a slight modification of the same algorithm we used to solve
    the subset sum problem.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，相对高效的DP解决方案对于背包问题而言只是对解决子集和问题所使用的相同算法的轻微修改。
- en: Unbounded Knapsack
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无界背包
- en: The implementation we explored regarding the knapsack problem is the most traditional
    version, but as we mentioned earlier in this chapter, there are actually many
    varieties of this problem that can apply to different scenarios. We will now consider
    the case where we have unlimited amounts of each item in the set.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨的背包问题的实现是最传统的版本，但正如我们在本章前面提到的，实际上有许多种类的问题可以适用于不同的场景。现在，我们将考虑我们拥有每个物品无限数量的情况。
- en: 'Let''s consider an example where we find the solution by brute force:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个通过蛮力找到解决方案的例子：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From a brute-force perspective, this problem seems to be significantly more
    complex. Let's restate our pseudocode logic from the 0-1 knapsack implementation
    to handle this extra stipulation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从蛮力的角度来看，这个问题似乎要复杂得多。让我们重新陈述我们从0-1背包实现中的伪代码逻辑，以处理这个额外的规定。
- en: 'The maximum value sum, `y`, that can be found at index `i` of the set of items
    with a combined weight `total_weight` can be either of the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在集合的项目索引`i`处找到的具有组合重量`total_weight`的最大值总和`y`可以是以下之一：
- en: An existing maximum value sum, `x`, that had been found within the previous
    `i - 1` items and also had a combined weight equal to `total_weight`
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在先前`i-1`个项目中找到的现有最大值总和`x`，并且还具有等于`total_weight`的组合重量
- en: 'Assuming `total_weight` can be formed by adding `current_weight` to some other
    subset''s total weight found within the previous `i – 1` items:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`total_weight`可以通过将`current_weight`添加到前`i-1`个项目中找到的某个其他子集的总重量来形成：
- en: a) The sum of the current item's value with the maximum value sum for subsets
    spanning the previous `i - 1` items and having a combined weight of `total_weight
    – current_weight`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: a) 当前项目值与跨越前`i-1`个项目的子集的最大值总和，且组合重量为`total_weight - current_weight`
- en: b) The sum of the current item's value with some previous `y` found in the recent
    iteration having a combined weight of `total_weight – current_weight`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: b) 当前项目值与最近迭代中找到的某个先前`y`的总重量为`total_weight - current_weight`的组合
- en: 'In terms of the DP table, we can represent the new logic as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在DP表方面，我们可以将新逻辑表示如下：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can implement this like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样实现：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Logically, this approach will work, but it turns out that this is actually not
    the most efficient implementation. Let's understand its limitations and how to
    overcome them in the following section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，这种方法是可行的，但事实证明这实际上并不是最有效的实现。让我们在下一节中了解它的局限性以及如何克服它们。
- en: State Space Reduction
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态空间缩减
- en: One rather tricky aspect of using DP effectively is the concept of **state space
    reduction**, which is the act of reformulating a working DP algorithm to use the
    minimal amount of space required to represent a state. This often comes down to
    exploiting some pattern or symmetry inherent to the nature of the problem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有效使用DP的一个相当棘手的方面是**状态空间缩减**的概念，即重新构建工作的DP算法以使用表示状态所需的最小空间。这通常归结为利用问题本质中固有的某种模式或对称性。
- en: 'To demonstrate this concept, let''s consider the problem of finding the value
    in the *n**th* row and *m**th* column of **Pascal''s triangle**, which can be
    represented as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个概念，让我们考虑寻找**Pascal三角形**第*n*行和第*m*列中的值的问题，可以表示如下：
- en: '![](img/C14498_09_03.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_09_03.jpg)'
- en: 'Figure 9.3: Pascal''s triangle'
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.3：Pascal三角形
- en: 'Pascal''s triangle is built according to the following logic:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal三角形是根据以下逻辑构建的：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In other words, the first value in every row is `1`, and each subsequent column
    value is equal to the sum of the current and previous columns of the previous
    row. As you can see from the following figure, in the second column of the second
    row, we get `2` by adding the elements in the second (`1`) and the first column
    (`1`) from the previous row:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每一行的第一个值是`1`，每个后续列的值都等于前一行的当前列和前一列的和。正如您从下图中看到的，在第二行的第二列中，通过将前一行的第二列（`1`）和第一列（`1`）的元素相加，我们得到`2`：
- en: '![Figure 9.4: Getting the next values in Pascal’s triangle](img/C14498_09_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：获取Pascal三角形中的下一个值](img/C14498_09_04.jpg)'
- en: 'Figure 9.4: Getting the next values in Pascal''s triangle'
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.4：获取Pascal三角形中的下一个值
- en: 'Solving the problem of finding the value in the *n**th* row and *m**th* column
    using tabulation could be done as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用制表法解决寻找**Pascal三角形**第*n*行和第*m*列中的值的问题可以如下进行：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The DP table that was built in the preceding code would look like this for
    `N = 7`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中构建的DP表对于`N = 7`将如下所示：
- en: '![Figure 9.5: Pascal’s triangle represented as an N × N DP table](img/C14498_09_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：将Pascal三角形表示为N×N DP表](img/C14498_09_05.jpg)'
- en: 'Figure 9.5: Pascal''s triangle represented as an N × N DP table'
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.5：将Pascal三角形表示为N×N DP表
- en: 'As we can see, this algorithm is quite wasteful both in terms of memory usage
    and redundant calculations. The immediately apparent problem is the fact that
    the table has *N + 1* columns, despite the fact that only one row ever contains
    that many values. We could easily reduce space complexity by initializing each
    row as needed, sized according to the number of elements it requires, which reduces
    the space required by the table from *N**2* to *N × (N + 1) / 2*. Let''s modify
    our implementation as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个算法在内存使用和冗余计算方面都是相当浪费的。显而易见的问题是，尽管只有一行包含那么多的值，但表格却有*N + 1*列。我们可以通过根据所需的元素数量初始化每行，从而将空间复杂度降低，从*N**2*减少到*N
    × (N + 1) / 2*。让我们修改我们的实现如下：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We may further observe that there is a symmetrical relationship between the
    first and second half of each row, which means that we really only need to calculate
    the values for the first (n/2) columns. Therefore, we have the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以观察到每一行的前半部分和后半部分之间存在对称关系，这意味着我们实际上只需要计算前（n/2）列的值。因此，我们有以下内容：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We could state this in a generalized way like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以一般化的方式陈述如下：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Considering this, we could modify our implementation as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以修改我们的实现如下：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, assuming we were able to receive input queries in advance and precompute
    the results, we could abandon storing the full table entirely since only the previous
    row is needed to produce results for the current row. Hence, we could further
    modify our implementation as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设我们能够提前接收输入查询并预先计算结果，我们可以完全放弃存储完整的表，因为只需要前一行来生成当前行的结果。因此，我们可以进一步修改我们的实现如下：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s get back to the unbounded knapsack problem:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到无界背包问题：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The DP table that was constructed by our proposed solution in the previous
    section would look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出的解决方案在前一节中构建的DP表将如下所示：
- en: '![Figure 9.6: Two-dimensional DP table constructed by the proposed algorithm](img/C14498_09_06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6：由提议算法构建的二维DP表](img/C14498_09_06.jpg)'
- en: 'Figure 9.6: Two-dimensional DP table constructed by the proposed algorithm'
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.6：由提议的算法构建的二维DP表
- en: 'The logic that we used to produce the preceding table was based on the approach
    we used to solve the 0-1 form of the knapsack problem, and thus, we assumed that
    the maximum value sum for a given `weight` and `i` types of items, that is, `DP(i,
    weight)`, could be as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来生成上表的逻辑是基于解决0-1背包问题的方法，因此，我们假设给定`weight`和`i`种物品的最大值之和，即`DP(i, weight)`，可以如下：
- en: The maximum value sum for the same weight and `i - 1` types of items, without
    including the current item, that is, `DP(i - 1, weight)`
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同重量和`i-1`种物品的最大值之和，不包括当前物品，即`DP(i-1, weight)`
- en: The sum of the current item's `value` with the maximum sum for `i - 1` types
    of items, that is, `DP(i - 1, weight - w) + value`
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前物品的`value`与`i-1`种物品的最大和的总和，即`DP(i-1, weight-w) + value`
- en: The sum of the current item's `value` with the maximum sum for `i` types of
    items if the item is to be included more than once, that is, `DP(i, weight - w)
    + value`
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前物品的`value`与`i`种物品的最大和的总和，如果要多次包括该物品，即`DP(i, weight-w) + value`
- en: The first two conditions correspond to the logic of the 0-1 knapsack problem.
    However, considering them within the context of the unbounded knapsack and checking
    them against the table that was produced by our algorithm, we can actually conclude
    that the first two conditions are essentially irrelevant.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个条件对应于0-1背包问题的逻辑。然而，在无界背包的情况下考虑它们，并根据我们的算法生成的表进行检查，我们实际上可以得出前两个条件基本上是无关紧要的结论。
- en: In the original problem, we were concerned about the values for `i - 1` items
    because we needed to decide whether to include or exclude item `i`, but in this
    problem, we have no reason to exclude any of the items as long as their weight
    doesn't exceed the knapsack's capacity. In other words, the conditions dictating
    each state transition are bounded only by the `weight` and are therefore representable
    in one dimension!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始问题中，我们关心`i-1`个物品的值，因为我们需要决定是否包括或排除物品`i`，但在这个问题中，只要它们的重量不超过背包的容量，我们就没有理由排除任何物品。换句话说，规定每个状态转换的条件仅由`weight`限制，因此可以用一维表示！
- en: 'This leads to an important distinction that must be made: the dimensions required
    to *simulate* a state are not necessarily the same as the dimensions required
    to *describe* a state. Until now, every DP problem we have examined, when cached,
    results in a form that was essentially equivalent to the state itself. However,
    in the unbounded knapsack problem, we can describe each state as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致必须进行重要的区分：*模拟*状态所需的维度不一定与*描述*状态所需的维度相同。到目前为止，我们研究的每个DP问题，在缓存时，结果都基本上等同于状态本身。然而，在无界背包问题中，我们可以描述每个状态如下：
- en: '*"For each item of weight w and value v, the maximum value of a knapsack of
    capacity C is equal to v plus the maximum value of a knapsack of capacity C –
    w."*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “对于每个重量w和价值v的物品，容量为C的背包的最大价值等于v加上容量为C-w的背包的最大价值。”
- en: 'Consider the following input data:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下输入数据：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the following table, each row represents a weight, `w`, from `0` to the
    maximum capacity, and each column represents the index, `i`, of an item. The number
    in every cell represents the maximum value sum for each weight after the item
    at index `i` has been considered:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，每一行代表一个重量`w`，从`0`到最大容量，每一列代表一个物品的索引`i`。每个单元格中的数字表示考虑了索引`i`的物品后每个重量的最大值之和：
- en: '![Figure 9.7: Subproblem results for each weight-index pair ](img/C14498_09_07.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7：每个重量-索引对的子问题结果](img/C14498_09_07.jpg)'
- en: 'Figure 9.7: Subproblem results for each weight-index pair'
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.7：每个重量-索引对的子问题结果
- en: As demonstrated in the preceding table, the allowance of duplicates means that
    no item needs to be excluded as long as its inclusion fits within the maximum
    capacity. Therefore, whether or not the weight sum could be found at index *0*
    or index *1,000* of the collection is irrelevant because we are never going to
    leave a previously found subset sum as is unless adding to it exceeds the defined
    bounds of the knapsack. This means that there is no advantage to maintaining a
    record of the item's index, which allows us to cache our subproblems in a single
    dimension – the combined weight of any number of items encountered. We'll look
    at its implementation in the following exercise.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前表所示，允许重复意味着只要包含在最大容量内，就不需要排除任何物品。因此，无论重量总和是否可以在集合的索引*0*或索引*1,000*处找到都是无关紧要的，因为我们永远不会保留先前找到的子集总和，除非添加到它超出了背包的定义边界。这意味着维护物品索引的记录没有任何优势，这使我们能够在一维中缓存我们的子问题-任意数量的物品的组合重量。我们将在下一个练习中看到它的实现。
- en: 'Exercise 42: Unbounded Knapsack'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习42：无界背包
- en: 'In this exercise, we shall apply the concept of state space reduction to the
    unbounded knapsack problem by representing our DP table in one dimension. Let''s
    get started:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将应用状态空间缩减的概念来将无界背包问题表示为一维的DP表。让我们开始：
- en: 'Let''s use the same headers and input that we used in the previous exercise:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用与上一个练习中相同的标题和输入：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we will implement a function called `UnboundedKnapsack()` that returns
    an integer. Its parameters will be identical to the input:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现一个名为`UnboundedKnapsack()`的函数，它返回一个整数。它的参数将与输入相同：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our DP table will be represented as an integer vector with size equal to `capacity
    + 1`, with each index initialized to `0`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的DP表将表示为一个整数向量，大小为`capacity + 1`，每个索引初始化为`0`：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Like the 0-1 knapsack problem, our state logic will be contained in two nested
    loops; however, in this variation of the problem, we will invert the nesting of
    the loops so that the outer loop iterates from `0` to `capacity` (inclusive),
    and the inner loop iterates through the item indices:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与0-1背包问题一样，我们的状态逻辑将包含在两个嵌套循环中；但是，在这个问题的变体中，我们将颠倒循环的嵌套，使得外部循环从`0`到`capacity`（包括），内部循环遍历项目索引：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we must decide on how to cache our states. Our only concern is that the
    capacity is not exceeded by the weights of the chosen items. Since our table is
    only large enough to represent weight values from `0` to `capacity`, we only need
    to make sure that the difference between `w` and `weight[i]` is non-negative.
    Thus, all of the assignment logic can be contained within a single `if` statement:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须决定如何缓存我们的状态。我们唯一关心的是容量不被选择物品的重量超过。由于我们的表只足够大，可以表示从`0`到`capacity`的重量值，我们只需要确保`w`和`weight[i]`之间的差值是非负的。因此，所有的赋值逻辑都可以包含在一个`if`语句中：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s return to `main()`, add a call to `UnboundedKnapsack()`, and output
    the results:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们返回到`main()`，添加一个调用`UnboundedKnapsack()`，并输出结果：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Try running your program with the following input:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用以下输入运行您的程序：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Your output should be as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出应该如下：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As demonstrated by the preceding implementation, it is often worth it to consider
    less costly ways to cache solutions in a DP algorithm. Problems that seem to require
    complex state representations can often be simplified significantly after closer
    examination.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的实现所示，通常值得考虑在DP算法中缓存解决方案的更便宜的方法。看起来需要复杂状态表示的问题经过仔细检查后通常可以显著简化。
- en: 'Activity 22: Maximizing Profit'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动22：最大化利润
- en: You are working for a large chain of department stores. Like any retail business,
    your company purchases items from wholesale distributors in large quantities and
    then sells them at a higher price to gain profit. Certain types of products that
    are being sold in your store can be purchased from multiple different distributors,
    but the quality and price of the products can vary considerably, which naturally
    has an effect on its corresponding retail value. Once factors such as exchange
    rates and public demand are taken into account, products from certain distributors
    can often be bought at a much lower price per unit than what they can ultimately
    be sold for. You have been tasked with designing a system that calculates the
    maximum profit you can gain with an allotted budget.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在为一家大型连锁百货商店工作。像任何零售业务一样，您的公司以大量购买商品从批发分销商那里，然后以更高的价格出售以获得利润。您商店销售的某些类型的产品可以从多个不同的分销商那里购买，但产品的质量和价格可能有很大的差异，这自然会影响其相应的零售价值。一旦考虑到汇率和公众需求等因素，某些分销商的产品通常可以以比最终销售价格低得多的价格每单位购买。您的任务是设计一个系统，计算您可以在分配的预算中获得的最大利润。
- en: 'You have been provided with a catalog of similar products. Each listed product
    has the following information:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经提供了一份类似产品的目录。列出的每个产品都有以下信息：
- en: The wholesale price of the product
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品的批发价格
- en: The amount of profit that can be made by selling the same product after markup
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过销售相同产品后的标记，可以获得的利润金额
- en: The quantity of the product sold per unit by the distributor
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分销商每单位销售的产品数量
- en: Given that the distributor will only sell the product in the exact quantity
    specified, your task is to determine the maximum amount of money that can be made
    by purchasing some subset of the listed products. To ensure that the store offers
    a variety of choices, each item that's listed can only be purchased once.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于分销商只会按照指定的确切数量出售产品，您的任务是确定通过购买列出的一些产品的子集可以获得的最大金额。为了确保商店提供多种选择，列出的每个物品只能购买一次。
- en: Since you only have a limited amount of warehouse space and don't want to overstock
    a particular type of item, you are also given a restriction on the maximum number
    of individual units that can be purchased. Therefore, your program should also
    ensure that the combined number of products that are bought does not exceed this
    limit.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您只有有限的仓库空间，并且不想过度库存某种类型的物品，因此您还受到可以购买的单个单位的最大数量的限制。因此，您的程序还应确保购买的产品的总数不超过此限制。
- en: '**Example**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**例子**'
- en: 'Say five items are listed in the catalog with the following information:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设目录中列出了五种产品，具有以下信息：
- en: '![](img/C14498_09_08.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_09_08.jpg)'
- en: 'Figure 9.8: Sample values for profit optimization'
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.8：利润优化的示例值
- en: 'You have a budget of $100 and a warehouse capacity of 20 units. The following
    sets of purchases would be valid:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您有100美元的预算和20个单位的仓库容量。以下一组购买将是有效的：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Thus, the program should output `160`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，程序应该输出`160`。
- en: '**Input**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**'
- en: The first line contains three integers, `N` as the number of distributors, `budget`
    as the maximum amount of money that can be spent, and `capacity` as the maximum
    number of units that can be purchased.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含三个整数，`N`作为分销商的数量，`budget`作为可以花费的最大金额，`capacity`作为可以购买的最大单位数的限制。
- en: 'The next `N` lines should contain three space-separated integers:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`N`行应包含三个以空格分隔的整数：
- en: '`quantity`: The quantity per unit offered by the distributor'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`：分销商提供的每单位数量'
- en: '`cost`: The price of the item'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cost`：物品的价格'
- en: '`value`: The amount of profit that can be gained after selling the product'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：销售产品后可以获得的利润金额'
- en: '**Output**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: A single integer representing the maximum amount of profit that can be made
    by choosing some subset of items from the catalog.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 表示从目录中选择一些子项可以获得的最大利润的单个整数。
- en: '**Test cases**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例**'
- en: 'The following set of test cases should help you understand this problem better:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一组测试用例应该帮助您更好地理解这个问题：
- en: '![Figure 9.9: Activity 22 test case 1'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：活动22测试用例1
- en: '](img/C14498_09_09.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_09_09.jpg)'
- en: 'Figure 9.9: Activity 22 test case 1'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.9：活动22测试用例1
- en: '![Figure 9.10: Activity 22 test case 2'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：活动22测试用例2
- en: '](img/C14498_09_10.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_09_10.jpg)'
- en: 'Figure 9.10: Activity 22 test case 2'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.10：活动22测试案例2
- en: '![Figure 9.11: Activity 22 test case 3'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11：活动22测试案例3'
- en: '](img/C14498_09_11.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_09_11.jpg)'
- en: 'Figure 9.11: Activity 22 test case 3'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.11：活动22测试案例3
- en: '![Figure 9.12: Activity 22 test case 4'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12：活动22测试案例4'
- en: '](img/C14498_09_12.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_09_12.jpg)'
- en: 'Figure 9.12: Activity 22 test case 4'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.12：活动22测试案例4
- en: '**Activity Guidelines**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动指南**'
- en: The implementation that's required is very similar to the 0-1 knapsack problem.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的实现与0-1背包问题非常相似。
- en: Since there are two constraints (capacity and budget), the DP table will require
    three dimensions.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于存在两个约束（容量和预算），DP表将需要三个维度。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 581.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第581页找到。
- en: Graphs and Dynamic Programming
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图和动态规划
- en: In this section, we have discussed advanced graph algorithms and DP as distinctly
    different topics, but as is often the case, they can be used concurrently depending
    on the type of problem we are trying to solve and the nature of the graph. Several
    problems commonly associated with graphs are identified as *NP*-complete (graph
    coloring and the vertex cover problem, to name two examples) and can, under the
    right circumstances, be solved with dynamic programming. However, most of these
    topics are outside the scope of this book (and are actually worthy of having entire
    books dedicated specifically to their analysis).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们已经讨论了高级图算法和DP作为截然不同的主题，但通常情况下，它们可以根据我们试图解决的问题类型和图的性质同时使用。与图相关的几个常见问题被确定为*NP*完全问题（图着色和顶点覆盖问题，这只是两个例子），在适当的情况下，可以用动态规划来解决。然而，大多数这些主题都超出了本书的范围（实际上，它们值得专门撰写整本书来进行分析）。 '
- en: 'However, one problem in graph theory is particularly well suited to the DP
    approach, and fortunately, it is one we are already very familiar with: the shortest-path
    problem. In fact, in *Chapter 7*, *Graph Algorithms II*, we actually discussed
    an algorithm that''s commonly categorized under the DP umbrella, despite the fact
    that we never identified it as such.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，图论中的一个问题非常适合DP方法，而且幸运的是，这是我们已经非常熟悉的问题：最短路径问题。实际上，在*第7章*，*图算法II*中，我们实际上讨论了一个通常归类为DP范畴的算法，尽管我们从未将其标识为这样。
- en: Reconsidering the Bellman-Ford Algorithm
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新考虑贝尔曼-福特算法
- en: In our exploration of the Bellman-Ford algorithm, we were viewing it in light
    of our previous discussions of Dijkstra's algorithm, with which it certainly shares
    some similarities. But now that we have a solid grasp of the concepts underlying
    the dynamic programming paradigm, let's reconsider Bellman-Ford according to our
    new understanding.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨贝尔曼-福特算法时，我们是根据之前讨论的迪杰斯特拉算法来看待它的，它确实与迪杰斯特拉算法有一些相似之处。但是现在我们对动态规划范式的概念有了牢固的理解，让我们根据新的理解重新考虑贝尔曼-福特算法。
- en: 'In brief, the approach that''s used by Bellman-Ford can be described as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，贝尔曼-福特使用的方法可以描述如下：
- en: 'Given a source node called `start`, the number of vertices, `V`, and the edges,
    `E`, of a graph, do the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个名为“start”的源节点，图的顶点数“V”和边“E”，执行以下操作：
- en: Mark distances of each node from `0` to `V – 1` (inclusive) as `UNKNOWN`, except
    for `start`, which is `0`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个节点从“0”到“V – 1”（包括）的距离标记为“UNKNOWN”，除了“start”为“0”。
- en: Iterate from `1` to `V – 1` (inclusive).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“1”迭代到“V – 1”（包括）。
- en: On each iteration, consider every edge in `E` and check to see whether the source
    node's respective distance value is `UNKNOWN`. If not, then compare the neighboring
    node's currently stored distance to the sum of the source node's distance with
    the edge weight between them.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次迭代中，考虑图中的每条边，并检查源节点的相应距离值是否为“UNKNOWN”。如果不是，则将相邻节点当前存储的距离与源节点的距离与它们之间的边权重的和进行比较。
- en: If the sum of the source node's distance with the edge weight is less than the
    destination node's distance, update the destination node's distance to the lesser
    value.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果源节点的距离与边权重的和小于目标节点的距离，则将目标节点的距离更新为较小值。
- en: After `V – 1` iterations, either the shortest path has been found or the graph
    has a negative weight cycle, which can be determined with an additional iteration
    through the edges.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过“V – 1”次迭代后，要么找到了最短路径，要么图中存在负权重循环，可以通过对边进行额外迭代来确定。
- en: 'The success of this algorithm is clearly dependent on the fact that the problem
    exhibits an optimal substructure. We can illustrate the recursive logic behind
    this concept as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的成功显然取决于问题具有最优子结构的事实。我们可以将这个概念背后的递归逻辑描述如下：
- en: '![Figure 9.13: Visualizing the Bellman-Ford algorithm](img/C14498_09_13.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13：可视化贝尔曼-福特算法](img/C14498_09_13.jpg)'
- en: 'Figure 9.13: Visualizing the Bellman-Ford algorithm'
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.13：可视化贝尔曼-福特算法
- en: 'Expressing this as pseudocode would look something like the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将此表示为伪代码将看起来类似于以下内容：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Clearly, the shortest-path problem also possesses the overlapping subproblems
    property. Bellman-Ford effectively avoids recomputation due to two key observations:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最短路径问题也具有重叠子问题属性。贝尔曼-福特算法有效地避免了由于两个关键观察而导致的重复计算：
- en: The maximum number of moves that can be made in a non-cyclic traversal between
    any two nodes in a graph is `| V – 1 |` (that is, every node in the graph minus
    the starting node).
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图中任意两个节点之间进行非循环遍历的最大移动次数为“| V – 1 |”（即图中的每个节点减去起始节点）。
- en: The shortest path between a source node and every reachable node after N iterations
    is equivalent to the shortest paths to every node that's reachable after `| N
    – 1 |` iterations, plus the edge weights to each of their neighbors.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过N次迭代后，源节点与每个可达节点之间的最短路径等于在“| N – 1 |”次迭代后可达的每个节点的最短路径，加上到它们各自邻居的边权重。
- en: 'The following set of figures should help you better visualize the steps in
    the Bellman-Ford algorithm:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一组图表应该能帮助你更好地可视化贝尔曼-福特算法中的步骤：
- en: '![Figure 9.14: Bellman-Ford Step 1](img/C14498_09_14.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14：贝尔曼-福特算法第1步](img/C14498_09_14.jpg)'
- en: 'Figure 9.14: Bellman-Ford Step 1'
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.14：贝尔曼-福特算法第1步
- en: '![Figure 9.15: Bellman-Ford Step 2](img/C14498_09_15.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15：贝尔曼-福特算法第2步](img/C14498_09_15.jpg)'
- en: 'Figure 9.15: Bellman-Ford Step 2'
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.15：贝尔曼-福特算法第2步
- en: '![Figure 9.16: Bellman-Ford Step 3](img/C14498_09_16.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16：贝尔曼-福特算法第3步](img/C14498_09_16.jpg)'
- en: 'Figure 9.16: Bellman-Ford Step 3'
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.16：贝尔曼-福特算法第3步
- en: The specific problem that Bellman-Ford is said to solve is known as the **single-source
    shortest path problem** because it is used to find the shortest paths for a single
    node. In *Chapter 7*, *Graph Algorithms II*, we discussed Johnson's algorithm,
    which solves what is known as the **all-pairs shortest path problem** because
    it finds the shortest paths between every pair of vertices in the graph.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 贝尔曼-福特算法被认为解决的具体问题被称为**单源最短路径问题**，因为它用于找到单个节点的最短路径。在*第7章*，*图算法II*中，我们讨论了约翰逊算法，它解决了被称为**全对最短路径问题**的问题，因为它找到了图中每对顶点之间的最短路径。
- en: Johnson's algorithm combined the DP approach seen in the Bellman-Ford algorithm
    with the greedy approach seen in Dijkstra's. In this section, we will explore
    a complete DP implementation of the all-pairs shortest path problem. However,
    let's consider the nature of the problem a bit deeper by implementing a top-down
    solution.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰逊算法将贝尔曼-福特算法中看到的DP方法与狄克斯特拉算法中看到的贪婪方法相结合。在本节中，我们将探讨全对最短路径问题的完整DP实现。然而，让我们通过实现一个自顶向下的解决方案来更深入地考虑问题的性质。
- en: Approaching the Shortest Path Problem as a DP Problem
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将最短路径问题作为DP问题来解决
- en: One way to better understand the logic behind Bellman-Ford is to transform it
    into a top-down solution. To do this, let's start by considering our base cases.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地理解贝尔曼-福特背后的逻辑的一种方法是将其转化为自顶向下的解决方案。为此，让我们从考虑我们的基本情况开始。
- en: 'Bellman-Ford performs `V – 1` iterations through the edges of the graph, typically
    by way of a `for` loop. Since our previous implementations have iterated from
    `1` to `V – 1` inclusive, let''s have our top-down solution begin at `V – 1` and
    decrement to `0`. In terms of our recurrence structure, let''s say that every
    state can be described as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 贝尔曼-福特算法通过图的边执行`V - 1`次迭代，通常通过`for`循环。由于我们先前的实现已经从`1`迭代到`V - 1`，让我们的自顶向下解决方案从`V
    - 1`开始，并递减到`0`。就我们的递归结构而言，让我们说每个状态可以描述如下：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Therefore, our first base case can be defined as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的第一个基本情况可以定义如下：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In other words, if `depth` has been decremented to `0`, we can conclude that
    no path exists and terminate our search.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果`depth`已经减少到`0`，我们可以得出结论，没有路径存在，并终止我们的搜索。
- en: 'The second base case we need to handle is, of course, the point where we find
    a path from the source to the target. In this case, the depth of the search is
    irrelevant; the shortest distance from the target to itself will always be `0`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理的第二个基本情况当然是我们找到从源到目标的路径的情况。在这种情况下，搜索的深度是无关紧要的；从目标到自身的最短距离总是`0`：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s define our intermediate states. Let''s review what the iterative
    approach that''s used by Bellman-Ford looks like:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的中间状态。让我们回顾一下贝尔曼-福特算法使用的迭代方法：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In terms of a recursive traversal, this can be restated as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 就递归遍历而言，可以重新表述如下：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since every state can be uniquely described according to these two dimensions
    and the possible existence of cycles means that we are likely to encounter the
    same states more than once, we can conclude that caching according to node-depth
    pairs is both valid and useful for memoization purposes:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个状态可以根据这两个维度和可能存在循环的存在而唯一描述，并且可能会多次遇到相同的状态，我们可以得出结论，根据节点深度对缓存进行缓存既有效又有用于记忆化目的：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'These states are illustrated in the following figure:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态在下图中说明：
- en: '![Figure 9.17: All the states for the shortest-path problem ](img/C14498_09_17.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17：最短路径问题的所有状态](img/C14498_09_17.jpg)'
- en: 'Figure 9.17: All the states for the shortest-path problem'
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.17：最短路径问题的所有状态
- en: We'll look at the implementation of this approach in the following exercise.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中看看这种方法的实现。
- en: 'Exercise 43: Single-Source Shortest Paths (Memoization)'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习43：单源最短路径（记忆化）
- en: 'In this exercise, we shall take the top-down DP approach to finding a solution
    to the single-source shortest path problem. Let''s get started:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将采用自顶向下的动态规划方法来解决单源最短路径问题。让我们开始吧：
- en: 'Let''s begin by including the following headers and the `std` namespace, as
    well as defining an `UNKNOWN` constant:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从包括以下标头和`std`命名空间开始，并定义一个`UNKNOWN`常量：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s also declare `V` and `E` (the number of vertices and the number of edges,
    respectively), as well as two two-dimensional integer vectors, `adj` (an adjacency
    list of our graph) and `weight` (a matrix of edge weight values). Finally, we
    will define a memoization table called `memo`. This time, we will use `std::map`
    to simplify the differentiation between checking whether a key exists in the cache
    versus whether its value is unknown:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还声明`V`和`E`（顶点数和边数），以及两个二维整数向量，`adj`（图的邻接表）和`weight`（边权重值的矩阵）。最后，我们将定义一个名为`memo`的记忆化表。这次，我们将使用`std::map`来简化区分检查缓存中的键是否存在与其值是否未知：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the `main()` function, we should handle input so that we receive the graph
    we wish to apply the algorithm to. The first line of input will contain `V` and
    `E`, and the following `E` lines will contain three integers: `u`, `v`, and `w`
    (the source, destination, and weight of each edge, respectively):'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们应该处理输入，以便接收我们希望应用算法的图。输入的第一行将包含`V`和`E`，接下来的`E`行将包含三个整数：`u`、`v`和`w`（每条边的源、目的地和权重）：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will now define a function called `SingleSourceShortestPaths()` that will
    take one argument—`source`, which is the index of the source vertex—and will return
    an integer vector:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将定义一个名为`SingleSourceShortestPaths()`的函数，它将接受一个参数——`source`，即源顶点的索引，并将返回一个整数向量：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we will need to make some preliminary modifications to our graph. As opposed
    to traversing from the source node to all the other nodes in the graph, we will
    instead begin each traversal from the other nodes and calculate the shortest path
    from the source in reverse. Since our graph is directed, we will have to use its
    transpose to accomplish this:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要对我们的图进行一些初步的修改。与其从源节点遍历图中的所有其他节点，我们将从其他节点开始每次遍历，并计算从源到目标的最短路径。由于我们的图是有向的，我们将不得不使用其转置来实现这一点：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we defined two new two-dimensional integer vectors, `adj_t` and `weight_t`,
    which will correspond to the adjacency list and weight matrix for the transpose
    graph. We then used a nested loop to create our modified graph, as well as initialized
    the values in our `memo` table.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个新的二维整数向量，`adj_t`和`weight_t`，它们将对应于转置图的邻接表和权重矩阵。然后，我们使用嵌套循环来创建我们的修改后的图，并初始化了我们`memo`表中的值。
- en: 'We should now define the `ShortestPath_Memoization()` function with four parameters:
    two integers, `depth` and `node`, and `adj` and `weight` (which, in this case,
    will be references to the transpose graph):'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该定义`ShortestPath_Memoization()`函数，它有四个参数：两个整数，`depth`和`node`，以及`adj`和`weight`（在这种情况下，它们将是对转置图的引用）：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our algorithm will essentially be a standard depth-first search, except we
    will cache the results for each `{ node, depth }` pair at the end of each function
    call. At the top of the function, we will check for a cached result and return
    it if the key exists in the map:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的算法本质上是标准的深度优先搜索，除了我们将在每次函数调用结束时缓存每个`{节点，深度}`对的结果。在函数顶部，我们将检查缓存的结果，如果键存在于映射中，则返回它：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Back in the `SingleSourceShortestPaths()` function, we will define an integer
    vector called `distance` of size `V` and fill it through successive calls to `ShortestPath_Memoization()`:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`SingleSourceShortestPaths()`函数，我们将定义一个名为`distance`的整数向量，大小为`V`，并通过对`ShortestPath_Memoization()`的连续调用来填充它：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Back in `main()`, we will define a two-dimensional integer matrix called `paths`,
    which will store the distances returned from `SingleSourceShortestPaths()` for
    each node index from `0` to `V`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`main()`，我们将定义一个名为`paths`的二维整数矩阵，它将存储从`0`到`V`的每个节点索引返回的`SingleSourceShortestPaths()`的距离：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can now use the `paths` table to print the distance values for every pair
    of nodes in the graph:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`paths`表来打印图中每对节点的距离值：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, run your code with the following input:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下输入运行您的代码：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output should be as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Unsurprisingly, this is not the preferred way of handling this particular problem,
    but as with the previous exercises, we can learn quite a bit about how the optimal
    substructure is formed by implementing recursive solutions like this one. With
    these insights, we are now equipped to fully understand how the shortest distances
    between every pair of nodes can be found simultaneously using tabulation.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，这并不是处理这个特定问题的首选方式，但是和之前的练习一样，我们可以通过实现像这样的递归解决方案来学习到很多关于最优子结构是如何形成的。有了这些见解，我们现在可以完全理解如何使用制表法同时找到每对节点之间的最短距离。
- en: All-Pairs Shortest Path
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有对最短路径
- en: Our program from the previous exercise does print the shortest paths for every
    vertex pair, but its efficiency is roughly equivalent to performing `V` calls
    to Bellman-Ford, with the added memory-related disadvantages associated with recursive
    algorithms.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的程序确实打印了每对顶点的最短路径，但它的效率大致相当于执行`V`次贝尔曼-福特算法，同时还有与递归算法相关的内存缺点。
- en: Thankfully, there is a very useful bottom-up algorithm for this problem that
    is equipped to handle everything that the others can in *O(V**3**)* time and *O(V**2**)*
    space. It is also quite intuitive, particularly after having implemented the other
    shortest path algorithms in this book.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于这个问题有一个非常有用的自底向上算法，它能够在*O(V**3**)*时间和*O(V**2**)*空间内处理其他算法所能处理的一切。特别是在实现了本书中其他最短路径算法之后，这种算法也是相当直观的。
- en: The Floyd-Warshall Algorithm
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弗洛伊德-沃舍尔算法
- en: By now, we should have a fairly clear grasp of how the Bellman-Ford algorithm
    exploits the optimal substructure that's exhibited in the shortest path problem.
    The key takeaway is that any shortest path between two graph vertices is going
    to be a combination of some other shortest path beginning from the source and
    the edge connecting the path's endpoint to the destination vertex.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该已经相当清楚地掌握了贝尔曼-福特算法如何利用最短路径问题中所表现出的最优子结构。关键是，两个图顶点之间的任何最短路径都将是从源开始的某些其他最短路径和连接路径终点到目标顶点的边的组合。
- en: 'The **Floyd-Warshall algorithm** uses this same concept to great effect by
    making an even broader generalization:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**弗洛伊德-沃舍尔算法**通过使用相同的概念取得了很大的效果：'
- en: '*"If the shortest distance between Node A and Node B is AB, and the shortest
    distance between Node B and Node C is BC, then the shortest distance between Node
    A and Node C is AB + BC."*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*"如果节点A和节点B之间的最短距离是AB，节点B和节点C之间的最短距离是BC，那么节点A和节点C之间的最短距离是AB + BC。"*'
- en: This logic certainly isn't groundbreaking in and of itself; however, combined
    with the insight demonstrated by Bellman-Ford—that *V* iterations across the edges
    of a graph is sufficient to determine the shortest path from a source node and
    every other node in a graph—we can use this idea to successively generate the
    shortest paths between pairs of nodes with `Node A` as the source, and then use
    those results to generate potential shortest paths for `Node B`, `C`, `D`, and
    so on.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑本身当然并不是突破性的；然而，结合贝尔曼-福特所展示的洞察力——图的边上的*V*次迭代足以确定从源节点到图中每个其他节点的最短路径——我们可以使用这个想法来逐步生成以`节点A`为源的节点对之间的最短路径，然后使用这些结果来生成`节点B`、`C`、`D`等的潜在最短路径。
- en: Floyd-Warshall accomplishes this by performing *V**3* iterations across the
    vertices. The first dimension represents a potential midpoint, *B*, between every
    possible pair of vertices *A* and *C*. The algorithm then checks whether the currently
    known distance value from *A* to *C* is greater than the sum of the shortest known
    distances from *A* to *B* and *B* to *C*. If so, it determines that that sum is
    at least closer to the optimal shortest distance value for *A* and *C*, and caches
    it in a table. Floyd-Warshall makes these sets of comparisons using every node
    in the graph as a midpoint, continuously improving the accuracy of its results.
    After every possible start and end point pair has been tested against every possible
    midpoint, the results in the table contain the correct shortest distance values
    for every pair of vertices.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Floyd-Warshall通过在顶点之间执行*V**3*次迭代来实现这一点。第一维表示潜在的中点*B*，在每对顶点*A*和*C*之间。然后算法检查从*A*到*C*的当前已知距离值是否大于从*A*到*B*和从*B*到*C*的最短已知距离之和。如果是，它确定该和至少更接近*A*和*C*的最优最短距离值，并将其缓存到表中。Floyd-Warshall使用图中的每个节点作为中点进行这些比较，不断提高其结果的准确性。在每个可能的起点和终点对被测试过每个可能的中点之后，表中的结果包含每对顶点的正确最短距离值。
- en: Just like any graph-related algorithm, Floyd-Warshall is not guaranteed to be
    the best choice in every given circumstance, and comparative complexity between
    Floyd-Warshall and other alternatives should always be considered. A good rule
    of thumb is to use Floyd-Warshall for dense graphs (that is, graphs containing
    a large number of edges). Imagine, for example, that you have a graph with 100
    vertices and 500 edges. Running the Bellman-Ford algorithm (with a worst-case
    complexity of *O(V×E)*) on each starting vertex successively could potentially
    lead to a total complexity of 500×100×100 (or 5,000,000) operations, whereas Floyd-Warshall
    would require 100×100×100 (or 1,000,000) operations. Dijkstra's algorithm is usually
    more efficient than Bellman-Ford and may also be a viable alternative. Nevertheless,
    one distinct advantage of Floyd-Warshall is the fact that the overall complexity
    of the algorithm is always exactly *O(V**3**)*, regardless of the other properties
    of the input graph. So, we do not need to know any details about the graph we
    are using other than the number of vertices to be able to determine exactly how
    efficient (or inefficient) Floyd-Warshall will be.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何与图相关的算法一样，Floyd-Warshall并不保证在每种情况下都是最佳选择，应始终考虑Floyd-Warshall和其他替代方案之间的比较复杂性。一个很好的经验法则是在稠密图（即包含大量边的图）中使用Floyd-Warshall。例如，假设你有一个包含100个顶点和500条边的图。在每个起始顶点上连续运行Bellman-Ford算法（最坏情况下的复杂度为*O(V×E)*)可能导致总复杂度为500×100×100（或5,000,000）次操作，而Floyd-Warshall只需要100×100×100（或1,000,000）次操作。Dijkstra算法通常比Bellman-Ford更有效，也可能是一个可行的替代方案。然而，Floyd-Warshall的一个明显优势是算法的总体复杂度始终是*O(V**3**)*，不需要知道输入图的其他属性，就能确定Floyd-Warshall的效率（或低效性）。
- en: A final point to consider is the fact that, like Bellman-Ford (and unlike Dijkstra's
    algorithm), Floyd-Warshall is equipped to handle graphs with negative edge weights
    but will also be thwarted by negative edge weight cycles without explicit handling.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要考虑的一点是，与Bellman-Ford（不同于Dijkstra算法），Floyd-Warshall能够处理具有负边权重的图，但也会受到负边权重循环的阻碍，除非有明确的处理。
- en: We'll implement the Floyd-Warshall algorithm in the following exercise.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下练习中实现Floyd-Warshall算法。
- en: 'Exercise 44: Implementing the Floyd-Warshall Algorithm'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习44：实现Floyd-Warshall算法
- en: 'In this exercise, we shall find the shortest distance between every pair of
    vertices using the Floyd-Warshall algorithm. Let''s get started:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Floyd-Warshall算法找到每对顶点之间的最短距离。让我们开始吧：
- en: 'We will begin by including the following headers and defining an `UNKNOWN`
    constant:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先包括以下标头并定义一个`UNKNOWN`常量：
- en: '[PRE57]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s begin by handling the input almost exactly like we did in the previous
    exercise. This time, however, we have no need for an adjacency list representation
    of the graph:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先处理输入，几乎与我们在上一个练习中所做的完全相同。然而，这一次，我们不需要图的邻接表表示：
- en: '[PRE58]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Our `FloydWarshall()` function will take two arguments—`V` and `weight`—and
    will return a two-dimensional integer vector of shortest-path distances:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`FloydWarshall()`函数将接受两个参数——`V`和`weight`——并返回一个二维整数向量，表示最短路径距离：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s define a two-dimensional DP table with the name `distance` and with
    every value initialized to `UNKNOWN`. Then, we need to assign the initially known
    shortest distance "estimates" for each pair of nodes (that is, the values in the
    `weight` matrix), as well as the base case values (that is, the shortest distance
    from every node to itself, `0`):'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`distance`的二维DP表，并将每个值初始化为`UNKNOWN`。然后，我们需要为每对节点分配最初已知的最短距离“估计”（即`weight`矩阵中的值），以及基本情况值（即从每个节点到自身的最短距离`0`）：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will now perform three nested `for` loops from `0` to `V – 1` (inclusive),
    with the outer loop representing the current intermediate vertex, `mid`, the middle
    loop representing the source vertex, `start`, and the innermost loop representing
    the destination vertex, `end`. We will then compare distance values between every
    combination of vertices and reassign the distance value from start to end whenever
    a shorter path is found:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从`0`到`V – 1`（包括）执行三个嵌套的`for`循环，外部循环表示当前中间顶点`mid`，中间循环表示源顶点`start`，最内部循环表示目标顶点`end`。然后我们将比较每对顶点之间的距离值，并在找到更短的路径时重新分配从起点到终点的距离值：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Similar to Bellman-Ford, we will need to check for negative cycles if our input
    is expected to contain negative edge weights. Thankfully, this can be accomplished
    with great ease using the distance table.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于Bellman-Ford，如果我们的输入预计包含负边权重，我们需要检查负循环。值得庆幸的是，使用距离表可以很容易地实现这一点。
- en: 'Consider the fact that a graph cycle is a path that has a length greater than
    zero and is where the start and end vertices are the same. In a table representing
    distances between each pair of nodes, the shortest path between a node and itself
    will be contained in `distance[node][node]`. In a graph containing only positive
    edge weights, the value contained in `distance[node][node]` can clearly only ever
    be equal to `0`; however, if the graph contains a negative weight cycle, `distance[node][node]`
    will be negative. Thus, we can test for negative cycles like so:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到图中的循环是一条长度大于零的路径，起点和终点顶点相同。在表示每对节点之间的距离的表中，节点和自身之间的最短路径将包含在`distance[node][node]`中。在只包含正边权的图中，`distance[node][node]`中包含的值显然只能等于`0`；然而，如果图中包含负权重循环，`distance[node][node]`将为负。因此，我们可以这样测试负循环：
- en: '[PRE62]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we have finished writing the algorithm, we can perform a call to `FloydWarshall()`
    in `main()` and output the results:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了算法的编写，可以在`main()`中调用`FloydWarshall()`并输出结果：
- en: '[PRE63]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s run our program on the following set of input:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在以下输入集上运行我们的程序：
- en: '[PRE64]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let''s try another set of input:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试另一组输入：
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see, Floyd-Warshall is an incredibly useful algorithm that is not
    only effective but quite easy to implement. In terms of efficiency, whether we
    should choose Floyd-Warshall or Johnson's algorithm depends entirely on the structure
    of the graph. But strictly in terms of ease of implementation, Floyd-Warshall
    is the clear winner.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Floyd-Warshall是一种非常有用的算法，不仅有效而且相当容易实现。在效率方面，我们应该选择Floyd-Warshall还是Johnson算法完全取决于图的结构。但严格从实现的角度来看，Floyd-Warshall是明显的赢家。
- en: 'Activity 23: Residential Roads'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动23：住宅道路
- en: You are the head of a real estate development project that is planning on constructing
    a number of high-end residential communities. You've been given a variety of information
    about the various properties where developments will be built and are currently
    tasked with designing a system of roads as cheaply as possible.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一个房地产开发项目的负责人，计划建造一些高端住宅社区。你已经收到了关于将要建造的各种属性的各种信息，目前的任务是尽可能便宜地设计一套道路系统。
- en: Many of the communities are set to be built in areas replete with lakes, forests,
    and mountains. In these areas, the terrain is often quite rugged, which can make
    construction much more complicated. You have been warned that the cost of building
    increases based on the ruggedness of the terrain. For your first drafts, you are
    told to consider the increase in cost linearly, relative to the ruggedness value
    of each coordinate where a road may be built.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 许多社区计划建在湖泊、森林和山区。在这些地区，地形通常非常崎岖，这可能会使建筑变得更加复杂。你已经被警告，建筑成本会根据地形的崎岖程度而增加。在初稿中，你被告知要考虑成本的增加是与可以建造道路的每个坐标的崎岖值成正比的。
- en: 'You''ve been given the following information:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经收到了以下信息：
- en: Maps of the properties
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性地图
- en: The coordinates where properties can be built
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以建造属性的坐标
- en: The ruggedness of the terrain at each coordinate
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个坐标的地形崎岖程度
- en: 'You have also been given the following guidelines for determining how roads
    should be built:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你还收到了确定如何建造道路的以下准则：
- en: Points on the map where a road may be built will be marked with "`.`" characters.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图上可以建造道路的位置将用“。”字符标记。
- en: Roads may only be built between two houses that have a direct vertical, horizontal,
    or diagonal path between them.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能在两个房屋之间建造道路，这两个房屋之间有直接的垂直、水平或对角线路径。
- en: All the houses in the community should be reachable from every other house.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区中的所有房屋都应该可以从其他房屋到达。
- en: Roads may not be built across bodies of water, mountains, forests, and so on.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 道路不能建在水域、山区、森林等地方。
- en: The cost of building a road between two houses is equal to the sum of ruggedness
    values on the path between them.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个房屋之间建造道路的成本等于它们之间路径上的地形崎岖值之和。
- en: A road between two houses should be built only if it is on the path with the
    lowest possible cost to the designated entry point of the property.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在建造的道路是通往指定入口的最低成本路径上时，两个房屋之间才应该建造一条道路。
- en: The entrance point is always the highest indexed house in the input.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口点始终是输入中索引最高的房屋。
- en: 'Once the positions of the houses and roads have been determined, you should
    produce a new version of the original map according to the following legend:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了房屋和道路的位置后，应根据以下图例生成原始地图的新版本：
- en: Houses should be labeled with uppercase letters corresponding to the order they
    were given in input (that is, 0 = `A`, 1 = `B`, 2 = `C` and so on).
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房屋应该用大写字母标记，对应于它们在输入中给出的顺序（即0=`A`，1=`B`，2=`C`等）。
- en: Roads should be indicated with the characters `|`, `-`, `\`, and `/`, depending
    on their orientation. If two roads with different orientations intersect, this
    should be indicated with the `+` character.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 道路应该用字符`|`、`-`、`\`和`/`表示，取决于它们的方向。如果两条具有不同方向的道路相交，应该用`+`字符表示。
- en: Everything else on the map should be displayed as it was originally given in
    the input.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图上的其他所有内容应该显示为输入中原始给出的样子。
- en: '**Input Format**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入格式**'
- en: 'The program should take an input in the following format:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应按以下格式接受输入：
- en: The first line contains two space-separated integers, `H` and `W`, representing
    the height and width of the map.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含两个以空格分隔的整数`H`和`W`，表示地图的高度和宽度。
- en: The second contains a single integer, `N`, which is the number of houses to
    be built.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行包含一个整数`N`，表示要建造的房屋数量。
- en: The next `H` lines each contain a string of length `W`, representing a row on
    the grid. Valid locations for building roads will be marked with the "`.`" character.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的`H`行每行包含一个长度为`W`的字符串，表示网格上的一行。可以建造道路的有效位置将用“。”字符标记。
- en: The next `N` lines contain two integers, `x` and `y`, which are the coordinates
    of the houses. The final index (that is, `N - 1`) always represents the entry
    point to the community.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的`N`行包含两个整数`x`和`y`，它们是房屋的坐标。最后一个索引（即`N-1`）始终代表社区的入口点。
- en: '**Output Format**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出格式**'
- en: 'The program should output the same map given in the input, with the following
    additions:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应输出与输入中给出的相同地图，并添加以下内容：
- en: The positions of each house should be labeled with uppercase letters corresponding
    to their zero-based index, with the origin on the top left, relative to `N` (that
    is, 0 = `A`, 1 = `B`, 2 = `C`, and so on).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个房屋的位置应标有大写字母，对应它们的从零开始的索引，原点在左上角，相对于`N`（即0 = `A`，1 = `B`，2 = `C`，依此类推）。
- en: 'The roads connecting each pair of houses should be indicated as follows:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接每对房屋的道路应如下所示：
- en: '`-` if the road''s orientation is horizontal'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`-` 如果道路的方向是水平的'
- en: '`|` if the road''s orientation is vertical'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`|` 如果道路的方向是垂直的'
- en: '`/` or `\` if the road''s orientation is diagonal'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 或 `\` 如果道路的方向是对角线的'
- en: '`+` if any number of roads with different orientations intersect at the same
    point'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 如果任意数量的具有不同方向的道路在同一点相交'
- en: '**Hints/Guidelines**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示/指导**'
- en: To produce the final result, a number of distinct steps are required. It is
    recommended that you outline the necessary steps prior to their implementation.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要得出最终结果，需要一些不同的步骤。建议您在实施之前概述必要的步骤。
- en: It may be quite helpful to devise some scheme for debugging and producing test
    output for each individual part of the program. A mistake early on in the process
    is likely to cause subsequent steps to fail.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个程序的各个部分设计一些调试和生成测试输出的方案可能非常有帮助。在过程的早期出现错误可能会导致后续步骤失败。
- en: Study the simpler input and output samples if you are having trouble understanding
    what needs to be done.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在理解需要完成的任务方面有困难，请研究更简单的输入和输出示例。
- en: Start by implementing the algorithms you know you will need, particularly the
    ones we discussed in the previous chapter. There may be multiple ways to accomplish
    each part of this task—be creative!
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先实施您知道需要的算法，特别是我们在上一章讨论过的算法。完成此任务的每个部分可能有多种方法-要有创造力！
- en: '**Test Cases**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试案例**'
- en: 'These test cases should help you understand how you need to proceed. Let''s
    begin by taking a simple example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试案例应该帮助您了解如何继续。让我们从一个简单的例子开始：
- en: '![Figure 9.18: Activity 23, test cases 1 (left) and 2 (right)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18：活动23，测试案例1（左）和2（右）'
- en: '](img/C14498_09_18.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_09_18.jpg)'
- en: 'Figure 9.18: Activity 23, test cases 1 (left) and 2 (right)'
  id: totrans-370
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.18：活动23，测试案例1（左）和2（右）
- en: 'Let''s consider the sample output on the right side of the previous figure.
    In that example, a path from `E(0,4)` to `C(5,4)` cannot be built as impassable
    obstacles, `#`, exist. Let''s consider a few more samples with more complexity:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们考虑前一图中右侧的示例输出。在该示例中，从`E（0,4）`到`C（5,4）`的路径无法建立，因为存在不可通过的障碍物`#`。让我们考虑一些更复杂的示例： '
- en: '![Figure 9.19: Activity 23, test cases 3 (left) and 4 (right)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.19：活动23，测试案例3（左）和4（右）'
- en: '](img/C14498_09_19.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_09_19.jpg)'
- en: 'Figure 9.19: Activity 23, test cases 3 (left) and 4 (right)'
  id: totrans-374
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.19：活动23，测试案例3（左）和4（右）
- en: 'Note that the different symbols are used to represent different types of obstacles.
    Though the effect of any obstacle is the same, we cannot build a road there. Finally,
    let''s step up the complexity in the following example:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不同的符号用于表示不同类型的障碍物。尽管任何障碍物的影响都是相同的，但我们不能在那里建造道路。最后，让我们在以下示例中增加复杂性：
- en: '![Figure 9.20: Activity 23, test case 5'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20：活动23，测试案例5'
- en: '](img/C14498_09_20.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_09_20.jpg)'
- en: 'Figure 9.20: Activity 23, test case 5'
  id: totrans-378
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.20：活动23，测试案例5
- en: Note
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 585.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第585页找到。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that you have completed this chapter, you should have a fairly high appreciation
    for the value of dynamic programming. If you initially found this topic to be
    somewhat anxiety-provoking, you have hopefully come to realize that it is not
    as complicated as it may have first appeared. Viewing familiar problems through
    the dynamic programming lens, as we did in this chapter, can certainly help us
    understand the core ideas that are needed to arrive at a working DP solution.
    To that end, we encourage you to investigate other variants of the knapsack problem
    and attempt to implement them using the strategies provided.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了本章，您应该对动态规划的价值有相当高的欣赏。如果您最初发现这个主题有些焦虑，希望您已经意识到它并不像最初看起来那么复杂。像我们在本章中所做的那样，通过动态规划的视角来看待熟悉的问题，肯定可以帮助我们理解需要达到工作动态规划解决方案所需的核心思想。为此，我们鼓励您调查背包问题的其他变体，并尝试使用提供的策略来实现它们。
- en: And with that, your tour through the vast world of algorithms and data structures
    in C++ has reached its conclusion. Having arrived at the end of this book, you
    should have a markedly deepened understanding of how and when to use some of the
    most useful tools of our trade. Hopefully, you have developed a better sense of
    the practical applications of the structures and techniques that were covered
    in this book, as well as an expanded knowledge of the C++ language and its vast
    collection of features.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，您在C++中算法和数据结构的广阔世界中的旅程已经结束。到达本书的末尾，您应该对何时以及如何使用我们行业中最有用的工具有了明显加深的理解。希望您对本书中涵盖的结构和技术的实际应用有了更好的认识，以及对C++语言及其丰富的功能集有了更广泛的了解。
- en: It should be noted that the appropriate occasions to use many of these techniques
    in practice are not necessarily obvious, which is why it is immensely beneficial
    to apply what you have learned to a range of different contexts. We have endeavored
    to provide a variety of interesting activities for practicing the concepts in
    this book, but it is highly recommended that you also try to use these skills
    in other situations. There are a plethora of online resources offering unique
    and engaging programming challenges for developers of all levels, which can be
    invaluable if you wish to train yourself to recognize how certain techniques can
    be utilized in a variety of circumstances.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，实践中使用许多这些技术的适当场合并不一定明显，这就是为什么将所学知识应用于各种不同的情境中是非常有益的。我们努力提供了一系列有趣的活动来练习本书中的概念，但强烈建议您也尝试在其他情况下使用这些技能。有大量在线资源提供独特而引人入胜的编程挑战，适合各个级别的开发人员，如果您希望训练自己认识到某些技术如何在各种情况下被利用，这些资源将是非常宝贵的。
- en: Certainly, every topic that we've discussed in this book deserves much deeper
    study than what can be covered in any single book, and we hope that the information
    we have provided has made these topics accessible enough to encourage you to explore
    them deeper. Regardless of whether you are a student, looking for a development
    job, or already working in the field professionally, you are likely to encounter
    a use for at least one (and likely many) of the subjects that were covered in
    this book; and with any luck, you will know exactly what to do when that time
    comes!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在本书中讨论的每个主题都值得进行比任何一本书所能涵盖的更深入的研究，我们希望我们提供的信息足够使这些主题变得易于访问，以鼓励您深入探索它们。无论您是学生，正在寻找发展工作，还是已经在专业领域工作，您可能会遇到本书涵盖的至少一个（很可能是许多）主题的用途；并且幸运的话，当那个时机来临时，您将会知道该怎么做！
