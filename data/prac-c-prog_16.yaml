- en: Low-Level Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级编程
- en: 'Sometimes, for precise results and in order to overcome the limitations of
    a programming language, you need to control the content of CPU registers at the
    bit level. In such situations, you can make use of two things: bitwise operators
    and assembly language programming.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了获得精确的结果并克服编程语言的限制，您需要控制CPU寄存器的内容在位级别。在这种情况下，您可以利用以下两个东西：位运算符和汇编语言编程。
- en: 'In this chapter, we will learn how to perform the following recipes in order
    to carry out low-level programming in C:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何执行以下操作，以便在C中进行底层编程：
- en: Converting a binary number into a decimal using a bitwise operator
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位运算符将二进制数转换为十进制
- en: Converting a decimal into binary using a bitwise operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位运算符将十进制转换为二进制
- en: Converting a decimal number into binary using bit masking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位掩码将十进制数转换为二进制
- en: Multiplying two numbers using the inline assembly language in C
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C中的内联汇编语言进行乘法
- en: Dividing two numbers using assembly code in C
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C中的汇编代码进行除法
- en: Introduction to bitwise operators
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算符简介
- en: Every number that we enter into any variable is internally stored in the form
    of binary digits. To perform bit-level operations, C provides the following bitwise
    operators.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将任何数字输入任何变量时，都是内部以二进制位的形式存储。为了执行位级操作，C提供了以下位运算符。
- en: '& (binary AND)'
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '&（二进制与）'
- en: This results in a binary 1 if both the operands are 1\. If either of the bits
    is 0, then the result of the & operation is 0.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数都是1，则结果为二进制1。如果任一位是0，那么&操作的结果为0。
- en: 'Assuming that operand A has a value of 1010 and operand B has a value of 0111,
    then A&B will be as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设操作数A的值为1010，操作数B的值为0111，那么A&B的结果如下：
- en: '| A | 1010 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| A | 1010 |'
- en: '| B | 0111 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| B | 0111 |'
- en: '| A&B | 0010 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| A&B | 0010 |'
- en: '| (binary OR)'
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '|（二进制或）'
- en: This results in a binary 1 if either of the operands is 1\. If both of the bits
    are 0, then the result of the | operation is 0.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任一操作数为1，则结果为二进制1。如果两个位都是0，那么|操作的结果为0。
- en: 'Assuming that operand A has a value of 1010 and operand B has a value of 0111,
    then A|B will be as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设操作数A的值为1010，操作数B的值为0111，那么A|B的结果如下：
- en: '| A | 1010 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| A | 1010 |'
- en: '| B | 0111 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| B | 0111 |'
- en: '| A&#124;B | 1111 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| A|B | 1111 |'
- en: ^ (binary XOR)
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ^（二进制异或）
- en: This results in a binary 1 if either of the operands is 1 but not both. If both
    of the bits are 0, or if both are 1, then the result of the ^ operation is 0.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任一操作数为1但不是两者都为1，则结果为二进制1。如果两个位都是0或都是1，则^操作的结果为0。
- en: 'Assuming that operand A has a value of 1010 and operand B has a value of 0111,
    then A^B will be as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设操作数A的值为1010，操作数B的值为0111，那么A^B的结果如下：
- en: '| A | 1010 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| A | 1010 |'
- en: '| B | 0111 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| B | 0111 |'
- en: '| A^B | 1111 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| A^B | 1111 |'
- en: ~ (binary complement)
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ~（二进制补码）
- en: 'This negates or inverses the binary digits of the operand. That is, the binary
    digit 1 will be converted to 0 and vice versa. Assuming that operand A has a value
    of 1010, then ~A will be as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将反转操作数的二进制位。也就是说，二进制位1将转换为0，反之亦然。假设操作数A的值为1010，那么~A的结果如下：
- en: '| A | 1010 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| A | 1010 |'
- en: '| ~A | 0101 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| ~A | 0101 |'
- en: << (binary shift left)
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <<（二进制左移）
- en: This left-shifts the binary digits of the operand by the specified number of
    bits, and the empty space created after the least significant bits is filled with
    0s.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将操作数的二进制位向左移动指定的位数，并在最低有效位之后创建的空位用0填充。
- en: 'Assuming that operand A has a value of 00001010, then left-shifting A by 2
    bits (A<<2) will give us the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设操作数A的值为00001010，那么将A左移2位（A<<2）将得到以下结果：
- en: '| A | 00001010 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| A | 00001010 |'
- en: '| A<<2 | 00101000 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| A<<2 | 00101000 |'
- en: On every left-shift, the value of the operand is multiplied by powers of 2\.
    That is, if the operand is left-shifted by 2 bits, that means it is multiplied
    by 2 x 2, that is, 4.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次左移时，操作数的值乘以2的幂。也就是说，如果操作数左移2位，那么它乘以2 x 2，即4。
- en: '>> (binary shift right)'
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '>>（二进制右移）'
- en: This right-shifts the binary digits of the operand by the specified number of
    bits, and the empty space created after the most significant bits is filled with
    0s.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作将操作数的二进制位向右移动指定的位数，并在最高有效位之后创建的空位用0填充。
- en: 'Assuming that operand A has a value of 00001010, then right-shifting A by 2
    bits (A>>2) will give us the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设操作数A的值为00001010，那么将A右移2位（A>>2）将得到以下结果：
- en: '| A | 00001010 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| A | 00001010 |'
- en: '| A>>2 | 00000010 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| A>>2 | 00000010 |'
- en: You can see that on right-shifting, the least significant bits are dropped off.
    On every right-shift, the value of the operand is divided by powers of 2\. That
    is, if the operand is right-shifted by 2 bits, that means it is divided by 2 x
    2, that is, 4.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在右移时，最低有效位被丢弃。在每次右移时，操作数的值被除以 2 的幂。也就是说，如果操作数向右移动 2 位，这意味着它被除以 2 x 2，即
    4。
- en: Let's go on to gain some practical knowledge by making some working recipes.
    The first recipe is next.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过制作一些实际的工作食谱来获取一些实际知识。第一个食谱是下一个。
- en: Converting a binary number into a decimal using a bitwise operator
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位运算符将二进制数转换为十进制数
- en: In this recipe, you will learn how to convert a binary number into a decimal.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你将学习如何将二进制数转换为十进制数。
- en: How to do it…
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To convert a binary number into a decimal, perform the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要将二进制数转换为十进制数，执行以下步骤：
- en: Enter a binary number.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个二进制数。
- en: Apply a mod 10 (`% 10`) operator to the binary digits of the binary number to
    isolate the last bit of the binary number.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模 10 (`% 10`) 操作符应用于二进制数的二进制数字，以隔离二进制数的最后一位。
- en: Left-shift the binary digit isolated in *step 2* to multiply it by the power
    of 2.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在 *步骤 2* 中隔离的二进制数字左移，乘以 2 的幂。
- en: Add the product of the previous multiplication to the variable that will store
    the result, that is, the decimal number. Let's call the variable `dec`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一次乘法的结果加到将要存储结果的变量中，即十进制数。我们可以称这个变量为 `dec`。
- en: The last digit of the binary number is truncated.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制数的最后一位被截断。
- en: Repeat *step 2* to *step 4* until all the bits of the binary digits are over.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 2* 到 *步骤 4*，直到二进制数字的所有位都处理完毕。
- en: Display the decimal in the `dec` variable.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `dec` 变量中显示十进制数。
- en: 'The program for converting a binary number into a decimal is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制数转换为十进制数的程序如下：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You will be prompted to enter a binary number. The number you enter will be
    assigned to the `bin` variable. The binary number is temporarily assigned to a
    `temp` variable. A `while` loop is executed until the binary number in the `bin` variable
    becomes 0.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示输入一个二进制数。你输入的数字将被分配给 `bin` 变量。二进制数临时分配给一个名为 `temp` 的变量。执行一个 `while` 循环，直到
    `bin` 变量中的二进制数变为 0。
- en: Let's assume that the binary number entered in the `bin` variable is `1101`.
    Then, we will apply the `mod` (`%`) operator to the binary digits in the `bin` variable
    in order to isolate its last bit. In fact, the `%` operator divides by the specified
    number and returns the remainder. That is, when `% 10` is applied to `1 1 0 1`,
    it will return `1`, which is then assigned to the `num` variable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设输入到 `bin` 变量的二进制数是 `1101`。然后，我们将对 `bin` 变量中的二进制数字应用 `mod` (`%`) 操作符，以隔离其最后一位。实际上，`%`
    操作符除以指定的数字并返回余数。也就是说，当 `1 1 0 1` 应用 `% 10` 时，它将返回 `1`，然后分配给 `num` 变量。
- en: A `topower` variable is initialized to `0`. The purpose of the `topower` variable
    is to left-shift the digits, that is, to multiply the binary digits by the power
    of `2`. The binary digit `1` in the `num` variable is added to another variable
    called `dec`. The value of the `topower` variable is incremented to `1`. The binary
    number `1 1 0 1` in the `bin` variable is truncated to `1 1 0` by dividing it
    by `10` and removing the fraction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`topower` 变量初始化为 `0`。`topower` 变量的目的是将数字左移，即乘以 `2` 的幂。`num` 变量中的二进制数字 `1` 被添加到另一个名为
    `dec` 的变量中。`topower` 变量的值增加至 `1`。`bin` 变量中的二进制数 `1 1 0 1` 通过除以 `10` 并去除小数部分被截断为
    `1 1 0`。'
- en: Again, the whole procedure is repeated. The last digit in the `bin` variable
    is isolated by the application of the `%10` operator; that is, `0` will be isolated
    from `1 1 0` and assigned to the `num` variable. The binary digit `0` is left-shifted
    by `1` bit, making it `0 0`. So, a value of `0` is then added to the value in the `dec` variable;
    that is, the value in the `dec` variable remains `1`. The value of `topower` is
    incremented to `2`. The last digit of the binary digit `1 1 0` in the `bin` variable
    is removed by dividing it by `10`; therefore, the binary digit in the `bin` variable
    will become `1 1`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，整个过程重复进行。通过应用 `%10` 操作符，`bin` 变量中的最后一个数字被隔离；也就是说，`0` 将从 `1 1 0` 中隔离出来并分配给
    `num` 变量。二进制数字 `0` 向左移动 `1` 位，变成 `0 0`。因此，`0` 的值被加到 `dec` 变量的值上；也就是说，`dec` 变量的值保持为
    `1`。`topower` 的值增加至 `2`。通过除以 `10`，`bin` 变量中二进制数字 `1 1 0` 的最后一个数字被移除；因此，`bin` 变量中的二进制数字将变为
    `1 1`。
- en: Once again, apply `%10` to `1 1`; the remainder will be `1`, which will be assigned
    to the `num` variable. The binary digit `1` is left-shifted by 2 bits, making
    it `1 0 0`. The binary value `1 0 0` represents `4`, which is then added to the
    value in the `dec` variable. The value in the `dec` variable was `1`, and after
    adding `4` to it, the total in the `dec` variable will become `5`. Again, the
    value in the `topower` variable will be incremented, making its value `3`. The
    last digit of the binary digits (`1 1`) in the `bin` variable will be truncated
    by dividing it by 10\. Hence, the digit in the `bin` variable will become `1`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，将 `1 1` 应用 `%10`；余数将是 `1`，它将被分配给 `num` 变量。二进制位 `1` 向左移动了 2 位，变成了 `1 0 0`。二进制值
    `1 0 0` 代表 `4`，然后将其加到 `dec` 变量中的值上。`dec` 变量中的值原本是 `1`，加上 `4` 后，`dec` 变量中的总和将变为
    `5`。再次，`topower` 变量中的值将增加，使其值变为 `3`。`bin` 变量中二进制位 (`1 1`) 的最后一位将被除以 10 截断。因此，`bin`
    变量中的数字将变为 `1`。
- en: Again, `%10` is applied to binary digit `1` in the `bin` variable. As a result
    of this, `1` will be assigned to the `num` variable. The binary digit `1` in the `num` variable
    is left-shifted by 3 bits, making it `1 0 0 0`. The binary value `1 0 0 0` represents `8`, which
    is then added to the value in the `dec` variable. The current value in the `dec` variable
    is `5`. On adding `8` to it, the value in the `dec` variable will become `13`. The
    value of the `topower` variable is incremented to `4`. The binary value `1` in the `bin` variable
    is divided by `10`, making it `0`. The `while` loop will terminate and the decimal
    value `13` in the `dec` variable is displayed on the screen.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`%10` 被应用于 `bin` 变量中的二进制位 `1`。因此，`1` 将被分配给 `num` 变量。`num` 变量中的二进制位 `1` 向左移动了
    3 位，变成了 `1 0 0 0`。二进制值 `1 0 0 0` 代表 `8`，然后将其加到 `dec` 变量中的值上。`dec` 变量当前的值是 `5`。加上
    `8` 后，`dec` 变量中的值将变为 `13`。`topower` 变量的值增加至 `4`。`bin` 变量中的二进制值 `1` 除以 `10`，变成了
    `0`。`while` 循环将终止，`dec` 变量中的十进制值 `13` 将显示在屏幕上。
- en: 'The whole procedure can be illustrated as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程可以如下表示：
- en: '![](img/40a9f30b-d8a8-41ef-b2b4-abf2fd07c7a0.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40a9f30b-d8a8-41ef-b2b4-abf2fd07c7a0.png)'
- en: Figure 16.1
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1
- en: 'Let''s use GCC to compile the `binintodec.c` program as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `binintodec.c` 程序如下：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you get no errors or warnings, this means the `binintodec.c` program has
    compiled into an executable file, `binintodec.exe`. Let''s run this executable
    file as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着 `binintodec.c` 程序已编译成可执行文件，`binintodec.exe`。让我们按照以下方式运行这个可执行文件：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Voilà! We've successfully converted a binary number to a decimal using a bitwise
    operator. Now, let's move on to the next recipe!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用位运算符将二进制数转换为十进制数。现在，让我们继续下一个菜谱！
- en: Converting a decimal into binary using a bitwise operator
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位运算符将十进制转换为二进制
- en: In this recipe, we will learn to convert a decimal number into a binary number
    by making use of a bitwise operator. Bitwise operators operate on the binary digits
    of a number and enable us to do precise manipulation as desired.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何通过使用位运算符将十进制数转换为二进制数。位运算符在数字的二进制位上操作，使我们能够进行精确的操纵，以满足我们的需求。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To convert a decimal number into a binary number by making use of a bitwise
    operator, perform the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过使用位运算符将十进制数转换为二进制数，执行以下步骤：
- en: Enter a decimal number. This number is internally stored in the form of binary
    digits.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个十进制数。这个数字以二进制位的形式内部存储。
- en: Isolate the least significant bit of the decimal number by applying a logical
    AND operation between the entered decimal number and value `1`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在输入的十进制数和值 `1` 之间应用逻辑与操作来隔离十进制数的最低有效位。
- en: The least significant bit that results from *step 2* is stored in an array.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*步骤 2* 得到的最低有效位被存储在数组中。'
- en: Right-shift the binary digits of the decimal number by 1 bit. On shifting to
    the right, the second least significant bit will become the least significant
    bit.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将十进制数的二进制位向右移动 1 位。向右移动时，第二位最低有效位将变成最低有效位。
- en: Repeat *steps 2* to *4* until all the binary digits of the decimal number are
    placed into the array.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 2* 到 *4*，直到将十进制数的所有二进制位放入数组中。
- en: The binary digits assigned to the array are the binary version of the entered
    decimal number. Display the binary digits in an array to get the result.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配给数组的二进制位是输入的十进制数的二进制版本。将二进制位显示在数组中以获得结果。
- en: 'The program for converting a decimal into a binary number using a bitwise operator
    is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位运算符将十进制数转换为二进制数的程序如下：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's go behind the scenes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You will be prompted to enter a decimal number. The number you enter is assigned
    to the `num` variable. The value entered in the `num` variable is temporarily
    assigned to another variable, `temp`. A `while` loop is set to execute until the
    value of `num` becomes `0`. Apply the logical AND operation to isolate each binary
    digit of the number. For example, if the value entered in variable `num` is `13`,
    then, internally, it will be stored in a binary format as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示输入一个十进制数。你输入的数字将被分配给`num`变量。`num`变量中输入的值暂时分配给另一个变量`temp`。设置一个`while`循环，直到`num`的值变为`0`时执行。应用逻辑AND操作以隔离数字的每个二进制位。例如，如果变量`num`中输入的值是`13`，那么，在内部，它将以以下二进制格式存储：
- en: '![](img/843a9aec-7d2c-4131-9ece-3d1bd50c3e1f.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/843a9aec-7d2c-4131-9ece-3d1bd50c3e1f.png)'
- en: Figure 16.2
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2
- en: 'Now, the least significant bit is isolated by applying the AND operation. That
    is, the binary digits of `13`are ANDed with `1` as follows. The ANDed means the
    AND operation is applied on binary digits of 13 and 1 :'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过应用AND操作来隔离最低有效位。也就是说，`13`的二进制数字与`1`进行AND操作如下。AND操作意味着在`13`的二进制数字和`1`上应用AND操作：
- en: '![](img/3ab2537f-2235-4ae0-a780-95128ed0d245.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ab2537f-2235-4ae0-a780-95128ed0d245.png)'
- en: Figure 16.3
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3
- en: 'The application of AND on binary digits** `1`** and `1` results in `1`. If
    either of the binary digits is `0`, then the result of AND will be `0`. So, the
    output of `num` AND `1` will be **1**, which will be stored into array `p` at
    index location `0` as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对二进制数字**`1`**和**`1`**进行AND操作的结果是`1`。如果任一二进制数字是`0`，那么AND操作的结果将是`0`。因此，`num`与`1`的AND操作的结果将是**`1`**，然后将被存储到数组`p`的索引位置`0`，如图下所示：
- en: '![](img/de43bfe9-797e-4c46-9902-d77cde9f5efc.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de43bfe9-797e-4c46-9902-d77cde9f5efc.png)'
- en: Figure 16.4
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4
- en: 'After that, right-shift the digits in the `num` variable by 1 bit. On shifting
    to the right, the least significant bit, `1`, will be dropped off and a `0` will
    be added to the most significant bit. Again, the new set of binary digits in the `num` variables
    is ANDed with `1`, that is, the AND operation is applied between the new set of
    binary digits in `num ` variable and `1`. The output of `num` AND **`1` **will
    be `0`, which is then assigned to array `p` at index location `1`; that is, `0` will
    be assigned to the `p[1]` location as shown in the figure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将`num`变量中的数字右移1位。在右移时，最低有效位`1`将被移除，并在最高有效位添加一个`0`。再次，`num`变量中的新二进制数字集与`1`进行AND操作，即，在`num`变量中的新二进制数字集和`1`之间应用AND操作。`num`与**`1`**的AND操作的结果将是`0`，然后将其分配给数组`p`的索引位置`1`；即，`0`将被分配到`p[1]`位置，如图所示：
- en: '![](img/4dbdaf5c-b0e7-4355-ae9b-204533f1ba85.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4dbdaf5c-b0e7-4355-ae9b-204533f1ba85.png)'
- en: Figure 16.5
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5
- en: 'Again, right-shift the digits in the `num` variable by 1 bit. Again, the least
    significant bit, `0`, will be dropped off and a `0` will be added to the most
    significant bit. Once more, the new set of binary digits in the `num` variables
    is ANDed with `1`, as shown in *Figure 16.6(a)*. The output of the `num` variable AND `1` will
    be`1`, which is then assigned to array `p` at index location `2`. Thereafter,
    right-shift the digits in the `num` variable again by 1 bit. The most significant
    bit in the `num` variable, `1`, will be dropped off and a `0` bit will be added
    to the most significant bit location. The binary digits in `num` are once more
    ANDed with `1` . ANDed here means, the AND operation is applied between the binary
    digits in num and 1\. The output of the AND operation will be `1`, which will
    be assigned to array `p` at index location `p[3]` (*Figure 16.6(b)*):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，将`num`变量的数字右移1位。再次，最低有效位，`0`，将被移除，并在最高有效位添加一个`0`。再次，`num`变量中的新二进制数字集与`1`进行AND操作，如图*图16.6(a)*所示。`num`变量与`1`进行AND操作的结果将是`1`，然后将其分配给数组`p`的索引位置`2`。之后，再次将`num`变量中的数字右移1位。`num`变量中的最高有效位`1`将被移除，并在最高有效位位置添加一个`0`位。`num`中的二进制数字再次与`1`进行AND操作。这里的AND操作意味着在`num`的二进制数字和`1`之间应用AND操作。AND操作的结果将是`1`，然后将被分配给数组`p`的索引位置`p[3]`（*图16.6(b)*）：
- en: '![](img/62b2c593-074a-40b4-9ad7-b7450ae8a7af.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62b2c593-074a-40b4-9ad7-b7450ae8a7af.png)'
- en: Figure 16.6 (a) and (b)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 (a) 和 (b)
- en: Now, the binary digits assigned to array `p` are the binary conversion of the
    number assigned to variable `num`. Simply display the binary digits in array `p` in
    reverse order to get the result. Hence, `1 1 0 1` is the binary conversion of `13`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分配给数组`p`的二进制位是分配给变量`num`的数字的二进制转换。只需以相反的顺序显示数组`p`中的二进制位即可得到结果。因此，`1 1 0 1`是`13`的二进制转换。
- en: 'Let''s use GCC to compile the `convertintobin.c` program as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`convertintobin.c`程序，如下所示：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you get no errors or warnings, that means the `convertintobin.c` program
    has compiled into an executable file, `convertintobin.exe`. Let''s run this executable
    file as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误或警告，这意味着`convertintobin.c`程序已编译成可执行文件`convertintobin.exe`。让我们按照以下方式运行这个可执行文件：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Voilà! We've successfully converted a decimal number into a binary number using
    a bitwise operator. Now, let's move on to the next recipe!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用位运算符将十进制数转换为二进制数。现在，让我们继续下一个菜谱！
- en: Converting a decimal number into binary using bit masking
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位掩码将十进制数转换为二进制数
- en: In this recipe, we will learn how to convert a decimal number into a binary
    number by masking certain bits of a register. Masking means isolating or separating
    out the desired binary digits. Masking hides the undesired binary digits and makes
    only the desired binary digits visible.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何通过掩码寄存器的一些位将十进制数转换为二进制数。掩码意味着隔离或分离出所需的二进制位。掩码隐藏了不需要的二进制位，只使所需的二进制位可见。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To convert a decimal number into a binary number using bit masking, perform
    the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用位掩码将十进制数转换为二进制数，请执行以下步骤：
- en: Enter a decimal value. The decimal number entered is internally stored in the
    form of binary digits.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个十进制值。输入的十进制数以二进制位的形式内部存储。
- en: Assign a number `1` followed by 31 zeros to a variable called `mask`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个由一个数字`1`后跟31个零组成的数字赋值给一个名为`mask`的变量。
- en: Mask each of the binary digits of the decimal number one by one, beginning from
    the most significant bit. Apply an AND operation between the binary digits of
    the entered decimal number and the binary digits in the `mask` variable.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个掩码十进制数的一位二进制数，从最高位开始。在输入的十进制数的二进制数和`mask`变量的二进制数之间应用AND操作。
- en: Right-shift the binary digits in the `mask` variable by `1` bit making it `0
    1` followed by 30 zeros.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`mask`变量中的二进制位右移`1`位，使其变为`0 1`后跟30个零。
- en: Repeat this procedure. Apply the AND operation between the entered decimal number
    and the `mask` variable and the resultant binary digit is displayed on the screen.
    The procedure is repeated until the value in the `mask` variable becomes `0`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程。在输入的十进制数和`mask`变量之间应用AND操作，并将结果二进制位显示在屏幕上。当`mask`变量中的值变为`0`时，重复此过程。
- en: 'The program for converting a decimal number into binary using bit masking is
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制数转换为二进制数的位掩码程序如下：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's go behind the scenes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You will be prompted to enter a decimal value. The decimal value you entered
    will be assigned to the `num` variable. Let''s assume that you have entered a
    value of `13`. This value will be internally stored in the form of binary digits
    in the `num` variable as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示输入一个十进制值。您输入的十进制值将被分配给`num`变量。让我们假设您输入了一个值为`13`。此值将以以下形式作为二进制位的形式在`num`变量中内部存储：
- en: '![](img/1115dd56-feaf-42ce-a529-05c91dc5e53a.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1115dd56-feaf-42ce-a529-05c91dc5e53a.png)'
- en: Figure 16.7
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7
- en: 'We will set a `totbits` variable to `32` bits because an `int` data type in
    C consists of `32` bits, and we have to mask each bit of the number in the `num` variable
    to display its binary version. We will define a `mask` variable and assign a value
    of `1` to it. To make the value `1` in the `mask` variable appear as `10000...00`,
    that is, `1` followed by 31 zeros, we will left-shift value `1` by `31` bits as
    follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置`totbits`变量为`32`位，因为C语言中的`int`数据类型由`32`位组成，我们必须掩码`num`变量中的每个位以显示其二进制版本。我们将定义一个`mask`变量并将其赋值为`1`。为了使`mask`变量中的`1`值显示为`10000...00`，即`1`后跟31个零，我们将`1`左移`31`位，如下所示：
- en: '![](img/c45e3224-6be0-42d6-a744-1d66b328b76d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c45e3224-6be0-42d6-a744-1d66b328b76d.png)'
- en: Figure 16.8
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8
- en: Now, we will execute a `for` loop `32` times to mask or isolate each bit in
    the `num` variable and display it. Within the `for` loop, we will apply an AND
    operation on the `num` and `mask` variables. Consequently, each of the binary
    digits of the two variables will be ANDed. We know that, in the AND operation,
    the output is `1` only when both of the bits are `1`. If either of the bits is `0`,
    the AND operation will return `0`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将执行一个 `for` 循环 `32` 次，以屏蔽或隔离 `num` 变量中的每个位并显示它。在 `for` 循环中，我们将对 `num` 和
    `mask` 变量应用 AND 操作。因此，这两个变量的每个二进制位都将进行 AND 操作。我们知道，在 AND 操作中，只有当两个位都是 `1` 时，输出才是
    `1`。如果任一位是 `0`，AND 操作将返回 `0`。
- en: '*Figure 16.9* shows the application of the AND operation on the `num` and `mask` variables:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16.9* 显示了在 `num` 和 `mask` 变量上应用 AND 操作：'
- en: '![](img/7cbab9b5-10bc-40ee-b527-9c306e0aebf1.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cbab9b5-10bc-40ee-b527-9c306e0aebf1.png)'
- en: Figure 16.9
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.9
- en: 'Hence, the value `0` is returned. Thereafter, we will right-shift the binary
    digits in the `mask` variable by `1` bit, making it `0 1` followed by 30 zeros.
    Again, when the AND operation is applied between the `num` and `mask` variables,
    the result will be `0` (refer to the following figure), which is then displayed
    on the screen. So, up until now, we have `0 0` displayed on the screen:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，返回值是 `0`。之后，我们将 `mask` 变量的二进制位向右移动 `1` 位，使其变成 `0 1` 后面跟着 30 个零。再次，当在 `num`
    和 `mask` 变量之间应用 AND 操作时，结果将是 `0`（参见图），然后显示在屏幕上。所以，到目前为止，屏幕上显示的是 `0 0`：
- en: '![](img/413430bf-f501-4b95-8692-c25a76f815b0.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/413430bf-f501-4b95-8692-c25a76f815b0.png)'
- en: Figure 16.10
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.10
- en: Again, we will right-shift the binary digits in the `mask` variable by `1` bit,
    making `0 0 1` followed by 29 zeros. Again, when the AND operation is applied
    between the `num` and `mask` variables, the result will be `0`, which is then
    displayed on the screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将 `mask` 变量的二进制位向右移动 `1` 位，使其变成 `0 0 1` 后面跟着 29 个零。再次，当在 `num` 和 `mask`
    变量之间应用 AND 操作时，结果将是 `0`，然后显示在屏幕上。
- en: 'The procedure and output will be the same for the next `25` bits; that is,
    we will get 28 zeros on the screen. After that, when we apply another right-shift
    operation on the binary digits of the `mask` variable, it will become `1 0 0 0`.
    On the application of the AND operation on the `num` and `mask` variables, we
    will get an output of `1`, which is then displayed on the screen. So, for now,
    we have 28 zeros followed by `1` bit on the screen:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `25` 位的过程和输出将相同；也就是说，屏幕上会有 28 个零。之后，当我们对 `mask` 变量的二进制位应用另一个右移操作时，它将变成 `1
    0 0 0`。在 `num` 和 `mask` 变量之间应用 AND 操作后，我们将得到一个输出 `1`，然后显示在屏幕上。所以，到目前为止，屏幕上有 28
    个零后面跟着 `1` 位：
- en: '![](img/b84697f1-c54a-4d11-b609-89f6569eab28.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b84697f1-c54a-4d11-b609-89f6569eab28.png)'
- en: Figure 16.11
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.11
- en: 'As we keep repeating the procedure, we will get the outputs shown in *Figure
    16.12*. We will have 28 zeros followed by `1 1` bits on the screen (*Figure 16.12
    (a)*). After another repetition, we will have 28 zeros followed by `1 1 0` bits
    on the screen (*Figure 16.12 (b)*). In the final execution of the `for` loop, the
    final binary version of the number assigned to the `num` variable will be 28 zeros followed
    by `1 1 0 1` (*Figure 16.12 (c)*):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '随着我们不断重复这个程序，我们将得到 *图 16.12* 中显示的输出。屏幕上会有 28 个零，后面跟着 `1 1` 位 (*图 16.12 (a)*)。再次重复后，屏幕上会有
    28 个零，后面跟着 `1 1 0` 位 (*图 16.12 (b)*)。在 `for` 循环的最终执行中，分配给 `num` 变量的数字的最终二进制版本将是
    28 个零，后面跟着 `1 1 0 1` (*图 16.12 (c)*):'
- en: '![](img/ee8309cc-b22f-4bd8-8cf1-a3b045257609.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee8309cc-b22f-4bd8-8cf1-a3b045257609.png)'
- en: Figure 16.12 (a), (b), and (c)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.12 (a), (b), 和 (c)
- en: 'Let''s use GCC to compile the `decintobin.c` program as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 按以下步骤编译 `decintobin.c` 程序：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you get no errors or warnings, that means the `decintobin.c` program has
    compiled into an executable file, `decintobin.exe`. Let''s run this executable
    file as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着 `decintobin.c` 程序已编译成可执行文件，`decintobin.exe`。让我们按照以下步骤运行这个可执行文件：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Voilà! We've successfully converted a decimal number into binary using bit masking.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用位屏蔽将十进制数字转换为二进制。
- en: Introduction to assembly coding
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编语言编程简介
- en: The x86 processors have eight 32-bit general-purpose registers. The names of
    some of these general-purpose registers are EAX, EBX, ECX, and EDX. These registers
    can be used in subsections. For example, the least significant 2 bytes of EAX
    can be used as a 16-bit register called AX. Again, the least significant byte
    of AX can be used as an 8-bit register called AL and the most significant byte
    of AX can be used as an 8-bit register called AH. Similarly, the BX register can
    be used in the form of the BH and BL registers, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: x86处理器有八个32位通用寄存器。其中一些通用寄存器的名称是EAX、EBX、ECX和EDX。这些寄存器可以在子部分中使用。例如，EAX的最低2个字节可以用作16位寄存器AX。再次，AX的最低字节可以用作8位寄存器AL，而AX的最高字节可以用作8位寄存器AH。同样，BX寄存器可以用作BH和BL寄存器，依此类推。
- en: We will be writing inline assembly code in this chapter because this code is
    easily integrated with C code during code generation. Consequently, the C and
    assembly code is optimized by the compiler to produce efficient object code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中编写内联汇编代码，因为这段代码在代码生成期间很容易与C代码集成。因此，编译器会对C和汇编代码进行优化，以生成高效的对象代码。
- en: 'The syntax for using inline assembly code is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联汇编代码的语法如下：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `asm` statements are enclosed within quotes, and the outputs and inputs
    are in the form of `"constraint"` (name) pairs separated by commas. The constraints
    can be any of the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`asm`语句被引号包围，输出和输入以`"约束"（名称）对的形式呈现，由逗号分隔。约束可以是以下任何一种：'
- en: '| **Constraint ** | **Usage** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **约束** | **用法** |'
- en: '| `g` | Compiler will decide the register to be used for the variable |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 编译器将决定用于变量的寄存器 |'
- en: '| `r` | Load into any available register |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 将数据加载到任何可用的寄存器 |'
- en: '| `a` | Load into the `eax` register |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 将数据加载到`eax`寄存器 |'
- en: '| `b` | Load into the `ebx` register |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 将数据加载到`ebx`寄存器 |'
- en: '| `c` | Load into the `ecx` register |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 将数据加载到`ecx`寄存器 |'
- en: '| `d` | Load into the `edx` register |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 将数据加载到`edx`寄存器 |'
- en: '| `f` | Load into the floating-point register |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 将数据加载到浮点寄存器 |'
- en: '| `D` | Load into the `edi` register |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 将数据加载到`edi`寄存器 |'
- en: '| `S` | Load into the `esi` register |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `S` | 将数据加载到`esi`寄存器 |'
- en: The outputs and inputs are referenced by numbers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 输出和输入通过数字引用。
- en: Multiplying two numbers using the inline assembly language in C
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C中的内联汇编语言乘以两个数字
- en: In this recipe, we will learn how to multiply two numbers using the inline assembly
    language in C. By making use of inline assembly code, we can have better control
    over CPU registers, manipulate their values up to the bit level, and take advantage
    of C as well.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用C中的内联汇编语言来乘以两个数字。通过使用内联汇编代码，我们可以更好地控制CPU寄存器，在位级别上操作它们的值，并利用C的优势。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To multiply two numbers using the inline assembly language in C, perform the
    following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用C中的内联汇编语言乘以两个数字，请执行以下步骤：
- en: Load the two values to be multiplied into `eax` and `ebx` registers
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将要乘的两个值加载到`eax`和`ebx`寄存器
- en: Multiply the contents of the `eax` and `ebx` registers and store the result
    in the `eax` register
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`eax`和`ebx`寄存器的内容相乘，并将结果存储在`eax`寄存器中
- en: Display the content of the `eax` register on the screen
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上显示`eax`寄存器的内容
- en: 'The program for multiplying two digits using inline assembly code is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联汇编代码乘以两个数字的程序如下：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's go behind the scenes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's assign the two numbers that we want to multiply to two integer variables, `var1`
    and `var2`. Thereafter, we will load the contents of the `var1` variable into
    the `eax` register and the contents of the `var2` variable into the `ebx` register.
    We will multiply the contents of the `eax` and `ebx` registers and store the result
    in the `eax` register.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们想要乘的两个数字分配给两个整数变量，`var1`和`var2`。然后，我们将`var1`变量的内容加载到`eax`寄存器，将`var2`变量的内容加载到`ebx`寄存器。我们将乘以`eax`和`ebx`寄存器的内容，并将结果存储在`eax`寄存器中。
- en: The content of the `eax` register is assigned to the `multi` variable. The content
    in this variable, which contains the multiplication of two variables, is displayed
    on the screen.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`eax`寄存器的内容被分配给`multi`变量。这个变量中包含两个变量的乘积，其内容将在屏幕上显示。'
- en: 'Let''s use GCC to compile the `multiasm.c` program as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`multiasm.c`程序，如下所示：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you get no errors or warnings, that means the `multiasm.c` program has compiled
    into an executable file, `multiasm.exe`. Let''s run this executable file as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`multiasm.c`程序已编译成可执行文件，`multiasm.exe`。让我们按照以下步骤运行这个可执行文件：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Voilà! We've successfully multiplied two numbers using the inline assembly language
    in C. Now, let's move on to the next recipe!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用C语言中的内联汇编语言乘以两个数。现在，让我们继续下一个菜谱！
- en: Dividing two numbers using assembly code in C
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C语言中的汇编代码进行两个数的除法
- en: In this recipe, we will learn to divide two numbers using the inline assembly
    language in C. The assembly language provides us with better control over CPU
    registers, so we have to manually place the divisor and dividend in their respective
    registers. Additionally, after the division, the quotient and remainder will be
    automatically saved in their respective registers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用C语言中的内联汇编语言除以两个数。汇编语言为我们提供了更好的对CPU寄存器的控制，因此我们必须手动将除数和被除数放入各自的寄存器中。此外，在除法之后，商和余数将自动保存在各自的寄存器中。
- en: How to do it…
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To divide two numbers using assembly code in C, perform the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用C语言中的汇编代码除以两个数，请执行以下步骤：
- en: Load the dividend into the `eax` register.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将被除数加载到`eax`寄存器中。
- en: Load the divisor into the `ebx` register.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将除数加载到`ebx`寄存器中。
- en: Initialize the `edx` register to zero.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`edx`寄存器初始化为零。
- en: Execute the `divl` assembly statement to divide the content of the `eax` register
    by the content of the `ebx` register. By doing this division, the quotient will
    be assigned to any available register and the remainder will be assigned to the `ebx`
    register.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`divl`汇编语句，将`eax`寄存器的内容除以`ebx`寄存器的内容。通过这种方式进行除法，商将被分配给任何可用的寄存器，余数将被分配给`ebx`寄存器。
- en: The quotient is retrieved from the available register and the remainder is retrieved
    from the `ebx` register, and both are displayed on the screen.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用寄存器中检索商，从`ebx`寄存器中检索余数，并在屏幕上显示。
- en: 'The program for dividing two digits using inline assembly code is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联汇编代码除以两个数字的程序如下：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let's go behind the scenes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's assign the two numbers to be divided to the two variables `var1` and `var2`.
    Assign the dividend to `var1` and the divisor to `var2`. Thereafter, we will load
    the dividend from the `var1` variable into the `eax` register and the divisor
    from the `var2` variable into the `ebx` register.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将要除以的两个数分配给两个变量`var1`和`var2`。将被除数分配给`var1`，除数分配给`var2`。之后，我们将从`var1`变量中将被除数加载到`eax`寄存器中，并将除数从`var2`变量中加载到`ebx`寄存器中。
- en: The `edx` register has to be initialized to zero. To do this, we will initialize
    a `var3` variable to zero. From `var3`, the zero value is loaded into the `edx`
    register. Then, we will execute the `divl` assembly statement to divide the content
    of the `eax` register by the content of the `ebx` register. By doing this division,
    the quotient will be assigned to any available register and the remainder will
    be assigned to the `ebx` register.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`edx`寄存器必须初始化为零。为此，我们将一个`var3`变量初始化为零。从`var3`，零值被加载到`edx`寄存器中。然后，我们将执行`divl`汇编语句，将`eax`寄存器的内容除以`ebx`寄存器的内容。通过这种方式进行除法，商将被分配给任何可用的寄存器，余数将被分配给`ebx`寄存器。'
- en: The quotient from the available register is loaded into a variable called `quotient`,
    and the remainder from the `ebx` register is loaded into another variable called
    `remainder`. Finally, the quotient and remainder values are displayed on the screen.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从可用寄存器中将商加载到名为`quotient`的变量中，将`ebx`寄存器中的余数加载到另一个名为`remainder`的变量中。最后，在屏幕上显示商和余数的值。
- en: 'Let''s use GCC to compile the `asmdivide.c` program as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC按照以下步骤编译`asmdivide.c`程序：
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you get no errors or warnings, that means the `asmdivide.c` program has
    compiled into an executable file, `asmdivide.exe`. Let''s run this executable
    file as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`asmdivide.c`程序已编译成可执行文件，`asmdivide.exe`。让我们按照以下步骤运行这个可执行文件：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Voilà! We've successfully divided two numbers using assembly code in C.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用C语言中的汇编代码除以两个数。
