- en: Introduction to C++17 Standard Template Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍C++17标准模板库
- en: As you know, the C++ language is the brain child of Bjarne Stroustrup, who developed
    C++ in 1979\. The C++ programming language is standardized by International Organization
    for Standardization (ISO). The initial standardization was published in 1998,
    commonly referred to as C++98, and the next standardization C++03 was published
    in 2003, which was primarily a bug fix release with just one language feature
    for value initialization. In August 2011, the C++11 standard was published with
    several additions to the core language, including several significant interesting
    changes to the Standard Template Library (STL); C++11 basically replaced the C++03
    standard. C++14 was published in December, 2014 with some new features, and later,
    the C++17 standard was published on July 31, 2017\. At the time of writing this
    book, C++17 is the latest revision of the ISO/IEC standard for the C++ programming
    language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，C++语言是Bjarne Stroustrup于1979年开发的产物。C++编程语言由国际标准化组织（ISO）标准化。最初的标准化于1998年发布，通常称为C++98，下一个标准化C++03于2003年发布，主要是一个修复错误的版本，只有一个语言特性用于值初始化。2011年8月，C++11标准发布，对核心语言进行了多项增加，包括对标准模板库（STL）的一些重大有趣的更改；C++11基本上取代了C++03标准。C++14于2014年12月发布，带有一些新功能，后来，C++17标准于2017年7月31日发布。在撰写本书时，C++17是C++编程语言的最新修订版。
- en: 'This chapter requires a compiler that supports C++17 features: gcc version
    7 or later. As gcc version 7 is the latest version at the time of writing this
    book, I''ll be using gcc version 7.1.0 in this chapter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要支持C++17特性的编译器：gcc版本7或更高。由于gcc版本7是撰写本书时的最新版本，本章将使用gcc版本7.1.0。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: STL overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL概述
- en: STL architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL架构
- en: Containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Iterators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法
- en: Functors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对象
- en: STL containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL容器
- en: Sequence
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列
- en: Associative
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联
- en: Unordered
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序
- en: Adaptors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Let's look into the STL topics one by one in the following sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的章节逐个了解STL的主题。
- en: The Standard Template Library architecture
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准模板库架构
- en: The C++ **Standard Template Library** (**STL**) offers ready-made generic containers,
    algorithms that can be applied to the containers, and iterators to navigate the
    containers. The STL is implemented with C++ templates, and templates allow generic
    programming in C++.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准模板库（STL）提供了现成的通用容器、可应用于容器的算法以及用于导航容器的迭代器。STL是用C++模板实现的，模板允许在C++中进行通用编程。
- en: The STL encourages a C++ developer to focus on the task at hand by freeing up
    the developer from writing low-level data structures and algorithms. The STL is
    a time-tested library that allows rapid application development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: STL鼓励C++开发人员专注于手头的任务，摆脱了编写低级数据结构和算法的束缚。STL是一个经过时间考验的库，可以实现快速应用程序开发。
- en: 'The STL is an interesting piece of work and architecture. Its secret formula
    is compile-time polymorphism. To get better performance, the STL avoids dynamic
    polymorphism, saying goodbye to virtual functions. Broadly, the STL has the following
    four components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: STL是一项有趣的工作和架构。它的秘密公式是编译时多态性。为了获得更好的性能，STL避免了动态多态性，告别了虚函数。总的来说，STL有以下四个组件：
- en: Algorithms
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法
- en: Functors
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对象
- en: Iterators
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Containers
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: The STL architecture stitches all the aforementioned four components together.
    It has many commonly used algorithms with performance guarantees. The interesting
    part about STL algorithms is that they work seamlessly without any knowledge about
    the containers that hold the data. This is made possible due to the iterators
    that offer high-level traversal APIs, which completely abstracts the underlying
    data structure used within a container. The STL makes use of operator overloading
    quite extensively. Let's understand the major components of STL one by one to
    get a good grasp of the STL conceptually.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: STL架构将所有上述四个组件连接在一起。它具有许多常用的算法，并提供性能保证。有趣的是，STL算法可以在不了解包含数据的容器的情况下无缝工作。这是由于迭代器提供了高级遍历API，完全抽象了容器内部使用的底层数据结构。STL广泛使用运算符重载。让我们逐个了解STL的主要组件，以便对STL的概念有一个良好的理解。
- en: Algorithms
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法
- en: The STL algorithms are powered by C++ templates; hence, the same algorithm works
    irrespective of what data type it deals with or independently of how the data
    is organized by a container. Interestingly, the STL algorithms are generic enough
    to support built-in and user-defined data types using templates. As a matter of
    fact, the algorithms interact with the containers via iterators. Hence, what matters
    to the algorithms is the iterator supported by the container. Having said that,
    the performance of an algorithm depends on the underlying data structure used
    within a container. Hence, certain algorithms work only on selective containers,
    as each algorithm supported by the STL expects a certain type of iterator.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法由C++模板驱动；因此，相同的算法可以处理任何数据类型，独立于容器中数据的组织方式。有趣的是，STL算法足够通用，可以使用模板支持内置和用户定义的数据类型。事实上，算法通过迭代器与容器交互。因此，算法关心的是容器支持的迭代器。然而，算法的性能取决于容器内部使用的数据结构。因此，某些算法仅适用于特定的容器，因为STL支持的每个算法都期望一种特定类型的迭代器。
- en: Iterators
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: An iterator is a design pattern, but interestingly, the STL work started much
    before
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一种设计模式，但有趣的是，STL的工作开始得早于此
- en: '*Gang of Four* published their design patterns-related work to the software
    community. Iterators themselves are objects that allow traversing the containers
    to access, modify, and manipulate the data stored in the containers. Iterators
    do this so magically that we don''t realize or need to know where and how the
    data is stored and retrieved.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*四人帮*将他们与设计模式相关的工作发布给了软件社区。迭代器本身是允许遍历容器以访问、修改和操作容器中存储的数据的对象。迭代器以如此神奇的方式进行操作，以至于我们并不意识到或需要知道数据存储和检索的位置和方式。'
- en: 'The following image visually represents an iterator:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像直观地表示了一个迭代器：
- en: '![](img/540e553e-34b4-4deb-94d0-2b1671b4c429.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/540e553e-34b4-4deb-94d0-2b1671b4c429.png)'
- en: From the preceding image, you can understand that every iterator supports the `begin()`
    API, which returns the first element position, and the `end()` API returns one
    position past the last element in the container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图像中，您可以理解每个迭代器都支持`begin()` API，它返回第一个元素的位置，`end()` API返回容器中最后一个元素的下一个位置。
- en: 'The STL broadly supports the following five types of iterators:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: STL广泛支持以下五种类型的迭代器：
- en: Input iterators
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入迭代器
- en: Output iterators
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出迭代器
- en: Forward iterators
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向迭代器
- en: Bidirectional iterators
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向迭代器
- en: Random-access iterators
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问迭代器
- en: The container implements the iterator to let us easily retrieve and manipulate
    the data, without delving much into the technical details of a container.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 容器实现了迭代器，让我们可以轻松地检索和操作数据，而不需要深入了解容器的技术细节。
- en: 'The following table explains each of the five iterators:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了这五种迭代器中的每一种：
- en: '| **The type of iterator** | **Description                                
                  ** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: 迭代器的类型 | 描述
- en: '| Input iterator |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 输入迭代器 |'
- en: It is used to read from the pointed element
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于从指定的元素读取数据
- en: It is valid for single-time navigation, and once it reaches the end of the container,
    the iterator will be invalidated
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只能用于单次导航，一旦到达容器的末尾，迭代器将失效
- en: It supports pre- and post-increment operators
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前置和后置递增运算符
- en: It does not support decrement operators
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持递减运算符
- en: It supports dereferencing
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: It supports the `==` and `!=` operators to compare with the other iterators
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持`==`和`!=`运算符来与其他迭代器进行比较
- en: The `istream_iterator` iterator is an input iterator
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istream_iterator`迭代器是输入迭代器'
- en: All the containers support this iterator
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的容器都支持这种迭代器
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Output iterator |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 输出迭代器 |'
- en: It is used to modify the pointed element
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于修改指定的元素
- en: It is valid for single-time navigation, and once it reaches the end of the container,
    the iterator will be invalidated
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只能用于单次导航，一旦到达容器的末尾，迭代器将失效
- en: It supports pre- and post-increment operators
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前置和后置递增运算符
- en: It does not support decrement operators
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持递减运算符
- en: It supports dereferencing
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: It doesn't support the `==` and `!=` operators
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持`==`和`!=`运算符
- en: The `ostream_iterator`, `back_inserter`, `front_inserter` iterators are examples
    of output iterators
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ostream_iterator`、`back_inserter`、`front_inserter`迭代器是输出迭代器的例子'
- en: All the containers support this iterator
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的容器都支持这种迭代器
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Forward iterator |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 前向迭代器 |'
- en: It supports the input iterator and output iterator functionalities
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持输入迭代器和输出迭代器的功能
- en: It allows multi-pass navigation
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许多次导航
- en: It supports pre-increment and post-increment operators
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前置和后置递增运算符
- en: It supports dereferencing
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: The `forward_list` container supports forward iterators
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forward_list`容器支持前向迭代器'
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Bidirectional iterator |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 双向迭代器 |'
- en: It is a forward iterator that supports navigation in both directions
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个支持双向导航的前向迭代器
- en: It allows multi-pass navigation
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许多次导航
- en: It supports pre-increment and post-increment operators
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前置和后置递增运算符
- en: It supports pre-decrement and post-decrement operators
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前置和后置递减运算符
- en: It supports dereferencing
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: It supports the `[]` operator
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持`[]`运算符
- en: The `list`, `set`, `map`, `multiset`, and `multimap` containers support bidirectional
    iterators
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`、`set`、`map`、`multiset`和`multimap`容器支持双向迭代器'
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Random-access iterator |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 随机访问迭代器 |'
- en: Elements can be accessed using an arbitrary offset position
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用任意偏移位置访问元素
- en: It supports pre-increment and post-increment operators
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前置和后置递增运算符
- en: It supports pre-decrement and post-decrement operators
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前置和后置递减运算符
- en: It supports dereferencing
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: It is the most functionally complete iterator, as it supports all the functionalities
    of the other types of iterators listed previously
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是最功能完备的迭代器，因为它支持前面列出的其他类型迭代器的所有功能
- en: The `array`, `vector`, and `deque` containers support random-access iterators
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`、`vector`和`deque`容器支持随机访问迭代器'
- en: A container that supports random access will naturally support bidirectional
    and other types of iterators
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持随机访问的容器自然也支持双向和其他类型的迭代器
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Containers
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: STL containers are objects that typically grow and shrink dynamically. Containers
    use complex data structures to store the data under the hood and offer high-level
    functions to access the data without us delving into the complex internal implementation
    details of the data structure. STL containers are highly efficient and time-tested.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: STL容器通常是动态增长和收缩的对象。容器使用复杂的数据结构来存储数据，并提供高级函数来访问数据，而不需要我们深入了解数据结构的复杂内部实现细节。STL容器非常高效且经过时间考验。
- en: Every container uses different types of data structures to store, organize,
    and manipulate data in an efficient way. Though many containers may seem similar,
    they behave differently under the hood. Hence, the wrong choice of containers
    leads to application performance issues and unnecessary complexities.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器使用不同类型的数据结构以高效地存储、组织和操作数据。尽管许多容器可能看起来相似，但它们在内部的行为却有所不同。因此，选择错误的容器会导致应用程序性能问题和不必要的复杂性。
- en: 'Containers come in the following flavors:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 容器有以下几种类型：
- en: Sequential
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序
- en: Associative
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联
- en: Container adapters
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器适配器
- en: The objects stored in the containers are copied or moved, and not referenced.
    We will explore every type of container in the upcoming sections with simple yet
    interesting examples.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中存储的对象是复制或移动的，而不是引用。我们将在接下来的章节中用简单而有趣的示例探索每种类型的容器。
- en: Functors
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数对象
- en: Functors are objects that behave like regular functions. The beauty is that
    functors can be substituted in the place of function pointers. Functors are handy
    objects that let you extend or complement the behavior of an STL function without
    compromising the object-oriented coding principles.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象是行为类似于常规函数的对象。美妙之处在于函数对象可以替代函数指针。函数对象是方便的对象，可以让您扩展或补充STL函数的行为，而不会违反面向对象编程原则。
- en: Functors are easy to implement; all you need to do is overload the function
    operator. Functors are also referred to as functionoids.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象易于实现；您只需重载函数运算符。函数对象也被称为函数对象。
- en: 'The following code will demonstrate the way a simple functor can be implemented:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将演示如何实现一个简单的函数对象：
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s quickly compile the program using the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速使用以下命令编译程序：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s check the output of the program:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查程序的输出：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We hope you realize how easy and cool a functor is.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您意识到函数对象是多么简单和酷。
- en: Sequence containers
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列容器
- en: 'The STL supports quite an interesting variety of sequence containers. Sequence
    containers store homogeneous data types in a linear fashion, which can be accessed
    sequentially. The STL supports the following sequence containers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: STL支持一系列有趣的序列容器。序列容器以线性方式存储同类数据类型，可以按顺序访问。STL支持以下序列容器：
- en: Arrays
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Vectors
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量
- en: Lists
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: '`forward_list `'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forward_list`'
- en: deque
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双端队列
- en: 'As the objects stored in an STL container are nothing but copies of the values,
    the STL expects certain basic requirements from the user-defined data types in
    order to hold those objects inside a container. Every object stored in an STL
    container must provide the following as a minimum requirement:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储在STL容器中的对象只是值的副本，STL期望用户定义的数据类型满足一定的基本要求，以便将这些对象存储在容器中。存储在STL容器中的每个对象都必须提供以下最低要求：
- en: A default constructor
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: A copy constructor
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复制构造函数
- en: An assignment operator
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: Let's explore the sequence containers one by one in the following subsections.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下小节中逐一探索序列容器。
- en: Array
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'The STL array container is a fixed-size sequence container, just like a C/C++
    built-in array, except that the STL array is size-aware and a bit smarter than
    the built-in C/C++ array. Let''s understand an STL array with an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: STL数组容器是一个固定大小的序列容器，就像C/C++内置数组一样，只是STL数组具有大小感知，并且比内置的C/C++数组更智能。让我们通过一个示例了解STL数组：
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以编译，并且可以使用以下命令查看输出：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the program is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Code walkthrough
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following line declares an array of a fixed size (`5`) and initializes
    the array with five elements:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个固定大小（`5`）的数组，并用五个元素初始化数组：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The size mentioned can't be changed once declared, just like a C/C++ built-in
    array. The `array::size()` method returns the size of the array, irrespective
    of how many integers are initialized in the initializer list. The `auto pos =
    a.begin()` method declares an iterator of `array<int,5>` and assigns the starting
    position of the array. The `array::end()` method points to one position after
    the last element in the array. The iterator behaves like or mimics a C++ pointer,
    and dereferencing the iterator returns the value pointed by the iterator. The
    iterator position can be moved forward and backwards with `++pos` and `--pos`,
    respectively.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明，大小就无法更改，就像C/C++内置数组一样。`array::size()`方法返回数组的大小，不管初始化列表中初始化了多少个整数。`auto
    pos = a.begin()`方法声明了一个`array<int,5>`的迭代器，并将数组的起始位置赋给它。`array::end()`方法指向数组中最后一个元素之后的一个位置。迭代器的行为类似于或模仿C++指针，对迭代器进行解引用会返回迭代器指向的值。迭代器的位置可以向前和向后移动，分别使用`++pos`和`--pos`。
- en: Commonly used APIs in an array
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组中常用的API
- en: 'The following table shows some commonly used array APIs:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一些常用的数组API：
- en: '| **API** | **Description** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '**API** | **描述**'
- en: '| `at( int index )` | This returns the value stored at the position referred
    to by the index. The index is a zero-based index. This API will throw an `std::out_of_range`
    exception if the index is outside the index range of the array. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `at( int index )` | 这返回索引指向的位置存储的值。索引是从零开始的。如果索引超出数组的索引范围，此API将抛出`std::out_of_range`异常。'
- en: '| `operator [ int index ]` | This is an unsafe method, as it won''t throw any
    exception if the index falls outside the valid range of the array. This tends
    to be slightly faster than `at`, as this API doesn''t perform bounds checking.
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `operator [ int index ]` | 这是一个不安全的方法，如果索引超出数组的有效范围，它不会抛出任何异常。这比`at`略快，因为此API不执行边界检查。'
- en: '| `front()` | This returns the first element in the array. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 这返回数组中的第一个元素。'
- en: '| `back()` | This returns the last element in the array. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `back()` | 这返回数组中的最后一个元素。'
- en: '| `begin()` | This returns the position of the first element in the array |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `begin()` | 这返回数组中第一个元素的位置'
- en: '| `end()`  | This returns one position past the last element in the array |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '`end()` | 这返回数组中最后一个元素的位置之后的一个位置'
- en: '| `rbegin()` | This returns the reverse beginning position, that is, it returns
    the position of the last element in the array |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `rbegin()` | 这返回反向开始位置，即返回数组中最后一个元素的位置'
- en: '| `rend()` | This returns the reverse end position, that is, it returns one
    position before the first element in the array |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `rend()` | 这返回反向结束位置，即返回数组中第一个元素之前的一个位置'
- en: '| `size()`  | This returns the size of the array |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 这返回数组的大小'
- en: The array container supports random access; hence, given an index, the array
    container can fetch a value with a runtime complexity of *O(1)* or constant time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 数组容器支持随机访问；因此，给定一个索引，数组容器可以以*O(1)*或常量时间的运行复杂度获取一个值。
- en: 'The array container elements can be accessed in a reverse fashion using the
    reverse iterator:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 数组容器元素可以使用反向迭代器以反向方式访问：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will use the following command to get the output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令来获取输出：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Vector
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vector
- en: Vector is a quite useful sequence container, and it works exactly as an array,
    except that the vector can grow and shrink at runtime while an array is of a fixed
    size. However, the data structure used under the hood in an array and vector is
    a plain simple built-in C/C++ style array.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是一个非常有用的序列容器，它的工作方式与数组完全相同，只是向量可以在运行时增长和缩小，而数组的大小是固定的。然而，在数组和向量底层使用的数据结构是一个简单的内置C/C++风格数组。
- en: 'Let''s look at the following example to understand vectors better:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子更好地理解向量：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编译上述代码，并使用以下命令查看输出：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the program is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Code walkthrough
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following line declares a vector and initializes the vector with five elements:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个向量，并用五个元素初始化了向量：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, a vector also allows appending values to the end of the vector by using
    the `vector::push_back<data_type>( value )` API. The `sort()` algorithm takes
    two random access iterators that represent a range of data that must be sorted.
    As the vector internally uses a built-in C/C++ array, just like the STL array
    container, a vector also supports random access iterators; hence the `sort()`
    function is a highly efficient algorithm whose runtime complexity is logarithmic,
    that is, *O(N log2 (N))*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，向量还允许使用`vector::push_back<data_type>( value )` API将值附加到向量的末尾。`sort()`算法接受两个表示必须排序的数据范围的随机访问迭代器。由于向量在内部使用内置的C/C++数组，就像STL数组容器一样，向量也支持随机访问迭代器；因此，`sort()`函数是一个运行时复杂度为对数的高效算法，即*O(N
    log2 (N))*。
- en: Commonly used vector APIs
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用的向量API
- en: 'The following table shows some commonly used vector APIs:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一些常用的向量API：
- en: '| **API** | **Description** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `at ( int index )` | This returns the value stored at the indexed position.
    It throws the `std::out_of_range` exception if the index is invalid. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '`at ( int index )` | 返回存储在索引位置的值。如果索引无效，则会抛出`std::out_of_range`异常。'
- en: '| `operator [ int index ]` | This returns the value stored at the indexed position.
    It is faster than `at( int index )`, since no bounds checking is performed by
    this function. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '`operator [ int index ]` | 返回存储在索引位置的值。这个函数比`at( int index )`更快，因为它不执行边界检查。'
- en: '| `front()` | This returns the first value stored in the vector. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '`front()` | 返回向量中存储的第一个值。'
- en: '| `back()`  | This returns the last value stored in the vector. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '`back()` | 返回向量中存储的最后一个值。'
- en: '| `empty()` | This returns true if the vector is empty, and false otherwise.
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '`empty()` | 如果向量为空，则返回true，否则返回false。'
- en: '| `size()`  | This returns the number of values stored in the vector. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '`size()` | 返回向量中存储的值的数量。'
- en: '| `reserve( int size )`  | This reserves the initial size of the vector. When
    the vector size has reached its capacity, an attempt to insert new values requires
    vector resizing. This makes the insertion consume *O(N)* runtime complexity. The
    `reserve()` method is a workaround for the issue described. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '`reserve( int size )` | 这会保留向量的初始大小。当向量大小达到其容量时，插入新值需要向量调整大小。这使得插入消耗*O(N)*的运行复杂度。`reserve()`方法是对描述的问题的一种解决方法。'
- en: '| `capacity()` | This returns the total capacity of the vector, while the size
    is the actual value stored in the vector. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '`capacity()` | 返回向量的总容量，而大小是向量中实际存储的值。'
- en: '| `clear()`  | This clears all the values. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '`clear()` | 这会清除所有的值。'
- en: '| `push_back<data_type>( value )` | This adds a new value at the end of the
    vector. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '`push_back<data_type>( value )` | 这会在向量的末尾添加一个新值。'
- en: 'It would be really fun and convenient to read and print to/from the vector
    using `istream_iterator` and `ostream_iterator`. The following code demonstrates
    the use of a vector:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`istream_iterator`和`ostream_iterator`从向量中读取和打印会非常有趣和方便。以下代码演示了向量的使用：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the output of the program is skipped, as the output depends on the
    input entered by you. Feel free to try the instructions on the command line.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序的输出被跳过，因为输出取决于您输入的输入。请随意在命令行上尝试这些指令。
- en: Code walkthrough
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'Basically, the copy algorithm accepts a range of iterators, where the first
    two arguments represent the source and the third argument represents the destination,
    which happens to be the vector:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，复制算法接受一系列迭代器，其中前两个参数表示源，第三个参数表示目标，这恰好是向量：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `start_input` iterator instance defines an `istream_iterator` iterator that
    receives input from `istream` and `cin`, and the `end_input` iterator instance
    defines an end-of-file delimiter, which is an empty string by default (`""`).
     Hence, the input can be terminated by typing `""` in the command-line input terminal.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_input`迭代器实例定义了一个从`istream`和`cin`接收输入的`istream_iterator`迭代器，而`end_input`迭代器实例定义了一个文件结束分隔符，默认情况下是一个空字符串(`""`)。因此，输入可以通过在命令行输入终端中键入`""`来终止。'
- en: 'Similarly, let''s understand the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们了解下面的代码片段：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The copy algorithm is used to copy the values from a vector, one element at
    a time, to `ostream`, separating the output with a tab character (`t`).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 复制算法用于将向量中的值逐个复制到`ostream`中，并用制表符(`t`)分隔输出。
- en: Pitfalls of a vector
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量的缺陷
- en: Every STL container has its own advantages and disadvantages. There is no single
    STL container that works better in all the scenarios. A vector internally uses
    an array data structure, and arrays are fixed in size in C/C++. Hence, when you
    attempt to add new values to the vector at the time the vector size has already
    reached its maximum capacity, then the vector will allocate new consecutive locations
    that can accommodate the old values and the new value in a contiguous location.
    It then starts copying the old values into the new locations. Once all the data
    elements are copied, the vector will invalidate the old location.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每个STL容器都有自己的优点和缺点。没有一个STL容器在所有情况下都表现更好。向量在内部使用数组数据结构，而在C/C++中数组的大小是固定的。因此，当您尝试在向量中添加新值时，如果向量的大小已经达到了最大容量，那么向量将分配新的连续位置，可以容纳旧值和新值，并且在连续位置开始复制旧值。一旦所有数据元素都被复制，向量将使旧位置无效。
- en: Whenever this happens, the vector insertion will take *O(N)* runtime complexity.
    As the size of the vector grows over time, on demand, the *O(N)* runtime complexity
    will show up a pretty bad performance. If you know the maximum size required,
    you could reserve so much initial size upfront in order to overcome this issue.
    However, not in all scenarios do you need to use a vector. Of course, a vector
    supports dynamic size and random access, which has performance benefits in some
    scenarios, but it is possible that the feature you are working on may not really
    need random access, in which case a list, deque, or some other container may work
    better for you.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每当这种情况发生时，向量插入将需要*O(N)*的运行时复杂度。随着向量大小随时间增长，*O(N)*的运行时复杂度将导致性能相当糟糕。如果您知道所需的最大大小，可以预留足够的初始大小来克服这个问题。然而，并不是在所有情况下都需要使用向量。当然，向量支持动态大小和随机访问，在某些情况下具有性能优势，但您正在处理的功能可能并不真正需要随机访问，这种情况下列表、双端队列或其他某些容器可能更适合您。
- en: List
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: The list STL container makes use of a doubly linked list data structure internally.
    Hence, a list supports only sequential access, and searching a random value in
    a list in the worst case may take *O(N)* runtime complexity. However, if you know
    for sure that you only need sequential access, the list does offer its own benefits.
    The list STL container lets you insert data elements at the end, in the front,
    or in the middle with a constant time complexity, that is, *O(1)* runtime complexity
    in the best, average, and worst case scenarios.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表STL容器在内部使用双向链表数据结构。因此，列表仅支持顺序访问，在最坏的情况下在列表中搜索随机值可能需要*O(N)*的运行时复杂度。然而，如果您确定只需要顺序访问，列表确实提供了自己的好处。列表STL容器允许您以常数时间复杂度在末尾、前面或中间插入数据元素，即在最佳、平均和最坏的情况下都是*O(1)*的运行时复杂度。
- en: 'The following image demonstrates the internal data structure used by the list
    STL:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了列表STL使用的内部数据结构：
- en: '![](img/90865fd4-3858-4fbc-bdd2-60c23f16c550.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90865fd4-3858-4fbc-bdd2-60c23f16c550.png)'
- en: 'Let''s write a simple program to get first-hand experience of using the list
    STL:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序来亲身体验使用列表STL：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I'm sure that by now you have got a taste of the C++ STL, its elegance, and
    its power. Isn't it cool to observe that the syntax remains the same for all the
    STL containers? You may have observed that the syntax remains the same no matter
    whether you are using an array, a vector, or a list. Trust me, you will get the
    same impression when you explore the other STL containers as well.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信到现在为止，您已经品尝到了C++ STL的优雅和强大之处。观察到语法在所有STL容器中保持不变，是不是很酷？您可能已经注意到，无论您使用数组、向量还是列表，语法都保持不变。相信我，当您探索其他STL容器时，也会有同样的感觉。
- en: Having said that, the previous code is self-explanatory, as we did pretty much
    the same with the other containers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，前面的代码是不言自明的，因为我们在其他容器中做了几乎相同的事情。
- en: 'Let''s try to sort the list, as shown in the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试对列表进行排序，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Did you notice the `sort()` method? Yes, the list container has its own sorting
    algorithms. The reason for a list container to support its own version of a sorting
    algorithm is that the generic `sort()` algorithm expects a random access iterator,
    whereas a list container doesn't support random access. In such cases, the respective
    container will offer its own efficient algorithms to overcome the shortcoming.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到了`sort()`方法吗？是的，列表容器有自己的排序算法。列表容器支持自己版本的排序算法的原因是，通用的`sort()`算法需要一个随机访问迭代器，而列表容器不支持随机访问。在这种情况下，相应的容器将提供自己的高效算法来克服这个缺点。
- en: Interestingly, the runtime complexity of the `sort` algorithm supported by a
    list is *O (N log2 N)*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，列表支持的`sort`算法的运行时复杂度为*O(N log2 N)*。
- en: Commonly used APIs in a list
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表中常用的API
- en: 'The following table shows the most commonly used APIs of an STL list:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了STL列表中最常用的API：
- en: '| **API** | **Description** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `front()` | This returns the first value stored in the list |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 这返回列表中存储的第一个值 |'
- en: '| `back() ` | This returns the last value stored in the list |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `back() ` | 这返回列表中存储的最后一个值 |'
- en: '| `size()` | This returns the count of values stored in the list |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 这返回列表中存储的值的数量 |'
- en: '| `empty()` | This returns `true` when the list is empty, and `false` otherwise
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 当列表为空时返回`true`，否则返回`false` |'
- en: '| `clear()` | This clears all the values stored in the list |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 这会清除列表中存储的所有值 |'
- en: '| `push_back<data_type>( value )` | This adds a value at the end of the list
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `push_back<data_type>( value )` | 这在列表的末尾添加一个值 |'
- en: '| `push_front<data_type>( value )` | This adds a value at the front of the
    list |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `push_front<data_type>( value )` | 这在列表的前面添加一个值 |'
- en: '| `merge( list )` | This merges two sorted lists with values of the same type
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `merge( list )` | 这将两个相同类型值的排序列表合并 |'
- en: '| `reverse()` | This reverses the list |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `reverse()` | 这会反转列表 |'
- en: '| `unique()` | This removes duplicate values from the list |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `unique()` | 这从列表中删除重复的值 |'
- en: '| `sort()` | This sorts the values stored in a list |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `sort()` | 这会对列表中存储的值进行排序 |'
- en: Forward list
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Forward list
- en: The STL's `forward_list` container is built on top of a singly linked list data
    structure; hence, it only supports navigation in the forward direction. As `forward_list`
    consumes one less pointer for every node in terms of memory and runtime, it is
    considered more efficient compared with the list container. However, as price
    for the extra edge of performance advantage, `forward_list` had to give up some
    functionalities.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`forward_list`容器是建立在单向链表数据结构之上的；因此，它只支持向前导航。由于`forward_list`在内存和运行时方面每个节点消耗一个较少的指针，因此与列表容器相比，它被认为更有效。然而，作为性能优势的额外代价，`forward_list`必须放弃一些功能。
- en: 'The following diagram shows the internal data-structure used in `forward_list`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`forward_list`中使用的内部数据结构：
- en: '![](img/149c8d91-7bb4-4194-9635-f9bf4a0ead5e.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/149c8d91-7bb4-4194-9635-f9bf4a0ead5e.png)'
- en: 'Let''s explore the following sample code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索以下示例代码：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output can be viewed with the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以通过以下命令查看：
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output will be as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Code walkthrough
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following code declares and initializes the `forward_list` container with
    some unique values and some duplicate values:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明并初始化了`forward_list`容器，其中包含一些唯一的值和一些重复的值：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As the `forward_list` container doesn''t support the `size()` function, we
    used the `distance()` function to find the size of the list:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`forward_list`容器不支持`size()`函数，我们使用`distance()`函数来找到列表的大小：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following `forward_list<int>::unique()` function removes the duplicate
    integers and retains only the unique values:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`forward_list<int>::unique()`函数会移除重复的整数，只保留唯一的值：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Commonly used APIs in a forward_list container
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`forward_list`容器中常用的API'
- en: 'The following table shows the commonly used `forward_list` APIs:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了常用的`forward_list` API：
- en: '| **API** | **Description** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `front()` | This returns the first value stored in the `forward_list` container
    |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 这返回`forward_list`容器中存储的第一个值 |'
- en: '| `empty()` | This returns true when the `forward_list` container is empty
    and false, otherwise |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 当`forward_list`容器为空时返回true，否则返回false。 |'
- en: '| `clear()` | This clears all the values stored in `forward_list` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 这会清除`forward_list`中存储的所有值。 |'
- en: '| `push_front<data_type>( value )` | This adds a value to the front of `forward_list`
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `push_front<data_type>( value )` | 这会将一个值添加到`forward_list`的前面。 |'
- en: '| `merge( list )` | This merges two sorted `forward_list` containers with values
    of the same type |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `merge( list )` | 这会合并两个排序的`forward_list`容器，其值类型相同 |'
- en: '| `reverse()` | This reverses the `forward_list` container |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `reverse()` | 这会颠倒`forward_list`容器 |'
- en: '| `unique()` | This removes duplicate values from the `forward_list` container
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `unique()` | 这会从`forward_list`容器中移除重复的值。 |'
- en: '| `sort()` | This sorts the values stored in `forward_list` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `sort()` | 这会对`forward_list`中存储的值进行排序 |'
- en: 'Let''s explore one more example to get a firm understanding of the `forward_list`
    container:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看一个例子，以更好地理解`forward_list`容器：
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code snippet is an interesting example that demonstrates the practical
    use of the `sort()`, `merge()`, and `unique()` STL algorithms.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段是一个有趣的例子，演示了`sort()`、`merge()`和`unique()` STL算法的实际用途。
- en: 'The output can be viewed with the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以通过以下命令查看：
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the program is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE27]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output and the program are pretty self-explanatory.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 输出和程序都很容易理解。
- en: Deque
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deque
- en: The deque container is a double-ended queue and the data structure used could
    be a dynamic array or a vector. In a deque, it is possible to insert an element
    both at the front and back, with a constant time complexity of *O(1)*, unlike
    vectors, in which the time complexity of inserting an element at the back is *O(1)*
    while that for inserting an element at the front is *O(N)*. The deque doesn't
    suffer from the problem of reallocation, which is suffered by a vector. However,
    all the benefits of a vector are there with deque, except that deque is slightly
    better in terms of performance as compared to a vector as there are several rows
    of dynamic arrays or vectors in each row.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: deque容器是一个双端队列，其使用的数据结构可以是动态数组或向量。在deque中，可以在前面和后面插入元素，时间复杂度为*O(1)*，而在向量中，插入元素在后面的时间复杂度为*O(1)*，而在前面的时间复杂度为*O(N)*。deque不会遭受向量遭受的重新分配问题。然而，deque具有向量的所有优点，只是在性能方面略优于向量，因为每一行都有几行动态数组或向量。
- en: 'The following diagram shows the internal data structure used in a deque container:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了deque容器中使用的内部数据结构：
- en: '![](img/69ccaa1c-1be2-4f91-89b2-fa780a1d54b0.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69ccaa1c-1be2-4f91-89b2-fa780a1d54b0.png)'
- en: 'Let''s write a simple program to try out the deque container:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序来尝试deque容器：
- en: '[PRE28]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output can be viewed with the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以通过以下命令查看：
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the program is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Commonly used APIs in a deque
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: deque中常用的API
- en: 'The following table shows the commonly used deque APIs:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了常用的deque API：
- en: '| **API** | **Description** |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `at ( int index )` | This returns the value stored at the indexed position.
    It throws the `std::out_of_range` exception if the index is invalid. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `at ( int index )` | 这返回存储在索引位置的值。如果索引无效，则会抛出`std::out_of_range`异常。 |'
- en: '| `operator [ int index ]` | This returns the value stored at the indexed position.
    It is faster than `at( int index )` since no bounds checking is performed by this
    function. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `operator [ int index ]` | 这返回存储在索引位置的值。与`at( int index )`相比，此函数不执行边界检查，因此速度更快。
    |'
- en: '| `front()` | This returns the first value stored in the deque. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 这返回deque中存储的第一个值。 |'
- en: '| `back() ` | This returns the last value stored in the deque. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `back() ` | 这返回deque中存储的最后一个值。 |'
- en: '| `empty()` | This returns `true` if the deque is empty and `false`, otherwise.
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 如果deque为空则返回`true`，否则返回`false`。 |'
- en: '| `size() ` | This returns the number of values stored in the deque. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `size() ` | 这返回deque中存储的值的数量。 |'
- en: '| `capacity()` | This returns the total capacity of the deque, while `size()`
    returns the actual number of values stored in the deque. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `capacity()` | 这会返回deque的总容量，而`size()`返回deque中实际存储的值的数量。 |'
- en: '| `clear() ` | This clears all the values. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 这会清除所有值。 |'
- en: '| `push_back<data_type>( value )` | This adds a new value at the end of the
    deque. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `push_back<data_type>( value )` | 这会在deque的末尾添加一个新值。 |'
- en: Associative containers
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联容器
- en: Associative containers store data in a sorted fashion, unlike the sequence containers.
    Hence, the order in which the data is inserted will not be retained by the associative
    containers. Associative containers are highly efficient in searching a value with
    *O( log n )* runtime complexity. Every time a new value gets added to the container,
    the container will reorder the values stored internally if required.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器以排序的方式存储数据，与序列容器不同。因此，关联容器不会保留插入数据的顺序。关联容器在搜索值时非常高效，具有*O(log n)*的运行时复杂度。每次向容器添加新值时，如果需要，容器将重新排序内部存储的值。
- en: 'The STL supports the following types of associative containers:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: STL支持以下类型的关联容器：
- en: Set
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Map
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Multiset
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重集
- en: Multimap
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重映射
- en: Unordered set
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序集合
- en: Unordered multiset
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序多重集
- en: Unordered map
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序映射
- en: Unordered multimap
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序多重映射
- en: 'Associative containers organize the data as key-value pairs. The data will
    be sorted based on the key for random and faster access. Associative containers
    come in two flavors:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器将数据组织为键-值对。数据将根据键进行排序，以实现随机和更快的访问。关联容器有两种类型：
- en: Ordered
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序
- en: Unordered
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序
- en: 'The following associative containers come under ordered containers, as they
    are ordered/sorted in a particular fashion. Ordered associative containers generally
    use some form of **Binary Search Tree** (**BST**); usually, a red-black tree is
    used to store the data:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下关联容器属于有序容器，因为它们以特定的方式排序。有序关联容器通常使用某种形式的**二叉搜索树**（**BST**）；通常使用红黑树来存储数据：
- en: Set
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Map
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Multiset
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重集
- en: Multimap
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重映射
- en: 'The following associative containers come under unordered containers, as they
    are not ordered in any particular fashion and they use hash tables:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下关联容器属于无序容器，因为它们没有以任何特定方式排序，并且它们使用哈希表：
- en: Unordered Set
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序集合
- en: Unordered Map
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序映射
- en: Unordered Multiset
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序多重集
- en: Unordered Multimap
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序多重映射
- en: Let's understand the previously mentioned containers with examples in the following
    subsections.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下小节中通过示例了解先前提到的容器。
- en: Set
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: A set container stores only unique values in a sorted fashion. A set organizes
    the values using the value as a key. The set container is immutable, that is,
    the values stored in a set can't be modified; however, the values can be deleted.
    A set generally uses a red-black tree data structure, which is a form of balanced
    BST. The time complexity of set operations are guaranteed to be *O ( log N )*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 集合容器以排序的方式仅存储唯一的值。集合使用值作为键来组织值。集合容器是不可变的，也就是说，存储在集合中的值不能被修改；但是，值可以被删除。集合通常使用红黑树数据结构，这是一种平衡二叉搜索树。集合操作的时间复杂度保证为*O(log
    N)*。
- en: 'Let''s write a simple program using a set:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个集合编写一个简单的程序：
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output can be viewed with the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令查看输出：
- en: '[PRE32]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the program is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE33]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Code walkthrough
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following code declares and initializes two sets, `s1` and `s2`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明并初始化了两个集合`s1`和`s2`：
- en: '[PRE34]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following line will ensure that the vector has enough room to store the
    values in the resultant vector:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将确保向量有足够的空间来存储结果向量中的值：
- en: '[PRE35]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following code will print the values in `s1` and `s2`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印`s1`和`s2`中的值：
- en: '[PRE36]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `set_difference()` algorithm will populate the vector `v` with values only
    present in set `s1` but not in `s2`. The iterator, `pos`, will point to the last
    element in the vector; hence, the vector `resize` will ensure that the extra spaces
    in the vector are removed:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_difference()`算法将使用集合`s1`中仅存在而不在`s2`中的值填充向量`v`。迭代器`pos`将指向向量中的最后一个元素；因此，向量`resize`将确保向量中的额外空间被移除：'
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following code will print the values populated in the vector `v`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印向量`v`中填充的值：
- en: '[PRE38]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `set_union()` algorithm will merge the contents of sets `s1` and `s2` into
    the vector, and the vector is then resized to fit only the merged values:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_union()`算法将合并集合`s1`和`s2`的内容到向量中，然后调整向量的大小以适应合并后的值：'
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following code will print the merged values populated in the vector `v`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印向量`v`中填充的合并值：
- en: '[PRE40]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Commonly used APIs in a set
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合中常用的API
- en: 'The following table describes the commonly used set APIs:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了常用的集合API：
- en: '| **API** | **Description** |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `insert( value )` | This inserts a value into the set |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `insert( value )` | 这会将一个值插入到集合中 |'
- en: '| `clear()` | This clears all the values in the set |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 这会清除集合中的所有值 |'
- en: '| `size()` | This returns the total number of entries present in the set |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 这会返回集合中存在的条目总数 |'
- en: '| `empty()` | This will print `true` if the set is empty, and returns `false` otherwise
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 如果集合为空，则会打印`true`，否则返回`false` |'
- en: '| `find()` | This finds the element with the specified key and returns the
    iterator position |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `find()` | 这会查找具有指定键的元素并返回迭代器位置 |'
- en: '| `equal_range()` | This returns the range of elements matching a specific
    key |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `equal_range()` | 这会返回与特定键匹配的元素范围 |'
- en: '| `lower_bound()` | This returns an iterator to the first element not less than
    the given key |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `lower_bound()` | 这会返回指向第一个不小于给定键的元素的迭代器 |'
- en: '| `upper_bound()` | This returns an iterator to the first element greater than
    the given key  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `upper_bound()` | 这会返回指向第一个大于给定键的元素的迭代器 |'
- en: Map
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: A map stores the values organized by keys. Unlike a set, a map has a dedicated
    key per value.  Maps generally use a red-black tree as an internal data structure,
    which is a balanced BST that guarantees *O( log N )* runtime efficiency for searching
    or locating a value in the map. The values stored in a map are sorted based on
    the key, using a red-black tree. The keys used in a map must be unique. A map
    will not retain the sequences of the input as it reorganizes the values based
    on the key, that is, the red-black tree will be rotated to balance the red-black
    tree height.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 映射按键组织值。与集合不同，映射每个值都有一个专用键。映射通常使用红黑树作为内部数据结构，这是一种平衡的BST，可以保证在映射中搜索或定位值的*O(log
    N)*运行时效率。映射中存储的值根据键使用红黑树进行排序。映射中使用的键必须是唯一的。映射不会保留输入的顺序，因为它根据键重新组织值，也就是说，红黑树将被旋转以平衡红黑树高度。
- en: 'Let''s write a simple program to understand map usage:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的程序来理解映射的用法：
- en: '[PRE41]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s compile and check the output of the program:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并检查程序的输出：
- en: '[PRE42]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Code walkthrough
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码漫游
- en: 'The following line declares a map with a `string` name as the key and a `long`
    mobile number as the value stored in the map:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个映射，其中`string`名称作为键，`long`手机号作为存储在映射中的值：
- en: '[PRE44]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following code snippet adds four contacts organized by name as the key:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段添加了四个按名称组织的联系人：
- en: '[PRE45]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following line will try to locate the contact with the name, `Sriram`,
    in the contacts map; if `Sriram` is found, then the `find()` function will return
    the iterator pointing to the location of the key-value pair; otherwise it returns
    the `contacts.end()` position:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将尝试在联系人映射中查找名为`Sriram`的联系人；如果找到`Sriram`，则`find()`函数将返回指向键值对位置的迭代器；否则返回`contacts.end()`位置：
- en: '[PRE46]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following code verifies whether the iterator, `pos`, has reached `contacts.end()`
    and prints the contact number. Since the map is an associative container, it stores
    a `key=>value` pair; hence, `pos->first` indicates the key and `pos->second` indicates
    the value:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码验证迭代器`pos`是否已达到`contacts.end()`并打印联系人号码。由于映射是一个关联容器，它存储`key=>value`对；因此，`pos->first`表示键，`pos->second`表示值：
- en: '[PRE47]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Commonly used APIs in a map
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射中常用的API
- en: 'The following table shows the commonly used map APIs:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了常用的映射API：
- en: '| **API** | **Description** |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `at ( key )` | This returns the value for the corresponding key if the key
    is found; otherwise it throws the `std::out_of_range` exception |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `at ( key )` | 如果找到键，则返回相应键的值；否则抛出`std::out_of_range`异常 |'
- en: '| `operator[ key ]` | This updates an existing value for the corresponding
    key if the key is found; otherwise it will add a new entry with the respective
    `key=>value` supplied |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `operator[ key ]` | 如果找到键，则更新相应键的现有值；否则，将添加一个具有相应`key=>value`的新条目 |'
- en: '| `empty()` | This returns `true` if the map is empty, and `false` otherwise
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 如果映射为空，则返回`true`，否则返回`false` |'
- en: '| `size()` | This returns the count of the `key=>value` pairs stored in the
    map |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 返回映射中存储的`key=>value`对的数量 |'
- en: '| `clear()` | This clears the entries stored in the map |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 清除映射中存储的条目 |'
- en: '| `count()` | This returns the number of elements matching the given key |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `count()` | 返回与给定键匹配的元素数量 |'
- en: '| `find()` | This finds the element with the specified key |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `find()` | 查找具有指定键的元素 |'
- en: Multiset
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重集合
- en: A multiset container works in a manner similar to a set container, except for
    the fact that a set allows only unique values to be stored whereas a multiset
    lets you store duplicate values. As you know, in the case of set and multiset
    containers, the values themselves are used as keys to organize the data. A multiset
    container is just like a set; it doesn't allow modifying the values stored in
    the multiset.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 多重集合容器的工作方式与集合容器类似，只是集合只允许存储唯一的值，而多重集合允许存储重复的值。如你所知，在集合和多重集合容器的情况下，值本身被用作键来组织数据。多重集合容器就像一个集合；它不允许修改存储在多重集合中的值。
- en: 'Let''s write a simple program using a multiset:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个使用多重集合的简单程序：
- en: '[PRE48]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output can be viewed with the following command:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令查看输出：
- en: '[PRE49]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output of the program is as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE50]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Interestingly, in the preceding output, you can see that the multiset holds
    duplicate values.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在前面的输出中，你可以看到多重集合包含重复的值。
- en: Multimap
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重映射
- en: A multimap works exactly as a map, except that a multimap container will allow
    multiple values to be stored with the same key.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 多重映射与映射完全相同，只是多重映射容器允许使用相同的键存储多个值。
- en: 'Let''s explore the multimap container with a simple example:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来探索多重映射容器：
- en: '[PRE51]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The program can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序可以编译，并且可以使用以下命令查看输出：
- en: '[PRE52]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output of the program is as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE53]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Unordered sets
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序集合
- en: An unordered set works in a manner similar to a set, except that the internal
    behavior of these containers differs. A set makes use of red-black trees while
    an unordered set makes use of hash tables. The time complexity of set operations
    is *O( log N)* while the time complexity of unordered set operations is *O(1)*;
    hence, the unordered set tends to be faster than the set.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 无序集合的工作方式与集合类似，只是这些容器的内部行为不同。集合使用红黑树，而无序集合使用哈希表。集合操作的时间复杂度为*O(log N)*，而无序集合操作的时间复杂度为*O(1)*；因此，无序集合比集合更快。
- en: The values stored in an unordered set are not organized in any particular fashion,
    unlike in a set, which stores values in a sorted fashion. If performance is the
    criteria, then an unordered set is a good bet; however, if iterating the values
    in a sorted fashion is a requirement, then set is a good choice.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 无序集合中存储的值没有特定的顺序，不像集合那样以排序的方式存储值。如果性能是标准，那么无序集合是一个不错的选择；然而，如果需要以排序的方式迭代值，那么集合是一个不错的选择。
- en: Unordered maps
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序映射
- en: An unordered map works in a manner similar to a map, except that the internal
    behavior of these containers differs. A map makes use of red-black trees while
    unordered map makes use of hash tables. The time complexity of map operations
    is *O( log N)* while that of unordered map operations is *O(1);* hence, an unordered
    map tends to be faster than a map.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 无序映射的工作方式类似于映射，只是这些容器的内部行为不同。映射使用红黑树，而无序映射使用哈希表。映射操作的时间复杂度为*O(log N)*，而无序映射操作的时间复杂度为*O(1)*；因此，无序映射比映射更快。
- en: The values stored in an unordered map are not organized in any particular fashion,
    unlike in a map where values are sorted by keys.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 无序映射中存储的值没有任何特定的顺序，不像映射中的值按键排序。
- en: Unordered multisets
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序多重集
- en: An unordered multiset works in a manner similar to a multiset, except that the
    internal behavior of these containers differs. A multiset makes use of red-black
    trees while an unordered multiset makes use of hash tables. The time complexity
    of multiset operations is *O( log N)* while that of unordered multiset operations
    is *O(1)*. Hence, an unordered multiset tends to be faster than a multiset.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 无序多重集的工作方式类似于多重集，只是这些容器的内部行为不同。多重集使用红黑树，而无序多重集使用哈希表。多重集操作的时间复杂度为*O(log N)*，而无序多重集操作的时间复杂度为*O(1)*。因此，无序多重集比多重集更快。
- en: The values stored in an unordered multiset are not organized in any particular
    fashion, unlike in a multiset where values are stored in a sorted fashion. If
    performance is the criteria, unordered multisets are a good bet; however, if iterating
    the values in a sorted fashion is a requirement, then multiset is a good choice.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 无序多重集中存储的值没有任何特定的顺序，不像多重集中的值以排序的方式存储。如果性能是标准，无序多重集是一个不错的选择；然而，如果需要以排序的方式迭代值，则多重集是一个不错的选择。
- en: Unordered multimaps
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序多重映射
- en: An unordered multimap works in a manner similar to a multimap, except that the
    internal behavior of these containers differs. A multimap makes use of red-black
    trees while an unordered multimap makes use of hash tables. The time complexity
    of multimap operations is *O( log N)* while that of unordered multimap operations
    is *O(1)*; hence, an unordered multimap tends to be faster than a multimap.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 无序多重映射的工作方式类似于多重映射，只是这些容器的内部行为不同。多重映射使用红黑树，而无序多重映射使用哈希表。多重映射操作的时间复杂度为*O(log
    N)*，而无序多重映射操作的时间复杂度为*O(1)*；因此，无序多重映射比多重映射更快。
- en: The values stored in an unordered multimap are not organized in any particular
    fashion, unlike in multimaps where values are sorted by keys. If performance is
    the criteria, then an unordered multimap is a good bet; however, if iterating
    the values in a sorted fashion is a requirement, then multimap is a good choice.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 无序多重映射中存储的值没有任何特定的顺序，不像多重映射中的值按键排序。如果性能是标准，那么无序多重映射是一个不错的选择；然而，如果需要以排序的方式迭代值，则多重映射是一个不错的选择。
- en: Container adapters
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器适配器
- en: Container adapters adapt existing containers to provide new containers. In simple
    terms, STL extension is done with composition instead of inheritance.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 容器适配器通过组合而不是继承来适配现有容器以提供新的容器。
- en: STL containers can't be extended by inheritance, as their constructors aren't
    virtual. Throughout the STL, you can observe that while static polymorphism is
    used both in terms of operator overloading and templates, dynamic polymorphism
    is consciously avoided for performance reasons. Hence, extending the STL by subclassing
    the existing containers isn't a good idea, as it would lead to memory leaks because
    container classes aren't designed to behave like base classes.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: STL容器不能通过继承来扩展，因为它们的构造函数不是虚拟的。在整个STL中，您可以观察到，虽然在运算符重载和模板方面都使用了静态多态性，但出于性能原因，动态多态性是有意避免的。因此，通过对现有容器进行子类化来扩展STL并不是一个好主意，因为容器类并没有设计成像基类一样行为，这会导致内存泄漏。
- en: 'The STL supports the following container adapters:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: STL支持以下容器适配器：
- en: Stack
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Queue
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Priority Queue
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列
- en: Let's explore the container adapters in the following subsections.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下小节中探索容器适配器。
- en: Stack
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: Stack is not a new container; it is a template adapter class. The adapter containers
    wrap an existing container and provide high-level functionalities. The stack adapter
    container offers stack operations while hiding the unnecessary functionalities
    that are irrelevant for a stack. The STL stack makes use of a deque container
    by default; however, we can instruct the stack to use any existing container that
    meets the requirement of the stack during the stack instantiation.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 栈不是一个新的容器；它是一个模板适配器类。适配器容器包装现有容器并提供高级功能。栈适配器容器提供栈操作，同时隐藏对栈不相关的不必要功能。STL栈默认使用双端队列容器；然而，在栈实例化期间，我们可以指示栈使用任何满足栈要求的现有容器。
- en: Deques, lists, and vectors meet the requirements of a stack adapter.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列、列表和向量满足栈适配器的要求。
- en: A stack operates on the **Last In First Out** (**LIFO**) philosophy.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 栈遵循**后进先出**（**LIFO**）的原则。
- en: Commonly used APIs in a stack
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈中常用的API
- en: 'The following table shows commonly used stack APIs:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了常用的栈API：
- en: '| **API** | **Description** |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `top()` | This returns the top-most value in the stack, that is, the value
    that was added last |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `top()` | 这将返回栈中的顶部值，即最后添加的值 |'
- en: '| `push<data_type>( value )` | This will push the value provided to the top
    of the stack |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `push<data_type>( value )` | 这将提供的值推送到栈的顶部 |'
- en: '| `pop()` | This will remove the top-most value from the stack  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 这将从栈中移除顶部的值 |'
- en: '| `size()` | This returns the number of values present in the stack |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 这将返回栈中存在的值的数量 |'
- en: '| `empty()` | This returns `true` if the stack is empty; otherwise it returns
    `false` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 如果栈为空，则返回`true`；否则返回`false` |'
- en: 'It''s time to get our hands dirty; let''s write a simple program to use a stack:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候动手了；让我们编写一个简单的程序来使用栈：
- en: '[PRE54]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The program can be compiled and the output can be viewed with the following
    command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以编译，并且可以使用以下命令查看输出：
- en: '[PRE55]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output of the program is as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE56]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: From the preceding output, we can see the LIFO behavior of stack.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到栈的LIFO行为。
- en: Queue
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: A queue works based on the **First In First Out** (**FIFO**) principle. A queue is
    not a new container; it is a templatized adapter class that wraps an existing
    container and provides the high-level functionalities that are required for queue
    operations, while hiding the unnecessary functionalities that are irrelevant for
    a queue. The STL queue makes use of a deque container by default; however, we
    can instruct the queue to use any existing container that meets the requirement
    of the queue during the queue instantiation.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 队列基于**先进先出**（FIFO）原则工作。队列不是一个新的容器；它是一个模板化的适配器类，它包装了一个现有的容器，并提供了队列操作所需的高级功能，同时隐藏了对队列无关的不必要功能。STL队列默认使用双端队列容器；然而，我们可以在队列实例化期间指示队列使用满足队列要求的任何现有容器。
- en: In a queue, new values can be added at the back and removed from the front.
    Deques, lists, and vectors meet the requirements of a queue adapter.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列中，新值可以添加到后面并从前面删除。双端队列、列表和向量满足队列适配器的要求。
- en: Commonly used APIs in a queue
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列中常用的API
- en: 'The following table shows the commonly used queue APIs:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了常用的队列API：
- en: '| **API** | **Description** |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `push()` | This appends a new value at the back of the queue |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `push()` | 这在队列的后面追加一个新值 |'
- en: '| `pop()` | This removes the value at the front of the queue |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 这删除队列前面的值 |'
- en: '| `front()` | This returns the value in the front of the queue |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 这返回队列前面的值 |'
- en: '| `back()` | This returns the value at the back of the queue |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `back()` | 这返回队列的后面的值 |'
- en: '| `empty()` | This returns `true` when the queue is empty; otherwise it returns
    `false` |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 当队列为空时返回`true`；否则返回`false` |'
- en: '| `size()` | This returns the number of values stored in the queue |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 这返回存储在队列中的值的数量 |'
- en: 'Let''s use a queue in the following program:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下程序中使用队列：
- en: '[PRE57]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The program can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以编译，并且可以使用以下命令查看输出：
- en: '[PRE58]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output of the program is as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE59]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: From the preceding output, you can observe that the values were popped out in
    the same sequence that they were pushed in, that is, FIFO.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以观察到值以它们被推入的相同顺序弹出，即FIFO。
- en: Priority queue
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列
- en: A priority queue is not a new container; it is a templatized adapter class that
    wraps an existing container and provides high-level functionalities that are required
    for priority queue operations, while hiding the unnecessary functionalities that
    are irrelevant for a priority queue. A priority queue makes use of a vector container
    by default; however, a deque container also meets the requirement of the priority
    queue. Hence, during the priority queue instantiation, you could instruct the
    priority queue to make use of a deque as well.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列不是一个新的容器；它是一个模板化的适配器类，它包装了一个现有的容器，并提供了优先队列操作所需的高级功能，同时隐藏了对优先队列无关的不必要功能。优先队列默认使用向量容器；然而，双端队列容器也满足优先队列的要求。因此，在优先队列实例化期间，您可以指示优先队列也使用双端队列。
- en: A priority queue organizes the data in such a way that the highest priority
    value appears first; in other words, the values are sorted in a descending order.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列以这样的方式组织数据，使得最高优先级的值首先出现；换句话说，值按降序排序。
- en: The deque and vector meet the requirements of a priority queue adaptor.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列和向量满足优先队列适配器的要求。
- en: Commonly used APIs in a priority queue
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列中常用的API
- en: 'The following table shows commonly used priority queue APIs:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了常用的优先队列API：
- en: '| **API** | **Description** |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `push()` | This appends a new value at the back of the priority queue |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `push()` | 这在优先队列的后面追加一个新值 |'
- en: '| `pop()` | This removes the value at the front of the priority queue |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 这删除优先队列前面的值 |'
- en: '| `empty()` | This returns `true` when the priority queue is empty; otherwise
    it returns `false` |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 当优先队列为空时返回`true`；否则返回`false` |'
- en: '| `size()` | This returns the number of values stored in the priority queue
    |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 这返回存储在优先队列中的值的数量 |'
- en: '| `top()` | This returns the value in the front of the priority queue |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `top()` | 这返回优先队列前面的值 |'
- en: 'Let''s write a simple program to understand `priority_queue`:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序来理解`priority_queue`：
- en: '[PRE60]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The program can be compiled and the output can be viewed with the following
    command:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以编译，并且可以使用以下命令查看输出：
- en: '[PRE61]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output of the program is as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE62]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: From the preceding output, you can observe that `priority_queue` is a special
    type of queue that reorders the inputs in such a way that the highest value appears
    first.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以观察到`priority_queue`是一种特殊类型的队列，它重新排列输入，使得最高值首先出现。
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you learned about ready-made generic containers, functors, iterators,
    and algorithms. You also learned set, map, multiset, and multimap associative
    containers, their internal data structures, and common algorithms that can be
    applied on them. Further you learned how to use the various containers with practical
    hands-on code samples.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了现成的通用容器、函数对象、迭代器和算法。您还学习了集合、映射、多重集和多重映射关联容器，它们的内部数据结构以及可以应用于它们的常见算法。此外，您还学习了如何使用各种容器与实际的代码示例。
- en: In the next chapter, you will learn template programming, which helps you master
    the essentials of templates.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习模板编程，这将帮助您掌握模板的基本知识。
