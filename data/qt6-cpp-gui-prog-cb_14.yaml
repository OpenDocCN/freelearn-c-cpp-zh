- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Performance Optimization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化
- en: Qt 6 is known for its optimized performance. However, performance issues may
    still occur if your code is poorly written. There are many ways we can identify
    these issues and fix them before releasing the software to our users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6 以其优化的性能而闻名。然而，如果您的代码编写得不好，性能问题仍然可能发生。有许多方法可以帮助我们识别这些问题并在发布软件给用户之前修复它们。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Optimizing forms and C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化表单和 C++
- en: Profiling and optimizing QML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析和优化 QML
- en: Rendering and animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染和动画
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include Qt 6.6.1 MinGW 64 bit, Qt
    Creator 12.0.2, and Windows 11\. All the code used in this chapter can be downloaded
    from the following GitHub repository at [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括 Qt 6.6.1 MinGW 64 位、Qt Creator 12.0.2 和 Windows 11。本章中使用的所有代码都可以从以下
    GitHub 仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14)。
- en: Optimizing forms and C++
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化表单和 C++
- en: It’s very important to learn how to optimize your form-based Qt 6 applications
    that are built with C++. The best way to do that is to learn how to measure and
    compare the different methods that are used and decide which one works the best
    for you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何优化使用 C++ 构建的基于表单的 Qt 6 应用程序非常重要。做到这一点最好的方法就是学习如何衡量和比较所使用的方法，并决定哪一种最适合您。
- en: How to do it…
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Let’s get started by following these steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: 'Let’s create a `mainwindow.cpp`. After that, add the following headers to the
    top of the source code:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `mainwindow.cpp` 文件。之后，将以下头文件添加到源代码的顶部：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `QGridLayout` object and set its parent to `centralWidget`:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `QGridLayout` 对象并将其父对象设置为 `centralWidget`：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: QElapsedTimer* time = new QElapsedTimer;
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QElapsedTimer* time = new QElapsedTimer;
- en: time->start();
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: time->start();
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use two loops to add 600 push buttons to our grid layout and connect
    all of them to a lambda function when clicked. We will then measure the elapsed
    time and print out the result, as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用两个循环将 600 个按钮添加到我们的网格布局中，并在点击时将它们连接到一个 lambda 函数。然后我们将测量经过的时间并打印出结果，如下所示：
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we build and run the project now, we will see a window filled with lots
    of buttons. When we click on one of them, a message box will pop up on the screen.
    It only took around nine milliseconds on my computer to create and lay out all
    of the 600 buttons on the main window. There is also no performance issue when
    we move the window around or resize it, which is quite impressive. It proves that
    Qt 6 can handle this pretty well. However, please be aware that your users might
    be using older machines, and you might want to be extra careful when designing
    your user interface:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在构建并运行项目，我们会看到一个窗口充满了许多按钮。当我们点击其中一个时，屏幕上会弹出一个消息框。在我的电脑上，创建和布局主窗口中的所有 600
    个按钮只花了大约九毫秒。当我们移动窗口或调整其大小时，也没有性能问题，这相当令人印象深刻。这证明了 Qt 6 可以很好地处理这种情况。然而，请注意，您的用户可能在使用较旧的机器，因此在设计用户界面时，您可能需要格外小心：
- en: '![Figure 14.1 – Spawn 600 buttons on a Qt window](img/B20976_14_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 在 Qt 窗口中生成 600 个按钮](img/B20976_14_001.jpg)'
- en: Figure 14.1 – Spawn 600 buttons on a Qt window
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 在 Qt 窗口中生成 600 个按钮
- en: 'Let’s add a style sheet to each of the buttons, like so:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们给每个按钮添加一个样式表，如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Build and run the program again. This time, it took roughly 75 milliseconds
    to set up the GUI. This means that the style sheet does have some impact on the
    performance of your program:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建并运行程序。这次，设置 GUI 大约花了 75 毫秒。这意味着样式表确实对您程序的性能有一定影响：
- en: '![Figure 14.2 – Apply the style sheet to all 600 buttons](img/B20976_14_002.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 将样式表应用于所有 600 个按钮](img/B20976_14_002.jpg)'
- en: Figure 14.2 – Apply the style sheet to all 600 buttons
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 将样式表应用于所有 600 个按钮
- en: 'Once you are done with that, let’s do some performance tests on different types
    of C++ containers. Open up `main.cpp` and add the following headers:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，让我们对不同类型的 C++ 容器进行一些性能测试。打开 `main.cpp` 并添加以下头文件：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a `testArray()` function before the `main()` function:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数之前创建一个 `testArray()` 函数：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create another function called `testVector()`, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `testVector()` 的函数，如下所示：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you are done with that, proceed to create yet another function called
    `testQtVector()`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，继续创建另一个名为`testQtVector()`的函数：
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside the `main()` function, define a `QElapsedTimer` object and an integer
    variable called `lastElapse`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，定义一个`QElapsedTimer`对象和一个名为`lastElapse`的整型变量：
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will call the three functions we created in the previous steps to test their
    performance:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将调用之前步骤中创建的三个函数来测试它们的性能：
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Build and run the program now; we will see the performance differences between
    these containers. On my computer, the array took 650 milliseconds to execute,
    while the STL vector took roughly 3,830 milliseconds, and the Qt vector took around
    5,400 milliseconds to execute.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建并运行程序；我们将看到这些容器之间的性能差异。在我的电脑上，数组执行耗时650毫秒，而STL向量大约耗时3,830毫秒，Qt向量执行耗时约为5,400毫秒。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a result, the array is still the container that yields the best performance,
    despite its lack of features compared to the other two. Surprisingly, Qt’s own
    vector class works slightly slower than the vector container provided by the C++
    standard library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管与另外两个相比缺少一些功能，数组仍然是性能最佳的容器。令人惊讶的是，Qt自己的向量类比C++标准库提供的向量容器运行得略慢。
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'When creating a **Qt Widgets Application** project, try to do the following
    to improve performance:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建**Qt Widgets应用程序**项目时，尝试以下操作以提高性能：
- en: Avoid adding too many pages to a stacked widget and filling them with widgets,
    as Qt needs to find all of them recursively during the rendering process and event
    handling, which will highly impact the program’s performance.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免向堆叠小部件添加太多页面并将它们填满小部件，因为Qt需要在渲染过程和事件处理中递归地找到所有这些，这将极大地影响程序的性能。
- en: Do note that the `QWidget` class uses the Raster Engine, a software renderer,
    to render the widgets instead of using the GPU. However, it is lightweight enough
    to keep the performance good most of the time. Alternatively, you could consider
    using QML for your program’s GUI instead, since it is fully hardware accelerated.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，`QWidget`类使用光栅引擎，一个软件渲染器，来渲染小部件，而不是使用GPU。然而，它足够轻量，足以在大多数时候保持良好的性能。或者，你也可以考虑为程序的GUI使用QML，因为它完全硬件加速。
- en: 'Turn off **mouseTracking**, **tabletTracking**, and other event catching for
    your widgets if they do not need it. This tracking and catchings adds to the CPU
    usage costs of your program:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的小部件不需要，请关闭**mouseTracking**、**tabletTracking**和其他事件捕获。这种跟踪和捕获会增加程序CPU使用成本：
- en: '![Figure 14.3 – Disable mouseTracking and tabletTracking for optimization](img/B20976_14_003.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 为优化禁用mouseTracking和tabletTracking](img/B20976_14_003.jpg)'
- en: Figure 14.3 – Disable mouseTracking and tabletTracking for optimization
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 为优化禁用mouseTracking和tabletTracking
- en: Keep your style sheets as simple as possible. A large style sheet needs a longer
    time for Qt to parse the information into the rendering system, which will also
    impact performance.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能保持样式表简单。一个大的样式表需要更长的时间让Qt将信息解析到渲染系统中，这也会影响性能。
- en: Different C++ containers produce different speeds, as we showed in the preceding
    example. Surprisingly, Qt’s vector container is slightly slower than STL’s (the
    C++ standard library) vector container. Overall, the good old C++ array is still
    the fastest, but does not provide sorting functionality. Use what is best for
    your requirements.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的C++容器产生不同的速度，正如我们在前面的例子中所展示的。令人惊讶的是，Qt的向量容器比STL（C++标准库）的向量容器略慢。总的来说，古老的C++数组仍然是最快的，但它不提供排序功能。使用最适合你需求的方法。
- en: For large operations, use *asynchronous* methods whenever possible as it will
    not stall the main process and will keep your program running smoothly.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大型操作，尽可能使用*异步*方法，因为它不会阻塞主进程，并保持程序平稳运行。
- en: '*Multi-threading* is really good for running different operations in parallel
    event loops. However, it can also become quite ugly if not done right, for example,
    creating and destroying threads frequently, or with inter-thread communications
    that are not planned well.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多线程*对于在并行事件循环中运行不同的操作非常好。然而，如果操作不当，它也可能变得相当丑陋，例如，频繁创建和销毁线程，或者线程间通信没有计划好。'
- en: Try to avoid using the web engine unless absolutely necessary. This is because
    embedding a full web browser on your program is really heavy overkill, especially
    for a small application. You can consider using QML instead of making a hybrid
    application if you want to create user interface-centric software.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是绝对必要，请尽量避免使用网络引擎。这是因为将完整的网络浏览器嵌入到您的程序中是非常沉重的，尤其是对于小型应用程序。如果您想创建以用户界面为中心的软件，可以考虑使用
    QML 而不是创建混合应用程序。
- en: By doing performance tests as we did in the preceding example project, you can
    easily determine which method is the best choice for your project and how to make
    your program perform better.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过像前一个示例项目中所做的那样进行性能测试，您可以轻松地确定哪种方法最适合您的项目，以及如何使您的程序表现更佳。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Qt 5, we can use the `QTime` class to do the test as seen in this section.
    However, functions such as `start()` and `elapsed()` have been deprecated from
    the `QTime` class in Qt 6\. Since Qt 6, the player must use `QElapsedTimer` to
    handle this.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 5 中，我们可以使用 `QTime` 类进行测试，如本节所示。然而，`start()` 和 `elapsed()` 等函数已被从 Qt 6 中的
    `QTime` 类中弃用。从 Qt 6 开始，玩家必须使用 `QElapsedTimer` 来处理此功能。
- en: Profiling and optimizing QML
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析和优化 QML
- en: The QML engine in Qt 6 took advantage of hardware acceleration to make its rendering
    capability and performance superior to the old widgets user interface. However,
    this does not mean that you do not need to worry about optimization, because small
    performance issues may snowball into bigger problems over time and cause damage
    to your product’s reputation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6 中的 QML 引擎利用了硬件加速，使其渲染能力和性能优于旧的 widgets 用户界面。但这并不意味着您不需要担心优化，因为小的性能问题可能会随着时间的推移而累积成更大的问题，并损害您产品的声誉。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to start profiling and optimizing a QML application:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始分析并优化 QML 应用程序：
- en: 'Let’s create a **Qt Quick** **Application** project:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 **Qt Quick 应用程序** 项目：
- en: '![Figure 14.4 – Create a Qt Quick Application project](img/B20976_14_004.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 创建 Qt Quick 应用程序项目](img/B20976_14_004.jpg)'
- en: Figure 14.4 – Create a Qt Quick Application project
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 创建 Qt Quick 应用程序项目
- en: 'Then, go to **Analyze | QML Profiler** and run the **QML** **Profiler** tool:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到 **分析 | QML 分析器** 并运行 **QML 分析器** 工具：
- en: '![Figure 14.5 – Run the QML Profiler to check the QML performance](img/B20976_14_005.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 运行 QML 分析器以检查 QML 性能](img/B20976_14_005.jpg)'
- en: Figure 14.5 – Run the QML Profiler to check the QML performance
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 运行 QML 分析器以检查 QML 性能
- en: 'Your Qt Quick project will then be run by the QML Profiler. The **QML Profiler**
    window will also appear under the code editor. Click the **Stop** button located
    at the top bar of the **QML Profiler** window after the program has passed the
    test point, which in this case meant successfully creating the empty window:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您的 Qt Quick 项目将由 QML 分析器运行。在代码编辑器下也会出现 **QML 分析器** 窗口。在程序通过测试点（在这种情况下意味着成功创建空窗口）后，点击位于
    **QML 分析器** 窗口顶部栏的 **停止** 按钮：
- en: '![Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle
    icon](img/B20976_14_006.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6 – 通过按下带有红色矩形图标的按钮停止 QML 分析器](img/B20976_14_006.jpg)'
- en: Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle
    icon
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – 通过按下带有红色矩形图标的按钮停止 QML 分析器
- en: 'After you stop the profiler analysis, a timeline will be displayed in the **Timeline**
    tab under the **QML Profiler** window. There are four tabs that you can switch
    between, namely **Timeline**, **Flame Graph**, **Quick3D Frame**, and **Statistics**,
    at the bottom of the **QML** **Profiler** window:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在停止分析器分析后，在 **QML 分析器** 窗口下的 **时间线** 标签将显示一个时间线。您可以在以下四个标签之间切换，即 **时间线**、**火焰图**、**Quick3D
    帧** 和 **统计信息**，位于 **QML 分析器** 窗口的底部：
- en: '![Figure 14.7 – You can look at different data on different tabs](img/B20976_14_007.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 您可以在不同的标签页上查看不同的数据](img/B20976_14_007.jpg)'
- en: Figure 14.7 – You can look at different data on different tabs
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 您可以在不同的标签页上查看不同的数据
- en: 'Let’s check out the **Timeline** tab. We can see six different categories under
    the timeline display: **Scene Graph**, **Memory Usage**, **Input Events**, **Compiling**,
    **Creating**, and **Binding**. These categories give us an overview of the different
    stages and processes of our program throughout its execution. We can also see
    some colorful bars displayed on the timeline. Let’s click on one of the bars under
    the **Creating** category that says **QtQuick/Window**. Once clicked, we will
    see the total duration for this operation and the location of the code displayed
    in a rectangular window located at the top of the QML Profiler window:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下 **Timeline** 标签页。在时间线显示下，我们可以看到六个不同的类别：**Scene Graph**、**Memory Usage**、**Input
    Events**、**Compiling**、**Creating** 和 **Binding**。这些类别为我们提供了程序在整个执行过程中的不同阶段和过程的概述。我们还可以在时间线上看到一些彩色条形。让我们点击
    **Creating** 类别下名为 **QtQuick/Window** 的一个条形。一旦点击，我们将在 QML Profiler 窗口顶部的矩形窗口中看到此操作的持续时间以及代码的位置：
- en: '![Figure 14.8 – The Timeline tab](img/B20976_14_008.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8 – 时间线标签页](img/B20976_14_008.jpg)'
- en: Figure 14.8 – The Timeline tab
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 – 时间线标签页
- en: 'Once you are done with that, let’s move on and open up the **Flame Graph**
    tab instead. Under the **Flame Graph** tab, you will see the visualization of
    the total time, memory, and allocation of your application in the form of percentages.
    You can switch between total time, memory, and allocation by clicking on the selection
    box that’s located at the top-right corner of the **QML** **Profiler** window:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，让我们继续并打开 **Flame Graph** 标签页。在 **Flame Graph** 标签页下，你会看到以百分比形式显示的应用程序的总时间、内存和分配的视觉化。你可以通过点击位于
    **QML** **Profiler** 窗口右上角的选项框来在总时间、内存和分配之间切换：
- en: '![Figure 14.9 – The Flame Graph tab](img/B20976_14_009.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9 – 火焰图标签页](img/B20976_14_009.jpg)'
- en: Figure 14.9 – The Flame Graph tab
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 – 火焰图标签页
- en: 'Not only that, you will also see the percentage value displayed on your QML
    code editor:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不仅如此，你还会在 QML 代码编辑器上看到显示的百分比值：
- en: '![Figure 14.10 – Percentage values are shown on the right](img/B20976_14_010.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10 – 百分比值显示在右侧](img/B20976_14_010.jpg)'
- en: Figure 14.10 – Percentage values are shown on the right
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – 百分比值显示在右侧
- en: Open up the **Quick3D Frame** category under the **QML Profiler** window. This
    tab is where you check the performance of 3D rendering. It is currently empty
    because we are not doing any 3D rendering.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **QML Profiler** 窗口下打开 **Quick3D Frame** 类别。这个标签页是检查 3D 渲染性能的地方。目前它是空的，因为我们没有进行任何
    3D 渲染。
- en: 'Next, let’s open up the **Statistics** category. This tab basically shows us
    information about the processes in table form:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们打开 **Statistics** 类别。这个标签页基本上以表格形式显示关于进程的信息：
- en: '![Figure 14.11 – The Statistics tab](img/B20976_14_011.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11 – 统计标签页](img/B20976_14_011.jpg)'
- en: Figure 14.11 – The Statistics tab
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 – 统计标签页
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This is similar to what we did in the previous example project that used C++
    and widgets except, this time, it is automatically analyzed by the **QML Profiler**
    tool that’s provided by Qt 6.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在之前使用 C++ 和小部件的示例项目中做的是类似的，只是这次它是通过 Qt 6 提供的 **QML Profiler** 工具自动分析的。
- en: The QML Profiler not only produces the total time used for running a specific
    process, but also displays the memory allocation, the execution timeline of your
    application, and other information that gives you insight into the performance
    of your software.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: QML Profiler 不仅生成特定进程运行的总时间，还显示内存分配、应用程序的执行时间线以及其他能让你深入了解软件性能的信息。
- en: By looking at the data that was analyzed by the QML Profiler, you will be able
    to find out which part of your code slows down the program, allowing you to fix
    any problems quickly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 QML Profiler 分析的数据，你将能够找出代码中哪个部分减慢了程序，让你能够快速修复任何问题。
- en: There are some rules that you need to be aware of when writing QML to avoid
    performance bottlenecks. For instance, type conversion can sometimes be expensive,
    especially between types that are not closely matched (string to number, for example).
    Small issues like this will likely snowball into bottlenecks as your project grows
    larger over time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 QML 时，有一些规则你需要注意，以避免性能瓶颈。例如，类型转换有时可能很昂贵，尤其是在不紧密匹配的类型之间（例如字符串到数字）。随着项目随时间增长而变大，这类小问题很可能会演变成瓶颈。
- en: 'Other than that, try not to use `id` for an item lookup multiple times in blocks
    of code that are run often, as in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，尽量避免在经常运行的代码块中多次使用`id`进行项目查找，如下例所示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Instead, we can use a variable to cache the data and avoid multiple look-ups
    on the same item over and over again:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用一个变量来缓存数据，避免在同一个项目上重复多次查找：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Besides, if you change the property of a binding expression, especially in
    a loop, Qt will be forced to re-evaluate it repeatedly. This will cause some performance
    issues. Instead of doing this, the user should follow the next code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你更改绑定表达式的属性，尤其是在循环中，Qt将被迫反复重新评估它。这将导致一些性能问题。而不是这样做，用户应该遵循以下代码片段：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instead, we can use a temporary variable for storing the data of `myValue`,
    then apply the final result back to `myValue` once the loop has been completed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用一个临时变量来存储`myValue`的数据，然后在循环完成后将最终结果重新应用到`myValue`上：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Consider using an anchor to position your UI items instead of using bindings.
    Item positioning with bindings is really slow and inefficient, although it allows
    for maximum flexibility.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用锚点来定位你的UI项目，而不是使用绑定。使用绑定进行项目定位非常慢且效率低下，尽管它提供了最大的灵活性。
- en: Rendering and animation
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染和动画
- en: When it comes to an application that renders graphics and animation, good performance
    is critical. Users can easily notice performance issues when graphics are not
    animated smoothly on screen. In the following example, we will look at how we
    can further optimize a graphics-heavy Qt Quick application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到渲染图形和动画的应用程序时，良好的性能至关重要。当图形在屏幕上没有平滑动画时，用户很容易注意到性能问题。在以下示例中，我们将探讨如何进一步优化一个图形密集型的Qt
    Quick应用程序。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To learn how to render animation in QML, follow this example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在QML中渲染动画，请参考以下示例：
- en: 'Create a `tux.png` to our project’s resources:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`tux.png`并将其添加到项目的资源中：
- en: '![Figure 14.12 – Include main.qml and tux.png into your project resources](img/B20976_14_012.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图14.12 – 将main.qml和tux.png包含到你的项目资源中](img/B20976_14_012.jpg)'
- en: Figure 14.12 – Include main.qml and tux.png into your project resources
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12 – 将main.qml和tux.png包含到你的项目资源中
- en: 'Open up `650` x `650`. We will also add `id` to the `window` item and name
    it `window`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`650` x `650`。我们还将向`window`项目添加`id`并将其命名为`window`：
- en: '[PRE15]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code inside the `window` item:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`window`项目内部添加以下代码：
- en: '[PRE16]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Right after that, add `Repeater` and `Image` under it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，在下面添加`Repeater`和`Image`：
- en: '[PRE17]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will proceed and add the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续添加以下代码：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you are done with that, add the following code below the previous code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成上述操作后，在之前的代码下面添加以下代码：
- en: '[PRE19]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code animates the `x` property of the image. We need another
    `NumberAnimation` property to animate the `y` property:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一段代码动画化了图像的`x`属性。我们需要另一个`NumberAnimation`属性来动画化`y`属性：
- en: '[PRE20]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, we repeat the entire code of `ParallelAnimation`, except this time,
    we swap the `from` and `to` values, like so:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们重复整个`ParallelAnimation`的代码，但这次我们将`from`和`to`的值交换，如下所示：
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The same goes for `NumberAnimation` for the `y` property:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`y`属性的`NumberAnimation`也是如此：
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we add a `Text` item for displaying the frame rate of our application:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`Text`项目来显示我们应用程序的帧率：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s add `Timer` under `Text` and update the frame rate to display every second:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Text`下面添加`Timer`并更新帧率以每秒显示一次：
- en: '[PRE24]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we build and run the program now, we will be able to see several penguins
    moving around the screen with a steady 60 fps:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在构建并运行程序，我们将能够看到几只企鹅在屏幕上以稳定的60 fps移动：
- en: '![Figure 14.13 – 10 penguins floating around the window](img/B20976_14_013.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图14.13 – 10只企鹅在窗口周围漂浮](img/B20976_14_013.jpg)'
- en: Figure 14.13 – 10 penguins floating around the window
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 – 10只企鹅在窗口周围漂浮
- en: 'Let’s go back to our code and change the `model` property of the `Repeater`
    item to `10000`. Build and run the program again; you should see that your window
    is full of moving penguins and that the frame rate has significantly dropped to
    roughly 39 fps, which is not too bad, considering the amount of penguins we have:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们的代码，将`Repeater`项目的`model`属性更改为`10000`。重新构建并运行程序；你应该会看到你的窗口充满了移动的企鹅，并且帧率显著下降到大约39
    fps，考虑到企鹅的数量，这并不太糟糕：
- en: '![Figure 14.14 – 10,000 penguins floating around the window](img/B20976_14_014.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图14.14 – 10,000只企鹅在窗口周围漂浮](img/B20976_14_014.jpg)'
- en: Figure 14.14 – 10,000 penguins floating around the window
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14 – 10,000只企鹅在窗口周围漂浮
- en: 'Next, let’s go back to our source code and comment out both of the `sourceSize`
    properties. We also set the `smooth` and `antialiasing` properties to `false`,
    while setting the `asynchronous` property to `false`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们回到我们的源代码，并注释掉两个`sourceSize`属性。我们还设置了`平滑`和`抗锯齿`属性为`false`，同时将`异步`属性设置为`false`：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s build and run the program again. This time, the frame rate dropped slightly
    to 32 fps, but the penguins look smoother and are of better quality, even when
    moving:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次构建并运行程序。这次，帧率略有下降至 32 fps，但企鹅看起来更加平滑，质量也更好，即使在移动时也是如此：
- en: '![Figure 14.15 – Our penguins look much smoother now without slowing down too
    much](img/B20976_14_015.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.15 – 我们的企鹅现在看起来更加平滑，而且没有减慢太多](img/B20976_14_015.jpg)'
- en: Figure 14.15 – Our penguins look much smoother now without slowing down too
    much
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15 – 现在我们的企鹅看起来更加平滑，而且没有减慢太多
- en: How it works…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The QML engine that powers Qt Quick applications is very optimized and powerful
    when it comes to rendering animated graphics on screen. However, there are still
    some tips that we can follow to make it even faster.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动 Qt Quick 应用程序的 QML 引擎在屏幕上渲染动画图形时非常优化且强大。然而，我们仍然可以遵循一些提示来使其更快。
- en: Try and make use of the built-in features provided by Qt 6 instead of implementing
    your own, such as `Repeater`, `NumberAnimation`, and `SequentialAnimation`. This
    is because Qt 6 developers have put great effort into optimizing these features
    so that you don’t have to.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 Qt 6 提供的内置功能，而不是实现自己的功能，例如`Repeater`、`NumberAnimation`和`SequentialAnimation`。这是因为
    Qt 6 开发者已经投入了大量努力来优化这些功能，以便你不必这样做。
- en: The `sourceSize` properties tell Qt to resize the image before loading it into
    memory so that large images do not use more memory than necessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`sourceSize`属性告诉 Qt 在将其加载到内存之前调整图像大小，这样大图像就不会使用比必要的更多内存。'
- en: The `smooth` property, when enabled, tells Qt to filter the image to make look
    it smoother when scaled or transformed from its natural size. It will not make
    any difference if the image is rendered at the same as its `sourceSize` value.
    This property will impact the performance of your application on some older hardware.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用时，`平滑`属性告诉 Qt 在缩放或从其自然大小转换图像时过滤图像，使其看起来更平滑。如果图像以与`sourceSize`值相同的分辨率渲染，则此属性不会产生任何差异。此属性将影响某些较旧硬件上应用程序的性能。
- en: The `antialiasing` property tells Qt to remove the aliasing artifacts around
    the edge of the image and make it look smoother. This property will also impact
    the performance of your program.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`抗锯齿`属性告诉 Qt 移除图像边缘的锯齿状伪影，使其看起来更平滑。此属性也会影响程序的性能。'
- en: The `asynchronous` property tells Qt to load the image under a low-priority
    thread, which means that your program will not stall when loading huge image files.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`异步`属性告诉 Qt 在一个低优先级的线程中加载图像，这意味着当加载大图像文件时，你的程序不会停滞。'
- en: We used the frame rate to indicate the performance of our program. Since `onAfterRendering`
    always gets called on every frame, we can then accumulate the frame variable on
    every render. Then, we used `Timer` to reset the frame value every second.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用帧率来表示我们程序的性能。由于`onAfterRendering`总是在每一帧被调用，因此我们可以在每一帧渲染时累积帧变量。然后，我们使用`Timer`每秒重置帧值。
- en: Finally, we displayed the value on screen using a `Text` item.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`Text`项目在屏幕上显示值。
