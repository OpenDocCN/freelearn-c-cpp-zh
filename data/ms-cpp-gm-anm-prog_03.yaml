- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Moving Animation Calculations from CPU to GPU
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将动画计算从CPU迁移到GPU
- en: Welcome to *Chapter 2*! In the previous chapter, we explored the steps to load
    and animate a 3D model by using Open Assimp Import Library, or Assimp for short.
    The resulting application can render a large number of model instances. But, depending
    on your processor type and speed, the computational part for the model matrices
    becomes dominant quite fast. As a consequence, we are no longer able to reach
    60 frames per second in the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第二章**！在前一章中，我们探讨了使用Open Assimp导入库（简称Assimp）加载和动画3D模型的步骤。生成的应用程序可以渲染大量的模型实例。但是，根据你的处理器类型和速度，模型矩阵的计算部分很快就会变得占主导地位。结果，我们无法在应用程序中达到每秒60帧。
- en: In this chapter, we move the matrix calculations to compute shaders, running
    entirely on the GPU. We start with a short history of methods to do computations
    that are independent of the main code of the application, and the growth of parallelism
    in CPUs and GPUs. Next, we examine the current state of the matrix calculations.
    Then, we create a plan for what we should move to a compute shader, and how this
    relocation could be accomplished. As the last step, we check the results of the
    relocation and take a short look at which other parts of the application could
    possibly take advantage of offloading compute-intense work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将矩阵计算移动到计算着色器中，完全在GPU上运行。我们首先简要回顾一下独立于应用程序主代码进行计算的方法的历史，以及CPU和GPU中并行性的增长。接下来，我们考察当前矩阵计算的状态。然后，我们制定一个计划，说明我们应该将哪些内容移动到计算着色器中，以及这种迁移如何实现。最后一步，我们检查迁移的结果，并简要看看应用程序的其他哪些部分可能可以利用卸载计算密集型工作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are compute shaders and why should we love them?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算着色器是什么，为什么我们应该喜欢它们？
- en: Profiling animation performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析动画性能
- en: Moving the node computations to the GPU
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将节点计算迁移到GPU
- en: Testing the implementation by scaling up
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扩展测试实现
- en: How to debug a compute shader
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何调试计算着色器
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To use compute shaders, a GPU supporting at least OpenGL 4.3 and/or Vulkan 1.0
    is required. Since the source code for the book is written for OpenGL 4.6 and
    Vulkan 1.1, we are safe here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用计算着色器，需要一个至少支持OpenGL 4.3和/或Vulkan 1.0的GPU。由于本书的源代码是为OpenGL 4.6和Vulkan 1.1编写的，所以我们在这里是安全的。
- en: You can find the example code in the folder `chapter02`, subfolders `01_opengl_computeshader`
    for OpenGL, and `02_vulkan_computeshader` for Vulkan.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`chapter02`文件夹中找到示例代码，对于OpenGL，在`01_opengl_computeshader`子文件夹中，对于Vulkan，在`02_vulkan_computeshader`子文件夹中。
- en: What are compute shaders and why should we love them?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算着色器是什么，为什么我们应该喜欢它们？
- en: Let’s take a short look at the history of home computers to see how concurrency
    was handled. On servers, concurrent programs have been the norm since the mid-1960s
    but for home computers and game consoles, the evolution is a bit different.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下家用电脑的历史，看看并发是如何处理的。在服务器上，自1960年代中期以来，并发程序一直是常态，但对于家用电脑和游戏机来说，其发展轨迹略有不同。
- en: The famous raster interrupt
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 著名的光栅中断
- en: 'While the general idea of interrupts has existed in computer systems since
    the beginning of computers, interrupts in home computers were normally used by
    the operating system to react to external events (though the first machines with
    interrupts were introduced in the 1950s). One of these interrupts signaled the
    beginning of a new picture to output to old “cathode-ray tube” TV sets: the raster
    interrupt.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然中断的一般概念自计算机诞生以来就存在于计算机系统中，但家用电脑中的中断通常由操作系统用来响应外部事件（尽管在1950年代就引入了具有中断的第一台机器）。其中一种中断标志着向旧“阴极射线管”电视输出新图像的开始：光栅中断。
- en: The raster interrupt fired after the cathode ray was reset to the top left of
    the TV set. This steady event, occurring 50 times per second (in the EU; 60 times
    per second in the US), became a point of interest for programmers really quickly.
    By redirecting the interrupt handler to their own code, the machine could do work
    that needed to be done to a fixed time schedule, like playing music or graphic
    changes that should happen at a specific location on the screen. These programs
    embraced the capabilities of home computers even more than the architects of the
    machines could have imagined, like adding more sprites to the screen than the
    machine had available, drawing sprites inside of screen borders, raster bars,
    or even a simple form of multitasking on 8-bit CPUs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当阴极射线管重置到电视屏幕的左上角后，光栅中断就会触发。这个每秒发生50次（在欧洲；在美国为每秒60次）的稳定事件，很快就成了程序员的兴趣点。通过将中断处理程序重定向到自己的代码，机器可以完成需要按固定时间表执行的工作，比如播放音乐或屏幕上特定位置应发生的图形变化。这些程序甚至比机器的架构师所能想象的更能发挥家用电脑的能力，比如在屏幕上添加比机器可用的更多精灵，在屏幕边界内绘制精灵，甚至在8位CPU上实现简单形式的并行处理。
- en: Up to this day, retro coders do even more magic with old home computers. See
    the *Additional resources* section for links to demos plus tutorials on how the
    limitations of hardware were embraced over time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，复古程序员甚至能在老式家用电脑上施展更多魔法。请参阅*附加资源*部分，获取演示链接以及关于如何随着时间的推移接受硬件限制的教程。
- en: Then, for a long time, nothing special happened. The era of 8- and 16-bit home
    computers ended, and x86 machines took over. However, the general system layout
    stayed the same – one processor core using time-sharing via interrupts to present
    the illusion of having multiple programs running at the same time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，很长一段时间内，没有发生什么特别的事情。8位和16位家用电脑的时代结束了，x86机器接管了市场。然而，总体系统布局保持不变——一个处理器核心通过中断的时间共享来呈现同时运行多个程序的感觉。
- en: The rise of multi-core machines
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多核机器的兴起
- en: 'By the start of the year 2000, common desktop machines became capable of working
    with multiple CPU cores: Windows 2000 was introduced (Linux was able to utilize
    more than one CPU for a long time, but it was a niche system on desktops in 2000).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到2000年初，常见的台式机已经能够处理多个CPU核心：推出了Windows 2000（Linux长期以来能够利用多个CPU，但在2000年的台式机上是一个利基系统）。
- en: 'Five years later, the first processors with more than one computational core
    were available for desktop users: Pentium D and AMD 64 X2\. These new CPUs were
    seen as the start of a new era in programming, since more than one process could
    run at the same time. That was also the start of an era of headaches for programmers
    – two threads could really run in parallel, requiring new thinking about synchronization.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 五年后，第一个面向桌面用户的具有多个计算核心的处理器出现了：Pentium D和AMD 64 X2。这些新CPU被视为编程新时代的开始，因为可以同时运行多个进程。这也标志着程序员烦恼时代的开始——两个线程可以真正并行运行，需要新的同步思考。
- en: Right now, the average CPU core count of a desktop machine is between 4 and
    8\. Taking into account the simultaneous multithreading of modern CPUs, many desktop
    machines can even handle between 28 and 32 threads in parallel. Sadly, the headaches
    for programmers are the same as 20 years ago – utilizing a large number of cores
    is still a complex and error-prone process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，台式机的平均CPU核心数在4到8之间。考虑到现代CPU的并行多线程，许多台式机甚至可以并行处理28到32个线程。遗憾的是，程序员的烦恼和20年前一样——利用大量核心仍然是一个复杂且容易出错的流程。
- en: 'Behind the scenes, another technology with an even more massive number of cores
    evolved: graphics processors.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器核心升级的背后，另一种拥有更多核心数量的技术也在发展：图形处理器。
- en: Hidden multi-core champions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏的多核冠军
- en: 'In the shadows of processor core upgrades, graphics cards also raised the number
    of parallel cores. They did this on even larger scales. Starting with only a couple
    of shader cores in 2009 and 2010, the growth in numbers is insane:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器核心升级的阴影下，显卡也增加了并行核心的数量。他们在这方面做得更大。从2009年和2010年只有几个着色器核心开始，数量的增长是惊人的：
- en: A NVIDIA GeForce RTX 4090 has a whopping 16,384 shader cores, and an AMD Radeon
    RX 7900 XTX has 6,144 shader cores.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NVIDIA GeForce RTX 4090拥有16,384个着色器核心，而AMD Radeon RX 7900 XTX则有6,144个着色器核心。
- en: 'These two numbers can’t be compared directly due to internal differences between
    these two GPUs, but the raw numbers show one thing: If we were able to use some
    of the shader cores to calculate our model matrices for the animation frames,
    the computation would be a lot faster. At the same time, our CPU would have less
    work to do, enabling us to do other tasks while the GPU calculates the model matrices.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两款GPU之间的内部差异，这两个数字不能直接比较，但原始数字显示了一件事：如果我们能够使用一些着色器核心来计算动画帧的模型矩阵，计算将会快得多。同时，我们的CPU将需要做更少的工作，使我们能够在GPU计算模型矩阵的同时执行其他任务。
- en: 'Thanks to graphics API designers and GPU vendors, using these shader cores
    is as easy as writing a small, C-like program: a compute shader.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢图形API设计师和GPU供应商，使用这些着色器核心就像编写一个小型的C语言程序：一个计算着色器。
- en: Welcome to the wonderful world of compute shaders
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎来到计算着色器的奇妙世界
- en: 'Up to OpenGL 4.2, doing computations on the GPU was already possible by utilizing
    the other shader types, like vertex and fragment shaders. Similar to uploading
    arbitrary data to the GPU via texture buffer objects, shaders could be used to
    do massive parallel computations, saving the results into a texture buffer. The
    final texture could be read back to the CPU-accessible memory – et voila: the
    GPU helped us do some expensive calculations.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 直到OpenGL 4.2，通过利用其他着色器类型（如顶点着色器和片段着色器）在GPU上进行计算已经是可能的。类似于通过纹理缓冲区对象将任意数据上传到GPU，着色器可以用来进行大规模并行计算，将结果保存到纹理缓冲区。最终的纹理可以被读取回CPU可访问的内存——就这样：GPU帮助我们做了昂贵的计算。
- en: With the introduction of OpenGL 4.3, this process was simplified by officially
    adding compute shaders and **shader storage buffer objects** (**SSBOs**). In Vulkan
    1.0, the support for compute shaders and SSBOs was already mandatory, bringing
    the new graphics API to par with OpenGL 4.3+.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随着OpenGL 4.3的引入，这个过程通过正式添加计算着色器和**着色器存储缓冲区对象**（**SSBOs**）而简化。在Vulkan 1.0中，对计算着色器和SSBOs的支持已经是强制性的，使新的图形API与OpenGL
    4.3+相当。
- en: 'The advantages of SSBOs are great: shaders can read and write to an SSBO, unlike
    read-only uniform buffers. The general access to an SSBO is simplified too, as
    it has no hard-limited maximum size. Combined with slightly different padding
    for `float` and `vec2` data types, getting or setting a value in an SSBO is simple,
    like using a C-style array:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SSBOs的优势很大：着色器可以读写SSBO，而不仅仅是只读的uniform缓冲区。对SSBO的通用访问也简化了，因为它没有硬性限制的最大大小。结合对`float`和`vec2`数据类型的轻微不同的填充，在SSBO中获取或设置一个值就像使用C风格的数组一样简单：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On the other hand, with compute shaders, you get full control of the number
    of shader instances you want to start. The overall number of shader invocations
    depends on the setting in the compute shader and the dispatch call.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用计算着色器，你可以完全控制你想要启动的着色器实例数量。着色器调用的总数取决于计算着色器中的设置和调度调用。
- en: 'Suppose we use the following compute shader settings:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用以下计算着色器设置：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, run this OpenGL dispatch call:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行这个OpenGL调度调用：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It means we will send a request to start 51,200 instances of the shader to
    the GPU driver:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将向GPU驱动程序发送一个请求，启动51,200个着色器实例：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For more details about compute shaders, links to tutorials for OpenGL and Vulkan
    are available in the *Additional resources* section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计算着色器的更多详细信息，OpenGL和Vulkan的教程链接可在**附加资源**部分找到。
- en: While there are some additional limitations, like the number of shader cores
    used together for the sake of simplified internal management (called a wave on
    AMD GPUs, and a warp on NVIDIA GPUs), the number of invocations shows the user-friendly
    usage of compute shaders.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一些额外的限制，比如为了简化内部管理而一起使用的着色器核心数量（在AMD GPU上称为wave，在NVIDIA GPU上称为warp），但调用次数显示了计算着色器的用户友好性。
- en: You, the programmer, don’t need to care about spawning a massive number of threads
    in the code or joining them at the end of the program. Also, there is no need
    to create mutexes, or atomic variables, to control access to the data. All these
    steps are firmly hidden from your eyes in the depths of the graphics driver.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你，作为程序员，不需要在代码中关心生成大量的线程或在程序结束时将它们连接起来。也没有必要创建互斥锁或原子变量来控制对数据的访问。所有这些步骤都深深地隐藏在图形驱动程序的深处。
- en: Though you are not free of obligations – you still have to make sure only a
    single shader invocation reads or writes a single buffer address. But, with the
    help of the control variables set by the GPU, like the global and local invocation
    IDs, this part is also easy – a lot easier compared to the efforts needed for
    manual multi-threading on the CPU.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你仍有责任在身——你仍需确保只有一个着色器调用读取或写入单个缓冲区地址。但是，借助 GPU 设置的控制变量，如全局和局部调用 ID，这部分工作也很容易——相比在
    CPU 上手动多线程，要容易得多。
- en: So, how do we use the magic of the compute shaders in our program? The first
    step here is to analyze the hotspots in the code and to create a plan for how
    the same data could be computed on the GPU.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在程序中使用计算着色器的魔法？第一步是分析代码中的热点，并制定一个计划，以确定相同数据如何在 GPU 上进行计算。
- en: Profiling animation performance
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析动画性能
- en: To test the performance of the application on your system, you can import the
    test model named `Woman.gltf` in the `woman` subfolder of the `assets` folder,
    move the slider next to the **Create Multiple Instances** button to 100, and click
    the button **Create Multiple Instances** several times. Every click will add another
    100 instances of the model, distributed randomly across the virtual world.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试系统上应用程序的性能，你可以将名为 `Woman.gltf` 的测试模型导入 `assets` 文件夹中的 `woman` 子文件夹，将 **创建多个实例**按钮旁边的滑块移动到
    100，然后多次点击 **创建多个实例**按钮。每次点击都会添加 100 个模型的另一个实例，这些实例在虚拟世界中随机分布。
- en: 'Or, you can change the code for the instance slider in the `createFrame()`
    method of the `UserInterface` class in the `opengl` folder. Adjust the fourth
    parameter of the call, controlling the maximum value of the slider:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以更改 `opengl` 文件夹中 `UserInterface` 类的 `createFrame()` 方法中实例滑块的代码。调整调用中的第四个参数，以控制滑块的最大值：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After you add a couple of hundreds of instances, you should see a picture similar
    to *Figure 2.1*. The **Timers** section of the user interface has been zoomed
    into to show the values for the time it takes to generate the model matrices:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了数百个实例后，你应该会看到一个类似于 *图 2.1* 的图像。用户界面的 **计时器**部分已经被放大，以显示生成模型矩阵所需的时间值：
- en: '![](img/figure_2_01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_2_01.png)'
- en: 'Figure 2.1: Model matrix generation time with 1,601 instances on the screen'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：在屏幕上有 1,601 个实例时的模型矩阵生成时间
- en: Here, the 1,601 instances require more than 20 milliseconds to create the model
    matrices – which is still a small value, if we calculate the raw numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，1,601 个实例需要超过 20 毫秒来创建模型矩阵——如果我们计算原始数字，这仍然是一个较小的值。
- en: 'Each model has 41 animated bones. For each of the bones, two values for each
    of the **translation, rotation, and scale** (**TRS**) are read in every frame.
    These values are mixed together by linear interpolation for translation and scale,
    and **spherical linear interpolation** (**SLERP**) for rotation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型有 41 个动画骨骼。对于每个骨骼，每帧都会读取每个 **平移、旋转和缩放**（**TRS**）的两个值。这些值通过线性插值混合在一起，用于平移和缩放，而
    **球面线性插值**（**SLERP**）用于旋转：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On top of these nearly 400,000 vector multiplications, every bone needs the
    resulting TRS matrix created, multiplied by the parent matrix. Every matrix multiplication
    consists of 16 float multiplications, so we have another ~100,000 multiplications:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些近 40 万次向量乘法之上，每个骨骼都需要创建的结果 TRS 矩阵，并将其与父矩阵相乘。每次矩阵乘法都包含 16 次浮点乘法，所以我们还有大约 10
    万次乘法：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That’s quite a large amount of work to be done for the CPU in every single frame.
    These numbers are also reflected in the profiling outputs for Windows and Linux.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于 CPU 来说在每一帧中要完成的大量工作。这些数字也反映在 Windows 和 Linux 的性能分析输出中。
- en: Let’s verify the assumption about the workload of the CPU.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证关于 CPU 工作负载的假设。
- en: Locating the hotspots in the code
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位代码中的热点
- en: 'By using the built-in profiler of Visual Studio 2022, we see the function calls
    for the animations and the matrix multiplications among the functions with the
    most execution time spent inside a single function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Visual Studio 2022 的内置性能分析器，我们可以看到动画的函数调用以及单个函数内部花费最多执行时间的函数之间的矩阵乘法：
- en: '![](img/figure_2_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_2_02.png)'
- en: 'Figure 2.2: Animation calls in Visual Studio 2022 profiling'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：Visual Studio 2022 性能分析中的动画调用
- en: 'After compiling the executable on Linux with the extra flag `-pg`, running
    the application, and starting `gprof`, the result is similar:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上使用额外的标志 `-pg` 编译可执行文件，运行应用程序，并启动 `gprof` 后，结果类似：
- en: '![](img/figure_2_03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_2_03.png)'
- en: 'Figure 2.3: Animation calls in Linux profiling'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：Linux 中的动画调用
- en: The vast amount of CPU time is needed to calculate the new translation, rotation,
    scaling, and model matrices for every node. So, let’s check how to change the
    data representation to allow a simple upload to a compute shader.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 需要大量的 CPU 时间来计算每个节点的新的平移、旋转、缩放和模型矩阵。因此，让我们看看如何更改数据表示，以便允许简单地将数据上传到计算着色器。
- en: Analyzing the current data representation
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析当前的数据表示
- en: 'In the current implementation, the matrix work is done in the `updateAnimation()`
    method of the `AssimpInstance` class. For every frame the renderer draws to the
    screen, the following steps must be done:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前实现中，矩阵工作是在 `AssimpInstance` 类的 `updateAnimation()` 方法中完成的。对于渲染器绘制到屏幕上的每一帧，必须执行以下步骤：
- en: 'First, we loop over all animation channels, getting the corresponding node
    of the model and updating the translation, scaling, and rotation of every node
    with the bone-local transforms from the animation data:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们遍历所有动画通道，获取模型的相应节点，并使用动画数据中的骨骼局部变换来更新每个节点的平移、缩放和旋转：
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we iterate over all bones, and update the TRS matrix of every node, calculating
    the node-local transforms:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历所有骨骼，并更新每个节点的 TRS 矩阵，计算节点局部变换：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The TRS matrix update of a node includes the multiplication by the parent node
    TRS matrix.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的 TRS 矩阵更新包括与父节点 TRS 矩阵的乘法。
- en: 'At this point, we can collect the final TRS matrix for the nodes, and multiply
    it by the corresponding bone offset node, generating the `mBoneMatrices` vector
    containing the world position for every node:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以收集节点的最终 TRS 矩阵，并将其与相应的骨骼偏移节点相乘，生成包含每个节点的世界位置的 `mBoneMatrices` 向量：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The extra `.count()` check for the bone offset matrices is done to avoid accessing
    an invalid matrix. The bone offset matrix should be valid for every node that
    is part of the animation, but it’s better to be safe than sorry.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对骨骼偏移矩阵进行额外的 `.count()` 检查是为了避免访问无效的矩阵。骨骼偏移矩阵应该对动画中的每个节点都有效，但为了安全起见，最好是谨慎行事。
- en: 'Then, in the `draw()` call of our renderer, i.e., in the `OGLRenderer` class,
    the animation is updated for every instance. After the animation update, the `mBoneMatrices`
    vector is retrieved and added to a local `mBoneMatrices` vector:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的渲染器的 `draw()` 调用中，即 `OGLRenderer` 类中，为每个实例更新动画。在动画更新后，检索 `mBoneMatrices`
    向量并将其添加到本地 `mBoneMatrices` 向量中：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As the next step, the local `mBoneMatrices` vector will be uploaded into the
    SSBO buffer:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为下一步，将本地的 `mBoneMatrices` 向量上传到 SSBO 缓冲区：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `assimp_skinning.vert` vertex shader in the `shader` folder, the bone
    matrices are visible as the `readonly` buffer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `shader` 文件夹中的 `assimp_skinning.vert` 顶点着色器中，骨骼矩阵作为 `readonly` 缓冲区可见：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We use the values from the bone number of every vertex as an index into the
    bone matrices SSBO to calculate the final vertex skinning matrix named `skinMat`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用每个顶点的骨骼编号作为索引，进入骨骼矩阵 SSBO，以计算名为 `skinMat` 的最终顶点皮肤矩阵：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As the last step, we use the `skinMat` matrix to move the vertex to the correct
    position for the specific animation frame:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们使用 `skinMat` 矩阵将顶点移动到特定动画帧的正确位置：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, there are a lot of calculations needed for every single frame
    of the animation we render. Let’s transfer the computational load to the graphics
    card.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于我们要渲染的动画的每一帧，都需要进行大量的计算。让我们将计算负载转移到显卡上。
- en: Adjusting the data model
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整数据模型
- en: 'To move the calculations to the GPU, we create a new struct called `NodeTransformData`
    in the file `OGLRenderData.h` in the `opengl` folder:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将计算移动到 GPU，我们在 `opengl` 文件夹中的 `OGLRenderData.h` 文件中创建一个新的结构体 `NodeTransformData`：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the Vulkan renderer, the struct needs to be created in the file `VkRenderData.h`
    in the `vulkan` folder.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vulkan 渲染器，需要在 `vulkan` 文件夹中的 `VkRenderData.h` 文件中创建该结构体。
- en: In this new `struct`, we will save the transformation values on a per-node basis.
    We are using a `glm::vec4`, that’s a vector type with four `float` elements for
    translation and scaling to avoid additional padding values for proper alignment
    and simply ignoring the last element in the shader.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的 `struct` 中，我们将按节点保存变换值。我们使用 `glm::vec4`，这是一个包含四个 `float` 元素的向量类型，用于平移和缩放，以避免额外的填充值以实现正确的对齐，并简单地忽略最后一个元素在着色器中的使用。
- en: GPU/CPU memory alignment may differ
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: GPU/CPU 内存对齐可能不同
- en: Since GPUs are optimized for fast memory access, data in the buffers must be
    aligned in memory, in most cases to multiples of 16 bytes. This alignment will
    be automatically created when uploading data to the GPU. On the CPU side, a different
    alignment may be used, for instance for 3-element vector types like a `glm::vec3`,
    which is 12 bytes long. To use a `glm::vec3` vector, an additional `float` is
    needed as padding to match the 16-byte alignment because uploading misaligned
    data will end up in distorted images and incorrect results.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GPU优化了快速内存访问，缓冲区中的数据必须在内存中对齐，在大多数情况下是对16字节的多倍数对齐。当将数据上传到GPU时，将自动创建这种对齐。在CPU端，可能使用不同的对齐方式，例如对于3元素向量类型，如`glm::vec3`，它长度为12字节。为了使用`glm::vec3`向量，需要一个额外的`float`作为填充以匹配16字节的对齐，因为上传未对齐的数据最终会导致图像扭曲和结果不正确。
- en: 'We also use a `glm::vec4` vector for the rotation, which is a `glm::quat` quaternion
    in the `AssimpChannel` class. The reason for this decision is simple: **GLSL**,
    the **OpenGL Shading Language**, does not know what a quaternion is, or how to
    handle a quaternion. We will have to implement the quaternion functions by ourselves
    in the compute shader. So, we utilize the normal 4-element vector to transport
    the four elements of the rotation quaternion to the shader.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用一个`glm::vec4`向量来表示旋转，这在`AssimpChannel`类中是一个`glm::quat`四元数。做出这个决定的原因很简单：**GLSL**（OpenGL着色语言）不知道四元数是什么，也不知道如何处理四元数。我们将不得不在计算着色器中自行实现四元数函数。因此，我们利用普通的4元素向量来将旋转四元数的四个元素传输到着色器中。
- en: 'Now, we can simplify the animation update. First, we add a local `std::vector`
    of our new type `NodeTransformData` to the class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简化动画更新。首先，我们在类中添加一个局部`std::vector`，它包含我们新的`NodeTransformData`类型：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We iterate again over all channels, but instead of modifying the nodes of the
    model, we fill a local `NodeTransformData` variable with the transformation data:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次遍历所有通道，但这次不是修改模型的节点，而是将转换数据填充到一个局部的`NodeTransformData`变量中：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And, after a check to avoid accessing an invalid bone, we set the node transform
    of the corresponding bone with the collected transformation data:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在检查以避免访问无效骨骼之后，我们使用收集到的转换数据设置相应骨骼的节点转换：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'During the `draw()` call of our renderer, we still need to update the animations
    in the same way:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的渲染器的`draw()`调用期间，我们仍然需要以相同的方式更新动画：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we get the node transformation from the instance, and collect them in
    a local array:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从实例中获取节点转换，并将它们收集到一个局部数组中：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As the last step, we must upload the node transforms to an SSBO:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们必须将节点转换上传到SSBO：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The elements of the `NodeTransformData` struct are not 4x4 matrices, but only
    the three `glm::vec4` elements per node. So, we need to upload 25% less data to
    the SSBO in this step.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodeTransformData`结构体的元素不是4x4矩阵，而每个节点只有三个`glm::vec4`元素。因此，在这一步中，我们需要上传25%更少的数据到SSBO。'
- en: Having the node transformations available on the GPU is a cool first step. But,
    if we further analyze the data flow, we will find out we need much more data in
    our compute shaders to calculate the final model matrices. Let’s see what else
    is required to calculate the world space positions from the bone-local transform
    data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPU上拥有节点转换是一个很酷的第一步。但是，如果我们进一步分析数据流，我们会发现我们需要在计算着色器中计算最终模型矩阵时需要更多的数据。让我们看看还需要什么来从骨骼局部转换数据计算世界空间位置。
- en: Adding missing data for the compute shader
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加计算着色器缺失的数据
- en: 'The first, and most obvious missing data part is the array of bone offset matrices.
    In the CPU implementation, we multiply the final TRS matrix per node with the
    bone offset matrix for the same node:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显且首先缺失的数据部分是骨骼偏移矩阵的数组。在CPU实现中，我们每个节点将最终TRS矩阵与相同节点的骨骼偏移矩阵相乘：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since the bone offset matrices are on a per-model base, we can add an SSBO
    to our `AssimpModel` class and upload the data during the model loading. We can
    simply add an SSBO to the `AssimpModel.h` header file in the `model` folder:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于骨骼偏移矩阵是基于每个模型的，我们可以在`AssimpModel`类中添加一个SSBO（存储缓冲对象），并在模型加载期间上传数据。我们只需在`model`文件夹中的`AssimpModel.h`头文件中简单地添加一个SSBO：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, in the `loadModel()` method, we fill a local vector with the offset matrices
    and upload the data to the SSBO:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`loadModel()`方法中，我们填充一个局部向量，包含偏移矩阵，并将数据上传到SSBO：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After we prepare the data for our compute shader, we bind the SSBO containing
    the bone offset matrices to the same binding point we configured in the matrix
    multiplication compute shader (`binding = 2`):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为计算着色器准备数据之后，我们将包含骨骼偏移矩阵的SSBO绑定到我们在矩阵乘法计算着色器中配置的相同绑定点（`binding = 2`）：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A bit more hidden at first glance is the need for parent matrices. In the method
    `updateTRSMatrix()` of `AssimpNode`, we retrieve the TRS matrix from the parent
    node (if we have a parent node). Then, we use the parent node to calculate the
    TRS matrix of the node itself:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下较为隐蔽的是需要父矩阵。在`AssimpNode`类的`updateTRSMatrix()`方法中，我们从父节点（如果有父节点）检索TRS矩阵。然后，我们使用父节点来计算节点的自身TRS矩阵：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the `updateAnimation()` method of the `AssimpInstance` class, we start with
    the update of the TRS matrix of the root node and descend into the child nodes,
    collecting the parent matrix node, which contains all transformation matrices
    up to the model root node.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AssimpInstance`类的`updateAnimation()`方法中，我们首先更新根节点的TRS矩阵，然后进入子节点，收集包含所有变换矩阵直到模型根节点的父矩阵节点。
- en: For the compute shader, we need a different approach. Since all shader invocations
    run in parallel, we would need to cut down the number of invocations to one per
    model, allowing the known linear progression on the model matrices. To use a larger
    amount of shader invocations, we will create an `int` vector that contains the
    number of the parent node at each position. This “parent node vector” enables
    us to “walk” backward on the model skeleton in the shader, collecting all parent
    node matrices on the way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算着色器，我们需要不同的方法。由于所有着色器调用都是并行运行的，我们需要将调用次数减少到每个模型一个，以便在模型矩阵上实现已知的线性进展。为了使用更多的着色器调用，我们将创建一个包含每个位置父节点编号的`int`向量。这个“父节点向量”使我们能够在着色器中“向后行走”模型骨骼，沿途收集所有父节点矩阵。
- en: 'We create the parent node vector in the loop with the bone offset matrices.
    First, we get the parent node of our current bone, then use a small lambda to
    get the position of the parent bone in the same bone list:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在循环中创建父节点向量，并使用骨骼偏移矩阵。首先，我们获取当前骨骼的父节点，然后使用一个小lambda函数获取同一骨骼列表中父骨骼的位置：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we don’t find a parent node in the bone list, we have found the root node
    of the model. In this case, we add a `-1` to identify the root node. In all other
    cases, we add the index number of the parent bone:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在骨骼列表中找不到父节点，我们就找到了模型的根节点。在这种情况下，我们添加一个`-1`来标识根节点。在所有其他情况下，我们添加父骨骼的索引编号：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `boneParentIndexList` now contains a flat list of the parent nodes for all
    the nodes in the model, with the special parent `-1` for the root node. By a repeated
    lookup of the parent node, we can ascend the skeleton tree from every node, until
    we reach the root node with the special number `-1` as parent.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`boneParentIndexList`现在包含模型中所有节点的父节点列表，对于根节点使用特殊父节点`-1`。通过重复查找父节点，我们可以从每个节点向上遍历骨骼树，直到我们到达具有特殊父节点编号`-1`的根节点。'
- en: 'To make the parent bone list available in the compute shader, we create another
    SSBO in the `AssimpModel` class, and upload the `boneParentIndexList` to the GPU:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使父骨骼列表在计算着色器中可用，我们在`AssimpModel`类中创建另一个SSBO，并将`boneParentIndexList`上传到GPU：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Back in the renderer, the parent bone buffer will be bound to a binding point
    of our compute shader:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器中，父骨骼缓冲区将被绑定到计算着色器的绑定点上：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We haven’t finished the workload transformation to the GPU yet. Some data needs
    to be handled in a different way when using a compute shader.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成将工作量转换到GPU的工作。在使用计算着色器时，一些数据需要以不同的方式处理。
- en: Relocating data to another shader
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据重新定位到另一个着色器
- en: 'Also missing from the calculations now is the instance world position. The
    `updateAnimation()` method contains the following line to set the transformation
    matrix for the root node of the model:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的计算中还缺少实例世界位置。`updateAnimation()`方法包含以下行来设置模型根节点的变换矩阵：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The root transformation matrix of the model contains general transformations
    that will be applied to the entire model, like a global scaling of the model.
    The other matrix, `mLocalTransformMatrix`, is used to set the user-controlled
    parameters of the model instance. The local transformation matrix allows us to
    rotate and move the model instance in the virtual world.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的根变换矩阵包含将应用于整个模型的一般变换，例如模型的全球缩放。另一个矩阵`mLocalTransformMatrix`用于设置模型实例的用户可控参数。局部变换矩阵允许我们在虚拟世界中旋转和移动模型实例。
- en: In contrast to the bone offset matrices, the root node transformation will be
    moved to the `assimp_skinning.vert` vertex shader, not to a compute shader. It
    does not matter which of the two shaders does the matrix multiplication, but moving
    the root node transformation to the vertex shader may lower the load of the computer
    shaders a bit. Also, the vertex shader only runs for objects that are drawn to
    the screen, not for instances that are culled before the rendering itself, or
    invisible instances, potentially lowering the overall computational load of the
    GPU.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与骨骼偏移矩阵不同，根节点的变换将被移动到`assimp_skinning.vert`顶点着色器中，而不是计算着色器中。哪个着色器执行矩阵乘法并不重要，但将根节点变换移动到顶点着色器可能会稍微降低计算着色器的负载。此外，顶点着色器只对绘制到屏幕上的对象运行，而不是在渲染本身之前被剔除的实例或不可见的实例，这可能会降低GPU的整体计算负载。
- en: Doing the last preparations
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行最后的准备
- en: 'And, at last, we can also decide how many distinct computer shaders we need:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以决定需要多少个不同的计算着色器：
- en: '*We need – at least – two compute shaders*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们至少需要两个计算着色器*。'
- en: To calculate the final TRS matrix for a node, we need to have all parent TRS
    matrices completed, with all matrices multiplied from the current node up to the
    model root. Since we can only control the amount of shader invocations we start,
    but not when or how long such a shader invocation runs, we need to set some sort
    of barrier between the calculation of the node TRS matrices, and the process of
    collecting the matrices along the skeleton.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算节点的最终TRS矩阵，我们需要所有父级TRS矩阵都已完成，并且所有矩阵都从当前节点乘到模型根。由于我们只能控制启动着色器调用的数量，但不能控制其何时或运行多长时间，我们需要在节点TRS矩阵的计算和收集骨骼上的矩阵过程中设置某种类型的屏障。
- en: The only way to create such a barrier is on the CPU side. A barrier will be
    added while submitting the compute shader to the graphics API, telling the GPU
    to wait for the first shaders to finish, before it starts the second batch.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPU端创建这样的屏障是唯一的方法。在提交计算着色器到图形API时，将添加一个屏障，告诉GPU在开始第二个批次之前等待第一个着色器完成。
- en: So, we will have to start with the node transforms, wait until all node transform
    matrices are finished, and then start the calculation of the final node matrices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须从节点变换开始，等待所有节点变换矩阵完成，然后开始计算最终节点矩阵。
- en: After the theoretical part is done, we can start the shader-related implementation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 理论部分完成后，我们可以开始着色器相关的实现。
- en: Moving the node computations to the GPU
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将节点计算移动到GPU
- en: 'The process of loading a compute shader differs only slightly from a vertex
    or fragment shader. For OpenGL, we have to set the shader type in the `glCreateShader()`
    call:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 加载计算着色器的过程与顶点或片段着色器略有不同。对于OpenGL，我们必须在`glCreateShader()`调用中设置着色器类型：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For Vulkan, we must set the correct shader stage during the creation of the
    `VkShaderModule`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，我们必须在创建`VkShaderModule`时设置正确的着色器阶段：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All the other steps of loading the shader code, linking, or creating the shader
    module, stay the same. Because we have only a single shader file, additional methods
    have been added to the `Shader` class. Loading a compute shader in OpenGL can
    now be achieved by calling the `loadComputeShader()` method of the `Shader` class
    with the relative file name of the shader source:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 加载着色器代码、链接或创建着色器模块的所有其他步骤保持不变。因为我们只有一个着色器文件，所以已经向`Shader`类中添加了额外的功能。现在可以通过调用`Shader`类的`loadComputeShader()`方法并传入着色器源文件的相对路径来在OpenGL中加载计算着色器：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Vulkan uses the **Standard Portable Intermediate Representation** (**SPIR-V**)
    format for shaders. Instead of the shader source, the precompiled shader code
    must be loaded into the `Shader` class for the Vulkan renderer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan使用**标准可移植中间表示**（**SPIR-V**）格式进行着色器。对于Vulkan渲染器，必须将预编译的着色器代码加载到`Shader`类中，而不是着色器源代码。
- en: As we compute new matrices in the compute shaders, and we have to move these
    matrices between different shaders, two additional SSBOs are required.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们计算新的矩阵在计算着色器中，并且我们必须在不同着色器之间移动这些矩阵，因此需要两个额外的SSBO。
- en: Adding more shader storage buffers
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加更多的着色器存储缓冲区
- en: 'The first SSBO will store the TRS matrices that we create from the node transforms.
    This SSBO is a simple buffer, defined in the header file for the renderer:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个SSBO将存储我们从节点变换创建的TRS矩阵。这个SSBO是一个简单的缓冲区，定义在渲染器的头文件中：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The second SSBO will contain the final bone matrices that will be used in the
    skinning vertex shader. The bone matrix buffer is also added as a normal SSBO
    declaration in the header file of the renderer:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个SSBO将包含用于皮肤着色器的最终骨骼矩阵。骨骼矩阵缓冲区也被添加为渲染器头文件中的正常SSBO声明：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'One important step to use the SSBO in the shaders is the have a correct size
    set. If the SSBO is too small, not all data will be stored in the compute shader,
    and instances or body parts of instances may be missing. A wrong buffer size may
    be hard to debug – you may not even get a warning that the shader writes beyond
    the end of the buffer. We must calculate the buffer size according to the number
    of bones, the number of instances, and the size of the 4x4 matrix, as shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSBO在着色器中的一个重要步骤是设置正确的大小。如果SSBO太小，则不是所有数据都会存储在计算着色器中，实例或实例的部位可能会缺失。错误的缓冲区大小可能很难调试——你可能甚至不会收到一个警告，表明着色器写入了缓冲区末尾之外。我们必须根据骨骼数量、实例数量和4x4矩阵的大小来计算缓冲区大小，如下所示：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we resize the two SSBOs to the final matrix size:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将两个SSBO的大小调整为最终矩阵大小：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When drawing multiple models, both buffers will end up with the maximum size
    of all models. But this does not do any harm, as the buffers will be reused for
    the next model and filled only up to the real amount of data used in the new model.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制多个模型时，两个缓冲区最终都会达到所有模型的最大大小。但这并不会造成任何伤害，因为缓冲区将被用于下一个模型，并且只填充到新模型实际使用的数据量。
- en: Calculating the node transforms in a shader
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在着色器中计算节点变换
- en: 'For the first compute shader, we must upload the node transform data to the
    first compute shader. We bind the SSBO storing the new TRS matrices created from
    the node transform to the proper binding point of the compute shader:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个计算着色器，我们必须将节点变换数据上传到第一个计算着色器。我们将存储从节点变换创建的新TRS矩阵的SSBO绑定到计算着色器的正确绑定点：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The compute shader itself is named `assimp_instance_transform.comp`, located
    in the `shader` folder. The first line of the compute shader is the usual version
    definition; the second line defines the local invocation sizes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器本身命名为`assimp_instance_transform.comp`，位于`shader`文件夹中。计算着色器的第一行是通常的版本定义；第二行定义了局部调用大小：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we create 32 invocations of the shader by default. You may need to experiment
    with the local sizes to achieve maximum performance. Shaders are started in groups
    of fixed sizes to simplify the GPU-internal management. Common values are 32 (called
    “warps,” for NVIDIA GPUs) or 64 (called “waves,” for AMD GPUs). It’s kind of useless
    to set all the local sizes to 1 for NVIDIA or AMD GPUs, since the remaining 31
    warps or respective 63 waves will be unused.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们默认创建32个着色器调用。你可能需要尝试不同的局部大小以实现最佳性能。着色器以固定大小的组启动，以简化GPU内部管理。常见的值是32（称为“warps”，针对NVIDIA
    GPU）或64（称为“waves”，针对AMD GPU）。对于NVIDIA或AMD GPU，将所有局部大小设置为1是有点无用的，因为剩余的31个warps或相应的63个waves将不会被使用。
- en: 'Next, we must add the `NodeTransformData` with the same data types as we used
    while declaring the type in the `OGLRenderData.h`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加与我们在`OGLRenderData.h`中声明类型时使用的相同数据类型的`NodeTransformData`：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As a reminder: The `rotation` element is a quaternion, disguised as `vec4`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下：`rotation`元素是一个四元数，伪装成`vec4`。
- en: 'Now, we define the two SSBOs, using the same binding points as in the renderer
    code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义两个SSBO，使用与渲染器代码中相同的绑定点：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We mark the node transform data as `readonly`, and the TRS matrices as `writeonly`.
    The two modifiers could help the shader compiler to optimize the access of the
    buffers, since some operations could be left out. The other modifier, `restrict`,
    also helps the shader compiler to optimize the shader code. By adding `restrict`,
    we tell the shader compiler that we will never read a value with a variable that
    we wrote before from another variable. Eliminating read-after-write dependencies
    will make the life of the shader compiler much easier.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将节点变换数据标记为`readonly`，将TRS矩阵标记为`writeonly`。这两个修饰符可以帮助着色器编译器优化缓冲区的访问，因为某些操作可以被省略。另一个修饰符`restrict`也有助于着色器编译器优化着色器代码。通过添加`restrict`，我们告诉着色器编译器我们不会从另一个变量中读取我们之前用变量写入的值。消除读后写依赖将使着色器编译器的生命变得更加轻松。
- en: To read the data from the `TransformData` buffer, three methods have been added.
    Within these three methods, called `getTranslationMatrix()`, `getScaleMatrix()`,
    and `getRotationMatrix()`, we read the data elements of the buffer and create
    4x4 matrices for the corresponding transformation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`TransformData`缓冲区读取数据，已添加了三种方法。在这三个方法中，称为`getTranslationMatrix()`、`getScaleMatrix()`和`getRotationMatrix()`，我们读取缓冲区中的数据元素并创建相应的变换的4x4矩阵。
- en: 'As an example, see the implementation of the `getTranslationMatrix()` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看`getTranslationMatrix()`方法的实现：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The resulting 4x4 matrix is an identity matrix, enriched by the translation
    data for the specific `index` in the `TransformData` buffer. The `getScaleMatrix()`
    method creates a scaling matrix, having the first three elements of the main diagonal
    set to the scaling values. Finally, the `getRotationMatrix()` method resembles
    the spirit of the `mat3_cast` algorithm from GLM, converting a quaternion into
    a 4x4 rotation matrix.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的4x4矩阵是一个单位矩阵，通过`TransformData`缓冲区中特定`index`的平移数据进行了丰富。`getScaleMatrix()`方法创建一个缩放矩阵，将主对角线的第一个三个元素设置为缩放值。最后，`getRotationMatrix()`方法类似于GLM中的`mat3_cast`算法的精神，将四元数转换为4x4旋转矩阵。
- en: 'In the `main()` method of the first compute shader, we get the `x` and `y`
    dimensions of the shader invocations:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个计算着色器的`main()`方法中，我们获取着色器调用的`x`和`y`维度：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will use the number of bones in the model as `x` dimension, simplifying
    the remaining part of the shader code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用模型中的骨骼数量作为`x`维度，简化着色器代码的其余部分：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Locating the correct index in the buffer is done by combining the number of
    bones, the shader instance (invocation), and the node we will work on:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合骨骼数量、着色器实例（调用）和我们将要处理的节点来定位缓冲区中的正确索引：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The main logic for the compute shader multiplies the translation, rotation,
    and scaling matrix in the TRS order, and saves the result in the buffer for the
    TRS matrices, at the same `index` of the node transforms:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器的主要逻辑按照TRS顺序乘以平移、旋转和缩放矩阵，并将结果保存在TRS矩阵的缓冲区中，与节点变换的相同`index`：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In GLM, matrices are multiplied from right to left, a fact that may be confusing
    at first. So, despite the name of the matrix being “TRS,” the multiplications
    are performed in reverse order of the name: The model scaling is applied first,
    then the rotation, and then the translation comes last. Other math libraries or
    different matrix packings may use a different order of multiplication. Two extensive
    matrix tutorials are listed in the *Additional resources* section.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLM中，矩阵是从右到左相乘的，这一点一开始可能会让人困惑。因此，尽管矩阵的名称是“TRS”，但乘法是按照名称的反序进行的：首先应用模型缩放，然后是旋转，最后是平移。其他数学库或不同的矩阵打包可能使用不同的乘法顺序。在*附加资源*部分列出了两个广泛的矩阵教程。
- en: Saving the TRS matrix on the same spot as the node transforms retains the order
    of nodes in a model and the order of nodes in all model instances.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将TRS矩阵保存在与节点变换相同的地点保留了模型中节点和所有模型实例中节点的顺序。
- en: 'To trigger the shader execution, we call `glDispatchCompute()` for the OpenGL
    renderer, adding a memory barrier that waits for the SSBO:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发着色器执行，我们为OpenGL渲染器调用`glDispatchCompute()`，并添加一个等待SSBO的内存屏障：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The memory barrier makes sure the CPU waits for a specific state of the GPU.
    In this case, we must wait until all SSBO writes have finished, so we set the
    bit for the shader storage buffers. The call to `glMemoryBarrier()` simply blocks
    execution, returning only after the GPU has reached the desired state.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 内存屏障确保CPU等待GPU达到特定状态。在这种情况下，我们必须等待所有SSBO写入完成，因此我们设置了着色器存储缓冲区的位。对`glMemoryBarrier()`的调用简单地阻塞执行，只有在GPU达到所需状态后才会返回。
- en: 'Before we go on, let’s take a look at what happens inside the compute shader
    when `glDispatchCompute()` or `vkCmdDispatch()` is called. *Figure 2.4* shows
    the internal elements of the compute shader invocations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看看当调用`glDispatchCompute()`或`vkCmdDispatch()`时计算着色器内部发生了什么。*图2.4*显示了计算着色器调用的内部元素：
- en: '![](img/figure_2_4.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_2_4.png)'
- en: 'Figure 2.4: Global work groups and local invocation structure of a compute
    shader'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：计算着色器的全局工作组和局部调用结构
- en: When we call the dispatch command with the parameters `4,4,2`, a total of number
    of `4*4*2 = 32` workgroups will be started, as shown on the left side of *Figure
    2.4*. The total number of workgroups is simply the product of the three dimensions
    `X`, `Y`, and `Z` of the global compute space.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用参数`4,4,2`调用调度命令时，总共将启动`4*4*2 = 32`个工作组，如图2.4左边的所示。工作组的总数是全球计算空间三个维度`X`、`Y`和`Z`的乘积。
- en: 'In each of the 32 workgroups, a total of four shader invocations are running,
    as seen for the workgroup `[3,0,0]` in the middle of *Figure 2.4*. The so-called
    local size is defined by the three shader layout values `local_size_x`, `local_size_y`,
    and `local_size_z`. The local size of a workgroup is calculated like the number
    of workgroups, by multiplying the three values for `X`, `Y`, and `Z` dimensions:
    `2*2*1 = 4`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个32个工作组中，总共运行了四个着色器调用，如*图2.4*中间的工作组`[3,0,0]`所示。所谓的局部大小由三个着色器布局值`local_size_x`、`local_size_y`和`local_size_z`定义。工作组的局部大小是通过将`X`、`Y`和`Z`维度的三个值相乘来计算的：`2*2*1
    = 4`。
- en: A separation into workgroups is important if the shader instances need to communicate
    between each other since communication is only possible inside the same workgroup.
    Shader invocations from different workgroups are effectively isolated and unable
    to communicate.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果着色器实例需要相互通信，那么将它们分离到工作组中是很重要的，因为通信只能在同一工作组内进行。来自不同工作组的着色器调用实际上是隔离的，无法通信。
- en: As you can see, the total number of shader invocations can become huge quite
    quickly, since the local size of a single workgroup and the total number of workgroups
    are multiplied. This massive parallelism is the secret behind the raw power of
    a GPU.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，着色器调用的总数可以非常快地变得非常大，因为单个工作组的局部大小和总工作组的数量是相乘的。这种巨大的并行性是GPU原始功率的秘密所在。
- en: So, for the `x` dimension, we use the `numberOfBones`, as stated before. By
    calculating the `std::ceil` of the `numberOfInstances` divided by 32 as the `y`
    dimension, we make sure to start groups of 32 shader invocations to calculate
    the matrices for up to 32 instances at once, as configured as the local `y` dimension
    in the shader code. If we have an instance count of less than a multiple of 32,
    the additional waves or warps are still running, but the results are ignored.
    Technically, we are reading and writing outside the buffer bounds, but the GPU
    driver should handle the situation, i.e., by discarding the writes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`x`维度，我们使用之前提到的`numberOfBones`。通过计算`numberOfInstances`除以32的`std::ceil`值作为`y`维度，我们确保以32个着色器调用为一组开始，一次计算多达32个实例的矩阵，正如在着色器代码中配置的局部`y`维度。如果我们有小于32的倍数的实例计数，额外的波或warp仍然在运行，但结果会被忽略。技术上，我们是在缓冲区边界之外进行读写，但GPU驱动程序应该处理这种情况，即通过丢弃写入。
- en: 'For Vulkan, we must call `VkCmdDispatch()`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，我们必须调用`VkCmdDispatch()`：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The size of the Shader Storage Buffer Object for the compute shaders in Vulkan
    should also be rounded to hold a multiple of 32 times the number of bones to avoid
    accidental overwrites of buffer data:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan中计算着色器的Shader Storage Buffer Object的大小也应该四舍五入，以容纳32的倍数个骨骼，以避免意外覆盖缓冲区数据：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Barriers to synchronizing the shaders in Vulkan must be set to wait for the
    results of the queues. For synchronization between the compute shader and the
    vertex shader, we need to set the barrier between the writes of the compute shader
    and the first read operation of the vertex shader like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中同步着色器的障碍必须设置为等待队列的结果。为了在计算着色器和顶点着色器之间进行同步，我们需要设置计算着色器写入和顶点着色器第一次读取操作之间的障碍，如下所示：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, Vulkan waits for the compute shader to finish all calculations before starting
    the draw calls in the vertex shader.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Vulkan在开始顶点着色器中的绘制调用之前，会等待计算着色器完成所有计算。
- en: The TRS matrix buffer now contains the matrices for every node, but without
    the parent nodes, the root node transform matrix, or any offset matrices.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: TRS矩阵缓冲区现在包含了每个节点的矩阵，但没有父节点、根节点变换矩阵或任何偏移矩阵。
- en: Creating the final node matrices
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建最终的节点矩阵
- en: 'Before we can start the next compute shader, we must bind all buffers that
    will be used during the shader run. We have a total of four SSBOs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始下一个计算着色器之前，我们必须绑定所有将在着色器运行期间使用的缓冲区。我们总共有四个SSBO：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since all data already resides on the GPU, we don’t need any kind of upload
    here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有数据已经驻留在GPU上，我们在这里不需要任何类型的上传。
- en: 'The second compute shader itself is called `assimp_instance_matrix_mult.comp`
    and can be found in the `shader` folder. The shader code starts – again – with
    a version and the local size definitions:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个计算着色器本身被称为 `assimp_instance_matrix_mult.comp`，可以在 `shader` 文件夹中找到。着色器代码再次从版本和局部大小定义开始：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A local size of 32 is used since the code was developed on a machine with an
    NVIDIA GPU. For an AMD GPU, you should use a local size of 64, as explained in
    the section *Calculating the node transforms in a shader*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码是在具有 NVIDIA GPU 的机器上开发的，因此使用了本地大小为 32。对于 AMD GPU，应使用本地大小为 64，如 *在着色器中计算节点变换*
    部分所述。
- en: 'Similar to the first compute shader, the SSBOs follow:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个计算着色器类似，接下来是 SSBOs：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first buffer, `TRSMatrix`, contains the TRS matrices from the first compute
    shader. In the `ParentMatrixIndices` buffer, the shader can find the list containing
    the parent node for each of the nodes. The bone matrix offsets for every node
    are made available in the third buffer, `BoneOffsets`, and the final node matrices
    will be stored in the last buffer, `BoneMatrices`. The `readonly` and `writeonly`
    modifiers are set according to the usage of the buffers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个缓冲区 `TRSMatrix` 包含第一个计算着色器中的 TRS 矩阵。在 `ParentMatrixIndices` 缓冲区中，着色器可以找到包含每个节点的父节点的列表。每个节点的骨骼矩阵偏移量在第三个缓冲区
    `BoneOffsets` 中提供，最终节点矩阵将存储在最后一个缓冲区 `BoneMatrices` 中。`readonly` 和 `writeonly`
    修饰符根据缓冲区的使用情况设置。
- en: 'Since we use the same settings as the first compute shader, having virtually
    the same first lines in the `main()` method of the second compute shader should
    be no surprise:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用与第一个计算着色器相同的设置，因此在第二个计算着色器的 `main()` 方法中几乎有相同的第一行代码应该不会让人感到惊讶：
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we get the TRS matrix for the bone we will be working on:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们获取我们将要工作的骨骼的 TRS 矩阵：
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we introduce a variable called `parent`, storing the `index` of the parent
    node:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们引入一个名为 `parent` 的变量，用于存储父节点的 `index`：
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We will need the `parent` node index to get the correct parent matrix while
    we walk the node skeleton up to the root node.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历节点骨架到根节点时，我们需要 `parent` 节点索引来获取正确的父矩阵。
- en: 'As the first step of the skeleton walk, we get the parent node of the node
    that we are working on:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为骨架遍历的第一步，我们获取我们正在工作的节点的父节点：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the following `while` loop, we get the parent matrix of the node and multiply
    both matrices. Then we look up the parent of the parent node, and so on:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 `while` 循环中，我们获取节点的父矩阵并相乘这两个矩阵。然后我们查找父节点的父节点，依此类推：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding lines of code may make you raise your eyebrows, since we apparently
    break one of the basic rules of GLSL shader code: the size of a loop must be known
    at compile time. Luckily, this rule does not apply to a `while` loop. We are free
    to alter the loop control variable inside the body of the loop, creating loops
    of various lengths.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可能让你皱眉，因为我们显然违反了 GLSL 着色器代码的一个基本规则：循环的大小必须在编译时已知。幸运的是，这个规则不适用于 `while` 循环。我们可以在循环体内自由更改循环控制变量，创建各种长度的循环。
- en: However, this code could impact shader performance as GPUs are optimized to
    execute the same instructions on every thread. You may have to check the shader
    code on different GPUs to make sure you see the expected speedup.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码可能会影响着色器性能，因为 GPU 优化了在每条线程上执行相同的指令。您可能需要在不同 GPU 上检查着色器代码，以确保您看到预期的加速。
- en: Also be aware that the accidental creation of an infinite loop may end in a
    locked-up system since the shader code never returns the wave or warp to the pool.
    It’s a good idea to ensure a valid exit condition for a while loop on the CPU
    side since a GPU lockup may only be resolved by a forced restart of your computer.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，意外创建无限循环可能会导致系统锁定，因为着色器代码永远不会将波或变形返回到池中。确保 CPU 侧的 `while` 循环有一个有效的退出条件是个好主意，因为
    GPU 锁定可能只能通过强制重启计算机来解决。
- en: 'As long as we don’t have errors or cycles in the parent node list, we will
    end at the last block for every node:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 只要父节点列表中没有错误或循环，我们就会在每个节点的最后一个块结束：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we multiply the resulting node matrix, containing all matrices up to the
    root node, by the bone offset matrix for the node, and store the result in the
    writable `NodeMatrices` buffer.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将包含所有矩阵（直到根节点）的结果节点矩阵与节点的骨骼偏移矩阵相乘，并将结果存储在可写的 `NodeMatrices` 缓冲区中。
- en: 'Starting the computation is done in exactly the same way as for the first shader.
    Run `glDispatchCompute()` for OpenGL, followed by a `glMemoryBarrier()`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的启动方式与第一个着色器完全相同。对于 OpenGL，运行 `glDispatchCompute()`，然后是 `glMemoryBarrier()`：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And, for Vulkan, use `VkCmdDispatch()`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，使用`VkCmdDispatch()`：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: At this point, the `NodeMatrices` buffer contains the TRS matrices for all nodes,
    close to the result we had after the `updateAnimation()` call in the CPU-based
    version of the code in [*Chapter 1*](Chapter_1.xhtml) – with the exception of
    the model root matrix for the instance.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`NodeMatrices`缓冲区包含所有节点的TRS矩阵，接近于[*第1章*](Chapter_1.xhtml)中基于CPU的代码在`updateAnimation()`调用后的结果——除了实例的模型根矩阵。
- en: Finalizing the compute relocation
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成计算重定位
- en: 'So, let’s add the missing matrix calculation to the vertex skinning shader.
    First, we collect the matrices containing the world positions during the loop
    over all instances of the model:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将缺少的矩阵计算添加到顶点皮肤着色器中。首先，我们在遍历模型的所有实例时收集包含世界位置的矩阵：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, the world position matrices are uploaded into an SSBO, and bound to the
    vertex skinning shader:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将世界位置矩阵上传到SSBO，并绑定到顶点皮肤着色器：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the vertex skinning shader itself, the new buffer is introduced:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点皮肤着色器本身中，引入了新的缓冲区：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, we create a combined matrix from the world position and the vertex
    skin matrix, and use the new matrix to calculate the position of the vertex and
    the normal:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个由世界位置和顶点皮肤矩阵组成的组合矩阵，并使用新的矩阵来计算顶点的位置和法线：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Compiling and running the example from *Chapter 2* should result in the same
    functionality as the example from [*Chapter 1*](Chapter_1.xhtml). We can load
    models and create a large number of instances, but we are still able to control
    the parameters of every single instance of every model. The main difference should
    be the amount of time it takes to create the transform matrices – we should see
    a large drop, compared to the CPU-based version, and end up most probably below
    10 milliseconds. Depending on your CPU and GPU types, the speed gain will differ.
    But in all cases, the GPU shader should be notably faster than pure CPU calculations.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第2章*](Chapter_2.xhtml)编译并运行示例应该会产生与[*第1章*](Chapter_1.xhtml)中的示例相同的功能。我们可以加载模型并创建大量实例，但我们仍然能够控制每个模型的每个实例的参数。主要区别应该是创建变换矩阵所需的时间——我们应该看到与基于CPU的版本相比有大幅下降，并且最终可能低于10毫秒。根据您的CPU和GPU类型，速度提升会有所不同。但在所有情况下，GPU着色器应该比纯CPU计算明显更快。
- en: Let’s see the speedup we achieved by using compute shaders.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们通过使用计算着色器所实现的加速效果。
- en: Testing the implementation by scaling up
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过扩展规模来测试实现
- en: 'All features and the user interface are identical to [*Chapter 1*](Chapter_1.xhtml).
    But our changes can be made visible by adding more and more instances. If you
    add the same 1,600 instances as in *Figure 2.1*, you will see much smaller matrix
    generation times. The values may be similar to *Figure 2.5*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所有功能和用户界面都与[*第1章*](Chapter_1.xhtml)相同。但通过添加越来越多的实例，我们可以使我们的更改变得可见。如果你添加与*图2.1*中相同的1,600个实例，你将看到更小的矩阵生成时间。数值可能类似于*图2.5*：
- en: '![](img/figure_2_5.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_2_5.png)'
- en: 'Figure 2.5: The compute shader version with 1,600 instances'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：具有1,600个实例的计算着色器版本
- en: The time for virtually the same matrix operations went down from ~24 milliseconds
    on the CPU to less than 6 milliseconds by using compute shaders. We won around
    18 milliseconds of CPU time in every single frame!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用计算着色器，几乎相同的矩阵操作时间从CPU上的约24毫秒下降到不到6毫秒。我们在每一帧中赢得了大约18毫秒的CPU时间！
- en: 'Now let us add more models – many models. Let’s say we add a total of 4,000
    instances of the example model. The resulting matrix generation times on your
    machine may be similar to the number in *Figure 2.6*:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加更多的模型——许多模型。比如说，我们添加了4,000个示例模型的实例。在您的机器上生成的矩阵时间可能与*图2.6*中的数字相似：
- en: '![](img/figure_2_6.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_2_6.png)'
- en: 'Figure 2.6: The compute shader version with 4,000 instances'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：具有4,000个实例的计算着色器版本
- en: Even with 2.5 times the number of instances, the average matrix generation time
    of the compute shader code is still at about half the time of the CPU version.
    You may even see a much larger, non-linear performance gain with more powerful
    GPUs. Recent GPUs not only have several thousands of cores that are working in
    parallel on the matrix multiplications, but the next biggest model also nearly
    doubles the number of cores, leading to more parallelization.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 即使实例数量增加了2.5倍，计算着色器代码的平均矩阵生成时间仍然大约是CPU版本的二分之一。你甚至可能会看到更大的、非线性的性能提升，尤其是在更强大的GPU上。最近的GPU不仅拥有数千个并行工作的核心来处理矩阵乘法，而且下一个最大的型号几乎将核心数量翻倍，从而实现更多的并行化。
- en: We can scale up the number of instances a lot more or process more complex models
    while still having a lower matrix generation time. At some arbitrary number of
    instances, the frame rate of the application will still drop below 60 FPS. Depending
    on your system, this may happen before reaching the 4,000 instances of *Figure
    2.6*, or much later.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以大幅增加实例的数量，或者处理更复杂的模型，同时仍然保持较低的矩阵生成时间。在某个任意的实例数量时，应用程序的帧率仍然会低于60 FPS。根据你的系统，这可能会发生在达到*图2.6*的4,000个实例之前，或者更晚。
- en: 'If you attach a profiler to the application, you will spot the new bottleneck
    of our calculation: The quaternion SLERP at the end of the method `getRotation()`
    in the `AssimpAnimChannel` class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将分析器附加到应用程序上，你会注意到我们计算的新瓶颈：`AssimpAnimChannel`类中`getRotation()`方法末尾的四元数SLERP：
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Also, the two `mix()` calls of `getTranslation()` and `getScale()` in the `AssimpAnimChannel`
    class will be among the top findings of the profiler.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AssimpAnimChannel`类中`getTranslation()`和`getScale()`的两次`mix()`调用将是分析器的前几个发现之一。
- en: 'At this point, you could try to move even more operations to the compute shaders.
    But be aware that your mileage may vary. Some changes could raise the computational
    load of the GPU more than the CPU load will be lowered. That’s the moment when
    you should grab a good book about shader programming, or watch some conference
    talks, if you want to continue your journey into the world of compute shaders.
    The best way to get into GPU computation is still “learning by doing” and not
    giving up if the shader does not give the expected results. But be warned: Here
    will be dragons around, eating your time...'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以尝试将更多的操作移动到计算着色器中。但请注意，你的效果可能会有所不同。一些更改可能会增加GPU的计算负载，而CPU负载则会降低。这就是你应该拿起一本关于着色器编程的好书，或者观看一些会议演讲，如果你想继续你的计算着色器之旅的时候。进入GPU计算的最佳方式仍然是“实践学习”，并且如果着色器没有给出预期的结果，不要放弃。但警告：这里会有龙，吞噬你的时间...
- en: Before we close this chapter, let’s talk briefly about compute shader debugging.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关闭这一章之前，让我们简要地谈谈计算着色器调试。
- en: How to debug a compute shader
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何调试计算着色器
- en: Compute shaders are cool – at least, until you run into some kind of trouble.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器很酷——至少，直到你遇到某种麻烦。
- en: While you can easily attach a debugger to the CPU code to see what’s going on,
    the GPU side is harder to check. A mistake in a fragment shader may cause distorted
    graphics, providing some hint for where the bug lies, but in other cases, you
    might see just nothing. In addition to undoing the latest changes, you can always
    attach a debugging tool like **RenderDoc** and check out what’s going wrong with
    the usual shader types.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以轻松地将调试器附加到CPU代码中查看发生了什么，但GPU端更难检查。片段着色器中的错误可能会导致图形扭曲，提供一些关于错误位置的线索，但在其他情况下，你可能会什么也看不到。除了撤销最新的更改外，你还可以始终附加调试工具如**RenderDoc**，并检查通常的着色器类型中出了什么问题。
- en: But, while RenderDoc has experimental support for compute shader debugging,
    this support is still limited. So, in contrast to other shader types, a compute
    shader is mostly a “black box” for us with RenderDoc – a program receiving and
    outputting opaque data.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，尽管RenderDoc对计算着色器调试有实验性支持，但这种支持仍然有限。因此，与其他着色器类型相比，计算着色器对我们来说主要是“黑盒”——一个接收和输出不透明数据的程序。
- en: Depending on your GPU, you might want to try out NVIDIA Nsight (for NVIDIA GPUs)
    or the AMD Radeon GPU Profiler (for AMD GPUs). Links to all three tools are available
    in the *Additional resources* section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的GPU，你可能想尝试NVIDIA Nsight（适用于NVIDIA GPU）或AMD Radeon GPU Profiler（适用于AMD GPU）。所有三个工具的链接都可在*附加资源*部分找到。
- en: In many cases though, the problems in a compute shader come from simple mistakes.
    Uploading wrong or incomplete data to an SSBO, stride or padding problems, getting
    the order of elements wrong, swapping the order of a (non-commutative) matrix
    multiplication by accident... simple, but annoying errors that can take ages to
    find.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，计算着色器中的问题源于简单的错误。将错误或不完整的数据上传到SSBO，步进或填充问题，元素顺序错误，意外地交换（非交换）矩阵乘法的顺序……这些简单但令人烦恼的错误可能需要花费很长时间才能找到。
- en: 'A quite easy way to see what a compute shader stage does is by reading back
    the contents of the SSBOs. As an example for OpenGL, these lines read the data
    inside the SSBO `buffer` into the `std::vector` named `bufferVector`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过读取SSBO的内容，可以很容易地看到计算着色器阶段做了什么。例如，对于OpenGL，这些行将`buffer` SSBO中的数据读取到名为`bufferVector`的`std::vector`中：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The contents of the SSBO could be compared to the results of the same calculations
    done on the CPU. Step by step and buffer by buffer, the problem may be narrowed
    down until the error has been found.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: SSBO的内容可以与在CPU上执行相同计算的结果进行比较。逐步逐缓冲区地缩小问题，直到找到错误。
- en: Reading back an SSBO may not be an obvious solution to do compute shader debugging,
    but every little bit of help is welcome here. But, depending on the complexity
    of the shader, you may be thrown back to a manual walk-through of the code. Also,
    try to use a simple dataset to simplify debugging.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从SSBO读取可能不是进行计算着色器调试的明显解决方案，但这里任何一点帮助都是受欢迎的。但是，根据着色器的复杂性，你可能需要手动遍历代码。此外，尝试使用简单的数据集以简化调试。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we moved a large part of the computations from the CPU to compute
    shaders on the GPU. After a brief history of concurrent code execution, we created
    a plan on how to move the node transform calculation to the GPU, and we finally
    executed that plan. At the end of the chapter, we checked the resulting application
    for the speedup we achieved.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将大量计算从CPU移动到GPU上的计算着色器。在简要回顾了并发代码执行的历史之后，我们制定了一个将节点变换计算移动到GPU的计划，并最终执行了该计划。在章节末尾，我们检查了实现的应用程序以确认我们获得的速度提升。
- en: In the next chapter, we will take a look at solutions to add a visual selection
    to the model view application. Being able to create thousands of model instances
    is nice, but locating one special instance among all the others is nearly impossible
    right now. We will discuss two different approaches and implement one of them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨为模型视图应用程序添加视觉选择的方法。能够创建成千上万的模型实例是件好事，但在众多实例中找到特殊的一个几乎是不可能的。我们将讨论两种不同的方法并实现其中之一。
- en: Practical sessions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'There are some additions you could make to the code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中添加一些内容：
- en: Add “Programmable Vertex Pulling” to the code.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“可编程顶点拉取”添加到代码中。
- en: With Programmable Vertex Pulling, the vertex data will no longer be pushed by
    using a vertex buffer. Instead, the vertex data will be uploaded to a UBO or SSBO
    to the GPU, and the vertex shader is used to extract all the data for every vertex
    from that buffer.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可编程顶点拉取，顶点数据将不再通过顶点缓冲区来推送。相反，顶点数据将被上传到GPU的UBO或SSBO，并且顶点着色器用于从该缓冲区中提取每个顶点的所有数据。
- en: Move `mix()` and `slerp()` from `AssimpAnimChannel` to the GPU.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`mix()`和`slerp()`从`AssimpAnimChannel`移动到GPU。
- en: When the two data values for the timings of translation, rotation, and scaling
    have been extracted from the channel vector, a linear interpolation for translation
    and scaling and a SLERP for rotation are required. Both interpolation types are
    called thousands of items per frame – maybe the GPU is faster.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当从通道向量中提取了平移、旋转和缩放的时序数据值后，需要为平移和缩放进行线性插值，以及为旋转进行SLERP。这两种插值类型每帧都称为数千项——也许GPU更快。
- en: Blend between two animations in a compute shader.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算着色器中混合两个动画。
- en: This task is similar to the previous practical session. But, instead of doing
    the interpolation between the animation keys of a single animation clip on the
    GPU, do the interpolation between the transformations at the same time for two
    different animation clips.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务与之前的实践课程类似。但是，不是在GPU上对单个动画剪辑的动画键进行插值，而是在两个不同的动画剪辑的变换同时进行插值。
- en: 'For extra difficulty: Combine both tasks and do interpolations between the
    4 values for the node transformations of two animation clips in a compute shader.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 额外难度：将两个任务结合起来，在计算着色器中对两个动画剪辑的节点变换的4个值进行插值。
- en: Use RenderDoc to view the buffer contents.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RenderDoc查看缓冲区内容。
- en: Since the buffer data type is shown as RGB values in RenderDoc, you may see
    some interesting and recurring patterns in the buffers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RenderDoc中显示的缓冲区数据类型是RGB值，你可能在缓冲区中看到一些有趣且重复的模式。
- en: Additional resources
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外资源
- en: 'C64 demo coding: [https://codebase64.org/doku.php?id=base:start](https://codebase64.org/doku.php?id=base:start)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C64演示编码：[https://codebase64.org/doku.php?id=base:start](https://codebase64.org/doku.php?id=base:start)
- en: 'Atari ST demo scene: [https://democyclopedia.wordpress.com](https://democyclopedia.wordpress.com)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atari ST演示场景：[https://democyclopedia.wordpress.com](https://democyclopedia.wordpress.com)
- en: 'pouët.net demo scene archive: [https://www.pouet.net](https://www.pouet.net)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pouët.net演示场景存档：[https://www.pouet.net](https://www.pouet.net)
- en: 'LearnOpenGL on compute shaders: [https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction](https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LearnOpenGL上的计算着色器教程：[https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction](https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction)
- en: 'Vulkan Tutorial on compute shaders: [https://vulkan-tutorial.com/Compute_Shader](https://vulkan-tutorial.com/Compute_Shader)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算着色器的Vulkan教程：[https://vulkan-tutorial.com/Compute_Shader](https://vulkan-tutorial.com/Compute_Shader)
- en: '*Vulkan Compute: High-Performance Compute Programming with Vulkan and Compute
    Shaders* by *Kenwright*, published by the author himself, ISBN: 979-8345148280'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '由Kenwright撰写的《*Vulkan Compute: High-Performance Compute Programming with Vulkan
    and Compute Shaders*》，作者自出版，ISBN：979-8345148280'
- en: 'GLSL Interface block restrictions: [https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)](https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL))'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLSL 接口块限制：[https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)](https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL))
- en: 'Matrix multiplication guide: [https://blog.mecheye.net/2024/10/the-ultimate-guide-to-matrix-multiplication-and-ordering/](https://blog.mecheye.net/2024/10/the-ultimate-guide-to-matrix-multiplication-and-ordering/%0D%0A)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵乘法指南：[https://blog.mecheye.net/2024/10/the-ultimate-guide-to-matrix-multiplication-and-ordering/](https://blog.mecheye.net/2024/10/the-ultimate-guide-to-matrix-multiplication-and-ordering/%0D%0A)
- en: 'Tutorial on different matrix multiplications: [https://tomhultonharrop.com/mathematics/matrix/2022/12/26/column-row-major.html](https://tomhultonharrop.com/mathematics/matrix/2022/12/26/column-row-major.html%0D%0A)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同矩阵乘法的教程：[https://tomhultonharrop.com/mathematics/matrix/2022/12/26/column-row-major.html](https://tomhultonharrop.com/mathematics/matrix/2022/12/26/column-row-major.html%0D%0A)
- en: 'OpenGL memory barriers: [https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml%0D%0A)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL 内存屏障：[https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml%0D%0A)
- en: 'RenderDoc homepage: [https://renderdoc.org](https://renderdoc.org)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RenderDoc 主页：[https://renderdoc.org](https://renderdoc.org)
- en: 'NVIDIA Nsight: [https://developer.nvidia.com/tools-overview](https://developer.nvidia.com/tools-overview)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVIDIA Nsight：[https://developer.nvidia.com/tools-overview](https://developer.nvidia.com/tools-overview)
- en: 'AMD Radeon GPU Profiler: [https://gpuopen.com/rgp/](https://gpuopen.com/rgp/)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD Radeon GPU 分析器：[https://gpuopen.com/rgp/](https://gpuopen.com/rgp/)
