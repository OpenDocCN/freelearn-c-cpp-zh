- en: '*Chapter 6*: Concepts and Constraints'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：概念和约束'
- en: The C++20 standard provides a series of significant improvements to template
    metaprogramming with concepts and constraints. A **constraint** is a modern way
    to define requirements on template parameters. A **concept** is a set of named
    constraints. Concepts provide several benefits to the traditional way of writing
    templates, mainly improved readability of code, better diagnostics, and reduced
    compilation times.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++20标准通过概念和约束提供了一系列对模板元编程的重大改进。**约束**是一种现代的方式来定义对模板参数的要求。**概念**是一组命名的约束。概念为传统的模板编写方式提供了几个好处，主要是代码可读性的提高、更好的诊断和减少编译时间。
- en: 'In this chapter, we will address the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding the need for concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解概念的需求
- en: Defining concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义概念
- en: Exploring requires expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索需求表达式
- en: Composing constraints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写约束
- en: Learning about the ordering of templates with constraints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解带有约束的模板的排序
- en: Constraining non-template member functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制非模板成员函数
- en: Constraining class templates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制类模板
- en: Constraining variable templates and template aliases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制变量模板和模板别名
- en: Learning more ways to specify constraints
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习更多指定约束的方式
- en: Using concepts to constrain auto parameters
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用概念来约束`auto`参数
- en: Exploring the standard concepts library
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索标准概念库
- en: By the end of this chapter, you will have a good understanding of the C++20
    concepts, and an overview of what concepts the standard library provides.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解C++20的概念，并对标准库提供哪些概念有一个概述。
- en: We will start the chapter by discussing what led to the development of concepts
    and what their main benefits are.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章的讨论从探讨导致概念发展的原因及其主要好处开始。
- en: Understanding the need for concepts
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解概念的需求
- en: 'As briefly mentioned in the introduction to this chapter, there are some important
    benefits that concepts provide. Arguably, the most important ones are code readability
    and better error messages. Before we look at how to use concepts, let’s revisit
    an example we saw previously and see how it stands in relation to these two programming
    aspects:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言中简要提到的，概念提供了一些重要的好处。可以说，其中最重要的好处是代码可读性和更好的错误信息。在我们查看如何使用概念之前，让我们回顾一个之前看到的例子，并看看它与这两个编程方面有什么关系：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This simple function template takes two arguments and returns their sum. In
    fact, it does not return the sum, but the result of applying the plus operator
    to the two arguments. A user-defined type can overload this operator and perform
    some particular operation. The term *sum* only makes sense when we discuss mathematical
    types, such as integral types, floating-point types, the `std::complex` type,
    matrix types, vector types, etc.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数模板接受两个参数并返回它们的和。实际上，它并不返回和，而是将加法运算符应用于两个参数的结果。用户定义的类型可以重载此运算符并执行某些特定操作。术语“和”仅在讨论数学类型时才有意义，例如整数类型、浮点类型、`std::complex`类型、矩阵类型、向量类型等。
- en: 'For a string type, for instance, the plus operator can mean concatenation.
    And for most types, its overloading does not make sense at all. Therefore, just
    by looking at the declaration of the function, without inspecting its body, we
    cannot really say what this function may accept as input and what it does. We
    can call this function as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于字符串类型，加法运算符可以表示连接。而对于大多数类型，其重载根本没有任何意义。因此，仅通过查看函数的声明，而不检查其主体，我们并不能真正地说这个函数可能接受什么作为输入以及它做什么。我们可以这样调用这个函数：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first three calls are all good; the first call adds two integers, the second
    adds two `double` values, and the third concatenates two `std::string` objects.
    However, the fourth call will produce a compiler error because `const char *`
    is substituted for the `T` type template parameter, and the plus operator is not
    overloaded for pointer types.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前三次调用都是好的；第一次调用添加了两个整数，第二次添加了两个`double`值，第三次连接了两个`std::string`对象。然而，第四次调用将产生编译错误，因为`const
    char *`被替换为类型模板参数`T`，并且加法运算符没有为指针类型重载。
- en: The intention for this `add` function template is to allow passing only values
    of arithmetic types, that is, integer and floating-point types. Before C++20,
    we could do this in several ways.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`add`函数模板的意图是仅允许传递算术类型的值，即整数和浮点类型。在C++20之前，我们可以用几种方式做到这一点。
- en: 'One way is to use `std::enable_if` and SFINAE, as we saw in the previous chapter.
    Here is such an implementation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是通过使用`std::enable_if`和SFINAE，正如我们在上一章中看到的。以下是一个这样的实现：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first thing to notice here is that the readability has decreased. The second
    type template parameter is difficult to read and requires good knowledge of templates
    to understand. However, this time, both the calls on the lines marked with `[3]`
    and `[4]` are producing a compiler error. Different compilers are issuing different
    error messages. Here are the ones for the three major compilers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里首先要注意的是，可读性已经下降。第二个模板参数类型难以阅读，并且需要良好的模板知识才能理解。然而，这次，标记为 `[3]` 和 `[4]` 的行上的调用都在产生编译器错误。不同的编译器会发出不同的错误信息。以下是三个主要编译器的错误信息：
- en: 'In **VC++ 17**, the output is:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **VC++ 17** 中，输出如下：
- en: '[PRE16]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In **GCC 12**, the output is:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **GCC 12** 中，输出如下：
- en: '[PRE17]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In **Clang 13**, the output is:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Clang 13** 中，输出如下：
- en: '[PRE18]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The error message in GCC is very verbose, and VC++ doesn’t say what the reason
    for failing to match the template argument is. Clang does, arguably, a better
    job at providing an understandable error message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: GCC的错误信息非常冗长，而VC++没有说明模板参数匹配失败的原因。Clang在这方面做得更好，提供了更易于理解的错误信息。
- en: 'Another way to define restrictions for this function, prior to C++20, is with
    the help of a `static_assert` statement, as shown in the following snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20之前，为这个函数定义限制的另一种方法是通过`static_assert`语句，如下面的片段所示：
- en: '[PRE19]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this implementation, however, we returned to the original problem that
    just by looking at the declaration of the function, we wouldn’t know what kind
    of parameters it would accept, provided that any restriction exists. The error
    messages, on the other hand, are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个实现中，我们回到了原始问题：仅仅通过查看函数的声明，我们无法知道它将接受什么样的参数，前提是存在任何限制。另一方面，错误信息如下：
- en: 'In **VC++ 17**:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **VC++ 17** 中：
- en: '[PRE26]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In **GCC 12**:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **GCC 12** 中：
- en: '[PRE27]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In **Clang 13**:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Clang 13** 中：
- en: '[PRE28]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The use of the `static_assert` statement results in similar error messages received
    regardless of the compiler.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static_assert`语句会导致无论使用哪种编译器都会收到类似的错误信息。
- en: 'We can improve these two discussed aspects (readability and error messages)
    in C++20 by using constraints. These are introduced with the new `requires` keyword
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用C++20中的约束来改进这两个讨论的方面（可读性和错误信息）。这些约束是通过新的`requires`关键字引入的，如下所示：
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `requires` keyword introduces a clause, called the **requires clause**,
    that defines the constraints on the template parameters. There are, actually,
    two alternative syntaxes: one when the requires clause follows the template parameter
    list, as seen previously, and one when the requires clause follows the function
    declaration, as shown in the next snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires`关键字引入了一个子句，称为**requires子句**，它定义了模板参数的约束。实际上，有两种不同的语法：一种是在模板参数列表之后跟随requires子句，如之前所见，另一种是在函数声明之后跟随requires子句，如下一个片段所示：'
- en: '[PRE35]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Choosing between these two syntaxes is a matter of personal preference. However,
    in both cases, the readability is much better than in the pre-C++20 implementations.
    You know just by reading the declaration that the `T` type template parameter
    must be of an arithmetic type. Also, this implies that the function is simply
    adding two numbers. You don’t really need to see the definition to know that.
    Let’s see how the error message changes when we call the function with invalid
    arguments:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择这两种语法时，这是一个个人偏好的问题。然而，在两种情况下，可读性都比C++20之前的实现要好得多。仅通过阅读声明，你就知道类型模板参数`T`必须是算术类型。这也意味着该函数只是简单地相加两个数字。你实际上不需要看到定义就能知道这一点。让我们看看当我们用无效参数调用函数时错误信息如何变化：
- en: 'In **VC++ 17**:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **VC++ 17** 中：
- en: '[PRE41]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In **GCC 12**:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **GCC 12** 中：
- en: '[PRE42]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In **Clang 13**:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Clang 13** 中：
- en: '[PRE43]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The error messages follow the same patterns seen already: GCC is too verbose,
    VC++ is missing essential information (the constraint that is not met), while
    Clang is more concise and better pinpoints the cause of the error. Overall, there
    is an improvement in the diagnostic messages, although there is still room for
    improvement.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息遵循之前看到的相同模式：GCC太啰嗦，VC++缺少必要的信息（未满足的约束），而Clang则更加简洁，并能更好地指出错误的原因。总的来说，诊断信息有所改进，尽管仍有改进的空间。
- en: A constraint is a predicate that evaluates to true or false at compile-time.
    The expression used in the previous example, `std::is_arithmetic_v<T>`, is simply
    using a standard type trait (which we saw in the previous chapter). However, these
    are different kinds of expressions that can be used in a constraint, and we will
    learn about them later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是一个在编译时评估为真或假的谓词。在前面示例中使用的表达式 `std::is_arithmetic_v<T>`，仅仅是使用了一个标准类型特性（我们在上一章中看到过）。然而，这些是可以在约束中使用的不同类型的表达式，我们将在本章后面学习它们。
- en: In the next section, we look at how to define and use named constraints.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何定义和使用命名约束。
- en: Defining concepts
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义概念
- en: 'The constraints seen previously are nameless predicates defined in the places
    they are used. Many constraints are generic and can be used in multiple places.
    Let’s consider the following example of a function similar to the `add` function.
    This function performs the multiplication of arithmetic values and is shown next:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之前看到的约束是在它们被使用的地方定义的无名谓词。许多约束是通用的，可以在多个地方使用。让我们考虑以下类似于 `add` 函数的函数示例。这个函数执行算术值的乘法，如下所示：
- en: '[PRE44]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The same requires clause seen with the `add` function is present here. To avoid
    this repetitive code, we can define a name constraint that can be reused in multiple
    places. A named constraint is called a `concept` keyword and template syntax.
    Here is an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `add` 函数中看到的相同的 requires 子句也出现在这里。为了避免这种重复的代码，我们可以定义一个可以在多个地方重用的命名约束。命名约束被称为
    `concept` 关键字和模板语法。以下是一个示例：
- en: '[PRE50]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Even though they are assigned a Boolean value, concept names should not contain
    verbs. They represent requirements and are used as attributes or qualifiers on
    template parameters. Therefore, you should prefer names such as *arithmetic*,
    *copyable*, *serializable*, *container*, and more, and not *is_arithmetic*, *is_copyable*,
    *is_serializable*, and *is_container*. The previously defined arithmetic concept
    can be used as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们被分配了布尔值，概念名称也不应包含动词。它们代表需求，并用作模板参数的属性或限定符。因此，你应该优先选择诸如 *arithmetic*、*copyable*、*serializable*、*container*
    等名称，而不是 *is_arithmetic*、*is_copyable*、*is_serializable* 和 *is_container*。之前定义的算术概念可以这样使用：
- en: '[PRE52]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can see from this snippet that the concept is used instead of the `typename`
    keyword. It qualifies the `T` type with the arithmetic quality, meaning that only
    the types that satisfy this requirement can be used as template arguments. The
    same arithmetic concept can be defined with a different syntax, shown in the following
    snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个片段中，你可以看到概念被用来代替 `typename` 关键字。它用算术质量限定 `T` 类型，这意味着只有满足这个要求的类型才能用作模板参数。相同的算术概念可以用不同的语法定义，如下面的片段所示：
- en: '[PRE56]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This uses a *requires expression*. A requires expression uses curly branches,
    `{}`, whereas a *requires clause* does not. A requires expression can contain
    a sequence of requirements of different kinds: simple requirements, type requirements,
    compound requirements, and nested requirements. The one seen here is a simple
    requirement. For the purpose of defining this particular concept, this syntax
    is more complicated but has the same final effect. However, in some cases, complex
    requirements are needed. Let’s look at an example.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了 *requires 表达式*。requires 表达式使用花括号 `{}`，而 requires 子句则不使用。requires 表达式可以包含一系列不同类型的约束：简单约束、类型约束、复合约束和嵌套约束。这里看到的是一个简单约束。为了定义这个特定的概念，这种语法更复杂，但最终效果相同。然而，在某些情况下，需要复杂的约束。让我们看一个例子。
- en: 'Consider the case when we want to define a template that should only take container
    types for an argument. Before concepts were available, this could have been solved
    with the help of a type trait and SFINAE or a `static_assert` statement, as we
    saw at the beginning of this chapter. However, a container type is not really
    easy to define formally. We can do it based on some properties of the standard
    containers:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们想要定义一个只接受容器类型作为参数的模板的情况。在概念可用之前，这可以通过类型特性、SFINAE 或 `static_assert` 语句的帮助来解决，正如我们在本章开头所看到的。然而，正式定义容器类型并不容易。我们可以基于标准容器的一些属性来完成它：
- en: They have the member types `value_type`, `size_type`, `allocator_type`, `iterator`,
    and `const_iterator`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有成员类型 `value_type`、`size_type`、`allocator_type`、`iterator` 和 `const_iterator`。
- en: They have the member function `size` that returns the number of elements in
    the container.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个成员函数 `size`，该函数返回容器中的元素数量。
- en: They have the member functions `begin`/`end` and `cbegin`/`cend` that return
    iterators and constant iterators to the first and one-past-the-last element in
    the container.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有`begin`/`end`和`cbegin`/`cend`成员函数，这些函数返回迭代器和常量迭代器，指向容器中的第一个元素和最后一个元素之后的一个元素。
- en: 'With the knowledge accumulated from [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*, we can define an `is_containter` type
    trait as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从[*第5章*](B18367_05_ePub.xhtml#_idTextAnchor080)积累的知识，*类型特性和条件编译*，我们可以定义一个`is_containter`类型特性如下：
- en: '[PRE58]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can verify with the help of `static_assert` statements that the type trait
    correctly identifies container types. Here is an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`static_assert`语句来验证类型特性是否正确识别容器类型。以下是一个示例：
- en: '[PRE75]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Concepts make writing such a template constraint much easier. We can employ
    the concept syntax and requires expressions to define the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 概念使得编写这样的模板约束变得更容易。我们可以使用概念语法和`requires`表达式来定义以下内容：
- en: '[PRE78]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This definition is both shorter and more readable. It uses both simple requirements,
    such as `t.size()`, and type requirements, such as `typename T::value_type`. It
    can be used to constrain template parameters in the manner seen previously but
    can also be used with the `static_assert` statements (since constraints evaluate
    to a compile-time Boolean value):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义既简短又易于阅读。它使用了简单的要求，如`t.size()`，以及类型要求，如`typename T::value_type`。它可以用来以先前看到的方式约束模板参数，也可以与`static_assert`语句一起使用（因为约束评估为编译时的布尔值）：
- en: '[PRE92]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In the following section, we will explore in depth the various kinds of requirements
    that can be used in requires expressions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨`requires`表达式中可以使用的各种要求类型。
- en: Exploring requires expressions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索`requires`表达式
- en: 'A requires expression may be a complex expression, as seen earlier in the example
    with the container concept. The actual form of a requires expression is very similar
    to function syntax and is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`requires`表达式可能是一个复杂表达式，如前面示例中容器概念的例子所示。`requires`表达式的实际形式非常类似于函数语法，如下所示：
- en: '[PRE97]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `parameter-list` is a comma-separated list of parameters. The only difference
    from a function declaration is that default values are not allowed. However, the
    parameters that are specified in this list do not have storage, linkage, or lifetime.
    The compiler does not allocate any memory for them; they are only used to define
    requirements. However, they do have a scope, and that is the closing curly brace
    of the requires expression.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`parameter-list`是一个以逗号分隔的参数列表。与函数声明不同的是，不允许使用默认值。然而，在此列表中指定的参数没有存储、链接或生命周期。编译器不会为它们分配任何内存；它们仅用于定义要求。但是，它们确实有作用域，那就是`requires`表达式的闭合花括号。'
- en: 'The `requirements-seq` is a sequence of requirements. Each such requirement
    must end with a semicolon, like any statement in C++. There are four types of
    requirements:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements-seq`是一系列要求。每个此类要求必须以分号结束，就像C++中的任何语句一样。有四种类型的要求：'
- en: Simple requirements
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单要求
- en: Type requirements
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型要求
- en: Compound requirements
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合要求
- en: Nested requirements
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套要求
- en: 'These requirements may refer to the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求可能引用以下内容：
- en: Template parameters that are in scope
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围内的模板参数
- en: Local parameters introduced in the parameter list of the requires expression
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`requires`表达式的参数列表中引入的局部参数
- en: Any other declaration that is visible from the enclosing context
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何从封装上下文中可见的其他声明
- en: In the following subsections, we will explore all the mentioned types of requirements.
    In the beginning, we’ll look at the simple requirements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将探讨所有提到的要求类型。一开始，我们将查看简单要求。
- en: Simple requirements
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单要求
- en: A `true`. The expression must not start with the `requires` keyword as that
    defines a nested requirement (which will be discussed later).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`true`。表达式不能以`requires`关键字开头，因为这定义了一个嵌套要求（稍后讨论）。
- en: 'We already saw examples of simple statements when we defined the `arithmetic`
    and `container` concepts earlier. Let’s see a few more:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前定义`arithmetic`和`container`概念时，我们已经看到了简单语句的例子。让我们再看几个例子：
- en: '[PRE98]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The first concept, `arithmetic`, is the same one we defined earlier. The `std::is_arithmetic_v<T>`
    expression is a simple requirement. Notice that when the parameter list is empty
    it can be completely omitted, as seen in this case, where we only check that the
    `T` type template parameter is an arithmetic type.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个概念，`算术`，与我们之前定义的是同一个。`std::is_arithmetic_v<T>` 表达式是一个简单的需求。注意，当参数列表为空时，它可以完全省略，就像在这个例子中，我们只检查
    `T` 类型模板参数是否为算术类型。
- en: The `addable` and `logger` concepts both have a parameter list because we are
    checking operations on values of the `T` type. The expression `a + b` is a simple
    requirement, as the compiler just checks that the plus operator is overloaded
    for the `T` type. In the last example, we make sure that the `T` type has three
    member functions called `error`, `warning`, and `info` that take a single parameter
    of the `const char*` type or some type that can be constructed from `const char*`.
    Keep in mind that the actual values passed as arguments have no importance since
    these calls are never performed; they are only checked for correctness.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`addable` 和 `logger` 概念都有参数列表，因为我们正在检查 `T` 类型值的操作。`a + b` 是一个简单需求，因为编译器只需检查加号运算符是否为
    `T` 类型重载。在最后一个例子中，我们确保 `T` 类型有三个名为 `error`、`warning` 和 `info` 的成员函数，这些函数接受一个 `const
    char*` 类型或可以从 `const char*` 构造的类型的单个参数。记住，实际传递给参数的值并不重要，因为这些调用从未执行过；它们只是被检查是否正确。'
- en: 'Let’s elaborate briefly on the last example and consider the following snippet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地阐述最后一个例子，并考虑以下片段：
- en: '[PRE115]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The `log_error` function template requires an argument of a type that meets
    the `logger` requirements. We have two classes, called `console_logger` and `stream_logger`.
    The first meets the `logger` requirements, but the second does not. That is because
    the `info` function cannot be invoked with a single argument of type `const char*`.
    This function also requires a second, Boolean, argument. The first two methods,
    `error` and `warning`, define a default value for the second argument, so they
    can be invoked with calls such as `t.error("just")` and `warning("a")`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`log_error` 函数模板需要一个满足 `logger` 需求的类型参数。我们有两个类，称为 `console_logger` 和 `stream_logger`。第一个满足
    `logger` 需求，但第二个不满足。这是因为 `info` 函数不能使用单个 `const char*` 类型的参数调用。此函数还需要一个布尔类型的第二个参数。前两个方法
    `error` 和 `warning` 为第二个参数定义了一个默认值，因此它们可以用如 `t.error("just")` 和 `warning("a")`
    这样的调用执行。'
- en: 'However, because of the third member function, `stream_logger` is not a log
    class that meets the expected requirements and, therefore, cannot be used with
    the `log_error` function. The use of `console_logger` and `stream_logger` is exemplified
    in the following snippet:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于第三个成员函数，`stream_logger` 不是一个满足预期需求的日志类，因此不能与 `log_error` 函数一起使用。`console_logger`
    和 `stream_logger` 的使用在以下片段中得到了示例：
- en: '[PRE130]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: In the next section, we look at the second category of requirements, type requirements.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨需求类型的第二类，即类型需求。
- en: Type requirements
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型需求
- en: '`typename` followed by the name of a type. We have already seen several examples
    when we defined the `container` constraint. The name of the type must be valid
    for the requirement to be true. Type requirements can be used for several purposes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`typename` 后跟一个类型名称。我们已经在前面的 `container` 约束定义中看到了几个例子。类型名称必须有效，需求才为真。类型需求可用于多个目的：'
- en: To verify that a nested type exists (such as in `typename T::value_type;`)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了验证嵌套类型的存在（例如在 `typename T::value_type;` 中）
- en: To verify that a class template specialization names a type
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了验证类模板特化是否命名了一个类型
- en: To verify that an alias template specialization names a type
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了验证别名模板特化是否命名了一个类型
- en: 'Let’s see several examples to learn how to use type requirements. In the first
    example, we check whether a type contains the inner types, `key_type` and `value_type`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个例子，了解如何使用类型需求。在第一个例子中，我们检查一个类型是否包含内部类型 `key_type` 和 `value_type`：
- en: '[PRE134]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The type, `key_value_pair<int, std::string>`, satisfies these type requirements,
    but `std::pair<int, std::string>` does not. The `std::pair` type does have inner
    types, but they are called `first_type` and `second_type`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 类型，`key_value_pair<int, std::string>` 满足这些类型需求，但 `std::pair<int, std::string>`
    不满足。`std::pair` 类型确实有内部类型，但它们被称为 `first_type` 和 `second_type`。
- en: 'In the second example, we check whether a class template specialization names
    a type. The class template is `container`, and the specialization is `container<T>`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们检查类模板特化是否命名了一个类型。类模板是 `container`，特化是 `container<T>`：
- en: '[PRE150]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: In this snippet, `container` is a class template that can only be specialized
    for arithmetic types, such as `int`, `long`, `float`, or `double`. Therefore,
    specializations such as `container<int>` exist, but `container<std::string>` does
    not. The `containerizeable` concept specifies a requirement for a type `T` to
    define a valid specialization of `container`. Therefore, `containerizeable<int>`
    is true, but `containerizeable<std::string>` is false.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`container` 是一个只能针对算术类型（如 `int`、`long`、`float` 或 `double`）进行特化的类模板。因此，存在如
    `container<int>` 这样的特化，但不存在 `container<std::string>`。`containerizeable` 概念指定了对类型
    `T` 的要求，以定义一个有效的 `container` 特化。因此，`containerizeable<int>` 为真，但 `containerizeable<std::string>`
    为假。
- en: Now that we have understood simple requirements and type requirements it is
    time to explore the more complex category of requirements. The first to look at
    is compound requirements.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了简单的要求和类型要求，是时候探索更复杂的要求类别了。首先我们要看的是复合要求。
- en: Compound requirements
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合要求
- en: 'Simple requirements allow us to verify that an expression is valid. However,
    sometimes we need to verify some properties of an expression not just that it
    is valid. This can include whether an expression does not throw exceptions or
    requirements on the result type (such as the return type of a function). The general
    form is the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的要求使我们能够验证一个表达式是否有效。然而，有时我们需要验证一个表达式的某些属性，而不仅仅是它是否有效。这可以包括表达式是否不会抛出异常或对结果类型的要求（例如函数的返回类型）。一般形式如下：
- en: '[PRE160]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Both the `noexcept` specification and the `type_constraint` (with the leading
    `->`) are optional. The substitution process and the checking of the constraints
    occur as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept` 说明符和 `type_constraint`（带前导 `->`）都是可选的。替换过程和约束检查如下：'
- en: The template arguments are substituted in the expression.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板参数在表达式中被替换。
- en: If `noexcept` is specified, then the expression must not throw exceptions; otherwise,
    the requirement is false.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指定了 `noexcept`，则表达式不得抛出异常；否则，要求为假。
- en: If the type constraint is present, then the template arguments are also substituted
    into `type_contraint` and `decltype((expression))` must satisfy the conditions
    imposed by `type_constraint`; otherwise, the requirement is false.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在类型约束，则模板参数也被替换到 `type_contraint` 和 `decltype((expression))` 中，并且必须满足 `type_constraint`
    强加的条件；否则，要求为假。
- en: 'We will discuss a couple of examples to learn how to use compound requirements.
    In the first example, we check whether a function is marked with the `noexcept`
    specifier:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论几个示例，以了解如何使用复合要求。在第一个例子中，我们检查一个函数是否带有 `noexcept` 说明符：
- en: '[PRE161]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'In this snippet, there are two function templates: `f` is declared `noexcept`;
    therefore, it shall not throw any exception, and `g`, which potentially throws
    exceptions. The `NonThrowing` concept imposes the requirement that the variadic
    function of type `F` must not throw exceptions. Therefore, of the following two
    invocations, only the first is valid and the second will produce a compiler error:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，有两个函数模板：`f` 被声明为 `noexcept`；因此，它不应该抛出任何异常，而 `g` 可能会抛出异常。`NonThrowing`
    概念强制要求类型 `F` 的变异性函数不得抛出异常。因此，在以下两个调用中，只有第一个是有效的，第二个将产生编译器错误：
- en: '[PRE176]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The error messages generated by Clang are shown in the following listing:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 生成的错误信息如下所示：
- en: '[PRE178]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: These error messages tell us that the `invoke(g<int>, 42)` call is not valid
    because `g<int>` may throw an exception, which results in `NonThrowing<F, T…>`
    to evaluating as `false`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误信息告诉我们，`invoke(g<int>, 42)` 调用无效，因为 `g<int>` 可能会抛出异常，导致 `NonThrowing<F,
    T…>` 评估为 `false`。
- en: 'For the second example, we will define a concept that provides requirements
    for timer classes. Specifically, it requires that a function called `start` exists,
    that it can be invoked without any parameters, and that it returns `void`. It
    also requires that a second function called `stop` exists, that it can be invoked
    without any parameters, and that it returns a value that can be converted to `long
    long`. The concept is defined as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个例子，我们将定义一个概念，为计时器类提供要求。具体来说，它要求存在一个名为 `start` 的函数，它可以无参数调用，并且返回 `void`。它还要求存在一个名为
    `stop` 的第二个函数，它可以无参数调用，并且返回一个可以转换为 `long long` 的值。该概念定义如下：
- en: '[PRE179]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Notice that the type constraint cannot be any compile-time Boolean expression,
    but an actual type requirement. Therefore, we use other concepts for specifying
    the return type. Both `std::same_as` and `std::convertible_to` are concepts available
    in the standard library in the `<concepts>` header. We’ll learn more about these
    in the *Exploring the standard concepts library* section. Now, let’s consider
    the following classes that implement timers:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型约束不能是任何编译时布尔表达式，而是一个实际的类型要求。因此，我们使用其他概念来指定返回类型。`std::same_as` 和 `std::convertible_to`
    都是 `<concepts>` 头文件中标准库中可用的概念。我们将在 *探索标准概念库* 部分了解更多关于这些内容。现在，让我们考虑以下实现计时器的类：
- en: '[PRE185]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'In this example, `timerA` satisfies the timer concept because it contains the
    two required methods: `start` that returns `void` and `stop` that returns `long
    long`. Similarly, `timerB` also satisfies the timer concept because it features
    the same methods, even though `stop` returns an `int`. However, the `int` type
    is implicitly convertible to the `long long` type; therefore, the type requirement
    is met. Lastly, `timerC` also has the same methods, but both of them return `void`,
    which means the type requirement for the return type of `stop` is not met, and
    therefore, the constraints imposed by the `timer` concept are not satisfied.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`timerA` 满足计时器概念，因为它包含两个必需的方法：返回 `void` 的 `start` 和返回 `long long` 的 `stop`。同样，`timerB`
    也满足计时器概念，因为它具有相同的方法，尽管 `stop` 返回的是 `int`。然而，`int` 类型可以隐式转换为 `long long` 类型；因此，类型要求得到了满足。最后，`timerC`
    也具有相同的方法，但它们都返回 `void`，这意味着 `stop` 返回类型的要求没有得到满足，因此，计时器概念施加的约束没有得到满足。
- en: The last category of requirements left to look into is nested requirements.
    We will do this next.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的最后一种要求是嵌套要求。我们将在下一部分进行探讨。
- en: Nested requirements
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套要求
- en: 'The last category of requirements is nested requirements. A nested requirement
    is introduced with the `requires` keyword (remember we mentioned that a simple
    requirement is a requirement that is not introduced with the `requires` keyword)
    and has the following form:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种要求是嵌套要求。嵌套要求是通过 `requires` 关键字引入的（记住我们提到简单要求是不用 `requires` 关键字引入的要求），并且具有以下形式：
- en: '[PRE204]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: The expression must be satisfied by the substituted arguments. The substitution
    of the template arguments into `constraint-expression` is done only to check whether
    the expression is satisfied or not.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式必须由替换的参数满足。模板参数替换到 `constraint-expression` 中仅用于检查表达式是否满足。
- en: 'In the following example, we want to define a function that performs addition
    on a variable number of arguments. However, we want to impose some conditions:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们想要定义一个函数，该函数可以对可变数量的参数执行加法操作。然而，我们想要施加一些条件：
- en: There is more than one argument.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多个参数。
- en: All the arguments have the same type.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参数具有相同的类型。
- en: The expression `arg1 + arg2 + … + argn` is valid.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式 `arg1 + arg2 + … + argn` 是有效的。
- en: 'To ensure this, we define a concept called `HomogenousRange` as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这一点，我们定义了一个名为 `HomogenousRange` 的概念如下：
- en: '[PRE205]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: This concept contains one simple requirement and two nested requirements. One
    nested requirement uses the `are_same_v` variable template whose value is determined
    by the conjunction of one or more type traits (`std::is_same`), and the other,
    the compile-time Boolean expression `size…(T) > 1`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念包含一个简单要求和两个嵌套要求。一个嵌套要求使用 `are_same_v` 变量模板，其值由一个或多个类型特性（`std::is_same`）的合取确定，另一个是编译时布尔表达式
    `size…(T) > 1`。
- en: 'Using this concept, we can define the `add` variadic function template as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个概念，我们可以定义 `add` 可变参数函数模板如下：
- en: '[PRE215]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The first call exemplified previously is correct, as there are two arguments,
    and both are of type `int`. The second call produces an error because the types
    of the arguments are different (`int` and `double`). Similarly, the third call
    also produces an error because only one argument was supplied.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中演示的第一个调用是正确的，因为有两个参数，并且它们都是 `int` 类型。第二个调用产生了一个错误，因为参数的类型不同（`int` 和 `double`）。同样，第三个调用也产生了一个错误，因为只提供了一个参数。
- en: 'The `HomogenousRange` concept can also be tested with the help of several `static_assert`
    statements, as shown next:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`HomogenousRange` 概念也可以通过几个 `static_assert` 语句进行测试，如下所示：'
- en: '[PRE224]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: We have walked through all the categories of the requires expressions that can
    be used for defining constraints. However, constraints can also be composed, and
    this is what we will discuss next.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走过了所有可以用于定义约束的`requires`表达式的类别。然而，约束也可以组合，这正是我们将要讨论的。
- en: Composing constraints
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合约束
- en: We have seen multiple examples of constraining template arguments but in all
    the cases so far, we used a single constraint. It is possible though for constraints
    to be composed using the `&&` and `||` operators. A composition of two constraints
    using the `&&` operator is called a `||` operator is called a **disjunction**.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了多个约束模板参数的例子，但在所有这些情况下，我们只使用了一个约束。然而，使用`&&`和`||`运算符，约束可以组合。使用`&&`运算符组合两个约束称为**析取**。
- en: 'For a conjunction to be true, both constraints must be true. Like in the case
    of logical **AND** operations, the two constraints are evaluated from left to
    right, and if the left constraint is false, the right constraint is not evaluated.
    Let’s look at an example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个合取为真，两个约束都必须为真。就像逻辑**AND**操作的情况一样，两个约束从左到右进行评估，如果左边的约束是假的，则不会评估右边的约束。让我们看一个例子：
- en: '[PRE227]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'In this snippet, we have a function template that returns the decremented value
    of the received argument. However, it only accepts signed integral values. This
    is specified with the conjunction of two constraints, `std::is_integral_v<T> &&
    std::is_signed_v<T>`. The same result can be achieved using a different approach
    to defining the conjunction, as shown next:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们有一个返回接收到的参数递减值的函数模板。然而，它只接受有符号整数值。这是通过两个约束的合取来指定的，即`std::is_integral_v<T>
    && std::is_signed_v<T>`。同样，可以使用不同的方法来定义合取，如下所示：
- en: '[PRE233]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'You can see three concepts defined here: one that constrains integral types,
    one that constrains signed types, and one that constrains integral and signed
    types.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里定义了三个概念：一个约束整型类型，一个约束有符号类型，以及一个约束整型和有符号类型的。
- en: 'Disjunctions work in a similar way. For a disjunction to be true, at least
    one of the constraints must be true. If the left constraint is true, then the
    right one is not evaluated. Again, let’s see an example. If you recall the `add`
    function template from the first section of the chapter, we constrained it with
    the `std::is_arithmetic` type trait. However, we can get the same result using
    `std::is_integral` and `std::is_floating_point`, used as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 并非（disjunctions）以类似的方式工作。对于一个非约束为真，至少必须有一个约束为真。如果左边的约束为真，则不会评估右边的约束。再次，让我们看一个例子。如果你还记得本章第一节的`add`函数模板，我们用`std::is_arithmetic`类型特性对其进行了约束。然而，我们可以使用`std::is_integral`和`std::is_floating_point`来得到相同的结果，如下所示：
- en: '[PRE244]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'The expression `std::is_integral_v<T> || std::is_floating_point_v<T>` defines
    a disjunction of two atomic constraints. We will look at this kind of constraint
    in more detail later. For the time being, keep in mind that an atomic constraint
    is an expression of the `bool` type that cannot be decomposed into smaller parts.
    Similarly, to what we’ve done previously, we can also build a disjunction of concepts
    and use that. Here is how:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`std::is_integral_v<T> || std::is_floating_point_v<T>`定义了两个原子约束的非约束。我们将在稍后更详细地探讨这种约束。目前，请记住，原子约束是一个不能分解成更小部分的`bool`类型表达式。同样，就像我们之前所做的那样，我们也可以构建一个概念的非约束，并使用它。下面是如何做的：
- en: '[PRE250]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: As already mentioned, conjunctions and disjunctions are short-circuited. This
    has an important implication in checking the correctness of a program. Considering
    a conjunction of the form `A<T> && B<T>`, then `A<T>` is checked and evaluated
    first, and if it is false, the second constraint, `B<T>`, is not checked anymore.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，合取（conjunctions）和析取（disjunctions）是短路操作的。这在检查程序的正确性方面有重要的含义。考虑一个形式为`A<T>
    && B<T>`的合取，那么首先会检查和评估`A<T>`，如果它是假的，则不再检查第二个约束`B<T>`。
- en: 'Similarly, for the `A<T> || B<T>` disjunction, after `A<T>` is checked, if
    it evaluates to true, the second constraint, `B<T>`, will not be checked. If you
    want both conjunctions to be checked for well-formedness and then their Boolean
    value determined, then you must use the `&&` and `||` operators differently. A
    conjunction or disjunction is formed only when the `&&` and `||` tokens, respectively,
    appear nested in parentheses or as an operand of the `&&` or `||` tokens. Otherwise,
    these operators are treated as logical operators. Let’s explain this with examples:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于`A<T> || B<T>`析取，在检查`A<T>`之后，如果它评估为真，则不会检查第二个约束`B<T>`。如果你想要检查两个合取的有效性并确定它们的布尔值，那么你必须使用`&&`和`||`运算符的不同方式。合取或析取仅在`&&`和`||`符号分别嵌套在括号内或作为`&&`或`||`运算符的操作数时形成。否则，这些运算符被视为逻辑运算符。让我们用例子来解释这一点：
- en: '[PRE261]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'In all these examples, the `||` token defines a disjunction. However, when
    used inside a cast expression or a logical `&&` and `||` tokens define a logical
    expression:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些例子中，`||`符号定义了一个析取。然而，当它用于类型转换表达式或逻辑`&&`和`||`符号时，它们定义了一个逻辑表达式：
- en: '[PRE270]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: In these cases, the entire expression is first checked for correctness, and
    then its Boolean value is determined. It is worth mentioning that in this latter
    example both expressions, `!(A<T> || B<T>)` and `static_cast<bool>(A<T> || B<T>)`,
    need to be wrapped inside another set of parentheses because the expression of
    a requires clause cannot start with the `!` token or a cast.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，整个表达式首先检查其正确性，然后确定其布尔值。值得一提的是，在这个后一个例子中，两个表达式`!(A<T> || B<T>)`和`static_cast<bool>(A<T>
    || B<T>)`都需要被括号包围，因为`requires`子句的表达式不能以`!`符号或类型转换开始。
- en: 'Conjunctions and disjunctions cannot be used to constrain template parameter
    packs. However, there is a workaround to make it happen. Let’s consider a variadic
    implementation of the `add` function template with the requirement that all arguments
    must be integral types. One would attempt to write such a constraint in the following
    form:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 交集和并集不能用于约束模板参数包。然而，有一个解决方案可以实现这一点。让我们考虑一个具有所有参数都必须是整型要求的`add`函数模板的可变实现。人们会尝试以下形式来编写这样的约束：
- en: '[PRE276]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'This will generate a compiler error because the ellipsis is not allowed in
    this context. What we can do to avoid this error is to wrap the expression in
    a set of parentheses, as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成编译器错误，因为在这个上下文中不允许使用省略号。为了避免这个错误，我们可以将表达式括在括号中，如下所示：
- en: '[PRE282]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'The expression, `(std::is_integral_v<T> && ...)`, is now a fold expression.
    It is not a conjunction, as one would expect. Therefore, we get a single atomic
    constraint. The compiler will first check the correctness of the entire expression
    and then determine its Boolean value. To build a conjunction we first need to
    define a concept:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`(std::is_integral_v<T> && ...)`现在是一个折叠表达式。它不是一个合取，正如人们所期望的那样。因此，我们得到一个单一的原子约束。编译器将首先检查整个表达式的正确性，然后确定其布尔值。要构建一个合取，我们首先需要定义一个概念：
- en: '[PRE288]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'What we need to do next is change the requires clause so that it uses the newly
    defined concept and not the Boolean variable, `std::is_integral_v<T>`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的是更改`requires`子句，使其使用新定义的概念而不是布尔变量`std::is_integral_v<T>`：
- en: '[PRE290]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: It does not look like much of a change but, in fact, because of the use of concepts,
    validating the correctness and determining the Boolean value occur individually
    for each template argument. If the constraint is not met for a type, the rest
    is short-circuited, and the validation stops.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来变化不大，但实际上，由于使用了概念，验证正确性和确定布尔值对于每个模板参数都是单独发生的。如果某个类型的约束未满足，其余部分将短路，验证将停止。
- en: 'You must have noticed that earlier in this section I used the term *atomic
    constraint* twice. Therefore, one would ask, what is an atomic constraint? It
    is an expression of the `bool` type that cannot be decomposed further. Atomic
    constraints are formed during the process of constraint normalization when the
    compiler decomposes constraints into conjunction and disjunctions of atomic constraints.
    This works as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了在本节前面我两次使用了术语*原子约束*。因此，人们会问，什么是原子约束？它是一个不能进一步分解的`bool`类型表达式。原子约束是在约束归一化过程中形成的，当编译器将约束分解为原子约束的交集和并集时。这如下所示：
- en: The expression, `E1 && E2`, is decomposed into the conjunction of `E1` and `E2`.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式`E1 && E2`被分解为`E1`和`E2`的合取。
- en: The expression, `E1 || E2`, is decomposed into the disjunction of `E1` and `E2`.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式 `E1 || E2` 被分解为 `E1` 和 `E2` 的析取。
- en: The concept, `C<A1, A2, … An>`, is replaced with its definition after substituting
    all the template arguments into its atomic constraints.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念 `C<A1, A2, … An>` 在将所有模板参数替换到其原子约束中后，被替换为其定义。
- en: Atomic constraints are used for determining the partial ordering of constraints
    that, in turn, determine the partial ordering of function templates and class
    template specializations, as well as the next candidate for non-template functions
    in overload resolution. We will discuss this topic next.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 原子约束用于确定约束的部分排序，这反过来又确定了函数模板和类模板特化的部分排序，以及重载解析中非模板函数的下一个候选。我们将在下一节讨论这个主题。
- en: Learning about the ordering of templates with constraints
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解具有约束的模板的排序
- en: When a compiler encounters function calls or class template instantiations,
    it needs to figure out what overload (for a function) or specialization (for a
    class) is the best match. A function may be overloaded with different type constraints.
    Class templates can also be specialized with different type constraints. In order
    to decide which is the best match, the compiler needs to figure out which one
    is the most constrained and, at the same time, evaluates to `true` after substituting
    all the template parameters. In order to figure this out, it performs the **constraints
    normalization**. This is the process of transforming the constraint expression
    into conjunctions and disjunctions of atomic constraints, as described at the
    end of the previous section.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到函数调用或类模板实例化时，它需要确定哪个重载（对于函数）或特化（对于类）是最合适的。一个函数可能具有不同的类型约束。类模板也可以用不同的类型约束进行特化。为了决定哪个是最合适的，编译器需要确定哪个是最受约束的，并且在将所有模板参数替换后，同时评估为
    `true`。为了找出这一点，它执行 **约束规范化**。这是将约束表达式转换为原子约束的合取和析取的过程，如前一小节所述。
- en: An atomic constraint `A` is said to subsume another atomic constraint `B` if
    `A` implies `B`. A constraint declaration `D1` whose constraints subsume the constraints
    of another declaration `D2` is said to be at least as constrained as `D2`. Moreover,
    if `D1` is at least as constrained as `D2` but the reciprocal is not true, then
    it’s said that `D1` is more constrained than `D2`. More constrained overloads
    are selected as the best match.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个原子约束 `A` 意味着另一个原子约束 `B`，则称 `A` 为 `B` 的子集。如果一个约束声明 `D1` 的约束包含另一个声明 `D2` 的约束，则称
    `D1` 至少与 `D2` 一样受约束。此外，如果 `D1` 至少与 `D2` 一样受约束，但反之不成立，则称 `D1` 比 `D2` 更受约束。更受约束的重载被选为最佳匹配。
- en: 'We will discuss several examples in order to understand how constraints affect
    overload resolution. First, let’s start with the following two overloads:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过几个示例来讨论约束如何影响重载解析。首先，让我们从以下两个重载开始：
- en: '[PRE296]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: The first overload is a non-template function that takes two `int` arguments
    and returns their sum. The second is the template implementation we have seen
    already in the chapter.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载是一个非模板函数，它接受两个 `int` 参数并返回它们的和。第二个是我们在本章中已经看到的模板实现。
- en: 'Having these two, let’s consider the following calls:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 有这两个重载后，让我们考虑以下调用：
- en: '[PRE305]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: The first call (at line `[1]`) takes two `double` values so only the template
    overload is a match. Therefore, its instantiation for the `double` type will be
    called. The second invocation of the `add` function (at line `[2]`) takes two
    integer arguments. Both overloads are a possible match. The compiler will select
    the most specific one, which is the non-template overload.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用（在第 `[1]` 行）接受两个 `double` 类型的值，因此只有模板重载匹配。因此，将调用其 `double` 类型的实例化。第二次调用
    `add` 函数（在第 `[2]` 行）接受两个整数参数。两个重载都是可能的匹配。编译器将选择最具体的一个，即非模板重载。
- en: 'What if both overloads are templates but one of them is constrained? Here is
    an example to discuss:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个重载都是模板，但其中一个有约束，会怎样？以下是一个讨论的例子：
- en: '[PRE307]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: The first overload is the function template seen previously. The second has
    an identical implementation except that it specifies a requirement for the template
    argument, which is restricted to integral types. If we consider the same two calls
    from the previous snippet, for the call at line `[1]` with two `double` values,
    only the first overload is a good match. For the call at line `[2]` with two integer
    values, both overloads are a good match. However, the second overload is more
    constrained (it has one constraint compared to the first one that has no constraint)
    so the compiler will select this one for the invocation.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载是之前看到的函数模板。第二个重载与第一个具有相同的实现，只是它指定了对模板参数的要求，该参数限制为整型类型。如果我们考虑之前代码片段中的相同两个调用，对于第
    `[1]` 行的调用，使用两个 `double` 值，只有第一个重载是一个良好的匹配。对于第 `[2]` 行的调用，使用两个整数值，两个重载都是良好的匹配。然而，第二个重载更加受限（它有一个约束，而第一个没有约束），因此编译器将选择这个重载进行调用。
- en: 'In the next example, both overloads are constrained. The first overload requires
    that the size of the template argument is four, and the second overload requires
    that the template argument must be an integral type:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，两个重载都有约束。第一个重载要求模板参数的大小为四，第二个重载要求模板参数必须是整型类型：
- en: '[PRE318]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'Let’s consider the following calls to this overloaded function template:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑对这个重载函数模板的以下调用：
- en: '[PRE330]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: The call at line `[1]` uses arguments of the `short` type. This is an integral
    type with the size `2`; therefore, only the second overload is a match. However,
    the call at line `[2]` uses arguments of the `int` type. This is an integral type
    of size `4`. Therefore, both overloads are a good match. However, this is an ambiguous
    situation, and the compiler is not able to select between the two and it will
    trigger an error.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 第 `[1]` 行的调用使用 `short` 类型的参数。这是一个大小为 `2` 的整型类型；因此，只有第二个重载是匹配的。然而，第 `[2]` 行的调用使用
    `int` 类型的参数。这是一个大小为 `4` 的整型类型。因此，两个重载都是良好的匹配。然而，这是一个模糊的情况，编译器无法在这两个之间选择，并将触发一个错误。
- en: What happens, though, if we change the two overloads slightly, as shown in the
    next snippet?
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们稍微改变这两个重载，如下一个代码片段所示，会发生什么？
- en: '[PRE332]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: Both overloads require that the template argument must be an integral type,
    but the second also requires that the size of the integral type must be `4` bytes.
    So, for the second overload, we use a conjunction of two atomic constraints. We
    will discuss the same two calls, with `short` arguments and with `int` arguments.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 两个重载都要求模板参数必须是整型类型，但第二个还要求整型类型的大小必须是 `4` 字节。因此，对于第二个重载，我们使用两个原子约束的组合。我们将讨论相同的两个调用，一个使用
    `short` 参数，另一个使用 `int` 参数。
- en: 'For the call at line `[1]`, passing two `short` values, only the first overload
    is a good match, so this one will be invoked. For the call at line `[2]` that
    takes two `int` arguments, both overloads are a match. The second, however, is
    more constrained. Yet, the compiler is not able to decide which is a better match
    and will issue an ambiguous call error. This may be surprising to you because,
    in the beginning, I said that the most constrained overload will be selected from
    the overload set. It does not work in our example because we used type traits
    to constrain the two functions. The behavior is different if we instead use concepts.
    Here is how:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第 `[1]` 行的调用，传递两个 `short` 值，只有第一个重载是良好的匹配，因此将调用这个重载。对于第 `[2]` 行的调用，它接受两个 `int`
    参数，两个重载都是匹配的。然而，第二个重载更加受限。尽管如此，编译器无法决定哪个是更好的匹配，并将发出一个模糊调用错误。这可能让你感到惊讶，因为一开始我说最受限的重载将从重载集中被选中。在我们的例子中并不适用，因为我们使用了类型特性来约束这两个函数。如果我们使用概念而不是类型特性，行为会有所不同。下面是如何做的：
- en: '[PRE344]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'There is no ambiguity anymore; the compiler will select the second overload
    as the best match from the overload set. This demonstrates that concepts are handled
    preferentially by the compiler. Remember, there are different ways to use constraints
    using concepts, but the preceding definition simply replaced a type trait with
    a concept; therefore, they are arguably a better choice for demonstrating this
    behavior than the next implementation:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再存在歧义；编译器将从重载集中选择第二个重载作为最佳匹配。这表明概念在编译器中被优先处理。记住，使用概念有不同方式来使用约束，但前面的定义只是用一个概念替换了一个类型特性；因此，它们在演示这种行为方面可能是一个更好的选择：
- en: '[PRE358]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: All the examples discussed in this chapter involved constraining function templates.
    However, it’s possible to constrain non-template member functions as well as class
    templates and class template specializations. We will discuss these in the next
    sections, and we will start with the former.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的所有示例都涉及约束函数模板。然而，也可以约束非模板成员函数以及类模板和类模板特化。我们将在下一节讨论这些内容，并从前者开始。
- en: Constraining non-template member functions
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制非模板成员函数
- en: 'Non-template functions that are members of class templates can be constrained
    in a similar way to what we have seen so far. This enables template classes to
    define member functions only for types that satisfy some requirements. In the
    following example, the equality operator is constrained:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板的成员函数可以以与我们迄今为止看到的方式类似的方式进行约束。这使得模板类能够只为满足某些要求的类型定义成员函数。在以下示例中，相等运算符被约束：
- en: '[PRE369]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: 'The `wrapper` class holds a value of a `T` type and defines the `operator==`
    member only for types that are convertible to `std::string_view`. Let’s see how
    this can be used:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper`类持有`T`类型的值，并且只为可以转换为`std::string_view`的类型定义了`operator==`成员。让我们看看这是如何使用的：'
- en: '[PRE379]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: We have two instantiations of the `wrapper` class here, one for `int` and one
    for `char const*`. The attempt to compare the `a` object with the literal `42`
    generates a compiler error, because the `operator==` is not defined for this type.
    However, comparing the `b` object with the string literal `"42"` is possible because
    the equality operator is defined for types that can be implicitly converted to
    `std::string_view`, and `char const*` is such a type.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个`wrapper`类的实例化，一个用于`int`，一个用于`char const*`。尝试将`a`对象与字面量`42`进行比较会生成编译器错误，因为此类型没有定义`operator==`。然而，将`b`对象与字符串字面量`"42"`进行比较是可能的，因为对于可以隐式转换为`std::string_view`的类型，定义了相等运算符，而`char
    const*`就是这样的类型。
- en: 'Constraining non-template members is useful because it’s a cleaner solution
    than forcing members to be templates and using SFINAE. To understand this better
    let’s consider the following implementation of the `wrapper` class:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 限制非模板成员是有用的，因为它比强制成员成为模板并使用SFINAE的解决方案更干净。为了更好地理解这一点，让我们考虑以下`wrapper`类的实现：
- en: '[PRE383]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: 'This class template can be instantiated as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类模板可以如下实例化：
- en: '[PRE389]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: The first line compiles successfully, but the second generates a compiler error.
    There are different messages issued by different compilers, but at the core of
    the error is the call to the implicitly deleted copy constructor of `std::unique_ptr`.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行编译成功，但第二行生成编译器错误。不同的编译器会发出不同的消息，但错误的根本是调用隐式删除的`std::unique_ptr`的复制构造函数。
- en: 'What we want to do is restrict the copy construction of `wrapper` from objects
    of the `T` type so that it only works for `T` types that are copy-constructible.
    The approach available before C++20 was to transform the copy constructor into
    a template and employ SFINAE. This would look as follows:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是限制`wrapper`从`T`类型对象的复制构造，使其只对可复制的`T`类型有效。在C++20之前可用的方法是，将复制构造函数转换为模板并使用SFINAE。这看起来如下所示：
- en: '[PRE392]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: 'This time we also get an error when trying to initialize a `wrapper<std::unique_ptr<int>>`
    from an `std::unique_ptr<int>` value but the errors are different. For instance,
    here are the error messages generated by Clang:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们尝试从`std::unique_ptr<int>`值初始化`wrapper<std::unique_ptr<int>>`时，也会出现错误，但错误不同。例如，以下是Clang生成的错误信息：
- en: '[PRE402]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: 'The most important message to help understand the cause of the problem is the
    last one. It says that the requirement that `U` substituted with `std::unique_ptr<int>`
    does not satisfy the Boolean condition. In C++20, we can do a better job at implementing
    the same restriction on the `T` template argument. This time, we can use constraints
    and the copy constructor does not need to be a template anymore. The implementation
    in C++20 can look as follows:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助理解问题原因的最重要信息是最后一条。它指出，将`U`替换为`std::unique_ptr<int>`的要求不满足布尔条件。在C++20中，我们可以更好地对`T`模板参数实施相同的限制。这次，我们可以使用约束，并且复制构造函数不再需要是模板。C++20中的实现可以如下所示：
- en: '[PRE414]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: 'Not only there is less code that does not require complicated SFINAE machinery,
    but it is simpler and easier to understand. It also generates potentially better
    error messages. In the case of Clang, the last note listed earlier is replaced
    with the following:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅代码量更少，不需要复杂的SFINAE机制，而且它更简单，更容易理解。它还可能生成更好的错误信息。在Clang的情况下，前面列出的最后一个注意事项被以下内容所取代：
- en: '[PRE423]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'Before closing this section, it’s worth mentioning that not only non-template
    functions that are members of classes can be constrained but also free functions.
    The use cases for non-template functions are rare and can be achieved with alternative
    simple solutions such as constexpr if. Let’s look at an example, though:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭这一节之前，值得提一下，不仅类成员的非模板函数可以被约束，自由函数也可以。非模板函数的使用场景很少，可以使用如constexpr if之类的简单替代解决方案来实现。尽管如此，让我们来看一个例子：
- en: '[PRE428]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: 'In this snippet, we have two overloads of the `handle` function. The first
    overload takes an `int` value and the second a `long` value. The body of these
    overloaded functions is not important but they should do different things, if
    and only if the size of `long` is different from the size of `int`. The standard
    specifies that the size of `int` is at least 16 bits, although on most platforms
    it is 32 bits. The size of `long` is at least 32 bits. However, there are platforms,
    such as `int` is 32 bits and `long` is 64 bits. On these platforms, both overloads
    should be available. On all the other platforms, where the two types have the
    same size, only the first overload should be available. This can be defined in
    the form shown earlier, although the same can be achieved in C++17 with constexpr
    if as follows:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`handle`函数有两个重载版本。第一个重载接受一个`int`类型的值，第二个接受一个`long`类型的值。这些重载函数的函数体并不重要，但它们应该执行不同的操作，仅当`long`的大小与`int`的大小不同时。标准规定`int`的大小至少为16位，尽管在大多数平台上它是32位。`long`的大小至少为32位。然而，有些平台，如`int`是32位而`long`是64位。在这些平台上，两个重载都应该可用。在所有其他平台上，如果两种类型的大小相同，则只有第一个重载应该可用。这可以按照前面所示的形式定义，尽管在C++17中可以使用constexpr
    if以以下方式实现：
- en: '[PRE433]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: In the next section, we’ll learn how to use constraints to define restrictions
    on template arguments of class templates.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用约束来定义类模板的模板参数的限制。
- en: Constraining class templates
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束类模板
- en: 'Class templates and class template specializations can also be constrained
    just like function templates. To start, we’ll consider the `wrapper` class template
    again, but this time with the requirement that it should only work for template
    arguments of integral types. This can be simply specified in C++20 as follows:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板和类模板特化也可以像函数模板一样被约束。首先，我们将再次考虑`wrapper`类模板，但这次要求它只能针对整型模板参数工作。这可以在C++20中简单地按照以下方式指定：
- en: '[PRE444]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: Instantiating the template for the `int` type is fine but does not work for
    `double` because this is not an integral type.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化`int`类型的模板是可以的，但对于`double`类型则不行，因为这不是一个整型。
- en: 'Requirements that also be specified with requires clauses and class template
    specializations can also be constrained. To demonstrate this, let’s consider the
    scenario when we want to specialize the `wrapper` class template but only for
    types whose size is `4` bytes. This can be implemented as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用requires子句和类模板特化来指定的要求也可以被约束。为了演示这一点，让我们考虑这样一个场景：当我们想要特化`wrapper`类模板，但仅针对大小为`4`字节的类型时。这可以按照以下方式实现：
- en: '[PRE451]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: 'We can use this class template as shown in the following snippet:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码片段中的这个类模板：
- en: '[PRE472]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: The object `a` is an instance of `wrapper<short>`; therefore, the primary template
    is used. On the other hand, the object `b` is an instance of `wrapper<int>`. Since
    `int` has a size of 4 bytes (on most platforms) the specialization is used and
    we can access the individual types of the wrapped value through the `byte1`, `byte2`,
    `byte3`, and `byte4` members.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`a`是`wrapper<short>`的实例；因此，使用的是主模板。另一方面，对象`b`是`wrapper<int>`的实例。由于`int`的大小为4字节（在大多数平台上），使用的是特化，我们可以通过`byte1`、`byte2`、`byte3`和`byte4`成员访问包装值的各个类型。
- en: Lastly on this topic, we will discuss how variable templates and template aliases
    can also be constrained.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于这个话题，我们将讨论变量模板和模板别名也可以被约束的情况。
- en: Constraining variable templates and template aliases
  id: totrans-656
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束变量模板和模板别名
- en: As you well know, apart from function templates and class templates we also
    have variable templates and alias templates in C++. These make no exception of
    the need to define constraints. The same rules for constraining the template arguments
    discussed so far apply to these two. In this section, we will demonstrate them
    shortly. Let’s start with variable templates.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，除了函数模板和类模板之外，C++中还有变量模板和别名模板。它们也不例外，需要定义约束。到目前为止讨论的模板参数约束规则同样适用于这两个。在本节中，我们将简要演示它们。让我们从变量模板开始。
- en: 'It is a typical example to define the `PI` constant for showing how variable
    templates work. Indeed, it is a simple definition that looks as follows:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的例子，用于定义`PI`常量，以展示变量模板是如何工作的。实际上，这是一个看起来如下所示的定义：
- en: '[PRE480]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: 'However, this only makes sense for floating-point types (and maybe other types
    such as `decimal`, which does not exist in C++ yet). Therefore, this definition
    should be restricted to floating-point types, as follows:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅对浮点类型（以及可能的其他类型，如尚不存在于C++中的`decimal`）有意义。因此，这个定义应该限制为浮点类型，如下所示：
- en: '[PRE482]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: The use of `PI<double>` is correct but `PI<int>` produces a compiler error.
    This is what constraints can provide in a simple and readable manner.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PI<double>`是正确的，但`PI<int>`会产生编译错误。这就是约束可以以简单和可读的方式提供的内容。
- en: 'Finally, the last category of templates that we have in the language, alias
    templates, can also be constrained. In the following snippet, we can see such
    an example:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们语言中最后一种模板类别，别名模板，也可以被约束。在下面的代码片段中，我们可以看到一个这样的例子：
- en: '[PRE486]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: 'The `integral_vector` template is an alias for `std::vector<T>` when `T` is
    an integral type. The very same can be achieved with the following alternative,
    although longer, declaration:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 当`T`是整型时，`integral_vector`模板是`std::vector<T>`的一个别名。同样的效果可以通过以下更长一些的声明来实现：
- en: '[PRE488]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: 'We can use this `integral_vector` alias template as follows:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用这个`integral_vector`别名模板：
- en: '[PRE491]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: Defining the `v1` object works fine since `int` is an integral type. However,
    defining the `v2` vector generates a compiler error because `double` is not an
    integral type.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`v1`对象没有问题，因为`int`是整型。然而，定义`v2`向量会产生编译错误，因为`double`不是整型。
- en: 'If you paid attention to the examples in this section, you will have noticed
    that they don’t use the type traits (and the associated variable templates) we
    used previously in the chapter, but a couple of concepts: `std::integral` and
    `std::floating_point`. These are defined in the `<concepts>` header and help us
    avoid repeatedly defining the same concepts based on available C++11 (or newer)
    type traits. We will look at the content of the standard concepts library shortly.
    Before we do that, let’s see what other ways we can employ to define constraints
    in C++20.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了本节中的示例，你会注意到它们没有使用我们在本章之前使用的类型特性（以及相关的变量模板），而是使用了几个概念：`std::integral`和`std::floating_point`。这些定义在`<concepts>`头文件中，并帮助我们避免重复定义基于可用的C++11（或更新的）类型特性。我们将在稍后查看标准概念库的内容。在我们这样做之前，让我们看看我们还可以用其他什么方法在C++20中定义约束。
- en: Learning more ways to specify constraints
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习更多指定约束的方法
- en: 'We have discussed in this chapter about requires clauses and requires expressions.
    Although both are introduced with the new `requires` keyword, they are different
    things and should be fully understood:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经讨论了requires子句和requires表达式。尽管两者都是通过新的`requires`关键字引入的，但它们是不同的事物，应该被完全理解：
- en: A *requires clause* determines whether a function participates in overload resolution
    or not. This happens based on the value of a compile-time Boolean expression.
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *requires子句* 决定一个函数是否参与重载解析。这是基于编译时布尔表达式的值来发生的。
- en: A *requires expression* determines whether a set of one or more expressions
    is well-formed, without having any side effects on the behavior of the program.
    A requires expression is a Boolean expression that can be used with a requires
    clause.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *requires表达式* 决定一组一个或多个表达式是否良好形成，而不会对程序的行为产生任何副作用。一个requires表达式是一个布尔表达式，它可以与requires子句一起使用。
- en: 'Let’s see an example again:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看一个例子：
- en: '[PRE493]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: The construct at line `[1]` that starts with the `requires` keyword is a requires
    expression. It verifies that the expression, `a + b`, is well-formed for any `T`.
    On the other hand, the construct at line `[2]` is a requires clause. If the Boolean
    expression `addable<T>` evaluates to `true`, the function takes part in overload
    resolution; otherwise, it does not.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 行 `[1]` 上以`requires`关键字开始的构造是一个要求表达式。它验证表达式`a + b`对于任何`T`都是良好形成的。另一方面，行 `[2]`
    上的构造是一个要求子句。如果布尔表达式`addable<T>`评估为`true`，则函数参与重载解析；否则，它不参与。
- en: 'Although requires clauses are supposed to use concepts, a requires expression
    can also be used. Basically, anything that can be placed on the right-hand side
    of the `=` token in a concept definition can be used with a requires clause. That
    means we can do the following:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然要求子句应该使用概念，但也可以使用要求表达式。基本上，任何可以放在概念定义中`=`符号右侧的内容都可以与要求子句一起使用。这意味着我们可以做以下操作：
- en: '[PRE502]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: Although this is perfectly legal code it is arguable whether it’s a good way
    of using constraints. I would recommend avoiding creating constructs that start
    with `requires requires`. They are less readable and may create confusion. Moreover,
    named concepts can be used anywhere, while a requires clause with a requires expression
    will have to be duplicated if it needs to be used for multiple functions.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是完全合法的代码，但关于它是否是使用约束的好方法存在争议。我建议避免创建以`requires requires`开头的构造。它们可读性较差，可能造成混淆。此外，命名概念可以在任何地方使用，而带有要求表达式的需求子句如果需要用于多个函数，则必须重复。
- en: Now that we’ve seen how to constrain template arguments in several ways using
    constraints and concepts, let’s see how we can simplify function template syntax
    and constrain the template arguments.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何使用约束和概念以多种方式约束模板参数，让我们看看我们如何简化函数模板语法并约束模板参数。
- en: Using concepts to constrain auto parameters
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用概念约束`auto`参数
- en: 'In [*Chapter 2*](B18367_02_ePub.xhtml#_idTextAnchor024), *Template Fundamentals*,
    we discussed generic lambdas, introduced in C++14, as well as lambda templates,
    introduced in C++20\. A lambda that uses the `auto` specifier for at least one
    parameter is called a **generic lambda**. The function object generated by the
    compiler will have a templated call operator. Here is an example to refresh your
    memory:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第2章*](B18367_02_ePub.xhtml#_idTextAnchor024) *模板基础* 中，我们讨论了C++14中引入的泛型lambda以及C++20中引入的lambda模板。至少有一个参数使用`auto`指定符的lambda称为**泛型lambda**。编译器生成的函数对象将具有模板调用操作符。以下是一个示例以刷新您的记忆：
- en: '[PRE508]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'The C++20 standard generalizes this feature for all functions. You can use
    the `auto` specifier in the function parameter list. This has the effect of transforming
    the function into a template function. Here is an example:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: C++20标准将此功能推广到所有函数。您可以在函数参数列表中使用`auto`指定符。这会将函数转换为模板函数。以下是一个示例：
- en: '[PRE509]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: 'This is a function that takes two parameters and returns their sum (or to be
    more precise, the result of applying `operator+` on the two values). Such a function
    using `auto` for function parameters is called an **abbreviated function template**.
    It is basically shorthand syntax for a function template. The equivalent template
    for the previous function is the following:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受两个参数并返回它们的和（或者更准确地说，是应用`operator+`于两个值的结果）的函数。使用`auto`作为函数参数的这种函数称为**缩写函数模板**。它基本上是函数模板的简写语法。前一个函数的等效模板如下：
- en: '[PRE513]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: 'We can call this function as we would call any template function, and the compiler
    will generate the proper instantiations by substituting the template arguments
    with the actual types. For instance, let’s consider the following calls:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像调用任何模板函数一样调用这个函数，编译器将通过用实际类型替换模板参数来生成适当的实例化。例如，让我们考虑以下调用：
- en: '[PRE518]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: 'We can use the [cppinsights.io](http://cppinsights.io) website to check the
    compiler-generated code for the `add` abbreviated function template based on these
    two calls. The following specializations are generated:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [cppinsights.io](http://cppinsights.io) 网站来检查基于这两个调用的`add`缩写函数模板生成的编译器代码。以下是一些特化：
- en: '[PRE520]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: 'Since an abbreviated function template is nothing but a regular function template
    with a simplified syntax, such a function can be explicitly specialized by the
    user. Here is an example:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缩写函数模板实际上只是一个具有简化语法的常规函数模板，因此用户可以显式特化这样的函数。以下是一个示例：
- en: '[PRE530]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: This is a full specialization for the `char const*` type. This specialization
    enables us to make calls such as `add("4", "2")`, although the result is a `std::string`
    value.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`char const*`类型的完全特化。这种特化使我们能够进行如`add("4", "2")`这样的调用，尽管结果是`std::string`类型。
- en: 'This category of abbreviated function templates is called `add` function constrained
    for integral types:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写函数模板的类别被称为`add`函数，其参数类型受限为整型：
- en: '[PRE535]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: 'If we consider again the same calls we saw earlier, the first would be successful,
    but the second would produce a compiler error because there is no overload that
    takes a `double` and an `int` value:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次考虑之前看到的相同调用，第一个调用将成功，但第二个调用将产生编译器错误，因为没有重载可以接受`double`和`int`类型的值：
- en: '[PRE539]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: 'Constrained `auto` can also be used for variadic abbreviated function templates.
    An example is shown in the following snippet:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 受限的`auto`也可以用于变长简写函数模板。以下是一个示例片段：
- en: '[PRE541]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: 'Last but not least, constrained `auto` can be used with generic lambdas too.
    If we would like the generic lambda shown at the beginning of this section to
    be used only with integral types, then we can constrain it as follows:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，受限的`auto`也可以与泛型lambda一起使用。如果我们希望本节开头显示的泛型lambda仅用于整型类型，那么我们可以将其约束如下：
- en: '[PRE545]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: With the closing of this section, we have seen all the language features related
    to concepts and constraints in C++20\. What is left to discuss is the set of concepts
    provided by the standard library, of which we have seen a couple already. We will
    do this next.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本节的结束，我们已经看到了C++20中与概念和约束相关的所有语言特性。接下来要讨论的是标准库提供的一组概念，其中我们已经看到了一些。我们将在下一节中这样做。
- en: Exploring the standard concepts library
  id: totrans-757
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索标准概念库
- en: The standard library provides a set of fundamental concepts that can be used
    to define requirements on the template arguments of function templates, class
    templates, variable templates, and alias templates, as we have seen throughout
    this chapter. The standard concepts in C++20 are spread across several headers
    and namespaces. We will present some of them in this section although not all
    of them. You can find all of them online at [https://en.cppreference.com/](https://en.cppreference.com/).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一组基本概念，可以用来定义对函数模板、类模板、变量模板和别名模板的模板参数的要求，正如我们在本章中看到的。C++20的标准概念分布在几个头文件和命名空间中。虽然不是全部，但我们将在本节中介绍其中的一些。您可以在网上找到所有这些概念，地址为[https://en.cppreference.com/](https://en.cppreference.com/)。
- en: 'The main set of concepts is available in the `<concepts>` header and the `std`
    namespace. Most of these concepts are equivalent to one or more existing type
    traits. For some of them, their implementation is well-defined; for some, it is
    unspecified. They are grouped into four categories: core language concepts, comparison
    concepts, object concepts, and callable concepts. This set of concepts contains
    the following (but not only):'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的概念集可以在`<concepts>`头文件和`std`命名空间中找到。其中大部分概念与一个或多个现有的类型特性等价。对于其中一些，它们的实现是明确定义的；对于一些，它是未指定的。它们被分为四个类别：核心语言概念、比较概念、对象概念和可调用概念。这个概念集包含以下内容（但不仅限于此）：
- en: '![Table 6.1'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18367_06_Table2.1.jpg)'
- en: '](img/B18367_06_Table1.1.jpg)'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18367_06_Table1.1.jpg)'
- en: '![Table 6.1'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18367_06_Table1.1.jpg)'
- en: '](img/B18367_06_Table1.2.png)'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18367_06_Table1.2.png)'
- en: Table 6.1
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1
- en: 'Some of these concepts are defined using type traits, some are a combination
    of other concepts or concepts and type traits, and some have, at least partially,
    an unspecified implementation. Here are some examples:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些概念是通过类型特性定义的，一些是其他概念或概念与类型特性的组合，还有一些至少部分地具有未指定的实现。以下是一些示例：
- en: '[PRE549]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: 'C++20 also introduces a new system of iterators, based on concepts, and defines
    a set of concepts in the `<iterator>` header. Some of these concepts are listed
    in the following table:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: C++20还引入了一种基于概念的新迭代器系统，并在`<iterator>`头文件中定义了一组概念。以下表格中列出了其中一些：
- en: '![Table 6.2'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18367_06_Table2.2.jpg)'
- en: '](img/B18367_06_Table2.1.jpg)![Table 6.2'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18367_06_Table2.1.jpg)![表6.2'
- en: '](img/B18367_06_Table2.2.jpg)'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18367_06_Table2.2.jpg)'
- en: Table 6.2
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2
- en: 'Here is how the `random_access_iterator` concept is defined in the C++ standard:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C++标准中对`random_access_iterator`概念的定义：
- en: '[PRE557]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: As you can see, it uses several concepts (some of them not listed here) as well
    as a requires expression to ensure that some expressions are well-formed.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它使用了几个概念（其中一些未在此列出）以及一个requires表达式来确保某些表达式是良好形成的。
- en: 'Also, in the `<iterator>` header, there is a set of concepts designed to simplify
    the constraining of general-purpose algorithms. Some of these concepts are listed
    in the next table:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `<iterator>` 头文件中，有一组旨在简化通用算法约束的概念。其中一些概念在下一表中列出：
- en: '![Table 6.3'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.3'
- en: '](img/B18367_06_Table3.jpg)'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18367_06_Table3.jpg)'
- en: Table 6.3
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3
- en: 'One of the several major features included in C++20 (along with concepts, modules,
    and coroutines) are ranges. The `ranges` library defines a series of classes and
    functions for simplifying operations with ranges. Among these is a set of concepts.
    These are defined in the `<ranges>` header and the `std::ranges` namespace. Some
    of these concepts are listed as follows:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 包含的几个主要特性之一（包括概念、模块和协程）是范围。`ranges` 库定义了一系列类和函数，用于简化范围操作。其中之一是一组概念。这些概念在
    `<ranges>` 头文件和 `std::ranges` 命名空间中定义。以下列出了一些这些概念：
- en: '![Table 6.4'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.4'
- en: '](img/B18367_06_Table4.1.jpg)![Table 6.4'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18367_06_Table4.1.jpg)![表 6.4'
- en: '](img/B18367_06_Table4.2.jpg)'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18367_06_Table4.2.jpg)'
- en: Table 6.4
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4
- en: 'Here is how some of these concepts are defined:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何定义这些概念的一些例子：
- en: '[PRE575]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: As mentioned already, there are more concepts than those listed here. Others
    will probably be added in the future. This section is not intended as a complete
    reference to the standard concepts but rather as an introduction to them. You
    can learn more about each of these concepts from the official C++ reference documentation
    available at [https://en.cppreference.com/](https://en.cppreference.com/). As
    for ranges, we will learn more about them and explore what the standard library
    provides in [*Chapter 8*](B18367_08_ePub.xhtml#_idTextAnchor179), *Ranges and
    Algorithms*.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这里列出的概念比这些还要多。未来可能会添加更多。本节的目的不是作为标准概念的完整参考，而是作为对这些概念的介绍。您可以从官方 C++ 参考文档中了解更多关于这些概念的信息，该文档可在
    [https://en.cppreference.com/](https://en.cppreference.com/) 找到。至于范围，我们将在 [*第
    8 章*](B18367_08_ePub.xhtml#_idTextAnchor179) *范围和算法* 中了解更多关于它们的信息，并探索标准库提供的功能。
- en: Summary
  id: totrans-823
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The C++20 standard introduced some new major features to the language and the
    standard library. One of these is concepts, which was the topic of this chapter.
    A concept is a named constraint that can be used to define requirements on template
    arguments for function templates, class templates, variable templates, and alias
    templates.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 标准为语言和标准库引入了一些新的主要功能。其中之一是概念，这是本章的主题。概念是一个命名约束，可以用来定义函数模板、类模板、变量模板和别名模板的模板参数的要求。
- en: In this chapter, we have explored in detail how we can use constraints and concepts
    and how they work. We have learned about requires clauses (that determine whether
    a template participates in overload resolution) and requires expressions (that
    specify requirements for well-formedness of expressions). We have seen what various
    syntaxes are for specifying constraints. We also learned about abbreviated function
    templates that provide a simplified syntax for function templates. At the end
    of the chapter, we explored the fundamental concepts available in the standard
    library.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了如何使用约束和概念以及它们的工作原理。我们学习了 requires 子句（确定模板是否参与重载解析）和 requires 表达式（指定表达式良好形式的条件）。我们还看到了指定约束的各种语法。我们还学习了提供函数模板简化语法的简化函数模板。在本章末尾，我们探讨了标准库中可用的基本概念。
- en: In the next chapter, we will shift our attention toward applying the knowledge
    accumulated so far to implement various template-based patterns and idioms.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向如何将到目前为止积累的知识应用于实现各种基于模板的模式和惯用法。
- en: Questions
  id: totrans-827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are constraints and what are concepts?
  id: totrans-828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 约束和概念是什么？
- en: What are a requires clause and a requires expression?
  id: totrans-829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: requires 子句和 requires 表达式是什么？
- en: What are the categories of requires expressions?
  id: totrans-830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: requires 表达式的类别有哪些？
- en: How do constraints affect the ordering of templates in overload resolution?
  id: totrans-831
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 约束如何影响重载解析中模板的排序？
- en: What are abbreviated function templates?
  id: totrans-832
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化函数模板是什么？
- en: Further reading
  id: totrans-833
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*C++20 Concepts - A Quick Introduction*, Bartlomiej Filipek, [https://www.cppstories.com/2021/concepts-intro/](https://www.cppstories.com/2021/concepts-intro/)'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++20 Concepts - A Quick Introduction*，Bartlomiej Filipek，[https://www.cppstories.com/2021/concepts-intro/](https://www.cppstories.com/2021/concepts-intro/)'
- en: '*How C++20 Concepts can simplify your code*, Andreas Fertig, [https://andreasfertig.blog/2020/07/how-cpp20-concepts-can-simplify-your-code/](https://andreasfertig.blog/2020/07/how-cpp20-concepts-can-simplify-your-code/)'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++20概念如何简化你的代码*，安德烈亚斯·费蒂格，[https://andreasfertig.blog/2020/07/how-cpp20-concepts-can-simplify-your-code/](https://andreasfertig.blog/2020/07/how-cpp20-concepts-can-simplify-your-code/)'
- en: '*What are C++20 concepts and constraints? How to use them?*, Sorush Khajepor,
    [https://iamsorush.com/posts/concepts-cpp/](https://iamsorush.com/posts/concepts-cpp/)'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++20概念和约束是什么？如何使用它们？*，索鲁什·卡杰波尔，[https://iamsorush.com/posts/concepts-cpp/](https://iamsorush.com/posts/concepts-cpp/)'
- en: '*Requires-clause*, Andrzej Krzemieński, [https://akrzemi1.wordpress.com/2020/03/26/requires-clause/](https://akrzemi1.wordpress.com/2020/03/26/requires-clause/)'
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*requires子句*，安德烈·克日梅尼斯基，[https://akrzemi1.wordpress.com/2020/03/26/requires-clause/](https://akrzemi1.wordpress.com/2020/03/26/requires-clause/)'
- en: '*Ordering by constraints*, Andrzej Krzemieński, [https://akrzemi1.wordpress.com/2020/05/07/ordering-by-constraints/](https://akrzemi1.wordpress.com/2020/05/07/ordering-by-constraints/)'
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*按约束排序*，安德烈·克日梅尼斯基，[https://akrzemi1.wordpress.com/2020/05/07/ordering-by-constraints/](https://akrzemi1.wordpress.com/2020/05/07/ordering-by-constraints/)'
