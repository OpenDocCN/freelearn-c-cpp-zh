- en: '*Chapter 15*: Testing Classes and Components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：测试类和组件'
- en: This chapter will continue our pursuit for increasing your C++ programming repertoire
    beyond OOP concepts through exploring means to test the classes and components
    that comprise our OO programs. We will explore various strategies to help ensure
    that the code we write will be well-tested and robust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续探索如何通过探索测试组成我们面向对象程序的类和组件的方法，来增加您的C++编程技能库。我们将探索各种策略，以确保我们编写的代码经过充分测试并且健壮。
- en: This chapter shows how to test your OO programs through testing individual classes,
    as well as testing the various components that work together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示如何通过测试单个类以及测试一起工作的各种组件来测试您的面向对象程序。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding canonical class form; creating robust classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解规范类形式；创建健壮的类
- en: Creating drivers to test classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建驱动程序来测试类
- en: Testing classes related by inheritance, association, or aggregation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试通过继承、关联或聚合相关的类
- en: Testing exception handling mechanisms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试异常处理机制
- en: By the end of this chapter, you will have various techniques in your programming
    arsenal to ensure that your code is well-tested before it goes into production.
    Having the skills to consistently produce robust code will help you become a more
    beneficial programmer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将掌握各种技术，确保您的代码在投入生产之前经过充分测试。具备持续产生健壮代码的技能将帮助您成为更有益的程序员。
- en: Let's increase our C++ skills set by examining various techniques for OO testing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究各种面向对象测试技术来增强我们的C++技能。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The online code for the full program examples can be found at the following
    GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter15` in a file named `Chp15-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15)。每个完整程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名对应于章节号，后跟破折号，再跟随该章节中的示例编号。例如，本章的第一个完整程序可以在名为`Chp15-Ex1.cpp`的文件中的`Chapter15`子目录中找到上述GitHub目录下。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/314TI8h](https://bit.ly/314TI8h).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/314TI8h](https://bit.ly/314TI8h)。
- en: Contemplating OO testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考面向对象测试
- en: Software testing is immensely important prior to any code deployment. Testing
    object-oriented software will require different techniques than other types of
    software. Because OO software contains relationships between classes, we must
    understand how to test dependencies and relationships that may exist between classes.
    Additionally, each object may progress through different states based upon the
    order that operations are applied to each instance, as well as through specific
    interactions with related objects (for example, via association). The overall
    flow of control through an OO application is much more complex than with procedural
    applications because the combinations and order of operations applied to a given
    object and influences from associated objects are numerous.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署任何代码之前，软件测试非常重要。测试面向对象的软件将需要不同于其他类型软件的技术。因为面向对象的软件包含类之间的关系，我们必须了解如何测试可能存在的类之间的依赖关系和关系。此外，每个对象可能会根据对每个实例应用操作的顺序以及与相关对象的特定交互而进入不同的状态（例如，通过关联）。与过程性应用程序相比，面向对象应用程序的整体控制流程要复杂得多，因为应用于给定对象的操作的组合和顺序以及相关对象的影响是多种多样的。
- en: Nonetheless, there are metrics and processes we can apply to test OO software.
    These range from understanding idioms and patterns we can apply for class specification,
    to creating drivers to test classes both independently and as they relate to other
    classes. These processes can further include creating scenarios to provide likely
    sequences of events or states that objects may progress through. Relationships
    between objects, such as inheritance, association, and aggregation, become very
    important in testing; related objects can influence the state of an existing object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以应用指标和流程来测试面向对象的软件。这些范围从理解我们可以应用于类规范的习语和模式，到创建驱动程序来独立测试类以及它们与其他类的关系。这些流程还可以包括创建场景，以提供对象可能经历的事件或状态的可能序列。对象之间的关系，如继承、关联和聚合，在测试中变得非常重要；相关对象可以影响现有对象的状态。
- en: Let's begin our quest in testing OO software by understanding a simple pattern
    that we can often apply to classes we develop. This idiom will ensure that a class
    is potentially complete, with no unexpected behavior. We will start with canonical
    class form.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解我们经常可以应用于开发的类的简单模式开始，来开始我们在测试面向对象软件中的探索。这种习语将确保一个类可能是完整的，没有意外的行为。我们将从规范类形式开始。
- en: Understanding canonical class form
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解规范类形式
- en: For many classes in C++, it is reasonable to follow a pattern for class specification
    to ensure that a new class contains a full set of desired components. **Canonical
    class form** is a robust specification of a class that enables class instances
    to provide uniform behavior (analogous to standard data types) in areas such as
    initialization, assignment, argument passing, and usage in return values from
    functions. Canonical class form will apply to most classes that are either intended
    for instantiation or that will serve as public base classes for new derived classes.
    Classes that are intended to serve as private or protected base classes (even
    if they may be instantiated themselves) may not follow all parts of this idiom.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++中的许多类来说，遵循类规范的模式是合理的，以确保新类包含所需的全部组件。规范类形式是一个强大的类规范，使得类实例能够在初始化、赋值、参数传递和从函数返回值的使用等方面提供统一的行为（类似于标准数据类型）。规范类形式将适用于大多数既用于实例化的类，又用于作为新派生类的公共基类的类。打算作为私有或受保护基类的类（即使它们可能被实例化）可能不遵循这种习惯的所有部分。
- en: 'A class following **orthodox** canonical form will include:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循正统规范形式的类将包括：
- en: A default constructor
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个默认构造函数
- en: A copy constructor
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复制构造函数
- en: An overloaded assignment operator
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个过载的赋值运算符
- en: A virtual destructor
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚析构函数
- en: 'A class following **extended** canonical form will additionally include:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循扩展规范形式的类还将包括：
- en: A *move* copy constructor
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“移动”复制构造函数
- en: A *move* assignment operator
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“移动”赋值运算符
- en: Let's look at each component of canonical class form in the next subsections.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的子节中看看规范类形式的每个组件。
- en: Default constructor
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: A **default constructor** is necessary for simple instantiation. Though a default
    (empty) constructor will be provided if a class contains no constructors, it is
    important to recall that a default constructor will not be provided if a class
    contains constructors with other signatures. It is best to provide a default constructor
    with reasonable, basic initialization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简单实例化需要一个默认构造函数。虽然如果一个类不包含构造函数，将会提供一个默认（空）构造函数，但重要的是要记住，如果一个类包含其他签名的构造函数，将不会提供默认构造函数。最好提供一个合理的基本初始化的默认构造函数。
- en: Additionally, a default constructor for a given class' base class will be called
    in the absence of an alternate base class constructor specification in the member
    initialization list. If a base class has no such default constructor (and one
    hasn't been provided because a constructor with another signature exists), the
    implicit call to the base class constructor will be flagged as an error.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在成员初始化列表中没有指定替代基类构造函数的情况下，将调用给定类的基类的默认构造函数。如果基类没有这样的默认构造函数（并且没有提供另一个签名的构造函数），则对基类构造函数的隐式调用将被标记为错误。
- en: Let's also consider multiple inheritance situations in which a diamond-shaped
    hierarchy occurs, and virtual base classes are used to eliminate duplication of
    most base class sub-objects within instances of the most derived class. In this
    scenario, the default constructor for the now *shared* base class sub-object is
    called unless otherwise specified in the member initialization list of the derived
    class responsible for creating the diamond shape. This occurs even if non-default
    constructors are specified in the member initialization list at the middle level;
    remember these specifications are ignored when the mid-levels specify a potentially
    shared virtual base class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还考虑多重继承情况，其中出现了菱形继承结构，并且使用虚基类来消除最派生类实例中大多数基类子对象的重复。在这种情况下，除非在负责创建菱形形状的派生类的成员初始化列表中另有规定，否则现在*共享*基类子对象的默认构造函数将被调用。即使在中间级别指定了非默认构造函数，当中间级别指定了一个可能共享的虚基类时，这些规定也会被忽略。
- en: Copy constructor
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制构造函数
- en: A **copy constructor** is crucial for all objects containing pointer data members.
    Unless a copy constructor is supplied by the programmer, a system-supplied copy
    constructor will be linked in when necessary in the application. The system-supplied
    copy constructor performs a member-wise (shallow) copy of all data members. This
    means that multiple instances of a class may contain pointers to *shared* pieces
    of memory representing the data that should have been individualized. Also, remember
    to use the member initialization list in a derived class copy constructor to specify
    the base class' copy constructor to copy the base class data members. Certainly,
    copying the base class sub-object in a deep fashion is crucial; additionally,
    the base class data members are inevitably private so selecting the base class
    copy constructor in the derived class' member initialization list is very important.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含指针数据成员的所有对象来说，复制构造函数是至关重要的。除非程序员提供了复制构造函数，否则系统将在应用程序中必要时链接系统提供的复制构造函数。系统提供的复制构造函数执行所有数据成员的成员逐一（浅层）复制。这意味着一个类的多个实例可能包含指向共享内存块的指针，这些内存块代表应该是个体化的数据。此外，记得在派生类的复制构造函数中使用成员初始化列表来指定基类的复制构造函数以复制基类的数据成员。当然，在深度方式中复制基类子对象是至关重要的；此外，基类数据成员不可避免地是私有的，因此在派生类的成员初始化列表中选择基类复制构造函数非常重要。
- en: By specifying a copy constructor, we also help provide an expected manner for
    the creation of objects passed (or returned) by value from a function. Ensuring
    deep copies in these scenarios is crucial. The user may think these copies are
    *by value*, yet if their pointer data members are actually shared with the source
    instance, it's not truly passing (or returning) an object by value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定一个复制构造函数，我们还帮助提供了一个对象通过值从函数传递（或返回）的预期方式。在这些情况下确保深层复制是至关重要的。用户可能认为这些复制是“通过值”，但如果它们的指针数据成员实际上与源实例共享，那么它实际上并不是通过值传递（或返回）对象。
- en: Overloaded assignment operator
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过载的赋值运算符
- en: An **overloaded assignment operator**, much like the copy constructor, is also
    crucial for all objects containing pointer data members. The default behavior
    for the system-supplied assignment operator is a shallow assignment of data from
    source to destination object. Again, when data members are pointers, it is highly
    recommended that the assignment operator should be overloaded to allocate space
    for any such pointer data members.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**重载的赋值运算符**，就像复制构造函数一样，对于所有包含指针数据成员的对象也是至关重要的。系统提供的赋值运算符的默认行为是从源对象到目标对象的浅赋值。同样，当数据成员是指针时，强烈建议重载赋值运算符以为任何这样的指针数据成员分配空间。
- en: Also, remember that an overloaded assignment operator is not *inherited*; each
    class is responsible for writing its own version. This makes sense, as the derived
    class inevitably has more data members to copy than the assignment operator in
    its base class. However, when overloading an assignment operator in a derived
    class, remember to call the base class' assignment operator to perform a deep
    assignment of inherited base class members (which may be private and otherwise
    inaccessible).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请记住，重载的赋值运算符不会*继承*；每个类都负责编写自己的版本。这是有道理的，因为派生类不可避免地有更多的数据成员需要复制，而其基类中的赋值运算符则可能是私有的或无法访问的。然而，在派生类中重载赋值运算符时，请记住调用基类的赋值运算符来执行继承的基类成员的深度赋值（这些成员可能是私有的或无法访问的）。
- en: Virtual destructor
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚析构函数
- en: A **virtual destructor** is required when using public inheritance. Often, derived
    class instances are collected in a group and generalized by a set of base class
    pointers. Recall, upcasting in this fashion is only possible to public base classes
    (not to protected or private base classes). When pointers to objects are generalized
    in this fashion, a virtual destructor is crucial to allow the correct starting
    point in the destructor sequence to be determined through dynamic (that is, runtime)
    binding versus static binding. Recall, static binding would choose the starting
    destructor based on the pointer's type, not what type the object actually is.
    A good rule of thumb is if a class has one or more virtual functions, be sure
    to ensure that you also have a virtual destructor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虚析构函数在使用公共继承时是必需的。通常，派生类实例被收集在一组中，并由一组基类指针进行泛化。请记住，以这种方式进行向上转型只可能对公共基类进行（而不是对受保护或私有基类）。当以这种方式对对象的指针进行泛化时，虚析构函数对于通过动态（即运行时）绑定确定正确的析构函数起始点至关重要，而不是静态绑定。请记住，静态绑定会根据指针的类型选择起始析构函数，而不是对象实际的类型。一个很好的经验法则是，如果一个类有一个或多个虚函数，请确保你也有一个虚析构函数。
- en: Move copy constructor
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动复制构造函数
- en: A `this`. We then must null the source object's pointers to those data members
    so that both instances do not *share* the dynamically allocated data members.
    We have, in essence, moved (the memory for) the pointer data members.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`this`。然后我们必须将源对象的指针置空，以便这两个实例不共享动态分配的数据成员。实质上，我们已经移动了（内存中的）指针数据成员。
- en: What about the non-pointer data members? The memory for these data members will
    be copied as usual. The memory for the non-pointer data members and the memory
    for the pointers themselves (not the memory pointed to by those pointers) still
    resides in the source instance. As such, the best we can do is designate a null
    value for the source object's pointers and place a `0` (or similar) value in the
    non-pointer data members to indicate that these members are no longer relevant.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么非指针数据成员呢？这些数据成员的内存将像往常一样被复制。非指针数据成员的内存和指针本身的内存（而不是指针指向的内存）仍然驻留在源实例中。因此，我们能做的最好的事情就是为源对象的指针指定一个空值，并在非指针数据成员中放置一个`0`（或类似的）值，以指示这些成员不再相关。
- en: 'We will use the `move()` function, found in the C++ Standard Library, to indicate
    a move copy constructor as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用C++标准库中的`move()`函数来指示移动复制构造函数如下：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Additionally, with classes related by inheritance, we will also use `move()`
    in the member initialization list of the derived class constructor. This will
    specify the base class move copy constructor to help initialize the sub-object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于通过继承相关的类，我们还将在派生类构造函数的成员初始化列表中使用`move()`。这将指定基类移动复制构造函数来帮助初始化子对象。
- en: Move assignment operator
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动赋值运算符
- en: A **move assignment operator** is much like an overloaded assignment operator,
    however, the goal is to again conserve memory by *moving* the dynamically allocated
    data of the source object to the destination object (versus performing a deep
    assignment). As with the overloaded assignment operator, we will test for self-assignment
    and then delete any previously dynamically allocated data members from the (pre-existing)
    destination object. However, we will then simply copy the pointer data members
    from the source object to those in the destination object. We will also null out
    the pointers in the source object so that the two instances do not share these
    dynamically allocated data members.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动赋值运算符**与重载的赋值运算符非常相似，但其目标是再次通过*移动*源对象的动态分配数据来节省内存（而不是执行深度赋值）。与重载的赋值运算符一样，我们将测试自我赋值，然后从（已存在的）目标对象中删除任何先前动态分配的数据成员。然后，我们将简单地将源对象中的指针数据成员复制到目标对象中的指针数据成员。我们还将将源对象中的指针置空，以便这两个实例不共享这些动态分配的数据成员。'
- en: Also, much like the move copy constructor, non-pointer data members will be
    simply copied from source to destination object and replaced with a `0` value
    in the source object to indicate non-usage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像移动复制构造函数一样，非指针数据成员将简单地从源对象复制到目标对象，并在源对象中用`0`值替换以指示不使用。
- en: 'We will again use the `move()` function as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`move()`函数如下：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Additionally, with classes related by inheritance, we can again specify that
    the move assignment operator of the derived class will call the base class move
    assignment operator to help complete the task.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于通过继承相关的类，我们可以再次指定派生类的移动赋值运算符将调用基类的移动赋值运算符来帮助完成任务。
- en: Bringing the components of canonical class form together
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将规范类形式的组件结合在一起
- en: 'Let''s see an example of a pair of classes that embrace canonical class form.
    We will start with our `Person` class. This example can be found as a complete
    program in our GitHub:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个采用规范类形式的一对类的例子。我们将从我们的`Person`类开始。这个例子可以在我们的GitHub上找到一个完整的程序：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex1.cpp)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex1.cpp)'
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous class definition, we notice that `Person` contains a default
    constructor, copy constructor, overloaded assignment operator, and virtual destructor.
    Here, we have embraced orthodox canonical class form as a pattern applicable for
    a class that might one day serve as a public base class. Also notice that we have
    added the prototypes for the move copy constructor and move assignment operator
    to additionally embrace the extended canonical class form.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的类定义中，我们注意到`Person`包含默认构造函数、复制构造函数、重载赋值运算符和虚析构函数。在这里，我们已经采用了正统的规范类形式作为一个模式，适用于可能有一天作为公共基类的类。还要注意，我们已经添加了移动复制构造函数和移动赋值运算符的原型，以进一步采用扩展的规范类形式。
- en: The prototypes of the move copy constructor `Person(Person &&);` and the move
    assignment operator `Person &operator=(Person &&);` contain parameters of type
    `Person &&`. These are examples of `Person &`, will bind to the original copy
    constructor and overloaded assignment operator, whereas r-value reference parameters
    will bind to the applicable move methods instead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 移动复制构造函数`Person(Person &&);`和移动赋值运算符`Person &operator=(Person &&);`的原型包含类型为`Person
    &&`的参数。这些是`Person &`的例子，将绑定到原始复制构造函数和重载赋值运算符，而r值引用参数将绑定到适用的移动方法。
- en: 'Let''s now look at the definitions for the methods contributing to the extended
    canonical class form – the move copy constructor and the move assignment operator
    for `Person`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下有助于`Person`扩展规范类形式的方法定义 - 移动复制构造函数和移动赋值运算符：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice, in the preceding move copy constructor, we overtake the source object's
    dynamically allocated memory by using simple pointer assignments (versus memory
    allocation such as we would employ in a deep copy constructor). We then place
    a null value in the source object's pointer data members. For non-pointer data
    members, we simply copy the values from source to destination object and place
    a zeroed value (such as `'\0'` for `p.middleInitial`) in the source object to
    indicate its further non-use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的移动复制构造函数中，我们通过简单的指针赋值（而不是内存分配，如我们在深复制构造函数中所使用的）接管源对象的动态分配内存。然后我们在源对象的指针数据成员中放置一个空值。对于非指针数据成员，我们只是将值从源对象复制到目标对象，并在源对象中放置一个零值（例如`p.middleInitial`的`'\0'`）以表示其进一步的非使用。
- en: In the move assignment operator, we check for self-assignment and then employ
    the same scheme to merely move the dynamically allocated memory from the source
    object to the destination object with a simple pointer assignment. We copy simple
    data members as well, and of course replace source object data values with either
    null pointers or zeroed values to indicate further non-use. The return value of
    `*this` allows for cascaded assignments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动赋值运算符中，我们检查自我赋值，然后采用相同的方案，仅仅通过简单的指针赋值将动态分配的内存从源对象移动到目标对象。我们也复制简单的数据成员，并且当然用空指针或零值替换源对象数据值，以表示进一步的非使用。`*this`的返回值允许级联赋值。
- en: 'Now, let''s see how a derived class, `Student`, employs both orthodox and extended
    canonical class form while utilizing its base class components to aid in the implementation
    of selected idiom methods:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看派生类`Student`如何在利用其基类组件来辅助实现选定的成语方法时，同时使用正统和扩展的规范类形式：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding class definition, we again see that `Student` contains a default
    constructor, a copy constructor, an overloaded assignment operator, and a virtual
    destructor to complete the orthodox canonical class form.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的类定义中，我们再次看到`Student`包含默认构造函数、复制构造函数、重载赋值运算符和虚析构函数，以完成正统的规范类形式。
- en: Notice, however, in the `Student` copy constructor, we specify the use of the
    `Person` copy constructor through the member initialization list. Similarly, in
    the `Student` overloaded assignment operator, once we check for self-assignment,
    we call the overloaded assignment operator in `Person` to help us complete the
    task using `Person::operator=(s);`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在`Student`复制构造函数中，我们通过成员初始化列表指定了`Person`复制构造函数的使用。同样，在`Student`重载赋值运算符中，一旦我们检查自我赋值，我们调用`Person`中的重载赋值运算符来帮助我们使用`Person::operator=(s);`完成任务。
- en: 'Let''s now look at the method definitions contributing to the extended canonical
    class form of `Student` – the move copy constructor and the move assignment operator:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下有助于`Student`扩展规范类形式的方法定义 - 移动复制构造函数和移动赋值运算符：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice, in the previously listed `Student` move copy constructor, we specify
    utilization of the base class move copy constructor in the member initialization
    list. The remainder of the `Student` move copy constructor is similar to that
    found in the `Person` base class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在先前列出的`Student`移动复制构造函数中，我们在成员初始化列表中指定了基类的移动复制构造函数的使用。`Student`移动复制构造函数的其余部分与`Person`基类中的类似。
- en: Likewise, let's notice, in the `Student` move assignment operator, the call
    to the base class move `operator=` with `Person::operator=(move(s);`. The remainder
    of this method is similar to that found in the base class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们注意，在`Student`移动赋值运算符中，调用基类的移动`operator=`与`Person::operator=(move(s);`。这个方法的其余部分与基类中的类似。
- en: A good rule of thumb is that most non-trivial classes should minimally utilize
    orthodox canonical class form. Of course, there are exceptions. For example, a
    class that will only serve as a protected or private base class need not have
    a virtual destructor because derived class instances cannot be upcast past a non-public
    inheritance boundary. Similarly, if we have a good reason to not want copies or
    to disallow assignment, we can prohibit copies or assignment using the `= delete`
    specification in the extended signature of either of these methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是，大多数非平凡的类应该至少使用正统的规范类形式。当然，也有例外。例如，一个只用作受保护或私有基类的类不需要具有虚析构函数，因为派生类实例不能通过非公共继承边界向上转型。同样，如果我们有充分的理由不希望复制或禁止赋值，我们可以在这些方法的扩展签名中使用`=
    delete`规范来禁止复制或赋值。
- en: Nonetheless, canonical class form will add robustness to classes that embrace
    this idiom. The uniformity among classes utilizing this idiom with respect to
    their implementation of initialization, assignment, and argument passing will
    be valued by programmers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，规范类形式将为采用这种习惯的类增加健壮性。采用这种习惯的类在初始化、赋值和参数传递方面的统一性将受到程序员的重视。
- en: Let's move forward to take a look at a complementary idea to canonical class
    form, that of robustness.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续来看看与规范类形式相辅相成的一个概念，即健壮性。
- en: Ensuring a class is robust
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保类是健壮的
- en: An important feature of C++ is the ability to build libraries of classes for
    widespread reuse. Whether we wish to achieve this goal, or simply wish to provide
    reliable code for our own organization's use, it is important that our code is
    robust. A **robust class** will be well-tested, should follow canonical class
    form (except for requiring a virtual destructor in protected and private base
    classes), and be portable (or included in a platform-specific library). Any class
    that is a candidate for reuse, or that is to be used in any professional capacity,
    absolutely must be robust.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++的一个重要特性是能够构建用于广泛重用的类库。无论我们希望实现这个目标，还是只是希望为我们自己组织的使用提供可靠的代码，重要的是我们的代码是健壮的。一个健壮的类将经过充分测试，应该遵循规范的类形式（除了在受保护和私有基类中需要虚析构函数），并且是可移植的（或包含在特定平台的库中）。任何候选重用的类，或者将在任何专业环境中使用的类，绝对必须是健壮的。
- en: A robust class must ensure that all instances of a given class are fully constructed.
    A **fully constructed object** is one in which all data members are appropriately
    initialized. All constructors for a given class (including copy constructors)
    must be verified to initialize all data members. The values with which data members
    are loaded should be checked for range suitability. Remember, an un-initialized
    data member is a potential disaster! Precautions should be made in the event that
    a given constructor does not complete properly or if the initial values of data
    members are inappropriate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 健壮的类必须确保给定类的所有实例都完全构造。**完全构造的对象**是指所有数据成员都得到适当初始化的对象。必须验证给定类的所有构造函数（包括复制构造函数）以初始化所有数据成员。应检查加载数据成员的值是否适合范围。记住，未初始化的数据成员是潜在的灾难！应该在给定构造函数未能正确完成或数据成员的初始值不合适的情况下采取预防措施。
- en: Fully constructed objects may be validated using a variety of techniques. A
    rudimentary technique is to embed a status data member into each class (or derive
    or embed a status ancestor/member). Set the status member to `0` in the member
    initialization list and to `1` as the last line of the constructor. Probe this
    value after instantiation. The huge downfall of this approach is that users will
    certainly forget to probe the *fully constructed* success flag.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用各种技术来验证完全构造的对象。一种基本的技术是在每个类中嵌入一个状态数据成员（或派生或嵌入一个状态祖先/成员）。在成员初始化列表中将状态成员设置为`0`，并在构造函数的最后一行将其设置为`1`。在实例化后探测这个值。这种方法的巨大缺陷是用户肯定会忘记探测*完全构造*的成功标志。
- en: A much better technique is to utilize exception handling. Embedding exception
    handling inside each constructor is ideal. If data members are not initialized
    within a suitable range, first try to re-enter their values, or open an alternate
    database for input, for example. As a last resort, you can throw an exception
    to report the *not fully constructed object*. We will more closely examine exception
    handling with respect to testing later in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的技术是利用异常处理。在每个构造函数内嵌异常处理是理想的。如果数据成员未在合适范围内初始化，首先尝试重新输入它们的值，或者例如打开备用数据库进行输入。作为最后手段，您可以抛出异常来报告*未完全构造的对象*。我们将在本章后面更仔细地研究关于测试的异常处理。
- en: Meanwhile, let us move forward with a technique to rigorously test our classes
    and components – creating drivers to test classes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们继续使用一种技术来严格测试我们的类和组件——创建驱动程序来测试类。
- en: Creating drivers to test classes
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建驱动程序来测试类
- en: In [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199), *Exploring
    Classes in Detail*, we briefly talked about breaking our code into source and
    header files. Let us briefly recap. Typically, the header file will be named after
    the class (such as `Student.h`) and will contain the class definition, plus any
    inline member function definitions. By placing inline functions in a header file,
    they will be properly re-expanded should their implementations change (as the
    header is subsequently included in each source file, creating a dependency with
    that header).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199)中，*详细探讨类*，我们简要讨论了将代码分解为源文件和头文件的方法。让我们简要回顾一下。通常，头文件将以类的名称命名（如`Student.h`），并包含类定义，以及任何内联成员函数定义。通过将内联函数放在头文件中，它们将在其实现更改时被正确地重新扩展（因为头文件随后包含在每个源文件中，与该头文件创建了依赖关系）。
- en: The implementation for the methods of each class will be placed in a corresponding
    source code file (such as `Student.cpp`), which will include the header on which
    it is based (that is, `#include "Student.h"`). Note that the double quotes imply
    that this header is in our current working directory; we could also specify a
    path as to where to find the header. By comparison, the angle brackets used with
    C++ libraries tell the preprocessor to look in pre-designated directories by the
    compiler. Also, note that each derived class header file will include the header
    file for its base class (so that it may see member function prototypes).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类的方法实现将被放置在相应的源代码文件中（比如`Student.cpp`），它将包括它所基于的头文件（即`#include "Student.h"`）。请注意，双引号意味着这个头文件在我们当前的工作目录中；我们也可以指定一个路径来找到头文件。相比之下，C++库使用的尖括号告诉预处理器在编译器预先指定的目录中查找。另外，请注意，每个派生类的头文件将包括其基类的头文件（以便它可以看到成员函数的原型）。
- en: With this header and source code file structure in mind, we can now create a
    driver to test each individual class or each grouping of closely related classes
    (such as those related through association or aggregation). Classes related through
    inheritance can be tested in their own, individual driver files. Each driver file
    can be named to reflect the class that is being tested, such as `StudentDriver.cpp`.
    The driver file will include the relevant header files for the class(es) being
    tested. Of course, the source files from the classes in question would be compiled
    and linked to the driver file as part of the compilation process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种头文件和源代码文件结构，我们现在可以创建一个驱动程序来测试每个单独的类或每组紧密相关的类（例如通过关联或聚合相关的类）。通过继承相关的类可以在它们自己的单独的驱动程序文件中进行测试。每个驱动程序文件可以被命名为反映正在测试的类的名称，比如`StudentDriver.cpp`。驱动程序文件将包括正在测试的类的相关头文件。当然，所涉及类的源文件将作为编译过程的一部分被编译和链接到驱动程序文件中。
- en: The driver file can simply contain a `main()` function as a testbed to instantiate
    the class(es) in question and serve as a scope to test each member function. The
    driver will test default instantiation, typical instantiation, copy construction,
    assignment between objects, and each of the additional methods in the class(es).
    Should virtual destructors or other virtual functions exist, we should instantiate
    derived class instances (in the derived class' driver), upcasting these instances
    to be stored using base class pointers, and then invoke the virtual functions
    to verify that the correct behaviors occur. In the case of a virtual destructor,
    we can trace which destructor is the entry point in the destruction sequence by
    deleting a dynamically allocated instance (or waiting for a stack instance to
    go out of scope) and single-stepping through our debugger to verify all is as
    expected.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序文件可以简单地包含一个`main()`函数，作为一个测试平台来实例化相关的类，并作为测试每个成员函数的范围。驱动程序将测试默认实例化、典型实例化、复制构造、对象之间的赋值，以及类中的每个附加方法。如果存在虚析构函数或其他虚函数，我们应该实例化派生类实例（在派生类的驱动程序中），将这些实例向上转型为基类指针进行存储，然后调用虚函数以验证发生了正确的行为。在虚析构函数的情况下，我们可以通过删除动态分配的实例（或等待栈实例超出范围）并通过调试器逐步验证一切是否符合预期来跟踪销毁顺序的入口点。
- en: We can also test that objects are fully constructed; we will see more on this
    topic shortly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试对象是否完全构造；我们很快将在这个主题上看到更多。
- en: 'Assuming we have our usual `Person` and `Student` class hierarchy, here is
    a simple driver to test the `Student` class. This driver can be found in our GitHub
    repository. To make a complete program, you will also need to compile and link
    together the `Student.cpp` and `Person.cpp` files found in this same directory.
    Here is the GitHub URL for the driver:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有我们通常的`Person`和`Student`类层次结构，这里有一个简单的驱动程序来测试`Student`类。这个驱动程序可以在我们的GitHub存储库中找到。为了创建一个完整的程序，您还需要编译和链接在同一目录中找到的`Student.cpp`和`Person.cpp`文件。这是驱动程序的GitHub
    URL：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex2.cpp)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter15/Chp15-Ex2.cpp)'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Briefly reviewing the preceding program fragment, we can see that we have tested
    each means for instantiation, including the copy constructor. We've also tested
    the assignment operator, verified each member function works (an example method
    is shown), and verified that the virtual functions (including virtual destructor)
    work as intended.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 简要回顾前面的程序片段，我们可以看到我们已经测试了每种实例化方式，包括复制构造函数。我们还测试了赋值运算符，验证了每个成员函数的工作（示例方法显示了），并验证了虚函数（包括虚析构函数）按预期工作。
- en: Now that we have seen a basic driver test our classes, let's consider some additional
    metrics we can use when testing classes related via inheritance, association,
    or aggregation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了一个基本的驱动程序测试我们的类，让我们考虑一些额外的指标，当测试通过继承、关联或聚合相关的类时可以使用。
- en: Testing related classes
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试相关类
- en: With OO programs, it is not sufficient to simply test an individual class for
    completeness and robustness, though these are good starting points. Completeness
    entails not only following canonical class form but also ensuring that data members
    have a safe means for access using appropriate access methods (labeled as `const`
    when not modifying the instance). Completeness also verifies that the required
    interface as specified by the OO design has been implemented.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向对象的程序，仅仅测试单个类的完整性和健壮性是不够的，尽管这些是很好的起点。完整性不仅包括遵循规范的类形式，还包括确保数据成员具有安全的访问方式，使用适当的访问方法（在不修改实例时标记为`const`）。完整性还验证了按照面向对象设计规范实现了所需的接口。
- en: Robustness leads us to verify that all of the aforementioned methods had been
    tested within an appropriate driver, evaluated for platform independence, and
    verified that each means for instantiation leads to a fully constructed object.
    We can augment this type of testing with threshold testing of data members for
    instances, noting when exceptions are thrown. Completeness and robustness, though
    seemingly comprehensive, are actually the most straightforward means for OO component
    testing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 健壮性要求我们验证所有上述方法是否在适当的驱动程序中进行了测试，评估其平台独立性，并验证每种实例化方式是否导致完全构造的对象。我们可以通过对实例的数据成员进行阈值测试来增强这种类型的测试，注意当抛出异常时。完整性和健壮性，尽管看似全面，实际上是OO组件测试最直接的手段。
- en: A more challenging means for testing is to test the interaction between related
    classes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 测试相关类之间交互的一种更具挑战性的手段是测试聚合和关联之间的交互。
- en: Testing classes related through inheritance, association, or aggregation
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过继承、关联或聚合相关的类进行测试
- en: Classes related through various object relationships require various additional
    means for component testing. Objects with various relationships with one another
    can impact the state progression a given instance may have during its life expectancy
    within the application. This type of testing will require the most detailed effort.
    We will find that scenarios will be useful to help us capture the usual interactions
    between related objects, leading to more comprehensive ways to test classes that
    interact with one another.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过各种对象关系相关的类需要各种额外的组件测试手段。具有各种关系的对象之间的相互影响可能会影响应用程序中给定实例的生命周期内的状态变化。这种类型的测试将需要最详细的努力。我们会发现场景对于帮助我们捕捉相关对象之间的常规交互是有用的，从而导致更全面的测试相互交互的类的方式。
- en: Let's begin by considering how we can test classes related by inheritance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑如何测试通过继承相关的类。
- en: Adding strategies to test inheritance
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加测试继承的策略
- en: Classes related through public inheritance need to have virtual functions verified.
    For example, have all intended derived class methods been overridden? Remember,
    a derived class does not need to override all virtual functions specified in its
    base class if base class behaviors are still deemed appropriate at the derived
    class level. It will be necessary to compare the implementation to the design
    to ensure that we have overridden all required polymorphic operations with suitable
    methods.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过公共继承相关的类需要验证虚函数。例如，所有预期的派生类方法是否已被覆盖？记住，如果基类行为在派生类级别仍然被认为是适当的，那么派生类不需要覆盖其基类中指定的所有虚函数。将需要将实现与设计进行比较，以确保我们已经用适当的方法覆盖了所有必需的多态操作。
- en: Certainly, the binding of virtual functions is done at runtime (that is, dynamic
    binding). It will be important to create derived class instances and store them
    using base class pointers so that the polymorphic operations can be applied. We
    then need to verify that the derived class behavior shines through. If not, perhaps
    we may find ourselves in an un-intended function hiding situation, or perhaps
    the base class operation wasn't marked virtual as intended (keeping in mind that
    the keywords virtual and override at the derived class level, though nice and
    recommended, are optional and do not affect the dynamic behavior).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，虚函数的绑定是在运行时完成的（即动态绑定）。重要的是创建派生类实例并使用基类指针存储它们，以便可以应用多态操作。然后我们需要验证派生类的行为是否突出。如果没有，也许我们会发现自己处于一个意外的函数隐藏情况，或者基类操作没有像预期的那样标记为虚拟（请记住，虚拟和覆盖关键字在派生类级别，虽然很好并且推荐，但是是可选的，不会影响动态行为）。
- en: Though classes related through inheritance have unique testing strategies, remember
    that instantiation will create a single object, that is, of a base class or of
    a derived class type. When we instantiate one such type, we have one such instance
    – not a pair of instances working together. A derived class merely has a base
    class sub-object, which is part of itself. Let's consider how this compares with
    associated objects or aggregates, which can be separate objects (association),
    potentially interacting with their companions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过继承相关的类具有独特的测试策略，但要记住实例化将创建一个单一对象，即基类或派生类类型的对象。当我们实例化这样的类型时，我们有一个实例，而不是一对共同工作的实例。派生类仅具有基类子对象，该子对象是其自身的一部分。让我们考虑一下这与关联对象或聚合物的比较，它们可以是单独的对象（关联），可能与其伴侣进行交互。
- en: Adding strategies to test aggregation and association
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加测试聚合和关联的策略
- en: Classes related through association or aggregation may be multiple instances
    communicating with one another, and causing state changes with one another. This
    is certainly more complex than the object relationship of inheritance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关联或聚合相关的类可能是多个实例之间的通信，并且彼此引起状态变化。这显然比继承的对象关系更复杂。
- en: Classes related via aggregation are generally easier to test than those related
    via association. Thinking of the most common form of aggregation (composition),
    the embedded (inner) object is part of the outer (whole) object. When the outer
    object is instantiated, we get the memory for the inner object embedded within
    the "*whole*." The memory layout is not tremendously different (other than the
    potential ordering) when compared to the memory layout of a derived class instance,
    which contains a base class sub-object. In each case, we are still dealing with
    a single instance (even though it has embedded *parts*). The point of comparison
    with testing, however, is that operations applied to the *whole* are often delegated
    to the *parts* or components. We will rigorously need to test the operations,
    on the whole, to ensure that they delegate necessary information to each of the
    parts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过聚合相关的类通常比通过关联相关的类更容易测试。考虑到最常见的聚合形式（组合），内嵌（内部）对象是外部（整体）对象的一部分。当实例化外部对象时，我们得到内部对象嵌入在“整体”中的内存。与包含基类子对象的派生类实例的内存布局相比，内存布局并没有非常不同（除了可能的排序）。在每种情况下，我们仍然处理单个实例（即使它有嵌入的“部分”）。然而，与测试进行比较的重点是，应用于“整体”的操作通常被委托给“部分”或组件。我们将严格需要测试整体上的操作，以确保它们将必要的信息委托给每个部分。
- en: Classes related via the lesser-used form of a general aggregation (where the
    whole contains pointers to the parts versus the typical embedded object implementation
    of composition) have similar issues to an association, as the implementation is
    similar. With that in mind, let's take a look at testing issues relating to associated
    objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一般聚合的较少使用的形式相关的类（其中整体包含指向部分的指针，而不是典型的组合的嵌入对象实现）与关联有类似的问题，因为实现是相似的。考虑到这一点，让我们来看看与相关对象有关的测试问题。
- en: Classes related via an association are often independently existing objects,
    which at some point in the application have created a link to one another. There
    may or may not be a predetermined point in the application when the two objects
    create a link to one another. Operations applied on one object may cause a change
    in the associated object. For example, let us consider a `Student` and a `Course`.
    Both may exist independently, then at some point in the application, a `Student`
    may add a `Course` with `Student::AddCourse()`. By doing so, not only does a particular
    `Student` instance now contain a link to a specific `Course` instance, but the
    `Student::AddCourse()` operation has caused a change in the `Course` class. That
    particular `Student` instance is now part of a particular `Course` instance's
    roster. At any point, the `Course` may be canceled, rippling a change in all `Student`
    instances who are enrolled in that `Course`. These changes reflect states in which
    each associated object may exist. For example, a `Student` may be in a state of
    *currently enrolled*, or *dropping* a `Course`. There are many possibilities.
    How do we test all of them?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关联相关的类通常是独立存在的对象，在应用程序的某个时刻彼此创建了链接。在应用于一个对象上的操作可能会导致关联对象的变化。例如，让我们考虑一个“学生”和一个“课程”。两者可能独立存在，然后在应用程序的某个时刻，“学生”可能通过“Student::AddCourse()”添加一个“课程”。通过这样做，不仅特定的“学生”实例现在包含到特定的“课程”实例的链接中，而且“Student::AddCourse()”操作已经导致了“课程”类的变化。特定的“学生”实例现在是特定“课程”实例名单的一部分。在任何时候，“课程”可能被取消，从而影响到所有已经在该“课程”中注册的“学生”实例。这些变化反映了每个关联对象可能存在的状态。例如，“学生”可能处于“当前注册”或“退出”“课程”的状态。有很多可能性。我们如何测试它们？
- en: Adding scenarios to aid in testing object relationships
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加场景以帮助测试对象关系
- en: The notion of a scenario comes up in object-oriented analysis as a means to
    both create OO designs and to test them. A **scenario** is a descriptive walkthrough
    of a likely series of events that will occur in an application. A scenario will
    feature classes and how they may interact with one another for a specific situation.
    Many related scenarios can be collected into the OO concept of a **use-case**.
    In the OO analysis and design phases, scenarios help determine which classes may
    exist in the application as well as operations and relationships each may have.
    In testing, scenarios can be reused to form the basis for driver creation to test
    various object relationships. With this in mind, a series of drivers can be developed
    to test numerous scenarios (that is, use-cases). This type of modeling will more
    thoroughly be able to provide a test bed for related objects than the initial,
    simple means of testing for completeness and robustness.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象分析中，场景的概念被提出作为创建OO设计和测试的手段。**场景**是对应用程序中可能发生的一系列事件的描述性步行。场景将展示类以及它们如何在特定情况下相互作用。许多相关场景可以被收集到OO概念的**用例**中。在OO分析和设计阶段，场景有助于确定应用程序中可能存在的类，以及每个类可能具有的操作和关系。在测试中，场景可以被重复使用，形成测试各种对象关系的驱动程序创建的基础。考虑到这一点，可以开发一系列驱动程序来测试多种场景（即用例）。这种建模方式将更彻底地为相关对象提供一个测试基础，而不仅仅是最初的简单测试完整性和健壮性的手段。
- en: Another area of concern between any type of related classes is that of version
    control. What happens, for example, if a base class definition or default behavior
    changes? How will that impact a derived class? How will that impact associated
    objects? With each change, we inevitably will need to revisit component testing
    for all related classes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何类型的相关类之间的另一个关注领域是版本控制。例如，如果基类定义或默认行为发生了变化会发生什么？这将如何影响派生类？这将如何影响相关对象？随着每次变化，我们不可避免地需要重新审视所有相关类的组件测试。
- en: Next, let's consider how exception handling mechanisms factor into OO component
    testing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑异常处理机制如何影响OO组件测试。
- en: Testing exception handling mechanisms
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异常处理机制
- en: Now that we can create drivers to test each class (or a grouping of related
    classes), we will want to understand which methods in our code may throw exceptions.
    For these scenarios, we will want to add try blocks within the driver to ensure
    we know how to handle each potential exception thrown. Before doing so, we should
    ask ourselves, did we include adequate exception handling in our code during the
    development process? For example, considering instantiation, do our constructors
    check if an object is fully constructed? Do they throw exceptions if not? If the
    answer is no, our classes may not be as robust as we had anticipated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建驱动程序来测试每个类（或一组相关类），我们将想要了解我们代码中哪些方法可能会抛出异常。对于这些情况，我们将希望在驱动程序中添加try块，以确保我们知道如何处理每个可能抛出的异常。在这样做之前，我们应该问自己，在开发过程中我们的代码是否包含了足够的异常处理？例如，考虑实例化，我们的构造函数是否检查对象是否完全构造？如果没有，它们会抛出异常吗？如果答案是否定的，我们的类可能不像我们预期的那样健壮。
- en: Let's consider embedding exception handling into a constructor, and how we may
    construct a driver to test all potential means for instantiation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑将异常处理嵌入到构造函数中，以及我们如何构建一个驱动程序来测试所有可能的实例化方式。
- en: Embedding exception handling in constructors to create robust classes
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将异常处理嵌入到构造函数中以创建健壮的类
- en: We may recall from our recent [*Chapter 11*](B15702_11_Final_NM_ePub.xhtml#_idTextAnchor417),
    *Handling Exceptions*, that we can create our own exception classes, derived from
    the C++ Standard Library `exception` class. Let's assume that we have created
    such a class, namely `ConstructionException`. If at any point in a constructor
    we are not able to properly initialize a given instance to provide a fully constructed
    object, we can throw a `ConstructionException` from any constructor. The implication
    of potentially throwing a `ConstructionException` is that we now should enclose
    instantiation within try blocks and add matching catch blocks to anticipate a
    `ConstructionException` that may be thrown. Keep in mind, however, that instances
    declared within the scope of a try block have scope only within the try-catch
    pairing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还记得我们最近的[*第11章*](B15702_11_Final_NM_ePub.xhtml#_idTextAnchor417)，*处理异常*，我们可以创建自己的异常类，从C++标准库`exception`类派生而来。假设我们已经创建了这样一个类，即`ConstructionException`。如果在构造函数的任何时候我们无法正确初始化给定实例以提供一个完全构造的对象，我们可以从任何构造函数中抛出`ConstructionException`。潜在抛出`ConstructionException`的含义是我们现在应该在try块中封闭实例化，并添加匹配的catch块来预期可能抛出的`ConstructionException`。然而，请记住，在try块范围内声明的实例只在try-catch配对内部有效。
- en: The good news is that if an object does not complete construction (that is,
    if an exception is thrown before the constructor completes), the object will technically
    not exist. If an object does not technically exist, there will be no necessary
    clean-up of a partially instantiated object. We will, however, need to think about
    what this means to our application if an instance we anticipate does not fully
    construct. How will that alter the progression in our code? Part of testing is
    to ensure that we have considered all ways in which our code may be used and bulletproof
    accordingly!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如果一个对象没有完成构造（也就是说，在构造函数完成之前抛出异常），那么这个对象在技术上就不存在。如果一个对象在技术上不存在，就不需要清理部分实例化的对象。然而，我们需要考虑如果我们预期的实例没有完全构造，这对我们的应用意味着什么。这将如何改变我们代码中的进展？测试的一部分是确保我们已经考虑了我们的代码可能被使用的所有方式，并相应地进行防护！
- en: It is important to note that the introduction of `try` and `catch` blocks may
    alter our program flow and it is crucial to include this type of testing in our
    drivers. We may seek scenarios that account for the `try` and `catch` blocks as
    we conduct our testing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，引入`try`和`catch`块可能会改变我们的程序流程，包括这种类型的测试对我们的驱动程序是至关重要的。我们可能会寻找考虑`try`和`catch`块的场景，当我们进行测试时。
- en: We have now seen how we can augment our test drivers to accommodate classes
    that may throw exceptions. We have also discussed in this chapter adding scenarios
    in our drivers to help track the states between objects with relationships, and
    of course, simple class idioms we can follow to set us up for success. Let us
    now briefly recap these concepts before moving forward to our next chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何增强我们的测试驱动程序以适应可能抛出异常的类。在本章中，我们还讨论了在我们的驱动程序中添加场景，以帮助跟踪具有关系的对象之间的状态，当然，我们还讨论了可以遵循的简单类习惯，以便为成功做好准备。在继续下一章之前，让我们简要回顾一下这些概念。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have increased our ability to become better C++ programmers
    by examining various OO class and component testing practices and strategies.
    Our primary goal is to ensure that our code is robust, well-tested, and can be
    deployed error-free to our various organizations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过检查各种OO类和组件测试实践和策略，增强了成为更好的C++程序员的能力。我们的主要目标是确保我们的代码是健壮的，经过充分测试，并且可以无错误地部署到我们的各个组织中。
- en: We have considered programming idioms, such as following canonical class form
    to ensure that our classes are complete and have expected behavior for construction/destruction,
    assignment, and usage in argument passing and as return values from functions.
    We have talked about what it means to create a robust class – one that follows
    canonical class form, that is also well-tested, platform-independent, and tested
    for fully constructed objects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了编程习惯，比如遵循规范的类形式，以确保我们的类是完整的，并且在构造/销毁、赋值以及在参数传递和作为函数返回值中的使用方面具有预期的行为。我们已经讨论了创建健壮类的含义
    - 一个遵循规范的类形式，也经过充分测试，独立于平台，并且针对完全构造的对象进行了测试。
- en: We have also explored how to create drivers to test individual classes or sets
    of related classes. We have established a checklist of items to test individual
    classes within a driver. We have looked more thoroughly at object relationships
    to understand that objects that interact with one another require more sophisticated
    testing. That is, as objects move from state to state, they may be impacted by
    associated objects, which can further alter their course of progression. We've
    added utilizing scenarios as test cases for our drivers to better capture the
    dynamic states in which instances may move within an application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何创建驱动程序来测试单个类或一组相关类。我们已经建立了一个测试单个类的项目清单。我们更深入地研究了对象关系，以了解彼此交互的对象需要更复杂的测试。也就是说，当对象从一种状态转移到另一种状态时，它们可能会受到相关对象的影响，这可能会进一步改变它们的进展方向。我们已经添加了使用场景作为我们的驱动程序的测试用例，以更好地捕捉实例可能在应用程序中移动的动态状态。
- en: Finally, we have taken a look at how exception handling mechanisms can impact
    how we test our code, augmenting our drivers to account for the flow of control
    that try and catch blocks may maneuver in our applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经看了一下异常处理机制如何影响我们测试代码，增强我们的驱动程序以考虑try和catch块在我们的应用程序中可能操纵的控制流。
- en: We are now ready to continue forward with the next part of our book, design
    patterns and idioms in C++. We will start with [*Chapter 16*](B15702_16_Final_NM_ePub.xhtml#_idTextAnchor622),
    *Using the Observer Pattern*. In the remaining chapters, we will understand how
    to apply popular design patterns, employing them in our coding. These skills will
    make us better programmers. Let's move forward!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续我们书的下一部分，C++中的设计模式和习惯用法。我们将从[*第16章*](B15702_16_Final_NM_ePub.xhtml#_idTextAnchor622)开始，*使用观察者模式*。在剩下的章节中，我们将了解如何应用流行的设计模式，在我们的编码中使用它们。这些技能将使我们成为更好的程序员。让我们继续前进！
- en: Questions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Consider a pair of classes from one of your previous exercises containing an
    object relationship (Hint: public inheritance will be easier to consider than
    association).'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一对包含对象关系的类，来自你以前的练习（提示：公共继承比关联更容易考虑）。
- en: a. Do your classes follow canonical class form? Orthodox or extended? Why or
    why not? If they do not and should, revise the classes to follow this idiom.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: a. 你的类遵循规范的类形式吗？是正统的还是扩展的？为什么？如果不是，而应该是，修改类以遵循这种习惯用法。
- en: b. Would you consider your classes robust? Why or why not?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: b. 你认为你的类健壮吗？为什么？为什么不？
- en: Create a driver (or two) to test your pair of classes.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个（或两个）驱动程序来测试你的一对类。
- en: a. Be sure to test for the usual checklist of items (construction, assignment,
    destruction, the public interface, upcasting (if applicable), and use of virtual
    functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: a. 确保测试通常的项目清单（构造、赋值、销毁、公共接口、向上转型（如果适用）和使用虚函数）。
- en: b. (Optional) If you selected two classes related to association, create a separate
    driver to follow a typical scenario detailing the interaction of the two classes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: b.（可选）如果您选择了两个与关联相关的类，请创建一个单独的驱动程序，以详细描述这两个类的交互的典型场景。
- en: c. Be sure to include the testing of exception handling in one of your test
    drivers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: c. 确保在您的一个测试驱动程序中包括异常处理的测试。
- en: Create a `ConstructionException` class (derived from the C++ Standard Library
    `exception`). Embed checks within your constructors in a sample class to throw
    a `ConstructionException` when necessary. Be sure to enclose all forms of instantiation
    of this class within appropriate `try` and `catch` block pairings.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ConstructionException`类（从C++标准库`exception`派生）。在样本类的构造函数中嵌入检查，以在必要时抛出`ConstructionException`。确保将此类的所有实例化形式都包含在适当的`try`和`catch`块配对中。
