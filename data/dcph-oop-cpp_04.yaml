- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Indirect Addressing – References
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接寻址 – 引用
- en: This chapter will examine how to utilize references in C++. References can often,
    but not always, be used as an alternative to pointers for indirect addressing.
    Though you have prior experience with indirect addressing from our last chapter
    using pointers, we will start at the beginning to understand C++ references.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨如何在 C++ 中使用引用。引用通常，但不总是，可以用作间接寻址的替代品，而指针则不行。尽管您已经从上一章通过使用指针获得了间接寻址的经验，但我们仍将从基础开始，以理解
    C++ 中的引用。
- en: References, like pointers, are a language feature you must be able to utilize
    with ease. Many other languages use references for indirect addressing without
    requiring the thorough understanding that C++ imposes to correctly utilize both
    pointers and references. Just as with pointers, you will see references frequently
    used throughout code from other programmers. You may be pleased that using references
    will provide notational ease when writing applications compared to pointers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与指针一样，引用是您必须能够轻松利用的语言特性。许多其他语言在不需要像 C++ 那样彻底理解的情况下，使用引用进行间接寻址。正如指针一样，您将在其他程序员的代码中经常看到引用的使用。您可能会很高兴地发现，与指针相比，使用引用在编写应用程序时将提供更简洁的记法。
- en: Unfortunately, references cannot be used as a substitute for pointers in all
    situations requiring indirect addressing. Therefore, a thorough understanding
    of indirect addressing using both pointers and references is a necessity in C++
    to create successful and maintainable code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，引用不能在所有需要间接寻址的情况下替代指针。因此，在 C++ 中，对使用指针和引用进行间接寻址的彻底理解是编写成功且可维护代码的必要条件。
- en: The goal of this chapter will be to complement your understanding of indirect
    addressing using pointers with knowing how to use C++ references as an alternative.
    Understanding both techniques of indirect addressing will enable you to be a better
    programmer, to easily understand and modify others’ code, as well as to write
    original, mature, and competent C++ code yourself.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标将是补充您对使用指针进行间接寻址的理解，并了解如何使用 C++ 引用作为替代品。理解这两种间接寻址技术将使您成为一名更好的程序员，能够轻松理解并修改他人的代码，以及自己编写原创、成熟和合格的
    C++ 代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Reference basics – declaring, initializing, accessing, and referencing existing
    objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用基础 – 声明、初始化、访问和引用现有对象
- en: Using references with functions as arguments and as return values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将引用用作函数的参数和返回值
- en: Using the `const` qualifier with references
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引用的 `const` 限定符
- en: Understanding underlying implementation, and when references cannot be utilized
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解底层实现，以及何时无法使用引用
- en: By the end of this chapter, you will understand how to declare, initialize,
    and access references; you will understand how to reference existing objects in
    memory. You will be able to use references as arguments to functions, and understand
    how they may be used as return values from functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何声明、初始化和访问引用；您将了解如何引用内存中的现有对象。您将能够将引用用作函数的参数，并理解它们如何作为函数的返回值使用。
- en: You will also fathom how the `const` qualifier may apply to references as variables
    and be utilized with both a function’s parameters and return type. You will be
    able to distinguish when references can be used in lieu of pointers, and in which
    situations they cannot provide a substitute for pointers. These skills will be
    necessary in order to move forward with the next chapters in the book successfully.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将理解 `const` 限定符如何应用于引用作为变量，以及如何与函数的参数和返回类型一起使用。您将能够区分在哪些情况下可以使用引用代替指针，以及在哪些情况下它们不能作为指针的替代品。为了成功进行本书后续章节的学习，这些技能是必要的。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter04`
    in a file named `Chp4-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL中找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04)。每个完整程序示例都可以在GitHub的相应章节标题（子目录）下的文件中找到，该文件以章节编号开头，后面跟着一个连字符，然后是本章中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter04`子目录中的`Chp4-Ex1.cpp`文件中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3ptaMRK](https://bit.ly/3ptaMRK).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下网址查看：[https://bit.ly/3ptaMRK](https://bit.ly/3ptaMRK)。
- en: Understanding reference basics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解引用基础
- en: In this section, we will revisit reference basics as well as introduce operators
    applicable to references, such as the reference operator `&`. We will employ the
    reference operator (`&`) to establish a reference to the existing variable. Like
    pointer variables, reference variables refer to memory that is defined elsewhere.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾引用基础，并介绍适用于引用的运算符，例如引用操作符 `&`。我们将使用引用操作符（`&`）来建立对现有变量的引用。与指针变量一样，引用变量引用的是在别处定义的内存。
- en: Using reference variables allows us to use a more straightforward notation than
    the notation that pointers use when using indirectly accessed memory. Many programmers
    appreciate the clarity in the notation of a reference versus a pointer variable.
    But, behind the scenes, memory must always be properly allocated and released;
    some portion of memory that is referenced may come from the heap. The programmer
    will undoubtedly need to deal with pointers for some portion of their overall
    code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引用变量使我们能够使用比指针在间接访问内存时使用的符号更直接的符号。许多程序员都欣赏引用变量与指针变量在符号上的清晰度。然而，在幕后，内存必须始终得到适当的分配和释放；被引用的部分内存可能来自堆。程序员无疑需要处理他们整体代码中的一些指针。
- en: We will discern when references and pointers are interchangeable, and when they
    are not. Let’s get started with the basic notation for declaring and using reference
    variables.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将区分引用和指针何时可以互换，何时不能。让我们从声明和使用引用变量的基本符号开始。
- en: Declaring, initializing, and accessing references
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明、初始化和访问引用
- en: Let’s begin with the meaning of a reference variable. A C++ `&`. A reference
    must be initialized (at declaration) and may never be assigned to reference another
    object. The reference and the initializer must be of the same type. Since the
    reference and the object being referenced share the same memory, either variable
    may be used to modify the contents of the shared memory location.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从引用变量的含义开始。C++中的 `&`。引用必须在声明时初始化，并且永远不能被分配以引用另一个对象。引用和初始化器必须是同一类型。由于引用和被引用的对象共享相同的内存，因此可以使用任一变量来修改共享内存位置的内存内容。
- en: A reference variable, behind the scenes, can be compared to a pointer variable
    in that it holds the address of the variable that it is referencing. Unlike a
    pointer variable, any usage of the reference variable automatically dereferences
    the variable to go to the address that it contains; the dereference operator `*`
    is simply not needed with references. Dereferencing is automatic and implied with
    each use of a reference variable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，引用变量可以与指针变量相提并论，因为它持有它所引用的变量的地址。与指针变量不同，引用变量的任何使用都会自动解除引用变量，以到达它所包含的地址；引用操作符
    `*` 对于引用来说是不需要的。解除引用是自动的，并且在使用引用变量时是隐含的。
- en: 'Let’s take a look at an example illustrating reference basics:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个说明引用基础的示例：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we first declare and initialize `int x = 10;` and
    then declare and allocate `int *p = new int;`. We then assign the integer value
    `20` to `*p.`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先声明并初始化`int x = 10;`，然后声明并分配`int *p = new int;`。然后我们将整数值`20`赋给`*p`。
- en: Next, we declare and initialize two reference variables, `refInt1` and `refInt2`.
    In the first reference declaration and initialization, `int &refInt1 = x;`, we
    establish `refInt1` to refer to the variable `x`. It helps to read the reference
    declaration from right to left. Here, we are saying to use `x` to initialize `refInt1`,
    which is a reference (`&`) to an integer. Notice that both the initializer, `x`,
    is an integer and that `refInt1` is declared to be a reference to an integer;
    their types match. This is important. The code will not compile if the types differ.
    Likewise, the declaration and initialization `int &refInt2 = *p;` also establishes
    `refInt2` as a reference to an integer. Which one? The one pointed to by `p`.
    This is why `p` is dereferenced using `*` to go to the integer itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明并初始化两个引用变量，`refInt1`和`refInt2`。在第一个引用声明和初始化中，`int &refInt1 = x;`，我们将`refInt1`设置为引用变量`x`。从右到左阅读引用声明有助于理解。在这里，我们说的是使用`x`来初始化`refInt1`，它是一个指向整数的引用（`&`）。注意，初始化器`x`是一个整数，而`refInt1`被声明为指向整数的引用；它们的类型匹配。这是很重要的。如果类型不匹配，代码将无法编译。同样，声明和初始化`int
    &refInt2 = *p;`也将`refInt2`声明为指向整数的引用。哪一个？由`p`指向的那个。这就是为什么使用`*`解引用`p`以到达整数本身的原因。
- en: Now, we print out `x`, `*p`, `refInt1`, and `refInt2`; we can verify that `x`
    and `refInt1` have the same value of `10`, and `*p` and `refInt2` also have the
    same value of `20`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们打印出`x`、`*p`、`refInt1`和`refInt2`；我们可以验证`x`和`refInt1`具有相同的值`10`，而`*p`和`refInt2`也具有相同的值`20`。
- en: Next, using the original variables, we increment both `x` and `*p` by one. Not
    only does this increment the values of `x` and `*p`, but the values of `refInt1`
    and `refInt2`. Repeating the printing of these four values, we again notice that
    `x` and `refInt1` have the value of `11`, while `*p` and `refInt2` have the value
    of `21`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用原始变量，我们将`x`和`*p`都增加一。这不仅增加了`x`和`*p`的值，还增加了`refInt1`和`refInt2`的值。重复打印这四个值，我们再次注意到`x`和`refInt1`的值为`11`，而`*p`和`refInt2`的值为`21`。
- en: Finally, we use the reference variables to increment the shared memory. We increment
    both `refInt1` and `*refint2` by one and this also increments the values of the
    original variables `x` and `*p`. This is because the memory is one and the same
    between the original variable and the reference to that variable. That is, the
    reference can be thought of as an alias to the original variable. We conclude
    the program by again printing out the four variables.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用引用变量来增加共享内存。我们将`refInt1`和`*refint2`都增加一，这也增加了原始变量`x`和`*p`的值。这是因为原始变量和对其的引用之间的内存是相同的。也就是说，引用可以被视为原始变量的别名。我们通过再次打印出这四个变量来结束程序。
- en: 'Here is the output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember, a reference variable must be initialized to the variable it will refer
    to. The reference may never be assigned to another variable. More precisely, we
    cannot rebind the reference to another entity. The reference and its initializer
    must be the same type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，引用变量必须初始化为它将要引用的变量。引用永远不能分配给另一个变量。更准确地说，我们不能重新绑定引用到另一个实体。引用及其初始化器必须是同一类型。
- en: Now that we have a handle on how to declare simple references, let’s take a
    more complete look at referencing existing objects, such as those to user defined
    types.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了如何声明简单的引用，让我们更全面地看看如何引用现有对象，例如用户定义的类型。
- en: Referencing existing objects of user defined types
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用用户定义类型的现有对象
- en: Should a reference to an object of a `struct` or `class` type be defined, the
    object being referenced is simply accessed using the `.` (member selection) operator.
    Again, it is not necessary (such as it is with pointers) to first use the dereference
    operator to go to the object being referenced before choosing the desired member.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要定义对`struct`或`class`类型对象的引用，则可以通过使用`.`（成员选择）运算符直接访问被引用的对象。再次强调，与指针不同，在选择所需的成员之前，没有必要首先使用解引用运算符来访问被引用的对象。
- en: 'Let’s take a look at an example in which we reference a user defined type:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，其中我们引用一个用户定义的类型：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp)'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first part of this program, we define a user defined type, `Student`,
    using a `class`. Next, we declare a variable `s1` of type `Student` using `Student
    s1;`. Now, we declare and initialize a reference to a `Student` using `Student
    &sRef = s1;`. Here, we declare `sRef` to reference a specific `Student`, namely
    `s1`. Notice that both `s1` is of type `Student` and the reference type of `sRef`
    is also that of type `Student`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本程序的第一个部分，我们使用 `class` 定义了一个用户自定义类型 `Student`。接下来，我们使用 `Student s1;` 声明了一个类型为
    `Student` 的变量 `s1`。现在，我们声明并初始化了一个指向 `Student` 的引用 `Student &sRef = s1;`。在这里，我们声明
    `sRef` 来引用一个特定的 `Student`，即 `s1`。请注意，`s1` 是 `Student` 类型，而 `sRef` 的引用类型也是 `Student`
    类型。
- en: Now, we load some initial data into `s1.name` and `s1.gpa` using two simple
    assignments. Consequently, this alters the value of `sRef` since `s1` and `sRef`
    refer to the same memory. That is, `sRef` is an alias for `s1`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过两个简单的赋值将一些初始数据加载到 `s1.name` 和 `s1.gpa` 中。因此，这改变了 `sRef` 的值，因为 `s1` 和
    `sRef` 引用的是相同的内存。也就是说，`sRef` 是 `s1` 的别名。
- en: We print out various data members for `s1` and `sRef` and notice that they contain
    the same values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出 `s1` 和 `sRef` 的各种数据成员，并注意到它们包含相同的值。
- en: Now, we load new values into `sRef.name` and `sRef.gpa` using assignments. Similarly,
    we print out various data members for `s1` and `sRef` and notice that again, the
    values for both have changed. Again, we can see that they reference the same memory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过赋值将新的值加载到 `sRef.name` 和 `sRef.gpa` 中。同样，我们打印出 `s1` 和 `sRef` 的各种数据成员，并注意到两者的值都发生了变化。再次，我们可以看到它们引用的是相同的内存。
- en: 'The output to accompany this program is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随此程序的输出如下：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s now move forward with our understanding of references by considering their
    usage in functions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑引用在函数中的使用来进一步理解引用的概念。
- en: Using references with functions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数中使用引用
- en: So far, we have minimally demonstrated references by using them to establish
    an alias for an existing variable. Instead, let’s put forth a meaningful use of
    references, such as when they are used in function calls. We know most functions
    in C++ will take arguments, and we have seen many examples in the previous chapters
    illustrating function prototypes and function definitions. Now, let’s augment
    our understanding of functions by passing references as arguments to functions,
    and using references as return values from functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过使用它们为现有变量创建别名来最小化地展示了引用。相反，让我们提出一个有意义的引用用法，例如在函数调用中使用它们。我们知道大多数 C++
    函数都会接受参数，我们已经在之前的章节中看到了许多示例，说明了函数原型和函数定义。现在，让我们通过将引用作为函数参数传递，并使用引用作为函数的返回值来增强我们对函数的理解。
- en: Passing references as arguments to functions
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将引用作为函数参数传递
- en: References may be used as arguments to functions to achieve call-by-reference,
    rather than call-by-value, parameter passing. References can alleviate the need
    for pointer notation in the scope of the function in question as well as in the
    call to that function. Object or `.` (member selection) notation is used to access
    `struct` or `class` members for formal parameters that are references.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 引用可以用作函数的参数，以实现按引用传递参数，而不是按值传递参数。引用还可以在所讨论的函数的作用域内以及在调用该函数时减少对指针符号的需求。对于引用形式的正式参数，使用对象或
    `.`（成员选择）符号来访问 `struct` 或 `class` 成员。
- en: In order to modify the contents of a variable passed as an argument to a function,
    a reference (or pointer) to that argument must be used as a function parameter.
    Just as with a pointer, when a reference is passed to a function, a copy of the
    address representing the reference is passed to the function. However, within
    the function, any usage of a formal parameter that is a reference will automatically
    and implicitly be dereferenced, allowing the user to use object rather than pointer
    notation. As with passing a pointer variable, passing a reference variable to
    a function will allow the memory referenced by that parameter to be modified.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改传递给函数的变量的内容，必须使用该参数的引用（或指针）作为函数参数。就像指针一样，当将引用传递给函数时，传递的是表示该引用的地址的副本。然而，在函数内部，任何使用形式参数为引用的用法都将自动和隐式地解引用，使用户可以使用对象而不是指针表示法。与传递指针变量一样，将引用变量传递给函数将允许修改该参数引用的内存。
- en: When examining a function call (apart from its prototype), it will not be obvious
    whether an object passed to that function is passed by value or by reference.
    That is, whether the entire object will be copied on the stack or whether a reference
    to that object will instead be passed on the stack. This is because object notation
    is used when manipulating references, and the function calls for these two scenarios
    will use the same syntax.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查一个函数调用（除了其原型）时，不会很明显地看出传递给该函数的对象是按值传递还是按引用传递。也就是说，整个对象是否会在栈上复制，或者是否将对该对象的引用传递到栈上。这是因为当操作引用时使用了对象表示法，并且这两种情况下的函数调用将使用相同的语法。
- en: Diligent use of function prototypes will solve the mystery of what a function
    definition looks like and whether its arguments are objects or references to objects.
    Remember, a function definition may be defined in a separate file from any calls
    to that function, and not be easily available to view. Note that this ambiguity
    does not come up with pointers specified in a function call; it is immediately
    obvious that an address is being sent to a function based on how the variable
    is declared.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细使用函数原型将解决函数定义看起来是什么样子以及其参数是对象还是对象引用的神秘。记住，函数定义可能定义在一个与该函数的任何调用都分开的文件中，并且不容易查看。注意，这种歧义不会出现在函数调用中指定的指针；根据变量的声明方式，立即可以明显看出地址是否被发送到函数。
- en: 'Let’s take a few minutes to understand an example illustrating passing references
    as arguments to functions. Here, we will begin by examining three functions, which
    contribute to the following full program example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟时间理解一个示例，该示例说明了将引用作为参数传递给函数。在这里，我们将首先检查三个函数，这些函数有助于以下完整的程序示例：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp)'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Examining the previous functions, notice that `AddOne(int &arg)` takes a reference
    to an `int` as a formal parameter, while `AddOne(int *arg)` takes a pointer to
    an `int` as a formal parameter. These functions are overloaded. The types of their
    actual parameters will determine which version is called.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面的函数，注意`AddOne(int &arg)`将一个`int`的引用作为形式参数，而`AddOne(int *arg)`将一个`int`的指针作为形式参数。这些函数是重载的。它们的实际参数的类型将确定调用哪个版本。
- en: Now let’s consider `Display(int &arg)`. This function takes a reference to an
    integer. Notice that object (not pointer) notation is used to print `arg` within
    this function’s definition.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑`Display(int &arg)`。这个函数接受一个整数的引用。注意，在这个函数的定义中，使用的是对象（而不是指针）表示法来打印`arg`。
- en: 'Now, let’s examine the remainder of this program:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查这个程序的其余部分：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the function prototypes at the top of this program segment. They will
    match the function definitions in the previous segment of code. Now, in the `main()`
    function, we declare and initialize `int x = 10;` and declare a pointer `int *y;`.
    We allocate the memory for `y` using `new()` and then assign a value by dereferencing
    the pointer with `*y = 15;`. We print out the respective values of `x` and `*y`
    as a baseline using successive calls to `Display()`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个程序段顶部的函数原型。它们将与代码前一段中的函数定义相匹配。现在，在 `main()` 函数中，我们声明并初始化 `int x = 10;` 并声明一个指针
    `int *y;`。我们使用 `new()` 分配 `y` 的内存，然后通过解引用指针赋值 `*y = 15;`。我们使用连续的 `Display()` 调用来打印
    `x` 和 `*y` 的相应值作为基准。
- en: Next, we call `AddOne(x)` followed by `AddOne(*y)`. Variable `x` is declared
    to be an integer and `*y` refers to the integer pointed to by `y`. In both cases,
    we are passing integers as actual parameters to the version of the overloaded
    function with the signature `void AddOne(int &);`. In both cases, the formal parameters
    will be changed in the function, as we are passing by reference. We can verify
    this when their respective values are next printed using successive calls to `Display()`.
    Note that in the function call `AddOne(x);`, the reference to the actual parameter
    `x` is established by the formal parameter `arg` (in the function’s parameter
    list) at the time of the function call.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `AddOne(x)` 然后是 `AddOne(*y)`。变量 `x` 被声明为整数，`*y` 指向 `y` 所指向的整数。在这两种情况下，我们都在将整数作为实际参数传递给具有签名
    `void AddOne(int &);` 的重载函数版本。在这两种情况下，形式参数将在函数中被更改，因为我们是通过引用传递的。我们可以在使用连续的 `Display()`
    调用打印它们的相应值时验证这一点。注意，在函数调用 `AddOne(x);` 中，实际参数 `x` 的引用是通过函数调用时参数列表中的形式参数 `arg`
    建立的。
- en: In comparison, we then call `AddOne(&x);` followed by `AddOne(y);`. In both
    cases, we are calling the overloaded version of this function with the signature
    `void AddOne(int *);`. In each case, we are passing a copy of an address as the
    actual parameter to the function. Naturally, `&x` is the address of variable `x`,
    so this works. Likewise, `y` itself is an address – it is declared as a pointer
    variable. We again verify that their respective values are again changed with
    two calls to `Display()`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们随后调用 `AddOne(&x);` 然后是 `AddOne(y);`。在这两种情况下，我们都在调用具有签名 `void AddOne(int
    *);` 的重载函数版本。在每种情况下，我们都在函数中将地址的副本作为实际参数传递。自然地，`&x` 是变量 `x` 的地址，所以这行得通。同样，`y` 本身也是一个地址——它被声明为一个指针变量。我们再次通过两次调用
    `Display()` 验证它们的相应值是否被更改。
- en: Notice, in each call to `Display()`, we pass an object of type `int`. Looking
    at the function call alone, we cannot determine whether this function will take
    an `int` as an actual parameter (which would imply the value could not be changed),
    or an `int &` as an actual parameter (which would imply that the value could be
    modified). Either of these is a possibility. However, by looking at the function
    prototype, we can clearly see that this function takes an `int &` as a parameter,
    and from this, we understand that the parameter may likely be modified. This is
    one of the many reasons function prototypes are helpful.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每次调用 `Display()` 时，我们传递一个 `int` 类型的对象。仅从函数调用本身来看，我们无法确定这个函数是否将接受一个 `int`
    作为实际参数（这意味着值不能被更改），或者接受一个 `int &` 作为实际参数（这意味着值可以被修改）。这两种情况都是可能的。然而，通过查看函数原型，我们可以清楚地看到这个函数接受一个
    `int &` 作为参数，并且由此我们可以理解参数可能被修改。这是函数原型有很多好处之一。
- en: 'Here is the output for the full program example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整程序示例的输出：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let’s add to our discussion of using references with functions by using
    references as return values from functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用函数的引用作为返回值来补充我们对使用引用与函数的讨论。
- en: Using references as return values from functions
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用引用作为函数的返回值
- en: Functions may return references to data via their return statements. We will
    see a requirement to return data by reference when we overload operators for user
    defined types in [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and
    Operator Overloading*. With operator overloading, returning a value from a function
    using a pointer will not be an option to preserve the operator’s original syntax.
    We must return a reference (or a reference qualified with `const`); this will
    also allow overloaded operators to enjoy cascaded use. Additionally, understanding
    how to return objects by reference will be useful as we explore the C++ Standard
    Template Library in [*Chapter 14*](B19087_14.xhtml#_idTextAnchor595), *Understanding
    STL Basics*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过返回语句返回数据的引用。当我们为用户定义的类型重载运算符时，在[*第12章*](B19087_12.xhtml#_idTextAnchor526)，*朋友与运算符重载*中，我们将看到需要通过引用返回数据的需求。在运算符重载中，使用指针从函数返回值将不会是保留运算符原始语法的选项。我们必须返回一个引用（或带有`const`修饰的引用）；这也会使重载的运算符能够享受级联使用。此外，当我们探索C++标准模板库时，在[*第14章*](B19087_14.xhtml#_idTextAnchor595)，*理解STL基础*中，了解如何通过引用返回对象将是有用的。
- en: When returning a reference via the return statement of a function, be sure that
    the memory that is referred to will persist after the function call is completed.
    Do **not** return a reference to a local variable defined on the stack within
    the function; this memory will be popped off the stack the moment the function
    completes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过函数的返回语句返回引用时，请确保所引用的内存在函数调用完成后仍然存在。**不要**返回函数中定义在栈上的局部变量的引用；这个内存将在函数完成时从栈上弹出。
- en: Since we cannot return a reference to a local variable within the function,
    and since returning a reference to an external variable is pointless, you may
    ask where the data that we return a reference to will reside. This data will inevitably
    be on the heap. Heap memory will exist past the extent of the function call. In
    most circumstances, the heap memory will have been allocated elsewhere; however,
    on rare occasions, the memory may have been allocated within this function. In
    this unusual situation, you must remember to relinquish the allocated heap memory
    when it is no longer required.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法在函数内部返回局部变量的引用，并且返回外部变量的引用是没有意义的，您可能会问我们返回引用的数据将驻留在何处。这些数据不可避免地将在堆上。堆内存将存在于函数调用的范围之外。在大多数情况下，堆内存已经在其他地方分配；然而，在罕见的情况下，内存可能在此函数内部分配。在这种情况下，您必须记住在不再需要时释放分配的堆内存。
- en: Deleting heap memory through a reference (versus pointer) variable will require
    you to use the address-of operator, `&`, to pass the required address to operator
    `delete()`. Even though reference variables contain the address of the object
    they are referencing, the use of a reference identifier is always in its dereferenced
    state. It is **rare** that the need may arise to delete memory using a reference
    variable; we will discuss a meaningful (yet rare) example in [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454),
    *Implementing Association, Aggregation, and Composition*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用变量删除堆内存（与指针相比）将需要您使用地址运算符`&`将所需的地址传递给`delete()`运算符。尽管引用变量包含它们所引用的对象的地址，但引用标识符的使用始终处于解引用状态。使用引用变量删除内存的需求**很少**出现；我们将在[*第10章*](B19087_10.xhtml#_idTextAnchor454)，*实现关联、聚合和组合*中讨论一个有意义的（尽管很少见）示例。
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The following example illustrates syntactically how to return a reference from
    a function, which you will utilize when we overload operators to allow their cascaded
    use, for example. However, it is not recommended to use references to return newly
    allocated heap memory (in most cases, the heap memory will have been allocated
    elsewhere). It is a common convention to use references to signal to other programmers
    that there is no need for memory management for that variable. Nevertheless, rare
    scenarios for such deletions via references may be seen in existing code (as with
    the aforementioned rare usage with associations), so it is useful to see how such
    a rare deletion may be done.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何从函数中返回引用的语法，您将在我们重载运算符以允许其级联使用时使用它，例如。然而，不建议使用引用返回新分配的堆内存（在大多数情况下，堆内存已经在其他地方分配）。这是一个常见的约定，使用引用向其他程序员发出信号，表明该变量不需要内存管理。尽管如此，在现有代码中可能会看到通过引用进行此类删除的罕见场景（如上述与关联的罕见使用），因此了解如何进行这种罕见的删除是有用的。
- en: 'Let’s see an example to illustrate the mechanics of using a reference as a
    return value from a function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示将引用作为函数返回值的机制：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp)'
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we see `int &CreateId();` prototyped towards the top of the
    program. This tells us that `CreateId()` will return a reference to an integer.
    The return value must be used to initialize a variable of type `int &`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们看到`int &CreateId();`在程序顶部进行了原型声明。这告诉我们`CreateId()`将返回一个整数的引用。返回值必须用于初始化类型为`int
    &`的变量。
- en: Toward the bottom of the program, we see the function definition for `CreateId()`.
    Notice that this function first declares a `static` counter, which is initialized
    exactly once to `100`. Because this local variable is `static`, it will preserve
    its value from function call to function call. We then increment this counter
    by one a few lines later. The static variable, `count`, will be used as a basis
    to generate a unique ID.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序底部，我们看到`CreateId()`函数的定义。请注意，此函数首先声明了一个`static`计数器，它被初始化一次为`100`。因为这个局部变量是`static`的，它将在函数调用之间保留其值。然后我们在几行之后将这个计数器增加一。静态变量`count`将作为生成唯一ID的基础。
- en: Next, in `CreateId()`, we allocate space for an integer on the heap and point
    to it using the local variable `memory`. We then load `*memory` with the value
    of `count` and then increase `count` for the next time we enter this function.
    We then use `*memory` as the return value of this function. Notice that `*memory`
    is an integer (the one pointed to on the heap by the variable `memory`). When
    we return it from the function, it is returned as a reference to that integer.
    When returning a reference from a function, always ensure that the memory that
    is referenced exists beyond the extent of the function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`CreateId()`中，我们在堆上为整数分配空间，并使用局部变量`memory`指向它。然后我们将`*memory`加载为`count`的值，然后增加`count`以便下次进入此函数时使用。然后我们使用`*memory`作为此函数的返回值。请注意，`*memory`是一个整数（由变量`memory`在堆上指向的整数）。当我们从函数返回它时，它作为对该整数的引用返回。当从函数返回引用时，始终确保所引用的内存存在于函数的作用域之外。
- en: 'Now, let’s look at our `main()` function. Here, we initialize a reference variable
    `id1` with the return value of our first call to `CreateId()` in the following
    function call and initialization: `int &id1 = CreateId();`. Note that the reference
    `id1` must be initialized when it is declared, and we have met that requirement
    with the aforementioned line of code.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`main()`函数。在这里，我们用以下函数调用和初始化的返回值初始化引用变量`id1`：`int &id1 = CreateId();`。请注意，引用`id1`必须在声明时初始化，我们通过上述代码满足了这一要求。
- en: We repeat this process with `id2`, initializing this reference with the return
    value of `CreateId()`. We then print both `id1` and `id2`. By printing both `id1`
    and `id2`, you can see that each ID variable has its own memory and maintains
    its own data values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`id2`重复此过程，用`CreateId()`的返回值初始化这个引用。然后我们打印`id1`和`id2`。通过打印`id1`和`id2`，你可以看到每个ID变量都有自己的内存并保持自己的数据值。
- en: Next, we must remember to deallocate the memory that `CreateId()` allocated
    on our behalf. We must use operator `delete()`. Wait, operator `delete()` expects
    a pointer to the memory that will be deleted. Variables `id1` and `id2` are both
    references, not pointers. True, they each contain an address because each is inherently
    implemented as a pointer, but any use of their respective identifiers is always
    in a dereferenced state. To circumvent this dilemma, we simply take the address
    of reference variables `id1` and `id2` prior to calling `delete()`, such as `delete
    &id1;`. It is **rare** that you would need to delete memory via a reference variable,
    but now you know how to do so should the need arise.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须记住释放`CreateId()`代表我们分配的内存。我们必须使用`delete()`运算符。等等，`delete()`运算符期望一个指向将被删除内存的指针。变量`id1`和`id2`都是引用，不是指针。确实，它们各自包含一个地址，因为每个都是作为指针实现的，但任何使用它们各自标识符的操作总是处于解引用状态。为了解决这个问题，我们在调用`delete()`之前简单地取引用变量`id1`和`id2`的地址，例如`delete
    &id1;`。通过引用变量删除内存的情况**很少见**，但现在你知道了如果需要这样做该如何操作。
- en: 'The output for this example is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出如下：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we understand how references can be used within parameters to functions
    and as return values from functions, let’s move forward by examining further reference
    nuances.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在函数参数中使用引用以及如何从函数返回引用，让我们进一步探讨引用的细微差别。
- en: Using the const qualifier with references
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 const 关键字与引用
- en: The `const` qualifier can be used to qualify the data in which references are
    initialized or *refer to*. We can also use `const` qualified references as arguments
    to functions and as return values from functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 关键字可以用来限定引用初始化或*引用*的数据。我们还可以使用 `const` 限定的引用作为函数的参数和函数的返回值。'
- en: It is important to understand that a reference is implemented as a constant
    pointer in C++. That is, the address contained within the reference variable is
    a fixed address. This explains why a reference variable must be initialized to
    the object to which it will refer, and may not later be updated using an assignment.
    This also explains why constant qualifying the reference itself (and not just
    the data that it refers to) does not make sense. This variety of `const` qualification
    is already implied with its underlying implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解在 C++ 中，引用被实现为一个常量指针。也就是说，引用变量中包含的地址是一个固定的地址。这解释了为什么引用变量必须初始化为它将要引用的对象，并且不能通过赋值来更新。这也解释了为什么对引用本身进行常量限定（而不仅仅是它引用的数据）没有意义。这种
    `const` 限定的变体已经隐含在其底层实现中。
- en: Let’s take a look at these various scenarios using `const` with references.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 `const` 与引用的各种场景来看看这些。
- en: Using references to constant objects
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用常量对象引用
- en: The `const` qualifier can be used to indicate that the data to which references
    are initialized are unmodifiable. In this fashion, the alias always refers to
    a fixed piece of memory, and the value of that variable may not be changed using
    the alias itself. The reference, once specified as constant, implies that neither
    the reference nor its value may be changed. Again, the reference itself may not
    be changed due to its underlying implementation as a constant qualified pointer.
    A `const` qualified reference may not be used as an *l-value* in any assignment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 关键字可以用来表明引用初始化的数据是不可修改的。以这种方式，别名始终指向一个固定的内存块，该变量的值不能通过别名本身来更改。一旦引用被指定为常量，就暗示了引用及其值都不能更改。再次强调，由于引用本身作为常量限定指针的底层实现，引用本身不能更改。`const`
    限定的引用不能用作任何赋值中的 *左值*。'
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Recall, an **l-value** is a value that can be modified and that occurs on the
    left-hand side of an assignment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，**左值** 是一个可以修改的值，它出现在赋值语句的左侧。
- en: 'Let’s introduce a simple example to understand the situation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来了解这种情况：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex5.cpp)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex5.cpp)'
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous example, notice that we declare `int x = 5;` and then we establish
    a constant reference to that integer with the declaration: `const int &refInt
    = x;`. Next, we print out both values for a baseline and notice that they are
    identical. This makes sense; they reference the same integer memory.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，请注意我们声明了 `int x = 5;` 然后通过以下声明建立对该整数的常量引用：`const int &refInt = x;`。接下来，我们打印出这两个值作为基准，并注意到它们是相同的。这是有道理的；它们引用了相同的整数内存。
- en: Next, in the commented-out piece of code, `//refInt = 6;`, we try to modify
    the data that the reference refers to. Because `refInt` is qualified as `const`,
    this is illegal; this is the reason why we commented out this line of code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在注释掉的代码片段 `//refInt = 6;` 中，我们尝试修改引用所引用的数据。因为 `refInt` 被标记为 `const`，这是非法的；这就是为什么我们注释掉了这一行代码。
- en: However, on the following line of code, we assign `x` a value of `7`. Since
    `refInt` refers to this same memory, its value will also be modified. Wait, isn’t
    `refInt` constant? Yes, by qualifying `refInt` as `const`, we are indicating that
    its value will not be modified using the identifier `refInt`. This memory can
    still be modified using `x`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在下一行代码中，我们将 `x` 的值赋为 `7`。由于 `refInt` 引用了相同的内存，其值也将被修改。等等，`refInt` 不是常量吗？是的，通过将
    `refInt` 标记为 `const`，我们表明其值不会通过 `refInt` 这个标识符来修改。这个内存仍然可以通过 `x` 来修改。
- en: But wait, isn’t this a problem? No, if `refInt` truly wants to refer to something
    unmodifiable, it can instead initialize itself with a `const int`, not an `int`.
    This subtle point is something to remember in C++ so you can write code for exactly
    the scenario you intend to have, understanding the significance and consequences
    of each choice.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这难道不是一个问题吗？不，如果`refInt`确实想要引用不可修改的对象，它可以用`const int`而不是`int`来初始化自己。这个微妙之处是C++中需要记住的，这样你就可以编写出符合你意图的代码，理解每个选择的意义和后果。
- en: 'The output for this example is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的输出如下：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, let’s see a variation on the `const` qualification theme.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`const`修饰符主题的一个变体。
- en: Using pointers to constant objects as function arguments and as return types
    from functions
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指向常量对象的指针作为函数参数，以及作为函数的返回类型
- en: Using `const` qualification with function parameters cannot just allow the speed
    of passing an argument by reference, but the safety of passing an argument by
    value. It is a useful feature in C++.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`修饰符作为函数参数不仅允许通过引用传递参数的速度，还允许通过值传递参数的安全性。这是C++中的一个有用特性。
- en: A function that takes a reference to an object as a parameter often has less
    overhead than a comparable version of the function that takes a copy of an object
    as a parameter. This most notably occurs when the object type that would be otherwise
    copied on the stack is large. Passing a reference as a formal parameter is speedier,
    yet permits the actual parameter to be potentially modified in the scope of the
    function. Passing a reference to a constant object as a function argument provides
    both speed and safety for the argument in question. The reference qualified as
    `const` in the parameter list simply may not be an *l-value* in the scope of the
    function in question.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个以对象引用作为参数的函数通常比一个以对象副本作为参数的函数开销更小。这最明显地发生在对象类型本应复制到栈上且很大时。将引用作为形式参数传递更快，同时允许在函数的作用域内修改实际参数。将常量对象的引用作为函数参数提供了对所讨论参数的速度和安全性。在参数列表中修饰为`const`的引用在相关函数的作用域内可能不是`*l-value*`。
- en: The same benefit of `const` qualified references exists for the return value
    from a function. Constant qualifying the data referenced insists that the caller
    of the function must also store the return value in a reference to a constant
    object, ensuring the object may not be modified.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`修饰的引用对函数的返回值也有同样的好处。对引用的数据进行常量修饰坚持要求函数的调用者必须也将返回值存储在常量对象的引用中，确保对象不会被修改。'
- en: 'Let’s take a look at an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp)'
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we first define a simple `struct` `collection` with data members
    `x` and `y`. Next, we prototype `Update(collection &);` and `Print(const collection
    &);`. Notice that `Print()` constant qualifies the data being referenced as the
    input parameter. This means that this function will enjoy the speed of passing
    this parameter by reference, and the safety of passing the parameter by value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了一个简单的`struct` `collection`，其中包含数据成员`x`和`y`。接下来，我们原型化了`Update(collection
    &);`和`Print(const collection &);`。请注意，`Print()`的常量修饰符指定了被引用的数据作为输入参数。这意味着这个函数将享受通过引用传递参数的速度，以及通过值传递参数的安全性。
- en: 'Notice, towards the end of the program, we see the definitions for both `Update()`
    and `Print()`. Both take references as arguments, however, the parameter to `Print()`
    is constant qualified: `void Print(const collection &);`. Notice that both functions
    use the `.` (member selection) notation within each function body to access the
    relevant data members.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在程序末尾，我们看到了`Update()`和`Print()`的定义。两个函数都接受引用作为参数，然而，`Print()`的参数是常量修饰的：`void
    Print(const collection &);`。请注意，两个函数都在函数体内使用`.`（成员选择）运算符来访问相关数据成员。
- en: In `main()`, we declare two variables, `collect1` of type `collection`, and
    `collect2`, which is a pointer to a `collection` (and whose memory is subsequently
    allocated). We call `Update()` for both `collect1` and `*collect2`, and in each
    case, a reference to the applicable object is passed to the `Update()` function.
    In the case of `collect2`, which is a pointer variable, the actual parameter must
    first dereference `*collect2` to go to the object being referenced before calling
    this function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 中，我们声明了两个变量，`collect1` 类型为 `collection`，以及 `collect2`，它是一个指向 `collection`
    的指针（其内存随后被分配）。我们对 `collect1` 和 `*collect2` 都调用了 `Update()`，在每种情况下，都向 `Update()`
    函数传递了适用对象的引用。在 `collect2` 的情况下，由于它是一个指针变量，在调用此函数之前必须首先取消引用 `*collect2` 以到达被引用的对象。
- en: Finally, in `main()`, we call `Print()` successively for both `collect1` and
    `*collect2`. Here, `Print()` will reference each object serving as a formal parameter
    as constant qualified referenced data, ensuring that no modifications of either
    input parameter are possible within the scope of the `Print()` function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `main()` 函数中，我们依次对 `collect1` 和 `*collect2` 调用 `Print()`。在这里，`Print()`
    将引用每个作为形式参数的对象作为常量合格引用数据，确保在 `Print()` 函数的作用域内不可能修改任何输入参数。
- en: 'Here is the output to accompany our example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是伴随我们示例的输出：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have an understanding of when `const` qualified references are useful,
    let’s take a look at when we can use references in lieu of pointers, and when
    we cannot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了何时使用常量合格引用是有用的，让我们看看何时可以使用引用代替指针，以及何时不能。
- en: Realizing underlying implementation and restrictions
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解底层实现和限制
- en: References can ease the notation required for indirect referencing. However,
    there are situations in which references simply cannot take the place of pointers.
    To understand these situations, it is useful to review the underlying implementation
    of a reference in C++.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 引用可以简化间接引用所需的符号。然而，有些情况下引用根本不能取代指针。为了理解这些情况，回顾 C++ 中引用的底层实现是有用的。
- en: References are implemented as constant pointers, hence they must be initialized.
    Once initialized, references may not refer to a different object (though the value
    of the object being referenced can be changed).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 引用被实现为常量指针，因此它们必须被初始化。一旦初始化，引用就不能指向不同的对象（尽管被引用的对象的值可以改变）。
- en: 'To understand the implementation, let’s consider a sample reference declaration:
    `int &intVar = x;`. From an implementation aspect, it is as though the former
    variable declaration is instead declared as `int *const intVar = &x;`. Note that
    the `&` symbol shown on the left-hand side of an initialization takes on the meaning
    of reference, whereas the `&` symbol shown on the right-hand side of an initialization
    or assignment implies address-of. These two declarations illustrate how a reference
    is defined versus its underlying implementation.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解实现，让我们考虑一个示例引用声明：`int &intVar = x;`。从实现的角度来看，这就像前面的变量声明被改为 `int *const intVar
    = &x;`。请注意，初始化左侧的 `&` 符号表示引用的意义，而初始化或赋值右侧的 `&` 符号表示取地址。这两个声明说明了引用的定义与其底层实现之间的关系。
- en: Even though a reference is implemented as a constant pointer, the usage of the
    reference variable is as if the underlying constant pointer has been dereferenced.
    For this reason, you cannot initialize a reference with a `nullptr` – not only
    can a `nullptr` not be dereferenced but since references can only be initialized
    and not reset, the opportunity would be lost to establish the reference variable
    to refer to a meaningful object. This also holds true for references to pointers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管引用被实现为常量指针，但引用变量的使用就像底层常量指针已被取消引用一样。因此，你不能用 `nullptr` 初始化引用——不仅 `nullptr`
    不能被取消引用，而且由于引用只能初始化而不能重置，就会失去将引用变量设置为指向有意义对象的机遇。这也适用于指针的引用。
- en: Next, let’s understand in which situations we cannot use references.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解在哪些情况下我们不能使用引用。
- en: Understanding when we must use pointers instead of references
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解何时必须使用指针而不是引用
- en: Based on the underlying implementation of references (as `const` pointers),
    most of the restrictions for reference usage make sense. For example, references
    to references are generally not allowed; each level of indirection would need
    to be initialized upfront and that often takes multiple steps, such as when using
    pointers. However, we will see `&&`) in [*Chapter 15*](B19087_15.xhtml#_idTextAnchor655),
    *Testing Classes and Components*, where we will examine various *move* operations.
    Arrays of references are also not permitted (each element would need to be initialized
    immediately); nonetheless, arrays of pointers are always an option. Also, pointers
    to references are not permitted; however, references to pointers are permitted
    (as are pointers to pointers).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 基于引用的底层实现（作为`const`指针），大多数引用使用的限制都是有意义的。例如，引用的引用通常是不允许的；每个间接级别都需要预先初始化，这通常需要多个步骤，例如使用指针。然而，我们将在[*第15章*](B19087_15.xhtml#_idTextAnchor655)中看到`&&`)，*测试类和组件*，我们将检查各种*移动*操作。引用数组也是不允许的（每个元素都需要立即初始化）；然而，指针数组始终是一个选项。此外，不允许指向引用的指针；但是，允许引用指针（以及指针的指针）。
- en: 'Let’s take a look at the mechanics of an interesting allowable reference case
    that we have not yet explored:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个有趣的允许引用案例的机制，我们尚未探索：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp)'
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we declare `int *ptr;` and then allocate the memory for `ptr`
    (consolidated on one line). We then assign a value of `20` to `*p`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明`int *ptr;`然后为`ptr`分配内存（合并在一行中）。然后我们将值`20`赋给`*p`。
- en: Next, we declare `int *&refPtr = ptr;`, which is a reference to a pointer of
    type `int`. It helps to read the declaration from right to left. As such, we use
    `ptr` to initialize `refPtr`, which is a reference to a pointer to an `int`. In
    this case, the two types match; `ptr` is a pointer to an `int`, so `refPtr` must
    also then reference a pointer to an `int`. We then print out the value of both
    `*ptr` and `*refPtr` and can see that they are the same.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明`int *&refPtr = ptr;`，这是一个指向`int`类型指针的引用。有助于从右到左阅读声明。因此，我们使用`ptr`来初始化`refPtr`，它是指向`int`的指针的引用。在这种情况下，两种类型匹配；`ptr`是`int`的指针，所以`refPtr`也必须引用一个指向`int`的指针。然后我们打印出`*ptr`和`*refPtr`的值，可以看到它们是相同的。
- en: 'Here is the output to accompany our program:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是伴随我们程序的输出：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this example, we have seen yet another interesting use of references. We
    also understand the restrictions placed upon using references, all of which are
    driven by their underlying implementation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们看到了引用的另一种有趣用途。我们还理解了使用引用的限制，所有这些限制都是由它们的底层实现驱动的。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned numerous aspects of C++ references. We have
    taken the time to understand reference basics, such as declaring and initializing
    reference variables to existing objects, as well as how to access reference components
    for basic and user defined types.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了C++引用的众多方面。我们花时间理解了引用的基础，例如将引用变量声明和初始化为现有对象，以及如何访问基本和用户定义类型的引用组件。
- en: We have seen how to utilize references in a meaningful fashion with functions,
    both as input parameters and as a return value. We have also seen when it is reasonable
    to apply the `const` qualifier to references, as well as seen how this concept
    can be combined with parameters and return values from functions. Lastly, we have
    seen the underlying implementation of references. This has helped explain some
    of the restrictions references encompass, as well as understand which cases of
    indirect addressing will require the use of pointers instead of references.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何以有意义的方式在函数中使用引用，无论是作为输入参数还是作为返回值。我们还看到了何时合理地将`const`限定符应用于引用，以及看到了如何将此概念与函数的参数和返回值相结合。最后，我们看到了引用的底层实现。这有助于解释引用包含的一些限制，以及理解哪些间接寻址的情况需要使用指针而不是引用。
- en: As with pointers, all of the skills using references from this chapter will
    be used freely in the upcoming chapters. C++ allows programmers to have a more
    convenient notation for indirect addressing using references; however, programmers
    are expected to utilize either for indirect addressing with relative ease.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与指针一样，本章中使用的所有关于引用的技能将在接下来的章节中自由使用。C++允许程序员使用引用来更方便地实现间接寻址；然而，程序员应预期能够相对容易地使用引用进行间接寻址。
- en: Finally, you are now ready to move forward to [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222),
    *Exploring Classes in Detail*, in which we begin the object-oriented features
    of C++. This is what we have been waiting for; let’s get started!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你现在可以向前推进到[*第5章*](B19087_05.xhtml#_idTextAnchor222)，*详细探索类*，其中我们将开始C++的面向对象特性。这是我们一直在等待的；让我们开始吧！
- en: Questions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Modify and augment your C++ program from [*Chapter 3*](B19087_03.xhtml#_idTextAnchor118),
    *Indirect Addressing – Pointers*, *Question 1* as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改并增强你的C++程序，从[*第3章*](B19087_03.xhtml#_idTextAnchor118)，*间接寻址 – 指针*，*问题1*，如下进行：
- en: Overload your `ReadData()` function with a version that accepts a `Student &`
    parameter to allow `firstName`, `lastName`, `currentCourseEnrolled`, and `gpa`
    to be entered from the keyboard within the function.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载你的`ReadData()`函数，添加一个接受`Student &`参数的版本，以便在函数内部从键盘输入`firstName`、`lastName`、`currentCourseEnrolled`和`gpa`。
- en: Replace the `Print()` function that takes a `Student` from your previous solution
    to instead take a `const` `Student &` as a parameter for `Print()`.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你之前解决方案中的`Print()`函数替换为接受一个`const Student &`作为参数的函数。
- en: Create variables of type `Student` and of type `Student *` in `main()`. Now,
    call the various versions of `ReadData()`, and `Print()`. Do the pointer variables
    necessarily need to call the versions of these functions that accept pointers,
    and do the non-pointer variables necessarily need to call the versions of these
    functions that accept references? Why or why not?
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中创建`Student`类型和`Student *`类型的变量。现在，调用`ReadData()`和`Print()`的各种版本。指针变量是否必须调用接受指针的这些函数版本，非指针变量是否必须调用接受引用的这些函数版本？为什么或为什么不？
- en: 'Part 2: Implementing Object-Oriented Concepts in C++'
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：在C++中实现面向对象的概念
- en: The goal of this part is to understand how to implement OO designs using both
    C++ language features and proven programming techniques. C++ can be used for many
    paradigms of coding; programmers must strive to program in an OO fashion in C++
    (it’s not automatic). This is the largest section of the book, as understanding
    how to map language features and implementation techniques to OO concepts is paramount.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分的目标是理解如何使用C++语言特性和经过验证的编程技术来实现OO设计。C++可以用于许多编码范式；程序员必须努力在C++中以OO方式编程（这不是自动的）。这是本书最大的章节，因为理解如何将语言特性和实现技术映射到OO概念是至关重要的。
- en: The initial chapter in this section explores classes in great detail, beginning
    by describing the OO concepts of encapsulation and information hiding. Language
    features such as member functions, the `this` pointer, access regions in detail,
    constructors in detail (including the copy constructor, the member initialization
    list, and in-class initialization), destructor, qualifiers on member functions
    (`const`, `static`, and `inline`), and qualifiers on data members (`const` and
    `static`) are examined in depth.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的第一章详细探讨了类，从描述OO概念中的封装和信息隐藏开始。深入探讨了语言特性，如成员函数、`this`指针、详细访问区域、构造函数（包括拷贝构造函数、成员初始化列表和类内初始化）、析构函数、成员函数的限定符（`const`、`static`和`inline`），以及数据成员的限定符（`const`和`static`）。
- en: The next chapter in this section tackles single inheritance basics with the
    OO concepts of generalization and specialization, detailing inherited constructors
    through the member initialization list, the order of construction and destruction,
    and understanding inherited access regions. Final classes are explored. This chapter
    pushes deeper by exploring public versus protected and private base classes and
    how these language features change the OO meaning of inheritance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本节下一章探讨单继承的基本概念，使用OO概念中的泛化和特化，详细介绍了通过成员初始化列表继承的构造函数、构造和析构的顺序，以及理解继承的访问区域。探讨了最终类。本章通过探索公有与保护以及私有基类，以及这些语言特性如何改变继承的OO意义来进一步深入。
- en: The subsequent chapter delves into the OO concept of polymorphism with respect
    to understanding the concept as well as its implementation in C++ using virtual
    functions. The `virtual`, `override`, and `final` keywords are explored. Dynamic
    binding of an operation to a specific method is examined. The virtual function
    table is explored to explain runtime binding.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章深入探讨了面向对象的泛型概念，包括对这一概念的理解以及如何在C++中使用虚函数实现。探讨了`virtual`、`override`和`final`关键字。检查了将操作动态绑定到特定方法。通过探索虚函数表来解释运行时绑定。
- en: The next chapter explains abstract classes in detail, pairing the OO concept
    with its implementation using pure virtual functions. The OO concept of an interface
    (not explicitly in C++) is introduced and a method for implementation is reviewed.
    Casting up and down the inheritance hierarchy completes this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章详细解释了抽象类，将面向对象（OO）概念与其使用纯虚函数的实现相结合。介绍了接口的OO概念（在C++中不是显式定义的），并回顾了其实施方法。通过继承层次结构的向上和向下转换完成本章内容。
- en: The next chapter explores multiple inheritance and the potential issues that
    may arise from using this feature. Virtual base classes are detailed as well as
    the OO concept of a discriminator to help determine whether multiple inheritance
    is the best design for a given scenario or if another may exist.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章探讨了多重继承及其可能引发的问题。详细介绍了虚拟基类以及用于确定多重继承是否是特定场景的最佳设计的OO概念——区分器。如果存在其他可能的设计。
- en: The final chapter in this section introduces the concepts of association, aggregation,
    and composition and how to implement these common object relationships using pointers
    or references, sets of pointers, or embedded objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后一章介绍了关联、聚合和组合的概念，以及如何使用指针或引用、指针集或内嵌对象来实现这些常见的对象关系。
- en: 'This part comprises the following chapters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in Detail*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19087_05.xhtml#_idTextAnchor222)，*详细探索类*'
- en: '[*Chapter 6*](B19087_06.xhtml#_idTextAnchor314), *Implementing Hierarchies
    with Single Inheritance*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19087_06.xhtml#_idTextAnchor314)，*使用单继承实现层次结构*'
- en: '[*Chapter 7*](B19087_07.xhtml#_idTextAnchor366), *Utilizing Dynamic Binding
    through Polymorphism*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19087_07.xhtml#_idTextAnchor366)，*通过多态利用动态绑定*'
- en: '[*Chapter 8*](B19087_08.xhtml#_idTextAnchor399), *Mastering Abstract Classes*'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19087_08.xhtml#_idTextAnchor399)，*掌握抽象类*'
- en: '[*Chapter 9*](B19087_09.xhtml#_idTextAnchor426), *Exploring Multiple Inheritance*'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19087_09.xhtml#_idTextAnchor426)，*探索多重继承*'
- en: '[*Chapter 10*](B19087_10.xhtml#_idTextAnchor454), *Implementing Association,
    Aggregation, and Composition*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19087_10.xhtml#_idTextAnchor454)，*实现关联、聚合和组合*'
- en: 'Part 2: Implementing Object-Oriented Concepts in C++'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分：在C++中实现面向对象的概念
