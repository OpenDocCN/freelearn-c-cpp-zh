- en: Building an Obstacle-Avoiding Robot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建避障机器人
- en: Now that we can move the robot in multiple directions for specified periods
    of time, let's think about how to read values from an ultrasonic sensor in order
    to create a robot that can avoid obstacles. We will also use an LCD display and
    use it to print distance values.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让机器人以多个方向移动指定的时间，让我们考虑如何从超声波传感器中读取数值，以创建一个可以避开障碍物的机器人。我们还将使用LCD显示器，并用它来打印距离数值。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using an ultrasonic sensor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用超声波传感器
- en: Using an LCD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LCD
- en: Creating an obstacle-avoiding robot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个避障机器人
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The main hardware requirements for this chapter are the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要硬件要求如下：
- en: An HC-SR04 ultrasonic sensor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HC-SR04超声波传感器
- en: A 16x2 LCD or a 16x2 LCD with an I2C LCD module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16x2 LCD或带有I2C LCD模块的16x2 LCD
- en: A breadboard
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: One 1 KΩ resistor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个1KΩ的电阻
- en: One 2 KΩ resistor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个2KΩ的电阻
- en: 12-13 connecting wires
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12-13根连接线
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter04).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以从[https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter04)下载。
- en: Using an ultrasonic sensor
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超声波传感器
- en: 'An ultrasonic sensor is used to measure the distance between an obstacle or
    an object. An ultrasonic sensor consists of a transmitting transducer and a receiving
    transducer. The transmitting transducer (the trigger) emits **ultrasonic pulses**
    (also referred to as **ultrasonic sound**), which collide with nearby obstacles
    and are received by the receiving transducer (the echo). The sensor determines
    the distance between a target by measuring the time difference between the sending
    and the receiving of ultrasonic waves. The following diagram illustrates this
    process:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波传感器用于测量障碍物或物体之间的距离。超声波传感器由发射换能器和接收换能器组成。发射换能器（触发）发出**超声脉冲**（也称为**超声波**），与附近的障碍物碰撞并被接收换能器（回波）接收。传感器通过测量超声波发送和接收之间的时间差来确定目标之间的距离。下图说明了这个过程：
- en: '![](img/8f46574f-956b-4437-8c0e-980e47cc5d17.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f46574f-956b-4437-8c0e-980e47cc5d17.png)'
- en: 'The ultrasonic sensor we will use for this project is called an **HC-SR04 ultrasonic
    sensor**, which is one of the most widely-used ultrasonic sensors. It can measure
    distances in the range of 0–180 cm, with a resolution of about 0.3 cm. It has
    a frequency of around 40 KHz. The HC-SR04 sensor consists of the following four
    pins:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于此项目的超声波传感器称为**HC-SR04超声波传感器**，这是最广泛使用的超声波传感器之一。它可以测量0-180厘米范围内的距离，分辨率约为0.3厘米。它的频率约为40千赫。HC-SR04传感器由以下四个引脚组成：
- en: VCC pins
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VCC引脚
- en: A ground pin
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个地线引脚
- en: A trigger pin
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个触发引脚
- en: An echo pin
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个回波引脚
- en: 'A trigger pin is connected to the transmitting transducer, which transmits
    pulses, and an echo pin is connected to the receiving transducer, which receives
    the pulses, as shown in the photo of an HC-SR04 ultrasonic sensor:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 触发引脚连接到发射换能器，发射脉冲，回波引脚连接到接收换能器，接收脉冲，如HC-SR04超声波传感器的照片所示：
- en: '![](img/73133637-f38b-49e7-879f-c72f0e9be28f.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73133637-f38b-49e7-879f-c72f0e9be28f.png)'
- en: How an ultrasonic sensor measures distances
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超声波传感器如何测量距离
- en: 'Now that we''ve understood the basic workings of an ultrasonic sensor, let''s
    think about exactly how the ultrasonic sensor measures distance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了超声波传感器的基本工作原理，让我们思考一下超声波传感器如何测量距离：
- en: '![](img/609372a0-6067-4556-84bd-da0cd9761349.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/609372a0-6067-4556-84bd-da0cd9761349.png)'
- en: In order to measure distance, the ultrasonic sensor generates an ultrasonic
    pulse. To generate this ultrasonic pulse, the trigger pin is set in a **high**
    state for **10 microseconds**. This produces an *eight-cycle sonic burst* that
    travels at the *speed of sound*, which is received by the echo pin after colliding
    with an object. When this *eight-cycle sonic burst* is received, the echo will
    become high and it will remain high for a time duration that is proportional to
    the time taken for the ultrasonic pulse to reach the echo pin. If it took 20 microseconds
    for the ultrasonic pulse to reach the echo pin, the echo pin would remain high
    for 20 microseconds.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量距离，超声波传感器会产生超声脉冲。为了产生这个超声脉冲，触发引脚被设置为**高**状态，持续**10微秒**。这产生了一个以*声速*传播的*八周期声波*，在与物体碰撞后被回波引脚接收。当接收到这个*八周期声波*时，回波将变高，并且会保持高电平一段时间，这段时间与超声脉冲到达回波引脚的时间成比例。如果超声脉冲到达回波引脚花费了20微秒，回波引脚将保持高电平20微秒。
- en: The arithmetic equation for determining the time taken
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定所花时间的算术方程
- en: 'Let''s firstly look at the arithmetic equation for calculating distance, which
    is shown in the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下计算距离的算术方程，如下图所示：
- en: '![](img/ed84f223-6087-425e-8553-a3016e6073f4.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed84f223-6087-425e-8553-a3016e6073f4.png)'
- en: As indicated in the preceding diagram, let's imagine that the distance between
    the sensor and the object is 30 cm. The ultrasonic sensor travels at a speed of
    sound, which is 340 m/s, or 0.034 cm/μs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，假设传感器和物体之间的距离为30厘米。超声波传感器的传播速度为340米/秒，或0.034厘米/微秒。
- en: 'To calculate the time taken, we will use the following equation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算时间，我们将使用以下方程：
- en: '![](img/bc7241ea-190d-418e-b0a0-cf8d89d70a93.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc7241ea-190d-418e-b0a0-cf8d89d70a93.png)'
- en: 'If we move time to the left-hand side, and speed to the right-hand side, we
    get the following equation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将时间移到左边，速度移到右边，我们得到以下方程：
- en: '![](img/1ddea5b8-fca7-44ee-937c-afe3c1aea1c7.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ddea5b8-fca7-44ee-937c-afe3c1aea1c7.png)'
- en: 'If we input the preceding numbers, we get the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入前面的数字，我们得到以下结果：
- en: '![](img/5f5d9451-5fda-467f-8e7e-b60216141bd1.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f5d9451-5fda-467f-8e7e-b60216141bd1.png)'
- en: The result of this equation is that the time taken is 882.35 μs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程的结果是所花时间为882.35微秒。
- en: 'Even though the time value is 882.35 μs, the time duration for which the echo
    pin remains high will actually be double 882.35 μs, which is 1764.70 μs. This
    is because the ultrasonic sound first travels toward the object, and is received
    by the echo after bouncing back from the object. It travels the same distance
    twice: first from the sensor to the object, and then from the object to the sensor.
    If the time value is doubled, the distance value will also be doubled. We can
    modify the preceding equation to find the distance as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管时间值为882.35μs，但回波引脚保持高电平的时间持续值实际上将是882.35μs的两倍，即1764.70μs。这是因为超声波首先朝着物体传播，然后从物体反射回来后被回波接收。它传播的距离是相同的：首先从传感器到物体，然后从物体到传感器。如果时间值加倍，距离值也将加倍。我们可以修改上述方程来找到距离，如下所示：
- en: '![](img/9724eb93-b665-47db-8dd0-3e94527ccd68.png)![](img/c226d115-3dd0-4781-8a83-ba2a81032fd6.png)![](img/69e3b3b7-117e-46e2-a910-00d48243a1b2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9724eb93-b665-47db-8dd0-3e94527ccd68.png)![](img/c226d115-3dd0-4781-8a83-ba2a81032fd6.png)![](img/69e3b3b7-117e-46e2-a910-00d48243a1b2.png)'
- en: Make note of this equation, as we will use it later on to find the distance,
    once we get the time duration value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请记下这个方程，因为我们稍后将使用它来找到距离，一旦我们得到时间持续值。
- en: Wiring the ultrasonic sensor to the Raspberry Pi
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将超声波传感器连接到树莓派
- en: 'The HC-SRO4 sensor consists of four pins: **VCC**, **GND**, **trigger** (**Trig**),
    and **echo**, so the wiring connections of the RPi and the ultrasonic sensor should
    be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: HC-SRO4传感器由四个引脚组成：**VCC**、**GND**、**trigger**（**Trig**）和**echo**，因此RPi和超声波传感器的接线连接应如下所示：
- en: Connect the **VCC** pin of the sensor to pin number 4.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传感器的**VCC**引脚连接到引脚编号4。
- en: Connect the **GND** pin of the sensor to pin number 9.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传感器的**GND**引脚连接到引脚编号9。
- en: Connect the **Trig** pin of the sensor to wiringPi pin number 12.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传感器的**Trig**引脚连接到wiringPi引脚编号12。
- en: 'The **echo** pin of the sensor is connected to wiringPi pin number 13 via a
    voltage divider. The two resistors used in the voltage divider circuit have a
    resistance value of 1 KΩ (**R1**) and 2KΩ (**R2**), respectively. The voltage
    divider circuit is used to reduce the incoming 5V signal from the echo pin (to
    the RPi) to 3.3V. The wiring connection of RPi and HC-SR04 is shown in the following
    figure:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器的**echo**引脚通过电压分压器连接到wiringPi引脚编号13。电压分压器电路中使用的两个电阻的电阻值分别为1KΩ（**R1**）和2KΩ（**R2**）。电压分压器电路用于将来自回波引脚（到RPi）的输入5V信号降低到3.3V。RPi和HC-SR04的接线连接如下图所示：
- en: '![](img/4ac40083-049a-41fd-9ec6-39e8fa313c5f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ac40083-049a-41fd-9ec6-39e8fa313c5f.png)'
- en: 'The formula used to convert the incoming voltage to 3.3V is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将传入电压转换为3.3V的公式如下：
- en: '![](img/00e0025c-7d65-4bcc-90d3-77a0bbbe6d7b.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00e0025c-7d65-4bcc-90d3-77a0bbbe6d7b.png)'
- en: '**Vin** is the incoming voltage from the echo pin, **R1** is the first resistor,
    and **R2** is the second resistor. **Vin** is 5V, **R1** is 1 KΩ, and **R2** is
    2 KΩ:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vin**是来自回波引脚的输入电压，**R1**是第一个电阻，**R2**是第二个电阻。**Vin**为5V，**R1**为1KΩ，**R2**为2KΩ：'
- en: '![](img/357686da-8029-432c-8e80-b638b0fc8561.png)![](img/8c54b198-1b8e-47e7-be56-a0fdbe0eba7b.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/357686da-8029-432c-8e80-b638b0fc8561.png)![](img/8c54b198-1b8e-47e7-be56-a0fdbe0eba7b.png)'
- en: The HC-SR04 sensor program
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HC-SR04传感器程序
- en: After wiring up the HC-SR04 sensor to the Raspberry Pi, let's write a program
    for measuring the distance between an object from an ultrasonic sensor. The distance
    measurement program is called `DistanceMeasurement.cpp` and you can download it
    from the `Chapter04` folder of the GitHub repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将HC-SR04传感器连接到树莓派后，让我们编写一个程序来测量超声波传感器到物体之间的距离。距离测量程序名为`DistanceMeasurement.cpp`，您可以从GitHub存储库的`Chapter04`文件夹中下载。
- en: 'The code for measuring the distance is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 测量距离的代码如下：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we declared the `wiringPi`, `stdio`, and `iostream`
    libraries. After that, we declared the `std` namespace:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们声明了`wiringPi`、`stdio`和`iostream`库。之后，我们声明了`std`命名空间：
- en: After this, with the lines `#define trigger 12` and `#define echo 13`, we declare
    wiringPi pin number 12 as the trigger pin and wiringPi pin number 13 as the echo
    pin.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用`#define trigger 12`和`#define echo 13`这两行，我们将wiringPi引脚编号12声明为触发引脚，将wiringPi引脚编号13声明为回波引脚。
- en: Then, we declare two variables called `startTime` and `stopTime`, which are
    of the datatype `Long`.The `startTime` variable will record the time when the
    ultrasonic pulse is sent by the trigger pin and the `stopTime` variable will record
    the time when the ultrasonic pulse is received by the echo pin.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明了两个名为`startTime`和`stopTime`的变量，它们的数据类型为`Long`。`startTime`变量将记录触发引脚发送超声波脉冲的时间，`stopTime`变量将记录回波引脚接收超声波脉冲的时间。
- en: Inside the main function, the trigger pin is set up as `OUTPUT`, as it will
    generate the ultrasonic pulse. The echo pin is set up as `INPUT`, as it will receive
    the ultrasonic pulse.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数内，将触发引脚设置为`OUTPUT`，因为它将产生超声波脉冲。将回波引脚设置为`INPUT`，因为它将接收超声波脉冲。
- en: Inside a `for` loop, we set the trigger pin to `LOW` for 500 milliseconds, or
    0.5 seconds.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个`for`循环内，将触发引脚设置为500毫秒或0.5秒的`LOW`。
- en: To generate the ultrasonic pulse, the trigger pin is set to `HIGH` (`digitalWrite(trigger,HIGH)`)
    for 10 microseconds (`delayMicroseconds(10)`). After generating the pulse for
    10 μs, we set the trigger pin to `LOW` again.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了产生超声波脉冲，将触发引脚设置为`HIGH`（`digitalWrite(trigger,HIGH)`）持续10微秒（`delayMicroseconds(10)`）。产生了10微秒的脉冲后，我们再次将触发引脚设置为`LOW`。
- en: Next, we have two `while` loops, inside of which, there are two `micros()` functions.
    The `micros()` will return the current time value in milliseconds. The first while
    loop (`digitalRead(echo) == LOW`) will record the time at the beginning of the
    pulse, and the time duration in which the echo pin is `LOW` will be stored in
    the `startTime` variable.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有两个`while`循环，在这两个循环内，有两个`micros()`函数。`micros()`将以毫秒为单位返回当前时间值。第一个`while`循环（`digitalRead(echo)
    == LOW`）将记录脉冲开始时的时间，并将回波引脚为`LOW`的时间持续值存储在`startTime`变量中。
- en: When the pulse is received by the echo pin, the second `while` loop (`digitalRead(echo)
    == HIGH`*)* will execute. The `micros()` function inside this while loop will
    return the time value for the time taken for the ultrasonic pulse to reach the
    echo pin. This time value will be stored in the `stopTime` variable.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当回波引脚接收到脉冲时，第二个`while`循环(`digitalRead(echo) == HIGH`*)*将执行。此`while`循环中的`micros()`函数将返回超声脉冲到达回波引脚所花费的时间值。这个时间值将被存储在`stopTime`变量中。
- en: Next, to find the total time, we subtract the `startTime` from the `stopTime`
    and store this time value in the `totalTime` variable.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了找到总时间，我们将从`stopTime`中减去`startTime`，并将这个时间值存储在`totalTime`变量中。
- en: 'After finding out the `totalTime`, we use the following formula to calculate
    the distance:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`totalTime`后，我们使用以下公式来计算距离：
- en: '*float distance = (totalTime x 0.034)/2*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*float distance = (totalTime x 0.034)/2*'
- en: To display the distance value, we will use the `cout` statement. The `delay(2000);`
    command is called so that the distance value is printed after every two seconds.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示距离值，我们将使用`cout`语句。调用`delay(2000);`命令，以便每两秒打印一次距离值。
- en: After completing the code, you can compile and build it to check the final output.
    You can place an object in front of the sensor and the object's distance from
    the sensor will be displayed inside the console.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完成代码后，您可以编译和构建它以检查最终输出。您可以将一个物体放在传感器前面，物体距离传感器的距离将显示在控制台内。
- en: On my robot's chassis, there is an additional part on which I have fixed the
    ultrasonic sensor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器人底盘上，有一个额外的部件，我已经固定了超声波传感器。
- en: Using an LCD
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LCD
- en: 'A **liquid crystal display** (**LCD**) is an electronic display unit that is
    generally used in computers, TVs, smartphones, and cameras. A 16x2 LCD is a basic
    LCD module that is generally used in electronics or DIY projects. As the name
    suggests, a 16x2 LCD consists of 16 columns and 2 rows. This means that it has
    two lines, on each of which we can display a maximum of 16 characters. A 16x2
    LCD consists of 16 pins labeled from **VSS** to **K**, as shown in the following
    photo:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**液晶显示器**（LCD）是一种电子显示单元，通常用于计算机、电视、智能手机和相机。16x2 LCD是一个基本的LCD模块，通常用于电子或DIY项目。顾名思义，16x2
    LCD由16列和2行组成。这意味着它有两行，每行最多可以显示16个字符。16x2 LCD由从**VSS**到**K**标记的16个引脚组成，如下图所示：'
- en: '![](img/2131f109-6a0f-44de-85f9-b39236de6b2f.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2131f109-6a0f-44de-85f9-b39236de6b2f.png)'
- en: 'Each pin on the LCD can be described as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: LCD上的每个引脚可以描述如下：
- en: '| **Pin number** | **Name** | **How it works** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **引脚号** | **名称** | **工作原理** |'
- en: '| 1  | VSS (GND) | Ground pin. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 1  | VSS (GND) | 地线引脚。 |'
- en: '| 2 | VCC | The VCC pin requires 5V of power in order to turn on the LCD module.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 2 | VCC | VCC引脚需要5V电源才能打开LCD模块。 |'
- en: '| 3 | Vo | Using this pin, we can adjust the contrast of LCD. We can connect
    it to GND for maximum contrast. If you want to vary the contrast, connect it to
    the data pin of a potentiometer. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Vo | 使用此引脚，我们可以调整LCD的对比度。我们可以将它连接到GND以获得最大对比度。如果您想要改变对比度，将其连接到电位器的数据引脚。
    |'
- en: '| 4 | RS (RegisterSelect) | The LCD consist of two registers: the command register
    and the data register. The RS pin is used to switch between the command and the
    data register. It is set to HIGH (1) for the command register and LOW (0) for
    the data register. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 4 | RS (RegisterSelect) | LCD由两个寄存器组成：命令寄存器和数据寄存器。RS引脚用于在命令寄存器和数据寄存器之间切换。它被设置为高电平（1）以用于命令寄存器，低电平（0）用于数据寄存器。
    |'
- en: '| 5 | R/W (Read Write) | Set this pin to LOW to write to the register, or set
    it to HIGH to read from the register.  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 5 | R/W (Read Write) | 将此引脚设置为低电平以写入寄存器，或将其设置为高电平以从寄存器中读取。 |'
- en: '| 6 | E (Enable) | This pin enables the clock of the LCD, so that the LCD can
    execute instructions.  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 6 | E (Enable) | 此引脚使LCD的时钟启用，以便LCD可以执行指令。 |'
- en: '| 7 | D0 | Even though the LCD has eight data pins, we can either use it in
    eight-bit mode or four-bit mode. In eight-bit mode, all the eight data pins (D0-D7)
    are connected to the RPi pins. In four-bit mode, only four pins (D4-D7) are connected
    to the RPi. We will use the LCD in four-bit mode in this case, so that fewer wiringPi
    pins are occupied.   |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 7 | D0 | 尽管LCD有八个数据引脚，我们可以将其用于八位模式或四位模式。在八位模式中，所有八个数据引脚（D0-D7）都连接到RPi引脚。在四位模式中，只有四个引脚（D4-D7）连接到RPi。在这种情况下，我们将使用四位模式的LCD，以便占用更少的wiringPi引脚。
    |'
- en: '| 8 | D1 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 8 | D1 |'
- en: '| 9 | D2 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 9 | D2 |'
- en: '| 10 | D3 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 10 | D3 |'
- en: '| 11 | D4 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 11 | D4 |'
- en: '| 12 | D5 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 12 | D5 |'
- en: '| 13 | D6 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 13 | D6 |'
- en: '| 14 | D7 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 14 | D7 |'
- en: '| 15 | A (Anode) | +5V pin for LCD backlight. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 15 | A (Anode) | LCD背光的+5V引脚。 |'
- en: '| 16 | K (Cathode) | GND pin for LCD backlight. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 16 | K (Cathode) | LCD背光的GND引脚。 |'
- en: Since a 16x2 LCD has a total of 16 pins, connecting all the pins correctly to
    the Raspberry Pi can sometimes be an issue. If you make a mistake and a pin that
    needs to be connected to D0 gets connected to D1, for example, you might get incorrect
    output.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于16x2 LCD有16个引脚，正确连接所有引脚到树莓派有时可能会有问题。如果您犯了一个错误，例如将需要连接到D0的引脚连接到D1，您可能会得到不正确的输出。
- en: To avoid this potential confusion, you can choose to purchase an **I2C LCD adapter
    module** for a 16x2 LCD. This module takes the 16 pins of LCD as an input, and
    provides only 4 pins as an output (VCC, GND, SDA, SCL). This means that you only
    need to connect 4 pins to the Raspberry Pi, instead of 16 pins.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种潜在的混淆，您可以选择购买一个16x2 LCD的**I2C LCD适配器模块**。该模块将LCD的16个引脚作为输入，并提供4个引脚作为输出（VCC、GND、SDA、SCL）。这意味着您只需要连接4个引脚到树莓派，而不是16个引脚。
- en: 'The 16x2 LCDs with I2C LCD adapters soldered to them are also available, which
    can save you some time. The 16x2 LCD that I''m using for this project already
    has an I2C LCD adapter soldered to it, as shown in the following picture:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有带有I2C LCD适配器焊接的16x2 LCD，这可以节省一些时间。我用于这个项目的16x2 LCD已经焊接了I2C LCD适配器，如下图所示：
- en: '![](img/d8ddc43e-28b8-4c72-983d-55bc3a128e5e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8ddc43e-28b8-4c72-983d-55bc3a128e5e.png)'
- en: In the following sections, we'll understand the wiring connections and how to
    program both a normal LCD and an LCD with an I2C LCD adapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将了解接线连接以及如何编程普通LCD和带有I2C LCD适配器的LCD。
- en: I will refer to the **16x2 LCD with the I2C LCD adapter** as **I2C LCD** to
    avoid complication.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我将**16x2 LCD与I2C LCD适配器**称为**I2C LCD**，以避免复杂化。
- en: Wiring the 16x2 LCD to the Raspberry Pi
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将16x2 LCD连接到Raspberry Pi
- en: 'To connect the 16x2 LCD to the Raspberry Pi, you will need a mini breadboard,
    as there are a couple of pins that need to be connected to the VCC and the GND.
    The wiring connections of RPi and the 16x2 LCD are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要将16x2 LCD连接到Raspberry Pi，您将需要一个迷你面包板，因为有几个引脚需要连接到VCC和GND。 RPi和16x2 LCD的接线连接如下：
- en: '![](img/bc131ce7-56ca-450b-8f64-8a9b22acb8cb.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc131ce7-56ca-450b-8f64-8a9b22acb8cb.png)'
- en: 'First, connect pin number 2 or pin number 4 from the Raspberry Pi to one horizontal
    pin of the breadboard, so that we can use that row as a VCC row. Similarly, connect
    one ground pin from the Raspberry Pi to a horizontal pin of the breadboard, so
    that we can use that row as the ground row. Next, follow these instructions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将Raspberry Pi的引脚号2或引脚号4连接到面包板的一个水平引脚，以便我们可以将该行用作VCC行。同样，将Raspberry Pi的一个地引脚连接到面包板的一个水平引脚，以便我们可以将该行用作地行。接下来，按照以下说明进行操作：
- en: Connect the VSS (GND) pin to the ground row of breadboard
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将VSS（GND）引脚连接到面包板的地行
- en: Connect the VCC pin to the VCC row of the breadboard
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将VCC引脚连接到面包板的VCC行
- en: Connect the V0 pin to the ground row of breadboard
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将V0引脚连接到面包板的地行
- en: Connect the **register select** (**RS**) pin to wiringPi pin number 22 of the
    RPi
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**寄存器选择**（RS）引脚连接到RPi的wiringPi引脚号22
- en: Connect the R/W pin to the ground row of the breadboard, as we will write off
    the LCD's register
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将R/W引脚连接到面包板的地行，因为我们将关闭LCD的寄存器
- en: Connect the enable pin to wiringPi pin number 26 of the RPi
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使能引脚连接到RPi的wiringPi引脚号26
- en: We will use the LCD in four-bit mode, so pins D0 to D3 will remain unconnected
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用四位模式的LCD，因此D0到D3引脚将保持未连接状态
- en: Pin D4 should be connected to wiringPi pin number 24 of the RPi
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引脚D4应连接到RPi的wiringPi引脚号24
- en: Pin D5 should be connected to wiringPi pin number 25 of the RPi
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引脚D5应连接到RPi的wiringPi引脚号25
- en: Pin D6 should be connected to wiringPi pin number 27 of the RPi
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引脚D6应连接到RPi的wiringPi引脚号27
- en: Pin D7 should be connected to wiringPi pin number 28 of the RPi
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引脚D7应连接到RPi的wiringPi引脚号28
- en: Connect the anode pin to the VCC row of the breadboard
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将阳极引脚连接到面包板的VCC行
- en: Connect the cathode pin to the ground row of the breadboard
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将阴极引脚连接到面包板的地行
- en: 'For testing the LCD program, add `-lwiringPiDev` command inside Compile and
    Build option by opening Build | Set Build Commands as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试LCD程序，在“Build | Set Build Commands”中打开Build选项，并在Compile and Build选项中添加`-lwiringPiDev`命令，如下截图所示：
- en: '![](img/b116e0b7-8c82-44f2-9b5e-e8c153012deb.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b116e0b7-8c82-44f2-9b5e-e8c153012deb.png)'
- en: After connecting the 16X2 LCD to the RPi, let's program the LCD.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将16X2 LCD连接到RPi后，让我们编程LCD。
- en: Programming the LCD
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程LCD
- en: We will write two programs using the normal 16x2 LCD. In the first program,
    we will print a value on the 16x2 LCD. In the second program, we will print the
    ultrasonic sensor value on the LCD screen. The first program is called `LCDdisplay.cpp`
    and you can download it from the GitHub repository of `Chapter04`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用普通的16x2 LCD编写两个程序。在第一个程序中，我们将在16x2 LCD上打印一个值。在第二个程序中，我们将在LCD屏幕上打印超声波传感器值。第一个程序称为`LCDdisplay.cpp`，您可以从`Chapter04`的GitHub存储库中下载。
- en: The LCD program
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LCD程序
- en: 'After connecting the LCD to the Raspberry Pi, let''s examine the program for
    printing the value on the LCD, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将LCD连接到Raspberry Pi后，让我们检查在LCD上打印值的程序，如下所示：
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the details of the preceding program:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面程序的详细信息：
- en: First, we call the `LCD.h` library. The `LCD.h` library consists of all the
    important functions that we can use to print, position, and move text, as well
    as clear the LCD screen.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们调用`LCD.h`库。`LCD.h`库包含了我们可以用来打印、定位和移动文本以及清除LCD屏幕的所有重要函数。
- en: Next, we define pin numbers RS, E, D4, D5, D6, and D7.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义引脚号RS、E、D4、D5、D6和D7。
- en: After this, inside the `lcdInit` function, the first number, which is `2`, represents
    the number of rows in the LCD, while the number `16` represents the number of
    columns. The number `4` means that we are using the LCD in four-bit mode. Next,
    we have the RS and E pins, and finally, we have the four data pins. Since we haven't
    connected the D0, D1, D2, and D3 data pins to the RPi, we have four zeros at the
    end.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lcdInit`函数内部，第一个数字`2`代表LCD中的行数，而数字`16`代表列数。数字`4`表示我们正在使用四位模式的LCD。接下来是RS和E引脚，最后是四个数据引脚。由于我们没有将D0、D1、D2和D3数据引脚连接到RPi，因此在末尾有四个零。
- en: 'The `lcdPuts` is used to print data on the LCD. It takes two parameters as
    input: the `fd` variable and the text value that needs to be displayed.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lcdPuts`用于在LCD上打印数据。它有两个输入参数：`fd`变量和需要显示的文本值。'
- en: After completing this code, you can compile and build the code to test the final
    output.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此代码后，您可以编译和构建代码以测试最终输出。
- en: In the output, you will notice that the text output will start from column one,
    instead of column zero.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出中，您会注意到文本输出将从第一列开始，而不是从第零列开始。
- en: 'To position the text on the extreme left side, or column `0`, row `0`, we need
    to use the `lcdPosition()` function. The `lcdPosition(fd, column position, row
    position)` function consists of three parameters, and it should be written before
    the `lcdPuts` function as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将文本定位在极左侧，或列`0`，行`0`，我们需要使用`lcdPosition()`函数。`lcdPosition(fd,列位置,行位置)`函数由三个参数组成，并且应该在`lcdPuts`函数之前写入，如下所示：
- en: '[PRE2]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the text is not positioned at column 0 and row 0, restart your RPi and test
    the code once again.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本未定位在列0和行0，请重新启动RPi并再次测试代码。
- en: The LCD and the ultrasonic sensor program
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LCD和超声波传感器程序
- en: 'After printing a simple text value on the LCD, let''s take a look at how to
    view the ultrasonic distance value on the LCD screen. The wiring connection of
    the HC-SR04 ultrasonic sensor, the 16x2 LCD, and the RPi are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在LCD上打印简单的文本值后，让我们看看如何在LCD屏幕上查看超声波距离值。HC-SR04超声波传感器、16x2 LCD和RPi的接线连接如下：
- en: '![](img/50d44944-2bea-4121-b45f-bb6aeec24483.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50d44944-2bea-4121-b45f-bb6aeec24483.png)'
- en: 'The LCD connections to the RPi remain the same. The ultrasonic trigger pin
    is connected to wiringPi pin number 12 and the echo pin is connected to wiringPi
    pin number 13\. Let''s now take a look at the program. This program is called
    `LCDdm.cpp` (**dm** is short for **distance measurement**) and you can download
    it from the GitHub repository of `Chapter04`. The `LCDdm.cpp` program is a combination
    of the `LCDdisplay.cpp` and `DistanceMeasurement.cpp` programs:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: LCD连接到RPi保持不变。超声波触发引脚连接到wiringPi引脚12号，回波引脚连接到wiringPi引脚13号。现在让我们看看程序。该程序称为`LCDdm.cpp`（**dm**代表**距离测量**），您可以从`Chapter04`的GitHub存储库中下载。`LCDdm.cpp`程序是`LCDdisplay.cpp`和`DistanceMeasurement.cpp`程序的组合：
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, after finding out the distance value, we position the
    cursor in row zero, column zero, using the `lcdPosition(fd, 0, 0);` command. Next,
    with the `lcdPuts(fd, "Distance: ")` code, we are displaying the distance text.
    After this, we position the cursor in column zero and row one. Finally, to print
    the distance value, we use the `lcdPrintf(fd, distance);` command. Since we have
    set the delay to two seconds, the distance value will be printed every two seconds.
    It will then be cleared (`clear()`) and replaced with a new value.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述代码中，找到距离值后，我们使用`lcdPosition(fd, 0, 0);`命令将光标定位在第零行，第零列。接下来，使用`lcdPuts(fd,
    "Distance: ")`代码，我们显示距离文本。然后，我们将光标定位在第一行的第零列。最后，使用`lcdPrintf(fd, distance);`命令打印距离值。由于我们将延迟设置为两秒，因此每两秒将打印一次距离值。然后它将被清除（`clear()`）并替换为新值。'
- en: What is the I2C protocol?
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I2C协议是什么？
- en: The I2C protocol is used in many electronic devices. We use it to connect one
    master device to multiple slave devices, or multiple master devices to multiple
    slave devices. The main advantage of the I2C protocol is that the master needs
    only two pins to communicate with multiple slave devices.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: I2C协议用于许多电子设备。我们用它来连接一个主设备到多个从设备，或者多个主设备到多个从设备。I2C协议的主要优势在于主设备只需要两个引脚与多个从设备通信。
- en: 'In an I2C bus, all devices are connected in parallel to the same two-wire bus.
    We can connect a total of 128 devices using 7-bit addressing, and a total of 
    1,024 devices using 10-bit addressing, as shown in the following diagram:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在I2C总线中，所有设备都并行连接到相同的双线总线。我们可以使用7位寻址连接总共128个设备，使用10位寻址连接总共1,024个设备，如下图所示：
- en: '![](img/cb12dc27-aadc-4936-a5a2-5e1816b59d8f.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb12dc27-aadc-4936-a5a2-5e1816b59d8f.png)'
- en: 'Each device connected using the I2C protocol has a unique ID, which makes it
    possible to communicate with multiple devices. The two main pins in the I2C protocol
    are the **Serial Data** (**SDA**) pin and the **Serial Clock** (**SCA**) pin:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用I2C协议连接的每个设备都有一个唯一的ID，这使得可以与多个设备通信。I2C协议中的两个主要引脚是**串行数据**（SDA）引脚和**串行时钟**（SCA）引脚：
- en: '**SDA**: The SDA line is used for transferring data.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDA**：SDA线用于传输数据。'
- en: '**SCL**: The SCL is generated by the master device. It is a clock signal that
    synchronizes the data transfer between the devices connected in the I2C.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCL**：SCL由主设备生成。它是一个时钟信号，用于同步连接在I2C中的设备之间的数据传输。'
- en: Now that we've understood the basics of the I2C protocol, let's look at how
    to connect the I2C LCD and the Raspberry Pi.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了I2C协议的基础知识，让我们看看如何连接I2C LCD和树莓派。
- en: Wiring the I2C LCD and the Raspberry Pi
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接I2C LCD和树莓派
- en: 'On the Raspberry Pi, physical pin number 3 is the SDA pin, while physical pin
    number 5 is the SCA pin, as shown in the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派上，物理引脚3是SDA引脚，而物理引脚5是SCA引脚，如下图所示：
- en: '![](img/1a26ae87-880f-47ed-bd0d-4202a77002d3.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a26ae87-880f-47ed-bd0d-4202a77002d3.png)'
- en: 'The following is the details of connecting LCD with the RPi:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是连接LCD与RPi的详细信息：
- en: Connect pin number 3 of the Raspberry Pi to the SDA pin of the LCD
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的3号引脚连接到LCD的SDA引脚
- en: Connect pin number 5 of the Raspberry Pi to the SCA pin of the LCD
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的5号引脚连接到LCD的SCA引脚
- en: Connect the GND pin of the LCD to the GND pin of the RPi
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LCD的GND引脚连接到RPi的GND引脚
- en: Connect the VCC pin of the LCD to pin number 2 or pin number 4 of the Raspberry
    Pi
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LCD的VCC引脚连接到树莓派的2号引脚或4号引脚
- en: Programming the LCD with the I2C LCD module
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用I2C LCD模块编程LCD
- en: 'Before writing the program, we first need to enable the I2C protocol from the
    Raspberry Pi configuration. To do this, open the command window and type in the
    following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序之前，我们首先需要从树莓派配置中启用I2C协议。为此，请打开命令窗口并输入以下命令：
- en: '[PRE4]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside configurations, open Interfacing Options, shown as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，打开接口选项，如下所示：
- en: '![](img/3f02ab85-9905-400a-a784-589eb3e4ec2c.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f02ab85-9905-400a-a784-589eb3e4ec2c.png)'
- en: 'Next, open the I2C option, as shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开I2C选项，如下面的屏幕截图所示：
- en: '![](img/2d20a283-291f-4fef-b936-bedda3ee1613.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d20a283-291f-4fef-b936-bedda3ee1613.png)'
- en: 'Select the Yes option and press *Enter* to enable I2C, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“是”选项并按*Enter*键启用I2C，如下所示：
- en: '![](img/b31f95ca-9171-4eae-9d40-2e3cfca6d1a7.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b31f95ca-9171-4eae-9d40-2e3cfca6d1a7.png)'
- en: 'After enabling I2C, select the Ok option and exit the configuration, shown
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 启用I2C后，选择“确定”选项并退出配置，如下所示：
- en: '![](img/9d1c032c-dd09-46ef-b8b1-3299651b5b8c.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d1c032c-dd09-46ef-b8b1-3299651b5b8c.png)'
- en: After enabling the I2C protocol inside your Raspberry Pi, let's write the program
    to print values to the LCD. The program is called `I2CLCD.cpp` and you can download
    it from the GitHub repository of `Chapter04`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派内部启用I2C协议后，让我们编写程序将值打印到LCD上。该程序称为`I2CLCD.cpp`，您可以从`Chapter04`的GitHub存储库中下载。
- en: 'Since this LCD has an I2C module attached to it, the `LCD.h` library that we
    used in the previous LCD program will not work in this program. Instead, I have
    created five main functions that will initialize the LCD, print messages, and
    clear the LCD screen, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个LCD连接了一个I2C模块，我们之前用过的`LCD.h`库在这个程序中将无法使用。相反，我创建了五个主要函数，用于初始化LCD，打印消息和清除LCD屏幕，如下所示：
- en: '`init_lcd()`: This function will initialize (set up) the LCD'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_lcd()`: 该函数将初始化（设置）LCD'
- en: '`printmessage()`: This function is used to print a string on the LCD'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printmessage()`: 该函数用于在LCD上打印字符串'
- en: '`printInt()`: This function is used to display integer values'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printInt()`: 该函数用于显示整数值'
- en: '`printfloat()`: This function is used to display float values'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printfloat()`: 该函数用于显示浮点值'
- en: '`clear()`: This function will clear the LCD screen'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 该函数将清除LCD屏幕'
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We start the program by declaring the `wiringPiI2C.h` library. Next, we have
    the `wiringPi` library and two other libraries, which are standard C libraries.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过声明`wiringPiI2C.h`库来启动程序。接下来，我们有`wiringPi`库和另外两个标准C库。
- en: After this, with the `#define I2C_DEVICE_ADDRESS 0x27` command, we define the
    I2C device address, which is `0x27`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`#define I2C_DEVICE_ADDRESS 0x27`命令，我们定义了I2C设备地址，即`0x27`。
- en: 'The `0x80` command represents the first row: row zero, column zero. With the  `#define
    firstrow 0x80` command, we initialize the first line of the LCD.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0x80`命令代表第一行：第零行，第零列。使用`#define firstrow 0x80`命令，我们初始化LCD的第一行。'
- en: 'Similarly, `0xC0` represents the second row of LCD: row one, column zero. With
    the `#define secondrow 0xC0` command, we initialize the second line of the LCD.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`0xC0`代表LCD的第二行：第一行，第零列。使用`#define secondrow 0xC0`命令，我们初始化LCD的第二行。
- en: 'Next, inside the `lcdaddr` variable, we will store the I2C LCD''s address,
    as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`lcdaddr`变量内，我们将存储I2C LCD的地址，如下所示：
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inside the `main()` function, we store the device address inside the `lcdaddr`
    variable.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数内，我们将设备地址存储在`lcdaddr`变量中。
- en: After this, we initialize, or set up the LCD with the `init_lcd();` command.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`init_lcd();`命令初始化LCD。
- en: Next, in the `for` loop, we move the cursor to the first row with the `moveCursor(firstrow);`command.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`for`循环中，我们使用`moveCursor(firstrow);`命令将光标移动到第一行。
- en: Now, since the cursor is in the first row, the `LCD OUTPUT` text inside the
    `printmessage("LCD OUTPUT"`code will be printed on the first row.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于光标在第一行，所以在`printmessage("LCD OUTPUT"`代码中的`LCD OUTPUT`文本将被打印在第一行。
- en: The cursor is then moved to the second row with the `moveCursor(secondrow)` command.
    The `USING I2C` text is printed on that row.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`moveCursor(secondrow)`命令将光标移动到第二行。在该行上打印`USING I2C`文本。
- en: The text on the first and second rows will be visible for two seconds, after
    which time the LCD screen will be cleared with the `clear()` command.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行和第二行的文本将在两秒内可见，之后LCD屏幕将被`clear()`命令清除。
- en: After this, with the next four lines, an integer, `314`, will be printed on
    the first row. The `printInt(iNumber)` function is used to display the integer
    value.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用接下来的四行，在第一行上打印一个整数`314`。`printInt(iNumber)`函数用于显示整数值。
- en: Similarly, the `printFloat(iFloat)` function is used to display the float value.
    In the next four lines, `float 3.14` will be printed on the second row.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`printFloat(iFloat)`函数用于显示浮点值。在接下来的四行中，将在第二行上打印`float 3.14`。
- en: After this, we again clear the LCD.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们再次清除LCD。
- en: This is how we can display string, numeric, and float values inside our I2C LCD.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在I2C LCD内显示字符串，数字和浮点值。
- en: The I2C LCD and the ultrasonic sensor program
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I2C LCD和超声波传感器程序
- en: 'To read the ultrasonic sensor value inside an I2C LCD, connect the ultrasonic
    sensor and I2C LCD to the RPi. From the GitHub repository of `Chapter04`, you
    can download the complete program called `I2CLCDdm.cpp` program. The wiring connections
    of I2C LCD, ultrasonic sensor, and the RPi is shown in the following figure:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要在I2C LCD内读取超声波传感器值，请将超声波传感器和I2C LCD连接到RPi。您可以从`Chapter04`的GitHub存储库中下载名为`I2CLCDdm.cpp`的完整程序。I2C
    LCD，超声波传感器和RPi的接线连接如下图所示：
- en: '![](img/870f16ba-4b07-4833-824d-4930cd0e0704.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/870f16ba-4b07-4833-824d-4930cd0e0704.png)'
- en: 'This `I2CLCDdm.cpp`program is basically a combination of the `DistanceMeasurement.cpp`
    and the `I2CLCD.cpp` programs. In this program, after declaring all the necessary
    libraries and variables related to the ultrasonic sensor and the I2C LCD below
    the `cout << "Distance: "<<distance << "cm" << endl` line, we need to add the
    following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '这个`I2CLCDdm.cpp`程序基本上是`DistanceMeasurement.cpp`和`I2CLCD.cpp`程序的组合。在这个程序中，在`cout
    << "Distance: "<<distance << "cm" << endl`行下面声明了与超声波传感器和I2C LCD相关的所有必要库和变量，我们需要添加以下代码：'
- en: '[PRE7]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the first row, the text `DISTANCE` will be printed using the `printmessage("DISTANCE")` command.
    After that, on the second row, the distance value will be printed using the `printFloat(distance)` command,
    since the code is still on the second line. With the `printmessage(" cm")` command,
    the `cm` text will be printed beside the distance value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`printmessage("DISTANCE")`命令将在第一行上打印文本`DISTANCE`。之后，在第二行上，使用`printFloat(distance)`命令将打印距离值，因为代码仍在第二行上。使用`printmessage("
    cm")`命令，`cm`文本将在距离值旁边打印出来。
- en: The distance value inside the console and the I2C LCD will be visible for two
    seconds. Next, with the `clear()` function, the old distance value will be cleared
    and replaced with a new value. In the console, however, the new value will be
    displayed on the next line.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台内的距离值和I2C LCD将在两秒内可见。接下来，使用`clear()`函数，旧的距离值将被清除并替换为新值。然而，在控制台中，新值将显示在下一行。
- en: Building an obstacle-avoiding robot
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建避障机器人
- en: In this case, our robot will move freely in a given space, but as soon as it
    comes near to an object or an obstacle, it will turn or move backward, thus avoiding
    the obstacle. In this kind of project, we generally use an ultrasonic sensor.
    As the robot moves, the ultrasonic sensor keeps measuring the distance it is away
    from objects. When the sensor detects that the distance value is very low, and
    the robot may collide with the nearby object, it will command the robot to change
    direction, thus avoiding the obstacle.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的机器人将在给定空间内自由移动，但一旦靠近物体或障碍物，它将转向或向后移动，从而避开障碍物。在这种项目中，我们通常使用超声波传感器。当机器人移动时，超声波传感器不断测量它与物体的距离。当传感器检测到距离值非常低，并且机器人可能与附近物体碰撞时，它将命令机器人改变方向，从而避开障碍物。
- en: 'To create an obstacle-avoiding robot, you first need to mount the ultrasonic
    sensor on the robot. Inside my robotic kit, there is already an attachment that
    allows me to mount the ultrasonic sensor on the robot. This attachment looks as
    follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个避障机器人，您首先需要将超声波传感器安装在机器人上。在我的机器人套件中，已经有一个附件可以让我将超声波传感器安装在机器人上。这个附件如下所示：
- en: '![](img/eb5a56d9-8248-406f-b183-c67105b56321.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb5a56d9-8248-406f-b183-c67105b56321.png)'
- en: 'After attaching the ultrasonic sensor on the robot, the final assembly looks
    as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器人上安装超声波传感器后，最终装配如下所示：
- en: '![](img/3314bcae-f4eb-4046-b225-99fc138a42a4.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3314bcae-f4eb-4046-b225-99fc138a42a4.png)'
- en: Wiring connections
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接线连接
- en: 'The ultrasonic sensor''s trigger pin is connected to wiringPi pin number 12,
    while the echo pin is connected to wiringPi pin number 13 via the voltage divider
    circuit. The VCC pin of the ultrasonic sensor is connected to physical pin 2 (5V)
    of RPi, and the ground pin of the ultrasonic sensor is connected to physical pin
    6 of RPi. The remaining connections are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波传感器的触发引脚连接到wiringPi引脚号12，而回波引脚通过电压分压电路连接到wiringPi引脚号13。超声波传感器的VCC引脚连接到RPi的物理引脚2（5V），超声波传感器的地线引脚连接到RPi的物理引脚6。其余连接如下：
- en: '**WiringPi pin 0** is connected to the **IN1 pin** of the L298N motor driver.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WiringPi引脚0**连接到L298N电机驱动器的**IN1引脚**。'
- en: '**WiringPi pin 2** is connected to the **IN2 pin** of the L298N motor driver.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WiringPi引脚2**连接到L298N电机驱动器的**IN2引脚**。'
- en: '**WiringPi pin 3** is connected to the **IN3 pin** of the L298N motor driver.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WiringPi引脚3**连接到L298N电机驱动器的**IN3引脚**。'
- en: '**WiringPi pin 4** is connected to the **IN4 pin** of the L298N motor driver.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WiringPi引脚4**连接到L298N电机驱动器的**IN4引脚**。'
- en: The **motor driver's ground pin** is connected to the **physical pin 3** of
    RPi.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电机驱动器的地线引脚**连接到RPi的**物理引脚3**。'
- en: I'm using an I2C LCD, so the **SDA pin** of the I2C LCD is connected to the
    **physical pin 3 of the RPi**, and the **SCL pin** is connected to the **physical
    pin 5**. The **ground pin of I2C LCD** is connected to **physical pin 9**, and
    the **VCC pin of I2C LCD** is connected to **physical pin 4** of RPi.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我正在使用I2C LCD，因此I2C LCD的**SDA引脚**连接到**RPi的物理引脚3**，**SCL引脚**连接到**物理引脚5**。**I2C
    LCD的地线引脚**连接到**物理引脚9**，**I2C LCD的VCC引脚**连接到RPi的**物理引脚4**。
- en: Connecting the LCD display to the robot is totally up to you. If you have sufficient
    space on the robot where the LCD can be placed, go ahead and add it. If not, this
    is not a necessity.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将LCD显示器连接到机器人完全取决于您。如果机器人上有足够的空间可以放置LCD，那就加上去。如果没有，这不是必需的。
- en: Programming the obstacle-avoiding robot
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程避障机器人
- en: 'In this program, we will first find out the distance of a nearby object using
    the ultrasonic sensor. Next, we will create an `if` condition that monitors the
    distance value. If the distance goes below a certain value, we will command the
    robot to take a turn. Otherwise, the robot will keep moving forward. You can download
    the complete code called `ObstacleAvoiderRobot.cpp` from `Chapter04` in the GitHub repository:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将首先使用超声波传感器找出附近物体的距离。接下来，我们将创建一个`if`条件来监测距离数值。如果距离低于某个数值，我们将命令机器人转向。否则，机器人将继续向前移动。您可以从GitHub存储库的`Chapter04`中下载名为`ObstacleAvoiderRobot.cpp`的完整代码：
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code, if the **distance** is **greater** than **7 cm**, the robot will
    keep moving forward. Now, as long as the obstacle is not present, the LCD will
    display the message `No Obstacle` on the second row. If an obstacle is detected,
    the robot will first make a radial left turn for 0.5 seconds and the I2C LCD will
    display the `Obstacle detected` text on the second row. You can increase or decrease
    the delay value depending on the speed of your motors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，如果**距离**大于**7厘米**，机器人将继续向前移动。只要障碍物不存在，LCD将在第二行显示`No Obstacle`的消息。如果检测到障碍物，机器人将首先进行0.5秒的径向左转，I2C
    LCD将在第二行显示`Obstacle detected`的文本。您可以根据电机速度增加或减少延迟值。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have looked at how an ultrasonic sensor works, and we wrote
    a program to measure the distance values. Next, we programmed the 16x2 LCD, and
    read the ultrasonic distance value using it. We also looked at the I2C LCD, which
    takes the 16 LCD pin as an input, and provides four pins as an output, thus simplifying
    the wiring connections. Finally, we fitted the ultrasonic sensor on our robot
    to create our obstacle-avoiding robot. This robot moved freely when there was
    no obstacle near it, and if it approached an obstacle, it would avoid it by taking
    a turn.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了超声波传感器的工作原理，并编写了一个程序来测量距离值。接下来，我们编程16x2 LCD，并使用它读取超声波距离值。我们还研究了I2C
    LCD，它将16个LCD引脚作为输入，并提供四个引脚作为输出，从而简化了接线连接。最后，我们将超声波传感器安装在我们的机器人上，创建了我们的避障机器人。这个机器人在附近没有障碍物时自由移动，如果靠近障碍物，它将通过转向来避开。
- en: In the next chapter, we are going to create two different types of PC-controlled
    robot. In the first PC-controlled robot, we will use a library called **ncurses**
    and use the keyboard as an input. In the second PC-controlled robot, we will create
    UI buttons using QT, and then use them to move the robot.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建两种不同类型的PC控制机器人。在第一个PC控制机器人中，我们将使用一个叫做**ncurses**的库，并使用键盘作为输入。在第二个PC控制机器人中，我们将使用QT创建UI按钮，然后使用它们来移动机器人。
- en: Questions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What type of pulse does an ultrasonic sensor send?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超声波传感器发送什么类型的脉冲？
- en: What does LCD stand for?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LCD代表什么？
- en: Up to what distance can an HC-SR04 ultrasonic sensor measure?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HC-SR04超声波传感器可以测量到多远的距离？
- en: Which row and column would the `lcdPosition(fd, 4,1)` command start printing
    the text?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lcdPosition(fd, 4,1)`命令会从哪一行和哪一列开始打印文本？'
- en: What are the functions of the anode pin (pin 15) and the cathode pin (pin 16)
    pin on an LCD?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LCD的阳极引脚（引脚15）和阴极引脚（引脚16）在LCD上有什么功能？
