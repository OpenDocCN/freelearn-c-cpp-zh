- en: Chapter 3. Qt GUI Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. Qt 图形界面编程
- en: '*This chapter will help you learn how to use Qt to develop applications with
    a graphical user interface using the Qt Creator IDE. We will get familiar with
    the core Qt functionality, property system, and the signals and slots mechanism
    that we will later use to create complex systems such as games. We will also cover
    the various actions and resource system of Qt. By the end of this chapter, you
    will be able to write your own programs that communicate with the user through
    windows and widgets.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*本章将帮助你学习如何使用 Qt Creator IDE 开发具有图形用户界面的应用程序。我们将熟悉 Qt 的核心功能、属性系统以及我们将用于创建复杂系统（如游戏）的信号和槽机制。我们还将介绍
    Qt 的各种操作和资源系统。到本章结束时，你将能够编写自己的程序，通过窗口和控件与用户进行通信。*'
- en: Windows and dialogs
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口和对话框
- en: The most basic skill that you need to learn is creating windows, showing them
    on a screen, and managing their content.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要学习的最基本技能是创建窗口，在屏幕上显示它们，并管理它们的内容。
- en: Creating a Qt project
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Qt 项目
- en: The first step to develop an application with Qt Creator is to create a project
    using one of the templates provided by the editor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt Creator 开发应用程序的第一步是使用编辑器提供的模板之一创建一个项目。
- en: Time for action – creating a Qt Desktop project
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建一个 Qt 桌面项目
- en: 'When you first start Qt Creator, you will see a welcome screen. From the **File**
    menu, choose **New File or Project**. There are a number of project types to choose
    from. follow the given steps for creating a Qt Desktop project:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次启动 Qt Creator 时，你将看到一个欢迎屏幕。从 **文件** 菜单中选择 **新建文件或项目**。有几种项目类型可供选择。按照以下步骤创建
    Qt 桌面项目：
- en: For a widget-based application, choose the **Applications** group and the **Qt
    Gui Application** template:![Time for action – creating a Qt Desktop project](img/8874OS_03_01.jpg)
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于基于小部件的应用程序，选择 **应用程序** 组和 **Qt Gui 应用程序** 模板：![行动时间 – 创建一个 Qt 桌面项目](img/8874OS_03_01.jpg)
- en: The next step is to choose a name and location for your new project:![Time for
    action – creating a Qt Desktop project](img/8874OS_03_02.jpg)
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是选择新项目的名称和位置：![行动时间 – 创建一个 Qt 桌面项目](img/8874OS_03_02.jpg)
- en: We are going to create a simple tic-tac-toe game, so we will name our project
    `tictactoe` and provide a nice location for it.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的井字棋游戏，因此我们将我们的项目命名为 `tictactoe` 并为其提供一个合适的位置。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have a common directory where you put all your projects, you can tick
    the **Use as default project location** checkbox for Creator to remember the location
    and suggest it the next time when you start a new project.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你有一个存放所有项目的公共目录，你可以勾选 **用作默认项目位置** 复选框，以便 Creator 记住位置并在下次启动新项目时建议该位置。
- en: When you click on **Next**, you will be presented with a window that lets you
    choose one or more of the defined compilation kits for the project. Proceed to
    the next step without changing anything. You will be presented with the option
    of creating the first widget for your project. Fill in the data as shown in the
    following screenshot:![Time for action – creating a Qt Desktop project](img/8874OS_03_03.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击 **下一步** 时，你将看到一个窗口，允许你选择一个或多个为项目定义的编译工具包。继续下一步，不做任何更改。你将看到创建项目第一个小部件的选项。按照以下截图所示填写数据：![行动时间
    – 创建一个 Qt 桌面项目](img/8874OS_03_03.jpg)
- en: Then, click on **Next** and **Finish**.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **下一步** 和 **完成**。
- en: '*What just happened?*'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'Creator created a new subdirectory in the directory that you previously chose
    for the location of the project and where you put a number of files. Two of these
    files (`tictactoewidget.h` and `tictactoewidget.cpp`) implement the `TicTacToeWidget`
    class as the subclass of `QWidget`. The third file called `main.cpp` contains
    code for the entry point of the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Creator 在你之前选择的项目位置目录中创建了一个新的子目录，并将一些文件放在那里。其中两个文件（`tictactoewidget.h` 和 `tictactoewidget.cpp`）实现了
    `TicTacToeWidget` 类，作为 `QWidget` 的子类。第三个文件名为 `main.cpp`，包含应用程序入口点的代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This file creates an instance of the `QApplication` class and feeds it with
    standard arguments to the `main()` function. Then, it instantiates our `TicTacToeWidget`
    class, calls its `show` method, and finally returns a value returned by the `exec`
    method of the application object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件创建了一个 `QApplication` 类的实例，并将其标准参数传递给 `main()` 函数。然后，它实例化我们的 `TicTacToeWidget`
    类，调用其 `show` 方法，并最终返回应用程序对象的 `exec` 方法返回的值。
- en: '`QApplication` is a singleton class that manages the whole application. In
    particular, it is responsible for processing events that come from within the
    application or from external sources. For events to be processed, an event loop
    needs to be running. The loop waits for incoming events and dispatches them to
    proper routines. Most things in Qt are done through events—input handling, redrawing,
    receiving data over the network, triggering timers, and so on. This is the reason
    we say that Qt is an event-oriented framework. Without an active event loop, nothing
    would function properly. The `exec` call in `QApplication` (or to be more specific,
    in its base class—`QCoreApplication`) is responsible for entering the main event
    loop of the application. The function does not return until your application requests
    the event loop to be terminated. When this eventually happens, the `main` function
    returns and your application ends.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`QApplication` 是一个单例类，它管理整个应用程序。特别是，它负责处理来自应用程序内部或外部来源的事件。为了处理事件，需要一个事件循环正在运行。循环等待传入的事件并将它们分派到适当的例程。Qt
    中的大多数事情都是通过事件完成的——输入处理、重绘、通过网络接收数据、触发计时器等等。这就是我们说 Qt 是一个面向事件框架的原因。如果没有活跃的事件循环，任何东西都无法正常工作。`QApplication`
    中的 `exec` 调用（或者更具体地说，在其基类 `QCoreApplication` 中）负责进入应用程序的主事件循环。该函数在应用程序请求事件循环终止之前不会返回。当这最终发生时，`main`
    函数返回，你的应用程序结束。'
- en: 'The final file that was generated is called `tictactoe.pro` and is the project
    configuration file. It contains all the information that is required to build
    your project using the tools Qt provides. Let''s analyze this file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的最终文件名为 `tictactoe.pro`，是项目配置文件。它包含了使用 Qt 提供的工具构建项目所需的所有信息。让我们分析这个文件：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first two lines enable Qt's `core`, `gui`, and `widgets` modules. The next
    two lines specify that your project file describes an application (as opposed
    to, for example, a library) and declares the name of the target that is executable
    to be `tictactoe`. The last two lines add files that Creator generated for us
    to build the process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行启用了 Qt 的 `core`、`gui` 和 `widgets` 模块。接下来的两行指定了你的项目文件描述了一个应用程序（而不是，例如，一个库），并声明了可执行的目标名称为
    `tictactoe`。最后两行添加了 Creator 为我们生成的文件，用于构建过程。
- en: What we have now is a complete minimal Qt GUI project. To build and run it,
    simply choose the **Run** entry from the **Build** drop-down menu or click on
    the green triangle icon on the left-hand side of the Qt Creator window. After
    a while, you should see a window pop up. Since we didn't add anything to the window,
    it is blank.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个完整的最小化 Qt GUI 项目。要构建和运行它，只需从 **构建** 下拉菜单中选择 **运行** 选项，或者在 Qt Creator
    窗口的左侧点击绿色的三角形图标。过了一会儿，你应该会看到一个窗口弹出。由于我们没有向窗口添加任何内容，所以它是空的。
- en: Adding child widgets to a window
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向窗口添加子控件
- en: After we managed to get a blank window on screen, the next step is to add some
    content to it. To do this, you need to create widgets and tell Qt to position
    them in the window. The basic way to do this is to provide a parent to a widget.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们成功在屏幕上得到一个空白窗口之后，下一步就是向其中添加一些内容。为此，你需要创建控件并告诉 Qt 将它们定位在窗口中。基本的方法是为控件提供一个父控件。
- en: 'In Qt, we group objects (such as widgets) into parent-child relationships.
    This scheme is defined in the superclass of `QWidget`—`QObject`, which is the
    most important class in Qt, and we will cover it in more detail later in this
    chapter. What is important now is that each object can have a parent object and
    an arbitrary number of children. In the case of widgets, there is a rule that
    a child occupies a subarea of its parent. If it doesn''t have a parent, then it
    becomes a top-level window that can usually be dragged around, resized, and closed.
    We can set a parent for an object in two ways. One way is to call the `setParent`
    method defined in `QObject` that accepts a `QObject` pointer. Because of the rule
    mentioned earlier, `QWidget` wants to have other widgets as parents, so the method
    is overloaded in `QWidget` to accept a `QWidget` pointer. The other way is to
    pass a pointer to the parent object to the `QWidget` constructor of the child
    object. If you look at the code of the widget that was generated by Creator, you
    will notice that the constructor also accepts a pointer to a widget as its last
    (optional) argument:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中，我们将对象（如小部件）组合成父子关系。这种方案在 `QWidget` 的超类 `QObject` 中定义，`QObject` 是 Qt 中最重要的类，我们将在本章后面更详细地介绍它。现在重要的是，每个对象都可以有一个父对象和任意数量的子对象。在部件的情况下，有一个规则，即子对象占据其父对象的一个子区域。如果没有父对象，则它成为一个顶级窗口，通常可以拖动、调整大小和关闭。我们可以通过两种方式为对象设置父对象。一种方式是调用
    `QObject` 中定义的 `setParent` 方法，该方法接受一个 `QObject` 指针。由于前面提到的规则，`QWidget` 希望有其他小部件作为父对象，因此该方法在
    `QWidget` 中被重载以接受一个 `QWidget` 指针。另一种方式是将父对象指针传递给子对象的 `QWidget` 构造函数。如果您查看 Creator
    生成的部件代码，您会注意到构造函数也接受一个指向小部件的指针作为其最后一个（可选）参数：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It then passes that pointer to the constructor of its base class. Therefore,
    it is important that you always remember to create a constructor for your widgets
    that accepts a pointer to a `QWidget` instance and passes it up the inheritance
    tree. All standard Qt widgets also behave this way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将那个指针传递给其基类的构造函数。因此，您始终记得为您的部件创建一个接受指向 `QWidget` 实例的指针并将其传递到继承树上的构造函数是非常重要的。所有标准
    Qt 小部件也都以这种方式行为。
- en: Managing widget content
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理小部件内容
- en: Making a widget display as part of its parent is not enough to make a good user
    interface. You also need to set its position and size and react to the changes
    that happen to its content and to the content of its parent widget. In Qt, we
    do this using a mechanism called layouts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使小部件显示为其父对象的一部分并不足以制作出良好的用户界面。您还需要设置其位置和大小，并对其内容和父小部件内容的变化做出反应。在 Qt 中，我们使用称为布局的机制来完成这项工作。
- en: Layouts allow us to arrange the content of a widget, making sure that its space
    is used efficiently. When we set a layout on a widget, we can start adding widgets
    and even other layouts, and the mechanism will resize and reposition them according
    to the rules that we specify. When something happens in the user interface that
    influences how widgets should be displayed (for example, the button text is replaced
    with longer text, which makes the button require more space to show its content;
    if not, one of the widgets gets hidden), the layout is triggered again, which
    recalculates all positions and sizes and updates widgets as necessary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 布局允许我们安排小部件的内容，确保其空间得到有效利用。当我们为小部件设置布局时，我们可以开始添加小部件甚至其他布局，机制将根据我们指定的规则调整大小和重新定位它们。当用户界面中发生影响小部件显示方式的事件时（例如，按钮文本被替换为更长的文本，这使得按钮需要更多空间来显示其内容；如果没有，则某个小部件被隐藏），布局会被触发，重新计算所有位置和大小，并根据需要更新小部件。
- en: 'Qt comes with a predefined set of layouts that are derived from the `QLayout`
    class, but you can also create your own. Those that we already have at our disposal
    are `QHBoxLayout` and `QVBoxLayout`, which position items horizontally and vertically;
    `QGridLayout`, which arranges items in a grid so that an item can span across
    columns or rows; and `QFormLayout`, which creates two columns of items with item
    descriptions in one column and item content in the other. There is also `QStackedLayout`,
    which is rarely used directly and which makes one of the items assigned to it
    possess all the available space. You can see the most common layouts in action
    in the following figure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 提供了一组预定义的布局，这些布局是从 `QLayout` 类派生出来的，但您也可以创建自己的。我们目前可用的布局有 `QHBoxLayout` 和
    `QVBoxLayout`，它们分别水平垂直定位项目；`QGridLayout`，它以网格排列项目，以便项目可以跨越列或行；以及 `QFormLayout`，它创建两列项目，其中一列包含项目描述，另一列包含项目内容。还有一个
    `QStackedLayout`，它很少直接使用，并且使分配给它的一个项目拥有所有可用空间。您可以在以下图中看到最常见的布局的实际应用：
- en: '![Managing widget content](img/8874OS_03_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![管理小部件内容](img/8874OS_03_04.jpg)'
- en: 'To use a layout, we need to create an instance of it and pass a pointer to
    a widget that we want it to manage. Then, we can start adding widgets to the layout:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用布局，我们需要创建其实例，并将我们想要它管理的小部件的指针传递给它。然后，我们可以开始向布局中添加小部件：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can even move widgets further from each other by setting spacing on the
    layout and setting custom margins on the layout:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过设置布局上的间距和在布局上设置自定义边距来将小部件彼此进一步移动：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After building and running this code, you see two buttons that are evenly distributed
    in their parent space. Note that, even though we didn't explicitly pass the parent
    widget pointer, adding a widget to a layout makes it reparent the newly added
    widget to the widget that the layout manages. Resizing the parent horizontally
    would also cause buttons to resize again, covering all the space available. However,
    if you resize `parentWidget` vertically, buttons will change their position but
    not their height.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和运行此代码后，您会看到两个均匀分布在父空间中的按钮。请注意，尽管我们没有明确传递父小部件指针，但将小部件添加到布局中会使它重新将新添加的小部件作为布局管理的小部件的子部件。水平调整父小部件的大小也会导致按钮再次调整大小，覆盖所有可用空间。然而，如果您垂直调整
    `parentWidget` 的大小，按钮将改变其位置但不会改变其高度。
- en: 'This is because each widget has an attribute called a size policy, which decides
    how a widget is to be resized by a layout. You can set separate size policies
    for horizontal and vertical directions. A button has a vertical size policy of
    `Fixed`, which means that the height of the widget will not change from the default
    height regardless of how much space there is available. The following are the
    available size policies:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为每个小部件都有一个名为大小策略的属性，它决定了布局如何调整小部件的大小。您可以为水平和垂直方向设置不同的尺寸策略。按钮的垂直尺寸策略为 `Fixed`，这意味着无论有多少可用空间，小部件的高度都不会从默认高度改变。以下是可以用的尺寸策略：
- en: '`Ignore`: In this, the default size of the widget is ignored and the widget
    can freely grow and shrink'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`忽略`: 在此，小部件的默认大小被忽略，小部件可以自由地增长和缩小'
- en: '`Fixed`: In this, the default size is the only allowed size of the widget'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`固定`: 在此，默认大小是小部件唯一允许的大小'
- en: '`Preferred`: In this, the default size is the desired size, but both smaller
    and bigger sizes are acceptable'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`首选`: 在此，默认大小是期望的大小，但较小和较大的尺寸也是可接受的'
- en: '`Minimum`: In this, the default size is the smallest acceptable size for the
    widget, but the widget can be made larger without hurting its functionality'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最小`: 在此，小部件的默认大小是最小可接受的大小，但小部件可以被放大而不会损害其功能'
- en: '`Maximum`: In this, the default size is the largest size of the widget and
    the widget can be shrunk (even to nothing) without hurting its functionality'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大`: 在此，默认大小是小部件的最大大小，小部件可以被缩小（甚至缩小到无），而不会损害其功能'
- en: '`Expanding`: In this, the default size is the desired size; a smaller size
    (even zero) is acceptable but the widget is able to increase its usefulness when
    more and more space is assigned to it'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`扩展`: 在此，默认大小是期望的大小；较小的尺寸（甚至为零）是可接受的，但小部件能够在分配更多空间时增加其有用性'
- en: '`MinimumExpanding`: This is a combination of `Minimum` and `Expanding`—the
    widget is greedy in terms of space and it cannot be made smaller than its default
    size'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最小扩展`: 这是由 `最小` 和 `扩展` 组合而成的——小部件在空间方面是贪婪的，并且不能缩小到其默认大小以下'
- en: How do we determine the default size? The answer is by the size returned by
    the `sizeHint` virtual method. For layouts, the size is calculated based on the
    sizes and size policies of their child widgets and nested layouts. For basic widgets,
    the value returned by `sizeHint` depends on the content of the widget. In the
    case of a button, if it holds a line of text and an icon, `sizeHint` will return
    the size that is required to fully encompass the text, icon, some space between
    them, the button frame, and the padding between the frame and content itself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确定默认大小？答案是通过对`sizeHint`虚拟方法返回的大小。对于布局，大小是根据其子小部件和嵌套布局的大小和大小策略计算的。对于基本小部件，`sizeHint`返回的值取决于小部件的内容。在按钮的情况下，如果它包含一行文本和一个图标，`sizeHint`将返回完全包含文本、图标、它们之间的一些空间、按钮框架以及框架和内容本身之间的填充所需的大小。
- en: Time for action – implementing a tic-tac-toe game board
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 实现井字棋游戏棋盘
- en: We will now create a widget that implements a game board for tic-tac-toe using
    buttons.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个使用按钮实现井字棋游戏棋盘的小部件。
- en: 'Open the `tictactoewidget.h` file in Creator and update it by adding the highlighted
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Creator中打开`tictactoewidget.h`文件，并通过添加以下高亮代码来更新它：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our additions create a list that can hold pointers to instances of the `QPushButton`
    class, which is the most commonly used button class in Qt. It will represent our
    game board. We have to teach the compiler to understand the classes that we use;
    thus, we add a forward declaration of the `QPushButton` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的增加创建了一个可以持有`QPushButton`类实例指针的列表，这是Qt中最常用的按钮类。它将代表我们的游戏棋盘。我们必须教会编译器理解我们使用的类；因此，我们添加了`QPushButton`类的前置声明。
- en: The next step is to create a method that will help us create all the buttons
    and use a layout to manage their geometries. Go to the header file again and add
    a `void setupBoard();` declaration in the `private` section of the class. To quickly
    implement a freshly declared method, we can ask Qt Creator to create the skeleton
    code for us by positioning the text cursor just before after the method declaration
    (before the semicolon), pressing *Alt* + *Enter* on the keyboard, and choosing
    **Add definition in tictactoewidget.cpp** from the pop-up.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个方法，帮助我们创建所有按钮并使用布局来管理它们的几何形状。再次进入头文件，并在类的`private`部分添加一个`void setupBoard();`声明。为了快速实现新声明的方法，我们可以请求Qt
    Creator为我们创建骨架代码，只需将文本光标定位在方法声明（分号之前）之前，然后在键盘上按*Alt* + *Enter*，并从弹出菜单中选择**在tictactoewidget.cpp中添加定义**。
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It also works the other way around. You can write the method body first and
    then position the cursor on the method signature, press *Alt* + *Enter*, and choose
    **Add public declaration** from the quick fix menu. There are also various other
    context-dependent fixes that are available in Creator.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也适用。你可以先编写方法主体，然后将光标定位在方法签名上，按*Alt* + *Enter*，并从快速修复菜单中选择**添加公共声明**。Creator中还有各种其他上下文相关的修复方案。
- en: Because in the header file we only forward-declared `QPushButton`, we now need
    to provide a full class definition for it by including an appropriate header file.
    In Qt, all classes are declared in the header files that are called exactly the
    same as the classes themselves. Thus, to include a header file for `QPushButton`,
    we need to add a `#include <QPushButton>` line to the implementation file. We
    are also going to use the `QGridLayout` class to manage the space in our widget,
    so we need `#include <QGridLayout>` as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在头文件中我们只进行了`QPushButton`的前置声明，所以我们现在需要通过包含适当的头文件来提供完整的类定义。在Qt中，所有类都在与类本身名称完全相同的头文件中声明。因此，为了包含`QPushButton`的头文件，我们需要在实现文件中添加一行`#include
    <QPushButton>`。我们还将使用`QGridLayout`类来管理小部件中的空间，因此我们还需要`#include <QGridLayout>`。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: From now on, this book will not remind you about adding the `include` directives
    to your source code—you will have to take care of this by yourself. This is really
    easy, just remember that to use a Qt class, you need to include a file named after
    that class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，这本书将不再提醒你添加`include`指令到你的源代码中——你必须自己负责这一点。这真的很简单，只需记住，要使用Qt类，你需要包含一个以该类命名的文件。
- en: 'Now, let''s add the code to the body of the `setupBoard` method. First, let''s
    create a layout that will hold our buttons:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将代码添加到`setupBoard`方法的主体中。首先，让我们创建一个将包含我们的按钮的布局：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can start adding buttons to the layout:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始向布局中添加按钮：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code creates a loop over rows and columns of the board. In each iteration,
    it creates an instance of the `QPushButton` class and sets the button's size policy
    to `Minimum`/`Minimum` so that when we resize the widget, buttons also get resized.
    A button is assigned a single space as its content so that it gets the correct
    initial size. Then, we add the button to the layout in `row` and `column`. At
    the end, we store the pointer to the button in the list that was declared earlier.
    This lets us reference any of the buttons later on. They are stored in the list
    in such an order that the first three buttons of the first row are stored first,
    then the buttons from the second row, and finally those from the last row.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在棋盘的行和列上创建了一个循环。在每次迭代中，它创建一个`QPushButton`类的实例，并将按钮的大小策略设置为`Minimum`/`Minimum`，这样当我们调整小部件大小时，按钮也会调整大小。按钮被分配一个空格作为其内容，以便它获得正确的初始大小。然后，我们将按钮添加到`row`和`column`中的布局中。最后，我们将按钮的指针存储在之前声明的列表中。这使得我们可以在以后引用任何按钮。它们在列表中的顺序是这样的：首先存储第一行的前三个按钮，然后是第二行的按钮，最后是最后一行的按钮。
- en: 'The last thing to do is to tell our widget that `gridLayout` is going to manage
    its size:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是告诉我们的小部件`gridLayout`将管理其大小：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Alternatively, we might have passed this as a parameter to the layout's constructor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能将此作为参数传递给布局的构造函数。
- en: 'Now that we have code that will prepare our board, we need to have it invoked
    somewhere. A good place to do this is the class constructor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了准备棋盘的代码，我们需要在某个地方调用它。一个很好的地方是在类构造函数中执行：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, build and run the program.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建并运行程序。
- en: '*What just happened?*'
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'You should get a window containing nine buttons positioned in a grid-like fashion.
    If you start resizing the window, the buttons are going to be resized as well.
    This is because we set a grid layout with three columns and three rows that evenly
    distributes widgets in the managed area, as shown in the following figure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个包含九个按钮的窗口，这些按钮以网格状排列。如果你开始调整窗口大小，按钮也会相应调整大小。这是因为我们设置了一个包含三列和三行的网格布局，它将小部件均匀地分布在管理区域内，如下所示：
- en: '![What just happened?](img/8874OS_03_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/8874OS_03_05.jpg)'
- en: 'While we''re here, add another `public` method to the class and name it `initNewGame`.
    We will use this method to clear the board when a new game is started. The body
    of the method should look as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，给这个类添加另一个`public`方法，并将其命名为`initNewGame`。我们将使用这个方法在开始新游戏时清除棋盘。方法体应该如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might have noticed that although we created a number of objects in `setupBoard`
    using the `new` operator, we didn't destroy those objects anywhere (for example,
    in the destructor). This is because of the way the memory is managed by Qt. Qt
    doesn't do any garbage collecting (as Java does), but it has this nice feature
    related to `QObject` parent-child hierarchies. The rule is that whenever a `QObject`
    instance is destroyed, it also deletes all its children. Since both the layout
    object and the buttons are the children of the `TicTacToeWidget` instance, they
    will all be deleted when the main widget is destroyed. This is another reason
    to set parents to the objects that we create—if we do this, we don't have to care
    about explicitly freeing any memory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，尽管我们在`setupBoard`中使用`new`操作符创建了许多对象，但我们并没有在任何地方（例如，在析构函数中）销毁这些对象。这是因为Qt管理内存的方式。Qt不会进行垃圾回收（如Java那样），但它有一个与`QObject`父子层次结构相关的良好特性。规则是，每当一个`QObject`实例被销毁时，它也会删除所有子对象。由于布局对象和按钮都是`TicTacToeWidget`实例的子对象，因此当主小部件被销毁时，它们都会被删除。这也是为什么我们要设置我们创建的对象的父对象的原因——如果我们这样做，我们就不必担心显式释放任何内存。
- en: Qt meta-objects
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt元对象
- en: 'Most of the special functionality that Qt offers revolves around the `QObject`
    class and the meta-object paradigm that we will take a closer look at now. The
    paradigm says that with every `QObject` subclass, there is a special object associated
    that contains information about that class. It allows us to make runtime queries
    to learn useful things about the class—the class name, superclass, constructors,
    methods, fields, enumerations, and so on. The meta-object is generated for the
    class at compile time when three conditions are met:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供的许多特殊功能都围绕着`QObject`类和我们现在将更详细地探讨的元对象范式。范式表明，对于每个`QObject`子类，都有一个与之关联的特殊对象，它包含有关该类的信息。它允许我们在运行时查询以了解有关类的有用信息——类的名称、超类、构造函数、方法、字段、枚举等。当满足三个条件时，元对象在编译时为类生成：
- en: The class is a descendant of `QObject`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类是 `QObject` 的子类
- en: It contains a special `Q_OBJECT` macro in a private section of its definition
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在其定义的私有部分包含一个特殊的 `Q_OBJECT` 宏
- en: Code of the class is preprocessed by a special **Meta-Object Compiler** (**moc**)
    tool
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的代码由一个特殊的 **元对象编译器**（**moc**）工具预处理
- en: We can comply to the first two conditions ourselves by writing proper code for
    the class just like Qt Creator does when we create a class derived from `QObject`.
    The last condition is met automatically when you use a tool chain that comes with
    Qt (and Qt Creator) to build your project. Then, it is enough to make sure that
    the file containing the class definition is added to the `HEADERS` variable of
    the project file and Qt will take care of the rest. What really happens is that
    moc generates some code for us that is later compiled in the main program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为类编写适当的代码来满足前两个条件，就像 Qt Creator 在我们创建一个从 `QObject` 派生的类时所做的那样。最后一个条件在您使用
    Qt（和 Qt Creator）附带的工具链构建项目时自动满足。然后，只需确保包含类定义的文件被添加到项目文件的 `HEADERS` 变量中，Qt 就会处理其余部分。实际上发生的是
    moc 为我们生成一些代码，这些代码随后在主程序中编译。
- en: All features discussed in this section of the chapter require a meta-object
    for the class. Therefore, it is essential to make sure that the three conditions
    I mentioned are met if you want a class to use any of those features.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本章本节中讨论的所有功能都需要类的元对象。因此，如果您想使类使用这些功能中的任何一个，确保满足我提到的三个条件是至关重要的。
- en: Signals and slots
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号和槽
- en: To trigger functionality as a response to something that happens in an application,
    Qt uses a mechanism of signals and slots. This is based on connecting a notification
    (which we call a **signal**) about a change of state in some object with a function
    or method (called a **slot**) that is executed when such a notification arises.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应应用程序中发生的事情而触发功能，Qt 使用信号和槽的机制。这是基于将关于某个对象状态变化的通告（我们称之为 **信号**）与一个函数或方法（称为
    **槽**）相连接，当这种通告出现时，该函数或方法将被执行。
- en: Signals and slots can be used with all classes that inherit `QObject`. A signal
    can be connected to a slot, member function, or functor (which includes a regular
    global function). When an object emits a signal, any of these entities that are
    connected to that signal will be called. A signal can also be connected to another
    signal in which case, emitting the first signal will make the other signal be
    emitted as well. You can connect any number of slots to a single signal and any
    number of signals to a single slot.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽可以与所有继承自 `QObject` 的类一起使用。一个信号可以连接到一个槽、成员函数或函数对象（包括常规的全局函数）。当一个对象发出信号时，任何连接到该信号的这些实体都将被调用。一个信号也可以连接到另一个信号，在这种情况下，发出第一个信号将使另一个信号也被发出。你可以将任意数量的槽连接到单个信号，也可以将任意数量的信号连接到单个槽。
- en: 'A signal slot connection is defined by the following four attributes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 信号槽连接由以下四个属性定义：
- en: An object that changes its state (sender)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变其状态的对象（发送者）
- en: A signal in the sender object
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者的信号
- en: An object that contains the function to be called (receiver)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含要调用的函数的对象（接收者）
- en: A slot in the receiver
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者的槽
- en: To declare a signal, we put its declaration, that is, a regular member function
    declaration in a special class scope called signals. However, we don't implement
    such a function—this will be done automatically by moc. To declare a slot, we
    put the declaration in the class scope of either public slots, protected slots,
    or private slots. Slots are regular methods and can be called directly in code
    just like any other method. Contrary to signals, we need to provide bodies for
    slot methods.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个信号，我们将它的声明，即一个常规成员函数声明，放在一个称为 signals 的特殊类作用域中。然而，我们并不实现这样的函数——这将由 moc
    自动完成。要声明一个槽，我们将声明放在公共槽、受保护槽或私有槽的类作用域中。槽是常规方法，可以在代码中直接调用，就像任何其他方法一样。与信号相反，我们需要为槽方法提供主体。
- en: 'A sample class implementing some signals and slots looks like as shown in the
    following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了一些信号和槽的示例类如下所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Signals and slots can be connected and disconnected dynamically using the `connect()`
    and `disconnect()` statements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `connect()` 和 `disconnect()` 语句动态地连接和断开信号和槽。
- en: 'The classic `connect` statement looks as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 `connect` 语句如下所示：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This statement establishes a connection between `SIGNAL` of the `spinBox` object
    called `valueChanged` that carries an `int` parameter and a `setValue` slot in
    the `dial` object that accepts an `int` parameter. It is forbidden to put variable
    names or values in a `connect` statement. You can only make a connection between
    a signal and slot that have matching signatures, which means that they accept
    the same types of arguments (any type casts are not allowed, and type names have
    to match exactly) with the exception that the slot can omit an arbitrary number
    of last arguments. Therefore, the following `connect` statement is valid:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句在名为`valueChanged`的`spinBox`对象的`SIGNAL`和名为`dial`对象的`setValue`槽之间建立连接，该槽接受一个`int`参数。在`connect`语句中放置变量名或值是禁止的。你只能连接具有匹配签名的信号和槽，这意味着它们接受相同类型的参数（不允许任何类型转换，并且类型名称必须完全匹配），除了槽可以省略任意数量的最后一个参数。因此，以下`connect`语句是有效的：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is because the parameter of the `valueChanged` signal can be discarded
    before `clear` is called. However, the following statement is invalid:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在调用`clear`之前可以丢弃`valueChanged`信号的参数。然而，以下语句是无效的：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is nowhere to get the value that is to be passed to `setText`, so such
    a connection will fail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 没有地方可以获取要传递给`setText`的值，因此这种连接将失败。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is important that you wrap signal and slot signatures into the `SIGNAL` and
    `SLOT` macros and that when you specify signatures, you only pass argument types
    and not values or variable names. Otherwise, the connection will fail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你必须将信号和槽签名包装在`SIGNAL`和`SLOT`宏中，并且在指定签名时，你只传递参数类型，而不是值或变量名。否则，连接将失败。
- en: Since Qt 5, there are a couple of different connect syntax available that don't
    require a meta-object for the class implementing the slot. The `QObject` legacy
    is still a requirement though, and the meta-object is still required for the class
    that emits the signal.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Qt 5以来，有几种不同的连接语法可用，不需要实现槽的类的元对象。尽管如此，`QObject`的遗留要求仍然存在，并且元对象对于发出信号的类仍然是必需的。
- en: 'The first additional syntax that we can use is the one where we pass a pointer
    to the signal method and a pointer to the slot method instead of wrapping signatures
    in the `SIGNAL` and `SLOT` macros:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的第一种附加语法是，我们传递信号方法指针和槽方法指针，而不是在`SIGNAL`和`SLOT`宏中包装签名：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this situation, the slot can be any member function of any `QObject` subclass
    that has argument types that match the signal or such that can be converted to
    match the signal. This means that you can, for example, connect a signal carrying
    a double value with a slot taking an int parameter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，槽可以是任何`QObject`子类的任何成员函数，其参数类型与信号匹配，或者可以转换为与信号匹配的类型。这意味着，例如，你可以将携带双值信号的信号与接受整型参数的槽连接起来：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An important aspect is that you cannot freely mix meta-object-based and function-pointer-based
    approaches. If you decide to use pointers to member methods in a particular connection,
    you have to do that for both the signal and the slot.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的方面是，你不能自由地混合基于元对象和基于函数指针的方法。如果你决定在特定的连接中使用成员方法指针，你必须对信号和槽都这样做。
- en: 'We can even go a step further and have a signal connected to a standalone function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更进一步，将一个信号连接到一个独立的函数：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you use C++11, the function can also be a lambda expression in which case,
    it is possible to write the body of the slot directly in the `connect` statement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用C++11，函数也可以是一个lambda表达式，在这种情况下，你可以在`connect`语句中直接编写槽的正文：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is especially useful if you want to invoke a slot with a fixed argument
    value that can''t be carried by a signal because it has less arguments. A solution
    is to invoke the slot from a lambda function (or a standalone function):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想调用一个具有固定参数值的槽，而这个值不能由信号携带，因为它有更少的参数，这特别有用。一种解决方案是从lambda函数（或独立函数）中调用槽：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A function can even be replaced with a function object (functor). To do this,
    we create a class for which we overload the call operator that is compatible with
    the signal that we wish to connect to, as shown in the following snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数甚至可以被函数对象（functor）所替代。为此，我们创建一个类，为该类重载的调用操作符与我们要连接的信号兼容，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is often a nice way to execute a slot with an additional parameter that
    is not carried by the signal, as this is much cleaner than using a lambda expression.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一种执行带有额外参数的槽的方法，该参数不是由信号携带的，因为这样做比使用lambda表达式要干净得多。
- en: There are some aspects of signals and slots that we have not covered here. We
    will come back to them later when we deal with multithreading.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还没有涵盖信号和槽的一些方面。当我们处理多线程时，我们将在稍后回到它们。
- en: Pop quiz – making signal-slot connections
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速问速答 - 建立信号-槽连接
- en: Q1\. For which of the following do you have to provide your own implementation?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 对于以下哪个选项，你必须提供自己的实现？
- en: A signal
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信号
- en: A slot
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 槽
- en: Both
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者
- en: Q2\. Which of the following statements are valid?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 以下哪些陈述是有效的？
- en: '`connect(sender, SIGNAL(textEdited(QString)), receiver, SLOT(setText("foo")))`'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect(sender, SIGNAL(textEdited(QString)), receiver, SLOT(setText("foo")))`'
- en: '`connect(sender, SIGNAL(toggled(bool)), receiver, SLOT(clear()));`'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect(sender, SIGNAL(toggled(bool)), receiver, SLOT(clear()));`'
- en: '`connect(sender, SIGNAL(valueChanged(7)), receiver, SLOT(setValue(int)));`'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect(sender, SIGNAL(valueChanged(7)), receiver, SLOT(setValue(int)));`'
- en: '`connect(sender, &QPushButton::clicked, receiver, &QLineEdit::clear);`'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect(sender, &QPushButton::clicked, receiver, &QLineEdit::clear);`'
- en: Time for action – functionality of a tic-tac-toe board
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 跳棋板的功能
- en: We need to implement a function that will be called upon by clicking on any
    of the nine buttons on the board. It has to change the text of the button that
    was clicked on—either `X` or `O`—based on which player made the move; then, it
    has to check whether the move resulted in winning the game by the player (or a
    draw if no more moves are possible), and if the game ended, it should emit an
    appropriate signal, informing the environment about the event.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个函数，该函数将在点击板上的任何九个按钮时被调用。它必须根据哪个玩家移动来更改被点击的按钮上的文本——要么是`X`要么是`O`——然后，它必须检查该移动是否使玩家获胜（如果没有更多移动，则为平局），如果游戏结束，它应该发出适当的信号，通知环境有关事件。
- en: 'When the user clicks on a button, the `clicked()` signal is emitted. Connecting
    this signal to a custom slot lets us implement the mentioned functionality, but
    since the signal doesn''t carry any parameters, how do we tell which button caused
    the slot to be triggered? We could connect each button to a separate slot but
    that''s an ugly solution. Fortunately, there are two ways of working around this
    problem. When a slot is invoked, a pointer to the object that caused the signal
    to be sent is accessible through a special method in `QObject` called `sender()`.
    We can use that pointer to find out which of the nine buttons stored in the board
    list is the one that caused the signal to fire:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，会发出`clicked()`信号。将此信号连接到自定义槽允许我们实现所提到的功能，但由于该信号不携带任何参数，我们如何知道哪个按钮触发了槽？我们可以将每个按钮连接到单独的槽，但这是一种丑陋的解决方案。幸运的是，有两种方法可以解决这个问题。当槽被调用时，可以通过`QObject`中的特殊方法`sender()`访问导致信号发出的对象的指针。我们可以使用该指针来确定哪个存储在板列表中的九个按钮导致了信号的触发：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'While `sender()` is a useful call, we should try to avoid it in our own code
    as it breaks some principles of object-oriented programming. Moreover, there are
    situations where calling this function is not safe. A better way is to use a dedicated
    class called `QSignalMapper`, which lets us achieve a similar result without using
    `sender()` directly. Modify the `setupBoard()` method in `TicTacToeWidget` as
    follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`sender()`是一个有用的调用，但我们应该尽量避免在我们的代码中使用它，因为它破坏了一些面向对象编程的原则。此外，还有一些情况下调用此函数是不安全的。更好的方法是使用一个专门的类，称为`QSignalMapper`，它允许我们在不直接使用`sender()`的情况下达到类似的结果。按照以下方式修改`TicTacToeWidget`中的`setupBoard()`方法：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we first created an instance of `QSignalMapper` and passed a pointer to
    the board widget as its parent so that the mapper is deleted when the widget is
    deleted. Then, when we create buttons, we "teach" the mapper that each of the
    buttons has a number associated with it—the first button will have the number
    `0`, the second one will be bound to the number `1`, and so on. By connecting
    the `clicked()` signal from the button to mapper's `map()` slot, we tell the mapper
    to do its magic upon receiving that signal. What the mapper will do is that it
    will then find the mapping of the sender of the signal and emit another signal—`mapped()`—with
    the mapped number as its parameter. This allows us to connect to that signal with
    a slot (`handleButtonClick`) that takes the index of the button in the board list.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建了一个`QSignalMapper`的实例，并将棋盘小部件的指针传递给它作为其父对象，这样当小部件被删除时，映射器也会被删除。然后，当我们创建按钮时，我们“教导”映射器每个按钮都有一个与之关联的数字——第一个按钮将具有数字`0`，第二个按钮将绑定到数字`1`，依此类推。通过将按钮的`clicked()`信号连接到映射器的`map()`槽，我们告诉映射器在接收到该信号时执行其魔法。映射器将执行的操作是找到信号发送者的映射，并发出另一个信号——`mapped()`，其参数为映射的数字。这允许我们连接到该信号，并使用一个槽（`handleButtonClick`）来处理按钮在棋盘列表中的索引。
- en: 'Now it is time to implement the slot itself (remember to declare it in the
    header file!). However, before we do that, let''s add a useful enum and a few
    helper methods to the class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现槽本身了（记得在头文件中声明它！）然而，在我们这样做之前，让我们向类中添加一个有用的枚举和一些辅助方法：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This enum lets us specify information about players in the game. We can use
    it immediately to mark whose move it is now. To do so, add a private field to
    the class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个枚举让我们可以指定游戏中玩家的信息。我们可以立即使用它来标记现在是哪个玩家的回合。为此，向类中添加一个私有字段：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, add the two public methods to manipulate the value of this field:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加两个公共方法来操作这个字段的值：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last method emits a signal, so we have to add the signal declaration to
    the class definition along with another signal that we are going to use:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法发出一个信号，因此我们必须将信号声明添加到类定义中，以及我们将要使用的另一个信号：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that we only emit the `currentPlayerChanged` signal when the current player
    really changes. You always have to pay attention that you don't emit a "changed"
    signal when you set a value to a field to the same value that it had before the
    function was called. Users of your classes expect that if a signal is called changed,
    it is emitted when the value really changes. Otherwise, this can lead to an infinite
    loop in signal emissions if you have two objects that connect their value setters
    to the other object's changed signal.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只在当前玩家真正改变时发出`currentPlayerChanged`信号。你总是必须注意，当你将一个字段的值设置为在函数调用之前它所拥有的相同值时，不要发出“已更改”信号。你的类的用户期望如果调用了一个名为“已更改”的信号，那么它是在值真正更改时发出的。否则，如果你有两个对象，它们将它们的值设置器连接到另一个对象的“已更改”信号，这可能导致信号发射中的无限循环。
- en: 'Now let''s declare the `handleButtonClick` slot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们声明`handleButtonClick`槽：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And then implement it in the `.cpp` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`.cpp`文件中实现它：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we first retrieve a pointer to the button based on its index. Then, we
    check whether the button contains any text—if so, then this means that it doesn't
    participate in the game anymore, so we return from the method so that the player
    can pick another field in the board. Next, we set the current player's mark on
    the button. Then, we check whether the player has won the game, passing it the
    row (`index / 3`) and column (`index % 3`) index of the current move. If the game
    didn't end, we switch the current player and return. Otherwise, we emit a `gameOver()`
    signal, telling our environment who won the game. The `checkWinCondition()` method
    returns `Player1`, `Player2`, or `Draw` if the game has ended and `Invalid` otherwise.
    We will not show the implementation of this method here as it is quite complex.
    Try implementing it on your own and if you encounter problems, you can see the
    solution in the code bundle that accompanies this book.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先根据索引检索按钮的指针。然后，我们检查按钮是否包含任何文本——如果是这样，这意味着它不再参与游戏，因此我们从方法中返回，以便玩家可以在棋盘上选择另一个字段。接下来，我们在按钮上设置当前玩家的标记。然后，我们检查玩家是否赢得了游戏，传递当前移动的行（`index
    / 3`）和列（`index % 3`）索引。如果游戏没有结束，我们切换当前玩家并返回。否则，我们发出`gameOver()`信号，告诉我们的环境谁赢得了游戏。`checkWinCondition()`方法在游戏结束时返回`Player1`、`Player2`或`Draw`，否则返回`Invalid`。我们不会在这里展示这个方法的实现，因为它相当复杂。尝试自己实现它，如果遇到问题，你可以在本书附带的代码包中查看解决方案。
- en: Properties
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: Apart from signals and slots, Qt meta-objects also give programmers an ability
    to use the so-called properties that are essentially named attributes that can
    be assigned values of a particular type. They are useful to express important
    features of an object—like text of a button, size of a widget, player names in
    games, and so on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了信号和槽，Qt元对象还让程序员能够使用所谓的属性，这些属性本质上是可以分配特定类型值的命名属性。它们对于表达对象的重要特性非常有用——比如按钮的文本、小部件的大小、游戏中的玩家名字等等。
- en: Declaring a property
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明属性
- en: 'To create a property, we first need to declare it in a private section of a
    class that inherits `QObject` using a special `Q_PROPERTY` macro, which lets Qt
    know how to use the property. A minimal declaration contains the type of the property,
    its name, and information about a method name that is used to retrieve a value
    of the property. For example, the following code declares a property of the type
    `double` that is called `height` and uses a method called `height` to read the
    property value:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个属性，我们首先需要在继承自`QObject`的类的私有部分使用特殊的`Q_PROPERTY`宏来声明它，这样Qt就能知道如何使用这个属性。一个最小的声明包含属性的类型、它的名字以及用于检索属性值的方方法的名称信息。例如，以下代码声明了一个类型为`double`的属性，名为`height`，并使用名为`height`的方法来读取属性值：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The getter method has to be declared and implemented as usual. Its prototype
    has to comply with these rules: it has to be a public method that returns a value
    or constant reference of a type of the property, and it can''t take any input
    parameters and the method itself has to be constant. Typically, a property will
    manipulate a private member variable of the class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器方法必须按照常规进行声明和实现。它的原型必须遵守以下规则：它必须是一个返回属性类型值或常量引用的公共方法，它不能接受任何输入参数，并且方法本身必须是常量。通常，属性会操作类的私有成员变量：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Such a property is practically useless because there is no way to change its
    value. Luckily, we can extend the declaration to include the information about
    how to write a value to the property:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的属性实际上是没有用的，因为没有方法可以改变它的值。幸运的是，我们可以扩展声明以包括如何将值写入属性的信息：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Again, we have to declare and implement `setHeight` so that it behaves as the
    setter method for the property—it needs to be a public method that takes a value
    or constant reference of the type of the property and returns void:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们必须声明和实现`setHeight`，使其作为属性的设置器方法——它需要是一个接受属性类型值或常量引用的公共方法，并返回void：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Property setters are good candidates for public slots so that you can easily
    manipulate property values using signals and slots.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 属性设置器是公共槽的良好候选者，这样你就可以通过信号和槽轻松地操作属性值。
- en: We will learn about some of the other extensions to `Q_PROPERTY` declarations
    in the later chapters of this book.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后续章节中学习关于`Q_PROPERTY`声明的其他扩展。
- en: Using a property
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用属性
- en: There are two ways in which you can access properties. One is of course, to
    use getter and setter methods that we declared with `READ` and `WRITE` keywords
    in the `Q_PROPERTY` macro—this will naturally work since they are regular C++
    methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式访问属性。一种当然是使用我们用`READ`和`WRITE`关键字在`Q_PROPERTY`宏中声明的获取器和设置器方法——这自然会起作用，因为它们是常规的C++方法。
- en: The other way is to use facilities offered by `QObject` and the meta-object
    system. They allow to us access properties by name using two methods that accept
    property names as strings. A generic property getter (which returns the property
    value) is a method called `property`. Its setter counterpart (that takes the value
    and returns void) is `setProperty`. Since we can have properties with different
    data types, what is the data structure that is used by those two methods that
    hold values for different kinds of properties? Qt has a special class for this
    called `QVariant`, which behaves a lot like a C union in the way that it can store
    values of different types. There are a couple of advantages to using a union though—the
    three most important are that you can ask the object what type of data it currently
    holds, you can convert some of the types to other types (for example, a string
    to an integer), and you can teach it to operate on your own custom types.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `QObject` 和元对象系统提供的功能。它们允许我们通过两个接受属性名称作为字符串的方法按名称访问属性。一个通用的属性获取器（返回属性值）是一个名为
    `property` 的方法。它的设置器对应物（接受值并返回 void）是 `setProperty`。由于我们可以有不同数据类型的属性，那么这两个方法所使用的数据结构是什么，它们用于存储不同类型属性的值？Qt
    有一个专门用于此的类，称为 `QVariant`，它在行为上与 C 联合体非常相似，因为它可以存储不同类型的值。尽管如此，使用联合体有几个优点——其中三个最重要的优点是你可以询问对象它当前持有哪种类型的数据，你可以将一些类型转换为其他类型（例如，将字符串转换为整数），并且你可以教会它操作你自己的自定义类型。
- en: Time for action – adding properties to the board class
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 向棋盘类添加属性
- en: 'In this exercise, we will be adding a useful property to the board class. The
    property is going to hold information about the player who should make the next
    move. The type of the property is going to be the `TicTacToeWidget::Player` enumeration
    that we created earlier. For the getter and the setter methods, we are going to
    use the two functions that we created earlier: `currentPlayer()` and `setCurrentPlayer()`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向棋盘类添加一个有用的属性。该属性将保存关于应该进行下一步棋的玩家的信息。属性的类型将是我们在之前创建的 `TicTacToeWidget::Player`
    枚举。对于获取器和设置器方法，我们将使用我们之前创建的两个函数：`currentPlayer()` 和 `setCurrentPlayer()`。
- en: 'Open the header file for our class and modify the class definition as shown
    in the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们类的头文件，并按照以下代码修改类定义：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*What just happened?*'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Since we want to use an enumeration as a type of a property, we have to inform
    Qt's meta-object system about the enum. This is done with the `Q_ENUMS` macro.
    Then, we declare a property called `currentPlayer` and mark our two existing methods
    as getter and setter for the property. We also use the `NOTIFY` keyword to mark
    `currentPlayerChanged` as a signal that is sent to inform about a change in the
    value of the property. We won't be using this extra information in our small game,
    and we don't require `currentPlayer` to be a property at all, but it is always
    a good idea to try and find good candidates for properties and expose them because
    some day, someone might want to use our class in a way we hadn't predicted and
    a particular property might become useful.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想将枚举用作属性的类型，我们必须通知 Qt 的元对象系统关于枚举的信息。这是通过使用 `Q_ENUMS` 宏来完成的。然后，我们声明一个名为 `currentPlayer`
    的属性，并将我们现有的两个方法标记为属性的获取器和设置器。我们还使用 `NOTIFY` 关键字将 `currentPlayerChanged` 标记为发送通知以告知属性值变化的信号。在我们的小游戏中，我们不会使用这些额外的信息，而且我们根本不需要
    `currentPlayer` 是一个属性，但始终尝试找到好的属性候选者并公开它们是一个好主意，因为总有一天，有人可能会以我们没有预测到的方式使用我们的类，某个特定的属性可能会变得有用。
- en: Designing GUIs
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 GUI
- en: So far, we have coded all the user interfaces manually by writing C++ code that
    instantiates widgets, arranges them in layouts, and connects signals to slots.
    It is not that hard for simple widgets, but becomes tedious and time-consuming
    when the UI becomes more and more complex. Fortunately, Qt provides tools to do
    all this in a more pleasant way. Instead of writing C++ code, we can create forms
    using a graphical tool by dragging and dropping widgets on a canvas, applying
    layouts to them, and even establishing signal-slot connections using the point-and-click
    technique. Later during the compilation, such forms will get converted into C++
    code for us and will be ready for applying onto a widget.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们都是通过手动编写实例化小部件、在布局中排列它们并将信号连接到槽的C++代码来编码所有用户界面。对于简单的小部件来说，这并不难，但当UI变得越来越复杂时，就会变得繁琐且耗时。幸运的是，Qt提供了工具，可以以更愉快的方式完成所有这些工作。我们不必编写C++代码，而可以通过在画布上拖放小部件、应用布局以及甚至使用点按技术建立信号-槽连接来创建表单。在编译的后期，这些表单将为我们转换为C++代码，并准备好应用于小部件。
- en: The tool is called Qt Designer and is integrated with Qt Creator. To use it,
    select **New File** or **Project** from the **File** menu and choose the **Qt
    Designer Form Class** template available after selecting Qt in the **Files and
    Classes** section of the dialog box. You get to choose a template for the form
    and configure details such as the names of the files to create. In the end, three
    files will get created—two of them implement a C++ class derived from `QWidget`
    or one of its subclasses and the last one contains data for the form itself.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具被称为Qt Designer，并且与Qt Creator集成。要使用它，从**文件**菜单中选择**新建文件**或**项目**，然后在对话框的**文件和类**部分选择Qt，之后选择可用的**Qt
    Designer表单类**模板。你可以选择表单的模板并配置诸如要创建的文件名称等细节。最后，将创建三个文件——其中两个实现从`QWidget`或其子类派生的C++类，最后一个包含表单本身的数据。
- en: 'After closing the wizard, we are taken to Qt Creator''s **Design** mode that
    looks as shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭向导后，我们将进入Qt Creator的**设计**模式，其外观如下所示：
- en: '![Designing GUIs](img/8874OS_03_06.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![设计GUI](img/8874OS_03_06.jpg)'
- en: The **Design** mode consists of four major parts that are marked on the preceding
    figure with numbers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计**模式由四个主要部分组成，如图中用数字标记所示。'
- en: The area marked as **1** is the main worksheet. It contains a graphical representation
    of the form being designed where you can move widgets around, compose them into
    layouts, and see how they react. It also allows further manipulation of the form
    using the point-and-click method that we will learn later.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 **1** 的区域是主要的工作表。它包含正在设计的表单的图形表示，你可以移动小部件，将它们组合成布局，并查看它们的反应。它还允许使用我们稍后将要学习的点按方法进一步操作表单。
- en: The second area **2** is the widget box. It contains a list of available types
    of widget that are arranged into groups containing items with a related or similar
    functionality. Over the list, you can see a box that lets you filter widgets that
    are displayed in the list to only show those that match the entered expression.
    In the beginning of the list, there are also items that are not really widgets—one
    group contains layouts and the other one contains so-called spacers, which are
    a way to push other items away from each other.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区域 **2** 是小部件框。它包含一个可用小部件类型的列表，这些类型被组织成包含具有相关或相似功能的项目的小组。在列表上方，你可以看到一个框，允许你过滤列表中显示的小部件，只显示与输入的表达式匹配的小部件。在列表的起始处，也有一些实际上不是小部件的项目——一个组包含布局，另一个组包含所谓的间隔符，这是一种将其他项目彼此推开的方式。
- en: The main purpose of the widget box is to add widgets to the form in the worksheet.
    You can do that by grabbing a widget from the list with the mouse, dragging it
    to the canvas, and releasing the mouse button. The widget will appear in the form
    and can be further manipulated with further tools in Creator's Design mode.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件框的主要目的是在电子表格中向表单添加小部件。你可以通过用鼠标从列表中抓取一个小部件，将其拖动到画布上，然后释放鼠标按钮来实现这一点。小部件将出现在表单中，并且可以使用Creator的“设计”模式中的其他工具进一步操作。
- en: The next area **3**, which we are going to talk about, is situated on the right-hand
    side of the window and consists of two parts. At the top of the figure, you can
    see Object Inspector. It presents the parent-child relationship of all widgets
    that are currently present in the edited form. Each line contains the name of
    the object and the name of its class as seen by the meta-object system. If you
    click on an entry, a corresponding widget in the form gets selected (and vice
    versa).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的下一个区域 **3** 位于窗口的右侧，由两部分组成。在图象的顶部，你可以看到对象检查器。它展示了当前编辑表单中所有小部件的父子关系。每一行包含对象的名称以及元对象系统所看到的其类名。如果你点击一个条目，表单中相应的部件就会被选中（反之亦然）。
- en: The lower part of the figure shows the property editor. You can use it to change
    the values of all the properties that each object has. Properties are grouped
    by their classes that they have been declared in, starting from `QObject` (the
    base class implementing properties), which declares only one but an important
    property—`objectName`. Following `QObject`, there are properties declared in `QWidget`,
    which is a direct descendant of `QObject`. They are mainly related to the geometry
    and layout policies of the widget. Lower in the list, you can find properties
    that come from further derivations of `QWidget`. If you prefer a pure alphabetical
    order where properties are not grouped by their class, you can switch the view
    using a pop-up menu that becomes available after you click on the wrench icon
    positioned over the property list; however, once you get familiar with the hierarchy
    of Qt classes, it will be much easier to navigate the list when it is sorted by
    a class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图象的下半部分显示了属性编辑器。你可以用它来更改每个对象的所有属性值。属性根据它们声明的类分组，从 `QObject`（实现属性的基类）开始，它只声明了一个但很重要的属性—`objectName`。在
    `QObject` 之后，是 `QWidget` 中声明的属性，它是 `QObject` 的直接后代。它们主要与部件的几何和布局策略相关。在列表的下方，你可以找到来自
    `QWidget` 进一步派生的属性。如果你更喜欢纯字母顺序，其中属性不是按其类分组，你可以通过点击属性列表上方的扳手图标后出现的弹出菜单来切换视图；然而，一旦你熟悉了
    Qt 类的层次结构，当按类排序时，导航列表将会容易得多。
- en: 'Having a closer look at the property editor, you can see that some of them
    have arrows beneath them that reveal new rows when clicked. These are composed
    properties where the complete property value is determined from more than one
    subproperty values; for example, if there is a property called `geometry` that
    defines a rectangle, it can be expanded to show four subproperties: `x`, `y`,
    `width`, and `height`. Another thing that you should quickly notice is that some
    property names are displayed in bold. This means that the property value was modified
    and is different from the default value for this property. This lets you quickly
    find those properties that you have modified.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察属性编辑器，你会发现其中一些属性下面有箭头，点击后会展开新的行。这些是复合属性，其完整属性值由多个子属性值确定；例如，如果有一个名为 `geometry`
    的属性定义了一个矩形，它可以展开以显示四个子属性：`x`、`y`、`width` 和 `height`。还有一点你应该很快就能注意到，一些属性名以粗体显示。这意味着该属性的值已被修改，并且与该属性的默认值不同。这让你可以快速找到你已修改的属性。
- en: The last group of functionality **4** that we will explain now is the one positioned
    in the lower part of the window. By default, you will see two tabs—**Action Editor**
    and **Signal/Slot Editor**. They allow us to create helper entities such as actions
    for the menus and toolbars or signal-slot connections between widgets using a
    clean tabular interface.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要解释的最后一个功能组 **4** 位于窗口的下半部分。默认情况下，你会看到两个标签页—**动作编辑器**和**信号/槽编辑器**。它们允许我们通过干净的表格界面创建辅助实体，例如菜单和工具栏的动作，或者小部件之间的信号-槽连接。
- en: What was described here is the basic tool layout. If you don't like it, you
    can invoke the context menu from the main worksheet, uncheck the **Locked** entry,
    and rearrange all the windows to your liking or even close the ones you currently
    don't need.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所描述的是基本工具布局。如果你不喜欢它，你可以从主工作表调用上下文菜单，取消选择 **锁定** 条目，并将所有窗口重新排列到你喜欢的样子，甚至关闭你现在不需要的窗口。
- en: Time for action – designing the game configuration dialog
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 设计游戏配置对话框
- en: Now, we will use Qt Designer forms to build a simple game configuration dialog
    that will let us choose names for our players.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Qt Designer 表单来构建一个简单的游戏配置对话框，这将允许我们为我们的玩家选择名字。
- en: 'First, invoke the new file dialog from the menu and choose to create a new
    **Qt Designer Form Class** as shown in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从菜单中调用新的文件对话框，选择创建一个如以下截图所示的**Qt Designer表单类**：
- en: '![Time for action – designing the game configuration dialog](img/8874OS_03_07.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间——设计游戏配置对话框](img/8874OS_03_07.jpg)'
- en: 'In the window that appears, choose **Dialog with Buttons Bottom**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的窗口中，选择**底部有按钮的对话框**：
- en: '![Time for action – designing the game configuration dialog](img/8874OS_03_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间——设计游戏配置对话框](img/8874OS_03_08.jpg)'
- en: Adjust the class name to `ConfigurationDialog`, leave the rest of the settings
    at their default values, and complete the wizard.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将类名调整为`ConfigurationDialog`，将其他设置保留为默认值，并完成向导。
- en: 'Drag and drop two labels and two line edits on the form, position them roughly
    in a grid, double-click on each of the labels, and adjust their captions to receive
    a result similar to the following figure:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个标签和两个行编辑拖放到表单上，将它们大致放置在一个网格中，双击每个标签，调整它们的标题以获得以下类似的结果：
- en: '![Time for action – designing the game configuration dialog](img/8874OS_03_09.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间——设计游戏配置对话框](img/8874OS_03_09.jpg)'
- en: Select the first line to edit and look at the property editor. Find a property
    called `objectName` and change it to `player1Name`. Do the same for the other
    line and call it `player2Name`. Then, click on some empty space in the form and
    choose the **Layout in a grid** entry in the upper toolbar. You should see the
    widgets snap into place—that's because you have just applied a layout to the form.
    When you're done, open the **Tools** menu, go to the **Form Editor** submenu,
    and choose the **Preview** entry.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要编辑的第一行，查看属性编辑器。找到一个名为`objectName`的属性，将其更改为`player1Name`。对另一行也做同样的操作，并将其命名为`player2Name`。然后，在表单上的某个空白区域单击，在上工具栏中选择**在网格中布局**选项。你应该看到部件自动对齐——这是因为你刚刚将布局应用到表单上。完成操作后，打开**工具**菜单，转到**表单编辑器**子菜单，并选择**预览**选项。
- en: '*What just happened?*'
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You can see a new window open that looks exactly like the form we just designed.
    You can resize the window and interact with the objects inside to monitor the
    behavior of the layouts and widgets. What really happened here is that Qt Creator
    built a real window for us based on the description that we provided in all the
    areas of the design mode. Without any compilation, in a blink of an eye we received
    a fully working window with all the layouts working and all the properties adjusted
    to our liking. This is a very important tool so make sure to use it often to verify
    that your layouts are controlling all the widgets as you intended them to—it is
    much faster than compiling and running the whole application just to check whether
    the widgets stretch or squeeze properly. It's all possible thanks to Qt's meta-object
    system.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一个新窗口打开，其外观与我们刚刚设计的表单完全一样。你可以调整窗口大小并与之交互，以监控布局和部件的行为。实际上发生的事情是Qt Creator根据我们在设计模式的所有区域提供的描述为我们构建了一个真实的窗口。无需任何编译，在一瞬间我们就得到了一个完全工作的窗口，所有布局都正常工作，所有属性都调整到我们喜欢的样子。这是一个非常重要的工具，所以请确保经常使用它来验证你的布局是否按照你的意图控制所有部件——这比编译和运行整个应用程序以检查部件是否正确拉伸或挤压要快得多。这一切都得益于Qt的元对象系统。
- en: Time for action – polishing the dialog
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动起来——润色对话框
- en: Now that the GUI itself works as we intended it to, we can focus on giving the
    dialog some more polish.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在GUI本身已经按照我们的预期工作，我们可以专注于给对话框添加更多润色。
- en: Accelerators and label buddies
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速器和标签伙伴
- en: 'The first thing we are going to do is add accelerators to our widgets. These
    are keyboard shortcuts that, when activated, cause particular widgets to gain
    keyboard focus or perform a predetermined action (for example, toggle a checkbox
    or push a button). Accelerators are usually marked by underlining them, as shown
    in the following figure:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是为我们的部件添加加速器。这些是键盘快捷键，当激活时，会导致特定部件获得键盘焦点或执行预定的操作（例如，切换复选框或按下按钮）。加速器通常通过下划线标记，如下面的图所示：
- en: '![Accelerators and label buddies](img/8874OS_03_10.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![加速器和标签伙伴](img/8874OS_03_10.jpg)'
- en: We will set accelerators to our line edits so that when the user activates an
    accelerator for the first field, it will gain focus. Through this we can enter
    the name of the first player, and similarly, when the accelerator for the second
    line edit is triggered, we can start typing in the name for the second player.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为行编辑设置加速键，以便当用户激活第一个字段的加速键时，它将获得焦点。通过这种方式，我们可以输入第一个玩家的名字，同样，当第二个行编辑的加速键被触发时，我们可以开始输入第二个玩家的名字。
- en: Start by selecting the label on the left-hand side of the first line edit. Press
    *F2* or double-click on the label (alternatively, find the text property of the
    label in the property editor and activate its value field). This enables us to
    change the text of the label. Navigate using cursor keys so that the text cursor
    is placed before the character `1` and type the `&` character. This character
    marks the character directly after it as an accelerator for the widget. For widgets
    that are composed of both text and the actual functionality (for example, a button),
    this is enough to make accelerators work. However, since `QLineEdit` does not
    have any text associated with it, we have to use a separate widget for that. This
    is why we have set the accelerator on the label. Now, we need to associate the
    label with the line edit so that the activation of the label's accelerator will
    forward it to the widget of our choice. This is done by setting a so-called buddy
    for the label. You can do this in code using the `setBuddy` method of the `QLabel`
    class or using Creator's form designer. Since we're already in the Design mode,
    we'll use the latter approach. For that, we need to activate a dedicated mode
    in the form designer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在第一行编辑的左侧选择标签。按*F2*键或双击标签（或者，在属性编辑器中找到标签的文本属性并激活其值字段）。这样我们就可以更改标签的文本。使用光标键导航，使文本光标位于字符`1`之前，并输入`&`字符。这个字符将紧随其后的字符标记为小部件的加速键。对于由文本和实际功能（例如，按钮）组成的控件，这足以使加速键工作。然而，由于`QLineEdit`没有与之关联的任何文本，我们必须使用单独的控件。这就是为什么我们在标签上设置了加速键。现在，我们需要将标签与行编辑关联起来，以便标签加速器的激活可以将其转发到我们选择的控件。这是通过为标签设置所谓的伙伴来完成的。您可以使用`QLabel`类的`setBuddy`方法在代码中这样做，或者使用Creator的表单设计器。由于我们已经在设计模式中，我们将使用后一种方法。为此，我们需要在表单设计器中激活一个专用模式。
- en: Look at the upper part of Creator's window; directly above the form, you will
    find a toolbar containing a couple of icons. Click on the one labeled **Edit buddies**
    or just press *F5* on your keyboard. Now, move the mouse cursor over the label,
    press the mouse button, and drag from the label towards the line edit. When you
    drag the label over the line edit, you'll see a graphical visualization of a connection
    being set between the label and the line edit. If you release the button now,
    the association will be made permanent. You should notice that when such an association
    is made, the ampersand character (`&`) vanishes from the label and the character
    behind it gets an underscore. Repeat this for the other label and corresponding
    line edit. Now, you can preview the form again and check whether accelerators
    work as expected.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 看看Creator窗口的上方；在表单上方，你会找到一个包含几个图标的工具栏。点击标有**编辑伙伴**的图标或直接在键盘上按*F5*键。现在，将鼠标光标移到标签上，按下鼠标按钮，并从标签拖动到行编辑。当你将标签拖动到行编辑上时，你会看到一个标签和行编辑之间正在设置连接的图形可视化。如果你现在释放按钮，这个关联将被永久化。你应该注意到，当这种关联被建立时，`&`字符将从标签中消失，并且它后面的字符会得到一个下划线。对其他标签和相应的行编辑重复此操作。现在，您可以再次预览表单，并检查加速键是否按预期工作。
- en: The tab order
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签顺序
- en: While you're previewing the form, you can check another aspect of the UI design.
    Start by pressing the *Tab* key and see how the focus moves from widget to widget.
    There is a good chance that the focus will start jumping back and forth between
    buttons and line edits instead of a linear progress from top to bottom (which
    is an intuitive order for this particular dialog). To check and modify the order
    of focus, leave the preview and switch to the tab order editing mode by clicking
    on the icon called Edit Tab Order in the toolbar.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在预览表单时，你可以检查UI设计的另一个方面。首先，按*Tab*键，看看焦点是如何从一个控件移动到另一个控件的。有很大可能性，焦点将开始在前一个按钮和行编辑之间来回跳跃，而不是从上到下（这是这个特定对话框的直观顺序）。要检查和修改焦点顺序，请离开预览，并切换到标签顺序编辑模式，方法是点击工具栏中称为**编辑标签顺序**的图标。
- en: 'This mode associates a box with a number to each focusable widget. By clicking
    on the rectangle in the order you wish the widgets to gain focus, you can reorder
    values, thus reordering focus. Now, make it so that the order is as shown in the
    following figure:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式将一个框与一个数字关联到每个可聚焦的小部件。通过按照您希望小部件获得焦点的顺序单击矩形，您可以重新排序值，从而重新排序焦点。现在，使其顺序如下所示：
- en: '![The tab order](img/8874OS_03_11.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![标签顺序](img/8874OS_03_11.jpg)'
- en: Enter the preview again and check whether the focus changes according to what
    you've set.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 再次进入预览并检查焦点是否根据您设置的进行改变。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When deciding about the tab order, it is good to consider which fields in the
    dialog are mandatory and which are optional. It is a good habit to allow the user
    to tab through all the mandatory fields first, then to the dialog confirmation
    button (for example, one that says **OK** or **Accept**), and then cycle through
    all the optional fields. Thanks to this, the user will be able to quickly fill
    all the mandatory fields and accept the dialog without the need to cycle through
    all the optional fields that the user wants to leave at their default values.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定标签顺序时，考虑对话框中哪些字段是必需的，哪些是可选的，是很好的。一个好的习惯是首先允许用户遍历所有必需的字段，然后到对话框确认按钮（例如，一个写着**确定**或**接受**的按钮），然后遍历所有可选字段。这样，用户将能够快速填写所有必需的字段并接受对话框，而无需遍历所有用户希望保留为默认值的可选字段。
- en: Signals and slots
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号和槽
- en: 'The last thing we are going to do right now is make sure that the signal-slot
    connections are set up properly. To do this, switch to the signal-slot editor
    mode by pressing *F4* or choosing **Edit Signals/Slots** from the toolbar. The
    **Dialog with Buttons Bottom** widget template predefines two connections for
    us, which should now become visible in the main canvas area:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要做的最后一件事是确保信号-槽连接设置正确。为此，通过按*F4*或从工具栏中选择**编辑信号/槽**来切换到信号-槽编辑模式。**底部按钮对话框**小部件模板为我们预定义了两个连接，现在应该可以在主画布区域中看到：
- en: '![Signals and slots](img/8874OS_03_12.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![信号和槽](img/8874OS_03_12.jpg)'
- en: The `QDialog` class that implements dialogs in Qt has two useful slots—`accept()`
    and `reject()`—which inform the caller whether the action represented by the dialog
    was accepted or not. For our convenience, these slots should already be connected
    to the respective `accepted()` and `rejected()` signals from the group of buttons
    (which is an instance of the `QDialogButtonBox` class) that by default, contain
    the **OK** and **Cancel** buttons. If you click on any of them signal `accepted()`
    or respectively, `rejected()` will be emitted by the box.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Qt中对话框的`QDialog`类有两个有用的槽——`accept()`和`reject()`——它们通知调用者对话框所表示的操作是否被接受。为了方便起见，这些槽应该已经连接到相应的`accepted()`和`rejected()`信号，这些信号来自默认包含**确定**和**取消**按钮的按钮组（这是一个`QDialogButtonBox`类的实例）。如果您单击其中的任何一个，将分别发出信号`accepted()`或`rejected()`。
- en: At this point, we can add some more connections to make our dialog more functional.
    Let's make it such that the button to accept the dialog is only enabled when neither
    of the two line edits is empty (that is, when both the fields contain player names).
    While we will implement the logic itself later, we can now make connections to
    a slot that will perform the task.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以添加一些更多连接，使我们的对话框更加实用。让我们设置成只有当两个行编辑中的任何一个都不为空时（即，当两个字段都包含玩家名称时），接受对话框的按钮才可用。虽然我们将在稍后实现逻辑本身，但现在我们可以将连接到一个将执行此任务的槽。
- en: 'Since no such slot exists by default, we need to inform the form editor that
    such a slot will exist at the time when the application is compiled. To do this,
    we need to switch back to the default mode of the form editor by pressing *F3*
    or choosing **Edit Widgets** from the toolbar. Then, you can invoke the form''s
    context menu and choose **Change signals/slots**. A window will pop up such as
    the one shown in the following figure that lists the available signals and slots:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认情况下没有这样的槽，我们需要通知表单编辑器，在应用程序编译时将存在这样的槽。为此，我们需要通过按*F3*或从工具栏中选择**编辑小部件**来切换回表单编辑器的默认模式。然后，您可以调用表单的上下文菜单并选择**更改信号/槽**。将弹出一个窗口，如下所示，列出了可用的信号和槽：
- en: '![Signals and slots](img/8874OS_03_13.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![信号和槽](img/8874OS_03_13.jpg)'
- en: 'Click on the **+** button in the **Slots** group and create a slot called `updateOKButtonState()`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在**槽**组中单击**+**按钮，创建一个名为`updateOKButtonState()`的槽：
- en: '![Signals and slots](img/8874OS_03_14.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![信号和槽](img/8874OS_03_14.jpg)'
- en: Then, accept the dialog and go back to the **Signals/Slots** mode. Create a
    new connection by grabbing one of the line edits with your mouse. When you move
    the cursor outside the widget, you will notice a red line following your pointer.
    If the line encounters a valid target, the line will change to an arrow and the
    target object will be highlighted. The form itself can also be a target (or a
    source); in this case, the line will end with a ground mark (two short horizontal
    lines).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，接受对话框并返回到**信号/槽**模式。通过用鼠标拖拽一个行编辑创建一个新的连接。当您将光标移出小部件时，您会注意到一个红色线条跟随您的指针。如果线条遇到一个有效目标，线条将变成箭头，并且目标对象将被突出显示。表单本身也可以是一个目标（或一个源）；在这种情况下，线条将以一个接地标记结束（两条短的水平线）。
- en: When you release the mouse button, a window will pop up, listing all the signals
    of the source object and all the slots of the target object. Choose the `textChanged(QString)`
    signal. Note that when you do this, some of the available slots will disappear.
    This is because the tool only allows us to choose from slots that are compatible
    with the highlighted signal. Select our newly created slot and accept the dialog.
    Repeat the same for the other line edit.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当您释放鼠标按钮时，将弹出一个窗口，列出源对象的所有信号和目标对象的所有槽。选择`textChanged(QString)`信号。请注意，当您这样做时，一些可用的槽将消失。这是因为工具只允许我们从与突出显示的信号兼容的槽中进行选择。选择我们新创建的槽并接受对话框。对其他行编辑重复相同的操作。
- en: What we have done here is that we've created two connections that will trigger
    when the text of either of the two line edits is changed. They will execute a
    slot that doesn't exist yet—by "creating" the slot, we only declared our intention
    to implement it in a `QDialog` subclass that was also created for us. You can
    now go ahead and save the form.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是创建了两个连接，当两个行编辑中的任何一个文本发生变化时，它们将会触发。它们将执行一个尚不存在的槽——通过“创建”槽，我们只声明了在我们的`QDialog`子类中实现它的意图，该子类也是为我们创建的。现在您可以继续保存表单了。
- en: '*What just happened?*'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**发生了什么？**'
- en: We performed a number of tasks that make our form follow standard behaviors
    known from many applications—this makes form navigation easy and shows the user
    which actions can be undertaken and which are currently not available.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了多项任务，使我们的表单遵循来自许多应用程序的标准行为——这使得表单导航变得简单，并显示了用户可以执行哪些操作以及哪些操作目前不可用。
- en: Using designer forms
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用设计器表单
- en: If you open the form in a text editor (for example, by switching to the Creator's
    **Edit** pane), you will notice that it is really an XML file. So how do we use
    this file?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在文本编辑器中打开表单（例如，通过切换到创建者的**编辑**面板），您会注意到它实际上是一个XML文件。那么我们如何使用这个文件呢？
- en: As part of the build process, Qt calls a special tool called **User Interface
    Compiler** (**uic**) that reads the file and generates a C++ class that contains
    a `setupUi()` method. This method accepts a pointer to a widget and contains code,
    which instantiates all the widgets, sets their properties, and establishes signal-slot
    connections, and it is our responsibility to call it to prepare the GUI. The class
    itself, which is named after your form (that is after the value of the `objectName`
    property of the form object) with a `Ui` namespace prepended to it (for example,
    `Ui::MyForm`) is not derived from a widget class but is rather meant to be used
    with one. There are basically three ways of doing this.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构建过程的一部分，Qt调用一个名为**用户界面编译器**（**uic**）的特殊工具，该工具读取文件并生成一个包含`setupUi()`方法的C++类。此方法接受一个指向小部件的指针，并包含代码，该代码实例化所有小部件，设置它们的属性，并建立信号-槽连接，而我们负责调用它来准备GUI。该类本身（以您的表单命名，即表单对象的`objectName`属性的值）前面加上一个`Ui`命名空间（例如，`Ui::MyForm`），并不是从小部件类派生的，而是旨在与一个小部件一起使用。基本上有三种方法可以这样做。
- en: Direct approach
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接方法
- en: 'The most basic way to use a Qt Designer form is to instantiate a widget and
    the form object and to call `setupUi` on the widget, like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt Designer表单的最基本方法是实例化一个小部件和一个表单对象，并在小部件上调用`setupUi`，如下所示：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This approach has a number of flaws. First of all, it creates a potential memory
    leak of the `ui` object (remember, it is not `QObject`, so you can''t set a parent
    to it so that it''s deleted when the parent is deleted). Second, since all the
    widgets of the form are variables of the `ui` object that is not tied to the widget
    object, it breaks encapsulation, which is one of the most important paradigms
    of object-oriented programming. However, there is a situation when such a construct
    is acceptable. This is when you create a simple short-lived modal dialog. You
    surely need to remember that to show regular widgets, we have been using the `show()`
    method. This is fine for non-modal widgets, but for modal dialogs you should instead
    call the `exec()`method that is defined in the `QDialog` class. This is a blocking
    method that doesn''t return until the dialog is closed. This allows us to modify
    the code so that it becomes:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在一些缺陷。首先，它可能导致 `ui` 对象的潜在内存泄漏（记住，它不是 `QObject`，因此你不能设置其父对象，以便在父对象被删除时删除它）。其次，由于表单中的所有小部件都是未与小部件对象绑定的
    `ui` 对象的变量，它破坏了封装性，这是面向对象编程最重要的范式之一。然而，有一种情况下这种结构是可以接受的。那就是当你创建一个简单的短期模态对话框时。你肯定需要记住，为了显示常规小部件，我们一直在使用
    `show()` 方法。这对于非模态小部件来说是好的，但对于模态对话框，你应该调用 `QDialog` 类中定义的 `exec()` 方法。这是一个阻塞方法，它不会返回，直到对话框关闭。这允许我们修改代码，使其变为：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Since we're creating objects on the stack, the compiler will take care of deleting
    them when the local scope ends.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是在栈上创建对象，编译器将负责在局部作用域结束时删除它们。
- en: The multiple-inheritance approach
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多重继承方法
- en: 'The second way of using Designer forms is to create a class derived from both
    `QWidget` (or one of its subclasses) and the form class itself. We can then call
    `setupUi` from the constructor:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Designer 表单的第二种方式是创建一个从 `QWidget`（或其子类之一）和表单类本身派生的类。然后我们可以从构造函数中调用 `setupUi`：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This way, we keep the encapsulation as our class inherits fields and methods
    from the `Ui` class, and we can call any of them directly from within the class
    code while restricting access from the outside world by using private inheritance.
    The drawback of this approach is that we pollute the class namespace, for example,
    if we had a name object in `Ui::MyForm`, we wouldn't be able to create a `name`
    method in `Widget`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们保持了封装性，因为我们的类从 `Ui` 类继承字段和方法，并且我们可以在类代码内部直接调用它们，同时通过使用私有继承来限制外部世界的访问。这种方法的缺点是它会污染类命名空间，例如，如果我们有
    `Ui::MyForm` 中的 `name` 对象，我们就无法在 `Widget` 中创建一个 `name` 方法。
- en: The single inheritance approach
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单重继承方法
- en: 'Fortunately, we can work around this using the composition instead of inheritance.
    We can derive our widget class only from `QWidget` and instead of also subclassing
    `Ui::MyForm`, we can make an instance of it a private member of the new class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过组合而非继承来解决这个问题。我们只从 `QWidget` 派生我们的小部件类，而不是也继承自 `Ui::MyForm`，我们可以将其实例作为新类的一个私有成员：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: At the cost of having to manually create and destroy the instance of `Ui::MyForm`,
    we can have the additional benefit of containing all variables and code of the
    form in a dedicated object, which prevents the aforementioned namespace pollution.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以必须手动创建和销毁 `Ui::MyForm` 实例为代价，我们可以获得额外的好处，即在一个专用对象中包含表单的所有变量和代码，这防止了上述命名空间污染。
- en: This is the recommended way of using Designer forms, and it's also the default
    mode of operation when you tell Qt Creator to generate a Designer form class for
    you.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 Designer 表单的推荐方式，也是当你告诉 Qt Creator 为你生成 Designer 表单类时的默认操作模式。
- en: Time for action – the logic of the dialog
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 对话框的逻辑
- en: Now, it is time to make our game settings dialog work. Earlier, we declared
    a signal-slot connection but now the slot itself needs to be implemented.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们让游戏设置对话框工作的时候了。之前，我们声明了一个信号-槽连接，但现在槽本身需要实现。
- en: 'Open the form class generated by Creator. If you''re still in the Design mode,
    you can quickly jump to the respective form class file using the *Shift* + *F4*
    keyboard shortcut. Create a public slots section of the class and declare a `void
    updateOKButtonState()` slot. Open the refactorization menu (*Alt* + *Enter*) and
    ask Creator to create the skeleton implementation of the slot for you. Fill the
    function body with the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 打开由 Creator 生成的表单类。如果你仍然处于设计模式，你可以使用 *Shift* + *F4* 键盘快捷键快速跳转到相应的表单类文件。为该类创建一个公共槽段，并声明一个
    `void updateOKButtonState()` 槽。打开重构菜单 (*Alt* + *Enter*)，并让 Creator 为你创建该槽的骨架实现。在函数体中填充以下代码：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code retrieves player names and checks whether either of them is empty.
    Then, it asks the button box that currently contains the **OK** and **Cancel**
    buttons to give a pointer to the button that accepts the dialog. Then, we set
    the button''s disabled state based on whether both player names contain valid
    values or not. The button state also needs to be updated when we first create
    the dialog, so add invocation of `updateOKButtonState()` to the constructor of
    the dialog:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检索玩家名称并检查其中任何一个是否为空。然后，它要求包含当前 **OK** 和 **Cancel** 按钮的按钮框提供一个指向接受对话框的按钮的指针。然后，我们根据两个玩家名称是否都包含有效值来设置按钮的禁用状态。当第一次创建对话框时，也需要更新按钮状态，因此将
    `updateOKButtonState()` 的调用添加到对话框的构造函数中：
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The next thing to do is to allow to store and read player names from outside
    the dialog—since the `ui` component is private, there is no access to it from
    outside the class code. This is a common situation and one that Qt is also compliant
    with. Each data field in almost every Qt class is private and may contain accessors
    (a getter and optionally a setter), which are public methods that allow to read
    and store values for data fields. Our dialog has two such fields—the names for
    the two players. At this point, we should note that they are good candidates for
    properties so at the end, we'll declare them as such. But first, let's start by
    implementing the accessors.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是允许从对话框外部存储和读取玩家名称——由于 `ui` 组件是私有的，因此无法从类代码外部访问它。这是一个常见的情况，Qt 也遵循这一原则。几乎每个
    Qt 类中的每个数据字段都是私有的，可能包含访问器（一个获取器和可选的设置器），这些是允许读取和存储数据字段值的公共方法。我们的对话框有两个这样的字段——两个玩家的名称。在此阶段，我们应该注意它们是属性的良好候选者，因此最终我们将它们声明为属性。但首先，让我们从实现访问器开始。
- en: 'Setter methods in Qt are usually named using the lowercase pattern, for example,
    `set` followed by the name of the property with the first letter converted to
    uppercase. In our situation, the two setters will be called `setPlayer1Name` and
    s`etPlayer2Name` and they will both accept `QString` and return `void`. Declare
    them in the class header as shown in the following code snippet:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中，设置器方法通常使用小写模式命名，例如，`set` 后跟属性名称，首字母转换为大写。在我们的情况下，两个设置器将分别称为 `setPlayer1Name`
    和 `setPlayer2Name`，它们都将接受 `QString` 并返回 `void`。在类头文件中声明它们，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implement their bodies in the `.cpp` file:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.cpp` 文件中实现它们的主体：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Getter methods in Qt are usually called the same as the property that they
    are related to—`player1Name` and `player2Name`. Put the following code in the
    header file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中，获取器方法通常与它们相关的属性同名——`player1Name` 和 `player2Name`。将以下代码放入头文件中：
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Put the following code in the implementation file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入实现文件中：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The only thing left to do now is to declare the properties. Add the highlighted
    lines to the class declaration:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的事情就是声明属性。将以下高亮行添加到类声明中：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our dialog is now ready. You can test it by creating an instance of it in `main()`
    and calling `show()` or `exec()`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的对话框现在已准备就绪。您可以通过在 `main()` 中创建其实例并调用 `show()` 或 `exec()` 来测试它。
- en: An application's main window
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的主窗口
- en: 'We already have two major components in our game—the game board and configuration
    dialog. Now, we will need to bind them together. To do this, we will use another
    important component—the `QMainWindow` class. A "main window" represents the control
    center of an application. It can contain menus, toolbars, docking widgets, a status
    bar, and the actual widget content called a "central widget", as presented in
    the following diagram:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏中已经有了两个主要组件——游戏板和配置对话框。现在，我们需要将它们绑定在一起。为此，我们将使用另一个重要组件——`QMainWindow` 类。一个“主窗口”代表应用程序的控制中心。它可以包含菜单、工具栏、停靠小部件、状态栏以及称为“中央小部件”的实际小部件内容，如下面的图所示：
- en: '![An application''s main window](img/8874OS_03_15.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序的主窗口](img/8874OS_03_15.jpg)'
- en: The central widget part doesn't need any extra explanation—it is a regular widget
    like any other. We will also not focus on dock widgets or the status bar here.
    They are useful components but they are so easy to master that you can learn about
    them yourself. Instead, we will spend some time mastering menus and toolbars.
    You have surely seen and used toolbars and menus in many applications and you
    know how important they are for good user experience.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 中心小部件部分不需要任何额外的解释——它是一个像任何其他小部件一样的常规小部件。我们也不会在这里关注停靠小部件或状态栏。它们是有用的组件，但它们如此容易掌握，以至于你可以自己学习它们。相反，我们将花一些时间掌握菜单和工具栏。你肯定在许多应用程序中看到并使用过工具栏和菜单，你知道它们对于良好的用户体验是多么重要。
- en: The main hero shared by both these concepts is a class called `QAction`, which
    represents a functionality that can be invoked by a user. A single action can
    have more than one incarnation—it can be an entry in a menu (the `QMenu` instances),
    a toolbar (`QToolBar`), button, or keyboard shortcut (`QShortcut`). Manipulating
    the action (for example, changing its text) causes all its incarnations to update.
    For example, if you have a **Save** entry in the menu (with a keyboard shortcut
    bound to it), a Save icon in the toolbar, and maybe also a **Save** button somewhere
    else in your user interface and you want to disallow saving the document (for
    example, a map in your dungeons and dragons game level editor) because its contents
    haven't changed since the document was last loaded. In this case, if, the menu
    entry, toolbar icon, and button are all linked to the same `QAction` instance
    then, once you set the `enabled` property of the action to `false`, all the three
    entities will become disabled as well. This is an easy way to keep different parts
    of your application in sync—if you disable an action object, you can be sure that
    all entries that trigger the functionality represented by the action are also
    disabled. Actions can be instantiated in code or created graphically using **Action
    Editor** in Qt Creator. An action can have different pieces of data associated
    with it—a text, tooltip, status bar tip, icons, and others that are less often
    used. All these are used by incarnations of your actions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念共享的主要英雄是一个名为`QAction`的类，它代表用户可以调用的功能。一个单独的动作可以有多个化身——它可以是一个菜单（`QMenu`实例）、工具栏（`QToolBar`）、按钮或键盘快捷键（`QShortcut`）。操作动作（例如，更改其文本）会导致所有化身更新。例如，如果你在菜单中有一个**保存**条目（与键盘快捷键绑定），工具栏中的保存图标，以及可能在你的用户界面中的其他地方的**保存**按钮，并且你想要禁止保存文档（例如，你的地下城与龙游戏关卡编辑器中的地图），因为自上次加载文档以来其内容没有变化。在这种情况下，如果菜单条目、工具栏图标和按钮都链接到同一个`QAction`实例，那么一旦你将动作的`enabled`属性设置为`false`，这三个实体也将被禁用。这是一个保持应用程序不同部分同步的简单方法——如果你禁用动作对象，你可以确信触发动作所代表功能的所有条目也被禁用。动作可以在代码中实例化，也可以使用Qt
    Creator中的**动作编辑器**图形化创建。动作可以与不同的数据相关联——文本、工具提示、状态栏提示、图标以及其他较少使用的。所有这些都被你的动作的化身所使用。
- en: The Qt resource system
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Qt资源系统
- en: While speaking of icons, there is an important feature in Qt that you should
    learn. A natural way of creating icons is by loading images from the filesystem.
    The problem with this is that you have to install a bunch of files together with
    your application and you need to always know where they are located to be able
    to provide paths to access them. This is difficult but fortunately, Qt has a solution
    to this—it allows you to embed arbitrary files (such as images for icons) directly
    in the application that is executable. This is done by preparing resource files
    that are later compiled in the binary. Fortunately, Qt Creator provides a graphical
    tool for this as well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到图标时，Qt有一个重要的特性你应该学习。创建图标的一种自然方式是从文件系统中加载图像。这个问题在于你必须与你的应用程序一起安装一堆文件，并且你需要始终知道它们的位置，以便能够提供路径来访问它们。这是困难的，但幸运的是，Qt有一个解决方案——它允许你将任意文件（如图标图像）直接嵌入到可执行的应用程序中。这是通过准备随后编译到二进制中的资源文件来完成的。幸运的是，Qt
    Creator也提供了一个图形化工具来完成这项工作。
- en: Time for action – the main window of the application
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——应用程序的主窗口
- en: Create a new **Qt** **Designer Form Class** application. As a template, choose
    **Main Window**. Accept the default values for the rest of the wizard.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的**Qt** **Designer Form Class**应用程序。作为一个模板，选择**主窗口**。接受向导中其余部分的默认值。
- en: 'Create an action using the action editor and enter the following values in
    the dialog:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动作编辑器创建一个动作，并在对话框中输入以下值：
- en: '![Time for action – the main window of the application](img/8874OS_03_16.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![现在是时候添加下拉菜单了 - 应用程序的主窗口](img/8874OS_03_16.jpg)'
- en: 'Now, create another action and fill it with the values shown in the following
    screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建另一个动作并填写以下截图中的值：
- en: '![Time for action – the main window of the application](img/8874OS_03_17.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![现在是时候添加下拉菜单了 - 应用程序的主窗口](img/8874OS_03_17.jpg)'
- en: We want our game to look nice, so we will provide icons for the actions and
    we will embed images for them in our application using the resource system. Create
    a new file and make it **Qt Resource File**. Call it `resources.qrc`. Click on
    the **Add** button and choose **Add Prefix**. Change the value for the prefix
    to `/`. Then, click on the **Add** button again and choose **Add Files**. Find
    appropriate images for your actions and add them to the resource file. A dialog
    will appear asking whether you want to copy the files to the project directory.
    Agree by choosing **Copy**.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的游戏看起来很漂亮，所以我们将为动作提供图标，并使用资源系统将图像嵌入到我们的应用程序中。创建一个新文件，将其命名为 **Qt Resource
    File**。命名为 `resources.qrc`。点击 **Add** 按钮，选择 **Add Prefix**。将前缀的值更改为 `/`。然后，再次点击
    **Add** 按钮，选择 **Add Files**。找到适合你动作的图像并将它们添加到资源文件中。将出现一个对话框询问你是否希望将文件复制到项目目录。通过选择
    **Copy** 来同意。
- en: '![Time for action – the main window of the application](img/8874OS_03_18.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![现在是时候添加下拉菜单了 - 应用程序的主窗口](img/8874OS_03_18.jpg)'
- en: Now, edit the actions again in the Action Editor and choose icons for them.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在动作编辑器中再次编辑动作并为它们选择图标。
- en: '*What just happened?*'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We added a resource file to our project. In that resource file, we created entries
    for a number of images. Each of the images is put under a `/` prefix, which stands
    for the root node of the artificial filesystem that we create. Each entry in a
    resource file can be accessed directly from the manually written code as a file
    with a special name. This name is assembled from three components. First comes
    a colon character (`:`), which identifies the resource filesystem. This is followed
    by a prefix (for example, `/`) and a full path of the entry in the resource (for
    example, `exit.png`). This makes an image called `exit.png` accessible through
    the `:/exit.png` path. When we build the project, the file will be transformed
    into a C data array code and integrated with the application binary. Having prepared
    the resource file, we used images embedded there as icons for our actions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向项目中添加了一个资源文件。在该资源文件中，我们为许多图像创建了条目。每个图像都被放置在一个 `/` 前缀下，这代表我们创建的人工文件系统的根节点。资源文件中的每个条目都可以通过手动编写的代码直接访问，作为一个具有特殊名称的文件。这个名称由三个部分组成。首先是冒号字符（`:`），它标识资源文件系统。接着是一个前缀（例如，`/`）和资源条目的完整路径（例如，`exit.png`）。这使得名为
    `exit.png` 的图像可以通过 `:/exit.png` 路径访问。当我们构建项目时，该文件将被转换成 C 数据数组代码并与应用程序二进制文件集成。在准备完资源文件后，我们使用了其中嵌入的图像作为我们动作的图标。
- en: The next step is to add these actions to a menu and toolbar.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将这些动作添加到菜单和工具栏中。
- en: Time for action – adding a pull-down menu
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是时候添加下拉菜单了
- en: 'To create a menu for the window, double-click on the **Type Here** text on
    the top of the form and replace the text with `&File`. Then, drag the **New Game**
    action from the action editor over the newly created menu but do not drop it there
    yet. The menu should open now and you can drag the action so that a red bar appears
    in the submenu in the position where you want the menu entry to appear—now you
    can release the mouse button to create the entry. Afterwards, open the menu again
    by clicking on **File** and choose **Add Separator**. Then, repeat the drag-and-drop
    operation for the **Quit** action to insert a menu entry for it just below the
    separator in the **File** menu, as shown in the following figure:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要为窗口创建一个菜单，双击表单顶部的 **Type Here** 文本，并将其替换为 `&File`。然后，将动作编辑器中的 **New Game**
    动作拖动到新创建的菜单上，但不要放下它。菜单现在应该打开了，你可以拖动动作，直到子菜单中出现一个红色条，在你想菜单条目出现的位置——现在你可以释放鼠标按钮来创建条目。之后，再次通过点击
    **File** 来打开菜单，并选择 **Add Separator**。然后，重复拖放操作为 **Quit** 动作插入一个菜单条目，位于 **File**
    菜单中的分隔符下方，如图所示：
- en: '![Time for action – adding a pull-down menu](img/8874OS_03_19.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![现在是时候添加下拉菜单了 - 添加下拉菜单](img/8874OS_03_19.jpg)'
- en: '*What just happened?*'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Using graphical tools, we created a menu for our program and added a number
    of actions (that were automatically transformed into menu items) to that menu.
    Each menu entry received some text and an icon specified by the action that was
    dropped in the menu.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图形工具，我们为我们的程序创建了一个菜单，并向该菜单添加了多个操作（这些操作被自动转换为菜单项）。每个菜单条目都接收了一些文本和一个由放入菜单中的操作指定的图标。
- en: Tip
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To create submenus, first create a menu entry by clicking on the **Type Here**
    line and entering the submenu name. Then, drag and hover an action over such a
    submenu. After a short time, a submenu will pop up and you will be able to drop
    your action there to create an entry in the second-level menu.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建子菜单，首先通过点击**在此处输入**行创建一个菜单条目，并输入子菜单名称。然后，将一个操作拖动并悬停在这样一个子菜单上。经过一段时间，子菜单将弹出，你将能够将操作放下以在二级菜单中创建一个条目。
- en: Time for action – creating a toolbar
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建工具栏
- en: 'To create a toolbar, invoke the context menu on the form and choose **Add Tool
    Bar**. Then, drag the **New Game** action over the toolbar and drop it there.
    Open a context menu for the toolbar and choose **Append Separator**. Then, drag
    the **Quit** action from the Action Editor and drop it in the toolbar behind the
    separator. The following figure presents the final layout that you should have
    now:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建工具栏，请在表单上调用上下文菜单并选择**添加工具栏**。然后，将**新游戏**操作拖动到工具栏上并放下。为工具栏打开上下文菜单并选择**追加分隔符**。然后，从操作编辑器中将**退出**操作拖动到分隔符后面的工具栏中。以下图展示了你现在应该拥有的最终布局：
- en: '![Time for action – creating a toolbar](img/8874OS_03_20.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 创建工具栏](img/8874OS_03_20.jpg)'
- en: '*What just happened?*'
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Creating toolbars is very similar to creating menus. You first create the container
    (the toolbar) and then drag-and-drop actions from the action editor. You can even
    drag an action from the menu bar and drop it on the toolbar and vice versa!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 创建工具栏与创建菜单非常相似。首先创建容器（工具栏），然后从操作编辑器中拖放操作。你甚至可以从菜单栏拖动一个操作并将其放到工具栏上，反之亦然！
- en: Time for action – filling in the central widget
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 填充中心部件
- en: 'Add two labels in the main window area—one at the top for the first player
    name and one at the bottom of the form for the second player name—and then change
    their `objectName` property to `player1` and `player2`, respectively. Clear their
    text property so that they don''t display anything. Then, drag **Widget** from
    the widget box, drop it between the two labels'' and set its object name to `gameBoard`.
    Invoke the context menu on the widget that you just dropped and choose **Promote
    to**. This allows us to substitute a widget in the form with another class; in
    our case, we will want to replace the empty widget with our game board. Fill the
    dialog that has just appeared with the values shown in the following figure:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在主窗口区域添加两个标签 – 一个在顶部用于第一个玩家名称，一个在表单底部用于第二个玩家名称 – 然后将它们的`objectName`属性分别更改为`player1`和`player2`。清除它们的文本属性，以便它们不显示任何内容。然后，从部件框中拖动**Widget**，将其放在两个标签之间，并将它的对象名称设置为`gameBoard`。在刚刚放置的部件上调用上下文菜单并选择**提升到**。这允许我们用另一个类替换表单中的部件；在我们的情况下，我们希望用我们的游戏板替换空部件。将刚刚出现的对话框填写如下图的值：
- en: '![Time for action – filling in the central widget](img/8874OS_03_21.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 填充中心部件](img/8874OS_03_21.jpg)'
- en: Then, click on the button labeled **Add** and then **Promote** to close the
    dialog and confirm the promotion. You will not notice any changes in the form
    because the replacement only takes place during compilation. Now, apply a vertical
    layout on the form so that the labels and the empty widget snap into place.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击标有**添加**的按钮，然后点击**提升**以关闭对话框并确认提升。你不会在表单上注意到任何变化，因为替换仅在编译期间发生。现在，在表单上应用垂直布局，以便标签和空部件能够正确对齐。
- en: '*What just happened?*'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Not all widget types are directly available in the form designer. Sometimes,
    we need to use widget classes that will only be created in the project that is
    being built. The simplest way to be able to put custom widgets on a form is to
    ask the designer to replace class names with some of the objects when C++ code
    for the form is to be generated. By promoting an object to a different class,
    we saved a lot of work trying to otherwise fit our game board into the user interface.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有部件类型都在表单设计器中直接可用。有时，我们需要使用仅在构建的项目中创建的部件类。将自定义部件放在表单上的最简单方法是在生成表单的C++代码时，要求设计者将类名替换为一些对象。通过将对象提升到不同的类，我们节省了大量将游戏板适应用户界面的工作。
- en: Time for action – putting it all together
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 整合所有内容
- en: 'The visual part of the game is ready and what remains is to complete the logic
    of the main window and put all the pieces together. Add a public slot to the class
    and call it `startNewGame`. In the class constructor, connect the **New Game**
    action''s triggered signal to this slot and connect the application''s quit slot
    to the other action:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的视觉部分已经准备好，接下来需要完成主窗口逻辑的编写并将所有组件整合在一起。给类添加一个公共槽位，命名为 `startNewGame`。在类构造函数中，将
    **New Game** 动作的触发信号连接到这个槽位，并将应用程序的退出槽位连接到另一个动作：
- en: '[PRE45]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `qApp` special macro represents a pointer to the application object instance,
    so the preceding code will call the `quit()` slot on the `QApplication` object
    created in `main()`, which in turn will eventually cause the application to end.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`qApp` 特殊宏代表指向应用程序对象实例的指针，因此前面的代码将调用在 `main()` 中创建的 `QApplication` 对象的 `quit()`
    槽位，这最终将导致应用程序结束。'
- en: 'Let''s implement the `startNewGame` slot as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式实现 `startNewGame` 槽位：
- en: '[PRE46]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this slot, we create the settings dialog and show it to the user, forcing
    him to enter player names. If the dialog was canceled, we abandon the creation
    of a new game. Otherwise, we ask the dialog for player names and set them on appropriate
    labels. Finally, we initialize the board and enable it so that users can interact
    with it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个槽位中，我们创建设置对话框并展示给用户，强制用户输入玩家名称。如果对话框被取消，我们放弃创建新游戏。否则，我们从对话框获取玩家名称并将它们设置在适当的标签上。最后，我们初始化棋盘并启用它，以便用户可以与之交互。
- en: 'While writing a turn-based board game, it is a good idea to always clearly
    mark whose turn it is now to make a move. We will do this by marking the moving
    player''s name in bold. There is already a signal in the board class that tells
    us that a valid move was made, which we can react to in order to update the labels.
    Let''s add an appropriate code into the constructor of the main window class:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写回合制棋盘游戏时，始终清楚地标记现在是哪个玩家的回合进行移动是个好主意。我们将通过在粗体中标记移动玩家的名称来实现这一点。棋盘类中已经有一个信号告诉我们已经完成了一次有效移动，我们可以通过它来更新标签。让我们在主窗口类的构造函数中添加适当的代码：
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now for the slot itself; let add a private slot''s section to the class and
    declare the slot there:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看槽位本身；让我们在类中添加一个私有槽位部分并声明该槽位：
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can implement it:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现它：
- en: '[PRE49]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In addition to the slot being called after a signal is emitted, we can also
    use it to set the initial data for the labels when the game is starting. Since
    all the slots are also regular methods, we can simply call `updateNameLabels()`
    from `startNewGame()`—go ahead and invoke `updateNameLabels()` at the end of `startNewGame()`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在信号发出后调用槽位之外，我们还可以在游戏开始时使用它来设置标签的初始数据。由于所有槽位也都是常规方法，我们只需从 `startNewGame()`
    中调用 `updateNameLabels()` 即可——在 `startNewGame()` 的末尾调用 `updateNameLabels()`。
- en: 'The last thing that needs to be done is to handle the situation when the game
    ends. Connect the `gameOver()` signal from the board to a new slot in the main
    window class. Implement the slot as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要完成的事情是处理游戏结束的情况。将棋盘的 `gameOver()` 信号连接到主窗口类中的新槽位。如下实现该槽位：
- en: '[PRE50]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*What just happened?*'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'Our code does two things. First, it disables the board so that players can
    no longer interact with it. Second, it checks who won the game, assembles the
    message (we will learn more about `QString` in the next chapter), and shows it
    using a static method `QMessageBox::information()` that shows a modal dialog containing
    the message and a button that allows us to close the dialog. The last thing that
    remains is to update the `main()` function in order to create an instance of our
    `MainWindow` class:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码做了两件事。首先，它禁用了棋盘，这样玩家就不能再与之交互了。其次，它检查谁赢得了游戏，组装消息（我们将在下一章中了解更多关于 `QString`
    的内容），并使用静态方法 `QMessageBox::information()` 显示它，该方法显示一个包含消息和允许我们关闭对话框的按钮的模态对话框。最后一件剩下的事情是更新
    `main()` 函数，以便创建我们的 `MainWindow` 类的实例：
- en: '[PRE51]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, you can run your first Qt game.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行你的第一个 Qt 游戏。
- en: Have a go hero – extending the game
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试扩展游戏
- en: As an additional exercise, you can try to modify the code we have written in
    this chapter to allow playing the game on boards bigger than 3 x 3\. Let the user
    decide about the size of the board (you can modify the game options dialog for
    that and use `QSlider` and `QSpinBox` to allow the user to choose the size of
    the board) and you can then instruct `TicTacToeWidget` to build the board based
    on the size it gets. Remember to adjust the game winning logic! If at any point
    you run into a dead end and do not know which classes and functions to use, consult
    the reference manual.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项附加练习，你可以尝试修改本章中我们编写的代码，以便在大于 3 x 3 的棋盘上玩游戏。让用户决定棋盘的大小（你可以修改游戏选项对话框来实现这一点，并使用
    `QSlider` 和 `QSpinBox` 允许用户选择棋盘的大小），然后你可以指导 `TicTacToeWidget` 根据它得到的大小构建棋盘。记住调整游戏胜利逻辑！如果在任何时刻你遇到了死胡同，不知道该使用哪些类和函数，请查阅参考手册。
- en: Tip
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To quickly find the documentation for a class (or any other page in the docs),
    switch to the **Help** pane, choose **Index** from the drop-down list on top of
    the sidebar, and type in the search term, such as `QAction`. Also, the *F1* key
    is very helpful for browsing the manual. Position the mouse pointer or text cursor
    in the code editor over the name of a class, function, or object and press *F1*
    on your keyboard. By doing this, Qt Creator will happily show you the available
    help information on the chosen subject.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速查找类的文档（或文档中的任何其他页面），切换到 **帮助** 面板，从侧边栏顶部的下拉列表中选择 **索引**，并输入搜索词，例如 `QAction`。此外，*F1*
    键在浏览手册时非常有用。将鼠标指针或文本光标放在代码编辑器中类的名称、函数或对象上，然后按键盘上的 *F1*。通过这样做，Qt Creator 将乐意向你展示所选主题的可用帮助信息。
- en: Pop quiz – using widgets
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——使用小部件
- en: 'Q1\. A method that returns the preferred size of a widget is called:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 返回小部件首选大小的方法被称为：
- en: '`preferredSize`'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`preferredSize`'
- en: '`sizeHint`'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sizeHint`'
- en: '`defaultSize`'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`defaultSize`'
- en: Q2\. What is the name of a Qt class that can carry values for any property?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 哪个 Qt 类可以携带任何属性的值？
- en: '`QVariant`'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QVariant`'
- en: '`QUnion`'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QUnion`'
- en: '`QPropertyValue`'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QPropertyValue`'
- en: Q3\. What is the purpose of the `QAction` object?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. `QAction` 对象的目的是什么？
- en: It represents a functionality that a user can invoke in the program.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它代表用户可以在程序中调用的功能。
- en: It holds a key sequence to move the focus on a widget.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它包含一个用于将焦点移动到小部件上的快捷键序列。
- en: It is a base class for all forms generated using Qt Designer.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是使用 Qt Designer 生成的所有表单的基类。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create simple graphical user interfaces
    with Qt. We went through two approaches—creating user interface classes by writing
    all the code directly and designing the user interface with a graphical tool that
    generates most of the code for us. There is no telling which of the two approaches
    is better; each of them is better in some areas and worse in others. In general,
    you should prefer using Qt Designer forms to write code directly because it's
    faster and less prone to errors as most of the code is generated. However, if
    you want to retain more control over the code or your GUI is highly dynamic, writing
    all the code yourself will be easier, especially when you gain enough experience
    with Qt to avoid common pitfalls and learn to use advanced programming constructs.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 Qt 创建简单的图形用户界面。我们探讨了两种方法——通过直接编写所有代码来创建用户界面类，以及使用生成大部分代码的图形工具来设计用户界面。无法确定两种方法中哪一种更好；它们各自在某些方面更好，在其他方面则较差。一般来说，你应该优先使用
    Qt Designer 表单来直接编写代码，因为它更快，更不容易出错，因为大部分代码都是自动生成的。然而，如果你想要对代码有更多的控制，或者你的 GUI 非常动态，自己编写所有代码会更容易，尤其是在你积累了足够的
    Qt 经验，可以避免常见陷阱并学会使用高级编程结构之后。
- en: We also learned how the heart of Qt—the meta-object system—works. You should
    now be able to create simple user interfaces and fill them with logic by connecting
    signals to slots—predefined ones as well as custom ones that you now know how
    to define and fill with code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了 Qt 的核心——元对象系统是如何工作的。你现在应该能够通过连接信号到槽（预定义的以及你现在已经知道如何定义并填充代码的自定义槽）来创建简单的用户界面并填充逻辑。
- en: Qt contains many widget types but I didn't introduce them to you one by one.
    There is a really nice explanation of many widget types in the Qt manual called
    *Qt Widget Gallery*, which shows most of them in action.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 包含许多小部件类型，但我没有逐一向你介绍它们。Qt 手册中有一个非常好的关于许多小部件类型的解释，称为 *Qt 小部件画廊*，它展示了其中大部分的实际应用。
- en: If you have any doubts about using any of those widgets, you can check the example
    code and also look up the appropriate class in the Qt reference manual to learn
    more about them.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些小部件的任何使用有疑问，你可以查看示例代码，并在 Qt 参考手册中查找相应的类，以了解更多关于它们的信息。
- en: Using Qt is much more than just dragging-and-dropping widgets on forms and providing
    some code to glue the pieces together. In the next chapter, you will learn about
    some of the most useful functionalities that Qt has to offer; they do not relate
    to showing graphics on screen, but rather let you manipulate various kind of data.
    This is essential for any game that is more complicated than a simple tic-tac-toe.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt 远不止在表单上拖放小部件并提供一些代码来将这些部件粘合在一起。在下一章中，你将了解 Qt 提供的一些最实用的功能；它们与在屏幕上显示图形无关，而是让你能够操作各种类型的数据。这对于比简单的井字棋更复杂的任何游戏来说都是必不可少的。
