- en: Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Storing a few elements in the sequence container
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在序列容器中存储少量元素
- en: Storing most N elements in the sequence container
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在序列容器中存储大多数N个元素
- en: Comparing strings in an ultra-fast manner
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以超快速度比较字符串
- en: Using an unordered set and map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无序集和映射
- en: Making a map, where the value is also a key
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个地图，其中值也是一个键
- en: Using multi-index containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多索引容器
- en: Getting benefits of a single linked list and memory pool
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得单链表和内存池的好处
- en: Using flat associative containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扁平的关联容器
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter is devoted to the Boost containers and the things directly connected
    with them. It provides information about the Boost classes that can be used in
    every day programming, and that will make your code much faster, and the development
    of new applications easier.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍了Boost容器及与其直接相关的内容。它提供了关于Boost类的信息，这些类可以在日常编程中使用，并且可以使您的代码更快，新应用程序的开发更容易。
- en: Containers differ not only by functionality, but also by the efficiency (complexity)
    of some of its members. The knowledge about complexities is essential for writing
    fast applications. This chapter doesn't just introduce some new containers to
    you, it gives you tips on when and when not to use a specific type of container
    or its methods.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 容器不仅在功能上有所不同，而且在某些成员的效率（复杂性）上也有所不同。了解复杂性对于编写快速应用程序至关重要。本章不仅向您介绍了一些新的容器，还为您提供了关于何时以及何时不使用特定类型的容器或其方法的建议。
- en: So, let's begin!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: Storing a few elements in a sequence container
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在序列容器中存储少量元素
- en: For the past two decades, C++ programmers were using `std::vector` as a default
    sequence container. It is a fast container that does not do a lot of allocations,
    stores elements in a CPU cache friendly way and because container stores the elements
    contiguously `std::vector::data()` like functions allows to inter-operate with
    pure C functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的20年里，C++程序员一直将`std::vector`作为默认的序列容器。它是一个快速的容器，不会进行大量的分配，以CPU缓存友好的方式存储元素，并且因为容器连续存储元素，`std::vector::data()`等函数允许与纯C函数进行交互。
- en: But, we want more! There are cases when we do know the typical elements count
    to store in the vector, and we need to improve the performance of the vector by
    totally eliminating the memory allocations for that case.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们想要更多！有些情况下，我们知道要在向量中存储的典型元素数量，并且我们需要通过完全消除该情况下的内存分配来提高向量的性能。
- en: 'Imagine that we are writing a high performance system for processing bank transactions.
    **Transaction** is a sequence of operations that must all succeed or fail if at
    least one of the operations failed. We know that the 99% of transactions consist
    of 8 or less operations and wish to speed up things:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在编写一个高性能的用于处理银行交易的系统。**交易**是一系列操作，如果其中至少有一个操作失败，那么所有操作都必须成功或失败。我们知道99%的交易由8个或更少的操作组成，并希望加快处理速度：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe requires only the basic knowledge of standard library and C++.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例只需要基本的标准库和C++知识。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This is going to be a simplest task of this book, thanks to the `Boost.Container`
    library:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是本书中最简单的任务，这要归功于`Boost.Container`库：
- en: 'Include the appropriate header:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括适当的头文件：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Replace `std::vector` with `boost::container::small_vector` and drop the `reserve()`
    call:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`boost::container::small_vector`替换`std::vector`并删除`reserve()`调用：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::container::small_vector`'s second template parameter is the elements
    count to preallocate on a stack. So if most of the time we have to store 8 or
    less elements in the vector, we just put `8` as a second template parameter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::container::small_vector`的第二个模板参数是要在堆栈上预分配的元素数量。因此，如果大多数情况下我们需要在向量中存储8个或更少的元素，我们只需将`8`作为第二个模板参数。'
- en: If we have to store more than 8 elements in the container, then the `small_vector`
    behaves exactly as `std::vector` and dynamically allocates a chunk of memory to
    store more than 8 elements. Just like `std::vector`, the `small_vector` is a sequence
    container with **random access iterators** that stores the elements consistently.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在容器中存储超过8个元素，那么`small_vector`的行为就与`std::vector`完全相同，并动态分配一块内存来存储超过8个元素。就像`std::vector`一样，`small_vector`是一个具有**随机访问迭代器**的序列容器，它一致地存储元素。
- en: To sum up, `boost::container::small_vector` is a container that behaves exactly
    as `std::vector`, but allows to avoid memory allocations for a compile time specified
    amount of elements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`boost::container::small_vector`是一个行为与`std::vector`完全相同的容器，但允许在编译时指定的元素数量避免内存分配。
- en: There's more...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A drawback of using `small_vector` is that our elements count assumption leaks
    into the function signature that accepts `small_vector` as a parameter. So if
    we have three functions specialized for `4`, `8`, and `16` elements, respectively,
    and all those functions process transactions using `execute_operations` from the
    preceding example, we''ll end up with multiple instantiations of the `execute_operations`
    function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`small_vector`的一个缺点是，我们的元素数量假设泄漏到接受`small_vector`作为参数的函数签名中。因此，如果我们有三个专门用于分别处理`4`、`8`和`16`个元素的函数，并且所有这些函数都使用前面示例中的`execute_operations`进行事务处理，我们将得到`execute_operations`函数的多个实例化：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's not good! Now, we have multiple functions in our executable that do exactly
    the same thing and consist of almost exactly the same machine codes. This leads
    to bigger binaries, longer startup times of the executable, longer compile, and
    link times. Some compilers may eliminate the redundancy but chances are low.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这不好！现在，我们的可执行文件中有多个函数执行完全相同的操作，并且几乎完全由相同的机器代码组成。这会导致更大的二进制文件，可执行文件启动时间更长，编译和链接时间更长。一些编译器可能会消除冗余，但机会很低。
- en: 'However, the solution is very simple. `boost::container::small_vector` is derived
    from the `boost::container::small_vector_base` type that is independent from preallocated
    elements count:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，解决方案非常简单。`boost::container::small_vector`是从`boost::container::small_vector_base`类型派生的，该类型独立于预分配的元素数量：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's it! Now, we may use the new `execute_operations` function with any `boost::container::small_vector`
    without a risk of bloating the binary size.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，我们可以在任何`boost::container::small_vector`中使用新的`execute_operations`函数，而不会使二进制大小膨胀。
- en: C++17 has no `small_vector` like class. There are proposals to include `small_vector`
    to the next C++ standard that will be out somewhere around year 2020.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有像`small_vector`这样的类。有提案将`small_vector`包含在下一个C++标准中，该标准将在2020年左右发布。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `Boost.Container` library has a full reference documentation for many interesting
    classes at [http://boost.org/libs/container](http://boost.org/libs/container)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Container`库在[http://boost.org/libs/container](http://boost.org/libs/container)上为许多有趣的类提供了完整的参考文档'
- en: '`small_vector` came to Boost from the **LLVM** project; you can read about
    the container at the origin site [http://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h](http://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`small_vector`来自**LLVM**项目的Boost；您可以在原始网站[http://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h](http://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h)上阅读有关该容器的信息'
- en: Storing at most N elements in the sequence container
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在序列容器中存储最多N个元素
- en: 'Here''s a question: what container should we use to return the sequence from
    function if we know that the sequence never has more than *N* elements and *N*
    is not big. For example, how we must write the `get_events()` function that returns
    at most five events:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题：如果我们知道序列永远不会超过*N*个元素，而*N*不大，那么我们应该使用什么容器来从函数中返回序列。例如，我们必须如何编写`get_events()`函数，以返回最多五个事件：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `std::vector<event>` allocates memory, so the code from earlier is not a
    good solution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector<event>`分配内存，因此先前的代码不是一个好的解决方案。'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`boost::array<event, 5>` does not allocate memory, but it constructs all the
    five elements. There''s no way to return less than five elements.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::array<event, 5>`不分配内存，但它构造了所有五个元素。没有办法返回少于五个元素。'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `boost::container::small_vector<event, 5>` does not allocate memory for
    five or less elements and allows us to return less than five elements. However,
    the solution is not perfect, because it is not obvious from the function interface
    that it never returns more than five elements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::container::small_vector<event, 5>`不会为五个或更少的元素分配内存，并允许我们返回少于五个元素。但是，这个解决方案并不完美，因为从函数接口中并不明显它永远不会返回超过五个元素。'
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe requires only a basic knowledge of standard library and C++.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程只需要对标准库和C++有基本的了解。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The `Boost.Container` has a container that perfectly satisfies our need:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Container`有一个完全满足我们需求的容器：'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `boost::container::static_vector<T, N>` is a container that does not allocate
    memory and can hold no more than a compile-time-specified amount of elements.
    Think of it as of `boost::container::small_vector<T, N>` that just cannot dynamically
    allocate memory and any attempt to store more than *N* elements results in a `std::bad_alloc`
    exception:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::container::static_vector<T, N>`是一个不分配内存并且最多可以容纳编译时指定数量的元素的容器。可以将其视为`boost::container::small_vector<T,
    N>`，只是它不能动态分配内存，任何尝试存储超过*N*个元素的操作都会导致`std::bad_alloc`异常：'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Just like all the containers of the `Boost.Container` library, `static_vector`
    supports **move semantics** and emulates rvalue references using Boost.Move library
    if your compiler does not support rvalues.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Boost.Container`库的所有容器一样，`static_vector`支持**移动语义**，并且在编译器不支持rvalues的情况下使用Boost.Move库模拟rvalue引用。
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `std::vector` allocates bigger chunks of memory if a user inserts an element
    and it is impossible to fit the new value into the already allocated memory. In
    that case, `std::vector` moves elements from the old location to the new one if
    the elements are nothrow move constructible. Otherwise, `std::vector` copies elements
    to a new location and after that calls destructor for each element in the old
    location.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`如果用户插入一个元素并且无法将新值放入已分配的内存中，则会分配更大的内存块。在这种情况下，如果元素是无异常移动可构造的，则`std::vector`会将元素从旧位置移动到新位置。否则，`std::vector`会将元素复制到新位置，然后调用旧位置中每个元素的析构函数。'
- en: Because of that, behavior `std::vector` has amortized constant complexity for
    many member functions. The `static_vector` never allocates memory so that it does
    not have to move or copy elements from an old location to a new one. Because of
    that, operations that have **amortized O(1)** complexity for `std::vector` have
    true O(1) complexity for `boost::container::static_vector`. This may be handy
    for some real-time applications; though, beware of exceptions!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`std::vector`的行为对于许多成员函数具有摊销常数复杂度。`static_vector`从不分配内存，因此不必将元素从旧位置移动或复制到新位置。因此，对于`std::vector`具有摊销O(1)复杂度的操作，对于`boost::container::static_vector`具有真正的O(1)复杂度。这对于一些实时应用可能很方便；但是要注意异常！
- en: 'Some people still prefer to pass output parameters by reference instead of
    returning them: `void get_events(static_vector<event, 5>& result_out)`. They think
    that this way, there''s a guarantee that no copying of result happens. Don''t
    do that, it makes things worse! C++ compilers have a whole bunch of optimizations,
    such as **Return Value Optimization** (**RVO**) and **Named Return Value Optimization**
    (**NRVO**); different platforms have agreements nailed down in ABI that code with
    `retun something;` does not result in an unnecessary copy and so forth. No copying
    happens already. However, when you pass a value, the reference compiler just does
    not see where the value came from and may assume that it aliases some other value
    in the scope. This may significantly degrade performance.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人仍然更喜欢通过引用传递输出参数，而不是返回它们：`void get_events(static_vector<event, 5>& result_out)`。他们认为这样可以保证不会发生结果的复制。不要这样做，这会使情况变得更糟！C++编译器有一整套优化，例如**返回值优化**（**RVO**）和**命名返回值优化**（**NRVO**）；不同的平台在ABI中已经约定，带有`retun
    something;`的代码不会导致不必要的复制等等。已经不会发生复制。但是，当您传递一个值时，引用编译器只是看不到值来自何处，并且可能会假定它与作用域中的其他值有别名。这可能会严重降低性能。
- en: C++17 has no `static_vector` class, and at this moment, there's no plan to add
    it into C++20.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有`static_vector`类，目前也没有计划将其添加到C++20中。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation of `Boost.Container` has a detailed reference section
    that describes all the member functions of the `boost::container::static_vector`
    class. Refer to [http://boost.org/libs/container.](http://boost.org/libs/container)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Container`的官方文档有一个详细的参考部分，描述了`boost::container::static_vector`类的所有成员函数。参考[http://boost.org/libs/container.](http://boost.org/libs/container)'
- en: "[\uFEFF](http://boost.org/libs/container)"
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: "[\uFEFF](http://boost.org/libs/container)"
- en: Comparing strings in an ultra-fast manner
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以超快速的方式比较字符串
- en: It is a common task to manipulate strings. Here, we'll see how an operation
    of string comparison can be done quickly using some simple tricks. This recipe
    is a trampoline for the next one, where the techniques described here will be
    used to achieve constant time-complexity searches.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 操作字符串是一个常见的任务。在这里，我们将看到如何使用一些简单的技巧快速进行字符串比较操作。这个教程是下一个教程的跳板，这里描述的技术将用于实现常数时间复杂度搜索。
- en: 'So, we need to make some class that is capable of quickly comparing strings
    for equality. We''ll make a template function to measure the speed of comparison:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一个能够快速比较字符串是否相等的类。我们将创建一个模板函数来测量比较的速度：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires only the basic knowledge of standard library and C++.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程只需要基本的标准库和C++知识。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll make `std::string` a public field in our own class and add all the comparison
    code to our class, without writing helper methods to work with the stored `std::string`,
    as shown in the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们自己的类中将`std::string`作为公共字段，并将所有比较代码添加到我们的类中，而不是编写用于处理存储的`std::string`的辅助方法，如下面的步骤所示：
- en: 'To do so, we''ll need the following header:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了这样做，我们需要以下标题：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can create our `fast comparison_` class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的`fast comparison_`类：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Do not forget to define the `equality comparisons` operators:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记定义`equality comparisons`运算符：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And, that''s it! Now, we can run our tests and see the result using the following
    code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样！现在，我们可以运行我们的测试，并使用以下代码查看结果：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The comparison of strings is slow because we are required to compare all the
    characters of the string one-by-one, if strings have equal length. Instead of
    doing that, we replace the comparison of strings with the comparison of integers.
    This is done via the `hash` function - the function that makes some short-fixed
    length representation of the string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的比较很慢，因为我们需要逐个比较字符串的所有字符，如果字符串长度相等的话。我们不是这样做，而是用整数的比较代替字符串的比较。这是通过`hash`函数完成的-这个函数生成字符串的一些短固定长度的表示。
- en: Let's talk about the `hash` values on apples. Imagine that you have two apples
    with labels, as shown in the following diagram, and you wish to check that the
    apples are of the same cultivar. The simplest way to compare those apples is by
    comparing them by labels. Otherwise, you'll lose a lot of time comparing the apples
    based on the color, size, form, and other parameters. Hash is something like a
    label that reflects the value of the object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈苹果上的`hash`值。想象一下，你有两个带标签的苹果，如下图所示，你希望检查这些苹果是否属于同一品种。比较这些苹果最简单的方法是通过比较它们的标签。否则，基于颜色、大小、形状和其他参数比较苹果会浪费很多时间。Hash就像是一个反映对象值的标签。
- en: '![](img/00018.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: Now, let's move step bystep.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步地进行。
- en: 'In *step 1*, we include the header file that contains definitions of the `hash`
    functions. In *step 2*, we declare our new `string` class that contains `str_`,
    which is the original value of string and `comparison_`, which is the computed
    `hash` value. Note the construction:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们包含包含`hash`函数定义的头文件。在*步骤2*中，我们声明了我们的新`string`类，其中包含`str_`，这是字符串的原始值，以及`comparison_`，这是计算出的`hash`值。注意构造：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `boost::hash<std::string>` is a structure, a functional object just like
    `std::negate<>`. That is why we need the first parenthesis--we construct that
    functional object. The second parenthesis with `s` inside is a call to `std::size_t
    operator()(const std::string& s)`, which computes the `hash` value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`boost::hash<std::string>`是一个结构，一个功能对象，就像`std::negate<>`一样。这就是为什么我们需要第一个括号--我们构造了那个功能对象。带有`s`的第二个括号是对`std::size_t
    operator()(const std::string& s)`的调用，它计算了`hash`值。
- en: 'Now, take a look at *step 3,* where we define `operator==`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下*步骤3*，我们定义`operator==`：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Take additional care about the second part of the expression. Hashing operation
    loses information, which means that there is possibly more than one string that
    produces exactly the same `hash` value. It means that if hashes mismatch, there
    is a 100% guarantee that the strings does not match; otherwise, we are required
    to compare strings using the traditional methods.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对表达式的第二部分要特别小心。哈希操作会丢失信息，这意味着可能有多个字符串产生完全相同的`hash`值。这意味着如果哈希不匹配，那么可以百分之百保证字符串不匹配；否则，我们需要使用传统方法比较字符串。
- en: Well, it's time to compare numbers. If we measure the execution time using the
    default comparison method, it'll give us 819 milliseconds; however, our hashing
    comparison works almost two times faster and finishes in 475 milliseconds.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在是比较数字的时候了。如果我们使用默认的比较方法来测量执行时间，它将给出819毫秒；然而，我们的哈希比较工作几乎快两倍，并在475毫秒内完成。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has the `hash` functional object; you may find it in the `<functional>`
    header in the `std::` namespace. Hashing in Boost and standard library is fast
    and reliable. It does not allocate additional memory and also does not have virtual
    functions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C++11有`hash`函数对象；你可以在`std::`命名空间的`<functional>`头文件中找到它。Boost和标准库中的哈希是快速可靠的。它不会分配额外的内存，也不会有虚拟函数。
- en: 'You may specialize hashing for your own types. In Boost, it is done via specializing
    the `hash_value` function in the namespace of a custom type:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为自己的类型专门设计哈希。在Boost中，通过在自定义类型的命名空间中专门设计`hash_value`函数来实现：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is different from standard library specialization of `std::hash`, where
    you are required to make template specialization of the `hash<>` structure in
    the `std::` namespace.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`std::hash`的标准库专门化不同，其中你需要在`std::`命名空间中对`hash<>`结构进行模板专门化。
- en: Hashing in Boost is defined for all the basic types (such as `int`, `float`,
    `double`, and `char`), for arrays, and for all the standard library containers,
    including `std::array`, `std::tuple`, and `std::type_index`. Some libraries also
    provide hash specializations, for example, the `Boost.Variant` library can hash
    any `boost::variant` classes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Boost中，对于所有基本类型（如`int`、`float`、`double`和`char`）、数组以及所有标准库容器，包括`std::array`、`std::tuple`和`std::type_index`，都定义了哈希。一些库还提供了哈希专门化，例如`Boost.Variant`库可以哈希任何`boost::variant`类。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read the *Using unordered set and map* recipe in this chapter for more information
    about the hash functions' usage.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中阅读*使用无序集和映射*配方，了解有关哈希函数使用的更多信息。
- en: The official documentation of `Boost.Functional/Hash` will tell you how to combine
    multiple hashes and provide more examples; read about it at [http://boost.org/libs/functional/hash](http://boost.org/libs/functional/hash).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Functional/Hash`的官方文档将告诉你如何组合多个哈希并提供更多示例；在[http://boost.org/libs/functional/hash](http://boost.org/libs/functional/hash)上阅读有关它的信息。'
- en: Using an unordered set and map
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无序集和映射
- en: 'In the previous recipe, we saw how string comparison can be optimized using
    hashing. After reading it, the following question may arise: can we make a container
    that will cache hashed values to use faster comparison?'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们看到了如何使用哈希来优化字符串比较。阅读之后，可能会产生以下问题：我们是否可以创建一个容器，以便缓存哈希值以便更快地进行比较？
- en: The answer is yes, and we can do much more. We may achieve almost constant search,
    insertion, and removal times for elements.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的，我们还可以做更多。我们可以几乎实现常量搜索、插入和删除元素的时间。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge about C++ and STL containers are required. Reading the previous
    recipe will also help.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本的C++和STL容器的知识。阅读前面的配方也会有所帮助。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This will be the simplest of all recipes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是所有配方中最简单的一个：
- en: All you need to do is just include the `<boost/unordered_map.hpp>` header, if
    you wish to use maps. If we wish to use sets, include the `<boost/unordered_set.hpp>`
    header.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你只需要包含`<boost/unordered_map.hpp>`头文件，如果你想使用映射。如果我们想使用集合，包含`<boost/unordered_set.hpp>`头文件。
- en: 'Now, you are free to use `boost::unordered_map` instead of `std::map` and `boost::unordered_set`
    instead of `std::set`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以自由地使用`boost::unordered_map`代替`std::map`，使用`boost::unordered_set`代替`std::set`：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unordered containers store values and remember the hash of each value. Now if
    you wish to find a value in them, they will compute the hash of that value and
    search for that hash in the container. After hash is found, containers check for
    equality of the found value and the searched value. Then, the iterator to the
    value or to the end of container is returned.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无序容器存储值并记住每个值的哈希。现在，如果你希望在其中找到一个值，它们将计算该值的哈希并在容器中搜索该哈希。找到哈希后，容器会检查找到的值和搜索的值是否相等。然后，返回值的迭代器或容器的末尾。
- en: Because the container may search for the constant width integral hash value,
    it may use some optimizations and algorithms suitable only for integers. Those
    algorithms guarantee constant search complexity O(1), when traditional `std::set`
    and `std::map` provide worse complexity O(log(N)), where *N* is the number of
    elements in the container. This leads us to a situation where the more the elements
    in traditional `std::set` or `std::map`, the slower it works. However, the performance
    of unordered containers does not depend on the element count.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为容器可能搜索常量宽度整数哈希值，它可能使用一些仅适用于整数的优化和算法。这些算法保证了常量搜索复杂度O(1)，而传统的`std::set`和`std::map`提供了更差的复杂度O(log(N))，其中*N*是容器中的元素数量。这导致了这样一种情况：传统的`std::set`或`std::map`中的元素越多，它的工作速度就越慢。然而，无序容器的性能并不取决于元素数量。
- en: 'Such good performance never comes free of cost. In unordered containers, values
    are unordered (you are not surprised, are you?). It means that we''ll be elements
    of containers from `begin()` to `end()` will be the output, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的良好性能从来都不是免费的。在无序容器中，值是无序的（你不会感到惊讶，对吧？）。这意味着我们将从`begin()`到`end()`的容器元素输出如下：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll get the following output for `std::set` and `boost::unordered_set`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到`std::set`和`boost::unordered_set`的以下输出：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, how much does the performance differ? Usually, it depends on the implementation
    quality. I''ve got the following numbers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，性能差异有多大呢？通常取决于实现的质量。我得到了以下数字：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The performance was measured using for the following code block:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是使用以下代码块进行测量的：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code contains a lot of string constructions, so it is not 100% correct to
    measure the speedup using this test. It is here to show that unordered containers
    are usually faster than ordered ones.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含了很多字符串构造，因此使用这个测试来衡量加速并不是100%正确。这里只是为了表明无序容器通常比有序容器更快。
- en: 'Sometimes, a task might arise where we need to use a user-defined type in unordered
    containers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能会出现需要在无序容器中使用用户定义类型的任务：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To do that, we need to write a comparison operator for that type:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要为该类型编写一个比较运算符：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to specialize the hashing function for that type. If the type
    consists of multiple fields, we usually just need to combine hashes of all the
    fields that participate in `equality comparisons`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为该类型专门化哈希函数。如果该类型由多个字段组成，通常只需要组合所有参与`相等比较`的字段的哈希：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is highly recommended to combine hashes using the `boost::hash_combine` function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议使用`boost::hash_combine`函数来组合哈希。
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Multiversions of containers are also available, `boost::unordered_multiset`
    is defined in the `<boost/unordered_set.hpp>` header, and `boost::unordered_multimap`
    is defined in the `<boost/unordered_map.hpp>` header. Just like in the case of
    a standard library, multiversions of containers are capable of storing multiple
    equal key values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 多版本的容器也可用，`boost::unordered_multiset`定义在`<boost/unordered_set.hpp>`头文件中，`boost::unordered_multimap`定义在`<boost/unordered_map.hpp>`头文件中。就像标准库的情况一样，容器的多个版本能够存储多个相等的键值。
- en: All the unordered containers allow you to specify your own hashing functor,
    instead of the default `boost::hash`. They also allow you to specialize your own
    equal comparison functor, instead of the default `std::equal_to`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有无序容器都允许您指定自己的哈希函数，而不是默认的`boost::hash`。它们还允许您专门化自己的相等比较函数，而不是默认的`std::equal_to`。
- en: 'C++11 has all the unordered containers of the Boost library. You may find them
    in the headers: `<unordered_set>` and `<unordered_map>`, in the `std::` namespace,
    instead of `boost::`. The Boost and the standard library versions may differ in
    performance, but must work in the same way. However, Boost''s unordered containers
    are available even on C++03/C++98 compilers and make use of the rvalue reference
    emulation of `Boost.Move`, so you may use those containers for the move-only classes
    even on pre-C++11 compilers.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C++11具有Boost库的所有无序容器。您可以在头文件`<unordered_set>`和`<unordered_map>`中找到它们，它们位于`std::`命名空间中，而不是`boost::`。Boost和标准库版本在性能上可能有所不同，但必须以相同的方式工作。但是，Boost的无序容器甚至可以在C++03/C++98编译器上使用，并利用了`Boost.Move`的右值引用模拟，因此即使在C++11之前的编译器上，您也可以使用这些容器来处理仅移动的类。
- en: 'C++11 has no `hash_combine` function, so you have to write your own:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有`hash_combine`函数，因此您必须自己编写：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Or just use `boost::hash_combine`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者只需使用`boost::hash_combine`。
- en: Since Boost 1.64, unordered containers in Boost have the C++17's functionality
    for extracting and inserting nodes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 自Boost 1.64以来，Boost中的无序容器具有C++17的功能，用于提取和插入节点。
- en: See also
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipe *Using C++11 move emulation* in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, for more details on rvalue reference emulation
    of `Boost.Move`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Boost.Move`的右值引用模拟的更多详细信息，请参阅[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd)中的教程*使用C++11移动模拟*。
- en: More information about the unordered containers is available on the official
    site at [http://boost.org/libs/unordered](http://boost.org/libs/unordered)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关无序容器的更多信息，请访问官方网站[http://boost.org/libs/unordered](http://boost.org/libs/unordered)
- en: More information about combining hashes and computing hashes for ranges are
    available at [http://boost.org/libs/functional/hash](http://boost.org/libs/functional/hash)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关组合哈希和计算范围哈希的更多信息，请访问[http://boost.org/libs/functional/hash](http://boost.org/libs/functional/hash)
- en: Making a map, where value is also a key
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作一个映射，其中值也是一个键
- en: Several times in a year, we need something that may store and index a pair of
    values. Moreover, we need to get the first part of the pair using the second,
    and get the second part using the first. Confused? Let me show you an example.
    We create a vocabulary class. When the users put values into it, the class must
    return identifiers, and when the users put identifiers into it, the class must
    return values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一年中有几次，我们需要一些可以存储和索引一对值的东西。此外，我们需要使用第二个部分来获取第一部分，并使用第一部分来获取第二部分。感到困惑了吗？让我给你举个例子。我们创建一个词汇表类。当用户将值放入其中时，该类必须返回标识符，当用户将标识符放入其中时，该类必须返回值。
- en: To be more practical, users are putting login names in our vocabulary and wish
    to get the unique identifier out of it. They also wish to get all the logins for
    an identifier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更实际，用户们将登录名放入我们的词汇表中，并希望从中获取唯一标识符。他们还希望获取标识符的所有登录名。
- en: Let's see how it can be implemented using Boost.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Boost来实现它。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge about standard library and templates is required for this recipe.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此教程需要对标准库和模板有基本的了解。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This recipe is about the abilities of the `Boost.Bimap` library. Let''s see
    how it can be used to implement this task:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程是关于`Boost.Bimap`库的能力。让我们看看它如何用于实现这个任务：
- en: 'We need the following includes:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下包含：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we are ready to make our vocabulary structure:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备制作我们的词汇结构：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It can be filled using the following syntax:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下语法填充：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can work with the left part of it just like with a map:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像处理映射一样处理它的左部分：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The right part is almost the same as the left:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右边部分几乎与左边相同：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We also need to ensure that there is such a person in vocabulary:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要确保词汇表中有这样的人：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That''s it, now if we put all the code (except includes) inside `int main()`,
    we''ll get the following output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，现在如果我们将所有代码（除了包含）放在`int main()`中，我们将得到以下输出：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In *step 2*, we define the `bimap` type:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们定义了`bimap`类型：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first template parameter tells that the first key must have type `std::string`,
    and should work as `std::set`. The second template parameter tells that the second
    key must have type `std::size_t`. Multiple first keys may have a single second
    key value, just like in `std::multimap`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模板参数表示第一个键必须具有类型`std::string`，并且应该作为`std::set`。第二个模板参数表示第二个键必须具有类型`std::size_t`。多个第一个键可以具有单个第二个键值，就像`std::multimap`中一样。
- en: 'We may specify the underlying behavior of `bimap` using classes from the `boost::bimaps::`
    namespace. We may use hash map as an underlying type for the first key:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`boost::bimaps::`命名空间中的类来指定`bimap`的基本行为。我们可以使用哈希映射作为第一个键的基本类型：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we do not specify the behavior of the key and just specify its type, `Boost.Bimap`
    uses `boost::bimaps::set_of` as a default behavior. Just like in our example,
    we may try to express the following code using standard library:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不指定键的行为，只指定其类型时，`Boost.Bimap`使用`boost::bimaps::set_of`作为默认行为。就像在我们的示例中一样，我们可以尝试使用标准库来表达以下代码：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using standard library it would look like a combination of the following two
    variables:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准库，它看起来像以下两个变量的组合：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see from the preceding comments, a call to `name_id.left` (in *step
    4*) returns a reference to something with an interface close to `std::map<std::string,
    std::size_t>`. A call to `name_id.right` from *step 5* returns something with
    an interface close to `std::multimap<std::size_t, std::string>`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的评论中可以看出，调用`name_id.left`（在*步骤4*中）返回一个接口接近于`std::map<std::string, std::size_t>`的引用。从*步骤5*中调用`name_id.right`返回一个接口接近于`std::multimap<std::size_t,
    std::string>`的东西。
- en: In *step 6*, we work with a whole `bimap`, searching for a pair of keys and
    making sure that they are in the container.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们使用整个`bimap`，搜索一对键，并确保它们在容器中。
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Unfortunately, C++17 has nothing close to `Boost.Bimap`. Here are some other
    bad news:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++17没有类似于`Boost.Bimap`的东西。以下是一些其他坏消息：
- en: '`Boost.Bimap` does not support rvalue references, and on some compilers, insane
    amount of warnings is shown. Refer to your compilers'' documentation to get the
    information about suppressing specific warnings.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Bimap`不支持右值引用，在一些编译器上会显示大量警告。请参考您的编译器文档，了解如何抑制特定警告。'
- en: Good news is that `Boost.Bimap` usually uses less memory than two standard library
    containers and makes searches as fast as standard library containers. It has no
    virtual function calls inside, but uses dynamic allocations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，`Boost.Bimap`通常比两个标准库容器使用更少的内存，并且使搜索速度与标准库容器一样快。它内部没有虚函数调用，而是使用动态分配。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next recipe, *Using multi-index containers*, will give you more information
    about multi-indexing, and about the Boost library that can be used instead of
    `Boost.Bimap`
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个配方，*使用多索引容器*，将为您提供有关多索引和可以用来替代`Boost.Bimap`的Boost库的更多信息
- en: Read the official documentation for more examples and information about `bimap`
    at [http://boost.org/libs/bimap](http://boost.org/libs/bimap)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读官方文档，了解有关`bimap`的更多示例和信息，网址为[http://boost.org/libs/bimap](http://boost.org/libs/bimap)
- en: Using multi-index containers
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多索引容器
- en: 'In the previous recipe, we made some kind of vocabulary, which is good when
    we need to work with pairs. But, what if we need much more advanced indexing?
    Let''s make a program that indexes persons:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们制作了一种词汇，当我们需要处理成对时，这是很好的。但是，如果我们需要更高级的索引呢？让我们制作一个索引人员的程序：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will need a lot of indexes, for example, by name, ID, height, and weight.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要很多索引，例如按名称、ID、身高和体重。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge about standard library containers and unordered maps is required.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本了解标准库容器和无序映射。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: All the indexes can be constructed and managed by a single `Boost.Multiindex`
    container.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的索引都可以由单个`Boost.Multiindex`容器构造和管理。
- en: 'To do so, we need a lot of includes:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们需要很多包含：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The hardest part is to construct `multi-index` type:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最困难的部分是构造`multi-index`类型：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we may insert values into our `multi-index`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将值插入到我们的`multi-index`中：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s construct a function for printing the index content:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建一个打印索引内容的函数：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Print all the indexes as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印所有的索引如下：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Some code from the previous recipe can also be used:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面示例中的一些代码也可以使用：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now if we run our example, it will output the content of indexes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的示例，它将输出索引的内容：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The hardest part here is a construction of multi-index type using `boost::multi_index::multi_index_container`.
    The first template parameter is a class that we are going to index. In our case,
    it is `person`. The second parameter is a type `boost::multi_index::indexed_by`,
    all the indexes must be described as a template parameter of that class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最困难的部分是使用`boost::multi_index::multi_index_container`构造多索引类型。第一个模板参数是我们要索引的类。在我们的例子中，它是`person`。第二个参数是一个类型`boost::multi_index::indexed_by`，所有的索引必须作为该类的模板参数进行描述。
- en: 'Now, let''s take a look at the first index description:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下第一个索引描述：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The usage of the `boost::multi_index::ordered_unique` class means that the index
    must work like `std::set` and have all of its members. The `boost::multi_index::identity<person>`
    class means that the index must use the `operator <` of a `person` class for orderings.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`boost::multi_index::ordered_unique`类意味着索引必须像`std::set`一样工作并且具有所有成员。`boost::multi_index::identity<person>`类意味着索引必须使用`person`类的`operator
    <`进行排序。
- en: 'The next table shows the relation between the `Boost.MultiIndex` types and
    the **STL containers**:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了`Boost.MultiIndex`类型与**STL容器**之间的关系：
- en: '| The `Boost.MultiIndex` types | STL containers |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `Boost.MultiIndex`类型 | STL容器 |'
- en: '| `boost::multi_index::ordered_unique` | `std::set` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::ordered_unique` | `std::set` |'
- en: '| `boost::multi_index::ordered_non_unique` | `std::multiset` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::ordered_non_unique` | `std::multiset` |'
- en: '| `boost::multi_index::hashed_unique` | `std::unordered_set` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::hashed_unique` | `std::unordered_set` |'
- en: '| `boost::multi_index::hashed_non_unique` | `std::unordered_mutiset` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::hashed_non_unique` | `std::unordered_mutiset` |'
- en: '| `boost::multi_index::sequenced` | `std::list` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index::sequenced` | `std::list` |'
- en: 'Take a look at the second index:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下第二个索引：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `boost::multi_index::hashed_non_unique` type means that the index works
    like `std::set`, and `boost::multi_index::member<person, std::size_t, &person::id_>`
    means that the index must apply the hash function only to a single member field
    of the person structure to `person::id_`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::multi_index::hashed_non_unique`类型意味着索引的工作方式类似于`std::set`，而`boost::multi_index::member<person,
    std::size_t, &person::id_>`意味着索引必须仅对person结构的单个成员字段`person::id_`应用哈希函数。'
- en: 'The remaining indexes won''t be a trouble now; so let''s take a look at the
    usage of indexes in the `print` function instead. Getting the type of iterator
    for a specific index is done using the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的索引现在不会有麻烦了；所以让我们看看在`print`函数中使用索引的用法。使用以下代码可以获取特定索引的迭代器类型：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This looks slightly overcomplicated because `Indexes` is a template parameter.
    The example would be simpler, if we could write this code in the scope of `indexes_t`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点复杂，因为`Indexes`是一个模板参数。如果我们可以在`indexes_t`的范围内编写这段代码，示例将会更简单：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `nth_index` member metafunction takes a zero-based number of index to use.
    In our example, index 1 is index of IDs, index 2 is index of heights, and so on.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`nth_index`成员元函数接受一个从零开始的索引号。在我们的例子中，索引1是ID的索引，索引2是高度的索引，依此类推。'
- en: 'Now, let''s take a look at how to use `const_iterator_t`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`const_iterator_t`：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This can also be simplified for `indexes_t` being in scope:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在范围内的`indexes_t`，这也可以简化：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The function `get<indexNo>()` returns index. We may use that index almost like
    an STL container.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`get<indexNo>()`返回索引。我们可以几乎像STL容器一样使用该索引。
- en: There's more...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++17 has no multi-index library. The `Boost.MultiIndex` is a fast library that
    uses no virtual functions. The official documentation of `Boost.MultiIndex` contains
    performance and memory usage measures, showing that this library in most cases
    uses less memory than standard library based handwritten code. Unfortunately,
    `boost::multi_index::multi_index_container` does not support C++11 features and
    also has no rvalue references emulation using `Boost.Move`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有多索引库。`Boost.MultiIndex`是一个快速库，不使用虚拟函数。`Boost.MultiIndex`的官方文档包含性能和内存使用情况的测量，显示该库在大多数情况下使用的内存比基于标准库的手写代码少。不幸的是，`boost::multi_index::multi_index_container`不支持C++11特性，也没有使用`Boost.Move`进行右值引用模拟。
- en: See also
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation of `Boost.MultiIndex` contains tutorials, performance
    measures, examples, and other `Boost.Multiindex` libraries' description of useful
    features. Read about it at [http://boost.org/libs/multi_index.](http://boost.org/libs/multi_index)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.MultiIndex`的官方文档包含教程、性能测量、示例和其他`Boost.Multiindex`库的有用功能描述。请在[http://boost.org/libs/multi_index](http://boost.org/libs/multi_index)上阅读相关内容。'
- en: Getting benefits of a single linked list and memory pool
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获得单链表和内存池的好处
- en: Nowadays, we usually use `std::vector` when we need nonassociative and nonordered
    containers. This is recommended by *Andrei Alexandrescu* and *Herb Sutter* in
    the book *C++ Coding Standards*. Even those users who did not read the book usually
    use `std::vector`. Why? Well, `std::list` is slower and uses much more resources
    than `std::vector`. The `std::deque` container is very close to `std::vector`,
    but does not store values continuously.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，当我们需要非关联和非有序的容器时，我们通常使用`std::vector`。这是由*Andrei Alexandrescu*和*Herb Sutter*在书籍*C++
    Coding Standards*中推荐的。即使没有读过这本书的用户通常也使用`std::vector`。为什么呢？嗯，`std::list`更慢，使用的资源比`std::vector`多得多。`std::deque`容器非常接近`std::vector`，但不连续存储值。
- en: If we need a container where erasing and inserting elements does not invalidate
    iterators, then we are forced to choose a slow `std::list`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个容器，其中删除和插入元素不会使迭代器失效，那么我们被迫选择一个慢的`std::list`。
- en: But wait, we may assemble a better solution using Boost!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等，我们可以使用Boost组装一个更好的解决方案！
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Good knowledge about standard library containers is required to understand the
    introduction part. After that, only basic knowledge of C++ and standard library
    containers is required.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对标准库容器有良好的了解才能理解介绍部分。之后，只需要基本的C++和标准库容器的知识。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll be using two Boost libraries at the same time: `Boost.Pool`
    and a single linked list from `Boost.Container`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将同时使用两个Boost库：`Boost.Pool`和`Boost.Container`中的单链表。
- en: 'We need the following headers:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下头文件：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we need to describe the type of our list. This can be done as shown in
    the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要描述我们列表的类型。可以按照以下代码进行操作：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can work with our single linked list like with `std::list`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像使用`std::list`一样使用我们的单链表：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Some list-specific functions:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些特定于列表的函数：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Memory must be freed using the following code:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须使用以下代码释放内存：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we are using `std::list`, we may notice a slowdown because each node of
    the list needs separate allocation. It means that usually when we insert 10 elements
    into `std::list`, the container calls `new` 10 times. Also, the allocated nodes
    usually are located randomly in memory, which is not CPU cache friendly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`std::list`时，可能会注意到减速，因为列表的每个节点都需要单独分配。这意味着通常当我们向`std::list`插入10个元素时，容器会调用10次`new`。此外，分配的节点通常位于内存中随机位置，这对CPU缓存不友好。
- en: That is why we used Boost `::fast_pool_allocator<int>` from `Boost.Pool`. This
    allocator tries to allocate bigger blocks of memory, so that at a later stage,
    multiple nodes could be constructed without multiple calls to `new`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们使用了Boost.Pool中的Boost `::fast_pool_allocator<int>`。这个分配器尝试分配更大的内存块，这样在后期，可以构造多个节点而不需要多次调用`new`。
- en: The `Boost.Pool` library has a drawback--it uses memory for internal needs.
    Usually, additional `sizeof(void*)` is used per element. To workaround that issue,
    we are using a single linked list from `Boost.Containers`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Pool`库有一个缺点——它使用内存来满足内部需求。通常，每个元素会额外使用`sizeof(void*)`的内存。为了解决这个问题，我们使用了`Boost.Containers`中的单链表。'
- en: The `boost::container::slist` class is more compact, but its iterators can iterate
    only forward. *Step 3* is simple for those readers who are aware of standard library
    containers, so we move to *step 4* to see some `boost::container::slist` specific
    features. Since a single linked list iterator could iterate only forward, traditional
    algorithms of insertion and deletion take linear time O(N). That's because when
    we are erasing or inserting, the previous element of the list must be modified.
    To workaround that issue, the single linked list has methods `erase_after` and
    `insert_after` that work for a constant time O(1). These methods insert or erase
    elements right after the current position of the iterator.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::container::slist`类更加紧凑，但其迭代器只能向前迭代。对于了解标准库容器的读者来说，*步骤3*很简单，所以我们转到*步骤4*来看一些`boost::container::slist`的特定功能。由于单链表迭代器只能向前迭代，插入和删除的传统算法需要线性时间O(N)。这是因为在擦除或插入时，列表的前一个元素必须被修改。为了解决这个问题，单链表有`erase_after`和`insert_after`方法，可以在常数时间O(1)内工作。这些方法在当前迭代器位置之后插入或擦除元素。'
- en: However, erasing and inserting values at the beginning of a single linked lists
    makes no big difference.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在单链表的开头删除和插入值并没有太大的区别。
- en: 'Take a careful look at the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下以下代码：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is required because `boost::fast_pool_allocator` does not free memory, so
    we must do it by hand. The *Doing something at scope exit* recipe from [Chapter
    2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd), *Managing Resources*,
    may be a help in freeing `Boost.Pool`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必需的，因为 `boost::fast_pool_allocator` 不会释放内存，所以我们必须手动释放。[第 2 章](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd)
    中的 *在作用域退出时执行某些操作* 示例，*管理资源*，可能有助于释放 `Boost.Pool`。
- en: 'Let''s take a look at the execution times to feel the difference:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下执行时间，感受一下其中的差异：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we may see, `slist_t` uses half the memory, and is twice as fast compared
    to the `std::list` class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`slist_t` 使用了一半的内存，并且比 `std::list` 类快两倍。
- en: There's more...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Container` library actually has an out-of-the-box solution, called
    `boost::container::stable_vector`. The latter allows random access to the elements,
    has random access iterators, but has most of the performance and memory usage
    drawbacks of `std::list`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Container` 库实际上有一个开箱即用的解决方案，称为 `boost::container::stable_vector`。后者允许对元素进行随机访问，具有随机访问迭代器，但具有
    `std::list` 大部分性能和内存使用缺点。'
- en: C++11 has `std::forward_list`, which is very close to `boost::containers::slist`.
    It also has the `*_after` methods, but has no `size()` method. C++11 and Boost
    versions of single linked list have the same performance and neither of them have
    virtual functions. However, the Boosts version is also usable on C++03 compilers,
    and even has support for rvalue references emulation via `Boost.Move`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 有 `std::forward_list`，它与 `boost::containers::slist` 非常接近。它也有 `*_after`
    方法，但没有 `size()` 方法。C++11 和 Boost 版本的单链表具有相同的性能，它们都没有虚函数。然而，Boost 版本也可以在 C++03
    编译器上使用，并且甚至支持通过 `Boost.Move` 对右值引用进行模拟。
- en: The `boost::fast_pool_allocator` is not in C++17\. However, C++17 has a better
    solution! The header `<memory_resource>` contains useful stuff to work with polymorphic
    allocator, and in there you can find `std::pmr::synchronized_pool_resource`, `std::pmr::unsynchronized_pool_resource`,
    and `std::pmr::monotonic_buffer_resource`. Experiment with those to achieve even
    better performance.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::fast_pool_allocator` 不在 C++17 中。然而，C++17 有一个更好的解决方案！头文件 `<memory_resource>`
    包含了一些有用的内容，可以用于处理多态分配器，在那里你可以找到 `std::pmr::synchronized_pool_resource`、`std::pmr::unsynchronized_pool_resource`
    和 `std::pmr::monotonic_buffer_resource`。尝试使用这些内容来实现更好的性能。'
- en: Guessing why `boost::fast_pool_allocator` does not free the memory by itself?
    That's because C++03 has no stateful allocators, so the containers are not copying
    and storing allocators. That makes it impossible to implement a `boost::fast_pool_allocator`
    function that deallocates memory by itself.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 猜想为什么 `boost::fast_pool_allocator` 不会自动释放内存？那是因为 C++03 没有有状态的分配器，所以容器不会复制和存储分配器。这使得不可能实现一个可以自动释放内存的
    `boost::fast_pool_allocator` 函数。
- en: See also
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation of `Boost.Pool` contains more examples and classes
    to work with memory pools. Follow the link [http://boost.org/libs/pool](http://boost.org/libs/pool)
    to read about it.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Pool` 的官方文档包含了更多的示例和类，用于处理内存池。点击链接 [http://boost.org/libs/pool](http://boost.org/libs/pool)
    了解更多信息。'
- en: The *Using flat associative containers* recipe will introduce you to some more
    classes from `Boost.Container`. You can also read the official documentation of
    `Boost.Container` at [http://boost.org/libs/container](http://boost.org/libs/container)
    to study that library by yourself or to get full reference documentation of its
    classes.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用平面关联容器* 示例将向您介绍 `Boost.Container` 中的一些其他类。您也可以在 [http://boost.org/libs/container](http://boost.org/libs/container)
    阅读 `Boost.Container` 的官方文档，自行学习该库或获取其类的完整参考文档。'
- en: '*Vector vs List*, and other interesting topics from *Bjarne Stroustrup*, the
    inventor of C++ programming language, can be found at [http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style)
    site.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Vector vs List*，以及 C++ 编程语言的发明者 *Bjarne Stroustrup* 的其他有趣主题，可以在 [http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style)
    网站找到。'
- en: Using flat associative containers
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平面关联容器
- en: 'After reading the previous recipe, some of the readers may start using fast
    pool allocators everywhere; especially, for `std::set` and `std::map`. Well, I''m
    not going to stop you from doing that, but at least let''s take a look at an alternative:
    flat associative containers. These containers are implemented on top of the traditional
    vector container and store the values ordered.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了前面的示例之后，一些读者可能会开始在各处使用快速池分配器；特别是对于 `std::set` 和 `std::map`。好吧，我不会阻止你这样做，但至少让我们看看另一种选择：平面关联容器。这些容器是在传统的向量容器之上实现的，并按顺序存储值。
- en: Getting ready
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The basic knowledge about standard library associative containers is required.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本了解标准库关联容器。
- en: How to do it...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The flat containers are part of the `Boost.Container` library. We already saw
    how to use some of its containers in the previous recipes. In this recipe, we''ll
    be using a `flat_set` associative container:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 平面容器是 `Boost.Container` 库的一部分。我们已经看到了如何在之前的示例中使用它的一些容器。在这个示例中，我们将使用 `flat_set`
    关联容器：
- en: 'We''ll need to include only a single header file:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要包含一个头文件：
- en: '[PRE59]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After that, we are free to construct the flat container and experiment with
    it:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以自由地构造平面容器并进行实验：
- en: '[PRE60]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Reserving space for elements:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为元素保留空间：
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Filling the container:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充容器：
- en: '[PRE62]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we can work with it just like with `std::set`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像使用 `std::set` 一样使用它：
- en: '[PRE63]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '*Steps 1* and *2* are simple, but *step 3* requires attention. It is one of
    the most important steps while working with flat associative containers and `std::vector`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1* 和 *步骤 2* 非常简单，但 *步骤 3* 需要注意。这是在使用平面关联容器和 `std::vector` 时最重要的步骤之一。'
- en: The `boost::container::flat_set` class stores its values ordered in vector,
    which means that any insertion or deletion of elements not on the end on the container
    takes liner time O(N), just like in case of `std::vector`. This is a necessary
    evil. But for that, we gain almost three times less memory usage per element,
    more processor cache friendly storage, and random access iterators. Take a look
    at *step 5*, `5.1`, where we were getting the distance between two iterators returned
    by calls to the `lower_bound` member functions. Getting distance with flat set
    takes constant time O(1), while the same operation on iterators of `std::set`
    takes linear time O(N). In case of `5.1`, getting the distance using `std::set`
    would be 400 times slower than getting the distance for flat set containers.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::container::flat_set`类将其值按顺序存储在向量中，这意味着对容器中非末尾元素的任何插入或删除都需要线性时间O(N)，就像`std::vector`一样。这是一个必要的牺牲。但是为此，我们几乎可以减少每个元素的内存使用量三倍，更加友好地存储处理器缓存，并且具有随机访问迭代器。看看*步骤5*，`5.1`，在那里我们得到了通过调用`lower_bound`成员函数返回的两个迭代器之间的距离。使用flat
    set获取距离只需要常数时间O(1)，而在`std::set`的迭代器上进行相同操作需要线性时间O(N)。在*5.1*的情况下，使用`std::set`获取距离的速度比使用flat
    set容器慢400倍。'
- en: Back to *step 3*. Without reserving memory, insertion of elements may become
    at times slower and less memory efficient. The `std::vector` class allocates the
    required chunk of memory and then in-place construct elements on that chunk. When
    we insert some element without reserving the memory, there is a chance that there
    is no free space remaining on the preallocated chunk of memory, so `std::vector`
    allocates a bigger chunk of memory . After that, `std::vector` copies or moves
    elements from the first chunk to the second, deletes elements of the first chunk,
    and deallocates the first chunk. Only after that, insertion occurs. Such copying
    and deallocation may occur multiple times during insertions, dramatically reducing
    the speed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*步骤3*。如果不预留内存，插入元素可能会变得更慢，内存效率也会降低。`std::vector`类会分配所需的内存块，然后在该块上就地构造元素。当我们在没有预留内存的情况下插入一些元素时，有可能预分配的内存块上没有剩余的空间，因此`std::vector`会分配一个更大的内存块。之后，`std::vector`会将元素从第一个块复制或移动到第二个块，删除第一个块的元素，并释放第一个块。只有在此之后才会进行插入。在插入过程中可能会多次发生这种复制和释放，从而大大降低速度。
- en: If you know the count of elements that `std::vector` or any flat container must
    store, reserve the space for those elements before insertion. This speeds up the
    program in most cases!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道`std::vector`或任何扁平容器必须存储的元素数量，请在插入之前为这些元素预留空间。这在大多数情况下可以加快程序！
- en: '*Step 4* is simple, we are inserting elements here. Note that we are inserting
    ordered elements. This is not required, but recommended to speed up insertion.
    Inserting elements at the end of `std::vector` is much more cheaper than in the
    middle or at the beginning.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*很简单，我们在这里插入元素。请注意，我们在这里插入有序元素。这不是必需的，但建议以加快插入速度。在`std::vector`的末尾插入元素比在中间或开头更便宜得多。'
- en: In *step 5*, `5.2` and `5.3` do not differ much, except in their execution speed.
    Rules for erasing elements are pretty much the same as for inserting them. See
    the preceding paragraph for explanations.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，`5.2`和`5.3`并没有太大区别，除了它们的执行速度。删除元素的规则与插入它们的规则几乎相同。有关解释，请参见前一段。
- en: May be I'm telling you simple things about containers, but I saw some very popular
    products that use features of C++11, have insane amount of optimizations and lame
    usage of standard library containers, especially `std::vector`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我正在向你讲述关于容器的简单事情，但我看到一些非常流行的产品使用了C++11的特性，进行了大量的优化，并且对标准库容器的使用非常糟糕，特别是`std::vector`。
- en: In *step 5*, `5.4` shows you that the `std::lower_bound` function works faster
    with `boost::container::flat_set` than with `std::set`, because of random access
    iterators.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，`5.4`向你展示了`std::lower_bound`函数在`boost::container::flat_set`上的速度比在`std::set`上更快，因为它具有随机访问迭代器。
- en: In *step 5*, `5.5` also shows you the benefit of random access iterators.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，`5.5`也向你展示了随机访问迭代器的好处。
- en: We did not use the `std::find` function here. This is because that function
    takes liner time O(N), while the member `find` functions take logarithmic time
    O(log(N)).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有使用`std::find`函数。这是因为该函数需要线性时间O(N)，而成员`find`函数需要对数时间O(log(N))。
- en: There's more...
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When should we use flat containers, and when should we use usual ones? Well,
    it''s up to you, but here is a list of differences from the official documentation
    of `Boost.Container` that will help you to decide:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 何时应该使用扁平容器，何时应该使用常规容器？嗯，这取决于你，但是这里有一份来自`Boost.Container`官方文档的差异列表，可以帮助你做出决定。
- en: A faster lookup than standard associative containers
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比标准关联容器更快的查找
- en: Much faster iteration than standard associative containers
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比标准关联容器更快的迭代
- en: Less memory consumption for small objects (and for big objects if `shrink_to_fit`
    is used)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对小对象的内存消耗更少（如果使用`shrink_to_fit`，对大对象也是如此）
- en: Improved cache performance (data is stored in contiguous memory)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的缓存性能（数据存储在连续内存中）
- en: Nonstable iterators (iterators are invalidated when inserting and erasing elements)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不稳定的迭代器（在插入和删除元素时迭代器会失效）
- en: Non-copyable and non-movable value types can't be stored
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可复制和不可移动的值类型无法存储
- en: Weaker exception safety than standard associative containers (copy/move constructors
    can throw an exception when shifting values in erasures and insertions)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比标准关联容器具有更弱的异常安全性（复制/移动构造函数在移动值时可能会抛出异常）
- en: Slower insertion and erasure than standard associative containers (specially
    for non-movable types)
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入和删除速度比标准关联容器慢（特别是对于不可移动类型）
- en: C++17 unfortunately has no flat containers. Flat containers from Boost are fast,
    have a lot of optimizations, and do not use virtual functions. Classes from `Boost.Containers`
    have support of rvalue reference emulation via `Boost.Move`, so you are free to
    use them even on C++03 compilers.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++17没有平面容器。来自Boost的平面容器速度快，有很多优化，并且不使用虚拟函数。`Boost.Containers`中的类支持通过`Boost.Move`模拟右值引用，因此即使在C++03编译器上也可以自由使用它们。
- en: See also
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to the *Getting benefits of single linked list and memory pool* recipe
    for more information about `Boost.Container`.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Boost.Container`的*获取单链表和内存池的好处*的更多信息，请参考配方。
- en: The recipe *Using C++11 move emulation* in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*, will give you the basics of emulation rvalue
    references on C++03 compatible compilers.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd) *开始编写您的应用程序* 中的*使用C++11移动模拟*配方将为您提供关于在兼容C++03的编译器上模拟右值引用的基础知识。
- en: "The official documentation of `Boost.Container` contains a lot of useful information\
    \ about `Boost.Container` and full reference of each class. Read about it at [http://boost.org/libs/container.\uFEFF\
    ](http://boost.org/libs/container)"
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: "`Boost.Container`的官方文档包含大量关于`Boost.Container`和每个类的完整参考的有用信息。请访问[http://boost.org/libs/container.\uFEFF\
    ](http://boost.org/libs/container)了解更多信息。"
