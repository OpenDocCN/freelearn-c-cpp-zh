- en: '*Chapter 10*: Processing LLVM IR'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：处理 LLVM IR'
- en: In the previous chapter, we learned about PassManager and AnalysisManager in
    LLVM. We went through some tutorials for developing an LLVM pass and how to retrieve
    program analysis data via AnalysisManager. The knowledge and skills we acquired
    help to build the foundation for developers to create composable building blocks
    for code transformation and program analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 LLVM 中的 PassManager 和 AnalysisManager。我们回顾了一些关于开发 LLVM pass 以及如何通过
    AnalysisManager 获取程序分析数据的教程。我们获得的知识和技能有助于为开发者构建代码转换和程序分析的可组合构建块的基础。
- en: In this chapter, we are going to focus on the methodology of processing **LLVM
    IR**. LLVM IR is a target-independent **intermediate representation** for program
    analysis and compiler transformation. You can think of LLVM IR as an *alternative*
    form of the code you want to optimize and compile. However, different from the
    C/C++ code you're familiar with, LLVM IR describes the program in a different
    way – we will give you a more concrete idea later. The majority of the *magic*
    that's done by LLVM that makes the input program faster or smaller after the compilation
    process is performed on LLVM IR. Recall that in the previous chapter, [*Chapter
    9*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127), *Working with PassManager
    and AnalysisManager*, we described how different passes are organized in a pipeline
    fashion – that was the high-level structure of how LLVM transforms the input code.
    In this chapter, we are going to show you the fine-grained details of how to modify
    LLVM IR in an efficient way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注处理 **LLVM IR** 的方法。LLVM IR 是一个针对程序分析和编译转换的独立目标 **中间表示**。你可以将 LLVM
    IR 视为你想要优化和编译的代码的 *替代* 形式。然而，与您熟悉的 C/C++ 代码不同，LLVM IR 以不同的方式描述程序——我们稍后会给你一个更具体的概念。LLVM
    在编译过程中对 LLVM IR 执行的操作中，大部分 *魔法* 都是为了使输入程序在编译后更快或更小。回想一下，在上一章中，[*第 9 章*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127)，*与
    PassManager 和 AnalysisManager 一起工作*，我们描述了如何以管道方式组织不同的 pass——那是 LLVM 转换输入代码的高级结构。在本章中，我们将向您展示如何以高效的方式修改
    LLVM IR 的详细细节。
- en: Although the most straightforward and visual way to view LLVM IR is by its textual
    representation, LLVM provides libraries that contain a set of powerful modern
    C++ APIs to interface with the IR. These APIs can inspect the in-memory representation
    of LLVM IR and help us manipulate it, which effectively changes the target program
    we are compiling. These LLVM IR libraries can be embedded in a wide variety of
    applications, allowing developers to transform and analyze their target source
    code with ease.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过文本表示查看 LLVM IR 是最直接和直观的方式，但 LLVM 提供了包含一组强大现代 C++ API 的库，用于与 IR 接口。这些 API
    可以检查 LLVM IR 的内存表示，并帮助我们操作它，这实际上改变了我们要编译的目标程序。这些 LLVM IR 库可以嵌入到各种应用中，使开发者能够轻松地转换和分析他们的目标源代码。
- en: LLVM APIs for different programming languages
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不同编程语言的 LLVM API
- en: 'Officially, LLVM only supports APIs for two languages: C and C++. Between them,
    C++ is the most feature-complete and update to date, but it also has the most
    *unstable* interface – it might be changed at any time without backward compatibility.
    On the other hand, C APIs have stable interfaces but come at the cost of lagging
    behind new feature updates, or even keeping certain features absent. The API bindings
    for OCaml, Go, and Python are in the source tree as community-driven projects.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，LLVM 只支持两种语言的 API：C 和 C++。在这两者之间，C++ 是功能最完整且更新到最新的，但它也拥有最 *不稳定* 的接口——它可能在任何时候更改，而不具备向后兼容性。另一方面，C
    API 拥有稳定的接口，但代价是落后于新功能更新，甚至某些功能可能缺失。OCaml、Go 和 Python 的 API 绑定作为社区驱动的项目存在于源代码树中。
- en: 'We will try to guide you with generally applicable learning blocks driven by
    commonly seen topics and tasks that are supported by many realistic examples.
    Here is the list of topics we''ll cover in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试通过通常适用的学习块，由常见主题和任务驱动，这些主题和任务由许多现实世界的示例支持来引导您。以下是本章我们将涵盖的主题列表：
- en: Learning LLVM IR basics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 LLVM IR 基础
- en: Working with values and instructions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与值和指令一起工作
- en: Working with loops
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与循环一起工作
- en: We will start by introducing LLVM IR. Then, we will learn about two of the most
    essential elements in LLVM IR – values and instructions. Finally, we'll end this
    chapter by looking at loops in LLVM – a more advanced topic that is crucial for
    working on performance-sensitive applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍LLVM IR。然后，我们将学习LLVM IR中最基本的两个元素——值和指令。最后，我们将通过查看LLVM中的循环来结束本章，这是一个更高级的话题，对于处理性能敏感的应用至关重要。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The tools we''ll need in this chapter are the `opt` command-line utility and
    `clang`. Please build them using the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们需要使用的工具是`opt`命令行实用程序和`clang`。请使用以下命令构建它们：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most of the code in this chapter can be implemented inside LLVM pass – and the
    pass plugin – as introduced in [*Chapter 9*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127),
    *Working with PassManager and AnalysisManager*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大部分代码都可以实现在LLVM pass和pass插件中，如第9章中介绍的[*第9章*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127)，*与PassManager和AnalysisManager一起工作*。
- en: 'In addition, please install the **Graphviz** tool. You can consult the following
    page for an installation guide for your system: [https://graphviz.org/download](https://graphviz.org/download).
    On Ubuntu, for instance, you can install that package via the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请安装**Graphviz**工具。您可以通过以下页面了解您系统的安装指南：[https://graphviz.org/download](https://graphviz.org/download)。例如，在Ubuntu上，您可以使用以下命令安装该软件包：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will use a command-line tool – the `dot` command – provided by Graphviz to
    visualize the control flow of a function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Graphviz提供的命令行工具`dot`来可视化函数的控制流。
- en: The code example mentioned in this chapter can be implemented inside LLVM pass,
    if not specified otherwise.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提到的代码示例可以实现在LLVM pass中，除非另有说明。
- en: Learning LLVM IR basics
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习LLVM IR基础知识
- en: 'LLVM IR is an alternative form of the program you want to optimize and compile.
    It is, however, structured differently from normal programming languages such
    as C/C++. LLVM IR is organized in a hierarchical fashion. The levels in this hierarchy
    – counting from the top – are **Module**, **function**, **basic block**, and **instruction**.
    The following diagram shows their structure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR是您想要优化和编译的程序的一种替代形式。然而，它与C/C++等常规编程语言的结构不同。LLVM IR以分层的方式组织。这个层次结构的级别（从顶部开始计数）是**模块**、**函数**、**基本块**和**指令**。以下图表显示了它们的结构：
- en: '![Figure 10.1 – Hierarchy structure of LLVM IR'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – LLVM IR的层次结构'
- en: '](img/B14590_Figure_10.1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_10.1.jpg)'
- en: Figure 10.1 – Hierarchy structure of LLVM IR
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – LLVM IR的层次结构
- en: A **module** represents a translation unit – usually a source file. Each module
    can contain multiple **functions** (or global variables). Each contains a list
    of **basic blocks** where each of the basic blocks contains a list of **instructions**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块**代表一个翻译单元——通常是一个源文件。每个模块可以包含多个**函数**（或全局变量）。每个函数包含一个**基本块**列表，其中每个基本块包含一个**指令**列表。'
- en: Quick refresher – basic block
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾——基本块
- en: A basic block represents a list of instructions with only one entry and one
    exit point. In other words, if a basic block is executed, the control flow is
    guaranteed to walk through every instruction in the block.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块代表一系列指令，只有一个入口和一个出口点。换句话说，如果一个基本块被执行，控制流将保证遍历该块中的每个指令。
- en: 'Knowing the high-level structure of LLVM IR, let''s look at one of the LLVM
    IR examples. Let''s say we have the following C code, `foo.c`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 了解LLVM IR的高级结构后，让我们看看一个LLVM IR的示例。假设我们有以下C代码，`foo.c`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use the following `clang` command to generate its *textual* LLVM IR
    counterpart:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下`clang`命令生成其*文本*形式的LLVM IR对应物：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result will be put in the `foo.ll` file. The following diagram shows part
    of its content, with annotations for the corresponding IR unit:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将被放入`foo.ll`文件中。以下图表显示了其内容的一部分，并带有对相应IR单元的注释：
- en: '![Figure 10.2 – Part of the content in foo.ll, annotated with the corresponding
    IR unit'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 – foo.ll中的部分内容，带有相应的IR单元注释'
- en: '](img/B14590_Figure_10.2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_10.2.jpg)'
- en: Figure 10.2 – Part of the content in foo.ll, annotated with the corresponding
    IR unit
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – foo.ll中的部分内容，带有相应的IR单元注释
- en: 'In textual form, an instruction is usually presented in the following format:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本形式中，指令通常以以下格式呈现：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For instance, let''s assume we have the following instruction:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下指令：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `%12` is the result value, `load` is the op-code, `i32` is the data type
    of this instruction, and `%3` is the only operand.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`%12` 是结果值，`load` 是操作码，`i32` 是此指令的数据类型，而 `%3` 是唯一的操作数。
- en: In addition to the textual representation, nearly every component in LLVM IR
    has a C++ class counterpart with the same name. For instance, a function and a
    basic block are simply represented by `Function` and the `BasicBlock` C++ class,
    respectively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文本表示之外，LLVM IR 中几乎每个组件都有一个与同名字符相同的 C++ 类对应。例如，函数和基本块分别简单地表示为 `Function` 和
    `BasicBlock` C++ 类。
- en: Different kinds of instructions are represented by classes that are all derived
    from the `Instruction` class. For example, the `BinaryOperator` class represents
    a binary operation instruction, while `ReturnInst` class represents a return statement.
    We will look at `Instruction` and its child classes in more detail later.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的指令类型由从 `Instruction` 类派生出的类表示。例如，`BinaryOperator` 类表示二元运算指令，而 `ReturnInst`
    类表示返回语句。我们将在稍后更详细地探讨 `Instruction` 及其子类。
- en: 'The hierarchy depicted in *Figure 10.1* is the **concrete** structure of LLVM
    IR. That is, this is how they are stored in memory. On top of that, LLVM also
    provides other *logical* structures to view the relationships of different IR
    units. They are usually evaluated from the concrete structures and stored as auxiliary
    data structures or treated as analysis results. Here are some of the most important
    ones in LLVM:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.1* 中所示的结构是 LLVM IR 的**具体**结构。也就是说，这就是它们在内存中的存储方式。除此之外，LLVM 还提供了其他*逻辑*结构来查看不同
    IR 单元之间的关系。它们通常从具体结构评估并存储为辅助数据结构或作为分析结果。以下是 LLVM 中一些最重要的结构：'
- en: '**Control Flow Graph** (**CFG**): This is a graph structure that''s organized
    into basic blocks to show their control flow relations. The vertices in this graph
    represent basic blocks, while the edges represent a single control flow transfer.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制流图**（**CFG**）：这是一种组织成基本块的图结构，用于显示它们的控制流关系。该图中的顶点代表基本块，而边代表单个控制流转移。'
- en: '**Loop**: This represents the loop we are familiar with, which consists of
    multiple basic blocks that have at least one back edge – a control flow edge that
    goes back to its parent or ancestor vertices. We will look at this in more detail
    in the last section of this chapter, the *Working with loops* section.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环**：这代表我们熟悉的循环，由至少有一个回边（控制流边回到其父节点或祖先节点）的多个基本块组成。我们将在本章的最后部分，即“与循环一起工作”部分中更详细地探讨这一点。'
- en: '**Call graph**: Similar to CFG, the call graph also shows control flow transfers,
    but the vertices become individual functions and the edges become function call
    relations.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用图**：与 CFG 类似，调用图也显示了控制流转移，但顶点变为单个函数，边变为函数调用关系。'
- en: In the next section, we are going to learn how to iterate through different
    IR units in both concrete and logical structures.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在具体和逻辑结构中遍历不同的 IR 单元。
- en: Iterating different IR units
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历不同的 IR 单元
- en: 'Iterating IR units – such as basic blocks or instructions – are *essential*
    to LLVM IR development. It is usually one of the first steps we must complete
    in many transformation or analysis algorithms – scanning through the whole code
    and finding an interesting area in order to apply certain measurements. In this
    section, we are going to learn about the practical aspects of iterating different
    IR units. We will cover the following topics:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历 IR 单元（如基本块或指令）对于 LLVM IR 开发至关重要。这通常是我们在许多转换或分析算法中必须首先完成的步骤之一——扫描整个代码并找到一个有趣区域，以便应用某些测量。在本节中，我们将学习遍历不同
    IR 单元的实际方面。我们将涵盖以下主题：
- en: Iterating instructions
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历指令
- en: Iterating basic blocks
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历基本块
- en: Iterating the call graph
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历调用图
- en: Learning the GraphTraits
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 GraphTraits
- en: Let's start by discussing how to iterate instructions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论如何遍历指令开始。
- en: Iterating instructions
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历指令
- en: An instruction is one of the most basic elements in LLVM IR. It usually represents
    a single action in the program, such as an arithmetic operation or a function
    call. Walking through all the instructions in a single basic block or function
    is the cornerstone of most program analyses and compiler optimizations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是 LLVM IR 中最基本元素之一。它通常代表程序中的单个操作，例如算术运算或函数调用。遍历单个基本块或函数中的所有指令是大多数程序分析和编译器优化的基石。
- en: 'To iterate through all the instructions in a basic block, you just need to
    use a simple for-each loop over the block:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历基本块中的所有指令，你只需要使用一个简单的for-each循环即可：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can iterate through all the instructions in a function in two ways. First,
    we can iterate over all the basic blocks in the function before visiting the instructions.
    Here is an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式遍历函数中的所有指令。首先，我们可以在访问指令之前遍历函数中的所有基本块。以下是一个例子：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Second, you can leverage a utility called `inst_iterator`. Here is an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是利用一个名为`inst_iterator`的实用工具。以下是一个例子：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the preceding code, you can retrieve all the instructions in this function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，你可以检索此函数中的所有指令。
- en: Instruction visitor
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指令访问者
- en: 'There are many cases where we want to apply different treatments to different
    types of instructions in a basic block or function. For example, let''s assume
    we have the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们希望对一个基本块或函数中的不同类型的指令应用不同的处理方式。例如，假设我们有以下代码：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Recall that different kinds of instructions are modeled by (different) classes
    derived from `Instruction`. Therefore, an `Instruction` instance can represent
    any of them. The `getOpcode` method shown in the preceding snippet can give you
    a unique token – namely, `Instruction::BinaryOperator` and `Instruction::Return`
    in the given code – that tells you about the underlying class. However, if we
    want to work on the derived class ( `ReturnInst`, in this case) instance rather
    than the "raw" `Instruction`, we need to do some type casting.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，不同类型的指令是通过从`Instruction`派生出的（不同的）类来建模的。因此，一个`Instruction`实例可以代表它们中的任何一个。前面代码片段中显示的`getOpcode`方法可以给你一个唯一的令牌——即给定代码中的`Instruction::BinaryOperator`和`Instruction::Return`——这告诉你关于底层类的信息。然而，如果我们想对派生类（在这种情况下是`ReturnInst`）实例而不是“原始”的`Instruction`进行操作，我们需要进行一些类型转换。
- en: 'LLVM provides a better way to implement this kind of visiting pattern –`InstVisitor`.
    `InstVisitor` is a class where each of its member methods is a callback function
    for a specific instruction type. You can define your own callbacks after inheriting
    from the `InstVisitor` class. For instance, check out the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM提供了一种更好的方式来实现这种访问模式——`InstVisitor`。`InstVisitor`是一个类，其中每个成员方法都是特定指令类型的回调函数。你可以在从`InstVisitor`类继承后定义自己的回调。例如，查看以下代码片段：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each `visitXXX` method shown here is a callback function for a specific instruction
    type. Note that we are *not* overriding each of these methods (there was no `override`
    keyword attached to the method). Also, instead of defining callbacks for all the
    instruction types, `InstVisitor` allows you to only define those that we are interested
    in.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的每个`visitXXX`方法都是特定指令类型的回调函数。请注意，我们并没有覆盖这些方法（方法上没有附加`override`关键字）。此外，`InstVisitor`允许你只定义我们感兴趣的回调，而不是为所有指令类型定义回调。
- en: 'Once `MyInstVisitor` has been defined, we can simply create an instance of
    it and invoke the `visit` method to launch the visiting process. Let''s take the
    following code as an example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了`MyInstVisitor`，我们就可以简单地创建其实例并调用`visit`方法来启动访问过程。以下代码作为例子：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are also `visit` methods for `Instruction`, `BasicBlock`, and `Module`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Instruction`、`BasicBlock`和`Module`也有`visit`方法。
- en: Ordering basic blocks and instructions
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块和指令的排序
- en: All the skills we've introduced in this section assume that the `Function` doesn't
    store or iterate its enclosing `BasicBlock` instances in a particular *linear*
    order. We will show you how to iterate through all the basic blocks in various
    meaningful orders shortly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们介绍的所有技能都假设`Function`不会以特定的*线性*顺序存储或迭代其封装的`BasicBlock`实例。我们将在不久的将来向你展示如何以各种有意义的顺序遍历所有基本块。
- en: With that, you've learned several ways to iterate instructions from a basic
    block or a function. Now, let's learn how to iterate basic blocks in a function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了从基本块或函数中迭代指令的几种方法。现在，让我们学习如何在函数中迭代基本块。
- en: Iterating basic blocks
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代基本块
- en: In the previous section, we learned how to iterate basic blocks of a function
    using a simple for loop. However, developers can only receive basic blocks in
    an *arbitrary* order in this way – that ordering gave you neither the execution
    order nor the control flow information among the blocks. In this section, we will
    show you how to iterate basic blocks in a more meaningful way.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用简单的for循环迭代函数的基本块。然而，开发者只能以*任意*顺序接收基本块，这种方式并没有给你提供块的执行顺序或块之间的控制流信息。在本节中，我们将向您展示如何以更有意义的方式迭代基本块。
- en: 'Basic blocks are important elements for expressing the control flow of a function,
    which can be represented by a directed graph – namely, the `opt` tool. Assuming
    you have an LLVM IR file, `foo.ll`, you can use the following command to print
    out the CFG of each function in Graphviz format:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块是表达函数控制流的重要元素，可以用有向图表示，即`opt`工具。假设你有一个LLVM IR文件，`foo.ll`，你可以使用以下命令以Graphviz格式打印出每个函数的CFG：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command will generate one `.dot` file for each function in `foo.ll`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为`foo.ll`中的每个函数生成一个`.dot`文件。
- en: The .dot File might be hidden
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dot`文件可能被隐藏'
- en: The filename of the CFG `.dot` file for each function usually starts with a
    dot character (`'.'`). On Linux/Unix systems, this effectively *hides* the file
    from the normal `ls` command. So, use the `ls -a` command to show those files
    instead.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的控制流图（CFG）`.dot`文件的文件名通常以点字符（`'.'`）开头。在Linux/Unix系统中，这实际上*隐藏*了文件，使其不被正常的`ls`命令所显示。因此，请使用`ls
    -a`命令来显示这些文件。
- en: 'Each `.dot` file contains the Graphviz representation of that function''s CFG.
    Graphviz is a general and textual format for expressing graphs. People usually
    convert a `.dot` file into other (image) formats before studying it. For instance,
    using the following command, you can convert a `.dot` file into a PNG image file
    that visually shows the graph:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`.dot`文件都包含该函数CFG的Graphviz表示。Graphviz是一种用于表示图的通用文本格式。人们在研究之前通常将`.dot`文件转换为其他（图像）格式。例如，使用以下命令，你可以将`.dot`文件转换为PNG图像文件，该文件可以直观地显示图形：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following diagram shows two examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了两个示例：
- en: '![Figure 10.3 – Left: CFG for a function containing branches; right: CFG for
    a function containing a loop'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 左：包含分支的函数的CFG；右：包含循环的函数的CFG'
- en: '](img/B14590_Figure_10.3.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_10.3.jpg)'
- en: 'Figure 10.3 – Left: CFG for a function containing branches; right: CFG for
    a function containing a loop'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 左：包含分支的函数的CFG；右：包含循环的函数的CFG
- en: The left-hand side of the preceding diagram shows a CFG for a function containing
    several branches; the right-hand side shows a CFG for a function containing a
    single loop.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表的左侧显示了包含多个分支的函数的CFG；右侧显示了包含单个循环的函数的CFG。
- en: 'Now, we know that basic blocks are organized as a directed graph – namely,
    the CFG. Can we iterate this CFG so that it follows the edges and nodes? LLVM
    answers this question by providing utilities for iterating a graph in four different
    ways: topological order, depth first (essentially doing **DFS**), breadth first
    (essentially doing **BFS**), and **Strongly Connected Components** (**SCCs**).
    We are going to learn how to use each of these utilities in the following subsections.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道基本块是以有向图的形式组织的，即CFG。我们能否迭代这个CFG，使其遵循边和节点？LLVM通过提供四种不同方式迭代图的功能来回答这个问题：拓扑排序、深度优先（本质上做**DFS**）、广度优先（本质上做**BFS**）和**强连通分量**（**SCCs**）。我们将在以下小节中学习如何使用这些实用工具中的每一个。
- en: Let's start with topological order traversal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从拓扑排序遍历开始。
- en: Topological order traversal
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拓扑排序遍历
- en: 'Topological ordering is a simple linear ordering that guarantees that for each
    node in the graph, it will only be visited after we''ve visited all of its parent
    (predecessor) nodes. LLVM provides `po_iterator` and some other utility functions
    to implement *reversed* topological ordering (reversed topological ordering is
    easier to implement) on the CFG. The following snippet gives an example of using
    `po_iterator`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序是一种简单的线性排序，它保证了对于图中的每个节点，我们只有在访问了所有父节点（前驱节点）之后才会访问它。LLVM提供了`po_iterator`和其他一些实用函数，以在控制流图（CFG）上实现*逆序*拓扑排序（逆序拓扑排序更容易实现）。以下代码片段给出了使用`po_iterator`的示例：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `post_order` function is just a helper function to create an iteration range
    of `po_iterator`. Note that the `llvm/IR/CFG.h` header is necessary to make `po_iterator`
    work on `Function` and `BasicBlock`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_order` 函数只是一个辅助函数，用于创建 `po_iterator` 的迭代范围。请注意，`llvm/IR/CFG.h` 头文件对于使
    `po_iterator` 在 `Function` 和 `BasicBlock` 上工作是必要的。'
- en: 'If we apply the preceding code to the function containing branches in the preceding
    diagram, we''ll get the following command-line output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码应用于前面图中包含分支的函数，我们将得到以下命令行输出：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, you can traverse from a specific basic block using nearly the
    same syntax; for instance:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用几乎相同的语法从特定的基本块开始遍历；例如：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding snippet will give you the same result as the previous one since
    it's traveling from the entry block. You're free to traverse from the arbitrary
    block, though.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将给出与上一个相同的结果，因为它是从入口块开始的。尽管如此，你也可以从任意块开始遍历。
- en: Depth-first and breadth-first traversal
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深度优先和广度优先遍历
- en: '**DFS** and **BFS** are two of the most famous and iconic algorithms for visiting
    topological structures such as a graph or a tree. For each node in a tree or a
    graph, DFS will always try to visit its child nodes before visiting other nodes
    that share the same parents (that is, the *sibling* nodes). On the other hand,
    BFS will traverse all the sibling nodes before moving to its child nodes.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**DFS** 和 **BFS** 是访问拓扑结构（如图或树）中最著名和标志性的算法之二。对于树或图中的每个节点，DFS 总是会尝试在访问具有相同父节点的其他节点（即
    *兄弟* 节点）之前访问其子节点。另一方面，BFS 会遍历所有兄弟节点，然后再移动到其子节点。'
- en: 'LLVM provides `df_iterator` and `bf_iterator` (and some other utility functions)
    to implement depth-first and breadth-first ordering, respectively. Since their
    usages are nearly identical, we are only going to demonstrate `df_iterator` here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 提供了 `df_iterator` 和 `bf_iterator`（以及一些其他实用函数）来实现深度优先和广度优先排序。由于它们的用法几乎相同，我们在这里只演示
    `df_iterator`：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similar to `po_iterator` and `post_order`, `depth_first` is just a utility
    function for creating an iteration range of `df_iterator`. To use `bf_iterator`,
    simply replace `depth_first` with `breadth_first`. If you apply the preceding
    code to the containing branches in the preceding diagram, it will give you the
    following command-line output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `po_iterator` 和 `post_order` 类似，`depth_first` 只是一个用于创建 `df_iterator` 迭代范围的实用函数。要使用
    `bf_iterator`，只需将 `depth_first` 替换为 `breadth_first`。如果你将前面的代码应用于前面图中的包含分支，它将给出以下命令行输出：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When using `bf_iterator`/`breadth_first`, we will get the following command-line
    output for the same example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `bf_iterator`/`breadth_first` 时，对于相同的示例，我们将得到以下命令行输出：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`df_iterator` and `bf_iterator` can also be used with `BasicBlock`, in the
    same way as `po_iterator` shown previously.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`df_iterator` 和 `bf_iterator` 也可以与 `BasicBlock` 一起使用，就像前面展示的 `po_iterator`
    一样。'
- en: SSC traversal
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSC 遍历
- en: An **SCC** represents a subgraph where every enclosing node can be reached from
    every other node. In the context of CFG, it is useful to traverse CFG with loops.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**SCC** 表示一个子图，其中每个包围节点都可以从其他任何节点到达。在 CFG 的上下文中，使用循环遍历 CFG 是很有用的。'
- en: The basic block traversal methods we introduced earlier are useful tools to
    reason about the control flow in a function. For a loop-free function, these methods
    give you a linear view that closely reflects the execution orders of enclosing
    basic blocks. However, for a function that contains loops, these (linear) traversal
    methods cannot show the cyclic execution flow that's created by the loops.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前介绍的基本块遍历方法是有用的工具，可以用来推理函数中的控制流。对于一个无循环的函数，这些方法为你提供了一个线性视图，该视图与包围基本块的执行顺序紧密相关。然而，对于一个包含循环的函数，这些（线性）遍历方法无法显示由循环创建的循环执行流。
- en: Recurring control flow
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重复控制流
- en: Loops are not the only programming constructs that create recurring control
    flows within a function. A few other directives – the `goto` syntax in C/C++,
    for example – will also introduce a recurring control flow. However, those corner
    cases will make analyzing the control flow more difficult (which is one of the
    reasons you shouldn't use `goto` in your code), so when we are talking about recurring
    control flows, we are only referring to loops.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 循环并不是在函数内部创建重复控制流的唯一编程结构。一些其他指令——例如 C/C++ 中的 `goto` 语法——也会引入重复控制流。然而，这些特殊情况会使分析控制流变得更加困难（这也是你不应该在代码中使用
    `goto` 的原因之一），因此当我们谈论重复控制流时，我们仅指代循环。
- en: Using `scc_iterator` in LLVM, we can traverse strongly connected basic blocks
    in a CFG. With this information, we can quickly spot a recurring control flow,
    which is crucial for some analysis and program transformation tasks. For example,
    we need to know the back edges and recurring basic blocks in order to accurately
    propagate the branch probability data along the control flow edges.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM中使用`scc_iterator`，我们可以遍历CFG中的强连通基本块。有了这些信息，我们可以快速找到重复的控制流，这对于某些分析和程序转换任务至关重要。例如，为了准确地在控制流边沿传播分支概率数据，我们需要知道回边和重复的基本块。
- en: 'Here is an example of using `scc_iterator`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`scc_iterator`的示例：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Different from the previous traversal methods, `scc_iterator` doesn't provide
    a handy range-style iteration. Instead, you need to create a `scc_iterator` instance
    using `scc_begin` and do manual increments. More importantly, you should use the
    `isAtEnd` method to check the exit condition, rather than doing a comparison with
    the "end" iterator like we usually do with C++ STL containers. A vector of `BasicBlock`
    can be dereferenced from a single `scc_iterator`. These `BasicBlock` instances
    are the basic blocks within a SCC. The ordering among these SCC instances is roughly
    the same as in the reversed topological order – namely, the post ordering we saw
    earlier.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的遍历方法不同，`scc_iterator`不提供方便的范围式迭代。相反，你需要使用`scc_begin`创建一个`scc_iterator`实例，并进行手动递增。更重要的是，你应该使用`isAtEnd`方法来检查退出条件，而不是像我们通常与C++
    STL容器进行比较那样与“end”迭代器进行比较。可以从单个`scc_iterator`解引用一个`BasicBlock`向量。这些`BasicBlock`实例是SCC内的基本块。这些SCC实例的顺序大致与反转拓扑顺序相同——即我们之前看到的后序。
- en: 'If you run the preceding code over the function that contains a loop in the
    preceding diagram, it gives you the following command-line output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码在包含前面图中循环的函数上，它将给出以下命令行输出：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This shows that basic blocks `%4` and `%2` are in the same SCC.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明基本块`%4`和`%2`位于同一个强连通分量（SCC）中。
- en: With that, you've learned how to iterate basic blocks within a function in different
    ways. In the next section, we are going to learn how to iterate functions within
    a module by following the call graph.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了以不同的方式遍历函数中的基本块。在下一节中，我们将学习如何通过遵循调用图来遍历模块内的函数。
- en: Iterating the call graph
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历调用图
- en: A call graph is a direct graph that represents the function call relationships
    in a module. It plays an important role in **inter-procedural** code transformation
    and analysis, namely, analyzing or optimizing code across multiple functions.
    A famous optimization called **function inlining** is an example of this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 调用图是一个直接图，它表示模块中函数之间的调用关系。它在**跨过程**代码转换和分析中扮演着重要角色，即分析或优化跨多个函数的代码。一个著名的优化称为**函数内联**，就是这种情况的一个例子。
- en: 'Before we dive into the details of iterating nodes in the call graph, let''s
    take a look at how to build a call graph. LLVM uses the `CallGraph` class to represent
    the call graph of a single `Module`. The following sample code uses a pass module
    to build a `CallGraph`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到调用图中节点迭代的细节之前，让我们看看如何构建一个调用图。LLVM使用`CallGraph`类来表示单个`Module`的调用图。以下示例代码使用一个pass模块来构建`CallGraph`：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This snippet built a `CallGraph` instance before iterating through all the enclosing
    functions and printing their names.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段在遍历所有封装函数并打印它们的名称之前构建了一个`CallGraph`实例。
- en: 'Just like `Module` and `Function`, `CallGraph` only provides the most basic
    way to enumerate all its enclosing components. So, how do we traverse `CallGraph`
    in different ways – for instance, by using SCC – as we saw in the previous section?
    The answer to this is surprisingly simple: in the exact *same* way – using the
    same set of APIs and the same usages.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Module`和`Function`一样，`CallGraph`只提供了一种最基本的方式来枚举其所有封装组件。那么，我们如何以不同的方式遍历`CallGraph`——例如，使用SCC——就像我们在上一节中看到的那样？这个答案出人意料地简单：确实是以相同的方式——使用相同的API集合和用法。
- en: The secret behind this is a thing called `GraphTraits`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的秘密是一个叫做`GraphTraits`的东西。
- en: Learning about GraphTraits
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习关于GraphTraits
- en: '`GraphTraits` is a class designed to provide an abstract interface over various
    different graphs in LLVM – CFG and call graph, to name a few. It allows other
    LLVM components – analyses, transformations, or iterator utilities, as we saw
    in the previous section – to build their works *independently* of the underlying
    graphs. Instead of asking every graph in LLVM to inherit from `GraphTraits` and
    implement the required functions, `GraphTraits` takes quite a different approach
    by using **template specialization**.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`GraphTraits`是一个旨在为LLVM中各种不同的图提供抽象接口的类——例如CFG和调用图。它允许其他LLVM组件——分析、转换或迭代器实用工具，正如我们在上一节中看到的——独立于底层图构建它们的工作。`GraphTraits`不是要求LLVM中的每个图都从`GraphTraits`继承并实现所需函数，而是采取了一种相当不同的方法，即使用**模板特化**。'
- en: 'Let''s say that you have written a simple C++ class that has a template argument
    that accepts arbitrary types, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了一个简单的C++类，它有一个接受任意类型的模板参数，如下所示：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This C++ class will compute the distance between two points upon calling the
    `Distance::compute` method. The types of those points are parameterized by the
    `T` template argument.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个C++类在调用`Distance::compute`方法时会计算两点之间的距离。这些点的类型由`T`模板参数参数化。
- en: 'If `T` is a numeric type such as `int` or `float`, everything will be fine.
    However, if `T` is a struct of a class, like the one here, then the default `compute`
    method implementation will not be able to compile:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`T`是如`int`或`float`这样的数值类型，一切都会正常。然而，如果`T`是一个结构体或类，如这里所示，那么默认的`compute`方法实现将无法编译：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To solve this issue, you can either implement a subtract operator for `SimplePoint`,
    or you can use template specialization, as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以为`SimplePoint`实现一个减法运算符，或者你可以使用模板特化，如下所示：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Distance<SimplePoint>` in the previous code describes what `Distance<T>` looks
    like when `T` is equal to `SimplePoint`. You can think of the original `Distance<T>`
    as some kind of `Distance<SimplePoint>` being one of its `compute` method in `Distance<SimplePoint>`
    is *not* an override method of the original `compute` in `Distance<T>`. This is
    different from normal class inheritance (and virtual methods).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中的`Distance<SimplePoint>`描述了当`T`等于`SimplePoint`时`Distance<T>`的样子。你可以将原始的`Distance<T>`视为某种`Distance<SimplePoint>`，其中`Distance<SimplePoint>`中的`compute`方法不是原始`Distance<T>`中`compute`的覆盖方法。这与正常的类继承（和虚方法）不同。
- en: '`GraphTraits` in LLVM is a template class that provides an interface for various
    graph algorithms, such as `df_iterator` and `scc_iterator`, as we saw previously.
    Every graph in LLVM will *implement* this interface via template specialization.
    For instance, the following `GraphTraits` specialization is used for modeling
    the **CFG** of a function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM中的`GraphTraits`是一个模板类，它为各种图算法提供了一个接口，例如我们之前看到的`df_iterator`和`scc_iterator`。在LLVM中的每个图都会通过模板特化来实现这个接口。例如，以下`GraphTraits`特化用于模拟函数的**CFG**：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside the body of `GraphTraits<Function*>`, there are several (static) methods
    and `typedef` statements that implement the required interface. For example, `nodes_iterator`
    is the type that''s used for iterating over all the vertices in CFG, while `nodes_begin`
    provides you with the entry/starting node of this CFG:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GraphTraits<Function*>`的主体中，有几个（静态）方法和`typedef`语句实现了所需接口。例如，`nodes_iterator`是用于遍历CFG中所有顶点的类型，而`nodes_begin`为你提供了这个CFG的入口/起始节点：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this case, `nodes_iterator` is basically `Function::iterator`. `nodes_begin`
    simply returns the first basic block in the function (via an iterator). If we
    look at `GraphTraits` for `CallGraph`, it has completely different implementations
    of `nodes_iterator` and `nodes_begin`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`nodes_iterator`基本上是`Function::iterator`。`nodes_begin`简单地返回函数中的第一个基本块（通过一个迭代器）。如果我们查看`CallGraph`的`GraphTraits`，它对`nodes_iterator`和`nodes_begin`有完全不同的实现：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When developers are implementing a new graph algorithm, instead of hardcoding
    it for each kind of graph in LLVM, they can build their algorithms by using `GraphTraits`
    as an interface to access the key properties of arbitrary graphs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者实现一个新的图算法时，他们不必为LLVM中的每种图硬编码它，而是可以通过使用`GraphTraits`作为接口来访问任意图的关键属性来构建他们的算法。
- en: 'For example, let''s say we want to create a new graph algorithm, `find_tail`,
    which finds the first node in the graph that has no child nodes. Here is the skeleton
    of `find_tail`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要创建一个新的图算法，`find_tail`，它找到图中没有子节点的第一个节点。以下是`find_tail`的框架：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With the help of this template and `GraphTraits`, we can *reuse* this function
    on `Function`, `CallGraph`, or any kind of graph in LLVM; for instance:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板和`GraphTraits`的帮助下，我们可以在`Function`、`CallGraph`或LLVM中的任何类型的图上*重用*这个函数；例如：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In short, `GraphTraits` generalizes algorithms – such as `df_iterator` and `scc_iterator`,
    as we saw previously – in LLVM to *arbitrary* graphs using the template specialization
    technique. This is a clean and efficient way to define interfaces for reusable
    components.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`GraphTraits`通过模板特化技术将LLVM中的算法（如我们之前看到的`df_iterator`和`scc_iterator`）泛化到*任意*图中。这是一种干净且高效的方式来定义可重用组件的接口。
- en: In this section, we learned the hierarchy structure of LLVM IR and how to iterate
    different IR units – either concrete or logical units, such as CFGs. We also learned
    the important role of `GraphTraits` for encapsulating different graphs – CFGs
    and call graphs, to name a few – and exposed a common interface to various algorithms
    in LLVM, thus making those algorithms more concise and reusable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了LLVM IR的层次结构以及如何迭代不同的IR单元——无论是具体的还是逻辑单元，如CFGs。我们还学习了`GraphTraits`在封装不同图（例如CFGs和调用图）中的重要作用，并暴露了LLVM中各种算法的通用接口，从而使这些算法更加简洁和可重用。
- en: In the next section, we will learn about how values are represented in LLVM,
    which describes a picture of how different LLVM IR components are associated with
    each other. In addition, we will learn about the correct and efficient way to
    manipulate and update values in LLVM.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在LLVM中表示值，这描述了不同LLVM IR组件之间关联的图景。此外，我们还将学习在LLVM中正确且高效地操作和更新值的方法。
- en: Working with values and instructions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与值和指令一起工作
- en: In LLVM, a **value** is a unique construct – not only does it represent values
    stored in variables, but it also models a wide range of concepts from constants,
    global variables, individual instructions, and even basic blocks. In other words,
    it is one of the *foundations* of LLVM IR.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM中，一个**值**是一个独特的结构——它不仅代表存储在变量中的值，还模拟了从常量、全局变量、单个指令甚至基本块等广泛的概念。换句话说，它是LLVM
    IR的*基础*之一。
- en: The concept of value is especially important for instructions as it directly
    interacts with values in the IR. Therefore, in this section, we will put them
    into the same discussion. We are going to see how values work in LLVM IR and how
    values are associated with instructions. On top of that, we are going to learn
    how to create and insert new instructions, as well as how to update them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 价值的概念对于指令来说尤为重要，因为它直接与IR中的值进行交互。因此，在本节中，我们将它们纳入相同的讨论。我们将探讨在LLVM IR中值是如何工作的，以及值是如何与指令关联的。在此基础上，我们还将学习如何创建和插入新的指令，以及如何更新它们。
- en: To learn how to use values in LLVM IR, we must understand the important theory
    behind this system, which dictates the behavior and the format of LLVM instructions
    – the **Single Static Assignment** (**SSA**) form.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在LLVM IR中使用值，我们必须理解支撑这个系统的关键理论，它决定了LLVM指令的行为和格式——**单静态赋值**（**SSA**）形式。
- en: Understanding SSA
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解SSA
- en: 'SSA is a way of structuring and designing IR to make program analysis and compiler
    transformation easier to perform. In SSA, a variable (in the IR) will only be
    assigned a value exactly *once*. This means that we cannot manipulate a variable
    like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: SSA是一种对IR进行结构和设计的方式，使得程序分析和编译器转换更容易执行。在SSA中，一个变量（在IR中）将只被赋值一次。这意味着我们不能像这样操作变量：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Although a variable can only be assigned once, it can be *used* multiple times
    in arbitrary instructions. For instance, check out the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个变量只能被赋值一次，但它可以在任意指令中被*使用*多次。例如，看看以下代码：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You might be wondering how normal C/C++ code – which is clearly not in SSA
    form – gets transformed into an SSA form of IR, such as LLVM. While there is a
    whole class of different algorithms and research papers that answer this question,
    which we are not going to cover here, most of the simple C/C++ code can be transformed
    using trivial techniques such as renaming. For instance, let''s say we have the
    following (non-SSA) C code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道普通的C/C++代码——显然不是SSA形式——是如何转换成LLVM这样的SSA形式IR的。虽然有一类不同的算法和研究论文回答了这个问题，我们在这里不会涉及，但大多数简单的C/C++代码可以通过诸如重命名等简单技术进行转换。例如，假设我们有以下（非SSA）的C代码：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we can rename `x` in the first assignment with something like `x0` and
    `x` on the left-hand side of the second and third assignments with alternative
    names such as `x1` and `x2`, respectively:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以将第一个赋值中的 `x` 重命名为 `x0`，并将第二个和第三个赋值左侧的 `x` 分别用 `x1` 和 `x2` 这样的替代名称替换：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With these simple measurements, we can obtain the SSA form of our original code
    with the same behavior.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简单的测量，我们可以获得具有相同行为的原始代码的 SSA 形式。
- en: 'To have a more comprehensive understanding of SSA, we must change our way of
    thinking about what instructions *look like* in a program. In `x`" where the second
    line means "do some multiplication using `x` and `y` before storing the result
    in the `x` variable":'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更全面地理解 SSA，我们必须改变我们对程序中指令*外观*的思考方式。在 `x`"中，第二行表示“使用 `x` 和 `y` 进行一些乘法运算，然后将结果存储在
    `x` 变量中”：
- en: '![Figure 10.4 – Thinking instructions as "actions"'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.4 – 将指令视为“动作”]'
- en: '](img/B14590_Figure_10.4.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14590_Figure_10.4.jpg]'
- en: Figure 10.4 – Thinking instructions as "actions"
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 将指令视为“动作”
- en: These interpretations sound intuitive. However, things get tricky when we make
    some *transformations* – which is, of course, a common thing in a compiler – on
    these instructions. In the preceding diagram, on the right-hand side, when the
    first instruction becomes `x = 87`, we don't know if this modification `x` variable
    on the right-hand side of `x`. Here, we have no choice but to list all the instructions
    that have `x` on their left-hand side (that is, using `x` as the destination),
    which is pretty inefficient.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解释听起来直观。然而，当我们对这些指令进行一些*转换*——这当然是编译器中常见的事情——时，事情就变得复杂了。在前面的图表中，在右侧，当第一个指令变为
    `x = 87` 时，我们不知道这个修改是否会影响右侧的 `x` 变量。在这里，我们别无选择，只能列出所有左侧有 `x` 的指令（即使用 `x` 作为目标），这相当低效。
- en: 'Instead of looking at the *action* aspect of an instruction, we can focus on
    the *data* that''s generated by an instruction and get a clear picture of the
    provenance of each instruction – that is, the region that can be reached by its
    resulting value. Furthermore, we can easily find out the origins of arbitrary
    variables/values. The following diagram illustrates this advantage:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不关注指令的*动作*方面，而是关注由指令生成的*数据*，从而清楚地了解每个指令的来源——即其结果值可以到达的区域。此外，我们还可以轻松地找出任意变量/值的来源。以下图表说明了这一优势：
- en: '![Figure 10.5 – SSA highlighting the dataflow among instructions'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – SSA 突出显示指令之间的数据流]'
- en: '](img/B14590_Figure_10.5.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14590_Figure_10.5.jpg]'
- en: Figure 10.5 – SSA highlighting the dataflow among instructions
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – SSA 突出显示指令之间的数据流
- en: In other words, SSA highlights the **dataflow** in a program so that the compiler
    will have an easier time tracking, analyzing, and modify the instructions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，SSA 突出了程序中的**数据流**，以便编译器更容易跟踪、分析和修改指令。
- en: 'Instructions in LLVM are organized in SSA form. This means we are more interested
    in the value, or the data flow generated by an instruction, rather than which
    variable it stores the result in. Since each instruction in LLVM IR can only produce
    a single result value, an `Instruction` object – recall that `Instruction` is
    the C++ class that represents an instruction in LLVM IR – also represents its
    `Value`. `Instruction` is one of its child classes. This means that given an `Instruction`
    object, we can, of course, cast it to a `Value` object. That particular `Value`
    object is effectively the result of that `Instruction`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 中的指令以 SSA 形式组织。这意味着我们更感兴趣的是指令产生的值，或数据流，而不是它将结果存储在哪个变量中。由于 LLVM IR 中的每个指令只能产生单个结果值，因此
    `Instruction` 对象——回想一下 `Instruction` 是表示 LLVM IR 中指令的 C++ 类——也代表其 `Value`。`Instruction`
    是其子类之一。这意味着给定一个 `Instruction` 对象，我们当然可以将它转换为 `Value` 对象。那个特定的 `Value` 对象实际上是那个
    `Instruction` 的结果：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is one of the most important things to know in order to work with LLVM
    IR, especially to use most of its APIs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是了解如何使用 LLVM IR 的重要事项之一，尤其是要使用其大多数 API。
- en: 'While the `Instruction` object represents its own result value, it also has
    *operands* that are served as inputs to the instruction. Guess what? We are also
    using `Value` objects as operands. For example, let''s assume we have the following
    code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Instruction` 对象代表其自身的结果值，但它也有作为指令输入的*操作数*。猜猜看？我们也在使用 `Value` 对象作为操作数。例如，假设我们有以下代码：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding snippet is basically creating an arithmetic addition instruction
    (represented by `BinaryOperator`), whose *result* value will be the *operand*
    of another return instruction. The resulting IR is equivalent to the following
    C/C++ code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段基本上创建了一个算术加法指令（由 `BinaryOperator` 表示），其 *结果* 值将成为另一个返回指令的 *操作数*。生成的 IR
    等价于以下 C/C++ 代码：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In addition to `Instruction`, `Constant` (the C++ class for different kinds
    of constant values), `GlobalVariable` (the C++ class for global variables), and
    `BasicBlock` are all subclasses of `Value`. This means that they're also organized
    in SSA form and that you can use them as the operands for an `Instruction`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Instruction`、`Constant`（表示不同类型常量的 C++ 类）、`GlobalVariable`（表示全局变量的 C++ 类）和
    `BasicBlock` 之外，它们都是 `Value` 的子类。这意味着它们也以 SSA 形式组织，并且你可以将它们用作 `Instruction` 的操作数。
- en: Now, you know what SSA is and learned what impact it has on the design of LLVM
    IR. In the next section, we are going to discuss how to modify and update values
    in LLVM IR.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了 SSA 是什么以及它对 LLVM IR 设计的影响。在下一节中，我们将讨论如何修改和更新 LLVM IR 中的值。
- en: Working with values
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与值一起工作
- en: 'SSA makes us focus on the *data flow* among instructions. Since we have a clear
    view of how values go from one instruction to the other, it''s easy to replace
    the usage of certain values in an instruction. But how is the concept of "value
    usage" represented in LLVM? The following diagram shows two important C++ classes
    that answer this question – `User` and `Use`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: SSA 让我们关注指令之间的 *数据流*。由于我们对值如何从一个指令流向另一个指令有清晰的了解，因此很容易替换指令中某些值的用法。但在 LLVM 中，“值使用”的概念是如何表示的呢？以下图表显示了两个重要的
    C++ 类，它们回答了这个问题 – `User` 和 `Use`：
- en: '![Figure 10.6 – The relationship between Value, User, and Use'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – Value、User 和 Use 之间的关系'
- en: '](img/B14590_Figure_10.6.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – Value、User 和 Use 之间的关系](img/B14590_Figure_10.6.jpg)'
- en: Figure 10.6 – The relationship between Value, User, and Use
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – Value、User 和 Use 之间的关系
- en: As we can see, `User` represents the concept of an IR instance (for example,
    an `Instruction`) that uses a certain `Value`. Furthermore, LLVM uses another
    class, `Use`, to model the edge between `Value` and `User`. Recall that `Instruction`
    is a child class of `Value` – which represents the result that's generated by
    this instruction. In fact, `Instruction` is also derived from `User`, since almost
    all instructions take at least one operand.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`User` 代表了 IR 实例（例如，一个 `Instruction`）使用某个 `Value` 的概念。此外，LLVM 使用另一个类 `Use`
    来模拟 `Value` 和 `User` 之间的边。回想一下，`Instruction` 是 `Value` 的子类 – 它代表由该指令生成的结果。实际上，`Instruction`
    也是从 `User` 继承而来的，因为几乎所有的指令至少需要一个操作数。
- en: 'A `User` might be pointed to by multiple `Use` instances, which means it uses
    many `Value` instances. You can use `value_op_iterator` provided by `User` to
    check out each of these `Value` instances; for example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `User` 可能会被多个 `Use` 实例指向，这意味着它使用了多个 `Value` 实例。你可以使用 `User` 提供的 `value_op_iterator`
    来检查这些 `Value` 实例中的每一个；例如：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Again, `operand_values` is just a utility function to generate a `value_op_iterator`
    range.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`operand_values` 只是一个生成 `value_op_iterator` 范围的实用函数。
- en: 'Here is an example of why we want to iterate through all the `User` instances
    of a `Value`: imagine we are analyzing a program where one of its `Function` instances
    will return sensitive information – let''s say, a `get_password` function. Our
    goal is to ensure that whenever `get_password` is called within a `Function`,
    its returned value (sensitive information) won''t be leaked via another function
    call. For example, we want to detect the following pattern and raise an alarm:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是为什么要遍历一个 `Value` 的所有 `User` 实例的一个例子：想象我们正在分析一个程序，其中它的一个 `Function` 实例将返回敏感信息
    – 假设是一个 `get_password` 函数。我们的目标是确保在 `Function` 中调用 `get_password` 时，其返回值（敏感信息）不会通过另一个函数调用泄露。例如，我们希望检测以下模式并发出警报：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'One of the most naïve ways to implement this analysis is by inspecting all
    `User` instances of the sensitive `Value`. Here is some example code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种分析的最简单方法之一是检查敏感 `Value` 的所有 `User` 实例。以下是一些示例代码：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `find_leackage` function takes a `CallInst` argument – which represents
    a `get_password` function call – and returns any `User` instance that uses the
    `Value` instance that's returned from that `get_password` call.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_leackage` 函数接受一个 `CallInst` 参数 – 它代表一个 `get_password` 函数调用 – 并返回任何使用从该
    `get_password` 调用返回的 `Value` 实例的 `User` 实例。'
- en: 'A `Value` instance can be used by multiple different `User` instances. So,
    similarly, we can iterate through all of them using the following snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Value` 实例可以被多个不同的 `User` 实例使用。因此，同样地，我们可以使用以下代码片段遍历它们：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With that, you've learned how to inspect the `User` instance of a `Value`, or
    the `Value` instance that's used by the current `User`. In addition, when we're
    developing a compiler transformation, it is pretty common to change the `Value`
    instance that's used by a `User` to another one. LLVM provides some handy utilities
    to do this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何检查 `Value` 的 `User` 实例，或者当前 `User` 使用的 `Value` 实例。此外，在开发编译器转换时，改变
    `User` 使用的 `Value` 实例为另一个实例是非常常见的。LLVM 提供了一些方便的实用工具来完成这项工作。
- en: 'First, the `Value::replaceAllUsesWith` method can, as its name suggests, tell
    all of its `User` instances to use another `Value` instead of it. The following
    diagram illustrates its effect:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Value::replaceAllUsesWith` 方法，正如其名称所暗示的，可以告诉其所有 `User` 实例使用另一个 `Value` 而不是它。以下图表说明了其影响：
- en: '![Figure 10.7 – Effect of Value::replaceAllUsesWith'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – Value::replaceAllUsesWith 的影响'
- en: '](img/B14590_Figure_10.7.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – Value::replaceAllUsesWith 的影响](img/B14590_Figure_10.7.jpg)'
- en: Figure 10.7 – Effect of Value::replaceAllUsesWith
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – Value::replaceAllUsesWith 的影响
- en: This method is really useful when you're replacing an `Instruction` with another
    `Instruction`. Using the preceding diagram to explain this, `V1` is the original
    `Instruction` and `V2` is the new one.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要用另一个 `Instruction` 替换 `Instruction` 时，这个方法非常有用。使用前面的图表来解释这一点，`V1` 是原始的 `Instruction`，而
    `V2` 是新的。
- en: Another utility function that does a similar thing is `User::replaceUsesOfWith(From,To)`.
    This method effectively scans through all of the operands in this `User` and replaces
    the usage of a specific `Value` (the *From* argument) with another `Value` (the
    *To* argument).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个执行类似操作的实用函数是 `User::replaceUsesOfWith(From,To)`。此方法有效地扫描此 `User` 中的所有操作数，并将特定
    `Value`（*From* 参数）的使用替换为另一个 `Value`（*To* 参数）。
- en: The skills you've learned in this section are some of the most fundamental tools
    for developing a program transformation in LLVM. In the next section, we will
    talk about how to create and modify instructions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中你学到的技能是开发 LLVM 程序转换的最基本工具之一。在下一节中，我们将讨论如何创建和修改指令。
- en: Working with instructions
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与指令一起工作
- en: Previously, we learned the basics of `Value` – including its relationship with
    `Instruction` – and the way to update `Value` instances under the framework of
    SSA. In this section, we are going to learn some more basic knowledge and skills
    that give you a better understanding of `Instruction` and help you *modify* `Instruction`
    instances in a correct and efficient way, which is the key to developing a successful
    compiler optimization.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了 `Value` 的基础知识——包括它与 `Instruction` 的关系——以及如何在 SSA 框架下更新 `Value` 实例。在本节中，我们将学习一些更基本的知识和技能，这些知识和技能将帮助你更好地理解
    `Instruction`，并帮助你以正确和高效的方式修改 `Instruction` 实例，这是开发成功的编译器优化的关键。
- en: 'Here is the list of topics we are going to cover in this section:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下主题列表：
- en: Casting between different instruction types
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同指令类型之间的转换
- en: Inserting a new instruction
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入新的指令
- en: Replacing an instruction
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换指令
- en: Processing instructions in batches
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量处理指令
- en: Let's start by looking at different instruction types.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看不同的指令类型。
- en: Casting between different instruction types
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同指令类型之间的转换
- en: In the previous section, we learned about a useful utility called `InstVisitor`.
    The `InstVisitor` class helps you determine the underlying class of an `Instruction`
    instance. It also saves you the efforts of casting between different instruction
    types. However, we cannot always rely on `InstVisitor` for every task that involves
    type casting between `Instruction` and its derived classes. More generally speaking,
    we want a simpler solution for type casting between parent and child classes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们学习了一个有用的实用工具 `InstVisitor`。`InstVisitor` 类帮助你确定 `Instruction` 实例的底层类。它还节省了你进行不同指令类型之间转换的努力。然而，我们并不能总是依赖
    `InstVisitor` 来完成涉及 `Instruction` 及其派生类之间类型转换的每一项任务。更普遍地说，我们希望有一个更简单的解决方案来进行父类和子类之间的类型转换。
- en: 'Now, you might be wondering, but C++ *already* provided this mechanism via
    the `dynamic_cast` directive, right? Here is an example of `dynamic_cast`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道，但 C++ 已经通过 `dynamic_cast` 指令提供了这种机制，对吧？以下是一个 `dynamic_cast` 的例子：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the `foo` function used in the preceding code, we can see that in its second
    line, we can convert `P` into a `Child1` instance because that is its underlying
    type. On the other hand, we cannot convert `P` into `Child2` – the program will
    simply crash during runtime if we do so.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中使用的 `foo` 函数中，我们可以看到在其第二行，我们可以将 `P` 转换为 `Child1` 实例，因为那是它的底层类型。另一方面，我们不能将
    `P` 转换为 `Child2` – 如果我们这样做，程序将在运行时崩溃。
- en: Indeed, `dynamic_cast` has the exact functionality we are looking for – more
    formally speaking, the **Runtime Type Info** (**RTTI**) feature – but it also
    comes with high overhead in terms of runtime performance. What's worse, the default
    implementation of RTTI in C++ is quite complex, making the resulting program difficult
    to optimize. Therefore, LLVM *disables* RTTI by default. Due to this, LLVM came
    up with its own system of runtime type casting that is much simpler and more efficient.
    In this section, we are going to talk about how to use it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`dynamic_cast` 具有我们需要的精确功能 – 更正式地说，是 **运行时类型信息** （**RTTI**）功能 – 但它也带来了运行时性能方面的高开销。更糟糕的是，C++
    中 RTTI 的默认实现相当复杂，使得生成的程序难以优化。因此，LLVM 默认 **禁用** RTTI。由于这个原因，LLVM 提出了一种自己的运行时类型转换系统，它更加简单和高效。在本节中，我们将讨论如何使用它。
- en: 'LLVM''s casting framework provides three functions for dynamic type casting:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 的类型转换框架提供了三个用于动态类型转换的函数：
- en: '`isa<T>(val)`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isa<T>(val)`'
- en: '`cast<T>(val)`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cast<T>(val)`'
- en: '`dyn_cast<T>(val)`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dyn_cast<T>(val)`'
- en: 'The first function, `isa<T>` – pronounced "is-a" – checks if the `val` pointer
    type can be cast to a pointer of the `T` type. Here is an example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数，`isa<T>` – 发音为 "is-a" – 检查 `val` 指针类型是否可以转换成 `T` 类型的指针。以下是一个例子：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that differently from `dynamic_cast`, you don't need to put `BinaryOperator*`
    as the template argument in this case – only a type without a pointer qualifier.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 `dynamic_cast` 不同，在这种情况下，你不需要将 `BinaryOperator*` 作为模板参数 – 只需一个没有指针修饰符的类型。
- en: 'The `cast<T>` function performs the real type casting from (pointer-type) `val`
    to a pointer of the `T` type. Here is an example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`cast<T>` 函数执行从（指针类型）`val` 到 `T` 类型指针的实际类型转换。以下是一个例子：'
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Again, you don't need to put `BinaryOperator*` as the template argument. Note
    that if you don't perform type checking using `isa<T>` before calling `cast<T>`,
    the program will just crash during runtime.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你不需要将 `BinaryOperator*` 作为模板参数。注意，如果你在调用 `cast<T>` 之前没有使用 `isa<T>` 进行类型检查，程序将在运行时崩溃。
- en: 'The last function, `dyn_cast<T>`, is a combination of `isa<T>` and `cast<T>`;
    that is, you perform type casting if applicable. Otherwise, it returns a null.
    Here is an example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数，`dyn_cast<T>`，是 `isa<T>` 和 `cast<T>` 的组合；也就是说，如果适用，你将执行类型转换。否则，它返回一个空值。以下是一个例子：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we can see some neat syntax that combines the variable declaration (of
    `BinOp`) with the `if` statement.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一些将变量声明（`BinOp`）与 `if` 语句结合的整洁语法。
- en: Be aware that none of these APIs can take null as the argument. On the contrary,
    `dyn_cast_or_null<T>` doesn't have this limitation. It is basically a `dyn_cast<T>`
    API that accepts null as input.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些 API 都不能接受空值作为参数。相反，`dyn_cast_or_null<T>` 没有这个限制。它基本上是一个接受空值作为输入的 `dyn_cast<T>`
    API。
- en: Now, you know how to check and cast from an arbitrary `Instruction` instance
    to its underlying instruction type. Starting from the next section, we are finally
    going to create and modify some instructions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何从一个任意的 `Instruction` 实例检查和转换到其底层指令类型。从下一节开始，我们终于要创建和修改一些指令了。
- en: Inserting a new instruction
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入一个新的指令
- en: 'In one of the code examples from the previous *Understanding SSA* section,
    we saw a snippet like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节 *理解 SSA* 的代码示例中，我们看到了一个类似的片段：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As suggested by the method's name – `Create` – we can infer that these two lines
    created a `BinaryOperator` and a `ReturnInst` instruction.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如方法名所暗示的 – `Create` – 我们可以推断出这两行代码创建了一个 `BinaryOperator` 和一个 `ReturnInst` 指令。
- en: 'Most of the instruction classes in LLVM provide factory methods – such as `Create`
    here – to build a new instance. People are encouraged to use these factory methods
    versus allocating instruction objects manually via the `new` keyword or `malloc`
    function. LLVM will manage the instruction object''s memory for you – once it''s
    been inserted into a `BasicBlock`. There are several ways to insert a new instruction
    into a `BasicBlock`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数的 LLVM 指令类都提供了工厂方法 – 例如这里的 `Create` – 来构建一个新的实例。人们被鼓励使用这些工厂方法，而不是通过 `new`
    关键字或 `malloc` 函数手动分配指令对象。LLVM 将为你管理指令对象的内存 – 一旦它被插入到 `BasicBlock` 中。有几种方法可以将新的指令插入到
    `BasicBlock` 中：
- en: 'Factory methods in some instruction classes provide an option to insert the
    instruction right after it is created. For instance, one of the `Create` method
    variants in `BinaryOperator` allows you to insert it *before* another instruction
    after the creation. Here is an example:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些指令类中的工厂方法提供了一种在创建后立即插入指令的选项。例如，`BinaryOperator`中的`Create`方法变体之一允许你在创建后将其插入到另一个指令之前。以下是一个示例：
- en: '[PRE47]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can use the `insertBefore`/`insertAfter` methods provided by the `Instruction`
    class to insert a new instruction. Since all instruction classes are subclasses
    of `Instruction`, we can use `insertBefore` or `insertAfter` to insert the newly
    created instruction instance before or after another `Instruction`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`Instruction`类提供的`insertBefore`/`insertAfter`方法来插入一个新的指令。由于所有指令类都是`Instruction`的子类，我们可以使用`insertBefore`或`insertAfter`来在另一个`Instruction`之前或之后插入新创建的指令实例。
- en: 'We can also use the `IRBuilder` class. `IRBuilder` is a powerful tool for automating
    some of the instruction creation and insertion steps. It implements a builder
    design pattern that can insert new instructions one after another when developers
    invoke one of its creation methods. Here is an example:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用`IRBuilder`类。`IRBuilder`是一个强大的工具，可以自动化一些指令创建和插入步骤。它实现了构建者设计模式，可以在开发者调用其创建方法之一时依次插入新指令。以下是一个示例：
- en: '[PRE48]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With that, you've learned how to create and insert new instructions. Now, let's
    look at how to *replace* existing instructions with others.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何创建和插入新的指令。现在，让我们看看如何用其他指令来*替换*现有的指令。
- en: Replacing an instruction
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换指令
- en: There are many cases where we will want to replace an existing instruction.
    For instance, a simple optimizer might replace an arithmetic multiplication instruction
    with a left-shifting instruction when one of the multiplication's operands is
    a power-of-two integer constant. In this case, it seems straightforward that we
    can achieve this by simply changing the *operator* (the opcode) and one of the
    operands in the original `Instruction`. That is **not** the recommended way to
    do things, however.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可能需要替换现有的指令。例如，一个简单的优化器可能会在乘法的一个操作数是2的幂次整数常量时，将算术乘法指令替换为左移指令。在这种情况下，似乎简单直接的方法是通过简单地更改*运算符*（操作码）和原始`Instruction`中的一个操作数来实现这一点。然而，这并不是推荐的做法。
- en: 'To replace an `Instruction` in LLVM, you need to create a new `Instruction`
    (as the replacement) and *reroute* all the SSA definitions and usages from the
    original `Instruction` to the replacement one. Let''s use the power-of-two-multiplication
    we just saw as an example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要在LLVM中替换`Instruction`，你需要创建一个新的`Instruction`（作为替换）并将所有从原始`Instruction`到替换实例的SSA定义和引用重新路由。让我们以我们刚才看到的2的幂次乘法为例：
- en: 'The function we are going to implement is called `replacePow2Mul`, whose argument
    is the multiplication instruction to be processed (assuming that we have ensured
    the multiplication has a constant, power-of-two integer operand). First, we will
    retrieve the constant integer – represented by the `ConstantInt` class – operand
    and convert it into its base-2 logarithm value (via the `getLog2` utility function;
    the exact implementation of `getLog2` is left as an exercise for you):'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要实现的函数名为`replacePow2Mul`，其参数是要处理的乘法指令（假设我们已经确保乘法有一个常数，2的幂次整数操作数）。首先，我们将检索常数整数操作数——由`ConstantInt`类表示——并将其转换为它的2的底数对数值（通过`getLog2`实用函数；`getLog2`的确切实现留作你的练习）：
- en: '[PRE49]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we will create a new left-shifting instruction – represented by the `ShlOperator`
    class:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的左移指令——由`ShlOperator`类表示：
- en: '[PRE50]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, before we remove the `Mul` instruction, we need to tell all the users
    of the original `Mul` to use our newly created `Shl` instead:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们删除`Mul`指令之前，我们需要通知所有原始`Mul`的使用者使用我们新创建的`Shl`：
- en: '[PRE51]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With that, you've learned how to replace an existing `Instruction` properly.
    In the final subsection, we are going to talk about some tips for processing multiple
    instructions in a `BasicBlock` or a `Function`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何正确地替换现有的`Instruction`。在最后一小节中，我们将讨论在`BasicBlock`或`Function`中处理多个指令的一些技巧。
- en: Tips for processing instructions in batches
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量处理指令的技巧
- en: 'So far, we have been learning how to insert, delete, and replace a single `Instruction`.
    However, in real-world cases, we usually perform such actions on a *sequence*
    of `Instruction` instances (that are in a `BasicBlock`, for instance). Let''s
    try to do that by putting what we''ve learned into a `for` loop that iterates
    through all the instructions in a `BasicBlock`; for instance:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在学习如何插入、删除和替换单个 `Instruction`。然而，在现实世界的案例中，我们通常会对一系列 `Instruction`
    实例（例如在 `BasicBlock` 中）执行此类操作。让我们通过将所学知识应用到遍历 `BasicBlock` 中所有指令的 `for` 循环中来尝试这样做；例如：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding code used the `replacePow2Mul` function we just saw in the previous
    section to replace the multiplications in this `BasicBlock` with left-shifting
    instructions if the multiplication fulfills certain criteria. (This is checked
    by the `isMulWithPowerOf2` function. Again, the details of this function have
    been left as an exercise to you.)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的代码使用了我们在上一节中看到的 `replacePow2Mul` 函数来替换 `BasicBlock` 中的乘法运算，如果乘法满足某些条件，则用左移指令替换。
    (这是通过 `isMulWithPowerOf2` 函数来检查的。同样，这个函数的细节已经留作你的练习。)
- en: This code looks pretty straightforward but unfortunately, it will crash while
    running this transformation. What happened here was that the `Instruction` instances
    in `BasicBlock` became *stale* after running our `replacePow2Mul`. The `Instruction`
    iterator is unable to keep updated with the changes that have been applied to
    the `Instruction` instances in this `BasicBlock`. In other words, it's really
    hard to change the `Instruction` instances while iterating them at the same time.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来相当简单，但不幸的是，在运行这个转换时会发生崩溃。这里发生的事情是，在运行我们的 `replacePow2Mul` 之后，`BasicBlock`
    中的 `Instruction` 实例变得*过时*。`Instruction` 迭代器无法跟上对 `BasicBlock` 中 `Instruction`
    实例应用的变化。换句话说，在迭代的同时更改 `Instruction` 实例真的很困难。
- en: 'The simplest way to solve this problem is to **push off** the changes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法是将更改**推迟**：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding code separates the previous code example into two parts (as two
    separate `for` loops). The first `for` loop is still iterating through all the
    `Instruction` instances in `BasicBlock`. But this time, it only performs the checks
    (that is, calling `isMulWithPowerOf2`) without replacing the `Instruction` instance
    right away if it passes the checks. Instead, this `for` loop pushes the candidate
    `Instruction` into array storage – a `for` loop, the second `for` loop inspects
    the worklist and performs the real replacement by calling `replacePow2Mul` on
    each worklist item. Since the replacements in the second `for` loop don't invalidate
    any iterators, we can finally transform the code without any crashes occurring.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将之前的代码示例分为两部分（作为两个单独的 `for` 循环）。第一个 `for` 循环仍然遍历 `BasicBlock` 中的所有 `Instruction`
    实例。但这次，它只执行检查（即调用 `isMulWithPowerOf2`），如果通过检查则不会立即替换 `Instruction` 实例。相反，这个 `for`
    循环将候选 `Instruction` 推送到数组存储中 - 第二个 `for` 循环检查工作列表并通过对每个工作列表项调用 `replacePow2Mul`
    来执行实际的替换。由于第二个 `for` 循环中的替换不会使任何迭代器失效，我们最终可以无崩溃地转换代码。
- en: There are, of course, other ways to circumvent the aforementioned iterator problem,
    but they are mostly complicated and less readable. Using a worklist is the safest
    and most expressive way to modify instructions in batches.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他方法可以绕过上述迭代器问题，但它们通常比较复杂且可读性较差。使用工作列表是批量修改指令最安全且最表达性的方式。
- en: '`Value` is a first-class construction in LLVM that outlines the data flow among
    different entities such as instructions. In this section, we introduced how values
    are represented in LLVM IR and the model of SSA that makes it easier to analyze
    and transform it. We also learned how to update values in an efficient way and
    some useful skills for manipulating instructions. This will help build the foundation
    for you to build more complex and advanced compiler optimizations using LLVM.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value` 是 LLVM 中的第一级构造，概述了不同实体（如指令）之间的数据流。在本节中，我们介绍了在 LLVM IR 中如何表示值以及使分析和管理它更容易的
    SSA 模型。我们还学习了如何以高效的方式更新值以及一些操作指令的有用技巧。这将帮助你建立使用 LLVM 构建更复杂和高级编译器优化的基础。'
- en: In the next section, we will look at a slightly more complicated IR unit – a
    loop. We are going to learn how loops are represented in LLVM IR and how to work
    with them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看一个稍微复杂一点的 IR 单元 - 循环。我们将学习如何在 LLVM IR 中表示循环以及如何与它们一起工作。
- en: Working with loops
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理循环
- en: 'So far, we have learned about several IR units such as modules, functions,
    basic blocks, and instructions. We have also learned about some *logical* units
    such as CFG and call graphs. In this section, we are going to look at a more logical
    IR unit: a loop.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了几个 IR 单元，如模块、函数、基本块和指令。我们还学习了关于一些 *逻辑* 单元，如 CFG 和调用图。在本节中，我们将探讨一个更逻辑的
    IR 单元：循环。
- en: Loops are ubiquitous constructions that are heavily used by programmers. Not
    to mention that nearly every programming language contains this concept, too.
    A loop repeatedly executes a certain number of instructions multiple times, which,
    of course, saves programmers lots of effort from repeating that code by themselves.
    However, if the loop contains any *inefficient* code – for example, a time-consuming
    memory load that always delivers the same value – the performance slowdown will
    also be *magnified* by the number of iterations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是程序员广泛使用的构造，几乎所有编程语言都包含这个概念。循环会重复执行一定数量的指令多次，这当然可以节省程序员自己重复代码的大量工作。然而，如果循环中包含任何
    *低效* 的代码——例如，总是返回相同值的耗时内存加载——性能下降也将被迭代次数 *放大*。
- en: Therefore, it is the compiler's job to eliminate as many flaws as possible from
    a loop. In addition to removing suboptimal code from loops, since loops are on
    the critical path of the runtime's performance, people have always been trying
    to further optimize them with special hardware-based accelerations; for example,
    replacing a loop with vector instructions, which can process multiple scalar values
    in just a few cycles. In short, loop optimization is the key to generating faster,
    more efficient programs. This is especially important in the high-performance
    and scientific computing communities.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编译器的任务是尽可能多地消除循环中的缺陷。除了从循环中移除次优代码外，由于循环是运行时性能的关键路径，人们一直在尝试通过特殊的基于硬件的加速来进一步优化它们；例如，用向量指令替换循环，这些指令可以在几个周期内处理多个标量值。简而言之，循环优化是生成更快、更有效程序的关键。这在高性能和科学计算社区尤为重要。
- en: 'In this section, we are going to learn how to process loops with LLVM. We will
    try to tackle this topic in two parts:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 LLVM 处理循环。我们将尝试将这个主题分为两部分：
- en: Learning about loop representation in LLVM
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于 LLVM 中循环表示的知识
- en: Learning about loop infrastructure in LLVM
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于 LLVM 中循环基础设施的知识
- en: In LLVM, loops are slightly more complicated than other (logical) IR units.
    Therefore, we will learn about the high-level concept of a loop in LLVM and its
    *terminologies* first. Then, in the second part, we are going to get our hands
    on the infrastructure and tools that are used for processing loops in LLVM.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 中，循环比其他（逻辑）IR 单元稍微复杂一些。因此，我们首先将学习 LLVM 中循环的高级概念及其 *术语*。然后，在第二部分，我们将了解用于在
    LLVM 中处理循环的基础设施和工具。
- en: Let's start with the first part.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一部分开始。
- en: Learning about loop representation in LLVM
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习关于 LLVM 中循环表示的知识
- en: A loop is represented by the `Loop` class in LLVM. This class captures any control
    flow structure that has a *back edge* from an enclosing basic block in one of
    its predecessor blocks. Before we dive into its details, let's learn how to retrieve
    a `Loop` instance.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 中，循环是通过 `Loop` 类来表示的。这个类捕捉了任何从其前驱块中的一个基本块到包围基本块的 *回边* 的控制流结构。在我们深入其细节之前，让我们学习如何检索一个
    `Loop` 实例。
- en: 'As we mentioned previously, a loop is a logical IR unit in LLVM IR. Namely,
    it is derived (or calculated) from physical IR units. In this case, we need to
    retrieve the calculated `Loop` instances from `AnalysisManager` – which was first
    introduced in [*Chapter 9*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127), *Working
    with PassManager and AnalysisManager*. Here is an example showing how to retrieve
    it in a `Pass` function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，循环是 LLVM IR 中的一个逻辑 IR 单元。也就是说，它是从物理 IR 单元派生（或计算）出来的。在这种情况下，我们需要从 `AnalysisManager`
    中检索计算出的 `Loop` 实例——该实例首次在 [*第 9 章*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127)，*与
    PassManager 和 AnalysisManager 一起工作* 中介绍。以下是一个示例，展示了如何在 `Pass` 函数中检索它：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`LoopAnalysis` is an LLVM analysis class that provides us with a `LoopInfo`
    instance, which includes *all* the `Loop` instances in a `Function`. We can iterate
    through a `LoopInfo` instance to get an individual `Loop` instance, as shown in
    the preceding code.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoopAnalysis` 是一个 LLVM 分析类，它为我们提供了一个 `LoopInfo` 实例，该实例包含 `Function` 中所有的 `Loop`
    实例。我们可以遍历一个 `LoopInfo` 实例来获取一个单独的 `Loop` 实例，如前述代码所示。'
- en: Now, let's look into a `Loop` instance.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个 `Loop` 实例。
- en: Learning about loop terminologies
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习循环术语
- en: 'A `Loop` instance contains multiple `BasicBlock` instances for a particular
    loop. LLVM assigns a special meaning/name to some of these blocks, as well as
    the (control flow) edges among them. The following diagram shows this terminology:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`Loop`实例包含特定循环的多个`BasicBlock`实例。LLVM为其中一些块以及它们之间的（控制流）边赋予了特殊含义/名称。以下图表显示了这些术语：'
- en: '![Figure 10.8 – Structure and terminology used in a loop'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8 – 循环中使用的结构和术语'
- en: '](img/B14590_Figure_10.8.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_10.8.jpg)'
- en: Figure 10.8 – Structure and terminology used in a loop
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 循环中使用的结构和术语
- en: 'Here, every rectangle is a `BasicBlock` instance. However, only blocks residing
    within the dash line area are included in a `Loop` instance. The preceding diagram
    also shows two important control flow edges. Let''s explain each of these terminologies
    in detail:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个矩形都是一个`BasicBlock`实例。然而，只有位于虚线区域内的块才包含在`Loop`实例中。前面的图表还显示了两个重要的控制流边。让我们详细解释每个术语：
- en: '`Loop`, it represents the block that has the header block as the only successor.
    In other words, it''s the only predecessor of the header block.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Loop`，它表示具有头块作为唯一后继者的块。换句话说，它是头块的唯一前驱。'
- en: The existence of a pre-header block makes it easier to write some of the loop
    transformations. For instance, when we want to *hoist* an instruction to the outside
    of the loop so that it is only executed once before entering the loop, the pre-header
    block can be a good place to put this. If we don't have a pre-header block, we
    need to duplicate this instruction for *every* predecessor of the header block.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存在预头块使得编写一些循环转换变得更容易。例如，当我们想要将指令**提升**到循环外部，以便在进入循环之前只执行一次时，预头块可以是一个放置该指令的好地方。如果我们没有预头块，我们需要为头块**每个**前驱重复此指令。
- en: '**Back Edge**: This is the control flow edge that goes from one of the blocks
    in the loop to the header block. A loop might contain several back edges.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回边**：这是从循环中的某个块到头块的控制流边。一个循环可能包含多个回边。'
- en: '**Latch Block**: This is the block that sits at the source of a back edge.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '** latch块**：这是位于回边源处的块。'
- en: '**Exiting Block** and **Exit Block**: These two names are slightly confusing:
    the exiting block is the block that has a control flow edge – the **Exit Edge**
    – that goes *outside* the loop. The other end of the exit edge, which is not part
    of the loop, is the exit block. A loop can contain multiple exit blocks (and exiting
    blocks).'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出块**和**出口块**：这两个名称有些令人困惑：退出块是具有控制流边界的块——即**出口边**——该边界**离开**循环。出口边的另一端，即不属于循环的部分，是出口块。一个循环可以包含多个出口块（和退出块）。'
- en: 'These are the important terminologies for blocks in a `Loop` instance. In addition
    to the control flow structure, compiler engineers are also interested in a special
    value that might exist in a loop: the `i` variable is the induction variable:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是`Loop`实例中块的重要术语。除了控制流结构之外，编译器工程师还对循环中可能存在的一个特殊值感兴趣：`i`变量是归纳变量：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A loop might not contain an induction variable – for example, many `while` loops
    in C/C++ don't have one. Also, it's not always easy to find out about an induction
    variable, nor its *boundary* – the start, end, and stopping values. We will show
    some of the utilities in the next section to help you with this task. But before
    that, we are going to discuss an interesting topic regarding the *canonical* form
    of a loop.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一个循环可能不包含归纳变量——例如，许多C/C++中的`while`循环都没有。此外，找到归纳变量及其**边界**——起始值、结束值和停止值——并不总是容易。我们将在下一节中展示一些工具，以帮助您完成这项任务。但在那之前，我们将讨论一个关于循环**规范**形式的有趣话题。
- en: Understanding canonical loops
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解规范循环
- en: In the previous section, we learned several pieces of terminology for loops
    in LLVM, including the pre-header block. Recall that the existence of a pre-header
    block makes it easier to develop a loop transformation because it creates a simpler
    loop structure. Following this discussion, there are other properties that make
    it easier for us to write loop transformations, too. If a `Loop` instance has
    these nice properties, we usually call it a **canonical loop**. The optimization
    pipeline in LLVM will try to "massage" a loop into this canonical form before
    sending it to any of the loop transformations.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了 LLVM 中循环的几个术语，包括预头块。回想一下，预头块的存在使得开发循环转换更容易，因为它创建了一个更简单的循环结构。在此讨论之后，还有其他一些属性使得我们更容易编写循环转换。如果一个
    `Loop` 实例具有这些良好的属性，我们通常称它为**规范循环**。LLVM 中的优化管道将尝试在将其发送到任何循环转换之前将循环“按摩”成这种规范形式。
- en: 'Currently, LLVM has two canonical forms for `Loop`: a **simplified** form and
    a **rotated** form. The simplified form has the following properties:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，LLVM 为 `Loop` 有两种规范形式：一种**简化**形式和一种**旋转**形式。简化形式具有以下属性：
- en: A pre-header block.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预头块。
- en: A single back edge (and thus a single latch block).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个后继边（因此只有一个锁存块）。
- en: The predecessors of the exit blocks come from the loop. In other words, the
    header block dominates all the exit blocks.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出块的前驱来自循环。换句话说，头块支配所有退出块。
- en: To get a simplified loop, you can run `LoopSimplfyPass` over the original loop.
    In addition, you can use the `Loop::isLoopSimplifyForm` method to check if a `Loop`
    is in this form.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得简化的循环，您可以在原始循环上运行 `LoopSimplfyPass`。此外，您还可以使用 `Loop::isLoopSimplifyForm`
    方法来检查一个 `Loop` 是否处于这种形式。
- en: The benefits of having a single back edge include that we can analyze recursive
    data flow – for instance, the induction variable – more easily. For the last property,
    if every exit block is dominated by the loop, we can have an easier time "sinking"
    instructions below the loop without any interference from other control flow paths.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 单个后继边的好处在于我们可以更容易地分析递归数据流——例如，归纳变量。对于最后一个属性，如果每个退出块都受循环支配，我们可以在没有其他控制流路径干扰的情况下更容易地将指令“下沉”到循环下面。
- en: 'Let''s look at the rotated canonical form. Originally, the rotated form was
    not a formal canonical form in LLVM''s loop optimization pipeline. But with more
    and more loop passes depending on it, it has become the "de facto" canonical form.
    The following diagram shows what this form looks like:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看旋转规范形式。最初，旋转形式在 LLVM 的循环优化管道中不是一个正式的规范形式。但随着越来越多的循环传递依赖于它，它已经成为了“事实上的”规范形式。以下图表显示了这种形式的外观：
- en: '![Figure 10.9 – Structure and terminology of a rotated loop'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.9 – 旋转循环的结构和术语'
- en: '](img/B14590_Figure_10.9.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14590_Figure_10.9.jpg)'
- en: Figure 10.9 – Structure and terminology of a rotated loop
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 旋转循环的结构和术语
- en: To get a rotated loop, you can run `LoopRotationPass` over the original loop.
    To check if a loop is rotated, you can use the `Loop::isRotatedForm` method.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得旋转循环，您可以在原始循环上运行 `LoopRotationPass`。要检查循环是否旋转，您可以使用 `Loop::isRotatedForm`
    方法。
- en: 'This rotated form is basically transforming an arbitrary loop into a `do{…}while(…)`
    loop (in C/C++) with some extra checks. More specifically, let''s say we have
    the following `for` loop:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这种旋转形式基本上是将任意循环转换为一个带有一些额外检查的 `do{…}while(…)` 循环（在 C/C++ 中）。更具体地说，假设我们有一个以下的
    `for` 循环：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Loop rotation effectively turns it into the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 循环旋转有效地将其转换为以下代码：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The highlighted boundary check in the preceding code is used to ensure that
    the loop won't execute if the `i` variable is out of bounds at the very beginning.
    We also call this check the **loop guard**, as shown in the preceding diagram.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中突出显示的边界检查用于确保如果 `i` 变量在最开始就超出范围，则循环不会执行。我们也将这个检查称为**循环守卫**，如前图所示。
- en: In addition to the loop guard, we also found that a rotated loop has a combined
    header, latch, and exiting block. The rationale behind this is to ensure that
    every instruction in this block has the same *execution count*. This is a useful
    property for compiler optimizations such as loop vectorization.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 除了循环守卫之外，我们还发现旋转循环有一个组合的头、锁存和退出块。背后的理由是确保这个块中的每条指令都有相同的*执行计数*。这对于编译器优化，如循环向量化，是一个有用的属性。
- en: With that, we have learned about the various loop terminologies and the definition
    of canonical loops in LLVM. In the next section, we will learn about some APIs
    that can help you inspect some of these properties and process loops in an efficient
    way.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经了解了各种循环术语和 LLVM 中规范循环的定义。在下一节中，我们将了解一些可以帮助你检查这些属性并以高效方式处理循环的 API。
- en: Learning about loop infrastructure in LLVM
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 LLVM 中了解循环基础设施
- en: In the *Learning about loop representation in LLVM* section, we learned about
    the high-level construction and important properties of a loop in LLVM IR. In
    this section, we are going to see what APIs are available for us to inspect those
    properties and further transform the loops. Let's start our discussion from the
    loop pass – the LLVM pass that applies to `Loop` instances.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *在 LLVM 中了解循环表示* 部分，我们学习了 LLVM IR 中循环的高级构造和重要属性。在本节中，我们将了解可用于检查这些属性和进一步转换循环的
    API。让我们从循环传递开始讨论——这是应用于 `Loop` 实例的 LLVM 传递。
- en: 'In [*Chapter 9*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127), *Working
    with PassManager and AnalysisManager*, we learned that there are different kinds
    of LLVM pass that work on different IR units – for instance, we have seen passes
    for `Function` and `Module`. These two kinds of passes have a similar function
    signature for their `run` method – the main entry point of an LLVM pass – as shown
    here:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 9 章*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127)，*与 PassManager 和
    AnalysisManager 一起工作* 中，我们了解到有不同种类的 LLVM 传递，它们在不同的 IR 单元上工作——例如，我们看到了针对 `Function`
    和 `Module` 的传递。这两种类型的传递具有类似的 `run` 方法签名——LLVM 传递的主要入口点，如下所示：
- en: '[PRE58]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Both of their `run` methods take two arguments – a reference to the IR unit
    instance and an `AnalysisManager` instance.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的 `run` 方法都接受两个参数——IR 单元实例的引用和 `AnalysisManager` 实例。
- en: 'In contrast, a loop pass has a slightly more complicated `run` method signature,
    as shown here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，循环传递的 `run` 方法签名稍微复杂一些，如下所示：
- en: '[PRE59]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `run` method takes four arguments, but we already know about the first
    two. Here are the descriptions for the other two:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 方法接受四个参数，但我们已经了解了前两个。以下是其他两个参数的描述：'
- en: The third argument, `LoopStandardAnalysisResults`, provides you with some analysis
    data instances, such as `AAResults` (alias analysis data), `DominatorTree`, and
    `LoopInfo`. These analyses are extensively used by many loop optimizations. However,
    most of them are managed by either `FunctionAnalysisManager` or `ModuleAnalysisManager`.
    This means that, originally, developers needed to implement more complicated methods
    – for example, using the `OuterAnalysisManagerProxy` class – to retrieve them.
    The `LoopStandardAnalysisResults` instance basically helps you retrieve this analysis
    data *ahead of time*.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数，`LoopStandardAnalysisResults`，为你提供一些分析数据实例，例如 `AAResults`（别名分析数据）、`DominatorTree`
    和 `LoopInfo`。这些分析被许多循环优化广泛使用。然而，大多数分析都由 `FunctionAnalysisManager` 或 `ModuleAnalysisManager`
    管理。这意味着，最初，开发者需要实现更复杂的方法——例如，使用 `OuterAnalysisManagerProxy` 类——来检索它们。`LoopStandardAnalysisResults`
    实例基本上帮助你提前检索这些分析数据。
- en: The last argument is used for notifying `PassManager` of any newly added loops
    so that it can put those new loops into the queue before processing them later.
    It can also tell the PassManager to put the current loop into the queue again.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数用于通知 `PassManager` 任何新添加的循环，以便它可以在稍后处理之前将这些新循环放入队列中。它还可以告诉 `PassManager`
    再次将当前循环放入队列中。
- en: 'When we are writing a pass, we will want to use the analysis data provided
    by AnalysisManager – in this case, it is the `LoopAnalysisManager` instance. `LoopAnalysisManager`
    has a similar usage to other versions of AnalysisManager (`FunctionAnalysisManager`,
    for example) we learned about in the previous chapter. The only difference is
    that we need to supply an additional argument to the `getResult` method. Here
    is an example:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写传递时，我们希望使用 AnalysisManager 提供的分析数据——在这种情况下，它是 `LoopAnalysisManager` 实例。`LoopAnalysisManager`
    的用法与其他版本的 AnalysisManager（例如，上一章中我们了解的 `FunctionAnalysisManager`）类似。唯一的区别是我们需要向
    `getResult` 方法提供一个额外的参数。以下是一个示例：
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`LoopNest` is the analysis data that''s generated by `LoopNestAnalysis`. (We
    will talk about both shortly in the *Dealing with nested loops* section.)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoopNest` 是由 `LoopNestAnalysis` 生成的分析数据。（我们将在 *处理嵌套循环* 部分简要讨论这两个内容。）'
- en: As shown in the previous snippet, `LoopAnalysisManager::getResult` takes another
    `LoopStandarAnalysisResults` type argument, in addition to the `Loop` instance.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`LoopAnalysisManager::getResult` 除了接受一个 `LoopStandarAnalysisResults` 类型的参数外，还接受一个
    `Loop` 实例。
- en: Except for having different a `run` method signature and a slightly different
    usage of `LoopAnalysisManager`, developers can build their loop passes in the
    same way as other kinds of passes. Now that we've looked at the foundation provided
    by loop pass and AnalysisManager, it's time to look at some specialized loops.
    The first one we are going to introduce is the *nested* loop.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具有不同的 `run` 方法签名和 `LoopAnalysisManager` 的略微不同用法外，开发者可以以与其他类型相同的方式构建他们的循环传递。现在我们已经了解了循环传递和
    AnalysisManager 提供的基础，是时候看看一些专门的循环了。我们将首先介绍的是**嵌套**循环。
- en: Dealing with nested loops
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理嵌套循环
- en: So far, we have been talking about loops with only one layer. However, nested
    loops – loops with other loop(s) enclosed in them – are also common in real-world
    scenarios. For example, most of the matrix multiplication implementations require
    at least two layers of loops.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在谈论只有一层的循环。然而，嵌套循环——包含其他循环的循环——在现实场景中也很常见。例如，大多数矩阵乘法实现至少需要两层循环。
- en: 'Nested loops are usually depicted as a tree – called a **loop tree**. In a
    loop tree, every node represents a loop. If a node has a parent node, this means
    that the corresponding loop is *enclosed* within the loop being modeled by the
    parent. The following diagram shows an example of this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环通常被表示为树——称为**循环树**。在循环树中，每个节点代表一个循环。如果一个节点有父节点，这意味着相应的循环被父节点所建模的循环**包含**。以下图展示了这一例子：
- en: '![Figure 10.10 – A loop tree example'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.10 – 一个循环树示例'
- en: '](img/B14590_Figure_10.10.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14590_Figure_10.10.jpg]'
- en: Figure 10.10 – A loop tree example
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 一个循环树示例
- en: In the preceding diagram, loops `j` and `g` are enclosed within loop `i`, so
    they are both child nodes of loop `i` in the loop tree. Similarly, loop `k` –
    the innermost loop – is modeled as the child node of loop `j` in the tree.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，循环 `j` 和 `g` 被包含在循环 `i` 内，因此它们都是循环树中循环 `i` 的子节点。同样，循环 `k` —— 最内层的循环 ——
    被建模为树中循环 `j` 的子节点。
- en: 'The root of a loop tree also represents a *top-level* loop in a `Function`.
    Recall that, previously, we learned how to retrieve all `Loop` instances in a
    `Function` by iterating through the `LoopInfo` object – each of the `Loop` instances
    that were retrieved in this way are top-level loops. For a given `Loop` instance,
    we can retrieve its subloops at the next layer in a similar way. Here is an example:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 循环树的根也代表 `Function` 中的**顶层**循环。回想一下，之前我们学习了如何通过迭代 `LoopInfo` 对象来检索 `Function`
    中的所有 `Loop` 实例——以这种方式检索到的每个 `Loop` 实例都是顶层循环。对于给定的 `Loop` 实例，我们可以以类似的方式检索其下一层的子循环。以下是一个示例：
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note that the preceding snippet only traversed the subloops at the next level,
    rather than all the descendant subloops. To traverse all descendant subloops in
    a tree, you have two options:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码片段仅遍历了下一级的子循环，而不是所有后代子循环。要遍历树中的所有后代子循环，你有两种选择：
- en: By using the `Loop::getLoopsInPreorder()` method, you can traverse all the descendant
    loops of a `Loop` instance in a pre-ordered fashion.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `Loop::getLoopsInPreorder()` 方法，你可以以预排序的方式遍历 `Loop` 实例的所有后代循环。
- en: 'In the *Iterating different IR units* section, we have learned what `GraphTraits`
    is and how LLVM uses it for graph traversal. It turns out that LLVM also has a
    default implementation of `GraphTraits` for the loop tree. Therefore, you can
    traverse a loop tree with existing graph iterators in LLVM, such as post-ordering
    and depth-first, to name a few. For example, the following code tries to traverse
    a loop tree rooted at `RootL` in a depth-first fashion:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *迭代不同的 IR 单元* 部分，我们学习了 `GraphTraits` 是什么以及 LLVM 如何使用它进行图遍历。事实证明，LLVM 还为循环树提供了一个默认的
    `GraphTraits` 实现。因此，你可以使用 LLVM 中现有的图迭代器遍历循环树，例如后序和深度优先，仅举几例。例如，以下代码尝试以深度优先的方式遍历以
    `RootL` 为根的循环树：
- en: '[PRE62]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In addition to dealing with individual loops in a loop tree, LLVM also provides
    a wrapper class that represents the whole structure – `LoopNest`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理循环树中的单个循环外，LLVM 还提供了一个表示整个结构的包装类——`LoopNest`。
- en: '`LoopNest` is analysis data that''s generated by `LoopNestAnalysis`. It encapsulates
    all the subloops in a given `Loop` instance and provides several "shortcut" APIs
    for commonly used functionalities. Here are some of the important ones:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoopNest`是由`LoopNestAnalysis`生成的分析数据。它封装了给定`Loop`实例中的所有子循环，并为常用功能提供了几个“快捷”API。以下是一些重要的API：'
- en: '`getOutermostLoop()`/`getInnermostLoop()`: These utilities retrieve the outer/innermost
    `Loop` instances. These are pretty handy because many loop optimizations only
    apply to either the inner or outermost loop.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOutermostLoop()`/`getInnermostLoop()`: 这些实用工具检索最外层/最内层的`Loop`实例。这些工具非常实用，因为许多循环优化仅适用于内层或最外层循环。'
- en: '`areAllLoopsSimplifyForm()`/`areAllLoopsRotatedForm()`: These useful utilities
    tell you if all the enclosing loops are in a certain canonical form, as we mentioned
    in the previous section.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`areAllLoopsSimplifyForm()`/`areAllLoopsRotatedForm()`: 这些有用的实用工具会告诉您所有包围的循环是否处于我们之前章节中提到的某种规范形式。'
- en: '`getPerfectLoops(…)`: You can use this to get all the *perfect loops* in the
    current loop hierarchy. By perfect loops, we are referring to loops that are nested
    together without a "gap" between them. Here is an example of perfect loops and
    non-perfect loops:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPerfectLoops(…)`: 您可以使用此方法获取当前循环层次结构中的所有**完美循环**。所谓完美循环，是指彼此嵌套在一起且之间没有“间隙”的循环。以下是一个完美循环和非完美循环的示例：'
- en: '[PRE63]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With that, you''ve learned how to work with nested loops. In the next section,
    we are going to learn about another important topic for loop optimization: induction
    variables.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，您已经学会了如何处理嵌套循环。在下一节中，我们将学习关于循环优化另一个重要主题：归纳变量。
- en: Retrieving induction variables and their range
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取归纳变量及其范围
- en: 'The induction variable is a variable that progresses by a certain pattern in
    each loop iteration. It is the key to many loop optimizations. For example, in
    order to *vectorize* a loop, we need to know how the induction variable is used
    by the array – the data we want to put in a vector – within the loop. The induction
    variable can also help us resolve the **trip count** – the total number of iterations
    – of a loop. Before we dive into the details, the following diagram shows some
    terminology related to induction variables and where they''re located in the loop:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳变量是在每次循环迭代中按照一定模式进步的变量。它是许多循环优化的关键。例如，为了将循环**向量化**，我们需要知道归纳变量在数组中是如何使用的 –
    即我们想要放入向量的数据 – 在循环内部。归纳变量还可以帮助我们解决循环的**迭代次数** – 总迭代次数。在我们深入细节之前，以下图表显示了与归纳变量及其在循环中的位置相关的术语：
- en: '![Figure 10.11 – Terminology for an induction variable'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11 – 归纳变量的术语'
- en: '](img/B14590_Figure_10.11.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14590_Figure_10.11.jpg](img/B14590_Figure_10.11.jpg)'
- en: Figure 10.11 – Terminology for an induction variable
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 归纳变量的术语
- en: Now, let's introduce some APIs that can help you retrieve the components shown
    in the preceding diagram.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍一些可以帮助您检索前面图表中显示的组件的API。
- en: 'First, let''s talk about the induction variable. The `Loop` class already provides
    two convenient methods for retrieving the induction variable: `getCanonicalInductionVariable`
    and `getInductionVariable`. Both methods return a `PHINode` instance as the induction
    variable (if there are any). The first method can only be used if the induction
    variable starts from zero and only increments by one on each iteration. On the
    other hand, the second method can handle more complicated cases, but requires
    a `ScalarEvolution` instance as the argument.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈归纳变量。`Loop`类已经提供了两个方便的方法来检索归纳变量：`getCanonicalInductionVariable`和`getInductionVariable`。这两个方法都返回一个`PHINode`实例作为归纳变量（如果有）。第一个方法只能在归纳变量从零开始且每次迭代只增加一的情况下使用。另一方面，第二个方法可以处理更复杂的情况，但需要一个`ScalarEvolution`实例作为参数。
- en: '`ScalarEvolution` is an interesting and powerful framework in LLVM. Simply
    put, it tries to track how values *change* – for example, through arithmetic operation
    – over the program path. Putting this into the context of loop optimization, it
    is used to capture recurrence value-changing behaviors in the loop, which has
    a strong relationship with the induction variable.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalarEvolution`是LLVM中一个有趣且强大的框架。简单来说，它试图跟踪值如何**变化** – 例如，通过算术运算 – 在程序路径上。将这个概念应用到循环优化中，它用于捕获循环中的递归值变化行为，这与归纳变量有很强的关联。'
- en: 'To find out more about the induction variable''s behavior in a loop, you can
    retrieve an `InductionDescriptor` instance via `Loop::getInductionDescriptor`.
    An `InductionDescriptor` instance provides information such as the initial value,
    the step value, and the instruction that *updates* the induction variable at each
    iteration. The `Loop` class also provides another similar data structure for realizing
    the boundaries of the induction variable: the `Loop::LoopBounds` class. `LoopBounds`
    not only provides the initial and step values of the induction variable, but also
    the prospective ending value, as well as the predicate that''s used for checking
    the exit condition. You can retrieve a `LoopBounds` instance via the `Loop::getBounds`
    method.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解循环中归纳变量的行为，你可以通过 `Loop::getInductionDescriptor` 获取一个 `InductionDescriptor`
    实例。一个 `InductionDescriptor` 实例提供了诸如初始值、步长值以及在每个迭代中更新归纳变量的指令等信息。`Loop` 类还提供了一个类似的数据结构来实现归纳变量的边界：`Loop::LoopBounds`
    类。`LoopBounds` 不仅提供了归纳变量的初始值和步长值，还提供了预期的结束值以及用于检查退出条件的谓词。你可以通过 `Loop::getBounds`
    方法获取一个 `LoopBounds` 实例。
- en: Loops are crucial for a program's runtime performance. In this section, we learned
    how loops are represented in LLVM IR and how to work with them. We also looked
    at their high-level concepts and various practical APIs for retrieving the desired
    loop properties. With this knowledge, you are one step closer to creating a more
    effective, aggressive loop optimization and gaining even higher performance from
    your target applications.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 循环对于程序的运行时性能至关重要。在本节中，我们学习了循环在 LLVM IR 中的表示方式以及如何与之交互。我们还探讨了它们的高级概念和用于检索所需循环属性的多种实用
    API。有了这些知识，你离创建更有效、更具侵略性的循环优化，并从目标应用程序中获得更高的性能又近了一步。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this section, we learned about LLVM IR – the target-independent intermediate
    representation that sits at the core of the entire LLVM framework. We provided
    an introduction to the high-level structure of LLVM IR, followed by practical
    guidelines on how to walk through different units within its hierarchy. We also
    focused on instructions, values, and SSA form at, which are crucial for working
    with LLVM IR efficiently. We also presented several practical skills, tips, and
    examples on the same topic. Last but not least, we learned how to process loops
    in LLVM IR – an important technique for optimizing performance-sensitive applications.
    With these abilities, you can perform a wider range of program analysis and code
    optimization tasks on LLVM IR.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了关于 LLVM IR 的内容——这是一个位于整个 LLVM 框架核心的目标无关中间表示。我们介绍了 LLVM IR 的高层结构，并提供了如何在它的层次结构中遍历不同单元的实用指南。我们还关注了指令、值和
    SSA 形式，这些对于高效地使用 LLVM IR 至关重要。我们还就同一主题提供了几个实用的技能、技巧和示例。最后但同样重要的是，我们学习了如何在 LLVM
    IR 中处理循环——这是一个优化性能敏感型应用程序的重要技术。有了这些能力，你可以在 LLVM IR 上执行更广泛的程序分析和代码优化任务。
- en: In the next chapter, we will learn about a collection of LLVM utilities APIs
    that can improve your productivity when it comes to developing, diagnosing, and
    debugging with LLVM.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于一组 LLVM 工具 API 的集合，这些 API 可以在开发、诊断和调试使用 LLVM 时提高你的生产力。
