- en: Introduction to Data Flow Computation and the RxCpp Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流计算和 RxCpp 库的介绍
- en: 'From this chapter onward, we will get into meat of the reactive programming
    model. You can consider earlier chapters as a kind of prerequisite for understanding
    the reactive programming model, more specifically reactive programming using the
    C++ programming language. If we look back, we covered the necessary prerequisites,
    which includes the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一章开始，我们将深入了解响应式编程模型的核心。你可以把之前的章节看作是理解响应式编程模型的先决条件，更具体地说是使用 C++ 编程语言进行响应式编程的先决条件。回顾一下，我们已经涵盖了必要的先决条件，其中包括以下内容：
- en: The event programming models on various GUI platforms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种 GUI 平台上的事件编程模型
- en: A whirlwind tour of the Modern C++ language (including functional programming)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代 C++ 语言的快速介绍（包括函数式编程）
- en: Language-level concurrency in C++ for better concurrent systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 中的语言级并发，以实现更好的并发系统
- en: Lock-free programming models (as a step towards declarative programming)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无锁编程模型（作为朝向声明式编程的一步）
- en: Advanced design patterns and the concept of Observables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级设计模式和 Observables 的概念
- en: Event Stream programming using C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++ 进行事件流编程
- en: All of these topics come together in a systematic manner in the case of **functional
    reactive programming** (**FRP**). The FRP acronym is used here in the loose sense
    of programming reactive systems using functional programming constructs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些主题在**函数式响应式编程**（**FRP**）的情况下以系统化的方式结合在一起。在这里，FRP 缩写被用于使用函数式编程构造来编程响应式系统的宽泛意义上。
- en: Simply put, reactive programming is nothing but programming with asynchronous
    data streams. By applying various operations on streams, we can achieve different
    computational goals. The primary task in a reactive program is to convert data
    into streams, regardless of the source of the data. The Event Streams are typically
    called **Observables** and event Stream subscribers are called **Observers**.
    Between Observables and Observers, there are Stream Operators (filters/transforms).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，响应式编程无非就是使用异步数据流进行编程。通过对流应用各种操作，我们可以实现不同的计算目标。在响应式程序中的主要任务是将数据转换为流，无论数据的来源是什么。事件流通常被称为**Observables**，事件流的订阅者被称为**Observers**。在
    Observables 和 Observers 之间，有流操作符（过滤器/转换器）。
- en: Since it is implicitly assumed that the data source won't be mutated while data
    is passed through Operators, we can have multiple Operator paths between Observables
    and Observers. Immutability gives options for out-of-order execution, and scheduling
    can be delegated to a special piece of software called a Scheduler. Thus Observables,
    Observers, Stream Operators, and Schedulers form the backbone of the reactive
    programming model.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认假设数据源在数据通过操作符时不会被改变，我们可以在 Observables 和 Observers 之间有多个操作符路径。不可变性为乱序执行提供了选项，并且调度可以委托给一个名为调度器的特殊软件。因此，Observables、Observers、流操作符和调度器构成了响应式编程模型的支柱。
- en: 'In this chapter, we will cover following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A short discussion about the data flow computing paradigm
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于数据流计算范式的简要讨论
- en: Introduction to the RxCpp library and its programming model
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 RxCpp 库及其编程模型
- en: Some basic RxCpp programs to get our feet wet
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些基本的 RxCpp 程序来入门
- en: Rx Stream Operators
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rx 流操作符
- en: Marble diagrams
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹珠图
- en: Scheduling
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度
- en: '`flatmap`/`concatmap`  oddities'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatmap`/`concatmap` 的奇特之处'
- en: Additional  Rx Operators
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加的 Rx 操作符
- en: The data flow computation paradigm
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流计算范式
- en: Traditionally, programmers encode computer programs in terms of control flow.
    That means we encode programs as a series of small statements (sequence, branching,
    iteration) or functions (including recursive), with their associated states. We
    use constructs, such as selection (`if`/`else`), iteration (`while`/`for`), and
    functions (recursive functions as well), to encode our computation. Handling concurrency
    and state management for these types of program are really difficult and they
    lead to subtle bugs while managing state information which are mutable in nature.
    We need to place locks and other synchronization primitives around shared mutable
    states. At the compiler level, the language compiler will parse the source code
    to generate an **abstract syntax tree** (**AST**), do type analysis, and code
    generation. In fact, AST is an information flow graph where you can perform data-flow
    analysis (for data/register level optimization) and control-flow analysis to exploit
    code pipeline optimization at the processor level. Even though programmers encode
    programs in terms of control flow, the compiler (at least some part of it) tries
    to see the program in terms of data flow as well. The bottom line here is the
    fact that there is an implicit data flow graph dormant in every computer program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，程序员以控制流的形式编码计算机程序。这意味着我们将程序编码为一系列小语句（顺序、分支、迭代）或函数（包括递归），以及它们关联的状态。我们使用诸如选择（`if`/`else`）、迭代（`while`/`for`）和函数（递归函数也包括在内）等构造来编码我们的计算。处理这些类型的程序的并发和状态管理真的很困难，并且在管理可变的状态信息时会导致微妙的错误。我们需要在共享的可变状态周围放置锁和其他同步原语。在编译器级别，语言编译器将解析源代码以生成**抽象语法树**（**AST**），进行类型分析和代码生成。实际上，AST
    是一个信息流图，你可以在其中执行数据流分析（用于数据/寄存器级优化）和控制流分析，以利用处理器级别的代码管道优化。尽管程序员以控制流的形式编码程序，但编译器（至少部分）也试图以数据流的形式看待程序。这里的关键是，每个计算机程序中都存在一个潜在的隐式数据流图。
- en: The data flow computation organizes computation as an explicit graph, where
    nodes are computations and edges are paths for data to flow between the nodes.
    If we place certain restrictions such as preservation of the data state by working
    on a copy of the input data, (the avoidance of in-place algorithms) on computations
    at the nodes in a computational graph, we can exploit opportunities for parallelism.
    The Scheduler will find opportunities for parallelism by doing a topological sort
    on the graph data structure. We will construct the graph data structure using
    streams (`Path`) and operations on streams (`Node`). This can be done declaratively,
    as Operators can be encoded as lambdas, which do some local computations on  node.
    There is a set of primitive standard (functional/stream) Operators, such as `map`,
    `reduce`, `filter`, `take and so on`, are identified by the functional programming
    community which works on streams. There is a provision in every data flow computation
    framework to convert data into streams. The TensorFlow library for machine learning
    is one library that uses the data flow paradigm. The RxCpp library can also be
    considered as a data flow computation library, even though graph creation  process
    is not fully explicit, as in the case of TensorFlow library. Since functional
    programming constructs support lazy evaluation, we are effectively creating a
    computation flow graph, when we construct a stream pipeline with asynchronous
    data streams and operations. These graphs are executed by a scheduling sub system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流计算将计算组织为一个显式图，其中节点是计算，边是数据在节点之间流动的路径。如果我们对计算图中的节点上的计算施加一些限制，例如通过在输入数据的副本上工作来保留数据状态（避免原地算法），我们可以利用并行性的机会。调度器将通过对图数据结构进行拓扑排序来找到并行性的机会。我们将使用流（`Path`）和流操作（`Node`）构建图数据结构。这可以以声明方式完成，因为操作符可以被编码为lambda，对节点进行一些本地计算。有一组原始标准（函数/流）操作符，如`map`、`reduce`、`filter`、`take`等，被函数式编程社区确定，可以在流上工作。在每个数据流计算框架中，都有一种将数据转换为流的方法。用于机器学习的TensorFlow库就是一个使用数据流范式的库。尽管图的创建过程不是完全显式的，RxCpp库也可以被视为一个数据流计算库。由于函数式编程构造支持惰性评估，当我们使用异步数据流和操作构建流水线时，我们实际上正在创建一个计算流图。这些图由调度子系统执行。
- en: An introduction to the RxCpp library
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxCpp库简介
- en: 'We will be using the RxCpp library to write our reactive programs for rest
    of the book. The RxCpp library is a header-only C++ library that can be downloaded
    from a GitHub repo: [http://reactive-extensions.github.io/RxCpp/](http://reactive-extensions.github.io/RxCpp/).
    The RxCpp library relies on Modern C++ constructs, such as language-level concurrency,
    lambda functions/expressions, functional composition/transformation, and operator-overloading,
    to implement reactive programming constructs. The RxCpp library is structured
    along the lines of libraries such as `Rx.net` and `Rxjava`. Like any other reactive
    programming framework, there are some key constructs that everyone should understand
    before they write the first line of code. They are:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其余部分中使用RxCpp库来编写我们的响应式程序。RxCpp库是一个仅包含头文件的C++库，可以从GitHub仓库下载：[http://reactive-extensions.github.io/RxCpp/](http://reactive-extensions.github.io/RxCpp/)。RxCpp库依赖于现代C++构造，如语言级并发、lambda函数/表达式、函数式组合/转换和运算符重载，以实现响应式编程构造。RxCpp库的结构类似于`Rx.net`和`Rxjava`等库。与任何其他响应式编程框架一样，在编写第一行代码之前，每个人都应该了解一些关键构造。它们是：
- en: Observables (Observable Streams)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables（Observable Streams）
- en: Observers (who subscribe to the Observables)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者（订阅Observables的人）
- en: Operators (for example, filters, transformations, and reductions)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符（例如，过滤器、转换和减少）
- en: Schedulers
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器
- en: RxCpp is a header-only library and most of the computation is based on the notion
    of Observables. The library provides lot of primitives to create Observable Streams
    from various data sources. The data sources can be  Arrays, C++ Ranges, STL containers,
    and so on. We can place Operators between Observables and their consumers (monikered
    as Observers). Since functional programming support composition of functions,
    we can place a chain of operators as a single entity between Observables and Observers
    who subscribe to the Streams. The Scheduler associated with the library will make
    sure that when data is available in Observable Streams, it will be passed through
    the series of Operators and a notification will be issued to subscribers. The
    Observers will get notification through on_next,on_completed or on_error lambdas,
    whenever something significant happens in the pipeline. Thus, Observers can focus
    on tasks for which they are primarily responsible, as data will reach them through
    notification.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: RxCpp是一个仅包含头文件的库，大部分计算都基于Observables的概念。该库提供了许多原语，用于从各种数据源创建Observable Streams。数据源可以是数组、C++范围、STL容器等。我们可以在Observables和它们的消费者（被称为Observers）之间放置Operators。由于函数式编程支持函数的组合，我们可以将一系列操作符作为一个单一实体放置在Observables和订阅流的Observers之间。与库相关的调度器将确保当Observable
    Streams中有数据可用时，它将通过一系列Operators传递，并向订阅者发出通知。观察者将通过on_next、on_completed或on_error
    lambda收到通知，每当管道中发生重要事件时。因此，观察者可以专注于它们主要负责的任务，因为数据将通过通知到达它们。
- en: The RxCpp library and its programming model
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxCpp库及其编程模型
- en: In this section, we will write some programs that will help the reader to understand
    the programming model of the RxCpp library. The aim of these programs is to elucidate
    Rx concepts and they are mostly trivial in nature. The code will be sufficient
    for a programmer to incorporate them into a production implementation with minor
    tweaks. In this section, Data producers and their Observables will be based on 
    C++ ranges, STL containers, and so on to make the listings simple enough to digest
    the core concepts  outlined here
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将编写一些程序，帮助读者理解RxCpp库的编程模型。这些程序的目的是阐明Rx概念，它们大多是微不足道的。代码将足以让程序员在进行轻微调整后将其纳入生产实现。在这一部分，数据生产者及其Observables将基于C++范围、STL容器等，以使清单足够简单，以便理解这里概述的核心概念。
- en: A simple Observable/Observer interaction
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的Observable/Observer交互
- en: 'Let''s write a simple program that help us understand the programming model
    of the RxCpp library. In this particular program, we will have an Observable Stream
    and an Observer that subscribes to the Stream. We will generate a series of numbers
    from 1 to 12, using a range object. After creating the range of values and an
    Observable over them, we will attach them together When we execute the program,
    it will print a series of numbers to the console. Finally, a literal string (
    "Oncompleted") will also be printed on the console. :'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序，帮助我们理解RxCpp库的编程模型。在这个特定的程序中，我们将有一个Observable Stream和一个订阅该Stream的Observer。我们将使用一个范围对象从1到12生成一系列数字。在创建值的范围和一个Observable之后，我们将它们连接在一起。当我们执行程序时，它将在控制台上打印一系列数字。最后，一个字面字符串（"Oncompleted"）也将打印在控制台上。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding program will display numbers to the console and the literal string 
    "`OnCompleted` "will also  be displayed  on  the console. This program demonstrates
    how we can create an Observable Stream and connect an Observer to the  the  created 
    Observable Stream using the subscribe method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序将在控制台上显示数字，并且字面字符串"`OnCompleted`"也将显示在控制台上。这个程序演示了如何创建一个Observable Stream，并使用subscribe方法将Observer连接到创建的Observable
    Stream。
- en: Filters and Transformations with Observables
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Observables进行过滤和转换
- en: 'The following program will help us to understand how filter and `map` Operators
    work, besides the usual mechanism of connecting an Observer to Observable Streams
    ,using the subscribe method. The filter method evaluates a predicate on each item
    of the Stream, and if the evaluation happens to produce a positive assertion,
    the item will be present in the output Stream. The `map` operator applies a lambda
    expression on each element of its input Stream and helps produce an output value
    every time (which can be propagated through the pipeline):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将帮助我们理解过滤和`map`操作符的工作原理，以及使用subscribe方法将Observer连接到Observable Streams的通常机制。filter方法对流的每个项目进行谓词评估，如果评估产生积极断言，该项目将出现在输出流中。`map`操作符对其输入流的每个元素应用一个lambda表达式，并在每次产生一个输出值（可以通过管道传播）时帮助产生一个输出值：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding program generates a series of numbers ( as an Observable) and
    passes content of the Stream through a filter function. The `filter` function
    tries to detect whether the number is even. if the predicate is true , the data
    will be passed to the `map` function, which will square its input. Eventually,
    the contents of the Stream will be displayed on to the console.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序生成一系列数字（作为Observable），并通过一个filter函数传递流的内容。`filter`函数尝试检测数字是否为偶数。如果谓词为真，则数据将传递给`map`函数，该函数将对其输入进行平方。最终，流的内容将显示在控制台上。
- en: Streaming values from C++ containers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++容器中流出值
- en: 'The data in STL containers are considered as the data which exists in space.(data
    which are already captured). Even though Rx streams are  meant for processing
    data varying over time (dynamic), we can convert an STL container into a Rx Stream.
    We need to use Iterate operator to do the conversion. This can be handy at times
    and has been helpful in integrating code from code bases that use STL:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: STL容器中的数据被视为存在于空间中的数据（已经捕获的数据）。尽管Rx流用于处理随时间变化的数据（动态数据），我们可以将STL容器转换为Rx流。我们需要使用Iterate操作符进行转换。这在某些时候可能很方便，并且有助于集成使用STL的代码库中的代码。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating Observables from the scratch
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始创建Observables
- en: 'So far, we have written code that create an Observable Stream from a range
    object or STL containers. Let''s see how we can create an Observable Stream from
    the scratch. Well, almost:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了代码，从一个范围对象或STL容器创建了一个Observable Stream。让我们看看如何可以从头开始创建一个Observable
    Stream。嗯，几乎：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding program calls the `on_ext` method to emit a series of numbers
    that are perfect squares. Those numbers (1,4,9) will be printed to the console.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序调用`on_ext`方法来发出一系列完全平方数。这些数字（1,4,9）将被打印到控制台上。
- en: Concatenating Observable Streams
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接Observable Streams
- en: 'We can concatenate two Streams to form a new Stream and this can be handy in
    some cases. Let''s see how this works by writing a simple program:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以连接两个流来形成一个新的流，在某些情况下这可能很方便。让我们通过编写一个简单的程序来看看这是如何工作的：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The concat Operator append the contents of constituent Observable Streams one
    after another by preserving the order. In the preceding code,after creating an
    Observable (values), we did create two additional Observables ( s1 and s2 ) and
    did append the content generated by  second Observable stream (s2) to produce
    a combined Observable Stream (s1.concat(s2)). Finally, we subscribed to the Combined
    Observable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: concat操作符通过保持顺序，将组成的Observable Streams的内容依次附加在一起。在前面的代码中，在创建一个Observable（values）之后，我们创建了另外两个Observables（s1和s2），并附加了第二个Observable
    Stream（s2）生成的内容，以产生一个组合的Observable Stream（s1.concat(s2)）。最后，我们订阅了组合的Observable。
- en: Unsubscribing from Observable Streams
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消订阅Observable Streams
- en: The following program shows how one can subscribe to an Observable and stop
    the subscription, if it is warranted.  in the case of some programs ,this option
    is very useful.  Please consult the Rxcpp documentation to understand more about
    the subscription and how one can use them effectively. In the mean time, following
    program will demonstrate how cone can un-subscribe from a Observable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序展示了如何订阅 Observable 并在需要时停止订阅。在某些程序的情况下，这个选项非常有用。请参阅 Rxcpp 文档，了解更多关于订阅以及如何有效使用它们的信息。与此同时，以下程序将演示如何取消订阅
    Observable。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the above program, when the value emitted reaches a thresh hold value, we
    do call unsubscribe (subs.unsubscribe ()) method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的程序中，当发出的值达到阈值时，我们调用取消订阅（subs.unsubscribe()）方法。
- en: An introduction to marble diagrams for visual representation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于大理石图表的视觉表示的介绍
- en: 'It is difficult to visualize Rx Streams, as the data flows asynchronously.
    The designers of Rx systems have created a set of visualization cues called **marble
    diagrams**: Let us write a small program and depict logic of the map Operator
    as a marble diagram.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很难将 Rx Streams 可视化，因为数据是异步流动的。Rx 系统的设计者创建了一组名为**大理石图表**的可视化线索：让我们编写一个小程序，并将
    map 操作符的逻辑描述为大理石图表。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Rather than giving a description of marble diagrams, let''s look at a marble
    diagram that depicts the `map` operator:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与其描述大理石图表，不如看一个描述 `map` 操作符的大理石图表：
- en: '![](img/d4c71177-6c60-4fa9-aae4-f57b3c7d3b83.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4c71177-6c60-4fa9-aae4-f57b3c7d3b83.png)'
- en: The top part of the marble diagram shows a timeline where a series of values
    (represented as circles) are displayed. Each of the value will be passing through
    a map Operator, which takes a lambda as parameter. The lambda will be applied
    on each element of the Stream to produce  the output Stream (shown in the bottom
    part of the diagram as a diamond).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大理石图表的顶部显示了一个时间线，其中显示了一系列值（表示为圆圈）。每个值将通过一个 map 操作符，该操作符以 lambda 作为参数。lambda
    将应用于流的每个元素，以产生输出流（在图表的底部部分显示为菱形）。
- en: RxCpp (Stream) Operators
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxCpp（流）操作符
- en: One of the primary advantage of Stream-oriented processing is the fact that
    we can apply functional programming primitives on them. In RxCpp parlance, the
    processing is done using Operators. They are nothing but filters, transformations,
    aggregations, and reductions on Streams. We have already seen how the `map`, `filter`,
    and `take` operators work in the previous examples. Let us explore them further.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 流导向处理的主要优势之一是我们可以在其上应用函数式编程原语。在 RxCpp 术语中，处理是使用操作符完成的。它们只是对流的过滤、转换、聚合和减少。我们已经看到了
    `map`、`filter` 和 `take` 操作符在之前的示例中是如何工作的。让我们进一步探索它们。
- en: The average Operator
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平均值操作符
- en: 'The `average` Operator computes arithmetic mean of values from Observable Streams.
    The other statistical Operators supported include:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`average` 操作符计算来自 Observable Streams 的值的算术平均值。其他支持的统计操作符包括：'
- en: Min
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Min
- en: Max
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Max
- en: Count
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数
- en: Sum
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sum
- en: 'The following program just demonstrates the `average` Operator. The schema
    is the same for other operators in the preceding list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序只是演示了 `average` 操作符。在前面的列表中，其他操作符的模式是相同的：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Scan Operator
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描操作符
- en: 'The `scan` Operator applies a function on each element of a Stream sequentially
    and accumulates the value into a seed value. The following program produces average
    of a series of numbers as and when the values are accumulated:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan` 操作符对流的每个元素依次应用函数，并将值累积到种子值中。以下程序在值累积时产生一系列数字的平均值：'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The running average will be printed on to the console. `OnNext functor` will
    be called twenty times before `OnCompleted` is called.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行平均值将打印到控制台。在调用 `OnCompleted` 之前，`OnNext functor` 将被调用二十次。
- en: Composing Operators through the pipe Operator
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过管道操作符组合操作符
- en: 'The RxCpp library allows devolopers to chain or compose Operators to enable
    Operator composition. The library allows you to use the `pipe` (`|`) Operator
    to compose Operators (instead of the usual fluent interface using the  "." ),
    and programmers can pipe the output of one Operator to another as if they are
    in the command line of a UNIX shell. This assists in comprehension (about what
    a piece of code does ). The following program uses the `|` Operator to map a range.
    The RxCpp samples contain many examples using pipe functions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: RxCpp 库允许开发者链式或组合操作符以启用操作符组合。该库允许您使用 `pipe` (`|`) 操作符来组合操作符（而不是使用 "." 的通常流畅接口），程序员可以将一个操作符的输出管道传递给另一个，就像在
    UNIX shell 的命令行中一样。这有助于理解（代码的作用是什么）。以下程序使用 `|` 操作符来映射一个范围。RxCpp 示例包含许多使用管道函数的示例：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Working with Schedulers
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调度器
- en: We have already learned about Observables, Operators, and Observers , in the
    above section. We now know that, between Observables and Observers, we can apply
    standard Rx Operators to filter and transform streams. In the case of Functional
    Programming, we write immutable functions (functions without side-effects) and
    a consequence of immutability is the potential for an out-of-order execution.
    The order in which we execute a function/functor does not matter, if we can guarantee
    that the input to an Operator is never modified. Since an Rx program will be manipulating
    multiple Observables  and Observers, we can delegate the task of choosing the
    execution order to a Scheduler module. By default, Rxcpp is single threaded. The
    RxCpp will schedule the execution of Operators in the thread which we called the `subscribe` method.
    It is possible to specify a different thread using the `observe_on` and `subscribe_on`
    operators. Also, some Observable Operators take a Scheduler as a parameter, where
    execution can happen in a thread managed by the Scheduler.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上面的部分学习了Observables、Operators和Observers。我们现在知道，在Observables和Observers之间，我们可以应用标准的Rx操作符来过滤和转换流。在函数式编程的情况下，我们编写不可变的函数（没有副作用的函数），不可变性的结果是可能出现无序执行。如果我们可以保证操作符的输入永远不会被修改，那么执行函数/函子的顺序就不重要了。由于Rx程序将操作多个Observables和Observers，我们可以将选择执行顺序的任务委托给调度程序模块。默认情况下，Rxcpp是单线程的。RxCpp将在我们调用`subscribe`方法的线程中安排操作符的执行。可以使用`observe_on`和`subscribe_on`操作符指定不同的线程。此外，一些Observable操作符以调度程序作为参数，执行可以在调度程序管理的线程中进行。
- en: 'The RxCpp library supports the following two Scheduler types:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: RxCpp库支持以下两种调度程序类型：
- en: '`ImmediateScheduler`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImmediateScheduler`'
- en: '`EventLoopScheduler`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventLoopScheduler`'
- en: 'The RxCpp library is single-threaded by default. But you can configure it to
    run in multiple threads using certain operators:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: RxCpp库默认是单线程的。但是你可以使用特定的操作符来配置它在多个线程中运行：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding program will produce the following output. We will be using the
    STD C++ thread ID to help us distinguish the items scheduled in the new thread
    (one of which is different from the main thread):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序将产生以下输出。我们将使用STD C++线程ID来帮助我们区分在新线程中安排的项目（其中一个与主线程不同）：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following program will demonstrate the usage of the `subscribe_on` method.
    There are subtle differences between the `observe_on` and `subscribe_on` methods
    in terms of behavior. The purpose of the following listing is to show the options
    available for declarative scheduling:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将演示`subscribe_on`方法的用法。在行为上，`observe_on`和`subscribe_on`方法之间存在微妙的差异。以下列表的目的是展示声明式调度的选项：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A tale of two Operators – flatmap versus concatmap
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个操作符的故事- flatmap与concatmap
- en: 'A source of confusion among developers is often centered around the flatmap and
    `concatmap`  Operators. Their differences are really important and we will cover
    them in this section. Let''s take a look at the flatmap  operator and how it works:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员经常围绕flatmap和`concatmap`操作符产生困惑。它们的区别非常重要，我们将在本节中进行介绍。让我们看一下flatmap操作符以及它的工作原理：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The previous program produces output sequence which are not predictable. The
    output of one run of the program is shown as follows. This need not be what we
    get when we run it again.  The reason for this behavior has to do with the post
    processing of the Stream after the mapping operation: The flatmap uses merge Operator
    for post processing of Streams.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序产生了不可预测的输出序列。程序的一次运行的输出如下所示。这不一定是再次运行时得到的结果。这种行为的原因与映射操作后的流的后处理有关：flatmap使用merge操作符对流进行后处理。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following marble diagram shows schema of the operation. The `flat_map` applies
    the lambda on the Observable Stream and produces a new Observable Stream. The
    Streams produced are merged together to provide the output. In the diagram, the
    red ball gets transformed into a pair of red colored diamonds, whereas the output
    of the green and blue balls produces interleaved diamonds as output in the newly
    created Observable:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的弹珠图显示了操作的模式。`flat_map`对Observable Stream应用lambda并产生一个新的Observable Stream。产生的流被合并在一起以提供输出。在图中，红色的球被转换成一对红色的菱形，而绿色和蓝色的球的输出在新创建的Observable中产生交错的菱形：
- en: '![](img/343fddd9-d86e-484b-97e8-15b35584ee34.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/343fddd9-d86e-484b-97e8-15b35584ee34.png)'
- en: 'Let us look at the `concat_map` operator by going through the listing given
    below. The program listing is identical to the earlier program. The only change
    is the substitution of the `flat_map` with `concat_map`. Even though there is
    no practical difference in the listing, there is a marked difference in the output
    behavior. Maybe `concat_map` produces output that suits the synchronized mental
    model of the programmer:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下列表来看一下`concat_map`操作符。程序列表与之前的程序相同。唯一的变化是用`concat_map`替换了`flat_map`。尽管列表中没有实际区别，但输出行为上有明显的不同。也许`concat_map`产生的输出更适合程序员的同步心理模型：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is how the output will look:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following marble diagram shows `concat_map` in operation. Unlike the Flatmap
    marble diagram, the output is synchronized (red, green, and blue balls produce
    the same colored output in the order in which the input is processed):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的弹珠图显示了`concat_map`的操作。与Flatmap弹珠图不同，输出是同步的（红色、绿色和蓝色的球按照输入处理的顺序产生相同颜色的输出）：
- en: '![](img/0fc73749-7bc0-4da9-bfc4-95c0a87e3b28.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fc73749-7bc0-4da9-bfc4-95c0a87e3b28.png)'
- en: 'In the case of `flat_map`, we got the output in an interleaved manner. But
    in the case of `concat_map`, we got the value in the order that we expected the
    output. What is the real difference here? To make the difference clear, let''s
    take a look at two operators: `concat` and `merge`. Let''s look into the way the
    concatenation of the Streams works. It basically appends the contents of the Stream
    one after the another, preserving the order:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`flat_map`的情况下，我们以交错的方式得到了输出。但在`concat_map`的情况下，我们按照预期的顺序得到了值。这里真正的区别是什么？为了澄清区别，让我们看看两个操作符：`concat`和`merge`。让我们看看流的连接方式。它基本上是将流的内容一个接一个地附加，保持顺序：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following marble diagram clearly shows what happens when a `concat` Operator
    is applied on two Streams. We create a new Stream by appending contents of the
    second Stream to the contents of the first. This preserves the order:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下弹珠图清楚地显示了当`concat`操作符应用于两个流时会发生什么。我们通过将第二个流的内容附加到第一个流的内容来创建一个新流。这保留了顺序：
- en: '![](img/c2d0a75b-de50-4890-9735-f63cb41d2227.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2d0a75b-de50-4890-9735-f63cb41d2227.png)'
- en: 'Now, let''s see what happens when two Streams are merged. The following code
    shows how you can merge two Streams:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当两个流合并时会发生什么。以下代码显示了如何合并两个流：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following marble diagram clearly shows what happens when we merge two Observable
    Streams. The contents of the output Stream will be an interleaved combination
    of two Streams:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下弹珠图清楚地显示了当我们合并两个Observable流时会发生什么。输出流的内容将是两个流的交错组合：
- en: '![](img/b4d9457c-159e-44d7-9893-64b195484549.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4d9457c-159e-44d7-9893-64b195484549.png)'
- en: Both flat_map and concat_map more or less do the same operation. The difference
    lies in the way values are combined together. The `flat_map`  uses the `merge` Operator,
    while the `concact_map ` uses the `concact` Operator for post processing of results.
    In the case of `merge`, the order does not matter. The `concat` operator appends
    Observables one after the another. That is why you got synchronized output with
    concat_map and flat_map produced irregularly ordered results.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`flat_map`和`concat_map`基本上做相同的操作。区别在于值的组合方式。`flat_map`使用`merge`操作符，而`concact_map`使用`concact`操作符进行结果的后处理。在`merge`的情况下，顺序并不重要。`concat`操作符将Observable一个接一个地附加。这就是为什么使用`concat_map`会得到同步的输出，而`flat_map`会产生无序的结果。'
- en: Other Important Operators
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他重要操作符
- en: 'We now understand the crux of reactive programming model, because we covered
    basic topics such as Observables, Observers, Operators, and Schedulers. There
    are some more Operators we should know about to write our logic better. In this
    section, we will cover the `tap` , `defer` and `buffer` Operators. We will first
    explore the `tap`  Operator, which helps peek into the contents of the Stream:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了响应式编程模型的要点，因为我们涵盖了诸如Observables、Observers、Operators和Schedulers等基本主题。还有一些我们应该了解以更好地编写逻辑的操作符。在本节中，我们将介绍`tap`、`defer`和`buffer`操作符。我们将首先探讨`tap`操作符，它可以帮助查看流的内容：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s take a look at the `defer` operator. The `defer` operator takes
    an Observable factory as a parameter to create an Observable for each client that
    subscribes to it. In the following program, we invoke the `observable_factory` lambda
    when somebody tries to connect to the specified Observable:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`defer`操作符。`defer`操作符将Observable工厂作为参数，为每个订阅它的客户端创建一个Observable。在下面的程序中，当有人尝试连接到指定的Observable时，我们调用`observable_factory`
    lambda：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `buffer` Operator emits an Observable that contains the non-overlapping
    contents of an Observable, each containing at most the number of items specified
    by the count parameter. This will help us to process the items in a manner suitable
    for the content:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer`操作符发出一个Observable，其中包含Observable的非重叠内容，每个Observable最多包含由count参数指定的项目数。这将帮助我们以适合内容的方式处理项目：'
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `timer` Operator emits an Observable that takes the interval period as
    a parameter. There is an option to specify the `Scheduler` object as a parameter.
    There are various versions of this function in the library; we have shown one
    in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer`操作符发出一个Observable，以间隔周期作为参数。有一个选项可以指定`Scheduler`对象作为参数。库中有这个函数的各种版本；我们在下面的代码中展示了其中一个：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A peek into the things we haven't covered yet
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们尚未涵盖的事物一瞥
- en: 'The Rx programming model can be considered as confluence of the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Rx编程模型可以被认为是以下内容的汇合：
- en: Data-flow computation
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流计算
- en: Declarative concurrency
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式并发
- en: Functional programming
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Stream processing (event)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流处理（事件）
- en: Design patterns and idioms
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式和习语
- en: 'To get a comprehensive view of the whole discipline, you need to work with
    the programming model extensively. Initially, things won''t make much sense. At
    some point, you''ll reach a *click point* where everything will start making sense.
    So far, we have covered the following topics:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解整个学科，您需要广泛地使用编程模型。最初，事情不会有太多意义。在某个时候，您会达到一个*点燃点*，一切都会开始有意义。到目前为止，我们已经涵盖了以下主题：
- en: Observables and Observers
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables和Observers
- en: Basic and intermediate Operators
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本和中级操作符
- en: Basic and intermediate scheduling
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本和中级调度
- en: 'This is just the beginning, and we need to cover many more topics to get familiar
    with the programming model. They are:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个开始，我们需要涵盖更多的主题，以熟悉编程模型。它们是：
- en: Hot and cold Observables ([Chapter 8](b59c2b7c-703d-4c1d-8c31-db01506c57db.xhtml), 
    *RxCpp - the Key Elements*)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热和冷Observables（[第8章](b59c2b7c-703d-4c1d-8c31-db01506c57db.xhtml)，*RxCpp - 关键元素*）
- en: A detailed exploration of Rx components ([Chapter 8](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86), 
    *RxCpp - the Key Elements*)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rx组件的详细探索（[第8章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86)，*RxCpp
    - 关键元素*）
- en: Advanced scheduling ([Chapter 8](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86),
    *RxCpp - the Key Elements)*
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级调度（[第8章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86)，*RxCpp
    - 关键元素*）
- en: Programming GUI systems ([Chapter 9](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86), *Reactive
    GUI Programming Using Qt/C++*)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程GUI系统（[第9章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86)，*使用Qt/C++进行响应式GUI编程*）
- en: Advanced operators ([Chapter 10](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86),
    Creating Custom Operators in RxCpp)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级操作符（[第10章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86)，在RxCpp中创建自定义操作符）
- en: Reactive design patterns ([Chapter 11](dfe8398d-170d-4ce3-94f0-7ffae409d1e5.xhtml),
    *Design Patterns and Idioms for C++ Rx Programming*)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式设计模式（[第11章](dfe8398d-170d-4ce3-94f0-7ffae409d1e5.xhtml)，*C++ Rx编程的设计模式和习语*）
- en: Programming for robustness (Chapter 13, *Advanced Streams and Handling Errors*)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程的健壮性（第13章，*高级流和错误处理*）
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered quite a bit of ground in understanding the Rx programming
    model in general, and  the RxCpp library in particular. We started with a conceptual
    overview of the data flow computing paradigm and moved quickly to writing some
    basic RxCpp programs. After introducing Rx marble diagrams, we learned about the
    set of Operators supported by the RxCpp library. We also introduced the important
    topic of Scheduler, and finally we discussed the difference between the `flatmap` and
    `concatmap`  Operators. In the next chapter, we will cover `hot` and `cold` Observables,
    Advanced scheduling, and some  topics that we have not covered in this chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在理解Rx编程模型和RxCpp库方面涵盖了相当多的内容。我们从数据流计算范式的概念概述开始，迅速转向编写一些基本的RxCpp程序。在介绍Rx弹珠图后，我们了解了RxCpp库支持的一组操作符。我们还介绍了调度器这一重要主题，最后讨论了`flatmap`和`concatmap`操作符之间的区别。在下一章中，我们将涵盖`hot`和`cold`可观察对象，高级调度以及一些本章未涵盖的主题。
