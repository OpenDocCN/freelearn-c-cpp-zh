- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Creating an Online Co-Op Platformer Prototype
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建在线合作平台游戏原型
- en: In this chapter, we will delve deeper into the work of creating action multiplayer
    online games. Our goal is to turn a local multiplayer puzzle platformer game prototype
    into an online version.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨创建动作多人在线游戏的工作。我们的目标是把一个本地多人拼图平台游戏原型转变为在线版本。
- en: 'Here’s what the final puzzle platformer prototype will look like:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终拼图平台游戏原型的样子：
- en: '![Figure 8.1 – A preview of the Puzzle Platformer prototype](img/Figure_08.01_B18527.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 拼图平台游戏原型的预览](img/Figure_08.01_B18527.jpg)'
- en: Figure 8.1 – A preview of the Puzzle Platformer prototype
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 拼图平台游戏原型的预览
- en: By the end of this chapter, you’ll know how to use the features of the `MultiplayerSpawner`
    node to create and assign playable characters to each player in the game, using
    the features offered by `MultiplayerSynchronizer` to sync relevant properties.
    With these features, we can go beyond updating the position of nodes; they will
    allow us to synchronize other properties, particularly animations. You will also
    learn how to leverage **Remote Procedure Calls** (**RPCs**) to manipulate the
    **multiplayer authority** of nodes. This will enable us to implement an exciting
    object-grabbing mechanic that will be a key element in our prototype.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何使用`MultiplayerSpawner`节点的功能来创建和分配可玩角色给游戏中的每个玩家，并使用`MultiplayerSynchronizer`提供的功能同步相关属性。有了这些功能，我们不仅可以更新节点的位置；它们还将允许我们同步其他属性，尤其是动画。您还将学习如何利用**远程过程调用（RPCs**）来操纵节点的**多人权限**。这将使我们能够实现一个令人兴奋的对象抓取机制，这将是我们的原型中的关键元素。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To access the resources for this chapter, you can find our repository of online
    projects by following the link provided here: [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的资源，您可以点击此处提供的链接找到我们的在线项目仓库：[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)。
- en: Once you have the repository, open the `res://08.designing-online-platformer`
    folder in the Godot Engine editor. All the necessary files for this chapter are
    located there.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了仓库，请打开Godot引擎编辑器中的`res://08.designing-online-platformer`文件夹。本章所需的所有文件都位于那里。
- en: Now, let’s begin the onboarding process. In the upcoming section, we will familiarize
    ourselves with the project, explore its main classes, and identify where we need
    to implement networking features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始入职流程。在接下来的部分，我们将熟悉项目，探索其主要类，并确定我们需要实现网络功能的地方。
- en: Introducing the platformer project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍平台游戏项目
- en: Our project presents a captivating puzzle platformer that will test players’
    strategic thinking and collaboration skills as they overcome challenging obstacles
    together. At the heart of this game lies a core mechanic centered around the manipulation
    of objects, utilizing them to construct platforms for the other player to traverse.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目展示了一个引人入胜的拼图平台游戏，玩家在克服挑战性障碍的过程中将测试他们的战略思维和协作技能。这个游戏的核心机制围绕着对象的操控，利用它们为其他玩家构建可以穿越的平台。
- en: Now, let’s dive into the essential classes that serve as the pillars of our
    project’s foundation. Our first encounter will be with the `Player` class, which
    embodies the avatars controlled by each individual player. As the main protagonist,
    the `Player` class handles essential functionalities such as movement and interaction
    with various environmental elements. Notably, the `Player` class incorporates
    `InteractionArea2D` that detects contact with `InteractiveArea2D`, enabling players
    to perform specific actions upon them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解构成我们项目基础的基石类。我们的第一次接触将是`Player`类，它代表了每个玩家控制的化身。作为主要的主角，`Player`类处理诸如移动和与各种环境元素交互等基本功能。值得注意的是，`Player`类集成了`InteractionArea2D`，它可以检测与`InteractiveArea2D`的接触，使玩家能够在它们上执行特定操作。
- en: Moving forward, we encounter the `InteractiveArea2D` class. This class extends
    the functionality of the `Area2D` node and assumes the crucial role of a trigger
    area for detecting interactions. When `InteractionArea2D` overlaps with `InteractiveArea2D`,
    it becomes responsive to input events. Triggering the designated *interact* input
    action emits a signal, allowing us to create further engaging gameplay interactions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遇到了 `InteractiveArea2D` 类。这个类扩展了 `Area2D` 节点的功能，并承担了检测交互的关键触发区域角色。当 `InteractionArea2D`
    与 `InteractiveArea2D` 重叠时，它会对输入事件做出响应。触发指定的 *interact* 输入动作会发出信号，使我们能够创建更吸引人的游戏交互。
- en: In our game, the `Crate` class represents an interactive object that players
    can skillfully manipulate. Each `Crate` instance has an `InteractiveArea2D` node
    and a `CharacterBody2D` node, offering players the opportunity to collide with
    and leap onto them, which allows players to use them as viable platforms for navigating
    the level. These crates stand as major elements for puzzle-solving and advancing
    through the game’s levels.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，`Crate` 类代表一个玩家可以熟练操作的交互式对象。每个 `Crate` 实例都有一个 `InteractiveArea2D` 节点和
    `CharacterBody2D` 节点，为玩家提供了与它们碰撞和跳跃的机会，这使得玩家可以将它们作为可行的平台来导航关卡。这些箱子是解决谜题和通过游戏关卡的主要元素。
- en: Lastly, we encounter the versatile `PlayerSpawner` class, responsible for the
    dynamic spawning and management of players within the game. This class adeptly
    adapts to the number of participating players, seamlessly instantiating a `Player`
    instance for each individual. Additionally, in the realm of local multiplayer,
    the `PlayerSpawner` class ensures a smooth and immersive gaming experience by
    establishing distinct controls for each player and optimizing gameplay customization.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遇到了多才多艺的 `PlayerSpawner` 类，它负责在游戏中动态生成和管理玩家。这个类能够灵活地适应参与玩家的数量，为每个玩家无缝地实例化一个
    `Player` 实例。此外，在本地多人游戏中，`PlayerSpawner` 类通过为每个玩家设置独特的控制并优化游戏定制来确保流畅和沉浸式的游戏体验。
- en: In the upcoming section, we will dive into the `Player` object, which is composed
    of a script and a scene. We are going to understand how the script works with
    the available nodes on the scene and structures the desired behavior for our local
    `Player` node.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将深入研究 `Player` 对象，它由脚本和场景组成。我们将了解脚本如何与场景上的可用节点协同工作，并构建我们本地 `Player`
    节点的期望行为。
- en: Understanding the Player class
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Player 类
- en: The `Player` class and scene represent the player’s avatar in the game. It is
    through this scene and script that players interact with the game world. The scene
    is a `CharacterBody2D` node with a `CollisionShape2D` Resource, a `Node2D` node
    called `Sprites`, which we use to group and pivot an `AnimatedSprite2D` node,
    and an `InteractionArea2D` node, which we are going to talk about in the *How
    the InteractiveArea2D class works* section. The `InteractionArea2D` node also
    has a `CollisionShape2D` Resource and a `RemoteTransformer2D` node, which we call
    `GrabberRemoteTransformer2D`. A `RemoteTransformer2D` node allows us to remotely
    sync the position, rotation, and scale of a node that is outside the hierarchy
    of the `RemoteTransformer2D`’s parent as if it were a sibling of the `RemoteTransformer2D`,
    which is very useful. In this case, we use the `GrabberRemoteTransformer2D` node
    to remotely transform the objects the player can grab, such as the *crate*, which
    we will talk about in the *Unveiling the Crate class* section. Finally, the `Player`
    class also has a `Label` node that we use to visually communicate the player controlling
    the avatar.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 类和场景代表了游戏中的玩家角色。玩家正是通过这个场景和脚本与游戏世界进行交互。场景是一个带有 `CollisionShape2D`
    资源的 `CharacterBody2D` 节点，一个名为 `Sprites` 的 `Node2D` 节点，我们用它来分组和旋转一个 `AnimatedSprite2D`
    节点，以及一个 `InteractionArea2D` 节点，我们将在 *InteractiveArea2D 类的工作原理* 部分进行讨论。`InteractionArea2D`
    节点也包含一个 `CollisionShape2D` 资源和一个 `RemoteTransformer2D` 节点，我们称之为 `GrabberRemoteTransformer2D`。一个
    `RemoteTransformer2D` 节点允许我们远程同步一个节点（它位于 `RemoteTransformer2D` 父节点的层次结构之外）的位置、旋转和缩放，就像它是
    `RemoteTransformer2D` 的兄弟节点一样，这非常有用。在这种情况下，我们使用 `GrabberRemoteTransformer2D` 节点来远程变换玩家可以抓取的对象，例如
    *箱子*，我们将在 *揭开 Crate 类的面纱* 部分进行讨论。最后，`Player` 类还有一个 `Label` 节点，我们用它来视觉上传达控制角色的玩家。'
- en: '![Figure 8.2 – The Player’s scene node hierarchy](img/Figure_8.02_B18527.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 玩家的场景节点层次结构](img/Figure_8.02_B18527.jpg)'
- en: Figure 8.2 – The Player’s scene node hierarchy
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 玩家的场景节点层次结构
- en: 'Now, let’s look at the script itself. There are some aspects that we won’t
    delve into in this section because they are more related to the basic platformer
    game player movement, and our focus here is on the online multiplayer aspect,
    so we would go beyond our scope. But the important part for your job is to know
    that when two players are playing locally, the `Player` node can set up its controllers
    dynamically so each player controls only one avatar. And this is something you’ll
    have to make work in the online version of the prototype: how each player will
    control only their own avatar. For reference, the following code snippet does
    this locally:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看脚本本身。在本节中，我们不会深入探讨一些方面，因为它们与基本平台游戏玩家移动更相关，而我们在这里的重点是网络多人游戏方面，所以我们将超出我们的范围。但对你工作来说重要的是要知道，当两个玩家在本地玩游戏时，`Player`节点可以动态设置其控制器，以便每个玩家只控制一个角色。在原型网络版本中，你必须实现这一点：每个玩家将只控制自己的角色。为了参考，以下代码片段在本地执行此操作：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code iterates over actions in `InputMap` singleton and creates
    new actions specific to a given controller device, using an index. It also updates
    the events and properties associated with the actions to be specific to the given
    device. The purpose of this code is to set up controller mappings for different
    players or devices in a game, allowing customization and differentiation of input
    controls.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码遍历`InputMap`单例中的操作，并使用索引创建针对给定控制器设备的新操作。它还更新与操作相关的事件和属性，以确保它们针对特定设备。此代码的目的是为游戏中的不同玩家或设备设置控制器映射，允许自定义和区分输入控制。
- en: In the next section, let’s see how the *Crate* scene works, it’s a pretty simple
    scene that essentially works as a passive object that players can use as a platform
    to move around the level.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看*Crate*场景是如何工作的，这是一个相当简单的场景，本质上作为一个被动对象，玩家可以用它作为移动的平台。
- en: Unveiling the Crate class
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示*Crate*类
- en: 'The `Crate` scene plays a crucial role in our game prototype. It represents
    interactive objects that players can skillfully manipulate to overcome obstacles
    and progress through the levels. Each instance of the `Crate` scene is a `Node2D`
    equipped with two important components: `InteractiveArea2D` node and `CharacterBody2D`
    node.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Crate`场景在我们的游戏原型中起着至关重要的作用。它代表玩家可以熟练操作的交互式对象，以克服障碍并通过关卡。`Crate`场景的每个实例都配备了两个重要的组件：`InteractiveArea2D`节点和`CharacterBody2D`节点。'
- en: '![Figure 8.3 – The Crate’s scene node hierarchy](img/Figure_8.03_B18527.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – *Crate*场景节点层次结构](img/Figure_8.03_B18527.jpg)'
- en: Figure 8.3 – The Crate’s scene node hierarchy
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – *Crate*场景节点层次结构
- en: The `CharacterBody2D` node represents the physical body of the *Crate* node
    within the game’s physics simulation. It ensures that the crates collide with
    the player’s avatar or other objects. The `CharacterBody2D` node handles the collision
    detection and response, allowing the player to seamlessly jump on and stand on
    the crate as if it were a solid platform.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharacterBody2D`节点代表游戏物理模拟中*Crate*节点的物理身体。它确保箱子与玩家的角色或其他对象发生碰撞。`CharacterBody2D`节点处理碰撞检测和响应，使玩家能够无缝地跳上并站在箱子上，就像它是一个坚固的平台。'
- en: As for `InteractiveArea2D` node, it is a special `Area2D` node that detects
    when `InteractiveArea2D` nodes overlap with it. In the context of the `Crate`
    class, the `InteractiveArea2D` node allows players to grab and lift the *Crate*
    nodes if they press the `interact` action while their `InteractionArea2D` node
    overlaps with the *Crate*’s `InteractionArea2D` node. This interaction enables
    players to use the *Crate* nodes as sturdy platforms to navigate the level since
    they will be able to move them around and jump on them even when another player
    is grabbing them. `InteractiveArea2D` node acts as a trigger, detecting when the
    player’s avatar comes into contact with the `Crate` node and assigning the `Crate`
    node to the player’s avatar `GrabbingRemoteTransform2D` node, synchronizing its
    position with the player even when they are moving.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`InteractiveArea2D`节点，它是一个特殊的`Area2D`节点，用于检测当`InteractiveArea2D`节点与其重叠时。在*Crate*类的上下文中，`InteractiveArea2D`节点允许玩家在按下`interact`动作且其`InteractionArea2D`节点与*Crate*的`InteractionArea2D`节点重叠时抓住并举起*Crate*节点。这种交互使玩家能够将*Crate*节点作为坚固的平台来导航关卡，因为他们将能够移动它们并在其他玩家抓住它们时跳上它们。`InteractiveArea2D`节点充当触发器，检测玩家的角色与`Crate`节点接触时，并将`Crate`节点分配给玩家的角色`GrabbingRemoteTransform2D`节点，即使他们在移动时也会同步其位置。
- en: 'The `Crate` script is fairly simple and structures how the `Crate` node responds
    and updates to interactions with the `Player` node:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Crate`脚本相当简单，它定义了`Crate`节点如何响应和更新与`Player`节点的交互：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code sets up references to nodes in the `Crate`’s scene hierarchy.
    It also defines two callback functions that handle signals from the `Crate` node’s
    `InteractiveArea2D` node. When an `InteractionArea2D` node enters the `Crate`
    node’s `InteractiveArea2D` node, we presume it is the `Player` node interacting
    and we retrieve the `Player` node’s `"GrabbingRemoteTransform2D"` node, assigning
    it to the `lift_transformer` variable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码设置了`Crate`场景层次结构中节点的引用。它还定义了两个回调函数，用于处理来自`Crate`节点`InteractiveArea2D`节点的信号。当一个`InteractionArea2D`节点进入`Crate`节点的`InteractiveArea2D`节点时，我们假设它是`Player`节点进行交互，并检索`Player`节点的`"GrabbingRemoteTransform2D"`节点，将其分配给`lift_transformer`变量。
- en: When an interaction happens, the code assigns the `lift_transformer.remote_path`
    node to the path from `lift_transformer` variable to the `Crate` node’s body.
    Remember, `lift_transformer` variable is a `RemoteTransform2D` node. This is how
    we allow the `Player` node’s `GrabbingRemoteTransform2D` node to remotely transform
    the `Crate` node’s `CharacterBody2D` Node position.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生交互时，代码将`lift_transformer.remote_path`节点分配给从`lift_transformer`变量到`Crate`节点身体的路径。记住，`lift_transformer`变量是一个`RemoteTransform2D`节点。这就是我们允许`Player`节点的`GrabbingRemoteTransform2D`节点远程变换`Crate`节点的`CharacterBody2D`节点位置的方式。
- en: In the next section, we will understand how `InteractiveArea2D` node detects
    players’ interactions with the *Crate* node and its role in our game.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解`InteractiveArea2D`节点如何检测玩家与*Crate*节点的交互以及它在我们的游戏中的作用。
- en: How the InteractiveArea2D class works
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: InteractiveArea2D类的工作原理
- en: In this section, we’ll understand the role of a major scene that lies at the
    heart of our game’s mechanics. Called `InteractiveArea2D` node, this scene plays
    a fundamental role in detecting and enabling player interactions with various
    objects in the game environment. `InteractiveArea2D` node enables us to turn any
    object into an object the player can interact with. For example, in our prototype,
    we use `InteractiveArea2D` node to allow the player to grab a `Crate` node and
    move it around.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解我们游戏机制核心中的一个主要场景的作用。这个场景被称为`InteractiveArea2D`节点，它在检测和启用玩家与游戏环境中的各种对象交互方面发挥着基本作用。`InteractiveArea2D`节点使我们能够将任何对象转换为玩家可以与之交互的对象。例如，在我们的原型中，我们使用`InteractiveArea2D`节点来允许玩家抓住`Crate`节点并将其移动。
- en: The `InteractiveArea2D` scene, built upon the foundation of the `Area2D` node,
    serves as a fundamental component in our game. Its primary function is to detect
    and ease player interactions with objects, particularly within the player-crate
    interaction mechanic. Through the use of signals and input handling, the `InteractiveArea2D`
    scene ensures smooth gameplay interactions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`Area2D`节点构建的`InteractiveArea2D`场景是我们游戏中的基本组件。其主要功能是检测和简化玩家与对象的交互，尤其是在玩家与箱子交互机制中。通过使用信号和输入处理，`InteractiveArea2D`场景确保了流畅的游戏交互。
- en: '![Figure 8.4 – The InteractiveArea2D’s scene node hierarchy](img/Figure_8.04_B18527.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – InteractiveArea2D场景节点层次结构](img/Figure_8.04_B18527.jpg)'
- en: Figure 8.4 – The InteractiveArea2D’s scene node hierarchy
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – InteractiveArea2D场景节点层次结构
- en: One of the standout features of our game is the player-`Crate` node interaction
    mechanism, offering players the ability to manipulate interactive objects. The
    `InteractiveArea2D` scene serves as the catalyst for this interaction, acting
    as the gateway through which players can engage with the objects that populate
    the game world.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的一个突出特点是玩家与`Crate`节点交互机制，它为玩家提供了操作交互对象的能力。`InteractiveArea2D`场景是这个交互的催化剂，它作为玩家可以与之互动的游戏世界中对象的门户。
- en: Using signals, the `InteractiveArea2D` scene establishes communication channels
    with other game objects and systems. Whenever a player successfully interacts
    with an object, `InteractiveArea2D` node emits the `interacted` signal. On top
    of that, the scene emits signals to indicate the availability or unavailability
    of interactions, allowing us to provide visual and auditory feedback to players.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用信号，`InteractiveArea2D`场景与其他游戏对象和系统建立了通信渠道。每当玩家成功与一个对象交互时，`InteractiveArea2D`节点会发出`interacted`信号。除此之外，场景还会发出信号以指示交互的可用性或不可用性，使我们能够向玩家提供视觉和听觉反馈。
- en: To detect player input, the `InteractiveArea2D` scene uses an `_unhandled_input`
    callback. When players press the designated `interact` input action, it triggers
    the `interacted` signal, signaling that an interaction has occurred. This control
    scheme allows the players to interact with the game world.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测玩家输入，`InteractiveArea2D` 场景使用 `_unhandled_input` 回调。当玩家按下指定的 `interact`
    输入动作时，它触发 `interacted` 信号，表示发生了交互。这种控制方案允许玩家与游戏世界进行交互。
- en: 'Understanding the role of the `InteractiveArea2D` scene and its seamless integration
    with the player-`Crate` node interaction system is key. Now, it’s time to dive
    into the code and unleash the full potential of this vital scene in our game:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `InteractiveArea2D` 场景的作用以及它与玩家-`Crate` 节点交互系统的无缝集成是关键。现在，是时候深入代码，发挥这个关键场景在我们游戏中的全部潜力了：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `InteractiveArea2D` script extends `Area2D` node and provides interaction
    functionality. It emits signals when an interaction occurs, when an interaction
    becomes available, and when an interaction becomes unavailable. It also handles
    unhandled input events to trigger interactions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`InteractiveArea2D` 脚本扩展了 `Area2D` 节点，并提供了交互功能。当发生交互时，当交互变得可用时，以及当交互变得不可用时，它会发出信号。它还处理未处理的输入事件以触发交互。'
- en: In the upcoming section and the final part of the onboarding, we will see how
    we create and insert `Player` instances in the game world dynamically based on
    how many players are playing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节和入门的最后部分，我们将看到如何根据有多少玩家在玩，动态地在游戏世界中创建和插入 `Player` 实例。
- en: Understanding the PlayerSpawner class
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 PlayerSpawner 类
- en: '`PlayerSpawner` scene is another vital component in our game that handles the
    creation and positioning of `Player` instances. The `PlayerSpawner` class, based
    on the `Marker2D` node, follows the `Spawner` pattern, enabling us to dynamically
    generate `Player` instances in the game world.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerSpawner` 场景是我们游戏中另一个关键组件，负责创建和定位 `Player` 实例。基于 `Marker2D` 节点的 `PlayerSpawner`
    类遵循 `Spawner` 模式，使我们能够在游戏世界中动态生成 `Player` 实例。'
- en: '![Figure 8.5 – The PlayerSpawner’s scene node hierarchy](img/Figure_8.05_B18527.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – PlayerSpawner 的场景节点层次结构](img/Figure_8.05_B18527.jpg)'
- en: Figure 8.5 – The PlayerSpawner’s scene node hierarchy
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – PlayerSpawner 的场景节点层次结构
- en: One of the key features of the `PlayerSpawner` class is its ability to position
    the spawned `Player` instances. As a `Marker2D` node, `PlayerSpawner` node provides
    a convenient way to specify the location and orientation of the players within
    the game world. This ensures that each player starts in the appropriate position,
    ready to embark on their adventure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerSpawner` 类的一个关键特性是其能够定位生成的 `Player` 实例。作为一个 `Marker2D` 节点，`PlayerSpawner`
    节点提供了一个方便的方式来指定玩家在游戏世界中的位置和朝向。这确保了每个玩家都能从适当的位置开始，准备好开始他们的冒险。'
- en: 'Let’s see its code to understand what this class does under the hood:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的代码，以了解这个类在底层做了什么：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding script showcases the implementation of a `Spawner` class, based
    on the `Marker2D` node. It checks for connected joypads and creates instances
    of the `Player` scene accordingly. If no joypads are connected, it creates a single
    instance. If there are connected joypads, it creates one `Player` instance per
    joypad and sets up their respective controls. The preceding code snippet allows
    for the dynamic creation of `Player` instances in a multiplayer game, easing our
    work developing a multiplayer experience.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本展示了基于 `Marker2D` 节点的 `Spawner` 类的实现。它检查连接的控制器，并根据连接的控制器创建相应的 `Player` 场景实例。如果没有连接的控制器，它创建一个单独的实例。如果有连接的控制器，它为每个控制器创建一个
    `Player` 实例并设置它们各自的控制。上述代码片段允许在多人游戏中动态创建 `Player` 实例，简化了我们开发多人游戏体验的工作。
- en: We are finally done with our onboarding; in the next section, we’ll start to
    implement our online multiplayer features, turning our local prototype into something
    we can securely work with and polish knowing it’s ready to launch with remote
    multiplayer features.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了我们的入门；在下一节中，我们将开始实现我们的在线多人游戏功能，将我们的本地原型转变为我们可以安全工作并打磨的产品，因为我们知道它已经准备好与远程多人游戏功能一起发布。
- en: Spawning players in the match
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在比赛中生成玩家
- en: In this section, we will understand how to improve the `PlayerSpawner` class
    to introduce online multiplayer features to our game. Leveraging the foundation
    laid by the *Understanding the PlayerSpawner class*, *Unveiling the Crate class*,
    and the *Understanding the Player class* sections, these enhancements enable multiple
    players to connect and interact seamlessly within a synchronized game environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何改进 `PlayerSpawner` 类，以将在线多人功能引入我们的游戏。利用 *理解 PlayerSpawner 类*、*揭示
    Crate 类* 和 *理解 Player 类* 等章节所奠定的基础，这些增强功能使多个玩家能够无缝连接并在同步的游戏环境中交互。
- en: '`PlayerSpawner` node plays a fundamental role in our game’s multiplayer architecture,
    acting as the core mechanism responsible for dynamically creating instances of
    the `Player` class for each connected player. These instances represent the avatars
    through which players engage with the game world.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerSpawner` 节点在我们游戏的多玩家架构中扮演着基本角色，作为负责为每个连接的玩家动态创建 `Player` 类实例的核心机制。这些实例代表玩家通过它们与游戏世界进行交互的化身。'
- en: With the integration of multiplayer functionalities, we will add features designed
    for an online multiplayer experience. This includes mechanisms to handle multiplayer
    authority, enabling proper gameplay across all connected peers. On top of that,
    the code will establish unique player names using the peers’ IDs, allowing us
    to easily identify players on the network. To ensure synchronized actions, we
    will use RPCs, which will allow us to share events and actions among all connected
    players, especially the instantiation of other players.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集成多人功能，我们将添加专为在线多人体验设计的功能。这包括处理多人权限的机制，确保所有连接节点上的游戏玩法正确。在此基础上，代码将使用节点 ID 建立独特的玩家名称，使我们能够轻松识别网络上的玩家。为了确保同步动作，我们将使用
    RPC，这将允许我们在所有连接的玩家之间共享事件和动作，特别是其他玩家的实例化。
- en: One fundamental concept we are going to introduce here is the `MultiplayerSpawner`
    node. In the Godot Engine 4 High-Level Network API, the `MultiplayerSpawner` node
    is an invaluable asset for creating synced scenes in a networked multiplayer setting.
    In our context, it is a core component in synchronizing the creation of players,
    ensuring that every player can see and interact with the avatars of other players
    in real time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要介绍的一个基本概念是 `MultiplayerSpawner` 节点。在 Godot Engine 4 高级网络 API 中，`MultiplayerSpawner`
    节点是在网络化多人设置中创建同步场景的无价资产。在我们的上下文中，它是同步创建玩家核心组件，确保每个玩家都能实时看到并与其他玩家的化身进行交互。
- en: With the `MultiplayerSpawner` node, we can effortlessly instantiate and position
    player avatars across all connected game instances. So to start with, let’s open
    the `PlayerSpawner` scene at `res://08.designing-online-platformer/Levels/PlayerSpawner.tscn`
    and add a `MultiplayerSpawner` node as its child.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MultiplayerSpawner` 节点，我们可以轻松地在所有连接的游戏实例中实例化和定位玩家化身。因此，首先，让我们打开位于 `res://08.designing-online-platformer/Levels/PlayerSpawner.tscn`
    的 `PlayerSpawner` 场景，并将其作为子节点添加一个 `MultiplayerSpawner` 节点。
- en: '![Figure 8.6 – A MultiplayerSpawner node as a child of the PlayerSpawner node](img/Figure_8.06_B18527.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – PlayerSpawner 节点作为 PlayerSpawner 节点的子节点](img/Figure_8.06_B18527.jpg)'
- en: Figure 8.6 – A MultiplayerSpawner node as a child of the PlayerSpawner node
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – PlayerSpawner 节点作为 PlayerSpawner 节点的子节点
- en: After that, we need to configure the `MultiplayerSpawner` node’s `PlayerSpawner`.
    This tells `MultiplayerSpawner` who should be the spawned scenes’ parent. Then,
    the second property should point to the same `PackedScene` Resource our `PlayerSpawner`
    node spawns. This will ensure that, when a new instance is created locally, `MultiplayerSpawner`
    node will replicate it on connected peers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要配置 `MultiplayerSpawner` 节点的 `PlayerSpawner` 属性。这告诉 `MultiplayerSpawner`
    应该将哪个场景作为生成场景的父级。然后，第二个属性应该指向 `PlayerSpawner` 节点生成的相同 `PackedScene` 资源。这将确保，当本地创建新实例时，`MultiplayerSpawner`
    节点将在连接的节点上复制它。
- en: '![Figure 8.7 – The MultiplayerSpawner’s Spawn Path and Auto Spawn List properties
    set up](img/Figure_8.07_B18527.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 配置 MultiplayerSpawner 的生成路径和自动生成列表属性](img/Figure_8.07_B18527.jpg)'
- en: Figure 8.7 – The MultiplayerSpawner’s Spawn Path and Auto Spawn List properties
    set up
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 配置 MultiplayerSpawner 的生成路径和自动生成列表属性
- en: With that, our `MultiplayerSpawner` node is ready to sync new players on everyone’s
    game instances. But we still need to configure these new instances, otherwise,
    only the server will be able to control them. So, let’s see how we can empower
    players with the ability to control their own avatars. Open the `PlayerSpawner`
    script at `res://08.designing-online-platformer/Levels/PlayerSpawner.gd`. In the
    next section, we will make some changes to this script.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的`MultiplayerSpawner`节点就准备好在每个人的游戏实例上同步新玩家了。但我们仍然需要配置这些新实例，否则，只有服务器才能控制它们。所以，让我们看看我们如何赋予玩家控制自己化身的能力。打开`PlayerSpawner`脚本，位于`res://08.designing-online-platformer/Levels/PlayerSpawner.gd`。在下一节中，我们将对此脚本进行一些修改。
- en: Giving players control in PlayerSpawner
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`PlayerSpawner`中赋予玩家控制权
- en: 'The new `PlayerSpawner` code introduces changes that enhance the multiplayer
    functionality of the game. Specifically, this code includes mechanisms to handle
    multiplayer synchronization and sets up `Player` instances correctly when multiple
    peers are connected. The changes involve checking for multiplayer authority, setting
    player names, and using RPCs to set up multiplayer functionality for each connected
    player. Let’s implement these features:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`PlayerSpawner`代码引入了增强游戏多人功能性的更改。具体来说，此代码包括处理多人同步的机制，并在多个Peer连接时正确设置`Player`实例。这些更改包括检查多人权限、设置玩家名称和使用RPC为每个连接的玩家设置多人功能。让我们实现这些功能：
- en: 'Add `await(get_tree().create_timer(0.1).timeout)` at the beginning of the `_ready()`
    callback. This line introduces a delay of 0.1 seconds using a timer, allowing
    time for the multiplayer networking initialization to complete:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_ready()`回调的开始处添加`await(get_tree().create_timer(0.1).timeout)`。这一行使用计时器引入了0.1秒的延迟，为多人网络初始化完成留出了时间：
- en: '[PRE4]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, let’s check whether there are connected peers by checking for the size
    of the `multiplayer.get_peers()` array. With that, we can check whether there
    are any connected peers in the multiplayer session. This condition verifies whether
    this is a local game session:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们检查是否有连接的Peer，通过检查`multiplayer.get_peers()`数组的大小。有了这个，我们可以检查多人会话中是否有连接的Peer。这个条件验证了这是否是一个本地游戏会话：
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If this is the case, we use the original logic we saw in the *Understanding
    the Player class* section to set up the local players’ avatars’ controllers. With
    a small twist, we use the `return` keyword at the end to prevent `_ready()` from
    reaching the next steps, which are only necessary if this is an online game session:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，我们使用在*理解Player类*部分看到的原始逻辑来设置本地玩家化身控制器。稍作修改，我们在最后使用`return`关键字来防止`_ready()`执行到下一步，这些步骤只有在是在线游戏会话时才是必要的：
- en: '[PRE6]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, if this is an online game session, we check whether this game instance
    is the multiplayer authority (in other words, the server), and if so, we enter
    a loop that iterates over the connected peers:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果这是一个在线游戏会话，我们检查这个游戏实例是否是多人权限（换句话说，是服务器），如果是的话，我们进入一个循环，遍历连接的Peer：
- en: '[PRE7]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similar to the local session logic, we create a `Player` instance for each
    connected player:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与本地会话逻辑类似，我们为每个连接的玩家创建一个`Player`实例：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the catch: after creating the `Player` instance, we set its name to
    the player’s peer ID. Only then do we add it as a child of the `PlayerSpawner`
    node. This ensures each `Player` instance has a unique name and will prevent the
    RPCs and `MultiplayerSpawner` node from returning errors:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有个关键点：在创建`Player`实例后，我们将其实例的名称设置为玩家的Peer ID。只有在这个步骤之后，我们才将其添加为`PlayerSpawner`节点的子节点。这确保了每个`Player`实例都有一个唯一的名称，并将防止RPC和`MultiplayerSpawner`节点返回错误：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we add another timer delay of `0.1` seconds. This delay gives time for
    peers’ game instances to synchronize their multiplayer setup:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加另一个`0.1`秒的计时器延迟。这个延迟给Peer的游戏实例同步多人设置留出了时间：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we make an RPC to the `Player.setup_multiplayer()` method passing
    `player_id` as an argument. `Player.setup_multiplayer()` is responsible for configuring
    the player’s *multiplayer authority* based on the player ID, ultimately allowing
    this player, and only this player, to control this instance. We will implement
    this method in the *Setting up the Player multiplayer* *controls* section:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过传递`player_id`作为参数调用RPC到`Player.setup_multiplayer()`方法。`Player.setup_multiplayer()`负责根据玩家ID配置玩家的*多人权限*，最终允许这个玩家，而且只有这个玩家，控制这个实例。我们将在*设置玩家多人控制*部分实现此方法：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We aren’t done yet. We still need to set up the multiplayer features on other
    players’ avatar instances when `MultiplayerSpawner` node creates them. For that,
    let’s connect the `MultiplayerSpawner` node’ `spawned` signal to the `PlayerSpawner`
    node using a method called `_on_multiplayer_spawner_spawned`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。我们还需要在`MultiplayerSpawner`节点创建其他玩家的化身实例时设置多人游戏功能。为此，让我们使用名为`_on_multiplayer_spawner_spawned`的方法将`MultiplayerSpawner`节点的`spawned`信号连接到`PlayerSpawner`节点。
- en: '![Figure 8.8 – The MultiplayerSpawner spawned signal connecting to the PlayerSpawner
    _on_multiplayer_spawner_spawned callback](img/Figure_8.08_B18527.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – MultiplayerSpawner产生的信号连接到PlayerSpawner的_on_multiplayer_spawner_spawned回调](img/Figure_8.08_B18527.jpg)'
- en: Figure 8.8 – The MultiplayerSpawner spawned signal connecting to the PlayerSpawner
    _on_multiplayer_spawner_spawned callback
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – MultiplayerSpawner产生的信号连接到PlayerSpawner的_on_multiplayer_spawner_spawned回调
- en: 'Then, we make an RPC on the spawned node’s `setup_multiplayer` method using
    the node’s name as an argument. Since the name is a `StringName` variable, we
    need to convert it to a string and then to an integer in order for the `Player`
    class to handle it. The complete `PlayerSpawner` script should look like this
    after these changes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用节点名称作为参数在产生的节点的`setup_multiplayer`方法上执行RPC。由于名称是一个`StringName`变量，我们需要将其转换为字符串，然后再将其转换为整数，以便`Player`类可以处理它。在做出这些更改后，完整的`PlayerSpawner`脚本应如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The updated script incorporates multiplayer functionality by creating `Player`
    instances for each player in the network. It checks for the presence of connected
    joypads and multiplayer peers to determine the appropriate number of `Player`
    instances to create. The code also sets up the `Player` instances’ controls and
    synchronizes their multiplayer settings. With these changes, `PlayerSpawner` node
    now enables multiplayer gameplay, allowing multiple players to control their avatars
    and interact within the game world simultaneously with no control conflicts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的脚本通过为网络中的每个玩家创建`Player`实例来集成多人游戏功能。它检查连接的摇杆和多人游戏对等体的存在，以确定需要创建的`Player`实例的数量。代码还设置了`Player`实例的控制并同步它们的多人游戏设置。这些更改使得`PlayerSpawner`节点现在可以启用多人游戏，允许多个玩家同时控制他们的化身并在游戏世界中交互，没有任何控制冲突。
- en: In the upcoming section, we will explore the implementation of the `Player.setup_multiplayer()`
    method, which is responsible for configuring online multiplayer settings in the
    `Player` class. Within the `setup_multiplayer()` method, we set the multiplayer
    authority, disable the physics and input processing based on the local player’s
    authority over the instance, and set a visual player index label updated with
    which player is controlling the instance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨`Player.setup_multiplayer()`方法的实现，该方法负责配置`Player`类的在线多人游戏设置。在`setup_multiplayer()`方法中，我们设置多人游戏权限，根据本地玩家对实例的权限禁用物理和输入处理，并设置一个视觉玩家索引标签，该标签会更新控制实例的玩家。
- en: Setting up the Player multiplayer controls
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置玩家多人游戏控制
- en: In this section, let’s see how to implement the `Player.setup_multiplayer()`
    method, which plays a core role in setting up the online multiplayer controls
    for the `Player` class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何实现`Player.setup_multiplayer()`方法，该方法在设置`Player`类的在线多人游戏控制中起着核心作用。
- en: Within the `setup_multiplayer()` method, we need to take some key steps to achieve
    our online multiplayer controls. Firstly, we need to establish the new multiplayer
    authority, verifying the player’s control and decision-making capabilities within
    the multiplayer environment. Then, we will adjust the physics and input processing
    based on whether the player ID matches the player ID we designated using the node’s
    name. This ensures that each player controls the right `Player` instance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup_multiplayer()`方法中，我们需要采取一些关键步骤来实现我们的在线多人游戏控制。首先，我们需要建立新的多人游戏权限，验证玩家在多人游戏环境中的控制和决策能力。然后，我们将根据玩家ID是否与我们使用节点名称指定的玩家ID匹配来调整物理和输入处理。这确保了每个玩家控制正确的`Player`实例。
- en: On top of that, the method updates a visual player index label, allowing players
    to see their assigned avatar. This visual feedback enhances the multiplayer experience
    by providing a clear indication of each player’s identity and presence in the
    game.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该方法还更新了视觉玩家索引标签，使玩家能够看到分配给他们的化身。这种视觉反馈通过提供每个玩家身份和游戏中的存在感的明确指示，增强了多人游戏体验。
- en: By implementing the `setup_multiplayer()` method, the game achieves synchronized
    multiplayer functionality, creating a cohesive and immersive multiplayer experience.
    Players can interact and collaborate with one another, encouraging a sense of
    shared adventure and enjoyment within the game world.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`setup_multiplayer()`方法，游戏实现了同步多人功能，创造了一个统一且沉浸式的多人体验。玩家可以相互互动和协作，在游戏世界中鼓励共享冒险和享受的感觉。
- en: 'That said, let’s dive into the code and unlock the potential of our multiplayer
    gameplay on our prototype! Open the `Player` script at `res://08.designing-online-platformer/Actors/Player/Player2D.gd`
    and let’s implement the `setup_multiplayer()` method to finally allow players
    to control their avatars:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们深入代码，解锁我们原型中多人游戏功能的潜力！打开位于`res://08.designing-online-platformer/Actors/Player/Player2D.gd`的`Player`脚本，并实现`setup_multiplayer()`方法，最终允许玩家控制他们的化身：
- en: 'In the `Player` script, create a new method called `setup_multiplayer()`. It
    should receive an argument to get the player’s ID; here, we’ll call it `player_id`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player`脚本中，创建一个新的方法名为`setup_multiplayer()`。它应该接收一个参数来获取玩家的ID；在这里，我们将它称为`player_id`：
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, decorate the method with the `@rpc` annotation, using the `"any_peer"`
    and `"call_local"` options. This specifies that the method can be called by any
    peer and executed locally. So, when players spawn their avatars, they tell the
    other peers to set up their avatars, setting up the avatar instance locally as
    well:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`@rpc`注解装饰该方法，使用`"any_peer"`和`"call_local"`选项。这指定了该方法可以被任何同伴调用并在本地执行。因此，当玩家生成他们的化身时，他们会告诉其他同伴设置他们的化身，同时在本地设置化身实例：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the `setup_multiplayer()` method, let’s call `set_multiplayer_authority()`
    passing `player_id` as an argument to set the new multiplayer authority of this
    `Player` instance. Remember, the multiplayer authority determines the peer’s control
    and decision-making capabilities over a given node:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup_multiplayer()`方法内部，让我们调用`set_multiplayer_authority()`，传递`player_id`作为参数来设置这个`Player`实例的新多人权限。记住，多人权限决定了节点上同伴的控制和决策能力：
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, let’s create a variable to store whether `player_id` is equal to the
    `Player` instance name. With that, we check whether the current avatar is supposed
    to be controlled by the local player:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个变量来存储`player_id`是否等于`Player`实例名称。有了这个，我们检查当前化身是否应该由本地玩家控制：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After that, we set the physics and unhandled input processes based on the value
    of the `is_player` variable. With that, we disable the physics processing and
    the input handling on the `Player` instances that don’t belong to the local player:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们根据`is_player`变量的值设置物理和未处理输入处理。有了这个，我们禁用了不属于本地玩家的`Player`实例上的物理处理和输入处理：
- en: '[PRE17]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we update the text of the `label` node to display the player index.
    Here, `%s` is a placeholder that is replaced with the value returned by `get_index()`,
    representing the player’s index in the `PlayerSpawner` children hierarchy (remember
    the first node is `MultiplayerSpawner`) so the player indexing starts at `1`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`label`节点的文本更新为显示玩家索引。在这里，`%s`是一个占位符，它会被`get_index()`返回的值替换，代表玩家在`PlayerSpawner`子节点层次结构中的索引（记住第一个节点是`MultiplayerSpawner`），因此玩家索引从`1`开始：
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With that, we have our `Player` instance ready to behave in an online multiplayer
    environment. The `setup_multiplayer()` method configures the multiplayer features
    in the `Player` instances. It sets the multiplayer authority, adjusts physics
    processing and input handling based on the local player ID, and updates a label
    with the player’s index.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了准备在在线多人环境中表现的`Player`实例。`setup_multiplayer()`方法配置了`Player`实例中的多人功能。它设置多人权限，根据本地玩家ID调整物理处理和输入处理，并更新一个带有玩家索引的标签。
- en: But notice, since we are disabling physics and input processing, technically
    the other players’ avatars will remain static during the whole gameplay session,
    right? Each player will only control and see their own character moving around
    and we don’t want that. We want players to interact with each other and see how
    other players are behaving within this shared experience.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，由于我们正在禁用物理和输入处理，从技术上讲，其他玩家的化身在整个游戏过程中将保持静态，对吧？每个玩家只能控制并看到他们自己的角色移动，我们不想这样。我们希望玩家能够相互互动，并看到其他玩家在这个共享体验中的行为。
- en: 'In the next section, we are going to use `MultiplayerSynchronizer` node to
    keep all other players on the same page regarding each other’s avatar, including
    going beyond just the avatar’s position, but also its animation and more. We will
    also see how we handle the `Crate` node: since players can grab and carry it around,
    who should have control over it? Who should be the `Crate` node’s **Multiplayer
    Authority**?'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用`MultiplayerSynchronizer`节点来确保所有玩家在彼此的角色的各个方面保持一致，包括不仅仅是角色的位置，还包括其动画等。我们还将了解如何处理`Crate`节点：由于玩家可以抓住并携带它，谁应该控制它？`Crate`节点的**多玩家权限**应该由谁拥有？
- en: Syncing physical objects
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步物理对象
- en: In this section, we will understand how to use the `MultiplayerSynchronizer`
    node for more than position updates. This node plays an important role in ensuring
    that players are synchronized with the avatars of other players in the game. As
    we have seen in the *Giving players control in PlayerSpawner* section, it is essential
    to maintain consistency among players to create a seamless multiplayer experience.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用`MultiplayerSynchronizer`节点进行位置更新以外的同步。该节点在确保玩家与游戏中其他玩家的角色保持同步方面发挥着重要作用。正如我们在*在PlayerSpawner中给予玩家控制权*部分所看到的，保持玩家之间的一致性对于创建无缝的多人游戏体验至关重要。
- en: The `MultiplayerSynchronizer` class serves as a bridge between players, enabling
    real-time updates and synchronization of various properties. One key aspect that
    we will explore is how the `Crate` object’s position is updated based on the player
    who is carrying it. This functionality allows for interactive and collaborative
    gameplay, where players can work together to solve puzzles or accomplish tasks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiplayerSynchronizer`类作为玩家之间的桥梁，实现了各种属性的实时更新和同步。我们将探讨的一个关键方面是，如何根据携带`Crate`对象的玩家更新该对象的位置。这一功能允许玩家进行交互式和协作式游戏，玩家可以一起解决谜题或完成任务。'
- en: On top of that, we will see how the `MultiplayerSynchronizer` node handles properties
    related to avatar animations. By leveraging the `MultiplayerSynchronizer` class,
    we can ensure that all players observe the same animation state of other players’
    avatars, enabling a visually consistent experience.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将了解`MultiplayerSynchronizer`节点如何处理与角色动画相关的属性。通过利用`MultiplayerSynchronizer`类，我们可以确保所有玩家观察到其他玩家角色的相同动画状态，从而实现视觉上的一致体验。
- en: Through the usage of the `MultiplayerSynchronizer` node, we can establish a
    robust framework for synchronizing player actions, avatar positions, and animations.
    This synchronization ensures that all players perceive a cohesive and immersive
    multiplayer environment, fostering collaboration and enhancing the overall gameplay
    experience.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`MultiplayerSynchronizer`节点，我们可以建立一个强大的同步框架，用于同步玩家动作、角色位置和动画。这种同步确保了所有玩家感知到一个统一和沉浸式的多人游戏环境，促进协作并提升整体游戏体验。
- en: Let’s explore the implementation details of `MultiplayerSynchronizer`!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`MultiplayerSynchronizer`的实现细节！
- en: Synchronizing the player’s position and animations
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步玩家的位置和动画
- en: 'Our `Player` scene has some nodes responsible for playing animations based
    on the player’s actions and the current state of the avatar, namely the `Sprites`
    and `AnimatedSprite2D` nodes. It is important to synchronize the `Sprites` nodes’
    scale and the `AnimatedSprite` animation and frame since players’ avatars would
    look rather weird if they jump, run, and stay idle and there’s no visual feedback
    updating the performance of such actions in the game world other than the avatar’s
    position changing. So, in this section, let’s ensure that on top of the position,
    other relevant properties are also synced among players. For that, let’s open
    the `Player` scene at `res://08.designing-online-platformer/Actors/Player/Player2D.tscn`
    and, of course, add `MultiplayerSynchronizer` as its child. With that, we will
    perform the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Player`场景中有些节点负责根据玩家的动作和当前角色状态播放动画，即`Sprites`和`AnimatedSprite2D`节点。同步`Sprites`节点的缩放和`AnimatedSprite`动画及帧非常重要，因为如果玩家跳跃、奔跑和保持静止，而游戏世界中没有视觉反馈来更新这些动作的表现，玩家角色看起来会相当奇怪。因此，在本节中，让我们确保除了位置之外，其他相关属性也在玩家之间同步。为此，让我们打开`Player`场景，路径为`res://08.designing-online-platformer/Actors/Player/Player2D.tscn`，当然，将其子节点添加为`MultiplayerSynchronizer`。有了这个，我们将执行以下步骤：
- en: First of all, we need to change the `MultiplayerSynchronizer`’s **Visibility
    Update Mode** to **Physics** so it syncs the physics simulations on remote peers’
    game instances.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将`MultiplayerSynchronizer`的**可见性更新模式**更改为**物理**，以便它在远程玩家的游戏实例上同步物理模拟。
- en: '![Figure 8.9 – The player’s MultiplayerSynchronizer properties](img/Figure_8.09_B18527.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 玩家的MultiplayerSynchronizer属性](img/Figure_8.09_B18527.jpg)'
- en: Figure 8.9 – The player’s MultiplayerSynchronizer properties
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 玩家的MultiplayerSynchronizer属性
- en: After that, in the `PlayerCharacter2D` node’s `AnimatedSprite2D` node’s `Sprite`
    nodes’ `MultiplayerSynchronizer` node also synchronizes the animation-related
    properties, allowing the players to see what their peers’ avatars are doing.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`PlayerCharacter2D`节点的`AnimatedSprite2D`节点的`Sprite`节点的`MultiplayerSynchronizer`节点也同步了动画相关属性，使得玩家可以看到他们的同伴的化身正在做什么。
- en: '![Figure 8.10 – The MultiplayerSynchronizer’s Replication properties](img/Figure_8.10_B18527.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – MultiplayerSynchronizer的复制属性](img/Figure_8.10_B18527.jpg)'
- en: Figure 8.10 – The MultiplayerSynchronizer’s Replication properties
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – MultiplayerSynchronizer的复制属性
- en: And that’s it! With that, our players are ready to interact within a shared
    game world. The `MultiplayerSynchronizer` node is an incredible ally to have in
    our toolbelt when developing online multiplayer games. As we can see in this section,
    those node allows for the synchronization of a range of different properties that
    can help us make our online gameplay experience enjoyable. There’s a small, though
    very important observation to make in this regard. As we’ve seen throughout this
    book, especially in *Part 1*, we can’t pass objects around, and we should avoid
    heavy data transmission through the network. So, keep that in mind when adding
    properties to the `MultiplayerSynchronizer` node’s **Replication** menu. For instance,
    if you try to sync a **Texture** property, you are likely to fail the replication.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！有了这个，我们的玩家就可以在共享的游戏世界中互动了。`MultiplayerSynchronizer`节点是我们工具箱中一个了不起的盟友，在开发在线多人游戏时。正如我们在这个部分所看到的，这些节点允许同步一系列不同的属性，可以帮助我们使在线游戏体验愉快。在这方面有一个小但非常重要的观察要提。正如我们在整本书中看到的，特别是在*第一部分*，我们不能传递对象，我们应该避免通过网络进行大量数据传输。所以，在向`MultiplayerSynchronizer`节点的**复制**菜单添加属性时要记住这一点。例如，如果你尝试同步一个**纹理**属性，你很可能会失败复制。
- en: That said, in the next section, we are going to use `MultiplayerSynchronizer`
    node to sync the `Crate` node’s position property, but there’s a twist. Since
    any player can grab a `Crate` node and move it around, who should be its **Multiplayer
    Authority**? Well, that’s what we are about to see!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在下一节中，我们将使用`MultiplayerSynchronizer`节点来同步`Crate`节点的位置属性，但有一个转折。由于任何玩家都可以抓取一个`Crate`节点并移动它，那么它的**多玩家权限**应该归谁？嗯，这正是我们即将看到的！
- en: Updating the crate’s position remotely
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程更新箱子的位置
- en: At this point, we are fairly familiar with how `MultiplayerSynchronizer` node
    works and the overall concept of a node’s multiplayer authority, right? One of
    the core mechanics in our online multiplayer puzzle platformer game is the ability
    for players to collaborate by taking objects and using them as platforms to progress
    through the levels’ obstacles.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对`MultiplayerSynchronizer`节点的工作方式和节点多玩家权限的整体概念相当熟悉，对吧？我们在线多人解谜平台游戏中的一个核心机制是玩家能够通过拿取物体并将它们用作平台来通过关卡障碍。
- en: 'In this section, we are going to see how we can dynamically change an object’s
    multiplayer authority based on which player is currently interacting with it so
    that only that player can change the object’s properties. Open the `Crate` scene
    at `res://08.designing-online-platformer/Objects/Crate/Crate.tscn`, and add a
    new `MultiplayerSynchronizer` node as its child. Then, follow these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何根据当前与对象交互的是哪个玩家动态地更改对象的多玩家权限，以便只有那个玩家可以更改对象的属性。打开`Crate`场景在`res://08.designing-online-platformer/Objects/Crate/Crate.tscn`，并添加一个新的`MultiplayerSynchronizer`节点作为其子节点。然后，按照以下步骤操作：
- en: Just like in the `Player` scene, we need to change the `MultiplayerSynchronizer`
    node’s **Visibility Update Mode** to **Physics** to maintain the physics simulations
    consistently.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在`Player`场景中一样，我们需要将`MultiplayerSynchronizer`节点的**可见性更新模式**更改为**物理**，以保持物理模拟的一致性。
- en: '![Figure 8.11 – The crate’s MultiplerSynchronizer properties](img/Figure_8.11_B18527.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 箱子的MultiplerSynchronizer属性](img/Figure_8.11_B18527.jpg)'
- en: Figure 8.11 – The crate’s MultiplerSynchronizer properties
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 箱子的MultiplerSynchronizer属性
- en: Then, in the `CharacterBody2D` node’s **Position** property to the syncing.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`CharacterBody2D`节点的**位置**属性中进行同步。
- en: '![Figure 8.12 – The crate’s CharacterBody2D position property in the Replication
    menu](img/Figure_8.12_B18527.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 复制菜单中箱子的CharacterBody2D位置属性](img/Figure_8.12_B18527.jpg)'
- en: Figure 8.12 – The crate’s CharacterBody2D position property in the Replication
    menu
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 复制菜单中箱子的CharacterBody2D位置属性
- en: With that, believe it or not, we already have what we need to sync the crate’s
    position. Currently, the crate does not have any built-in behavior to move on
    its own, as its position is expected to be altered by the players who interact
    with it. To enable this functionality, we will make some additions to the `Crate`
    script. To get started, let’s open the script file at `res://08.designing-online-platformer/Objects/Crate/Crate.gd`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 相信与否，我们已经有同步箱子位置所需的一切了。目前，箱子没有内置的移动行为，因为它的位置预计将被与之交互的玩家更改。为了启用此功能，我们将对`Crate`脚本进行一些修改。要开始，让我们打开位于`res://08.designing-online-platformer/Objects/Crate/Crate.gd`的脚本文件。
- en: 'In the `_on_interactive_area_2d_area_entered()` method, we need to change the
    crate’s multiplayer authority to match the player it’s interacting with. For that,
    we can call the `set_multiplayer_authority()` method passing the area’s multiplayer
    authority. This area that just entered is the player’s `InteractionArea2D` node,
    so its multiplayer authority is the same as that of the player’s:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_on_interactive_area_2d_area_entered()`方法中，我们需要将箱子的多人游戏权限更改为与它交互的玩家匹配。为此，我们可以调用`set_multiplayer_authority()`方法，传入区域的多人游戏权限。刚刚进入的这个区域是玩家的`InteractionArea2D`节点，因此它的多人游戏权限与玩家相同：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With that, whenever the player’s avatar enters the crate’s `InteractiveArea2D`
    node, the player will become the crate’s multiplayer authority and will be able
    to grab it and change its position once they interact with it. With this addition,
    we are ready to witness the seamless synchronization of the crate’s position as
    players interact with it. You can test the prototype to explore the possibilities
    of collaborative gameplay and enjoy the immersive multiplayer experience we have
    just created!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，每当玩家的角色进入箱子的`InteractiveArea2D`节点时，玩家将成为箱子的多人游戏权限，并且一旦与它交互，就能抓住它并改变它的位置。有了这个新增功能，我们就可以见证箱子位置在玩家交互时的无缝同步。您可以测试原型来探索协作游戏的可能性，并享受我们刚刚创建的沉浸式多人游戏体验！
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dived into the world of online multiplayer puzzle platformers,
    which emphasized teamwork and collaboration. Players will be challenged to work
    together, leveraging their skills to overcome obstacles and progress through intricate
    levels. Throughout the chapter, we explored key concepts and techniques to enhance
    the multiplayer experience and create a seamless collaborative gameplay environment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了在线多人解谜平台游戏的世界，这强调了团队合作和协作。玩家将面临挑战，需要共同努力，利用他们的技能克服障碍并穿越复杂的关卡。在整个章节中，我们探讨了增强多人游戏体验和创建无缝协作游戏环境的关键概念和技术。
- en: To enable multiplayer functionality, we introduced the `MultiplayerSpawner`
    class, which dynamically instantiates `Player` instances based on the number of
    connected players. This ensures that each player has a unique avatar in the game,
    promoting a personalized and immersive multiplayer experience. The `Player` class
    played a crucial role, and we implemented the `setup_multiplayer()` method to
    configure its multiplayer settings. This method allowed us to set each instance’s
    multiplayer authority, adjust physics and input processing, and update a visual
    player index label, providing players with a clear identification in the game.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用多人游戏功能，我们引入了`MultiplayerSpawner`类，该类根据连接的玩家数量动态实例化`Player`实例。这确保了每个玩家在游戏中都有一个独特的角色，促进了个性化且沉浸式的多人游戏体验。`Player`类发挥了关键作用，我们实现了`setup_multiplayer()`方法来配置其多人游戏设置。此方法允许我们设置每个实例的多人游戏权限，调整物理和输入处理，并更新一个视觉玩家索引标签，为玩家提供清晰的识别。
- en: To achieve synchronization between players, we harnessed the power of `MultiplayerSynchronizer`
    node. This powerful tool enabled us to synchronize not only the positions of players
    but also their animations. By incorporating `MultiplayerSynchronizer` node, we
    created a visually captivating multiplayer experience where players moved and
    interacted with the game world in perfect harmony. This synchronization brought
    the multiplayer gameplay to life, enhancing immersion and ensuring a cohesive
    and enjoyable shared experience.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现玩家之间的同步，我们利用了`MultiplayerSynchronizer`节点的力量。这个强大的工具使我们能够同步玩家的位置以及他们的动画。通过整合`MultiplayerSynchronizer`节点，我们创造了一个视觉上引人入胜的多玩家体验，玩家在游戏中移动和互动，达到了完美的和谐。这种同步让多玩家游戏玩法栩栩如生，增强了沉浸感，并确保了一个连贯且愉快的共享体验。
- en: An exciting feature we implemented was the ability for players to grab and manipulate
    the `Crate` object. By dynamically changing the crate’s multiplayer authority,
    we ensured that only the player interacting with the crate had control over its
    movements. This added an extra layer of collaboration and puzzle-solving, as players
    can strategically use the crate as a platform to navigate the levels, fostering
    teamwork and coordination.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的一个令人兴奋的功能是玩家能够抓取并操作`Crate`对象。通过动态改变箱子的多玩家权限，我们确保只有与箱子互动的玩家才能控制其移动。这增加了一层额外的协作和解决问题，因为玩家可以战略性地使用箱子作为平台来穿越关卡，促进团队合作和协调。
- en: To sum up, this chapter provided a solid foundation for understanding and implementing
    multiplayer features using the Godot Engine High-level Network API. By combining
    the concepts and techniques explored, we created an online multiplayer puzzle
    platformer prototype, where players can seamlessly collaborate, synchronize their
    actions, and conquer challenges together. This chapter opened doors to endless
    possibilities in future multiplayer game development endeavors, empowering you
    to create engaging and interactive multiplayer experiences.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这一章为使用Godot引擎高级网络API理解和实现多人功能提供了一个坚实的基础。通过结合探索的概念和技术，我们创建了一个在线多人益智平台游戏原型，玩家可以无缝协作，同步他们的行动，并共同克服挑战。这一章为未来多人游戏开发中的无限可能性打开了大门，赋予你创造引人入胜和互动的多玩家体验的能力。
- en: In the next chapter, we’ll leverage all the knowledge we’ve seen so far in *Part
    2* of this book to create a multiplayer online adventure with a persistent section
    system where players can log in and out and maintain their progress. The players
    will also synchronize the server’s world with their game instance world, which
    also means they will be able to see all the other players that are currently playing
    as well and interact with one another. It’s fundamentally a prototype that you
    can expand to a **Massive Multiplayer Online Role Playing Game** (**MMORPG**)
    if you want.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用本书第二部分所看到的所有知识，创建一个具有持久部分系统的多人在线冒险游戏，玩家可以登录和登出并保持他们的进度。玩家还将同步服务器的世界与他们的游戏实例世界，这也意味着他们能够看到当前正在玩的所有其他玩家，并相互互动。这本质上是一个原型，如果你愿意，可以扩展成一个**大型多人在线角色扮演游戏**（**MMORPG**）。
