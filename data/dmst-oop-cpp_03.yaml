- en: '*Chapter 2*: Adding Language Necessities'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：添加语言必需性'
- en: This chapter will introduce necessary non-OO features of C++ that are critical
    building blocks for C++'s object-oriented features. The features presented in
    this chapter represent topics that you will see matter-of-factly used from this
    point onward in the book. C++ is a language shrouded in areas of gray; from this
    chapter forward, you will become versed in not only language features, but in
    language nuances. The goal of this chapter will be to begin enhancing your skills
    from those of an average C++ programmer to one who is capable of operating amongst
    language subtleties successfully while creating maintainable code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍C++的非面向对象特性，这些特性是C++面向对象特性的重要基石。本章介绍的特性代表了从本章开始在本书中将被毫不犹豫地使用的主题。C++是一门笼罩在灰色地带的语言；从本章开始，您将不仅熟悉语言特性，还将熟悉语言的微妙之处。本章的目标将是从一个普通的C++程序员的技能开始，使其能够成功地在创建可维护的代码的同时在语言的微妙之处中操作。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The `const` qualifier
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`限定符'
- en: Function prototyping
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数原型
- en: Function overloading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载
- en: By the end of this chapter, you will understand non-OO features such as the
    `const` qualifier, function prototyping (including using default values), and
    function overloading (including how standard type conversion affects overloaded
    function choices and may create potential ambiguities). Many of these seemingly
    straightforward topics include an assortment of interesting details and nuances.
    These skills will be necessary in order to move forward with the next chapters
    in the book successfully.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将了解非面向对象的特性，如`const`限定符，函数原型（包括使用默认值），函数重载（包括标准类型转换如何影响重载函数选择并可能创建潜在的歧义）。许多这些看似简单的主题包括各种有趣的细节和微妙之处。这些技能将是成功地继续阅读本书后续章节所必需的。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in [*Chapter 2*](B15702_02_Final_NM_ePub.xhtml#_idTextAnchor066),
    *Adding Language Necessities* can be found in the subdirectory `Chapter02` in
    a file named `Chp2-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02)。每个完整的程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名与所在章节号相对应，后跟破折号，再跟随所在章节中的示例编号。例如，[*第2章*](B15702_02_Final_NM_ePub.xhtml#_idTextAnchor066)，*添加语言必需性*中的第一个完整程序可以在名为`Chp2-Ex1.cpp`的文件中的`Chapter02`子目录中找到上述GitHub目录下。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3cTYgnB](https://bit.ly/3cTYgnB).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/3cTYgnB](https://bit.ly/3cTYgnB)。
- en: Using the const qualifier
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用const限定符
- en: In this section, we will add the `const` qualifier to variables, and discuss
    how it can be added to functions in both their input parameters and as return
    values. The `const` qualifier will be used quite liberally as we move forward
    in the C++ language. The use of `const` can enable values to be initialized, yet
    never again modified. Functions can advertise that they will not modify their
    input parameters, or that their return value may only be captured (but not modified)
    by using `const`. The `const` qualifier helps make C++ a more secure language.
    Let's take a look at `const` in action.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向变量添加`const`限定符，并讨论如何将其添加到函数的输入参数和返回值中。随着我们在C++语言中的进一步学习，`const`限定符将被广泛使用。使用`const`可以使值被初始化，但永远不会再次修改。函数可以声明它们不会修改其输入参数，或者它们的返回值只能被捕获（但不能被修改）使用`const`。`const`限定符有助于使C++成为一种更安全的语言。让我们看看`const`的实际应用。
- en: Const variables
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量变量
- en: A `const` qualified variable is a variable that must be initialized, and may
    never be assigned a new value. It is seemingly a paradox to pair the usage of
    `const` and a variable together – `const` implies not to change, yet the concept
    of a variable is to inherently hold different values. Nonetheless, it is useful
    to have a strongly type-checked variable whose one and only value can be determined
    at run time. The keyword `const` is added to the variable declaration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`const`限定的变量是一个必须被初始化的变量，永远不能被赋予新值。将`const`和变量一起使用似乎是一个悖论-`const`意味着不改变，然而变量的概念本质上是持有不同的值。尽管如此，拥有一个在运行时可以确定其唯一值的强类型检查变量是有用的。关键字`const`被添加到变量声明中。
- en: 'Let''s consider a few examples in the following program. We will break this
    program into two segments for a more targeted explanation, however, the full program
    example can be found in its entirety at the following link:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下程序中考虑一些例子。我们将把这个程序分成两个部分，以便更有针对性地解释，但是完整的程序示例可以在以下链接中找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex1.cpp)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous program segment, notice how we declare a variable with the
    `const` qualifier preceding the data type. Here, `const int MAX = 50;` simply
    initializes `MAX` to `50`. `MAX` may not be modified via assignment later in the
    code. Out of convention, simple `const` qualified variables are often capitalized.
    Next, we have the definition for the function `minimum()`; notice the use of the
    ternary conditional operator `?:` in this function body. Next, let''s examine
    the body of the `main()` function as we continue with the remainder of this program:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序段中，请注意我们在数据类型之前使用`const`限定符声明变量。在这里，`const int MAX = 50;`简单地将`MAX`初始化为`50`。`MAX`不能通过赋值在代码中后期修改。按照惯例，简单的`const`限定变量通常大写。接下来，我们有函数`minimum()`的定义；请注意在这个函数体中使用了三元条件运算符`?:`。接下来，让我们继续查看`main()`函数的主体，继续进行本程序的其余部分：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `main()`, let''s consider the sequence of code in which we prompt the user
    to `"Enter two values: "` into variables `x` and `y`, respectively. Here, we call
    the function `minimum(x,y)` and pass as actual parameters our two values `x` and
    `y`, which were just read in using `cin` and the extraction operator `>>`. Notice
    that alongside the `const` variable declaration of `MIN`, we initialize `MIN`
    with the return value of the function call `minimum()`. It is important to note
    that setting `MIN` is bundled as a single declaration and initialization. Had
    this been broken into two lines of code – a variable declaration followed by an
    assignment – the compiler would have flagged an error. `const` variables may only
    be initialized with a value, never assigned a value after declaration.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，让我们考虑代码的顺序，提示用户将“输入两个值：”分别存入变量`x`和`y`中。在这里，我们调用函数`minimum(x,y)`，并将我们刚刚使用`cin`和提取运算符`>>`读取的两个值`x`和`y`作为实际参数传递。请注意，除了`MIN`的`const`变量声明之外，我们还使用函数调用`minimum()`的返回值初始化了`MIN`。重要的是要注意，设置`MIN`被捆绑为单个声明和初始化。如果这被分成两行代码--变量声明后跟一个赋值--编译器将会标记一个错误。`const`变量只能在声明后用一个值初始化，不能在声明后赋值。
- en: 'In the last sequence of code above, notice that we use `MAX` (defined in the
    earlier segment of this full program example) to define a size for the fixed-sized
    array `bigName` in the declaration: `char bigName[MAX];`. We then further use
    `MAX` in `setw(MAX)` to ensure that we do not overflow `bigName` while reading
    keyboard input with `cin` and the extraction operator `>>`. Finally, we initialize
    the variable `const int NAMELEN` with the return value of the function `strlen(bigname)`
    and print this value out using `cout`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的最后一段代码中，请注意我们使用`MAX`（在这个完整程序示例的早期部分定义）来定义固定大小数组`bigName`的大小：`char bigName[MAX];`。然后，我们在`setw(MAX)`中进一步使用`MAX`来确保我们在使用`cin`和提取运算符`>>`读取键盘输入时不会溢出`bigName`。最后，我们使用函数`strlen(bigname)`的返回值初始化变量`const
    int NAMELEN`，并使用`cout`打印出这个值。
- en: 'The output to accompany the above full program example is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上面完整程序示例的输出如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have seen how to `const` qualify variables, let's consider `const`
    qualification with functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何对变量进行`const`限定，让我们考虑对函数进行`const`限定。
- en: Const qualification with functions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的const限定
- en: The keyword `const` can also be used in conjunction with functions. The `const`
    qualifier can be used amongst parameters to indicate that the parameters themselves
    will not be modified. This is a useful feature -- the caller of the function will
    understand that the function will not modify input parameters qualified in this
    manner. However, because non-pointer (and non-reference) variables are passed
    "by value" to functions, as copies of the actual parameters on the stack, `const`
    qualifying these inherent copies of parameters does not serve a purpose. Hence,
    `const` qualifying parameters that are of standard data types are not necessary.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`const`也可以与函数一起使用。`const`限定符可以用于参数中，表示参数本身不会被修改。这是一个有用的特性--函数的调用者将了解到以这种方式限定的输入参数不会被修改。然而，因为非指针（和非引用）变量被作为“按值”传递给函数，作为实际参数在堆栈上的副本，对这些固有参数的`const`限定并没有任何意义。因此，对标准数据类型的参数进行`const`限定是不必要的。
- en: 'The same principle applies to return values from functions. A return value
    from a function can be `const` qualified, however, unless a pointer (or reference)
    is returned, the item passed back on the stack as the return value is a copy.
    For this reason, `const` qualifying return values are more meaningful when the
    return type is a pointer to a constant object (which we will cover in [*Chapter
    3*](B15702_03_Final_NM_ePub.xhtml#_idTextAnchor112), *Indirect Addressing: Pointers*
    and beyond). As one final use of `const`, we can utilize this keyword when we
    move onto OO details for a class to specify that a particular member function
    will not modify any data members of that class. We will look at this scenario
    in [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199), *Exploring Classes
    in Detail*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的原则也适用于函数的返回值。函数的返回值可以被`const`限定，然而，除非返回一个指针（或引用），作为返回值传回堆栈的项目是一个副本。因此，当返回类型是指向常量对象的指针时，`const`限定返回值更有意义（我们将在[*第3章*](B15702_03_Final_NM_ePub.xhtml#_idTextAnchor112)中介绍，*间接寻址：指针*及以后内容）。作为`const`的最后一个用途，我们可以在类的OO细节中使用这个关键字，以指定特定成员函数不会修改该类的任何数据成员。我们将在[*第5章*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199)中探讨这种情况，*详细探讨类*。
- en: 'Now that we understand the use of the `const` qualifier for variables and have
    seen potential uses of `const` in conjunction with functions, let''s move onward
    to the next language feature in this chapter: function prototypes.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了`const`限定符用于变量，并看到了与函数一起使用`const`的潜在用途，让我们继续前进到本章的下一个语言特性：函数原型。
- en: Working with function prototypes
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数原型
- en: In this section, we will examine the mechanics of function prototyping, such
    as necessary placement in files and across multiple files for greater program
    flexibility. We will also add optional names to prototype arguments, as well as
    understanding how and why we may choose to add default values to C++ prototypes.
    Function prototypes ensure C++ code is strongly type-checked.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究函数原型的机制，比如在文件中的必要放置和跨多个文件以实现更大的程序灵活性。我们还将为原型参数添加可选名称，并了解我们为什么可以选择向C++原型添加默认值。函数原型确保了C++代码的强类型检查。
- en: Prior to proceeding to function prototypes, let's take a moment to review some
    necessary programming terms. A **function definition** refers to the body of code
    comprising a function. Whereas a declaration of a function (also known as a **forward
    declaration**) merely introduces a function name with its return type and argument
    types, forward declarations allow the compiler to perform strong type checking
    between the function call and its definition by instead comparing the call with
    the forward declaration. Forward declarations are useful because function definitions
    do not always appear in a file prior to a function call; sometimes, function definitions
    appear in a separate file from their calls.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论函数原型之前，让我们花一点时间回顾一些必要的编程术语。**函数定义**指的是组成函数的代码主体。而函数的声明（也称为**前向声明**）仅仅是引入了函数名及其返回类型和参数类型，前向声明允许编译器通过将调用与前向声明进行比较而执行强类型检查。前向声明很有用，因为函数定义并不总是在函数调用之前出现在一个文件中；有时，函数定义出现在与它们的调用分开的文件中。
- en: Defining function prototypes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数原型
- en: 'A **function prototype** is a forward declaration of a function that describes
    how a function should be correctly invoked. A prototype ensures strong type checking
    between a function call and its definition. A function prototype consists of:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数原型**是对函数的前向声明，描述了函数应该如何被正确调用。原型确保了函数调用和定义之间的强类型检查。函数原型包括：'
- en: The function's return type
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回类型
- en: The function's name
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的名称
- en: The function's type and number of arguments
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的类型和参数数量
- en: 'A function prototype allows a function call to precede the function''s definition
    or allows calls to functions that exist in separate files. Let''s examine a simple
    example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型允许函数调用在函数的定义之前，或者允许调用存在于不同的文件中的函数。让我们来看一个简单的例子：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex2.cpp)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex2.cpp)'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we prototype `int minimum(int, int);` near the beginning of the
    example above. This prototype lets the compiler know that any calls to `minimum()`
    should take two integer arguments and should return an integer value (we'll discuss
    type conversions later in this section).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在上面的例子中在开头原型了`int minimum(int, int);`。这个原型让编译器知道对`minimum()`的任何调用都应该带有两个整数参数，并且应该返回一个整数值（我们将在本节后面讨论类型转换）。
- en: Next, in the `main()` function, we call the function `minimum(x, y)`. At this
    point, the compiler checks that the function call matches the aforementioned prototype
    with respect to the type and number of arguments and the return type. Namely,
    that the two arguments are integers (or could easily be converted to integers)
    and that the return type is an integer (or could easily be converted to an integer).
    The return value will be utilized as a value to print using `cout`. Lastly, the
    function `minimum()` is defined in the file. Should the function definition not
    match the prototype, the compiler will raise an error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`main()`函数中，我们调用函数`minimum(x, y)`。此时，编译器检查函数调用是否与前面提到的原型匹配，包括参数的类型和数量以及返回类型。也就是说，这两个参数是整数（或者可以轻松转换为整数），返回类型是整数（或者可以轻松转换为整数）。返回值将被用作`cout`打印的值。最后，在文件中定义了函数`minimum()`。如果函数定义与原型不匹配，编译器将引发错误。
- en: The existence of the prototype allows the call of a given function to be fully
    type-checked prior to the function's definition being seen by the compiler. The
    example above is of course contrived to demonstrate this point; we could have
    instead switched the order in which `minimum()` and `main()` appear in the file.
    However, imagine that the definition of `minimum()` was contained in a separate
    file (the more typical scenario). In this case, the prototype will appear at the
    top of the file, which will call this function (along with header file inclusions)
    so that the function call can be fully type-checked against the prototype.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的存在允许对给定函数的调用在编译器看到函数定义之前进行完全的类型检查。上面的例子当然是为了演示这一点而捏造的；我们也可以改变`minimum()`和`main()`在文件中出现的顺序。然而，想象一下`minimum()`的定义包含在一个单独的文件中（更典型的情况）。在这种情况下，原型将出现在调用这个函数的文件的顶部（以及头文件的包含），以便函数调用可以完全根据原型进行类型检查。
- en: In the above-mentioned multiple file scenario, the file containing the function
    definition will be separately compiled. It will then be the linker's job to ensure
    that when the two files are linked together, the function definition and prototypes
    match so that the linker can resolve any references to such function calls. Should
    prototypes and definitions not match, the linker will not be able to link the
    two sections of code together into one compiled unit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的多文件情况下，包含函数定义的文件将被单独编译。然后链接器的工作是确保当这两个文件链接在一起时，函数定义和原型匹配，以便链接器可以解析对这样的函数调用的任何引用。如果原型和定义不匹配，链接器将无法将代码的这两部分链接成一个编译单元。
- en: 'Let''s take a look at this example''s output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个例子的输出：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we understand function prototype basics, let's see how we can add optional
    argument names to function prototypes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了函数原型基础知识，让我们看看如何向函数原型添加可选参数名称。
- en: Naming arguments in function prototypes
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数原型中命名参数
- en: Function prototypes may optionally contain names, which may differ from those
    in either the formal or actual parameter lists. Argument names are ignored by
    the compiler, yet can often enhance readability. Let's revisit our previous example,
    adding optional argument names in the function prototype.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型可以选择包含名称，这些名称可能与形式参数或实际参数列表中的名称不同。参数名称会被编译器忽略，但通常可以增强可读性。让我们重新看一下我们之前的示例，在函数原型中添加可选参数名称。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex3.cpp)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex3.cpp)'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example is nearly identical to the one preceding it. However, notice that
    the function prototype contains named arguments `arg1` and `arg2`. These identifiers
    are immediately ignored by the compiler. As such, these named arguments do not
    need to match either the formal or actual parameters of the function and are optionally
    present merely to enhance readability.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例几乎与前面的示例相同。但是，请注意函数原型包含了命名参数`arg1`和`arg2`。这些标识符会被编译器立即忽略。因此，这些命名参数不需要与函数的形式参数或实际参数匹配，仅仅是为了增强可读性而可选地存在。
- en: 'The output to accompany this example is the same as the previous example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例相同，此示例的输出如下：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let''s move forward with our discussion by adding a useful feature to
    function prototypes: default values.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过向函数原型添加一个有用的功能来继续我们的讨论：默认值。
- en: Adding default values to function prototypes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向函数原型添加默认值
- en: '**Default values** may be specified in function prototypes. These values will
    be used in the absence of actual parameters in the function call and will serve
    as the actual parameters themselves. Default values adhere to the following criteria:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认值**可以在函数原型中指定。这些值将在函数调用中没有实际参数时使用，并将作为实际参数本身。默认值必须符合以下标准：'
- en: Default values must be specified from right to left in the function prototype,
    without omitting any values.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须从右到左在函数原型中指定默认值，不能省略任何值。
- en: Actual parameters are substituted from left to right in the function call; hence
    the right to left order for default value specification in the prototype is significant.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际参数在函数调用中从左到右进行替换；因此，在原型中从右到左指定默认值的顺序是重要的。
- en: A function prototype may have all, some, or none of its values filled with default
    values, as long as the default values adhere to the above specifications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型可以有全部、部分或没有默认值填充，只要默认值符合上述规定。
- en: 'Let''s see an example using default values:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用默认值的示例：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex4.cpp)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex4.cpp)'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example, notice that a default value is added to the right-most argument
    in the function prototype for `int minimum(int arg1, int arg2 = 100000);`. This
    means that when `minimum` is called from `main()`, it may be called with either
    one argument: `minimum(x)` or with two arguments: `minimum(x, y)`. When `minimum()`
    is called with a single argument, the single argument is bound to the left-most
    argument in the formal parameters of the function and the default value is bound
    to the next sequential argument in the formal parameter list. However, when `minimum()`
    is called with two arguments, both of the actual parameters are bound to the formal
    parameters in the function; the default value is not used.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，请注意在函数原型`int minimum(int arg1, int arg2 = 100000);`中向最右边的参数添加了一个默认值。这意味着当从`main()`中调用`minimum`时，可以使用一个参数调用：`minimum(x)`，也可以使用两个参数调用：`minimum(x,
    y)`。当使用一个参数调用`minimum()`时，单个参数绑定到函数的形式参数中的最左边参数，而默认值绑定到形式参数列表中的下一个顺序参数。但是，当使用两个参数调用`minimum()`时，实际参数都绑定到函数中的形式参数；默认值不会被使用。
- en: 'Here is the output for this example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出如下：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have a handle on default values within a function prototype, let's
    expand on this idea by using different default values with prototypes in various
    program scopes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了函数原型中的默认值，让我们通过在各种程序作用域中使用不同的默认值来扩展这个想法。
- en: Prototyping with different default values in different scopes
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同作用域中使用不同默认值进行原型化
- en: Functions may be prototyped in different scopes with different default values.
    This allows functions to be built generically and customized through prototypes
    within multiple applications or for use in multiple sections of code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以在不同的作用域中使用不同的默认值进行原型化。这允许函数在多个应用程序中以通用方式构建，并通过原型在多个代码部分中进行定制。
- en: Here is an example illustrating multiple prototypes for the same function (in
    different scopes) using different default values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示了相同函数的多个原型（在不同的作用域中）使用不同的默认值。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex5.cpp)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex5.cpp)'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, notice that `int minimum(int, int);` is prototyped near the
    top of the file. Then notice that `minimum()` is re-prototyped in the more local
    scope of `function1()` as `int minimum(int arg1, int arg2 = 500);`, specifying
    a default value of `500` for its right-most argument. Likewise, in the scope of
    `function2()`, function `minimum()` is re-prototyped as: `int minimum(int arg1,
    int arg2 = 90);`, specifying a default value of `90` in the right-most argument.
    When `minimum()` is called from within `function1()` or `function2()`, the local
    prototypes in each of these function scopes, respectively, will be used – each
    with their own default values.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，请注意在文件顶部附近原型化了`int minimum(int, int);`，然后注意在`function1()`的更局部范围内重新定义了`minimum()`，作为`int
    minimum(int arg1, int arg2 = 500);`，为其最右边的参数指定了默认值`500`。同样，在`function2()`的范围内，函数`minimum()`被重新定义为：`int
    minimum(int arg1, int arg2 = 90);`，为其最右边的参数指定了默认值`90`。当在`function1()`或`function2()`中调用`minimum()`时，将分别使用每个函数范围内的本地原型-每个都有自己的默认值。
- en: In this fashion, specific areas of a program may be easily customized with default
    values that may be meaningful within a specific portion of an application. However,
    be sure to *only* employ re-prototyping a function with individualized default
    values within the scope of a calling function to ensure that this customization
    can be easily contained within the safety of a very limited scope. Never re-prototype
    a function in a global scope with differing default values – this could lead to
    unexpected and error-prone results.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，程序的特定部分可以很容易地使用默认值进行定制，这些默认值在应用程序的特定部分可能是有意义的。但是，请确保*仅*在调用函数的范围内使用重新定义函数的个性化默认值，以确保这种定制可以轻松地包含在非常有限的范围内。永远不要在全局范围内重新定义具有不同默认值的函数原型-这可能会导致意外和容易出错的结果。
- en: 'The output for the example is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的输出如下：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Having now explored function prototypes with respect to default usage in single
    and multiple files, using default values in prototypes, and re-prototyping functions
    in different scopes with individual default values, we are now able to move forward
    with the last major topic in this chapter: function overloading.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个和多个文件中探索了函数原型的默认用法，使用原型中的默认值，并在不同范围内重新定义函数以及使用个别默认值后，我们现在可以继续进行本章的最后一个主要主题：函数重载。
- en: Understanding function overloading
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数重载
- en: C++ allows two or more functions that share a similar purpose, yet differ in
    the types or number of arguments they take, to co-exist with the same function
    name. This is known as **function overloading**. This allows more generic function
    calls to be made, leaving the compiler to choose the correct version of the function
    based on the type of the variable (object) using the function. In this section,
    we will add default values to the basics of function overloading to provide flexibility
    and customization. We will also learn how standard type conversions may impact
    function overloading, and potential ambiguities that may arise (as well as how
    to resolve those types of uncertainties).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许两个或更多个函数共享相似的目的，但在它们所接受的参数类型或数量上有所不同，以相同的函数名称共存。这被称为**函数重载**。这允许进行更通用的函数调用，让编译器根据使用函数的变量（对象）的类型选择正确的函数版本。在本节中，我们将在函数重载的基础上添加默认值，以提供灵活性和定制。我们还将学习标准类型转换如何影响函数重载，以及可能出现的歧义（以及如何解决这些类型的不确定性）。
- en: Learning the basics of function overloading
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习函数重载的基础知识
- en: 'When two or more functions with the same name exist, the differentiating factor
    between these similar functions will be their signature. By varying a function''s
    signature, two or more functions with otherwise identical names may exist in the
    same namespace. Function overloading depends on the signature of a function as
    follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在两个或更多个同名函数时，这些相似函数之间的区别因素将是它们的签名。通过改变函数的签名，两个或更多个在同一命名空间中具有相同名称的函数可以存在。函数重载取决于函数的签名，如下所示：
- en: The **signature of a function** refers to a function's name, plus its type and
    number of arguments.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数的签名**指的是函数的名称，以及其参数的类型和数量。'
- en: A function's return type is not included as part of its signature.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回类型不包括在其签名中。
- en: Two or more functions with the same purpose may share the same name, provided
    that their signatures differ.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个或更多个具有相同目的的函数可以共享相同的名称，只要它们的签名不同。
- en: A function's signature helps provide an internal, "mangled" name for each function.
    This encoding scheme guarantees that each function is uniquely represented internally
    to the compiler.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名有助于为每个函数提供一个内部的“混淆”名称。这种编码方案保证每个函数在编译器内部都有唯一的表示。
- en: 'Let''s take a few minutes to understand a slightly larger example that will
    incorporate function overloading. To simplify the explanation, this example is
    broken into three segments; nonetheless, the full program can be found in its
    entirety at the following link:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟来理解一个稍微复杂的示例，其中将包含函数重载。为了简化解释，这个示例被分成了三个部分；然而，完整的程序可以在以下链接中找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex6.cpp)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex6.cpp)'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the beginning of this example, notice that we include the math library with
    `#include <cmath>`, to provide access to basic math functions, such as `pow()`.
    Next, notice the class definitions for `Circle` and `Rectangle`, each with relevant
    data members (`radius` and `area` for `Circle`; `length`, `width`, and `area`
    for `Rectangle`). Once these types have been defined, prototypes for two overloaded
    display functions are shown. Since the prototypes for the two display functions
    utilize user-defined types `Circle` and `Rectangle`, it is important that `Circle`
    and `Rectangle` have both previously been defined. Now, let''s examine the body
    of the `main()` function as we continue with the next segment of this program:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子的开头，注意我们用 `#include <cmath>` 包含了 math 库，以便访问基本的数学函数，比如 `pow()`。接下来，注意 `Circle`
    和 `Rectangle` 的类定义，每个类都有相关的数据成员（`Circle` 的 `radius` 和 `area`；`Rectangle` 的 `length`、`width`
    和 `area`）。一旦这些类型被定义，就会显示两个重载的显示函数的原型。由于这两个显示函数的原型使用了用户定义的类型 `Circle` 和 `Rectangle`，所以很重要的是
    `Circle` 和 `Rectangle` 必须先被定义。现在，让我们继续查看 `main()` 函数的主体部分：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, in the `main()` function, we declare a variable of type `Circle` and two
    variables of type `Rectangle`. We then proceed to load the data members for each
    of these variables in `main()` using the dot operator `.` with appropriate values.
    Next in `main()`, there are three calls to `display()`. The first function call,
    `display(myCircle)`, will call the version of `display()` that takes a `Circle`
    as a formal parameter because the actual parameter passed to this function is
    in fact of the user-defined type `Circle`. The next two function calls, `display(myRect)`
    and `display(mySquare)`, will call the overloaded version of `display()`, which
    takes `Rectangle` as a formal parameter because the actual parameters passed in
    each of these two calls are Rectangles themselves. Let''s complete this program
    by examining both function definitions for `display()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `main()` 函数中，我们声明了一个 `Circle` 类型的变量和两个 `Rectangle` 类型的变量。然后我们使用适当的值在 `main()`
    中使用点运算符 `.` 加载了每个变量的数据成员。接下来，在 `main()` 中，有三次对 `display()` 的调用。第一个函数调用 `display(myCircle)`，将调用以
    `Circle` 作为形式参数的 `display()` 版本，因为传递给这个函数的实际参数实际上是用户定义的类型 `Circle`。接下来的两个函数调用
    `display(myRect)` 和 `display(mySquare)`，将调用重载版本的 `display()`，因为这两个调用中传递的实际参数本身就是
    `Rectangle`。让我们通过查看 `display()` 的两个函数定义来完成这个程序：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice in the final segment of this example, both versions of `display()` are
    defined. One of the functions takes `Circle` as the formal parameter, and the
    overloaded version takes `Rectangle` as its formal parameter. Each function body
    accesses data members specific to each of its formal parameter types, yet the
    overall functionality of each function is similar in that in each case a specific
    shape (`Circle` or `Rectangle`) is displayed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在这个示例的最后部分，定义了 `display()` 的两个版本。其中一个函数以 `Circle` 作为形式参数，重载版本以 `Rectangle`
    作为形式参数。每个函数体访问特定于其形式参数类型的数据成员，但每个函数的整体功能都是相似的，因为在每种情况下都显示了一个特定的形状（`Circle` 或 `Rectangle`）。
- en: 'Let''s take a look at the output for this full program example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个完整程序示例的输出：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, let's add to our discussion of function overloading by understanding how
    standard type conversion allows for one function to be used by multiple data types.
    This can allow function overloading to be used more selectively.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过理解标准类型转换如何允许一个函数被多个数据类型使用，来扩展我们对函数重载的讨论。这可以让函数重载更有选择性地使用。
- en: Eliminating excess overloading with standard type conversion
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过标准类型转换消除过多的重载
- en: Basic language types can be converted from one type to another automatically
    by the compiler. This allows the language to supply a smaller set of operators
    to manipulate standard types than would otherwise be necessary. Standard type
    conversion can also eliminate the need for function overloading when preserving
    the exact data type of the function parameters is not crucial. Promotion and demotion
    between standard types are often handled transparently, without explicit casting,
    in expressions including assignments and operations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以自动将基本语言类型从一种类型转换为另一种类型。这使得语言可以提供一个更小的操作符集来操作标准类型，而不需要更多的操作符。标准类型转换也可以消除函数重载的需要，当保留函数参数的确切数据类型不是至关重要的时候。标准类型之间的提升和降级通常是透明处理的，在包括赋值和操作的表达式中，不需要显式转换。
- en: Here is an example illustrating simple standard type conversions. This example
    does not include function overloading.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，说明了简单的标准类型转换。这个例子不包括函数重载。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex7.cpp)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex7.cpp)'
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, the `maximum()` function takes two double-precision floating-point
    numbers as parameters, and the function returns the result as an `int`. First,
    notice that `int maximum(double, double);` is prototyped near the top of the program
    and is defined at the bottom of this same file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`maximum()` 函数以两个双精度浮点数作为参数，并将结果作为 `int` 返回。首先，注意在程序的顶部附近原型化了 `int maximum(double,
    double);`，并且在同一个文件的底部定义了它。
- en: 'Now, in the `main()` function, notice that we have three int variables defined:
    `result`, `a`, and `x`. The latter two are initialized with values of `6` and
    `10`, respectively. We also have two floats defined and initialized: `float x
    = 5.7, y = 9.89;`. In the first call to function `maximum()`, we use `x` and `y`
    as actual parameters. These two floating-point numbers are promoted to double-precision
    floating-point numbers and the function is called as expected.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main（）`函数中，请注意我们定义了三个int变量：`result`，`a`和`x`。后两者分别初始化为`6`和`10`的值。我们还定义并初始化了两个浮点数：`float
    x = 5.7, y = 9.89;`。在第一次调用`maximum（）`函数时，我们使用`x`和`y`作为实际参数。这两个浮点数被提升为双精度浮点数，并且函数被按预期调用。
- en: This is an example of standard type conversion. Let's notice that the return
    value of `int maximum(double, double)` is an integer – not a double. This means
    that the value returned from this function (either formal parameter `a` or `b`)
    will be a copy of `a` or `b` first truncated to an integer before being used as
    a return value. This return value is neatly assigned to `result`, which has been
    declared an `int` in `main()`. These are all examples of standard type conversion.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标准类型转换的一个例子。让我们注意`int maximum(double, double)`的返回值是一个整数 - 而不是双精度。这意味着从这个函数返回的值（形式参数`a`或`b`）将首先被截断为整数，然后作为返回值使用。这个返回值被整洁地赋给了`result`，它在`main（）`中被声明为`int`。这些都是标准类型转换的例子。
- en: Next, `maximum()` is called with actual parameters `m` and `n`. Similar to the
    previous function call, the integers `m` and `n` are promoted to doubles and the
    function is called as expected. The return value will also be truncated back to
    an `int`, and this value will be passed to `cout` for printing as an integer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`maximum（）`被调用，实际参数为`m`和`n`。与前一个函数调用类似，整数`m`和`n`被提升为双精度，并且函数被按预期调用。返回值也将被截断为`int`，并且该值将作为整数传递给`cout`进行打印。
- en: 'The output for this example is:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出是：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we understand how function overloading and standard type conversions
    work, let's examine a situation where the two combined could create an ambiguous
    function call.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了函数重载和标准类型转换的工作原理，让我们来看一个情况，其中两者结合可能会产生一个模棱两可的函数调用。
- en: Ambiguities arising from function overloading and type conversion
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数重载和类型转换引起的歧义
- en: When a function is invoked and the formal and actual parameters match exactly
    in type, no ambiguities arise with respect to which of a selection of overloaded
    functions should be called – the function with the exact match is the obvious
    choice. However, when a function is called and the formal and actual parameters
    differ in type, standard type conversion may be performed on the actual parameters,
    as necessary. There are situations, however, when the formal and actual parameter
    types do not match, and overloaded functions exist. In these cases, it may be
    difficult for the compiler to select which function should be selected as the
    best match. In these cases, a compiler error is generated indicating that the
    available choices paired with the function call itself are ambiguous. Explicit
    type casting or re-prototyping the desired choice in a more local scope can help
    correct these otherwise ambiguous situations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，形式和实际参数在类型上完全匹配时，不会出现关于应该调用哪个重载函数的歧义 - 具有完全匹配的函数是显而易见的选择。然而，当调用函数时，形式和实际参数在类型上不同时，可能需要对实际参数进行标准类型转换。然而，在形式和实际参数类型不匹配且存在重载函数的情况下，编译器可能难以选择哪个函数应该被选为最佳匹配。在这些情况下，编译器会生成一个错误，指示可用的选择与函数调用本身是模棱两可的。显式类型转换或在更局部的范围内重新原型化所需的选择可以帮助纠正这些否则模棱两可的情况。
- en: Let's review a simple function illustrating the function overloading, standard
    type conversion, and potential ambiguity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个简单的函数，说明函数重载、标准类型转换和潜在的歧义。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex8.cpp)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex8.cpp)'
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this preceding simple example, two versions of `maximum()` are both prototyped
    and defined. These functions are overloaded; notice that their names are the same,
    but they differ in the types of arguments that they utilize. Also note that their
    return types differ; however, since return type is not part of a function's signature,
    the return types need not match.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的简单示例中，`maximum（）`的两个版本都被原型化和定义。这些函数被重载；请注意它们的名称相同，但它们在使用的参数类型上不同。还要注意它们的返回类型不同；但是，由于返回类型不是函数签名的一部分，因此返回类型不需要匹配。
- en: 'Next, in `main()`, two variables each of type `char`, `int`, and `float` are
    declared and initialized. Next, `maximum(a, b)` is called and the two `char` actual
    parameters are converted to integers (using their ASCII equivalents) to match
    the `maximum(int, int)` version of this function. This is the match closest to
    the `char` argument types of `a` and `b`: `maximum(int, int)` versus `maximum(float,
    float)`. Then, `maximum(x, y)` is called with two floats and this call will exactly
    match the `maximum(float, float)` version of this function. Similarly, `maximum(m,
    n)` will be called and will perfectly match the `maximum(int, int)` version of
    this function.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`main（）`中，声明并初始化了两个`char`，`int`和`float`类型的变量。接下来，调用`maximum（a，b）`，两个`char`实际参数被转换为整数（使用它们的ASCII等价物）以匹配该函数的`maximum(int,
    int)`版本。这是与`a`和`b`的`char`参数类型最接近的匹配：`maximum(int, int)`与`maximum(float, float)`。然后，使用两个浮点数调用`maximum（x，y）`，这个调用将完全匹配该函数的`maximum(float,
    float)`版本。类似地，`maximum（m，n）`将被调用，并且将完全匹配该函数的`maximum(int, int)`版本。
- en: 'Now, notice the next function call (which, not coincidentally, is commented
    out): `maximum(a, y)`. Here, the first actual parameter perfectly matches the
    first argument in `maximum(int, int)`, yet the second actual parameter perfectly
    matches the second argument in `maximum(float, float)`. And for the non-matching
    parameter, a type conversion *could* be applied – but it is not! Instead, this
    function call is flagged by the compiler as an ambiguous function call since either
    of the overloaded functions could be an appropriate match.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注意下一个函数调用（不巧的是，它被注释掉了）：`maximum(a, y)`。在这里，第一个实际参数完全匹配 `maximum(int, int)`
    中的第一个参数，但第二个实际参数完全匹配 `maximum(float, float)` 中的第二个参数。对于不匹配的参数，可以应用类型转换——但没有！相反，编译器将此函数调用标记为模棱两可的函数调用，因为任何一个重载函数都可能是一个合适的匹配。
- en: On the line of code `maximum((float) a, y)`, notice that the function call to
    `maximum((float) a, y)` forces an explicit typecast to the first actual parameter
    `a`, resolving any potential ambiguity of which overloaded function to call. With
    parameter `a` now cast to be a `float`, this function call easily matches `maximum(float,
    float)`, and is no longer considered ambiguous. Type casting can be a tool to
    disambiguate crazy situations such as these.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行 `maximum((float) a, y)` 上，注意到对 `maximum((float) a, y)` 的函数调用强制对第一个实际参数
    `a` 进行显式类型转换，解决了调用哪个重载函数的潜在歧义。现在，参数 `a` 被转换为 `float`，这个函数调用很容易匹配 `maximum(float,
    float)`，不再被视为模棱两可。类型转换可以是一个工具，用来消除这类疯狂情况的歧义。
- en: 'Here is the output to accompany our example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与我们示例配套的输出：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned additional non-OO C++ features that are essential
    building blocks needed to base C++'s object-oriented features. These language
    necessities include using the `const` qualifier, understanding function prototypes,
    using default values in prototypes, function overloading, how standard type conversion
    affects overloaded function choices, and how possible ambiguities may arise (and
    be resolved).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了额外的非面向对象的 C++ 特性，这些特性是构建 C++ 面向对象特性所必需的基本组成部分。这些语言必需品包括使用 `const`
    限定符，理解函数原型，使用原型中的默认值，函数重载，标准类型转换如何影响重载函数的选择，以及可能出现的歧义如何解决。
- en: Very importantly, you are now ready to move forward to the next chapter, in
    which we will explore indirect addressing using pointers in reasonable detail.
    The matter-of-fact skills that you have accumulated in this chapter will help
    you more easily navigate each progressively more detailed chapter to ensure you
    are ready to easily tackle the OO concepts starting in [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199),
    *Exploring Classes in Detail*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，您现在已经准备好进入下一章，我们将在其中详细探讨使用指针进行间接寻址。您在本章积累的事实技能将帮助您更轻松地导航每一个逐渐更详细的章节，以确保您准备好轻松应对从[*第
    5 章*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199) 开始的面向对象概念，*详细探索类*。
- en: Remember, C++ is a language filled with more gray areas than most other languages.
    The subtle nuances you are accumulating with your skillset will enhance your value
    as a C++ developer – one who can not only navigate and understand existing nuanced
    code but can create easily maintainable code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，C++ 是一种充满了比大多数其他语言更多灰色地带的语言。您积累的微妙细微之处将增强您作为 C++ 开发人员的价值——一个不仅可以导航和理解现有微妙代码的人，还可以创建易于维护的代码。
- en: Questions
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the signature of a function and how is a function's signature related
    to name mangling in C++? How do you think this facilitates how overloaded functions
    are handled internally by the compiler?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的签名是什么，函数的签名如何与 C++ 中的名称修饰相关联？您认为这如何促进编译器内部处理重载函数？
- en: Write a small C++ program to prompt a user to enter information regarding a
    `Student`, and print out the data.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个小的 C++ 程序，提示用户输入有关 `学生` 的信息，并打印出数据。
- en: a. `Student` information should minimally include first name, last name, GPA,
    and the current course in which the `Student` is registered. This information
    may be stored in a simple class. You may utilize arrays to represent the string
    fields since we have not yet covered pointers. Also, you may read in this information
    in the main function rather than creating a separate function to read in the data
    (since the latter will require knowledge of pointers or references). Please do
    not use global (that is, extern variables).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: a. `学生` 信息应至少包括名字、姓氏、GPA 和 `学生` 注册的当前课程。这些信息可以存储在一个简单的类中。您可以利用数组来表示字符串字段，因为我们还没有涉及指针。此外，您可以在主函数中读取这些信息，而不是创建一个单独的函数来读取数据（因为后者需要指针或引用的知识）。请不要使用全局（即
    extern 变量）。
- en: 'b. Create a function to print out all the data for the `Student`. Remember
    to prototype this function. Use a default value of 4.0 for GPA in the prototype
    of this function. Call this function two ways: once passing in each argument explicitly,
    and once using the default gpa.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: b. 创建一个函数来打印 `学生` 的所有数据。记得对这个函数进行原型声明。在这个函数的原型中，使用默认值 4.0 作为 GPA。以两种方式调用这个函数：一次显式传入每个参数，一次使用默认的
    GPA。
- en: c. Now, overload the `Print` function with one that either prints out selected
    data (that is, last name and GPA) or with a version of this function that takes
    a `Student` as an argument (but not a pointer or reference to a `Student` – we'll
    do that later). Remember to prototype this function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: c. 现在，重载 `Print` 函数，其中一个打印出选定的数据（即姓氏和 GPA），或者使用接受 `Student` 作为参数的版本的函数（但不是 `Student`
    的指针或引用——我们稍后会做）。记得对这个函数进行原型声明。
- en: d. Use iostreams for I/O.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: d. 使用 iostream 进行 I/O。
