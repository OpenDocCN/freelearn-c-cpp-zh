- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Practical Patterns – Building a Temperature Publisher
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用模式 - 构建温度发布者
- en: Design patterns are tools for solving common problems. So far, we have covered
    a few design patterns in this book, such as the Command and Adapter patterns.
    In this chapter, we will go over the **Observer pattern** and apply it to a common
    problem in embedded systems – handling temperature readings in different parts
    of the system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是解决常见问题的工具。到目前为止，我们在本书中已经介绍了一些设计模式，例如命令模式和适配器模式。在本章中，我们将介绍**观察者模式**并将其应用于嵌入式系统中的常见问题——处理系统不同部分的温度读数。
- en: We will start by looking at the Observer pattern and how it can be implemented
    at runtime. This pattern is particularly useful when multiple components need
    to react to changes in data from a central source. Imagine a temperature sensor
    in an embedded device that reports changes to multiple listeners. This could be
    part of a smart thermostat, an industrial machine monitor, or an HVAC control
    board – each with components such as a screen, a logger, or a fan controller that
    react to temperature updates.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨观察者模式及其在运行时的实现方式。当多个组件需要响应来自中央数据源的变化时，此模式特别有用。想象一下，在嵌入式设备中的一个温度传感器会向多个监听器报告变化。这可能是智能恒温器、工业机器监控器或HVAC控制板的一部分——每个部分都有屏幕、记录器或风扇控制器等组件，它们会对温度更新做出反应。
- en: Next, we will transition to a compile-time implementation of the same pattern
    using modern C++ techniques such as variadic templates and fold expressions. By
    leveraging these techniques, we can generate highly optimized code at compile
    time, avoiding virtual dispatch, associated with runtime polymorphism. This approach
    results in a smaller memory footprint and faster code that’s better suited to
    systems with limited resources.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用现代C++技术，如变长模板和折叠表达式，将相同的模式转换为编译时实现。通过利用这些技术，我们可以在编译时生成高度优化的代码，避免与运行时多态相关的虚拟调度。这种方法导致内存占用更小，代码运行更快，更适合资源有限的系统。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The Observer pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Runtime implementation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时实现
- en: Compile-time implementation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时实现
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Add an execution pane with GCC as your compiler for x86 architecture. This will
    allow you to see standard output and better observe the code’s behavior. As we
    are using a lot of modern C++ features, make sure to select C++23 standard, by
    adding `-std=c++23` in the **compiler options** box, and set the optimization
    level to `-O3`. Also, add a compiler pane using `ARM gcc 11.2.1 (none)` to inspect
    the assembly output of the examples.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议您在阅读示例时使用Compiler Explorer ([https://godbolt.org/](https://godbolt.org/))。添加一个执行面板，使用GCC作为x86架构的编译器。这将允许您查看标准输出并更好地观察代码的行为。由于我们使用了大量的现代C++特性，请确保选择C++23标准，通过在**编译器选项**框中添加`-std=c++23`，并将优化级别设置为`-O3`。此外，添加一个使用`ARM
    gcc 11.2.1 (none)`的编译器面板，以检查示例的汇编输出。
- en: You can try the examples from this chapter in the Renode simulator in the Docker
    container you set up in [*Chapter 4*](Chapter_04.xhtml). Make sure that the Docker
    container is running.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[*第4章*](Chapter_04.xhtml)中设置的Docker容器中的Renode模拟器中尝试本章的示例。请确保Docker容器正在运行。
- en: You can find the files for this chapter on GitHub at [https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter15/observer](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter15/observer).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的文件，地址为[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter15/observer](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter15/observer)。
- en: The Observer pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The **Observer pattern** is often used in event-driven systems to publish events
    to subscribed objects, usually by calling a method on them. An object that publishes
    events is called a **subject** or **publisher**. Objects that receive events from
    a publisher are called **observers** or **subscribers**. From now on, we will
    use the terms **publisher** and **subscriber**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者模式**常用于事件驱动系统，用于向已订阅的对象发布事件，通常通过调用它们的方法来实现。发布事件的对象称为**主题**或**发布者**。从发布者接收事件的对象称为**观察者**或**订阅者**。从现在起，我们将使用**发布者**和**订阅者**这两个术语。'
- en: A publisher has an internal list of subscribers and provides an interface to
    register and unregister a subscriber from the internal list. It also provides
    the `notify` method, used by its client, which in turn calls `update` methods
    on subscribers – that’s why we say that the publisher notifies subscribers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者有一个内部的订阅者列表，并提供了一个接口来注册和注销内部列表中的订阅者。它还提供了一个`notify`方法，该方法由其客户端使用，进而调用订阅者的`update`方法——这就是我们说发布者通知订阅者的原因。
- en: An example of a publisher-subscriber mechanism that is common in embedded systems
    would be a temperature publisher, which notifies the logger, display, and data
    sender at regular intervals. Before we go on to the implementation of this example,
    we will first go through a UML diagram of the Observer pattern.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在嵌入式系统中常见的发布者-订阅者机制的例子是一个温度发布者，它定期通知记录器、显示器和数据发送器。在我们继续此示例的实现之前，我们首先将查看观察者模式的UML图。
- en: '![Figure 15.1 – UML diagram of the Observer pattern](img/B22402_15_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – 观察者模式的UML图](img/B22402_15_01.png)'
- en: Figure 15.1 – UML diagram of the Observer pattern
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – 观察者模式的UML图
- en: '*Figure 15.1* depicts the UML class diagram of the Observer pattern. In the
    diagram, we see that the `publisher` class has the following members:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15.1*展示了观察者模式的UML类图。在图中，我们可以看到`publisher`类有以下成员：'
- en: '`etl::vector<subscribers_, 8>`: Internal list of pointers to the subscriber
    interface, for which we will use `vector` from ETL.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etl::vector<subscribers_, 8>`：指向订阅者接口的指针的内部列表，我们将使用ETL中的`vector`。'
- en: '`register_sub(subscriber *)`: The method used to register a subscriber. The
    `register` keyword is reserved in C++ and used as a storage specifier, so we are
    using `register_sub` as the name for this method.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register_sub(subscriber *)`：用于注册订阅者的方法。`register`关键字在C++中是保留的，用作存储指定符，所以我们使用`register_sub`作为此方法的名称。'
- en: '`unregister(subscriber *)`: The method used to unregister a subscriber.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unregister(subscriber *)`：用于注销订阅者的方法。'
- en: '`notify(float)`: The method used by the publisher’s client to trigger the updating
    of subscribers.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify(float)`：发布者客户端用来触发订阅者更新的方法。'
- en: The `subscriber` interface class has one pure virtual method – `void update(float)`.
    This method is overridden in the concrete implementation of the `subscriber` class.
    To see this in action, we will proceed with the runtime implementation of the
    Observer pattern.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscriber`接口类有一个纯虚方法——`void update(float)`。该方法在`subscriber`类的具体实现中被重写。为了展示其作用，我们将继续进行观察者模式的运行时实现。'
- en: Runtime implementation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时实现
- en: 'We will go through the runtime implementation of the Observer pattern on the
    example of temperature publisher. Subscribers will be a logger, display, and data
    sender. The code of the subscriber interface and concrete subscribers is shown
    here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过温度发布者的例子来讲解观察者模式的运行时实现。订阅者将是一个记录器、显示器和数据发送器。订阅者接口和具体订阅者的代码如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code defines the `subscriber` interface and concrete subscriber
    classes: `display`, `data_sender`, and `logger`. Concrete classes override the
    pure virtual `update` method from the interface class. For the sake of simplicity
    of the example, all concrete implementations are printing temperature to standard
    output.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了`subscriber`接口和具体的订阅者类：`display`、`data_sender`和`logger`。具体类覆盖了接口类中的纯虚`update`方法。为了简化示例，所有具体实现都打印温度到标准输出。
- en: 'Using the interface class allows the publisher to depend on the interface.
    The publisher maintains an internal container of pointers to the subscriber interface.
    This makes it possible to add different implementations of the subscriber interface
    through the pointer on the base interface class. The code for the `publisher`
    class is provided here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口类允许发布者依赖于接口。发布者维护一个指向订阅者接口的指针的内部容器。这使得通过基接口类上的指针添加不同的订阅者接口实现成为可能。`publisher`类的代码如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding `publisher` class, we see the following members:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`publisher`类中，我们可以看到以下成员：
- en: '`etl::vector<subscriber*, 8> subs_`: A private container used to maintain subscribers.
    If you are running this example in Compiler Explorer, make sure to add the ETL
    library using the **Libraries** option.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etl::vector<subscriber*, 8> subs_`：用于维护订阅者的私有容器。如果您在Compiler Explorer中运行此示例，请确保使用**库**选项添加ETL库。'
- en: '`void register_sub(subscriber * sub)`: A method used to register the subscriber.
    It uses the `std::find` algorithm to check if a subscriber has already been added.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void register_sub(subscriber * sub)`: 用于注册订阅者的方法。它使用 `std::find` 算法检查订阅者是否已经被添加。'
- en: '`void unregister(subscriber * sub)`: A method used to unregister a subscriber.
    It uses the `std::find` algorithm to check if a subscriber is added before the
    calling method `erase` to remove it from a vector. The method `erase` is provided
    by the iterator returned by `std::find` if it is different from `subs_.end()`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void unregister(subscriber * sub)`: 用于注销订阅者的方法。它使用 `std::find` 算法检查在调用方法 `erase`
    移除之前订阅者是否已被添加。如果 `std::find` 返回的迭代器与 `subs_.end()` 不同，则提供 `erase` 方法。'
- en: '`void notify(float value)`: Loops through registered subscribers and calls
    the method `update` on them.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void notify(float value)`: 遍历已注册的订阅者，并在它们上调用 `update` 方法。'
- en: 'Now, let us see how to use the preceding publisher and subscribers in the following
    code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在以下代码中使用前面的发布者和订阅者：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the code, we perform the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们执行以下步骤：
- en: 'Instantiate the following concrete subscribers: `temp_logger`, `temp_display`,
    and `temp_data_sender`.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化以下具体订阅者：`temp_logger`、`temp_display` 和 `temp_data_sender`。
- en: Instantiate the publisher `temp_publisher`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化发布者 `temp_publisher`。
- en: Register the subscribers `temp_logger` and `temp_display`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册订阅者 `temp_logger` 和 `temp_display`。
- en: Call `notify(24.02f)` on `temp_publisher`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `temp_publisher` 上调用 `notify(24.02f)`。
- en: 'After these steps, we expect the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤之后，我们期望得到以下输出：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we perform the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行以下步骤：
- en: Unregister the subscriber `temp_logger`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注销订阅者 `temp_logger`。
- en: Register the subscriber `temp_data_sender`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册订阅者 `temp_data_sender`。
- en: Call `notify(44.02f)` on `temp_publisher`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `temp_publisher` 上调用 `notify(44.02f)`。
- en: 'After these steps, we expect the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤之后，我们期望得到以下输出：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As an *exercise*, create a new subscriber class `eeprom_writer` that records
    temperature if it goes under or above a set threshold.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项*练习*，创建一个新的订阅者类 `eeprom_writer`，当温度低于或高于设定的阈值时记录温度。
- en: 'You can run the full example in Renode. Start Visual Studio Code, attach it
    to the running container, open the `Chapter15/observer` project as described in
    [*Chapter 4*](Chapter_04.xhtml), and run the following commands in the Visual
    Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Renode 中运行完整的示例。启动 Visual Studio Code，将其附加到正在运行的容器，按照[*第4章*](Chapter_04.xhtml)中所述打开
    `Chapter15/observer` 项目，并在 Visual Studio Code 终端或直接在容器终端中运行以下命令：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we will go through the compile-time implementation of the Observer pattern.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍观察者模式的编译时实现。
- en: Compile-time implementation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时实现
- en: In most embedded applications, we know a lot about the system’s behavior at
    compile time. This means that when using the Observer pattern, we already know
    all the subscribers. If we assume that subscribers are only registered once and
    never unregistered, we can create a compile-time version of the Observer pattern.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数嵌入式应用中，我们知道在编译时系统行为的信息很多。这意味着当使用观察者模式时，我们已经知道所有订阅者。如果我们假设订阅者只注册一次且不会注销，我们可以创建观察者模式的编译时版本。
- en: To enable this, we’ll first break down the key C++17 features that make compile-time
    implementation feasible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用此功能，我们首先分解使编译时实现可行的关键C++17特性。
- en: Leveraging variadic templates
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用变长模板
- en: 'We will base the implementation on variadic templates. We will start with a
    simplified implementation to explain variadic templates, parameter packs, and
    fold expressions – C++ features that will allow us to create a compile-time version
    of the Observer pattern. Let us proceed with the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于变长模板来实现。我们将从一个简化的实现开始，以解释变长模板、参数包和折叠表达式——这些是C++特性，将使我们能够创建观察者模式的编译时版本。让我们从以下代码开始：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the code above, we have subscribers structs `display`, `data_sender`, and
    `logger`. All structs implement the static method `update`, which takes `temperature`
    as a parameter and prints it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有订阅者结构体 `display`、`data_sender` 和 `logger`。所有结构体都实现了静态方法 `update`，该方法接受
    `temperature` 作为参数并打印它。
- en: 'The struct `publisher` is a variadic class template. A **variadic template**
    is a template with at least one **parameter pack**. A template parameter pack
    is a template parameter that accepts zero or more template arguments. `typename...
    Subs` is a type template parameter pack named `Subs`, meaning we can instantiate
    the struct `publisher` with zero or more different types. To sum it up:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结构 `publisher` 是一个可变参数类模板。一个**可变参数模板**是一个至少有一个**参数包**的模板。一个模板参数包是一个接受零个或多个模板参数的模板参数。`typename...
    Subs` 是一个名为 `Subs` 的类型模板参数包，这意味着我们可以用零个或多个不同的类型实例化 `publisher` 结构。总结一下：
- en: '`publisher` is a variadic class template as it has a template parameter pack
    `typename... Subs`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publisher` 是一个可变参数类模板，因为它有一个模板参数包 `typename... Subs`。'
- en: We can instantiate it with a variable number of types provided as template arguments.
    This is the way to register subscribers to the publisher.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用提供的变量数量的类型作为模板参数来实例化它。这是向发布者注册订阅者的方法。
- en: In the `main` function, we create the alias `temp_publisher` as `publisher<display,
    data_sender, logger>`. We call the `notify` method on this alias, which will result
    in calls to update functions in types provided through the template parameter
    pack, thanks to the fold expression in the `notify` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建了别名 `temp_publisher` 作为 `publisher<display, data_sender, logger>`。我们在这个别名上调用
    `notify` 方法，这将导致通过模板参数包提供的类型中的更新函数被调用，这是由于 `notify` 方法中的折叠表达式。
- en: 'The final piece of the puzzle is the fold expression `(Subs::update(temp),
    ...)`. This is a fold expression that uses the comma operator as the folding operator.
    It expands to: `(display::update(temp), data_sender::update(temp), logger::update(temp))`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图最后的碎片是折叠表达式 `(Subs::update(temp), ...)`。这是一个使用逗号运算符作为折叠运算符的折叠表达式。它展开为：`(display::update(temp),
    data_sender::update(temp), logger::update(temp))`。
- en: The fold expression ensures that `display::update(temp)` is called first, then
    `data_sender::update(temp)`, then `logger::update(temp)`. The order of evaluation
    is strictly left to right for the operands of the comma operator. Each `update(temp)`
    call returns a value (likely `void`).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠表达式确保首先调用 `display::update(temp)`，然后是 `data_sender::update(temp)`，最后是 `logger::update(temp)`。逗号运算符的操作数评估顺序是严格从左到右。每个
    `update(temp)` 调用都会返回一个值（可能是 `void`）。
- en: The comma operator discards all return values except the last one, so only the
    final `logger::update(temp)` determines the fold’s result. If they all return
    void, the whole expression also returns void.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符丢弃除了最后一个之外的所有返回值，所以只有最后的 `logger::update(temp)` 决定了折叠的结果。如果它们都返回 `void`，整个表达式也返回
    `void`。
- en: Fold expressions were introduced in C++17 and using the comma operator is a
    concise way to call a function on each type in the parameter pack. Before that,
    a recursion was needed to iterate through types and call a function on them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠表达式是在 C++17 中引入的，使用逗号运算符是调用参数包中每个类型的函数的简洁方式。在那之前，需要递归才能遍历类型并调用它们上的函数。
- en: 'When examining the disassembly output in Compiler Explorer, you’ll notice that
    the generated assembly code is relatively brief, approximately 30 lines in total,
    as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Compiler Explorer 中检查反汇编输出时，你会注意到生成的汇编代码相对简短，总共大约30行，如下所示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this assembly code, we can see that there are no calls to the static update
    methods from the `display`, `data_sender`, and `logger` structs. This means the
    compiler was able to optimize these calls out, along with the registration of
    subscribers and the call to the publisher’s `notify` method, resulting in direct
    calls to the `printf` function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段汇编代码中，我们可以看到没有从 `display`、`data_sender` 和 `logger` 结构体调用静态更新方法。这意味着编译器能够优化这些调用，包括订阅者的注册和对发布者
    `notify` 方法的调用，从而直接调用 `printf` 函数。
- en: 'The result is a small memory footprint and fast performance. This example demonstrates
    the zero-cost abstraction design principle: we have abstractions for the publisher
    and subscribers, yet there is zero overhead, as the compiler is able to optimize
    the code to be as efficient as if it were written by hand.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是小的内存占用和快速的性能。这个例子演示了零成本抽象设计原则：我们为发布者和订阅者提供了抽象，但没有任何开销，因为编译器能够优化代码，使其尽可能高效，就像它是手工编写的一样。
- en: Compare the assembly output of the compile-time implementation with that of
    the runtime implementation using the same optimization level (`-O3`). It is clear
    that the compile-time implementation uses less memory and is faster as the compiler
    optimized away most of the function calls, and there is no indirection caused
    by virtual functions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的优化级别（`-O3`）比较编译时实现和运行时实现的汇编输出。很明显，编译时实现使用的内存更少，速度更快，因为编译器优化掉了大部分函数调用，并且没有由虚函数引起的间接调用。
- en: As we analyze the assembly code, let’s take the opportunity to better understand
    fold expressions. To prevent GCC from optimizing away calls to the `update` methods,
    we can use the `__attribute__((noinline))` function attribute, e.g. `static void
    __attribute__((noinline)) update(float temp)`. Add this attribute to the static
    `update` method of the `display`, `data_sender`, and `logger` structs, and observe
    the generated assembly code. You’ll see how the call to the `notify` method in
    the `main` function results in parameter pack expansion and generates calls to
    the `update` methods of the `display`, `data_sender`, and `logger` structs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分析汇编代码时，让我们利用这个机会更好地理解折叠表达式。为了防止GCC优化掉对`update`方法的调用，我们可以使用`__attribute__((noinline))`函数属性，例如`static
    void __attribute__((noinline)) update(float temp)`。将此属性添加到`display`、`data_sender`和`logger`结构的静态`update`方法中，并观察生成的汇编代码。您将看到`main`函数中对`notify`方法的调用如何导致参数包展开并生成对`display`、`data_sender`和`logger`结构`update`方法的调用。
- en: 'You can run the full example in Renode. Start Visual Studio Code, attach it
    to the running container, open the `Chapter15/observer` project as described in
    [*Chapter 4*](Chapter_04.xhtml), and run the following commands in the Visual
    Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Renode中运行完整的示例。启动Visual Studio Code，将其附加到正在运行的容器，按照[*第4章*](Chapter_04.xhtml)中描述的方式打开`Chapter15/observer`项目，然后在Visual
    Studio Code终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Simplified compile-time implementation of the Observer pattern has a couple
    of limits:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的观察者模式编译时实现有几个限制：
- en: Subscribers can only be registered.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者只能被注册。
- en: All subscribers are registered when the publisher is instantiated. They cannot
    be registered after the publisher is instantiated.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发布者实例化时，所有订阅者都会被注册。发布者实例化后不能注册。
- en: Next, we will tackle the last point, as registering all subscribers in a single
    line of code may be cumbersome and not always practical. This will provide us
    with a more flexible compile-time design.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解决最后一个问题，因为将所有订阅者注册在一行代码中可能很繁琐，并不总是实用。这将为我们提供一个更灵活的编译时设计。
- en: Improving the compile-time implementation
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进编译时实现
- en: 'We will not change the interface of the publisher template struct. Instead,
    we will allow it to receive other publishers as arguments. The code is below:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会改变发布者模板结构的接口。相反，我们将允许它接收其他发布者作为参数。下面的代码是：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the code above, we defined the following concepts:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们定义了以下概念：
- en: '`Updatable`: This describes a type that has a static method `update` that accepts
    a float'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Updatable`：这描述了一个具有接受浮点数的静态方法`update`的类型'
- en: '`Notifiable`: This describes a type that has a static method `notify` that
    accepts a float'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notifiable`：这描述了一个具有接受浮点数的静态方法`notify`的类型'
- en: We covered concepts in more detail in [*Chapter 8*](Chapter_08.xhtml). The variadic
    template class `publisher` has a new method – `call_update_or_notify`. It is called
    on every type in the parameter pack `typename... Subs` in the method `notify`
    using the fold expression and the comma operator.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第8章*](Chapter_08.xhtml)中更详细地介绍了概念。变长模板类`publisher`有一个新方法——`call_update_or_notify`。它在`notify`方法中使用折叠表达式和逗号运算符在参数包`typename...
    Subs`中的每个类型上调用。
- en: In the method `call_update_or_notify`, we use `if constexpr` to check, at compile-time,
    if the type is `Updatable` or `Notifiable` and call the `update` or `notify` static
    method on it respectively.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`call_update_or_notify`方法中，我们使用`if constexpr`在编译时检查类型是否为`Updatable`或`Notifiable`，并分别调用其上的`update`或`notify`静态方法。
- en: 'Below is an example of using the new version of the Observer pattern:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用观察者模式新版本的示例：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the code above, we instantiate `temp_publisher` by providing the variadic
    class template `publisher` with types `display` and `data_sender`, which are both
    subscribers are `Updatable`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们通过提供变长类模板`publisher`的类型`display`和`data_sender`来实例化`temp_publisher`，这两个订阅者都是`Updatable`。
- en: 'Next, we instantiate `temp_publisher_new` by providing `publisher` with the
    previously instantiated `temp_publisher` and the subscriber `logger`. Below is
    the output of the above example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过提供之前实例化的`temp_publisher`和订阅者`logger`给`publisher`来实例化`temp_publisher_new`。以下是上述示例的输出：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can run the full example in Renode. Start Visual Studio Code, attach it
    to the running container, open the `Chapter15/observer` project as described in
    [*Chapter 4*](Chapter_04.xhtml), and run the following commands in the Visual
    Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Renode中运行完整示例。启动Visual Studio Code，将其附加到正在运行的容器，按照[*第4章*](Chapter_04.xhtml)中所述打开`Chapter15/observer`项目，并在Visual
    Studio Code终端中运行以下命令，或者直接在容器终端中运行它们：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This implementation of the Observer pattern allows us to register subscribers
    in a more flexible manner. To make it more generic, as an exercise, you can modify
    it so that the `notify` method is able to take a variable number of arguments.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种观察者模式的实现使我们能够以更灵活的方式注册订阅者。为了使其更通用，作为一个练习，你可以修改它，使得`notify`方法能够接受可变数量的参数。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the Observer pattern, both runtime and compile-time
    implementations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了观察者模式，包括运行时和编译时实现。
- en: Compile-time implementation is utilizing what we know about the application
    during compile-time. It is based on variadic template classes and fold expressions.
    The result is super compact and fast code, as we are not storing information about
    subscribers in a container, nor do we need to iterate through the container to
    make a call to `update` methods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时实现是利用我们在编译时对应用程序的了解。它基于变长模板类和折叠表达式。结果是代码非常紧凑且运行速度快，因为我们既不在容器中存储订阅者的信息，也不需要遍历容器来调用`update`方法。
- en: In the next chapter, we will cover **Finite State Machines (FSM)** and the implementation
    of the State patterns in C++.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍**有限状态机（FSM**）以及在C++中实现状态模式。
- en: Join our community on Discord
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
- en: '![](img/QR_code_Discord.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_code_Discord.png)'
