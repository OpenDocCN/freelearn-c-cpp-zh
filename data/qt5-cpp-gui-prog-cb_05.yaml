- en: Chapter 5. Building a Touch Screen Application with Qt5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用Qt5构建触摸屏应用程序
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting up Qt for mobile applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动应用程序设置Qt
- en: Designing a basic user interface with QML
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QML设计基本用户界面
- en: Touch events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸事件
- en: Animation in QML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML中的动画
- en: Displaying information using model views
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型视图显示信息
- en: Integrating QML and C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成QML和C++
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Qt is not only a cross-platform software development kit for PC platforms, it
    also supports mobile platforms such as iOS and Android. The developers of Qt introduced
    Qt Quick back in 2010, which provides an easy way to build custom user interfaces
    that are highly dynamic, where users can easily create fluid transitions and effects
    with only minimal coding. Qt Quick uses a declarative scripting language called
    **QML**, which is similar to the JavaScript language used in web development.
    Advanced users can also create custom functions in C++ and port them over to Qt
    Quick to enhance its functionality. At the moment, Qt Quick supports multiple
    platforms such as Windows, Linux, Mac, iOS, and Android.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Qt不仅是PC平台的跨平台软件开发工具包，还支持iOS和Android等移动平台。Qt的开发人员在2010年推出了Qt Quick，它提供了一种简单的方式来构建高度动态的自定义用户界面，用户可以轻松地通过最少的编码创建流畅的过渡和效果。Qt
    Quick使用一种称为**QML**的声明性脚本语言，类似于Web开发中使用的JavaScript语言。高级用户还可以在C++中创建自定义函数，并将其移植到Qt
    Quick中以增强其功能。目前，Qt Quick支持Windows、Linux、Mac、iOS和Android等多个平台。
- en: Setting up Qt for mobile applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动应用程序设置Qt
- en: In this example, we will learn how to set up our Qt project in Qt Quick and
    enable it to be build and exported to mobile devices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何在Qt Quick中设置我们的Qt项目，并使其能够构建和导出到移动设备。
- en: How to do it…
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: First of all, let's create a new project by going to **File** | **New File or
    New Project**. Then, a window will pop up for you to choose a project template.
    Select **Qt Quick Application** and click the **Choose** button:![How to do it…](img/B02820_05_01.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过转到**文件** | **新建文件或新建项目**来创建一个新项目。然后，将弹出一个窗口供您选择项目模板。选择**Qt Quick应用程序**并单击**选择**按钮：![操作步骤...](img/B02820_05_01.jpg)
- en: After that, insert the project name and select the project location. Click the
    **Next** button and it will ask you to select the minimum Qt version required
    for your project. Please make sure that you select a version that exists on your
    computer, otherwise you won't be able to run it properly. Once you have done that,
    proceed by clicking the **Next** button.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，插入项目名称并选择项目位置。单击**下一步**按钮，它将要求您选择项目所需的最低Qt版本。请确保选择计算机上存在的版本，否则您将无法正确运行它。完成后，单击**下一步**按钮继续。
- en: Then, Qt Creator will ask you which **kit** you want to use for your project.
    These "kits" are basically different compilers that you can use to compile your
    project for different platforms. Since we're doing an application for a mobile
    platform, we will enable the Android kit (or the iOS kit if you're running a Mac)
    in order to build and export your app to your mobile device. Do note that you
    need to configure the Android kit if you're using it for the first time, so that
    Qt can find the directory of the Android SDK. Click **Next** once you're done
    with it:![How to do it…](img/B02820_05_02.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Qt Creator将询问您要为项目使用哪个**工具**。这些“工具”基本上是您可以用来为不同平台编译项目的不同编译器。由于我们正在为移动平台开发应用程序，因此我们将启用Android工具（或者如果您使用Mac，则启用iOS工具）以构建和导出应用程序到移动设备。请注意，如果您首次使用Android工具，则需要配置它，以便Qt可以找到Android
    SDK的目录。完成后，单击**下一步**：![操作步骤...](img/B02820_05_02.jpg)
- en: 'Once the project has been created, Qt Creator will automatically open up a
    file from your project, called `main.qml`. You will see something like this on
    screen, which is very different from your usual C/C++ project:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目后，Qt Creator将自动打开项目中的一个文件，名为`main.qml`。您将在屏幕上看到类似于这样的东西，与您通常的C/C++项目非常不同：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build and run the project now by clicking on the green arrow button located
    at the bottom-left corner of your Qt Creator. If you set the default kit to **Desktop**,
    a window will pop up which looks something like this:![How to do it…](img/B02820_05_03.jpg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过单击Qt Creator左下角的绿色箭头按钮构建和运行项目。如果将默认工具设置为**桌面**，将弹出一个窗口，看起来像这样：![操作步骤...](img/B02820_05_03.jpg)
- en: We can switch between different kits by going to the **Projects** interface
    and selecting the kit you want your project to be built with. You can also manage
    all the kits available on your computer, or add a new kit to your project from
    the **Projects** interface:![How to do it…](img/B02820_05_04.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过转到**项目**界面并选择要使用的工具来在不同的工具之间切换。您还可以管理计算机上所有可用的工具，或者从**项目**界面向项目添加新的工具：![操作步骤...](img/B02820_05_04.jpg)
- en: If this is your first time building and running your project, you need to create
    a template for the Android kit under the **Build** settings. Once you have clicked
    the **Create Templates** button, Qt will generate all the files required to run
    your app on an Android device. If you don't plan to use Gradle in your project,
    disable the option **Copy the Gradles files to Android directory**. Otherwise,
    you may encounter problems when trying to compile and deploy your app to your
    mobile device:![How to do it…](img/B02820_05_05.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是您第一次构建和运行项目，您需要在**构建**设置下为Android工具创建一个模板。一旦单击了**创建模板**按钮，Qt将生成运行应用程序所需的所有文件。如果您不打算在项目中使用Gradle，请禁用**将Gradle文件复制到Android目录**选项。否则，在尝试编译和部署应用程序到移动设备时可能会遇到问题：![操作步骤...](img/B02820_05_05.jpg)
- en: Once you have created the template, press the **Run** button and now you should
    see a window popping up, asking which device it should export to:![How to do it…](img/B02820_05_06.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模板后，单击**运行**按钮，现在您应该看到一个弹出窗口，询问应该导出到哪个设备：![操作步骤...](img/B02820_05_06.jpg)
- en: Select the device that is currently connected to your computer and press the
    **OK** button. Wait for a while for it to build the project, and you should see
    something like this on your mobile device:![How to do it…](img/B02820_05_07.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择当前连接到计算机的设备，然后按**确定**按钮。等待一会儿，直到项目构建完成，然后您应该在移动设备上看到类似于这样的东西：![如何操作...](img/B02820_05_07.jpg)
- en: How it works…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A Qt Quick application project is quite different from a form application project.
    You will be writing QML script most of the time instead of writing C/C++ code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick应用程序项目与表单应用程序项目有很大不同。您将大部分时间编写QML脚本，而不是编写C/C++代码。
- en: 'The **Android Software** **Development Kit** (**SDK**), **Android** **Native
    Development Kit** (**NDK**), **Java** **Development Kit** (**JDK**), and **Apache
    Ant** are required to build and export your app to the Android platform. Alternatively,
    you can also use Gradle instead of Apache Ant for your Android kit. All you need
    to do is to enable the **Use Gradle instead of Ant** option and provide Qt with
    Gradle''s installation path. Note that Android Studio is currently not supported
    by Qt Creator:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和导出应用程序到Android平台需要**Android软件开发工具包**（**SDK**）、**Android本机开发工具包**（**NDK**）、**Java开发工具包**（**JDK**）和**Apache
    Ant**。或者，您也可以使用Gradle代替Apache Ant来构建您的Android工具包。您只需要启用**使用Gradle代替Ant**选项，并提供Qt
    Gradle的安装路径。请注意，Android Studio目前不受Qt Creator支持：
- en: '![How it works…](img/B02820_05_31.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B02820_05_31.jpg)'
- en: If you're running the app on an Android device, make sure that you have enabled
    USB Debugging Mode. To enable USB Debugging Mode, you need to first enable the
    developer options on your Android device by going to **Settings** | **About Phone**
    and tap the **Build Number** seven times. After that, go to **Settings** | **Developer
    Options** and you will see the **Android Debugging** option in the menu. Enable
    that option and you can now export your app to your device for testing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Android设备上运行应用程序，请确保已启用USB调试模式。要启用USB调试模式，您需要先在Android设备上启用开发者选项，方法是转到**设置**
    | **关于手机**，然后点击**版本号**七次。之后，转到**设置** | **开发者选项**，您将在菜单中看到**Android调试**选项。启用该选项后，您现在可以将应用程序导出到设备进行测试。
- en: To build for the iOS platform, you need to run Qt Creator on a Mac and make
    sure the latest XCode is installed on your Mac as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建iOS平台，您需要在Mac上运行Qt Creator，并确保最新的XCode也安装在您的Mac上。
- en: To test your app on an iOS device, you need to register a developer account
    with Apple, register your device at the developer portal, and install the provisioning
    to your XCode, which is a lot trickier than Android. You will be given access
    to the developer portal once you have obtained a developer account from Apple.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要在iOS设备上测试您的应用程序，您需要在Apple注册开发者帐户，在开发者门户注册您的设备，并将配置文件安装到XCode中，这比Android要棘手得多。一旦您从Apple获得了开发者帐户，您将获得访问开发者门户的权限。
- en: Designing a basic user interface with QML
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QML设计基本用户界面
- en: In this example, we will learn how to use Qt Quick Designer to design our program's
    user interface.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何使用Qt Quick Designer来设计程序的用户界面。
- en: How to do it…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First of all, create a new Qt Quick application project, just like we did in
    the previous recipe. You can also use the previous project files if you wish to.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Qt Quick应用程序项目，就像我们在之前的示例中所做的那样。如果愿意，您也可以使用之前的项目文件。
- en: 'You will see two QML files in your project resources—`main.qml` and `MainForm.ui.qml`.
    The former is where we implement the logic for our application, and the latter
    is where we design our user interface. We will start with the UI design, so let''s
    open up `MainForm.ui.qml`. Once it''s been opened by Qt Creator, you will see
    an entirely different UI editor compared to the one we used in previous chapters.
    This editor is called the Qt Quick Designer, which is used specifically to design
    UI for Qt Quick projects. The components of this editor are described as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在项目资源中看到两个QML文件——`main.qml`和`MainForm.ui.qml`。前者是我们实现应用程序逻辑的地方，后者是我们设计用户界面的地方。我们将从UI设计开始，所以让我们打开`MainForm.ui.qml`。一旦被Qt
    Creator打开，您将看到一个与我们在之前章节中使用的完全不同的UI编辑器。这个编辑器称为Qt Quick Designer，专门用于设计Qt Quick项目的UI。该编辑器的组件描述如下：
- en: '**Library**: The **Library** window displays all the predefined QML types that
    you can add to your UI canvas. You can also import custom Qt Quick components
    from the **Import** tab and display them here.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库**：**库**窗口显示了您可以添加到UI画布的所有预定义的QML类型。您还可以从**导入**选项卡导入自定义的Qt Quick组件并在此处显示它们。'
- en: '**Navigator**: The **Navigator** window displays the items in the current QML
    file in a tree structure.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航器**：**导航器**窗口以树形结构显示当前QML文件中的项目。'
- en: '**Connections**: You can use the tools provided in the **Connections** window
    to connect objects to signals, specify dynamic properties for objects, and create
    bindings between the properties of two objects.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：您可以使用**连接**窗口中提供的工具将对象连接到信号，为对象指定动态属性，并在两个对象的属性之间创建绑定。'
- en: '**State**: The **State** window displays the different states of an item. You
    can add a new state for an item by clicking on the **+** button on the right of
    the **State** window.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：**状态**窗口显示了项目的不同状态。您可以通过单击**状态**窗口右侧的**+**按钮为项目添加新状态。'
- en: '**Canvas**: The canvas is where you design your program''s user interface.
    You can drag and drop a Qt Quick component from the **Library** window onto the
    canvas and instantly see what it will look like in the program.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**画布**：画布是您设计程序用户界面的地方。您可以从**库**窗口将Qt Quick组件拖放到画布上，并立即看到它在程序中的外观。'
- en: '**Properties**: This is where you change the properties of a selected item.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：这是您更改所选项目属性的地方。'
- en: Select everything under the **Rectangle** object (**mouseArea** and **Text**)
    in the **Navigator** window and delete them.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导航器**窗口下选择**矩形**对象下的所有内容（**mouseArea**和**Text**）并删除它们。
- en: We're about to make a simple login screen. From the **Library** window, drag
    two text widgets onto the canvas.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将制作一个简单的登录界面。从**库**窗口中，将两个文本小部件拖放到画布上。
- en: Set the text properties of both the text widgets to **Username:** and **Password:**![How
    to do it…](img/B02820_05_32.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个文本小部件的文本属性设置为**用户名：**和**密码：**![操作步骤…](img/B02820_05_32.jpg)
- en: Drag two rectangles from the **Library** window to the canvas, then drag two
    text input widgets onto the canvas and parent each of them to the rectangles you
    just added to the canvas. Set the `border` property of the rectangles to `1` and
    the `radius` to `5`. Then, set the `echo mode` of one of the text fields to `Password`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**库**窗口中拖动两个矩形到画布上，然后将两个文本输入小部件拖到画布上，并将它们各自作为父级添加到刚刚添加到画布上的矩形上。将矩形的`border`属性设置为`1`，`radius`设置为`5`。然后，将一个文本字段的`echo
    mode`设置为`Password`。
- en: Now we're going to manually create a button widget by combining a mouse area
    widget with a rectangle and a text widget. Drag a mouse area widget onto the canvas,
    then drag a rectangle and a text widget onto the canvas and parent them both to
    the mouse area. Set the color of the rectangle to `#bdbdbd`, then set its `border`
    property to `1` and its `radius` to `5`. Then, set the `text` to `Login` and make
    sure the size of the mouse area is the same as the rectangle.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过将鼠标区域小部件与矩形和文本小部件组合来手动创建一个按钮小部件。将鼠标区域小部件拖到画布上，然后将矩形和文本小部件拖到画布上，并将它们都作为父级添加到鼠标区域上。将矩形的颜色设置为`#bdbdbd`，然后将其`border`属性设置为`1`，`radius`设置为`5`。然后，将文本设置为`登录`，并确保鼠标区域的大小与矩形相同。
- en: After that, drag another rectangle onto the canvas to act as the container for
    the login form so that it will look neat. Set its `border color` to `#5e5858`
    and its `border` property to `2`. Then, set its `radius` property to `5` to make
    its corners look a little rounded.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将另一个矩形拖到画布上，作为登录表单的容器，使其看起来整洁。将其`border color`设置为`#5e5858`，`border`属性设置为`2`。然后，将其`radius`属性设置为`5`，使其角看起来有点圆润。
- en: Make sure the rectangle that we added in the previous step is positioned at
    the top of the hierarchy in the **Navigator** window so that it appears behind
    all the other widgets. You can arrange the widget positions within the hierarchy
    by pressing the arrow buttons located at the top of the **Navigator** window:![How
    to do it…](img/B02820_05_08.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们在上一步中添加的矩形在**导航器**窗口中的层次结构顶部，以便它出现在所有其他小部件后面。您可以通过按位于**导航器**窗口顶部的箭头按钮来排列层次结构中的小部件位置：![操作步骤…](img/B02820_05_08.jpg)
- en: Next, we will export three widgets—mouse area and the two text input widgets—as
    alias properties of the root item so that later on we can access these widgets
    from the `main.qml` file. The widgets can be exported by clicking on the small
    icon behind the widget name and making sure the icon changes to the **On** status:![How
    to do it…](img/B02820_05_09.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将导出三个小部件——鼠标区域和两个文本输入小部件——作为根项目的别名属性，以便以后可以从`main.qml`文件中访问这些小部件。通过单击小部件名称后面的小图标，并确保图标变为**On**状态来导出小部件：![操作步骤…](img/B02820_05_09.jpg)
- en: By now, your UI should look something like this:![How to do it…](img/B02820_05_10.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，您的UI应该看起来像这样：![操作步骤…](img/B02820_05_10.jpg)
- en: Now let's open up `main.qml`. Qt Creator will not open this file in Qt Quick
    Designer by default, but instead, it will be opened with the Script Editor. This
    is because all the UI design-related tasks were done in `MainForm.ui.qml`, and
    `main.qml` is only for defining the logic and functions that will be applied to
    the UI. You can, however, open it with Qt Quick Designer to preview the UI by
    clicking on the **Design** button located in the side bar on the left of the editor.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们打开`main.qml`。Qt Creator默认情况下不会在Qt Quick Designer中打开此文件，而是会在脚本编辑器中打开。这是因为所有与UI设计相关的任务都是在`MainForm.ui.qml`中完成的，而`main.qml`仅用于定义将应用于UI的逻辑和函数。但是，您可以通过单击编辑器左侧边栏上的**Design**按钮，使用Qt
    Quick Designer打开它以预览UI。
- en: 'At the top of the script, add the third line to import the dialog module to
    `main.qml`, like so:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部，添加第三行以导入对话框模块到`main.qml`，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, replace the code below it with this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，用以下代码替换下面的代码：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Build and run this program on your PC and you should get a simple program that
    shows a message box when you click on the **Login** button:![How to do it…](img/B02820_05_11.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PC上构建并运行此程序，当您单击**登录**按钮时，应该会显示一个消息框的简单程序：![操作步骤…](img/B02820_05_11.jpg)
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Since Qt 5.4, a new file extension called `.ui.qml` has been introduced. The
    QML engine handles it like the normal `.qml` files, but forbids any logic implementation
    to be written in it. It serves as the UI definition template, which can be reused
    in different `.qml` files. The separation of UI definition and logic implementation
    improves the maintainability of QML code and creates a better workflow.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 自Qt 5.4以来，引入了一个名为`.ui.qml`的新文件扩展名。QML引擎处理它就像处理普通的`.qml`文件一样，但禁止在其中编写任何逻辑实现。它用作UI定义模板，可以在不同的`.qml`文件中重用。UI定义和逻辑实现的分离改善了QML代码的可维护性，并创建了更好的工作流程。
- en: All the widgets under **Qt Quick – Basic** are the most basic widgets that we
    can use to mix and match and create a new type of widget. In the previous example,
    we have learned how to put three widgets together—a text, a mouse area, and a
    rectangle, to form a button widget.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt Quick - 基本**下的所有小部件都是我们可以使用来混合和匹配并创建新类型小部件的最基本小部件。在前面的示例中，我们学习了如何将三个小部件组合在一起——文本、鼠标区域和矩形，以形成一个按钮小部件。'
- en: 'If you''re lazy, however, you can import pre-made modules to your Qt Quick
    project by going to the **Imports** tab in the **Library** window and clicking
    the **<Add Import>** button. Then, select the module you want to add to your project
    from the drop-down list. You can also create your own Qt Quick module once you
    have advanced in both QML scripting and C++ programming:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您懒得做，可以通过转到**库**窗口中的**导入**选项卡并单击**<添加导入>**按钮，将预制模块导入到您的Qt Quick项目中。然后，从下拉列表中选择要添加到项目中的模块。一旦您在QML脚本和C++编程方面有所进步，还可以创建自己的Qt
    Quick模块：
- en: '![How it works…](img/B02820_05_12.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B02820_05_12.jpg)'
- en: We imported `QtQuick.dialogs` module in `main.qml` and created a message box
    that displays the user name and password filled in by the user when the **Login**
    button is pressed, so that we can prove that the UI function is working. If the
    widgets are not exported from `MainForm.ui.qml`, we will not be able to access
    its properties in `main.qml`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main.qml`中导入了`QtQuick.dialogs`模块，并创建了一个消息框，当用户按下**登录**按钮时显示用户填写的用户名和密码，以证明UI功能正在工作。如果小部件没有从`MainForm.ui.qml`中导出，我们将无法在`main.qml`中访问其属性。
- en: At this point, we can export the program to iOS and Android, but the UI may
    not look accurate on some of the devices that have higher resolution or higher
    **Density-per-Pixel** (**DPI**) unit. We will cover this issue later on in this
    chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以将程序导出到iOS和Android，但是在一些具有更高分辨率或更高**每英寸像素密度**（**DPI**）单位的设备上，UI可能看起来不准确。我们将在本章后面解决这个问题。
- en: Touch events
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸事件
- en: In this section, we will learn how to develop a touch-driven application that
    runs on mobile devices using Qt Quick.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何使用Qt Quick开发在移动设备上运行的触摸驱动应用程序。
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: First of all, create a new Qt Quick application project.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Qt Quick应用程序项目。
- en: In Qt Creator, right-click on `qml.qrc` and select **Open in Editor**. Then,
    click **Add** | **Add Files** and add `tux.png` to the project:![How to do it…](img/B02820_05_13.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Qt Creator中，右键单击`qml.qrc`，然后选择**在编辑器中打开**。然后，单击**添加** | **添加文件**，将`tux.png`添加到项目中：![如何做…](img/B02820_05_13.jpg)
- en: Next, open up `MainForm.ui.qml`. Drag an image widget from the **Library** window
    to the canvas. Then, set the source of the image to `tux.png` and set its `fillmode`
    to `PreserveAspectFit`. After that, set its `width` to `200` and its `height`
    to `220`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`MainForm.ui.qml`。从**库**窗口将图像小部件拖动到画布上。然后，将图像的源设置为`tux.png`，并将其`fillmode`设置为`PreserveAspectFit`。之后，将其`width`设置为`200`，将其`height`设置为`220`。
- en: Make sure both the mouse area widget and the image widget are exported as alias
    properties of the root item by clicking on the small icon besides their respective
    widget name.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保鼠标区域小部件和图像小部件都通过单击其各自的小部件名称旁边的小图标作为根项目的别名属性导出。
- en: 'After that, switch over to the Script Editor by clicking on the **Edit** button
    on the side bar located at the left side of the editor. We need to change the
    mouse area widget to a multi-point touch area widget, like so:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那之后，通过单击编辑器左侧边栏上的**编辑**按钮切换到脚本编辑器。我们需要将鼠标区域小部件更改为多点触摸区域小部件，如下所示：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also set the `Image` widget to be automatically placed at the center of
    the window by default:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将`Image`小部件设置为默认自动放置在窗口中心：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final UI should look something like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的UI应该看起来像这样：
- en: '![How to do it…](img/B02820_05_14.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/B02820_05_14.jpg)'
- en: 'Once you''re done with that, let''s open up `main.qml`. First, clear everything
    within the `MainForm` object except `anchors.fill: parent`, like so:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '完成后，让我们打开`main.qml`。首先清除`MainForm`对象中除`anchors.fill: parent`之外的所有内容，如下所示：'
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After that, declare several variables within the `MainForm` object that will
    be used to rescale the image widget. If you want to know more about the `property`
    keyword used in the following code, check out the *There''s more…* section at
    the end of this example:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainForm`对象中声明几个变量，这些变量将用于重新调整图像小部件。如果您想了解以下代码中使用的`property`关键字的更多信息，请查看本示例末尾的*还有更多…*部分：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will define what will happen when our finger touches the multi-point
    area widget. In this case, we will save the positions of the first and second
    touch points if more than one finger touches the multi-point touch area. We also
    save the width and height of the image widget so that later on we can use these
    variables to calculate the scale of the image when the fingers start to move:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义当手指触摸多点区域小部件时会发生什么。在这种情况下，如果多个手指触摸到多点触摸区域，我们将保存第一个和第二个触摸点的位置。我们还保存图像小部件的宽度和高度，以便以后可以使用这些变量来计算手指开始移动时图像的比例：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following image shows the example of touch points being registered when
    two fingers are touching the screen, within the touchArea boundary. `touchArea`.`touchPoints[0]`
    is the first registered touch point and `touchArea.touchPoints[1]` is the second.
    We then calculate the X and Y distance between the two touch points and save them
    as `prevDistX` and `prevDistY`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了当两根手指触摸屏幕时，在触摸区域边界内注册的触摸点的示例。`touchArea`.`touchPoints[0]`是第一个注册的触摸点，`touchArea.touchPoints[1]`是第二个。然后我们计算两个触摸点之间的X和Y距离，并将它们保存为`prevDistX`和`prevDistY`：
- en: '![How to do it…](img/B02820_05_15.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/B02820_05_15.jpg)'
- en: 'After that, we will define what will happen when our fingers move while remaining
    in contact with the screen and still within the boundary of the touch area. At
    this point, we will calculate the scale of the image by using the variables we
    saved in the previous step. At the same time, if we detect that only a single
    touch is found, then we will move the image instead of altering its scale:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那之后，我们将定义当我们的手指在屏幕上移动时会发生什么，同时仍然保持与触摸区域的边界接触。在这一点上，我们将使用我们在上一步中保存的变量来计算图像的比例。同时，如果我们检测到只有一个触摸点，那么我们将移动图像而不是改变其比例：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following image shows the example of moving touch points - `touchArea.touchPoints[0]`
    moved from point A to point B while `touchArea.touchPoints[1]` moved from point
    C to point D. We can then determine how many units have the touch points moved
    by looking at the differences between the previous X, Y variables with the current
    ones:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了移动触摸点的示例 - `touchArea.touchPoints[0]`从点A移动到点B，而`touchArea.touchPoints[1]`从点C移动到点D。然后，我们可以通过查看先前的X、Y变量与当前变量之间的差异来确定触摸点移动了多少单位：
- en: '![How to do it…](img/B02820_05_16.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/B02820_05_16.jpg)'
- en: 'You can now build and export the program to your mobile device. You will not
    be able to test this program on a platform that does not support multi-touch.
    Once the program is running on the mobile device (or desktop/laptop that supports
    multi-touch), try two things: put only one finger on the screen and move it around,
    and put two fingers on the screen and move them in opposite directions. What you
    should see is that the penguin will be moved to another place if you use only
    one finger, and it will be scaled up or down if you use two fingers:![How to do
    it…](img/B02820_05_33.jpg)'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以构建并将程序导出到您的移动设备上。您将无法在不支持多点触摸的平台上测试此程序。一旦程序在支持多点触摸的移动设备（或支持多点触摸的台式机/笔记本电脑）上运行，请尝试两件事：只在屏幕上放一个手指并移动它，以及在屏幕上放两个手指并朝相反方向移动它们。您应该看到的是，如果您只使用一个手指，企鹅将被移动到另一个位置，如果您使用两个手指，它将被放大或缩小：![如何做…](img/B02820_05_33.jpg)
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When a finger touches the screen of the device, the multi-point touch area widget
    triggers the `onPressed` event and registers the position of each of the touch
    points in an internal array. We can get this data by telling Qt which touch point
    you want to get access to. The first touch will bear the index number of `0`,
    the second touch will be `1`, and so on. We will then save this data into variables
    so that we can retrieve it later to calculate the scaling of the penguin image.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当手指触摸设备的屏幕时，多点触摸区域小部件会触发“onPressed”事件，并在内部数组中注册每个触摸点的位置。我们可以通过告诉Qt要访问的触摸点来获取这些数据。第一个触摸点将带有索引号“0”，第二个触摸点将是“1”，依此类推。然后，我们将这些数据保存到变量中，以便以后可以检索它们以计算企鹅图像的缩放。
- en: When one or more fingers remain in contact with the screen while moving, a multi-point
    touch area will trigger the `onUpdate` event. We will then check how many touches
    there are—if only one touch is found, we will just move the penguin image based
    on how much our finger has moved. If there is more than one touch, we will compare
    the distance between the two touches and compare this with the previous variables
    we have saved, to determine how much we should rescale the image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个或多个手指在移动时仍然与屏幕保持接触，多点触摸区域将触发“onUpdate”事件。然后，我们将检查触摸点的数量 - 如果只找到一个触摸点，我们将根据手指移动的距离移动企鹅图像。如果有多个触摸点，我们将比较两个触摸点之间的距离，并将其与我们之前保存的变量进行比较，以确定我们应该如何重新调整图像的大小。
- en: '![How it works…](img/B02820_05_34.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B02820_05_34.jpg)'
- en: We must also check whether the first touch is on the left side of the second
    touch or the right side. This way we can prevent the image from being scaled in
    the inverse direction of the finger movement and producing an inaccurate result.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须检查第一个触摸点是否在第二个触摸点的左侧还是右侧。这样我们就可以防止图像在手指移动的反方向上被缩放，并产生不准确的结果。
- en: As for the movement of the penguin, we will just get the difference between
    the current touch position and the previous one, add that to the coordinate of
    the penguin, and it's done. A single touch event is usually a lot simpler and
    more straightforward than a multi-touch event.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 至于企鹅的移动，我们将只获取当前触摸位置和上一个触摸位置之间的差异，将其添加到企鹅的坐标中，然后完成。单点触摸事件通常比多点触摸事件简单得多，更直接。
- en: There's more…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In Qt Quick, all its components have built-in properties such as width, height,
    color, and so on that are attached to the components by default. However, Qt Quick
    also allows you to create your own custom properties and attach them to the components
    you declared in your QML script. A custom property of an object type may be defined
    in an object declaration in a QML document by adding the `property` keyword before
    the type keyword, for example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick中，所有组件都具有内置属性，如宽度、高度、颜色等，默认情况下附加到组件上。但是，Qt Quick还允许您创建自己的自定义属性，并将其附加到您在QML脚本中声明的组件上。对象类型的自定义属性可以通过在QML文档中的对象声明之前添加`property`关键字来定义，例如：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also bind the custom property to a value by using a colon (`:`) before
    the value, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用冒号（`:`）将自定义属性绑定到值，如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To learn more about the property types supported by Qt Quick, check out this
    link: [http://doc.qt.io/qt-5/qtqml-typesystem-basictypes.html](http://doc.qt.io/qt-5/qtqml-typesystem-basictypes.html)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Qt Quick支持的属性类型的更多信息，请查看此链接：[http://doc.qt.io/qt-5/qtqml-typesystem-basictypes.html](http://doc.qt.io/qt-5/qtqml-typesystem-basictypes.html)
- en: Animation in QML
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML中的动画
- en: Qt allows us to easily animate a UI component without writing a bunch of code.
    In this example, we will learn how to make our program's UI more interesting by
    applying animations to it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Qt允许我们在不编写大量代码的情况下轻松地为UI组件添加动画。在这个例子中，我们将学习如何通过应用动画使我们程序的UI更有趣。
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Once again, we will start everything from scratch. Therefore, create a new Qt
    Quick application project in Qt Creator and open up `MainForm.ui.qml`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次从头开始。因此，在Qt Creator中创建一个新的Qt Quick应用程序项目，并打开`MainForm.ui.qml`。
- en: Go to the **Imports** tab in the **Library** window and add a Qt Quick module
    called **QtQuick.Controls** to your project.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**库**窗口中的**导入**选项卡，并将一个名为**QtQuick.Controls**的Qt Quick模块添加到您的项目中。
- en: After that, you will see a new category appear in the **QML Types** tab called
    **Qt Quick - Controls**, which contains many new widgets that can be placed on
    the canvas.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您将在**QML类型**选项卡中看到一个名为**Qt Quick - Controls**的新类别，其中包含许多可以放置在画布上的新小部件。
- en: Next, drag three button widgets to the canvas and set their height to `45`.
    Then, go to the **Layout** tab on the **Properties** window and enable both the
    left and right anchors for all the three button widgets. Make sure the target
    for the anchors are set to **Parent** and the margins remain as `0`. This will
    make the buttons resize horizontally according to the width of the main window.
    After that, set the *y* value of the first button to `0`, the second to `45`,
    and the third to `90`. The UI should now look like this:![How to do it…](img/B02820_05_17.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将三个按钮小部件拖到画布上，并将它们的高度设置为`45`。然后，转到**属性**窗口上的**布局**选项卡，并为所有三个按钮小部件启用左右锚点。确保锚点的目标设置为**父级**，边距保持为`0`。这将使按钮根据主窗口的宽度水平调整大小。之后，将第一个按钮的*y*值设置为`0`，第二个为`45`，第三个为`90`。UI现在应该是这样的：![操作步骤…](img/B02820_05_17.jpg)
- en: Now, open up `qml.qrc` with the Editor and add `fan.png` to the project:![How
    to do it…](img/B02820_05_18.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用编辑器打开`qml.qrc`并将`fan.png`添加到项目中：![操作步骤…](img/B02820_05_18.jpg)
- en: Then, add two mouse area widgets to the canvas. After that, drag a rectangle
    widget and an image widget on the canvas. Parent the rectangle and image to the
    mouse areas we have just added before this.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在画布上添加两个鼠标区域小部件。之后，在画布上拖动一个矩形小部件和一个图像小部件。将矩形和图像作为父级部件添加到我们刚刚添加的鼠标区域上。
- en: Set the color of the rectangle to `#0000ff` and apply `fan.png` to the image
    widget. Your UI should now look like this:![How to do it…](img/B02820_05_19.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩形的颜色设置为`#0000ff`，并将`fan.png`应用到图像小部件。您的UI现在应该是这样的：![操作步骤…](img/B02820_05_19.jpg)
- en: After that, export all the widgets in your `MainForm.ui.qml` as alias properties
    of the root item by clicking on the icons located to the right of the widget name:![How
    to do it…](img/B02820_05_20.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过单击小部件名称右侧的图标，将`MainForm.ui.qml`中的所有小部件导出为根项目的别名属性：
- en: Next, we will apply animation and logic to the UI but we won't be doing it in
    `MainForm.ui.qml`. Instead, we will do it all in `main.qml`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为UI应用动画和逻辑，但我们不会在`MainForm.ui.qml`中进行。相反，我们将在`main.qml`中完成所有操作。
- en: 'In `main.qml`, remove the default code for the mouse area and add in a width
    and height for the window so that we get more space to preview:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.qml`中，删除鼠标区域的默认代码，并为窗口添加宽度和高度，以便我们有更多的空间进行预览：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, add the code that defines the behavior of the buttons in the `MainForm`
    widget:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`MainForm`小部件中添加定义按钮行为的代码：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, follow this with the behavior of the `fan` image and the mouse area widget
    it is attached to:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照`fan`图像和其附加的鼠标区域小部件的行为：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Last but not least, add the behavior of the rectangle and the mouse area widget
    it's attached to:![How to do it…](img/B02820_05_21.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，添加矩形和鼠标区域小部件的行为：![操作步骤…](img/B02820_05_21.jpg)
- en: If you compile and run the program now, you should see three buttons at the
    top of the window and a moving rectangle at the bottom left, followed by a spinning
    fan at the bottom right. If you click any of the buttons, they will move slightly
    downward with a nice, smooth animation. If you click on the rectangle, it will
    change color from blue to red. Meanwhile, the fan image will pause its animation
    if you click on it while it's animating, and it will resume the animation if you
    click on it again:![How to do it…](img/B02820_05_22.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在编译并运行程序，您应该会看到窗口顶部有三个按钮，底部左侧有一个移动的矩形，底部右侧有一个旋转的风扇。如果您点击任何按钮，它们将以流畅的动画略微向下移动。如果您点击矩形，它将从蓝色变为红色。同时，如果您在风扇图像正在动画时点击它，它将暂停动画，如果再次点击它，它将恢复动画：![操作步骤…](img/B02820_05_22.jpg)
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Most of the animation elements supported by the C++ version of Qt, such as transition,
    sequential animation, parallel animation, and so on, are also available in Qt
    Quick. If you are familiar with the Qt animation framework in C++, you should
    be able to grasp this pretty easily.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的C++版本支持的大多数动画元素，如过渡、顺序动画、并行动画等，在Qt Quick中也是可用的。如果您熟悉C++中的Qt动画框架，您应该能够很容易地掌握这个。
- en: In this example, we added a spring animation element to all three buttons that
    specifically tracked their respective *y*-axes. If Qt detects that the y value
    has changed, the widget will not instantly pop to the new position, but instead
    it will be interpolated, move across the canvas, and perform a little shaking
    animation when reaching its destination, which simulates the spring effect. We
    just have to write one line of code and leave the rest to Qt.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为所有三个按钮添加了一个弹簧动画元素，它专门跟踪它们各自的*y*轴。如果Qt检测到*y*值已经改变，小部件将不会立即跳到新位置，而是进行插值运算，沿着画布移动，并在到达目的地时执行一些摇晃动画，模拟弹簧效果。我们只需写一行代码，剩下的交给Qt处理。
- en: As for the fan image, we added a rotation animation element to it and set the
    `duration` to `1000` milliseconds, which means it will complete a full rotation
    in one second. We also set it to loop its animation infinitely. When we clicked
    on the mouse area widget it's attached to, we just called `pause()` or `resume()`
    to enable or disable the animation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 至于风扇图像，我们为其添加了旋转动画元素，并将`持续时间`设置为`1000`毫秒，这意味着它将在一秒内完成一次完整的旋转。我们还设置它循环播放动画。当我们点击它附加的鼠标区域小部件时，我们只需调用`pause()`或`resume()`来启用或禁用动画。
- en: Next, for the rectangle widget, we added two states to it, one called `BLUE`
    and one called `RED`, each of which carries a `color` property that will be applied
    to the rectangle upon state change. At the same time, we added a sequential animation
    group to the mouse area widget that the rectangle is attached to, and then added
    two property animation elements to the group. You can also mix different types
    of group animation; Qt can handle this very well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于矩形小部件，我们为其添加了两个状态，一个称为`BLUE`，一个称为`RED`，每个状态都带有一个在状态改变时将应用于矩形的`颜色`属性。同时，我们为矩形附加的鼠标区域小部件添加了一个顺序动画组，并向组中添加了两个属性动画元素。您还可以混合不同类型的组动画；Qt可以很好地处理这一点。
- en: Displaying information using Model View
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型视图显示信息
- en: Qt includes a Model View framework that maintains separation between the way
    data is organized and managed, and the way that it is presented to the user. In
    this section, we will learn how to make use of the model view, in particular by
    using the list view to display information and at the same time apply our own
    customization to make it look slick.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Qt包括一个模型视图框架，它保持数据组织和管理方式与向用户呈现方式之间的分离。在本节中，我们将学习如何利用模型视图，特别是通过使用列表视图来显示信息，并同时应用我们自己的定制使其看起来漂亮。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: Create a new Qt Quick application project and open up `qml.qrc` with Qt Creator.
    Add six images, `home.png`, `map.png`, `profile.png`, `search.png`, `settings.png`,
    and `arrow.png`, to the project:![How to do it…](img/B02820_05_35.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Qt Quick应用程序项目，并用Qt Creator打开`qml.qrc`。将六个图像`home.png`、`map.png`、`profile.png`、`search.png`、`settings.png`和`arrow.png`添加到项目中：![操作步骤…](img/B02820_05_35.jpg)
- en: After that, open up `MainForm.ui.qml`. Delete all the default widgets on the
    canvas and drag a **List View** widget from under the **Qt Quick - Views** category
    in the Library window onto the canvas. Then, set its **Anchors** setting to **Fill
    the parent size** by clicking on the button located in the middle of the **Layout**
    window:![How to do it…](img/B02820_05_23.jpg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`MainForm.ui.qml`。删除画布上的所有默认小部件，并从库窗口的**Qt Quick - Views**类别下拖动一个**列表视图**小部件到画布上。然后，通过单击**布局**窗口中间的按钮，将其**锚点**设置为**填充父级大小**：![操作步骤…](img/B02820_05_23.jpg)
- en: Next, switch over to the Script Editor, as we will define what the list view
    will look like:![How to do it…](img/B02820_05_24.jpg)![How to do it…](img/B02820_05_36.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，切换到脚本编辑器，因为我们将定义列表视图的外观：![操作步骤…](img/B02820_05_24.jpg)![操作步骤…](img/B02820_05_36.jpg)
- en: 'After that, open up `main.qml` and replace the code with this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`main.qml`并用以下代码替换原代码：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Build and run the program, and now your program should look like this:![How
    to do it…](img/B02820_05_25.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行程序，现在您的程序应该是这个样子：![操作步骤…](img/B02820_05_25.jpg)
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Qt Quick allows us to customize the look of each row of the list view with ease.
    The `delegate` defines what each row will look like and the `model` is where you
    store the data that will be displayed on the list view.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick允许我们轻松定制列表视图的每一行外观。`delegate`定义了每一行的外观，而`model`是您存储在列表视图上显示的数据的地方。
- en: In this example, we added a background with a gradient on each row, then we
    also added an icon on each side of the item, a title, a description, and a mouse
    area widget that makes each row of the list view clickable. The delegate is not
    static, as we allow the model to change the title, description, and the icon to
    make each row look unique.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在每一行上添加了一个渐变的背景，然后我们还在项目的两侧添加了一个图标、一个标题、一个描述，以及一个鼠标区域小部件，使列表视图的每一行都可以点击。委托是不静态的，因为我们允许模型更改标题、描述和图标，使每一行看起来都是独特的。
- en: In `main.qml`, we defined the behavior of the mouse area widget, which will
    halve its own opacity value lower when pressed and return to fully opaque when
    released. Since all other elements, such as title, icon, and so on, are all the
    children of the mouse area widget, they all will also automatically follow their
    parent widget's behavior and become semi-transparent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.qml`中，我们定义了鼠标区域小部件的行为，当按下时，它的不透明度值会降低一半，释放时会恢复完全不透明。由于所有其他元素，如标题、图标等，都是鼠标区域小部件的子元素，它们也会自动遵循其父小部件的行为，并变得半透明。
- en: 'Also, we have finally solved the display problem on mobile devices with high
    resolution and DPI. It''s a very simple trick—first, we defined a variable called
    `sizeMultiplier`. The value of `sizeMultiplier` is the result of dividing the
    width of the window by a predefined value, say `480`, which is the current window
    width we used for the PC. Then, multiply `sizeMultiplier` by all the widget variables
    that have to do with size and position, including font size. Do note that in this
    case, you should use the `pixelSize` property for text instead of `pointSize`,
    so that you will get the correct display when multiplying by `sizeMultiplier`.
    The following screenshot shows you what the app looks like on the mobile device
    with and without `sizeMultiplier`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们终于解决了移动设备高分辨率和DPI显示问题。这是一个非常简单的技巧——首先，我们定义了一个名为`sizeMultiplier`的变量。`sizeMultiplier`的值是将窗口宽度除以预定义值（例如`480`）的结果，这是我们用于PC的当前窗口宽度。然后，将`sizeMultiplier`乘以所有与大小和位置有关的小部件变量，包括字体大小。请注意，在这种情况下，应该使用文本的`pixelSize`属性而不是`pointSize`，这样当乘以`sizeMultiplier`时，您将获得正确的显示。以下截图显示了在移动设备上使用和不使用`sizeMultiplier`时应用的样子：
- en: '![How it works…](img/B02820_05_26.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B02820_05_26.jpg)'
- en: Notice that you may get a messed up UI in the editor once you multiply everything
    with the `sizeMultiplier` variable. This is because the `width` variable may return
    as `0` in the editor. Hence, by multiplying `0` by `480`, you may get the result
    `0`, which makes the entire UI to look funny. However, it will look fine when
    running the actual program. If you want to preview the UI on the editor, temporarily
    set the `sizeMultiplier` to `1`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦您用`sizeMultiplier`变量乘以所有东西，您可能会在编辑器中得到一个混乱的UI。这是因为编辑器中的`width`变量可能返回为`0`。因此，将`0`乘以`480`，您可能会得到结果`0`，这会使整个UI看起来很滑稽。然而，在运行实际程序时，它会看起来很好。如果您想在编辑器中预览UI，请将`sizeMultiplier`临时设置为`1`。
- en: Integrating QML and C++
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成QML和C++
- en: Qt supports bridging between C++ classes with the QML engine. This combination
    allows developers to take advantage of both the simplicity of QML and the flexibility
    of C++. You can even integrate features that are not supported by Qt from an external
    library, then pass the resulting data to Qt Quick to be displayed in the UI. In
    this example, we will learn how to export our UI components from QML to the C++
    framework and manipulate their properties before displaying them on screen.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Qt支持在C++类和QML引擎之间进行桥接。这种组合允许开发人员充分利用QML的简单性和C++的灵活性。您甚至可以集成来自外部库的Qt不支持的功能，然后将生成的数据传递给Qt
    Quick以在UI中显示。在这个例子中，我们将学习如何将我们的UI组件从QML导出到C++框架，并在显示在屏幕上之前操纵它们的属性。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Once again, we will start everything from scratch. Therefore, create a new Qt
    Quick application project in Qt Creator and open up `MainForm.ui.qml`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次从头开始。因此，在Qt Creator中创建一个新的Qt Quick应用程序项目，并打开`MainForm.ui.qml`。
- en: We can keep the mouse area and text widget, but place the text widget at the
    bottom of the window. Change the **Text** property of the text widget to **Change
    this text using C++** and set its font size to `18`. After that, go to the **Layout**
    tab and enable both **Vertical center anchor** and **Horizontal center anchor**
    to ensure it's always somewhere in the middle of the window, regardless of how
    you rescale the window. Set the **Margin** for the **Vertical center anchor**
    to `120`:![How to do it…](img/B02820_05_27.jpg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以保留鼠标区域和文本小部件，但将文本小部件放在窗口底部。将文本小部件的**文本**属性更改为**使用C++更改此文本**，并将其字体大小设置为`18`。之后，转到**布局**选项卡，并启用**垂直中心锚点**和**水平中心锚点**，以确保它始终位于窗口中间的某个位置，无论如何重新调整窗口。将**垂直中心锚点**的**边距**设置为`120`：![如何做…](img/B02820_05_27.jpg)
- en: Next, drag a **Rectangle** widget from the **Library** window to the canvas
    and set its color to `#ff0d0d`. Set its **Width** and **Height** to `200` and
    enable both the vertical and horizontal center anchor. After that, set the **Margin**
    of the horizontal center anchor to `-14`. Your UI should now look something like
    this:![How to do it…](img/B02820_05_28.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从**库**窗口将**Rectangle**小部件拖动到画布上，并将其颜色设置为`#ff0d0d`。将其**宽度**和**高度**设置为`200`，并启用垂直和水平中心锚点。之后，将水平中心锚点的**边距**设置为`-14`。您的UI现在应该看起来像这样：![如何做…](img/B02820_05_28.jpg)
- en: Once you are done with that, right-click on your project directory in Qt Creator
    and choose **Add New**. Then, a window will pop up and let you pick a file template.
    Select **C++ Class** and press **Choose…**. After that, it will ask you to define
    the C++ class by filling in the information for the class. In this case, insert
    **MyClass** in the **Class Name** field and select **QObject** as the **Base class**.
    Then, make sure **Include QObject** option is ticked and you can now click the
    **Next** button, follow by the **Finish** button. Two files—`myclass.h` and `myclass.cpp`—will
    now be created and added to your project:![How to do it…](img/B02820_05_29.jpg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，在Qt Creator中右键单击项目目录，然后选择**添加新内容**。然后，将弹出一个窗口，让您选择文件模板。选择**C++类**并按**选择…**。之后，它将要求您填写类的信息来定义C++类。在这种情况下，在**类名**字段中插入**MyClass**，并选择**QObject**作为**基类**。然后，确保**包括QObject**选项已被选中，现在可以单击**下一步**按钮，然后单击**完成**按钮。现在将创建并添加两个文件—`myclass.h`和`myclass.cpp`—到您的项目中：![如何做…](img/B02820_05_29.jpg)
- en: 'Now, open up `myclass.h` and add a variable and function below the class constructor,
    like so:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`myclass.h`并在类构造函数下方添加变量和函数，如下所示：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After that, open up `myclass.cpp` and define the `setMyObject()` function:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`myclass.cpp`并定义`setMyObject()`函数：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now close `myclass.cpp` and open up `main.qml`. At the top of the file,
    add in the third line, which imports the custom library we just created in C++:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以关闭`myclass.cpp`并打开`main.qml`。在文件顶部添加第三行，导入我们刚在C++中创建的自定义库：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, define `MyClass` in the `Window` object and call its function `setMyObject()`
    within the `MainForm` object, like so:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Window`对象中定义`MyClass`并在`MainForm`对象中调用其函数`setMyObject()`，如下所示：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Lastly, open up `main.cpp` and register the custom class to the QML engine.
    We also change the properties of the text widget and the rectangle here using
    C++ code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`main.cpp`并将自定义类注册到QML引擎。我们还在这里使用C++代码更改文本小部件和矩形的属性：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Build and run the program now, and you should see the colors of the rectangle
    and the text are completely different from what you defined earlier in Qt Quick.
    This is because their properties have been changed by the C++ code:![How to do
    it…](img/B02820_05_30.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建和运行程序，您应该看到矩形和文本的颜色与您在Qt Quick中定义的完全不同。这是因为它们的属性已被C++代码更改：![如何做…](img/B02820_05_30.jpg)
- en: How it works…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: QML is designed to be easily extensible through C++ code. The classes in the
    Qt QML module enable QML objects to be loaded and manipulated from C++.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: QML旨在通过C++代码轻松扩展。Qt QML模块中的类使QML对象可以从C++中加载和操作。
- en: Only classes that are inherited from the `QObject` base class can be integrated
    with QML, as it is part of the Qt ecosystem. Once the class has been registered
    with the QML engine, we get the root item from the QML engine and use it to find
    the objects we want to manipulate. After that, use the `setProperty()` function
    to change any of the properties belong to the widget.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 只有从`QObject`基类继承的类才能与QML集成，因为它是Qt生态系统的一部分。一旦类已经在QML引擎中注册，我们就可以从QML引擎获取根项目，并使用它来查找我们想要操作的对象。之后，使用`setProperty()`函数来更改小部件的任何属性。
- en: Notice that the `Q_INVOKABLE` macro is required in front of the function that
    you intend to call in QML. Without it, Qt will not expose the function to Qt Quick
    and you will not be able to call it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Q_INVOKABLE`宏在您打算在QML中调用的函数前是必需的。没有它，Qt不会将函数暴露给Qt Quick，您将无法调用它。
