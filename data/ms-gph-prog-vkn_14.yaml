- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Adding Dynamic Diffuse Global Illumination with Ray Tracing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用光线追踪添加动态漫反射全局照明
- en: So far in this book, illumination has been based on direct lighting coming from
    point lights. In this chapter, we will enhance lighting by adding indirect lighting,
    often referred to as global illumination in the context of video games.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的照明一直基于来自点光源的直接照明。在本章中，我们将通过添加间接照明（在视频游戏环境中通常称为全局照明）来增强照明。
- en: This type of illumination comes from emulating the behavior of light. Without
    going into quantum physics and optics, the information we need to consider is
    that light bounces off surfaces a few times until its energy becomes zero.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种照明类型来源于模拟光的行为。不深入量子物理和光学，我们需要考虑的信息是光在表面反射几次，直到其能量变为零。
- en: Throughout movies and video games, global illumination has always been an important
    aspect of lighting, but often impossible to perform in real time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影和视频游戏中，全局照明一直是照明的一个重要方面，但通常无法实时执行。
- en: With movies, it often took minutes (if not hours) to render a single frame,
    until global illumination was pioneered. Video games were inspired by this and
    now include it in their lighting.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影中，渲染一帧通常需要几分钟（如果不是几个小时），直到全局照明被开创。视频游戏受到了这种启发，现在也包括了它在其照明中。
- en: 'In this chapter, we will discover how to implement real-time global illumination
    by covering these topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过涵盖以下主题来发现如何实现实时全局照明：
- en: Introduction to indirect lighting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间接照明简介
- en: Introduction to **Dynamic Diffuse Global** **Illumination** (**DDGI**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态漫反射全局照明（DDGI）简介
- en: Implementing DDGI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现DDGI
- en: Each topic will contain subsections so that you can expand upon the knowledge
    provided.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题都将包含子节，以便您可以扩展所提供知识。
- en: 'The following figure shows how the code from this chapter helps contribute
    to indirect lighting:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了本章中的代码如何帮助间接照明：
- en: '![Figure 14.1 – Indirect lighting output](img/B18395_14_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 间接照明输出](img/B18395_14_01.jpg)'
- en: Figure 14.1 – Indirect lighting output
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 间接照明输出
- en: In *Figure 14**.1*, the scene has a point light on the left. We can see the
    green color from the light bouncing off the left curtain onto the floor and the
    right pillars and curtains.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图14.1* 中，场景左侧有一个点光源。我们可以看到光线从左侧的窗帘反射到地板和右侧的柱子和窗帘上，形成了绿色。
- en: On the floor in the distance, we can see the color of the sky tinting the walls.
    The occlusion given by its visibility provides a very low light contribution to
    the arches.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在远处的地板上，我们可以看到天空的颜色染上了墙壁。由于它的可见性提供的遮挡，对拱门的光贡献非常低。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter14](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter14).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下网址找到：[https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter14](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter14)。
- en: Introduction to indirect lighting
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接照明简介
- en: Going back to direct and indirect lighting, direct lighting just shows the first
    interaction between light and matter, but light continues to travel in space,
    bouncing at times.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回到直接和间接照明，直接照明仅显示光与物质之间的第一次相互作用，但光继续在空间中传播，有时会反射。
- en: From a rendering perspective, we use the G-buffer information to calculate the
    first light interaction with surfaces that are visible from our point of view,
    but we have little data on what is outside of our view.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从渲染的角度来看，我们使用G缓冲区信息来计算从我们的视角可见的表面与光的第一次相互作用，但我们对我们视野之外的数据知之甚少。
- en: 'The following diagram shows direct lighting:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了直接照明：
- en: '![Figure 14.2 – Direct lighting](img/B18395_14_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 直接照明](img/B18395_14_02.jpg)'
- en: Figure 14.2 – Direct lighting
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 直接照明
- en: '*Figure 14**.2* describes the current lighting setup. There are light-emitting
    rays, and those rays interact with surfaces. Light bounces off these surfaces
    and is captured by the camera, becoming the pixel color. This is an extremely
    simplified vision of the phenomena, but it contains all the basics we need.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.2* 描述了当前的照明设置。有发光光线，这些光线与表面相互作用。光从这些表面上反射并被相机捕捉，成为像素颜色。这是一个对现象的极度简化视图，但它包含了我们需要的基本知识。'
- en: For indirect lighting, relying only on the camera’s point of view is insufficient
    as we need to calculate how other lights and geometries can contribute and still
    affect the visible part of the scene but are outside of the view, as well as the
    visible surfaces.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于间接照明，仅依靠摄像机的视角是不够的，因为我们还需要计算其他光线和几何形状如何贡献并仍然影响场景中可见的部分，即使它们位于视野之外，以及可见的表面。
- en: 'For this matter, **ray tracing** is the best tool: it’s a way to query the
    scene spacially as we can use it to calculate how different bounces of light contribute
    to the final value of a given fragment.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，**光线追踪**是最好的工具：它是一种查询场景空间的方法，我们可以用它来计算不同光线弹跳如何贡献到给定片段的最终值。
- en: 'Here is a diagram showing indirect lighting:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示间接照明的图表：
- en: '![Figure 14.3 – Indirect lighting](img/B18395_14_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 间接照明](img/B18395_14_03.jpg)'
- en: Figure 14.3 – Indirect lighting
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 间接照明
- en: '*Figure 14**.3* shows indirect rays bouncing off surfaces until they hit the
    camera again.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14.3*显示了间接光线从表面弹跳，直到再次击中摄像机。'
- en: 'There are two rays highlighted in this figure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图中突出显示了两个光线：
- en: '**Indirect Ray 0**, bouncing off a hidden surface onto the blue floor and finally
    into the camera'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间接光线0**，从隐藏表面弹跳到蓝色地板，最终进入摄像机'
- en: '**Indirect Ray 0**, bouncing off another surface and bouncing off the red wall,
    and finally into the camera'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间接光线0**，从另一个表面弹跳，然后从红色墙上弹跳，最终进入摄像机'
- en: With indirect illumination, we want to capture the phenomena of rays of light
    bouncing off surfaces, both hidden and not.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用间接照明，我们想要捕捉光线从表面弹跳的现象，无论是隐藏的还是可见的。
- en: For example, in this setup, there are some rays between the red and blue surfaces
    that will bounce within each other, tinting the closer parts of the surfaces of
    the respective colors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这个设置中，红色和蓝色表面之间存在一些光线，它们将在彼此之间弹跳，使相应颜色的表面较近的部分着色。
- en: Adding indirect illumination to lighting enhances the realism and visual quality
    of the image, but how can we achieve that?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将间接照明添加到照明中可以增强图像的真实感和视觉质量，但我们如何实现这一点呢？
- en: 'In the next section, we will talk about the implementation that we chose: **Dynamic
    Diffuse Global Illumination**, or **DDGI**, which was developed mainly by researchers
    at Nvidia but is rapidly becoming one of the most used solutions in AAA games.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论我们选择实现的方法：**动态漫反射全局照明**，或**DDGI**，这主要是由Nvidia的研究人员开发的，但正在迅速成为AAA游戏中使用最广泛的一种解决方案。
- en: Introduction to Dynamic Diffuse Global Illumination (DDGI)
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态漫反射全局照明（DDGI）简介
- en: 'In this section, we will explain the algorithm behind DDGI. DDGI is based on
    two main tools: light probes and irradiance volumes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释DDGI背后的算法。DDGI基于两个主要工具：光照探针和辐照度体积：
- en: '**Light probes** are points in space, represented as spheres, that encode light
    information'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光照探针**是空间中的点，表示为球体，它们编码了光线信息'
- en: '**Irradiance volumes** are defined as spaces that contain three-dimensional
    grids of light probes with fixed spacing between them'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**辐照度体积**定义为包含三维网格的光照探针的空间，探针之间有固定的间距'
- en: Sampling is easier when the layout is regular, even though we will see some
    improvements to placements later. Probes are encoded using octahedral mapping,
    a convenient way to map a square to a sphere. Links to the math behind octahedral
    mapping have been provided in the *Further* *reading* section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当布局规则时，采样更容易，尽管我们稍后会看到一些改进放置的方法。探针使用八面体映射进行编码，这是一种将正方形映射到球体的便捷方法。在*进一步阅读*部分提供了八面体映射背后的数学链接。
- en: 'The core idea behind DDGI is to dynamically update probes using ray tracing:
    for each probe, we will cast some rays and calculate the radiance at the triangle
    intersection. Radiance is calculated with the dynamic lights present in the engine,
    reacting in real time to any light or geometry changes.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: DDGI背后的核心思想是使用光线追踪动态更新探针：对于每个探针，我们将发射一些光线并计算三角形交点的辐射度。辐射度是通过引擎中动态存在的光源计算的，能够实时响应任何光线或几何形状的变化。
- en: 'Given the low resolution of the grid compared to the pixels on the screen,
    the only lighting phenomenon possible is diffuse lighting. The following diagram
    provides an overview of the algorithm, showing the relationships and the sequences
    between shaders (green rectangles) and textures (yellow ellipses):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网格的分辨率相对于屏幕上的像素较低，唯一可能的光照现象就是漫反射。以下图表概述了算法，显示了着色器（绿色矩形）和纹理（黄色椭圆）之间的关系和顺序：
- en: '![Figure 14.4 – Algorithm overview](img/B18395_14_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 算法概述](img/B18395_14_04.jpg)'
- en: Figure 14.4 – Algorithm overview
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 算法概述
- en: 'Let’s provide a quick overview of the algorithm before looking at each step
    in detail:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细查看每个步骤之前，让我们快速概述一下算法：
- en: Perform ray tracing for each probe and calculate the radiance and distance.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个探针执行光线追踪并计算辐射度和距离。
- en: Update the irradiance of all probes with the radiance calculated while applying
    some hysteresis.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一些滞后更新所有探针的辐照度，同时使用计算出的辐射度。
- en: Update the visibility data of all probes with the distance calculated in the
    ray tracing pass, again with some hysteresis.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用光线追踪过程中的距离更新所有探针的可见性数据，再次使用一些滞后。
- en: (Optional) Calculate the per-probe offset position using the ray tracing distance.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）使用光线追踪距离计算每个探针的偏移位置。
- en: Calculate indirect lighting by reading the updated irradiance, visibility, and
    probe offsets.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过读取更新的辐照度、可见性和探针偏移来计算间接光照。
- en: In the following subsections, we will cover each step of the algorithm.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将介绍算法的每个步骤。
- en: Ray tracing for each probe
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对每个探针进行光线追踪
- en: This is the first step of the algorithm. For each ray of each probe that needs
    an update, we must ray trace the scene using dynamic lighting.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是算法的第一步。对于每个需要更新的探针的每条射线，我们必须使用动态光照对场景进行光线追踪。
- en: In the ray tracing hit shader, we calculate the world position and normal of
    the hit triangle and perform a simplified diffuse lighting calculation. Optionally,
    but more expensive, we can read the other irradiance probes to add an infinite
    number of bounces to the lighting calculation, giving it an even more realistic
    look.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在光线追踪的击中着色器中，我们计算击中三角形的全局位置和法线，并执行简化的漫反射光照计算。可选的，但成本更高，我们可以读取其他辐照度探头来为光照计算添加无限次的反弹，使其看起来更加逼真。
- en: 'Especially important here is the texture layout: each row represents the rays
    for a single probe. So, if we have 128 rays per probe, we will have a row of 128
    texels, while each column represents a probe.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里特别重要的是纹理布局：每一行代表单个探针的射线。因此，如果我们每个探针有128条射线，我们将有一个128个texels的行，而每一列代表一个探针。
- en: Thus, a configuration with 128 rays and 24 probes will result in a 128x24 texture
    dimension. We store the lighting calculation as radiance in the RGB channels of
    the texture, and the hit distance in the Alpha channel.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，具有128条射线和24个探针的配置将产生128x24的纹理维度。我们将光照计算作为辐射度存储在纹理的RGB通道中，并将击中距离存储在Alpha通道中。
- en: Hit distance will be used to help with light leaks and calculating probe offsets.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 击中距离将用于帮助处理光泄漏和计算探针偏移。
- en: Probes offsetting
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探针偏移
- en: Probes offsetting is a step that’s done when an irradiance volume is loaded
    into the world, or its properties are changed (such as spacing or position). Using
    the hit distances from the ray tracing step, we can calculate if a probe is placed
    straight into a surface and then create an offset for it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当辐照度体积被加载到世界中或其属性发生变化（如间距或位置）时，会执行探针偏移步骤。使用光线追踪步骤中的击中距离，我们可以计算探针是否直接放置在表面上，然后为其创建偏移量。
- en: The offsetting amount cannot be bigger than half the distance to other probes
    so that the grid still maintains some coherency between the grid indices and their
    position. This step is only done a few times (normally, around five is a suitable
    number) as having it run continuously will indefinitely move the probes, thus
    causing light flickering.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量不能大于到其他探针距离的一半，这样网格仍然在网格索引和它们的位置之间保持一定的连贯性。这一步骤只执行几次（通常，大约五次是一个合适的数字），因为持续执行会导致探针无限移动，从而引起光闪烁。
- en: Once the offsets have been calculated, every probe will have the final world
    position, drastically increasing the visual quality of indirect lighting.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出偏移量，每个探针都将具有最终的全局位置，这极大地提高了间接光照的视觉效果。
- en: 'Here, we can see the improvement after calculating these offsets:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到计算这些偏移量后的改进：
- en: '![ Figure 14.5 – Global illumination with (left) and without (right) probe
    offsets](img/B18395_14_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 带有（左）和没有（右）探针偏移的全局光照](img/B18395_14_05.jpg)'
- en: Figure 14.5 – Global illumination with (left) and without (right) probe offsets
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 带有（左）和没有（右）探针偏移的全局光照
- en: As you can see, the probes that are inside a geometry not only give no lighting
    contribution to the sampling but can create visual artifacts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，位于几何体内部的探针不仅不会对采样做出光照贡献，还可以创建视觉伪影。
- en: Thanks to probe offsetting, we can place probes in a better position.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了探针偏移，我们可以将探针放置在更好的位置。
- en: Probes irradiance and visibility updates
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探针辐照度和可见性更新
- en: We now have the result of each ray that’s been traced for each probe with dynamic
    lighting applied. How can we encode this information? As seen in the *Introduction
    to Dynamic Diffuse Global Illumination (DDGI)* section, one of the ways is to
    use octahedral mapping, which unwraps a sphere into a rectangle.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了每个探针在应用动态光照后追踪的每条射线的结果。我们如何编码这些信息？如*动态漫反射全局照明（DDGI）简介*部分所示，其中一种方法就是使用八面体映射，它将球体展开成矩形。
- en: Given that we are storing each probe’s radiance as a 3D volume, we need a texture
    that contains a rectangle for each probe. We will choose to create a single texture
    with a row that contains a *layer* of probes as MxN, while the height contains
    the other layers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将每个探针的辐照度存储为一个3D体积，我们需要一个包含每个探针矩形的纹理。我们将选择创建一个包含MxN个探针层的一行纹理，而高度包含其他层。
- en: For example, if we have a grid of 3x2x4 probes, each row will contain 6 probes
    (3x2) and the final texture will have 4 rows. We will execute this step two times,
    one to update the irradiance from the radiance, and the other to update the visibility
    from the distance of each probe.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个3x2x4的探针网格，每一行将包含6个探针（3x2），最终纹理将有4行。我们将执行这个步骤两次，一次用于从辐照度更新辐照度，另一次用于从每个探针的距离更新可见性。
- en: Visibility is crucial for minimizing light leaks, and irradiance and visibility
    are stored in different textures and can have different sizes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性对于最小化光泄漏至关重要，辐照度和可见性存储在不同的纹理中，并且可以有不同的尺寸。
- en: One thing to be aware of is that to add support for bilinear filtering, we need
    to store an additional 1-pixel border around each rectangle; this will be updated
    here as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，为了添加对双线性过滤的支持，我们需要在每个矩形周围存储一个额外的1像素边框；这在这里也会更新。
- en: The shader will read the new radiance and distances calculated and the previous
    frame’s irradiance and visibility textures to blend the values to avoid flickering,
    as Volumetric Fog does with temporal reprojection, using a simple hysteresis.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器将读取计算出的新辐照度和距离，以及前一帧的辐照度和可见性纹理，以混合值以避免闪烁，就像体量雾使用时间重投影那样，通过简单的滞后效应来实现。
- en: Hysteresis can be changed dynamically if the lighting conditions change drastically
    to counteract slow updates using hysteresis. The results will normally be slower
    to react to light movements, but it is a drawback needed to avoid flickering.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果光照条件发生剧烈变化，滞后效应可以动态地改变，以对抗使用滞后效应的缓慢更新。结果通常对光运动的反应较慢，但这是为了避免闪烁而必须接受的缺点。
- en: 'The last part of the shader involves updating the borders for bilinear filtering.
    Bilinear filtering requires samples to be read in a specific order, as highlighted
    in the following diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的最后部分涉及更新双线性过滤的边缘。双线性过滤需要按照特定的顺序读取样本，如下面的图所示：
- en: '![Figure 14.6 – Bilinear filtering samples. The outer grid copies pixels from
    the written pixel positions inside each rectangle](img/B18395_14_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 双线性过滤样本。外部网格复制每个矩形内写入的像素位置](img/B18395_14_06.jpg)'
- en: Figure 14.6 – Bilinear filtering samples. The outer grid copies pixels from
    the written pixel positions inside each rectangle
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 双线性过滤样本。外部网格复制每个矩形内写入的像素位置
- en: '*Figure 14**.6* shows the coordinate calculations for copying pixels: the center
    area is the one that did the full irradiance/visibility update, while the borders
    copy the values from the pixels at the specified coordinates.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14**.6* 展示了复制像素的坐标计算：中心区域是执行了完整的辐照度/可见性更新的区域，而边缘则复制指定坐标处的像素值。'
- en: We will run two different shaders – one to update probe irradiance and one to
    update probe visibility.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行两个不同的着色器 – 一个用于更新探针辐照度，另一个用于更新探针可见性。
- en: In the shader code, we will see the actual code to do this. We are now ready
    to sample the irradiance of the probes, as seen in the next subsection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器代码中，我们将看到实际执行此操作的代码。我们现在准备好采样探针的辐照度，如下一小节所示。
- en: Probes sampling
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探针采样
- en: This step involves reading the irradiance probes and calculating the indirect
    lighting contribution. We will render from the main camera’s point of view, and
    we will sample the eight closest probes given a world position and direction.
    The visibility texture is used to minimize leakage and soften the lighting results.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步涉及读取辐照度探针并计算间接光照贡献。我们将从主相机的视角进行渲染，并且给定一个世界位置和方向，我们将采样最近的八个探针。可见性纹理用于最小化泄漏并软化光照结果。
- en: Given the soft lighting nature of diffuse indirect components and to obtain
    better performance, we have opted to sample this at a quarter resolution, so we
    need to take extra care of where we sample to avoid pixel inaccuracies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于漫反射间接组件具有软光照特性，为了获得更好的性能，我们选择在四分之一分辨率下采样，因此我们需要特别注意采样位置以避免像素不精确。
- en: While looking at probe ray tracing, irradiance updates, visibility updates,
    probe offsetting, and probe sampling, we described all the basic steps necessary
    to have a working DDGI implementation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看探针光线追踪、辐照度更新、可见性更新、探针偏移和探针采样时，我们描述了实现DDGI所需的所有基本步骤。
- en: Other steps can be included to make the rendering even faster, such as using
    the distances to calculate inactive probes. Other extensions can also be included,
    such as those that contain a cascade of volumes and hand-placed volumes that give
    DDGI the best flexibility needed to be used in video games, where different hardware
    configurations can dictate algorithmic choices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以包括其他步骤来使渲染更快，例如使用距离来计算非活动探针。还可以包括其他扩展，例如包含一系列体积和手动放置的体积，这些体积为DDGI提供了在视频游戏中使用的最佳灵活性，因为不同的硬件配置可以决定算法选择。
- en: In the next section, we will learn how to implement DDGI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何实现DDGI。
- en: Implementing DDGI
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现DDGI
- en: The first shaders we will read are the ray tracing shaders. These, as we saw
    in [*Chapter 12*](B18395_12.xhtml#_idTextAnchor205), *Getting Started with Ray
    Tracing*, come as a bundle that includes the ray-generation, ray-hit, and ray-miss
    shaders.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先读取的是光线追踪着色器。正如我们在[*第12章*](B18395_12.xhtml#_idTextAnchor205)中看到的，“开始使用光线追踪”，这些着色器作为一个包含光线生成、光线击中和光线丢失着色器的包提供。
- en: There are a set of different methods that convert from world space into grid
    indices and vice versa that will be used here; they are included with the code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将使用一组不同的方法将世界空间转换为网格索引，反之亦然，这些方法将在这里使用；它们包含在代码中。
- en: 'First, we want to define the ray payload – that is, the information that’s
    cached after the ray tracing query is performed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要定义射线负载——即在光线追踪查询执行后缓存的那些信息：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ray-generation shader
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光线生成着色器
- en: The first shader is called ray-generation. It spawns rays from the probe’s position
    using random directions on a sphere using spherical Fibonacci sequences.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个着色器称为光线生成。它使用球面上的随机方向和球面斐波那契序列从探针位置生成光线。
- en: 'Like dithering for TAA and Volumetric Fog, using random directions and temporal
    accumulation (which happens in the Probe Update shader) allows us to have more
    information about the scene, thus enhancing the visuals:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就像TAA和体积雾的抖动一样，使用随机方向和时间累积（在探针更新着色器中发生）可以让我们获得更多关于场景的信息，从而增强视觉效果：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ray-hit shader
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光线击中着色器
- en: This is where all the heavy lifting happens.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有重负载发生的地方。
- en: 'First, we must declare the payload and the barycentric coordinates to calculate
    the correct triangle data:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须声明负载和重心坐标来计算正确的三角形数据：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, check for back-facing triangles, storing only the distance as lighting
    is not needed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检查背面三角形，只存储距离，因为不需要光照：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Otherwise, calculate the triangle data and perform lighting:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，计算三角形数据并执行光照：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, read the mesh instance data and read the index buffer:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，读取网格实例数据和索引缓冲区：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can read the vertices from the mesh buffer and calculate the world
    space position:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从网格缓冲区读取顶点并计算世界空间位置：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Calculate the world position:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 计算世界位置：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we did for the vertex positions, read the UV buffer and calculate the final
    UVs of the triangle:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就像读取顶点位置一样，读取UV缓冲区并计算三角形的最终UV值：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Read the diffuse texture. We can also read a lower MIP to improve performance:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 读取漫反射纹理。我们还可以读取较低的MIP级别以改善性能：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Read the triangle normals and calculate the final normal. You don’t need to
    read the normal texture as the cached result is so small that those details are
    lost:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 读取三角形法线并计算最终法线。您不需要读取法线纹理，因为缓存的计算结果非常小，这些细节已经丢失：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can calculate the world position and the normal, and then calculate the
    direct lighting:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算世界位置和法线，然后计算直接光照：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we can cache the radiance and the distance:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以缓存辐射度和距离：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let’s write the results to the payload:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将结果写入负载：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ray-miss shader
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光线丢失着色器
- en: 'In this shader, we simply return the sky color. Alternatively, if present,
    an environment cube map can be added:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个着色器中，我们简单地返回天空颜色。或者，如果存在，可以添加环境立方体贴图：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Updating probes irradiance and visibility shaders
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新探测器的辐照度和可见性着色器
- en: This compute shader will read the previous frame’s irradiance/visibility and
    the current frame’s radiance/distance and update the octahedral representation
    of each probe. This shader will be executed twice – once to update the irradiance
    and once to update the visibility. It will also update the borders to add support
    for bilinear filtering.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算着色器将读取前一帧的辐照度/可见性和当前帧的辐射/距离，并更新每个探测器的八面体表示。这个着色器将执行两次——一次用于更新辐照度，一次用于更新可见性。它还将更新边界以支持双线性过滤。
- en: 'First, we must check if the current pixel is a border. If so, we must change
    modes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须检查当前像素是否是边界。如果是，我们必须更改模式：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For non-border pixels, calculate a weight based on ray direction and the direction
    of the sphere encoded with octahedral coordinates, and calculate the irradiance
    as the summed weight of the radiances:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非边界像素，根据射线方向和用八面体坐标编码的球体方向计算权重，并将辐照度计算为辐射的总权重：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the contribution from each ray:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 添加每个射线的贡献：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Read the distance for this ray and early out if there are too many back faces:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 读取这个射线的距离，如果背面太多则提前退出：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, depending on if we are updating the irradiance or the visibility,
    we perform different calculations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，根据我们是在更新辐照度还是可见性，我们将执行不同的计算。
- en: 'For **irradiance**, we must do the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**辐照度**，我们必须做以下事情：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For **visibility**, we must read and limit the distance:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**可见性**，我们必须读取并限制距离：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, apply the weight:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用权重：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we can read the previous frame’s irradiance or visibility and blend it
    using hysteresis.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以读取前一帧的辐照度或可见性，并使用滞后性进行混合。
- en: 'For **irradiance**, we must do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**辐照度**，我们必须做以下事情：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For **visibility**, we must do the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**可见性**，我们必须做以下事情：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, we end the shader for non-border pixels. We will wait for the
    local group to finish and copy the pixels to the borders:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们结束非边界像素的着色器。我们将等待局部组完成并将像素复制到边界：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we must operate on the border pixels.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须处理边界像素。
- en: Given that we are working on a local thread group that’s as big as each square,
    when a group is finished, we can copy the border pixels with the currently updated
    data. This is an optimization process that helps us avoid dispatching two other
    shaders and adding barriers to wait for the updates to be done.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理一个与每个正方形一样大的本地线程组，当组完成时，我们可以使用当前更新的数据复制边界像素。这是一个优化过程，有助于我们避免调度其他两个着色器并添加屏障等待更新完成。
- en: 'After implementing the preceding code, we must wait for the group to finish:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现前面的代码后，我们必须等待组完成：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once those barriers are in the shader code, all the groups will be completed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些屏障在着色器代码中，所有组都将完成。
- en: We have the final irradiance/visibility stored in the texture, so we can copy
    the border pixels to add bilinear sampling support. As shown in *Figure 14**.6*,
    we need to read the pixels in a specific order to ensure bilinear filtering is
    working properly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有最终存储在纹理中的辐照度/可见性，因此我们可以复制边界像素以添加双线性采样支持。如图*图14**.6*所示，我们需要按特定顺序读取像素以确保双线性过滤正常工作。
- en: 'First, we must calculate the source pixel coordinates:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须计算源像素坐标：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we must copy the source pixels to the current border.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将源像素复制到当前边界。
- en: 'For **irradiance**, we must do the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**辐照度**，我们必须做以下事情：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For **visibility**, we must do the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**可见性**，我们必须做以下事情：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We now have the updated irradiance and visibility ready to be sampled by the
    scene.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了更新的辐照度和可见性，准备好被场景采样。
- en: Indirect lighting sampling
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间接光照采样
- en: This compute shader is responsible for reading the indirect irradiance so that
    it’s ready to be used by the illumination. It uses a utility method called `sample_irradiance`,
    which is also used inside the ray-hit shader to simulate an infinite bounce.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算着色器负责读取间接辐照度，以便它可用于照明。它使用一个名为`sample_irradiance`的实用方法，该方法也用于射线命中着色器以模拟无限反弹。
- en: 'First, though, let’s look at the compute shader. When using the quarter resolution,
    cycle through a neighborhood of 2x2 pixels and get the closest depth, and save
    the pixel index:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看计算着色器。当使用四分之一分辨率时，遍历2x2像素的邻域，获取最近的深度，并保存像素索引：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With the cached index of the closest depth, read the normal as well:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最近深度的缓存索引读取法线：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have calculated the depth and the normal, we can gather the world
    position and use the normal to sample the irradiance:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了深度和法线，我们可以收集世界位置并使用法线来采样辐照度：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The second part of this shader is about the `sample_irradiance` function, which
    does the actual heavy lifting.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的第二部分是关于`sample_irradiance`函数，它执行实际的重负载。
- en: 'It starts by calculating a bias vector to move the sampling so that it’s a
    little bit in front of the geometry, to help with leaks:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先计算一个偏差向量，将采样移动到几何体前方一点，以帮助解决泄漏问题：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We now have the grid world position and indices at the sampling world position
    (plus the bias).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了采样世界位置（加上偏差）的网格世界位置和索引。
- en: 'Now, we must calculate a per-axis value of where the sampling position is within
    the cell:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须计算采样位置在单元格内的每个轴上的值：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At this point, we can sample the eight adjacent probes to the sampling point:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以采样采样点的八个相邻探头：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For each probe, we must calculate its world space position from the indices:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个探头，我们必须根据索引计算其世界空间位置：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Compute the trilinear weights based on the grid cell vertex to smoothly transition
    between probes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 根据网格单元顶点计算三线性权重，以在探头之间平滑过渡：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, we can see how the visibility texture is used. It stores depth and depth
    squared values, and helps tremendously with light leaking.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到如何使用可见性纹理。它存储深度和深度平方值，对防止光泄漏有很大帮助。
- en: 'This test is based on variance, such as Variance Shadow Map:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试基于方差，例如方差阴影图：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Check if the sampled probe is in “shadow” and calculate the Chebyshev weight:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 检查采样探头是否处于“阴影”中，并计算Chebyshev权重：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With the weight calculated for this probe, we can apply the trilinear offset,
    read the irradiance, and calculate its contribution:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用为此探头计算的权重，我们可以应用三线性偏移，读取辐照度，并计算其贡献：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With all the probes sampled, the final irradiance is scaled accordingly and
    returned:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在采样所有探头后，最终辐照度相应缩放并返回：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With that, we’ve finished looking at the irradiance sampling compute shader
    and utility functions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经完成了对辐照度采样计算着色器和实用函数的查看。
- en: More filters can be applied to the sampling to further smooth the image, but
    this is the most basic version that’s enhanced by the visibility data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用更多过滤器来平滑采样，但这是由可见性数据增强的最基本版本。
- en: Now, let’s learn how the `calculate_lighting` method can be modified to add
    diffuse indirect.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何修改`calculate_lighting`方法以添加漫反射间接光照。
- en: Modifications to the calculate_lighting method
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对`calculate_lighting`方法的修改
- en: 'In our `lighting.h` shader file, add the following lines once the direct lighting
    computations have been done:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`lighting.h`着色器文件中，一旦完成直接光照计算，添加以下行：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `base_colour` is the albedo coming from the G-buffer and `final_color`
    is the pixel color with all the direct lighting contributions calculated.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`base_colour`是从G缓冲区来的漫反射，而`final_color`是计算了所有直接光照贡献的像素颜色。
- en: 'The basic algorithm is complete, but there is one last shader to have a look
    at: the Probe Offset shader. It calculates a per-probe world-space offset to avoid
    intersecting probes with geometries.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 基本算法已完成，但还有最后一个着色器要查看：探头偏移着色器。它计算每个探头的世界空间偏移量，以避免探头与几何体相交。
- en: Probe offsets shader
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探头偏移着色器
- en: This compute shader cleverly uses the per-ray distances coming from the ray
    tracing pass to calculate the offset based on backface and frontface counts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此计算着色器巧妙地使用来自射线追踪传递的每条射线距离来根据后表面和前表面计数计算偏移量。
- en: 'First, we must check for an invalid probe index to avoid writing to the wrong
    memory:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须检查无效的探头索引以避免写入错误的内存：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, we must search for front and backface hits based on the ray tracing distance
    that’s been calculated.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须根据已计算的射线追踪距离搜索前表面和后表面击中点：
- en: 'First, declare all the necessary variables:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明所有必要的变量：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For each ray of this probe, read the distance and calculate if it is a front
    or backface. We store negative distances for backfaces in the hit shader:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个探头的每条射线，读取距离并计算它是否是前表面或后表面。我们在击中着色器中存储后表面的负距离：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We know the front and backface indices and distances for this probe. Given
    that we incrementally move the probe, read the previous frame’s offset:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这个探头的正面和背面索引及距离。鉴于我们逐步移动探头，读取前一帧的偏移量：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we must check if the probe can be considered inside a geometry and calculate
    an offset moving away from that direction, but within the probe spacing limit,
    that we can call a `cell`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须检查探测器是否可以被认为是位于几何体内部，并计算一个偏离该方向的偏移量，但在这个探测器的间距限制内，我们可以称之为“单元格”：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Find the maximum offset inside the cell to move the probe:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元格内找到最大偏移量以移动探测器：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we have not hit a backface, we must move the probe slightly to put it in
    a resting position:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有击中背面，我们必须稍微移动探测器，使其处于静止位置：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Update the offset only if it is within the spacing or inside the cell limits.
    Then, store the value in the appropriate texture:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在偏移量在间距或单元格限制内时才更新偏移量。然后，将值存储在适当的纹理中：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With that, we have calculated the probe offsets.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就计算了探测器的偏移量。
- en: Again, this shader demonstrates how to cleverly use information you already
    have – in this case, the per-ray probe distances – to move probes outside of intersecting
    geometries.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个着色器展示了如何巧妙地使用你已有的信息——在这种情况下，每条光线的探测器距离——将探测器移动到相交几何体之外。
- en: We presented a fully funcitonal version of DDGI, but there are some improvements
    that can be made and the technique can be expanded in different directions. Some
    examples of improvements are a classification system to disable non contributing
    probes, or adding a moving grid with cascades of different grid spacing centered
    around the camera. Combined with hand-placed volumes can create a complete diffuse
    global-illumination system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了DDGI的完整功能版本，但还有一些改进可以做出，该技术可以在不同方向上扩展。一些改进的例子包括一个分类系统来禁用非贡献探测器，或者添加一个围绕相机中心具有不同网格间距的移动网格。与手动放置的体积结合，可以创建一个完整的漫反射全局照明系统。
- en: While having a GPU with ray-tracing capabilities is necessary for this technique,
    we could bake irradiance and visibility for static scene parts and use them on
    older GPUs. Another improvement can be changing hysteresis based on probe luminance
    changes, or adding a staggered probe update based on distance and importance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拥有具有光线追踪功能的GPU对于这项技术是必要的，但我们可以在静态场景部分烘焙辐照度和可见性，并在较旧的GPU上使用它们。另一个改进可以根据探测器的亮度变化更改滞后性，或者根据距离和重要性添加基于距离的交错探测器更新。
- en: All these ideas show how powerful and configurable DDGI is and we encourage
    the reader to experiment and create other improvements.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些想法都展示了DDGI是多么强大和可配置，我们鼓励读者进行实验并创造其他改进。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the DDGI technique. We started by talking about
    global illumination, the lighting phenomena that is implemented by DDGI. Then,
    we provided an overview of the algorithm, explaining each step in more detail.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了DDGI技术。我们首先讨论了全局照明，这是DDGI实现的照明现象。然后，我们概述了该算法，并更详细地解释了每个步骤。
- en: Finally, we wrote and commented on all the shaders in the implementation. DDGI
    already enhances the lighting of the rendered frame, but it can be improved and
    optimized.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对实现中的所有着色器进行了编写和注释。DDGI已经增强了渲染帧的照明，但它可以进一步改进和优化。
- en: 'One of the aspects of DDGI that makes it useful is its configurability: you
    can change the resolution of irradiance and visibility textures and change the
    number of rays, number of probes, and spacing of probes to support lower-end ray
    tracing-enabled GPUs.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: DDGI的一个使其有用的方面是其可配置性：你可以更改辐照度和可见性纹理的分辨率，并更改光线的数量、探测器的数量和探测器的间距，以支持低端具有光线追踪功能的GPU。
- en: 'In the next chapter we are going to add another element that will help us increase
    the accuracy of our lighting solution: reflections!'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加另一个元素，这将帮助我们提高照明解决方案的准确性：反射！
- en: Further reading
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Global illumination is an incredibly big topic that’s covered extensively in
    all rendering literature, but we wanted to highlight links that are more connected
    to the implementation of DDGI.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 全局照明是一个非常大的主题，在所有渲染文献中都有广泛的覆盖，但我们想强调与DDGI实现更紧密相关的链接。
- en: DDGI itself is an idea that mostly came from a team at Nvidia in 2017, with
    the central ideas described at [https://morgan3d.github.io/articles/2019-04-01-ddgi/index.xhtml](https://morgan3d.github.io/articles/2019-04-01-ddgi/index.xhtml).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: DDGI本身是一个主要来自2017年Nvidia团队的想法，其核心思想在[https://morgan3d.github.io/articles/2019-04-01-ddgi/index.xhtml](https://morgan3d.github.io/articles/2019-04-01-ddgi/index.xhtml)中进行了描述。
- en: 'The original articles on DDGI and its evolution are as follows. They also contain
    supplemental code that was incredibly helpful in implementing the technique:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: DDGI及其演变的原始文章如下。它们还包含了一些非常有帮助的补充代码，这些代码在实现该技术时极为有用：
- en: '[https://casual-effects.com/research/McGuire2017LightField/index.xhtml](https://casual-effects.com/research/McGuire2017LightField/index.xhtml)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://casual-effects.com/research/McGuire2017LightField/index.xhtml](https://casual-effects.com/research/McGuire2017LightField/index.xhtml)'
- en: '[https://www.jcgt.org/published/0008/02/01/](https://www.jcgt.org/published/0008/02/01/)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.jcgt.org/published/0008/02/01/](https://www.jcgt.org/published/0008/02/01/)'
- en: '[https://jcgt.org/published/0010/02/01/](https://jcgt.org/published/0010/02/01/)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jcgt.org/published/0010/02/01/](https://jcgt.org/published/0010/02/01/)'
- en: 'The following is a great overview of DDGI with Spherical Harmonics support,
    and the only diagram to copy the border pixels for bilinear interpolation. It
    also describes other interesting topics: [https://handmade.network/p/75/monter/blog/p/7288-engine_work__global_illumination_with_irradiance_probes](https://handmade.network/p/75/monter/blog/p/7288-engine_work__global_illumination_with_irradiance_probes).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对具有球谐函数支持的DDGI的精彩概述，以及唯一一个用于双线性插值复制边界像素的图表。它还描述了其他有趣的主题：[https://handmade.network/p/75/monter/blog/p/7288-engine_work__global_illumination_with_irradiance_probes](https://handmade.network/p/75/monter/blog/p/7288-engine_work__global_illumination_with_irradiance_probes)。
- en: The DDGI presentation by Nvidia can be found at [https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9900-irradiance-fields-rtx-diffuse-global-illumination-for-local-and-cloud-graphics.pdf](https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9900-irradiance-fields-rtx-diffuse-global-illumination-for-local-and-cloud-graphics.pdf).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在Nvidia的DDGI演示文稿中找到：[https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9900-irradiance-fields-rtx-diffuse-global-illumination-for-local-and-cloud-graphics.pdf](https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9900-irradiance-fields-rtx-diffuse-global-illumination-for-local-and-cloud-graphics.pdf)。
- en: 'The following is an intuitive introduction to global illumination: [https://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing](https://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对全局照明的直观介绍：[https://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing](https://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing)。
- en: '*Global Illumination* *Compendium*: [https://people.cs.kuleuven.be/~philip.dutre/GI/](https://people.cs.kuleuven.be/~philip.dutre/GI/).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局照明* *汇编*: [https://people.cs.kuleuven.be/~philip.dutre/GI/](https://people.cs.kuleuven.be/~philip.dutre/GI/)。'
- en: 'Finally, here is the greatest website for real-time rendering: [https://www.realtimerendering.com/](https://www.realtimerendering.com/).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是实时渲染的最佳网站：[https://www.realtimerendering.com/](https://www.realtimerendering.com/)。
