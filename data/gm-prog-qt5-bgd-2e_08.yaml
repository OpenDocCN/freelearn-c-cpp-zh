- en: Custom Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义小部件
- en: We have so far been using only ready-made widgets for the user interface, which
    resulted in the crude approach of using buttons for a tic-tac-toe game. In this
    chapter, you will learn about much of what Qt has to offer with regard to custom
    widgets. This will let you implement your own painting and event handling, incorporating
    content that is entirely customized.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止一直在使用现成的用户界面小部件，这导致了使用按钮进行井字棋游戏的粗糙方法。在本章中，你将了解Qt在自定义小部件方面提供的许多功能。这将使你能够实现自己的绘制和事件处理，并融入完全定制的内容。
- en: 'The main topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: Working with `QPainter`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QPainter`
- en: Creating custom widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义小部件
- en: Image handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理
- en: Implementing a chess game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个棋盘游戏
- en: Raster and vector graphics
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光栅和矢量图形
- en: When it comes to graphics, Qt splits this domain into two separate parts. One
    of them is raster graphics (used by widgets and the Graphics View, for example).
    This part focuses on using high-level operations (such as drawing lines or filling
    rectangles) to manipulate colors of a grid of points that can be visualized on
    different devices, such as images, printers, or the display of your computer device.
    The other is vector graphics, which involves manipulating vertices, triangles,
    and textures. This is tailored for maximum speed of processing and display, using
    hardware acceleration provided by modern graphics cards.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到图形时，Qt将这个领域分为两个独立的部分。其中之一是光栅图形（例如，由小部件和图形视图使用）。这部分侧重于使用高级操作（如绘制线条或填充矩形）来操纵可以可视化在不同设备上的点的颜色网格，例如图像、打印机或你的计算机设备的显示。另一个是矢量图形，它涉及操纵顶点、三角形和纹理。这是针对处理和显示的最大速度，使用现代显卡提供的硬件加速。
- en: 'Qt abstracts graphics using the concept of a surface (represented by the `QSurface` class)
    that it draws on. The type of the surface determines which drawing operations
    can be performed on the surface: surfaces that support software rendering and
    raster graphics have the `RasterSurface` type, and surfaces that support the OpenGL
    interface have the `OpenGLSurface` type. In this chapter, you will deepen your
    knowledge of Qt''s raster painting system. We will come back to the topic of OpenGL
    in the next chapter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Qt使用表面（由`QSurface`类表示）的概念来抽象图形，它在表面上绘制。表面的类型决定了可以在表面上执行哪些绘图操作：支持软件渲染和光栅图形的表面具有`RasterSurface`类型，而支持OpenGL接口的表面具有`OpenGLSurface`类型。在本章中，你将深化你对Qt光栅绘制系统的了解。我们将在下一章回到OpenGL的话题。
- en: '`QSurface` objects can have other types, but they are needed less often. `RasterGLSurface`
    is intended for internal Qt use. `OpenVGSurface` supports OpenVG (a hardware accelerated
    2D vector graphics API) and is useful on embedded devices that support OpenVG
    but lack OpenGL support. Qt 5.10 introduces `VulkanSurface`, which supports Vulkan
    graphics API.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSurface`对象可以有其他类型，但它们需要的频率较低。`RasterGLSurface`旨在供Qt内部使用。`OpenVGSurface`支持OpenVG（一个硬件加速的2D矢量图形API），在支持OpenVG但缺乏OpenGL支持的嵌入式设备上很有用。Qt
    5.10引入了`VulkanSurface`，它支持Vulkan图形API。'
- en: Raster painting
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光栅绘制
- en: When we talk about GUI frameworks, raster painting is usually associated with
    drawing on widgets. However, since Qt is something more than a GUI toolkit, the
    scope of raster painting that it offers is much broader.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论GUI框架时，光栅绘制通常与在控件上绘制相关联。然而，由于Qt不仅仅是GUI工具包，它提供的光栅绘制的范围要广泛得多。
- en: In general, Qt's drawing architecture consists of three parts. The most important
    part is the device the drawing takes place on, represented by the `QPaintDevice`
    class. Qt provides a number of paint device subclasses, such as `QWidget` or `QImage`
    and `QPrinter` or `QPdfWriter`. You can see that the approach for drawing on a
    widget and printing on a printer is quite the same. The difference is in the second
    component of the architecture—the paint engine (`QPaintEngine`). The engine is
    responsible for performing the actual paint operations on a particular paint device.
    Different paint engines are used to draw on images and to print on printers. This
    is completely hidden from you, as a developer, so you really don't need to worry
    about it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Qt的绘图架构由三个部分组成。其中最重要的部分是绘图发生的设备，由`QPaintDevice`类表示。Qt提供了一系列的绘图设备子类，例如`QWidget`或`QImage`和`QPrinter`或`QPdfWriter`。你可以看到，在部件上绘制和在打印机上打印的方法是非常相似的。区别在于架构的第二部分——绘图引擎（`QPaintEngine`）。引擎负责在特定的绘图设备上执行实际的绘图操作。不同的绘图引擎用于在图像上绘制和在打印机上打印。这对于你作为开发者来说是完全隐藏的，所以你实际上不需要担心这一点。
- en: 'For you, the most important piece is the third component—`QPainter`—which is
    an adapter for the whole painting framework. It contains a set of high-level operations
    that can be invoked on the paint device. Behind the scenes, the whole work is
    delegated to an appropriate paint engine. While talking about painting, we will
    be focusing solely on the painter object, as any painting code can be invoked
    on any of the target devices only by using a painter initialized on a different
    paint device. This effectively makes painting in Qt device agnostic, as in the
    following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你来说，最重要的部分是第三个组件——`QPainter`——它是整个绘图框架的适配器。它包含了一组可以在绘图设备上调用的高级操作。在幕后，所有的工作都委托给适当的绘图引擎。在讨论绘图时，我们将专注于绘图器对象，因为任何绘图代码都只能通过在不同的绘图设备上初始化的绘图器来调用。这有效地使得Qt的绘图与设备无关，如下面的例子所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The same code can be executed on a painter working on any possible `QPaintDevice`
    class, be it a widget, an image, or an OpenGL context (through the use of `QOpenGLPaintDevice`).
    We've already seen `QPainter` in action in [Chapter 4](33efb525-a584-4f9a-afaa-fe389d4a0400.xhtml),
    *Custom 2D Graphics with Graphics View*, when we created a custom graphics item.
    Now, let's learn more about this important class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同一段代码可以在任何可能的`QPaintDevice`类上的绘图器上执行，无论是部件、图像还是OpenGL上下文（通过使用`QOpenGLPaintDevice`）。我们已经在[第4章](33efb525-a584-4f9a-afaa-fe389d4a0400.xhtml)，*使用Graphics
    View的定制2D图形*中看到了`QPainter`的实际应用，当时我们创建了一个自定义的图形项。现在，让我们更深入地了解这个重要的类。
- en: 'The `QPainter` class has a rich API. The most important methods in this class
    can be divided into three groups:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`类有一个丰富的API。这个类中最重要的方法可以分为三个组：'
- en: Setters and getters for attributes of the painter
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘图器属性的设置器和获取器
- en: Methods, with names starting with `draw` and `fill`, that perform drawing operations
    on the device
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`draw`和`fill`开头名称的方法，在设备上执行绘图操作
- en: Methods that allow manipulating the coordinate system of the painter
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许操作绘图器坐标系的方法
- en: Painter attributes
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图器属性
- en: Let's start with the attributes. The three most important ones are the pen,
    brush, and font. The pen holds properties of the outline drawn by the painter,
    and the brush determines how it will fill shapes. We've already described pens
    and brushes in [Chapter 4](33efb525-a584-4f9a-afaa-fe389d4a0400.xhtml), *Custom
    2D Graphics with Graphics View*, so you should already understand how to work
    with them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从属性开始。最重要的三个属性是画笔、刷子和字体。画笔持有绘图器绘制轮廓的属性，而刷子决定了如何填充形状。我们已经在[第4章](33efb525-a584-4f9a-afaa-fe389d4a0400.xhtml)，*使用Graphics
    View的定制2D图形*中描述了画笔和刷子，所以你应该已经理解了如何使用它们。
- en: The `font` attribute is an instance of the `QFont` class. It contains a large
    number of methods for controlling font parameters such as font family, style (italic
    or oblique), font weight, and font size (either in points or device-dependent
    pixels). All the parameters are self-explanatory, so we will not discuss them
    here in detail. It is important to note that `QFont` can use any font installed
    on the system. In case more control over fonts is required or a font that is not
    installed in the system needs to be used, you can take advantage of the `QFontDatabase`
    class. It provides information about the available fonts (such as whether a particular
    font is scalable or bitmap or what writing systems it supports) and allows adding
    new fonts into the registry by loading their definitions directly from files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`font`属性是`QFont`类的实例。它包含大量用于控制字体参数的方法，例如字体家族、样式（斜体或倾斜）、字体粗细和字体大小（以点或设备相关像素为单位）。所有参数都是不言自明的，所以我们在这里不会详细讨论它们。重要的是要注意`QFont`可以使用系统上安装的任何字体。如果需要更多对字体的控制或需要使用系统上未安装的字体，可以利用`QFontDatabase`类。它提供了有关可用字体的信息（例如，特定字体是否可缩放或位图，以及它支持哪些书写系统），并允许通过直接从文件中加载它们的定义来将新字体添加到注册表中。'
- en: 'An important class, when it comes to fonts, is the `QFontMetrics` class. It
    allows calculating how much space is needed to paint particular text using a font
    or calculates text eliding. The most common use case is to check how much space
    to allocate for a particular user-visible string; consider this example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在字体方面，一个重要的类是`QFontMetrics`类。它允许计算使用字体绘制特定文本所需的空间量，或者计算文本的省略。最常见的用例是检查为特定用户可见字符串分配多少空间；考虑以下示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is especially useful when trying to determine `sizeHint` for a widget.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这在尝试确定小部件的`sizeHint`时特别有用。
- en: Coordinate systems
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标系
- en: The next important aspect of the painter is its coordinate system. The painter
    in fact has two coordinate systems. One is its own logical coordinate system that
    operates on real numbers, and the other is the physical coordinate system of the
    device the painter operates on. Each operation on the logical coordinate system
    is mapped to physical coordinates in the device and applied there. Let's start
    with explaining the logical coordinate system first, and then we'll see how this
    relates to physical coordinates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图器的下一个重要方面是其坐标系。实际上，绘图器有两个坐标系。一个是它自己的逻辑坐标系，它使用实数操作，另一个是绘图器操作的设备的物理坐标系。逻辑坐标系上的每个操作都映射到设备中的物理坐标，并在那里应用。让我们首先解释逻辑坐标系，然后我们将看到这与物理坐标有什么关系。
- en: The painter represents an infinite cartesian canvas, with the horizontal axis
    pointing right and the vertical axis pointing down by default. The system can
    be modified by applying affine transformations to it—translating, rotating, scaling,
    and shearing. This way, you can draw an analog clock face that marks each hour
    with a line by executing a loop that rotates the coordinate system by 30 degrees
    for each hour and draws a line that is vertical in the newly-obtained coordinate
    system. Another example is when you wish to draw a simple plot with an *x* axis
    going right and a *y* axis going up. To obtain the proper coordinate system, you
    would scale the coordinate system by −1 in the vertical direction, effectively
    reversing the direction of the vertical axis.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图器代表一个无限大的笛卡尔画布，默认情况下水平轴指向右，垂直轴指向下。可以通过对该系统应用仿射变换来修改它——平移、旋转、缩放和剪切。这样，你可以通过执行一个循环来绘制一个模拟时钟面，每个小时用一个线标记，每次循环将坐标系旋转30度，并在新获得的坐标系中绘制一条垂直线。另一个例子是当你希望绘制一个简单的图表，其中*x*轴向右延伸，而*y*轴向上延伸。为了获得正确的坐标系，你需要在垂直方向上将坐标系缩放为-1，从而有效地反转垂直轴的方向。
- en: What we described here modifies the world transformation matrix for the painter
    represented by an instance of the `QTransform` class. You can always query the
    current state of the matrix by calling `transform()` on the painter, and you can
    set a new matrix by calling `setTransform()`. `QTransform` has methods such as
    `scale()`, `rotate()`, and `translate()` that modify the matrix, but `QPainter`
    has equivalent methods for manipulating the world matrix directly. In most cases,
    using these would be preferable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的修改了由`QTransform`类实例表示的画家的世界变换矩阵。您可以通过在画家上调用`transform()`来始终查询矩阵的当前状态，并且可以通过调用`setTransform()`来设置新矩阵。`QTransform`有`scale()`、`rotate()`和`translate()`等方法来修改矩阵，但`QPainter`有直接操作世界矩阵的等效方法。在大多数情况下，使用这些方法会更可取。
- en: Each painting operation is expressed in logical coordinates, goes through the
    world transformation matrix, and reaches the second stage of coordinate manipulation,
    which is the view matrix. The painter has the concept of `viewport()` and `window()`
    rectangles. The `viewport` rectangle represents the physical coordinates of an
    arbitrary rectangle, while the `window` rectangle expresses the same rectangle
    but in logical coordinates. Mapping one to another gives a transformation that
    needs to be applied to each drawn primitive to calculate the area of the physical
    device that is to be painted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绘图操作都使用逻辑坐标表示，经过世界变换矩阵，并达到坐标操作的第二个阶段，即视图矩阵。画家有`viewport()`和`window()`矩形的观念。`viewport`矩形表示任意矩形的物理坐标，而`window`矩形表示相同的矩形，但在逻辑坐标中。将一个映射到另一个给出一个需要应用于每个绘制的原语以计算要绘制的物理设备区域的变换。
- en: By default, the two rectangles are identical to the rectangle of the underlying
    device (thus, no `window`–`viewport` mapping is done). Such transformation is
    useful if you wish to perform painting operations using measurement units other
    than the pixels of the target device. For example, if you want to express coordinates
    using percentages of the width and height of the target device, you would set
    both the window width and height to `100`. Then, to draw a line starting at 20%
    of the width and 10% of the height and ending at 70% of the width and 30% of the
    height, you would tell the painter to draw the line between `(20, 10)` and `(70,
    30)`. If you wanted those percentages to apply not to the whole area of an image
    but to its left half, you would set the viewport rectangle only to the left half
    of the image.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这两个矩形与底层设备的矩形相同（因此，不会进行`window`-`viewport`映射）。这种转换在您希望使用除目标设备像素以外的测量单位执行绘图操作时很有用。例如，如果您想使用目标设备宽度和高度的百分比来表示坐标，您应将窗口宽度和高度都设置为`100`。然后，为了绘制从宽度20%和高度10%开始的线，并结束于宽度70%和高度30%，您将告诉画家绘制从`(20,
    10)`到`(70, 30)`的线。如果您希望这些百分比只应用于图像的左半部分，您只需将视口矩形设置为图像的左半部分。
- en: Setting the `window` and `viewport` rectangles only defines coordinate mapping;
    it does not prevent drawing operations from painting outside the `viewport` rectangle.
    If you want such behavior, you have to enable **clipping** in the painter and
    define the clipping region or path.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 仅设置`window`和`viewport`矩形定义了坐标映射；它不会阻止绘图操作在`viewport`矩形外进行绘制。如果您希望这种行为，您必须在画家中启用**裁剪**并定义裁剪区域或路径。
- en: Drawing operations
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图操作
- en: Once you have the painter properly set, you can start issuing painting operations.
    `QPainter` has a rich set of operations for drawing different kinds of primitives.
    All of these operations have the `draw` prefix in their names, followed by the
    name of the primitive that is to be drawn. Thus, operations such as `drawLine`,
    `drawRoundedRect`, and `drawText` are available with a number of overloads that
    usually allow us to express coordinates using different data types. These may
    be pure values (either integer or real), Qt's classes, such as `QPoint` and `QRect`,
    or their floating point equivalents—`QPointF` and `QRectF`. Each operation is
    performed using current painter settings (font, pen, and brush).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确设置了画家，您就可以开始发出绘图操作。`QPainter`提供了一套丰富的操作来绘制不同类型的原语。所有这些操作在其名称中都包含`draw`前缀，后跟要绘制的原语名称。因此，`drawLine`、`drawRoundedRect`和`drawText`等操作都提供了一些重载，通常允许我们使用不同的数据类型来表示坐标。这些可能是纯值（整数或实数），Qt的类，如`QPoint`和`QRect`，或它们的浮点等效类——`QPointF`和`QRectF`。每个操作都是使用当前画家设置（字体、笔和画刷）执行的。
- en: Refer to the documentation of the `QPainter` class for the list of all drawing
    operations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅`QPainter`类的文档，以获取所有绘图操作的列表。
- en: Before you start drawing, you have to tell the painter which device you wish
    to draw on. This is done using the `begin()` and `end()` methods. The former accepts
    a pointer to a `QPaintDevice` instance and initializes the drawing infrastructure,
    and the latter marks the drawing as complete. Usually, we don't have to use these
    methods directly, as the constructor of `QPainter` calls `begin()` for us, and
    the destructor invokes `end()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始绘图之前，你必须告诉画家你希望在哪个设备上绘图。这是通过使用`begin()`和`end()`方法来完成的。前者接受一个指向`QPaintDevice`实例的指针并初始化绘图基础设施，后者标记绘图已完成。通常，我们不需要直接使用这些方法，因为`QPainter`的构造函数会为我们调用`begin()`，而析构函数会调用`end()`。
- en: 'Thus, the typical workflow is to instantiate a painter object, pass it to the
    device, then do the drawing by calling the `set` and `draw` methods, and finally
    let the painter be destroyed by going out of scope, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，典型的流程是实例化一个画家对象，将其传递给设备，然后通过调用`set`和`draw`方法进行绘图，最后通过超出作用域让画家被销毁，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will cover more methods from the `draw` family in the following sections
    of this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后续部分介绍`draw`家族的更多方法。
- en: Creating a custom widget
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义小部件
- en: It is time to actually get something onto the screen by painting on a widget.
    A widget is repainted as a result of receiving a paint event, which is handled
    by reimplementing the `paintEvent()` virtual method. This method accepts a pointer
    to the event object of the `QPaintEvent` type that contains various bits of information
    about the repaint request. Remember that you can only paint on the widget from
    within that widget's `paintEvent()` call.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候通过在部件上绘图将一些内容真正显示到屏幕上了。部件由于收到绘图事件而被重新绘制，该事件通过重新实现`paintEvent()`虚方法来处理。该方法接受一个指向`QPaintEvent`类型的事件对象的指针，该对象包含有关重新绘制请求的各种信息。记住，你只能在部件的`paintEvent()`调用内进行绘图。
- en: Time for action – Custom-painted widgets
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 定制绘制的小部件
- en: Let's immediately put our new skills in to practice! Start by creating a new
    Qt Widgets Application in Qt Creator, choosing `QWidget` as the base class, and
    ensuring that the Generate Form box is unchecked. The name of our widget class
    will be `Widget`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即将新技能付诸实践！在Qt Creator中创建一个新的Qt Widgets应用程序，选择`QWidget`作为基类，并确保不勾选生成表单框。我们的部件类名称将是`Widget`。
- en: 'Switch to the header file for the newly created class, add a protected section
    to the class, and type `void paintEvent` in that section. Then, press *Ctrl* +
    *Space* on your keyboard and Creator will suggest the parameters for the method.
    You should end up with the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到新创建的类的头文件，在类中添加一个受保护的节，并在该节中键入`void paintEvent`。然后，按键盘上的*Ctrl* + *Space*，Creator将建议方法的参数。你应该得到以下代码：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Creator will leave the cursor positioned right before the semicolon. Pressing
    *Alt* + *Enter* will open the refactoring menu, letting you add the definition
    in the implementation file. The standard code for a paint event is one that instantiates
    a painter on the widget, as shown:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Creator会将光标定位在分号之前。按下*Alt* + *Enter*将打开重构菜单，让你在实现文件中添加定义。处理绘图事件的标准化代码是在小部件上实例化一个画家，如下所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run this code, the widget will remain blank. Now we can start adding
    the actual painting code there:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，部件将保持空白。现在我们可以开始添加实际的绘图代码：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Build and run the code, and you''ll obtain the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行代码，你将得到以下输出：
- en: '![](img/486d6364-a374-484c-b234-088fe96a195d.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/486d6364-a374-484c-b234-088fe96a195d.png)'
- en: What just happened?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: First, we set a four pixels wide black pen for the painter. Then, we called
    `rect()` to retrieve the geometry rectangle of the widget. By calling `adjusted()`,
    we receive a new rectangle with its coordinates (in the left, top, right, and
    bottom order) modified by the given arguments, effectively giving us a rectangle
    with a 10 pixel margin on each side.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为画家设置了一个宽度为四像素的黑色笔。然后，我们调用`rect()`来获取小部件的几何矩形。通过调用`adjusted()`，我们接收一个新的矩形，其坐标（按照左、上、右、下的顺序）被给定的参数修改，从而有效地给我们一个每边有10像素边距的矩形。
- en: Qt usually offers two methods that allow us to work with modified data. Calling
    `adjusted()` returns a new object with its attributes modified, while if we had
    called `adjust()`, the modification would have been done in place. Pay special
    attention to which method you use to avoid unexpected results. It's best to always
    check the return value for a method—whether it returns a copy or void.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Qt通常提供两种方法，允许我们处理修改后的数据。调用`adjusted()`返回一个具有修改后属性的新对象，而如果我们调用`adjust()`，修改将就地完成。请特别注意你使用的方法，以避免意外结果。最好始终检查方法的返回值——它是否返回一个副本或空值。
- en: 'Finally, we call `drawRoundedRect()`, which paints a rectangle with its corners
    rounded by the number of pixels (in the *x*, *y* order) given as the second and
    third argument. If you look closely, you will note that the rectangle has nasty
    jagged rounded parts. This is caused by the effect of aliasing, where a logical
    line is approximated using the limited resolution of the screen; due to this,
    a pixel is either fully drawn or not drawn at all. As we learned in [Chapter 4](33efb525-a584-4f9a-afaa-fe389d4a0400.xhtml), *Custom
    2D Graphics with Graphics View*, Qt offers a mechanism called anti-aliasing to
    counter this effect using intermediate pixel colors where appropriate. You can
    enable this mechanism by setting a proper render hint on the painter before you
    draw the rounded rectangle, as shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`drawRoundedRect()`，它使用第二个和第三个参数（在*x*，*y*顺序中）给出的像素数来绘制一个圆角矩形。如果你仔细看，你会注意到矩形有讨厌的锯齿状圆角部分。这是由抗锯齿效应引起的，其中逻辑线使用屏幕有限的分辨率进行近似；由于这个原因，一个像素要么完全绘制，要么完全不绘制。正如我们在[第4章](33efb525-a584-4f9a-afaa-fe389d4a0400.xhtml)，“使用Graphics
    View的2D自定义图形”，Qt提供了一个称为抗锯齿的机制，通过在适当的位置使用中间像素颜色来对抗这种效果。你可以在绘制圆角矩形之前，在画家上设置适当的渲染提示来启用此机制，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you''ll get the following output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将得到以下输出：
- en: '![](img/458ab448-fa77-4ff5-9e7e-74d82e6facfb.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/458ab448-fa77-4ff5-9e7e-74d82e6facfb.png)'
- en: Of course, this has a negative impact on performance, so use anti-aliasing only
    where the aliasing effect is noticeable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会对性能产生负面影响，所以只在抗锯齿效果明显的地方使用抗锯齿。
- en: Time for action – Transforming the viewport
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 变换视口
- en: 'Let''s extend our code so that all future operations focus only on drawing
    within the border boundaries after the border is drawn. Use the `window` and `viewport`
    transformation, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的代码，以便所有未来的操作都只关注在绘制边界之后在边界内进行绘制。使用`window`和`viewport`变换，如下所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Also, create a protected method called `drawChart()`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建一个名为`drawChart()`的保护方法：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s take a look at our output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的输出：
- en: '![](img/d2936d80-e129-4603-8666-8988912ce80e.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2936d80-e129-4603-8666-8988912ce80e.png)'
- en: What just happened?
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: The first thing we did in the newly added code is call `painter.save()`. This
    call stores all parameters of the painter in an internal stack. We can then modify
    the painter state (by changing its attributes, applying transformations, and so
    on) and then, if at any point we want to go back to the saved state, it is enough
    to call `painter.restore()` to undo all the modifications in one go.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在新添加的代码中，我们首先调用了`painter.save()`。这个调用将画家的所有参数存储在一个内部栈中。然后我们可以修改画家的状态（通过更改其属性、应用变换等），然后，如果我们任何时候想要回到保存的状态，只需要调用`painter.restore()`就可以一次性撤销所有修改。
- en: The `save()` and `restore()` methods can be called as many times as needed.
    States are stored in a stack, so you can save multiple times in a row and then
    restore to undo each change. Just remember to always pair a call to `save()` with
    a similar call to `restore()`, or the internal painter state will get corrupted.
    Each call to `restore()` will revert the painter to the last saved state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`和`restore()`方法可以按需多次调用。状态存储在栈中，因此你可以连续保存多次，然后恢复以撤销每个更改。只需记住，始终将`save()`的调用与类似的`restore()`调用配对，否则内部画家状态将损坏。每次调用`restore()`都会将画家恢复到最后保存的状态。'
- en: After the state is saved, we modify the rectangle again by adjusting for the
    width of the border. Then, we set the new rectangle as the viewport, informing
    the painter about the physical range of coordinates to operate on. Then, we move
    the rectangle by half its height and set that as the painter window. This effectively
    puts the origin of the painter at half the height of the widget. Then, the `drawChart()`
    method is called, whereby a red line is drawn on the *x* axis of the new coordinate
    system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 状态保存后，我们再次调整矩形以适应边框的宽度。然后，我们将新的矩形设置为视口，通知绘图器操作的坐标物理范围。然后，我们将矩形向上移动其高度的一半，并将其设置为绘图器窗口。这有效地将绘图器的原点放置在小部件高度的一半处。然后，调用`drawChart()`方法，在新的坐标系中绘制一条红色线条。
- en: Time for action – Drawing an oscillogram
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——绘制示波器
- en: Let's further extend our widget to become a simple oscillogram renderer. For
    that, we have to make the widget remember a set of values and draw them as a series
    of lines.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步扩展我们的小部件，使其成为一个简单的示波器渲染器。为此，我们必须让小部件记住一组值，并将它们绘制成一系列线条。
- en: 'Let''s start by adding a `QVector<quint16>` member variable that holds a list
    of unsigned 16-bit integer values. We will also add slots for adding values to
    the list and for clearing the list, as shown:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加一个`QVector<quint16>`成员变量开始，该变量包含一个无符号16位整数值的列表。我们还将添加用于向列表添加值和清除列表的槽，如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that each modification of the list invokes a method called `update()`.
    This schedules a paint event so that our widget can be redrawn with the new values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次修改列表都会调用一个名为`update()`的方法。这安排了一个绘制事件，以便我们的小部件可以用新值重新绘制。
- en: 'Drawing code is also easy; we just iterate over the list and draw symmetric
    blue lines based on the values from the list. Since the lines are vertical, they
    don''t suffer from aliasing and so we can disable this render hint, as shown:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图代码也很简单；我们只需遍历列表，并根据列表中的值绘制对称的蓝色线条。由于线条是垂直的，它们不会受到混叠的影响，因此我们可以禁用此渲染提示，如下所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To see the result, let''s fill the widget with data in the `main()` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看结果，让我们在`main()`函数中用数据填充小部件：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This loop takes a random number between `0` and `119` and adds it as a point
    to the widget. A sample result from running such code can be seen in the following
    screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环生成一个介于`0`和`119`之间的随机数，并将其作为点添加到小部件中。运行此类代码的示例结果如下截图所示：
- en: '![](img/8bbcf228-49c4-4bfe-b36a-d5c7e563224b.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/8bbcf228-49c4-4bfe-b36a-d5c7e563224b.png)'
- en: If you scale down the window, you will note that the oscillogram extends past
    the boundaries of the rounded rectangle. Remember about clipping? You can use
    it now to constrain the drawing by adding a simple `painter.setClipRect(r)` call
    just before you call `drawChart()`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缩小窗口，你会注意到示波器延伸到了圆角矩形的边界之外。还记得剪裁吗？现在你可以使用它来通过在调用`drawChart()`之前添加一个简单的`painter.setClipRect(r)`调用来约束绘图。
- en: So far, the custom widget was not interactive at all. Although the widget content
    could be manipulated from within the source code (say by adding new points to
    the plot), the widget was deaf to any user actions (apart from resizing the widget,
    which caused a repaint). In Qt, any interaction between the user and the widget
    is done by delivering events to the widget. Such a family of events is generally
    called input events and contains events such as keyboard events and different
    forms of pointing-device events—mouse, tablet, and touch events.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，自定义小部件根本不具备交互性。尽管可以在源代码内部操作小部件内容（例如，通过向图表添加新点），但小部件对任何用户操作（除了调整小部件大小，这会导致重绘）都充耳不闻。在Qt中，用户与小部件之间的任何交互都是通过向小部件传递事件来完成的。这类事件通常被称为输入事件，包括键盘事件和不同形式的指向设备事件——鼠标、平板和触摸事件。
- en: In a typical mouse event flow, a widget first receives a mouse press event,
    then a number of mouse move events (when the user moves the mouse around while
    the mouse button is kept pressed), and finally, a mouse release event. The widget
    can also receive an additional mouse double-click event in addition to these events.
    It is important to remember that by default, mouse move events are only delivered
    if a mouse button is pressed when the mouse is moved. To receive mouse move events
    when no button is pressed, a widget needs to activate a feature called **mouse
    tracking**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的鼠标事件流程中，小部件首先接收到鼠标按下事件，然后是一系列鼠标移动事件（当用户在鼠标按钮按下时移动鼠标时），最后是一个鼠标释放事件。小部件还可以接收到除了这些事件之外的额外鼠标双击事件。重要的是要记住，默认情况下，只有在鼠标移动时按下鼠标按钮时，才会传递鼠标移动事件。要接收没有按钮按下时的鼠标移动事件，小部件需要激活一个称为**鼠标跟踪**的功能。
- en: Time for action – Making oscillograms selectable
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使示波图可选择
- en: 'It''s time to make our oscillogram widget interactive. We will teach it to
    add a couple of lines of code to it that let the user select part of the plot.
    Let''s start with storage for the selection. We''ll need two integer variables
    that can be accessed via read-only properties; therefore, add the following two
    properties to the class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使我们的示波器小部件交互式了。我们将教会它添加几行代码，使用户能够选择绘图的一部分。让我们从存储选择开始。我们需要两个可以通过只读属性访问的整数变量；因此，向类中添加以下两个属性：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, you need to create corresponding private fields (you can initialize them
    both to −1), getters, and signals.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要创建相应的私有字段（您可以初始化它们都为-1）、获取器和信号。
- en: 'The user can change the selection by dragging the mouse cursor over the plot.
    When the user presses the mouse button over some place in the plot, we''ll mark
    that place as the start of the selection. Dragging the mouse will determine the
    end of the selection. The scheme for naming events is similar to the paint event;
    therefore, we need to declare and implement the following two protected methods:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过将鼠标光标拖动到绘图上来更改选择。当用户在绘图上的某个位置按下鼠标按钮时，我们将该位置标记为选择的开始。拖动鼠标将确定选择的结束。事件命名的方案类似于绘图事件；因此，我们需要声明和实现以下两个受保护的方法：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The structure of both event handlers is similar. We update the needed values,
    taking into consideration the left padding (12 pixels) of the plot, similar to
    what we do while drawing. Then, a signal is emitted and `update()` is called to
    schedule a repaint of the widget.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 两个事件处理器的结构类似。我们更新所需值，考虑到绘图时的左填充（12像素），类似于我们在绘图时所做的。然后，发出一个信号并调用`update()`来安排小部件的重绘。
- en: 'What remains is to introduce changes to the drawing code. We suggest that you
    add a `drawSelection()` method similar to `drawChart()`, but that it is called
    from the paint event handler immediately before `drawChart()`, as shown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是对绘图代码进行更改。我们建议您添加一个类似于`drawChart()`的`drawSelection()`方法，但它从绘图事件处理程序立即在`drawChart()`之前调用，如下所示：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we check whether there is any selection to be drawn at all. Then, we
    save the painter state and adjust the pen and brush of the painter. The pen is
    set to `Qt::NoPen`, which means the painter should not draw any outline. To determine
    the brush, we use `palette()`; this returns an object of the `QPalette` type holding
    basic colors for a widget. One of the colors held in the object is the color of
    the highlight often used for marking selections. If you use an entry from the
    palette instead of manually specifying a color, you gain an advantage because
    when the user of the class modifies the palette, this modification is taken into
    account by our widget code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否需要绘制任何选择。然后，我们保存绘图器的状态并调整绘图器的笔和刷。笔设置为`Qt::NoPen`，这意味着绘图器不应绘制任何轮廓。为了确定刷，我们使用`palette()`；这返回一个包含小部件基本颜色的`QPalette`类型的对象。对象中包含的颜色之一是常用于标记选择的突出显示颜色。如果您使用调色板中的条目而不是手动指定颜色，您将获得优势，因为当类的用户修改调色板时，这种修改会被我们的小部件代码考虑在内。
- en: You can use other colors from the palette in the widget for other things we
    draw in the widget. You can even define your own `QPalette` object in the constructor
    of the widget to provide default colors for it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用小部件中的调色板中的其他颜色来绘制小部件中的其他内容。您甚至可以在小部件的构造函数中定义自己的`QPalette`对象，以提供默认颜色。
- en: Finally, we adjust the rectangle to be drawn and issue the drawing call.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调整要绘制的矩形并发出绘图调用。
- en: 'When you run this program, you will note that the selection color doesn''t
    contrast very well with the plot itself. To overcome this, a common approach is
    to draw the "selected" content with a different (often inverted) color. This can
    easily be applied in this situation by modifying the `drawChart()` code slightly:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此程序时，你会注意到选择颜色与图表本身的对比度不是很好。为了克服这一点，一个常见的做法是用不同的（通常是相反的）颜色绘制“选中”内容。在这种情况下，可以通过稍微修改`drawChart()`代码轻松实现这一点：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now you see the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到以下输出：
- en: '![](img/365e08df-895e-4841-8e76-eb33818a422d.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/365e08df-895e-4841-8e76-eb33818a422d.png)'
- en: Have a go hero – Reacting only to the left mouse button
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 勇敢尝试者——仅对左鼠标按钮做出反应
- en: As an exercise, you can modify the event handling code so that it only changes
    the selection if the mouse event was triggered by the left mouse button. To see
    which button triggered the mouse press event, you can use the `QMouseEvent::button()`
    method, which returns `Qt::LeftButton` for the left button, `Qt::RightButton`
    for the right, and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以修改事件处理代码，使其仅在鼠标事件由左鼠标按钮触发时更改选择。要查看哪个按钮触发了鼠标按下事件，你可以使用`QMouseEvent::button()`方法，它返回`Qt::LeftButton`表示左按钮，`Qt::RightButton`表示右按钮，依此类推。
- en: Touch events
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸事件
- en: Handling touch events is different. For any such event, you receive a call to
    the `touchEvent()` virtual method. The parameter of such a call is an object that
    can retrieve a list of points currently touched by the user with additional information
    regarding the history of user interaction (whether the touch was just initiated
    or the point was pressed earlier and moved) and what force is applied to the point
    by the user. Note that this is a low-level framework that allows you to precisely
    follow the history of touch interaction. If you are more interested in higher-level
    gesture recognition (pan, pinch, and swipe), there is a separate family of events
    available for it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 处理触摸事件是不同的。对于任何此类事件，你都会收到对`touchEvent()`虚拟方法的调用。此类调用的参数是一个对象，可以检索用户当前触摸的点列表，以及有关用户交互历史（触摸是否刚刚开始或点是否之前被按下并移动）以及用户施加到点的力的附加信息。请注意，这是一个低级框架，允许你精确地跟踪触摸交互的历史。如果你对高级手势识别（平移、捏合和滑动）更感兴趣，有针对它的一个单独的事件家族。
- en: Handling gestures is a two-step procedure. First, you need to activate gesture
    recognition on your widget by calling `grabGesture()` and passing in the type
    of gesture you want to handle. A good place for such code is the widget constructor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 处理手势是一个两步的过程。首先，你需要通过调用`grabGesture()`并传入你想要处理的手势类型来在你的小部件上激活手势识别。这样的代码放在小部件构造函数中是个好地方。
- en: 'Then, your widget will start receiving gesture events. There are no dedicated
    handlers for gesture events but, fortunately, all events for an object flow through
    its `event()` method, which we can reimplement. Here''s some example code that
    handles pan gestures:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你的小部件将开始接收手势事件。没有专门的手势事件处理器，但幸运的是，一个对象的所有事件都通过其`event()`方法流动，我们可以重新实现它。以下是一些处理平移手势的示例代码：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, a check for the event type is made; if it matches the expected value,
    the event object is cast to `QGestureEvent`. Then, the event is asked whether `Qt::PanGesture`
    was recognized. Finally, a `handlePanGesture` method is called. You can implement
    such a method to handle your pan gestures.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行事件类型的检查；如果它与预期值匹配，则将事件对象转换为`QGestureEvent`。然后，询问是否识别出`Qt::PanGesture`。最后，调用`handlePanGesture`方法。你可以实现这样一个方法来处理你的平移手势。
- en: Working with images
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与图像一起工作
- en: Qt has two classes for handling images. The first one is `QImage`, more tailored
    toward direct pixel manipulation. You can check the size of the image or check
    and modify the color of each pixel. You can convert the image into a different
    internal representation (say from 8-bit color map to full 32-bit color with a
    premultiplied alpha channel). This type, however, is not that fit for rendering.
    For that, we have a different class called `QPixmap`. The difference between the
    two classes is that `QImage` is always kept in the application memory, while `QPixmap`
    can only be a handle to a resource that may reside in the graphics card memory
    or on a remote *X* server. Its main advantage over `QImage` is that it can be
    rendered very quickly at the cost of the inability to access pixel data. You can
    freely convert between the two types, but bear in mind that on some platforms,
    this might be an expensive operation. Always consider which class serves your
    particular situation better. If you intend to crop the image, tint it with some
    color, or paint over it, `QImage` is a better choice, but if you just want to
    render a bunch of icons, it's best to keep them as `QPixmap` instances.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 有两个用于处理图像的类。第一个是 `QImage`，更倾向于直接像素操作。你可以检查图像的大小或检查和修改每个像素的颜色。你可以将图像转换为不同的内部表示（例如从8位调色板到带有预乘alpha通道的完整32位颜色）。然而，这种类型并不适合渲染。为此，我们有一个不同的类，称为
    `QPixmap`。这两个类之间的区别在于 `QImage` 总是保存在应用程序内存中，而 `QPixmap` 只能是一个指向可能位于图形卡内存或远程 *X*
    服务器上的资源的句柄。它相对于 `QImage` 的主要优势是它可以非常快速地渲染，但代价是无法访问像素数据。你可以在两种类型之间自由转换，但请注意，在某些平台上，这可能是一个昂贵的操作。始终考虑哪个类更适合你的特定情况。如果你打算裁剪图像、用某种颜色着色或在其上绘画，`QImage`
    是更好的选择，但如果你只是想渲染一些图标，最好将它们保持为 `QPixmap` 实例。
- en: Loading
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载
- en: 'Loading images is very easy. Both `QPixmap` and `QImage` have constructors
    that simply accept a path to a file containing the image. Qt accesses image data
    through plugins that implement reading and writing operations for different image
    formats. Without going into the details of plugins, it is enough to say that the
    default Qt installation supports reading the following image types:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像非常简单。`QPixmap` 和 `QImage` 都有构造函数，只需接受包含图像的文件路径即可。Qt 通过实现不同图像格式读取和写入操作的插件来访问图像数据。不深入插件细节，只需说默认的
    Qt 安装支持读取以下图像类型：
- en: '| **Type** | Description |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | 描述 |'
- en: '| --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| BMP | Windows Bitmap |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| BMP | Windows 位图 |'
- en: '| GIF | Graphics Interchange Format |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| GIF | 图像交换格式 |'
- en: '| JPG/JPEG | Joint Photography Experts Group |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| JPG/JPEG | 联合摄影专家组 |'
- en: '| PNG | Portable Network Graphics |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| PNG | 可移植网络图形 |'
- en: '| PPM/PBM/PGM | Portable anymap |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| PPM/PBM/PGM | 可移植任意图 |'
- en: '| XBM | X Bitmap |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| XBM | X 位图 |'
- en: '| XPM | X Pixmap |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| XPM | X Pixmap |'
- en: As you can see, the most popular image formats are available. The list can be
    further extended by installing additional plugins.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，最流行的图像格式都可用。通过安装额外的插件，该列表可以进一步扩展。
- en: You can ask Qt for a list of supported image types by calling a static method,
    `QImageReader::supportedImageFormats()`, which returns a list of formats that
    can be read by Qt. For a list of writable formats, call `QImageWriter::supportedImageFormats()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用静态方法 `QImageReader::supportedImageFormats()` 来请求 Qt 支持的图像类型列表，它返回 Qt
    可以读取的格式列表。对于可写入的格式列表，请调用 `QImageWriter::supportedImageFormats()`。
- en: An image can also be loaded directly from an existing memory buffer. This can
    be done in two ways. The first one is to use the `loadFromData()` method (it exists
    in both `QPixmap` and `QImage`), which behaves the same as when loading an image
    from a file—you pass it a data buffer and the size of the buffer and based on
    that, the loader determines the image type by inspecting the header data and loads
    the picture into `QImage` or `QPixmap`. The second situation is when you don't
    have images stored in a "filetype" such as JPEG or PNG; rather, you have raw pixel
    data itself. In such a situation, `QImage` offers a constructor that takes a pointer
    to a block of data together with the size of the image and format of the data.
    The format is not a file format such as the ones listed earlier but a memory layout
    for data representing a single pixel.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图像也可以直接从现有的内存缓冲区加载。这可以通过两种方式完成。第一种是使用`loadFromData()`方法（它存在于`QPixmap`和`QImage`中），其行为与从文件加载图像时相同——您传递一个数据缓冲区和缓冲区的大小，根据这些信息，加载器通过检查头数据来确定图像类型，并将图片加载到`QImage`或`QPixmap`中。第二种情况是您没有存储在“文件类型”如JPEG或PNG中的图像；相反，您有原始像素数据本身。在这种情况下，`QImage`提供了一个构造函数，它接受指向数据块的指针以及图像的大小和数据格式。格式不是如前面列出的文件格式，而是表示单个像素数据的内存布局。
- en: 'The most popular format is `QImage::Format_ARGB32`, which means that each pixel
    is represented by 32-bits (4 bytes) of data divided equally between alpha, red,
    green, and blue channels—8-bits per channel. Another popular format is `QImage::Format_ARGB32_Premultiplied`,
    where values for the red, green, and blue channels are stored after being multiplied
    by the value of the alpha channel, which often results in faster rendering. You
    can change the internal data representation using a call to `convertToFormat()`.
    For example, the following code converts a true-color image to 256 colors, where
    color for each pixel is represented by an index in a color table:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的格式是`QImage::Format_ARGB32`，这意味着每个像素由32位（4字节）数据表示，这些数据在alpha、红色、绿色和蓝色通道之间平均分配——每个通道8位。另一种流行的格式是`QImage::Format_ARGB32_Premultiplied`，其中红色、绿色和蓝色通道的值在乘以alpha通道的值之后存储，这通常会导致渲染速度更快。您可以使用`convertToFormat()`调用更改内部数据表示。例如，以下代码将真彩色图像转换为256种颜色，其中每个像素的颜色由颜色表中索引表示：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The color table itself is a vector of color definitions that can be fetched
    using `colorTable()` and replaced using `setColorTable()`. For example, you can
    convert an indexed image to grayscale by adjusting its color table, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色表本身是一个颜色定义的向量，可以使用`colorTable()`获取，并使用`setColorTable()`替换。例如，您可以通过调整颜色表将索引图像转换为灰度图，如下所示：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, there is a much cleaner solution to this task. You can convert any
    image to the `Format_Grayscale8` format:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这个任务有一个更简洁的解决方案。您可以将任何图像转换为`Format_Grayscale8`格式：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This format uses 8 bits per pixel and doesn't have a color table, so it can
    only store grayscale images.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此格式使用每个像素8位，没有颜色表，因此只能存储灰度图像。
- en: Modifying
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改
- en: 'There are two ways to modify image pixel data. The first one works only for
    `QImage` and involves direct manipulation of pixels using the `setPixel()` call,
    which takes the pixel coordinates and color to be set for that pixel. The second
    one works for both `QImage` and `QPixmap` and makes use of the fact that both
    these classes are subclasses of `QPaintDevice`. Therefore, you can open `QPainter`
    on such objects and use its drawing API. Here''s an example of obtaining a pixmap
    with a blue rectangle and red circle painted over it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 修改图像像素数据有两种方法。第一种仅适用于`QImage`，涉及使用`setPixel()`调用直接操作像素，该调用接受像素坐标和要设置的像素颜色。第二种方法适用于`QImage`和`QPixmap`，利用这两个类都是`QPaintDevice`的子类这一事实。因此，您可以在这些对象上打开`QPainter`并使用其绘图API。以下是一个获取带有蓝色矩形和红色圆圈的位图的示例：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we create a 256 x 256 pixmap and fill it with transparent color. Then,
    we open a painter on it and invoke a series of calls that draws a blue rectangle
    and red circle.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个256 x 256的位图，并用透明色填充它。然后，我们在其上打开一个画家，并调用一系列绘制蓝色矩形和红色圆圈的调用。
- en: '`QImage` also offers a number of methods for transforming the image, including
    `scaled()`, `mirrored()`, `transformed()`, and `copy()`. Their API is intuitive,
    so we won''t discuss it here.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`QImage`还提供了一些用于转换图像的方法，包括`scaled()`、`mirrored()`、`transformed()`和`copy()`。它们的API直观，因此我们在此不进行讨论。'
- en: Painting
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图
- en: Painting images in its basic form is as simple as calling `drawImage()` or `drawPixmap()`
    from the `QPainter` API. There are different variants of the two methods, but,
    basically, all of them allow one to specify which portion of a given image or
    pixmap is to be drawn and where. It is worth noting that painting pixmaps is preferred
    to painting images, as an image has to first be converted into a pixmap before
    it can be drawn.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在其基本形式中，绘制图像与从 `QPainter` API 调用 `drawImage()` 或 `drawPixmap()` 一样简单。这两个方法有不同的变体，但基本上，它们都允许指定要绘制的给定图像或位图的哪一部分以及绘制位置。值得注意的是，与绘制图像相比，绘制位图更受欢迎，因为图像必须首先转换为位图才能进行绘制。
- en: If you have a lot of pixmaps to draw, a class called `QPixmapCache` may come
    in handy. It provides an application-wide cache for pixmaps. Using it, you can
    speed up pixmap loading while introducing a cap on memory usage.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多位图要绘制，一个名为 `QPixmapCache` 的类可能会很有用。它为位图提供了一个应用程序范围内的缓存。使用它，你可以加快位图加载速度，同时限制内存使用量。
- en: Finally, if you just want to show a pixmap as a separate widget, you can use
    `QLabel`. This widget is usually used for displaying text, but you can configure
    it to show a pixmap instead with the `setPixmap()` function. By default, the pixmap
    is displayed without scaling. When the label is larger than the pixmap, it's position
    is determined by the label's alignment that you can change with the `setAlignment()`
    function. You can also call `setScaledContents(true)` to stretch the pixmap to
    the whole size of the label.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你只想将位图作为一个单独的小部件显示，你可以使用 `QLabel`。这个小部件通常用于显示文本，但你可以通过 `setPixmap()` 函数配置它以显示位图。默认情况下，位图以不缩放的方式显示。当标签比位图大时，它的位置由标签的对齐方式决定，你可以通过
    `setAlignment()` 函数更改它。你还可以调用 `setScaledContents(true)` 将位图拉伸到标签的全尺寸。
- en: Painting text
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制文本
- en: Drawing text using `QPainter` deserves a separate explanation, not because it
    is complicated, but because Qt offers much flexibility in this regard. In general,
    painting text takes place by calling `QPainter::drawText()` or `QPainter::drawStaticText()`.
    Let's focus on the former first, which allows the drawing of generic text.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QPainter` 绘制文本值得单独解释，不是因为它复杂，而是因为 Qt 在这方面提供了很多灵活性。一般来说，绘制文本是通过调用 `QPainter::drawText()`
    或 `QPainter::drawStaticText()` 来实现的。让我们首先关注前者，它允许绘制通用文本。
- en: 'The most basic call to paint some text is a variant of this method, which takes
    *x* and *y* coordinates and the text to draw:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 调用绘制文本的最基本的方法是这个方法的变体，它需要 *x* 和 *y* 坐标以及要绘制的文本：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding call draws the given text at position 10 horizontally and places
    the baseline of the text at position 20 vertically. The text is drawn using the
    painter''s current font and pen. The coordinates can alternatively be passed as
    `QPoint` instances, instead of being given *x* and *y* values separately. The
    problem with this method is that it allows little control over how the text is
    drawn. A much more flexible variant is one that lets us give a set of flags and
    expresses the position of the text as a rectangle instead of a point. The flags
    can specify the alignment of the text within the given rectangle or instruct the
    rendering engine about wrapping and clipping the text. You can see the result
    of giving a different combination of flags to the call in the following diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述调用将给定文本水平绘制在位置 10，并将文本的基线垂直放置在位置 20。文本使用画家的当前字体和笔进行绘制。坐标也可以作为 `QPoint` 实例传递，而不是分别给出
    *x* 和 *y* 值。这种方法的问题在于它对文本的绘制方式控制很少。一个更灵活的变体是允许我们给出一系列标志，并将文本的位置表示为一个矩形而不是一个点。标志可以指定文本在给定矩形内的对齐方式，或者指导渲染引擎关于文本的换行和剪切。你可以在以下图中看到向调用传递不同组合的标志的结果：
- en: '![](img/7734f14d-1980-4743-b108-123f2fb12aa8.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7734f14d-1980-4743-b108-123f2fb12aa8.png)'
- en: 'In order to obtain each of the preceding results, run code similar to the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得上述结果中的每一个，运行类似于以下代码：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see that unless you set the `Qt::TextDontClip` flag, the text is clipped
    to the given rectangle; setting `Qt::TextWordWrap` enables line wrapping, and
    `Qt::TextSingleLine` makes the engine ignore any newline characters encountered.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，除非你设置了 `Qt::TextDontClip` 标志，否则文本会被剪切到给定的矩形内；设置 `Qt::TextWordWrap` 启用换行，而
    `Qt::TextSingleLine` 使得引擎忽略遇到的任何换行符。
- en: Static text
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态文本
- en: Qt has to perform a number of calculations when laying out the text, and this
    has to be done each time the text is rendered. This will be a waste of time if
    the text and its attributes have not changed since the last time. To avoid the
    need to recalculate the layout, the concept of static text was introduced.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 在布局文本时必须执行一系列计算，并且每次渲染文本时都必须这样做。如果自上次渲染文本以来文本及其属性没有变化，这将是一种时间浪费。为了避免需要重新计算布局，引入了静态文本的概念。
- en: 'To use it, instantiate `QStaticText` and initialize it with the text you want
    to render along with any options you might want it to have (kept as the `QTextOption`
    instance). Then, store the object somewhere, and whenever you want the text to
    be rendered, just call `QPainter::drawStaticText()`, passing the static text object
    to it. If the layout of the text has not changed since the previous time the text
    was drawn, it will not be recalculated, resulting in improved performance. Here''s
    an example of a custom widget that simply draws text using the static text approach:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，实例化 `QStaticText` 并用你想要渲染的文本以及你可能希望它具有的任何选项（保持为 `QTextOption` 实例）进行初始化。然后，将对象存储在某个地方，每当你想渲染文本时，只需调用
    `QPainter::drawStaticText()`，并将静态文本对象传递给它。如果自上次绘制文本以来文本的布局没有变化，则不会重新计算，从而提高性能。以下是一个使用静态文本方法简单地绘制文本的自定义小部件示例：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Optimizing widget painting
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化小部件绘制
- en: As an exercise, we will modify our oscillogram widget so that it only rerenders
    the part of its data that is required.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，我们将修改我们的示波器小部件，使其只重绘所需的数据部分。
- en: Time for action – Optimizing oscillogram drawing
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 优化示波器绘制
- en: 'The first step is to modify the paint event handling code to fetch information
    about the region that needs updating and pass it to the method drawing the chart.
    The changed parts of the code have been highlighted here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是修改绘制事件处理代码，以获取需要更新的区域信息并将其传递给绘制图表的方法。代码中的改动部分已在此处突出显示：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step is to modify `drawSelection()` to only draw the part of the selection
    that intersects with the exposed rectangle. Luckily, `QRect` offers a method to
    calculate the intersection for us:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修改 `drawSelection()` 函数，使其只绘制与暴露矩形相交的选中部分。幸运的是，`QRect` 提供了一个方法来计算交集：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, `drawChart` needs to be adjusted to omit the values outside the exposed
    rectangle:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要调整 `drawChart` 以省略暴露矩形外的值：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What just happened?
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: By implementing these changes, we have effectively reduced the painted area
    to the rectangle received with the event. In this particular situation, we will
    not save much time as drawing the plot is not that time-consuming; in many situations,
    however, you will be able to save a lot of time using this approach. For example,
    if we were to plot a very detailed aerial map of a game world, it would be very
    expensive to replot the whole map if only a small part of it were modified. We
    can easily reduce the number of calculations and drawing calls by taking advantage
    of the information about the exposed area.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施这些更改，我们已经有效地将绘制的区域减少到事件接收到的矩形。在这种情况下，我们不会节省太多时间，因为绘制图表并不那么耗时；然而，在许多情况下，你将能够使用这种方法节省大量时间。例如，如果我们绘制一个游戏世界的非常详细的空中地图，如果只有一小部分被修改，重新绘制整个地图将非常昂贵。我们可以通过利用暴露区域的信息轻松减少计算和绘制调用的数量。
- en: Making use of the exposed rectangle is already a good step toward efficiency,
    but we can go a step further. The current approach requires that we redraw each
    and every line of the plot within the exposed rectangle, which still takes some
    time. Instead, we can paint those lines only once into a pixmap, and then whenever
    the widget needs repainting, tell Qt to render part of the pixmap to the widget.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 利用暴露矩形已经是提高效率的良好一步，但我们还可以更进一步。当前方法要求我们在暴露矩形内重绘图表的每一行，这仍然需要一些时间。相反，我们可以将这些线条只绘制一次到
    pixmap 中，然后每当小部件需要重绘时，告诉 Qt 将 pixmap 的一部分渲染到小部件上。
- en: Have a go hero – Caching the oscillogram in a pixmap
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 在 pixmap 中缓存示波器
- en: 'Now, it should be very easy for you to implement this approach for our example
    widget. The main difference is that each change to the plot contents should not
    result in a call to `update()` but in a call that will rerender the pixmap and
    then call `update()`. The `paintEvent` method then becomes simply this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该很容易为我们的示例小部件实现这种方法。主要区别在于，对绘图内容的每次更改不应导致调用 `update()`，而应导致调用将重绘 pixmap
    并随后调用 `update()` 的调用。`paintEvent` 方法因此变得非常简单：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You'll also need to rerender the pixmap when the widget is resized. This can
    be done from within the `resizeEvent()` virtual function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在部件大小调整时重新绘制位图。这可以在 `resizeEvent()` 虚拟函数内部完成。
- en: While it is useful to master the available approaches to optimization, it's
    always important to check whether they actually make your application faster.
    There are often cases where the straightforward approach is more optimal than
    a clever optimization. In the preceding example, resizing the widget (and subsequently
    resizing the pixmap) can trigger a potentially expensive memory allocation. Use
    this optimization only if direct painting on the widget is even more expensive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然掌握可用的优化方法很有用，但始终重要的是要检查它们是否实际上使你的应用程序更快。通常情况下，直接的方法比巧妙的优化更优。在先前的例子中，调整部件大小（以及随后调整位图大小）可能会触发潜在的昂贵内存分配。只有当直接在部件上绘制更加昂贵时，才使用此优化。
- en: Implementing a chess game
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现象棋游戏
- en: At this point, you are ready to employ your newly gained skills in rendering
    graphics with Qt to create a game that uses widgets with custom graphics. The
    hero of today will be chess and other chess-like games.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经准备好运用你新获得的使用 Qt 绘制图形的技能来创建一个使用具有自定义图形的部件的游戏。今天的英雄将是象棋和其他类似象棋的游戏。
- en: Time for action – Developing the game architecture
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动了——开发游戏架构
- en: 'Create a new Qt Widgets Application project. After the project infrastructure
    is ready, choose New File or Project from the File menu and choose to create a
    C++ Class. Call the new class `ChessBoard` and set `QObject` as its base class.
    Repeat the process to create a `ChessAlgorithm` class derived from `QObject` and
    another one called `ChessView`, but choose `QWidget` as the base class this time.
    You should end up with a file named `main.cpp` and four classes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Qt Widgets 应用程序项目。在项目基础设施准备就绪后，从文件菜单中选择新建文件或项目，然后选择创建一个 C++ 类。将新类命名为
    `ChessBoard`，并将 `QObject` 设置为其基类。重复此过程以创建一个从 `QObject` 派生的 `ChessAlgorithm` 类，另一个名为
    `ChessView`，但这次选择 `QWidget` 作为基类。你应该会得到一个名为 `main.cpp` 的文件和四个类：
- en: '`MainWindow` will be our main window class that contains a `ChessView`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainWindow` 将是我们的主窗口类，其中包含一个 `ChessView`'
- en: '`ChessView` will be the widget that displays our chess board'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChessView` 将是显示我们的棋盘的部件'
- en: '`ChessAlgorithm` will contain the game logic'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChessAlgorithm` 将包含游戏逻辑'
- en: '`ChessBoard` will hold the state of the chess board and provide it to `ChessView`
    and `ChessAlgorithm`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChessBoard` 将保存棋盘的状态，并将其提供给 `ChessView` 和 `ChessAlgorithm`'
- en: 'Now, navigate to the header file for `ChessAlgorithm` and add the following
    methods to the class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导航到 `ChessAlgorithm` 的头文件，并向该类添加以下方法：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also, add a private `m_board` field of the `ChessBoard*` type. Remember to
    either include `chessboard.h` or forward-declare the `ChessBoard` class. Implement
    `board()` as a simple getter method for `m_board`. The `setBoard()` method will
    be a protected setter for `m_board`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加一个私有的 `m_board` 字段，类型为 `ChessBoard*`。记住要么包含 `chessboard.h`，要么提前声明 `ChessBoard`
    类。实现 `board()` 作为 `m_board` 的简单获取器方法。`setBoard()` 方法将是 `m_board` 的受保护设置器：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, let''s provide a base implementation for `setupBoard()` to create a default
    chess board with eight ranks and eight columns:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为 `setupBoard()` 提供一个基本实现，以创建一个默认的棋盘，具有八行和八列：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The natural place to prepare the board is in a function executed when a new
    game is started:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 准备棋盘的自然地方是在新游戏开始时执行的一个函数中：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The last addition to this class for now is to extend the provided constructor
    to initialize `m_board` to a null pointer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个类最后的添加是将提供的构造函数扩展以初始化 `m_board` 为一个空指针。
- en: In the last method shown, we instantiated a `ChessBoard` object, so let's focus
    on that class now. First, extend the constructor to accept two additional integer
    parameters besides the regular parent argument. Store their values in private
    `m_ranks` and `m_columns` fields (remember to declare the fields themselves in
    the class header file).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后显示的方法中，我们实例化了一个 `ChessBoard` 对象，所以现在让我们关注这个类。首先，扩展构造函数以接受两个额外的整数参数，除了常规的父参数。将它们的值存储在私有的
    `m_ranks` 和 `m_columns` 字段中（记住在类头文件中声明这些字段本身）。
- en: 'In the header file, just under the `Q_OBJECT` macro, add the following two
    lines as property definitions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，在 `Q_OBJECT` 宏下方，添加以下两行作为属性定义：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Declare signals and implement getter methods to cooperate with those definitions.
    Also, add two protected methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 声明信号并实现获取器方法以与这些定义协同工作。此外，添加两个受保护的方法：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These will be setters for the rank and column properties, but we don't want
    to expose them to the outside world, so we will give them `protected` access scope.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将是等级和列属性的设置器，但我们不希望将它们暴露给外部世界，因此我们将给它们 `protected` 访问范围。
- en: 'Put the following code into the `setRanks()` method body:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入 `setRanks()` 方法体中：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, in a similar way, you can implement `setColumns()`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以类似的方式，你可以实现 `setColumns()`。
- en: 'The last class we will deal with now is our custom widget, `ChessView`. For
    now, we will provide only a rudimentary implementation for one method, but we
    will expand it later as our implementation grows. Add a public `setBoard(ChessBoard
    *)` method with the following body:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要处理的最后一个类是我们的自定义小部件，`ChessView`。目前，我们只为一个方法提供一个基本的实现，但随着我们的实现逐渐完善，我们将在以后扩展它。添加一个公共的
    `setBoard(ChessBoard *)` 方法，其内容如下：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s declare the `m_board` member. As we are not the owners of the board
    object (the algorithm class is responsible for managing it), we will use the `QPointer`
    class, which tracks the lifetime of `QObject` and sets itself to null once the
    object is destroyed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们声明 `m_board` 成员。由于我们不是棋盘对象的所有者（算法类负责管理它），我们将使用 `QPointer` 类，该类跟踪 `QObject`
    的生命周期，并在对象被销毁后将其自身设置为 null：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`QPointer` initializes its value to null, so we don''t have to do it ourselves
    in the constructor. For completeness, let''s provide a getter method for the board:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPointer` 将其值初始化为 null，所以我们不需要在构造函数中自己初始化它。为了完整性，让我们提供一个获取棋盘的方法：'
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: What just happened?
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'In the last exercise, we defined the base architecture for our solution. We
    can see that there are three classes involved: `ChessView` acting as the user
    interface, `ChessAlgorithm` for driving the actual game, and `ChessBoard` as a
    data structure shared between the view and the engine. The algorithm will be responsible
    for setting up the board (through `setupBoard()`), making moves, checking win
    conditions, and so on. The view will be rendering the current state of the board
    and will signal user interaction to the underlying logic.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个练习中，我们定义了我们解决方案的基架构。我们可以看到有三个类参与：`ChessView` 作为用户界面，`ChessAlgorithm` 用于驱动实际游戏，`ChessBoard`
    作为视图和引擎之间共享的数据结构。算法将负责设置棋盘（通过 `setupBoard()`），进行移动，检查胜利条件等。视图将渲染棋盘的当前状态，并将用户交互信号传递给底层逻辑。
- en: Most of the code is self-explanatory. You can see in the `ChessView::setBoard()`
    method that we are disconnecting all signals from an old board object, attaching
    the new one (we will come back to connecting the signals later when we have already
    defined them), and finally telling the widget to update its size and redraw itself
    with the new board.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都是自解释的。你可以在 `ChessView::setBoard()` 方法中看到，我们正在断开旧棋盘对象的所有信号，连接新的对象（我们将在稍后定义信号时再回来连接信号），最后告诉小部件更新其大小并使用新的棋盘重新绘制自己。
- en: Time for action – Implementing the game board class
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 实现游戏棋盘类
- en: 'Now we will focus on our data structure. Add a new private member to `ChessBoard`,
    a vector of characters that will contain information about pieces on the board:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注我们的数据结构。向 `ChessBoard` 添加一个新的私有成员，一个包含棋盘上棋子信息的字符向量：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Consider the following table that shows the piece type and the letters used
    for it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表格，它显示了棋子类型和用于它的字母：
- en: '| Piece type |  | White | Black |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 飞行类型 |  | 白色 | 黑色 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ![](img/a5eb6d64-b6b8-4344-beb4-6a0d23d08e5c.png)![](img/2dda234d-fdfe-4be0-9b36-d9ee1dd70486.png)
    | King | K | k |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| ![图片5](img/a5eb6d64-b6b8-4344-beb4-6a0d23d08e5c.png)![](img/2dda234d-fdfe-4be0-9b36-d9ee1dd70486.png)
    | 国王 | K | k |'
- en: '| ![](img/a6bb3af1-bb15-410d-8de6-301393e517bf.jpg) ![](img/de3320da-fb85-4d7e-9443-1cb66365436b.png)
    | Queen | Q | q |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| ![图片3](img/a6bb3af1-bb15-410d-8de6-301393e517bf.jpg) ![图片4](img/de3320da-fb85-4d7e-9443-1cb66365436b.png)
    | 女王 | Q | q |'
- en: '| ![](img/5e99e21e-bfda-447b-b556-9adcd9e352aa.png) ![](img/1c63c299-5f79-486c-8989-b93c9031aee0.jpg)
    | Rook | R | r |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| ![图片8](img/5e99e21e-bfda-447b-b556-9adcd9e352aa.png) ![图片9](img/1c63c299-5f79-486c-8989-b93c9031aee0.jpg)
    | 车辆 | R | r |'
- en: '| ![](img/c2a5c597-ac35-4ae2-9ecb-2c308b83fde9.jpg) ![](img/bb149e00-8633-4c11-82e6-faac23536bc4.jpg)
    | Bishop | B | b |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| ![图片10](img/c2a5c597-ac35-4ae2-9ecb-2c308b83fde9.jpg) ![图片11](img/bb149e00-8633-4c11-82e6-faac23536bc4.jpg)
    | 象 | B | b |'
- en: '| ![](img/bb697436-b5be-4312-951d-d6eaa7fcf179.jpg) ![](img/a32f3941-3593-475f-bf94-e47f5a3837ac.jpg)
    | Knight | N | n |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| ![图片1](img/bb697436-b5be-4312-951d-d6eaa7fcf179.jpg) ![图片2](img/a32f3941-3593-475f-bf94-e47f5a3837ac.jpg)
    | 骑士 | N | n |'
- en: '| ![](img/4f17458d-cec3-48d8-a1ce-156d1d8ff7c4.jpg) ![](img/05af7208-dcbb-4c6b-9a0d-053293de1ada.jpg)
    | Pawn | P | P |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| ![图片6](img/4f17458d-cec3-48d8-a1ce-156d1d8ff7c4.jpg) ![图片7](img/05af7208-dcbb-4c6b-9a0d-053293de1ada.jpg)
    | 兵 | P | P |'
- en: 'You can see that white pieces use uppercase letters and black pieces use lowercase
    variants of the same letters. In addition to that, we will use a space character
    (0x20 ASCII value) to denote that a field is empty. We will add a protected method
    for setting up an empty board based on the number of ranks and columns on the
    board and a `boardReset()` signal to inform that the position on the board has
    changed:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，白棋使用大写字母，黑棋使用相同字母的小写变体。此外，我们将使用空格字符（ASCII值为0x20）来表示空位。我们将添加一个受保护的设置空棋盘的方法，基于棋盘上的行数和列数，以及一个`boardReset()`信号来通知棋盘上的位置已更改：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can update our methods for setting rank and column counts to make use of
    that method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新设置行和列计数的现有方法，以便利用该方法：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `initBoard()` method should also be called from within the constructor,
    so place the call there as well.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`initBoard()`方法也应该在构造函数内部调用，所以也要在那里放置调用。'
- en: 'Next, we need a method to read which piece is positioned in a particular field
    of the board:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个方法来读取棋盘特定位置上的棋子：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Ranks and columns have indexes starting from 1, but the data structure is indexed
    starting from 0; therefore, we have to subtract 1 from both the rank and column
    index. It is also required to have a method to modify the data for the board.
    Implement the following public method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 行和列的索引从1开始，但数据结构从0开始索引；因此，我们必须从行和列索引中减去1。还需要有一个方法来修改棋盘的数据。实现以下公共方法：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The method makes use of another one that does the actual job. However, this
    method should be declared with `protected` access scope. Again, we adjust for
    index differences:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用了另一个实际执行工作的方法。然而，这个方法应该声明为`protected`访问范围。再次，我们调整索引差异：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since `setData()` makes use of a signal, we have to declare it as well:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`setData()`使用了信号，我们必须声明它：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The signal will be emitted every time there is a successful change to the situation
    on the board. We delegate the actual work to the protected method to be able to
    modify the board without emitting the signal.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 每当棋盘上的情况成功更改时，将发出信号。我们将实际工作委托给受保护的方方法，以便在不发出信号的情况下修改棋盘。
- en: 'Having defined `setData()`, we can add another method for our convenience:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`setData()`之后，我们可以添加另一个方便的方法：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Can you guess what it does? That's right! It moves a piece from one field to
    another one, leaving an empty space behind.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到它做什么吗？没错！它将一个棋子从一个位置移动到另一个位置，并在后面留下一个空位。
- en: 'There is still one more method worth implementing. A regular chess game contains
    32 pieces, and there are variants of the game where starting positions for the
    pieces might be different. Setting the position of each piece through a separate
    call to `setData()` would be very cumbersome. Fortunately, there is a neat chess
    notation called the **Forsyth-Edwards Notation** (**FEN**), with which the complete
    state of the game can be stored as a single line of text. If you want the complete
    definition of the notation, you can look it up yourself. In short, we can say
    that the textual string lists piece placement rank by rank, starting from the
    last rank where each position is described by a single character interpreted as
    in our internal data structure (`K` for white king, `q` for black queen, and so
    on). Each rank description is separated by a `/` character. If there are empty
    fields on the board, they are not stored as spaces, but as a digit specifying
    the number of consecutive empty fields. Therefore, the starting position for a
    standard game can be written as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个方法值得实现。标准的国际象棋游戏包含32个棋子，而游戏变体中棋子的起始位置可能不同。通过单独调用`setData()`来设置每个棋子的位置将会非常繁琐。幸运的是，存在一种整洁的棋盘表示法，称为**福赛斯-爱德华斯记法**（**FEN**），它可以将整个游戏状态存储为单行文本。如果你想要了解记法的完整定义，你可以自己查阅。简而言之，我们可以这样说，文本字符串按行排列棋子的位置，从最后一行开始，每一行由一个字符描述，该字符按照我们内部的数据结构进行解释（例如，`K`代表白王，`q`代表黑后，等等）。每一行的描述由一个`/`字符分隔。如果棋盘上有空位，它们不会存储为空格，而是用一个数字指定连续空位的数量。因此，标准游戏的起始位置可以写成如下：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This can be interpreted visually, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以直观地解释如下：
- en: '![](img/91155804-2828-48c5-ba5f-786aa686d7c9.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91155804-2828-48c5-ba5f-786aa686d7c9.png)'
- en: 'Let''s write a method called `setFen()` to set up the board based on an FEN
    string:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为`setFen()`的方法，根据FEN字符串设置棋盘：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The method iterates over all fields on the board and determines whether it is
    currently in the middle of inserting empty fields on the board or should rather
    read the next character from the string. If a digit is encountered, it is converted
    into an integer by subtracting the ASCII value of the 0 character (that is, `'7'
    - '0'` = 7). After setting each rank, we require that a slash or a space be read
    from the string. Otherwise, we reset the board to an empty one and bail out of
    the method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法遍历棋盘上的所有字段，并确定它是否正在中间插入空字段，或者应该从字符串中读取下一个字符。如果遇到数字，它将通过减去字符 '0' 的ASCII值（即
    `'7' - '0'` = 7）将其转换为整数。在设置每一行后，我们要求从字符串中读取一个斜杠或空格。否则，我们将棋盘重置为空棋盘，并退出该方法。
- en: What just happened?
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We taught the `ChessBoard` class to store simple information about chess pieces
    using a one-dimensional array of characters. We also equipped it with methods
    that allow querying and modifying game data. We implemented a fast way of setting
    the current state of the game by adopting the FEN standard. The game data itself
    is not tied to classic chess. Although we comply with a standard notation for
    describing pieces, it is possible to use other letters and characters outside
    the well-defined set for chess pieces. This creates a versatile solution for storing
    information about chess-like games, such as checkers, and possibly any other custom
    games played on a two-dimensional board of any size with ranks and columns. The
    data structure we came up with is not a stupid one—it communicates with its environment
    by emitting signals when the state of the game is modified.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们教会了 `ChessBoard` 类使用字符的单维数组存储关于棋子的简单信息。我们还为其配备了允许查询和修改游戏数据的方法。我们通过采用 FEN 标准，实现了一种快速设置游戏当前状态的方法。游戏数据本身并不局限于经典象棋。尽管我们遵守了用于描述棋子的标准记法，但仍然可以使用其他字母和字符，这些字母和字符超出了定义良好的棋子集。这为存储类似象棋的游戏信息提供了一种灵活的解决方案，例如跳棋，以及可能在任何大小和行列的二维棋盘上玩的其他自定义游戏。我们提出的数据结构并非愚蠢——它通过在游戏状态被修改时发出信号与环境进行通信。
- en: Time for action – Understanding the ChessView class
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 理解 ChessView 类
- en: This is a chapter about doing graphics, so it is high time we focus on displaying
    our chess game. Our widget currently displays nothing, and our first task will
    be to show a chess board with rank and column symbols and fields colored appropriately.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于图形处理的章节，所以现在是时候关注显示我们的棋盘游戏了。我们的部件目前什么都没有显示，我们的第一个任务将是显示带有行列符号并适当着色的棋盘。
- en: 'By default, the widget does not have any proper size defined, and we will have
    to fix that by implementing `sizeHint()`. However, to be able to calculate the
    size, we have to decide how big a single field on the board will be. Therefore,
    in `ChessView`, you should declare a property containing the size of the field,
    as shown:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，部件没有定义任何合适的尺寸，我们必须通过实现 `sizeHint()` 来解决这个问题。然而，为了能够计算尺寸，我们必须决定棋盘上单个字段的大小。因此，在
    `ChessView` 中，你应该声明一个包含字段大小的属性，如下所示：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To speed up coding, you can position the cursor over the property declaration,
    hit the *Alt* + *Enter* combination, and choose the Generate missing Q_PROPERTY
    members fix-up from the pop-up menu. Creator will provide minor implementations
    for the getter and setter for you. You can move the generated code to the implementation
    file by positioning the cursor over each method, hitting *Alt* + *Enter*, and
    choosing the Move definition to chessview.cpp file fixup. While the generated
    getter method is fine, the setter needs some adjusting. Modify it by adding the
    following highlighted code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快编码速度，你可以将光标置于属性声明上，按下 *Alt* + *Enter* 组合键，并从弹出菜单中选择“生成缺失的 Q_PROPERTY 成员修复”。Creator
    将为你提供getter和setter的简单实现。你可以通过将光标置于每个方法上，按下 *Alt* + *Enter*，并选择“将定义移动到 chessview.cpp
    文件修复”来将生成的代码移动到实现文件。虽然生成的getter方法很好，但setter需要一些调整。通过添加以下高亮代码来修改它：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This tells our widget to recalculate its size whenever the size of the field
    is modified. Now we can implement `sizeHint()`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令告诉我们的部件，每当字段大小被修改时，都要重新计算其大小。现在我们可以实现 `sizeHint()`：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: First, we check whether we have a valid board definition and if not, return
    a sane size of 100 × 100 pixels. Otherwise, the method calculates the size of
    all the fields by multiplying the size of each of the fields by the number of
    columns or ranks. We add one pixel to each dimension to accommodate the right
    and bottom border. A chess board not only consists of fields themselves but also
    displays rank symbols on the left edge of the board and column numbers on the
    bottom edge of the board.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否有有效的棋盘定义，如果没有，则返回一个合理的100 × 100像素大小。否则，该方法通过将每个字段的大小乘以列数或等级数来计算所有字段的大小。我们在每个维度上添加一个像素以容纳右侧和底部边框。棋盘不仅由字段本身组成，还在棋盘的左侧边缘显示等级符号，在棋盘的底部边缘显示列号。
- en: Since we use letters to enumerate ranks, we check the width of the widest letter
    using the `QFontMetrics` class. We use the same class to check how much space
    is required to render a line of text using the current font so that we have enough
    space to put column numbers. In both cases, we add 4 to the result to make a 2
    pixel margin between the text and the edge of the board and another 2 pixel margin
    between the text and the edge of the widget.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用字母来枚举等级，我们使用`QFontMetrics`类检查最宽字母的宽度。我们使用相同的类来检查使用当前字体渲染一行文本所需的空间，以便我们有足够的空间放置列号。在这两种情况下，我们将结果增加4，以便在文本和棋盘边缘之间以及文本和部件边缘之间留出2像素的边距。
- en: Actually, the widest letter in the most common fonts is W, but it won't appear
    in our game.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在最常见的字体中，最宽的字母是W，但它在我们的游戏中不会出现。
- en: 'It is very useful to define a helper method for returning a rectangle that
    contains a particular field, as shown:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个辅助方法来返回包含特定字段的矩形非常有用，如下所示：
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since rank numbers decrease from the top toward the bottom of the board, we
    subtract the desired rank from the maximum rank there is while calculating `fRect`.
    Then, we calculate the horizontal offset for rank symbols, just like we did in
    `sizeHint()`, and translate the rectangle by that offset before returning the
    result.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于等级数字从棋盘顶部到底部递减，我们在计算`fRect`时从最大等级中减去所需的等级。然后，我们像在`sizeHint()`中做的那样计算等级符号的水平偏移量，并在返回结果之前将矩形平移该偏移量。
- en: 'Finally, we can move on to implementing the event handler for the paint event.
    Declare the `paintEvent()` method (the fixup menu available under the *Alt* +
    *Enter* keyboard shortcut will let you generate a stub implementation of the method)
    and fill it with the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以继续实现绘制事件的处理器。声明`paintEvent()`方法（在*Alt* + *Enter*键盘快捷键下可用的修复菜单将允许您生成方法的存根实现）并填充以下代码：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The handler is quite simple. First, we instantiate the `QPainter` object that
    operates on the widget. Then, we have three loops: the first one iterates over
    ranks, the second over columns, and the third over all fields. The body of each
    loop is very similar; there is a call to a custom draw method that accepts a pointer
    to the painter and index of the rank, column, or both of them, respectively. Each
    of the calls is surrounded by executing `save()` and `restore()` on our `QPainter`
    instance. What are the calls for here? The three draw methods—`drawRank()`, `drawColumn()`,
    and `drawField()`—will be virtual methods responsible for rendering the rank symbol,
    the column number, and the field background. It will be possible to subclass `ChessView`
    and provide custom implementations for those renderers so that it is possible
    to provide a different look of the chess board. Since each of these methods takes
    the painter instance as its parameter, overrides of these methods can alter attribute
    values of the painter behind our back. Calling `save()` before handing over the
    painter to such override stores its state on an internal stack, and calling `restore()`
    after returning from the override resets the painter to what was stored with `save()`.
    Note that the painter can still be left in an invalid state if the override calls
    `save()` and `restore()`  a different number of times.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序相当简单。首先，我们实例化操作小部件的 `QPainter` 对象。然后，我们有三个循环：第一个遍历等级，第二个遍历列，第三个遍历所有字段。每个循环的体非常相似；都有一个调用自定义绘制方法的调用，该方法接受指向画家的指针和等级、列或两者的索引。每个调用都围绕在我们的
    `QPainter` 实例上执行 `save()` 和 `restore()`。这里的调用有什么用？三个绘制方法——`drawRank()`、`drawColumn()`
    和 `drawField()`——将是负责渲染等级符号、列号和字段背景的虚拟方法。将能够子类化 `ChessView` 并为这些渲染器提供自定义实现，以便能够提供不同的棋盘外观。由于这些方法都接受画家实例作为其参数，因此这些方法的覆盖可以改变画家背后的属性值。在将画家传递给此类覆盖之前调用
    `save()` 会将状态存储在内部堆栈上，并在覆盖返回后调用 `restore()` 会将画家重置为 `save()` 存储的状态。请注意，如果覆盖调用
    `save()` 和 `restore()` 的次数不同，画家仍然可能处于无效状态。
- en: Calling `save()` and `restore()` very often introduces a performance hit, so
    you should avoid saving and restoring painter states too often in time-critical
    situations. As our painting is very simple, we don't have to worry about that
    when painting our chess board.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 频繁调用 `save()` 和 `restore()` 会引入性能损失，因此在时间敏感的情况下应避免频繁保存和恢复画家状态。由于我们的绘制非常简单，所以在绘制棋盘时我们不必担心这一点。
- en: 'Having introduced our three methods, we can start implementing them. Let''s
    start with `drawRank` and `drawColumn`. Remember to declare them as virtual and
    put them in protected access scope (that''s usually where Qt classes put such
    methods), as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了我们的三种方法后，我们可以开始实施它们。让我们从 `drawRank` 和 `drawColumn` 开始。请记住将它们声明为虚拟的，并将它们放在受保护的访问范围内（通常Qt类将此类方法放在那里），如下所示：
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Both methods are very similar. We use `fieldRect()` to query for the left-most
    column and bottom-most rank, and, based on that, we calculate where rank symbols
    and column numbers should be placed. The call to `QRect::adjusted()` is to accommodate
    the 2 pixel margin around the text to be drawn. Finally, we use `drawText()` to
    render appropriate text. For the rank, we ask the painter to align the text to
    the right edge of the rectangle and to center the text vertically. In a similar
    way, when drawing the column, we align to the top edge and center the text horizontally.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法非常相似。我们使用 `fieldRect()` 查询最左列和最底等级，然后根据这个计算等级符号和列号应该放置的位置。调用 `QRect::adjusted()`
    是为了适应要绘制的文本周围的2像素边距。最后，我们使用 `drawText()` 来渲染适当的文本。对于等级，我们要求画家将文本对齐到矩形的右边缘并垂直居中文本。以类似的方式，在绘制列时，我们将文本对齐到顶部边缘并水平居中文本。
- en: 'Now we can implement the third draw method. It should also be declared protected
    and virtual. Place the following code in the method body:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现第三个绘制方法。它也应该声明为受保护和虚拟的。将以下代码放在方法体中：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this method, we use the `QPalette` object coupled with each widget to query
    for `Light` (usually white) and `Mid` (darkish) color, depending on whether the
    field we are drawing on the chess board is considered white or black. We do that
    instead of hardcoding the colors to make it possible to modify colors of the tiles
    without subclassing simply by adjusting the palette object. Then, we use the palette
    again to ask for the `Dark` color and use that as a pen for our painter. When
    we draw a rectangle with such settings, the pen will stroke the border of the
    rectangle to give it a more elegant look. Note how we modify attributes of the
    painter in this method and do not set them back afterward. We can get away with
    it because of the `save()` and `restore()` calls surrounding the `drawField()`
    execution.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们使用与每个部件耦合的`QPalette`对象来查询`Light`（通常是白色）和`Mid`（较暗）颜色，这取决于我们在棋盘上绘制的字段是否被认为是白色或黑色。我们这样做而不是硬编码颜色，以便可以通过调整调色板对象来修改瓷砖的颜色，而无需子类化。然后，我们再次使用调色板来请求`Dark`颜色，并将其用作画家的笔。当我们用这样的设置绘制矩形时，笔将勾勒出矩形的边缘，使其看起来更优雅。注意我们如何在方法中修改画家的属性，并在之后不将其设置回原位。我们可以这样做是因为`save()`和`restore()`调用包围了`drawField()`的执行。
- en: 'We are now ready to see the results of our work. Let''s switch to the `MainWindow`
    class and equip it with the following two private variables:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查看我们工作的结果了。让我们切换到`MainWindow`类，并为其配备以下两个私有变量：
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, modify the constructor by adding the following highlighted code to set
    up the view and the game engine:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过添加以下突出显示的代码来修改构造函数，设置视图和游戏引擎：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Afterward, you should be able to build the project. When you run it, you should
    see a result similar to the one in the following screenshot:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你应该能够构建项目。当你运行它时，你应该看到以下截图中的类似结果：
- en: '![](img/d8889080-7000-424f-bb79-aab60a893d2b.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8889080-7000-424f-bb79-aab60a893d2b.png)'
- en: What just happened?
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: In this exercise, we did two things. First, we provided a number of methods
    for calculating the geometry of important parts of the chess board and the size
    of the widget. Second, we defined three virtual methods for rendering visual primitives
    of a chess board. By making the methods virtual, we provided an infrastructure
    to let the look be customized by subclassing and overriding base implementations.
    Furthermore, by reading color from `QPalette`, we allowed customizing the colors
    of the primitives even without subclassing.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们做了两件事。首先，我们提供了一些方法来计算棋盘重要部分的几何形状和部件的大小。其次，我们定义了三个用于渲染棋盘视觉原语的方法。通过使方法虚拟，我们提供了一个基础设施，允许通过子类化和覆盖基本实现来自定义外观。此外，通过从`QPalette`读取颜色，我们允许在不进行子类化的情况下自定义原语的颜色。
- en: The last line of the main window constructor tells the layout of the window
    to force a fixed size of the window equal to what the size hint of the widget
    inside it reports.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 主窗口构造函数的最后一行告诉布局将窗口的大小强制设置为内部部件的大小提示。
- en: Time for action – Rendering the pieces
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 渲染棋子
- en: Now that we can see the board, it is time to put the pieces on it. We will use
    images for that purpose. In my case, we found a number of SVG files with chess
    pieces and decided to use them. SVG is a vector graphics format where all curves
    are defined not as a fixed set of points but as mathematic curves. Their main
    benefit is that they scale very well without causing an aliasing effect.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能看到棋盘了，是时候在上面放置棋子了。我们将使用图像来完成这个任务。在我的情况下，我们找到了一些包含棋子的SVG文件，并决定使用它们。SVG是一种矢量图形格式，其中所有曲线都是定义为数学曲线，而不是固定点集。它们的主要好处是它们可以很好地缩放，而不会产生锯齿效应。
- en: 'Let''s equip our view with a registry of images to be used for "stamping" a
    particular piece type. Since each piece type is identified with char, we can use
    it to generate keys for a map of images. Let''s put the following API into `ChessView`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的视图配备一个用于“打印”特定棋子类型的图像注册表。由于每个棋子类型都与字符相关联，我们可以使用它来生成图像映射的键。让我们将以下API放入`ChessView`：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For the image type, we do not use `QImage` or `QPixmap` but `QIcon`. This is
    because `QIcon` can store many pixmaps of different sizes and use the most appropriate
    one when we request an icon of a given size to be painted. It doesn't matter if
    we use vector images, but it does matter if you choose to use PNG or other types
    of image. In such cases, you can use `addFile()` to add many images to a single
    icon.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像类型，我们不使用`QImage`或`QPixmap`，而是使用`QIcon`。这是因为`QIcon`可以存储不同大小的多个位图，并在请求绘制给定大小的图标时使用最合适的一个。如果我们使用矢量图像，这无关紧要，但如果选择使用PNG或其他类型的图像，则很重要。在这种情况下，可以使用`addFile()`向单个图标添加多个图像。
- en: 'Going back to our registry, the implementation is very simple. We just store
    the icon in a map and ask the widget to repaint itself:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的注册表中，实现非常简单。我们只需将图标存储在映射中，并要求小部件重新绘制自己：
- en: '[PRE58]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we can fill the registry with actual images right after we create the view
    inside the `MainWindow` constructor. Note that we stored all the images in a resource
    file, as shown:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`MainWindow`构造函数中的视图后立即用实际图像填充注册表。请注意，我们已将所有图像存储在资源文件中，如下所示：
- en: '[PRE59]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next thing to do is to extend the `paintEvent()` method of the view to
    actually render our pieces. For that, we will introduce another protected virtual
    method called `drawPiece()`. We''ll call it when iterating over all the ranks
    and columns of the board, as shown:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是扩展视图的`paintEvent()`方法，以实际渲染我们的棋子。为此，我们将引入另一个受保护的虚拟方法，称为`drawPiece()`。我们将在遍历棋盘的所有等级和列时调用它，如下所示：
- en: '[PRE60]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It is not a coincidence that we start drawing from the highest (top) rank to
    the lowest (bottom) one. By doing that, we allow a pseudo-3D effect; if a piece
    drawn extends past the area of the field, it will intersect the field from the
    next rank (which is possibly occupied by another piece). By drawing higher rank
    pieces first, we cause them to be partially covered by pieces from the lower rank,
    which imitates the effect of depth. By thinking ahead, we allow reimplementations
    of `drawPiece()` to have more freedom in what they can do.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从最高（顶部）等级到最低（底部）等级开始绘制并非巧合。通过这样做，我们允许产生伪3D效果；如果一个绘制的棋子超出了棋盘区域，它将从下一个等级（可能被另一个棋子占据）与棋盘相交。通过首先绘制较高等级的棋子，我们使它们被较低等级的棋子部分覆盖，从而模仿深度效果。通过提前思考，我们允许`drawPiece()`的重实现有更多的自由度。
- en: 'The final step is to provide a base implementation for this method, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是为该方法提供一个基本实现，如下所示：
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The method is very simple; it queries for the rectangle of a given column and
    rank and then asks the `ChessBoard` instance about the piece occupying the given
    field. If there is a piece there, we ask the registry for the proper icon; if
    we get a valid one, we call its `paint()` routine to draw the piece centered in
    the field's rect. The image drawn will be scaled to the size of the rectangle.
    It is important that you only use images with a transparent background (such as
    PNG or SVG files and not JPEG files) so that the color of the field can be seen
    through the piece.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法非常简单；它查询给定列和等级的矩形，然后询问`ChessBoard`实例关于给定场地上占据的棋子。如果那里有棋子，我们要求注册表提供适当的图标；如果得到一个有效的图标，我们调用其`paint()`例程在场地矩形中绘制棋子。绘制的图像将被缩放到矩形的大小。重要的是，你只能使用具有透明背景的图像（如PNG或SVG文件，而不是JPEG文件），以便可以看到场地的颜色。
- en: What just happened?
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'To test the implementation, you can modify the algorithm to fill the board
    with the default piece set up by introducing the following change to the `ChessAlgorithm`
    class:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试实现，你可以修改算法，通过向`ChessAlgorithm`类引入以下更改来填充棋盘上的默认棋子设置：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Running the program should show the following result:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序应显示以下结果：
- en: '![](img/c6ebcd58-228f-4567-b7ef-a4a6916db4d4.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6ebcd58-228f-4567-b7ef-a4a6916db4d4.png)'
- en: 'The modification we did in this step was very simple. First, we provided a
    way to tell the board what each piece type looks like. This includes not only
    standard chess pieces but anything that fits into char and can be set inside the
    `ChessBoard` class''s internal data array. Second, we made an abstraction for
    drawing the pieces with the simplest possible base implementation: taking an icon
    from the registry and rendering it to the field. By making use of `QIcon`, we
    can add several pixmaps of different sizes to be used with different sizes of
    a single field. Alternatively, the icon can contain a single vector image that
    scales very well all by itself.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中我们做的修改非常简单。首先，我们提供了一种方法来告诉棋盘每种棋子类型的外观。这包括标准棋子以及任何可以设置在`ChessBoard`类内部数据数组中的、适合char类型的东西。其次，我们为用最简单的基类实现绘制棋子进行了抽象：从一个注册表中获取图标并将其渲染到字段上。通过使用`QIcon`，我们可以添加几个不同大小的位图，用于不同大小的单个字段。或者，图标可以包含一个单矢量图像，它可以自行很好地缩放。
- en: Time for action – Making the chess game interactive
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使棋盘游戏交互化
- en: 'We have managed to display the chess board, but to actually play a game, we
    have to tell the program what moves we want to play. We can do that by adding
    the `QLineEdit` widget where we will input the move in algebraic form (for example,
    `Nf3` to move a knight to `f3`), but a more natural way is to click on a piece
    with the mouse cursor (or tap it with a finger) and then click again on the destination
    field. To obtain such functionality, the first thing to do is to teach `ChessView`
    to detect mouse clicks. Therefore, add the following method:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功显示了棋盘，但要实际玩游戏，我们必须告诉程序我们想要进行的移动。我们可以通过添加`QLineEdit`小部件来实现，我们将在这里以代数形式输入移动（例如，`Nf3`将马移动到`f3`），但更自然的方式是使用鼠标光标（或用手指轻触）点击一个棋子，然后再次点击目标字段。为了获得这种功能，首先要做的是教会`ChessView`检测鼠标点击。因此，添加以下方法：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The code looks very similar to the implementation of `fieldRect()`. This is
    because `fieldAt()` implements its reverse operation—it transforms a point in
    the widget coordinate space to the column and rank index of a field the point
    is contained in. The index is calculated by dividing point coordinates by the
    size of the field. You surely remember that, in the case of columns, the fields
    are offset by the size of the widest letter and a margin of 4, and we have to
    consider that in our calculations here as well. We do two checks: first we check
    the horizontal point coordinate against the offset to detect whether the user
    clicked on the part of the widget where column symbols are displayed, and then
    we check whether the rank and column calculated fit the range represented in the
    board. Finally, we return the result as a `QPoint` value, since this is the easiest
    way in Qt to represent a two-dimensional value.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来与`fieldRect()`的实现非常相似。这是因为`fieldAt()`实现了其逆操作——它将小部件坐标空间中的一个点转换为包含该点的字段的列和行索引。索引是通过将点坐标除以字段大小来计算的。你肯定记得，在列的情况下，字段通过最宽字母的大小和4个边距进行偏移，我们在这里的计算中也要考虑这一点。我们进行两个检查：首先，我们将水平点坐标与偏移量进行比较，以检测用户是否点击了显示列符号的部分，然后我们检查计算出的行和列是否适合在棋盘上表示的范围。最后，我们将结果作为`QPoint`值返回，因为这是在Qt中表示二维值最简单的方式。
- en: 'Now we need to find a way to make the widget notify its environment that a
    particular field was clicked on. We can do this through the signal-slot mechanism.
    Switch to the header file of `ChessView` (if you currently have `chessview.cpp`
    opened in Qt Creator, you can simply press the *F4* key to be transferred to the
    corresponding header file) and declare a `clicked(const QPoint &)` signal:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找到一种方法让小部件通知其环境某个特定字段已被点击。我们可以通过信号-槽机制来实现。切换到`ChessView`的头文件（如果你目前在Qt
    Creator中打开了`chessview.cpp`，你可以简单地按*F4*键跳转到相应的头文件）并声明一个`clicked(const QPoint &)`信号：
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To detect mouse input, we have to override one of the mouse event handlers
    a widget has: either `mousePressEvent` or `mouseReleaseEvent`. It seems obvious
    that we should choose the former event; this would work, but it is not the best
    decision. Just think about the semantics of a mouse click: it is a complex event
    composed of pushing and releasing the mouse button. The actual "click" takes place
    after the mouse is released. Therefore, let''s use `mouseReleaseEvent` as our
    event handler:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测鼠标输入，我们必须重写小部件具有的一个鼠标事件处理程序：要么是`mousePressEvent`，要么是`mouseReleaseEvent`。显然，我们应该选择前者事件；这会起作用，但这并不是最佳选择。让我们思考一下鼠标点击的语义：它是由按下和释放鼠标按钮组成的复杂事件。实际的“点击”发生在鼠标释放之后。因此，让我们使用`mouseReleaseEvent`作为我们的事件处理程序：
- en: '[PRE65]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The code is simple; we use the method we just implemented and pass it the position
    read from the `QMouseEvent` object. If the returned point is invalid, we quietly
    return from the method. Otherwise, `clicked()` is emitted with the obtained column
    and rank values.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单；我们使用刚刚实现的方法，并传递从`QMouseEvent`对象中读取的位置。如果返回的点无效，我们默默地从方法中返回。否则，将发出带有获取到的列和行值的`clicked()`。
- en: 'We can make use of the signal now. Go to the constructor of `MainWindow` and
    add the following line to connect the widget''s clicked signal to a custom slot:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用这个信号了。转到`MainWindow`的构造函数，并添加以下行以将小部件的点击信号连接到自定义槽位：
- en: '[PRE66]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Declare the slot and implement it, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 声明槽位并实现它，如下所示：
- en: '[PRE67]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The function uses a class member variable—`m_clickPoint`—to store the clicked
    field. The variable value is made invalid after a move is made. Thus, we can detect
    whether the click we are currently handling has "select" or "move" semantics.
    In the first case, we store the selection in `m_clickPoint`; in the other case,
    we ask the board to make a move using the helper method we implemented some time
    ago. Remember to declare `m_clickPoint` as a private member variable of `MainWindow`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用一个类成员变量—`m_clickPoint`—来存储点击的棋盘区域。在移动之后，该变量的值会被设置为无效。因此，我们可以检测我们当前正在处理的点击是具有“选择”还是“移动”语义。在前一种情况下，我们将选择存储在`m_clickPoint`中；在另一种情况下，我们使用我们之前实现的一些辅助方法请求棋盘进行移动。请记住将`m_clickPoint`声明为`MainWindow`的私有成员变量。
- en: 'All should be working now. However, if you build the application, run it, and
    start clicking around on the chess board, you will see that nothing happens. This
    is because we forgot to tell the view to refresh itself when the game position
    on the board is changed. We have to connect the signals that the board emits to
    the `update()` slot of the view. Open the `setBoard()` method of the widget class
    and fix it, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切应该都正常工作了。然而，如果你构建应用程序，运行它，并在棋盘上开始点击，你会发现没有任何反应。这是因为我们忘记告诉视图在棋盘上的游戏位置改变时刷新自己。我们必须将棋盘发出的信号连接到视图的`update()`槽位。打开小部件类的`setBoard()`方法并修复它，如下所示：
- en: '[PRE68]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If you run the program now, moves you make will be reflected in the widget,
    as shown:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行程序，你做出的移动将在小部件中反映出来，如下所示：
- en: '![](img/73c9dcbe-c7a9-4627-acbf-ba50c4752b47.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73c9dcbe-c7a9-4627-acbf-ba50c4752b47.png)'
- en: At this point, we might consider the visual part of the game as finished, but
    there is still one problem you might have spotted while testing our latest additions.
    When you click on the board, there is no visual hint that any piece was actually
    selected. Let's fix that now by introducing the ability to highlight any field
    on the board.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能会认为游戏的视觉部分已经完成，但在测试我们最新的添加时，你可能已经注意到了一个问题。当你点击棋盘时，没有任何视觉提示表明任何棋子实际上已被选中。现在让我们通过引入在棋盘上高亮任何区域的能力来解决这个问题。
- en: 'To do that, we will develop a generic system for different highlights. Begin
    by adding a `Highlight` class as an internal class to `ChessView`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将开发一个用于不同高亮的通用系统。首先，在`ChessView`中添加一个`Highlight`类作为内部类：
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'It is a minimalistic interface for highlights and only exposes a method returning
    the type of the highlight using a virtual method. In our exercise, we will focus
    on just a basic type that marks a single field with a given color. Such a situation
    will be represented by the `FieldHighlight` class:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于高亮的最小化接口，它仅通过一个返回高亮类型的方法暴露一个虚拟方法。在我们的练习中，我们将专注于仅标记单个区域的基本类型，该类型使用给定的颜色。这种情况将由`FieldHighlight`类表示：
- en: '[PRE70]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can see that we provided a constructor that takes the column and rank indices
    and a color for the highlight and it stores them in private member variables.
    Also, `type()` is redefined to return `FieldHighlight::Type`, which we can use
    to easily identify the type of highlight. The next step is to extend `ChessView`
    with abilities to add and remove highlights. As the container declares a private
    `QList<Highlight*> m_highlights` member variable, add method declarations:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们提供了一个构造函数，它接受列索引和行索引以及突出显示的颜色，并将它们存储在私有成员变量中。此外，`type()` 被重新定义为返回 `FieldHighlight::Type`，我们可以用它来轻松地识别突出显示的类型。下一步是扩展
    `ChessView` 以添加和删除突出显示的能力。由于容器声明了一个私有的 `QList<Highlight*> m_highlights` 成员变量，添加方法声明：
- en: '[PRE71]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, provide implementations for non-inline methods:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，提供非内联方法的实现：
- en: '[PRE72]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Drawing the highlights is really easy; we will use yet another virtual `draw`
    method. Place the following call in the `paintEvent()` implementation right before
    the loop that is responsible for rendering pieces:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制突出显示非常简单；我们将使用另一个虚拟的 `draw` 方法。在 `paintEvent()` 实现中，在负责渲染棋子的循环之前放置以下调用：
- en: '[PRE73]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The implementation simply iterates over all the highlights and renders those
    it understands:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实现简单地遍历所有突出显示并渲染它理解的那些：
- en: '[PRE74]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: By checking the type of the highlight, we know which class to cast the generic
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查突出显示的类型，我们知道要将哪个类转换为通用的
- en: pointer to. Then, we can query the object for the needed data. Finally, we use
    `QPainter::fillRect()` to fill the field with the given color. As `drawHighlights()`
    is called before the piece painting loop and after the field painting loop, the
    highlight will cover the background but not the piece.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以查询该对象以获取所需的数据。最后，我们使用 `QPainter::fillRect()` 用给定的颜色填充方格。由于 `drawHighlights()`
    在棋子绘制循环之前和方格绘制循环之后被调用，突出显示将覆盖背景但不会覆盖棋子。
- en: 'That''s the basic highlighting system. Let''s make our `viewClicked()` slot
    use it:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基本的突出显示系统。让我们让我们的 `viewClicked()` 插槽使用它：
- en: '[PRE75]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note how we check that a field can only be selected if it is not empty (that
    is, there is an existing piece occupying that field).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何检查一个方格只有在它不为空（也就是说，有一个现有的棋子占据该方格）的情况下才能被选中的。
- en: 'You should also add a `ChessView::FieldHighlight *m_selectedField` private
    member variable and initialize it with a null pointer in the constructor. You
    can now build the game, execute it, and start moving pieces around:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该添加一个 `ChessView::FieldHighlight *m_selectedField` 私有成员变量，并在构造函数中将其初始化为空指针。现在你可以构建游戏，执行它，并开始移动棋子：
- en: '![](img/0895e10a-73a0-471c-8504-441296a71bf5.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0895e10a-73a0-471c-8504-441296a71bf5.png)'
- en: What just happened?
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: By adding a few lines of code, we managed to make the board clickable. We connected
    a custom slot that reads which field was clicked on and can highlight it with
    a semitransparent red color. Clicking on another field will move the highlighted
    piece there. The highlighting system we developed is very generic. We use it to
    highlight a single field with a solid color, but you can mark as many fields as
    you want with a number of different colors, for example, to show valid moves after
    selecting a piece. The system can easily be extended with new types of highlights;
    for example, you can draw arrows on the board using `QPainterPath` to have a complex
    hinting system (say, showing the player the suggested move).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加几行代码，我们成功使棋盘可点击。我们连接了一个自定义槽，该槽读取被点击的方格，并可以用半透明的红色突出显示它。点击另一个方格将移动突出显示的棋子到那里。我们开发的突出显示系统非常通用。我们用它用纯色突出显示单个方格，但你可以用多种不同的颜色标记尽可能多的方格，例如，在选中一个棋子后显示有效移动。该系统可以很容易地通过新的突出显示类型进行扩展；例如，你可以使用
    `QPainterPath` 在棋盘上绘制箭头，以拥有一个复杂的提示系统（比如，向玩家显示建议的移动）。
- en: '![](img/fb34cf99-db8a-470b-bb54-6f2f027de779.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb34cf99-db8a-470b-bb54-6f2f027de779.png)'
- en: Time for action – Connecting the game algorithm
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 连接游戏算法
- en: 'It would take us too long to implement a full chess game algorithm here, so
    instead, we will settle for a much simpler game called Fox and Hounds. One of
    the players has four pawns (hounds), which can only move over black fields and
    the pawn can only move in a forward fashion (toward higher ranks). The other player
    has just a single pawn (fox), which starts from the opposite side of the board:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里实现完整的国际象棋游戏算法会花费我们太多时间，所以我们将满足于一个更简单的游戏，称为狐狸与猎犬。其中一名玩家有四个兵（猎犬），它们只能移动到黑色方格上，兵只能向前移动（向更高的排数移动）。另一名玩家只有一个兵（狐狸），它从棋盘的另一侧开始：
- en: '![](img/582240d1-7e6f-4eb1-ba8e-1c75a7efb00f.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/582240d1-7e6f-4eb1-ba8e-1c75a7efb00f.png)'
- en: 'It can also move only over black fields; however it can move both forward (toward
    higher ranks) as well as backward (toward lower ranks). Players move their pawns
    in turn. The goal of the fox is to reach the opposite end of the board; the goal
    of the hounds is to trap the fox so that it can''t make a move:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 它只能移动到黑色区域；然而，它可以向前（向更高的等级）和向后（向更低的等级）移动。玩家轮流移动他们的棋子。狐狸的目标是到达棋盘的另一端；猎犬的目标是捕捉狐狸，使其无法移动：
- en: '![](img/5595544e-b857-4322-8efd-9ddf79941505.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5595544e-b857-4322-8efd-9ddf79941505.png)'
- en: 'It''s time to get to work! First, we will extend the `ChessAlgorithm` class
    with the required interface:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始工作了！首先，我们将使用所需的接口扩展`ChessAlgorithm`类：
- en: '[PRE76]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'There are two sets of members here. First, we have a number of enums, variables,
    signals, and methods that are related to the state of the game: which player should
    make their move now and what is the result of the game currently. The `Q_ENUM`
    macro is used to register enumerations in Qt''s metatype system so that they can
    be used as values for properties or arguments in signals. Property declarations
    and getters for them don''t need any extra explanation. We have also declared
    protected methods for setting the variables from within subclasses. Here''s their
    suggested implementation:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两组成员。首先，我们有一些与游戏状态相关的枚举、变量、信号和方法：哪个玩家现在应该移动，以及当前游戏的结果。`Q_ENUM`宏用于在Qt的元类型系统中注册枚举，以便它们可以用作属性或信号中的参数值。属性声明和它们的getter不需要额外解释。我们还在子类中声明了用于设置变量的受保护方法。以下是它们的建议实现：
- en: '[PRE77]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Remember about initializing `m_currentPlayer` and `m_result` to `NoPlayer` and
    `NoResult` in the constructor of the `ChessAlgorithm` class.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`ChessAlgorithm`类的构造函数中将`m_currentPlayer`和`m_result`初始化为`NoPlayer`和`NoResult`。
- en: 'The second group of functions is methods that modify the state of the game:
    the two variants of `move()`. The virtual variant is meant to be reimplemented
    by the real algorithm to check whether a given move is valid in the current game
    state and if that is the case, to perform the actual modification of the game
    board. In the base class, we can simply reject all possible moves:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组函数是修改游戏状态的函数：`move()`的两个变体。虚拟变体意味着由实际算法重新实现，以检查给定移动在当前游戏状态中是否有效，如果是这样，则执行实际的棋盘修改。在基类中，我们可以简单地拒绝所有可能的移动：
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The overload is simply a convenience method that accepts two `QPoint` objects
    instead of four integers:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 重载只是一个方便的方法，它接受两个`QPoint`对象而不是四个整数：
- en: '[PRE79]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The interface for the algorithm is ready now, and we can implement it for the
    Fox and Hounds game. Subclass `ChessAlgorithm` to create a `FoxAndHounds` class:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的接口现在已经准备好了，我们可以为狐狸与猎犬游戏实现它。从`ChessAlgorithm`派生出一个`FoxAndHounds`类：
- en: '[PRE80]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The implementation of `newGame()` is pretty simple: we set up the board, place
    pieces on it, and signal that it is time for the first player to make their move:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`newGame()`的实现相当简单：我们设置棋盘，放置棋子，并发出信号，表示现在是第一位玩家的移动时间：'
- en: '[PRE81]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The algorithm for the game is quite simple. Implement `move()` as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的算法相当简单。将`move()`实现如下：
- en: '[PRE82]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Declare a protected `foxCanMove()` method and implement it using the following
    code:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个受保护的`foxCanMove()`方法，并使用以下代码实现它：
- en: '[PRE83]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, do the same with `emptyByOffset()`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对`emptyByOffset()`做同样的操作：
- en: '[PRE84]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Lastly, declare a private `QPoint m_fox` member variable.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，声明一个私有的`QPoint m_fox`成员变量。
- en: 'The simplest way to test the game is to make two changes to the code. First,
    in the constructor of the main window class, replace `m_algorithm = new ChessAlgorithm(this)`
    with `m_algorithm = new FoxAndHounds(this)`. Second, modify the `viewClicked()`
    slot, as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 测试游戏的最简单方法是修改代码中的两个地方。首先，在主窗口类的构造函数中，将`m_algorithm = new ChessAlgorithm(this)`替换为`m_algorithm
    = new FoxAndHounds(this)`。其次，修改`viewClicked()`槽，如下所示：
- en: '[PRE85]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You can also connect signals from the algorithm class to custom slots of the
    view or window to notify about the end of the game and provide a visual hint as
    to which player should make their move now.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将算法类的信号连接到视图或窗口的自定义槽，以通知游戏结束，并提供一个视觉提示，说明现在哪个玩家应该移动。
- en: What just happened?
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We created a very simplistic API for implementing chess-like games by introducing
    the `newGame()` and `move()` virtual methods to the algorithm class. The former
    method simply sets up everything. The latter uses simple checks to determine whether
    a particular move is valid and whether the game has ended. We use the `m_fox`
    member variable to track the current position of the fox to be able to quickly
    determine whether it has any valid moves. When the game ends, the `gameOver()`
    signal is emitted and the result of the game can be obtained from the algorithm.
    You can use the exact same framework for implementing all chess rules.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向算法类引入`newGame()`和`move()`虚拟方法来创建了一个非常简单的API，用于实现类似棋类的游戏。前者方法简单地设置一切。后者使用简单的检查来确定某个移动是否有效以及游戏是否结束。我们使用`m_fox`成员变量来跟踪狐狸的当前位置，以便能够快速确定它是否有任何有效的移动。当游戏结束时，会发出`gameOver()`信号，并可以从算法中获取游戏结果。你可以使用完全相同的框架来实现所有棋类规则。
- en: Have a go hero – Implementing the UI around the chess board
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英雄试炼 - 实现围绕棋盘的UI
- en: During the exercise, we focused on developing the game board view and necessary
    classes to make the game actually run. However, we completely neglected the regular
    user interface the game might possess, such as toolbars and menus. You can try
    designing a set of menus and toolbars for the game. Make it possible to start
    a new game, save a game in progress (say by implementing a FEN serializer), load
    a saved game (say by leveraging the existing FEN string parser), or choose different
    game types that will spawn different `ChessAlgorithm` subclasses. You can also
    provide a settings dialog for adjusting the look of the game board. If you feel
    like it, you can add chess clocks or implement a simple tutorial system that will
    guide the player through the basics of chess using text and visual hints via the
    highlight system we implemented.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习过程中，我们专注于开发游戏板视图和使游戏实际运行的必要类。然而，我们完全忽略了游戏可能拥有的常规用户界面，例如工具栏和菜单。你可以尝试为游戏设计一套菜单和工具栏。使其能够开始新游戏、保存进行中的游戏（例如通过实现FEN序列化器），加载已保存的游戏（例如通过利用现有的FEN字符串解析器），或选择不同的游戏类型，这将生成不同的`ChessAlgorithm`子类。你还可以提供一个设置对话框来调整游戏板的外观。如果你愿意，你可以添加棋钟或实现一个简单的教程系统，该系统将通过文本和视觉提示（通过我们实现的突出显示系统）引导玩家了解国际象棋的基础。
- en: Have a go hero – Connecting a UCI-compliant chess engine
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英雄试炼 - 连接UCI兼容的棋引擎
- en: 'If you really want to test your skills, you can implement a `ChessAlgorithm`
    subclass that will connect to a **Universal Chess Interface** (**UCI**) chess
    engine such as StockFish ([http://stockfishchess.org](http://stockfishchess.org))
    and provide a challenging artificial intelligence opponent for a human player.
    UCI is the de facto standard for communication between a chess engine and a chess
    frontend. Its specification is freely available, so you can study it on your own.
    To talk to a UCI-compliant engine, you can use `QProcess`, which will spawn the
    engine as an external process and attach itself to its standard input and standard
    output. Then, you can send commands to the engine by writing to its standard input
    and read messages from the engine by reading its standard output. To get you started,
    here''s a short snippet of code that starts the engine and attaches to its communication
    channels:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想测试你的技能，你可以实现一个连接到**通用棋类接口**（**UCI**）棋引擎的`ChessAlgorithm`子类，例如StockFish（[http://stockfishchess.org](http://stockfishchess.org)），并为人类玩家提供一个具有挑战性的人工智能对手。UCI是棋引擎和棋类前端之间通信的事实标准。其规范是免费提供的，因此你可以自行研究。要与UCI兼容的引擎通信，你可以使用`QProcess`，它将引擎作为外部进程启动，并将其附加到其标准输入和标准输出。然后，你可以通过写入标准输入向引擎发送命令，通过读取标准输出从引擎读取消息。为了帮助你开始，这里有一个简短的代码片段，用于启动引擎并连接到其通信通道：
- en: '[PRE86]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Pop quiz
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which class should you use to load a JPEG image from a file and change
    a few pixels in it?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 你应该使用哪个类来从文件中加载JPEG图像并更改其中的一些像素？
- en: '`QImage`'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QImage`'
- en: '`QPixmap`'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QPixmap`'
- en: '`QIcon`'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QIcon`'
- en: Q2\. Which function can be used to schedule a repaint of the widget?
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 哪个函数可以用来安排小部件的重绘？
- en: '`paintEvent()`'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paintEvent()`'
- en: '`update()`'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update()`'
- en: '`show()`'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`show()`'
- en: Q3\. Which function can be used to change the color of the outline drawn by
    `QPainter`?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 哪个函数可以用来改变`QPainter`绘制的轮廓颜色？
- en: '`setColor()`'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setColor()`'
- en: '`setBrush()`'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setBrush()`'
- en: '`setPen()`'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setPen()`'
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about using raster graphics with Qt Widgets. What
    was presented in this chapter will let you implement custom widgets with painting
    and event handling. We also described how to handle image files and do some basic
    painting on images. This chapter concludes our overview of CPU rendering in Qt.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Qt Widgets进行光栅图形。本章所介绍的内容将使您能够实现具有绘图和事件处理的自定义小部件。我们还描述了如何处理图像文件以及在图像上进行一些基本的绘图。本章总结了Qt中CPU渲染的概述。
- en: In the next chapter, we will switch from raster painting to accelerated vector
    graphics and explore Qt capabilities related to OpenGL and Vulkan.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从光栅绘图切换到加速矢量图形，并探索与OpenGL和Vulkan相关的Qt功能。
