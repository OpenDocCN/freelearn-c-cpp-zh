- en: Immutability and Architecture - Event Sourcing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变性和架构 - 事件溯源
- en: Event sourcing is an architectural pattern that takes advantage of immutability
    for storage. The fundamental idea of event sourcing is the following—instead of
    storing the current state of data, how about we store the events that modify the
    data? This idea may seem radical, but it's not new; in fact, you're already using
    tools based on this principle—source-control systems such as Git follow this architecture.
    We will explore this idea in more detail, including a discussion about its advantages
    and disadvantages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源是一种利用不变性进行存储的架构模式。事件溯源的基本思想是，与其存储数据的当前状态，不如存储修改数据的事件。这个想法可能看起来很激进，但并不新颖；事实上，您已经在使用基于这一原则的工具——例如Git等源代码控制系统遵循这种架构。我们将更详细地探讨这个想法，包括其优点和缺点。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How the concept of immutability can be applied to data storage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变性的概念如何应用于数据存储
- en: What event sourcing architecture looks like
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源架构的外观
- en: What to take into account when deciding whether to use event sourcing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在决定是否使用事件溯源时需要考虑的因素
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a compiler that supports C++ 17\. I used GCC 7.4.0.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个支持C++ 17的编译器。我使用的是GCC 7.4.0。
- en: The code can be found on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the  `Chapter13` folder. It includes and uses `doctest`, which is a single-header
    open source unit testing library. You can find it on its GitHub repository at [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在GitHub上找到[https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)的`Chapter13`文件夹中。它包括并使用了`doctest`，这是一个单头开源单元测试库。您可以在其GitHub存储库中找到它[https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest)。
- en: Immutability and architecture – event sourcing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变性和架构 - 事件溯源
- en: Until around 2010, the choice of data storage was quite limited. Whether your
    preferred choice was Oracle, MySQL, or PostgreSQL, you were pretty much bound
    to using a relational model for your data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2010年左右，数据存储的选择相当有限。无论您偏好的是Oracle、MySQL还是PostgreSQL，您几乎都必须使用关系模型来存储数据。
- en: Then, suddenly, a plethora of new database engines popped up out of nowhere,
    with partial-to-no support for relational data. They were so different that they
    defied positive categorization, so the world ended up naming them based on what
    they didn't do—NoSQL databases. Indeed, their only commonality was that the support
    for SQL was little-to-none. The list of engines is long and changing, but at the
    time of writing, a few are prevalent—Redis, MongoDB, DynamoDb, Cassandra, and
    Couchbase, among others. Each of these engines has its own strengths and weaknesses,
    and the reason for their appearance is optimizing for various scenarios, usually
    in the context of cloud computing. For example, Cassandra is highly distributed,
    while MongoDB allows the easy storage of many types of data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，突然间，大量新的数据库引擎如雨后春笋般出现，对关系数据的支持部分或完全不足。它们如此不同，以至于无法进行积极的分类，因此世界最终以它们不做的事情来命名它们——NoSQL数据库。事实上，它们唯一的共同点是对SQL的支持很少或根本没有。引擎的列表很长且不断变化，但在撰写本文时，一些引擎很普遍，包括Redis、MongoDB、DynamoDb、Cassandra和Couchbase等。每个引擎都有其自身的优势和劣势，它们出现的原因是为了优化各种场景，通常是在云计算的背景下。例如，Cassandra具有高度分布式，而MongoDB允许轻松存储多种类型的数据。
- en: Around the same time I heard about NoSQL, I started hearing about a new architectural
    pattern called event sourcing. Event sourcing takes a radically different approach
    to data storage compared to the usual UI-server-RDBMS pattern. Instead of storing
    the current state of the system, the event sourcing pattern says—why don't we
    store the incremental changes to the system encoded as *domain events*?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在我听说NoSQL的同时，我开始听说一种称为事件溯源的新架构模式。与通常的UI服务器关系数据库模式相比，事件溯源对数据存储采取了一种根本不同的方法。事件溯源模式认为，与其存储系统的当前状态，不如我们将系统的增量更改编码为*领域事件*进行存储。
- en: 'The astute reader will notice two things about this idea:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者会注意到这个想法的两个方面：
- en: It sounds like something that would come out of the **domain-driven design**
    (**DDD**) movement, and indeed it has. Domain events can be just another pattern
    that we use as part of our DDD approach to architecture and as part of the evolution
    of our domain models.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这听起来像是**领域驱动设计**（**DDD**）运动中的产物，事实上确实如此。领域事件可以作为我们在架构和领域模型演进中使用的另一种模式。
- en: The idea of storing incremental changes in a data store, although radical for
    business applications, is not new in software architecture. In fact, I have been
    using a tool that is based on this pattern throughout the writing of this book.
    You probably also used it to get the code samples. While using a more complex
    model for history than what we'll discuss for event sourcing, Git stores incremental
    changes alongside the current state of the code.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管对于业务应用程序来说，在数据存储中存储增量更改的想法可能是激进的，但在软件架构中并不新鲜。事实上，在撰写本书的过程中，我一直在使用基于这种模式的工具。您可能也使用它来获取代码示例。虽然使用了比我们将在事件溯源中讨论的历史更复杂的模型，但Git将增量更改与代码的当前状态一起存储。
- en: Git is not the only tool using this pattern. We have been using such tools in operations for
    data backup for years. Since a full backup can take a very long time, a good strategy
    mixes frequent incremental backups with infrequent full backups. However, the
    trick is that, when recovery is needed, we can apply the incremental backups one
    after another, leading to the same state as a full backup. It's a good trade-off
    between the time and storage used for backups on one side and the time needed
    to restore a backup on the other.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Git并不是唯一使用这种模式的工具。多年来，我们一直在运维中使用这样的工具进行数据备份。由于完整备份可能需要很长时间，一个好的策略是将频繁的增量备份与不经常的完整备份混合使用。然而，诀窍在于，当需要恢复时，我们可以依次应用增量备份，达到与完整备份相同的状态。这是在备份所需的时间和存储空间以及恢复备份所需的时间之间的一个很好的权衡。
- en: By this point, you may wonder what event sourcing has to do with NoSQL databases,
    other than being related to storage? While I can't prove it, I believe the two
    ideas came from the same current of thought surrounding programming in the 2010s—optimize
    development speed by removing technical obstacles and optimize systems for various
    web and cloud-based architectures.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你可能会想知道事件溯源与NoSQL数据库有什么关系，除了与存储相关？虽然我无法证明，但我相信这两个想法都来自于2010年代围绕编程的思想潮流——通过消除技术障碍来优化开发速度，并为各种网络和基于云的架构优化系统。
- en: Let's think for a moment about Twitter. In terms of data flow, Twitter has two
    main features—posting a message and seeing the messages other people have posted.
    If you don't immediately see the message that another user has posted, you won't
    even know about it, so high latency is allowed. However, we don't want to lose
    data so we need the user message to be stored as quickly as possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来思考一下Twitter。在数据流方面，Twitter有两个主要功能——发布消息和查看其他用户发布的消息。如果你不能立即看到另一个用户发布的消息，你甚至都不会知道，因此允许高延迟。然而，我们不希望丢失数据，所以需要尽快将用户消息存储起来。
- en: The standard way to implement something like this has been to save the message
    directly into a database upon request and return the updated feed on response.
    This allows us to see the message immediately, but it has a few disadvantages.
    First, it makes the database a bottleneck, because every posted message executes
    both an `INSERT` and a `SELECT` statement. Second, it requires more resources
    on the server, thus increasing costs for cloud-based servers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这样的功能的标准方式是在请求时直接将消息保存到数据库中，并在响应时返回更新后的消息源。这使我们能够立即看到消息，但它也有一些缺点。首先，它使数据库成为瓶颈，因为每条发布的消息都执行了`INSERT`和`SELECT`语句。其次，它需要更多的服务器资源，从而增加了基于云的服务器成本。
- en: What if we think differently? When you post a message, we just save an event
    into a fast event store and return it immediately. Upon a future request to update
    the feed, the event is taken into account and the updated feed is returned. The
    data store is not a bottleneck anymore and we've reduced the server load. However,
    we have added a new element in the system, the event store, which may cost a bit
    more, but it turns out that, at high scale, this can be less expensive and more
    responsive than the alternative. This is an example of event sourcing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们换个思路呢？当你发布一条消息时，我们只是将事件保存到一个快速事件存储中，并立即返回。在未来的请求中更新消息源时，事件会被考虑进去，并返回更新后的消息源。数据存储不再是瓶颈，我们减少了服务器负载。然而，我们在系统中增加了一个新元素，即事件存储，这可能会增加一些成本，但事实证明，在高规模下，这可能比另一种选择更便宜、更响应。这是事件溯源的一个例子。
- en: Another option is to solve this at the data engine level and separate the writes
    and reads as previously stated; however, we use a data store that is optimized
    for writing. The downside is that the data will be available for reading with
    a higher latency than before, but that's OK. At some point in the future, it becomes
    available and the message feed is updated. This is an example of using a NoSQL
    database instead of an RDBMS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是在数据引擎层解决这个问题，并像之前提到的那样分离写入和读取；然而，我们使用的数据存储是为写入进行了优化。缺点是数据的可读性比以前更高延迟，但这没关系。在未来的某个时候，数据变得可用，消息源也会更新。这是使用NoSQL数据库而不是关系数据库管理系统的一个例子。
- en: The 2010s were very interesting indeed, giving rise to a number of new ideas
    in software architecture and design while introducing functional programming into
    mainstream programming languages. Incidentally, they were also interesting for
    the release of the interconnected series of superhero movies from **Marvel Cinematic
    Universe** (**MCU**). There's no connection between the two, I just like the MCU!
    However, I have to stop fanboying (about the history of software design and MCU)
    and move on to another weird idea—taking immutability into data storage.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年代确实非常有趣，引发了软件架构和设计领域的许多新想法，同时将函数式编程引入了主流编程语言。顺便说一句，这个时期还因漫威电影宇宙（MCU）的一系列超级英雄电影而变得有趣。这两者之间没有联系，我只是喜欢漫威电影宇宙！然而，我必须停止对软件设计历史和漫威电影宇宙的狂热追捧，转而讨论另一个奇怪的想法——将不可变性引入数据存储。
- en: Taking immutability to architecture
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将不可变性引入架构
- en: We've seen that immutability has a profound effect on code structure, and, therefore,
    on software design. We've also discussed, on multiple occasions, that I/O is fundamentally
    mutable. We're about to show that data storage is not necessarily mutable and
    that immutable data storage also has a profound effect on architecture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到不可变性对代码结构有深远影响，因此也对软件设计产生影响。我们还多次讨论过，I/O基本上是可变的。我们将要展示的是，数据存储不一定是可变的，不可变的数据存储也对架构产生深远影响。
- en: How can data storage be immutable? After all, the whole reason for many software
    applications is to do CRUD—create, retrieve, update, and delete. The only operation
    that doesn't change data is retrieve, although, in some cases, retrieving data
    can have additional side effects such as analytics or logging.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储如何做到不可变？毕竟，许多软件应用的整个目的就是CRUD——创建、检索、更新和删除。唯一不改变数据的操作是检索，尽管在某些情况下，检索数据可能会产生额外的副作用，如分析或日志记录。
- en: However, remember that we face the same problem with data structures. A mutable
    data structure will change its structure when adding to an element or deleting
    from it. Yet, pure functional languages support immutable data structures.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要记住我们面临着与数据结构相同的问题。可变数据结构在添加或删除元素时会改变其结构。然而，纯函数式语言支持不可变数据结构。
- en: An immutable data structure has the following property—adding or deleting items
    does not change the data structure. Instead, it returns a copy of the initial
    data structure plus the changes. To optimize memory, purely functional programming
    languages don't actually clone the data, they just make smart use of pointers
    to reuse the existing memory. However, for the programmer, it is as if the data
    structure has been completely cloned.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构具有以下特性——添加或删除项目不会改变数据结构。相反，它会返回初始数据结构的副本以及变化。为了优化内存，纯函数式编程语言实际上并不克隆数据，它们只是巧妙地利用指针来重用现有的内存。然而，对于程序员来说，就好像数据结构已经完全被克隆了。
- en: Consider applying the same idea to storage. Instead of changing the existing
    data, every write or delete creates a new version of the data with the applied
    changes, while leaving the previous version intact. Imagine the possibilities;
    we get the whole history of data changes and we can always recover them because
    we have a very recent version of the data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将相同的想法应用于存储。与其改变现有数据，每次写入或删除都会创建一个应用了变化的新版本的数据，同时保留之前的版本不变。想象一下可能性；我们得到了数据变化的整个历史，我们总是可以恢复它们，因为我们有一个非常近期的数据版本。
- en: That's not so easy though. Stored data tends to be large and duplicating it
    on every change will eat up huge storage space and become extremely slow in the
    process. The same optimization technique as for in-memory data doesn't work so
    well since stored data tends to be more complex and pointers aren't (yet?) as
    easy to manage for filesystems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不过这并不容易。存储的数据往往很大，在每次变化时复制它将占用大量的存储空间，并且在这个过程中变得极其缓慢。与内存数据一样，同样的优化技术并不奏效，因为存储的数据往往更加复杂，而指针在文件系统中并不（还没有？）那么容易管理。
- en: Fortunately, there's an alternative—store a version of data to begin with and
    just store a number of changes to the data. We could implement this in a relational
    database (the changes are just entities after all), but fortunately, we don't
    have to. To support this storage model, storage engines collectively called **event
    stores** have been implemented. They allow us to store events and get the latest
    version of data when we need it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，还有一种选择——一开始存储数据的版本，然后只存储数据的一些变化。我们可以在关系数据库中实现这一点（毕竟这些变化只是实体），但幸运的是，我们不必这样做。为了支持这种存储模型，一些被称为**事件存储**的存储引擎已经被实现。它们允许我们存储事件，并在需要时获取数据的最新版本。
- en: 'How would such a system work? Well, we need to model the domain and domain
    events. Let''s do this for Twitter as an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的系统会如何运作呢？嗯，我们需要对领域和领域事件进行建模。让我们以Twitter为例来做这个。
- en: '![](img/48cff6f2-742f-4b2e-82f6-cf016f2a3624.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48cff6f2-742f-4b2e-82f6-cf016f2a3624.png)'
- en: 'If we were using traditional data storage, we would just save the entities
    somehow, but we want to store events, so what we''ll have is a long list of incremental
    changes, conceptually looking like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用传统的数据存储，我们只会以某种方式保存实体，但我们想要存储事件，所以我们将会有一个长长的增量变化列表，概念上看起来像这样：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before we move on to see an example of implementation, we need to remember we're
    discussing software architecture, and no solution is perfect. Therefore, we have
    to stop and consider for a moment the trade-offs we're making when using event
    sourcing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续看一个实现的例子之前，我们需要记住我们正在讨论软件架构，没有解决方案是完美的。因此，我们必须停下来考虑一下在使用事件溯源时所做的权衡。
- en: Advantages of event sourcing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源的优势
- en: We wouldn't be talking about event sourcing if it didn't have advantages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件溯源没有优势，我们就不会谈论它。
- en: On a conceptual level, the domain model and domain events can be easily extracted
    from domain experts in very fast, lightweight sessions. Event storming is a facilitated
    session that allows us to design a complex system in hours, through collaboration
    between tech and domain experts. The knowledge created in this event is not to
    be underestimated; such common understanding is a strong basis for any collaboration
    across areas in a complex endeavor in knowledge work.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念层面，领域模型和领域事件可以很快地从领域专家那里提取出来，而且可以在非常快速、轻量级的会话中完成。事件风暴是一个促进会话，允许我们通过技术和领域专家之间的合作在几小时内设计一个复杂的系统。在这个事件中创造的知识不容小觑；这种共同的理解是知识工作中复杂努力中任何领域之间合作的强有力基础。
- en: On a software design level, event sourcing reveals intent better than other
    code structures. Domain operations tend to hide inside entities; with event sourcing,
    the changes to the domain model are front and center to the architecture. We can
    actually search for all the changes that data can go through, and obtain a list—something
    that's difficult for other code structures.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计层面，事件溯源比其他代码结构更好地揭示了意图。领域操作往往隐藏在实体内部；而在事件溯源中，领域模型的变化成为了架构的核心。我们实际上可以搜索数据可能经历的所有变化，并获得一个列表——这对其他代码结构来说是很困难的。
- en: On a coding level, event sourcing simplifies programming. While thinking in
    events may be difficult at first, it can quickly become second nature. This model
    allows us to write code that reflects the most important business features, thus
    leading to an easier understanding between programmers and product owners or clients.
    It also neatly encapsulates each type of change, thus simplifying our testing
    and code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码层面，事件溯源简化了编程。虽然一开始可能很难以事件的方式思考，但它很快就会变得很自然。这种模型允许我们编写反映最重要业务特性的代码，从而使程序员和产品所有者或客户之间的理解更加容易。它还很好地封装了每种类型的变化，从而简化了我们的测试和代码。
- en: On a data-storage level, event sourcing allows us to see a list of changes made
    to the data, an extreme feat for other data-storage models. Incremental backups
    fit better in this model since it's fundamentally incremental. Recovery is built
    into the data storage, allowing us to start from any past materialized storage
    and apply all the events.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据存储级别上，事件溯源允许我们查看对数据所做的更改列表，这对于其他数据存储模型来说是一个极端的壮举。增量备份在这种模型中更合适，因为它基本上是增量的。恢复内置于数据存储中，允许我们从任何过去的具体化存储开始，并应用所有事件。
- en: Moreover, event sourcing allows us to go back in time. If every event has an
    opposite event, which is usually quite easy to do, we can play the opposite events
    from the end to a certain timestamp, leading us to the exact data we had at that
    time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，事件溯源允许我们回到过去。如果每个事件都有一个相反的事件，通常很容易做到，我们可以从末尾播放相反的事件到特定的时间戳，从而导致我们在那个时间点拥有的确切数据。
- en: On a performance level, event sourcing optimizes writing data, making it very
    useful for most applications that require fast writes but can deal with latency
    on reads (also known as **most web-based systems**).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能水平上，事件溯源优化了数据的写入，使其对于大多数需要快速写入但可以处理读取延迟的应用程序非常有用（也被称为**大多数基于Web的系统**）。
- en: But nothing comes for free, so what can go wrong?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有什么是免费的，那么什么可能出错呢？
- en: Disadvantages and caveats of event sourcing
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源的缺点和注意事项
- en: With all its advantages, event sourcing could become a prevalent way of architecting
    complex applications, but it has a few important drawbacks that you need to consider
    before jumping on the wagon.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管事件溯源具有诸多优势，但在跳上这辆车之前，你需要考虑一些重要的缺点。
- en: Changing an event schema
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改事件模式
- en: The first issue comes from the core model of event sourcing—what if we need
    to change the structure of an event after we already have a bunch of data? For
    example, what if we need to add a timestamp to each of our events? Or what if
    we need to change our `PostMessage` event to include a field for visibility, which
    could be only receiver, only followers, or everyone?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题来自事件溯源的核心模型——如果我们需要在已经有大量数据的情况下更改事件的结构会怎样？例如，如果我们需要为每个事件添加时间戳怎么办？或者如果我们需要更改我们的`PostMessage`事件以包括一个可见性字段，该字段只能是接收者、只有关注者或所有人？
- en: This problem has solutions, but each comes with its own problems. One solution
    is to version the event schema and have multiple schemas side by side, which works
    but complicates the materialization. Another solution would be to use data migration
    scripts to change past events, but it breaks the concept of immutability and has
    to be done right. Another option is to never change an event schema, just add
    a new event type, but this can lead to confusion due to multiple deprecated event
    types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有解决方案，但每个解决方案都有自己的问题。一个解决方案是对事件模式进行版本控制，并且并排使用多个模式，这样做虽然有效，但会使具体化变得复杂。另一个解决方案是使用数据迁移脚本来更改过去的事件，但这会破坏不可变性的概念，而且必须做得正确。另一个选择是永远不更改事件模式，只是添加新的事件类型，但这可能会因多个已弃用的事件类型而导致混乱。
- en: Delete past data
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除过去的数据
- en: The second issue is with privacy. The **General Data Protection Regulation**
    (**GDPR**) adopted recently in the **European Union** (**EU**), affecting many
    software systems around the world, gives a user the right to ask for the complete
    deletion of private data from a system. When using a normal database, this is
    relatively easy—just delete the records related to the user ID—but how do we do
    this in an event store?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是隐私。最近在**欧洲联盟**（**EU**）颁布的**通用数据保护条例**（**GDPR**）影响了世界各地许多软件系统，赋予用户要求从系统中完全删除私人数据的权利。在使用普通数据库时，这相对容易——只需删除与用户ID相关的记录——但在事件存储中该如何做呢？
- en: 'We can start by deleting all of the events related to a user. But can we do
    that? We may hit a problem if the events have a temporal relationship. Imagine,
    for example, the following scenario for collaboratively editing a document:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从删除与用户相关的所有事件开始。但我们能这样做吗？如果事件具有时间关系，我们可能会遇到问题。例如，想象一下协同编辑文档的以下场景：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s mark the events we need to delete if the user `alexboly` asks us to:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户`alexboly`要求我们删除事件，让我们标记需要删除的事件：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do you see the problem? Not only do we lose data from the document if we delete
    the highlighted events, but the indexes don't match anymore either! Applying the
    events in order to a blank document will, therefore, lead to errors or corrupted
    data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到问题了吗？如果我们删除了突出显示的事件，不仅会丢失文档中的数据，而且索引也不再匹配！按顺序应用事件到空白文档将导致错误或损坏的数据。
- en: 'There are a few things we could do:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做一些事情：
- en: One solution is to delete the user's identity but preserve the data. While this
    could work in particular contexts, this solution depends on the outreach of the
    delete request. There's a special case where a user has added personal data (for
    example, an address, email address, or an ID number) into a document. If we delete
    the user's identity, but also need to delete the personal data, we will need to
    scan all events for the personal data and remove or replace it with the same number
    of blank characters.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个解决方案是删除用户的身份但保留数据。虽然这在特定情境下可能有效，但这个解决方案取决于删除请求的范围。有一种特殊情况，即用户已将个人数据（例如地址、电子邮件地址或ID号码）添加到文档中。如果我们删除了用户的身份，但也需要删除个人数据，我们将需要扫描所有事件以查找个人数据，并删除或用相同数量的空白字符替换它。
- en: Another solution is to materialize the database, to delete the data, and to
    start from the new checkpoint with future events. This breaks one of the core
    ideas of event sourcing—the ability to reconstruct the data from an empty store—and
    it can prove difficult for systems that have many events or many deletions. It
    is possible though, with proper planning and structure.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个解决方案是具体化数据库，删除数据，并从新的检查点开始处理未来事件。这破坏了事件溯源的核心理念之一——从空存储重建数据的能力——对于具有许多事件或许多删除的系统来说可能会很困难。但通过适当的规划和结构是可能的。
- en: A third solution is to take advantage of the architecture and use a special
    event for `DeletePrivateData`. However, this event is different because it will
    have to change the event store rather than the data. While it fits with the architecture,
    it is risky and will require extensive testing, since it can break everything.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种解决方案是利用架构并使用`DeletePrivateData`的特殊事件。但是，这个事件不同，因为它将改变事件存储而不是数据。虽然它符合架构，但它是有风险的，并且需要广泛的测试，因为它可能会破坏一切。
- en: A fourth solution is to design the events so that they are not temporally coupled.
    In theory, this sounds good, but we have to admit it may not always be possible
    in practice. In the previous example, we needed some kind of position for the
    text, and I challenge you to find a way of specifying the position that is independent
    of existing text. Also consider that we would carry out this design effort in
    a rare situation, potentially making all events less comprehensible. If it's possible
    with minimal changes, great; but if not, you'll need to make a decision yourself.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四种解决方案是设计事件，使它们不是时间上耦合的。从理论上讲，这听起来不错，但我们必须承认在实践中可能并不总是可能的。在前面的例子中，我们需要一些文本的位置，我向你挑战找到一种独立于现有文本的指定位置的方法。还要考虑到，我们将在一个罕见的情况下进行这种设计工作，这可能使所有事件都不那么容易理解。如果可以通过最小的更改实现，那就太好了；但如果不能，你就需要自己做出决定。
- en: An example of implementation
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现示例
- en: We will look next at a simple example of implementation using event sourcing.
    We'll start with our Twitter example, and start writing some tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看一个使用事件源的简单实现示例。我们将从我们的Twitter示例开始，然后开始编写一些测试。
- en: 'First, let''s create a user and check the event store for the right events,
    in pseudocode:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个用户，并在伪代码中检查正确的事件存储：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need a few things to compile this test. First, an event store that can store
    events, but how do we express an event that can be stored? We need some kind of
    data structure that can hold property names and values. The simplest one is a
    `map<string, string>` structure that will map the names of properties to their
    values. To see it in action, let''s create the event structure for `CreateUser`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些东西来编译这个测试。首先，一个可以存储事件的事件存储，但是如何表示可以存储的事件呢？我们需要一种可以保存属性名称和值的数据结构。最简单的是一个`map<string,
    string>`结构，它将属性的名称映射到它们的值。为了看到它的作用，让我们为`CreateUser`创建事件结构：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `CreateUser` event has a type, `CreateUser`, and needs a handle, for example, `alexboly`, and
    an `id` for the user. Let''s make it nicer and more explicit with `typedef`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateUser`事件有一个类型，`CreateUser`，并且需要一个句柄，例如`alexboly`，以及用户的`id`。让我们使用`typedef`使其更加友好和明确：'
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now create our `EventStore`. Since it''s basically a list of events,
    let''s just use it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的`EventStore`。因为它基本上是一个事件列表，让我们直接使用它：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, now our test can use the `EventStore` and the `makeCreateUserEvent` function
    to check that, after calling `createUser`, the right event will be in event store:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们的测试可以使用`EventStore`和`makeCreateUserEvent`函数来检查，在调用`createUser`后，正确的事件将在事件存储中：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We only have to implement `createUser` now for this test to work. It is simple
    enough; call `makeCreateUserEvent` and add the result to `EventStore`. We need
    an `id`, but since we only have one element, for now, let''s use a hardcoded value
    of `1`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只需要为这个测试实现`createUser`。这很简单；调用`makeCreateUserEvent`并将结果添加到`EventStore`。我们需要一个`id`，但由于我们现在只有一个元素，让我们使用一个硬编码值`1`：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The test passes; now we can execute events and they'll go to the event store.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了；现在我们可以执行事件，并它们将进入事件存储。
- en: 'Let''s see now how the new user can post a message. We will need a second event
    type, `PostMessage`, and a similar code infrastructure. Let''s write the test.
    First, we need to create a user. Second, we need to create a message that is linked
    to the user through the `userId`. Here''s the test:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看新用户如何发布消息。我们将需要第二种事件类型`PostMessage`，以及类似的代码基础设施。让我们编写测试。首先，我们需要创建一个用户。其次，我们需要创建一个通过`userId`与用户关联的消息。以下是测试：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `makePostMessageEvent` function will just create an `Event` structure with
    all the required information. It also needs a type and `messageId`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`makePostMessageEvent`函数将只创建一个带有所有必需信息的`Event`结构。它还需要一个类型和`messageId`：'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, `postMessage` just adds the result of `makePostMessageEvent` into
    the `EventStore`. We need an ID once again, but we only have one message, so we
    can use the same ID, `1`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`postMessage`只需将`makePostMessageEvent`的结果添加到`EventStore`中。我们再次需要一个ID，但我们只有一条消息，所以我们可以使用相同的ID`1`：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, now we have a user that can post a message, all through events. That's quite
    neat, and not as difficult as it may have seemed in the beginning.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们有一个用户可以通过事件发布消息。这相当不错，也没有像一开始看起来那么困难。
- en: This implementation raises a few interesting questions though.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现提出了一些有趣的问题。
- en: How do you retrieve data?
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你如何检索数据？
- en: Firstly, what if I want to search for a user by their handle or their `id`?
    That's a real use scenario on Twitter. If I mention another user in a message
    with `@alexboly`, a notification should be posted to the user with the handle
    `alexboly`. Also, I'd like to display all messages relevant to the user `@alexboly`
    on the timeline.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我想通过他们的句柄或`id`搜索用户怎么办？这是Twitter上的一个真实使用场景。如果我在消息中提到另一个用户`@alexboly`，通知应该发布到具有句柄`alexboly`的用户。此外，我想在时间轴上显示与用户`@alexboly`相关的所有消息。
- en: I have two options for this. The first option is to store just the events and
    run all of them whenever reading data. The second option is to maintain a domain
    store with the current values and query it like any other database. It's important
    to note that each or both of these stores may be in-memory for very fast access.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对此我有两个选择。第一个选择是仅存储事件，并在读取数据时运行所有事件。第二个选择是维护一个具有当前值的域存储，并像任何其他数据库一样查询它。重要的是要注意，这些存储中的每一个或两个可能都是内存中的，以便非常快速地访问。
- en: Regardless of whether the current values are cached or computed, we need a way
    to execute the events and obtain them. How do we do that?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 无论当前值是缓存还是计算得出的，我们都需要一种执行事件并获取它们的方法。我们怎么做呢？
- en: 'Let''s write a test to describe what we need. After running one or more events,
    we need to execute the events and get the current values, allowing us to retrieve
    them as needed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个测试来描述我们需要的内容。在运行一个或多个事件之后，我们需要执行这些事件并获取当前值，以便在需要时检索它们：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To make the test pass, we need a few things. First, a `User` domain object,
    which we''ll keep very simple:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们需要一些东西。首先，一个`User`领域对象，我们将保持非常简单：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Second, a data store that has a list of `users`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一个包含`users`列表的数据存储：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, the `play` mechanism. Let''s just use an ugly implementation for now:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`play`机制。现在让我们先使用一个丑陋的实现：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Knowing higher-order functions, we can, of course, see that our `for` statement
    in the preceding snippet can be turned into a functional approach. In fact, we
    can filter all the events by the `CreateUser` type and then transform each event
    into an entity through a call to `transform`. First, let''s extract some smaller
    functions. We need one function that turns a `CreateUser` event into a user:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 了解高阶函数后，我们当然可以看到我们在前面的片段中的`for`语句可以转换为函数式方法。实际上，我们可以通过调用`transform`将所有事件按`CreateUser`类型进行过滤，然后将每个事件转换为实体。首先，让我们提取一些较小的函数。我们需要一个将`CreateUser`事件转换为用户的函数：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And we need another one that filters a list of events by type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一个函数，它可以按类型过滤事件列表：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now extract a `playEvents` function, which takes a list of events, filters
    it by type, and runs the transformation, obtaining a list of entities:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以提取一个`playEvents`函数，它接受一个事件列表，按类型进行过滤，并运行转换，得到一个实体列表：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now use this function in our `EventStore` to both replace the treatment
    of `CreateUser` and generalize it to other events:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的`EventStore`中使用这个函数来替换`CreateUser`的处理，并将其泛化到其他事件中：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We now have a way to retrieve data from our store based on events. Time to look
    at the next question.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一种根据事件从我们的存储中检索数据的方法。是时候看看下一个问题了。
- en: What about referential integrity?
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用完整性怎么样？
- en: 'So far, we''ve seen that relationships between entities when using events are
    based on IDs, but what if we call an event using the wrong `id`? Look at the example
    in the following snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了在使用事件时实体之间的关系是基于ID的，但是如果我们使用错误的`id`调用事件会怎样？看看下面片段中的例子：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I see a few solutions to this problem:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到了这个问题的几个解决方案：
- en: The first solution is to run the event anyway. This will work if it doesn't
    create additional issues on display. On Twitter, if I see a message, I can navigate
    to the user who posted the message. In this case, the navigation would lead to
    an inexistent page. Is this a problem? I would argue that for something like Twitter,
    it's not such a big problem, as long as it doesn't happen very often, but you'll
    have to judge it in the context of your own product.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个解决方案是无论如何都运行事件。如果这不会在显示上创建额外的问题，那么这将起作用。在Twitter上，如果我看到一条消息，我可以导航到发布消息的用户。在这种情况下，导航将导致一个不存在的页面。这是一个问题吗？我认为对于像Twitter这样的东西，这不是一个很大的问题，只要它不经常发生，但你必须在你自己产品的上下文中判断它。
- en: The second solution is to run the event without any checks, but run a repeated
    job that checks for referential issues and cleans them up (through events, of
    course). This method allows you to eventually clean up the data using event sourcing,
    without slowing down updates with integrity checks. Once again, you'll need to
    figure out whether this works in your context.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个解决方案是在没有任何检查的情况下运行事件，但运行一个重复的作业来检查引用问题并清理它们（通过事件，当然）。这种方法允许您最终使用事件源清理数据，而不会通过完整性检查减慢更新。再次，您需要弄清楚这在您的上下文中是否起作用。
- en: The third solution is to run integrity checks on each event run. While this
    ensures referential integrity, it will also slow everything down.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种解决方案是在每次事件运行时运行完整性检查。虽然这可以确保引用完整性，但也会减慢一切速度。
- en: The checks can run in two ways—either by checking the data store or checking
    the event store. For example, you could check that `DeleteUser` for ID `1` never
    occurred, or that it didn't occur after `CreateUser` (but you'll need the user
    handle for that).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 检查可以通过两种方式进行——要么通过检查数据存储，要么通过检查事件存储。例如，你可以检查`DeleteUser`的ID`1`从未发生过，或者它没有在`CreateUser`之后发生过（但你需要用户句柄）。
- en: Keep this in mind when choosing event sourcing for your application!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择事件源应用程序时请记住这一点！
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Event sourcing is a method of immutable data storage, starting from a simple
    idea—instead of storing the current state of the world, what if we stored all
    the events that lead to the current state? The advantages of this approach are
    many and interesting—the ability to move forward and backward in time, built-in
    incremental backup, and thinking in a timeline rather than in a state. It also
    comes with a few caveats—deleting past data is very difficult, the event schema
    is difficult to change, and referential integrity tends to become looser. You
    also need to pay attention to possible errors and define policies for treating
    them in a structured and repeatable manner.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源是一种不可变数据存储方法，从一个简单的想法开始——我们存储导致当前状态的所有事件，而不是存储世界的当前状态？这种方法的优势很多，也很有趣——能够在时间上前进和后退，内置增量备份，并且以时间线而不是状态来思考。它也有一些注意事项——删除过去的数据非常困难，事件模式很难更改，引用完整性往往变得更松散。您还需要注意可能的错误，并定义处理它们的结构化和可重复的策略。
- en: We've also seen how a simple event sourcing architecture can be implemented
    with the help of lambdas as events. We could also look at event sourcing for storing
    lambdas, since a stored event is basically a command pattern, and the simplest
    implementation of a command pattern is a lambda. The curious reader can try to
    serialize/deserialize the events into lambdas and see how it changes the design.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用lambda作为事件实现简单的事件源架构。我们还可以看一下用于存储lambda的事件源，因为存储的事件基本上是一个命令模式，而命令模式的最简单实现是lambda。好奇的读者可以尝试将事件序列化/反序列化为lambda，并看看它如何改变设计。
- en: Like any architectural pattern, my advice is to carefully consider the trade-offs
    and to have answers to the most important challenges raised by the implementation.
    If you choose to try event sourcing, I also advise you to try a production-ready
    event store rather than building your own. The one we wrote in this chapter is
    useful for showcasing the core principles and challenges of event sourcing, but
    it's far from being ready to be used in production.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何架构模式一样，我的建议是仔细考虑权衡，并对实施中提出的最重要的挑战有答案。如果您选择尝试事件溯源，我还建议您尝试一个成熟的事件存储，而不是自己构建一个。本章中我们编写的事件存储对展示事件溯源的核心原则和挑战很有用，但远未准备好投入生产使用。
- en: It's now time to move on to the future of functional programming in C++. In
    the next chapter, we will walk through the existing functional programming features
    in C++ 17, and look at the news about C++ 20.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候转向C ++中函数式编程的未来了。在下一章中，我们将介绍C ++ 17中现有的函数式编程特性，并了解关于C ++ 20的最新消息。
