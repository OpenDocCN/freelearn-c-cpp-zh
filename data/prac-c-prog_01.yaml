- en: Working with Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作数组
- en: Arrays are an important construct of any programming language. To keep data
    of a similar type together, we need arrays. Arrays are heavily used in applications
    where elements have to be accessed at random. Arrays are also a prime choice when
    you need to sort elements, look for desired data in a collection, and find common
    or unique data between two sets. Arrays are assigned contiguous memory locations
    and are a very popular structure for sorting and searching data collections because
    any element of an array can be accessed by simply specifying its subscript or
    index location. This chapter will cover recipes that include operations commonly
    applied to arrays.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是任何编程语言的重要结构。为了将相似类型的数据放在一起，我们需要数组。数组在需要随机访问元素的应用中被大量使用。当您需要排序元素、在集合中查找所需数据或查找两个集合之间的公共或唯一数据时，数组也是一个主要的选择。数组分配了连续的内存位置，并且是排序和搜索数据集合的非常流行的结构，因为可以通过简单地指定其下标或索引位置来访问数组的任何元素。本章将涵盖包括常见数组操作的菜谱。
- en: 'In this chapter, we will learn how to make the following recipes using arrays:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用数组制作以下菜谱：
- en: Inserting an element into a one-dimensional array
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一维数组中插入一个元素
- en: Multiplying two matrices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘以两个矩阵
- en: Finding the common elements in two arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找两个数组中的公共元素
- en: Finding the difference between two sets or arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找两个集合或数组之间的差异
- en: Finding the unique elements in an array
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找数组中的唯一元素
- en: Finding whether a matrix is sparse
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找矩阵是否为稀疏
- en: Merging two sorted arrays into one
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个有序数组合并为一个
- en: Let's begin with the first recipe!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个菜谱开始！
- en: Inserting an element in an array
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数组中插入一个元素
- en: In this recipe, we will learn how to insert an element in-between an array.
    You can define the length of the array and also specify the location where you
    want the new value to be inserted. The program will display the array after the
    value has been inserted.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在数组中插入一个元素。您可以定义数组的长度，也可以指定新值要插入的位置。程序将在值插入后显示数组。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: '1\. Let''s assume that there is an array, **p**, with five elements, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 假设有一个名为 **p** 的数组，包含五个元素，如下所示：
- en: '![](img/88dedebb-9397-4a99-a0e1-7f24d92508e9.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88dedebb-9397-4a99-a0e1-7f24d92508e9.png)'
- en: Figure 1.1
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1
- en: 'Now, suppose you want to enter a value, say **99**, at the third position.
    We will write a C program that will give the following output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想在第三个位置输入一个值，比如 **99**。我们将编写一个 C 程序，它将给出以下输出：
- en: '![](img/affaa657-3cbc-497d-bba9-04d30a5dca2b.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/affaa657-3cbc-497d-bba9-04d30a5dca2b.png)'
- en: Figure 1.2
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2
- en: 'Here are the steps to follow to insert an element in an array:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是插入数组中元素的步骤：
- en: 'Define a macro called `max` and initialize it to a value of `100`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `max` 的宏并将其初始化为 `100` 的值：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define an array `p` of size max elements:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个大小为最大元素数量的数组 `p`：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter the length of the array when prompted. The length you enter will be assigned
    to a variable `n`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示输入数组长度时，输入的长度将被分配给变量 `n`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A `for` loop will be executed prompting you to enter the elements of the array:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将执行一个 `for` 循环，提示您输入数组的元素：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Specify the position in the array where the new value has to be inserted:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定新值需要插入的数组中的位置：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because the arrays in C are zero-based, the position you enter is decremented
    by 1:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 C 语言中的数组是从零开始的，所以输入的位置会减去 1：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To create space for the new element at the specified index location, all the
    elements are shifted one position down:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在指定的索引位置为新元素创建空间，所有元素都会向下移动一个位置：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Enter the new value which will be inserted at the vacated index location:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入将插入到空缺索引位置的新值：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the `insertintoarray.c` program for inserting an element in between
    an array:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于在数组中插入元素的 `insertintoarray.c` 程序：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we want to specify the length of the array, we will first define a macro
    called `max` and initialize it to a value of 100\. I have defined the value of
    max as 100 because I assume that I will not need to enter more than 100 values
    in an array, but it can be any value as desired. An array, `p`, is defined of
    size `max` elements. You will be prompted to specify the length of the array.
    Let's specify the length of the array as 5\. We will assign the value `5` to the
    variable `n`. Using a `for` loop, you will be asked to enter the elements of the
    array.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要指定数组的长度，所以我们首先定义一个名为 `max` 的宏并将其初始化为 100 的值。我之所以将 `max` 的值定义为 100，是因为我假设我不会在数组中输入超过
    100 个值，但可以设置为所需的任何值。定义了一个大小为 `max` 个元素的数组 `p`。你将被提示指定数组的长度。让我们将数组的长度指定为 5。我们将把值
    `5` 赋给变量 `n`。使用 `for` 循环，你将被要求输入数组的元素。
- en: 'Let''s say you enter the values in the array, as shown in *Figure 1.1* given
    earlier:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你输入的数组值如之前给出的 *图 1.1* 所示：
- en: '![](img/a4c3a8cb-d277-47bd-8d5b-31df5d1d9a21.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4c3a8cb-d277-47bd-8d5b-31df5d1d9a21.png)'
- en: In the preceding diagram, the numbers, 0, 1, 2, and so on are known as index
    or subscript and are used for assigning and retrieving values from an array. Next,
    you will be asked to specify the position in the array where the new value has
    to be inserted. Suppose, you enter `3`, which is assigned to the variable `k`.
    This means that you want to insert a new value at location 3 in the array.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，数字 0、1、2 等被称为索引或下标，用于从数组中分配和检索值。接下来，你将被要求指定新值需要插入到数组中的位置。假设，你输入 `3`，它被分配给变量
    `k`。这意味着你想要在数组的 3 号位置插入一个新值。
- en: Because the arrays in C are zero-based, position 3 means that you want to insert
    a new value at index location 2, which is **p[2]**. Hence, the position entered
    in `k` is decremented by 1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 C 语言中的数组是从 0 开始计数的，所以位置 3 表示你想要在索引位置 2 插入一个新的值，即 **p[2]**。因此，在 `k` 中输入的位置会减去
    1。
- en: 'To create space for the new element at index location **p[2]**, all the elements
    are shifted one position down. This means that the element at **p[4]** is moved
    to index location **p[5]**, the one at **p[3]** is moved to **p[4]**, and the
    element at **p[2]** is moved to **p[3]**, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在索引位置 **p[2]** 为新元素腾出空间，所有元素都将向下移动一个位置。这意味着 **p[4]** 位置的元素将被移动到索引位置 **p[5]**，**p[3]**
    位置的元素将被移动到 **p[4]**，而 **p[2]** 位置的元素将被移动到 **p[3]**，如下所示：
- en: '![](img/9bf16859-1375-4e03-9d61-fcbc348737d0.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bf16859-1375-4e03-9d61-fcbc348737d0.png)'
- en: Figure 1.3
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3
- en: 'Once the element from the target index location is safely copied to the next
    location, you will be asked to enter the new value. Suppose you enter the new
    value as `99`; that value will be inserted at index location **p[2]**, as shown
    in *Figure 1.2,* given earlier:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦目标索引位置的元素安全地复制到下一个位置，你将被要求输入新的值。假设你输入的新值为 `99`；该值将被插入到索引位置 **p[2]**，如之前给出的
    *图 1.2* 所示：
- en: '![](img/8dad9c99-e3a6-4418-b19d-9635c74eb8cb.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dad9c99-e3a6-4418-b19d-9635c74eb8cb.png)'
- en: 'Let’s use GCC to compile the `insertintoarray.c` program, as shown in this
    statement:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `insertintoarray.c` 程序，如下所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s run the generated executable file, `insertintoarray.exe`, to see
    the program output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行生成的可执行文件 `insertintoarray.exe`，以查看程序输出：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Voilà! We've successfully inserted an element in an array.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功地在数组中插入了一个元素。
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What if we want to delete an element from an array? The procedure is simply
    the reverse; in other words, all the elements from the bottom of the array will
    be copied one place up to replace the element that was deleted.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从数组中删除一个元素怎么办？程序流程是简单的反向；换句话说，数组底部的所有元素将被复制一个位置，以替换被删除的元素。
- en: 'Let''s assume array **p** has the following five elements (*Figure 1.1*):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数组 **p** 有以下五个元素 (*图 1.1*)：
- en: '![](img/236c2707-a44b-4300-8bbf-6c2a0684d61e.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/236c2707-a44b-4300-8bbf-6c2a0684d61e.png)'
- en: 'Suppose, we want to delete the third element, in other words, the one at **p[2]**,
    from this array. To do so, the element at **p[3]** will be copied to **p[2]**,
    the element at **p[4]** will be copied to **p[3]**, and the last element, which
    here is at **p[4]**, will stay as it is:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，我们想要从数组中删除第三个元素，换句话说，就是位于 **p[2]** 的元素。为此，**p[3]** 位置的元素将被复制到 **p[2]**，**p[4]**
    位置的元素将被复制到 **p[3]**，而最后一个元素，在这里是位于 **p[4]** 的，将保持不变：
- en: '![](img/b8a39086-7cf2-4b0e-a792-98d6cfc97f2c.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8a39086-7cf2-4b0e-a792-98d6cfc97f2c.png)'
- en: Figure 1.4
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4
- en: 'The `deletefromarray.c` program for deleting the array is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 用于删除数组的 `deletefromarray.c` 程序如下：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's move on to the next recipe!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Multiplying two matrices
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乘以两个矩阵
- en: A prerequisite for multiplying two matrices is that the number of columns in
    the first matrix must be equal to the number of rows in the second matrix.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 乘以两个矩阵的前提是第一个矩阵的列数必须等于第二个矩阵的行数。
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Create two matrices of orders **2 x 3** and **3 x 4** each.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个矩阵，每个矩阵的顺序为 **2 x 3** 和 **3 x 4**。
- en: 'Before we make the matrix multiplication program, we need to understand how
    matrix multiplication is performed manually. To do so, let''s assume that the
    two matrices to be multiplied have the following elements:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编写矩阵乘法程序之前，我们需要了解矩阵乘法是如何手动执行的。为了做到这一点，让我们假设要相乘的两个矩阵具有以下元素：
- en: '![](img/655cf601-5e0c-424f-ba47-932259913ba3.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/655cf601-5e0c-424f-ba47-932259913ba3.png)'
- en: Figure 1.5
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5
- en: 'The resultant matrix will be of the order **2 x 4**, that is, the resultant
    matrix will have the same number of rows as the first matrix and the same number
    of columns as the second matrix:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果矩阵的顺序将是 **2 x 4**，也就是说，结果矩阵将具有与第一个矩阵相同的行数和与第二个矩阵相同的列数：
- en: '![](img/6d962de0-0dfb-4bbb-9f54-7958be3cdcb6.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d962de0-0dfb-4bbb-9f54-7958be3cdcb6.png)'
- en: Figure 1.6
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6
- en: 'Essentially, the resultant matrix of the order **2 x 4** will have the following
    elements:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，**2 x 4** 顺序的结果矩阵将具有以下元素：
- en: '![](img/73d7a071-0545-4459-ab26-51687adcfe7d.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73d7a071-0545-4459-ab26-51687adcfe7d.png)'
- en: Figure 1.7
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7
- en: 'The element **first row, first column** in the resultant matrix is computed
    using the following formula:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果矩阵中**第一行第一列**的元素使用以下公式计算：
- en: <q>SUM(first element of the first row of the first matrix × first element of
    the first column of the second matrix), (second element of the first row... ×
    second element of the first column...), (and so on...)</q>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <q>求和（第一个矩阵第一行的第一个元素 × 第二个矩阵第一列的第一个元素），（第一行第二个元素... × 第一列第二个元素...），（以此类推...）</q>
- en: 'For example, let''s assume the elements of the two matrices are as shown in
    *Figure 1.5*.  The elements in the first row and the first column of the resultant
    matrix will be computed as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设两个矩阵的元素如图 *图 1.5* 所示。结果矩阵的第一行第一列的元素将按以下方式计算：
- en: '![](img/b55ec5fe-7b01-4f23-87f4-b0e3a6a3fa91.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b55ec5fe-7b01-4f23-87f4-b0e3a6a3fa91.png)'
- en: Figure 1.8
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8
- en: 'Hence, the element in **first row, first column** in the resultant matrix will
    be as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，结果矩阵中**第一行第一列**的元素如下：
- en: '**(3×6)+(9×3)+(7×5)**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**(3×6)+(9×3)+(7×5)**'
- en: '**=18 + 27 + 35**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**=18 + 27 + 35**'
- en: '**=80**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**=80**'
- en: '*Figure 1.9* explains how the rest of the elements are computed in the resultant
    matrix:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.9* 解释了结果矩阵中其余元素的计算方法：'
- en: '![](img/767866de-9455-4475-aaac-bb18f895746f.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/767866de-9455-4475-aaac-bb18f895746f.png)'
- en: Figure 1.9
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9
- en: 'The `matrixmulti.c` program for multiplying the two matrices is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 两个矩阵相乘的 `matrixmulti.c` 程序如下：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入幕后，更好地理解代码。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The two matrices are defined `matA` and `matB` of the orders 2 x 3 and 3 x
    4, respectively, using the following statement:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语句定义了两个矩阵 `matA` 和 `matB`，它们的顺序分别为 2 x 3 和 3 x 4：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You will be asked to enter the elements of the two matrices using the nested
    `for` loops. The elements in the matrix are entered in row-major order, in other
    words, all the elements of the first row are entered first, followed by all the
    elements of the second row, and so on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求使用嵌套的 `for` 循环输入两个矩阵的元素。矩阵中的元素以行主序输入，换句话说，首先输入第一行的所有元素，然后是第二行的所有元素，依此类推。
- en: In the nested loops, `for i` and `for j`, the outer loop, `for i`, represents
    the row and the inner loop, and `for j` represents the column.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套循环中，`for i` 和 `for j`，外循环 `for i` 代表行，内循环 `for j` 代表列。
- en: 'While entering the elements of matrices `matA` and `matB`, the values entered
    in the two matrices will be assigned to the respective index locations of the
    two-dimensional arrays as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入矩阵 `matA` 和 `matB` 的元素时，输入的两个矩阵中的值将被分配到二维数组的相应索引位置，如下所示：
- en: '![](img/693b9c12-b0ed-4f26-9b41-6bc889829fd5.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/693b9c12-b0ed-4f26-9b41-6bc889829fd5.png)'
- en: Figure 1.10
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10
- en: 'The nested loops that actually compute the matrix multiplication are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际计算矩阵乘法的嵌套循环如下：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The variable `i` represents the row of the resultant matrix, `j` represents
    the column of the resultant matrix, and `k` represents the common factor. The
    <q>common factor</q> here means the column of the first matrix and the row of
    the second matrix.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `i` 代表结果矩阵的行，`j` 代表结果矩阵的列，`k` 代表公共因子。这里的 <q>公共因子</q> 指的是第一个矩阵的列和第二个矩阵的行。
- en: Recall that the prerequisite for matrix multiplication is that the column of
    the first matrix should have the same number of rows as the second matrix. Because
    the respective elements have to be added after multiplication, the element has
    to be initialized to `0` before addition.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，矩阵乘法的先决条件是第一个矩阵的列数应该与第二个矩阵的行数相同。因为相应的元素在乘法后需要相加，所以元素在相加之前必须初始化为 `0`。
- en: 'The following statement initializes the elements of the resultant matrix:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句初始化结果矩阵的元素：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `for k` loop inside the nested loops helps in selecting the elements in
    the rows of the first matrix and multiplying them by elements of the column of
    the second matrix:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环中的 `for k` 循环有助于选择第一个矩阵的行元素，并将它们与第二个矩阵的列元素相乘：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s use GCC to compile the `matrixmulti.c` program as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `matrixmulti.c` 程序，如下所示：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s run the generated executable file, `matrixmulti.exe`, to see the output
    of the program:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行生成的可执行文件 `matrixmulti.exe`，以查看程序的输出：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Voilà! We've successfully multiplied two matrices.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功地将两个矩阵相乘了。
- en: There’s more…
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One thing that you might notice while entering the elements of the matrix is
    that there are two ways of doing it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入矩阵的元素时，你可能注意到有两种方法可以做到这一点。
- en: 'The first method is that you press *Enter* after inputting each element as
    follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一种方法是你在输入每个元素后按 *Enter*：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The values will be automatically assigned to the matrix in row-major order,
    in other words, `3` will be assigned to `matA[0][0]`, `9` will be assigned to
    `matA[0][1]`, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值将自动按照行主序分配到矩阵中，换句话说，`3` 将分配给 `matA[0][0]`，`9` 将分配给 `matA[0][1]`，依此类推。
- en: 'The second method of entering elements in the matrix is as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在矩阵中输入元素的第二种方法是：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `6` will be assigned to `matB[0][0]`, `2` will be assigned to `matB[0][1]`,
    and so on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`6` 将分配给 `matB[0][0]`，`2` 将分配给 `matB[0][1]`，依此类推。
- en: Now, let's move on to the next recipe!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Finding the common elements in two arrays
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在两个数组中找到公共元素
- en: Finding the common elements in two arrays is akin to finding the intersection
    of two sets. Let's learn how to do it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个数组中找到公共元素类似于找到两个集合的交集。让我们学习如何做到这一点。
- en: How to do it…
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Define two arrays of a certain size and assign elements of your choice to both
    the arrays. Let''s assume that we created two arrays called **p** and **q**, both
    of size four elements:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个特定大小的数组，并将你选择的元素分配给这两个数组。假设我们创建了两个名为 **p** 和 **q** 的数组，它们都有四个元素：
- en: '![](img/5f5a4b04-9ca7-4c11-9c3e-ebac923a6cc4.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f5a4b04-9ca7-4c11-9c3e-ebac923a6cc4.png)'
- en: Figure 1.11
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11
- en: Define one more array. Let's call it array **r**, to be used for storing the
    elements that are common between the two arrays.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个数组。让我们称它为数组 **r**，用于存储两个数组之间的公共元素。
- en: If an element in array **p** exists in the array **q**, it is added to array
    **r**. For instance, if the element at the first location in array **p**, which
    is at **p[0]**, does not appear in array **q**, it is discarded, and the next
    element, at **p[1]**, is picked up for comparison.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组 **p** 中的一个元素存在于数组 **q** 中，它将被添加到数组 **r** 中。例如，如果数组 **p** 中第一个位置的元素，即 **p[0]**，不在数组
    **q** 中，它将被丢弃，下一个元素，即 **p[1]**，将被选中进行比较。
- en: 'And if the element at **p[0]** is found anywhere in array **q**, it is added
    to array **r**, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组 **p** 中的 **p[0]** 元素在数组 **q** 中任何位置找到，它将被添加到数组 **r** 中，如下所示：
- en: '![](img/9ee95874-f55b-418e-a0f0-1bb0b3840df9.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ee95874-f55b-418e-a0f0-1bb0b3840df9.png)'
- en: Figure 1.12
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12
- en: This procedure is repeated with other elements of array **q**. That is, **p[1]**
    is compared with **q[0]**, **q[1]**, **q[2]**, and **q[3]**. If **p[1]** is not
    found in array **q**, then before inserting it straightaway into array **r**,
    it is compared with the existing elements of array **r** to avoid repetitive elements.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程会与其他数组 **q** 的元素重复。也就是说，**p[1]** 与 **q[0]**、**q[1]**、**q[2]** 和 **q[3]**
    进行比较。如果 **p[1]** 在数组 **q** 中找不到，那么在直接将其插入数组 **r** 之前，它会与数组 **r** 中现有的元素进行比较，以避免重复元素。
- en: 'Because the element at **p[1]** appears in array **q** and is not already present
    in array **r**, it is added to array **r** as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为数组 `p` 中的元素 **p[1]** 出现在数组 **q** 中，并且尚未存在于数组 **r** 中，所以它按照以下方式添加到数组 **r**
    中：
- en: '![](img/b3ed38d0-9d64-4a2f-9a0e-5ad75ab84c51.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3ed38d0-9d64-4a2f-9a0e-5ad75ab84c51.png)'
- en: Figure 1.13
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13
- en: 'The `commoninarray.c` program for establishing common elements among the two
    arrays is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 建立两个数组之间公共元素的 `commoninarray.c` 程序如下：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A macro, `max`, is defined of size `100`. A function, `ifexists()`, is defined
    that simply returns `true (1)` or `false (0)`. The function returns `true` if
    the supplied value exists in the specified array, and `false` if it doesn't.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个大小为 `100` 的宏 `max`。定义了一个函数 `ifexists()`，该函数简单地返回 `true (1)` 或 `false (0)`。如果提供的值存在于指定的数组中，则函数返回
    `true`，如果不存在，则返回 `false`。
- en: Two arrays are defined, called `p` and `q`, of size `max` (in other words, 100
    elements). You will be prompted to specify the length of the array, `p`, and then
    asked to enter the elements in that array. After that, you will be asked to specify
    the length of array `q`, followed by entering the elements in array `q`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了两个大小为 `max`（换句话说，100 个元素）的数组，分别称为 `p` 和 `q`。您将被提示指定数组 `p` 的长度，然后输入该数组的元素。之后，您将被要求指定数组
    `q` 的长度，然后输入数组 `q` 的元素。
- en: Thereafter, `p[0]`, the first element in array `p` , is picked up, and by using
    the `for` loop, `p[0]` is compared with all the elements of array `q`. If `p[0]`
    is found in array `q`, then `p[0]` is added to the resulting array, `r`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择数组 `p` 中的第一个元素 `p[0]`，并使用 `for` 循环将其与数组 `q` 的所有元素进行比较。如果 `p[0]` 在数组 `q`
    中找到，则将 `p[0]` 添加到结果数组 `r` 中。
- en: After a comparison of `p[0]`, the second element in array p, `p[1]`, is picked
    up and compared with all the elements of array `q`. The procedure is repeated
    until all the elements of array `p` are compared with all the elements of array
    `q`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 比较完 `p[0]` 后，将选择数组 `p` 的第二个元素 `p[1]` 并将其与数组 `q` 的所有元素进行比较。这个过程会一直重复，直到数组 `p`
    的所有元素都与数组 `q` 的所有元素进行比较。
- en: If any elements of array `p` are found in array `q`, then before adding that
    element to the resulting array, `r`, it is run through the `ifexists()` function
    to ensure that the element does not already exist in array `r`. This is because
    we don't want repetitive elements in array `r`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组 `p` 的任何元素在数组 `q` 中找到，则在将其添加到结果数组 `r` 之前，该元素会通过 `ifexists()` 函数运行以确保该元素尚未存在于数组
    `r` 中。这是因为我们不希望在数组 `r` 中有重复的元素。
- en: Finally, all the elements in array `r`, which are the common elements of the
    two arrays, are displayed on the screen.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有在数组 `r` 中的元素，即两个数组的公共元素，都会显示在屏幕上。
- en: 'Let''s use GCC to compile the `commoninarray.c` program as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 按以下方式编译 `commoninarray.c` 程序：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s run the generated executable file, `commoninarray.exe`, to see
    the output of the program:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行生成的可执行文件 `commoninarray.exe`，以查看程序输出：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Because there were no common elements between the two arrays entered previously,
    we can't quite say that we've truly tested the program. Let's run the program
    again, and this time, we will enter the array elements such that they have something
    in common.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前输入的两个数组之间没有公共元素，所以我们不能完全说我们已经真正测试了程序。让我们再次运行程序，这次我们将输入具有共同元素的数组元素。
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Voilà! We've successfully identified the common elements between two arrays.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功识别出两个数组之间的公共元素。
- en: Finding the difference between two sets or arrays
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找两个集合或数组之间的差异
- en: When we talk about the difference between two sets or arrays, we are referring
    to all the elements of the first array that don't appear in the second array.
    In essence, all the elements in the first array that are not common to the second
    array are referred to as the difference between the two sets. The difference in
    sets `p` and `q`, for example, will be denoted by `p – q`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论两个集合或数组之间的差异时，我们指的是第一个数组中不出现在第二个数组中的所有元素。本质上，第一个数组中不属于第二个数组的所有元素被称为两个集合的差异。例如，集合
    `p` 和 `q` 的差异将表示为 `p – q`。
- en: If array `p`, for example, has the elements `{1, 2, 3, 4}`, and array `q` has
    the elements `{2, 4, 5, 6}`, then the difference between the two arrays, `p -
    q`, will be  `{1,3}`.  Let's find out how this is done.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果数组 `p` 有元素 `{1, 2, 3, 4}`，而数组 `q` 有元素 `{2, 4, 5, 6}`，那么两个数组的差异 `p - q`
    将是 `{1,3}`。让我们看看这是如何实现的。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Define two arrays, say `p` and `q`, of a certain size and assign elements of
    your choice to both the arrays.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个数组，例如 `p` 和 `q`，并分配你选择的元素给这两个数组。
- en: Define one more array, say `r`, to be used for storing the elements that represent
    the difference between the two arrays.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个额外的数组，例如 `r`，用于存储代表两个数组之间差异的元素。
- en: Pick one element from array `p` and compare it with all the elements of the
    array `q`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组 `p` 中取一个元素，并与数组 `q` 的所有元素进行比较。
- en: If the element of array `p` exists in array `q`, discard that element and pick
    up the next element of array `p` and repeat from step 3.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组 `p` 的元素存在于数组 `q` 中，则舍弃该元素，取数组 `p` 的下一个元素，并从步骤 3 重新开始。
- en: If the element of array `p` does not exist in array `q`, add that element in
    array `r`. Before adding that element to array `r`, ensure that it does not already
    exist in array `r`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组 `p` 的元素不在数组 `q` 中，则将该元素添加到数组 `r` 中。在将该元素添加到数组 `r` 之前，请确保它尚未存在于数组 `r` 中。
- en: Repeat steps 3 to 5 until all the elements of array `p` are compared.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 3 到 5，直到比较完数组 `p` 的所有元素。
- en: Display all the elements in array `r`, as these are the elements that represent
    the difference between arrays `p` and `q`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数组 `r` 中显示所有元素，因为这些元素代表了数组 `p` 和 `q` 之间的差异。
- en: 'The `differencearray.c` program to establish the difference between two arrays
    is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 建立两个数组之间差异的 `differencearray.c` 程序如下：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以便更好地理解它。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We defined two arrays called **p** and **q**. We don't want to fix the length
    of these arrays, so we should define a macro called `max` of value `100` and set
    the two arrays, **p** and **q**, to the size of `max`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个数组，分别称为 **p** 和 **q**。我们不想固定这些数组的长度，因此应该定义一个名为 `max` 的宏，其值为 `100`，并将两个数组
    **p** 和 **q** 设置为 `max` 的大小。
- en: Thereafter, you will be prompted to specify the size of the first array and
    enter the elements in the first array, **p**. Similarly, you will be asked to
    specify the length of the second array, **q**, followed by entering the elements
    in the second array.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，你将被提示指定第一个数组的大小并输入第一个数组 **p** 的元素。同样，你将被要求指定第二个数组 **q** 的长度，然后输入第二个数组的元素。
- en: 'Let''s assume you have specified the length of both arrays as 4 and have entered
    the following elements:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已指定两个数组的长度为 4，并已输入以下元素：
- en: '![](img/8fc0af7c-1dc3-43a0-a703-259a403fa501.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fc0af7c-1dc3-43a0-a703-259a403fa501.png)'
- en: Figure 1.14
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14
- en: We need to pick up one element at a time from the first array and compare it
    with all the elements of the second array. If an element in array **p** does not
    appear in array **q**, it will be assigned to the third array we created, array **r**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一次从第一个数组中取一个元素，并与第二个数组的所有元素进行比较。如果数组 **p** 中的元素不在数组 **q** 中，它将被分配到我们创建的第三个数组，即数组
    **r**。
- en: Array **r** will be used for storing the elements that define the difference
    between two arrays. As shown in *Figure 1.15*, the first element of array **p**,
    in other words, at **p[0]**, is compared with all the elements of array **q**,
    in other words, with **q[0]**, **q[1]**, **q[2]**, and **q[3]**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 **r** 将用于存储定义两个数组之间差异的元素。如图 *图 1.15* 所示，数组 **p** 的第一个元素，即 **p[0]**，将与数组 **q**
    的所有元素进行比较，即与 **q[0]**、**q[1]**、**q[2]** 和 **q[3]**。
- en: 'Because the element at **p[0]**, which is **1**, does not appear in array **q**,
    it will be added to the array **r**, indicating the first element representing
    the difference between the two arrays:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为位于 `**p[0]**` 的元素，即 `**1**`，没有出现在数组 `**q**` 中，所以它将被添加到数组 **r** 中，表示两个数组之间的第一个差异元素：
- en: '![](img/e07c23be-748e-436a-8ef0-17269e96b071.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e07c23be-748e-436a-8ef0-17269e96b071.png)'
- en: Figure 1.15
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15
- en: Because the element at **p[1]**, which is **2**, appears in array **q**, it
    is discarded, and the next element in array **p**, in other words, **p[2]**, is
    picked up and compared with all the elements in array **q**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为位于 `**p[1]**` 的元素，即 `**2**`，出现在数组 `**q**` 中，所以它被舍弃，然后取数组 `**p**` 中的下一个元素，即
    `**p[2]**`，并与数组 `**q**` 中的所有元素进行比较。
- en: 'As the element at **p[2]** does not appear in array **q**, it is added to array **r**
    at the next available location, which is **r[1]** (see *Figure 1.16* as follows):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于位于 `**p[2]**` 的元素没有出现在数组 `**q**` 中，它将被添加到数组 **r** 的下一个可用位置，即 **r[1]**（如下 *图
    1.16* 所示）：
- en: '![](img/ca765e18-f000-44dc-9136-885c95b3315c.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca765e18-f000-44dc-9136-885c95b3315c.png)'
- en: Figure 1.16
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16
- en: Continue the procedure until all the elements of array **p** are compared with
    all the elements of array **q**. Finally, we will have array **r**, with the elements
    showing the difference between our two arrays, **p** and **q**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行此过程，直到数组 **p** 的所有元素都与数组 **q** 的所有元素进行比较。最后，我们将得到数组 **r**，其元素显示了我们的两个数组
    **p** 和 **q** 之间的差异。
- en: 'Let''s use GCC to compile our program, `differencearray.c`, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译我们的程序，`differencearray.c`，如下所示：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s run the generated executable file, `differencearray`, to see the
    output of the program:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行生成的可执行文件，`differencearray`，以查看程序的输出：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Voilà! We've successfully found the difference between two arrays. Now, let's
    move on to the next recipe!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功找到了两个数组之间的差异。现在，让我们继续下一个菜谱！
- en: Finding the unique elements in an array
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数组中查找唯一元素
- en: In this recipe, we will learn how to find the unique elements in an array, such
    that the repetitive elements in the array will be displayed only once.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何查找数组中的唯一元素，以便数组中的重复元素只显示一次。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Define two arrays, **p** and **q**, of a certain size and assign elements only
    to array **p**. We will leave array **q** blank.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个大小一定的数组 **p** 和 **q**，并将元素仅分配给数组 **p**。我们将数组 **q** 留空。
- en: These will be our source and target arrays, respectively. The target array will
    contain the resulting unique elements of the source array.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些将分别是我们的源数组和目标数组。目标数组将包含源数组的唯一元素。
- en: After that, each of the elements in the source array will be compared with the
    existing elements in the target array.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，源数组中的每个元素都将与目标数组中现有的元素进行比较。
- en: If the element in the source array exists in the target array, then that element
    is discarded and the next element in the source array is picked up for comparison.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果源数组中的元素存在于目标数组中，则该元素将被丢弃，并从源数组中取出下一个元素进行比较。
- en: If the source array element does not exist in the target array, it is copied
    into the target array.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果源数组元素不在目标数组中，它将被复制到目标数组中。
- en: 'Let''s assume that array **p** contains the following repetitive elements:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设数组 **p** 包含以下重复元素：
- en: '![](img/bb3482eb-e590-44c7-9ef5-0c21eab0731b.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb3482eb-e590-44c7-9ef5-0c21eab0731b.png)'
- en: Figure 1.17
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17
- en: 'We will start by copying the first element of the source array, **p**, into
    the target array, **q**, in other words, **p[0]** into array **q[0]**, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将源数组 **p** 的第一个元素复制到目标数组 **q** 中，换句话说，**p[0]** 复制到数组 **q[0]**，如下所示：
- en: '![](img/9e6c62a6-5225-4c80-bcdd-02877479214c.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e6c62a6-5225-4c80-bcdd-02877479214c.png)'
- en: Figure 1.18
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18
- en: 'Next, the second array element of **p**, in other words, **p[1]**, is compared
    with all the existing elements of array **q**. That is, **p[1]** is compared with
    array **q** to check whether it already exists in array **q**, as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，比较 **p** 的第二个数组元素，换句话说，**p[1]**，与数组 **q** 中所有现有的元素。也就是说，**p[1]** 与数组 **q**
    进行比较，以检查它是否已经存在于数组 **q** 中，如下所示：
- en: '![](img/a3d0013c-a44a-4ad0-80b8-071cd266163a.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3d0013c-a44a-4ad0-80b8-071cd266163a.png)'
- en: Figure 1.19
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19
- en: 'Because **p[1]** does not exist in array **q**, it is copied at **q[1]**, as
    shown in *Figure 1.20*:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 **p[1]** 不存在于数组 **q** 中，所以它被复制到 **q[1]**，如图 *1.20* 所示：
- en: '![](img/8f45d9b2-5b7f-4065-8fbf-ee262e075cc9.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f45d9b2-5b7f-4065-8fbf-ee262e075cc9.png)'
- en: Figure 1.20
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20
- en: This procedure is repeated until all the elements of array **p** are compared
    with array q. In the end, we will have array **q**, which will contain the unique
    elements of array **p**.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此过程会重复进行，直到数组 **p** 的所有元素都与数组 **q** 进行比较。最后，我们将得到数组 **q**，它将包含数组 **p** 的唯一元素。
- en: 'Here is the `uniqueelements.c` program for finding the unique elements in the
    first array:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于在第一个数组中查找唯一元素的 `uniqueelements.c` 程序：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will define a macro called `max` of size `100`. Two arrays, `p` and `q`,
    are defined of size `max`. Array `p` will contain the original elements, and array
    `q` will contain the unique elements of array `p`. You will be prompted to enter
    the length of the array and, thereafter, using the `for` loop, the elements of
    the array will be accepted and assigned to array `p`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个大小为 `100` 的宏 `max`。定义两个大小为 `max` 的数组 `p` 和 `q`。数组 `p` 将包含原始元素，而数组 `q`
    将包含数组 `p` 的唯一元素。您将被提示输入数组的长度，然后使用 `for` 循环，将数组元素接受并分配给数组 `p`。
- en: 'The following statement will assign the first element of array `p` to the first
    index location of our blank array, which we will name array `q`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句将数组`p`的第一个元素赋值给空白数组`q`的第一个索引位置，我们将该数组命名为`q`：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A `for` loop is again used to access the rest of the elements of array `p`,
    one by one. First, the foremost element of array `p`, which is at `p[0]`, is copied
    to array `q` at `q[0]`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`for`循环逐个访问数组`p`的其余元素。首先，数组`p`的第一个元素，即`p[0]`，被复制到数组`q`的`q[0]`位置。
- en: Next, the second array `p` element, `p[1]`, is compared with all the existing
    elements of array `q`. That is, `p[1]` is checked against array `q` to confirm
    whether it is already present there.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，比较第二个数组`p`的元素`p[1]`与数组`q`中所有现有的元素。也就是说，`p[1]`被检查是否已经存在于数组`q`中。
- en: Because there is only a single element in array `q`,  `p[1]` is compared with `q[0]`.
    Because `p[1]` does not exist in array `q`, it is copied at `q[1]`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组`q`中只有一个元素，所以`p[1]`与`q[0]`进行比较。由于`p[1]`不在数组`q`中，它被复制到`q[1]`。
- en: This procedure is repeated for all elements in array `p`. Each of the accessed
    elements of array `p` is run through the `ifexists()` function to check whether
    any of them already exist in array `q`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会重复进行，直到数组`p`中的所有元素都被检查和比较。数组`p`访问到的每个元素都会通过`ifexists()`函数来检查它们是否已经存在于数组`q`中。
- en: The function returns `1` if an element in array `p` already exists in array
    `q`. In that case, the element in array `p` is discarded and the next array element
    is picked up for comparison.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组`p`中的元素已经在数组`q`中，函数将返回`1`。在这种情况下，数组`p`中的元素将被丢弃，下一个数组元素将被选中进行比较。
- en: In case the `ifexists()` function returns `0`, confirming that the element in
    array `p` does not exist in array `q`, the array `p` element is added to array
    `q` at the next available index/subscript location.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ifexists()`函数返回`0`，确认数组`p`中的元素不在数组`q`中，则数组`p`的元素将被添加到数组`q`的下一个可用索引/下标位置。
- en: When all the elements of array `p` are checked and compared, array `q` will
    have only the unique elements of array `p`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查并比较数组`p`的所有元素后，数组`q`将只包含数组`p`的唯一元素。
- en: 'Let''s use GCC to compile the `uniqueelements.c` program as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`uniqueelements.c`程序，如下所示：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s run the generated executable file, `uniqueelements.exe`, to see
    the output of the program:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行生成的可执行文件`uniqueelements.exe`，以查看程序的输出：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Voilà! We've successfully identified the unique elements in an array. Now, let's
    move on to the next recipe!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功识别了数组中的唯一元素。现在，让我们继续下一个菜谱！
- en: Finding whether a matrix is sparse
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 判断矩阵是否为稀疏
- en: A matrix is considered sparse when it has more zero values than non-zero values
    (and dense when it has more non-zero values). In this recipe, we will learn how
    to find out whether the specified matrix is sparse.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个矩阵的零值多于非零值时（非零值多时为密集矩阵），它被认为是稀疏矩阵。在这个菜谱中，我们将学习如何判断指定的矩阵是否为稀疏。
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'First, specify the order of the matrix. Then, you will be prompted to enter
    the elements in the matrix. Let''s assume that you specified the order of the
    matrix as 4 x 4\. After entering the elements in the matrix, it might appear like
    this:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，指定矩阵的阶数。然后，您将被提示输入矩阵中的元素。假设您指定了矩阵的阶数为4 x 4。在输入矩阵元素后，它可能看起来像这样：
- en: '![](img/2f8763f6-46f1-4ecb-9a6d-b11350ac663c.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f8763f6-46f1-4ecb-9a6d-b11350ac663c.png)'
- en: Figure 1.21
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.21
- en: Once the elements of the matrix are entered, count the number of zeros in it.
    A counter for this purpose is initialized to **0**. Using nested loops, each of
    the matrix elements is scanned and, upon finding any zero elements, the value
    of the counter is incremented by 1.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦输入了矩阵的元素，就计算其中的零的数量。为此，初始化一个计数器为**0**。使用嵌套循环，扫描矩阵中的每个元素，并在找到任何零元素时，将计数器的值增加1。
- en: Thereafter, the following formula is used for establishing whether the matrix
    is sparse.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此后，使用以下公式来确定矩阵是否为稀疏。
- en: '*If counter > [(the number of rows x the number of columns)/2] =  Sparse Matrix*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果计数器 > [(行数 x 列数) / 2] = 稀疏矩阵*'
- en: 'Depending on the result of the preceding formula, one of the following messages
    will be displayed on the screen as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据前面公式的结果，屏幕上会显示以下消息之一：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: or
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `sparsematrix.c` program for establishing whether the matrix is sparse
    is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 用于确定矩阵是否为稀疏的`sparsematrix.c`程序如下：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we don't want to fix the size of the matrix, we will define a macro
    called `max` of value 100\. A matrix, or a two-dimensional array called **arr**,
    is defined of the order max x max. You will be prompted to enter the order of
    the matrix, for which you can again enter any value up to 100.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不想固定矩阵的大小，我们将定义一个名为 `max` 的宏，其值为 100。定义了一个矩阵，或称为二维数组 **arr**，其阶数为 max x
    max。你将被提示输入矩阵的阶数，你可以输入任何 100 以内的值。
- en: 'Let''s assume that you’ve specified the order of the matrix as 4 x 4\. You
    will be prompted to enter elements in the matrix. The values entered in the matrix
    will be in row-major order. After entering the elements, the matrix **arr** should
    look like *F**igure 1.22,* as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经指定了矩阵的阶数为 4 x 4。你将被提示输入矩阵的元素。矩阵中输入的值将按照行主序排列。输入元素后，矩阵 **arr** 应该看起来像 *图
    1.22*，如下所示：
- en: '![](img/aedcbc84-4f1e-4271-964d-3adf93ec0e3b.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aedcbc84-4f1e-4271-964d-3adf93ec0e3b.png)'
- en: Figure 1.22
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22
- en: 'A counter called `ctr` is created and is initialized to `0`. Using nested loops,
    each element of matrix `arr` is checked and the value of `ctr` is incremented
    if any element is found to be 0\. Thereafter, using the `if else` statement, we
    will check whether the count of zero values is more than non-zero values. If the
    count of zero values is more than non-zero values, then the message will be displayed
    on the screen as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个名为 `ctr` 的计数器，并将其初始化为 `0`。使用嵌套循环，检查矩阵 `arr` 的每个元素，如果发现任何元素是 0，则将 `ctr`
    的值增加。之后，使用 `if else` 语句检查零值的数量是否多于非零值。如果零值的数量多于非零值，则将在屏幕上显示以下消息：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, failing that, the message will be displayed on the screen as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有满足这些条件，屏幕上将会显示以下消息：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s use GCC to compile the `sparsematrix.c` program as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `sparsematrix.c` 程序，如下所示：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s run the generated executable file, `sparsematrix.exe`, to see the output
    of the program:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行生成的可执行文件，`sparsematrix.exe`，以查看程序的输出：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Okay. Let''s run the program again to see the output when the count of non-zero
    values is higher:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们再次运行程序，以查看非零值数量更多时的输出：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Voilà! We've successfully identified a sparse and a non-sparse matrix.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功识别了一个稀疏矩阵和一个非稀疏矩阵。
- en: There's more...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'How about finding an identity matrix, in other words, finding out whether the
    matrix entered by the user is an identity matrix or not. Let me tell you—a matrix
    is said to be an identity matrix if it is a square matrix and all the elements
    of the principal diagonal are ones and all other elements are zeros. An identity
    matrix of the order **3 x 3** may appear as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何找到一个单位矩阵，换句话说，判断用户输入的矩阵是否为单位矩阵呢？让我告诉你——如果一个矩阵是一个方阵，且主对角线上的所有元素都是 1，而其他所有元素都是
    0，那么这个矩阵就是一个单位矩阵。一个 **3 x 3** 阶的单位矩阵可能如下所示：
- en: '![](img/cec9498c-eb58-4644-a7b8-a829389e2475.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cec9498c-eb58-4644-a7b8-a829389e2475.png)'
- en: Figure 1.23
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23
- en: 'In the preceding diagram, you can see that the principal diagonal elements
    of the matrix are 1''s and the rest of them are 0''s. The index or subscript location
    of the principal diagonal elements will be `arr[0][0]`, `arr[1][1]`, and `arr[2][2]`,
    so the following procedure is followed to find out whether the matrix is an identity
    matrix or not:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到矩阵的主对角线元素是 1，其余元素都是 0。主对角线元素的索引或下标位置将是 `arr[0][0]`、`arr[1][1]` 和
    `arr[2][2]`，因此按照以下步骤来检查矩阵是否是单位矩阵：
- en: Checks that if the index location of the row and column is the same, in other
    words, if the row number is 0 and the column number, too, is 0, then at that index
    location, [0][0], the matrix element must be `1`. Similarly, if the row number
    is 1 and the column number, too, is 1, that is, at the [1][1] index location,
    the matrix element must be `1`.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查行和列的索引位置是否相同，换句话说，如果行号是 0，列号也是 0，那么在该索引位置 [0][0]，矩阵元素必须是 `1`。同样，如果行号是 1，列号也是
    1，即在 [1][1] 索引位置，矩阵元素必须是 `1`。
- en: Verify that the matrix element is `0` at all the other index locations.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证矩阵在其他所有索引位置上的元素都是 `0`。
- en: If both the preceding conditions are met, then the matrix is an identity matrix,
    or else it is not.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足上述两个条件，则该矩阵是单位矩阵，否则不是。
- en: 'The `identitymatrix.c` program to establish whether the entered matrix is an
    identity matrix or not is given as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 `identitymatrix.c` 程序，用于判断输入的矩阵是否为单位矩阵：
- en: '[PRE40]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s use GCC to compile the `identitymatrix.c` program as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `identitymatrix.c` 程序，如下所示：
- en: '[PRE41]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'No error is generated. This means the program is compiled perfectly and an
    executable file is generated. Let''s run the generated executable file. First,
    we will enter a non-square matrix:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 没有生成错误。这意味着程序编译完美，生成了一个可执行文件。让我们运行生成的可执行文件。首先，我们将输入一个非方阵：
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, let's run the program again; this time, we will enter a square matrix
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行程序；这次，我们将输入一个方阵
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Because a non-diagonal element in the preceding matrix is `1`, it is not an
    identity matrix. Let''s run the program again:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因为前面矩阵中的非对角线元素是 `1`，它不是一个单位矩阵。让我们再次运行程序：
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, let's move on to the next recipe!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Merging two sorted arrays into a single array
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将两个排序数组合并成一个数组
- en: In this recipe, we will learn to merge two sorted arrays into a single array
    so that the resulting merged array is also in sorted form.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何合并两个排序数组，以便生成的合并数组也是排序的。
- en: How to do it…
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s assume there are two arrays, **p** and **q**, of a certain length. The
    length of the two arrays can differ. Both have some sorted elements in them, as
    shown in *Figure 1.24*:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设有两个长度一定的数组 **p** 和 **q**。两个数组的长度可以不同。它们都包含一些排序元素，如图 *1.24* 所示：
- en: '![](img/3a51fc2f-4333-42ee-9a74-3103b8273fcb.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a51fc2f-4333-42ee-9a74-3103b8273fcb.png)'
- en: Figure 1.24
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.24
- en: The merged array that will be created from the sorted elements of the preceding
    two arrays will be called array **r**. Three subscripts or index locations will
    be used to point to the respective elements of the three arrays.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面两个数组的排序元素中创建的合并数组将被称为数组 **r**。将使用三个下标或索引位置来指向三个数组中的相应元素。
- en: Subscript `i` will be used to point to the index location of array `p`. Subscript
    `j` will be used to point to the index location of array `q` and subscript `k`
    will be used to point to the index location of array `r`. In the beginning, all
    three subscripts will be initialized to `0`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下标 `i` 将用于指向数组 `p` 的索引位置。下标 `j` 将用于指向数组 `q` 的索引位置，下标 `k` 将用于指向数组 `r` 的索引位置。一开始，所有三个下标都将初始化为
    `0`。
- en: 'The following three formulas will be applied to get the merged sorted array:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用以下三个公式来获取合并的排序数组：
- en: 'The element at `p[i]` is compared with the element at `q[j]`. If `p[i]` is
    less than `q[j]`, then `p[i]` is assigned to array `r`, and the indices of arrays `p`
    and `r` are incremented so that the following element of array `p` is picked up
    for the next comparison as follows:'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将比较 `p[i]` 中的元素与 `q[j]` 中的元素。如果 `p[i]` 小于 `q[j]`，则将 `p[i]` 分配给数组 `r`，并增加数组 `p`
    和 `r` 的索引，以便选择数组 `p` 的下一个元素进行比较，如下所示：
- en: '[PRE45]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If `q[j]` is less than `p[i]`, then `q[j]` is assigned to array `r`, and the
    indices of arrays `q` and `r`  are incremented so that the following element of
    array `q` is picked up for the next comparison as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `q[j]` 小于 `p[i]`，则将 `q[j]` 分配给数组 `r`，并增加数组 `q` 和 `r` 的索引，以便选择数组 `q` 的下一个元素进行比较，如下所示：
- en: '[PRE46]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If `p[i]` is equal to `q[j]`, then both the elements are assigned to array `r`.  `p[i]`
    is added to `r[k]`. The values of the `i` and `k` indices are incremented.  `q[j]` is
    also added to `r[k]`, and the indices of the `q` and `r` arrays are incremented.
    Refer to the following code snippet:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `p[i]` 等于 `q[j]`，则两个元素都分配给数组 `r`。`p[i]` 被添加到 `r[k]`。`i` 和 `k` 索引的值增加。`q[j]`
    也被添加到 `r[k]`，`q` 和 `r` 数组的索引增加。请参考以下代码片段：
- en: '[PRE47]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The procedure will be repeated until either of the arrays gets over. If any
    of the arrays is over, the remainder of the elements of the other array will be
    simply appended to the array `r`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程将重复进行，直到任一数组结束。如果任一数组结束，另一个数组的剩余元素将简单地追加到数组 `r` 中。
- en: 'The `mergetwosortedarrays.c` program for merging two sorted arrays is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个排序数组 `mergetwosortedarrays.c` 程序如下：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A macro called `max` is defined of size `100`. Three arrays, `p`, `q`, and `r`,
    are defined of size `max`. You will first be asked to enter the size of the first
    array, `p`, followed by the sorted elements for array `p`. The process is repeated
    for the second array `q`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个大小为 `100` 的宏 `max`。定义了三个大小为 `max` 的数组，`p`、`q` 和 `r`。你首先将被要求输入第一个数组 `p`
    的大小，然后输入数组 `p` 的排序元素。这个过程将重复用于第二个数组 `q`。
- en: Three indices, `i`, `j` and `k`, are defined and initialized to `0`. The three
    indices will point to the elements of the three arrays, `p`, `q`, and `r`, respectively.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 三个索引 `i`、`j` 和 `k` 被定义并初始化为 `0`。这三个索引将分别指向三个数组 `p`、`q` 和 `r` 的元素。
- en: The first elements of arrays **p** and **q**, in other words, **p[0]**  and **q[0]**,
    are compared and the smaller one is assigned to array **r**.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 **p** 和 **q** 的第一个元素，换句话说，**p[0]** 和 **q[0]**，将被比较，较小的值将被分配到数组 **r**。
- en: 'Because **q[0]** is smaller than **p[0]**, **q[0]** is added to array **r**, and
    the indices of arrays **q** and **r** are incremented for the next comparison
    as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `**q[0]**` 小于 `**p[0]**`，所以 `**q[0]**` 被添加到数组 `**r**`，并且 `**q**` 和 `**r**`
    数组的索引将增加以进行下一次比较，如下所示：
- en: '![](img/4f589a7b-f9dc-4b75-9996-03be25128569.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f589a7b-f9dc-4b75-9996-03be25128569.png)'
- en: Figure 1.25
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.25
- en: 'Next, **p[0]** will be compared with **q[1]**. Because **p[0]** is smaller
    than **q[1]**, the value at **p[0]** will be assigned to array **r** at **r[1]**:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将比较 `**p[0]**` 与 `**q[1]**`。因为 `**p[0]**` 小于 `**q[1]**`，所以 `**p[0]**` 的值将被分配到数组
    `**r**` 的 `**r[1]**` 位置：
- en: '![](img/7fd85177-4980-4662-b195-8e4e7c6fd69a.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fd85177-4980-4662-b195-8e4e7c6fd69a.png)'
- en: Figure 1.26
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.26
- en: 'Then, **p[1]** will be compared with **q[1]**. Because **q[1]** is smaller
    than **p[1]**, **q[1]** will be assigned to array **r**, and the indices of the **q** and **r** arrays
    will be incremented for the next comparisons (refer to the following diagram):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将比较 `**p[1]**` 与 `**q[1]**`。因为 `**q[1]**` 小于 `**p[1]**`，所以 `**q[1]**` 将被分配到数组
    `**r**`，并且 `**q**` 和 `**r**` 数组的索引将增加以进行下一次比较（参见图下所示）：
- en: '![](img/6c9a9e7d-fa51-4ee7-9988-77b0539eba1e.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c9a9e7d-fa51-4ee7-9988-77b0539eba1e.png)'
- en: Figure 1.27
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.27
- en: 'Let''s use GCC to compile the `mergetwosortedarrays.c` program as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `mergetwosortedarrays.c` 程序，如下所示：
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s run the generated executable file, `mergetwosortedarrays.exe`,
    in order to see the output of the program:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行生成的可执行文件 `mergetwosortedarrays.exe`，以查看程序的输出：
- en: '[PRE50]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Voilà! We've successfully merged two sorted arrays into one.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功地将两个排序后的数组合并成了一个。
