["```cpp\nSearch = function () \n{ \n    //Do search actions.. \n    if playerFound == true then currentState = Attack end \n} \nAttack = function() \n{ \n    //Do attack actions \n    if playerAttacks == true then currentState = Evade  \n    elseif playerOutOfSight == true then currentState = Search end \n} \nEvade = function() \n{ \n    //Do evade actions \n    If healthIsLow == true then currentState = FindHealth \n    Elseif playerRetreats == true then currentState == Attack end \n} \nFindHealth = function() \n{ \n    //Do finding health actions \n    If healthFound == true then currentState = Search end \n} \ncurrentState = Search \n```", "```cpp\nStateA =  \n{ \n    Update = function () \n    { \n        //Do state update actions \n} \nOnEnter = function() \n{ \n    //Do actions for first load \n} \nOnExit = function() \n{ \n    //Do action for last call for this state \n} \n} \n```", "```cpp\nclass StateList { \n    public: \n        StateList (); \n        ~ StateList (); \n\n        LuaState * GoToNext(); \n        LuaState * GoToPrevious(); \n\n        void SetCurrentState(int nextState); \n        void AddState(State * newState); \n\n        void Destroy(); \n\n        LuaState* GetCurrent(); \n\n    protected: \n        std::vector< LuaState*> m_states; \n        int m_currentStateIndex = -1; \n    }; \n} \n```", "```cpp\nDecisionTree = {}; \n\nfunction DecisionTree.SetBranch(self, branch)     \nself.branch_ = branch; \nend \n\nfunction DecisionTree.Update(self, deltaTime)     \n-- Skip execution if the tree hasn't been setup yet.     \nif (self.branch_ == nil) then \n        return; \n    end \n    -- Search the tree for an Action to run if not currently     \n    -- executing an Action. \n    if (self.currentAction_ == nil) then \n        self.currentAction_ = self.branch_:Evaluate(); \n        self.currentAction_:Initialize(); \n    end \n        local status = self.currentAction_:Update(deltaTime); \nend \nfunction DecisionTree.new() \n    local decisionTree = {}; \n        -- The DecisionTree's data members. \n    decisionTree.branch_ = nil; \n    decisionTree.currentAction_ = nil; \n        -- The DecisionTree's accessor functions. \n    decisionTree.SetBranch = decisionTree.SetBranch; \n    decisionTree.Update = decisionTree.Update; \n        return decisionTree; \nend \n```", "```cpp\nDecisionBranch = {} \nDecisionBranch.Type = \" DecisionBranch \"; \nfunction DecisionBranch.new() \n    local branch = {}; \n    -- The DecisionBranch data members. \n    branch.children_ = {}; \n    branch.conditional_ = nil; \n    branch.type_ = DecisionBranch.Type; \n    -- The DecisionBranch accessor functions. \n    branch.AddChild = DecisionBranch.AddChild; \n    branch.Evaluate = DecisionBranch.Evaluate; \n    branch. SetConditional = DecisionBranch. SetConditional; \n    return branch; \nend \nfunction DecisionBranch.AddChild(self, child, index) \n    -- Add the child at the specified index, or as the last child. \n    index = index or (#self.children_ + 1); \n        table.insert(self.children_, index, child); \nend \nfunction DecisionBranch.SetConditional (self, conditional) \n    self. conditional _ = conditional; \nend \n```", "```cpp\nfunction DecisionBranch.Evaluate(self) \n    -- Execute the branch's evaluator function, this will return a \n    -- numeric value which indicates what child should execute. \n    local conditional = self. conditional _(); \n    local choice = self.children_[conditional]; \n    if (choice.type_ == DecisionBranch.Type) then \n        -- Recursively evaluate children to see if they are decision branches. \n        return choice:Evaluate(); \n    else \n        -- Return the leaf action. \n        return choice; \n    end \nend \n```", "```cpp\nfunction AILogic_DecisionTree() \n    --Create a new instance of the tree \n    local tree = DecisionTree.new(); \n--Add branches \nlocal moveBranch = DecisionBranch.new(); \n    local shootBranch = DecisionBranch.new(); \n    --Connect the conditional branches and action leaves \n... \nmoveBranch:AddChild(MoveAction()); \n      moveBranch:AddChild(randomBranch); \n      moveRandomBranch:SetConditional( \n        function() \n            if Conditional_HasMovePosition() then \n                return 1; \n            end \n            return 2; \n        end); \n... \n    --Set initial branch \n    tree:SetBranch(moveBranch); \nreturn tree; \nend \n```", "```cpp\nvoid Update(float deltaTime) \n{ \n    if(currentState == attacking) \n    { \n        ReduceStamina(); \n    if(player.stamina <= depleted) \n{ \n        currentState = defending; \n} \n} \nelse if (currentState == defending) \n{ \n    IncreaseStamina(); \n    if(stamina >= replenished) \n    { \n        currentState = attacking; \n    } \n} \n} \n```", "```cpp\n    desiredHeading = normalize (position - target) * characterSpeed \n    steeringPath = desiredHeading - velocity \n```", "```cpp\nVec3 steerForSeek (const Vec3& target); \n```", "```cpp\n Vec3 steerForFlee (const Vec3& target); \n```", "```cpp\nVec3 steerForPursuit (const TargetObject& target); \n```", "```cpp\nVec3 steerForEvasion (const AbstractVehicle& menace, \n                      const float maxPredictionTime); \n```", "```cpp\nVec3 steerForWander (float dt); \n```", "```cpp\nvoid SearchGraph::BreadthFirst(int s) \n{ \n    // Mark all the vertices as not visited \n    bool *visited = new bool[V]; \n    for(int i = 0; i < V; i++) \n        visited[i] = false; \n\n    // Create a queue for BFS \n    list<int> queue; \n\n    // Mark the current node as visited and enqueue it \n    visited[s] = true; \n    queue.push_back(s); \n\n    // 'i' will be used to get all adjacent vertices of a vertex \n    list<int>::iterator i; \n\n    while(!queue.empty()) \n    { \n        // Dequeue a vertex from queue and print it \n        s = queue.front(); \n        cout << s << \" \"; \n        queue.pop_front(); \n\n        // Get all adjacent vertices of the dequeued vertex s \n        // If a adjacent has not been visited, then mark it visited \n        // and enqueue it \n        for(i = adj[s].begin(); i != adj[s].end(); ++i) \n        { \n            if(!visited[*i]) \n            { \n                visited[*i] = true; \n                queue.push_back(*i); \n            } \n        } \n    } \n} \n```", "```cpp\n// Prints shortest paths from src to all other vertices \nvoid SearchGraph:: Dijkstra(int src) \n{ \n    // Create a priority queue to store vertices that are being preprocessed \n    priority_queue< iPair, vector <iPair> , greater<iPair> > pq; \n\n    // Create a vector for distances and initialize all distances as infinite (INF) \n    vector<int> dist(V, INF); \n\n    // Insert source itself in priority queue and initialize its distance as 0\\. \n    pq.push(make_pair(0, src)); \n    dist[src] = 0; \n\n    /* Looping till priority queue becomes empty (or all \n      distances are not finalized) */ \n    while (!pq.empty()) \n    { \n        int u = pq.top().second; \n        pq.pop(); \n\n        // 'i' is used to get all adjacent vertices of a vertex \n        list< pair<int, int> >::iterator i; \n        for (i = adj[u].begin(); i != adj[u].end(); ++i) \n        { \n            // Get vertex label and weight of current adjacent of u. \n            int v = (*i).first; \n            int weight = (*i).second; \n\n            // If there is shorted path to v through u. \n            if (dist[v] > dist[u] + weight) \n            { \n                // Updating distance of v \n                dist[v] = dist[u] + weight; \n                pq.push(make_pair(dist[v], v)); \n            } \n        } \n    } \n\n    // Print shortest distances stored in dist[] \n    printf(\"Vertex   Distance from Sourcen\"); \n    for (int i = 0; i < V; ++i) \n        printf(\"%d tt %dn\", i, dist[i]); \n}  \n```", "```cpp\nfunction A*(start, goal) \n    // The set of nodes already evaluated \n    closedSet := {} \n\n    // The set of currently discovered nodes that are not evaluated yet. \n    // Initially, only the start node is known. \n    openSet := {start} \n\n    // For each node, which node it can most efficiently be reached from. \n    // If a node can be reached from many nodes, cameFrom will eventually contain the \n    // most efficient previous step. \n    cameFrom := the empty map \n\n    // For each node, the cost of getting from the start node to that node. \n    gScore := map with default value of Infinity \n\n    // The cost of going from start to start is zero. \n    gScore[start] := 0 \n\n    // For each node, the total cost of getting from the start node to the goal \n    // by passing by that node. That value is partly known, partly heuristic. \n    fScore := map with default value of Infinity \n\n    // For the first node, that value is completely heuristic. \n    fScore[start] := heuristic_cost_estimate(start, goal) \n\n    while openSet is not empty \n        current := the node in openSet having the lowest fScore[] value \n        if current = goal \n            return reconstruct_path(cameFrom, current) \n\n        openSet.Remove(current) \n        closedSet.Add(current) \n\n        for each neighbor of current \n            if neighbor in closedSet \n                continue        // Ignore the neighbor which is already evaluated. \n\n            if neighbor not in openSet    // Discover a new node \n                openSet.Add(neighbor) \n\n            // The distance from start to a neighbor \n            tentative_gScore := gScore[current] + dist_between(current, neighbor) \n            if tentative_gScore >= gScore[neighbor] \n                continue        // This is not a better path. \n\n            // This path is the best until now. Record it! \n            cameFrom[neighbor] := current \n            gScore[neighbor] := tentative_gScore \n            fScore[neighbor] := gScore[neighbor] + heuristic_cost_estimate(neighbor, goal) \n\n    return failure \n\nfunction reconstruct_path(cameFrom, current) \n    total_path := [current] \n    while current in cameFrom.Keys: \n        current := cameFrom[current] \n        total_path.append(current) \n    return total_path \n```"]