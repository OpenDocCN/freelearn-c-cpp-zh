- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Advanced Code Analysis
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é«˜çº§ä»£ç åˆ†æ
- en: 'Clang-Tidy checks, as discussed in the previous chapter, rely on advanced matching
    provided by the AST. However, this approach might not be sufficient for detecting
    more complex problems, such as lifetime issues (that is, when an object or resource
    is accessed or referenced after it has been deallocated or has gone out of scope,
    potentially leading to unpredictable behavior or crashes). In this chapter, we
    will introduce advanced code analysis tools based on the **Control Flow Graph**
    (**CFG**). The Clang Static Analyzer is an excellent example of such tools, and
    Clang-Tidy also integrates some aspects of CFGs. We will begin with typical usage
    examples and then delve into the implementation details. The chapter will conclude
    with a custom check that employs advanced techniques and extends the concept of
    class complexity to method implementations. We will define cyclomatic complexity
    and demonstrate how to calculate it using the CFG library provided by Clang. In
    this chapter, we will explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚å‰ä¸€ç« æ‰€è¿°ï¼ŒClang-Tidy æ£€æŸ¥ä¾èµ–äº AST æä¾›çš„é«˜çº§åŒ¹é…ã€‚ç„¶è€Œï¼Œè¿™ç§æ–¹æ³•å¯èƒ½ä¸è¶³ä»¥æ£€æµ‹æ›´å¤æ‚çš„é—®é¢˜ï¼Œä¾‹å¦‚ç”Ÿå‘½å‘¨æœŸé—®é¢˜ï¼ˆå³ï¼Œå½“å¯¹è±¡æˆ–èµ„æºåœ¨å·²è§£é™¤åˆ†é…æˆ–è¶…å‡ºä½œç”¨åŸŸä¹‹åè¢«è®¿é—®æˆ–å¼•ç”¨æ—¶ï¼Œå¯èƒ½å¯¼è‡´ä¸å¯é¢„æµ‹çš„è¡Œä¸ºæˆ–å´©æºƒï¼‰ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»åŸºäº
    **æ§åˆ¶æµå›¾**ï¼ˆ**CFG**ï¼‰çš„é«˜çº§ä»£ç åˆ†æå·¥å…·ã€‚Clang é™æ€åˆ†æå™¨æ˜¯æ­¤ç±»å·¥å…·çš„ç»ä½³ä¾‹å­ï¼ŒClang-Tidy ä¹Ÿé›†æˆäº† CFG çš„æŸäº›æ–¹é¢ã€‚æˆ‘ä»¬å°†ä»å…¸å‹ç”¨æ³•ç¤ºä¾‹å¼€å§‹ï¼Œç„¶åæ·±å…¥æ¢è®¨å®ç°ç»†èŠ‚ã€‚æœ¬ç« å°†ä»¥ä¸€ä¸ªä½¿ç”¨é«˜çº§æŠ€æœ¯å¹¶æ‰©å±•ç±»å¤æ‚åº¦æ¦‚å¿µåˆ°æ–¹æ³•å®ç°çš„å®šåˆ¶æ£€æŸ¥ç»“æŸã€‚æˆ‘ä»¬å°†å®šä¹‰åœˆå¤æ‚åº¦å¹¶å±•ç¤ºå¦‚ä½•ä½¿ç”¨
    Clang æä¾›çš„ CFG åº“æ¥è®¡ç®—å®ƒã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨ä»¥ä¸‹ä¸»é¢˜ï¼š
- en: What static analysis is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»€ä¹ˆæ˜¯é™æ€åˆ†æ
- en: Gaining knowledge of CFGs â€“ the basic data structure used for static analysis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: äº†è§£ CFG â€“ é™æ€åˆ†æä¸­ä½¿ç”¨çš„åŸºæœ¬æ•°æ®ç»“æ„
- en: How CFGs can be used in a custom Clang-Tidy check
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚ä½•åœ¨è‡ªå®šä¹‰ Clang-Tidy æ£€æŸ¥ä¸­ä½¿ç”¨ CFG
- en: What analysis tools are provided in Clang and what are their limitations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang æä¾›äº†å“ªäº›åˆ†æå·¥å…·ä»¥åŠå®ƒä»¬çš„å±€é™æ€§
- en: 6.1 Technical requirements
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 æŠ€æœ¯è¦æ±‚
- en: 'The source code for this chapter is located in the `chapter6` folder of the
    bookâ€™s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter6](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter6).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« çš„æºä»£ç ä½äºæœ¬ä¹¦ GitHub å­˜å‚¨åº“çš„ `chapter6` æ–‡ä»¶å¤¹ä¸­ï¼š[https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter6](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter6)ã€‚
- en: 6.2 Static analysis
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 é™æ€åˆ†æ
- en: Static analysis is a crucial technique in software development that involves
    inspecting the code without actually running the program. This method focuses
    on analyzing either the source code or its compiled version to detect a variety
    of issues, such as errors, vulnerabilities, and deviations from coding standards.
    Unlike dynamic analysis, which requires the execution of the program, static analysis
    allows for examining the code in a non-runtime environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: é™æ€åˆ†ææ˜¯è½¯ä»¶å¼€å‘ä¸­çš„ä¸€ç§å…³é”®æŠ€æœ¯ï¼Œå®ƒæ¶‰åŠåœ¨ä¸å®é™…è¿è¡Œç¨‹åºçš„æƒ…å†µä¸‹æ£€æŸ¥ä»£ç ã€‚è¿™ç§æ–¹æ³•ä¾§é‡äºåˆ†ææºä»£ç æˆ–å…¶ç¼–è¯‘ç‰ˆæœ¬ï¼Œä»¥æ£€æµ‹å„ç§é—®é¢˜ï¼Œä¾‹å¦‚é”™è¯¯ã€æ¼æ´å’Œä¸ç¼–ç æ ‡å‡†çš„åå·®ã€‚ä¸éœ€è¦æ‰§è¡Œç¨‹åºçš„åŠ¨æ€åˆ†æä¸åŒï¼Œé™æ€åˆ†æå…è®¸åœ¨éè¿è¡Œæ—¶ç¯å¢ƒä¸­æ£€æŸ¥ä»£ç ã€‚
- en: More generally, static analysis aims to check a specific property of a computer
    program based on its meaning; that is, it can be considered a part of semantic
    analysis (see [*Figure**Â 2.6*](B19722_02.xhtml#x1-390002)*, Parser*). For instance,
    if ğ’ is the set of all C/C++ programs and ğ’« is a property of such a program, then
    the goal of static analysis is to check the property for a specific program P
    âˆˆğ’, that is, to answer the question of whether ğ’«(P) is true or false.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´ä¸€èˆ¬åœ°è¯´ï¼Œé™æ€åˆ†ææ—¨åœ¨æ ¹æ®è®¡ç®—æœºç¨‹åºçš„æ„ä¹‰æ£€æŸ¥å…¶ç‰¹å®šçš„å±æ€§ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒå¯ä»¥è¢«è®¤ä¸ºæ˜¯è¯­ä¹‰åˆ†æçš„ä¸€éƒ¨åˆ†ï¼ˆå‚è§[*å›¾**Â 2.6*](B19722_02.xhtml#x1-390002)*ï¼Œè§£æå™¨*ï¼‰ã€‚ä¾‹å¦‚ï¼Œå¦‚æœ
    ğ’ æ˜¯æ‰€æœ‰ C/C++ ç¨‹åºçš„é›†åˆï¼Œè€Œ ğ’« æ˜¯æ­¤ç±»ç¨‹åºçš„ä¸€ä¸ªå±æ€§ï¼Œé‚£ä¹ˆé™æ€åˆ†æçš„ç›®æ ‡æ˜¯æ£€æŸ¥ç‰¹å®šç¨‹åº P âˆˆğ’ çš„å±æ€§ï¼Œå³å›ç­” ğ’«(P) æ˜¯å¦ä¸ºçœŸæˆ–å‡çš„é—®é¢˜ã€‚
- en: Our Clang-Tidy check from the previous chapter (see [*Section**Â 5.4*](B19722_05.xhtml#x1-1090004)*,
    Custom* *Clang-Tidy check*) is a good example of such a property. In reality,
    it takes C++ code with a class definition and decides whether the class is complex
    or not based on the number of methods it has.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨å‰ä¸€ç« ä¸­æåˆ°çš„ Clang-Tidy æ£€æŸ¥ï¼ˆå‚è§[*èŠ‚**Â 5.4*](B19722_05.xhtml#x1-1090004)*ï¼Œè‡ªå®šä¹‰* *Clang-Tidy
    æ£€æŸ¥*ï¼‰æ˜¯æ­¤ç±»å±æ€§çš„ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ã€‚å®é™…ä¸Šï¼Œå®ƒæ¥å—å…·æœ‰ç±»å®šä¹‰çš„ C++ ä»£ç ï¼Œå¹¶æ ¹æ®æ–¹æ³•æ•°é‡å†³å®šè¯¥ç±»æ˜¯å¦å¤æ‚ã€‚
- en: Itâ€™s worth noting that not all properties of a program can be checked. The most
    obvious example is the famous halting problem [[31](B19722_Bib.xhtml#XTuring1936)].
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¹¶éæ‰€æœ‰ç¨‹åºçš„æ€§è´¨éƒ½å¯ä»¥è¿›è¡Œæ£€æŸ¥ã€‚æœ€æ˜æ˜¾çš„ä¾‹å­æ˜¯è‘—åçš„åœæœºé—®é¢˜ [[31](B19722_Bib.xhtml#XTuring1936)]ã€‚
- en: Important note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦æç¤º
- en: 'The halting problem can be formulated as follows: Given a program P and an
    input I, determine whether P halts or continues to run indefinitely when executed
    with I.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: åœæœºé—®é¢˜å¯ä»¥è¡¨è¿°å¦‚ä¸‹ï¼šç»™å®šä¸€ä¸ªç¨‹åºPå’Œä¸€ä¸ªè¾“å…¥Iï¼Œç¡®å®šå½“Påœ¨Iä¸Šæ‰§è¡Œæ—¶ï¼ŒPæ˜¯åœæ­¢è¿è¡Œè¿˜æ˜¯æ— é™æœŸåœ°ç»§ç»­è¿è¡Œã€‚
- en: Formally, the problem is to decide, for a given program P and an input I, whether
    the computation of P(I) eventually stops (halts) or will never terminate (loops
    indefinitely).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å½¢å¼ä¸Šï¼Œé—®é¢˜æ˜¯è¦å†³å®šï¼Œå¯¹äºç»™å®šçš„ç¨‹åºPå’Œè¾“å…¥Iï¼ŒP(I)çš„è®¡ç®—æœ€ç»ˆæ˜¯å¦ä¼šåœæ­¢ï¼ˆåœæœºï¼‰æˆ–æ°¸è¿œä¸ä¼šç»ˆæ­¢ï¼ˆæ— é™å¾ªç¯ï¼‰ã€‚
- en: Alan Turing proved that there is no general algorithmic method for solving this
    problem for all possible program-input pairs. This result implies that there is
    no single algorithm that can correctly determine for every pair (P,I) whether
    P halts when run with I.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: é˜¿å…°Â·å›¾çµè¯æ˜äº†ä¸å­˜åœ¨ä¸€ç§é€šç”¨çš„ç®—æ³•æ–¹æ³•å¯ä»¥è§£å†³æ‰€æœ‰å¯èƒ½çš„ç¨‹åº-è¾“å…¥å¯¹çš„é—®é¢˜ã€‚è¿™ä¸ªç»“æœæ„å‘³ç€æ²¡æœ‰ä¸€ç§å•ä¸€çš„ç®—æ³•å¯ä»¥æ­£ç¡®åœ°ç¡®å®šå¯¹äºæ¯ä¸€å¯¹ï¼ˆPï¼ŒIï¼‰ï¼Œå½“Påœ¨Iä¸Šè¿è¡Œæ—¶ï¼ŒPæ˜¯å¦ä¼šåœæ­¢ã€‚
- en: Despite the fact that not all properties of programs can be proven, it can be
    done for some cases. There is a reasonable number of such cases that make static
    analysis a practical tool for usage. Thus, we can use the tools in these cases
    to systematically scan the code to determine properties of the code. These tools
    are adept at identifying issues ranging from simple syntax errors to more complex
    potential bugs. One of the key benefits of static analysis is its ability to catch
    problems early in the development cycle. This early detection is not only efficient
    but also resource-saving, as it helps identify and rectify issues before the software
    is run or deployed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡å¹¶éæ‰€æœ‰ç¨‹åºçš„æ€§è´¨éƒ½èƒ½è¢«è¯æ˜ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹æ˜¯å¯ä»¥åšåˆ°çš„ã€‚æœ‰ç›¸å½“æ•°é‡çš„è¿™ç§æ¡ˆä¾‹ä½¿å¾—é™æ€åˆ†ææˆä¸ºä¸€ä¸ªå®ç”¨çš„å·¥å…·ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™äº›å·¥å…·åœ¨è¿™äº›æƒ…å†µä¸‹ç³»ç»Ÿåœ°æ‰«æä»£ç ï¼Œä»¥ç¡®å®šä»£ç çš„æ€§è´¨ã€‚è¿™äº›å·¥å…·æ“…é•¿è¯†åˆ«ä»ç®€å•çš„è¯­æ³•é”™è¯¯åˆ°æ›´å¤æ‚çš„æ½œåœ¨é”™è¯¯çš„å„ç§é—®é¢˜ã€‚é™æ€åˆ†æçš„ä¸€ä¸ªå…³é”®ä¼˜åŠ¿æ˜¯å®ƒèƒ½å¤Ÿåœ¨å¼€å‘å‘¨æœŸçš„æ—©æœŸé˜¶æ®µæ•æ‰åˆ°é—®é¢˜ã€‚è¿™ç§æ—©æœŸæ£€æµ‹ä¸ä»…æ•ˆç‡é«˜ï¼Œè€Œä¸”èŠ‚çœèµ„æºï¼Œå› ä¸ºå®ƒæœ‰åŠ©äºåœ¨è½¯ä»¶è¿è¡Œæˆ–éƒ¨ç½²ä¹‹å‰è¯†åˆ«å’Œçº æ­£é—®é¢˜ã€‚
- en: Static analysis plays a significant role in ensuring the quality and compliance
    of software. It checks that the code adheres to prescribed coding standards and
    guidelines, which is particularly important in large-scale projects or industries
    with strict regulatory requirements. Moreover, it is highly effective in uncovering
    common security vulnerabilities such as buffer overflows, SQL injection flaws,
    and cross-site scripting vulnerabilities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: é™æ€åˆ†æåœ¨ç¡®ä¿è½¯ä»¶è´¨é‡å’Œåˆè§„æ€§æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚å®ƒæ£€æŸ¥ä»£ç æ˜¯å¦éµå¾ªè§„å®šçš„ç¼–ç æ ‡å‡†å’ŒæŒ‡å—ï¼Œè¿™åœ¨å¤§å‹é¡¹ç›®æˆ–å¯¹ç›‘ç®¡è¦æ±‚ä¸¥æ ¼çš„è¡Œä¸šä¸­å°¤ä¸ºé‡è¦ã€‚æ­¤å¤–ï¼Œå®ƒåœ¨æ­ç¤ºå¸¸è§çš„å®‰å…¨æ¼æ´æ–¹é¢éå¸¸æœ‰æ•ˆï¼Œä¾‹å¦‚ç¼“å†²åŒºæº¢å‡ºã€SQLæ³¨å…¥æ¼æ´å’Œè·¨ç«™è„šæœ¬æ¼æ´ã€‚
- en: Additionally, static analysis contributes to code refactoring and optimization
    by pinpointing areas of redundancy, unnecessary complexity, and opportunities
    for improvement. Itâ€™s a common practice to integrate these tools into the development
    process, including continuous integration pipelines. This integration allows for
    ongoing analysis of the code with each new commit or build, ensuring continual
    quality assurance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼Œé™æ€åˆ†æé€šè¿‡ç¡®å®šå†—ä½™åŒºåŸŸã€ä¸å¿…è¦çš„å¤æ‚æ€§å’Œæ”¹è¿›æœºä¼šï¼Œæœ‰åŠ©äºä»£ç é‡æ„å’Œä¼˜åŒ–ã€‚å°†æ­¤ç±»å·¥å…·é›†æˆåˆ°å¼€å‘è¿‡ç¨‹ä¸­ï¼ŒåŒ…æ‹¬æŒç»­é›†æˆç®¡é“ï¼Œæ˜¯ä¸€ç§å¸¸è§åšæ³•ã€‚è¿™ç§é›†æˆå…è®¸å¯¹ä»£ç è¿›è¡ŒæŒç»­åˆ†æï¼Œæ¯æ¬¡æäº¤æˆ–æ„å»ºæ—¶éƒ½ä¼šè¿›è¡Œï¼Œä»è€Œç¡®ä¿æŒç»­çš„è´¨é‡ä¿è¯ã€‚
- en: The Clang-Tidy checks that we created in the last chapter can be considered
    an example of a static analysis program. In this chapter, we will consider more
    advanced topics involving data structures such as CFGs, which we will see next.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨ä¸Šç« ä¸­åˆ›å»ºçš„Clang-Tidyæ£€æŸ¥å¯ä»¥è¢«è§†ä¸ºé™æ€åˆ†æç¨‹åºçš„ä¸€ä¸ªä¾‹å­ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†è€ƒè™‘æ¶‰åŠæ•°æ®ç»“æ„ï¼ˆå¦‚CFGï¼‰çš„æ›´é«˜çº§ä¸»é¢˜ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­çœ‹åˆ°ã€‚
- en: 6.3 CFG
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 CFG
- en: A **CFG** is a fundamental data structure in compiler design and static program
    analysis, representing all paths that might be traversed through a program during
    execution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**CFG**æ˜¯ç¼–è¯‘è®¾è®¡å’Œé™æ€ç¨‹åºåˆ†æä¸­çš„ä¸€ä¸ªåŸºæœ¬æ•°æ®ç»“æ„ï¼Œå®ƒè¡¨ç¤ºç¨‹åºåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å¯èƒ½éå†çš„æ‰€æœ‰è·¯å¾„ã€‚'
- en: 'A CFG consists of the following key components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªCFGç”±ä»¥ä¸‹å…³é”®ç»„ä»¶ç»„æˆï¼š
- en: '**Nodes**: Correspond to basic blocks, a straight-line sequence of operations
    with one entry and one exit point'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**èŠ‚ç‚¹**ï¼šå¯¹åº”äºåŸºæœ¬å—ï¼Œä¸€ä¸ªå…·æœ‰ä¸€ä¸ªå…¥å£ç‚¹å’Œä¸€ä¸ªå‡ºå£ç‚¹çš„æ“ä½œç›´çº¿åºåˆ—'
- en: '**Edges**: Represent the flow of control from one block to another, including
    both conditional and unconditional branches'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è¾¹**ï¼šè¡¨ç¤ºä»ä¸€ä¸ªå—åˆ°å¦ä¸€ä¸ªå—çš„æ§ä»¶æµï¼ŒåŒ…æ‹¬æ¡ä»¶å’Œæ— æ¡ä»¶åˆ†æ”¯'
- en: '**Start and end nodes**: Every CFG has a unique entry node and one or more
    exit nodes'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**èµ·å§‹å’Œç»“æŸèŠ‚ç‚¹**ï¼šæ¯ä¸ªCFGéƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„å…¥å£èŠ‚ç‚¹å’Œä¸€ä¸ªæˆ–å¤šä¸ªå‡ºå£èŠ‚ç‚¹'
- en: 'As an example of a CFG, consider the function to calculate the maximum of two
    integer numbers that we used as an example before; see [FigureÂ 2.5](B19722_02.xhtml#x1-37021r5):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºCFGçš„ä¸€ä¸ªç¤ºä¾‹ï¼Œè€ƒè™‘æˆ‘ä»¬ä¹‹å‰ç”¨ä½œç¤ºä¾‹çš„ä¸¤ä¸ªæ•´æ•°æœ€å¤§å€¼çš„å‡½æ•°ï¼›å‚è§[å›¾2.5](B19722_02.xhtml#x1-37021r5)ï¼š
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**FigureÂ 6.1**: CFG example C++ code: max.cpp'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.1**: max.cppçš„CFGç¤ºä¾‹ C++ä»£ç '
- en: 'The corresponding CFG can be represented as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åº”çš„CFGå¯ä»¥è¡¨ç¤ºå¦‚ä¸‹ï¼š
- en: '![FigureÂ 6.2: CFG example for max.cpp ](img/Figure6.2_B19722.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾6.2: max.cppçš„CFGç¤ºä¾‹](img/Figure6.2_B19722.png)'
- en: '**FigureÂ 6.2**: CFG example for max.cpp'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.2**: max.cppçš„CFGç¤ºä¾‹'
- en: 'The diagram shown in [FigureÂ 6.2](#Figure6.2) visually represents a CFG for
    the `max` function (from [FigureÂ 6.1](#x1-120012r1)) with a series of connected
    nodes and directed edges:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚[å›¾6.2](#Figure6.2)æ‰€ç¤ºï¼Œè¯¥å›¾ç›´è§‚åœ°è¡¨ç¤ºäº†`max`å‡½æ•°çš„CFGï¼ˆæ¥è‡ª[å›¾6.1](#x1-120012r1)ï¼‰ï¼Œé€šè¿‡ä¸€ç³»åˆ—è¿æ¥çš„èŠ‚ç‚¹å’Œæœ‰å‘è¾¹ï¼š
- en: '**Entry node**: At the top, there is an â€œ**entry**â€ node, representing the
    starting point of the functionâ€™s execution.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å…¥å£èŠ‚ç‚¹**ï¼šåœ¨é¡¶éƒ¨ï¼Œæœ‰ä¸€ä¸ªâ€œ**entry**â€èŠ‚ç‚¹ï¼Œè¡¨ç¤ºå‡½æ•°æ‰§è¡Œçš„èµ·ç‚¹ã€‚'
- en: '**Conditional node**: Below the entry node, there is a node labeled â€œ**a**
    **> b**â€. This node represents the conditional statement in the function, where
    the comparison between *a* and *b* is made.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ¡ä»¶èŠ‚ç‚¹**ï¼šåœ¨å…¥å£èŠ‚ç‚¹ä¸‹æ–¹ï¼Œæœ‰ä¸€ä¸ªæ ‡è®°ä¸ºâ€œ**a** **> b**â€çš„èŠ‚ç‚¹ã€‚æ­¤èŠ‚ç‚¹è¡¨ç¤ºå‡½æ•°ä¸­çš„æ¡ä»¶è¯­å¥ï¼Œå…¶ä¸­æ¯”è¾ƒ*a*å’Œ*b*ã€‚'
- en: '**Branches for true and false conditions**:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**çœŸå’Œå‡æ¡ä»¶åˆ†æ”¯**ï¼š'
- en: On the true branch (left side), there is a node labeled â€œ**Return** **a**â€,
    connected by an edge from the â€œ**a > b**â€ node. This edge is labeled â€œ**true**â€,
    indicating that if *a* is greater than *b*, the flow goes to this node.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨çœŸåˆ†æ”¯ï¼ˆå·¦ä¾§ï¼‰ï¼Œæœ‰ä¸€ä¸ªæ ‡è®°ä¸ºâ€œ**è¿”å›** **a**â€çš„èŠ‚ç‚¹ï¼Œé€šè¿‡ä»â€œ**a > b**â€èŠ‚ç‚¹çš„è¾¹è¿æ¥ã€‚è¿™æ¡è¾¹æ ‡è®°ä¸ºâ€œ**true**â€ï¼Œè¡¨ç¤ºå¦‚æœ*a*å¤§äº*b*ï¼Œåˆ™æµç¨‹æµå‘æ­¤èŠ‚ç‚¹ã€‚
- en: On the false branch (right side), there is a node labeled â€œ**Return** **b**â€,
    connected by an edge from the â€œ**a > b**â€ node. This edge is labeled â€œ**false**â€,
    indicating that if *a* is not greater than *b*, the flow goes to this node.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å‡åˆ†æ”¯ï¼ˆå³ä¾§ï¼‰ï¼Œæœ‰ä¸€ä¸ªæ ‡è®°ä¸ºâ€œ**è¿”å›** **b**â€çš„èŠ‚ç‚¹ï¼Œé€šè¿‡ä»â€œ**a > b**â€èŠ‚ç‚¹çš„è¾¹è¿æ¥ã€‚è¿™æ¡è¾¹æ ‡è®°ä¸ºâ€œ**false**â€ï¼Œè¡¨ç¤ºå¦‚æœ*a*ä¸å¤§äº*b*ï¼Œåˆ™æµç¨‹æµå‘æ­¤èŠ‚ç‚¹ã€‚
- en: '**Exit node**: Below both the â€œ**Return a**â€ and â€œ**Return b**â€ nodes, converging
    at a point, there is an â€œ**exit**â€ node. This represents the termination point
    of the function, where the control flow exits the function after returning either
    *a* or *b*.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å‡ºå£èŠ‚ç‚¹**ï¼šåœ¨â€œ**Return a**â€å’Œâ€œ**Return b**â€èŠ‚ç‚¹ä¸‹æ–¹ï¼Œæ±‡èšäºä¸€ç‚¹ï¼Œæœ‰ä¸€ä¸ªâ€œ**exit**â€èŠ‚ç‚¹ã€‚è¿™è¡¨ç¤ºå‡½æ•°çš„ç»ˆæ­¢ç‚¹ï¼Œåœ¨è¿”å›*a*æˆ–*b*åï¼Œæ§åˆ¶æµé€€å‡ºå‡½æ•°ã€‚'
- en: This CFG effectively illustrates how the `max` function processes input and
    reaches a decision on which value to return based on the comparison.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤CFGæœ‰æ•ˆåœ°è¯´æ˜äº†`max`å‡½æ•°å¦‚ä½•å¤„ç†è¾“å…¥å¹¶åŸºäºæ¯”è¾ƒå†³å®šè¿”å›å“ªä¸ªå€¼ã€‚
- en: 'The CFG representation can also be used to estimate function complexity. In
    brief, a more complex picture corresponds to a more complex system. We will use
    a precise definition of complexity known as cyclomatic complexity, or M [[28](B19722_Bib.xhtml#XMcCabe1976)],
    which can be calculated as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: CFGè¡¨ç¤ºä¹Ÿå¯ä»¥ç”¨æ¥ä¼°è®¡å‡½æ•°çš„å¤æ‚åº¦ã€‚ç®€è€Œè¨€ä¹‹ï¼Œæ›´å¤æ‚çš„å›¾åƒå¯¹åº”æ›´å¤æ‚çš„ç³»ç»Ÿã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªç§°ä¸ºå¾ªç¯å¤æ‚åº¦çš„ç²¾ç¡®å¤æ‚åº¦å®šä¹‰ï¼Œæˆ–M [[28](B19722_Bib.xhtml#XMcCabe1976)]ï¼Œå…¶è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š
- en: '| *M = E - N + 2P* |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| *M = E - N + 2P* |  |'
- en: 'where:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ï¼š
- en: E is the number of edges in the graph
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E æ˜¯å›¾ä¸­è¾¹çš„æ•°é‡
- en: N is the number of nodes in the graph
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: N æ˜¯å›¾ä¸­èŠ‚ç‚¹çš„æ•°é‡
- en: P is the number of connected components (for a single CFG, P is usually 1)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P æ˜¯è¿é€šåˆ†é‡çš„æ•°é‡ï¼ˆå¯¹äºå•ä¸ªCFGï¼ŒPé€šå¸¸ä¸º1ï¼‰
- en: 'For the `max` function discussed earlier, the CFG can be analyzed as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå‰é¢è®¨è®ºçš„`max`å‡½æ•°ï¼ŒCFGå¯ä»¥åˆ†æå¦‚ä¸‹ï¼š
- en: '**Nodes (N)**: There are five nodes (Entry, *a > b*, Return *a*, *b*, Exit)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**èŠ‚ç‚¹ (N)**: æœ‰äº”ä¸ªèŠ‚ç‚¹ï¼ˆå…¥å£ï¼Œ*a > b*ï¼Œè¿”å›*a*ï¼Œ*b*ï¼Œå‡ºå£ï¼‰'
- en: '**Edges (E)**: There are five edges (from Entry to *a > b*, from *a > b* to
    Return *a*, from *a > b* to Return *b*, from Return *a* to Exit, and from Return
    *b* to Exit)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è¾¹ (E)**: æœ‰äº”æ¡è¾¹ï¼ˆä»å…¥å£åˆ°*a > b*ï¼Œä»*a > b*åˆ°è¿”å›*a*ï¼Œä»*a > b*åˆ°è¿”å›*b*ï¼Œä»è¿”å›*a*åˆ°å‡ºå£ï¼Œä»¥åŠä»è¿”å›*b*åˆ°å‡ºå£ï¼‰'
- en: '**Connected components (P)**: As itâ€™s a single function, *P* = 1'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è¿é€šåˆ†é‡ (P)**: ç”±äºå®ƒæ˜¯ä¸€ä¸ªå•ä¸€å‡½æ•°ï¼Œ*P* = 1'
- en: 'Substituting these values into the formula, we get the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™äº›å€¼ä»£å…¥å…¬å¼ï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹ç»“æœï¼š
- en: ğ‘€ = 5 âˆ’ 5 + 2 Ã— 1 = 2
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ğ‘€ = 5 âˆ’ 5 + 2 Ã— 1 = 2
- en: Thus, the cyclomatic complexity of the `max` function, based on the given CFG,
    is 2\. This indicates that there are two linearly independent paths through the
    code, corresponding to the two branches of the if statement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒåŸºäºç»™å®šçš„CFGï¼Œ`max`å‡½æ•°çš„å¾ªç¯å¤æ‚åº¦ä¸º2ã€‚è¿™è¡¨æ˜ä»£ç ä¸­æœ‰ä¸¤æ¡çº¿æ€§ç‹¬ç«‹çš„è·¯å¾„ï¼Œå¯¹åº”äºifè¯­å¥çš„ä¸¤ä¸ªåˆ†æ”¯ã€‚
- en: Our next step will be to create a Clang-Tidy check that uses a CFG to calculate
    cyclomatic complexity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ä¸‹ä¸€æ­¥å°†æ˜¯åˆ›å»ºä¸€ä¸ªä½¿ç”¨CFGæ¥è®¡ç®—å¾ªç¯å¤æ‚åº¦çš„Clang-Tidyæ£€æŸ¥ã€‚
- en: 6.4 Custom CFG check
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 è‡ªå®šä¹‰CFGæ£€æŸ¥
- en: We are going to use the knowledge gained in [*Section**Â 5.4*](B19722_05.xhtml#x1-1090004)*,
    Custom Clang-Tidy* *check* to create a custom CFG check. As mentioned previously,
    the check will use Clangâ€™s CFG to calculate cyclomatic complexity. The check should
    issue a warning if the calculated complexity exceeds a threshold. This threshold
    will be set up as a configuration parameter, allowing us to change it during our
    tests. Letâ€™s start with the creation of the project skeleton.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨åœ¨[*ç¬¬5.4èŠ‚**](B19722_05.xhtml#x1-1090004)*ä¸­è·å¾—çš„å…³äºè‡ªå®šä¹‰Clang-Tidyæ£€æŸ¥çš„çŸ¥è¯†æ¥åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰CFGæ£€æŸ¥ã€‚å¦‚å‰æ‰€è¿°ï¼Œè¯¥æ£€æŸ¥å°†ä½¿ç”¨Clangçš„CFGæ¥è®¡ç®—å¾ªç¯å¤æ‚åº¦ã€‚å¦‚æœè®¡ç®—å‡ºçš„å¤æ‚åº¦è¶…è¿‡é˜ˆå€¼ï¼Œåˆ™æ£€æŸ¥åº”å‘å‡ºè­¦å‘Šã€‚æ­¤é˜ˆå€¼å°†ä½œä¸ºé…ç½®å‚æ•°è®¾ç½®ï¼Œå…è®¸æˆ‘ä»¬åœ¨æµ‹è¯•æœŸé—´æ›´æ”¹å®ƒã€‚è®©æˆ‘ä»¬ä»åˆ›å»ºé¡¹ç›®éª¨æ¶å¼€å§‹ã€‚
- en: 6.4.1 Creating the project skeleton
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 åˆ›å»ºé¡¹ç›®éª¨æ¶
- en: 'We will use `cyclomaticcomplexity` as the name for our check, and our project
    skeleton can be created as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨`cyclomaticcomplexity`ä½œä¸ºæ£€æŸ¥çš„åç§°ï¼Œæˆ‘ä»¬çš„é¡¹ç›®éª¨æ¶å¯ä»¥åˆ›å»ºå¦‚ä¸‹ï¼š
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**FigureÂ 6.3**: Creating a skeleton for the misc-cyclomaticcomplexity check'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.3**ï¼šä¸ºmisc-cyclomaticcomplexityæ£€æŸ¥åˆ›å»ºéª¨æ¶'
- en: 'As a result of the run, we will get a number of modified and new files. The
    most important ones for us are the following two files located in the `clang-tools-extra/clang-tidy/misc/`
    folder:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: è¿è¡Œç»“æœå°†ç”Ÿæˆå¤šä¸ªä¿®æ”¹åçš„æ–°æ–‡ä»¶ã€‚å¯¹æˆ‘ä»¬æ¥è¯´ï¼Œæœ€é‡è¦çš„æ˜¯ä½äº`clang-tools-extra/clang-tidy/misc/`æ–‡ä»¶å¤¹ä¸­çš„ä»¥ä¸‹ä¸¤ä¸ªæ–‡ä»¶ï¼š
- en: '`misc/CyclomaticcomplexityCheck.h` : This is the header file for our check'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`misc/CyclomaticcomplexityCheck.h`ï¼šè¿™æ˜¯æˆ‘ä»¬çš„æ£€æŸ¥çš„å¤´æ–‡ä»¶'
- en: '`misc/CyclomaticcomplexityCheck.cpp` : This file will house the implementation
    of our check'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`misc/CyclomaticcomplexityCheck.cpp`ï¼šæ­¤æ–‡ä»¶å°†åŒ…å«æˆ‘ä»¬çš„æ£€æŸ¥å®ç°'
- en: These files need to be modified to achieve the required functionality for the
    check.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ–‡ä»¶éœ€è¦ä¿®æ”¹ä»¥è¾¾åˆ°æ£€æŸ¥æ‰€éœ€çš„å‡½æ•°ã€‚
- en: 6.4.2 Check implementation
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 æ£€æŸ¥å®ç°
- en: 'For the header file, we aim to add a private function to calculate the cyclomatic
    complexity. Specifically, the following code needs to be inserted:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå¤´æ–‡ä»¶ï¼Œæˆ‘ä»¬æ—¨åœ¨æ·»åŠ ä¸€ä¸ªç”¨äºè®¡ç®—å¾ªç¯å¤æ‚åº¦çš„ç§æœ‰å‡½æ•°ã€‚å…·ä½“æ¥è¯´ï¼Œéœ€è¦æ’å…¥ä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**FigureÂ 6.4**: Modifications to CyclomaticcomplexityCheck.h'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.4**ï¼šå¯¹CyclomaticcomplexityCheck.hçš„ä¿®æ”¹'
- en: 'More substantial modifications are required in the `.cpp` file. We will begin
    with the implementation of the `registerMatchers` method, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`.cpp`æ–‡ä»¶ä¸­éœ€è¦æ›´å¤šçš„å®è´¨æ€§ä¿®æ”¹ã€‚æˆ‘ä»¬å°†ä»`registerMatchers`æ–¹æ³•çš„å®ç°å¼€å§‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**FigureÂ 6.5**: Modifications to CyclomaticcomplexityCheck.cpp: registerMatchers
    implementation'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.5**ï¼šå¯¹CyclomaticcomplexityCheck.cppçš„ä¿®æ”¹ï¼šregisterMatcherså®ç°'
- en: Based on the code, our check will be applied only to function declarations,
    `clang``::``FunctionDecl`. The code can also be extended to support other C++
    constructs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®ä»£ç ï¼Œæˆ‘ä»¬çš„æ£€æŸ¥å°†ä»…åº”ç”¨äºå‡½æ•°å£°æ˜ï¼Œå³`clang::FunctionDecl`ã€‚ä»£ç ä¹Ÿå¯ä»¥æ‰©å±•ä»¥æ”¯æŒå…¶ä»–C++ç»“æ„ã€‚
- en: The implementation of the `check` method is presented in [FigureÂ 6.6](#x1-123030r6).
    At *Lines 22-23*, we perform basic checks on the matched AST node, `clang``::``FunctionDecl`
    in our case. At *Lines 25-26*, we create the CFG object using the `CFG``::``buildCFG`
    method. The first two parameters specify the declaration (`clang``::``Decl`) and
    the statement for the declaration (`clang``::``Stmt`). At *Line 30*, we calculate
    the cyclomatic complexity using the threshold, which can be obtained as the `"``Threshold``"`
    option of our check. This provides flexibility in testing for different input
    programs. *Lines 31-34* contain the implementation of the check result printout.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`check`æ–¹æ³•çš„å®ç°å¦‚[å›¾6.6](#x1-123030r6)æ‰€ç¤ºã€‚åœ¨*ç¬¬22-23è¡Œ*ï¼Œæˆ‘ä»¬å¯¹åŒ¹é…çš„ASTèŠ‚ç‚¹è¿›è¡ŒåŸºæœ¬æ£€æŸ¥ï¼Œåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­æ˜¯`clang::FunctionDecl`ã€‚åœ¨*ç¬¬25-26è¡Œ*ï¼Œæˆ‘ä»¬ä½¿ç”¨`CFG::buildCFG`æ–¹æ³•åˆ›å»ºCFGå¯¹è±¡ã€‚å‰ä¸¤ä¸ªå‚æ•°æŒ‡å®šäº†å£°æ˜ï¼ˆ`clang::Decl`ï¼‰å’Œå£°æ˜çš„è¯­å¥ï¼ˆ`clang::Stmt`ï¼‰ã€‚åœ¨*ç¬¬30è¡Œ*ï¼Œæˆ‘ä»¬ä½¿ç”¨é˜ˆå€¼è®¡ç®—å¾ªç¯å¤æ‚åº¦ï¼Œè¯¥é˜ˆå€¼å¯ä»¥ä½œä¸ºæˆ‘ä»¬æ£€æŸ¥çš„`"Threshold"`é€‰é¡¹è·å¾—ã€‚è¿™ä¸ºæµ‹è¯•ä¸åŒçš„è¾“å…¥ç¨‹åºæä¾›äº†çµæ´»æ€§ã€‚*ç¬¬31-34è¡Œ*åŒ…å«äº†æ£€æŸ¥ç»“æœæ‰“å°çš„å®ç°ã€‚'
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**FigureÂ 6.6**: Modifications to CyclomaticcomplexityCheck.cpp: check implementation'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.6**ï¼šå¯¹CyclomaticcomplexityCheck.cppçš„ä¿®æ”¹ï¼šæ£€æŸ¥å®ç°'
- en: 'The `calculateCyclomaticComplexity` method is used to calculate the cyclomatic
    complexity. It takes the created `clang``::``CFG` object as an input parameter.
    The implementation is shown in the following figure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateCyclomaticComplexity`æ–¹æ³•ç”¨äºè®¡ç®—å¾ªç¯å¤æ‚åº¦ã€‚å®ƒæ¥å—åˆ›å»ºçš„`clang::CFG`å¯¹è±¡ä½œä¸ºè¾“å…¥å‚æ•°ã€‚å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**FigureÂ 6.7**: Modifications to CyclomaticcomplexityCheck.cpp: calculateCyclomaticComplexity
    implementation'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.7**ï¼šå¯¹CyclomaticcomplexityCheck.cppçš„ä¿®æ”¹ï¼šcalculateCyclomaticComplexityå®ç°'
- en: We iterate over all CFG blocks at *Lines 42-45*. The number of blocks corresponds
    to the number of nodes, denoted as N in [FigureÂ 6.2](#x1-120014r3). We sum up
    the number of successors for each block to calculate the number of edges, denoted
    as E. We assume that the number of connected components, denoted as P, is equal
    to one for our simplified example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨ç¬¬42-45è¡Œè¿­ä»£æ‰€æœ‰CFGå—ã€‚å—çš„æ•°é‡å¯¹åº”äºèŠ‚ç‚¹æ•°ï¼Œåœ¨[å›¾6.2](#x1-120014r3)ä¸­ç”¨Nè¡¨ç¤ºã€‚æˆ‘ä»¬è®¡ç®—æ¯ä¸ªå—çš„åç»­èŠ‚ç‚¹æ•°ä¹‹å’Œï¼Œä»¥è®¡ç®—è¾¹çš„æ•°é‡ï¼Œç”¨Eè¡¨ç¤ºã€‚æˆ‘ä»¬å‡è®¾å¯¹äºæˆ‘ä»¬çš„ç®€åŒ–ç¤ºä¾‹ï¼Œè¿æ¥ç»„ä»¶çš„æ•°é‡ï¼Œç”¨Pè¡¨ç¤ºï¼Œç­‰äºä¸€ä¸ªã€‚
- en: After implementing the check, itâ€™s time to build and run our new check on our
    example; see [FigureÂ 6.1](#x1-120012r1).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®ç°æ£€æŸ¥åï¼Œæ˜¯æ—¶å€™æ„å»ºå¹¶åœ¨æˆ‘ä»¬çš„ç¤ºä¾‹ä¸Šè¿è¡Œæˆ‘ä»¬çš„æ–°æ£€æŸ¥äº†ï¼›å‚è§[å›¾6.1](#x1-120012r1)ã€‚
- en: 6.4.3 Building and testing the cyclomatic complexity check
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 æ„å»ºå’Œæµ‹è¯•å¾ªç¯å¤æ‚åº¦æ£€æŸ¥
- en: 'We will use the basic build configuration specified in [FigureÂ 1.4](B19722_01.xhtml#x1-27004r4)
    and build Clang-Tidy using the standard command from [FigureÂ 5.2](B19722_05.xhtml#x1-102004r2):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨[å›¾1.4](B19722_01.xhtml#x1-27004r4)ä¸­æŒ‡å®šçš„åŸºæœ¬æ„å»ºé…ç½®ï¼Œå¹¶ä½¿ç”¨[å›¾5.2](B19722_05.xhtml#x1-102004r2)ä¸­çš„æ ‡å‡†å‘½ä»¤æ„å»ºClang-Tidyï¼š
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Assuming the build configuration from [FigureÂ 1.4](B19722_01.xhtml#x1-27004r4),
    this command will install the Clang-Tidy binary in the `<...>/llvm-project/install/bin`
    folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä»[å›¾1.4](B19722_01.xhtml#x1-27004r4)çš„æ„å»ºé…ç½®ï¼Œæ­¤å‘½ä»¤å°†Clang-TidyäºŒè¿›åˆ¶æ–‡ä»¶å®‰è£…åˆ°`<...>/llvm-project/install/bin`æ–‡ä»¶å¤¹ä¸­ã€‚
- en: Important note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦æç¤º
- en: If you use a build configuration with shared libraries (with the `BUILD``_SHARED``_LIBS`
    flag set to `ON` ), as shown in [FigureÂ 1.12](B19722_01.xhtml#x1-30003r12), then
    you might need to install and built all artifacts with `ninja` `install` .
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä½¿ç”¨å¸¦æœ‰å…±äº«åº“çš„æ„å»ºé…ç½®ï¼ˆå°†`BUILD_SHARED_LIBS`æ ‡å¿—è®¾ç½®ä¸º`ON`ï¼‰ï¼Œå¦‚[å›¾1.12](B19722_01.xhtml#x1-30003r12)æ‰€ç¤ºï¼Œé‚£ä¹ˆä½ å¯èƒ½éœ€è¦ä½¿ç”¨`ninja
    install`å®‰è£…å’Œæ„å»ºæ‰€æœ‰å·¥ä»¶ã€‚
- en: 'We will run our check on the example program shown in [FigureÂ 6.1](#x1-120012r1).
    As we previously calculated, the cyclomatic complexity for the test is 2, which
    is lower than the default value of 5 specified at *Line 29* in our `check` method
    implementation, as seen in [FigureÂ 6.6](#x1-123030r6). Thus, we need to override
    the default value to 1 to be able to see a warning in our test program. This can
    be done using the `-config` option, which we previously used for `classchecker`
    check tests, as shown in [FigureÂ 5.20](B19722_05.xhtml#x1-111061r20). The command
    for the test will look as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†åœ¨[å›¾6.1](#x1-120012r1)ä¸­æ˜¾ç¤ºçš„ç¤ºä¾‹ç¨‹åºä¸Šè¿è¡Œæˆ‘ä»¬çš„æ£€æŸ¥ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰è®¡ç®—çš„ï¼Œæµ‹è¯•çš„å¾ªç¯å¤æ‚åº¦ä¸º2ï¼Œä½äºæˆ‘ä»¬åœ¨`check`æ–¹æ³•å®ç°ä¸­æŒ‡å®šçš„é»˜è®¤å€¼5ï¼Œå¦‚[å›¾6.6](#x1-123030r6)æ‰€ç¤ºã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å°†é»˜è®¤å€¼é‡å†™ä¸º1ï¼Œä»¥ä¾¿åœ¨æµ‹è¯•ç¨‹åºä¸­çœ‹åˆ°è­¦å‘Šã€‚è¿™å¯ä»¥é€šè¿‡ä½¿ç”¨æˆ‘ä»¬ä¹‹å‰ç”¨äº`classchecker`æ£€æŸ¥æµ‹è¯•çš„`-config`é€‰é¡¹æ¥å®Œæˆï¼Œå¦‚[å›¾5.20](B19722_05.xhtml#x1-111061r20)æ‰€ç¤ºã€‚æµ‹è¯•å‘½ä»¤å¦‚ä¸‹ï¼š
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**FigureÂ 6.8**: Testing cyclomatic complexity on the max.cpp example'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.8**ï¼šåœ¨max.cppç¤ºä¾‹ä¸Šæµ‹è¯•å¾ªç¯å¤æ‚åº¦'
- en: '*Line 2* in [FigureÂ 6.8](#x1-124011r8) indicates that we want to run only one
    Clang-Tidy check: `misc-cyclomaticcomplexity` . At *lines 3-4*, we set up the
    required threshold. *Line 5* specifies the name of the file being tested (`max.cpp`
    in our case), and the final line, *Line 6*, contains some compilation flags for
    our program.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾6.8](#x1-124011r8)ä¸­çš„*ç¬¬2è¡Œ*è¡¨æ˜æˆ‘ä»¬åªæƒ³è¿è¡Œä¸€ä¸ªClang-Tidyæ£€æŸ¥ï¼š`misc-cyclomaticcomplexity`ã€‚åœ¨*ç¬¬3-4è¡Œ*ä¸­ï¼Œæˆ‘ä»¬è®¾ç½®äº†æ‰€éœ€çš„é˜ˆå€¼ã€‚*ç¬¬5è¡Œ*æŒ‡å®šäº†æ­£åœ¨æµ‹è¯•çš„æ–‡ä»¶åï¼ˆåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­æ˜¯`max.cpp`ï¼‰ï¼Œè€Œæœ€åä¸€è¡Œï¼Œ*ç¬¬6è¡Œ*åŒ…å«äº†æˆ‘ä»¬ç¨‹åºçš„æŸäº›ç¼–è¯‘æ ‡å¿—ã€‚'
- en: 'We will get the following output if we run the command from [FigureÂ 6.8](#x1-124011r8):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¿è¡Œ[å›¾6.8](#x1-124011r8)ä¸­çš„å‘½ä»¤ï¼Œå°†ä¼šå¾—åˆ°ä»¥ä¸‹è¾“å‡ºï¼š
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**FigureÂ 6.9**: Testing cyclomatic complexity on the max.cpp example: output'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.9**ï¼šåœ¨max.cppç¤ºä¾‹ä¸Šæµ‹è¯•å¾ªç¯å¤æ‚åº¦ï¼šè¾“å‡º'
- en: 'The following question might arise: How does Clang build the CFG? We can use
    a debugger to investigate the process.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: å¯èƒ½ä¼šæå‡ºä»¥ä¸‹é—®é¢˜ï¼šClangæ˜¯å¦‚ä½•æ„å»ºCFGçš„ï¼Ÿæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è°ƒè¯•å™¨æ¥è°ƒæŸ¥è¿™ä¸ªè¿‡ç¨‹ã€‚
- en: 6.5 CFG on Clang
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 Clangä¸Šçš„CFG
- en: A CFG is the basic data structure for advanced static analysis using Clang tools.
    Clang constructs the CFG for a function from its AST, identifying basic blocks
    and control flow edges. Clangâ€™s CFG construction handles various C/C++ constructs,
    including loops, conditional statements, switch cases, and complex constructs
    such as `setjmp/longjmp` and C++ exceptions. Letâ€™s consider the process using
    our example from [FigureÂ 6.1](#x1-120012r1).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CFGæ˜¯ä½¿ç”¨Clangå·¥å…·è¿›è¡Œé«˜çº§é™æ€åˆ†æçš„åŸºæœ¬æ•°æ®ç»“æ„ã€‚Clangä»å‡½æ•°çš„ASTï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰æ„å»ºCFGï¼Œè¯†åˆ«åŸºæœ¬å—å’Œæ§åˆ¶æµè¾¹ã€‚Clangçš„CFGæ„å»ºå¤„ç†å„ç§C/C++ç»“æ„ï¼ŒåŒ…æ‹¬å¾ªç¯ã€æ¡ä»¶è¯­å¥ã€switchæƒ…å†µä»¥åŠå¦‚`setjmp/longjmp`å’ŒC++å¼‚å¸¸ç­‰å¤æ‚ç»“æ„ã€‚è®©æˆ‘ä»¬ä½¿ç”¨[å›¾6.1](#x1-120012r1)ä¸­çš„ç¤ºä¾‹æ¥è€ƒè™‘è¿™ä¸ªè¿‡ç¨‹ã€‚
- en: 6.5.1 CFG construction by example
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 é€šè¿‡ç¤ºä¾‹è¿›è¡ŒCFGæ„å»º
- en: 'Our example from [FigureÂ 6.1](#x1-120012r1) has five nodes, as shown in [FigureÂ 6.2](#Figure6.2).
    Lets run a debugger to investigate the process, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨[å›¾6.1](#x1-120012r1)ä¸­çš„ç¤ºä¾‹æœ‰äº”ä¸ªèŠ‚ç‚¹ï¼Œå¦‚å›¾[å›¾6.2](#Figure6.2)æ‰€ç¤ºã€‚è®©æˆ‘ä»¬è¿è¡Œä¸€ä¸ªè°ƒè¯•å™¨æ¥è°ƒæŸ¥è¿™ä¸ªè¿‡ç¨‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**FigureÂ 6.10**: Debugger session running to investigate the CFG creation process'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.10**: è¿è¡Œä»¥è°ƒæŸ¥CFGåˆ›å»ºè¿‡ç¨‹çš„è°ƒè¯•å™¨ä¼šè¯'
- en: We used the same command as in [FigureÂ 6.8](#x1-124011r8) but changed the first
    line of the command to run the check via a debugger. We also changed the last
    line to suppress all warnings from the compiler.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨äº†ä¸[å›¾6.8](#x1-124011r8)ä¸­ç›¸åŒçš„å‘½ä»¤ï¼Œä½†å°†å‘½ä»¤çš„ç¬¬ä¸€è¡Œæ”¹ä¸ºé€šè¿‡è°ƒè¯•å™¨è¿è¡Œæ£€æŸ¥ã€‚æˆ‘ä»¬è¿˜æ”¹å˜äº†æœ€åä¸€è¡Œä»¥æŠ‘åˆ¶ç¼–è¯‘å™¨çš„æ‰€æœ‰è­¦å‘Šã€‚
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦æç¤º
- en: Advanced static analysis is a part of semantic analysis. For example, warnings
    are printed if Clang detects unreachable code, controlled by the `-Wunreachable-code`
    option. The detector is a part of Clangâ€™s semantic analysis and utilizes CFGs,
    in addition to ASTs, as the basic data structures to detect such issues. We can
    suppress these warnings and, as a result, disable CFG initialization in Clang
    by specifying the special `-Wno-all` command-line option, which suppresses all
    warnings generated by the compiler.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: é«˜çº§é™æ€åˆ†ææ˜¯è¯­ä¹‰åˆ†æçš„ä¸€éƒ¨åˆ†ã€‚ä¾‹å¦‚ï¼Œå¦‚æœClangæ£€æµ‹åˆ°ä¸å¯è¾¾çš„ä»£ç ï¼Œå°†ä¼šæ‰“å°è­¦å‘Šï¼Œç”±`-Wunreachable-code`é€‰é¡¹æ§åˆ¶ã€‚æ£€æµ‹å™¨æ˜¯Clangè¯­ä¹‰åˆ†æçš„ä¸€éƒ¨åˆ†ï¼Œå¹¶åˆ©ç”¨CFGsï¼ˆæ§åˆ¶æµå›¾ï¼‰ä»¥åŠASTsï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰ä½œä¸ºåŸºæœ¬æ•°æ®ç»“æ„æ¥æ£€æµ‹æ­¤ç±»é—®é¢˜ã€‚æˆ‘ä»¬å¯ä»¥æŠ‘åˆ¶è¿™äº›è­¦å‘Šï¼Œå¹¶å› æ­¤é€šè¿‡æŒ‡å®šç‰¹æ®Šçš„`-Wno-all`å‘½ä»¤è¡Œé€‰é¡¹æ¥ç¦ç”¨Clangä¸­çš„CFGåˆå§‹åŒ–ï¼Œè¯¥é€‰é¡¹æŠ‘åˆ¶ç¼–è¯‘å™¨ç”Ÿæˆçš„æ‰€æœ‰è­¦å‘Šã€‚
- en: We will set a breakpoint at the `CFGBuilder``::``createBlock` function, which
    creates a CFG block.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†åœ¨`CFGBuilder::createBlock`å‡½æ•°ä¸Šè®¾ç½®æ–­ç‚¹ï¼Œè¯¥å‡½æ•°åˆ›å»ºCFGå—ã€‚
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**FigureÂ 6.11**: Running debugger and setting breakpoint for CFGBuilder::createBlock'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.11**: è¿è¡Œè°ƒè¯•å™¨å¹¶è®¾ç½®CFGBuilder::createBlockçš„æ–­ç‚¹'
- en: 'If we run the debugger, we will see that the function is called five times
    for our example; that is, five CFG blocks are created for our `max` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¿è¡Œè°ƒè¯•å™¨ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°æˆ‘ä»¬çš„ç¤ºä¾‹å‡½æ•°è¢«è°ƒç”¨äº†äº”æ¬¡ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸ºæˆ‘ä»¬çš„`max`å‡½æ•°åˆ›å»ºäº†äº”ä¸ªCFGå—ï¼š
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**FigureÂ 6.12**: Creation of CFG blocks, with breakpoints highlighted'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.12**: åˆ›å»ºCFGå—ï¼Œçªå‡ºæ˜¾ç¤ºæ–­ç‚¹'
- en: The debugger session shown in [FigureÂ 6.12](#x1-126049r12) can be considered
    the entry point to the CFG creation process. Now, itâ€™s time to delve deeply into
    the implementation details.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚[å›¾6.12](#x1-126049r12)ä¸­æ‰€ç¤ºçš„è°ƒè¯•å™¨ä¼šè¯å¯ä»¥è¢«è®¤ä¸ºæ˜¯CFGåˆ›å»ºè¿‡ç¨‹çš„å…¥å£ç‚¹ã€‚ç°åœ¨ï¼Œæ˜¯æ—¶å€™æ·±å…¥æ¢è®¨å®ç°ç»†èŠ‚äº†ã€‚
- en: 6.5.2 CFG construction implementation details
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 CFGæ„å»ºå®ç°ç»†èŠ‚
- en: 'The blocks are created in reverse order, as seen in [FigureÂ 6.13](#x1-127017r13).
    The first block to be created is the exit block, as shown in [FigureÂ 6.13](#x1-127017r13),
    *Line 4*. Then, the CFG builder traverses the `clang``::``Stmt` object passed
    as a parameter (*Line 9*). The entry block is created last, at *Line 12*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: å—æ˜¯æŒ‰ç›¸åçš„é¡ºåºåˆ›å»ºçš„ï¼Œå¦‚å›¾[å›¾6.13](#x1-127017r13)æ‰€ç¤ºã€‚é¦–å…ˆåˆ›å»ºçš„æ˜¯é€€å‡ºå—ï¼Œå¦‚å›¾[å›¾6.13](#x1-127017r13)æ‰€ç¤ºï¼Œ*ç¬¬4è¡Œ*ã€‚ç„¶åï¼ŒCFGæ„å»ºå™¨éå†ä½œä¸ºå‚æ•°ä¼ é€’çš„`clang::Stmt`å¯¹è±¡ï¼ˆ*ç¬¬9è¡Œ*ï¼‰ã€‚å…¥å£å—æœ€ååˆ›å»ºï¼Œåœ¨*ç¬¬12è¡Œ*ï¼š
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**FigureÂ 6.13**: Simplified buildCFG implementation from clang/lib/Analysis/CFG.cpp'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.13**: ä»clang/lib/Analysis/CFG.cppä¸­æå–çš„ç®€åŒ–buildCFGå®ç°'
- en: 'The visitor uses the `clang``::``Stmt``::``getStmtClass` method to implement
    an ad hoc visitor based on the type of the statement, as shown in the following
    code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: è®¿é—®è€…ä½¿ç”¨`clang::Stmt::getStmtClass`æ–¹æ³•æ ¹æ®è¯­å¥çš„ç±»å‹å®ç°ä¸€ä¸ªä¸´æ—¶çš„è®¿é—®è€…ï¼Œå¦‚ä¸‹é¢çš„ä»£ç ç‰‡æ®µæ‰€ç¤ºï¼š
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**FigureÂ 6.14**: Statement visitor implementation; the cases used for our example
    are highlighted, the code was taken from clang/lib/Analysis/CFG.cpp'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.14**: çŠ¶æ€è®¿é—®è€…å®ç°ï¼›ç”¨äºæˆ‘ä»¬ç¤ºä¾‹çš„æƒ…å†µè¢«çªå‡ºæ˜¾ç¤ºï¼Œä»£ç å–è‡ªclang/lib/Analysis/CFG.cpp'
- en: Our example includes two return statements and one `if` statement, which are
    combined into a compound statement. The relevant parts of the visitor are shown
    in [FigureÂ 6.14](#x1-127035r14).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ä¾‹å­åŒ…æ‹¬ä¸¤ä¸ªè¿”å›è¯­å¥å’Œä¸€ä¸ª`if`è¯­å¥ï¼Œå®ƒä»¬è¢«ç»„åˆæˆä¸€ä¸ªå¤åˆè¯­å¥ã€‚è®¿é—®è€…çš„ç›¸å…³éƒ¨åˆ†åœ¨[å›¾6.14](#x1-127035r14)ä¸­æ˜¾ç¤ºã€‚
- en: 'In our case, the passed statement is a compound statement; therefore, *Line
    6* from [FigureÂ 6.14](#x1-127035r14) is activated. The following code is then
    executed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œä¼ é€’çš„è¯­å¥æ˜¯ä¸€ä¸ªå¤åˆè¯­å¥ï¼›å› æ­¤ï¼Œ[å›¾6.14](#x1-127035r14)ä¸­çš„ç¬¬6è¡Œè¢«æ¿€æ´»ã€‚ç„¶åæ‰§è¡Œä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**FigureÂ 6.15**: Compound statement visitor, the code was taken from clang/lib/Analysis/CFG.cpp'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.15**ï¼šå¤åˆè¯­å¥è®¿é—®è€…ï¼Œä»£ç æ¥è‡ªclang/lib/Analysis/CFG.cpp'
- en: 'Several constructions are visited while the CFG is being created for our example.
    The first one is `clang``::``IfStmt`. The relevant parts are shown in the following
    figure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸ºæˆ‘ä»¬çš„ä¾‹å­åˆ›å»ºCFGæ—¶ï¼Œè®¿é—®äº†å‡ ä¸ªæ„é€ ã€‚ç¬¬ä¸€ä¸ªæ˜¯`clang::IfStmt`ã€‚ç›¸å…³éƒ¨åˆ†åœ¨ä»¥ä¸‹å›¾ä¸­æ˜¾ç¤ºï¼š
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**FigureÂ 6.16**: If statement visitor, the code was taken from clang/lib/Analysis/CFG.cpp'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.16**ï¼š`if`è¯­å¥è®¿é—®è€…ï¼Œä»£ç æ¥è‡ªclang/lib/Analysis/CFG.cpp'
- en: A special block for the `if` statement is created at *Line 18*. We also visit
    the â€™thenâ€™ condition at *Line 8*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¬¬18è¡Œåˆ›å»ºäº†ä¸€ä¸ªç‰¹æ®Šçš„`if`è¯­å¥å—ã€‚æˆ‘ä»¬è¿˜è®¿é—®äº†ç¬¬8è¡Œçš„`then`æ¡ä»¶ã€‚
- en: 'The â€™thenâ€™ condition leads to visiting a return statement. The corresponding
    code is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`then`æ¡ä»¶å¯¼è‡´è®¿é—®è¿”å›è¯­å¥ã€‚ç›¸åº”çš„ä»£ç å¦‚ä¸‹ï¼š'
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**FigureÂ 6.17**: Return statement visitor, the code was taken from clang/lib/Analysis/CFG.cpp'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**å›¾6.17**ï¼šè¿”å›è¯­å¥è®¿é—®è€…ï¼Œä»£ç æ¥è‡ªclang/lib/Analysis/CFG.cpp'
- en: For our example, it creates a block at *Line 3* and visits the return expression
    at *Line 8*. Our return expression is a trivial one that does not necessitate
    the creation of a new block.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæˆ‘ä»¬çš„ä¾‹å­ï¼Œå®ƒåœ¨ç¬¬3è¡Œåˆ›å»ºäº†ä¸€ä¸ªå—å¹¶è®¿é—®äº†ç¬¬8è¡Œçš„è¿”å›è¡¨è¾¾å¼ã€‚æˆ‘ä»¬çš„è¿”å›è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªç®€å•çš„è¡¨è¾¾å¼ï¼Œä¸éœ€è¦åˆ›å»ºæ–°çš„å—ã€‚
- en: 'The code fragments presented in [FigureÂ 6.13](#x1-127017r13) to [FigureÂ 6.17](#x1-127097r17)
    show only the block creation procedure. Some important parts were omitted for
    simplicity. Notably, the build procedure also involves the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[å›¾6.13](#x1-127017r13)åˆ°[å›¾6.17](#x1-127097r17)ä¸­å±•ç¤ºçš„ä»£ç ç‰‡æ®µä»…æ˜¾ç¤ºäº†å—åˆ›å»ºè¿‡ç¨‹ã€‚ä¸ºäº†ç®€åŒ–ï¼Œçœç•¥äº†ä¸€äº›é‡è¦éƒ¨åˆ†ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæ„å»ºè¿‡ç¨‹è¿˜æ¶‰åŠä»¥ä¸‹å†…å®¹ï¼š
- en: 'Edge creation: A typical block can have one or more successors. The list of
    nodes (blocks) with a list of successors (edges) for each block maintains the
    entire graph structure, representing symbolic program execution.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¾¹ç¼˜åˆ›å»ºï¼šä¸€ä¸ªå…¸å‹çš„å—å¯ä»¥æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªåç»§è€…ã€‚æ¯ä¸ªå—çš„èŠ‚ç‚¹ï¼ˆå—ï¼‰åˆ—è¡¨ä»¥åŠæ¯ä¸ªå—çš„åç»§è€…ï¼ˆè¾¹ï¼‰åˆ—è¡¨ç»´æŠ¤æ•´ä¸ªå›¾ç»“æ„ï¼Œè¡¨ç¤ºç¬¦å·ç¨‹åºæ‰§è¡Œã€‚
- en: 'Storing meta-information: Each block stores additional meta-information associated
    with it. For instance, each block keeps a list of statements in the block.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å­˜å‚¨å…ƒä¿¡æ¯ï¼šæ¯ä¸ªå—å­˜å‚¨ä¸å…¶ç›¸å…³çš„é™„åŠ å…ƒä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œæ¯ä¸ªå—ä¿ç•™è¯¥å—ä¸­è¯­å¥çš„åˆ—è¡¨ã€‚
- en: 'Processing edge cases: C++ is a complex language with many different language
    constructs that require special processing.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¤„ç†è¾¹ç¼˜æƒ…å†µï¼šC++æ˜¯ä¸€ç§å¤æ‚çš„è¯­è¨€ï¼Œå…·æœ‰è®¸å¤šä¸åŒçš„è¯­è¨€ç»“æ„ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†ã€‚
- en: The CFG is a fundamental data structure for advanced code analysis. Clang has
    several tools created using CFGs. Letâ€™s briefly look at them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: CFGæ˜¯é«˜çº§ä»£ç åˆ†æçš„åŸºæœ¬æ•°æ®ç»“æ„ã€‚Clangæœ‰å‡ ä¸ªä½¿ç”¨CFGåˆ›å»ºçš„å·¥å…·ã€‚è®©æˆ‘ä»¬ç®€è¦åœ°çœ‹çœ‹å®ƒä»¬ã€‚
- en: 6.6 Brief description of Clang analysis tools
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 Clangåˆ†æå·¥å…·ç®€è¦æè¿°
- en: 'As mentioned earlier, the CFG is foundational for other analysis tools in Clang,
    several of which have been created atop the CFG. These tools also employ advanced
    mathematics to analyze various cases. The most notable tools are as follows [[32](B19722_Bib.xhtml#XClangDataFlow2020)]:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚å‰æ‰€è¿°ï¼ŒCFGæ˜¯Clangä¸­å…¶ä»–åˆ†æå·¥å…·çš„åŸºç¡€ï¼Œå…¶ä¸­ä¸€äº›æ˜¯åœ¨CFGä¹‹ä¸Šåˆ›å»ºçš„ã€‚è¿™äº›å·¥å…·ä¹Ÿä½¿ç”¨é«˜çº§æ•°å­¦æ¥åˆ†æå„ç§æƒ…å†µã€‚æœ€æ˜¾è‘—çš„å·¥å…·å¦‚ä¸‹ [[32](B19722_Bib.xhtml#XClangDataFlow2020)]ï¼š
- en: 'LivenessAnalysis: Determines whether a computed value will be used before being
    overwritten, producing liveness sets for each statement and CFGBlock'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LivenessAnalysisï¼šç¡®å®šè®¡ç®—å€¼åœ¨è¦†ç›–ä¹‹å‰æ˜¯å¦ä¼šè¢«ä½¿ç”¨ï¼Œä¸ºæ¯ä¸ªè¯­å¥å’ŒCFGBlockç”Ÿæˆæ´»åŠ¨æ€§é›†
- en: 'UninitializedVariables: Identifies the use of uninitialized variables through
    multiple passes, including initial categorization of statements and subsequent
    calculation of variable usages'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœªåˆå§‹åŒ–å˜é‡ï¼šé€šè¿‡å¤šæ¬¡éå†è¯†åˆ«æœªåˆå§‹åŒ–å˜é‡çš„ä½¿ç”¨ï¼ŒåŒ…æ‹¬å¯¹è¯­å¥çš„åˆå§‹åˆ†ç±»å’Œåç»­çš„å˜é‡ä½¿ç”¨è®¡ç®—
- en: 'Thread Safety Analysis: Analyzes annotated functions and variables to ensure
    thread safety'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: çº¿ç¨‹å®‰å…¨æ€§åˆ†æï¼šåˆ†ææ ‡è®°çš„å‡½æ•°å’Œå˜é‡ä»¥ç¡®ä¿çº¿ç¨‹å®‰å…¨æ€§
- en: LivenessAnalysis in Clang is essential for optimizing code by determining whether
    a value computed at one point will be used before being overwritten. It produces
    liveness sets for each statement and CFGBlock, indicating potential future use
    of variables or expressions. This backward â€mayâ€ analysis simplifies read/write
    categorization by treating variable declarations and assignments as writes, and
    other contexts as reads, regardless of aliasing or field usage. Valuable in dead
    code elimination and compiler optimizations, such as efficient register allocation,
    it helps free up memory resources and improve program efficiency. Despite challenges
    with corner cases and documentation, its straightforward implementation and the
    ability to cache and query results make it a vital tool in enhancing software
    performance and resource management.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Clang ä¸­çš„ LivenessAnalysis å¯¹äºé€šè¿‡ç¡®å®šåœ¨æŸä¸ªç‚¹è®¡ç®—å‡ºçš„å€¼åœ¨è¦†ç›–ä¹‹å‰æ˜¯å¦ä¼šè¢«ä½¿ç”¨æ¥ä¼˜åŒ–ä»£ç è‡³å…³é‡è¦ã€‚å®ƒä¸ºæ¯ä¸ªè¯­å¥å’Œ CFGBlock
    ç”Ÿæˆæ´»åŠ¨é›†ï¼ŒæŒ‡ç¤ºå˜é‡æˆ–è¡¨è¾¾å¼çš„æ½œåœ¨æœªæ¥ä½¿ç”¨ã€‚è¿™ç§â€œå¯èƒ½â€çš„åå‘åˆ†æé€šè¿‡å°†å˜é‡å£°æ˜å’Œèµ‹å€¼è§†ä¸ºå†™å…¥ï¼Œå°†å…¶ä»–ä¸Šä¸‹æ–‡è§†ä¸ºè¯»å–ï¼Œç®€åŒ–äº†è¯»å†™åˆ†ç±»ï¼Œæ— è®ºæ˜¯å¦å­˜åœ¨åˆ«åæˆ–å­—æ®µä½¿ç”¨ã€‚å®ƒåœ¨æ­»ä»£ç æ¶ˆé™¤å’Œç¼–è¯‘å™¨ä¼˜åŒ–ï¼ˆå¦‚é«˜æ•ˆçš„å¯„å­˜å™¨åˆ†é…ï¼‰ä¸­éå¸¸æœ‰ä»·å€¼ï¼Œæœ‰åŠ©äºé‡Šæ”¾å†…å­˜èµ„æºå¹¶æé«˜ç¨‹åºæ•ˆç‡ã€‚å°½ç®¡å­˜åœ¨è¾¹ç¼˜æ¡ˆä¾‹å’Œæ–‡æ¡£çš„æŒ‘æˆ˜ï¼Œä½†å…¶ç›´æ¥çš„å®ç°å’Œç¼“å­˜æŸ¥è¯¢ç»“æœçš„èƒ½åŠ›ä½¿å…¶æˆä¸ºæé«˜è½¯ä»¶æ€§èƒ½å’Œèµ„æºç®¡ç†çš„é‡è¦å·¥å…·ã€‚
- en: Important note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦æ³¨æ„äº‹é¡¹
- en: Forward analysis is a method used in programming to check how data moves through
    a program from start to finish. Following the data path step by step as the program
    runs allows us to see how it changes or where it goes. This method is instrumental
    for identifying issues such as improperly set-up variables or tracking data flow
    in the program. It contrasts with backward analysis, which starts at the end of
    the program and works backward.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: å‰å‘åˆ†ææ˜¯ç¼–ç¨‹ä¸­ç”¨æ¥æ£€æŸ¥æ•°æ®ä»ç¨‹åºå¼€å§‹åˆ°ç»“æŸå¦‚ä½•æµåŠ¨çš„æ–¹æ³•ã€‚éšç€ç¨‹åºçš„è¿è¡Œï¼Œé€æ­¥è·Ÿè¸ªæ•°æ®è·¯å¾„ä½¿æˆ‘ä»¬èƒ½å¤Ÿçœ‹åˆ°å®ƒçš„å˜åŒ–æˆ–å»å‘ã€‚è¿™ç§æ–¹æ³•å¯¹äºè¯†åˆ«è¯¸å¦‚è®¾ç½®ä¸å½“çš„å˜é‡æˆ–è·Ÿè¸ªç¨‹åºä¸­çš„æ•°æ®æµç­‰é—®é¢˜è‡³å…³é‡è¦ã€‚å®ƒä¸åå‘åˆ†æå½¢æˆå¯¹æ¯”ï¼Œåå‘åˆ†æä»ç¨‹åºçš„æœ«å°¾å¼€å§‹ï¼Œå‘åå·¥ä½œã€‚
- en: UninitializedVariables analysis in Clang, designed to detect the use of variables
    before initialization, operates as a forward â€mustâ€ analysis. It involves multiple
    passes, including initial code scanning for statement classification and subsequent
    use of a fix-point algorithm to propagate information through the CFG. Handling
    more sophisticated scenarios than LivenessAnalysis, it faces challenges such as
    lacking support for record fields and non-reusable analysis results, limiting
    its efficiency in certain situations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Clang ä¸­çš„æœªåˆå§‹åŒ–å˜é‡åˆ†ææ—¨åœ¨æ£€æµ‹åœ¨åˆå§‹åŒ–ä¹‹å‰ä½¿ç”¨å˜é‡çš„æƒ…å†µï¼Œå®ƒä½œä¸ºä¸€ä¸ªå‰å‘çš„â€œå¿…é¡»â€åˆ†ææ“ä½œã€‚å®ƒæ¶‰åŠå¤šä¸ªéå†ï¼ŒåŒ…æ‹¬å¯¹ä»£ç è¿›è¡Œåˆå§‹æ‰«æä»¥å¯¹è¯­å¥è¿›è¡Œåˆ†ç±»ï¼Œä»¥åŠéšåä½¿ç”¨å›ºå®šç‚¹ç®—æ³•é€šè¿‡
    CFG ä¼ æ’­ä¿¡æ¯ã€‚å®ƒå¤„ç†æ¯” LivenessAnalysis æ›´å¤æ‚çš„åœºæ™¯ï¼Œé¢ä¸´ç€è¯¸å¦‚ç¼ºä¹å¯¹è®°å½•å­—æ®µå’Œéå¯é‡ç”¨åˆ†æç»“æœæ”¯æŒç­‰æŒ‘æˆ˜ï¼Œè¿™é™åˆ¶äº†å®ƒåœ¨æŸäº›æƒ…å†µä¸‹çš„æ•ˆç‡ã€‚
- en: Thread Safety Analysis in Clang, a forward analysis, focuses on ensuring proper
    synchronization in multithreaded code. It computes sets of locked mutexes for
    each statement in a block and utilizes annotations to indicate guarded variables
    or functions. Translating Clang expressions into TIL (Typed Intermediate Language)[[32](B19722_Bib.xhtml#XClangDataFlow2020)],
    it effectively handles the complexity of C++ expressions and annotations. Despite
    strong C++ support and a sophisticated understanding of variable interactions,
    it faces limitations, such as lack of support for aliasing, which can lead to
    false positives.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Clang ä¸­çš„çº¿ç¨‹å®‰å…¨æ€§åˆ†ææ˜¯ä¸€ç§å‰å‘åˆ†æï¼Œå®ƒä¸“æ³¨äºç¡®ä¿å¤šçº¿ç¨‹ä»£ç ä¸­çš„æ­£ç¡®åŒæ­¥ã€‚å®ƒä¸ºæ¯ä¸ªè¯­å¥å—ä¸­çš„æ¯ä¸ªè¯­å¥è®¡ç®—è¢«é”å®šäº’æ–¥é”çš„é›†åˆï¼Œå¹¶åˆ©ç”¨æ³¨è§£æ¥æŒ‡ç¤ºå—ä¿æŠ¤çš„å˜é‡æˆ–å‡½æ•°ã€‚å°†
    Clang è¡¨è¾¾å¼è½¬æ¢ä¸º TILï¼ˆç±»å‹ä¸­é—´è¯­è¨€ï¼‰[[32](B19722_Bib.xhtml#XClangDataFlow2020)]ï¼Œå®ƒæœ‰æ•ˆåœ°å¤„ç†äº† C++
    è¡¨è¾¾å¼å’Œæ³¨è§£çš„å¤æ‚æ€§ã€‚å°½ç®¡å®ƒå¯¹ C++ æœ‰å¼ºå¤§çš„æ”¯æŒï¼Œå¹¶ä¸”å¯¹å˜é‡äº¤äº’æœ‰æ·±å…¥çš„ç†è§£ï¼Œä½†å®ƒé¢ä¸´ç€ä¸€äº›é™åˆ¶ï¼Œä¾‹å¦‚ç¼ºä¹å¯¹åˆ«åæ”¯æŒï¼Œè¿™å¯èƒ½å¯¼è‡´è¯¯æŠ¥ã€‚
- en: 6.7 Knowing the limitations of analysis
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 äº†è§£åˆ†æçš„é™åˆ¶
- en: 'Itâ€™s worth mentioning some limitations of the analysis that can be conducted
    with Clangâ€™s AST and CFG. The most notable ones are mentioned here [[2](B19722_Bib.xhtml#XCIR)]:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æåŠçš„æ˜¯ï¼Œä½¿ç”¨ Clang çš„ AST å’Œ CFG å¯ä»¥è¿›è¡Œä¸€äº›åˆ†æçš„é™åˆ¶ï¼Œå…¶ä¸­æœ€æ˜¾è‘—çš„å¦‚ä¸‹ [[2](B19722_Bib.xhtml#XCIR)]ï¼š
- en: 'Limitations of Clangâ€™s AST: Clangâ€™s AST is unsuitable for data flow analysis
    and control flow reasoning, leading to inaccurate results and inefficient analysis
    due to the loss of vital language information. Soundness of analysis is also a
    consideration, where the precision of certain analyses, such as liveness analysis,
    can be valuable if they are precise enough rather than always being conservative.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clangçš„ASTå±€é™æ€§ï¼šClangçš„ASTä¸é€‚åˆæ•°æ®æµåˆ†æå’Œæ§åˆ¶æµæ¨ç†ï¼Œç”±äºä¸¢å¤±äº†å…³é”®çš„è¯­è¨€ä¿¡æ¯ï¼Œå¯¼è‡´ç»“æœä¸å‡†ç¡®ä¸”åˆ†ææ•ˆç‡ä½ä¸‹ã€‚åˆ†æçš„å¥å…¨æ€§ä¹Ÿæ˜¯ä¸€ä¸ªè€ƒè™‘å› ç´ ï¼ŒæŸäº›åˆ†æï¼ˆå¦‚å¯è¾¾æ€§åˆ†æï¼‰çš„ç²¾ç¡®æ€§å¦‚æœè¶³å¤Ÿç²¾ç¡®ï¼Œé‚£ä¹ˆå®ƒä»¬æ˜¯æœ‰ä»·å€¼çš„ï¼Œè€Œä¸æ˜¯æ€»æ˜¯ä¿å®ˆçš„ã€‚
- en: 'Issues with Clangâ€™s CFG: While Clangâ€™s CFG aims to bridge the gap between AST
    and LLVM IR, it encounters known problems, has limited interprocedural capabilities,
    and lacks adequate testing coverage.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clangçš„CFGé—®é¢˜ï¼šå°½ç®¡Clangçš„CFGæ—¨åœ¨å¼¥åˆASTå’ŒLLVM IRä¹‹é—´çš„å·®è·ï¼Œä½†å®ƒé‡åˆ°äº†å·²çŸ¥çš„é—®é¢˜ï¼Œå…·æœ‰æœ‰é™çš„è·¨ç¨‹åºèƒ½åŠ›ï¼Œå¹¶ä¸”ç¼ºä¹è¶³å¤Ÿçš„æµ‹è¯•è¦†ç›–ç‡ã€‚
- en: One example mentioned in [[2](B19722_Bib.xhtml#XCIR)] relates to C++ coroutines,
    a new feature introduced in C++20\. Some aspects of this functionality are implemented
    outside the Clang frontend and are not visible with tools such as Clangâ€™s AST
    and CFG. This limitation makes analysis, especially lifetime analysis, tricky
    for such functionalities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[[2](B19722_Bib.xhtml#XCIR)]ä¸­æåˆ°çš„ä¸€ä¸ªä¾‹å­ä¸C++20ä¸­å¼•å…¥çš„æ–°ç‰¹æ€§C++ coroutinesæœ‰å…³ã€‚è¯¥åŠŸèƒ½çš„ä¸€äº›æ–¹é¢æ˜¯åœ¨Clangå‰ç«¯ä¹‹å¤–å®ç°çš„ï¼Œå¹¶ä¸”æ— æ³•é€šè¿‡Clangçš„ASTå’ŒCFGç­‰å·¥å…·çœ‹åˆ°ã€‚è¿™ç§é™åˆ¶ä½¿å¾—å¯¹è¿™äº›åŠŸèƒ½çš„åˆ†æï¼Œå°¤å…¶æ˜¯ç”Ÿå‘½å‘¨æœŸåˆ†æï¼Œå˜å¾—å¤æ‚ã€‚
- en: Despite these limitations, Clangâ€™s CFG remains a powerful tool widely used in
    compiler and compiler tool development. There is also active development of other
    tools [[27](B19722_Bib.xhtml#XCIR_upstream)] that aim to close the gaps in Clangâ€™s
    CFG capabilities.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡å­˜åœ¨è¿™äº›å±€é™æ€§ï¼ŒClangçš„CFGä»ç„¶æ˜¯ä¸€ä¸ªåœ¨ç¼–è¯‘å™¨å’Œç¼–è¯‘å™¨å·¥å…·å¼€å‘ä¸­å¹¿æ³›ä½¿ç”¨çš„å¼ºå¤§å·¥å…·ã€‚è¿˜æœ‰å…¶ä»–å·¥å…·æ­£åœ¨ç§¯æå¼€å‘ä¸­ [[27](B19722_Bib.xhtml#XCIR_upstream)]ï¼Œæ—¨åœ¨å¼¥åˆClangçš„CFGèƒ½åŠ›ä¸Šçš„å·®è·ã€‚
- en: 6.8 Summary
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 æ‘˜è¦
- en: In this chapter, we investigated Clangâ€™s CFG, a powerful data structure that
    represents the symbolic execution of a program. We created a simple Clang-Tidy
    check using a CFG to calculate cyclomatic complexity, a metric useful for estimating
    code complexity. Additionally, we explored the details of CFG creation and the
    formation of its basic internal structures. We discussed some tools developed
    with CFGs, which are useful for detecting lifetime issues, thread safety, and
    uninitialized variables. We also briefly described the limitations of CFGs and
    how other tools can address these limitations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬ç ”ç©¶äº†Clangçš„CFGï¼Œè¿™æ˜¯ä¸€ç§å¼ºå¤§çš„æ•°æ®ç»“æ„ï¼Œç”¨äºè¡¨ç¤ºç¨‹åºçš„ç¬¦å·æ‰§è¡Œã€‚æˆ‘ä»¬ä½¿ç”¨CFGåˆ›å»ºäº†ä¸€ä¸ªç®€å•çš„Clang-Tidyæ£€æŸ¥ï¼Œç”¨äºè®¡ç®—ç¯è·¯å¤æ‚åº¦ï¼Œè¿™æ˜¯ä¸€ä¸ªç”¨äºä¼°è®¡ä»£ç å¤æ‚åº¦çš„æœ‰ç”¨åº¦é‡ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜æ¢è®¨äº†CFGåˆ›å»ºçš„ç»†èŠ‚åŠå…¶åŸºæœ¬å†…éƒ¨ç»“æ„çš„å½¢æˆã€‚æˆ‘ä»¬è®¨è®ºäº†ä¸€äº›ä½¿ç”¨CFGå¼€å‘çš„å·¥å…·ï¼Œè¿™äº›å·¥å…·å¯¹äºæ£€æµ‹ç”Ÿå‘½å‘¨æœŸé—®é¢˜ã€çº¿ç¨‹å®‰å…¨å’Œæœªåˆå§‹åŒ–å˜é‡å¾ˆæœ‰ç”¨ã€‚æˆ‘ä»¬è¿˜ç®€è¦æè¿°äº†CFGçš„å±€é™æ€§ä»¥åŠå…¶ä»–å·¥å…·å¦‚ä½•è§£å†³è¿™äº›å±€é™æ€§ã€‚
- en: The next chapter will cover refactoring tools. These tools can perform complex
    code modifications using the AST provided by the Clang compiler.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€ç« å°†ä»‹ç»é‡æ„å·¥å…·ã€‚è¿™äº›å·¥å…·å¯ä»¥ä½¿ç”¨Clangç¼–è¯‘å™¨æä¾›çš„ASTæ‰§è¡Œå¤æ‚çš„ä»£ç ä¿®æ”¹ã€‚
- en: 6.9 Future reading
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 æœªæ¥é˜…è¯»
- en: Flemming Nielson, Hanne Riis Nielson, and Chris Hankin, *Principles* *of Program
    Analysis*, Springer, 2005 [[29](B19722_Bib.xhtml#XNielson2005Principles)]
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flemming Nielsonã€Hanne Riis Nielsonå’ŒChris Hankinï¼Œ*ç¨‹åºåˆ†æåŸç†*ï¼ŒSpringerï¼Œ2005 [[29](B19722_Bib.xhtml#XNielson2005Principles)]
- en: 'Xavier Rival and Kwangkeun Yi, *Introduction to Static Analysis: An* *Abstract*
    *Interpretation Perspective*, The MIT Press, 2020 [[30](B19722_Bib.xhtml#XRivalYi2020StaticAnalysis)]'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xavier Rivalå’ŒKwangkeun Yiï¼Œ*é™æ€åˆ†æå¯¼è®ºï¼šæŠ½è±¡è§£é‡Šè§†è§’*ï¼Œéº»çœç†å·¥å­¦é™¢å‡ºç‰ˆç¤¾ï¼Œ2020 [[30](B19722_Bib.xhtml#XRivalYi2020StaticAnalysis)]
- en: 'KristÃ³f Umann *A survey of dataflow analyses in Clang*: [https://lists.llvm.org/pipermail/cfe-dev/2020-October/066937.html](https://lists.llvm.org/pipermail/cfe-dev/2020-October/066937.html)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'KristÃ³f Umann *Clangä¸­æ•°æ®æµåˆ†æçš„è°ƒæŸ¥*: [https://lists.llvm.org/pipermail/cfe-dev/2020-October/066937.html](https://lists.llvm.org/pipermail/cfe-dev/2020-October/066937.html)'
- en: 'Bruno Cardoso Lopes and Nathan Lanza *An MLIR based Clang IR* *(CIR)*: [https://discourse.llvm.org/t/rfc-an-mlir-based-clang-ir-cir/63319](https://discourse.llvm.org/t/rfc-an-mlir-based-clang-ir-cir/63319)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bruno Cardoso Lopeså’ŒNathan Lanza *åŸºäºMLIRçš„Clang IR* *(CIR)*: [https://discourse.llvm.org/t/rfc-an-mlir-based-clang-ir-cir/63319](https://discourse.llvm.org/t/rfc-an-mlir-based-clang-ir-cir/63319)'
