- en: Deep Dive into Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解内存管理
- en: Memory turns out to be one of the core concepts when dealing with systems development.
    Allocating, freeing, and learning how memory is managed, and knowing what C++
    can offer to simplify and manage memory, are crucial. This chapter will help you
    grasp how memory works by learning how to use C++ smart pointers, aligned memory,
    memory-mapped I/O, and allocators.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内存在处理系统开发时是核心概念之一。分配、释放、学习内存管理方式，以及了解C++可以提供什么来简化和管理内存，都是至关重要的。本章将通过学习如何使用C++智能指针、对齐内存、内存映射I/O和分配器来帮助您理解内存的工作原理。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Learning automatic versus dynamic memory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习自动与动态内存
- en: Learning when to use `unique_ptr`, and the implications for size
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习何时使用`unique_ptr`，以及对大小的影响
- en: Learning when to use `shared_ptr`, and the implications for size
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习何时使用`shared_ptr`，以及对大小的影响
- en: Allocating aligned memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配对齐内存
- en: Checking whether the memory allocated is aligned
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查分配的内存是否对齐
- en: Dealing with memory-mapped I/O
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理内存映射I/O
- en: Dealing with allocators hands-on
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亲自处理分配器
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to let you immediately try the programs, we've set up a Docker image that
    has all the tools and libraries we'll need throughout the book. This is based
    on Ubuntu 19.04.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您立即尝试这些程序，我们设置了一个Docker镜像，其中包含本书中将需要的所有工具和库。这是基于Ubuntu 19.04的。
- en: 'In order to set it up, follow these steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置它，请按照以下步骤进行：
- en: Download and install Docker Engine from [www.docke](https://www.docker.com/)[r.com](https://www.docker.com/).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[www.docke](https://www.docker.com/)[r.com](https://www.docker.com/)下载并安装Docker
    Engine。
- en: 'Pull the image from Docker Hub by running the following command: `docker pull
    kasperondocker/system_programming_cookbook:latest`.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令从Docker Hub拉取镜像：`docker pull kasperondocker/system_programming_cookbook:latest`。
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该可以使用该镜像。键入以下命令查看镜像：`docker images`。
- en: You should have at least this image now: `kasperondocker/system_programming_cookbook`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您应该至少有这个镜像：`kasperondocker/system_programming_cookbook`。
- en: Run the Docker image with an interactive shell, with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令以交互式shell运行Docker镜像：`docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest
    /bin/bash`。
- en: The shell on the running container is now available. Type in `root@39a5a8934370/#
    cd /BOOK/` to get all the programs developed, by chapter.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在运行的容器上的shell现在可用。键入`root@39a5a8934370/# cd /BOOK/`以获取按章节开发的所有程序。
- en: The `--cap-add sys_ptrace` argument is needed to allow the **GNU Project Debugger** (**GDB**)
    in the Docker container to set breakpoints, which, by default, Docker does not
    allow.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`--cap-add sys_ptrace`参数以允许Docker容器中的GNU Project Debugger（GDB）设置断点，默认情况下Docker不允许。
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**免责声明**：C++20标准已经在二月底的布拉格会议上由WG21批准（即技术上最终确定）。这意味着本书使用的GCC编译器版本8.3.0不包括（或者对C++20的新功能支持非常有限）。因此，Docker镜像不包括C++20的代码。GCC将最新功能的开发保留在分支中（您必须使用适当的标志，例如`-std=c++2a`）；因此，鼓励您自行尝试。因此，请克隆并探索GCC合同和模块分支，并尽情玩耍。'
- en: Learning automatic versus dynamic memory
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习自动与动态内存
- en: This recipe will focus on the two main strategies C++ offers to allocate memory: **automatic**
    and **dynamic** memory allocation. A variable is automatic when its scope lasts
    for the duration of the block in which it is defined, and its allocation and deallocation
    are automatic (that is, not up to the developer). The variable is allocated on
    the stack.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将重点介绍C++提供的两种主要策略来分配内存：**自动**和**动态**内存分配。当变量的作用域持续到其定义的块的持续时间时，变量是自动的，并且其分配和释放是自动的（即不由开发人员决定）。变量分配在堆栈上。
- en: A variable is dynamic if allocated in the dynamic portion of the memory (free
    store, which is often referred to as the *heap*), and the allocation and deallocation
    are up to the developer. Greater flexibility offered by the dynamic memory allocation
    comes with a cost, in terms of more work for the developer to avoid memory leaks,
    dangling pointers, and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量在内存的动态部分（自由存储区，通常称为*堆*）中分配，并且分配和释放由开发人员决定，则变量是动态的。动态内存分配提供的更大灵活性伴随着更多的工作量，以避免内存泄漏、悬空指针等。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: This section will show two examples of automatic and dynamic variable allocation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示自动和动态变量分配的两个示例。
- en: 'Let''s create a utility class we''re going to need:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个我们需要的实用类：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And now, let''s create the `main` module to show automatic memory usage:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`main`模块来显示自动内存使用情况：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And now, we''ll write the `main` module for dynamic memory usage:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为动态内存使用编写`main`模块：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These two programs, although with the same outcome, show two different ways
    of dealing with memory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个程序，尽管结果相同，但展示了处理内存的两种不同方式。
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the first step, we defined a `User` class, which is used to show the difference
    between automatic and dynamic memory allocation. Its constructor and destructor
    will be used to show when the class is allocated and deallocated.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们定义了一个`User`类，用于展示自动和动态内存分配之间的区别。它的构造函数和析构函数将用于显示类何时分配和释放。
- en: 'In *step 2*, we can see that the variable is just defined as `User developer;`.
    The C++ runtime will take care of allocating memory of the stack and freeing it,
    without additional work for the developer. This type of memory management is faster
    and easier, but comes with two major costs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们可以看到变量只是定义为`User developer;`。C++运行时将负责在堆栈上分配内存并释放内存，而开发人员无需额外工作。这种类型的内存管理更快，更容易，但有两个主要成本：
- en: The amount of memory is limited.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存量是有限的。
- en: The variable is only valid and visible in the inner `{ }` block, where it is
    allocated.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量仅在内部`{ }`块中有效和可见，其中它被分配。
- en: 'In *step 3*, the same object is allocated on the dynamic memory (that is, **heap**).
    The main difference is that the developer is now responsible for allocating and
    deallocating the quantity of memory needed. If the memory is not deallocated (by
    using `free`), there''ll be a leak. The pros of managing the memory dynamically are as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，相同的对象分配在动态内存（即**堆**）上。主要区别在于现在开发人员负责分配和释放所需的内存量。如果内存没有被释放（使用`free`），就会发生泄漏。动态管理内存的优点如下：
- en: 'Flexibility: The pointer, referencing to the allocated memory (the `developer`
    variable) can be used throughout the whole program.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性：指针引用分配的内存（`developer`变量）可以在整个程序中使用。
- en: The quantity of memory available is way more than that for automatic memory
    management.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的内存量远远超过自动内存管理的内存量。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With the newer C++ standard (from version 11 onward), `new` and `delete` can
    be safely avoided in favor of smart pointers (`shared_ptr` and `unique_ptr`).
    These two tools will take care of deallocating the memory when it is not used
    anymore. [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting
    C++*, provides a refresher on smart pointers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新的C++标准（从版本11开始），可以安全地避免使用`new`和`delete`，而使用智能指针（`shared_ptr`和`unique_ptr`）。这两个工具将在不再使用内存时负责释放内存。[第2章](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml)，*重温C++*，提供了智能指针的复习。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next two recipes will show when to use `unique_ptr` and `shared_ptr`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个配方将展示何时使用`unique_ptr`和`shared_ptr`。
- en: Learning when to use unique_ptr, and the implications for size
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习何时使用`unique_ptr`，以及大小的影响
- en: 'In the previous recipe, we''ve learned the two fundamental ways of managing
    memory in C++: automatic and dynamic. We''ve also learned that dynamic memory
    is available to the developer in a greater quantity compared to automatic memory
    (that is, available from the stack), and offers great flexibility. On the other
    hand dealing with dynamic memory can be an unpleasant experience:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们已经学习了C++中管理内存的两种基本方式：自动和动态。我们还了解到，与自动内存（即从堆栈中可用）相比，动态内存对开发人员的数量更多，并提供了更大的灵活性。另一方面，处理动态内存可能是一种不愉快的体验：
- en: The pointer does not indicate whether it points to an array or to a single object.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针不指示它指向数组还是单个对象。
- en: When freeing the allocated memory, you don't know if you have to use `delete`
    or `delete[]`, so you have to look at how the variable is defined.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放分配的内存时，您不知道是否必须使用`delete`还是`delete[]`，因此您必须查看变量的定义方式。
- en: There is no explicit way to tell if the pointer is dangling.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有明确的方法告诉指针是否悬空。
- en: These are just a few issues you might encounter when dealing with dynamic memory,
    and then, with `new` and `delete`. `unique_ptr` is a smart pointer, which means
    that it knows when the memory should be deallocated, removing the burden from
    the developer. In this recipe, you'll learn how to use `unique_ptr` and `make_unique` properly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是您在处理动态内存以及`new`和`delete`时可能遇到的一些问题。`unique_ptr`是一个智能指针，这意味着它知道何时应该释放内存，从而减轻了开发人员的负担。在本配方中，您将学习如何正确使用`unique_ptr`和`make_unique`。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll develop a program to learn why `unique_ptr` is a convenient
    way of dealing with dynamic memory; and the second aspect is to learn whether `unique_ptr`
    is the same size as raw pointers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个程序，以了解为什么`unique_ptr`是处理动态内存的便捷方式；第二个方面是了解`unique_ptr`是否与原始指针大小相同：
- en: We'll reuse the `User` class developed in the previous recipe.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重用上一个配方中开发的`User`类。
- en: 'Let''s write the `main` program, allocating a `User` object with `make_unique`
    and using `unique_ptr`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写`main`程序，使用`make_unique`分配`User`对象并使用`unique_ptr`：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s see the memory implications:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看内存的影响：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What do you think will be the difference in size between `developer` and `developer2`?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为`developer`和`developer2`之间的大小差异是多少？
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In *step 2*, we used `unique_ptr` to define a variable allocated using `std::make_unique`.
    Once the variable is allocated, there is no risk of memory leak as the destructor
    will automatically deallocate the memory for us. The output is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们使用`unique_ptr`来定义使用`std::make_unique`分配的变量。一旦分配了变量，由于析构函数会自动为我们释放内存，因此不会有内存泄漏的风险。输出如下：
- en: '![](img/a9d63859-8852-406f-8c0e-3474395f5d97.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9d63859-8852-406f-8c0e-3474395f5d97.png)'
- en: 'In *step 3*, we wanted to check if `unique_ptr` added any memory compared to
    raw pointers. Well, the good news is that `unique_ptr` has the same size as the
    raw pointer version. The output of this step is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们想要检查`unique_ptr`是否与原始指针相比增加了任何内存。好消息是，`unique_ptr`与原始指针版本的大小相同。此步骤的输出如下：
- en: '![](img/541b1ef5-331f-4f88-b69d-1e6006d78c37.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/541b1ef5-331f-4f88-b69d-1e6006d78c37.png)'
- en: The `developer` and `developer2` variables are of the same size, and the developer
    can treat them the same way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`developer`和`developer2`变量的大小相同，开发人员可以以相同的方式处理它们。'
- en: A rule of thumb is to use `unique_ptr` for variables that manage resources with
    **exclusive ownership only**, which represent most developers' use cases.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是仅对具有**独占所有权的资源**使用`unique_ptr`，这代表了大多数开发人员的用例。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: By default, `unique_ptr` calls the default `delete` destructor for the object,
    but a custom `delete` destructor can be specified. If the pointer variable does
    not represent exclusive ownership but rather shared ownership converting it to
    `shared_ptr` is easy.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`unique_ptr`调用对象的默认`delete`析构函数，但可以指定自定义的`delete`析构函数。如果指针变量不代表独占所有权，而是共享所有权，将其转换为`shared_ptr`很容易。
- en: One important aspect to highlight is that `make_unique` is not part of the C++11
    standard library, but part of the C++ 14 library. If you're using the C++11 standard
    library, its implementation is quite simple, though.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点要强调的是，`make_unique`不是C++11标准库的一部分，而是C++14库的一部分。如果你使用的是C++11标准库，它的实现是非常简单的。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting C++* has
    a dedicated recipe on smart pointers, with one recipe on shared and unique pointers.
    A suggested read is *Effective Modern C++* by Scott Meyers.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml)，*重温C++*有一个专门讨论智能指针的配方，其中有一个关于共享和独特指针的配方。建议阅读的是Scott
    Meyers的*Effective Modern C++*。'
- en: Learning when to use shared_ptr, and the implications for size
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习何时使用shared_ptr，以及大小的影响
- en: In the previous recipe, we've learned how to manage dynamic memory (allocated
    on the heap) in a very convenient way, by using `unique_ptr`. We've learned as
    well that `unique_ptr` must be used, just in case of exclusive ownership of the
    memory, or resources managed by the memory. But what if we have a resource that
    is co-owned by more entities? What if the memory we have to manage has to be released
    when all the owners have completed their job? Well, this is exactly the use case
    for `shared_ptr`. Just as with `unique_ptr`, for `shared_ptr` we don't have to
    allocate memory with `new`, but there is a template function (part of the C++
    standard library), `make_shared`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的配方中，我们已经学会了如何以一种非常方便的方式管理动态内存（在堆上分配），使用`unique_ptr`。我们也学到了`unique_ptr`必须在内存的独占所有权或由内存管理的资源的情况下使用。但是，如果我们有一个资源是由多个实体共同拥有的呢？如果我们必须在所有者完成工作后释放要管理的内存呢？好吧，这正是`shared_ptr`的用例。就像`unique_ptr`一样，对于`shared_ptr`，我们不必使用`new`来分配内存，但是有一个模板函数（C++标准库的一部分），`make_shared`。 '
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this section, we''ll develop a program to show how to use `shared_ptr`.
    You''ll learn that the memory is only deallocated when none of the owners use
    the memory anymore:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个程序来展示如何使用`shared_ptr`。您将了解到只有在所有者不再使用内存时，内存才会被释放：
- en: 'We''ll reuse the `User` class developed in the first recipe. Let''s now write
    the `main` module:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重用第一个配方中开发的`User`类。现在让我们编写`main`模块：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s see the memory used by `shared_ptr` by writing this program:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过编写这个程序来看一下`shared_ptr`使用的内存：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, we should know the size of `unique_ptr` compared to a raw pointer
    (as we learned in the *Learning when to use unique_ptr, and the implications for
    size* recipe). What is the size of the `shared_ptr` variable? Still the same?
    In the next section, we'll learn about this important aspect.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该知道`unique_ptr`的大小与原始指针相比（正如我们在*学习何时使用unique_ptr以及大小的影响*配方中所学到的）。`shared_ptr`变量的大小是多少？还是一样的？在下一节中，我们将了解这个重要的方面。
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding first program, we showed how to use `shared_ptr`. First, we
    allocated a block of memory, which contained an object of type `User` with `auto
    shared1 = std::make_shared<User>();`. So far, the `User` resource is owned by
    the `shared1` variable. Next, into the block, we assigned the `shared1` variable
    to `shared2` through `auto shared2 = shared1;`. This means that the memory containing
    the `User` object is now pointed by `shared1` and `shared2`. The same goal would
    have been achieved by using the constructor copy `auto shared2 (shared1);`. As
    `User` is now pointed by two variables, the deallocation of the used memory only
    happens when all the variables go out of scope. Indeed, the output proves that
    the memory is deallocated (`User`''s destructor is called) at the end of the main
    block, and not at the end of the inner block, as happened for `unique_ptr`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的第一个程序中，我们展示了如何使用`shared_ptr`。首先，我们分配了一个内存块，其中包含了一个类型为`User`的对象，`auto shared1
    = std::make_shared<User>();`。到目前为止，`User`资源由`shared1`变量拥有。接下来，我们将`shared1`变量分配给`shared2`，通过`auto
    shared2 = shared1;`。这意味着包含`User`对象的内存现在由`shared1`和`shared2`指向。使用构造函数复制`auto shared2
    (shared1);`也可以达到相同的目标。由于`User`现在由两个变量指向，所以使用的内存只有在所有变量超出范围时才会被释放。事实上，输出证明了内存在主块结束时被释放（`User`的析构函数被调用），而不是在内部块结束时，就像`unique_ptr`一样。
- en: '![](img/a75c73de-d7b4-4ff1-9412-af044422965d.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a75c73de-d7b4-4ff1-9412-af044422965d.png)'
- en: The impact of `shared_ptr` on memory is not the same as `unique_ptr`. The reason
    is that the `shared_ptr` implementation needs one raw pointer to keep track of
    the memory (likewise with `unique_ptr`), and another raw pointer for the resource's
    reference counting.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`对内存的影响与`unique_ptr`不同。原因是`shared_ptr`的实现需要一个原始指针来跟踪内存（与`unique_ptr`一样），以及另一个原始指针用于资源的引用计数。'
- en: 'This reference-counting variable must necessarily be an atomic one, as it can
    be incremented and decremented by different threads:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个引用计数变量必须是原子的，因为它可以被不同的线程增加和减少：
- en: '![](img/2bbb9914-5677-489e-adc5-d9acef0e9550.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bbb9914-5677-489e-adc5-d9acef0e9550.png)'
- en: The memory size of a `shared_ptr` variable is, typically, twice the size of
    a raw pointer, as we see in the preceding output, on running the second program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`变量的内存大小通常是原始指针的两倍，正如在运行第二个程序时在前面的输出中所看到的。'
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One more interesting point not to overlook is that as `shared_ptr` contains
    an atomic variable, it is typically slower than normal variables.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的点不容忽视的是，由于`shared_ptr`包含原子变量，它通常比普通变量慢。
- en: See also
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting C++*, has
    a dedicated recipe on smart pointers, with one recipe on shared and unique pointers.
    A suggested read is *Effective Modern C++* by Scott Meyers.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml)，*重温C++*，有一个专门介绍智能指针的示例，其中包括一个关于共享指针和唯一指针的示例。建议阅读Scott
    Meyers的*Effective Modern C++*。'
- en: Allocating aligned memory
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配对齐内存
- en: Writing system programs might require the use of data that is aligned in memory in
    order to access the hardware efficiently (and in some cases, to access it at all).
    For example, on a 32-bit architecture machine, we have the memory allocated aligned
    to a 4-byte boundary. In this recipe, you'll learn how to use the C++11 `std::aligned_storage` to
    allocate aligned memory. Of course, there are other, more traditional, mechanisms
    to allocate aligned memory, but the goal of this book is to use C++ standard library
    tools as much as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 编写系统程序可能需要使用在内存中对齐的数据，以便有效地访问硬件（在某些情况下，甚至是访问硬件）。例如，在32位架构机器上，我们将内存分配对齐到4字节边界。在这个示例中，您将学习如何使用C++11的`std::aligned_storage`来分配对齐内存。当然，还有其他更传统的机制来分配对齐内存，但本书的目标是尽可能使用C++标准库工具。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll write a program that will use the allocated memory
    with `std::aligned_storage` and will show the use of `std::alignment_of`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个程序，该程序将使用使用`std::aligned_storage`分配的内存，并将展示`std::alignment_of`的使用：
- en: 'Let''s start by writing a program to check what is the default alignment boundary
    for integers and doubles on the current machine:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从编写一个程序开始，检查当前计算机上整数和双精度浮点数的默认对齐边界是多少：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s write a program to allocate memory aligned to a specific size.
    For this, let''s use `std::aligned_storage`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个程序来分配对齐到特定大小的内存。为此，让我们使用`std::aligned_storage`：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Allocating aligned memory can be tricky, and the C++ standard library (from
    version 11 onward) offers these two features (`std::alignment_of`, `std::aligned_storage`)
    to simplify it. The next section will describe the mechanics behind it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 分配对齐内存可能会很棘手，C++标准库（从第11版开始）提供了这两个功能（`std::alignment_of`，`std::aligned_storage`）来简化它。下一节将描述其背后的机制。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first program, which is quite simple, shows the natural alignment in memory
    for two primitive types through `std::alignment_of`. By compiling (`g++ alignedStorage.cpp`)
    and running the program, we have the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个程序非常简单，通过`std::alignment_of`显示了两种原始类型在内存中的自然对齐。通过编译（`g++ alignedStorage.cpp`）并运行程序，我们得到以下输出：
- en: '![](img/cb15931f-34a9-47f0-8177-6b312346afba.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb15931f-34a9-47f0-8177-6b312346afba.png)'
- en: This means that each integer will be aligned at `4` bytes of boundary and with floating-point
    types aligned to `8` bytes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个整数将在`4`字节的边界上对齐，并且浮点类型将在`8`字节处对齐。
- en: 'In the second program, we need an integer that is aligned to `8` bytes. By
    compiling it and running the executable, the output would be something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个程序中，我们需要一个对齐到`8`字节的整数。通过编译并运行可执行文件，输出将类似于这样：
- en: '![](img/9f9a06a2-f91c-41b7-a846-570c3b5837e4.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f9a06a2-f91c-41b7-a846-570c3b5837e4.png)'
- en: 'You may have noticed that I''ve compiled with the `-g` option (to add debug
    symbols). We did this to show, with the memory dump in GDB, that the memory of
    the integer is correctly aligned at `8` bytes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我已经使用了`-g`选项进行了编译（添加调试符号）。我们这样做是为了在GDB中的内存转储中显示整数的内存正确地对齐在`8`字节处：
- en: '![](img/71381006-7525-4b1d-9919-2163adf644e0.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71381006-7525-4b1d-9919-2163adf644e0.png)'
- en: 'From the debug session, we can see that through the `x/20bd iu` (`x` = *memory
    dump*) command, we dumped `20` bytes of the memory after the address of the `iu`
    variable. We can see something interesting here: both the `iu` and `ju` variables
    are aligned at `8` bytes. Each memory row displays `8` bytes (test it: `0x7ffc57654470`* –*
    `0x7ffc57654468` = `8`).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从调试会话中，我们可以看到通过`x/20bd iu`（`x`=*内存转储*）命令，我们在`iu`变量地址之后转储了`20`字节的内存。我们可以看到这里有一些有趣的东西：`iu`和`ju`变量都对齐在`8`字节处。每个内存行显示`8`字节（测试一下：`0x7ffc57654470`*
    - * `0x7ffc57654468` = `8`）。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Playing with memory is always risky, and these new C++ features (and others
    available in the `std` namespace) help us to **play safe**. The recommendation
    is still the same: premature optimization must be used carefully; optimize (that
    is, use aligned memory) only when necessary. One last recommendation: using `reinterpret_cast`
    is discouraged, as it manipulates memory at a low level. You need to know what
    you''re doing when using it.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 玩弄内存总是有风险的，这些新的C++特性（以及`std`命名空间中的其他可用特性）帮助我们**玩得更安全**。建议仍然是一样的：过早的优化必须谨慎使用；只有在必要时才进行优化（即使用对齐内存）。最后一个建议：不建议使用`reinterpret_cast`，因为它在低级别操纵内存。在使用它时，您需要知道自己在做什么。
- en: See also
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The latest version of *The C+**+ Programming Language, Fourth Edition* by Bjarne
    Stroustrup has a paragraph on *memory alignment* (*6.2.9*) and *aligned_storage *(*35.4.1*).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Bjarne Stroustrup的*The C++ Programming Language, Fourth Edition*的最新版本有一段关于*内存对齐*（*6.2.9*）和*aligned_storage*（*35.4.1*）的段落。
- en: Checking whether the memory allocated is aligned
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查分配的内存是否对齐
- en: 'In the previous recipe, you have learned how to use C++11 to allocate aligned
    memory. The question now is: how do we know that memory is properly aligned? This
    recipe will teach you about this.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，您已经学会了如何使用C++11来分配对齐内存。现在的问题是：我们如何知道内存是否正确对齐？这个示例将教会您这一点。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll be using the previous program, and by modifying it a little, we''ll
    see how to check whether a pointer is aligned or not:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前面的程序，并稍作修改，看看如何检查指针是否对齐：
- en: 'Let''s modify the previous program, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改前面的程序，如下所示：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We created on purpose two typedefs, one for the alignment to `8` bytes (`intAligned8`)
    and one for the alignment to `4` bytes (`intAligned4`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特意创建了两个typedef，一个用于对齐到`8`字节（`intAligned8`），一个用于对齐到`4`字节（`intAligned4`）。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the program, we defined two variables, `i` and `j`, of type `intAligned8`
    and `intAligned4` respectively. With the help of these two variables (with alignment
    to `8` and `4` bytes), we can see that they are properly aligned by checking that
    the result of the division by `8` is `0`: `((unsigned long)iu % 8 == 0)`. This
    ensures that the `iu` pointer is aligned to `8` bytes. The same is done for the
    `ju` variable. By running the preceding program, we''ll get this result:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，我们定义了两个变量`i`和`j`，分别为`intAligned8`和`intAligned4`类型。借助这两个变量（分别对齐到`8`和`4`字节），我们可以通过检查除以`8`的结果是否为`0`来验证它们是否正确对齐：`((unsigned
    long)iu % 8 == 0)`。这确保了`iu`指针对齐到`8`字节。对`ju`变量也是同样的操作。通过运行前面的程序，我们将得到这个结果：
- en: '![](img/d2ddef14-28cf-4cc5-9991-e6f703144054.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2ddef14-28cf-4cc5-9991-e6f703144054.png)'
- en: 'As expected: `iu` is properly aligned to `8` bytes and `ju` is not.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的结果：`iu`正确对齐到`8`字节，而`ju`没有。
- en: There's more...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As you might have noticed, we used `reinterpret_cast` to allow the modulus
    (`%`) operator instead of the C-style cast `((unsigned long)iu % 8 == 0)`. If
    you are developing in C++, you''re encouraged to use the named casts (`static_cast`,
    `reinterpret_cast`, `const_cast`, `dynamic_cast`) for two basic reasons:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们使用`reinterpret_cast`来允许模数（`%`）运算符，而不是C风格的转换`((unsigned long)iu
    % 8 == 0)`。如果您在C++中开发，建议使用命名转换（`static_cast`、`reinterpret_cast`、`const_cast`、`dynamic_cast`）有两个基本原因：
- en: To allow the programmer to express the intent of the cast
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许程序员表达转换的意图
- en: To make the cast safe
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使转换安全
- en: See also
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: More info on this topic can be found in *Advanced Programming in the UNIX*^®* Environment* by
    W. Richard Stevens and Stephen A. Rago.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息可以在W. Richard Stevens和Stephen A. Rago的*UNIX环境高级编程*中找到。
- en: When a portion of memory is aligned, the compiler can make great optimization.
    A compiler doesn't have the possibility of knowing this, and therefore cannot
    make any optimizations. The last C++20 standard added the `std::assume_aligned` feature.
    This informs the compiler that the value of a pointer is a memory address aligned
    to a certain number of bytes. What can happen is that when we allocate some aligned
    memory, the pointer to that memory is then passed to other functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当一部分内存对齐时，编译器可以进行很好的优化。编译器无法知道这一点，因此无法进行任何优化。最新的C++20标准添加了`std::assume_aligned`功能。这告诉编译器指针的值是对齐到一定字节数的内存地址。可能发生的情况是，当我们分配一些对齐的内存时，该内存的指针会传递给其他函数。
- en: 'The `std::assume_aligned` feature informs the compiler to assume that the memory
    pointed by a pointer is already aligned, so it is safe to make optimizations:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::assume_aligned`功能告诉编译器假定指针指向的内存已经对齐，因此可以进行优化：'
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `std::assume_aligned<64>(p);` feature informs the compiler that `p` is already
    aligned to at least `64` bytes. You'll get undefined behavior if the memory is
    not aligned.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::assume_aligned<64>(p);`功能告诉编译器`p`已经对齐到至少`64`字节。如果内存未对齐，将会得到未定义的行为。'
- en: Dealing with memory-mapped I/O
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理内存映射I/O
- en: Sometimes, we need to operate on memory in a way that is not conventional or,
    so to speak, not common. As we've seen, memory is allocated with `new` and released
    with `delete` (or, even better, with `make_unique` and `make_shared`). There might
    be cases in which we need to skip some layer—that is, using a Linux system call;
    for the sake of performance; or because of a custom behavior that we cannot map
    with the C++ standard library. This is the case with the `mmap` Linux system call
    (`man 2 mmap`). `mmap` is a POSIX-compliant system call that allows the programmer
    to map a file to a portion of memory. Among other things, `mmap` also allows memory
    to be allocated, and this recipe will teach you how to do it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要以非常规或者说不常见的方式操作内存。正如我们所见，内存是使用`new`分配的，并使用`delete`（或者更好的是`make_unique`和`make_shared`）释放的。可能存在需要跳过某些层的情况——也就是说，使用Linux系统调用；出于性能考虑；或者因为我们无法使用C++标准库来映射自定义行为。这就是`mmap`
    Linux系统调用的情况（`man 2 mmap`）。`mmap`是一个符合POSIX标准的系统调用，允许程序员将文件映射到内存的一部分。除其他功能外，`mmap`还允许分配内存，本教程将教您如何实现。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This section will show two `mmap` use cases: the first, how to map a file to
    a portion of memory; and the second, how to allocate memory using `mmap`. Let''s
    first write a program that maps a file to memory.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示两个`mmap`用例：第一个是如何将文件映射到内存的一部分；第二个是如何使用`mmap`分配内存。让我们首先编写一个将文件映射到内存的程序。
- en: 'In a shell, let''s create a new source file called `mmap_write.cpp`. We need
    to open a file to map:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell中，让我们创建一个名为`mmap_write.cpp`的新源文件。我们需要打开一个文件进行映射：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Second, we have to create a space into the file that we''ll use later (`mmap` does
    not do this):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们需要在文件中创建一个空间，以便以后使用（`mmap`不会执行此操作）：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can map the file—represented by the `fd` file descriptor—to the `map`
    variable:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将文件（由`fd`文件描述符表示）映射到`map`变量：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And finally, we need to write some value into it:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要向其中写入一些值：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s not forget to close the resources used:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记关闭使用的资源：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The steps seen so far are related to writing a file with `mmap`. For the sake
    of completeness, in this step, we develop the program to read a file called `mmap_read.cpp`,
    which is very similar to the one we''ve seen. Here, we''ll just see the important
    part (the Docker image contains the complete version of both the reader and the
    writer):'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止所看到的步骤都与使用`mmap`写入文件有关。为了完整起见，在这一步中，我们将开发一个读取名为`mmap_read.cpp`的文件的程序，它与我们之前看到的非常相似。在这里，我们只会看到重要的部分（Docker镜像包含读取器和写入器的完整版本）：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's now learn how to use `mmap` to allocate memory.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习如何使用`mmap`来分配内存。
- en: 'Let''s now allocate memory with `mmap`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用`mmap`分配内存：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Although simple, these two programs show you how to allocate memory and manage
    a file with `mmap`. In the next section, we'll see how it works.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管简单，这两个程序向您展示了如何使用`mmap`分配内存和管理文件。在下一节中，我们将看到它是如何工作的。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the first program, we''ve learned the most common use of `mmap`: to map
    a file to a portion of memory. As almost any resource can be mapped to a file
    in Linux, it means that we can map almost anything to memory with `mmap`. It indeed
    accepts a file descriptor. By compiling and running the `mmap_write.cpp` program
    first, we are able to write a file in memory with a list of integers. The file
    generated will be called `mmapped.txt`. The interesting part is to run the `mmap_read.cpp` reader
    program. Let''s compile and run it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个程序中，我们学习了`mmap`的最常见用法：将文件映射到内存的一部分。由于在Linux中几乎可以将任何资源映射到文件，这意味着我们可以使用`mmap`将几乎任何东西映射到内存中。它确实接受文件描述符。通过首先编译和运行`mmap_write.cpp`程序，我们能够在内存中写入一个整数列表的文件。生成的文件将被命名为`mmapped.txt`。有趣的部分是运行`mmap_read.cpp`读取程序。让我们编译并运行它：
- en: '![](img/04bbe152-7fff-49a6-a27f-fc23edc804d7.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04bbe152-7fff-49a6-a27f-fc23edc804d7.png)'
- en: As we can see, it correctly prints out all the integers from the file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，它正确地从文件中打印出所有的整数。
- en: 'Strictly speaking, `mmap` does not allocate memory in the heap memory, nor
    on the stack. It is a separate memory area, still in the virtual space of the
    process. `munmap` does the inverse: it releases the mapped memory, and flushes
    data to file (this behavior can be controlled with the `msync` system call).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`mmap`并不在堆内存或堆栈上分配内存。它是一个单独的内存区域，仍然在进程的虚拟空间中。`munmap`则相反：它释放映射的内存，并将数据刷新到文件（这种行为可以通过`msync`系统调用来控制）。
- en: 'The second program shows the second use case of `mmap`: Allocating memory in an
    alternative way to `new` and `malloc`. We can see a few differences in the call
    to `mmap`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个程序展示了`mmap`的第二种用法：以一种替代`new`和`malloc`的方式分配内存。我们可以看到在调用`mmap`时有一些不同之处：
- en: '`MAP_PRIVATE`: The modifications are private. Any modification made to the
    memory is not reflected back to the file or to other mappings. The file is mapped
    as copy-on-write.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAP_PRIVATE`：修改是私有的。对内存所做的任何修改都不会反映到文件或其他映射中。文件被映射为写时复制。'
- en: '`MAP_ANONYMOUS`: It indicates that a portion of the memory of size `SIZE` will
    be allocated and not associated with any specific file.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAP_ANONYMOUS`：表示将分配大小为`SIZE`的一部分内存，并且不与任何特定文件关联。'
- en: The fifth parameter we passed `-1` as we want to allocate memory (that is, no
    file descriptor).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们传递了第五个参数`-1`，因为我们想要分配内存（即没有文件描述符）。
- en: 'We allocated 1 KB of memory and used a string. The output is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配了1KB的内存并使用了一个字符串。输出如下：
- en: '![](img/b4a4ef22-fc72-4027-89d9-435480e7b79c.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4a4ef22-fc72-4027-89d9-435480e7b79c.png)'
- en: Likewise, when we deallocate memory with `free` or `delete`, we need to release
    the mapped memory with `munmap`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们使用`free`或`delete`释放内存时，我们需要使用`munmap`释放映射的内存。
- en: There's more...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a few advantages worth mentioning about `mmap`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个值得一提的优点关于`mmap`：
- en: Reading from and writing to a memory-mapped file avoids the copy needed by the
    `read()` and `write()` from the actual file if `mmap` is used with `MAP_SHARED`
    or `MAP_SHARED_VALIDATE` flags. Indeed, when we write a chunk of data to a file,
    a buffer is moved from the user space to the kernel space, and the same is true
    when reading a chunk of data.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内存映射文件读取和写入避免了使用`mmap`与`MAP_SHARED`或`MAP_SHARED_VALIDATE`标志时`read()`和`write()`所需的复制。实际上，当我们向文件写入一块数据时，缓冲区从用户空间移动到内核空间，当读取一块数据时也是如此。
- en: Reading and writing a memory-mapped file turns out to be a simple memory access. A
    memory-mapped file is only read and written in memory; at the `munmap` call, the
    memory is flushed back in the file. This behavior can be controlled by the `MS_SYNC`, `MS_ASYNC`,
    and `MS_INVALIDATE` flag parameters of the `msync` system call.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读写内存映射文件实际上是一个简单的内存访问。内存映射文件只在内存中读写；在`munmap`调用时，内存被刷新回文件。这种行为可以通过`msync`系统调用的`MS_SYNC`、`MS_ASYNC`和`MS_INVALIDATE`标志参数来控制。
- en: Very conveniently, when multiple processes map the same file in memory, the
    data is shared among all the processes (`MAP_SHARED`).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非常方便的是，当多个进程将同一文件映射到内存中时，数据在所有进程之间共享（`MAP_SHARED`）。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Check `man 2 mmap` for more information. Further information can be found in *Linux
    System Programming, Second Edition* by Robert Love.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`man 2 mmap`以获取更多信息。更多信息可以在Robert Love的《Linux系统编程，第二版》中找到。
- en: Dealing with allocators hands-on
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际操作分配器
- en: 'C++ **Standard Template Library** (**STL**) containers are a simple, as well
    as effective, way of managing resources. One huge benefit of containers is that
    they can manage (almost) any type of data. When dealing with system programming,
    though, we may need to provide an alternative way of managing memory for our container.
    Allocators are exactly this: they provide a custom implementation to a container.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: C++ **标准模板库**（**STL**）容器是管理资源的一种简单有效的方式。容器的一个巨大优势是它们可以管理（几乎）任何类型的数据。然而，在处理系统编程时，我们可能需要为容器提供一种替代的内存管理方式。分配器正是这样的：它们为容器提供了自定义实现。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, you''ll learn to implement your own custom allocator (based
    on `mmap`, in this case) to provide to a standard library container (`std::vector`):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习实现自己的自定义分配器（在本例中基于`mmap`）以提供给标准库容器（`std::vector`）：
- en: 'Let''s create an empty allocator template first:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个空的分配器模板：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, there are copy constructor, `allocate`, and `deallocate` methods
    to implement. Let''s implement them one by one (there is no need to implement
    the default constructor, in this case):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，有复制构造函数、`allocate`和`deallocate`方法需要实现。让我们逐一实现它们（在这种情况下不需要实现默认构造函数）：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, implement the `allocate` method:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`allocate`方法：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And finally, implement the `deallocate` method:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`deallocate`方法：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `main` method looks like this:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`方法如下：'
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The use of `std::vector`, as you can see, is seamless from the user's point
    of view. The only difference is to specify which allocator we want to use. This
    container will allocate and deallocate memory, using solely `mmap` and `munmap` and
    not the default implementation, based on `new` and `delete`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用`std::vector`对用户来说是无缝的。唯一的区别是要指定我们想要使用的分配器。这个容器将使用`mmap`和`munmap`来分配和释放内存，而不是基于`new`和`delete`的默认实现。
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The central part of this program is the two methods: `allocate`, which returns
    a pointer representing the memory allocated, and `deallocate`, which takes a pointer
    to the memory to be released.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的核心部分是两个方法：`allocate`，它返回表示分配的内存的指针，和`deallocate`，它接受要释放的内存的指针。
- en: In the first step, we've sketched the interface we're going to use to allocate
    and deallocate the memory. It's a template class, as we want it to be valid for
    any type. The two methods we have to implement, as discussed previously, are `allocate`
    and `deallocate`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们勾画了我们将用于分配和释放内存的接口。它是一个模板类，因为我们希望它对任何类型都有效。正如之前讨论的，我们必须实现的两种方法是`allocate`和`deallocate`。
- en: In the second step, we've developed the copy constructor, which will be called
    when we want to construct an object, passing in the input of an object of the
    same type. We're just returning a `typedef` that will communicate which allocator
    to use for the new object.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们开发了复制构造函数，当我们想要构造一个对象并传入相同类型的对象的输入时，它将被调用。我们只是返回一个`typedef`，它将指定新对象使用的分配器。
- en: In the third step, we've implemented the constructor, which basically allocates
    the space of object `n` of type `T` with `mmap`. We've seen the use of `mmap`
    already in the previous recipe, so you're invited to read that recipe again.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们实现了构造函数，它基本上使用`mmap`为类型为`T`的对象`n`分配空间。我们已经在上一个示例中看到了`mmap`的使用，所以你可以再次阅读那个示例。
- en: In the fourth step, we've implemented the `deallocate` method, which in this
    case is calling the `munmap` method, which deletes the mappings for the specified
    address range.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们实现了`deallocate`方法，这种情况下它调用`munmap`方法，用于删除指定地址范围的映射。
- en: 'Finally, the `main` method shows how to use our custom allocator with `std::vector`
    (it could have been any container—for example, list). In the definition of the
    variable, `mmap_vector`, we pass two parameters: the first one, `int`, to inform
    the compiler that it''ll be a vector of integers, and the second one, `mmap_allocator<int>`,
    to instruct the use of our custom allocator, `mmap_allocator`, instead of the
    default one.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main`方法展示了如何在`std::vector`中使用我们的自定义分配器（也可以是任何容器，例如list）。在变量`mmap_vector`的定义中，我们传递了两个参数：第一个是`int`，用于告诉编译器它将是一个整数向量，第二个是`mmap_allocator<int>`，用于指示使用我们的自定义分配器`mmap_allocator`，而不是默认的分配器。
- en: There's more...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In system programming, there is the concept of a **pool** of (pre-allocated)
    memory that the system reserves upfront and that must be used throughout the life
    of a resource. The `map_allocator` class seen in this recipe can be easily modified
    to pre-allocate a portion of memory in the constructor, and acquire and release
    it from the pool without affecting the system memory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，有一个预先分配的内存**池**的概念，系统预留并且必须在资源的整个生命周期中使用。在这个示例中看到的`map_allocator`类可以很容易地修改为在构造函数中预先分配一部分内存，并且从内存池中获取和释放它，而不影响系统内存。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming* *Language* by Bjarne
    Stroustrup cover these topics in great detail. Refer to the *Dealing with memory-mapped
    I/O* recipe for more details on `mmap`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的《Effective Modern C++》和Bjarne Stroustrup的《The C++ Programming Language》详细介绍了这些主题。有关`mmap`的更多细节，请参阅*处理内存映射I/O*示例。
