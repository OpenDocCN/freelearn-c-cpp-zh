- en: Chapter 06
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章
- en: OOP and Encapsulation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程与封装
- en: There are many great books and articles on the subject of object-oriented programming
    or OOP. But I don't think that many of them address the same topic using a non-OOP
    language such as C! How is that even possible? Are we even able to write object-oriented
    programs with a programming language that has no support for it? To be precise,
    is it possible to write an object-oriented program using C?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于面向对象编程或OOP有很多优秀的书籍和文章。但我认为其中许多并没有使用非OOP语言如C来讨论相同的话题！这是怎么可能的？我们甚至能够使用不支持面向对象的编程语言来编写面向对象的程序吗？更精确地说，使用C语言编写面向对象的程序是可能的吗？
- en: The short answer to the above question is yes, but before explaining how, we
    need to explain why. We need to break the question down and see what OOP really
    means. Why is it possible to write an object-oriented program using a language
    that has no claim for object-orientation support? This seems like a paradox, but
    it's not, and our effort in this chapter is to explain why that's possible and
    how it should be done.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述问题的简短回答是肯定的，但在解释如何之前，我们需要先解释为什么。我们需要将问题分解，看看面向对象编程（OOP）究竟是什么意思。为什么可以使用没有面向对象支持声明的语言来编写面向对象的程序？这似乎是一个悖论，但事实并非如此，我们本章的努力就是要解释这是为什么，以及应该如何去做。
- en: Another question that may puzzle you is that what's the point of having such
    discussions and knowing about OOP when you are going to use C as your primary
    programming language? Almost all existing mature C code bases such as open source
    kernels, implementation of services like HTTPD, Postfix, nfsd, ftpd, and many
    other C libraries such as OpenSSL and OpenCV, are all written in an object-oriented
    fashion. This doesn't mean that C is object-oriented; instead, the approach these
    projects have taken to organize their internal structure comes from an object-oriented
    mindset.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还会让你感到困惑的另一个问题是，当你打算将C语言作为你的主要编程语言时，讨论这些话题和了解面向对象编程（OOP）有什么意义？几乎所有现有的成熟的C代码库，如开源内核、HTTPD、Postfix、nfsd、ftpd等服务实现，以及许多其他C库如OpenSSL和OpenCV，都是用面向对象的方式编写的。这并不意味着C是面向对象的；相反，这些项目组织其内部结构的方法源于面向对象的思想。
- en: I highly recommend reading this chapter together with the next three chapters
    and getting to know more about OOP because firstly, it will enable you to think
    and design like the engineers who have designed the libraries mentioned before,
    and secondly, it would be highly beneficial when reading the sources of such libraries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐您与下一章一起阅读本章，并更多地了解面向对象编程，因为首先，这将使您能够像设计前面提到的库的工程师一样思考和设计，其次，在阅读这些库的源代码时将非常有帮助。
- en: C does not support object-oriented concepts such as classes, inheritance, and
    virtual functions in its syntax. However, it does support object-oriented concepts
    – in an indirect way. In fact, nearly all the computer languages through history
    have supported OOP intrinsically – way before the days of Smalltalk, C++, and
    Java. That's because there must be a way in every general-purpose programming
    language to extend its data types and it is the first step towards OOP.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C语言在其语法中不支持诸如类、继承和虚函数等面向对象的概念。然而，它确实以间接的方式支持面向对象的概念。实际上，几乎历史上所有的通用编程语言都内在地支持面向对象编程——在Smalltalk、C++和Java出现之前。这是因为每个通用编程语言都必须有一种方法来扩展其数据类型，而这正是面向对象的第一步。
- en: C cannot and *should not* support object-oriented features in its syntax; not
    because of its age, but because of very good reasons that we're going to talk
    about in this chapter. Simply put, you can still write an object-oriented program
    using C, but it takes a bit of extra effort to get around the complexity.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C语言不能，也不应该在其语法中支持面向对象的特性；这并非因为它的年代，而是因为我们将在本章中讨论的非常好的理由。简单来说，你仍然可以使用C语言编写面向对象的程序，但需要付出一些额外的努力来克服复杂性。
- en: There are a few books and articles regarding OOP in C, and they usually try
    to create a *type system* for writing classes, implementing inheritance, polymorphism,
    and more, using C. These books look at adding OOP support as a set of functions,
    macros, and a preprocessor, all of which can be used together to write object-oriented
    programs with C. This won't be the approach we take in this chapter. We are not
    going to create a new C++ out of C; instead, we want to speculate how C has the
    potential to be used for OOP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C语言中的OOP有一些书籍和文章，它们通常试图为编写类、实现继承、多态等创建一个*类型系统*，使用C语言来实现。这些书籍将添加OOP支持视为一系列函数、宏和预处理器，所有这些都可以一起使用来用C语言编写面向对象的程序。我们本章不会采取这种方法。我们不会从C中创建一个新的C++；相反，我们想要推测C如何有可能被用于OOP。
- en: It is usually said that OOP is another programming paradigm together with procedural
    and functional paradigms. But OOP is more than that. OOP is more like a way of
    thinking about and analyzing a problem. It is an attitude towards the universe
    and the hierarchy of objects within it. It is part of our ancient, intrinsic,
    and inherited method for comprehending and analyzing the physical and abstract
    entities around us. It is so fundamental to our understanding of nature.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常人们会说，面向对象编程（OOP）是与过程式和函数式编程范式并列的另一种编程范式。但OOP远不止于此。OOP更像是一种思考和分析问题的方法。它是对宇宙及其内部对象层次的一种态度。它是我们古老、内在和继承下来的方法，用于理解和分析我们周围的物理和抽象实体。它对我们理解自然的基本性不言而喻。
- en: We've always thought about every problem from an object-oriented point of view.
    OOP is just about applying the same point of view that humans have always adopted,
    but this time using a programming language to solve a computational problem. All
    this explains why OOP is the most common programming paradigm used for writing
    software.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是从面向对象的角度思考每一个问题。OOP只是将人类一直采用的观点应用到编程语言中，以解决计算问题。所有这些都解释了为什么OOP是编写软件时最常用的编程范式。
- en: This chapter, together with the following three chapters, are going to show
    that any concept within OOP can be implemented in C – even though it might be
    complex to do. We know we can have OOP with C because some people have already
    done it, especially when they created C++ on top of C, and since they have built
    many complex and successful programs in C in an object-oriented fashion.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及接下来的三章将展示，OOP中的任何概念都可以在C语言中实现——即使实现起来可能很复杂。我们知道我们可以用C实现OOP，因为有些人已经做到了，尤其是在他们基于C创建了C++之后，并且他们已经在C中以面向对象的方式构建了许多复杂且成功的程序。
- en: What these chapters are *not* going to suggest is a certain library or set of
    macros that you should use for declaring a class or establishing an inheritance
    relation or working with other OOP concepts. In addition, we won't impose any
    methodology or discipline such as specific naming conventions. We will simply
    use raw C to implement OOP concepts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节不会建议你使用特定的库或宏集来声明类、建立继承关系或处理其他OOP概念。此外，我们也不会强制任何方法或纪律，例如特定的命名约定。我们将简单地使用原始的C语言来实现OOP概念。
- en: The reason why we're dedicating **four whole chapters** to OOP with C is because
    of the heavy theory behind object orientation and the various examples that are
    necessary to be explored in order to demonstrate all of it. Most of the essential
    theory behind OOP is going to be explained in this chapter, while the more practical
    topics will be dealt with in the following chapters. With all that said, we need
    to discuss the theory because the OOP concepts are usually new to most skilled
    C programmers, even those with many years of experience.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以将**整整四章**都用于C语言中的OOP，是因为面向对象背后的理论很重，以及为了展示所有这些内容而必须探索的各种示例。OOP背后的大部分基本理论将在本章中解释，而更实际的话题将在接下来的章节中处理。话虽如此，我们需要讨论理论，因为OOP概念通常对大多数熟练的C程序员来说都是新的，即使是那些有多年经验的人。
- en: 'The upcoming four chapters together cover almost anything that you might come
    across in OOP. In this chapter, we are going to discuss the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四章几乎涵盖了你在OOP中可能会遇到的所有内容。在本章中，我们将讨论以下内容：
- en: First of all, we'll give definitions for the most fundamental terms used in
    OOP literature. We'll define classes, objects, attributes, behaviors, methods,
    domains, and more. These terms will be used heavily throughout these four chapters.
    They are also vital to your understanding of other OOP-related resources because
    they are a staple part of the accepted language of OOP.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将为面向对象文献中最基本的术语给出定义。我们将定义类、对象、属性、行为、方法、域等。这些术语将在接下来的四章中大量使用。它们对于你理解其他面向对象相关资源也是至关重要的，因为它们是面向对象接受的语言的基础部分。
- en: The first part of this chapter is not wholly about terminology; we'll also heavily
    discuss the roots of object orientation and the philosophy behind it, exploring
    the nature of object-oriented thinking.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的第一部分并不完全关于术语；我们还将深入讨论面向对象的根源及其背后的哲学，探讨面向对象思维的本质。
- en: The second section of this chapter is dedicated to C and why it is not, and
    cannot, be object-oriented. This is an important question that should be asked
    and properly answered. This topic will be further discussed in *Chapter 10*, *Unix
    – History and Architecture*, where we will be exploring Unix and its close relationship
    to C.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的第二部分致力于探讨C语言及其为什么不是，以及为什么不能成为面向对象的语言。这是一个应该被提出并得到恰当回答的重要问题。这个话题将在第10章“Unix
    – 历史 和架构”中进一步讨论，我们将探讨Unix及其与C语言的紧密关系。
- en: The third section of this chapter talks about *encapsulation*, which is one
    of the most fundamental concepts of OOP. Put simply, it's what allows you to create
    objects and use them. The fact that you can put variables and methods inside an
    object comes directly from encapsulation. This is discussed thoroughly in the
    third section, and several examples are given.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的第三部分讨论了*封装*，这是面向对象最基本的概念之一。简单来说，它允许你创建对象并使用它们。你可以在对象内部放置变量和方法的事实直接来自封装。这一点在第三部分中进行了详细讨论，并给出了几个示例。
- en: The chapter then moves on to *information-hiding*, which is something of a side
    effect (though a very important one) of having encapsulation. Without information-hiding,
    we wouldn't be able to isolate and decouple software modules, and we'd effectively
    be unable to provide implementation-independent APIs to clients. This is the last
    thing we discuss as part of this chapter.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后这一章转向*信息隐藏*，这是封装的一个副作用（尽管非常重要）。没有信息隐藏，我们就无法隔离和解除软件模块的耦合，并且我们实际上无法向客户提供实现无关的API。这是本章最后讨论的内容。
- en: As mentioned, the whole topic will cover four chapters, with the following chapters
    picking up from the *composition* relationship. From there, the upcoming chapters
    will cover *aggregation*, *inheritance*, *polymorphism*, *abstraction*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，整个主题将涵盖四章，接下来的章节将基于*组合*关系展开。从那里开始，接下来的章节将涵盖*聚合*、*继承*、*多态*、*抽象*。
- en: In this chapter, though, we'll start with the theory behind OOP and look at
    how we can extract an object model from our thought process regarding a software
    component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，尽管如此，我们将从面向对象（OOP）的理论开始，探讨如何从我们对软件组件的思考过程中提取对象模型。
- en: Object-oriented thinking
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象思维
- en: As we said in the chapter introduction, object-oriented thinking is the way
    in which we break down and analyze what surrounds us. When you're looking at a
    vase on a table, you're able to understand that the vase and the table are separate
    objects without any heavy analysis.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在章节介绍中所说，面向对象思维是我们分解和分析周围事物的方式。当你看着桌子上的一只花瓶时，你能够理解花瓶和桌子是独立的对象，而不需要进行任何深入的分析。
- en: Unconsciously, you are aware that there is a border between them that separates
    them. You know that you could change the color of the vase, and the color of the
    table would remain unchanged.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无意识地，你意识到它们之间存在一个边界，将它们分开。你知道你可以改变花瓶的颜色，而桌子的颜色将保持不变。
- en: These observations show us that we view our environment from an object-oriented
    perspective. In other words, we are just creating a reflection of the surrounding
    object-oriented reality in our minds. We also see this a lot in computer games,
    3D modeling software, and engineering software, all of which can entail many objects
    interacting with each other.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观察结果表明，我们从面向对象的视角看待我们的环境。换句话说，我们只是在脑海中创建周围面向对象现实的反映。我们也在计算机游戏、3D建模软件和工程软件中看到很多这种情况，所有这些都可以涉及许多对象之间的相互交互。
- en: OOP is about bringing object-oriented thinking to software design and development.
    Object-oriented thinking is our default way of processing our surroundings, and
    that's why OOP has become the most commonly used paradigm for writing software.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是将面向对象思维应用于软件设计和开发。面向对象思维是我们处理周围环境的方式，这就是为什么面向对象编程成为了编写软件最常用的范式。
- en: Of course, there are problems that would be hard to solve if you go with the
    object-oriented approach, and they would have been analyzed and resolved easier
    if you chose another paradigm, but these problems can be considered relatively
    rare.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你采用面向对象的方法，有些问题可能会很难解决，如果你选择了另一种范式，这些问题可能会更容易被分析和解决，但这些问题的出现相对较少。
- en: In the following sections, we are going to find out more about the translation
    of object-oriented thinking into writing object-oriented code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将了解更多关于将面向对象思维转化为面向对象代码的翻译。
- en: Mental concepts
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 心理概念
- en: 'You''d be hard-pressed to find a program that completely lacks at least some
    traces of object-oriented thinking, even if it had been written using C or some
    other non-OOP language. If a human writes a program, it will be naturally object-oriented.
    This will be evident even just in the variable names. Look at the following example.
    It declares the variables required to keep the information of 10 students:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你很难找到一个完全不包含至少一些面向对象思维痕迹的程序，即使它是用C或某些其他非面向对象语言编写的。如果人类编写程序，它将自然地是面向对象的。这甚至可以从变量名中看出。看看以下例子。它声明了保存10名学生信息的所需变量：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 6-1: Four arrays related by having the student_ prefix, according
    to a naming convention, supposed to keep the information of 10 students'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 6-1：四个通过具有学生_前缀相关联的数组，根据命名约定，旨在保存10名学生的信息
- en: 'The declarations found in *Code Box 6-1* show how we use variable names to
    group some variables under the same concept, which in this case is the *student*.
    We have to do this; else we would get confused by ad hoc names that don''t make
    any sense to our object-oriented minds. Suppose that we had something such as
    this instead:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在*代码框 6-1*中找到的声明显示了我们是怎样使用变量名将一些变量归入同一概念下的，在这个例子中是*学生*。我们必须这样做；否则，我们会因为那些对我们面向对象思维来说没有意义的临时命名而感到困惑。假设我们有如下这样的东西：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 6-2: Four arrays with ad hoc names supposed to keep the information
    of 10 students!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 6-2：四个具有特定名称的数组，旨在保存10名学生的信息！
- en: Using such variable names as seen in *Code Box 6-2*, however much experience
    in programming you have, you must admit that you'd have a lot of trouble dealing
    with this when writing an algorithm. Variable naming is – and has always been
    – important, because the names remind us of the concepts in our mind and the relationships
    between data and those concepts. By using this kind of ad hoc naming, we lose
    those concepts and their relationships in the code. This may not pose an issue
    for the computer, but it complicates the analysis and troubleshooting for us programmers
    and increases the likelihood of us making mistakes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如*代码框 6-2*中所示的那种变量名，无论你有多少编程经验，你必须承认在编写算法时你会遇到很多麻烦。变量命名一直很重要，因为名字提醒我们心中的概念以及数据与这些概念之间的关系。通过使用这种临时命名，我们在代码中失去了这些概念及其关系。这可能对计算机来说不是问题，但它会复杂化我们程序员的分析和故障排除，并增加我们犯错的几率。
- en: Let's clarify more about what we mean by a concept in our current context. A
    concept is a mental or abstract image that exists in the mind as a thought or
    an idea. A *concept* could be formed by the perception of a real-world entity
    or could simply be entirely imaginary and abstract. When you look at a tree or
    when you think about a car, their corresponding images come to mind as two different
    concepts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下在我们当前语境中我们所说的“概念”是什么。概念是一种存在于心中的心理或抽象图像，它以思想或想法的形式存在。一个*概念*可能是由对现实世界实体的感知形成的，也可能完全是虚构和抽象的。当你看一棵树或思考一辆车时，它们相应的图像作为两个不同的概念出现在你的脑海中。
- en: Note that sometimes we use the term concept in a different context, such as
    in "object-oriented concepts," which obviously doesn't use the word concept in
    the same way as the definition we just gave. The word concept, used in relation
    to technology-related topics, simply refers to the principles to understand regarding
    a topic. For now, we'll use this technology-related definition.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有时我们在不同的语境中使用“概念”这个术语，例如在“面向对象的概念”中，显然这个“概念”一词的使用方式与我们刚才给出的定义并不相同。在与技术相关的话题中使用的“概念”一词，简单来说是指理解某个主题所需的原则。目前，我们将使用这个与技术相关的定义。
- en: Concepts are important to object-oriented thinking because if you cannot form
    and maintain an understanding of objects in your mind, you cannot extract details
    about what they represent and relate to, and you cannot understand their interrelations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 概念对于面向对象思维非常重要，因为如果你不能在心中形成并维持对对象的了解，你就不能提取关于它们所代表和关联的细节，也不能理解它们之间的关系。
- en: So, object-oriented thinking is about thinking in terms of concepts and their
    relationships. It follows, then, that if you want to write a proper object-oriented
    program, you need to have a proper understanding of all the relevant objects,
    their corresponding concepts, and also their relationships, in your mind.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，面向对象思维是关于以概念及其关系为前提的思考。由此可以推断，如果你想编写一个合适的面向对象程序，你需要在你心中对所有的相关对象、它们对应的概念以及它们之间的关系有一个恰当的理解。
- en: An object-oriented map formed in your mind, which consists of many concepts
    and their mutual interrelations, cannot be easily communicated to others, for
    instance when approaching a task as a team. More than that, such mental concepts
    are volatile and elusive, and they can get forgotten very easily. This also puts
    an extra emphasis on the fact that you will need models and other tools for representation,
    in order to translate your mind map into communicable ideas.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在你心中形成的面向对象地图，由许多概念及其相互关系组成，不能轻易地传达给他人，例如在作为一个团队处理任务时。更重要的是，这种心理概念是易变的、难以捉摸的，并且很容易被遗忘。这也额外强调了这样一个事实，即你需要模型和其他工具来进行表示，以便将你的思维导图转化为可传达的想法。
- en: Mind maps and object models
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思维导图和对象模型
- en: 'In this section, we look at an example to understand further what we''ve been
    discussing so far. Suppose that we have a written description of a scene. The
    purpose of describing something is to communicate the related specific concepts
    to the audience. Think of it this way: the one who is describing has a map in
    their mind that lays out various concepts and how they all link together; their
    aim is to communicate that mind map to the audience. You might say that this is
    more or less the goal of all artistic expression; it is actually what''s happening
    when you look at a painting, listen to a piece of music, or read a novel.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过一个例子来进一步理解我们之前讨论的内容。假设我们有一个场景的书面描述。描述某物的目的是向观众传达相关的具体概念。可以这样想：描述者心中有一张地图，上面描绘了各种概念以及它们如何相互联系；他们的目标是向观众传达这张思维导图。你可以说，这基本上是所有艺术表达的目标；实际上，当你看一幅画、听一首音乐或读一本小说时，这正是发生的事情。
- en: 'Now we are going to look at a written description. It describes a classroom.
    Relax your mind and try to imagine what you are reading about. Everything you
    see in your mind is a concept communicated by the following description:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将来看一个书面描述。它描述了一个教室。放松你的心情，尽量想象你所读到的内容。你心中所看到的一切都是以下描述传达的概念：
- en: '*Our classroom is an old room with two big windows. When you enter the room,
    you can see the windows on the opposite wall. There are a number of brown wooden
    chairs in the middle of the room. There are five students sitting on the chairs,
    and two of them are boys. There is a green, wooden blackboard on the wall to your
    right, and the teacher is talking to the students. He is an old man wearing a
    blue shirt.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的教室是一个老旧的房间，有两扇大窗户。当你进入房间时，你可以看到对面墙上的窗户。房间中间有一些棕色的木椅。有五个学生坐在椅子上，其中两个是男孩。你右边墙上有一块绿色的木制黑板，老师正在和学生交谈。他是一位穿着蓝色衬衫的老人。*'
- en: Now, let's see what concepts have formed in our minds. Before we do that though,
    bear in mind that your imagination can run away without you noticing. So, let's
    do our best to limit ourselves to the boundaries of the description. For example,
    I could imagine more and say that the girls are blonde. But that is not mentioned
    in the description, so we won't take that into account. In the next paragraph,
    I explain what has been shaped in my mind, and before continuing, you should also
    try to do that for yourself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在我们心中形成了哪些概念。不过，在我们这样做之前，请记住，你的想象力可能会在你没有注意到的情况下失控。所以，让我们尽力限制自己在这个描述的范围内。例如，我可以想象更多，比如说女孩们是金发的。但是描述中没有提到这一点，所以我们不会考虑这一点。在下一段中，我将解释在我心中形成了什么，在继续之前，你也应该尝试为自己做同样的事情。
- en: In my mind, there are five concepts (or mental images, or objects), one for
    each student in the class. There are also another five concepts for the chairs.
    There is another concept for the wood and another one for the glass. And I know
    that every chair is made from wood. This is a relationship, between the concept
    of wood and the concepts of the chairs. In addition, I know that every student
    is sitting on a chair. As such, there are five relationships – between chairs
    and students. We could continue to identify more concepts and relate them. In
    no time, we'd have a huge and complex graph describing the relationships of hundreds
    of concepts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我心中，有五个概念（或心理图像，或对象），每个学生一个。还有五个概念用于椅子。还有一个概念用于木头，另一个概念用于玻璃。我知道每把椅子都是由木头制成的。这是一个关系，在木头概念和椅子概念之间。此外，我知道每个学生都坐在椅子上。因此，有五个关系——在椅子和学生之间。我们可以继续识别更多概念并将它们联系起来。很快，我们就会有一个描述数百个概念之间关系的巨大且复杂的图。
- en: Now, pause for a moment and see how differently you were extracting the concepts
    and their relationships. That's a lesson that everyone can do this in a different
    way. This procedure also happens when you want to solve a particular problem.
    You need to create a mind map before attacking the problem. This is the phase
    that we call the *understanding phase*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，暂停一下，看看你如何不同地提取概念及其关系。这是一个每个人都可以以不同方式完成的教训。当你想要解决特定问题时，这个过程也会发生。你需要在对问题发起攻击之前创建一个思维导图。这是我们称之为*理解阶段*的阶段。
- en: You solve a problem using an approach that is based on the concepts of the problem
    and the relationships you find between them. You explain your solution in terms
    of those concepts, and if someone wants to understand your solution, they should
    understand the concepts and their relationships first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用基于问题概念及其之间关系的途径来解决问题。你用这些概念来解释你的解决方案，如果有人想理解你的解决方案，他们首先应该理解这些概念及其关系。
- en: You'd be surprised if I told you this is what exactly happens when you try to
    solve a problem using a computer, but that is exactly the case. You break the
    problem into objects (same as the concepts in a mental context) and the relationships
    between them, and then you try to write a program, based on those objects, that
    eventually resolves the problem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，当你尝试使用计算机解决问题时，这正是所发生的事情，你可能会感到惊讶，但这正是实际情况。你将问题分解为对象（与心理环境中的概念相同）以及它们之间的关系，然后尝试编写一个基于这些对象的程序，最终解决问题。
- en: The program that you write simulates the concepts and their relations as you
    have them in your mind. The computer runs the solution, and you can verify whether
    it works. You are still the person who solves the problem, but now a computer
    is your colleague, since it can execute your solution, which is now described
    as a series of machine-level instructions translated from your mind map, much
    faster and more accurately.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你所编写的程序模拟了你心中所拥有的概念及其关系。计算机运行解决方案，你可以验证它是否有效。你仍然是解决问题的那个人，但现在一台计算机是你的同事，因为它可以执行你的解决方案，这个解决方案现在被描述为一系列从你的思维导图中翻译出来的机器级指令，执行得更快、更准确。
- en: An object-oriented program simulates concepts in terms of objects, and while
    we create a mind map for a problem in our minds, the program creates an object
    model in its memory. In other words, the terms *concept*, *mind*, and *mind map*
    are equivalent to *object*, *memory*, and *object model* respectively, if we are
    going to compare a human with an object-oriented program. This is the most important
    correlation we offer in this section, which relates the way we think to an object-oriented
    program.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的程序通过对象来模拟概念，当我们在大脑中为问题创建思维导图时，程序在其内存中创建一个对象模型。换句话说，如果我们把人类与面向对象的程序进行比较，那么术语*概念*、*思维*和*思维导图*分别等同于*对象*、*内存*和*对象模型*。这是我们在这个部分提供的重要关联，它将我们的思维方式与面向对象程序联系起来。
- en: But why are we using computers to simulate our mind maps? Because computers
    are good when it comes to speed and precision. This is a very classic answer to
    such questions, but it is still a relevant answer to our question. Creating and
    maintaining a big mind map and the corresponding object model is a complex task
    and is one that computers can do very well. As another advantage, the object model
    created by a program can be stored on a disk and used later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们为什么使用计算机来模拟我们的思维导图呢？因为计算机在速度和精度方面很擅长。这是一个非常经典的回答，但对我们的问题来说仍然是一个相关的回答。创建和维护一个大的思维导图及其相应的对象模型是一项复杂的任务，而计算机可以非常出色地完成这项任务。作为另一个优点，程序创建的对象模型可以存储在磁盘上并在以后使用。
- en: 'A mind map can be forgotten or altered by emotions, but computers are emotionless,
    and object models are far more robust than human thoughts. That''s why we should
    write object-oriented programs: to be able to transfer the concepts of our minds
    to effective programs and software.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 思维导图可能会因为情绪而遗忘或改变，但计算机没有情绪，对象模型比人类思维更加健壮。这就是我们为什么要编写面向对象的程序：能够将我们思维中的概念转移到有效的程序和软件中。
- en: '**Note**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: So far, nothing has been invented that can download and store a mind map from
    someone's mind – but perhaps in the future!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有发明出可以从某人的思维中下载和存储思维导图的东西——但也许在将来会！
- en: Objects are not in code
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象不在代码中
- en: If you look at the memory of a running object-oriented program, you'll find
    it full of objects, all of which are interrelated. That's the same for humans.
    If you consider a human as a machine, you could say that they are always up and
    running until they die. Now, that's an important analogy. Objects can only exist
    in a running program, just as concepts can only exist in a living mind. That means
    you have objects only when you have a running program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一个运行中的面向对象程序的内存，你会发现它充满了对象，它们都是相互关联的。对人类来说也是如此。如果你把人类看作是一部机器，你可以说他们总是处于运行状态，直到他们去世。这是一个重要的类比。对象只能存在于运行程序中，就像概念只能存在于活着的思维中。这意味着只有当你有一个运行程序时，你才有对象。
- en: This may look like a paradox because when you are writing a program (an object-oriented
    one), the program doesn't yet exist and so cannot be running! So, how can we write
    object-oriented code when there is no running program and no objects?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个悖论，因为当你编写一个程序（面向对象的程序）时，程序还不存在，所以不能运行！那么，在没有运行程序和没有对象的情况下，我们如何编写面向对象的代码呢？
- en: '**Note**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: When you are writing object-oriented code, no object exists. The objects are
    created once you build the code into an executable program and run it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写面向对象的代码时，没有任何对象存在。只有当你将代码构建成可执行的程序并运行它时，对象才会被创建。
- en: OOP is not actually about creating objects. It is about creating a set of instructions
    that will lead to a fully dynamic object model when the program is run. So, the
    object-oriented code should be able to create, modify, relate, and even delete
    objects, once compiled and run.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）实际上并不是关于创建对象。它是在程序运行时，创建一系列指令，这些指令将导致一个完全动态的对象模型。因此，面向对象的代码应该能够在编译和运行后创建、修改、关联甚至删除对象。
- en: As such, writing object-oriented code is a tricky task. You need to imagine
    the objects and their relations before they exist. This is exactly the reason
    why OOP can be complex and why we need a programming language that supports object-orientation.
    The art of imagining something which is not yet created and describing or engineering
    its various details is usually called *design*. That's why this process is usually
    called **object-oriented design** (**OOD**) in object-oriented programming.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编写面向对象代码是一项棘手的任务。在对象存在之前，你需要想象对象及其关系。这正是面向对象可能变得复杂，以及我们需要支持面向对象的编程语言的原因。想象尚未创造的事物并描述或设计其各种细节的艺术通常被称为*设计*。这就是为什么这个过程通常被称为**面向对象设计**（**OOD**）的原因。
- en: In object-oriented code, we only plan to create objects. OOP leads to a set
    of instructions for when and how an object should be created. Of course, it is
    not only about creation. All the operations regarding an object can be detailed
    using a programming language. An OOP language is a language that has a set of
    instructions (and grammar rules) that allow you to write and plan different object-related
    operations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象代码中，我们只计划创建对象。面向对象编程导致了一系列关于何时以及如何创建对象的指令。当然，这不仅仅关于创建。所有关于对象的操作都可以使用编程语言详细说明。面向对象编程语言是一种具有一系列指令（和语法规则）的语言，允许你编写和计划不同的与对象相关的操作。
- en: So far, we've seen that there is a clear correspondence between concepts in
    the human mind and objects in a program's memory. So, there should be a correspondence
    between the operations that can be performed on concepts and objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到人类心智中的概念与程序内存中的对象之间存在明显的对应关系。因此，对概念和对象可以执行的操作之间也应该存在对应关系。
- en: Every object has a dedicated life cycle. This is also true for concepts in the
    mind. At some point, an idea comes to mind and creates a mental image as a concept,
    and at some other point, it fades away. The same is true for objects. An object
    is constructed at one point and is destructed at another time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个专属的生命周期。这一点也适用于心中的概念。在某个时刻，一个想法出现在脑海中，并作为一个概念形成心理图像，而在另一个时刻，它逐渐消失。对于对象来说也是如此。对象在某个时刻被构建，在另一个时刻被销毁。
- en: As a final note, some mental concepts are very firm and constant (as opposed
    to volatile and transient concepts which come and go). It seems that these concepts
    are independent of any mind and have been in existence even when there were no
    minds to comprehend them. They are mostly mathematical concepts. The number 2
    is an example. We have only one number 2 in the whole universe! That's amazing.
    It means that you and I have the very same concept in our minds of the number
    2; if we tried to change it, it would no longer be the number 2\. This is exactly
    where we leave the object-oriented realm, and we step into another realm, full
    of immutable objects, that is described under the title of the *functional programming*
    paradigm.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要注意的是，一些心理概念非常坚定和稳定（与波动和短暂的概念相对，这些概念来去不定）。似乎这些概念与任何心智无关，即使在没有心智去理解它们的时候就已经存在。它们大多是数学概念。数字2就是一个例子。整个宇宙中只有一个数字2！这真是太神奇了。这意味着你和我心中对数字2的概念是完全相同的；如果我们试图改变它，它就不再是数字2了。这正是我们离开面向对象领域的时刻，我们进入另一个领域，充满了不可变对象，这被描述在*函数式编程*范式标题下。
- en: Object attributes
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象属性
- en: Each concept in any mind has some attributes associated with it. If you remember,
    in our classroom description, we had a chair, named *chair1*, that was brown.
    In other words, every chair object has an attribute called color and it was brown
    for the *chair1* object. We know that there were four other chairs in the classroom,
    and they had their color attributes which could have different values. In our
    description, all of them were brown, but it could be that in another description,
    one or two of them were yellow.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 任何心智中的每个概念都与一些属性相关联。如果你记得，在我们的教室描述中，我们有一个名为*chair1*的椅子，它是棕色的。换句话说，每个椅子对象都有一个名为颜色的属性，对于*chair1*对象来说它是棕色。我们知道教室里还有四把其他的椅子，它们有自己的颜色属性，可能具有不同的值。在我们的描述中，它们都是棕色的，但可能在另一个描述中，其中一把或两把是黄色的。
- en: An object can have more than one attribute or a set of attributes. We call the
    values assigned to these attributes, collectively, the *state* of an object. The
    state can be thought of simply as a list of values, each one belonging to a certain
    attribute, attached to an object. An object can be modified during its lifetime.
    Such an object is said to be *mutable*. This simply means that the state can be
    changed during its lifetime. Objects can also be *stateless*, which means that
    they don't carry any state (or any attributes).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以有一个或多个属性或一组属性。我们将分配给这些属性值的总和称为对象的**状态**。状态可以简单地被视为一个值列表，每个值属于某个特定的属性，并附加到对象上。对象在其生命周期内可以被修改。这样的对象被称为**可变的**。这仅仅意味着状态可以在其生命周期内被改变。对象也可以是**无状态的**，这意味着它们不携带任何状态（或任何属性）。
- en: An object can be *immutable* as well, exactly like the concept (or object) corresponding
    to the number 2, which cannot be altered — being immutable means that the state
    is determined upon construction and cannot be modified after that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象也可以是**不可变的**，就像对应于数字2的概念（或对象）一样，不能被改变——不可变意味着状态在构造时确定，之后不能被修改。
- en: '**Note**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: A stateless object can be thought of as an immutable object because its state
    cannot be changed throughout its lifetime. In fact, it has no state to be changed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将无状态对象视为不可变对象，因为它的状态在其整个生命周期内不能被改变。实际上，它没有任何状态可以改变。
- en: As a final note, immutable objects are especially important. The fact that their
    state cannot be altered is an advantage, especially when they are shared in a
    multithreaded environment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，不可变对象特别重要。它们的状态不能被改变的事实是一个优势，尤其是在它们在多线程环境中共享时。
- en: Domain
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域
- en: Every program written to solve a particular problem, even an exceedingly small
    one, has a well-defined domain. Domain is another big term that is used widely
    in the literature of software engineering. The domain defines the boundaries in
    which software exhibits its functionality. It also defines the requirements that
    software should address.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编写来解决特定问题（即使是极其微小的问题）的程序都有一个定义明确的领域。领域是另一个在软件工程文献中广泛使用的术语。领域定义了软件展示其功能边界的范围。它还定义了软件应该解决的问题的要求。
- en: A domain uses a specific and predetermined terminology (glossary) to deliver
    its mission and have engineers stay within its boundaries. Everyone participating
    in a software project should be aware of the domain in which their project is defined.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个领域使用特定的和预定的术语（词汇表）来传达其使命并使工程师保持在它的边界内。参与任何软件项目的每个人都应该意识到他们的项目定义的领域。
- en: As an example, banking software is usually built for a very well-defined domain.
    It has a set of well-known terms as its glossary which includes account, credit,
    balance, transfer, loan, interest, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，银行软件通常是为一个非常明确的领域构建的。它有一组作为其词汇表的已知术语，包括账户、信用、余额、转账、贷款、利息等等。
- en: The definition of a domain is made clear by the terms found in its glossary;
    you wouldn't find the terms patient, medicine, and dosage in the banking domain,
    for instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 领域的定义通过其词汇表中的术语变得清晰；例如，在银行领域，你不会找到患者、药品和剂量的术语。
- en: If a programming language doesn't provide facilities for working with the concepts
    specific to a given domain (such as the concepts of patients and medicines in
    the healthcare domain), it would be difficult to write the software for that domain
    using that programming language – not impossible, but certainly complex. Moreover,
    the bigger the software is, the harder it becomes to develop and maintain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一种编程语言不提供处理特定领域（如医疗保健领域的患者和药品概念）的特定概念的功能（设施），那么使用该编程语言编写该领域的软件将会很困难——并非不可能，但肯定很复杂。此外，软件越大，开发和维护就越困难。
- en: Relations among objects
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象之间的关系
- en: Objects can be inter-related; they can refer to each other to denote relationships.
    For example, as part of our classroom description, the object *student4* (the
    fourth student) might be related to the object *chair3* (the third chair) in regard
    to a relationship named *sitting on*. In other words, *student4* sits on *chair3*.
    This way, all objects within a system refer to each other and form a network of
    objects called an object model. As we've said before, an object model is the correspondent
    of the mind map that we form in our minds.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以相互关联；它们可以相互引用以表示关系。例如，作为我们课堂描述的一部分，对象 *student4*（第四个学生）可能与对象 *chair3*（第三个椅子）在名为
    *sitting on* 的关系上相关联。换句话说，*student4* 坐在 *chair3* 上。这样，系统中的所有对象都相互引用，形成一个称为对象模型的网络。正如我们之前所说的，对象模型是我们心中形成的思维导图的对应物。
- en: When two objects are related, a change in the state of one might affect the
    state of the other. Let's explain this by giving an example. Suppose that we have
    two unrelated objects, `p1` and `p2`, representing pixels.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个对象相关联时，一个对象状态的变化可能会影响另一个对象的状态。让我们通过一个例子来解释这一点。假设我们有两个无关的对象 `p1` 和 `p2`，代表像素。
- en: 'Object `p1` has a set of attributes as follows: `{x: 53, y: 345, red: 120,
    green: 45, blue: 178}`. Object `p2` has the attributes `{x: 53, y: 346, red: 79,
    green: 162, blue: 23}`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '对象 `p1` 的属性如下所示：`{x: 53, y: 345, red: 120, green: 45, blue: 178}`。对象 `p2` 的属性为
    `{x: 53, y: 346, red: 79, green: 162, blue: 23}`。'
- en: '**Note:**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: The notation we used is almost but not quite the same as **JavaScript Object
    Notation** or **JSON**. In this notation, the attributes of an individual object
    are embraced within two curly braces, and the attributes are separated by commas.
    Each attribute has a corresponding value separated from the attribute by a colon.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的符号几乎与 **JavaScript 对象表示法** 或 **JSON** 完全相同，但略有不同。在这个符号中，单个对象的属性被两个大括号包围，并且属性之间用逗号分隔。每个属性都有一个与它分开的值，由冒号分隔。
- en: 'Now, in order to make them related, they need to have an extra attribute to
    denote the relationship between themselves. The state of object `p1` would change
    to `{x: 53, y: 345, red: 120, green: 45, blue: 178, adjacent_down_pixel: p2}`,
    and that of `p2` would change to `{x: 53, y: 346, red: 79, green: 162, blue: 23,
    adjacent_up_pixel: p1}`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，为了使它们相关联，它们需要有一个额外的属性来表示它们之间的关系。对象 `p1` 的状态将变为 `{x: 53, y: 345, red: 120,
    green: 45, blue: 178, adjacent_down_pixel: p2}`，而 `p2` 的状态将变为 `{x: 53, y: 346,
    red: 79, green: 162, blue: 23, adjacent_up_pixel: p1}`。'
- en: The `adjacent_down_pixel` and `adjacent_up_pixel` attributes denote the fact
    that these pixel objects are adjacent; their `y` attributes differ only by 1 unit.
    Using such extra attributes, the objects realize that they are in a relationship
    with other objects. For instance, `p1` knows that its `adjacent_down_pixel` is
    `p2`, and `p2` knows that its `adjacent_up_pixel` is `p1`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjacent_down_pixel` 和 `adjacent_up_pixel` 属性表示这些像素对象是相邻的；它们的 `y` 属性仅相差 1
    个单位。使用这些额外的属性，对象意识到它们与其他对象之间存在关系。例如，`p1` 知道它的 `adjacent_down_pixel` 是 `p2`，而 `p2`
    知道它的 `adjacent_up_pixel` 是 `p1`。'
- en: So, as we can see, if a relationship is formed between two objects, the states
    of those objects (or the lists of the values corresponding to their attributes)
    are changed. So, the relationship among objects is created by adding new attributes
    to them and because of that, the relationship becomes part of the objects' states.
    This, of course, has ramifications for the mutability or immutability of these objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们所看到的，如果两个对象之间形成关系，这些对象的状态（或对应于它们属性的值列表）将发生变化。因此，通过向它们添加新属性来创建对象之间的关系，这使得关系成为对象状态的一部分。这当然对这些对象的可变性和不可变性有影响。
- en: Note that the subset of the attributes which define the state and immutability
    of an object can be changed from a domain to another, and it doesn't necessarily
    encompass all the attributes. In one domain, we might use only non-referring attributes
    (`x`, `y`, `red`, `green`, and `blue`, in the preceding example) as the state
    and in another domain, we might combine them all together with referring attributes
    (`adjacent_up_pixel` and `adjacent_down_pixel` in the preceding example).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，定义对象状态和不可变性的属性子集可以从一个域更改为另一个域，并且不一定包含所有属性。在一个域中，我们可能只使用非引用属性（如前例中的 `x`、`y`、`red`、`green`
    和 `blue`）作为状态，而在另一个域中，我们可能将它们与引用属性（如前例中的 `adjacent_up_pixel` 和 `adjacent_down_pixel`）一起组合。
- en: Object-oriented operations
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象操作
- en: An OOP language allows us to plan the object construction, object destruction,
    and altering the states of an object in a soon-to-be-running program. So, let's
    start by looking at the object construction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程语言允许我们在即将运行的程序中计划对象的构建、对象的销毁以及改变对象的状态。因此，让我们首先看看对象的构建。
- en: '**Note:**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: The term *construction* has been chosen carefully. We could use creation or
    building, but these terms are not accepted as part of the standard terminology
    in OOP literature. Creation refers to the memory allocation for an object, while
    construction means the initialization of its attributes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“构建”是经过精心选择的。我们本可以使用“创建”或“构建”，但这些术语在面向对象编程文献的标准术语中并不被接受。创建指的是为对象分配内存，而构建则意味着初始化其属性。
- en: 'There are two ways to plan the construction of an object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 计划对象的构建有两种方式：
- en: The first approach involves either constructing an empty object – one *without*
    any attributes in its state – or, more commonly, an object with a set of minimum
    attributes.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法涉及构建一个空对象——一个在其状态中没有任何属性的*无属性*对象——或者更常见的是，具有一组最小属性的对象。
- en: More attributes will be determined and added as the code is being run. Using
    this method, the same object can have different attributes in two different executions
    of the same program, in accordance with the changes found in the surrounding environment.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着代码的运行，将确定并添加更多属性。使用这种方法，同一个对象在不同的程序执行中可能会有不同的属性，这取决于周围环境的变化。
- en: Each object is treated as a separate entity, and any two objects, even if they
    seem to belong to the same group (or class), by having a list of common attributes,
    may get different attributes in their states as the program continues.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象都被视为一个独立的实体，任何两个对象，即使它们看起来属于同一个组（或类），由于它们具有共同属性列表，在程序继续执行时，它们的状态可能会有不同的属性。
- en: 'As an example, the already mentioned pixel objects `p1` and `p2` are both pixels
    (or they both belong to the same class named `pixel`) because they have the same
    attributes – `x`, `y`, `red`, `green`, and `blue`. After forming a relationship,
    they would have different states because they then have new and different attributes:
    `p1` has the `adjacent_down_pixel` attribute, and `p2` has the `adjacent_up_pixel`
    attribute.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，已经提到的像素对象`p1`和`p2`都是像素（或者它们都属于名为`pixel`的同一类），因为它们具有相同的属性——`x`、`y`、`red`、`green`和`blue`。在建立关系后，它们会有不同的状态，因为它们那时具有新的和不同的属性：`p1`有`adjacent_down_pixel`属性，而`p2`有`adjacent_up_pixel`属性。
- en: This approach is used in programming languages such as JavaScript, Ruby, Python,
    Perl, and PHP. Most of them are *interpreted programming languages*, and the attributes
    are kept as a *map* (or a *hash*) in their internal data structures that can be
    easily changed at runtime. This technique is usually called **prototype-based
    OOP**.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法用于JavaScript、Ruby、Python、Perl和PHP等编程语言。其中大部分是**解释型编程语言**，它们的属性被保留为内部数据结构中的**映射**（或**散列**），可以轻松地在运行时更改。这种技术通常被称为**基于原型的面向对象编程**。
- en: The second approach involves constructing an object whose attributes are predetermined
    and won't change in the middle of execution. No more attributes are allowed to
    be added to such an object at runtime, and the object will retain its structure.
    Only the values of the attributes are allowed to change, and that's possible only
    when the object is mutable.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法涉及构建一个其属性预先确定且在执行过程中不会改变的实体。不允许在运行时向此类对象添加更多属性，并且对象将保持其结构。仅允许属性的值发生变化，而这种变化仅在对象可变时才可能发生。
- en: To apply this approach, a programmer should create a predesigned *object template*
    or *class* that keeps track of all the attributes that need to be present in the
    object at runtime. Then, this template should be compiled and fed into the object-oriented
    language at runtime.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要应用这种方法，程序员应该创建一个预设计的**对象模板**或**类**，该模板跟踪在运行时需要存在于对象中的所有属性。然后，这个模板应该被编译并在运行时输入到面向对象的语言中。
- en: In many programming languages, this object template is called a class. Programming
    languages such as Java, C++, and Python use this term to denote their object templates.
    This technique is usually known as **class-based OOP**. Note that Python supports
    both prototype-based and class-based OOP.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多编程语言中，这种对象模板被称为类。例如，Java、C++和Python等编程语言使用这个术语来表示它们的对象模板。这种技术通常被称为**基于类的面向对象编程**。请注意，Python支持基于原型和基于类的面向对象编程。
- en: '**Note:**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: A class only determines the list of attributes present in an object but not
    the actual values assigned to them at runtime.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类仅确定对象中存在的属性列表，但并不确定在运行时分配给它们的实际值。
- en: Note that an object and an *instance* are the same thing, and they can be used
    interchangeably. However, in some texts, there might be some slight differences
    between them. There is also another term, *reference*, which is worth mentioning
    and explaining. The term object or instance is used to refer to the actual place
    allocated in the memory for the values of that object, while a reference is like
    a pointer that refers to that object. So, we can have many references referring
    to the same object. Generally speaking, an object usually has no name, but a reference
    does have a name.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对象和*实例*是同一件事，它们可以互换使用。然而，在某些文本中，它们之间可能存在一些细微的差异。还有一个术语，*引用*，值得提及并解释。术语对象或实例用于指代该对象值的实际内存分配位置，而引用就像一个指向该对象的指针。因此，我们可以有许多引用指向同一个对象。一般来说，对象通常没有名称，但引用确实有名称。
- en: '**Note:**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: In C, we have pointers as the corresponding syntax for references. We also have
    both Stack objects and Heap objects. A Heap object does not have a name and we
    use pointers to refer to it. In contrast, a Stack object is actually a variable
    and hence has a name.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，我们有指针作为引用的对应语法。我们还有栈对象和堆对象。堆对象没有名称，我们使用指针来引用它。相比之下，栈对象实际上是一个变量，因此有一个名称。
- en: While it is possible to use both approaches, C and especially C++ are officially
    designed in a way to support the class-based approach. Therefore, when a programmer
    wants to create an object in C or C++, they need to have a class first. We will
    talk more about the class and its role in OOP in future sections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用这两种方法，但C和特别是C++官方设计的方式是为了支持基于类的构造方法。因此，当程序员想在C或C++中创建一个对象时，他们首先需要有一个类。我们将在未来的章节中更多地讨论类及其在面向对象编程中的作用。
- en: The following discussion might seem a bit unrelated, but, in fact, it isn't.
    There are two schools of thought regarding how humans grow through life, and they
    match quite accurately the object construction approaches that we've talked about.
    One of these philosophies says that the human is empty at birth and has no essence
    (or state).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下讨论可能看起来有些不相关，但实际上并非如此。关于人类如何通过生活成长，有两种不同的观点，它们与我们讨论过的对象构造方法非常吻合。其中一种哲学认为，人类出生时是空无一物的，没有本质（或状态）。
- en: By living and experiencing different good and bad events in life, their essence
    starts to grow and evolves into something that has an independent and mature character.
    *Existentialism* is a philosophical tradition that promotes this idea.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在生活中经历不同的好事和坏事，他们的本质开始成长并发展成为一个具有独立和成熟性格的东西。*存在主义*是一种哲学传统，它推广了这个观点。
- en: Its famous precept is "Existence precedes essence". This simply means that the
    human first comes to existence and then gains their essence through life experience.
    This idea is awfully close to our prototype-based approach to object construction,
    in which the object is constructed empty and then evolves at runtime.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它著名的格言是“存在先于本质”。这简单意味着人类首先来到存在，然后通过生活经验获得他们的本质。这个想法与我们的基于原型的对象构造方法非常接近，在这种方法中，对象是空无一物地构造的，然后在运行时发展。
- en: The other philosophy is older and is promoted mostly by religions. In this,
    the human is created based on an image (or an essence), and this image has been
    determined before the human comes to exist. This is most similar to the way in
    which we plan to construct an object based on a template or class. As the object
    creators, we prepare a class, and then a program starts to create objects according
    to that class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种哲学更古老，主要是由宗教推广的。在这种观点中，人类是根据一个形象（或本质）创造的，而这个形象在人类存在之前就已经确定。这与我们计划根据模板或类来构造对象的方式非常相似。作为对象创造者，我们准备一个类，然后程序开始根据该类创建对象。
- en: '**Note:**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: There has been a great correspondence between the approaches that people in
    novels or stories, including both literature and history sources, take to overcome
    a certain difficulty and the algorithms we have designed in computer science to
    solve similar problems. I deeply believe that the way humans live and the reality
    they experience are in great harmony with what we understand about algorithms
    and data structures as part of computer science. The preceding discussion was
    a great example of such harmony between OOP and Philosophy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 小说或故事中的人物，包括文学和历史资料中的人物，在克服某种困难时所采取的方法与我们在计算机科学中为解决类似问题而设计的算法之间存在很大的对应关系。我深信人类的生活方式和他们所经历的现实与我们对计算机科学中算法和数据结构的理解之间存在着极大的和谐。前面的讨论就是这种OOP与哲学之间和谐的一个很好的例子。
- en: Like object construction, object destruction happens at runtime; we have only
    the power to plan it in code. All resources allocated by an object throughout
    its lifetime should be released when it is destroyed. When an object is being
    destructed, all other related objects should be changed so that they no longer
    refer to the destroyed object. An object shouldn't have an attribute that refers
    to a non-existent object, otherwise we lose the *referential integrity* in our
    object model. It can lead to runtime errors such as memory corruption or segmentation
    fault, as well as logical errors such as miscalculations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象构造类似，对象销毁发生在运行时；我们只能在代码中规划它。对象在其整个生命周期中分配的所有资源都应该在销毁时释放。当一个对象正在被销毁时，所有其他相关对象都应该被更改，以便它们不再引用被销毁的对象。一个对象不应该有引用一个不存在对象的属性，否则我们就会在我们的对象模型中失去*引用完整性*。这可能导致运行时错误，如内存损坏或段错误，以及逻辑错误，如计算错误。
- en: Modifying an object (or altering the state of an object) can happen in two different
    ways. It could simply be either a change in the value of an existing attribute
    or it could be the addition or removal of an attribute to/from the set of attributes
    in that object. The latter can only happen if we have chosen the prototype-based
    approach to object construction. Remember that altering the state of an object
    that is immutable is forbidden and usually, it is not permitted by an object-oriented
    language.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 修改对象（或改变对象的状态）可以通过两种不同的方式发生。它可能是现有属性值的改变，也可能是向该对象的属性集中添加或从集中移除属性。后者只有在选择了基于原型的对象构造方法时才能发生。记住，改变不可变对象的状态是被禁止的，通常面向对象的语言也不允许这样做。
- en: Objects have behaviors
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象具有行为
- en: Every object, together with its attributes, has a certain list of functionalities
    that it can perform. For instance, a car object is able to speed up, slow down,
    turn, and so on. In OOP, these functionalities are always in accordance with the
    domain requirements. For example, in a banking object model, a client can order
    a new account but cannot eat. Of course, the client is a person and can eat, but
    as long as eating functionality is not related to the banking domain, we don't
    consider it as a necessary functionality for a client object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象，连同其属性，都有它能够执行的一定列表的功能。例如，汽车对象能够加速、减速、转弯等。在面向对象编程（OOP）中，这些功能总是符合领域需求。例如，在银行对象模型中，客户可以订购新账户，但不能吃饭。当然，客户是人，可以吃饭，但只要吃饭功能与银行领域无关，我们就不会将其视为客户对象的一个必要功能。
- en: Every functionality is able to change the state of an object by altering the
    values of its attributes. As a simple example, a car object can accelerate. Acceleration
    is a functionality of the car object, and by accelerating, the speed of the car,
    which is one of its attributes, changes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个功能都能通过改变其属性的值来改变对象的状态。作为一个简单的例子，一辆汽车对象可以加速。加速是汽车对象的一个功能，通过加速，汽车的速度，即其属性之一，发生了变化。
- en: In summary, an object is simply a group of attributes and functionalities. In
    the later sections, we'll talk more about how to put these things together in
    an object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，对象仅仅是一组属性和功能。在后面的章节中，我们将更多地讨论如何将这些事物组合成一个对象。
- en: So far, we have explained the fundamental terminology needed to study and understand
    OOP. The next step is to explain the fundamental concept of encapsulation. But,
    as a break, let's read about why C cannot be an OOP language.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了研究和理解面向对象编程（OOP）所需的基本术语。下一步是解释封装的基本概念。但是，作为一个休息，让我们了解一下为什么C语言不能成为面向对象的语言。
- en: C is not object-oriented, but why?
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C语言不是面向对象的，但为什么？
- en: C is not object-oriented, but not because of its age. If age was a reason, we
    could have found a way to make it object-oriented by now. But, as you will see
    in *Chapter 12*, *The Most Recent C*, the latest standard of the C programming
    language, C18, doesn't try to make C an object-oriented language.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C不是面向对象的，但这并不是因为它的年龄。如果年龄是原因，我们到现在应该已经找到了一种方法使其成为面向对象的语言。但是，正如你将在第12章“最新的C”中看到的那样，C编程语言的最新标准C18并不试图将C变成面向对象的语言。
- en: On the other hand, we have C++, which is the result of all efforts to have an
    OOP language based on C. If the fate of C was for it to be replaced by an object-oriented
    language, then there wouldn't be any demand for C today, mainly because of C++
    – but the current demand for C engineers shows that this is not the case.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有C++，它是基于C的所有努力以实现面向对象语言的结果。如果C的命运是它被面向对象的语言所取代，那么今天就不会有任何对C的需求了，这主要是因为C++——但当前对C工程师的需求表明情况并非如此。
- en: A human thinks in an object-oriented way, but a CPU executes machine-level instructions
    which are procedural. A CPU just executes a set of instructions one by one, and
    from time to time, it has to jump, fetch, and execute other instructions from
    a different address in memory; quite similar to function calls in a program written
    using a procedural programming language like C.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 人类以面向对象的方式思考，但CPU执行的是机器级指令，这些指令是过程式的。CPU只是依次执行一系列指令，并且时不时地需要跳转、从内存中的不同地址获取并执行其他指令；这与使用像C这样的过程式编程语言编写的程序中的函数调用非常相似。
- en: C cannot be object-oriented because it is located on the barrier between object
    orientation and procedural programming. Object orientation is the human understanding
    of a problem and procedural execution is what a CPU can do. Therefore, we need
    something to be in this position and make this barrier. Otherwise high-level programs,
    which are usually written in an object-oriented way, cannot be translated directly
    into procedural instructions to be fed into the CPU.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: C不能成为面向对象的语言，因为它位于面向对象和过程式编程之间的障碍上。面向对象是人类对问题的理解，而过程式执行是CPU能够执行的操作。因此，我们需要某种东西处于这个位置并形成这个障碍。否则，通常以面向对象方式编写的程序无法直接转换为过程式指令以供CPU执行。
- en: If you look at high-level programming languages like Java, JavaScript, Python,
    Ruby, and so on, they have a component or layer within their architecture which
    bridges between their environment and the actual C library found inside the operating
    system (the Standard C Library in Unix-like systems and Win32 API in Windows systems).
    For instance, **Java Virtual Machine** (**JVM**) does that in a Java platform.
    While not all these environments are necessarily object-oriented (for example
    JavaScript or Python can be both procedural and object-oriented), they need this
    layer to translate their high-level logic to low-level procedural instructions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看像Java、JavaScript、Python、Ruby等高级编程语言，它们在其架构中都有一个组件或层，它介于它们的运行环境与操作系统内部实际找到的C库（Unix-like系统中的标准C库和Windows系统中的Win32
    API）之间。例如，**Java虚拟机**（**JVM**）在Java平台上就是这样做的。虽然并非所有这些环境都是必然面向对象的（例如JavaScript或Python可以是过程式和面向对象的），但它们需要这个层来将它们的高级逻辑转换为低级过程式指令。
- en: Encapsulation
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: In the previous sections, we saw that each object has a set of attributes and
    a set of functionalities attached to it. Here, we are going to talk about putting
    those attributes and functionalities into an entity called an object. We do this
    through a process called *encapsulation*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了每个对象都有一组属性和一组与之相关的功能。在这里，我们将讨论将这些属性和功能放入一个称为对象的实体中。我们通过一个称为“封装”的过程来完成这件事。
- en: Encapsulation simply means putting related things together into a *capsule*
    that represents an object. It happens first in your mind, and then it should be
    transferred to the code. The moment that you feel an object needs to have some
    attributes and functionalities, you are doing encapsulation in your mind; that
    encapsulation then needs to be transferred to the code level.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 封装简单地说就是将相关的事物放在一起，形成一个代表对象的“胶囊”。这首先发生在你的脑海中，然后应该转移到代码中。当你觉得一个对象需要有一些属性和功能时，你就在脑海中进行了封装；然后这个封装需要转移到代码层面。
- en: It is crucial to be able to encapsulate things in a programming language, otherwise
    keeping related variables together becomes an untenable struggle (we mentioned
    using naming conventions to accomplish this).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在编程语言中封装事物至关重要，否则将相关变量放在一起将变得难以承受（我们提到了使用命名约定来完成这一点）。
- en: An object is made from a set of attributes and a set of functionalities. Both
    of these should be encapsulated into the object capsule. Let's first talk about
    *attribute encapsulation*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是由一组属性和一组功能组成的。这两者都应该封装到对象胶囊中。让我们首先谈谈*属性封装*。
- en: Attribute encapsulation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性封装
- en: 'As we saw before, we can always use variable names to do encapsulation and
    tie different variables together and group them under the same object. Following
    is an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们总是可以使用变量名来进行封装，将不同的变量绑定在一起并将它们分组在同一个对象下。以下是一个例子：
- en: '[PRE2]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 6-3: Some variables representing two pixels grouped by their names'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框6-3：一些按名称分组的代表两个像素的变量
- en: This example clearly shows how variable names are used to group variables under
    `p1` and `p2`, which somehow are *implicit* objects. By implicit, we mean that
    the programmer is the only one who is aware of the existence of such objects;
    the programming language doesn't know anything about them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子清楚地说明了变量名是如何用来将变量分组在`p1`和`p2`下的，它们在某种程度上是*隐式*对象。通过隐式，我们是指程序员是唯一一个意识到这些对象存在的人；编程语言对它们一无所知。
- en: The programming language only sees 10 variables that seem to be independent
    of each other. This would be a very low level of encapsulation, to such an extent
    that it would not be officially considered as encapsulation. Encapsulation by
    variable names exists in all programming languages (because you can name variables),
    even in an assembly language.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言只看到10个似乎彼此独立的变量。这将是一个非常低级的封装，低到它甚至不会被正式认为是封装。通过变量名进行封装存在于所有编程语言中（因为你可以命名变量），即使在汇编语言中也是如此。
- en: What we need are approaches offering *explicit* encapsulation. By explicit,
    we mean that both the programmer and the programming language are aware of the
    encapsulation and the capsules (or objects) that exist. Programming languages
    that do not offer explicit *attribute encapsulation* are very hard to use.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是提供*显式*封装的方法。通过显式，我们是指程序员和编程语言都意识到封装以及存在的胶囊（或对象）。不提供显式*属性封装*的编程语言很难使用。
- en: Fortunately, C does offer explicit encapsulation, and that's one of the reasons
    behind why we are able to write so many intrinsically object-oriented programs
    with it more or less easily. On the other hand, as we see shortly in the next
    section, C doesn't offer explicit behavior encapsulation, and we have to come
    up with an implicit discipline to support this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C确实提供了显式封装，这也是我们能够相对容易地用C编写许多固有的面向对象程序的原因之一。另一方面，正如我们在下一节中将要看到的，C没有提供显式行为封装，我们必须提出一种隐式纪律来支持这一点。
- en: Note that having an explicit feature such as encapsulation in a programming
    language is always desired. Here, we only spoke about encapsulation, but this
    can be extended to many other object-oriented features, such as inheritance and
    polymorphism. Such explicit features allow a programming language to catch relevant
    errors at compile time instead of runtime.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在编程语言中拥有像封装这样的显式特性总是受欢迎的。在这里，我们只讨论了封装，但这可以扩展到许多其他面向对象特性，例如继承和多态。这样的显式特性允许编程语言在编译时而不是运行时捕获相关错误。
- en: Resolving errors at runtime is a nightmare, and so we should always try to catch
    errors at compile time. This is the main advantage of having an object-oriented
    language, which is completely aware of the object-oriented way of our thinking.
    An object-oriented language can find and report errors and violations in our design
    at compile time and keep us from having to resolve many severe bugs at runtime.
    Indeed, this is the reason why we are seeing more complex programming languages
    every day – to make everything explicit to the language.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时解决错误是一场噩梦，因此我们应始终尝试在编译时捕获错误。这是面向对象语言的主要优势，它完全了解我们的面向对象思维方式。面向对象语言可以在编译时找到并报告我们设计中的错误和违规，从而避免我们在运行时解决许多严重错误。事实上，这正是我们每天看到更多复杂编程语言的原因——让一切对语言来说都是明确的。
- en: Unfortunately, not all object-oriented features are explicit in C. That's basically
    why it is hard to write an object-oriented program with C. But there are more
    explicit features in C++ and, indeed, that's why it is called an object-oriented
    programming language.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C中并非所有面向对象特性都是显式的。这基本上是为什么用C编写面向对象程序很难的原因。但C++中有更多显式特性，确实，这也是它被称为面向对象编程语言的原因。
- en: 'In C, structures offer encapsulation. Let''s change the code inside *Code Box
    6-3*, and rewrite it using structures:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，结构提供了封装。让我们改变 *代码框 6-3* 中的代码，并使用结构来重写它：
- en: '[PRE3]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 6-4: The pixel_t structure and declaring two pixel_t variables'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 6-4：`pixel_t` 结构和声明两个 `pixel_t` 变量
- en: 'There are some important things to note regarding *Code Box 6-4*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 *代码框 6-4* 有几点需要注意：
- en: The attribute encapsulation happens when we put the `x`, `y`, `red`, `green`,
    and `blue` attributes into a new type, `pixel_t`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性封装发生在我们将 `x`、`y`、`red`、`green` 和 `blue` 属性放入一个新的类型 `pixel_t` 中时。
- en: Encapsulation always creates a new type; attribute encapsulation does this particularly
    in C. This is very important to note. In fact, this is the way that we make encapsulation
    explicit. Please note the `_t` suffix at the end of the `pixel_t`. It is very
    common in C to add the `_t` suffix to the end of the name of new types, but it
    is not mandatory. We use this convention throughout this book.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装总是创建一个新的类型；在 C 语言中，属性封装尤其如此。这一点非常重要，实际上，这是我们使封装显式化的方式。请注意 `pixel_t` 末尾的 `_t`
    后缀。在 C 语言中，通常会在新类型的名称末尾添加 `_t` 后缀，但这不是强制的。我们在这本书中一直使用这个约定。
- en: '`p1` and `p2` will be our explicit objects when this code is executed. Both
    of them are of the `pixel_t` type, and they have only the attributes dictated
    by the structure. In C, and especially C++, types dictate the attributes to their
    objects.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当这段代码执行时，`p1` 和 `p2` 将是我们的显式对象。它们都是 `pixel_t` 类型，并且只有结构中指定的属性。在 C 语言中，尤其是 C++
    中，类型决定了它们的对象的属性。
- en: The new type, `pixel_t`, is only the attributes of a class (or the object template).
    The word "class," remember, refers to a template of objects containing both attributes
    and functionalities. Since a C structure only keeps attributes, it cannot be a
    counterpart for a class. Unfortunately, we have no counterpart concept for a class
    in C; attributes and functionalities exist separately, and we implicitly relate
    them to each other in the code. Every class is implicit to C and it refers to
    a single structure together with a list of C functions. You'll see more of this
    in the upcoming examples, as part of this chapter and the future chapters.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新类型 `pixel_t` 只是一个类的属性（或对象模板）。记住，“类”这个词指的是包含属性和功能的对象模板。由于 C 结构只保留属性，它不能作为类的对应物。不幸的是，在
    C 语言中我们没有类的对应概念；属性和功能是分开存在的，我们在代码中隐式地将它们关联起来。每个类在 C 语言中都是隐式的，它指的是一个结构以及一系列 C 函数。你将在接下来的例子中看到更多关于这一点的内容，这是本章以及未来章节的一部分。
- en: As you see, we are constructing objects based on a template (here, the structure
    of `pixel_t`), and the template has the predetermined attributes that an object
    should have at birth. Like we said before, the structure only stores attributes
    and not the functionalities.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如你所见，我们正在基于一个模板（这里是指 `pixel_t` 的结构）构建对象，并且模板具有对象在出生时应该拥有的预定义属性。就像我们之前说的那样，结构只存储属性而不存储功能。
- en: 'Object construction is very similar to the declaration of a new variable. The
    type comes first, then the variable name (here the object name) after that. While
    declaring an object, two things happen almost at the same time: first the memory
    is allocated for the object (creation), and then, the attributes are initialized
    (construction) using the default values. In the preceding example, since all attributes
    are integers, the default integer value in C is going to be used which is 0.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象构造与声明新变量的声明非常相似。首先是类型，然后是变量名（在这里是对象名）。在声明对象时，几乎同时发生两件事：首先为对象分配内存（创建），然后使用默认值初始化属性（构造）。在上面的例子中，由于所有属性都是整数，C
    语言中的默认整数值将是 0。
- en: In C and many other programming languages, we use a dot (`.`) to access an attribute
    inside an object, or an arrow (`->`) while accessing the attributes of a structure
    indirectly through its address stored in a pointer. The statement `p1.x` (or `p1->x`
    if `p1` is a pointer) should be read as *the x attribute in the p1 object*.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C 语言和许多其他编程语言中，我们使用点 (`.`) 来访问对象内的属性，或者使用箭头 (`->`) 来通过存储在指针中的地址间接访问结构的属性。语句
    `p1.x`（如果 `p1` 是指针，则为 `p1->x`）应读作 *p1 对象中的 x 属性*。
- en: As you know by now, attributes are certainly not the only things that can be
    encapsulated into objects. Now it is time to see how functionalities are encapsulated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，属性当然不是唯一可以封装到对象中的东西。现在我们来看看功能是如何封装的。
- en: Behavior encapsulation
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为封装
- en: An object is simply a capsule of attributes and methods. The method is another
    standard term that we usually use to denote a piece of logic or functionality
    being kept in an object. It can be considered as a C function that has a name,
    a list of arguments, and a return type. Attributes convey *values* and methods
    convey *behaviors*. Therefore, an object has a list of values and can perform
    certain behaviors in a system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只是一个属性和方法胶囊。方法是我们通常用来表示保存在对象中的逻辑或功能的标准术语。它可以被认为是一个具有名字、参数列表和返回类型的C函数。属性传达*值*，方法传达*行为*。因此，一个对象有一系列值，可以在系统中执行某些行为。
- en: 'In class-based object-oriented languages such as C++, it is very easy to group
    a number of attributes and methods together in a class. In prototype-based languages
    such as JavaScript, we usually start with an empty object (*ex nihilo*, or "from
    nothing") or clone from an existing object. To have behaviors in the object, we
    need to add methods. Look at the following example, which helps you gain an insight
    into how prototype-based programming languages work. It is written in JavaScript:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于类的面向对象语言，如C++中，将多个属性和方法组合到一个类中非常容易。在基于原型的语言，如JavaScript中，我们通常从一个空对象（*ex nihilo*，或“无中生有”）或从现有对象克隆开始。为了在对象中拥有行为，我们需要添加方法。看看以下例子，它有助于你了解原型编程语言是如何工作的。它是用JavaScript编写的：
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 6-5: Constructing a client object in JavaScript'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框6-5：在JavaScript中构造客户端对象
- en: As you see in this example, on the 2nd line, we create an empty object. In the
    following two lines, we add two new attributes, `name` and `surname`, to our object.
    And on the following line, we add a new method, `orderBankAccount`, which points
    to a function definition. This line is an assignment actually. On the right-hand
    side is an *anonymous function*, which does not have a name and is assigned to
    the `orderBankAccount` attribute of the object, on the left-hand side. In other
    words, we store a function into the `orderBankAccount` attribute. On the last
    line, the object's method `orderBankAccount` is called. This example is a great
    demonstration of prototype-based programming languages, which only rely on having
    an empty object at first and nothing more.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，在第2行，我们创建了一个空对象。在接下来的两行中，我们向我们的对象添加了两个新属性，`name`和`surname`。然后在下一行，我们添加了一个新的方法，`orderBankAccount`，它指向一个函数定义。这一行实际上是一个赋值操作。在右侧是一个*匿名函数*，它没有名字，被分配给了左侧对象的`orderBankAccount`属性。换句话说，我们将一个函数存储到了`orderBankAccount`属性中。在最后一行，调用了对象的`orderBankAccount`方法。这个例子是原型编程语言的优秀演示，这些语言最初只依赖于一个空对象，没有更多。
- en: 'The preceding example would be different in a class-based programming language.
    In these languages, we start by writing a class because without having a class,
    we can''t have any object. The following code box contains the previous example
    but written in C++:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于类的编程语言中，前面的例子会有所不同。在这些语言中，我们首先编写一个类，因为没有类，我们就不能有任何对象。下面的代码框包含了之前的例子，但用C++编写：
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 6-6: Constructing the client object in C++'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框6-6：在C++中构造客户端对象
- en: As you see, we started by declaring a new class, `Client`. On the 1st line,
    we declared a class, which immediately became a new C++ type. It resembles a capsule
    and is surrounded by braces. After declaring the class, we constructed the object
    `clientObj` from the `Client` type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们首先声明了一个新的类，`Client`。在第1行，我们声明了一个类，它立即成为了一个新的C++类型。它类似于一个胶囊，被大括号包围。在声明类之后，我们从`Client`类型构造了`clientObj`对象。
- en: On the following lines, we set the attributes, and finally, we called the `orderBankAccount`
    method on the `clientObj` object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，我们设置了属性，最后，我们在`clientObj`对象上调用了`orderBankAccount`方法。
- en: '**Note:**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: In C++, methods are usually called *member functions* and attributes are called
    *data members*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++这样的基于类的面向对象语言中，方法通常被称为*成员函数*，属性被称为*数据成员*。
- en: If you look at the techniques employed by open source and well-known C projects
    in order to encapsulate some items, you notice that there is a common theme among
    them. In the rest of this section, we are going to propose a behavior encapsulation
    technique which is based on the similar techniques observed in such projects.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察开源和知名的C项目所采用的封装某些项目的技术，你会发现它们之间有一个共同的主题。在本节的剩余部分，我们将提出一种基于此类项目中观察到的类似技术的行为封装技术。
- en: Since we'll be referring back to this technique often, I'm going to give it
    a name. We call this technique **implicit encapsulation**. It's implicit because
    it doesn't offer an explicit behavior encapsulation that C knows about. Based
    on what we've got so far in the ANSI C standard, it is not possible to let C know
    about classes. So, all techniques that try to address object orientation in C
    have to be implicit.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们经常会回溯到这个技术，我将给它起一个名字。我们称这个技术为**隐式封装**。它是隐式的，因为它不提供C语言所知的明确的行为封装。基于ANSI C标准中我们目前所拥有的内容，我们无法让C语言知道类。因此，所有试图在C语言中实现面向对象技术的技术都必须是隐式的。
- en: 'The implicit encapsulation technique suggests the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式封装技术建议以下内容：
- en: Using C structures to keep the attributes of an object (explicit attribute encapsulation).
    These structures are called **attribute structures**.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C结构来保存对象的属性（显式属性封装）。这些结构被称为**属性结构**。
- en: For behavior encapsulation, C functions are used. These functions are called
    **behavior functions**. As you might know, we cannot have functions in structures
    in C. So, these functions have to exist outside the attribute structure (implicit
    behavior encapsulation).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于行为封装，使用C函数。这些函数被称为**行为函数**。正如你可能知道的，在C语言的结构中我们不能有函数。因此，这些函数必须存在于属性结构之外（隐式行为封装）。
- en: Behavior functions must accept a structure pointer as one of their arguments
    (usually the first argument or the last one). This pointer points to the attribute
    structure of the object. That's because the behavior functions might need to read
    or modify the object's attributes, which is very common.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为函数必须接受一个结构指针作为它们的参数之一（通常是第一个或最后一个参数）。这个指针指向对象的属性结构。这是因为行为函数可能需要读取或修改对象的属性，这是非常常见的。
- en: Behavior functions should have proper names to indicate that they are related
    to the same class of objects. That's why sticking to a consistent naming convention
    is very important when using this technique. This is one of the two naming conventions
    that we try to stick to in these chapters in order to have a clear encapsulation.
    The other one is using `_t` suffix in the names of the attribute structures. However,
    of course, we don't force them and you can use your own custom naming conventions.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为函数应该有合适的名字来表明它们与同一类对象相关。这就是为什么在使用这个技术时坚持一致的命名约定非常重要。这是我们在这几章中试图坚持的两个命名约定之一，以便实现清晰的封装。另一个是在属性结构的名称中使用`_t`后缀。然而，当然，我们并不强迫这样做，你可以使用你自己的自定义命名约定。
- en: The declaration statements corresponding to the behavior functions are usually
    put in the same header file that is used for keeping the declaration of the attribute
    structure. This header is called the **declaration header**.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应于行为函数的声明语句通常放在用于保持属性结构声明的同一个头文件中。这个头文件被称为**声明头文件**。
- en: The definitions of the behavior functions are usually put in one or various
    separate source files which include the declaration header.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为函数的定义通常放在一个或多个单独的源文件中，这些源文件包括声明头文件。
- en: Note that with implicit encapsulation, classes do exist, but they are implicit
    and known only to the programmer. The following example, *example 6.1*, shows
    how to use this technique in a real C program. It is about a car object that accelerates
    until it runs out of fuel and stops.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在隐式封装中，类确实存在，但它们是隐式的，只有程序员知道。以下示例*示例6.1*展示了如何在真实的C程序中使用这种技术。它是一个关于汽车对象，直到耗尽燃料并停止加速的例子。
- en: 'The following header file, as part of *example 6.1*, contains the declaration
    of the new type, `car_t`, which is the attribute structure of the `Car` class.
    The header also contains the declarations required for the behavior functions
    of the `Car` class. We use the phrase "the `Car` class" to refer to the implicit
    class that is missing from the C code and it encompasses collectively the attribute
    structure and the behavior functions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下头文件作为*示例6.1*的一部分，包含了新类型`car_t`的声明，它是`Car`类的属性结构。该头文件还包含了`Car`类行为函数所需的声明。我们使用“`Car`类”这个短语来指代C代码中缺失的隐式类，它集体包括了属性结构和行为函数：
- en: '[PRE6]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 6-7 [ExtremeC_examples_chapter6_1.h]: The declarations of the attribute
    structure and the behavior functions of the Car class'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框6-7 [ExtremeC_examples_chapter6_1.h]：Car类的属性结构和行为函数的声明
- en: As you see, the attribute structure `car_t` has three fields – `name`, `speed`,
    and `fuel` – which are the attributes of the car object. Note that `car_t` is
    now a new type in C, and we can now declare variables of this type. The behavior
    functions are also usually declared in the same header file, as you can see in
    the preceding code box. They start with the `car_` prefix to put emphasis on the
    fact that all of them belong to the same class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，属性结构`car_t`有三个字段——`name`、`speed`和`fuel`——它们是汽车对象的属性。请注意，`car_t`现在是一个新的C语言类型，我们现在可以声明此类类型的变量。行为函数通常也声明在同一个头文件中，正如你可以在前面的代码框中看到的那样。它们以`car_`前缀开头，以强调它们都属于同一个类。
- en: 'Something very important regarding the implicit encapsulation technique: each
    object has its own unique attribute structure variable, but all objects share
    the same behavior functions. In other words, we have to create a dedicated variable
    from the attribute structure type for each object, but we only write behavior
    functions once and we call them for different objects.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于隐式封装技术的一个重要事项：每个对象都有自己的唯一属性结构变量，但所有对象共享相同的行为函数。换句话说，我们必须为每个对象从属性结构类型创建一个专用变量，但我们只编写一次行为函数，并为不同的对象调用它们。
- en: Note that the `car_t` attribute structure is not a class itself. It only contains
    the attributes of the `Car` class. The declarations all together make the implicit
    `Car` class. You'll see more examples of this as we go on.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`car_t`属性结构本身不是一个类。它只包含`Car`类的属性。所有声明共同构成了隐式的`Car`类。随着我们的深入，你会看到更多这样的例子。
- en: 'There are many famous open source projects that use the preceding technique
    to write semi-object-oriented code. One example is `libcurl`. If you have a look
    at its source code, you will see a lot of structures and functions starting with
    `curl_`. You can find the list of such functions here: [https://curl.haxx.se/libcurl/c/allfuncs.html](https://curl.haxx.se/libcurl/c/allfuncs.html).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多著名的开源项目使用前面的技术来编写半面向对象的代码。一个例子是`libcurl`。如果你查看它的源代码，你会看到很多以`curl_`开头的结构和函数。你可以在这里找到此类函数的列表：[https://curl.haxx.se/libcurl/c/allfuncs.html](https://curl.haxx.se/libcurl/c/allfuncs.html)。
- en: 'The following source file contains the definitions of the behavior functions
    as part of example 6.1:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源文件包含了作为示例6.1一部分的行为函数的定义：
- en: '[PRE7]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code Box 6-8 [ExtremeC_examples_chapter6_1.c]: The definitions of the behavior
    functions as part of the Car class'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框6-8 [ExtremeC_examples_chapter6_1.c]：作为`Car`类一部分的行为函数的定义
- en: The `Car`'s behavior functions are defined in *Code Box 6-8*. As you can see,
    all the functions accept a `car_t` pointer as their first argument. This allows
    the function to read and modify the attributes of an object. If a function is
    not receiving a pointer to an attribute structure, then it can be considered as
    an ordinary C function that does not represent an object's behavior.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`的行为函数在*代码框6-8*中定义。正如你所见，所有这些函数都接受一个`car_t`指针作为它们的第一个参数。这允许函数读取和修改对象的属性。如果一个函数没有接收属性结构的指针，那么它可以被认为是一个普通的C函数，它不表示对象的任何行为。'
- en: Note that the declarations of behavior functions are usually found next to the
    declarations of their corresponding attribute structure. That's because the programmer
    is the sole person in charge of maintaining the correspondence of the attribute
    structure and the behavior functions, and the maintenance should be easy enough.
    That's why keeping these two sets close together, usually in the same header file,
    helps in maintaining the overall structure of the class, and eases the pain for
    future efforts.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，行为函数的声明通常位于它们对应的属性结构声明旁边。这是因为程序员是负责维护属性结构和行为函数之间对应关系的唯一人员，维护应该是足够简单的。这就是为什么将这两组保持在一起，通常在同一个头文件中，有助于维护类的整体结构，并减轻未来工作的痛苦。
- en: 'In the following code box, you''ll find the source file that contains the `main`
    function and performs the main logic. All the behavior functions will be used
    here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码框中，你会找到包含`main`函数和执行主要逻辑的源文件。所有行为函数都将在这里使用：
- en: '[PRE8]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 6-9 [ExtremeC_examples_chapter6_1_main.c]: The main function of example
    6.1'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框6-9 [ExtremeC_examples_chapter6_1_main.c]：示例6.1的主函数
- en: As the first instruction in the `main` function, we've declared the `car` variable
    from the `car_t` type. The variable `car` is our first `car` object. On this line,
    we have allocated the memory for the object's attributes. On the following line,
    we constructed the object. Now on this line, we have initialized the attributes.
    You can initialize an object only when there is memory allocated for its attributes.
    In the code, the constructor accepts a second argument as the car's name. You
    may have noticed that we are passing the address of the `car` object to all `car_*`
    behavior functions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`main`函数中的第一条指令，我们已从`car_t`类型声明了`car`变量。变量`car`是我们第一个`car`对象。在这一行，我们为对象的属性分配了内存。在下一行，我们构建了对象。现在在这一行，我们初始化了属性。你只能在为对象的属性分配了内存的情况下初始化对象。在代码中，构造函数接受第二个参数作为汽车的名字。你可能已经注意到，我们将`car`对象的地址传递给了所有的`car_*`行为函数。
- en: Following that in the `while` loop, the `main` function reads the `fuel` attribute
    and checks whether its value is greater than zero. The fact that the `main` function,
    which is not a behavior function, is able to access (read and write) the `car`'s
    attributes is an important thing. The `fuel` and `speed` attributes, for instance,
    are examples of *public* attributes, which functions (external code) other than
    the behavior functions can access. We will come back to this point in the next
    section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环之后，`main`函数读取`fuel`属性并检查其值是否大于零。事实上，`main`函数，作为一个非行为函数，能够访问（读取和写入）`car`的属性，这是一个重要的事情。例如，`fuel`和`speed`属性是*公共*属性的例子，除了行为函数之外的其他函数（外部代码）也可以访问。我们将在下一节回到这个点。
- en: Before leaving the `main` function and ending the program, we've destructed
    the `car` object. This simply means that resources allocated by the object have
    been released at this phase. Regarding the `car` object in this example, there
    is nothing to be done for its destruction, but it is not always the case and destruction
    might have steps to be followed. We will see more of this in the upcoming examples.
    The destruction phase is mandatory and prevents memory leaks in the case of Heap
    allocations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开`main`函数并结束程序之前，我们已经销毁了`car`对象。这仅仅意味着对象分配的资源在这一阶段被释放了。关于这个例子中的`car`对象，没有需要执行销毁操作，但并不总是这样，销毁可能需要遵循一些步骤。我们将在接下来的例子中看到更多关于这一点的内容。销毁阶段是强制性的，可以防止堆分配时的内存泄漏。
- en: It would be good to see how we could write the preceding example in C++. This
    would help you to get an insight into how an OOP language understands classes
    and objects and how it reduces the overhead of writing proper object-oriented
    code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何将前面的例子写成C++代码会很好。这有助于你了解面向对象的语言是如何理解类和对象的，以及它是如何减少编写正确面向对象代码的开销的。
- en: 'The following code box, as part of *example 6.2*, shows the header file containing
    the `Car` class in C++:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框，作为*示例 6.2*的一部分，显示了包含C++中`Car`类的头文件：
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 6-10 [ExtremeC_examples_chapter6_2.h]: The declaration of the Car
    class in C++'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 6-10 [ExtremeC_examples_chapter6_2.h]: C++中Car类的声明'
- en: The main feature of the preceding code is the fact that C++ knows about classes.
    Therefore, the preceding code demonstrates an explicit encapsulation; both attribute
    and behavior encapsulations. More than that, C++ supports more object-oriented
    concepts such as constructors and destructors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的主要特点是C++知道类。因此，前面的代码演示了显式封装；属性和行为封装。不仅如此，C++还支持更多的面向对象的概念，如构造函数和析构函数。
- en: In the C++ code, all the declarations, both attributes and behaviors, are encapsulated
    in the class definition. This is the explicit encapsulation. Look at the two first
    functions that we have declared as the constructor and the destructor of the class.
    C doesn't know about the constructors and destructors; but C++ has a specific
    notation for them. For instance, the destructor starts with ~ and it has the same
    name as the class does.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++代码中，所有的声明，无论是属性还是行为，都被封装在类定义中。这是显式封装。看看我们声明的第一个和第二个函数，我们将它们声明为类的构造函数和析构函数。C不知道构造函数和析构函数；但C++有它们自己的特定符号。例如，析构函数以~开头，并且与类的名字相同。
- en: 'In addition, as you can see, the behavior functions are missing the first pointer
    argument. That''s because they all have access to the attributes inside the class.
    The next code box shows the content of the source file that contains the definition
    of the declared behavior functions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如你所看到的，行为函数缺少第一个指针参数。这是因为它们都可以访问类内部的属性。下一个代码框显示了包含已声明行为函数定义的源文件内容：
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 6-11 [ExtremeC_examples_chapter6_2.cpp]: The definition of the Car
    class in C++'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框6-11 [ExtremeC_examples_chapter6_2.cpp]：C++中Car类的定义
- en: If you look carefully, you'll see that the `car` pointer in the C code has been
    replaced by a `this` pointer, which is a keyword in C++. The keyword `this` simply
    means the current object. I'm not going to explain it any further here, but it
    is a smart workaround to eliminate the pointer argument in C and make behavior
    functions simpler.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现C代码中的`car`指针已经被C++中的`this`指针所取代，`this`是C++中的一个关键字。关键字`this`简单地说就是当前对象。这里我就不再进一步解释了，但这是一个聪明的解决方案，用来消除C语言中的指针参数，并使行为函数更简单。
- en: 'And finally, the following code box contains the `main` function that uses
    the preceding class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码框包含了使用前面类定义的`main`函数：
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 6-12 [ExtremeC_examples_chapter6_2_main.cpp]: The main function of
    example 6.2'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框6-12 [ExtremeC_examples_chapter6_2_main.cpp]：示例6.2的主函数
- en: The `main` function written for C++ is very similar to the one we wrote for
    C, except that it allocates the memory for a class variable instead of a structure
    variable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为C++编写的`main`函数与我们为C编写的非常相似，只是它为类变量分配内存而不是结构变量。
- en: In C, we can't put attributes and behavior functions in a bundle that is known
    to C. Instead, we have to use files to group them. But in C++, we have a syntax
    for this bundle, which is the *class definition*. It allows us to put data members
    (or attributes) and member functions (or behavior functions) in the same place.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，我们不能将属性和行为函数组合在一起，因为C语言知道这个组合。相反，我们必须使用文件来分组它们。但在C++中，我们有这种组合的语法，即*类定义*。它允许我们将数据成员（或属性）和成员函数（或行为函数）放在同一个地方。
- en: Since C++ knows about the encapsulation, it is redundant to pass the pointer
    argument to the behavior functions, and as you can see, in C++, we don't have
    any first pointer arguments in member function declarations like those we see
    in the C version of the `Car` class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++知道封装，因此向行为函数传递指针参数是多余的，正如你所看到的，在C++中，我们在成员函数声明中没有任何像C版本的`Car`类中那样的第一个指针参数。
- en: So, what happened? We wrote an object-oriented program in both C, which is a
    procedural programming language, and in C++, which is an object-oriented one.
    The biggest change was using `car.Accelerate()` instead of `car_accelerate(&car)`,
    or using `car.Refuel(1000.0)` instead of `car_refuel(&car, 1000.0)`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么？我们在C语言，这是一种过程式编程语言，和C++语言，这是一种面向对象的语言，都编写了一个面向对象的程序。最大的变化是使用`car.Accelerate()`代替`car_accelerate(&car)`，或者使用`car.Refuel(1000.0)`代替`car_refuel(&car,
    1000.0)`。
- en: In other words, if we are doing a call such as `func(obj, a, b, c, ...)` in
    a procedural programming language, we can do it as `obj.func(a, b, c, ...)` in
    an object-oriented language. They are equivalent but coming from different programming
    paradigms. Like we said before, there are numerous examples of C projects that
    use this technique.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们在一个过程式编程语言中执行`func(obj, a, b, c, ...)`这样的调用，我们可以在面向对象的语言中这样做`obj.func(a,
    b, c, ...)`。它们是等效的，但来自不同的编程范式。就像我们之前说的那样，有无数使用这种技术的C项目例子。
- en: '**Note:**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: In *Chapter 9*, *Abstraction and OOP in C++*, you will see that C++ uses exactly
    the same preceding technique in order to translate high-level C++ function calls
    to low-level C function calls.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*C++中的抽象和面向对象*，你会看到C++使用完全相同的先导技术，将高级C++函数调用转换为低级C函数调用。
- en: As a final note, there is an important difference between C and C++ regarding
    object destruction. In C++, the destructor function is invoked automatically whenever
    an object is allocated on top of the Stack and it is going out of scope, like
    any other Stack variable. This is a great achievement in C++ memory management,
    because in C, you may easily forget to call the destructor function and eventually
    experience a memory leak.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的注意事项，C和C++在对象销毁方面有一个重要的区别。在C++中，每当在栈上分配一个对象并且它即将超出作用域时，析构函数会自动调用，就像任何其他栈变量一样。这是C++内存管理的一个重大成就，因为在C中，你可能会忘记调用析构函数，最终导致内存泄漏。
- en: 'Now it is time to talk about other aspects of encapsulation. In the next section,
    we will talk about a consequence of encapsulation: information-hiding.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论封装的其他方面了。在下一节中，我们将讨论封装的一个后果：信息隐藏。
- en: Information hiding
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息隐藏
- en: So far, we've explained how encapsulation bundles attributes (which represent
    values) and functionalities (which represent behaviors) together to form objects.
    But it doesn't end there.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了封装如何将属性（代表值）和功能（代表行为）捆绑在一起形成对象。但这并没有结束。
- en: Encapsulation has another important purpose or consequence, which is *information-hiding*.
    Information-hiding is the act of protecting (or hiding) some attributes and behaviors
    that should not be visible to the outer world. By the outer world, we mean all
    parts of the code that do not belong to the behaviors of an object. By this definition,
    no other code, or simply no other C function, can access a private attribute or
    a private behavior of an object if that attribute or behavior is not part of the
    public interface of the class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 封装还有一个重要的目的或后果，那就是*信息隐藏*。信息隐藏是指保护（或隐藏）一些不应对外界可见的属性和行为。这里的“外界”指的是不属于对象行为的代码的所有部分。根据这个定义，如果没有是类公共接口的一部分，那么没有任何其他代码，或者简单地说，没有任何其他C函数可以访问对象的私有属性或私有行为。
- en: Note that the behaviors of two objects from the same type, such as `car1` and
    `car2` from the `Car` class, can access the attributes of any object from the
    same type. That's because of the fact that we write behavior functions once for
    all objects in a class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，同一类型的两个对象的行为，例如`Car`类中的`car1`和`car2`，可以访问同一类型的任何对象的属性。这是因为我们为类中的所有对象编写一次行为函数。
- en: In *example 6.1*, we saw that the `main` function was easily accessing the `speed`
    and `fuel` attributes in the `car_t` attribute structure. This means that all
    attributes in the `car_t` type were public. Having a public attribute or behavior
    can be a bad thing because it might have some long-lasting and dangerous.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例6.1*中，我们看到`main`函数很容易访问`car_t`属性结构中的`speed`和`fuel`属性。这意味着`car_t`类型中的所有属性都是公共的。拥有公共属性或行为可能是一件坏事，因为它可能有一些长期和危险的影响。
- en: As a consequence, the implementation details could leak out. Suppose that you
    are going to use a car object. Usually, it is only important to you that it has
    a behavior that accelerates the car; and you are not curious about how it is done.
    There may be even more internal attributes in the object that contribute to the
    acceleration process, but there is no valid reason that they should be visible
    to the consumer logic.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，实现细节可能会泄露出来。假设你打算使用一个汽车对象。通常，对你来说，重要的是它有一个加速汽车的行为；而你并不好奇它是如何实现的。对象中可能有更多的内部属性有助于加速过程，但没有合理的理由让它们对消费者逻辑可见。
- en: For instance, the amount of the electrical current being delivered to the engine
    starter could be an attribute, but it should be just private to the object itself.
    This also holds for certain behaviors that are internal to the object. For example,
    injecting the fuel into the combustion chamber is an internal behavior that should
    not be visible and accessible to you, otherwise, you could interfere with that
    and interrupt the normal process of the engine.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，提供给发动机启动器的电流量可能是一个属性，但它应该仅对对象本身是私有的。这也适用于对象内部的一些行为。例如，将燃料注入燃烧室是一种内部行为，不应该对你可见和可访问，否则你可能会干扰它并中断发动机的正常工作过程。
- en: From another point of view, the implementation details (how the car works) vary
    from one car manufacturer to another but being able to accelerate a car is a behavior
    that is provided by all car manufacturers. We usually say that being able to accelerate
    a car is part of the *public API* or the *public interface* of the `Car` class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，实现细节（汽车是如何工作的）因汽车制造商而异，但能够加速汽车是一种所有汽车制造商都提供的行为。我们通常说，能够加速汽车是`Car`类的*公共API*或*公共接口*的一部分。
- en: Generally, the code using an object becomes dependent on the public attributes
    and behaviors of that object. This is a serious concern. Leaking out an internal
    attribute by declaring it public at first and then making it private can effectively
    break the build of the dependent code. It is expected that other parts of the
    code that are using that attribute as a public thing won't get compiled after
    the change.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用对象的代码会依赖于该对象的公共属性和行为。这是一个严重的问题。最初将内部属性声明为公共的，然后将其设置为私有，可能会导致依赖于该属性的代码构建失败。预期使用该属性作为公共事物的代码的其他部分在更改后不会编译。
- en: This would mean you've broken the backward compatibility. That's why we choose
    a conservative approach and make every single attribute private by default until
    we find sound reasoning for making it public.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你破坏了向后兼容性。这就是为什么我们选择保守的方法，默认将每个属性都设置为私有，直到我们找到将其公开的合理理由。
- en: To put it simply, exposing private code from a class effectively means that
    rather than being dependent on a light public interface, we have been dependent
    on a thick implementation. These consequences are serious and have the potential
    to cause a lot of rework in a project. So, it is important to keep attributes
    and behaviors as private as they can be.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，从类中公开私有代码实际上意味着我们不是依赖于轻量级的公共接口，而是依赖于厚重的实现。这些后果是严重的，有可能导致项目中的大量返工。因此，保持属性和行为尽可能私有是很重要的。
- en: 'The following code box, as part of *example 6.3*, will demonstrate how we can
    have private attributes and behaviors in C. The example is about a `List` class
    that is supposed to store some integer values:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码框，作为*示例 6.3*的一部分，将展示如何在C语言中拥有私有属性和行为。这个例子是关于一个`List`类，它应该存储一些整数值：
- en: '[PRE12]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 6-13 [ExtremeC_examples_chapter6_3.h]: The public interface of the
    List class'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 6-13 [ExtremeC_examples_chapter6_3.h]: List类的公共接口'
- en: What you see in the preceding code box is the way that we make the attributes
    private. If another source file, such as the one that contains the `main` function,
    includes the preceding header, it'll have no access to the attributes inside the
    `list_t` type. The reason is simple. The `list_t` is just a declaration without
    a definition, and with just a structure declaration, you cannot access the fields
    of the structure. You cannot even declare a variable out of it. This way, we guarantee
    the information-hiding. This is actually a great achievement.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码框中看到的是我们使属性私有的方式。如果另一个源文件，例如包含`main`函数的文件，包含了前面的头文件，它将无法访问`list_t`类型内部的属性。原因很简单。`list_t`只是一个声明而没有定义，仅通过结构声明，你无法访问结构体的字段。你甚至无法从它中声明一个变量。这样，我们保证了信息隐藏。这实际上是一项伟大的成就。
- en: Once again, before creating and publishing a header file, it is mandatory to
    double-check whether we need to expose something as public or not. By exposing
    a public behavior or a public attribute, you'll create dependencies whose breaking
    would cost you time, development effort, and eventually money.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在创建和发布头文件之前，必须仔细检查是否需要公开某些内容。通过公开公共行为或公共属性，你会创建依赖关系，其破坏将耗费你时间、开发努力，并最终导致金钱损失。
- en: 'The following code box demonstrates the actual definition of the `list_t` attribute
    structure. Note that it is defined inside a source file and not a header file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码框展示了`list_t`属性结构的实际定义。请注意，它是在源文件中定义的，而不是在头文件中：
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 6-14 [ExtremeC_examples_chapter6_3.c]: The definition of the List
    class'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 6-14 [ExtremeC_examples_chapter6_3.c]: List类的定义'
- en: All the definitions that you see in the preceding code box are private. The
    external logic that is going to use a `list_t` object does not know anything about
    the preceding implementations, and the header file is the only piece of code that
    the external code will be dependent on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码框中看到的所有定义都是私有的。将要使用`list_t`对象的外部逻辑对前面的实现一无所知，头文件是外部代码唯一依赖的代码片段。
- en: Note that the preceding file has not even included the header file! As long
    as the definitions and function signatures match the declarations in the header
    file, that's all that's needed. However, it is recommended to do so because it
    guarantees the compatibility between the declarations and their corresponding
    definitions. As you've seen in *Chapter 2*, *Compilation and Linking*, the source
    files are compiled separately and finally linked together.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的文件甚至没有包含头文件！只要定义和函数签名与头文件中的声明相匹配，这就足够了。然而，建议这样做，因为这保证了声明与其对应定义之间的兼容性。正如您在*第二章*，*编译和链接*中看到的，源文件是分别编译的，最后链接在一起。
- en: In fact, the linker brings private definitions to the public declarations and
    makes a working program out of them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，链接器将私有定义带到公共声明中，并从中制作出一个可工作的程序。
- en: '**Note:**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: We can use a different notation for private behavior functions. We use the prefix
    `__` in their names. As an example, the `__check_index` function is a private
    function. Note that a private function does not have any corresponding declaration
    in the header file.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为私有行为函数使用不同的表示法。我们在它们的名称中使用前缀`__`。例如，`__check_index`函数是一个私有函数。请注意，私有函数在头文件中没有相应的声明。
- en: 'The following code box contains *example 6.3*''s `main` function that creates
    two list objects, populates the first one, and uses the second list to store the
    reverse of the first list. Finally, it prints them out:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码框包含*示例6.3*的`main`函数，该函数创建两个列表对象，填充第一个，并使用第二个列表存储第一个列表的逆序。最后，它将它们打印出来：
- en: '[PRE14]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code Box 6-15 [ExtremeC_examples_chapter6_3_main.c]: The main function of example
    6.3'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框6-15 [ExtremeC_examples_chapter6_3_main.c]：示例6.3的`main`函数
- en: As you can see in the preceding code box, we wrote the `main` and `reverse`
    functions only based on the things declared in the header file. In other words,
    these functions are using only the public API (or public interface) of the `List`
    class; the declarations of the attribute structure `list_t` and its behavior functions.
    This example is a nice demonstration of how to break the dependencies and hide
    the implementation details from other parts of the code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码框中所见，我们只根据头文件中声明的功能编写了`main`和`reverse`函数。换句话说，这些函数仅使用了`List`类的公共API（或公共接口）；属性结构`list_t`及其行为函数的声明。这个例子很好地展示了如何打破依赖关系，并从代码的其他部分隐藏实现细节。
- en: '**Note:**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: Using the public API, you can write a program that compiles, but it cannot turn
    into a real working program unless you provide the corresponding object files
    of the private part and link them together.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公共API，您可以编写一个可以编译的程序，但除非您提供私有部分的相应对象文件并将它们链接在一起，否则它不能成为一个真正的可工作程序。
- en: There are some points related to the preceding code that we explore in more
    detail here. We needed to have a `list_malloc` function in order to allocate memory
    for a `list_t` object. Then, we can use the function `free` to release the allocated
    memory when we're done with the object.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一些相关点我们在下面进行了更详细的探讨。我们需要有一个`list_malloc`函数来为`list_t`对象分配内存。然后，当我们完成对象时，我们可以使用`free`函数释放分配的内存。
- en: You cannot use `malloc` directly in the preceding example. That's because if
    you are going to use `malloc` inside the `main` function, you have to pass `sizeof(list_t)`
    as the required number of bytes that should be allocated. However, you cannot
    use `sizeof` for an incomplete type.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您不能直接使用`malloc`。这是因为如果您打算在`main`函数中使用`malloc`，您必须传递`sizeof(list_t)`作为应该分配的字节数。然而，您不能对不完整类型使用`sizeof`。
- en: The `list_t` type included from the header file is an *incomplete type* because
    it is just a declaration that doesn't give any information regarding its internal
    fields, and we don't know its size while compiling it. The real size will be determined
    only at link time when we know the implementation details. As a solution, we had
    to have the `list_malloc` function defined and have `malloc` used in a place where
    `sizeof(list_t)` is determined.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从头文件中包含的`list_t`类型是一个*不完整类型*，因为它只是一个声明，没有提供有关其内部字段的信息，并且在编译时我们不知道它的大小。实际的大小只有在链接时间确定实现细节时才会确定。作为解决方案，我们必须定义`list_malloc`函数，并在`sizeof(list_t)`确定的地方使用`malloc`。
- en: 'In order to build *example 6.3*, we need to compile the sources first. The
    following commands produce the necessary object files before the linking phase:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建*示例6.3*，我们首先需要编译源文件。以下命令在链接阶段之前生成必要的对象文件：
- en: '[PRE15]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Shell Box 6-1: Compiling example 6.3'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 6-1: 编译示例 6.3'
- en: As you see, we have compiled the private part into `private.o` and the main
    part into `main.o`. Remember that we don't compile header files. The public declarations
    in the header are included as part of the `main.o` object file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将私有部分编译成 `private.o`，将主要部分编译成 `main.o`。记住，我们不编译头文件。头文件中的公共声明包含在 `main.o`
    对象文件中。
- en: 'Now we need to link the preceding object files together, otherwise `main.o`
    alone cannot turn into an executable program. If you try to create an executable
    file using only `main.o`, you will see the following errors:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将前面的对象文件链接在一起，否则 `main.o` 单独不能变成可执行程序。如果你尝试仅使用 `main.o` 创建可执行文件，你会看到以下错误：
- en: '[PRE16]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Shell Box 6-2: Trying to link example 6.3 by just providing main.o'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 6-2: 仅通过提供 main.o 尝试链接示例 6.3'
- en: 'You see that the linker cannot find the definitions of the functions declared
    in the header file. The proper way to link the example is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到链接器找不到在头文件中声明的函数的定义。链接示例的正确方法是：
- en: '[PRE17]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Shell Box 6-3: Linking and running example 6.3'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 6-3: 将示例 6.3 链接并运行'
- en: What happens if you change the implementation behind the `List` class?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改 `List` 类背后的实现会发生什么？
- en: 'Say, instead of using an array, you use a linked list. It seems that we don''t
    need to generate the `main.o` again, because it is nicely independent of the implementation
    details of the list it uses. So, we need only to compile and generate a new object
    file for the new implementation; for example, `private2.o`. Then, we just need
    to relink the object files and get the new executable:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，而不是使用数组，你使用链表。看起来我们不需要再次生成 `main.o`，因为它很好地独立于它使用的列表的实现细节。因此，我们只需要为新实现编译并生成一个新的对象文件；例如，`private2.o`。然后，我们只需要重新链接对象文件并获取新的可执行文件：
- en: '[PRE18]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Shell Box 6-4: Linking and running example 6.3 with a different implementation
    of the List class'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 6-4: 将示例 6.3 与 List 类的不同实现链接并运行'
- en: As you see, from the user's point of view, nothing has changed, but the underlying
    implementation has been replaced. That is a great achievement and this approach
    is being used heavily in C projects.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从用户的角度来看，没有任何变化，但底层实现已被替换。这是一项巨大的成就，这种方法在 C 项目中被广泛使用。
- en: What if we wanted to not repeat the linking phase in case of a new list implementation?
    In that case, we could use a shared library (or `.so` file) to contain the private
    object file. Then, we could load it dynamically at runtime, removing the need
    to relink the executable again. We have discussed shared libraries as part of
    *Chapter 3*, *Object Files*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在新的列表实现的情况下不重复链接阶段，该怎么办？在这种情况下，我们可以使用共享库（或 `.so` 文件）来包含私有对象文件。然后，我们可以在运行时动态加载它，从而无需再次重新链接可执行文件。我们已在
    *第 3 章*，*对象文件* 中讨论了共享库。
- en: Here, we bring the current chapter to an end and we will continue our discussion
    in the following chapter. The next two chapters will be about the possible relationships
    which can exist between two classes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将结束本章，并在下一章继续我们的讨论。接下来的两章将讨论两个类之间可能存在的可能关系。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, the following topics have been discussed:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，以下主题已被讨论：
- en: We gave a thorough explanation of object-orientation philosophy and how you
    can extract an object model from your mind map.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对面向对象哲学进行了详尽的解释，以及如何从你的思维导图中提取对象模型。
- en: We also introduced the concept of the domain and how it should be used to filter
    the mind map to just keep relevant concepts and ideas.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还介绍了领域概念及其如何用于过滤思维导图，仅保留相关概念和想法。
- en: We also introduced the attributes and behaviors of a single object and how they
    should be extracted from either the mind map or the requirements given in the
    description of a domain.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还介绍了单个对象的属性和行为，以及它们应该如何从领域描述中的思维导图或需求中提取。
- en: We explained why C cannot be an OOP language and explored its role in the translation
    of OOP programs into low-level assembly instructions that eventually will be run
    on a CPU.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了为什么 C 不能成为面向对象编程（OOP）语言，并探讨了它在将 OOP 程序翻译成最终将在 CPU 上运行的底层汇编指令中的作用。
- en: Encapsulation, as the first principle in OOP, was discussed. We use encapsulation
    to create capsules (or objects) that contain a set of attributes (placeholders
    for values) and a set of behaviors (placeholders for logic).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装作为面向对象编程（OOP）的第一原则已被讨论。我们使用封装来创建胶囊（或对象），它们包含一组属性（值的占位符）和一组行为（逻辑的占位符）。
- en: Information-hiding was also discussed, including how it can lead to interfaces
    (or APIs) that can be used without having to become dependent on the underlying
    implementation.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息隐藏也被讨论了，包括它如何导致可以不依赖底层实现而使用的接口（或API）。
- en: While discussing information-hiding, we demonstrated how to make attributes
    or methods private in C code.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在讨论信息隐藏时，我们展示了如何在C代码中使属性或方法私有化。
- en: The next chapter will be the opening to the discussion regarding possible relations
    between classes. We start *Chapter 7*, *Composition, and Aggregation*, with talking
    about composition relationship and then, we continue with inheritance and polymorphism
    as part of *Chapter 8*, *Inheritance and Polymorphism*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将开启关于类之间可能存在关系的讨论。我们开始**第七章**，**组合与聚合**，先讨论组合关系，然后，在**第八章**，**继承与多态**中，我们继续讨论继承和多态。
