- en: Behavior-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: 'This chapter covers the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: A brief overview of behavior-driven development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发简介
- en: TDD versus BDD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD与BDD
- en: C++ BDD frameworks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ BDD框架
- en: The Gherkin language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gherkin语言
- en: Installing `cucumber-cpp` in Ubuntu
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu中安装`cucumber-cpp`
- en: Feature file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性文件
- en: Spoken languages supported by Gherkin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gherkin支持的口语
- en: The recommended `cucumber-cpp` project folder structure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐的`cucumber-cpp`项目文件夹结构
- en: Writing our first Cucumber test case
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个Cucumber测试用例
- en: Dry running our Cucumber test cases
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行我们的Cucumber测试用例进行干运行
- en: BDD--a test-first development approach
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BDD——一种测试驱动的开发方法
- en: In the following sections, let's look into each topic with easy-to-digest and
    interesting code samples in a practical fashion.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，让我们以实用的方式逐个讨论每个主题，并提供易于理解和有趣的代码示例。
- en: Behavior-driven development
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: '**Behavior-driven development** (**BDD**) is an outside-in development technique.
    BDD encourages capturing the requirements as a set of scenarios or use cases that
    describe how the end user will use the feature. The scenario will precisely express
    what will be the input supplied and what is the expected response from the feature.
    The best part of BDD is that it uses a **domain-specific language** (**DSL**)
    called **Gherkin** to describe the BDD scenarios.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）是一种从外到内的开发技术。BDD鼓励将需求捕捉为一组场景或用例，描述最终用户如何使用功能。场景将准确表达输入和功能预期响应。BDD最好的部分是它使用称为**Gherkin**的**领域特定语言**（**DSL**）来描述BDD场景。'
- en: Gherkin is an English-like language that is used by all the BDD test frameworks.
    Gherkin is a business-readable DSL that helps you describe the test case scenarios,
    keeping out the implementation details. The Gherkin language keywords are a bunch
    of English words; hence the scenarios can be understood by both technical and
    non-technical members involved in a software product or a project team.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin是一种类似英语的语言，被所有BDD测试框架使用。Gherkin是一种可读的业务DSL，帮助您描述测试用例场景，排除实现细节。Gherkin语言关键字是一堆英语单词；因此，技术和非技术成员都可以理解涉及软件产品或项目团队的场景。
- en: Did I tell you that the BDD scenarios written in Gherkin languages serve as
    both documentation and test cases? As the Gherkin language is easy to understand
    and uses English-like keywords, the product requirements can be directly captured
    as BDD scenarios, as opposed to boring Word or PDF documents. Based on my consulting
    and industry experience, I have observed that a majority of the companies never
    update the requirement documents when the design gets refactored in the due course
    of time. This leads to stale and non-updated documents, which the development
    team will not trust for their reference purposes. Hence, the effort that has gone
    towards preparing the requirements, high-level design documents, and low-level
    design documents goes to waste in the long run, whereas Cucumber test cases will
    stay updated and relevant at all times.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我告诉过你了吗，用Gherkin语言编写的BDD场景既可以作为文档，也可以作为测试用例？由于Gherkin语言易于理解并使用类似英语的关键词，产品需求可以直接被捕捉为BDD场景，而不是无聊的Word或PDF文档。根据我的咨询和行业经验，我观察到大多数公司在设计在一段时间内重构时从不更新需求文档。这导致了陈旧和未更新的文档，开发团队将不信任这些文档作为参考。因此，为准备需求、高级设计文档和低级设计文档所付出的努力最终将付诸东流，而Cucumber测试用例将始终保持更新和相关。
- en: TDD versus BDD
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD与BDD
- en: TDD is an inside-out development technique whereas BDD is an outside-in development
    technique. TDD mainly focuses on unit testing and integration test case automation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种从内到外的开发技术，而BDD是一种从外到内的开发技术。TDD主要侧重于单元测试和集成测试用例自动化。
- en: BDD focuses on end-to-end functional test cases and user acceptance test cases.
    However, BDD could also be used for unit testing, smoke testing, and, literally,
    every type of testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: BDD侧重于端到端的功能测试用例和用户验收测试用例。然而，BDD也可以用于单元测试、冒烟测试，以及实际上的各种测试。
- en: BDD is an extension of the TDD approach; hence, BDD also strongly encourages
    test-first development. It is quite natural to use both BDD and TDD in the same
    product; hence, BDD isn't a replacement for TDD. BDD can be thought of as a high-level
    design document, while TDD is the low-level design document.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: BDD是TDD方法的扩展；因此，BDD也强烈鼓励测试驱动开发。在同一产品中同时使用BDD和TDD是非常自然的；因此，BDD并不是TDD的替代品。BDD可以被视为高级设计文档，而TDD是低级设计文档。
- en: C++ BDD frameworks
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ BDD框架
- en: In C++, TDD test cases are written using testing frameworks such as CppUnit,
    gtest, and so on, which require a technical background to understand them and
    hence, are generally used only by developers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，TDD测试用例是使用诸如CppUnit、gtest等测试框架编写的，这些测试框架需要技术背景才能理解，因此通常只由开发人员使用。
- en: In C++, BDD test cases are written using a popular test framework called cucumber-cpp.
    The cucumber-cpp framework expects that the test cases are written in the Gherkin
    language, while the actual test case implementations can be done with any test
    framework, such as gtest or CppUnit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，BDD测试用例是使用一种名为cucumber-cpp的流行测试框架编写的。cucumber-cpp框架期望测试用例是用Gherkin语言编写的，而实际的测试用例实现可以使用任何测试框架，如gtest或CppUnit。
- en: However, in this book, we will be using cucumber-cpp with the gtest framework.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本书中，我们将使用带有gtest框架的cucumber-cpp。
- en: The Gherkin language
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gherkin语言
- en: Gherkin is the universal language used by every BDD framework for various programming
    languages that enjoy BDD support.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin是每个BDD框架使用的通用语言，用于各种编程语言的BDD支持。
- en: Gherkin is a line-oriented language, similar to YAML or Python. Gherkin will
    interpret the structure of the test case based on indentations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin是一种面向行的语言，类似于YAML或Python。Gherkin将根据缩进解释测试用例的结构。
- en: The `#` character is used for a single line of comment in Gherkin. At the time
    of writing this book, Gherkin support about 60 keywords.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gherkin中，`#`字符用于单行注释。在撰写本书时，Gherkin支持大约60个关键字。
- en: Gherkin is a DSL used by the Cucumber framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin是Cucumber框架使用的DSL。
- en: Installing cucumber-cpp in Ubuntu
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ubuntu中安装cucumber-cpp
- en: Installing the cucumber-cpp framework is quite straightforward in Linux. All
    you need to do is either download or clone the latest copy of cucumber-cpp.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中安装cucumber-cpp框架非常简单。您只需要下载或克隆cucumber-cpp的最新副本即可。
- en: 'The following command can be used to clone the cucumber-cpp framework:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可用于克隆cucumber-cpp框架：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The cucumber-cpp framework is supported in Linux, Windows, and Macintosh. It
    can be integrated with Visual Studio on Windows or Xcode on macOS.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: cucumber-cpp框架支持Linux、Windows和Macintosh。它可以与Windows上的Visual Studio或macOS上的Xcode集成。
- en: 'The following screenshot demonstrates the Git clone procedure:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了Git克隆过程：
- en: '![](img/70e52cb7-7146-49a8-8b14-ad003e46069e.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70e52cb7-7146-49a8-8b14-ad003e46069e.png)'
- en: As cucumber-cpp depends on a wire protocol to allow the writing of BDD test
    case step definitions in the C++ language, we need to install Ruby.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: cucumber-cpp依赖于一种wire协议，允许在C++语言中编写BDD测试用例步骤定义，因此我们需要安装Ruby。
- en: Installing the cucumber-cpp framework prerequisite software
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装cucumber-cpp框架的先决软件
- en: 'The following command helps you install Ruby on your Ubuntu system. This is
    one of the prerequisite software that is required for the cucumber-cpp framework:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可帮助您在Ubuntu系统上安装Ruby。这是cucumber-cpp框架所需的先决软件之一：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot demonstrates the Ruby installation procedure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了Ruby安装过程：
- en: '![](img/1787118c-71e9-4412-9721-c2c01eb56687.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1787118c-71e9-4412-9721-c2c01eb56687.png)'
- en: 'Once the installation is complete, please ensure that Ruby is installed properly
    by checking its version. The following command should print the version of Ruby
    installed on your system:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，请确保Ruby已正确安装，检查其版本。以下命令应该打印出您系统上安装的Ruby版本：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to complete the Ruby installation, we need to install the `ruby-dev`
    packages, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成Ruby安装，我们需要安装`ruby-dev`软件包，如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to ensure that the bundler tool is installed so that the Ruby
    dependencies are installed by the bundler tool seamlessly:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保bundler工具已安装，以便bundler工具无缝安装Ruby依赖项：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If it all went smooth, you can go ahead and check if the correct version of
    Cucumber, Ruby, and Ruby''s tools are installed properly. The `bundle install`
    command will ensure that Cucumber and other Ruby dependencies are installed. Make
    sure you don''t install `bundle install` as a sudo user; this will prevent non-root
    from accessing the Ruby gem packages:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您可以继续检查Cucumber、Ruby和Ruby工具的正确版本是否已正确安装。`bundle install`命令将确保安装Cucumber和其他Ruby依赖项。确保您不要以sudo用户身份安装`bundle
    install`，这将阻止非root用户访问Ruby gem软件包：
- en: '![](img/25b61b48-e70a-4277-bea9-ad04b3f865dc.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25b61b48-e70a-4277-bea9-ad04b3f865dc.png)'
- en: 'We are almost done, but we are not there yet. We need to build the cucumber-cpp
    project; as part of that, let''s get the latest test suite for the cucumber-cpp
    framework:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了，但还没有完成。我们需要构建cucumber-cpp项目；作为其中的一部分，让我们获取cucumber-cpp框架的最新测试套件：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We go on to install the ninja and boost libraries before we can initiate the
    build. Though we aren''t going to use the boost test framework in this chapter,
    the `travis.sh` script file looks for the boost library. Hence, I would suggest
    installing the boost library in general, as part of Cucumber:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建之前，我们需要安装ninja和boost库。尽管在本章中我们不打算使用boost测试框架，但`travis.sh`脚本文件会寻找boost库。因此，我建议通常安装boost库，作为Cucumber的一部分：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Building and executing the test cases
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和执行测试用例
- en: 'Now, it''s time to build the cucumber-cpp framework. Let''s create the `build`
    folder. In the `cucumber-cpp` folder, there will be a shell script by the name, `travis.sh`.
    You got to execute the script to build and execute the test cases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建cucumber-cpp框架了。让我们创建`build`文件夹。在`cucumber-cpp`文件夹中，将有一个名为`travis.sh`的shell脚本。您需要执行该脚本来构建和执行测试用例：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Though the previous approach works, my personal preference and recommendation
    would be the following approach. The reason behind recommending the following
    approach is that the `build` folder is supposed to be created as a non-root user,
    as anyone should be able to perform the build once the `cucumber-cpp` setup is
    complete. You should be able to find the instructions in the `README.md` file
    under the `cucumber-cpp` folder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前的方法有效，但我个人偏好和建议是以下方法。推荐以下方法的原因是`build`文件夹应该被创建为非root用户，一旦`cucumber-cpp`设置完成，任何人都应该能够执行构建。您应该能够在`cucumber-cpp`文件夹下的`README.md`文件中找到说明：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you were able to complete all the previous installation steps exactly as
    explained, you are all set to start playing with `cucumber-cpp`. Congrats!!!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能够按照先前的安装步骤完全完成，那么您就可以开始使用`cucumber-cpp`了。恭喜！
- en: Feature file
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性文件
- en: Every product feature will have a dedicated feature file. The feature file is
    a text file with the `.feature` extension. A feature file can contain any number
    of scenarios, and each scenario is equivalent to a test case.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个产品特性都将有一个专用的特性文件。特性文件是一个文本文件，扩展名为`.feature`。一个特性文件可以包含任意数量的场景，每个场景相当于一个测试用例。
- en: 'Let''s take a look at a simple feature file example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的特性文件示例：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Cool, it appears like plain English, right? But trust me, this is how Cucumber
    test cases are written! I understand your doubt--it looks easy and cool but how
    does this verify the functionality, and where is the code that verifies the functionality?
     The `cucumber-cpp` framework is a cool framework, but it doesn't natively support
    any testing functionalities; hence `cucumber-cpp` depends on the gtest, `CppUnit`,
    other test frameworks. The test case implementation is written in a `Steps` file,
    which can be written in C++ using the gtest framework in our case. However, any
    test framework will work.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，看起来就像普通的英语，对吧？但相信我，这就是Cucumber测试用例的写法！我理解你的疑虑--看起来很简单很酷，但是这样怎么验证功能呢？验证功能的代码在哪里呢？`cucumber-cpp`框架是一个很酷的框架，但它并不原生支持任何测试功能；因此`cucumber-cpp`依赖于`gtest`、`CppUnit`和其他测试框架。测试用例的实现是在`Steps`文件中编写的，在我们的情况下可以使用`gtest`框架来编写C++。然而，任何测试框架都可以使用。
- en: Every feature file will start with the `Feature` keyword followed by one or
    more lines of description that describe the feature briefly. In the feature file,
    the words `Feature`, `Scenario`, `Given`, `And`, `When`, and `Then` are all Gherkin
    keywords.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特性文件都将以`Feature`关键字开头，后面跟着一行或多行描述，简要描述该特性。在特性文件中，`Feature`、`Scenario`、`Given`、`And`、`When`和`Then`都是Gherkin关键字。
- en: 'A feature file may contain any number of scenarios (test cases) for a feature.
    For instance, in our case, login is the feature, and there could be multiple login
    scenarios as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特性文件可以包含任意数量的场景（测试用例）对于一个特性。例如，在我们的情况下，登录是特性，可能有多个登录场景，如下所示：
- en: '`Success Login`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`登录成功`'
- en: '`Unsuccessful Login`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`登录失败`'
- en: '`Invalid password`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`密码无效`'
- en: '`Invalid username`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户名无效`'
- en: '`The user attempted to login without supplying credentials. `'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户尝试登录而没有提供凭据。`'
- en: Every line following the scenario will translate into one function in the `Steps_definition.cpp`
    source file. Basically, the `cucumber-cpp` framework maps the feature file steps
    with a corresponding function in the `Steps_definition.cpp` file using regular
    expressions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景后的每一行将在`Steps_definition.cpp`源文件中转换为一个函数。基本上，`cucumber-cpp`框架使用正则表达式将特性文件步骤映射到`Steps_definition.cpp`文件中的相应函数。
- en: Spoken languages supported by Gherkin
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gherkin支持的口语
- en: 'Gherkin supports over 60 spoken languages. As a best practice, the first line
    of a feature file will indicate to the Cucumber framework that we would like to
    use English:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin支持60多种口语。作为最佳实践，特性文件的第一行将指示Cucumber框架我们想要使用英语：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following command will list all the spoken languages supported by the `cucumber-cpp` framework:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将列出`cucumber-cpp`框架支持的所有语言：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The list is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表如下：
- en: '![](img/9aead3cf-addd-4ccd-8608-4862a5869ebe.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9aead3cf-addd-4ccd-8608-4862a5869ebe.png)'
- en: The recommended cucumber-cpp project folder structure
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐的cucumber-cpp项目文件夹结构
- en: 'Like TDD, the Cucumber framework too recommends a project folder structure.
    The recommended `cucumber-cpp` project folder structure is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与TDD一样，Cucumber框架也推荐了项目文件夹结构。推荐的`cucumber-cpp`项目文件夹结构如下：
- en: '![](img/85a639f3-e69f-4d1b-abab-e5d0a9603b8f.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85a639f3-e69f-4d1b-abab-e5d0a9603b8f.png)'
- en: The `src` folder will contain the production code, that is, all your project
    files will be maintained under the `src` directory. The BDD feature files will
    be maintained under the `features` folder and its respective `Steps` file, which
    has either boost test cases or gtest cases. In this chapter, we will be using
    the gtest framework with `cucumber-cpp`. The `wire` file has wire protocol-related
    connection details such as the port and others. The `CMakeLists.txt` is the build
    script that has the instructions to build your project along with its dependency
    details, just like `Makefile` used by the `MakeBuild` utility.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`文件夹将包含生产代码，也就是说，所有项目文件都将在`src`目录下维护。BDD特性文件将在`features`文件夹下维护，以及其相应的`Steps`文件，其中包含boost测试用例或gtest测试用例。在本章中，我们将使用`cucumber-cpp`的`gtest`框架。`wire`文件包含了与wire协议相关的连接细节，如端口等。`CMakeLists.txt`是构建脚本，其中包含构建项目及其依赖项的指令，就像`MakeBuild`实用程序使用的`Makefile`一样。'
- en: Writing our first Cucumber test case
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个Cucumber测试用例
- en: Let's write our very first Cucumber test case! As this is our first exercise,
    I would like to keep it short and simple. First, let's create the folder structure
    for our `HelloBDD` project.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写下我们的第一个Cucumber测试用例！由于这是我们的第一个练习，我想保持简短和简单。首先，让我们为我们的`HelloBDD`项目创建文件夹结构。
- en: 'To create the Cucumber project folder structure, we can use the `cucumber`
    utility, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Cucumber项目文件夹结构，我们可以使用`cucumber`实用程序，如下所示：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will ensure that the `features` and `steps_definitions` folders are created
    as per Cucumber best practices:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保`features`和`steps_definitions`文件夹按照Cucumber最佳实践创建：
- en: '![](img/9d381723-54cf-461d-801e-a999780f6655.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d381723-54cf-461d-801e-a999780f6655.png)'
- en: 'Once the basic folder structure is created, let''s manually create the rest
    of the files:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦基本文件夹结构创建完成，让我们手动创建其余的文件：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the folder structure and empty files are created, the project folder structure
    should look like the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件夹结构和空文件被创建，项目文件夹结构应该如下截图所示：
- en: '![](img/ab3e29a8-a2cc-423b-9b9f-d09026824b81.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab3e29a8-a2cc-423b-9b9f-d09026824b81.png)'
- en: 'It''s time to start applying our Gherkin knowledge in action; hence, let''s
    first start with the feature file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将我们的Gherkin知识付诸实践了，因此，让我们首先从特性文件开始：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s take a look at the `cucumber.wire` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`cucumber.wire`文件：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As Cucumber is implemented in Ruby, the Cucumber steps implementation has to
    be written in Ruby. This approach discourages using the cucumber-cpp framework
    for projects that are implemented in platforms other than Ruby. The wire protocol
    is the solution offered by the cucumber-cpp framework to extend cucumber support
    for non-Ruby platforms. Basically, whenever the cucumber-cpp framework executes
    the test cases, it looks for steps definitions, but if Cucumber finds a `.wire`
    file, it will instead connect to that IP address and port, in order to query the
    server if the process has definitions for the steps described in the `.feature`
    file. This helps Cucumber support many platforms apart from Ruby. However, Java
    and .NET have native Cucumber implementations: Cucumber-JVM and Specflow, respectively.
    Hence, in order to allow the test cases to be written in C++, the wire protocol
    is used by cucumber-cpp.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cucumber是用Ruby实现的，因此Cucumber步骤的实现必须用Ruby编写。这种方法不鼓励在除Ruby以外的平台上实现的项目中使用cucumber-cpp框架。`cucumber-cpp`框架提供的`wire`协议是为了扩展非Ruby平台对Cucumber的支持而提供的解决方案。基本上，每当`cucumber-cpp`框架执行测试用例时，它都会寻找步骤定义，但如果Cucumber找到一个`.wire`文件，它将连接到该IP地址和端口，以查询服务器是否有步骤描述中的定义`.feature`文件。这有助于Cucumber支持除Ruby以外的许多平台。然而，Java和.NET都有本地的Cucumber实现：Cucumber-JVM和Specflow。因此，为了允许用C++编写测试用例，`cucumber-cpp`使用了`wire`协议。
- en: Now let's see how to write the steps file using the gtest Framework.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用gtest框架编写步骤文件。
- en: Thanks to Google! The Google Test Framework (gtest) includes **Google Mock Framework**
    (**gmock**). For C/C++, the gtest framework is one of the best frameworks I have
    come across, as this is pretty close to the JUnit and Mockito/PowerMock offerings
    for Java. For a relatively modern language like Java compared to C++, it should
    be much easier to support mocking with the help of reflection, but from a C/C++
    point of view, without the reflection feature from C++, gtest/gmock is nothing
    short of JUnit/TestNG/Mockito/PowerMock.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Google！Google测试框架（gtest）包括Google Mock框架（gmock）。对于C/C++来说，gtest框架是我遇到的最好的框架之一，因为它与Java的JUnit和Mockito/PowerMock提供的功能非常接近。对于相对现代的语言Java来说，与C++相比，借助反射支持模拟应该更容易，但是从C/C++的角度来看，没有C++的反射功能，gtest/gmock简直就是JUnit/TestNG/Mockito/PowerMock。
- en: 'You can observe the written steps files using gtest in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下截图中观察使用gtest编写的步骤文件：
- en: '![](img/e9faafae-d3f1-4aa7-bffe-bacf1b20b618.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9faafae-d3f1-4aa7-bffe-bacf1b20b618.png)'
- en: 'The following header files ensure that the gtest header and Cucumber headers
    necessary for writing Cucumber steps are included:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下头文件确保包含了编写Cucumber步骤所需的gtest头文件和Cucumber头文件：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let''s proceed with writing the steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续编写步骤：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `HelloCtx` struct is a user-defined test context that holds the object instance
    under test and its test response. The cucumber-cpp framework offers a smart `ScenarioScope`
    class that allows us to access the object under test and its output, across all
    the steps in a Cucumber test scenario.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloCtx`结构是一个用户定义的测试上下文，它保存了测试对象实例及其测试响应。`cucumber-cpp`框架提供了一个智能的`ScenarioScope`类，允许我们在Cucumber测试场景的所有步骤中访问测试对象及其输出。'
- en: For every `Given`, `When`, and `Then` statement that we wrote in the feature
    file, there is a corresponding function in the steps file. The appropriate cpp
    functions that correspond to `Given`, `When`, and `Then` are mapped with the help
    of regular expressions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在特征文件中编写的每个`Given`、`When`和`Then`语句，都有一个相应的函数在步骤文件中。相应的cpp函数与`Given`、`When`和`Then`相对应的函数是通过正则表达式进行映射的。
- en: 'For instance, consider the following `Given` line in the feature file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑特征文件中的以下`Given`行：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This corresponds to the following cpp function that gets mapped with the help
    of regex. The `^` character in the regex implies that the pattern starts with
    `an`, and the `$` character implies that the pattern ends with `created`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于以下的cpp函数，它通过正则表达式进行映射。正则表达式中的`^`字符意味着模式以`an`开头，`$`字符意味着模式以`created`结尾：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As the `GIVEN` step says that, at this point, we must ensure that an instance
    of the `Hello` object is created; the corresponding C++ code is written in this
    function to instantiate an object of the `Hello` class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`GIVEN`步骤所说，在这一点上，我们必须确保创建`Hello`对象的一个实例；相应的C++代码写在这个函数中，用于实例化`Hello`类的对象。
- en: 'On a similar note, the following `When` step and its corresponding cpp functions
    are mapped by cucumber-cpp:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下`When`步骤及其相应的cpp函数由`cucumber-cpp`映射：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is important that the regex matches exactly; otherwise, the cucumber-cpp
    framework will report that it can''t find the steps function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很重要的是正则表达式要完全匹配；否则，`cucumber-cpp`框架将报告找不到步骤函数：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s look at the `Hello.h` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`Hello.h`文件：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the respective source file, that is, `Hello.cpp`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相应的源文件，即`Hello.cpp`：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As an industry best practice, the only header file that should be included in
    the source file is its corresponding header file. The rest of the headers required
    should go into the header files corresponding to the source file. This helps the
    development team to locate the headers quite easily. BDD is not just about test
    automation; the expected end result is clean, defectless, and maintainable code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为行业最佳实践，应该在源文件中包含的唯一头文件是其相应的头文件。其余所需的头文件应该放在与源文件对应的头文件中。这有助于开发团队轻松定位头文件。BDD不仅仅是关于测试自动化；预期的最终结果是干净、无缺陷和可维护的代码。
- en: 'Finally, let''s write `CMakeLists.txt`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们编写`CMakeLists.txt`：
- en: '![](img/7151a6f7-7c01-4cb1-82e4-a2a888d1738b.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7151a6f7-7c01-4cb1-82e4-a2a888d1738b.png)'
- en: The first line implies the name of the project. The third line ensures that
    the Cucumber header directories and our project's `include_directories` are in
    the `INCLUDE` path. The fifth line basically instructs the `cmake` utility to
    create a library out of the files present under the `src` folder, that is, `Hello.cpp`,
    and its `Hello.h` file. The seventh line detects whether the gtest framework is
    installed on our system, and the eighth line ensures that the `HelloBDDSteps.cpp`
    file is compiled. Finally, in the ninth line, the final executable is created,
    linking all the `HelloBDD` libraries that have our production code, the `HelloBDDSteps`
    object file, and the respective Cucumber and gtest library files.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示项目的名称。第三行确保Cucumber头文件目录和我们项目的`include_directories`在`INCLUDE`路径中。第五行基本上指示`cmake`工具将`src`文件夹中的文件创建为库，即`Hello.cpp`及其`Hello.h`文件。第七行检测我们的系统上是否安装了gtest框架，第八行确保编译了`HelloBDDSteps.cpp`文件。最后，在第九行，创建最终的可执行文件，链接所有包含我们生产代码的`HelloBDD`库，`HelloBDDSteps`对象文件以及相应的Cucumber和gtest库文件。
- en: Integrating our project in cucumber-cpp CMakeLists.txt
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的项目集成到cucumber-cpp的CMakeLists.txt中
- en: 'There is one last configuration that we need to do before we start building
    our project:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建项目之前，还有最后一个配置需要完成：
- en: '![](img/9bed5a14-4f3f-43de-95eb-81e5700cbaab.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bed5a14-4f3f-43de-95eb-81e5700cbaab.png)'
- en: Basically, I have commented the `examples` subdirectories and added our `HelloBDD`
    project in `CMakeLists.txt` present under the `cucumber-cpp` folder, as shown
    earlier.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我已经注释了`examples`子目录，并在`cucumber-cpp`文件夹下的`CMakeLists.txt`中添加了我们的`HelloBDD`项目，如前所示。
- en: 'As we have created the project as per cucumber-cpp best practices, let''s navigate
    to the `HelloBDD` project home and issue the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们按照cucumber-cpp最佳实践创建了项目，让我们转到`HelloBDD`项目主目录并发出以下命令：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It isn't mandatory to comment `add_subdirectory(examples)`. But commenting definitely
    helps us focus on our project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注释`add_subdirectory(examples)`并不是强制的。但注释确实有助于我们专注于我们的项目。
- en: 'The following screenshot shows the build procedure:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了构建过程：
- en: '![](img/14eeda23-b162-4a89-a442-8eaef8321723.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14eeda23-b162-4a89-a442-8eaef8321723.png)'
- en: Executing our test case
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行我们的测试用例
- en: 'Now let''s execute the test case. This involves two steps, as we are using
    the wire protocol. Let''s first launch the test case executable in background
    mode and then Cucumber, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行测试用例。由于我们使用了wire协议，这涉及两个步骤。让我们首先以后台模式启动测试用例可执行文件，然后启动Cucumber，如下所示：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Redirecting to `/dev/null` isn''t really mandatory. The main purpose of redirecting
    to a null device is to avoid distractions from the print statement that an application
    may spit in the terminal output. Hence, it is a personal preference. In case you
    prefer to see the debug or general print statements from your application, feel
    free to issue the command without redirection:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向到`/dev/null`并不是真正必需的。重定向到空设备的主要目的是避免应用程序在终端输出中打印语句，从而分散注意力。因此，这是个人偏好。如果你喜欢看到应用程序的调试或一般打印语句，可以自由地发出不带重定向的命令：
- en: '`build/HelloBDD/HelloBDDSteps &`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`build/HelloBDD/HelloBDDSteps &`'
- en: 'The following screenshot demonstrates the build and test execution procedure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了构建和测试执行过程：
- en: '![](img/efc1c7ee-ae0f-4764-b8ae-417299dc9c74.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efc1c7ee-ae0f-4764-b8ae-417299dc9c74.png)'
- en: Congrats! our very first cucumber-cpp test case has passed. Each scenario represents
    a test case and the test case includes three steps; as all the steps passed, the
    scenario is reported as passed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们的第一个cucumber-cpp测试用例已经通过。每个场景代表一个测试用例，测试用例包括三个步骤；由于所有步骤都通过了，因此报告为通过。
- en: Dry running your cucumber test cases
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的cucumber测试用例
- en: 'Do you want to quickly check whether the feature files and steps files are
    written correctly, without really executing them? Cucumber has a quick and cool
    feature to do so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你想快速检查功能文件和步骤文件是否正确编写，而不真正执行它们吗？Cucumber有一个快速而酷炫的功能来实现这一点：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command will execute our test application in the background mode. `/dev/null`
    is a null device in Linux OS, and we are redirecting all the unwanted print statements
    from the `HelloBDDSteps` executable to the null device to ensure it doesn't distract
    us while we execute our Cucumber test cases.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在后台模式下执行我们的测试应用程序。`/dev/null`是Linux操作系统中的一个空设备，我们将`HelloBDDSteps`可执行文件中的所有不需要的打印语句重定向到空设备，以确保在执行Cucumber测试用例时不会分散我们的注意力。
- en: 'The next command will allow us to dry run the Cucumber test scenario:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令将允许我们干运行Cucumber测试场景：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following screenshot shows the test execution:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了测试执行：
- en: '![](img/c45e6642-d9b5-472f-9a57-f3091c635722.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c45e6642-d9b5-472f-9a57-f3091c635722.png)'
- en: BDD - a test-first development approach
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BDD - 一种测试驱动的开发方法
- en: Just like TDD, BDD also insists on following a test-first development approach.
    Hence, in this section, let's explore how we could write an end-to-end feature
    following a test-first development approach the BDD way!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像TDD一样，BDD也坚持遵循测试驱动的开发方法。因此，在本节中，让我们探讨如何以BDD方式遵循测试驱动的开发方法编写端到端功能！
- en: Let's take a simple example that helps us understand the BDD style of coding.
    We will write an `RPNCalculator` application that does addition, subtraction,
    multiplication, division, and complex math expressions that involve many math
    operations in the same input.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的例子，帮助我们理解BDD风格的编码。我们将编写一个`RPNCalculator`应用程序，它可以进行加法、减法、乘法、除法以及涉及多个数学运算的复杂数学表达式。
- en: 'Let''s create our project folder structure as per Cucumber standards:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照Cucumber标准创建我们的项目文件夹结构：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following screenshot demonstrates the procedure visually:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图以可视化的方式展示了该过程：
- en: '![](img/a287b906-cc89-4033-aba4-494b823d8ca4.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a287b906-cc89-4033-aba4-494b823d8ca4.png)'
- en: 'Great! The folder structure is now created. Now, let''s create empty files
    with a touch utility to help us visualize our final project folder structure along
    with the files:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！文件夹结构现在已经创建。现在，让我们使用touch实用程序创建空文件，以帮助我们可视化我们的最终项目文件夹结构以及文件：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the dummy files are created, the final project folder structure will look
    like the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了虚拟文件，最终项目文件夹结构将如下截图所示：
- en: '![](img/5ae9f566-870f-4964-995c-a70dc87a9e18.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ae9f566-870f-4964-995c-a70dc87a9e18.png)'
- en: 'As usual, the Cucumber wire file is going to look as follows. In fact, throughout
    this chapter, this file will look same:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，Cucumber wire文件将如下所示。事实上，在本章中，这个文件将保持不变：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s start with the `rpncalculator.feature` file, as shown in the following
    screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从`rpncalculator.feature`文件开始，如下截图所示：
- en: '![](img/e2ebae2d-9518-42aa-854e-ba6f41f7bc06.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2ebae2d-9518-42aa-854e-ba6f41f7bc06.png)'
- en: As you can see, the feature description can be pretty elaborate. Did you notice?
    I have used `Scenario Outline` in the place of scenario. The interesting part
    of `Scenario Outline` is that it allows describing the set of inputs and the corresponding
    output in the form of a table under the `Examples` Cucumber section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您所看到的，特性描述可能相当详细。您注意到了吗？我在场景的位置使用了`Scenario Outline`。`Scenario Outline`的有趣之处在于它允许在`Examples`
    Cucumber部分下以表格的形式描述一组输入和相应的输出。 '
- en: If you are familiar with SCRUM, does the Cucumber scenario look pretty close
    to the user story? Yes, that's the idea. Ideally, the SCRUM user stories or use
    cases can be written as Cucumber scenarios. The Cucumber feature file is a live
    document that can be executed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉SCRUM，Cucumber场景看起来是否与用户故事非常接近？是的，这就是想法。理想情况下，SCRUM用户故事或用例可以编写为Cucumber场景。Cucumber特性文件是一个可以执行的实时文档。
- en: 'We need to add our project in the `CMakeLists.txt` file at the `cucumber-cpp`
    home directory, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`cucumber-cpp`主目录的`CMakeLists.txt`文件中添加我们的项目，如下所示：
- en: '![](img/2d0f647f-9747-47df-9981-612a870c6d5a.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d0f647f-9747-47df-9981-612a870c6d5a.png)'
- en: 'Ensure that `CMakeLists.txt` under the `RPNCalculator` folder looks as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`RPNCalculator`文件夹下的`CMakeLists.txt`如下所示：
- en: '![](img/ca912293-b420-4149-91ed-407512e201fe.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca912293-b420-4149-91ed-407512e201fe.png)'
- en: 'Now, let''s build our project with the following command from the `cucumber-cpp`
    home directory:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`cucumber-cpp`主目录中的以下命令构建我们的项目：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s execute our brand new `RPNCalculator` Cucumber test cases with the following
    command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令执行我们全新的`RPNCalculator` Cucumber测试用例：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output looks as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/8c60b645-7375-4e03-ac4f-303789cb36aa.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c60b645-7375-4e03-ac4f-303789cb36aa.png)'
- en: 'In the preceding screenshot, there are two suggestions for every `Given`, `When`,
    and `Then` statements we wrote in the feature file. The first version is meant
    for Ruby and the second is meant for C++; hence, we can safely ignore the step
    suggestions, which are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们在特性文件中编写的每个`Given`、`When`和`Then`语句都有两个建议。第一个版本适用于Ruby，第二个版本适用于C++；因此，我们可以安全地忽略这些步骤建议，具体如下：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we are yet to implement the `RPNCalculatorSteps.cpp` file, the Cucumber
    framework is suggesting us to supply implementations for the previous steps. Let''s
    copy and paste them in the `RPNCalculatorSteps.cpp` file and complete the steps
    implementations, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未实现`RPNCalculatorSteps.cpp`文件，Cucumber框架建议我们为先前的步骤提供实现。让我们将它们复制粘贴到`RPNCalculatorSteps.cpp`文件中，并完成步骤的实现，如下所示：
- en: '![](img/1b07b124-9ec9-48ec-b64b-b7308ac33a0e.png)`REGEX_PARAM` is a macro supported
    by the cucumber-cpp BDD framework, which comes in handy to extract the input arguments
    from the regular expression and pass them to the Cucumber step functions.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/1b07b124-9ec9-48ec-b64b-b7308ac33a0e.png)`REGEX_PARAM`是`cucumber-cpp`
    BDD框架支持的宏，它方便地从正则表达式中提取输入参数并将其传递给Cucumber步骤函数。'
- en: 'Now, let''s try to build our project again with the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用以下命令再次构建我们的项目：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The build log looks as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 构建日志如下所示：
- en: '![](img/722fdfd1-28c9-4426-bbe8-ffccedf1135e.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/722fdfd1-28c9-4426-bbe8-ffccedf1135e.png)'
- en: The secret formula behind every successful developer or consultant is that they
    have strong debugging and problem-solving skills. Analyzing build reports, especially
    build failures, is a key quality one should acquire to successfully apply BDD.
    Every build error teaches us something!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个成功的开发者或顾问背后的秘密公式是他们具有强大的调试和问题解决能力。分析构建报告，特别是构建失败，是成功应用BDD所需的关键素质。每个构建错误都教会我们一些东西！
- en: 'The build error is obvious, as we are yet to implement `RPNCalculator`, as
    the file is empty. Let''s write minimal code such that the code compiles:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 构建错误很明显，因为我们尚未实现`RPNCalculator`，文件是空的。让我们编写最小的代码，使得代码可以编译：
- en: '![](img/477bbef4-a203-47f0-873b-4d4229f00ad9.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/477bbef4-a203-47f0-873b-4d4229f00ad9.png)'
- en: BDD leads to incremental design and development, unlike the waterfall model.
    The waterfall model encourages upfront design. Typically, in a waterfall model,
    the design is done initially, and it consumes 30-40% of the overall project effort.
    The main issue with upfront design is that we will have less knowledge about the
    feature initially; often, we will have a vague feature knowledge, but it will
    improve over time. So, it isn't a good idea to put in more effort in the design
    activity upfront; rather, be open to refactoring the design and code as and when
    necessary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: BDD导致增量设计和开发，与瀑布模型不同。瀑布模型鼓励预先设计。通常在瀑布模型中，设计是最初完成的，并且占整个项目工作量的30-40%。预先设计的主要问题是我们最初对特性了解较少；通常我们对特性了解模糊，但随着时间的推移会有所改善。因此，在设计活动上投入更多的精力并不是一个好主意；相反，要随时准备根据需要重构设计和代码。
- en: Hence, BDD is a natural choice for complex projects.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，BDD是复杂项目的自然选择。
- en: 'With this minimal implementation, let''s try to build and run the test cases:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个最小的实现，让我们尝试构建和运行测试用例：
- en: '![](img/554d094a-2110-40a5-9866-0b4518d60a78.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/554d094a-2110-40a5-9866-0b4518d60a78.png)'
- en: 'Cool! Since the code compiles without errors, let''s execute the test case
    now and observe what happens:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！由于代码编译没有错误，现在让我们执行测试用例并观察发生了什么：
- en: '![](img/3bee50d4-757c-4826-9730-d0f36f533244.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bee50d4-757c-4826-9730-d0f36f533244.png)'
- en: The errors are highlighted in red color as shown in the preceding screenshot
    by the cucumber-cpp framework. This is expected; the test case is failing as the
    `RPNCalculator::evaluate` method is hardcoded to return `0.0`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 错误以红色突出显示，如前面的截图所示，由cucumber-cpp框架。这是预期的；测试用例失败，因为`RPNCalculator::evaluate`方法被硬编码为返回`0.0`。
- en: Ideally, we had to write only minimal code to make this pass, but I took the
    liberty of fast forwarding the steps, with the assumption that you have already
    read [Chapter 7](48a01a72-30c8-45f3-8b8d-e55ea6077866.xhtml), *Test Driven Development* before
    reading the current chapter. In that chapter, I have demonstrated every step in
    detail, including the refactoring.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们只需编写最少的代码使其通过，但我假设您在阅读本章之前已经阅读了[第7章](48a01a72-30c8-45f3-8b8d-e55ea6077866.xhtml)，*测试驱动开发*。在那一章中，我详细演示了每一步，包括重构。
- en: 'Now, let''s go ahead and implement the code to make this test case pass.  The
    modified `RPNCalculator` header file looks as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现代码以使该测试用例通过。修改后的`RPNCalculator`头文件如下所示：
- en: '![](img/746177d8-e4c1-4820-a193-fd6800b5a8cc.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/746177d8-e4c1-4820-a193-fd6800b5a8cc.png)'
- en: 'The respective `RPNCalculator` source file looks as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`RPNCalculator`源文件如下所示：
- en: '![](img/89bddc49-dcbb-4245-98fa-a182f7a49001.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89bddc49-dcbb-4245-98fa-a182f7a49001.png)'
- en: As per BDD practice, note that we have only implemented code that is necessary
    for supporting the addition operation alone, as per our current Cucumber scenario
    requirements. Like TDD, in BDD, we are supposed to write only the required amount
    of code to satisfy the current scenario; this way, we can ensure that every line
    of code is covered by effective test cases.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 根据BDD实践，注意我们只实现了支持加法操作的代码，根据我们当前的Cucumber场景要求。像TDD一样，在BDD中，我们应该只编写满足当前场景的所需代码；这样，我们可以确保每一行代码都被有效的测试用例覆盖。
- en: Let's build and run our BDD test case
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们构建和运行我们的BDD测试用例
- en: 'Let''s now build and test. The following commands can be used to build, launch
    the steps in the background, and run the Cucumber test cases with a wire protocol,
    respectively:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建和测试。以下命令可用于构建，启动后台中的步骤，并分别使用线协议运行Cucumber测试用例：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following screenshot demonstrates the procedure of building and executing
    the Cucumber test case:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了构建和执行Cucumber测试用例的过程：
- en: '![](img/54ea84e6-9ee4-41ab-8679-473840bc04d3.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54ea84e6-9ee4-41ab-8679-473840bc04d3.png)'
- en: Great! Our test scenario is all green now! Let's move on to our next test scenario.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的测试场景现在全部通过了！让我们继续进行下一个测试场景。
- en: 'Let''s add a scenario in the feature file to test the subtraction operation,
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在特性文件中添加一个场景来测试减法操作，如下所示：
- en: '![](img/51c98d11-3db0-4ea0-a154-9e4be399417f.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51c98d11-3db0-4ea0-a154-9e4be399417f.png)'
- en: 'The test output looks as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 测试输出如下：
- en: '![](img/2f940a5a-7f1b-4386-a26f-62a6f2d5360a.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f940a5a-7f1b-4386-a26f-62a6f2d5360a.png)'
- en: 'We had seen this before, hadn''t we?  I''m sure you guessed it right; the expected
    result is `85` whereas the actual result is `0`, as we haven''t added any support
    for subtraction yet. Now, let''s add the necessary code to add the subtraction
    logic in our application:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前见过这种情况，对吧？我相信你猜对了；预期结果是`85`，而实际结果是`0`，因为我们还没有添加减法的支持。现在，让我们添加必要的代码来在我们的应用程序中添加减法逻辑：
- en: '![](img/4c92aab4-df61-44a9-bf06-a83b4a062c0b.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c92aab4-df61-44a9-bf06-a83b4a062c0b.png)'
- en: 'With this code change, let''s rerun the test case and see what the test outcome
    is:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个代码更改，让我们重新运行测试用例，看看测试结果如何：
- en: '![](img/ac45480d-5b0c-4f1f-9811-66133896c427.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac45480d-5b0c-4f1f-9811-66133896c427.png)'
- en: Cool, the test report is back to green!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，测试报告又变成绿色了！
- en: 'Let''s move on and add a scenario in the feature file to test the multiplication
    operation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，在特性文件中添加一个场景来测试乘法操作：
- en: '![](img/e4248a4c-77e1-4a65-a7af-b181e147c161.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4248a4c-77e1-4a65-a7af-b181e147c161.png)'
- en: 'It is time to the run the test case, as shown in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行测试用例了，如下截图所示：
- en: '![](img/5adada80-5a58-4958-8200-33f1e98737de.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5adada80-5a58-4958-8200-33f1e98737de.png)'
- en: 'You got it right; yes, we need to add support for multiplication in our production
    code. Okay, let''s do it right away, as shown in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你说对了；是的，我们需要在我们的生产代码中添加对乘法的支持。好的，让我们立即做，如下截图所示：
- en: '![](img/8a777621-8ec8-4543-b3b3-0c8bb36fab8e.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a777621-8ec8-4543-b3b3-0c8bb36fab8e.png)'
- en: It's testing time!
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是测试时间！
- en: 'The following commands help you build, launch the steps applications, and run
    the Cucumber test cases, respectively. To be precise, the first command builds
    the test cases, while the second command launches the Cucumber steps test executable
    in the background mode. The third command executes the Cucumber test case that
    we wrote for the `RPNCalculator` project.  The `RPNCalculatorSteps` executable
    will work as a server that Cucumber can talk to via the wire protocol. The Cucumber
    framework will get the connection details of the server from the `cucumber.wire`
    file kept under the `step_definitions` folder:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可帮助您分别构建，启动步骤应用程序，并运行Cucumber测试用例。确切地说，第一个命令构建测试用例，而第二个命令以后台模式启动Cucumber步骤测试可执行文件。第三个命令执行我们为`RPNCalculator`项目编写的Cucumber测试用例。`RPNCalculatorSteps`可执行文件将作为Cucumber可以通过线协议与之通信的服务器。Cucumber框架将从`step_definitions`文件夹下的`cucumber.wire`文件中获取服务器的连接详细信息：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following screenshot demonstrates the Cucumber test case execution procedure:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了Cucumber测试用例的执行过程：
- en: '![](img/9d0ad0c8-8f70-4aa7-aa8b-d1ce15be05a4.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d0ad0c8-8f70-4aa7-aa8b-d1ce15be05a4.png)'
- en: 'I''m sure you''ve got the hang of BDD! Yes, BDD is pretty simple and straightforward.
    Now let''s add a scenario for the division operation as shown in the following
    screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经掌握了BDD！是的，BDD非常简单和直接。现在让我们根据以下截图添加一个除法操作的场景：
- en: '![](img/77471cb4-a2e7-4e8f-be7e-57f59d44c3f3.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77471cb4-a2e7-4e8f-be7e-57f59d44c3f3.png)'
- en: 'Let''s quickly run the test case and observe the test outcome, as shown in
    the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速运行测试用例并观察测试结果，如下截图所示：
- en: '![](img/483337a2-8b5c-4de8-9c1b-6f4b7d36f85a.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/483337a2-8b5c-4de8-9c1b-6f4b7d36f85a.png)'
- en: Yes, I heard you saying you know the reason for the failure. Let's quickly add
    support for division and rerun the test cases to see it turn all green! BDD makes
    coding really fun.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我听到你说你知道失败的原因。让我们快速添加对除法的支持并重新运行测试用例，看看它是否全部变成绿色！BDD让编码变得真的很有趣。
- en: 'We need to add the following code snippet in `RPNCalculator.cpp`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`RPNCalculator.cpp`中添加以下代码片段：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With this code change, let''s check the test output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个代码更改，让我们检查测试输出：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following screenshot demonstrates the procedure visually:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图以可视化方式演示了该过程：
- en: '![](img/bc21a042-07ff-4e90-ac55-0df232525fbd.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc21a042-07ff-4e90-ac55-0df232525fbd.png)'
- en: So far so good. All the scenarios we tested so far have passed, which is a good
    sign. But let's try a complex expression that involves many math operations. For
    instance, let's try *10.0 5.0 * 1.0 + 100.0 2.0 / -*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切都很顺利。到目前为止，我们测试过的所有场景都通过了，这是一个好迹象。但让我们尝试一个涉及许多数学运算的复杂表达式。例如，让我们尝试*10.0
    5.0 * 1.0 + 100.0 2.0 / -*。
- en: '**Did you know?**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**你知道吗？**'
- en: Reverse Polish Notation (postfix notation) is used by pretty much every compiler
    to evaluate mathematical expressions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 逆波兰表示法（后缀表示法）被几乎每个编译器用来评估数学表达式。
- en: 'The following screenshot demonstrates the integration of the complex expression
    test case:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了复杂表达式测试用例的集成：
- en: '![](img/46f4b83b-7b57-4b9b-9dea-9a245a865942.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46f4b83b-7b57-4b9b-9dea-9a245a865942.png)'
- en: Let's run the test scenarios one more time, as this would be a real test for
    the entire code implemented so far, as this expression involves all the operations
    our simple application supports.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行测试场景，因为这将是迄今为止实施的整个代码的真正测试，因为这个表达式涉及我们简单应用程序支持的所有操作。
- en: 'The following command can be used to launch the application in the background
    mode and to execute the Cucumber test cases:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可用于在后台模式下启动应用程序并执行Cucumber测试用例：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following screenshot demonstrates the procedure visually:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图以可视化方式演示了该过程：
- en: '![](img/0bf986c9-4996-437b-a00e-cfa466d1c553.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bf986c9-4996-437b-a00e-cfa466d1c553.png)'
- en: Great! If you have come this far, I'm sure you would have understood cucumber-cpp
    and the BDD style of coding.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！如果您已经走到这一步，我相信您已经了解了cucumber-cpp和BDD编码风格。
- en: '**Refactoring and Removing Code Smells**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构和消除代码异味**'
- en: The `RPNCalculator.cpp` code has too much branching, which is a code smell;
    hence, the code could be refactored. The good news is that `RPNCalculator.cpp`
    can be refactored to remove the code smells and has the scope to use the Factory
    Method, Strategy, and Null Object Design Patterns.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPNCalculator.cpp`代码中的分支太多，这是一个代码异味；因此，代码可以进行重构。好消息是`RPNCalculator.cpp`可以进行重构以消除代码异味，并有使用工厂方法、策略和空对象设计模式的空间。'
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the following
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了以下内容
- en: Behavior-driven development in short is referred as BDD.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发简称为BDD。
- en: BDD is a top-down development approach and uses Gherkin language as Domain Specific
    Language (DSL).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BDD是一种自顶向下的开发方法，并使用Gherkin语言作为领域特定语言（DSL）。
- en: In a project, BDD and TDD can be used side by side as they complement each other
    and not replace one another.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个项目中，BDD和TDD可以并行使用，因为它们互补而不是取代彼此。
- en: The cucumber-cpp BDD Framework makes use of wire protocol to support non-ruby
    platforms to write test cases.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cucumber-cpp BDD框架利用wire协议来支持非ruby平台编写测试用例。
- en: You learned BDD in a practical fashion by implementing an RPNCalculator with
    test-first development approach.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实施测试驱动开发方法，您以实际方式学习了BDD。
- en: BDD similar to TDD, it encourages developing clean code by refactoring the code
    in short-intervals in an incremental fashion.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BDD类似于TDD，它鼓励通过以增量方式短间隔重构代码来开发清晰的代码。
- en: You learned writing BDD test cases with Gherkin and the steps definition using
    Google test framework.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了使用Gherkin编写BDD测试用例以及使用Google测试框架定义步骤。
- en: In the next chapter, you will be learning about C++ debugging techniques.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习有关C++调试技术的知识。
