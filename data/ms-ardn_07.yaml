- en: Programming the Arduino - Beyond the Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程 Arduino - 超越基础
- en: One of the things that I learned early on in my development career is that I
    can write some pretty amazing applications even if I only know the basics of the
    programming language that I am using; however, it usually makes the code hard
    to maintain and read while also adding significant development time to the project.
    I always tell people that are learning a language to take the time to understand
    some of the more advanced features of the language they are learning prior to
    using it for serious projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的开发生涯早期，我学到的其中一件事是，即使我只了解我使用的编程语言的基础知识，我也能编写一些相当惊人的应用程序；然而，这通常会使代码难以维护和阅读，同时也会给项目增加显著的开发时间。我总是告诉正在学习语言的人，在为严肃的项目使用它之前，花时间了解他们正在学习的语言的更高级功能。
- en: 'In this chapter, we will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: How to set the pin mode on an Arduino digital pin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置 Arduino 数字引脚的引脚模式
- en: How to get and set the values of an Arduino digital pin
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取和设置 Arduino 数字引脚的值
- en: How to get and set the values of an Arduino analog pin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取和设置 Arduino 模拟引脚的值
- en: How to use structures and unions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用结构和联合
- en: How to use additional tabs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用额外的标签页
- en: How to use classes and objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用类和对象
- en: In the previous chapter, we looked at the basics of the Arduino programming
    language. In this chapter, we are going to go beyond the basics of the language
    itself. We will start off by looking at how we can interact with the digital pins
    on the Arduino.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Arduino 编程语言的基础知识。在本章中，我们将超越语言本身的基础。我们将从查看我们如何与 Arduino 上的数字引脚交互开始。
- en: For the samples in this chapter, we will be using the prototype that we created
    at the end of [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml), *Basic Prototyping*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，我们将使用在 [第 4 章](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml)，*基本原型* 的末尾创建的原型。
- en: Setting digital pin mode
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数字引脚模式
- en: 'In [Chapter 1](a46a0d68-6899-45e9-8f90-3ba0f15ad9e6.xhtml), *The Arduino*,
    we saw that the Arduino has several digital pins that we can connect external
    sensors and other devices to. Before we use these pins, we should configure them
    for either input or output depending on what we are using them for. To do this,
    we use the `pinMode()` function that is built into the Arduino programming language.
    Usually for smaller sketches we call the `pinMode()` function within the `setup()`
    function; however, this is not required. The following code shows the syntax for
    the `pinMode()` function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](a46a0d68-6899-45e9-8f90-3ba0f15ad9e6.xhtml)，*Arduino* 中，我们看到了 Arduino
    有几个数字引脚，我们可以将外部传感器和其他设备连接到这些引脚上。在我们使用这些引脚之前，我们应该根据我们使用它们的目的来配置它们为输入或输出。为此，我们使用内置在
    Arduino 编程语言中的 `pinMode()` 函数。通常对于较小的草图，我们在 `setup()` 函数中调用 `pinMode()` 函数；然而，这并不是必需的。以下代码展示了
    `pinMode()` 函数的语法：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This function is called with two parameters. The first is the number of the
    pin that we are setting and the second is the mode for the pin. The mode for the
    pin can be either `INPUT`, to read the value from the pin (external sensor writes
    a value to the pin), or `OUTPUT`, to set the value for the pin. The following
    code shows how to use this command to set the pin mode for two pins:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用两个参数调用。第一个是我们设置的引脚号，第二个是引脚的模式。引脚的模式可以是 `INPUT`，从引脚读取值（外部传感器将值写入引脚），或者
    `OUTPUT`，为引脚设置值。以下代码展示了如何使用此命令设置两个引脚的引脚模式：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we set pin `11` to input and pin `12` for output. Therefore,
    we would write values to pin 11 and read values from pin 12.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将引脚 `11` 设置为输入，引脚 `12` 设置为输出。因此，我们将值写入引脚 11，并从引脚 12 读取值。
- en: It is good practice never to use the pin numbers themselves, as shown in the
    last example, to access the pin on the Arduino. Instead of using the pin numbers
    like this, we should set a variable or constant with the number of the pin and
    then use that variable or constant when accessing the pin. This will prevent us
    from typing in the wrong number within the code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的做法是永远不要像在最后一个例子中那样使用引脚号本身来访问 Arduino 上的引脚。而不是像这样使用引脚号，我们应该设置一个变量或常数，包含引脚的数字，然后在访问引脚时使用该变量或常数。这将防止我们在代码中输入错误的数字。
- en: My personal preference is to use `#define` to define the pin numbers that I
    am using when the pin number will not change. This allows me to separate my pin
    definitions from the other constants within my sketch.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我的个人偏好是当引脚号不会改变时，使用 `#define` 来定义我使用的引脚号。这允许我将我的引脚定义与其他常数分开。
- en: If you wish to use constants instead of `#define`, that is perfectly acceptable,
    and some people would say that it is preferable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用常量而不是`#define`，这是完全可以接受的，有些人甚至会说这是首选的。
- en: 'The following code shows how we should use the `pinMode()` function within
    a sketch:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何在草图中使用`pinMode()`函数：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we defined constants that represented two pins. The first
    line defines `BUTTON_ONE` to the number (pin) `12` and the second line defines
    `LED_ONE` to the number (pin) `11`. We then set the `BUTTON_ONE` pin to input
    mode and `LED_ONE` pin to output mode within the `setup()` function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了代表两个引脚的常量。第一行将`BUTTON_ONE`定义为数字（引脚）`12`，第二行将`LED_ONE`定义为数字（引脚）`11`。然后，我们在`setup()`函数中将`BUTTON_ONE`引脚设置为输入模式，将`LED_ONE`引脚设置为输出模式。
- en: The `pinMode()` function can also be used to configure the internal pull-up
    resistor by setting the mode of the pin to `INPUT_PULLUP`. This will invert the
    behavior of the pin when it is in input mode.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`pinMode()`函数也可以用来通过设置引脚的模式为`INPUT_PULLUP`来配置内部上拉电阻。这将改变引脚在输入模式下的行为。'
- en: 'These digital pins may have one of two values: `HIGH` or `LOW`. Let''s see
    how we can set the value of a digital pin.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字引脚可能有两个值之一：`HIGH`或`LOW`。让我们看看我们如何设置数字引脚的值。
- en: Digital write
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字写入
- en: 'To set the value of a digital pin in the Arduino programming language, we use
    the `digitalWrite()` function. This function takes the following syntax:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino编程语言中设置数字引脚的值时，我们使用`digitalWrite()`函数。此函数的语法如下：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `digitalWrite()` function accepts two parameters, where the first one is
    the pin number and the second is the value to set. We should use either `HIGH`
    or `LOW` when setting the value of a digital pin. The following code shows how
    to do this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`digitalWrite()`函数接受两个参数，第一个是引脚号，第二个是要设置的值。在设置数字引脚的值时，我们应该使用`HIGH`或`LOW`。以下代码显示了如何进行此操作：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we set the pin defined by the `LED_ONE` constant too
    `HIGH` and then pause for half a second. The `delay()` function in the Arduino
    programming language pauses the execution of the sketch for a certain amount of
    time. The time for this function is in milliseconds. After the `delay()` function
    we then set the pin defined by the `LED_ONE` constant too `LOW` and wait another
    half a second before looping back to the beginning.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将由`LED_ONE`常量定义的引脚设置为`HIGH`，然后暂停半秒钟。Arduino编程语言中的`delay()`函数会暂停脚本的执行一段时间。这个函数的时间是以毫秒为单位的。在`delay()`函数之后，我们接着将`LED_ONE`常量定义的引脚设置为`LOW`，并在返回到开始之前再等待半秒钟。
- en: The previous code can be used in the `loop()` function to blink an LED; however,
    before we do that we need to define the `LED_ONE` constant and also set the pin
    mode. Let's look at the full sketch required to blink an LED.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以用在`loop()`函数中闪烁一个LED；然而，在我们这样做之前，我们需要定义`LED_ONE`常量并设置引脚模式。让我们看看闪烁LED所需的完整草图。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code starts off by defining the `LED_ONE` constant and setting to `11`.
    The pin mode for the `LED_ONE` pin is then set in the `setup()` function. Finally,
    the code that will cause the LED to blink is added to the `loop()` function. If
    you connect the prototype that we developed in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping* and ran this code, you should see one of the LEDs blinking.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先定义了`LED_ONE`常量并将其设置为`11`。然后，在`setup()`函数中设置了`LED_ONE`引脚的引脚模式。最后，将使LED闪烁的代码添加到`loop()`函数中。如果你连接了我们在[第4章](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml)，“基本原型”中开发的原型，并运行此代码，你应该会看到其中一个LED闪烁。
- en: Now that we know how to write to a digital pin, let's see how we can read the
    value of one.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何向数字引脚写入，让我们看看我们如何读取一个引脚的值。
- en: Digital read
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字读取
- en: 'To read the value of a digital pin in the Arduino programming language, we
    use the `digitalRead()` function. This function takes the following syntax:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino编程语言中读取数字引脚的值时，我们使用`digitalRead()`函数。此函数的语法如下：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `digitalRead()` function takes one parameter, which is the number of the
    digital pin to read, and will return an integer value. The following code shows
    how we can use the `digitalRead()` function to read one of the digital pins on
    the Arduino:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`digitalRead()`函数接受一个参数，即要读取的数字引脚的编号，并将返回一个整数值。以下代码显示了如何使用`digitalRead()`函数读取Arduino上的一个数字引脚：'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this code, the `digitalRead()` function will return the value of the pin
    defined by the `BUTTON_ONE` constant and put that value into the variable named
    `val`. The `val` variable is defined to be an integer. However, the `digitalRead()`
    function will only return a 0 or a 1\. We can use the same `HIGH` and `LOW` constants
    that we saw in the *Digital write* section to see if the pin is either high or
    low. Using these constants are preferred and makes your code more readable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，`digitalRead()`函数将返回由`BUTTON_ONE`常量定义的引脚的值，并将该值放入名为`val`的变量中。`val`变量被定义为整数类型。然而，`digitalRead()`函数只会返回0或1。我们可以使用我们在*数字写入*部分看到的相同的`HIGH`和`LOW`常量来查看引脚是高电平还是低电平。使用这些常量是首选的，并且可以使你的代码更易读。
- en: 'Now let''s see how we can use the `digitalRead()` function to read the status
    of a button. The following code will read the status of the button from the prototype
    that we built in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml), *Basic Prototyping*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用`digitalRead()`函数读取按钮的状态。以下代码将读取我们在[第4章](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml)中构建的原型*基本原型制作*的按钮状态：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code starts off by defining the `BUTTON_ONE` constant and setting it to
    `12`. The serial monitor and the pin mode for the pin that the button is connected
    to are both configured in the `setup()` function. Within the loop button, the
    `digitalRead()` function is used to read the pin and the `if` statement is used
    to compare the value that was returned with the `HIGH` constant. If they are equal,
    then the message `Button HIGH` is sent to the serial monitor otherwise the message
    `Button LOW` is sent.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先定义了`BUTTON_ONE`常量并将其设置为`12`。串行监视器和按钮连接的引脚模式都在`setup()`函数中配置。在循环按钮中，使用`digitalRead()`函数读取引脚，并使用`if`语句比较返回的值与`HIGH`常量。如果它们相等，则将消息`Button
    HIGH`发送到串行监视器，否则发送消息`Button LOW`。
- en: If this code is run on the prototype that was created in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*, then you should see one of the two messages being printed
    to the serial monitor depending if the button is pressed or not.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在[第4章](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml)中创建的原理图上运行此代码，*基本原型制作*，那么你应该会看到两个消息之一被打印到串行监视器，具体取决于按钮是否被按下。
- en: Now let's see how we can write to an analog pin on the Arduino.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何向Arduino上的模拟引脚写入数据。
- en: Analog write
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟写入
- en: Analog values are written to the Arduino with the **Pulse-Width Modulation**
    (**PWM**) pins. In [Chapter 1](a46a0d68-6899-45e9-8f90-3ba0f15ad9e6.xhtml), *The
    Arduino*, we looked at what PWM is and how they work. On most Arduino boards the
    PWM pins are configured for pins 3, 5, 6, 9, 10, and 11; however, the Arduino
    Mega has significantly more pins available for PWM functionality.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟值是通过Arduino的**脉冲宽度调制**（**PWM**）引脚写入的。在[第1章](a46a0d68-6899-45e9-8f90-3ba0f15ad9e6.xhtml)中，*Arduino*，我们探讨了PWM是什么以及它们是如何工作的。在大多数Arduino板上，PWM引脚被配置为引脚3、5、6、9、10和11；然而，Arduino
    Mega有更多可用的引脚用于PWM功能。
- en: 'To perform an analog write, we use the `analogWrite()` function, which takes
    the following syntax:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行模拟写入，我们使用`analogWrite()`函数，其语法如下：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `analogWrite()` function accepts two parameters, where the first one is
    the pin number and the second is the value to set. The value for the `analogWrite()`
    function can range from 0 to 255.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`analogWrite()`函数接受两个参数，第一个是引脚号，第二个是要设置的值。`analogWrite()`函数的值可以从0到255。'
- en: 'Let''s look at a sample sketch to see how we can use the `analogWrite()` function
    to fade a led in and out:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例草图，看看我们如何使用`analogWrite()`函数来使LED淡入淡出：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code starts off by defining a `LED_ONE` constant with a value of `11`.
    This will be the pin that the LED is connected to. There are also two global variables
    defined, both of the integer type, named `val` and `change`. The `val` integer
    will store the current value of the analog pin, and the `change` integer will
    store how much the `val` integer should change each loop.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先定义了一个值为`11`的`LED_ONE`常量。这将是要连接LED的引脚。还定义了两个全局变量，都是整数类型，分别命名为`val`和`change`。`val`整数将存储模拟引脚的当前值，而`change`整数将存储每次循环`val`整数应更改的量。
- en: The pin defined by the `LED_ONE` constant is set to output mode within the `setup()`
    function. This will enable us to write to the pin and change the brightness of
    the LED connected to the pin.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，由`LED_ONE`常量定义的引脚被设置为输出模式。这将使我们能够向引脚写入数据并改变连接到该引脚的LED的亮度。
- en: The `loop()` function starts off by adding the `change` variable to the `val`
    variable, and the result is stored in the `val` variable. If the value of the
    `val` variable is greater than 250 or less than 5 we multiple the `change` variable
    by -1\. This causes the `change` variable to rotate between 5 and -5, which causes
    the `val` variable to increase or decrease each loop. Finally, the value of the
    `val` variable is written to the pin defined by the `LED_ONE` constant, and then
    there is a short delay before looping back.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()`函数首先将`change`变量加到`val`变量上，并将结果存储在`val`变量中。如果`val`变量的值大于250或小于5，我们将`change`变量乘以-1。这导致`change`变量在5和-5之间旋转，从而使`val`变量在每次循环中增加或减少。最后，将`val`变量的值写入由`LED_ONE`常量定义的引脚，然后在循环回之前有一个短暂的延迟。'
- en: If this code is run on the prototype that was created in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*, then you should see LED fade in and out. Now let's look at
    how we can read an analog pin.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在[第4章](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml)中创建的原型上运行此代码，*基本原型制作*，你应该会看到LED灯闪烁。现在让我们看看如何读取模拟引脚。
- en: Analog read
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟读取
- en: 'We read the value from an analog pin using the `analogRead()` function. This
    function will return a value between 0 and 1023\. This means that if the sensor
    is returning the full voltage of 5V, then the `analogRead()` function will return
    a value 1023, which results in a value of 0.0049V per unit (we will use this number
    in the sample code). The following code shows the syntax for the `analogRead()`
    function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`analogRead()`函数从模拟引脚读取值。此函数将返回介于0到1023之间的值。这意味着如果传感器返回满电压5V，那么`analogRead()`函数将返回1023的值，这导致每单位值为0.0049V（我们将在示例代码中使用这个数字）。以下代码显示了`analogRead()`函数的语法：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `analogRead()` function takes one parameter which is the pin to read from.
    The following code uses the `analogRead()` function with a tmp36 temperature sensor
    to determine the current temperature:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`analogRead()`函数接受一个参数，即要读取的引脚。以下代码使用`analogRead()`函数和一个tmp36温度传感器来确定当前温度：'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code starts off by defining the pin that the temperature sensor
    is attached to which is the analog pin 5\. The `setup()` function configures the
    serial monitor so the application can print the temperature to it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先定义了温度传感器连接的引脚，即模拟引脚5。`setup()`函数配置串行监视器，以便应用程序可以将其打印到监视器上。
- en: The `loop()` function begins by reading the analog pin and storing the value
    in the `pinValue` variable. To convert this value to the actual voltage, we multiply
    it by the 0.0049V value that we saw earlier in this section. If we look at the
    datasheet for the tmp36 temperature sensor, we will determine that the `(voltage
    - .5) *100.0` is the correct formula to calculate the temperature in Celsius.
    We can then use the standard formula `(celsiusTemp *1.8) + 32` to determine the
    temperature in Fahrenheit. Finally, we print these values to the serial monitor
    and delay for two seconds before beginning the loop again.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()`函数首先读取模拟引脚并将值存储在`pinValue`变量中。要将此值转换为实际电压，我们将其乘以本节之前看到的0.0049V值。如果我们查看tmp36温度传感器的数据表，我们将确定`(电压
    - .5) *100.0`是计算摄氏温度的正确公式。然后我们可以使用标准公式`(摄氏温度 *1.8) + 32`来确定华氏温度。最后，我们将这些值打印到串行监视器，并在开始下一次循环之前延迟两秒钟。'
- en: We will be using the `digitalRead()`, `digitalWrite()`, `analogRead()` and `analogWrite()`
    functions a lot in this book so you will be getting familiar with them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将大量使用`digitalRead()`、`digitalWrite()`、`analogRead()`和`analogWrite()`函数，因此你会熟悉它们。
- en: Now let's look at structures.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看结构体。
- en: Structures
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: 'A structure is a user-defined a composite data type that is used to group multiple
    variables together. The variables in a structure may be of different types enabling
    us to store related data, of different types, together. The following code shows
    the syntax of how we would define a structure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是一种用户定义的复合数据类型，用于将多个变量组合在一起。结构体中的变量可以是不同类型，使我们能够将不同类型的关联数据存储在一起。以下代码显示了定义结构体的语法：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When a structure is defined, the `struct` keyword is used followed by the name
    of the structure. The variable list is then defined between the curly brackets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义结构体时，使用`struct`关键字后跟结构体的名称。然后定义变量列表，位于花括号之间。
- en: 'Let''s take a look at how we can create and use a structure by changing the
    previous sketch, which used the `analogRead()` function to read the TMP36 temperature,
    to use a structure. The first thing we need to do is to define a structure that
    will store the temperature information from the sensor. We will name this structure
    `tmp36_reading,` and it will contain three variables all of the double type. The
    following code shows how to define this structure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过将之前使用 `analogRead()` 函数读取 TMP36 温度的草图改为使用结构来创建和使用结构。首先，我们需要定义一个结构来存储传感器的温度信息。我们将把这个结构命名为
    `tmp36_reading`，它将包含三个双精度类型的变量。以下代码显示了如何定义这个结构：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code defines a structure named `tmp36_reading` that contains three
    variables all of the double type. Keep in mind that the variables in a structure
    do not have to be of the same type, it just worked out that all of the individual
    variables in this structure were of the double type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为 `tmp36_reading` 的结构，它包含三个双精度类型的变量。请注意，结构中的变量不必是同一类型，只是这个结构中的所有单个变量都是双精度类型。
- en: 'The following code shows how we would create a variable of the `tmp36_reading`
    type:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何创建 `tmp36_reading` 类型的变量：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code creates a variable named `temp` that is of the `tmp36_reading`
    type. We can then assign or retrieve values by using the dot syntax as shown in
    the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个名为 `temp` 的变量，其类型为 `tmp36_reading`。然后我们可以使用点语法来赋值或检索值，如下所示：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code we assign values to the `voltage`, `tempC` and `tempF`
    variables of the `tmp36_reading` structure. Now let''s see how we can integrate
    this code into a sketch that reads the TMP36 temperature sensor. The following
    is the complete code for the new sketch:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为 `tmp36_reading` 结构的 `voltage`、`tempC` 和 `tempF` 变量赋值。现在让我们看看如何将这段代码集成到一个读取
    TMP36 温度传感器的草图中去。以下是新草图的完整代码：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This sketch functions exactly like the previous sketch that read the TMP36 temperature
    sensor, except now we use a structure to store the values from the sensor rather
    than variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图的功能与之前读取 TMP36 温度传感器的草图完全相同，但现在我们使用结构来存储传感器的值，而不是变量。
- en: If you have multiple values that you can group together like this, it is recommended
    that we use a structure rather than variables because all of the values are grouped
    together in one structure.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多组可以像这样组合在一起的价值，建议我们使用结构而不是变量，因为所有的值都组合在一个结构中。
- en: Now let's look at another special data type that may look similar to a structure;
    however, the functionality is significantly different.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种可能看起来与结构相似的特殊数据类型；然而，其功能有显著不同。
- en: Unions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合
- en: 'A union is a special data type that enables us to store different data types
    in a single definition, similar to the structure; however, only one of the members
    may contain data at any one time. The following shows the syntax for defining
    a union:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 联合是一种特殊的数据类型，它允许我们在单个定义中存储不同的数据类型，类似于结构；然而，在任何时候只能有一个成员包含数据。以下是如何定义联合的语法：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the syntax looks a lot like the syntax for a structure. In fact, it is the
    same syntax except for the `struct`/`union` keywords.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语法看起来很像结构的语法。实际上，它确实是相同的语法，只是 `struct`/`union` 关键字不同。
- en: 'Let''s see how we would use a union. The following code defines a new union:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用联合。以下代码定义了一个新的联合：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code defines a union named `some_data` that can contain an integer,
    double or a character string. The keyword in that last sentence is the *o**r*.
    Unlike the structure, which can store several different values, a union can only
    store one value at a time. The following code will illustrate this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为 `some_data` 的联合，它可以包含整数、双精度或字符字符串。最后一句中的关键字是 *或*。与可以存储多个不同值的结构不同，联合一次只能存储一个值。以下代码将演示这一点：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we define a union named `some_data`. Then in the `setup()`
    function we create an instance of the `some_data` union type named `myData`. We
    then assign values to each member of the union type. The integer member is set
    to `42`, the double member is set to `3.14` and the character string is set to
    `Arduino`. When this code is run, we will see that the `Arduino` character string
    is correctly printed to the serial monitor; however, when the integer and double
    members are printed to the serial monitor the information is not correct.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为`some_data`的联合体。然后在`setup()`函数中，我们创建了一个名为`myData`的`some_data`联合体类型的实例。然后我们为联合体类型的每个成员分配值。整数成员设置为`42`，双精度浮点数成员设置为`3.14`，字符字符串设置为`Arduino`。当运行此代码时，我们将看到`Arduino`字符字符串被正确地打印到串行监视器中；然而，当整数和双精度浮点数成员被打印到串行监视器时，信息是不正确的。
- en: In the previous example, when the `some_data.i` member is set to `42`, the `some_data`
    union will contain the integer 42\. Then when we set the `some_data.d` member
    to `3.14`, the integer value of 42 is overwritten, and the `some_data` union would
    now contain 3.14\. Finally when we set the `some_data.s` member to `Arduino` it
    overwrites the `some_data.d` member, so the `some_data` union now contains the
    string `Arduino`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当`some_data.i`成员设置为`42`时，`some_data`联合体将包含整数42。然后当我们设置`some_data.d`成员为`3.14`时，42的整数值被覆盖，`some_data`联合体现在将包含3.14。最后，当我们设置`some_data.s`成员为`Arduino`时，它覆盖了`some_data.d`成员，因此`some_data`联合体现在包含字符串`Arduino`。
- en: Before we look at more features of the Arduino programming language, let's look
    at another feature of the Arduino IDE and the Web Editor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看Arduino编程语言的更多功能之前，让我们看看Arduino IDE和Web编辑器的另一个功能。
- en: Adding tabs
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加标签页
- en: As you begin to work with larger and more complex projects, it quickly becomes
    important to divide your code up into separate workspaces because it makes your
    code easier to manage. To do this, in both the Arduino IDE and the Web Editor,
    we can add new tabs to a sketch.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始处理更大、更复杂的项目时，迅速将代码分成单独的工作空间变得非常重要，因为这使你的代码更容易管理。为了做到这一点，在Arduino IDE和Web编辑器中，我们可以在草图中添加新的标签页。
- en: 'To add a new tab to the Arduino IDE, click on the button with an upside-down
    triangle in it that is located at the upper right side of the IDE window, as shown
    in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Arduino IDE中添加一个新标签页，请点击位于IDE窗口右上角的倒三角形按钮，如下面的截图所示：
- en: '![](img/17df9d15-3f78-4982-80fc-48a433b0694e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17df9d15-3f78-4982-80fc-48a433b0694e.png)'
- en: 'In the window that pops up, click on the New Tab option, and you will see an
    orange bar below the code section of the Arduino IDE windows. In this orange bar,
    you can name the new tab and then press the OK button to create the tab. The following
    screenshot shows how to name the new tab:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出的窗口中，点击“新建标签页”选项，你将在Arduino IDE窗口的代码部分下方看到一个橙色条。在这个橙色条中，你可以命名新标签页，然后按“确定”按钮创建标签页。以下截图显示了如何命名新标签页：
- en: '![](img/af64ca57-2280-48f2-ba1a-0718dabd3aaf.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af64ca57-2280-48f2-ba1a-0718dabd3aaf.png)'
- en: 'Once you click OK a new tab is created, with the name you gave it, as shown
    in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击“确定”，就会创建一个新标签页，其名称如以下截图所示：
- en: '![](img/0c582b88-8706-47a0-a7ed-8536061683e7.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c582b88-8706-47a0-a7ed-8536061683e7.png)'
- en: We can create a new tab in the Web Editor exactly as we did in the Arduino IDE.
    In the Web Editor, there is a similar button with an upside-down triangle. When
    that button is clicked a menu will appear, and you can select the New Tab option.
    Once you name the new tab, it will appear in the Web Editor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Web编辑器中创建一个新标签页，就像在Arduino IDE中做的那样。在Web编辑器中，有一个类似的倒三角形按钮。当点击该按钮时，将出现一个菜单，你可以选择“新建标签页”选项。一旦你命名了新标签页，它就会出现在Web编辑器中。
- en: Before we start adding tabs to our projects, we need to have a plan on how we
    want to separate the code. I find that for large projects it is good practice
    to only have the `setup()` and `loop()` functions in the main tab. I then create
    a tab for each functional area of the project. For example, if I made a weather
    station that had both temperature rain sensors, then I would have my main tab
    with the `setup()` and `loop()` functions and then have two additional tabs; one
    for the temperature sensor functionality and one for the rain sensor functionality.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向我们的项目添加标签页之前，我们需要有一个计划，即我们想要如何分离代码。我发现对于大型项目来说，只将`setup()`和`loop()`函数放在主标签页上是一种好的做法。然后我为项目的每个功能区域创建一个标签页。例如，如果我制作了一个包含温度和雨量传感器的气象站，那么我的主标签页将包含`setup()`和`loop()`函数，然后会有两个额外的标签页；一个用于温度传感器功能，另一个用于雨量传感器功能。
- en: In addition to using additional tabs for code, it is also good practice, for
    larger projects and libraries, to have tabs that define constants that need to
    be used in multiple tabs. These constants are usually put into header files. A
    header file should be named with a `.h` extension. Now let's see how to work with
    tabs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用额外的标签进行代码外，对于较大的项目和库，将定义需要在多个标签中使用的常量的标签也是良好的实践。这些常量通常放入头文件中。头文件应该以 `.h`
    扩展名命名。现在让我们看看如何使用标签。
- en: Working with tabs
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签
- en: When creating a new tab, the first thing we need to decide is what is going
    to the tab. For example in this section, we will create two new tabs. One will
    be named `led.h` and the other `led`. The `led.h` file will contain the constant
    definition, and the `led` file will contain code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新标签时，我们需要决定标签将包含什么。例如，在本节中，我们将创建两个新的标签。一个将命名为 `led.h`，另一个 `led`。`led.h` 文件将包含常量定义，而
    `led` 文件将包含代码。
- en: When we create a tab with the `.h` extension we are creating, what is known
    in the C language, a header file. A header file is a file that contains declarations
    and macro definitions. These tabs can then be included in the normal code tabs.
    In the next section, we will see another type of tab which is the cpp tab.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个以 `.h` 扩展名结尾的标签时，我们正在创建 C 语言中所谓的头文件。头文件是一个包含声明和宏定义的文件。这些标签可以随后包含在正常的代码标签中。在下一节中，我们将看到另一种类型的标签，即
    cpp 标签。
- en: 'Once the new tabs are created, add the following code to the `led.h` tab:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新的标签，请将以下代码添加到 `led.h` 标签中：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code will define two constants, which are the pin header numbers for the
    two LEDs on the prototype that we built in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*. The `#ifndef` and `#endif` ensure that the header file is
    imported only once within any tab. The `#ifndef` looks to see if the `LED_H` constant
    is defined, and if not then it includes the code between the `#ifndef` and `#endif`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将定义两个常量，它们是我们构建在 [第 4 章](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml) 中，*基本原型*上的两个
    LED 的引脚编号。`#ifndef` 和 `#endif` 确保头文件在任何标签中只导入一次。`#ifndef` 会检查 `LED_H` 常量是否已定义，如果没有，则包含
    `#ifndef` 和 `#endif` 之间的代码。
- en: 'Now in the `led` tab add the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `led` 标签中添加以下代码：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `blink_led()` function contains a single parameter, which will be the pin
    for the LED that we wish to blink. The function itself will turn the LED on for
    1/2 a second and then turn it off.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`blink_led()` 函数包含一个单一参数，它将是我们要闪烁的 LED 的引脚。该函数本身将 LED 打开 1/2 秒，然后关闭。'
- en: 'Now in the main tab, we will need to include an `#include` statement at the
    top of the tab to include the `led.h` header file. The following code shows how
    to do this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在主标签中，我们将在标签顶部需要包含一个 `#include` 语句来包含 `led.h` 头文件。以下代码显示了如何做到这一点：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `#include` statement will take a header file and includes it in the tab,
    allowing us to use the definitions within our code. If we attempted to use one
    of the constants within our code but forgot to include the header file, we would
    receive an error that the constant was not declared in this scope meaning the
    compiler was unable to find the declarations for the constant.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include` 语句将头文件包含在标签中，使我们能够在代码中使用这些定义。如果我们试图在我们的代码中使用某个常量，但忘记了包含头文件，我们会收到一个错误，表明常量在此作用域中未声明，这意味着编译器无法找到常量的声明。'
- en: If we are adding a header file from the sketch, we are working in, the name
    of the header file is surrounded by double quotes. If we include a header file
    from a separate library the name will be surrounded by the less than and greater
    than signs. We will see this later in this book as we use third-party libraries.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从正在工作的草图添加头文件，头文件的名称将被双引号包围。如果我们从单独的库中包含头文件，名称将被小于号和大于号包围。我们将在本书后面使用第三方库时看到这一点。
- en: 'In the `loop()` function, we will want to call the `blink_led()` function from
    the `led` tab. One thing to note here is we only need to include the `#include`
    statement for the header file and not for the tab that contains the code. The
    following shows the code for the main tab:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loop()` 函数中，我们将想要从 `led` 标签中调用 `blink_led()` 函数。这里需要注意的是，我们只需要包含头文件的 `#include`
    语句，而不是包含代码的标签。以下显示了主标签的代码：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now if you connect the prototype that we created in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*, you should see the LEDs blink one after the other.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您连接了我们在[第4章](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml)，“基本原型”中创建的原型，应该会看到LED灯依次闪烁。
- en: Dividing your code between separate tabs is a great way to organize it when
    working with larger projects. This makes it a lot easier to maintain and organize
    your code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大型项目时，将代码分布在单独的标签页中是一种很好的组织方式。这使得维护和组织代码变得容易得多。
- en: Classes are usually used when creating libraries for the Arduino. While creating
    libraries is beyond the scope of this book, it is good to know what classes are
    and how to use them because we will be using libraries in certain sections of
    this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Arduino创建库时通常使用类。虽然创建库超出了本书的范围，但了解类是什么以及如何使用它们是很好的，因为我们将在这本书的某些部分使用库。
- en: Object-oriented programming
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**Object-oriented programming** (**OOP**) is a programming paradigm that helps
    us divide our code into reusable components using classes and objects. An object
    is designed to model something. For example, we could create an LED object that
    will contain the properties and functionality we want for a LED; however, before
    we can create an object we need to have a blueprint for it. This blueprint is
    called a **class**. Let''s see how this works by creating a class that will help
    us control a LED.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）是一种编程范式，它帮助我们通过类和对象将代码划分为可重用的组件。对象是为了模拟某物而设计的。例如，我们可以创建一个LED对象，该对象将包含我们想要用于LED的属性和功能；然而，在我们能够创建对象之前，我们需要为其创建一个蓝图。这个蓝图被称为**类**。让我们通过创建一个帮助我们控制LED的类来了解这是如何工作的。'
- en: 'We will start off by creating two new tabs named `led.cpp` and `led.h`. The
    `led.h` file will contain the definition for the class, and the `led.cpp` file
    will contain the code. Let''s start off by adding the following code to the `led.h`
    file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建两个新的标签页，分别命名为`led.cpp`和`led.h`。`led.h`文件将包含类的定义，而`led.cpp`文件将包含代码。让我们首先将以下代码添加到`led.h`文件中：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The code is similar to the `led.h` file in the working with tabs section except
    the `Led` class definition is added. The `Led` class definition defines three
    properties (variables) for the class: `ledPin`, `onTime`, and `offTime`. Previous
    to this example, all of the variables we used have been either global variables
    or defined within a function. Class properties are variables that are defined
    within a class and usually define something about the object. In this example,
    the `ledPin` property defines what pin the LED is connected to; the `onTime` property
    defines the amount of time to keep the LED on and the `offTime` property defines
    how long to keep the LED off.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码与“使用标签页”部分中的`led.h`文件类似，除了添加了`Led`类定义。`Led`类定义定义了类的三个属性（变量）：`ledPin`、`onTime`和`offTime`。在此示例之前，我们使用的所有变量要么是全局变量，要么是在函数中定义的。类属性是在类中定义的变量，通常定义了关于对象的某些内容。在这个例子中，`ledPin`属性定义了LED连接到的引脚；`onTime`属性定义了保持LED开启的时间；`offTime`属性定义了保持LED关闭的时间。
- en: After the properties, a constructor for the class is defined. A constructor
    is used to create an instance of a class, and we will see how to use this later
    in this section. After the constructor, three methods (functions) for the class.
    A class method is simply a function that is part of a class and usually defines
    the functionality of an object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性之后，定义了一个类的构造函数。构造函数用于创建类的实例，我们将在本节后面看到如何使用它。在构造函数之后，有三个类方法（函数）。类方法简单来说就是属于类的一部分的函数，通常定义了对象的功能。
- en: 'Where the `led.h` tab contains the definition for the `Led` class, the `led.cpp`
    tab contains the code for the class. Let''s add the following code to the `led.cpp`
    tab:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`led.h`标签页中包含`Led`类的定义，而`led.cpp`标签页包含类的代码。让我们将以下代码添加到`led.cpp`标签页中：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code starts off by importing two header files. The first header file is
    the `led.h` file that we just created and the second is the `Arduino.h` header
    file. The `Arduino.h` header file contains the definitions for all of the custom
    Arduino functions. It is automatically added to the main tab; however, if you
    wish to use the Arduino custom functions in other tabs, as is needed here, we
    need to import this file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先导入两个头文件。第一个头文件是我们刚刚创建的`led.h`文件，第二个是`Arduino.h`头文件。`Arduino.h`头文件包含了所有自定义Arduino函数的定义。它自动添加到主标签页中；然而，如果您希望在其他标签页中使用Arduino自定义函数，就像这里需要的那样，我们需要导入此文件。
- en: Following the imports is the implementation of the constructor for the `Led`
    class that was defined in the `led.h` tab. When we implement a constructor or
    a method for a class we prefix the name of it with the name of the class followed
    by two colons (::). The name of a constructor for a class is required to be the
    same as the class name. Therefore, the implementation for the constructor is `Led::Led`.
    Within the constructor, we set the class properties and the pin mode for the pin
    that the LED is connected too.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入之后是`led.h`标签页中定义的`Led`类的构造函数的实现。当我们实现一个类的构造函数或方法时，我们使用类名作为前缀，后跟两个冒号（::）。类的构造函数的名称必须与类名相同。因此，构造函数的实现是`Led::Led`。在构造函数中，我们设置类的属性和LED连接的引脚的模式。
- en: The next two class methods, `Led::turnOn` and `Led::turnOff`, use the `digitalWrite()`
    method to turn the LED on or off. Notice how these two methods us the `ledPin`
    property within the `digitalWrite()` method. This property is set within the constructor
    when the class is created.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个类方法`Led::turnOn`和`Led::turnOff`使用`digitalWrite()`方法来打开或关闭LED。注意这两个方法如何在`digitalWrite()`方法中使用`ledPin`属性。这个属性在创建类时在构造函数中设置。
- en: Finally the implementation for the `Led::blinkLed()` method is defined. This
    method uses the `Led::turnOn` and `Led::turnOff` methods defined previously to
    blink the LED on and OFF. When we call a method of a class we use the dash/greater
    than signs together (`->`) as shown in the `blinkLed()` method. The `this` keyword
    is used to refer to the current instance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Led::blinkLed()`方法的实现被定义。此方法使用之前定义的`Led::turnOn`和`Led::turnOff`方法来闪烁LED。当我们调用一个类的成员方法时，我们使用连字符/大于号（`->`）一起使用，如`blinkLed()`方法所示。`this`关键字用于引用当前实例。
- en: 'Now let''s see how we would use the `Led` class. Within the main tab, the first
    thing we need to do is to include the `led.h` file. Add the following line to
    the top of the tab:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`Led`类。在主标签页中，我们首先需要做的是包含`led.h`文件。将以下行添加到标签页的顶部：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we need to create a global instance of the `Led` class and give it a
    name of `led`. To do this, we use the constructor that we created for the class.
    The following code will create an instance of the `Led` class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个全局的`Led`类实例，并给它命名为`led`。为此，我们使用为该类创建的构造函数。以下代码将创建一个`Led`类的实例：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within the `Led` class the constructor is defined like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Led`类中，构造函数定义如下：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that the definition for the `Led` class has three parameters (`pin`,
    `on` and `off`). These three parameters match the three values that we are passing
    into the constructor when we create an instance of the `Led` class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`Led`类的定义有三个参数（`pin`、`on`和`off`）。这三个参数与我们创建`Led`类实例时传递给构造函数的三个值相匹配。
- en: 'We can now use the class to make the LED blink by calling the `blinkLed()`
    method of the class. The following code shows how to do this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个类通过调用类的`blinkLed()`方法来使LED闪烁。以下代码展示了如何做到这一点：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code shows the code within the main tab that will use the `Led`
    class to blink an LED:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了主标签页中将要使用`Led`类来闪烁LED的代码：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you run this code on the prototype that we created in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*, you will see one of the LEDs blink.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这[第4章](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml)中创建的原型上运行此代码，*基本原型制作*，你会看到其中一个LED闪烁。
- en: In this section, we only gave a very brief introduction to OOP enabling you
    to understand how most professional Arduino libraries are created and how to use
    them. There are whole books written about OOP, and if you wish to create libraries
    for the Arduino, I would recommend reading more object-oriented design in general
    and OOP for the Arduino.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只给出了一个非常简短的面向对象编程（OOP）介绍，使你能够理解大多数专业Arduino库是如何创建的以及如何使用它们。关于OOP有整本书的讨论，如果你希望为Arduino创建库，我建议阅读更多关于面向对象设计和Arduino的OOP。
- en: Now let's look at how we can use the built-in String library for the Arduino.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用Arduino的内置String库。
- en: String library
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: String库
- en: The String library, which is part of the Arduino core libraries, enables us
    to use and manipulate text easier and in a more complex way then character arrays
    do. It does take more memory to use the String library than it does to use character
    arrays but it is easier to use the String library
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino核心库的一部分String库使我们能够更容易地使用和操作文本，并且比字符数组更复杂。使用String库比使用字符数组需要更多的内存，但使用String库更容易。
- en: 'There are numerous ways to create an instance of the String type. Let''s look
    at a few examples here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `String` 类型实例的方法有很多。让我们在这里看看几个例子：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Both of the first two lines create a simple string with the word `Arduino`
    in it. In the third line, a new String instance is created from a single constant
    character. In this line, notice that the single quote is used. The last example
    concatenates two Strings. There are several more constructors that enable us to
    create instances of the String class from a number. Here are a few examples:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行创建了一个包含单词 `Arduino` 的简单字符串。在第三行中，从单个常量字符创建了一个新的 `String` 实例。在这一行中，请注意使用了单引号。最后一个例子将两个字符串连接起来。还有几个其他构造函数使我们能够从数字创建
    `String` 类的实例。以下是一些例子：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, the `strNum1` String instance would contain the text
    `42`, which is the decimal version of the number 42\. The `strNum2` String instance
    would contain the text `2a` which is the hex version of the number 42\. The `strNum3`
    String instance would contain the text `101010`, which is the binary version of
    the number 42.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`strNum1` 字符串实例将包含文本 `42`，这是数字 42 的十进制版本。`strNum2` 字符串实例将包含文本 `2a`，这是数字
    42 的十六进制版本。`strNum3` 字符串实例将包含文本 `101010`，这是数字 42 的二进制版本。
- en: 'There are also numerous methods that can be used in instances of the `String`
    class. Some of these methods are:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在 `String` 类的实例中使用许多方法。其中一些方法包括：
- en: '`concat(string)`: Concatenates one string to the end of the original string.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat(string)`: 将一个字符串连接到原始字符串的末尾。'
- en: '`endsWith(string)`: Returns true if the original string ends with the characters
    of the other string.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endsWith(string)`: 如果原始字符串以另一个字符串的字符结尾，则返回 true。'
- en: '`equals()`: Will compare two strings and return true if the strings contain
    the same text. When comparing the strings, this method is case sensitive.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`: 将比较两个字符串，如果字符串包含相同的文本，则返回 true。在比较字符串时，此方法区分大小写。'
- en: '`equalsIgnoreCase()`: Will compare two strings and returns true if the strings
    contain the same text. When comparing strings, this method is case insensitive.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equalsIgnoreCase()`: 将比较两个字符串，如果字符串包含相同的文本，则返回 true。在比较字符串时，此方法不区分大小写。'
- en: '`length()`: Returns the length of the strings. The length will not include
    the trailing null character.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length()`: 返回字符串的长度。长度不包括尾随的空字符。'
- en: '`replace(substring1, substring2)`: This method will replace all instances of
    one substring with another substring.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace(substring1, substring2)`: 此方法将替换所有实例的一个子字符串为另一个子字符串。'
- en: '`startsWith(string)`: Returns true if the original string starts with the characters
    of the other string.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startsWith(string)`: 如果原始字符串以另一个字符串的字符开头，则返回 true。'
- en: '`toLowerCase()`: Returns the lower case version of the original string.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toLowerCase()`: 返回原始字符串的小写版本。'
- en: '`toUpperCase()`: Returns the upper case version of the original string.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toUpperCase()`: 返回原始字符串的大写版本。'
- en: The String library can be used as a replacement for the character array; however,
    you will find that most sample code on the internet uses character arrays mainly
    because they take up less memory and they execute faster than the String library.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串库可以用作字符数组的替代品；然而，你会发现互联网上大多数示例代码主要使用字符数组，因为它们占用的内存更少，并且执行速度比字符串库更快。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This ends the introduction to the Arduino programming language. You can refer
    to the Arduino quick reference pages for additional information about the Arduino
    programming language.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了 Arduino 编程语言的介绍。您可以参考 Arduino 快速参考页面以获取有关 Arduino 编程语言的更多信息。
- en: 'You can find the reference pages here: [https://www.arduino.cc/reference/en/](https://www.arduino.cc/reference/en/).
    On this page, you will find links to information about the built-in Arduino functions
    and variables. That are also links to information about the operators and other
    Arduino language elements.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到参考页面：[https://www.arduino.cc/reference/en/](https://www.arduino.cc/reference/en/)。在这个页面上，您可以找到有关内置
    Arduino 函数和变量的信息链接。还有关于运算符和其他 Arduino 语言元素的信息链接。
- en: Don't worry if you do not feel comfortable writing your own Arduino programs
    right now because we will be writing a lot of code in the remaining chapters of
    this book, and by the end you should feel comfortable writing your own Arduino
    applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在感觉不舒服编写自己的 Arduino 程序，请不要担心，因为在这本书的剩余章节中我们将编写大量代码，到那时您应该能够轻松编写自己的 Arduino
    应用程序。
