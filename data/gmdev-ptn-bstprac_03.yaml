- en: Creating Flexibility with the Component Object Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件对象模型创建灵活性
- en: In the last chapter, we saw how the Singleton pattern can help us solve the
    problem of creating and using the big core engines of our game. The engine code
    is designed to work with any game, meaning there is nothing gameplay-specific
    about it. So as the game design evolves, we don't need to worry about changes
    in game design breaking our engine. The goal when writing code for a graphics
    or physics engine is to make it as reusable or game-agnostic as possible. This
    means that when you are done making the current game, you should be able to use
    the code in the next game with very little or no change. The way to do this is
    to separate the engine code from anything related to the specific game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了单例模式如何帮助我们解决创建和使用游戏核心引擎的问题。引擎代码被设计成可以与任何游戏一起工作，这意味着它没有任何游戏特定的内容。因此，随着游戏设计的演变，我们不需要担心游戏设计的变化会破坏我们的引擎。编写图形或物理引擎代码的目标是使其尽可能可重用或与游戏无关。这意味着当你完成当前游戏后，你应该能够几乎不需要或不需要修改就使用代码在下一款游戏中。实现这一目标的方法是将引擎代码与任何与特定游戏相关的代码分离。
- en: Game objects, on the other hand, are completely specific to our game. If the
    game changes, all our object types will need to change as well. If we are making
    a platformer and suddenly change to making a Space Shooter, our graphics and physics
    engine code probably doesn't need to change. However, every single game object
    and behavior will change. While this may be the most extreme example, the fact
    is that our game objects are likely to change a lot. So let's look at how we can
    use patterns to solve this small, but very important, piece of our game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，游戏对象完全特定于我们的游戏。如果游戏发生变化，所有我们的对象类型都需要相应地改变。如果我们正在制作平台游戏，突然改为制作太空射击游戏，我们的图形和物理引擎代码可能不需要改变。然而，每个游戏对象和行为都会改变。虽然这可能是最极端的例子，但事实是，我们的游戏对象很可能会发生很大变化。因此，让我们看看我们如何使用模式来解决这个虽然小但非常重要的游戏问题。
- en: Chapter overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: 'In this chapter, we will be focusing on creating a game object that is flexible
    enough to adapt as our game design changes. We will do this by first looking at
    the two most common ways that new programmers create a game object, and the problems
    that arise when we use these approaches. Then we will discuss two design patterns
    that can help us solve our problem. Finally, we will arrive at our solution of
    creating a reusable, flexible game object. Since we know our game design and game
    objects are likely to change, the questions we are going to answer are the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于创建一个足够灵活的游戏对象，以便适应我们的游戏设计的变化。我们将首先查看新程序员创建游戏对象最常见的两种方式，以及使用这些方法时出现的问题。然后我们将讨论两种可以帮助我们解决问题的设计模式。最后，我们将得出创建可重用、灵活游戏对象的解决方案。由于我们知道我们的游戏设计和游戏对象很可能会发生变化，我们将回答以下问题：
- en: Is it possible to write game objects in a reusable way?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以以可重用的方式编写游戏对象？
- en: How can we decouple our game objects from our core engine code?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何将游戏对象与核心引擎代码解耦？
- en: If we have a reusable game object, how can we make it flexible enough to use
    in different games or account for changes in our game design while the game is
    being developed?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个可重用的游戏对象，我们如何使其足够灵活，以便在不同的游戏中使用或适应游戏设计在开发过程中的变化？
- en: Along the way, we will discuss a few important design principles that will come
    up again and again in this book that will help you write clean and solid code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将讨论一些重要的设计原则，这些原则将在本书中反复出现，并帮助你编写干净和稳固的代码。
- en: Your objectives
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'Over the course of this chapter, we will be focusing on a lot of important
    concepts and diving deep into some interesting code. Some of these concepts are
    about ways not to implement a game object. Learning the wrong way is often just
    as important as learning the right way. Here is an outline of the topics we will
    cover and your tasks for this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注许多重要概念，并深入探讨一些有趣的代码。其中一些概念是关于不实现游戏对象的方法。学习错误的方法往往与学习正确的方法一样重要。以下是我们将涵盖的主题和本章的任务概述：
- en: Why a monolithic game object is a bad design
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么单体游戏对象是一个糟糕的设计
- en: Why inheritance hierarchies are inflexible
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么继承层次结构缺乏灵活性
- en: Learning and implementing the Strategy pattern and the Decorator pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习和实现策略模式和装饰者模式
- en: Learning and implementing the Component Object Model
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习和实现组件对象模型
- en: Why a monolithic game object is a bad design
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么单体游戏对象是一个糟糕的设计
- en: When you break it down to the simplest terms, programming is about solving problems
    with code. Someone has an idea for a game or an app, and the problem that needs
    to be solved is how to describe that idea logically and correctly to the computer.
    Day to day, these problems usually come in the form of integrating code you wrote
    today with code written earlier by you or another programmer. When solving these
    problems, there is a constant struggle between doing things the *easy way* or
    doing them the *right way*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其分解为最简单的术语时，编程就是用代码解决问题。有人有一个游戏或应用程序的想法，需要解决的问题是如何逻辑且正确地向计算机描述这个想法。在日常工作中，这些问题通常以将你今天编写的代码与之前你或另一个程序员编写的代码集成在一起的形式出现。在解决问题时，总是在*简单的方式*和*正确的方式*之间进行不断的斗争。
- en: The *easy way* to solve a problem means solving the immediate problem in the
    fastest way possible. Examples of this might be hardcoding a number or string
    literal instead of using a named constant, copying code instead of writing a function
    or refactoring code into a base class, or just writing code without thinking about
    how it can impact the rest of the code base.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的*简单方法*意味着以尽可能快的方式解决当前问题。这种方法的例子可能包括直接编写数字或字符串字面量而不是使用命名常量，复制代码而不是编写函数或重构代码到基类，或者只是不考虑其对整个代码库的影响而编写代码。
- en: On the other hand, solving a problem the *right way* means thinking about how
    the new code will interact with the old code. It also means thinking about how
    the new code will interact with future code if the design changes. The *right
    way* doesn't mean that there is only one correct solution to the problem. There
    are often many possible ways to reach the same result. The creativity involved
    in programming is one of the reasons programming is so much fun.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以*正确的方式*解决问题意味着思考新代码将如何与旧代码交互。这也意味着思考如果设计发生变化，新代码将如何与未来代码交互。*正确的方式*并不意味着对问题只有一个正确的解决方案。通常有几种可能的方法可以达到相同的结果。编程中涉及的创造力是编程如此有趣的原因之一。
- en: Veteran programmers know that in the long run, the *easy way* often turns out
    to be more difficult. This is often because a quick fix solves an immediate problem
    but doesn't consider the changes that will occur as the project evolves.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的程序员知道，从长远来看，*简单的方式*往往最终会变得困难。这通常是因为快速修复解决了当前问题，但没有考虑到项目演变过程中可能发生的变化。
- en: The monolithic game object
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一的游戏对象
- en: 'The *easy way* to do a game object is to have a single `struct` that contains
    all of the data a game object will need. This seems correct because everything
    in the game has the same basic data. For example, we know players and enemies
    all have a position, scale, and rotation. So our struct will look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 制作游戏对象的*简单方法*是拥有一个包含游戏对象所需所有数据的单个`struct`。这似乎是正确的，因为游戏中的所有东西都有相同的基本数据。例如，我们知道玩家和敌人都有位置、缩放和旋转。所以我们的结构将看起来像这样：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This game object works well in theory, but it is too basic. It is true that
    everything in our game probably needs a position, scale, and rotation. Even an
    invisible trigger region needs these properties. However, as it stands, we can''t
    draw our object: we have no health, and no way to do damage. So, let''s add a
    few things to make the game object a little more real:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏对象在理论上工作得很好，但它太基础了。确实，我们游戏中的所有东西可能都需要位置、缩放和旋转。即使是不可见的触发区域也需要这些属性。然而，就目前而言，我们无法绘制我们的对象：我们没有生命值，也没有造成伤害的方法。所以，让我们添加一些东西，使游戏对象更加真实：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have added a few more basic elements to our game object. Most of our
    game object types will have health and damage, and we have added a texture ID
    so we can draw our game object, and some texture coordinates so we can use a sprite
    sheet for animation. Finally, we added a color so we can reuse the same texture
    and color it differently for different enemies (think about the different ghosts
    in Namco's *Pacman*).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们游戏对象添加了一些更多基本元素。我们的大多数游戏对象类型都将拥有生命值和伤害，我们添加了一个纹理ID，这样我们就可以绘制我们的游戏对象，还有一些纹理坐标，这样我们就可以使用精灵表进行动画。最后，我们添加了一个颜色，这样我们就可以重复使用相同的纹理，并为不同的敌人着色（想想南梦宫的*吃豆人*中的不同幽灵）。
- en: This is not that bad yet but, unfortunately, this is just the beginning. Once
    we start making a real game instead of just brainstorming about a basic game object,
    our struct member count starts to explode.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这还不算太糟糕，但不幸的是，这只是开始。一旦我们开始制作真正的游戏而不是仅仅头脑风暴一个基本游戏对象，我们的结构成员数量就开始激增。
- en: 'Imagine we are making a Space Shooter. There are lots of things we will want
    to add:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在制作一个太空射击游戏。我们希望添加很多东西：
- en: The player will have multiple types of weapons that all do different amounts
    of damage
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家将拥有多种类型的武器，每种武器造成的伤害量不同
- en: The player might have access to bombs and missiles that each have an ammo count
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家可能能够访问炸弹和导弹，每种都有弹药计数
- en: The missile needs a target to seek
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导弹需要寻找目标
- en: The bomb needs an explosion radius
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 炸弹需要一个爆炸半径
- en: There are two super enemies that each have a special ability with a cool-down
    time
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个超级敌人，每个都拥有特殊能力并带有冷却时间
- en: The player and one super enemy both have the ability to use a shield
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家和超级敌人都有使用护盾的能力
- en: The UI buttons have some actions associated with clicking them
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI按钮与点击它们相关的某些动作
- en: We have power-ups that add health and add lives
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有增加生命值和增加生命值的升级道具
- en: We need to add a lives count to all objects to account for the power up
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要给所有对象添加生命值计数，以考虑升级效果
- en: We should add velocity to objects and do time-based movement instead of just
    setting the position directly
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该给对象添加速度，并基于时间进行移动，而不是直接设置位置
- en: We need to add an enumeration for the type of the game object so we can update
    it properly
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要添加一个游戏对象类型的枚举，以便我们可以正确更新它
- en: 'Here is what our game object looks like now:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的游戏对象是什么样的：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this basic method of creating a game object doesn't scale very
    well. We already have more than 25 members in our struct and we haven't even talked
    about adding space stations that can spawn or repair units. We have only two boss
    types, we can make a few enemy types by allowing different enemies to use different
    player weapons such as the laser or missiles, but we are still limited.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种创建游戏对象的基本方法扩展性并不好。我们结构体中已经有了超过25个成员，我们甚至还没有讨论添加能够生成或修复单位的太空站。我们只有两种BOSS类型，我们可以通过允许不同敌人使用不同的玩家武器，如激光或导弹，来制作几种敌人类型，但我们仍然有限制。
- en: The major problem with this approach is that, as the game gets bigger, our game
    object must also get very big. Some types, such as the player, will use many of
    these members, but other types, such as a UI button, will only use a small amount.
    This means if we have lots of game objects, we are very likely wasting a lot of
    memory per object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的重大问题是，随着游戏的扩大，我们的游戏对象也必须变得非常大。某些类型，如玩家，将使用许多这些成员，但其他类型，如UI按钮，只会使用一小部分。这意味着如果我们有很多游戏对象，我们很可能每个对象都在浪费大量内存。
- en: The problem with object behavior
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象行为的问题
- en: 'So far, we have only considered what members the game object has. We haven''t
    considered how each object will have its behavior updated. Right now, the game
    object is just data. Since it has no functions, it can''t update itself. We could
    easily add an `Update` function for the game object but, in order to update each
    type of object correctly, we would need a `switch` statement:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了游戏对象有哪些成员。我们还没有考虑每个对象的行为如何更新。目前，游戏对象只是数据。因为它没有函数，所以不能自我更新。我们可以轻松地为游戏对象添加一个`Update`函数，但为了正确更新每种类型的对象，我们需要一个`switch`语句：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, this approach doesn't scale well. As we add more object types, we need
    to add even more cases to our `switch` statement. Since we only have one `struct`
    type, we need to have a `switch` statement, whenever we need to do something object-type-specific.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这种方法扩展性不好。随着我们添加更多对象类型，我们需要在`switch`语句中添加更多的情况。由于我们只有一个`struct`类型，我们需要在需要执行特定对象类型操作时，有一个`switch`语句。
- en: If we are adding behaviors, we will also face the decision of adding data to
    our object or hardcoding a value into the `switch` statement. For example, if
    our bomb grows in size, how does it grow? We could hard code `scale.x *= 1.1f`
    into our `switch` statement or we can add member data float `bombScaleFactor`
    to our struct.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加行为，我们还将面临在对象中添加数据或将值硬编码到`switch`语句中的决策。例如，如果我们的炸弹增大尺寸，它是如何增大的？我们可以在`switch`语句中硬编码`scale.x
    *= 1.1f`，或者我们可以在我们的结构体中添加成员数据浮点`bombScaleFactor`。
- en: In the end, this approach just isn't that flexible. Changing our design is very
    difficult because there are `switch` statements and public members throughout
    our code. If we were to make a game like this, then our code base would be a complete
    mess after only a few months. The worst part would be that once the game was completed,
    we wouldn't be able to reuse any code. The game object and all behaviors would
    be so gameplay-specific that unless we make a sequel, we would need to remake
    a brand new game object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这种方法并不那么灵活。改变我们的设计非常困难，因为我们的代码中到处都是`switch`语句和公共成员。如果我们制作这样的游戏，那么几个月后我们的代码库就会变得一团糟。最糟糕的部分是，一旦游戏完成，我们就无法重用任何代码。游戏对象和所有行为都会非常特定于游戏玩法，除非我们制作续集，否则我们需要重新制作一个全新的游戏对象。
- en: The benefits of the monolithic game object
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一游戏对象的好处
- en: 'It is worth noting that even if you choose this approach, you can still have
    your core engines decoupled from the game object. When writing the graphics engine,
    for example, instead of passing in a game object as a parameter to a `Draw` function,
    we could pass in the members that the graphics engine needs:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使你选择这种方法，你仍然可以使你的核心引擎与游戏对象解耦。例如，在编写图形引擎时，我们不是将游戏对象作为参数传递给`Draw`函数，而是传递图形引擎需要的成员：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another argument for creating objects like this is that we know exactly what
    is in our game object. Compared with other approaches, we never need to cast our
    object or search for properties within the object. These operations make the code
    more complicated and have a slight performance cost. By using a simple `struct`,
    we have direct access to the variables and the code is easier to understand.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为创建这种对象进行另一个论点是，我们知道我们的游戏对象中确切有什么。与其他方法相比，我们永远不需要将我们的对象进行类型转换或搜索对象内的属性。这些操作使代码更复杂，并略有性能成本。通过使用简单的`struct`，我们直接访问变量，代码更容易理解。
- en: The only time we might use this approach is if we know 100% that the number
    of object types won't be large, for example, if you are making a puzzle game and
    the only game objects are sheep and walls. Puzzle games are often very simple
    and use the same mechanics over and over. In this case, this is a good approach
    because it is easy and doesn't require any time building a complicated system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能唯一会使用这种方法的情况是，如果我们100%确定对象类型数量不会很大，例如，如果你正在制作一个益智游戏，唯一的游戏对象是羊和墙壁。益智游戏通常非常简单，反复使用相同的机制。在这种情况下，这是一个好的方法，因为它简单，不需要花费时间构建复杂系统。
- en: Why inheritance hierarchies are inflexible
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么继承层次结构不灵活
- en: 'The idea that **Players**, **Enemies**, **Missiles**, and **Medics** should
    all derive from one base object is very common to programmers new to object-oriented
    programming. It makes a lot of sense on paper that if you have a Raider and a
    SuperRaider, one should inherit from the other. I believe this comes from how
    inheritance is taught. When you are first learning about inheritance, you will
    almost always see a picture similar to this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家**、**敌人**、**导弹**和**医疗兵**都应该从一个基类派生出来的想法对于刚开始学习面向对象编程的程序员来说非常普遍。在纸面上，如果你有一个掠夺者和超级掠夺者，一个应该继承自另一个，这是非常有道理的。我认为这源于继承的教授方式。当你刚开始学习继承时，你几乎总是会看到一张类似这样的图片：'
- en: '![](img/00024.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00024.jpeg)'
- en: Figure 3.1 - A typical inheritance diagram when learning to program
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 学习编程时典型的继承图
- en: Many introductory programming courses are so focused on the mechanics of inheritance
    that they forget to tell you how to use it properly. A picture like the one above
    makes it easy to understand that ITWorker is an Employee, which is a Person. However,
    once you go beyond the mechanics, it is time to learn how to use inheritance correctly.
    This is why books on design patterns exist.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多入门级编程课程过于关注继承的机制，以至于忘记了如何正确地使用它。像上面的图片这样的图示很容易让人理解ITWorker是Employee，而Employee是Person。然而，一旦你超越了机制，就是时候学习如何正确地使用继承。这就是为什么存在关于设计模式的书籍。
- en: 'Inheritance is a powerful tool that lets us extend classes by adding members
    and methods that are specific to the derived classes. It allows us to start with
    general code and create more specialized classes. This solves one of the original
    problems that we had with the extremely bloated object struct in the first section.
    Inheritance lets us take an existing class, such as a Raider, and add more members
    to create a SuperRaider:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一种强大的工具，它允许我们通过添加特定于派生类的成员和方法来扩展类。它允许我们从通用代码开始，创建更专业的类。这解决了我们在第一部分中遇到的极端膨胀的对象结构的一个原始问题。继承允许我们从一个现有的类，如Raider，添加更多成员来创建SuperRaider：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/00025.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: Figure 3.2 - An example of Space Shooter inheritance hierarchy
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 太空射击游戏继承层次结构的示例
- en: This hierarchy makes a lot of sense when first designing a space shooter. It
    allows us to separate the details of a `Raider` class or a `Bomber` class away
    from the `Player` class. Adding a game object is easy because we can extend a
    class to create what we need. Removing a game object is easy because all the code
    is contained within each derived class. In fact, now that we have separate classes,
    each one can be responsible for itself via class methods. This means we no longer
    need `switch` statements all over our code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种层次结构在最初设计太空射击游戏时非常有意义。它允许我们将`Raider`类或`Bomber`类的细节与`Player`类分离。添加游戏对象很容易，因为我们可以通过扩展类来创建所需的内容。移除游戏对象也很容易，因为所有代码都包含在每个派生类中。实际上，现在我们有单独的类，每个类都可以通过类方法负责自己。这意味着我们不再需要在代码中到处使用`switch`语句。
- en: Best of all, we can use the power of virtual functions to decouple our derived
    classes from the core engines of our game. By using an array of base class pointers
    to the derived class instances, our core engines such as graphics or physics are
    only coupled to the object interface instead of derived classes, such as `Planet`
    or `SpawnerStation`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的是，我们可以使用虚函数的力量将我们的派生类与游戏的核心引擎解耦。通过使用指向派生类实例的基类指针数组，我们的核心引擎，如图形或物理，仅与对象接口耦合，而不是与派生类，如`Planet`或`SpawnerStation`耦合。
- en: 'Without inheritance hierarchy, the code would be as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 没有继承层次结构，代码如下：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With inheritance and polymorphism, the code is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承和多态，代码如下：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Organizing the code by what it does, not what it is
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按照代码的功能而不是它的本质来组织代码
- en: What is the difference between the Raider and the Bomber, really? How are a
    Raider and a SuperRaider different? Maybe they have a different speed, a different
    texture, and a different damage value? Do these changes in data really require
    a new class? Those are really just different values, not different behaviors.
    The problem is that we are creating extra classes because the concept of a Raider
    and SuperRaider is different, but there aren't differences in behavior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的区别在于Raider和Bomber吗？Raider和SuperRaider有何不同？也许它们有不同的速度、不同的纹理和不同的伤害值？这些数据的变化真的需要一个新的类吗？这些其实只是不同的值，而不是不同的行为。问题是，我们正在创建额外的类，因为Raider和SuperRaider的概念是不同的，但它们的行为并没有差异。
- en: 'Our class hierarchy actually violates three principles I teach, two of which
    I learned from the Gang of Four book:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实际类层次结构违反了我教授的三个原则，其中两个是从四人帮的书中学到的：
- en: '"Keep your inheritance trees shallow"'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: “保持你的继承树浅”
- en: '"Favor object composition over class inheritance" - Gang of Four, p20'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: “优先使用对象组合而不是类继承” —— 四人帮，第20页
- en: '"Consider what should be variable in your design. This approach is the opposite
    of focusing on the cause of redesign. Instead of considering what might force
    a change to a design, consider what you want to be able to change without redesign.
    The focus here is on encapsulating the concept that varies, a theme of many design
    patterns" - Gang of Four, p29'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “考虑在设计中的哪些部分应该是可变的。这种方法与关注重新设计的起因相反。与其考虑什么可能迫使设计发生变化，不如考虑你希望在无需重新设计的情况下能够改变的内容。这里的重点是封装变化的概念，这是许多设计模式的主题”
    —— 四人帮，第29页
- en: 'A different way to state the third principle is the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表述第三原则的另一种方式如下：
- en: '"Find what varies and encapsulate it"'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: “找出变化的部分并将其封装”
- en: These principles exist to eliminate, or completely avoid, the problems that
    can and will arise when using inheritance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则旨在消除或完全避免在使用继承时可能和将会出现的问题。
- en: The problem with our current design is that if we create a new class for every
    object type, we will end up with a lot of little classes that are mostly the same.
    Raider, SuperRaider, Bomber, and SuperBomber are mostly the same with just a few
    minor differences, some of which are only differences in `float` and `int` values.
    While this approach may seem like an improvement over the *easy way*, it becomes
    a problem because we will end up writing the same behavior code over and over
    again in many classes. If we have a lot of enemies, we might end up writing the
    same basic `ChasePlayerAI` code in every `Update` function. The only solution
    is moving the `ChasePlayerAI` up to a base class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前设计的问题在于，如果我们为每种对象类型创建一个新的类，我们最终会得到很多小类，它们大部分是相同的。掠夺者、超级掠夺者、轰炸机和超级轰炸机大部分相同，只有一些细微的差异，其中一些只是`float`和`int`值的差异。虽然这种方法可能看起来比“简单方法”有所改进，但它成为一个问题，因为我们将在许多类中反复编写相同的行为代码。如果我们有很多敌人，我们可能会在每一个`Update`函数中编写相同的`ChasePlayerAI`基本代码。唯一的解决方案是将`ChasePlayerAI`移动到基类中。
- en: 'Let''s take another look at our Space Shooter hierarchy but this time, let''s
    add in some different behaviors to our classes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的太空射击层次结构，但这次，让我们在我们的类中添加一些不同的行为：
- en: '![](img/00026.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: Figure 3.3 - After adding behavior to our objects (refer graphic bundle)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 在我们的对象中添加行为之后（参考图形包）
- en: We have decided that our base `object` class will at least be drawable to make
    things simple. If an object such as a trigger region needs to be invisible, we
    can simply support disabling rendering by putting a `bool` in the drawable behavior
    so it won't get drawn. However, with this game object approach, I still have some
    duplicated code. Both the `Raider` class and the `AttackStation` class have some
    AI that targets and shoots bullets at the Player. We have only duplicated our
    code once so maybe it isn't a big deal.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定，我们的基`object`类至少应该是可绘制的，以使事情简单。如果一个像触发区域这样的对象需要不可见，我们只需通过在可绘制行为中放置一个`bool`来简单地支持禁用渲染，这样它就不会被绘制。然而，使用这种游戏对象方法，我仍然有一些重复的代码。`Raider`类和`AttackStation`类都有一些针对玩家进行瞄准和射击子弹的AI。我们只重复了一次代码，所以可能不是什么大问题。
- en: 'Unfortunately, all game designs will change. What happens when our designer
    wants to add asteroids to our game? Technically, they are structures so they need
    some of the data inherited from that class, but they also move. Our designer also
    really liked the `SpawnerStation` class and wants to add that ability to a new
    `SpawnerPlanet` class, and to a new `BossSpawner` class. Should we rewrite the
    code two more times, or refactor the code into the base class? Our designer also
    wants to give the `Station` the ability to slowly patrol an area. This means the
    `Station` class needs the Patrol AI ability as well. Let''s take a look at our
    hierarchy now:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，所有的游戏设计都会发生变化。当我们的设计师想要在我们的游戏中添加小行星时会发生什么？从技术上讲，它们是结构，因此需要从那个类继承一些数据，但它们也会移动。我们的设计师也非常喜欢`SpawnerStation`类，并希望将那种能力添加到一个新的`SpawnerPlanet`类和一个新的`BossSpawner`类中。我们应该再次重写代码两次，还是将代码重构到基类中？我们的设计师还希望赋予`Station`类在区域内缓慢巡逻的能力。这意味着`Station`类也需要巡逻AI能力。现在让我们看看我们的层次结构：
- en: '![](img/00027.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: Figure 3 4 - After refactoring duplicate code to our base class (refer graphic
    bundle)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 在将重复的代码重构到基类之后（参考图形包）
- en: As it turns out, this approach isn't as flexible as it originally seemed. In
    order for our design to be really flexible, almost all of the behaviors need to
    be factored up into the base class. In the end, we aren't much better off than
    when we wrote our game object the *easy way*. And it is still possible that our
    designer will want to create the `RepairHelper` that chases the Player, meaning
    that everything will be in the base class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，这种方法并不像最初看起来那样灵活。为了使我们的设计真正灵活，几乎所有的行为都需要被分解到基类中。最终，我们并没有比用“简单方法”编写我们的游戏对象时好多少。而且，我们的设计师仍然可能想要创建一个追逐玩家的`RepairHelper`，这意味着所有东西都将位于基类中。
- en: This might sound like a contrived example but remember that games take years
    to develop and are likely to change. DMA Design's *Grand Theft Auto* was originally
    titled *Race'n'Chase*, but it was changed because a bug caused the police to try
    and run the Player off the road instead of pull them over. This ended up being
    way more fun. Another example is Blizzard's first-person shooter *Overwatch*,
    which was originally in development for 7 years as a massively multiplayer online
    game.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像是一个人为的例子，但请记住，游戏开发可能需要数年，并且很可能会发生变化。DMA Design的《侠盗猎车手》最初被命名为《Race'n'Chase》，但后来因为一个错误导致警察试图将玩家赶下马路而不是将其拦下。这最终变得更有趣。另一个例子是Blizzard的第一人称射击游戏《Overwatch》，它最初作为一款大型多人在线游戏开发了7年。
- en: The purpose of object-oriented programming is to recognize that designs will
    change and to write code with that change in mind.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的目的是认识到设计会发生变化，并考虑到这种变化来编写代码。
- en: Another problem with our inheritance approach is that it isn't very easy to
    add or remove abilities at runtime. Let's say our game has a special power-up
    item that will let the Player use a shield for 1 minute. The shield will absorb
    50% of the damage done to the Player for 1 minute then remove itself. We now have
    the problem of making sure that when a bullet collides with the shield, it will
    transfer some of the damage to the Player. The shield isn't just responsible for
    itself; it is responsible for the Player object too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用继承方法时的另一个问题是，在运行时添加或删除能力并不容易。假设我们的游戏有一个特殊升级物品，可以让玩家使用护盾1分钟。护盾将在1分钟内吸收玩家受到的50%的伤害，然后自行移除。我们现在的问题是确保当子弹与护盾碰撞时，它将部分伤害转移到玩家身上。护盾不仅负责自己，还负责玩家对象。
- en: This same situation exists for all things that will affect another game object
    for some duration of time. Imagine if we want our Raider to be able to do acid
    damage to the Player over 5 seconds instead. We need a way to attach this acid
    damage to the Player, and to remember to remove it after 5 seconds. We could add
    new variables such as `bool` `hasAcid` and `float` `acidTime` in the `Player`
    class that we can use to know whether we should do acid damage in this frame.
    However, this still isn't a flexible solution, because each new type of damage
    caused over time will need new variables like this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相同的情况存在于所有将在一段时间内影响另一个游戏对象的事物中。想象一下，如果我们想让我们的掠夺者能够在5秒内对玩家造成酸伤害。我们需要一种方法将这种酸伤害附加到玩家身上，并在5秒后记住移除它。我们可以在`Player`类中添加新的变量，例如`bool
    hasAcid`和`float acidTime`，这样我们就可以知道在这个帧上是否应该造成酸伤害。然而，这仍然不是一个灵活的解决方案，因为每种新的随时间造成的伤害类型都需要这样的新变量。
- en: In addition, there is no way to stack the acid damage effect if three enemies
    are attacking the Player with acid damage. If we like this ability and want the
    Player to use it, we also need to give all game objects these extra time-based
    damage variables and behavior code. What we would really like to do is attach
    acid behavior (or any effect) onto a game object at runtime and have it automatically
    detach itself when the effect is over. We are going to talk about how to do that
    later in this chapter, but first we need to talk about one more problem related
    to inherence hierarchies in C++.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果三个敌人用酸伤害攻击玩家，就没有办法堆叠酸伤害效果。如果我们喜欢这种能力，并希望玩家使用它，我们还需要给所有游戏对象这些额外的基于时间的伤害变量和行为代码。我们真正想做的就是在运行时将酸行为（或任何效果）附加到游戏对象上，并在效果结束时自动将其移除。我们将在本章后面讨论如何做到这一点，但首先我们需要讨论与C++中的继承层次结构相关的一个更多问题。
- en: Avoiding the Diamond of Death
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免死亡钻石
- en: 'The final problem with our inheritance approach involves the situation where
    we take code reuse to the extreme. In our hierarchy, we have SuperRaider, which
    is very fast, weak, and shoots little bullets. We also have SuperBomber, which
    is slow, strong, and shoots big bombs. Someday, a clever designer will want to
    create SuperBomberRaider that is very fast, strong, and shoots both little bullets
    and big bombs. Here is our partial tree:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用继承方法时遇到的最終問題涉及我们将代码重用推向極端的情况。在我们的层次结构中，我们有`SuperRaider`，它非常快，很弱，并且射击小子弹。我们还有`SuperBomber`，它很慢，很强，并且射击大炸弹。有一天，一个聪明的設計師會想要創建一個非常快、很强，并且能夠射擊小子和大炸彈的`SuperBomberRaider`。以下是我们的部分樹：
- en: '![](img/00028.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00028.jpeg)'
- en: Figure 3.5 - Example of the Diamond of Death
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 - 死亡钻石的示例
- en: This, of course, is the **Diamond of Death** (or **Dreaded Diamond of Death**),
    so named because the inheritance tree forms a diamond. The problem is that our
    `SuperBomberRaider` inherits from both the `SuperBomber` and `SuperRaider`. Those
    two classes each inherit from the `Enemy`, `Unit`, and `object`. That means `SuperBomberRaider`
    will have two copies of `m_pos`, `m_scale`, `m_rotation`, and every other member
    of `object`, `Unit`, and `Enemy`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这被称为**死亡钻石**（或**可怕的死亡钻石**），之所以这样命名是因为继承树形成了一个钻石形状。问题是我们的`SuperBomberRaider`同时继承自`SuperBomber`和`SuperRaider`。这两个类各自继承自`Enemy`、`Unit`和`object`。这意味着`SuperBomberRaider`将会有两份`m_pos`、`m_scale`、`m_rotation`以及`object`、`Unit`和`Enemy`的每一个成员。
- en: There will also be two copies of any functions that are contained in the `Object`,
    `Unit`, and `Enemy`. This means we need to specify which version of the functions
    we wish to use. This might sound good, since we get behavior from both classes,
    but remember that the individual base class function will only modify their version
    of variables. After calling `SuperRaider::Update` and `SuperBomber::Update`, we
    now need to figure out what version of `m_pos` (and `m_scale` and `m_rotation`)
    we want to use when we draw our object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object`、`Unit`和`Enemy`中包含的任何函数也都会有两份副本。这意味着我们需要指定我们希望使用的函数版本。这听起来可能不错，因为我们从两个类中获得了行为，但请记住，单个基类函数只会修改它们自己的变量版本。在调用`SuperRaider::Update`和`SuperBomber::Update`之后，我们现在需要确定在绘制我们的对象时我们想要使用哪个版本的`m_pos`（以及`m_scale`和`m_rotation`）。'
- en: C++ has ways of solving this problem, but most programmers agree that the solution
    makes things more complicated to understand and more difficult to use. The rule
    of thumb is that we should just avoid using multiple inheritance. We have seen
    some of the problems that it can cause and we haven't even talked about bugs related
    to using `new` and `delete` in a situation like this.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: C++有解决这个问题的方法，但大多数程序员都认为这种解决方案使得事情更难以理解，也更难以使用。一般来说，我们应该避免使用多重继承。我们已经看到了它可能引起的一些问题，而且我们甚至还没有讨论在这种情况下使用`new`和`delete`可能引起的错误。
- en: The Strategy pattern and the Decorator pattern
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式和装饰者模式
- en: We saw that in trying to be more flexible with our game object, a lot of behavior
    was factored into the base class. We also said that it would be nice to attach
    a behavior at runtime and have it detach itself when we are done with it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，在尝试使我们的游戏对象更加灵活的过程中，很多行为都被分解到了基类中。我们也说过，在运行时附加行为并在我们完成时将其分离会很好。
- en: There are actually two design patterns that have the potential to help our design,
    the Strategy pattern and the Decorator pattern. The Strategy pattern is all about
    encapsulating sets of behaviors instead of inheriting. The Decorator pattern is
    all about dynamically adding responsibilities as needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有两种设计模式有可能帮助我们进行设计，即策略模式和装饰者模式。策略模式主要关于封装一系列行为而不是继承。装饰者模式主要关于根据需要动态地添加责任。
- en: The Strategy pattern explained
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式解释
- en: 'The Strategy pattern is about encapsulating a set of behaviors and having the
    client control the behavior through an interface, instead of hardcoding the behavior
    into the client function itself. What this means is that we want the game object
    to be completely independent of the behavior it uses. Imagine that we want to
    give each enemy a different attack and flight AI. We could use the Strategy pattern
    instead of creating an inheritance tree:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是关于封装一系列行为，并通过接口让客户端控制行为，而不是将行为硬编码到客户端函数本身中。这意味着我们希望游戏对象完全独立于它所使用的行为。想象一下，如果我们想给每个敌人分配不同的攻击和飞行AI，我们可以使用策略模式而不是创建继承树：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, our client is the `Enemy` class and the interfaces that the client
    controls are the `AttackAI` and `FlightAI`. This is a much better solution than
    inheriting from the `Enemy` because we are only encapsulating what varies: the
    behavior. This pattern allows us to create as many `FlightAI` derived classes
    as we need and to reuse them to create different kinds of game object types, without
    needing to expand our inheritance tree. Since we can mix different strategy combinations,
    we can get a large number of different overall behaviors.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的客户端是`Enemy`类，客户端控制的接口是`AttackAI`和`FlightAI`。这比从`Enemy`继承要好得多，因为我们只封装了变化的部分：行为。这种模式允许我们创建任意数量的`FlightAI`派生类，并将它们重用来创建不同种类的游戏对象类型，而无需扩展我们的继承树。由于我们可以混合不同的策略组合，我们可以得到大量不同的整体行为。
- en: 'We are going to share the same strategies for both units and structures, so
    we should actually remove our inheritance tree altogether and just use the `Object`
    as our client. This way, the `Object` class becomes a collection of strategies,
    and our design is simpler. Plus, we are following some great programming principles:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将共享单位和结构相同的策略，因此我们应该完全删除我们的继承树，只使用`Object`作为我们的客户端。这样，`Object`类就变成了策略的集合，我们的设计更简单。此外，我们遵循了一些优秀的编程原则：
- en: Programing to an interface means that our client depends on behavior in an abstract
    class instead putting behavior in the client itself.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向接口编程意味着我们的客户端依赖于抽象类中的行为，而不是在客户端本身放置行为。
- en: Our interfaces are opened for extension so we can easily add as many behaviors
    as we need. The interface is simple so it won't need to be changed, which might
    break code.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的开界面对扩展是开放的，这样我们就可以轻松地添加我们需要的任何行为。接口很简单，因此不需要更改，这可能会破坏代码。
- en: Our inheritance trees are shallow so we don't need to worry about the Diamond
    of Death.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的继承树很浅，所以我们不需要担心死亡钻石问题。
- en: '![](img/00029.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00029.jpeg)'
- en: Figure 3.6 - Example of our Object using the Strategy pattern
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 使用策略模式的我们的对象示例
- en: The Strategy pattern allows our game object to be very flexible without the
    need for an inheritance tree. With these six small classes shown in the preceding
    diagram, we can have a total of nine different game object behaviors. If we add
    a new **FlightAI**, we have 12 possible game object behaviors. Creating brand
    new strategies allows for an amazing amount of mixed behaviors. However, if we
    only extend just the two strategies, we don't need to modify the **Object** at
    all. This works for the Player as well, if we make an **AttackAI** and **FlightAI**
    that have access to input.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式允许我们的游戏对象非常灵活，而无需继承树。通过前面图中显示的这六个小类，我们可以拥有总共九种不同的游戏对象行为。如果我们添加一个新的**FlightAI**，我们就有12种可能的游戏对象行为。创建全新的策略允许有大量的混合行为。然而，如果我们只扩展两种策略，我们根本不需要修改**对象**。这对玩家也适用，如果我们创建一个**AttackAI**和一个**FlightAI**，它们可以访问输入。
- en: 'Staying with only two strategies is unlikely, which means that whenever we
    add a new strategy, we will need to change the **Object** by adding a new member
    and modifying the `Update` function. This means that while the pattern is flexible
    enough to let us change strategies at runtime, we can''t add behaviors dynamically.
    If we need to add acid damage as a debuff in our game, we would need a `Damage`
    base class, and to give a `Damage` base class pointer to the `object`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 只保留两种策略是不太可能的，这意味着每次我们添加一个新的策略时，我们都需要通过添加一个新成员和修改`Update`函数来改变**对象**。这意味着虽然这个模式足够灵活，可以让我们在运行时更改策略，但我们不能动态地添加行为。如果我们需要在游戏中添加酸伤害作为减益效果，我们需要一个`Damage`基类，并将`Damage`基类指针赋予`object`：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This doesn't seem like a great solution because most damage will be instantaneous
    and, most of the time, the player isn't even taking damage. That means this will
    be either null or an empty strategy class, such as using a `NoDamage` derived
    class, that will be updated every frame but will do nothing. This is also no way
    to stack corrosive effects or to have two types of damage affecting the Player,
    such as corrosive damage and ice damage, which might cause the Player to move
    slower for 10 seconds. We really need a way to dynamically add and remove these
    abilities. Luckily, there is a pattern for that.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎不是一个很好的解决方案，因为大多数伤害都是瞬时的，而且大多数时候，玩家甚至没有受到伤害。这意味着这将要么是null，要么是一个空的策略类，例如使用一个`NoDamage`派生类，它将每帧更新但不会做任何事情。这也不是堆叠腐蚀效果或让两种类型的伤害影响玩家，例如腐蚀伤害和冰伤害，这可能会让玩家移动速度变慢10秒的方法。我们真的需要一种动态添加和删除这些能力的方法。幸运的是，有一个模式可以做到这一点。
- en: The Decorator pattern explained
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式解释
- en: The purpose of the Decorator pattern is to dynamically add responsibilities
    to an object at runtime. The goal is to be a flexible alternative to creating
    derived classes while still allowing for extended behavior. What this means is
    that we can take our `object` and add decorations or, in our case, behaviors at
    runtime.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式的目的是在运行时动态地向对象添加责任。目标是提供一个灵活的替代方案来创建派生类，同时仍然允许扩展行为。这意味着我们可以将我们的`object`添加装饰或，在我们的情况下，在运行时添加行为。
- en: 'This pattern requires that the `Decorator` and our `object` are derived from
    a common base class so they share the same interface. Each `Decorator` will then
    layer itself on top of an `object` or another `Decorator` to create more interesting
    object types and effects. When a function gets called on a `Decorator`, it will
    call the corresponding function on the next layer down, eventually calling the
    function of the `object`. It is similar in concept to the *Russian Matryoshka*
    dolls, the dolls that contain smaller and smaller versions inside of themselves.
    The final, most nested object is always the object with the core functionality:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式要求 `Decorator` 和我们的 `object` 都从一个公共基类派生，这样它们就共享相同的接口。然后每个 `Decorator` 将在其上添加自身，以创建更有趣的对象类型和效果。当一个函数在
    `Decorator` 上被调用时，它将调用下一层的相应函数，最终调用 `object` 的函数。在概念上与 *俄罗斯套娃* 类似，套娃内部包含越来越小的版本。最内层的最终对象总是具有核心功能的对象：
- en: '![](img/00030.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00030.jpeg)'
- en: Figure 3.7 - The layering effects of the Decorator pattern
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 - 装饰者模式的层叠效果
- en: 'Here is a simplified version in code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简化的代码版本：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/00031.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00031.jpeg)'
- en: Figure 3.8 - The Decorator pattern using our Object
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 - 使用我们的对象实现的装饰者模式
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Decorator` classes layer our concrete `object` class and add more information
    on top of the `object`. However, right now, all we are doing is adding superficial
    decorations. Since the `Decorator` class doesn't know whether it has a pointer
    to the `object` class or another `Decorator`, it can't modify the `object`. A
    good analogy is that the Strategy pattern changes the guts of the object, while
    the Decorator pattern changes the skin. This can be useful but doesn't help us
    with our buff/debuff problem. To solve this problem, we would need to add a method
    to find the `object` down the chain, or give a pointer to the `object` in the
    constructor of a `Decorator`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decorator` 类层叠我们的具体 `object` 类，并在 `object` 上添加更多信息。然而，目前我们只是在添加表面装饰。由于 `Decorator`
    类不知道它是否有指向 `object` 类或另一个 `Decorator` 的指针，它不能修改 `object`。一个很好的类比是，策略模式改变对象的内部结构，而装饰者模式改变对象的皮肤。这可能很有用，但并不能帮助我们解决增益/减益问题。为了解决这个问题，我们需要添加一个方法来沿着链找到
    `object`，或者在 `Decorator` 的构造函数中提供一个指向 `object` 的指针。'
- en: Another problem is that this pattern was designed to add a `Decorator` dynamically,
    but doesn't allow us to remove one. In the case of using a corrosive damage `Decorator`,
    we would only want it to exist for a set time, and then automatically detach itself.
    This can't be done, since a `Decorator` doesn't have a pointer to its parent.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是这个模式被设计用来动态添加 `Decorator`，但不允许我们移除一个。在使用腐蚀伤害 `Decorator` 的情况下，我们只想让它存在一段时间，然后自动断开连接。这是不可能的，因为
    `Decorator` 没有指向其父级的指针。
- en: The final problem for games is that our `Decorators` can't live in a vacuum.
    Sometimes, different gameplay behaviors may need to interact with each other.
    For example, the corrosive damage `Decorator` may affect the health of an `object`;
    however, it may first need to check whether the `object` has a shield `Decorator`
    and remove health from the shield.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的最终问题是我们不能让 `Decorators` 孤立存在。有时，不同的游戏玩法可能需要相互交互。例如，腐蚀伤害 `Decorator` 可能会影响
    `object` 的健康；然而，它可能首先需要检查 `object` 是否有护盾 `Decorator` 并从护盾中扣除健康。
- en: 'Unfortunately, neither the Decorator nor the Strategy pattern will work perfectly
    for us. What we really need is a new pattern that is a combination of the Strategy
    and Decorator patterns that does the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，装饰者模式和策略模式都无法完美地为我们工作。我们真正需要的是一个结合策略模式和装饰者模式的新模式，它能够做到以下事情：
- en: Encapsulates specific behavior into components so we avoid `Object` inheritance
    trees
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将特定行为封装到组件中，这样我们就避免了 `Object` 继承树
- en: Allows for a flexible number of components so we don't need to modify the `Object`
    each time we create a new component type
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许有灵活数量的组件，这样我们就不需要每次创建新的组件类型时都修改 `Object`
- en: Lets us add and remove components at runtime
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们在运行时添加和移除组件
- en: Gives components direct access to the `Object` so it can be modified
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使组件能够直接访问 `Object` 以便进行修改
- en: Allows components to be searchable by other components so they can interact
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许组件被其他组件搜索以便它们可以交互
- en: The Component Object Model explained
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释组件对象模型
- en: The alternative can be found by many names, though none are definitive yet.
    In this book, we will call it the **Component Object Model**, but others have
    called the **Entity Component System** or just **Component System**. No matter
    what you call it, the concept is surprisingly simple to learn and easy to implement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个替代方案可以用许多名字来称呼，但还没有一个确切的名称。在这本书中，我们将称之为**组件对象模型**，但其他人称之为**实体组件系统**或只是**组件系统**。无论你叫它什么，这个概念的学习非常简单，实现起来也很容易。
- en: The Component Object Model inverts the concept of the Decorator pattern, where
    each `Decorator` added a new layer on top of the game object. Instead of layering
    our `object`, which we have already seen problems with, we will put the decorations
    inside of it. Since we don't know how many we will need, our `object` will hold
    a container of decorations, as opposed to a single pointer. In the simplest form,
    our `object` is nothing more than a container for these components.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 组件对象模型颠倒了装饰器模式的概念，其中每个`Decorator`都在游戏对象之上添加了一层新层。而不是分层我们的`对象`，我们已经看到这会带来问题，我们将装饰物放在它的内部。由于我们不知道需要多少，我们的`对象`将包含一个装饰物的容器，而不是一个单独的指针。在最简单的情况下，我们的`对象`不过是一个这些组件的容器。
- en: If you search for Component Object Model (or Component Based object Model) on
    the Internet, you will get results that are similar to what we saw in the Strategy
    pattern. The object contains hardcoded pointers to each possible strategy. While
    using this approach alone is much better than a monolithic object or an inheritance-based
    object, we are stuck checking for null pointers or constantly modifying what strategies
    exists in our `object`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网上搜索组件对象模型（或基于组件的对象模型），你将得到与我们在策略模式中看到的结果相似的结果。对象包含对每个可能策略的硬编码指针。虽然单独使用这种方法比使用单体对象或基于继承的对象要好得多，但我们仍然被困在检查空指针或不断修改我们`对象`中存在的策略。
- en: 'In this alternative method, every strategy type will derive from a common interface.
    This way, our `object` can contain an array, or in our case an STL vector of base
    class `Component` pointers. This is like the `Decorator`, except our `object`
    is a separate class; it doesn''t derive from the `Component` interface. Instead,
    a `Component` will have a pointer to its parent `object` class. This solves the
    problem in which a `Decorator` didn''t know whether it held a pointer to another
    `Decorator`, or to the actual `object`. Here we avoid that problem by always giving
    our `Component` a pointer to the `object` it controls:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，每种策略类型都将从一个公共接口派生。这样，我们的`对象`可以包含一个数组，或者在我们的情况下是一个基类`Component`指针的STL向量。这就像`Decorator`，除了我们的`对象`是一个独立的类；它不派生自`Component`接口。相反，一个`Component`将有一个指向其父`对象`类的指针。这解决了`Decorator`不知道它持有的是另一个`Decorator`的指针，还是实际`对象`的指针的问题。在这里，我们通过始终给我们的`Component`提供一个指向它控制的`对象`的指针来避免这个问题：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/00032.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: Figure 3.9 - The Component Object Model
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 - 组件对象模型
- en: This approach allows us to be very flexible because our **object** is nothing
    more than components. There is nothing in it that is specific to any type. There
    is no code that is strictly for the Player or SuperRaider. We are free to add,
    change, or remove anything at runtime. This is important because in the early
    stages of development, the game design and game objects will change a lot. If
    we were to hardcode pointers to different base class `Strategies`, we would spend
    a lot of time changing those pointer types in the game object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使我们非常灵活，因为我们的`对象`不过是一系列组件。里面没有特定于任何类型的特定内容。没有严格为玩家或SuperRaider编写的代码。我们可以在运行时自由添加、更改或删除任何内容。这很重要，因为在开发的早期阶段，游戏设计和游戏对象会发生变化很多。如果我们对不同的基类`Strategies`进行硬编码指针，我们将在游戏对象中花费大量时间更改这些指针类型。
- en: Using the Component Object Model makes our code almost completely reusable as
    well. The game object itself is just an empty container of Components, and they
    are often so simple that most of them, such as a **CircleCollider**, can be used
    in any game. This means that a behavior component, originally meant only for the
    Player or SpawnerStation, can be easily used for any game object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件对象模型使我们的代码几乎完全可重用。游戏对象本身只是一个空的组件容器，而且它们通常非常简单，大多数组件，如**CircleCollider**，都可以在任何游戏中使用。这意味着原本只为玩家或SpawnerStation设计的行为组件可以很容易地用于任何游戏对象。
- en: Implementing the Component Object Model
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现组件对象模型
- en: 'Now that we have seen a basic version in code as well as a diagram, let''s
    look at exactly how the Mach5 Engine implements this system. As you will see,
    the `M5object`, as it is called, contains a position, rotation, scale, and velocity.
    Of course, these elements could be contained in a transform component; however,
    these are so common that most other components will need access to this information.
    This is different to data such as texture coordinates or a circle collider''s
    radius, which might not need to be shared at all:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了代码和图示的基本版本，让我们看看 Mach5 引擎是如何实现这个系统的。正如您将看到的，所谓的 `M5object` 包含位置、旋转、缩放和速度。当然，这些元素可以包含在一个变换组件中；然而，这些元素非常常见，大多数其他组件都需要访问这些信息。这与纹理坐标或圆形碰撞器的半径等数据不同，这些数据可能根本不需要共享：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first thing you will notice is that there are two enumerations in this code,
    `M5ArcheTypes` and `M5ComponentTypes`. These will become more useful later when
    we talk about creating Factories. However, for now, it is enough to understand
    that these will allow us to search through a collection of `M5objects` and get
    the components we need. For example, if we have a collection of `M5objects` but
    we need to find the Player, the `M5ArcheTypes` enum will allow us to do that.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先会注意到，这段代码中有两个枚举，`M5ArcheTypes` 和 `M5ComponentTypes`。当我们谈到创建工厂时，这些将变得更有用。然而，现在，理解这些将允许我们在
    `M5objects` 集合中搜索并获取所需的组件就足够了。例如，如果我们有一个 `M5objects` 集合，但我们需要找到玩家，`M5ArcheTypes`
    枚举将允许我们做到这一点。
- en: 'The next thing you will notice is the `M5object` is more than just a container
    of components. It has some public and private data. The public data is unlikely
    to need validating or protecting. We could create getters and setters but they
    would really just simply get and set the data, so it isn''t 100% necessary. Since
    they are public, we are locked into keeping them public forever. If you wish to
    make them `private` and create `accessor` methods, that is fine. There are some
    very important variables that we want to be private. The ID and the type are set
    once and can''t be changed, and the array of components is accessed through functions
    to add, remove, and clear all components. Let''s discuss the purpose of the public
    variables first:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您接下来会注意到，`M5object` 不仅仅是一个组件的容器。它有一些公共和私有数据。公共数据不太可能需要验证或保护。我们可以创建获取器和设置器，但它们实际上只是简单地获取和设置数据，所以并不是绝对必要的。由于它们是公共的，我们将永远锁定为公共。如果您希望将它们设置为
    `private` 并创建 `accessor` 方法，那也是可以的。有一些非常重要的变量我们希望是私有的。ID 和类型一旦设置就不能更改，并且组件数组通过添加、删除和清除所有组件的函数进行访问。让我们首先讨论公共变量的用途：
- en: '`pos`: The position of the `M5Object`. This is the rotational center, or pivot
    point, of the object.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pos`: `M5Object` 的位置。这是物体的旋转中心或支点。'
- en: '`scale`: The height and width of the `M5Object`, before rotation.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`: 旋转前的 `M5Object` 的高度和宽度。'
- en: '`vel`: The velocity of the `M5Object`. This is used to do time-based movement
    instead of simply setting the position to plus or minus some value.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vel`: `M5Object` 的速度。这用于基于时间的移动，而不是简单地设置位置为正负某个值。'
- en: '`rotation`: The rotation in radians. Positive rotations are counterclockwise.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation`: 以弧度为单位的旋转。正旋转是逆时针方向。'
- en: '`rotationalVel`: The rotational velocity of the `M5Object`, used to do time-based
    rotations.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotationalVel`: `M5Object` 的旋转速度，用于基于时间的旋转。'
- en: '`isDead`: This allows the `M5Object` to mark itself for deletion. Other objects
    or components are free to call one of the `DestroyObject` functions found in the
    `M5ObjectManager`; however, it isn''t a good idea for an object to delete itself
    in the middle of its own `Update` function.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDead`: 这允许 `M5Object` 标记自己以供删除。其他对象或组件可以自由调用 `M5ObjectManager` 中找到的 `DestroyObject`
    函数之一；然而，在对象的 `Update` 函数中间删除对象并不是一个好主意。'
- en: We are keeping these as part of the `M5object` because they are so common that
    all or almost all components will need access to them. We are marking these as
    public because there is no validation or protecting that we need to do on the
    data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些作为 `M5object` 的一部分，因为它们非常常见，所有或几乎所有组件都需要访问它们。我们将它们标记为公共的，因为没有必要对数据进行验证或保护。
- en: 'The private section starts with two type `defs`. They let us create shorter
    names for templated types. This is simply a style choice. Another style choice
    is to have an `m_` in front of all of the private member variable names. This
    or something similar is a common practice for class members. We didn''t do this
    with our public members because we are treating them more like properties. Now
    let''s look at the rest of the private data:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 私有部分从两个类型 `defs` 开始。它们允许我们为模板类型创建更短的名字。这仅仅是一个风格选择。另一个风格选择是在所有私有成员变量名前加上 `m_`。这或类似的做法是类成员的常见做法。我们没有对公共成员这样做，因为我们更倾向于将它们视为属性。现在让我们看看其余的私有数据：
- en: '`m_components`: This is the array of `M5Component` pointers. Each component
    in the vector will get updated in the `Update` function.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_components`：这是一个 `M5Component` 指针数组。向量中的每个组件都会在 `Update` 函数中被更新。'
- en: '`m_type`: The type of object. It will get set in the constructor and never
    change. It allows the user to use the `M5ObjectManager` to search or remove objects
    based on type.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_type`：对象的类型。它将在构造函数中设置，并且永远不会改变。它允许用户使用 `M5ObjectManager` 根据类型搜索或删除对象。'
- en: '`m_id`: This is a unique ID among `M5Objects`. It can be useful in cases such
    as a missile needing to target a specific instance of an object. If the missile
    contains a pointer to the target object, it can''t know whether the object has
    been destroyed. If we instead know the ID, we can search to see whether the target
    still exists.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_id`：这是 `M5Objects` 之间的唯一 ID。在导弹需要针对特定实例的对象的情况下可能很有用。如果导弹包含指向目标对象的指针，它就无法知道该对象是否已被销毁。如果我们知道
    ID，我们可以搜索以查看目标是否仍然存在。'
- en: '`s_objectIDCounter`: This is the shared ID counter for all `M5Objects`. This
    guarantees that each object will get a unique value because they are all using
    the same shared variable. Notice that this is marked with an `s_` to indicate
    that it is static.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_objectIDCounter`：这是所有 `M5Objects` 的共享 ID 计数器。这保证了每个对象都会得到一个唯一的值，因为它们都在使用相同的共享变量。注意，这个变量被标记为
    `s_` 以表示它是静态的。'
- en: That is all of the data in the `object`. Now, let's look at the functions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `object` 中的所有数据。现在，让我们看看函数。
- en: '`M5object` is the constructor for the class. It sets starting values for the
    variables as well as setting the type and giving a unique ID. Notice that we reserve
    an amount of starting space for the vector. A game object can have as many components
    as it needs, but in an actual game, we don''t expect them to have more than a
    few on average. By pre-allocating, we may avoid any additional calls to new (we
    will be a doing a lot anyway):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`M5object` 是类的构造函数。它设置了变量的起始值，以及设置类型和唯一 ID。注意，我们为向量预留了一定量的起始空间。一个游戏对象可以有它需要的任何数量的组件，但在实际游戏中，我们并不期望它们的平均数量超过几个。通过预分配，我们可以避免任何额外的
    `new` 调用（我们无论如何都会做很多）：'
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`~M5object` is the destructor for our game object. Here we want to make sure
    that we delete all of the components in our game object, so we make use of one
    of our public functions to help us:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`~M5object` 是我们游戏对象的析构函数。在这里，我们想要确保删除游戏对象中的所有组件，因此我们使用了一个公共函数来帮助我们：'
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`AddComponent` adds the given component pointer to this object vector. You
    will notice that before the component is added, you will need to first check to
    make sure the same pointer isn''t already in the list. While this isn''t very
    likely to happen, it could be a hard bug to find later so it is worth the check.
    It is also important when given a component to use the `SetParent` method of `M5Component`
    to make sure this object will be controlled by the component:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddComponent` 将给定的组件指针添加到这个对象向量中。你将注意到，在添加组件之前，你需要首先检查确保相同的指针还没有在列表中。虽然这种情况不太可能发生，但它可能是一个难以发现的严重错误，所以进行检查是值得的。当给一个组件时，使用
    `M5Component` 的 `SetParent` 方法也很重要，以确保这个对象将由组件控制：'
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Update` is the most used function in the `M5object`. This will get called
    automatically by the `M5ObjectManager` every frame. It is used to update every
    component as well as update position and rotation based on their velocities. The
    other important role of the `Update` function is that it deletes any dead components.
    Except for the `RemoveAllComponents` function, this is the only place where components
    are deleted:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update` 是 `M5object` 中最常用的函数。这个函数将由 `M5ObjectManager` 在每一帧自动调用。它用于更新每个组件，以及根据它们的速度更新位置和旋转。`Update`
    函数的另一个重要作用是删除任何已死亡的组件。除了 `RemoveAllComponents` 函数外，这是删除组件的唯一地方：'
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`RemoveComponent` is used for cases such as when you have buffs or debuffs
    on an object and you want the stage, or some other object, to delete it. For example,
    the Player may be using a shield but, after being hit with ion damage, the physics
    collider finds the shield and immediately removes it. Instead of using this method,
    it would also be fine to simply mark the component as dead and it will be cleaned
    up in the next update loop.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveComponent`用于处理对象上有增益或减益效果的情况，你希望舞台或其他对象删除它。例如，玩家可能在使用护盾，但在被电离子伤害击中后，物理碰撞体找到护盾并立即将其移除。除了使用此方法外，简单地标记组件为已死亡并在下一个更新循环中清理它也是可以的。'
- en: 'This code follows a similar pattern to the `AddComponent` function. First,
    we test to make sure the component exists. If it does exist, we swap places with
    the last item in the vector and pop back the vector. After that, we use the `SetParent`
    method to remove this object as the parent pointer before deleting it. This is
    a small precaution as, in case another pointer to this component exists, the program
    will crash instead of causing an undefined error:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遵循与`AddComponent`函数相似的模板。首先，我们检查组件是否存在。如果存在，我们将它与向量中的最后一个元素交换位置，然后从向量中弹出。之后，我们使用`SetParent`方法在删除之前将此对象作为父指针移除。这是一个小的预防措施，因为，如果存在指向此组件的另一个指针，程序将崩溃而不是产生未定义的错误：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`RemoveAllComponents` is the helper function used in the destructor. It deletes
    all components in the object. Except for the destructor, there probably isn''t
    much use for it. However, it was made public for those rare occasions where this
    is the behavior you need. This function simply loops through the vector and deletes
    every component, then finally clears the vector:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveAllComponents`是用于析构函数的辅助函数。它删除对象中的所有组件。除了析构函数外，可能没有太多用途。然而，它被公开，以便在那些罕见的情况下，你需要这种行为。此函数简单地遍历向量并删除每个组件，然后最终清空向量：'
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The second version of `RemoveAllComponents` removes all components of a specific
    type. This is another situation where external code, such as a stage, object,
    or even another component needs to remove a group of the same component type.
    This could be used to remove all corrosive damage effects on the Player, for example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveAllComponents`的第二个版本会移除特定类型的所有组件。这是另一种情况，外部代码，如舞台、对象或甚至另一个组件需要移除同一类型的组件组。例如，这可以用来移除玩家身上的所有腐蚀性伤害效果。'
- en: 'In this code, we are searching for the correct type, so we cannot use the `std::vector::find`
    method. Instead, we use a `for` loop and check the type of each component. If
    we find the correct type, we delete the current one, swap with the end and pop
    back. Since we are doing a swap, but continue searching, we must make sure to
    check the current index again to see whether it matches as well:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们正在寻找正确的类型，因此不能使用`std::vector::find`方法。相反，我们使用一个`for`循环并检查每个组件的类型。如果我们找到正确的类型，我们就删除当前的一个，与末尾交换，然后弹出。由于我们在进行交换的同时继续搜索，我们必须确保再次检查当前索引是否匹配：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`GetComponent` and `GetAllComponents` are helper functions to find and cast
    specific component types in an `M5object`, if they exist. As I said before, sometimes
    it is necessary that components interact. In that case, we need a way to search
    for a specific component and to convert it to the correct type. These two functions
    are almost the same. The first one finds the first instance of the correct component
    type and assigns it to the pointer parameter. If one doesn''t exist, we make sure
    to set the parameter to `0`. The second one finds all components of the correct
    type and saves them in the vector parameter. These are template functions so the
    component can be cast to the correct type supplied by the user:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetComponent`和`GetAllComponents`是辅助函数，用于在`M5object`中查找和转换特定的组件类型，如果它们存在。正如我之前所说的，有时组件之间的交互是必要的。在这种情况下，我们需要一种方法来搜索特定的组件并将其转换为正确的类型。这两个函数几乎相同。第一个找到正确组件类型的第一个实例并将其分配给指针参数。如果不存在，我们确保将参数设置为`0`。第二个找到所有正确类型的组件并将它们保存在向量参数中。这些是模板函数，因此组件可以被转换为用户提供的正确类型：'
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `GetID` and `GetType` functions just return the private class data. The
    `Clone` method is more interesting but we will go into more detail about it when
    we discuss the Prototype pattern.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetID`和`GetType`函数仅返回私有类数据。`Clone`方法更有趣，但当我们讨论原型模式时，我们会更详细地介绍它。'
- en: Implementing components
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现组件
- en: Now that you have seen the `M5object`, let's take a look at how the Mach5 Engine
    creates and uses the component hierarchy. Since this is an abstract class, there
    is no way to create an instance of an `M5Component`. It is only an interface.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了 `M5object`，让我们看看 Mach5 引擎如何创建和使用组件层次结构。由于这是一个抽象类，无法创建 `M5Component`
    的实例。它只是一个接口。
- en: 'As you will see, the base component contains some of the same members as the
    `M5object`. Since we will have a lot of components, it is important to give each
    one a type, so they can be searchable. It is important to give each a unique ID.
    Since these components can be deleted at any time, it is important to save an
    ID instead of a pointer, which can become invalid:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，基组件包含与 `M5object` 相同的一些成员。由于我们将有很多组件，因此为每个组件指定一个类型很重要，这样它们就可以被搜索。为每个组件提供一个唯一的标识符也很重要。由于这些组件可以在任何时候被删除，因此保存一个
    ID 而不是指针很重要，因为指针可能会变得无效：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The data section doesn''t contain as much as the `M5object`, but now it is
    split into three sections which are `public`, `private`, and `protected`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 数据部分不包含像 `M5object` 那么多的内容，但现在它被分为三个部分，即 `public`、`private` 和 `protected`：
- en: '`isDead`: This is the only public data and it serves a similar function to
    the member in the game object. This allows the component to mark itself for deletion.
    It isn''t a good idea for a component to call `RemoveComponent` on itself during
    its own `Update` function.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDead`: 这是唯一的公共数据，它起着与游戏对象中成员类似的作用。这允许组件为自己标记为删除。在组件自己的 `Update` 函数中调用 `RemoveComponent`
    并不是一个好主意。'
- en: '`m_pObj`: This is a pointer to the `M5Object` that owns this component.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_pObj`: 这是一个指向拥有此组件的 `M5Object` 的指针。'
- en: '`m_id`: The unique ID of this component. This allows users to get access to
    this specific component again, without the risk of saving a pointer which may
    become invalid.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_id`: 此组件的唯一标识符。这允许用户再次访问这个特定的组件，而不会存在保存可能变得无效的指针的风险。'
- en: '`m_type`: The type of this component. This allows users to search for a specific
    component within a game object.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_type`: 此组件的类型。这允许用户在游戏对象中搜索特定的组件。'
- en: '`s_compIDCounter`: This is used to create a unique ID for each component.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_compIDCounter`: 这用于为每个组件创建一个唯一的标识符。'
- en: The functions of the `M5Component` are not that interesting because they are
    mostly virtual. However, it is worth going over their purpose.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`M5Component` 的功能并不那么有趣，因为它们大多是虚拟的。然而，了解它们的目的还是值得的。'
- en: '`M5Component` is the non-default constructor for the component. This takes
    an argument of type `M5ComponentTypes` so that the private data `m_type` is guaranteed
    to be set by a derived type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`M5Component` 是组件的非默认构造函数。它接受一个 `M5ComponentTypes` 类型的参数，以确保私有数据 `m_type` 被派生类型设置：'
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`~M5Component` is the destructor for the class. Since this is meant to be a
    base class, it is important that a virtual destructor exists so that the correct
    method will be called when using polymorphism:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`~M5Component` 是类的析构函数。由于这是一个基类，存在一个虚析构函数非常重要，这样在多态使用时将调用正确的方法：'
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`Update` is where the component does the action. This method will be called
    every frame and its intended purpose is to add a behavior and/or data to the `M5object`.
    It is marked as pure virtual (`= 0`) so that the base class is forced to override
    it. That also means there is no body to the base class version.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update` 是组件执行动作的地方。这个方法会在每一帧被调用，其目的是向 `M5object` 添加行为和/或数据。它被标记为纯虚函数 (`= 0`)，这样基类就必须重写它。这也意味着基类版本没有函数体。'
- en: '`FromFile` is a virtual function that allows the component to read data from
    a preloaded INI file. It is not marked as pure virtual, meaning that a component
    doesn''t need to override this function. This might be the case if the derived
    component has no data to be loaded from a file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromFile` 是一个虚拟函数，允许组件从预加载的 INI 文件中读取数据。它没有被标记为纯虚函数，这意味着组件不需要重写这个函数。如果派生组件没有从文件中加载的数据，这种情况可能发生：'
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `SetParent` method is simply a setter for `m_pObj`. Recall the `AddComponent`
    function of `M5object`. When a component is added to an object, the object uses
    this function so the component knows which object to control.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetParent` 方法仅仅是 `m_pObj` 的设置器。回想一下 `M5object` 的 `AddComponent` 函数。当一个组件被添加到对象中时，对象会使用这个函数，这样组件就知道要控制哪个对象。'
- en: The `GetType` and `GetID` functions are similar to the functions in `M5object`.
    They allow the component to be searchable and saved without needing to use pointers
    that may become invalid. The `M5Component` also has a pure virtual `Clone` method.
    There is no function body in the base class. We will discuss the `Clone` method
    of both `M5Component` and `M5object` when we discuss the Prototype pattern.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetType` 和 `GetID` 函数与 `M5object` 中的函数类似。它们允许组件可搜索和保存，而无需使用可能变得无效的指针。`M5Component`
    还有一个纯虚的 `Clone` 方法。基类中没有函数体。当我们讨论原型模式时，我们将讨论 `M5Component` 和 `M5object` 的 `Clone`
    方法。'
- en: To add a behavior to an object, we must derive from the `M5Component` base class,
    overload the necessary methods, add a value to the `M5ComponentTypes` enumeration,
    then finally register the class and the associated builder with the object manager.
    Of course, these steps are prone to error and doing them repeatedly would be very
    tedious.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要向对象添加行为，我们必须从 `M5Component` 基类派生，重载必要的函数，向 `M5ComponentTypes` 枚举添加一个值，然后最后将类及其关联的构建器注册到对象管理器中。当然，这些步骤容易出错，反复执行会非常繁琐。
- en: For this reason, the Mach5 engine has included a batch file to do these steps
    automatically. By adding components to the `Source` folder within the file hierarchy,
    the batch file will find all files named `*Component.h`, where the asterisk is
    a wildcard character that includes any valid C++ identifier.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Mach5 引擎包含一个批处理文件来自动执行这些步骤。通过将组件添加到文件层次结构中的 `Source` 文件夹内，批处理文件将找到所有名为 `*Component.h`
    的文件，其中星号是一个通配符字符，包括任何有效的 C++ 标识符。
- en: For example, if a component named `LazerComponent` is located within a file
    named `LazerComponent.h`, an enumeration value named `CT_LazerComponent` will
    be automatically created along with the correct class builder, and both will be
    registered with the `M5ObjectManager`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个名为 `LazerComponent` 的组件位于名为 `LazerComponent.h` 的文件中，将自动创建一个名为 `CT_LazerComponent`
    的枚举值，以及正确的类构建器，并且两者都将注册到 `M5ObjectManager`。
- en: Creating and removing objects and components
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和删除对象和组件
- en: In order to use the Component Object Model, first create a game object, then
    add some components, then finally add it to the `M5ObjectManager` which calls
    an update on the game object every frame. Let's look at some code for creating
    objects and components.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用组件对象模型，首先创建一个游戏对象，然后添加一些组件，最后将其添加到 `M5ObjectManager`，该管理器每帧都会调用游戏对象的更新。让我们看看创建对象和组件的代码示例。
- en: 'If we wanted to create a `Player` object to fly around on screen, but stay
    within the bounds of the screen, we could do this inside the `Init` method of
    a stage:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个在屏幕上飞行的 `Player` 对象，但保持在屏幕范围内，我们可以在阶段的 `Init` 方法中这样做：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code works fine, but there are a few problems. First, we didn''t specify
    what texture we want. However, we could easily add a `textureID` or filename as
    a parameter to the `GfxComponent` constructor. The larger problem is that this
    code was tedious to write and we don''t want to write it again and again. If we
    are creating a Player in another stage, it will likely contain the exact same
    code. So a better approach is to factor this code into the `M5ObjectManager`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行良好，但存在一些问题。首先，我们没有指定想要的纹理。然而，我们可以轻松地将 `textureID` 或文件名作为参数添加到 `GfxComponent`
    构造函数中。更大的问题是，这段代码编写起来很繁琐，我们不希望反复编写。如果我们要在另一个阶段创建一个玩家，它可能包含完全相同的代码。因此，更好的方法是把这个代码分解到
    `M5ObjectManager` 中：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now in our stage `Init` function, we can simply write the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的阶段 `Init` 函数中，我们可以简单地写下以下内容：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, this is pretty hardcoded. This explicitly creates all of the components
    that a Player (and every type) needs, which means that our `M5ObjectManager` now
    contains game-specific code. The benefit of using the Component Object Model is
    that it is flexible, but we have lost some of that flexibility by having a hardcoded
    `switch` statement. We really want our designers, not programmers, to choose what
    goes into a Player, Raider, or SuperRaider. That means loading our object types
    from a file. In our case, we will use INI files because they are simple to use
    and simple to understand. They consist of global or labeled sections of key/value
    pairs. Here is an example Player archetype found in `Player.ini`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这相当硬编码。这明确地创建了玩家（以及每种类型）所需的所有组件，这意味着我们的`M5ObjectManager`现在包含了特定于游戏的代码。使用组件对象模型的优点在于其灵活性，但我们通过使用硬编码的`switch`语句而失去了一些灵活性。我们真正希望我们的设计师，而不是程序员，来选择放入玩家、掠夺者或超级掠夺者中的内容。这意味着从文件中加载我们的对象类型。在我们的情况下，我们将使用INI文件，因为它们易于使用且易于理解。它们由全局或标记的键/值对部分组成。以下是在`Player.ini`中找到的一个示例玩家原型：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that the first (global) section of the INI file contains all data found
    in the `M5object`. Since we know that those variables always exist in the object,
    they are placed at the top. This includes a list of components that this archetype
    will use. Here we have `GfxComponent`, `PlayerInputComponent`, and `ClampComponent`.
    The next sections are data associated with each component, for example, with the
    `GfxComponent` we can specify our texture to load. The `ClampComponent` doesn't
    need any data loaded so we didn't need to add a section for it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，INI文件的第一（全局）部分包含在`M5object`中找到的所有数据。由于我们知道这些变量始终存在于对象中，因此它们被放置在顶部。这包括该原型将使用的组件列表。这里我们有`GfxComponent`、`PlayerInputComponent`和`ClampComponent`。接下来的部分是与每个组件关联的数据，例如，对于`GfxComponent`，我们可以指定要加载的纹理。`ClampComponent`不需要加载任何数据，因此我们不需要为它添加一个部分。
- en: Comparing the Component Object Model with the monolithic object or the inheritance
    tree, we can see that the component-based approach is vastly more flexible and
    reusable. With this method, we can write as many different components as we want
    and let the designer choose what behaviors each object uses. The best part is
    that everything but the most game-specific components can be reused in another
    game.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件对象模型与单体对象或继承树进行比较，我们可以看到基于组件的方法在灵活性和可重用性方面远远超过。使用这种方法，我们可以编写尽可能多的不同组件，并让设计师选择每个对象使用的行为。最好的部分是，除了最特定于游戏的组件之外，所有内容都可以在另一款游戏中重用。
- en: That means that the `PlayerInputComponent` probably can't be reused in another
    game, but the `ClampComponent` and `GfxComponent` can be used whether we are making
    another Space Shooter, Platformer, or Racer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`PlayerInputComponent`可能无法在另一款游戏中重用，但`ClampComponent`和`GfxComponent`可以在我们制作另一款太空射击游戏、平台游戏或赛车游戏时使用。
- en: 'One note about components used for graphics and physics, such as `GfxComponent`
    and `CircleColliderComponent`: these are special in the sense that they need to
    interact with core engines in a way that other components may not need to. For
    example, the Graphics engine might want to organize these components based on
    whether they are world space objects or screen space objects (referred to as HUD
    space, since these would be things such as buttons and health bars). The Physics
    engine might want to use a special partition data structure to minimize the number
    of collision tests that need to be performed. For this reason, these components
    are automatically registered to their respective core engines when created through
    the object Manager and they automatically unregister when they are deleted.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用于图形和物理的组件，如`GfxComponent`和`CircleColliderComponent`的一个注意事项：它们在意义上是特殊的，因为它们需要以其他组件可能不需要的方式与核心引擎交互。例如，图形引擎可能希望根据它们是否为世界空间对象或屏幕空间对象（称为HUD空间，因为这些将是按钮和生命值条等东西）来组织这些组件。物理引擎可能希望使用特殊的分区数据结构来最小化需要执行的碰撞测试数量。因此，这些组件在通过对象管理器创建时自动注册到相应的核心引擎，并在它们被删除时自动注销。
- en: Performance concerns
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能问题
- en: There are a lot of benefits to using the Component Object Model. These days,
    many engines use this approach because of the flexibility it provides. However,
    that flexibility comes at a cost to performance. The biggest performance costs
    are calls to new/delete, cache coherency, and virtual methods.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件对象模型有很多好处。如今，许多引擎因为其提供的灵活性而采用这种方法。然而，这种灵活性是以性能为代价的。最大的性能成本是新/删除调用、缓存一致性以及虚方法。
- en: Our `M5ObjectManager` uses pointers to `M5objects` which uses an STL vector
    of pointers to components. This means that as we create `Bullets`, `Asteroids`,
    `Raiders`, and `Planets`, we are constantly calling new and delete. These are
    slow functions and have the chance to fragment our memory. In a later chapter,
    we will see how object pools can help us solve both of these problems.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `M5ObjectManager` 使用指向 `M5objects` 的指针，而 `M5objects` 使用指向组件的 STL 向量。这意味着当我们创建
    `子弹`、`小行星`、`入侵者` 和 `行星` 时，我们不断地调用 new 和 delete。这些函数运行缓慢，有可能使我们的内存碎片化。在后面的章节中，我们将看到对象池如何帮助我们解决这两个问题。
- en: However, even with object pools, we still have problems with cache misses. The
    fact is that iterating over an array of contiguous data is much faster than iterating
    over an array of pointers to data. When using the Component object Model, the
    CPU will be spending a lot more time chasing pointers and loading that data into
    the cache than if we just used arrays. Unfortunately, this is the price we pay
    for flexibility. Depending on the game, this may or may not cause a problem.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使有对象池，我们仍然会遇到缓存未命中问题。事实上，遍历连续数据数组的速度比遍历指向数据指针的数组要快得多。当使用组件对象模型时，CPU 将花费更多的时间追踪指针并将数据加载到缓存中，如果我们只是使用数组的话。不幸的是，这是我们为了灵活性所付出的代价。根据游戏的不同，这可能会导致问题，也可能不会。
- en: Virtual methods are also a source of potential performance problems because
    the function to call must always be looked up at runtime and they cannot be inlined
    by the compiler. Again, this is the price we pay for flexibility. We have an approach
    that allows our designer to load a behavior from a file and change that behavior
    at runtime. In my opinion, that outweighs the performance issues, at least at
    the beginning of the development cycle.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虚方法也是潜在性能问题的来源，因为必须始终在运行时查找要调用的函数，并且编译器无法内联它们。同样，这也是我们为了灵活性所付出的代价。我们有一种方法允许我们的设计师从文件中加载行为并在运行时更改该行为。在我看来，这至少在开发周期的开始阶段，超过了性能问题。
- en: You may have heard *premature optimization is the root of all evil*. It is more
    important to focus on making a fun game and to solve the performance problems
    later. You always have the option of hardcoding specific behaviors or data in
    the game object much later in the development cycle. If possible, you might merge
    two or more components that always get used together once you are in the polish
    stage. However, by limiting your flexibility early on, you may never discover
    a fun feature that comes from mixing two components in a way that wasn't originally
    planned.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过“过早优化是万恶之源”。更重要的是，要专注于制作一个有趣的游戏，并在以后解决性能问题。你总有在开发周期后期将特定行为或数据硬编码到游戏对象中的选项。如果可能的话，你可以在后期优化阶段合并两个或更多总是一起使用的组件。然而，通过早期限制你的灵活性，你可能永远发现不到来自混合两个组件的有趣特性，而这种混合原本并未计划。
- en: My advice is to focus first on algorithmic optimizations, then macro optimizations,
    then finally micro optimizations. What I mean is that it is better to worry about
    the time complexity of your physics engine and how many draw calls or collision
    tests you are performing, before worrying about what is in the CPU cache or the
    performance cost of virtual functions. While they can be a problem, these things
    fall under the category of micro optimizations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是首先关注算法优化，然后是宏优化，最后是微优化。我的意思是，在担心 CPU 缓存中的内容或虚函数的性能成本之前，最好先担心你的物理引擎的时间复杂性和你执行了多少次绘制调用或碰撞测试。虽然它们可能是个问题，但这些事情属于微优化范畴。
- en: However, before starting the long process of creating a game using an unfamiliar
    game engine, it can be a good idea to do some simple prototype tests to make sure
    the engine can meet the needs of the game. For example, a programmer could approximate
    the number of objects, and components, and test for performance to see whether
    the engine will work.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开始使用不熟悉的游戏引擎创建游戏的长过程之前，进行一些简单的原型测试可能是个好主意，以确保引擎能够满足游戏的需求。例如，程序员可以估算对象和组件的数量，并测试性能以查看引擎是否可行。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored many different ways to create a game object.
    We have seen the problems with using monolithic objects or large inheritance trees.
    We now know that neither of those approaches scale when creating a large game.
    They both suffer from the problem of giant bloated classes and dependencies in
    our code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了许多创建游戏对象的不同方法。我们看到了使用单体对象或大型继承树的问题。现在我们知道，在创建大型游戏时，这两种方法都不具备可扩展性。它们都存在代码中巨大膨胀的类和依赖性问题。
- en: We have also seen the flexibility that using the Component Object Model can
    bring to our games. It lets programmers focus on writing new code, while allowing
    designers to use that code to create new object types, even at runtime. Since
    we can now define objects completely in a file, we can create a tool that will
    let our designer, or even players, make completely new objects, or possibly a
    new game.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了使用组件对象模型可以为我们的游戏带来的灵活性。它让程序员能够专注于编写新代码，同时允许设计师使用这些代码来创建新的对象类型，甚至在运行时。由于我们现在可以在文件中完全定义对象，我们可以创建一个工具，让我们的设计师，甚至玩家，能够创建全新的对象，或者可能是一个全新的游戏。
- en: We also briefly touched on the performance issues related to using the Component
    Object Model. While these can be a problem, it is much better to focus on algorithmic
    optimizations then very low-level CPU instruction optimizations. We will revisit
    these problems in later chapters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要地提到了与使用组件对象模型相关的性能问题。虽然这些问题可能成为问题，但相比之下，专注于算法优化而不是非常低级的CPU指令优化要好得多。我们将在后面的章节中重新审视这些问题。
- en: For now, let's move on to a design pattern that can help us implement one of
    the big core engines of our game, as well as a small but important type of component.
    In the next chapter, we will discover how the State pattern can help decouple
    our code and can give us a great way to implement artificial intelligence in our
    game.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探讨一个可以帮助我们实现游戏核心引擎之一以及一种小型但重要的组件类型的设计模式。在下一章中，我们将发现状态模式如何帮助我们解耦代码，并为我们实现游戏中的人工智能提供一种很好的方法。
