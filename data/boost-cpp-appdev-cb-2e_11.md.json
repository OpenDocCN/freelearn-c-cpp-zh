["```cpp\n#include <boost/filesystem/operations.hpp> \n#include <iostream> \n```", "```cpp\nint main() { \n    boost::filesystem::directory_iterator begin(\"./\"); \n```", "```cpp\n    boost::filesystem::directory_iterator end; \n    for (; begin != end; ++ begin) { \n```", "```cpp\n        boost::filesystem::file_status fs = \n            boost::filesystem::status(*begin);\n```", "```cpp\n        switch (fs.type()) { \n        case boost::filesystem::regular_file: \n            std::cout << \"FILE       \";  \n            break; \n        case boost::filesystem::symlink_file: \n            std::cout << \"SYMLINK    \";  \n            break; \n        case boost::filesystem::directory_file: \n            std::cout << \"DIRECTORY  \";  \n            break; \n        default: \n            std::cout << \"OTHER      \";  \n            break; \n        } \n        if (fs.permissions() & boost::filesystem::owner_write) { \n            std::cout << \"W \"; \n        } else { \n            std::cout << \"  \"; \n        } \n```", "```cpp\n        std::cout << *begin << '\\n'; \n    } /*for*/ \n} /*main*/ \n```", "```cpp\nFILE W \"./main.o\" \nFILE W \"./listing_files\" \nDIRECTORY W \"./some_directory\" \nFILE W \"./Makefile\" \n```", "```cpp\nboost::filesystem::file_status fs = begin->status(); \n```", "```cpp\nstd::cout << begin->path() << '\\n'; \n```", "```cpp\n    std::ofstream ofs(\"dir/subdir/file.txt\"); \n    ofs << \"Boost.Filesystem is fun!\"; \n```", "```cpp\n#include <boost/filesystem/operations.hpp> \n#include <cassert> \n#include <fstream> \n```", "```cpp\nint main() { \n    boost::system::error_code error; \n```", "```cpp\n    boost::filesystem::create_directories(\"dir/subdir\", error); \n    assert(!error); \n```", "```cpp\n    std::ofstream ofs(\"dir/subdir/file.txt\");\n    ofs << \"Boost.Filesystem is fun!\";\n    assert(ofs);\n    ofs.close();\n```", "```cpp\n    boost::filesystem::create_symlink(\n        \"dir/subdir/file.txt\", \"symlink\", error);\n```", "```cpp\n    if (!error) {\n        std::cerr << \"Symlink created\\n\";\n        assert(boost::filesystem::exists(\"symlink\"));\n```", "```cpp\n    } else {\n        std::cerr << \"Failed to create a symlink\\n\";\n\n        boost::filesystem::remove_all(\"dir\", error);\n        assert(!error);\n\n        boost::filesystem::remove(\"symlink\", error);\n        assert(!error);\n    } /*if (!error)*/\n} /*main*/\n```", "```cpp\n#include <string>\n#include <boost/config.hpp>\n\n#define API extern \"C\" BOOST_SYMBOL_EXPORT\n\nAPI std::string greeter(const std::string& name) {\n    return \"Good to meet you, \" + name + \".\";\n}\n```", "```cpp\n#include <boost/dll/shared_library.hpp>\n```", "```cpp\nint main() {\n    boost::filesystem::path plugin_path = /* path-to-pligin */;\n\n    boost::dll::shared_library plugin(\n        plugin_path,\n        boost::dll::load_mode::append_decorations\n    );\n```", "```cpp\n    auto greeter = plugin.get<std::string(const std::string&)>(\"greeter\");\n```", "```cpp\n    std::cout << greeter(\"Sally Sparrow\");\n}\n```", "```cpp\nGood to meet you, Sally Sparrow.\n```", "```cpp\nThey are fast. Faster than you can believe. Don't turn \n\nyour back, don't look away, and don't blink. Good luck, Sally Sparrow.\n```", "```cpp\nboost::dll::shared_library lib(\n    \"./some/path/plugin_name\",\n    boost::dll::load_mode::append_decorations\n);\n```", "```cpp\nint main() {\n    int money = 1000;\n    start_trading(money);\n}\n```", "```cpp\nSorry, you're bankrupt!\n```", "```cpp\nvoid report_bankruptcy() {\n    std::cout << \"Sorry, you're bankrupt!\\n\";\n\n    std::exit(0);\n}\n```", "```cpp\n#include <iostream>\n#include <boost/stacktrace.hpp>\n\nvoid report_bankruptcy() {\n    std::cout << \"Sorry, you're bankrupt!\\n\";\n    std::cout << \"Here's how it happened:\\n\" \n        << boost::stacktrace::stacktrace();\n\n    std::exit(0);\n}\n```", "```cpp\nSorry, you're bankrupt!\nHere's how it happened:\n 0# report_bankruptcy()\n 1# loose(int)\n 2# go_to_casino(int)\n 3# go_to_bar(int)\n 4# win(int)\n 5# go_to_casino(int)\n 6# go_to_bar(int)\n 7# win(int)\n 8# make_a_bet(int)\n 9# loose(int)\n10# make_a_bet(int)\n11# loose(int)\n12# make_a_bet(int)\n13# start_trading(int)\n14# main\n15# 0x00007F79D4C48F45 in /lib/x86_64-linux-\n\ngnu/libc.so.6\n16# 0x0000000000401F39 in ./04_stacktrace\n```", "```cpp\n 0# report_bankruptcy()\n 1# go_to_casino(int)\n 2# win(int)\n 3# make_a_bet(int)\n 4# make_a_bet(int)\n 5# make_a_bet(int)\n 6# main\n```", "```cpp\n#include <boost/interprocess/managed_shared_memory.hpp> \n```", "```cpp\n#include <boost/atomic.hpp> \n\ntypedef boost::atomic<int> atomic_t; \n#if (BOOST_ATOMIC_INT_LOCK_FREE != 2) \n#error \"This code requires lock-free boost::atomic<int>\" \n#endif \n```", "```cpp\nint main() {\n    boost::interprocess::managed_shared_memory \n        segment(boost::interprocess::open_or_create, \"shm1-cache\", 1024);\n```", "```cpp\n    atomic_t& atomic \n        = *segment.find_or_construct<atomic_t> // 1\n            (\"shm1-counter\")                   // 2\n            (0)                                // 3\n    ;\n```", "```cpp\n    std::cout << \"I have index \" << ++ atomic \n        << \". Press any key...\\n\";\n    std::cin.get();\n```", "```cpp\n    const int snapshot = --atomic;\n    if (!snapshot) {\n        segment.destroy<atomic_t>(\"shm1-counter\");\n        boost::interprocess::shared_memory_object\n                ::remove(\"shm1-cache\");\n    }\n} /*main*/ \n```", "```cpp\nI have index 1\\. Press any key...\nI have index 2\\. \n\nPress any key...\nI have index 3\\. Press any key...\nI have index 4\\. Press any key...\nI have index 5\\. \n\nPress any key...\n```", "```cpp\n#include <boost/interprocess/managed_shared_memory.hpp> \n#include <boost/interprocess/containers/deque.hpp> \n#include <boost/interprocess/allocators/allocator.hpp> \n#include <boost/interprocess/sync/interprocess_mutex.hpp> \n#include <boost/interprocess/sync/interprocess_condition.hpp> \n#include <boost/interprocess/sync/scoped_lock.hpp> \n\n#include <boost/optional.hpp> \n```", "```cpp\nstruct task_structure { \n    // ... \n}; \n```", "```cpp\nclass work_queue { \npublic: \n    typedef boost::interprocess::managed_shared_memory  \n            managed_shared_memory_t; \n\n    typedef task_structure task_type; \n    typedef boost::interprocess::allocator< \n        task_type,  \n        boost::interprocess::managed_shared_memory::segment_manager \n    > allocator_t; \n```", "```cpp\nprivate: \n    managed_shared_memory_t segment_; \n    const allocator_t       allocator_; \n\n    typedef boost::interprocess::deque<task_type, allocator_t> deque_t; \n    deque_t&        tasks_; \n\n    typedef boost::interprocess::interprocess_mutex mutex_t; \n    mutex_t&        mutex_; \n\n    typedef boost::interprocess::interprocess_condition condition_t; \n    condition_t&    cond_; \n\n    typedef boost::interprocess::scoped_lock<mutex_t> scoped_lock_t;\n```", "```cpp\npublic: \n    explicit work_queue()\n        : segment_(\n              boost::interprocess::open_or_create,\n              \"work-queue\",\n              1024 * 1024 * 32\n        )\n        , allocator_(segment_.get_segment_manager())\n        , tasks_(\n            *segment_.find_or_construct<deque_t>\n              (\"work-queue:deque\")(allocator_)\n        )\n        , mutex_(\n            *segment_.find_or_construct<mutex_t>\n              (\"work-queue:mutex\")()\n        )\n        , cond_(\n            *segment_.find_or_construct<condition_t>\n              (\"work-queue:condition\")()\n        )\n    {}\n```", "```cpp\n    boost::optional<task_type> try_pop_task() { \n        boost::optional<task_type> ret; \n        scoped_lock_t lock(mutex_); \n        if (!tasks_.empty()) { \n            ret = tasks_.front(); \n            tasks_.pop_front(); \n        } \n        return ret; \n    }\n```", "```cpp\n    void cleanup() {\n        segment_.destroy<condition_t>(\"work-queue:condition\");\n        segment_.destroy<mutex_t>(\"work-queue:mutex\");\n        segment_.destroy<deque_t>(\"work-queue:deque\");\n\n        boost::interprocess::shared_memory_object\n            ::remove(\"work-queue\");\n    }\n```", "```cpp\nnamespace boost { namespace interprocess { \n    using boost::container::vector; \n}} \n```", "```cpp\nstruct with_pointer { \n    int* pointer_; \n    // ... \n    int value_holder_; \n}; \n```", "```cpp\n#include <boost/interprocess/offset_ptr.hpp> \n\nstruct correct_struct { \n    boost::interprocess::offset_ptr<int> pointer_; \n    // ... \n    int value_holder_; \n}; \n```", "```cpp\nint main() {\n    boost::interprocess::managed_shared_memory \n        segment(boost::interprocess::open_or_create, \"segment\", 4096);\n\n    correct_struct* ptr =\n        segment.find<correct_struct>(\"structure\").first;\n\n    if (ptr) {\n        std::cout << \"Structure found\\n\";\n        assert(*ptr->pointer_ == ethalon_value);\n        segment.destroy<correct_struct>(\"structure\");\n    }\n}\n```", "```cpp\n#include <boost/interprocess/file_mapping.hpp> \n#include <boost/interprocess/mapped_region.hpp> \n```", "```cpp\nconst boost::interprocess::mode_t mode = boost::interprocess::read_only; \nboost::interprocess::file_mapping fm(filename, mode); \n```", "```cpp\nboost::interprocess::mapped_region region(fm, mode, 0, 0);\n```", "```cpp\nconst char* begin = static_cast<const char*>(\n    region.get_address()\n);\n```", "```cpp\nconst char* pos = std::find(\n    begin, begin + region.get_size(), '\\1'\n);\n```", "```cpp\n    $ TIME=\"%E\" time ./reading_files m\n    mapped_region: 0:00.08\n\n    $ TIME=\"%E\" time ./reading_files r\n    ifstream: 0:00.09\n\n    $ TIME=\"%E\" time ./reading_files a\n    C: 0:00.09\n```", "```cpp\nstd::ifstream f(filename, std::ifstream::binary); \n// ... \nchar c[kilobyte]; \nf.read(c, kilobyte); \n```", "```cpp\n#include <boost/coroutine2/coroutine.hpp> \n```", "```cpp\ntypedef boost::coroutines2::asymmetric_coroutine<std::size_t> corout_t;\n```", "```cpp\nstruct coroutine_task {\n    std::string& result;\n\n    coroutine_task(std::string& r)\n        : result(r)\n    {}\n\n    void operator()(corout_t::pull_type& yield);\n\nprivate:\n    std::size_t ticks_to_work;\n    void tick(corout_t::pull_type& yield);\n};\n```", "```cpp\nint main() {\n    std::string result;\n    coroutine_task task(result);\n    corout_t::push_type coroutine(task);\n```", "```cpp\n    // Somewhere in main():\n\n    while (!spinlock.try_lock()) {\n        // We may do some useful work, before\n        // attempting to lock a spinlock once more.\n        coroutine(10); // 10 is the ticks count to run.\n    }\n    // Spinlock is locked.\n    // ...\n\n    while (!port.block_ready()) {\n        // We may do some useful work, before\n        // attempting to get block of data once more.\n        coroutine(300); // 300 is the ticks count to run.\n\n        // Do something with `result` variable.\n    }\n```", "```cpp\nvoid coroutine_task::operator()(corout_t::pull_type& yield) {\n    ticks_to_work = yield.get();\n\n    // Prepare buffers.\n    std::string buffer0;\n\n    while (1) {\n        const bool requiers_1_more_copy = copy_to_buffer(buffer0);\n        tick(yield);\n\n        if (requiers_1_more_copy) {\n            std::string buffer1;\n            copy_to_buffer(buffer1);\n            tick(yield);\n\n            process(buffer1);\n            tick(yield);\n        }\n\n        process(buffer0);\n        tick(yield);\n    }\n}\n```", "```cpp\nvoid coroutine_task::tick(corout_t::pull_type& yield) {\n    if (ticks_to_work != 0) {\n        --ticks_to_work;\n    }\n\n    if (ticks_to_work == 0) {\n        // Switching back to main.\n        yield();\n\n        ticks_to_work = yield.get();\n    }\n}\n```"]