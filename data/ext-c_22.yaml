- en: Chapter 22
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第22章
- en: Unit Testing and Debugging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和调试
- en: It doesn't really matter which programming language you are using or what type
    of application you are developing, it is always important to thoroughly test it
    before delivering it to the customer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您使用哪种编程语言或开发什么类型的应用程序并不重要，在交付给客户之前彻底测试它始终很重要。
- en: Writing tests is not a new thing and as of today, you can find hundreds or even
    thousands of tests in almost every software project. Nowadays writing tests for
    software is a must and delivering a piece of code or feature without having it
    tested properly is strongly discouraged. That's why we have a dedicated chapter
    to talk about testing software written in C, and various libraries that exist
    today for this purpose.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试并不是一件新鲜事，截至今天，您几乎可以在每个软件项目中找到数百甚至数千个测试。如今，编写软件测试是必须的，没有经过适当测试的代码或功能被强烈反对。这就是为什么我们有一个专门的章节来讨论用C编写的软件测试，以及今天存在用于此目的的各种库。
- en: Testing is not the only topic in this chapter, however. We will also be discussing
    the debugging tools and techniques that can be used to troubleshoot a C program.
    Testing and debugging have complimented one another from the start, and whenever
    a test fails, a series of investigations are followed and debugging the target
    code is a common follow-up action.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章不仅仅讨论测试。我们还将讨论可用于调试C程序的调试工具和技术。测试和调试从一开始就相互补充，每当测试失败时，都会进行一系列调查，调试目标代码是常见的后续行动。
- en: In this chapter, we won't go through the philosophy of testing and we assume
    that testing is good. Instead, we will give you a short introduction about the
    basic terminology and the guidelines that a developer should follow in order to
    write testable code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会讲解测试的哲学，而是假设测试是好的。相反，我们将为您提供一个关于基本术语和开发者在编写可测试代码时应遵循的指南的简要介绍。
- en: This chapter has two sections. In the first section, we talk about testing and
    the existing libraries that can be used in modern C development. The second section
    of this chapter is going to talk about debugging, starting with a discussion about
    various categories of bugs. Memory issues, concurrency issues, and performance
    issues are the most common cases in which further debugging seems to be necessary
    in order to establish a successful investigation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两部分。第一部分，我们讨论测试和可用于现代C开发的现有库。本章的第二部分将讨论调试，从讨论各种类型的错误开始。内存问题、并发问题和性能问题是似乎需要进一步调试以建立成功调查的最常见情况。
- en: We will also cover the most used debugging tools available for C (and C++).
    The final goal of this chapter is to let you know about the testing and debugging
    utilities available for C and give you some basic background knowledge about them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涵盖适用于C（和C++）的最常用的调试工具。本章的最终目标是让您了解C和调试工具，并为您提供一些基本背景知识。
- en: The first section introduces you to the basic terminology of software testing
    in general. It is not specific to C, and the ideas and concepts can be applied
    to other programming languages and technologies as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分向您介绍了软件测试的基本术语。它不仅限于C，这些思想和概念也可以应用于其他编程语言和技术。
- en: Software testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件测试
- en: Software testing is a big and important subject in computer programming, and
    it has its own specific terminology and many concepts. In this section, we are
    going to give you a very basic introduction to software testing. Our purpose is
    to define some terms that we are going to use in the first half of this chapter.
    Therefore, you should be aware that this is not a thorough chapter about testing
    and further study is strongly encouraged.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是计算机编程中的一个庞大且重要的主题，它有自己的特定术语和许多概念。在本节中，我们将为您提供一个关于软件测试的非常基础的介绍。我们的目的是定义一些我们将在本章前半部分使用的术语。因此，您应该意识到这不是一个关于测试的详尽章节，强烈建议进一步学习。
- en: When it comes to testing software, the first question that comes to mind is,
    what are we testing, and what is this testing about? In general, we test an aspect
    of a software system. This aspect can be *functional* or *non-functional*. In
    other words, the aspect may be related to a certain functionality of the system,
    or it can be related to a certain variable of a system when performing a functionality.
    Next, we give some examples.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到测试软件时，首先想到的问题是，我们在测试什么，这次测试是关于什么的？一般来说，我们测试软件系统的一个方面。这个方面可以是 *功能* 或 *非功能*
    的。换句话说，这个方面可能与系统的某个功能相关，或者当执行功能时，可能与系统的某个变量相关。接下来，我们给出一些例子。
- en: '*Functional testing* is about testing a defined functionality requested as
    part of the *functional requirements*. These tests provide a certain input to
    a *software element* such as a *function*, a *module*, a *component*, or a *software
    system*, and expect a certain output from them. Only if the expected output is
    seen as part of a test is that test considered as *passed*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能测试* 是关于测试作为 *功能需求* 部分请求的特定功能。这些测试向一个 *软件元素*，例如一个 *函数*、一个 *模块*、一个 *组件* 或一个
    *软件系统*，提供一定的输入，并期望从它们那里获得一定的输出。只有当期望的输出被视为测试的一部分时，该测试才被认为是 *通过* 的。'
- en: '*Non-functional testing* is about the *quality level* to which a software element,
    such as a function, a module, a component, or a software system as a whole, completes
    a specific functionality. These tests are usually supposed to *measure* various
    *variables* like *memory usage*, *time to completion*, *lock contention*, and
    *level of security*, and assess how well that element has done its job. A test
    is passed only when the measured variables are within the expected ranges. The
    *expectations* for these variables are derived from the *non-functional requirements*
    defined for the system.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*非功能测试* 是关于软件元素，例如一个函数、一个模块、一个组件或整个软件系统，完成特定功能的质量水平。这些测试通常旨在 *测量* 各种 *变量*，如
    *内存使用*、*完成时间*、*锁竞争* 和 *安全性级别*，并评估该元素完成其工作的程度。只有当测量的变量在预期的范围内时，测试才被认为是 *通过* 的。这些变量的
    *预期值* 来自为系统定义的 *非功能需求*。'
- en: Apart from functional and non-functional testing, we can have different *levels*
    of testing. These levels are designed in a way to cover some orthogonal aspects.
    Some of these aspects are size of the tested element, the actor of the test, and
    the extent of the functionalities that should be tested.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了功能和非功能测试之外，我们还可以有不同的 *测试级别*。这些级别的设计方式是为了覆盖一些正交方面。这些方面中的一些是测试元素的大小、测试的参与者以及应该测试的功能范围的广度。
- en: For instance, regarding the size of the element, these levels are defined from
    the smallest possible piece of functionality, which we know as a function (or
    a method), up to the biggest possible piece of functionality that it is exposed
    from a software system as a whole.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，就元素的大小而言，这些级别是从可能的最小功能块定义的，我们称之为函数（或方法），到从整个软件系统暴露出的可能最大的功能块。
- en: In the following section, we are going to introduce these levels in a deeper
    sense
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将更深入地介绍这些级别。
- en: Testing levels
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试级别
- en: 'For every software system, the following levels of testing can be considered
    and planned. These are not the only existing testing levels and you can find more
    of them in other references:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个软件系统，可以考虑和计划以下测试级别。这些并不是唯一的测试级别，你可以在其他参考资料中找到更多：
- en: Unit testing
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: System testing
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试
- en: Acceptance testing
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受测试
- en: Regression testing
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试
- en: In *unit testing*, we test a *unit* of functionality. This unit can be a function
    that performs a certain job, or a group of functions together to satisfy a need,
    or a class that has a final goal to perform a certain functionality, or even a
    component that has a specific task to do. A *component* is a part of a software
    system that has a well-defined set of functionalities and, together with other
    components, joins and becomes the whole software system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *单元测试* 中，我们测试一个 *功能单元*。这个单元可以是一个执行特定任务的函数，或者是一组函数组合起来满足需求，或者是一个有最终目标执行特定功能的类，甚至是一个有特定任务要完成的组件。一个
    *组件* 是软件系统的一部分，它有一组定义良好的功能，并且与其他组件一起结合，成为整个软件系统。
- en: In the case of having components as units, we call the testing process *component
    testing*. Both functional and non-functional testing can be done at the level
    of units. When testing a unit, that unit should become isolated from its surrounding
    units, and for this to happen, the surrounding environment should be simulated
    in some way. This level would be the only level that we cover as part of this
    chapter and we provide real code to demonstrate how unit testing and component
    testing can be done in C.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件作为单元的情况下，我们将测试过程称为*组件测试*。功能和非功能测试都可以在单元层面进行。在测试单元时，该单元应与其周围单元隔离，为此，周围环境应以某种方式模拟。这个层面将是本章涵盖的唯一层面，我们提供实际代码来演示如何在C中进行单元测试和组件测试。
- en: When the units join together, they form a component. In component testing, a
    component is tested alone in isolation. But when we group some of these components,
    we need a different level of testing that checks the functionality or the variables
    for that specific group of components. This level is *integration testing*. As
    the name implies, the tests in this level check if the integration of some of
    the components works well and they together still satisfy the defined requirements
    for the system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元组合在一起时，它们形成一个组件。在组件测试中，组件单独进行测试。但当我们将这些组件分组时，我们需要不同层面的测试来检查该特定组件组的函数性或变量。这个层面称为*集成测试*。正如其名所示，这个层面的测试检查某些组件的集成是否良好，并且它们一起仍然满足系统定义的要求。
- en: At a different level, we test the functionality of the whole system. This will
    contain a complete set of all components fully integrated. This way, we test if
    the exposed system functionalities and system variables are in accordance with
    the requirements defined for the software system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同层面，我们测试整个系统的功能。这将包含所有完全集成的组件的完整集合。这样，我们测试暴露的系统功能性和系统变量是否与为软件系统定义的要求一致。
- en: 'On a different level, we evaluate a software system to check if it is in accordance
    with the business requirements defined for that system from the *stakeholder*
    or *end user* point of view. This level is called *acceptance testing*. While
    both system testing and acceptance testing is about the whole software system,
    they are actually quite different. To name a few differences:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同层面，我们评估一个软件系统是否与从*利益相关者*或*最终用户*角度定义的业务需求一致。这个层面被称为*验收测试*。虽然系统测试和验收测试都是关于整个软件系统，但它们实际上相当不同。以下是一些差异：
- en: System testing is done by developers and testers, but acceptance testing is usually
    done by the end user or the stakeholder.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试由开发人员和测试人员执行，但验收测试通常由最终用户或利益相关者执行。
- en: System testing is about checking both functional and non-functional requirements,
    but acceptance testing is only about functional requirements.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试是关于检查功能和非功能需求，但验收测试只关注功能需求。
- en: In system testing, we usually use a prepared small set of data as the input,
    but in acceptance testing, the actual real-time data is fed to the system.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统测试中，我们通常使用准备好的小数据集作为输入，但在验收测试中，实际实时数据被输入到系统中。
- en: A great link that explains all the differences can be found [at https://www.javatpoint.com/acceptance-tes](https://www.javatpoint.com/acceptance-testing)ting.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的链接，解释了所有这些差异，可以在[https://www.javatpoint.com/acceptance-tes](https://www.javatpoint.com/acceptance-testing)ting找到。
- en: When a change is introduced to a software system, it is required to check if
    the current functional and non-functional tests are still in a good shape. This
    is done at a different level known as *regression testing*. The purpose of regression
    testing is to confirm that there is no *regression* after introducing a change.
    As part of regression testing, all the functional and non-functional tests found
    as unit tests, integration tests, and end-to-end (system) tests are run again
    to see if any of them fail following a change.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当向软件系统引入变更时，需要检查当前的功能和非功能测试是否仍然处于良好状态。这在不同层面进行，称为*回归测试*。回归测试的目的是确认在引入变更后没有发生*回归*。作为回归测试的一部分，所有作为单元测试、集成测试和端到端（系统）测试发现的测试都会再次运行，以查看是否有任何测试在变更后失败。
- en: In this section, we introduced various levels of testing. For the rest of this
    chapter, we are going to discuss unit testing. In the upcoming section, we start
    talking about it by giving a C example and trying to write test cases for it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了各种测试级别。在本章的其余部分，我们将讨论单元测试。在接下来的部分，我们将通过给出一个 C 示例并尝试为其编写测试用例来开始讨论它。
- en: Unit testing
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: As we explained in the previous section, as part of unit testing, we test isolated
    units and a unit can be as small as a function or as big as a component. In C,
    it can be a function or a whole component written in C. The same discussion can
    be applied to C++ as well, but there we can have other units like classes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节中解释的，作为单元测试的一部分，我们测试独立的单元，一个单元可以小到函数，也可以大到组件。在 C 中，它可以是一个函数，也可以是整个用 C
    编写的组件。同样的讨论也适用于 C++，但在那里我们可以有其他单元，如类。
- en: The most important thing about unit testing is that units should be tested in
    isolation. For example, if the target function depends on the output of another
    function, we need to find a way to test the target function in isolation. We are
    going to explain this using a real example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试最重要的地方是单元应该单独进行测试。例如，如果目标函数依赖于另一个函数的输出，我们需要找到一种方法来单独测试目标函数。我们将通过一个真实示例来解释这一点。
- en: '*Example 22.1* prints the factorials of even numbers less than 10, but not
    in the usual way. The code is well-organized in one header and two source files.
    The example is about two functions; one of them generates the even numbers less
    than 10 and the other function receives a function pointer and uses it as a source
    for reading an integer number, and finally calculates its factorial.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 22.1* 打印小于 10 的偶数的阶乘，但不是以通常的方式。代码在一个头文件和两个源文件中组织得很好。本例涉及两个函数；其中一个函数生成小于
    10 的偶数，另一个函数接收一个函数指针并将其用作读取整数数的源，并最终计算其阶乘。'
- en: 'The following code box contains the header file containing the function declarations:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含包含函数声明的头文件：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 22-1 [ExtremeC_examples_chapter22_1.h]: The header file of example
    22.1'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 22-1 [ExtremeC_examples_chapter22_1.h]：示例 22.1 的头文件
- en: 'As you can see, the function `calc_factorial` accepts a function pointer that
    returns an integer. It will use the function pointer in order to read an integer
    and calculate its factorial. The following code is the definition of the preceding
    functions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`calc_factorial` 函数接受一个返回整数的函数指针。它将使用该函数指针来读取一个整数并计算其阶乘。以下代码是前面函数的定义：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 22-2 [ExtremeC_examples_chapter22_1.c]: The definitions of the functions
    used in example 22.1'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 22-2 [ExtremeC_examples_chapter22_1.c]：示例 22.1 中使用的函数的定义
- en: 'The `next_even_number` function has an internal static variable that acts as
    a feed for the caller function. Note that it never exceeds 8 and after that, it
    goes back to 0\. Therefore, you can simply call this function as many times as
    you like, and you never get a number greater than 8 and lower than zero. The following
    code box contains the content of the source file that contains the `main` function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_even_number` 函数有一个内部静态变量，它作为调用函数的输入。请注意，它永远不会超过 8，之后它回到 0。因此，你可以简单地多次调用这个函数，而永远不会得到一个大于
    8 且小于零的数字。以下代码框包含包含 `main` 函数的源文件的内容：'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 22-3 [ExtremeC_examples_chapter22_1_main.c]: The main function of
    example 22.1'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 22-3 [ExtremeC_examples_chapter22_1_main.c]：示例 22.1 的主函数
- en: 'As you see, the `main` function calls the `calc_function` 12 times and prints
    the returned factorials. In order to run the preceding example, you need to compile
    both source files first and then link their corresponding relocatable object files
    together. The following shell box contains the required commands to build and
    run the example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`main` 函数调用了 `calc_function` 12 次，并打印了返回的阶乘。为了运行前面的示例，你需要首先编译这两个源文件，然后将它们相应的可重定位目标文件链接在一起。以下
    shell box 包含构建和运行示例所需的命令：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 22-1: Building and running example 22.1'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 22-1：构建和运行示例 22.1
- en: In order to write tests for the preceding functions, we need to give a bit of
    introduction first. As you can see, we have two functions (not including the `main`
    function) in the example. Therefore, there are two different units, in this case
    functions, that should be tested separately and in isolation from each other;
    one is the `next_even_number` function and the other one is the `calc_factorial`
    function. But as it is clear in the main function, the `calc_factorial` function
    depends on the `next_even_number` function and one might think that this dependency
    is going to make the isolation of the `calc_factorial` function much harder than
    we anticipated. But this is not true.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写前面函数的测试，我们首先需要做一些介绍。正如你所见，示例中有两个函数（不包括`main`函数）。因此，存在两个不同的单元，在这种情况下是函数，应该分别且独立于彼此进行测试；一个是`next_even_number`函数，另一个是`calc_factorial`函数。但是，正如主函数中所示，`calc_factorial`函数依赖于`next_even_number`函数，有人可能会认为这种依赖会使`calc_factorial`函数的隔离比我们预期的要困难得多。但这并不是真的。
- en: In fact, the `calc_factorial` function does not depend on the `next_even_number`
    function at all. It only depends on the *signature* of `next_even_number` and
    not its definition. Therefore, it is possible to replace `next_even_number` with
    a function that follows the same signature, but always returns a fixed integer.
    In other words, we can provide a simplified version of `next_even_number` that
    is intended to be used only in the *test cases*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`calc_factorial`函数根本不依赖于`next_even_number`函数。它只依赖于`next_even_number`的*签名*，而不是其定义。因此，我们可以用一个遵循相同签名的函数来替换`next_even_number`，但总是返回一个固定的整数。换句话说，我们可以提供一个简化的`next_even_number`版本，这个版本仅打算在*测试用例*中使用。
- en: So, what is a test case? As you know, there are various scenarios to test a
    specific unit. The simplest example is to provide various inputs to a certain
    unit and *expect* a predetermined output. In the preceding example, we can provide
    `0` as the input for the `calc_factorial` function and wait for `1` as its output.
    We can also provide `-1` and wait for `1`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是测试用例呢？正如你所知，有各种场景可以用来测试特定的单元。最简单的例子是向某个单元提供各种输入并*期望*得到预定的输出。在先前的例子中，我们可以为`calc_factorial`函数提供`0`作为输入，并等待其输出为`1`。我们也可以提供`-1`并等待其输出为`1`。
- en: Every one of these scenarios can be a test case. Therefore, regarding a single
    unit, we can have multiple test cases addressing all different corner cases of
    that unit. A collection of test cases is called a *test suite*. All the test cases
    found in a test suite are not necessarily related to the same unit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景中的每一个都可以成为一个测试用例。因此，针对单个单元，我们可以有多个测试用例，以解决该单元的所有不同边界情况。测试用例的集合称为*测试套件*。测试套件中找到的所有测试用例不一定与同一个单元相关。
- en: 'We start by creating a test suite for the `next_even_number` function. Since
    `next_even_number` can be easily tested in isolation, there is no need for extra
    work. Following are the test cases written for the `next_even_number` function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为`next_even_number`函数创建一个测试套件。由于`next_even_number`可以很容易地独立测试，因此不需要额外的工作。以下是为`next_even_number`函数编写的测试用例：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 22-4 [ExtremeC_examples_chapter22_1 __next_even_number__tests.c]:
    The test cases written for the next_even_number function'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 22-4 [ExtremeC_examples_chapter22_1 __next_even_number__tests.c]：为`next_even_number`函数编写的测试用例
- en: As you see, we have defined two test cases in the preceding test suite. Note
    that I have used my own convention to give names to the above test cases; however,
    there is no standard regarding this. The whole purpose of naming test cases is
    to realize what a test case does from its name and more important than that, to
    find it easily in the code when the test case fails or needs to be modified.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在先前的测试套件中定义了两个测试用例。请注意，我使用了自己的约定来命名上述测试用例；然而，这并没有标准。整个命名测试用例的目的是从其名称中了解测试用例的作用，更重要的是，当测试用例失败或需要修改时，可以在代码中轻松找到它。
- en: I used the capital `TESTCASE` as a prefix to function names to make them distinguished
    from other ordinary functions. The names of the functions also try to describe
    the test case and the concern it is addressing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用大写`TESTCASE`作为函数名称的前缀，以便与其它普通函数区分开来。函数的名称也试图描述测试用例及其所关注的问题。
- en: Both test cases have `assert` at the end. This is the thing that all test case
    functions do when evaluating the expectations. If the condition inside the parentheses
    of `assert` is not true, the *test runner*, a program that is running the tests,
    quits and an error message is printed. More than that, the test runner returns
    a non-zero *exit code* that indicates one or more of the test cases have failed.
    The test runner program must return 0 when all tests have been successful.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试用例都在最后使用了 `assert`。这是所有测试用例函数在评估期望时都会做的事情。如果 `assert` 括号内的条件不成立，*测试运行器*，一个正在运行测试的程序，会退出并打印错误信息。不仅如此，测试运行器还会返回一个非零的
    *退出码*，这表明一个或多个测试用例失败了。当所有测试都成功时，测试运行器程序必须返回 0。
- en: It would be nice to go through the test cases on your own and try to understand
    how they evaluate our expectations by calling the `next_even_number` function
    in the preceding two scenarios.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，你可以自己走一遍测试用例，尝试理解它们是如何通过调用前面两个场景中的 `next_even_number` 函数来评估我们的期望的。
- en: Now, it's time to write test cases for the `calc_factorial` function. Writing
    test cases for the `calc_factorial` function needs a *stub function* as its feed
    that returns the test input. We explain what stubs are shortly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为 `calc_factorial` 函数编写测试用例了。为 `calc_factorial` 函数编写测试用例需要一个 *存根函数* 作为其输入。我们简要解释一下存根是什么。
- en: 'Following are three test cases that are only testing the `calc_factorial` unit:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三个仅测试 `calc_factorial` 单元的测试用例：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 22-5 [ExtremeC_examples_chapter22_1 __calc_factorial__tests.c]: The
    test cases written for the calc_factorial function'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 22-5 [ExtremeC_examples_chapter22_1 __calc_factorial__tests.c]：为 `calc_factorial`
    函数编写的测试用例
- en: As you can see, we have defined three test cases for the `calc_factorial` function.
    Note the `feed_stub` function. It follows the same contract that `next_even_number`
    is following, as can be seen in *Code Box 22-2*, but it has a very simple definition.
    It just returns a value stored in the static variable `input_value`. This variable
    can be set by the test cases before calling the `calc_facorial` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们为 `calc_factorial` 函数定义了三个测试用例。注意 `feed_stub` 函数。它遵循与 `next_even_number`
    相同的契约，如 *代码框 22-2* 所示，但它有一个非常简单的定义。它只是返回存储在静态变量 `input_value` 中的值。这个变量可以在调用 `calc_factorial`
    函数之前由测试用例设置。
- en: Using the preceding stub function, we could isolate `calc_factorial` and test
    it individually. The same approach is valid for object-oriented programming languages
    like C++ or Java, but there we define *stub classes* and *stub objects*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的存根函数，我们可以隔离 `calc_factorial` 并单独测试它。同样的方法也适用于 C++ 或 Java 这样的面向对象编程语言，但我们在那里定义
    *存根类* 和 *存根对象*。
- en: In C, a *stub* is a function definition that conforms to a function declaration
    that the target unit would use as part of its logic, and more importantly, the
    stub doesn't have a complex logic and it just returns a value that is going to
    be used just by the test case.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，*存根* 是一个符合目标单元逻辑中使用的函数声明的函数定义，更重要的是，存根没有复杂的逻辑，它只是返回一个将被测试用例使用的值。
- en: In C++, a stub can still be a function definition that conforms to a function
    declaration, or a class that implements an interface. In other object-oriented
    languages where you cannot have standalone functions, for instance Java, a stub
    can only be a class that implements an interface. Then, a stub object is an object
    from such stub classes. Note that in all cases, a stub should have a simple definition
    that is only usable in tests, and not in production.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，存根仍然可以是一个符合函数声明的函数定义，或者是一个实现接口的类。在其他无法有独立函数的对象导向语言中，例如 Java，存根只能是一个实现接口的类。然后，存根对象是从这样的存根类中创建的对象。请注意，在所有情况下，存根都应该有一个简单的定义，仅适用于测试，而不适用于生产。
- en: 'Finally, we need to be able to run the test cases. As we said previously, we
    need a test runner to run tests. Therefore, we need a specific source file with
    a `main` function that only runs the test cases one after another. The following
    code box contains the code of the test runner:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要能够运行测试用例。正如我们之前所说的，我们需要一个测试运行器来运行测试。因此，我们需要一个包含 `main` 函数的特定源文件，该函数只依次运行测试用例。下面的代码框包含了测试运行器的代码：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 22-6 [ExtremeC_examples_chapter22_1 _tests.c]: The test runner used
    in example 22.1'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 22-6 [ExtremeC_examples_chapter22_1 _tests.c]：示例 22.1 中使用的测试运行器
- en: 'The above code returns `0` only if all the test cases within the `main` functions
    are executed successfully. For building the test runner, we need to run the following
    commands. Note the `-g` option that adds debugging symbols to the final test runner
    executable. Performing a *debug build* is the most common way to build tests since
    if a test case fails, we immediately need the precise *stack trace* and further
    debugging information to proceed with investigation. More than that, the `assert`
    statements are usually removed from *release builds*, but we need to have them
    in the test runner executable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅在`main`函数中的所有测试用例都成功执行时返回`0`。为了构建测试运行器，我们需要运行以下命令。注意`-g`选项，它将调试符号添加到最终的测试运行器可执行文件中。进行*调试构建*是构建测试的最常见方式，因为如果测试用例失败，我们立即需要精确的*堆栈跟踪*和进一步的调试信息以继续调查。更重要的是，`assert`语句通常从*发布构建*中删除，但我们需要在测试运行器可执行文件中保留它们：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 22-2: Building and running the test runner of example 22.1'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 22-2：构建和运行示例22.1的测试运行器
- en: The preceding shell box shows that all the tests have been passed. You can also
    check the exit code of the test runner process by using the `echo $?` command
    and see that it has returned zero.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的shell框显示所有测试都已通过。您也可以通过使用`echo $?`命令来检查测试运行进程的退出代码，并看到它已返回零。
- en: 'Now, by applying a simple change in one of the functions, we can fail the tests.
    Let''s see what happens when we change `calc_factorial` as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在其中一个函数中应用简单的更改，我们可以使测试失败。让我们看看当我们按照以下方式更改`calc_factorial`时会发生什么：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 22-7: Changing the calc_factorial function to fail the tests'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框22-7：将`calc_factorial`函数更改为使测试失败
- en: 'With the preceding change, shown in bold font, the test cases about the `0`
    and negative inputs still pass, but the last test case, which is about the calculation
    of the factorial of `5`, fails. We are going to build the test runner again and
    the following is the output of the execution on a macOS machine:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的更改，以粗体显示，关于`0`和负输入的测试用例仍然通过，但最后一个测试用例，即关于计算`5`的阶乘的测试用例失败了。我们将再次构建测试运行器，以下是在macOS机器上执行的输出：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Shell Box 22-3: Building and running the test runner after changing the calc_factorial
    function'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 22-3：更改`calc_factorial`函数后构建和运行测试运行器
- en: As you can see, `Assertion failed` appears in the output and the exit code is
    `134`. This exit code is usually used and reported by the systems running the
    tests periodically, such as *Jenkins*, to check if the tests have been run successfully.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出中出现了`Assertion failed`，退出代码为`134`。这个退出代码通常由定期运行测试的系统使用和报告，例如*Jenkins*，以检查测试是否成功运行。
- en: 'As a rule of thumb, whenever you have a unit that should be tested in isolation,
    you need to find a way to provide its dependencies as some kind of input. Therefore,
    the unit itself should be written in a way that makes it *testable*. Not all code
    is testable, and testability is not limited to unit testing, and this is very
    important to be aware of. This link provides good information on how to write
    t[estable code: https://blog.gurock.com/highly-](https://blog.gurock.com/highly-testable-code/)testable-code/.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项经验法则，每当您有一个需要独立测试的单元时，您需要找到一种方法来提供其依赖项作为某种输入。因此，单元本身应该以使其*可测试*的方式编写。并非所有代码都是可测试的，可测试性不仅限于单元测试，这一点非常重要，需要意识到。此链接提供了有关如何编写可测试代码的良好信息：[https://blog.gurock.com/highly-testable-code/](https://blog.gurock.com/highly-testable-code/)。
- en: 'To clarify the above discussion, suppose that we have written the `calc_factorial`
    function like below to use the `next_even_number` function directly instead of
    using a function pointer. Note that in the following code box, the function doesn''t
    receive a function pointer argument and it calls the `next_even_number` function
    directly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清上述讨论，假设我们已经像下面这样编写了`calc_factorial`函数，直接使用`next_even_number`函数而不是使用函数指针。请注意，在以下代码框中，函数不接收函数指针参数，并且它直接调用`next_even_number`函数：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 22-8: Changing the calc_factorial function''s signature to not accept
    a function pointer'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框22-8：将`calc_factorial`函数的签名更改为不接受函数指针
- en: The preceding code is less testable. There is no way to test `calc_factorial`
    without having the `next_even_number` called – that is, without employing some
    hacks to change the definition behind the symbol `next_even_number` as part of
    the final executable, as we do in *example 22.2*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的可测试性较低。没有方法在不调用`next_even_number`的情况下测试`calc_factorial`——也就是说，没有使用一些技巧来更改最终可执行文件中符号`next_even_number`背后的定义，就像我们在*示例22.2*中所做的那样。
- en: In fact, both versions of `calc_factorial` do the same thing, but the definition
    in *Code Box 22-2* is more testable because we could test it in isolation. Writing
    testable code is not easy, and you should always think carefully in order to implement
    code and have it be testable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`calc_factorial`的两个版本都做了同样的事情，但*代码框22-2*中的定义更易于测试，因为我们可以在隔离的情况下对其进行测试。编写可测试的代码并不容易，你应该始终仔细思考，以便实现代码并使其可测试。
- en: Writing testable code usually demands more work. There are various opinions
    about the overhead percentage of writing testable code but it is certain that
    writing tests brings some extra cost in terms of time and effort. But this extra
    cost surely has great benefits. Without having tests for a unit, you will lose
    track of it as time goes by and more changes are introduced to the unit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可测试的代码通常需要更多的工作。关于编写可测试代码的额外开销百分比存在各种观点，但可以肯定的是，编写测试确实会在时间和精力上带来一些额外的成本。但这种额外的成本确实带来了巨大的好处。如果没有为单元编写测试，随着时间的推移和单元中引入的更多更改，你将失去对它的跟踪。
- en: Test doubles
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试双胞胎
- en: 'In the preceding example, while writing test cases, we introduced stub functions.
    There are a few other terms about the objects that try to mimic a unit''s dependencies.
    These objects are called *test doubles*. Next, we are going to introduce two other
    test doubles: *mock* and *fake* functions. First, let''s briefly explain again
    what stub functions are.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，在编写测试用例时，我们引入了存根函数。还有一些其他术语是关于试图模仿单元依赖的对象。这些对象被称为*测试双胞胎*。接下来，我们将介绍另外两种测试双胞胎：*模拟*和*伪造*函数。首先，让我们再次简要解释一下存根函数是什么。
- en: Note two things in this short section. Firstly, there are never-ending debates
    on the definition of these test doubles, and we try to give a proper definition
    that matches our usage in this chapter. Secondly, we keep our discussion only
    relevant to C, so there is no object and everything we have is a function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的部分中，请注意两点。首先，关于这些测试双胞胎的定义永远存在争论，我们试图给出一个符合本章使用的适当定义。其次，我们只将讨论与C语言相关的内容，因此没有对象，我们有的都是函数。
- en: When a unit is dependent on another function, it simply depends on the signature
    of that function, therefore that function can be replaced by a new one. This new
    function, based on some properties that it might have, can be called a stub, a
    mock, or a fake function. These functions are just written to satisfy the test
    requirements and they cannot be used in production.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个单元依赖于另一个函数时，它只是依赖于该函数的签名，因此该函数可以被一个新的函数所替代。这个新函数，基于它可能具有的一些属性，可以被称作存根、模拟或伪造函数。这些函数只是编写来满足测试要求，它们不能在生产环境中使用。
- en: 'We explained a stub to be a function that is very simple, usually just returning
    a constant value. As you saw in *example 22.1*, it was indirectly returning a
    value just set by the running test case. In the following link, you can read more
    about the test doubles that we are talking about and a f[ew more of them: https://en.wikipedia.org](https://en.wikipedia.org/wiki/Test_double)/wiki/Test_double.
    If you open the link, a stub is defined as something that provides an *indirect
    input* to the testing code. If you accept this definition, the `feed_stub` function
    seen in *Code Box 22-5* is a stub function.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将存根（stub）解释为一个非常简单的函数，通常只是返回一个常量值。正如你在*示例22.1*中看到的，它间接地返回了由正在运行的测试用例设置的值。在以下链接中，你可以了解更多关于我们正在讨论的测试双胞胎以及一些其他的：[https://en.wikipedia.org/wiki/Test_double](https://en.wikipedia.org/wiki/Test_double)。如果你打开链接，存根被定义为向测试代码提供*间接输入*的东西。如果你接受这个定义，*代码框22-5*中看到的`feed_stub`函数就是一个存根函数。
- en: Mock functions, or generally mock objects as part of object-oriented languages,
    can be manipulated by specifying the output for a certain input. This way, you
    set whatever should be returned from a mock function for a certain input before
    running the test logic and during the logic it will act as you have set beforehand.
    Mock objects in general can have expectations as well and they perform the required
    assertions accordingly. As stated in the preceding link, for mock objects, we
    set expectations before running the test. We are going to give a C example of
    mock functions as part of the component testing section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟函数，或者更普遍地说，作为面向对象语言的一部分的模拟对象，可以通过指定某个输入的输出来进行操作。这样，在运行测试逻辑之前，你可以设置模拟函数对于某个输入应该返回的内容，在逻辑运行期间，它将按照你事先设置的方式行动。一般来说，模拟对象也可以有期望，并且它们将相应地执行所需的断言。正如前一个链接中所述，对于模拟对象，我们在运行测试之前设置期望。我们将在组件测试部分给出一个C语言的模拟函数示例。
- en: Finally, a fake function can be used to give a very simplified functionality
    for a real and maybe complex functionality as part of the running test. For example,
    instead of using a real filesystem, one may use some simplified in-memory storage.
    In component testing, for instance, other components that have complex functionalities
    can be replaced by fake implementations in the tests.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用一个假函数来为运行测试中的真实且可能复杂的函数提供非常简化的功能。例如，而不是使用真实的文件系统，可以使用一些简化的内存存储。在组件测试中，例如，具有复杂功能的其他组件可以在测试中用假实现替换。
- en: Before ending this section, I want to talk about *code coverage*. In theory,
    all units should have corresponding test suites and each test suite should contain
    all test cases that go through all possible branches of code. As we said, this
    is in theory, but in practice you usually have test units only for a percentage
    of units. Often, you don't have test cases that cover all possible branches of
    code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，我想谈谈 *代码覆盖率*。在理论上，所有单位都应该有相应的测试套件，并且每个测试套件都应该包含通过所有可能代码分支的所有测试用例。正如我们所说的，这是在理论上，但在实践中，您通常只为一部分单位有测试单元。通常，您没有覆盖所有可能代码分支的测试用例。
- en: The proportion of units that have proper test cases is called code coverage
    or *test coverage*. The higher the proportion, the better placed you are for getting
    notified about unwanted modifications. These unwanted modifications are not usually
    introduced by bad developers. In fact, these breaking changes are usually introduced
    while someone is working on a piece of code for fixing a bug or implementing a
    new feature.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有适当测试用例的单位比例称为代码覆盖率或 *测试覆盖率*。比例越高，您就越有可能被通知关于不希望修改的情况。这些不希望修改通常不是由糟糕的开发者引入的。事实上，这些破坏性更改通常是在某人正在修复代码中的错误或实现新功能时引入的。
- en: Having covered test doubles, we talk about component testing in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了测试替身之后，我们将在下一节中讨论组件测试。
- en: Component testing
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试
- en: As we explained in the previous section, units can be defined as a single function,
    a group of functions, or a whole component. Therefore, component testing is a
    special type of unit testing. In this section, we want to define a hypothetical
    component as part of *example 22.1* and put the two functions found in the example
    into this component. Note that a component usually results in an executable or
    a library. We can suppose that our hypothetical component would result in a library
    that contains the two functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中解释的，单位可以被定义为单个函数、一组函数或整个组件。因此，组件测试是单元测试的一种特殊类型。在本节中，我们想要定义一个假设的组件作为
    *示例 22.1* 的一部分，并将示例中找到的两个函数放入该组件中。请注意，组件通常会产生一个可执行文件或库。我们可以假设我们的假设组件将产生一个包含两个函数的库。
- en: As we said before, we have to be able to test the functionality of a component.
    In this section, we still want to write test cases but the difference between
    the tests written in this section and the previous section is to do with the units
    that should be isolated. In the previous section, we had functions that should
    have been isolated, but in this section, we have a component, compromising of
    two functions working hand in hand, that needs to be isolated. So, the functions
    must be tested when they are working together.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，我们必须能够测试组件的功能。在本节中，我们仍然想要编写测试用例，但本节中编写的测试用例与上一节的不同之处在于应该隔离的单位。在上一节中，我们有应该隔离的函数，但在本节中，我们有一个由两个协同工作的函数组成的组件，需要隔离。因此，当它们一起工作时，必须对这些函数进行测试。
- en: 'Next, you can find the test cases we have written for the component defined
    as part of *example 22.1*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以找到我们为作为 *示例 22.1* 部分定义的组件编写的测试用例：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 22-9 [ExtremeC_examples_chapter22_1_component_tests.c]: Some component
    tests written for our hypothetical component as part of example 22.1'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 22-9 [ExtremeC_examples_chapter22_1_component_tests.c]: 为我们假设的组件作为示例 22.1
    的一部分编写的某些组件测试'
- en: As you see, we have written two test cases. Like we said before, in our hypothetical
    component, the functions `calc_factorial` and `next_even_number` must work together,
    and as you see, we have passed `next_even_number` as the feed to `calc_factorial`.
    The preceding test cases, and other similar test cases, should guarantee that
    the component is working properly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们已经编写了两个测试用例。正如我们之前所说的，在我们的假设组件中，函数 `calc_factorial` 和 `next_even_number`
    必须协同工作，如您所见，我们已经将 `next_even_number` 作为 `calc_factorial` 的输入。前面的测试用例和其他类似的测试用例应该保证组件正常工作。
- en: It requires a lot of effort to prepare a basis for writing test cases. Therefore,
    it is very common to use a testing library for this purpose. These libraries prepare
    the playground for the test cases; they initialize every test case, run the test
    case, and finally tear down the test case. In the upcoming section, we are going
    to talk about two of the testing libraries available for C.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 准备编写测试用例的基础需要付出很多努力。因此，使用测试库来完成此目的非常常见。这些库为测试用例准备舞台；它们初始化每个测试用例，运行测试用例，并最终拆除测试用例。在下一节中，我们将讨论C可用的一些测试库。
- en: Testing libraries for C
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C的测试库
- en: In this section, we are going to demonstrate two of the well-known libraries
    used to write tests for C programs. For unit testing in C, we use libraries that
    are written in C or C++. That's because we can integrate them easily and use the
    units directly from a C or C++ testing environment. In this section, our focus
    is on unit testing and component testing in C.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示两个用于为C程序编写测试的知名库。对于C的单元测试，我们使用用C或C++编写的库，因为我们可以轻松地将它们集成并直接从C或C++测试环境中使用单元。在本节中，我们的重点是C的单元测试和组件测试。
- en: For integration testing, we are free to choose other programming languages.
    Generally, the integration and system testing are much more complex, and we therefore
    need to use some testing automation frameworks in order to write tests easier
    and run them without too much hassle. Using a **domain-specific language** (**DSL**)
    is part of this automation, in order to write test scenarios more easily and make
    test execution much simpler. Many languages can be used for this purpose, but
    scripting languages like Unix shell, Python, JavaScript, and Ruby are among the
    most favorite ones. Some other programming languages like Java are also used heavily
    in test automation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集成测试，我们可以自由选择其他编程语言。通常，集成和系统测试要复杂得多，因此我们需要使用一些测试自动化框架来更容易地编写测试并轻松运行它们。使用**领域特定语言**（**DSL**）是这一自动化过程的一部分，以便更容易地编写测试场景并使测试执行更加简单。许多语言都可以用于此目的，但像Unix
    shell、Python、JavaScript和Ruby这样的脚本语言是最受欢迎的。一些其他编程语言，如Java，也在测试自动化中得到了广泛使用。
- en: 'The following is a list of some well-known unit testing frameworks which can
    be used to write unit tests for C programs. This list below can be found at the
    following link: http://check.sourceforge.net/doc/check_html/check_2.html#SEC3:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于为C程序编写单元测试的知名单元测试框架列表。以下列表可以在以下链接中找到：http://check.sourceforge.net/doc/check_html/check_2.html#SEC3：
- en: Check (from the author of the preceding link)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Check（来自前一个链接的作者）
- en: AceUnit
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AceUnit
- en: GNU Autounit
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Autounit
- en: cUnit
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cUnit
- en: CUnit
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUnit
- en: CppUnit
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CppUnit
- en: CuTest
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CuTest
- en: embUnit
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: embUnit
- en: MinUnit
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MinUnit
- en: Google Test
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Test
- en: CMocka
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMocka
- en: 'In the following sections, we will introduce two popular testing frameworks:
    *CMocka*, which is written in C, and *Google Test*, which is written in C++. We
    won''t explore all features of these frameworks, but this is just to give you
    an initial feeling about a unit testing framework. Further study is highly encouraged
    in this domain.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几节中，我们将介绍两个流行的测试框架：用C编写的*CMocka*和用C++编写的*Google Test*。我们不会探索这些框架的所有功能，但这是为了给你一个单元测试框架的初步感觉。在这个领域进一步学习是非常鼓励的。
- en: In the next section, we are going to write unit tests for *example 22.1* using
    CMocka.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用CMocka为*example 22.1*编写单元测试。
- en: CMocka
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMocka
- en: The first great thing about CMocka is that it is written purely in C, and it
    only depends on the C standard library – not on any other libraries. So, you can
    use a C compiler to compile the tests, and this gives you the confidence that
    the test environment is very close to the actual production environment. CMocka
    is available on many platforms like macOS, Linux, and even Microsoft Windows.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: CMocka的第一个优点是它完全用C编写，并且只依赖于C标准库——不依赖于任何其他库。因此，你可以使用C编译器编译测试，这让你有信心测试环境非常接近实际的生产环境。CMocka可在许多平台如macOS、Linux甚至Microsoft
    Windows上使用。
- en: CMocka is the *de facto* framework for unit testing in C. It supports *test
    fixtures*. Test fixtures may allow you to initialize and clear the testing environment
    before and after each test case. CMocka also supports *function mocking*, which
    is very useful when trying to mock any C function. As a reminder, a mock function
    can be configured to return a certain value when a certain input is provided.
    We will give an example of mocking the `rand` standard function used in *example
    22.2*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: CMocka 是 C 语言单元测试的**事实上的**框架。它支持**测试夹具**。测试夹具可能允许你在每个测试用例之前和之后初始化和清理测试环境。CMocka
    还支持**函数模拟**，这在尝试模拟任何 C 函数时非常有用。作为提醒，模拟函数可以被配置为在提供特定输入时返回特定值。我们将给出模拟 *example 22.2*
    中使用的 `rand` 标准函数的示例。
- en: 'The following code box contains the same test cases that we saw for *example
    22.1* but written in CMocka this time. We have put all test cases in just one
    file, which has its own `main` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含与 *example 22.1* 中看到的相同的测试用例，但这次是用 CMocka 编写的。我们将所有测试用例都放在了一个文件中，该文件有自己的
    `main` 函数：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 22-10 [ExtremeC_examples_chapter22_1_cmocka_tests.c]: CMocka test
    cases for example 22.1'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 22-10 [ExtremeC_examples_chapter22_1_cmocka_tests.c]：示例 22.1 的 CMocka 测试用例
- en: In CMocka, every test case should return `void` and receive a `void**` argument.
    The pointer argument will be used to receive a piece of information, called a
    `state`, which is specific to a test case. In the `main` function, we create a
    list of test cases, and then finally we call the `cmocka_run_group_tests` function
    to run all the unit tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMocka 中，每个测试用例都应该返回 `void` 并接收一个 `void**` 参数。指针参数将被用来接收一段信息，称为 `state`，它对于每个测试用例是特定的。在
    `main` 函数中，我们创建一个测试用例列表，然后最终调用 `cmocka_run_group_tests` 函数来运行所有单元测试。
- en: 'In addition to test case functions, you see two new functions: `setup` and
    `tear_down`. As we said before, these functions are called test fixtures. Test
    fixtures are called before and after every test case and their responsibility
    is to set up and tear down the test case. The fixture `setup` is called before
    every test case and the fixture `tear_down` is called after every test case. Note
    that the names are optional, and they could be named anything, but we use `setup`
    and `tear_down` for clarity.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试用例函数外，你还会看到两个新的函数：`setup` 和 `tear_down`。正如我们之前所说的，这些函数被称为测试夹具。测试夹具在每次测试用例之前和之后被调用，其责任是设置和清理测试用例。夹具
    `setup` 在每个测试用例之前被调用，而夹具 `tear_down` 在每个测试用例之后被调用。请注意，名称是可选的，它们可以命名为任何名称，但我们使用
    `setup` 和 `tear_down` 以便清晰。
- en: Another important difference between the test cases we wrote before and the
    test cases written using CMocka is the use of different assertion functions. This
    is one of the advantages of using a unit testing framework. There are a wide range
    of assertion functions as part of a testing library that can give you more information
    about their failure, rather than the standard `assert` function, which terminates
    the program immediately and without giving much information. As you can see, we
    have used `assert_int_equal` in the preceding code, which checks the equality
    of two integers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的测试用例和用 CMocka 编写的测试用例之间的重要区别在于使用了不同的断言函数。这是使用单元测试框架的优点之一。测试库中包含了一系列断言函数，可以提供更多关于它们失败的信息，而不是标准的
    `assert` 函数，后者会立即终止程序且不提供太多信息。正如你所看到的，我们已经在前面的代码中使用了 `assert_int_equal`，它检查两个整数的相等性。
- en: In order to compile the preceding program, you need to have CMocka installed
    first. On a Debian-based Linux system, it is enough to run `sudo apt-get install
    libcmocka-dev`, and on macOS systems, it is enough to install it by using the
    command `brew install cmocka`. There will be a lot of help available online that
    can help you get through the installation process.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译前面的程序，你首先需要安装 CMocka。在基于 Debian 的 Linux 系统上，只需运行 `sudo apt-get install libcmocka-dev`
    即可，而在 macOS 系统上，只需使用命令 `brew install cmocka` 进行安装。网上将会有很多帮助信息，可以帮助你完成安装过程。
- en: 'After having CMocka installed, you can use the following commands to build
    the preceding code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 CMocka 之后，你可以使用以下命令来构建前面的代码：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Shell Box 22-4: Building and running CMocka unit tests written for example
    22.1'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 22-4：构建和运行为示例 22.1 编写的 CMocka 单元测试
- en: 'As you can see, we had to use `-lcmocka` in order to link the preceding program
    with the installed CMocka library. The output shows the test case names and the
    number of passed tests. Next, we change one of the test cases to make it fail.
    We just modify the first assertion in the `next_even_number__even_numbers_should_be_returned`
    test case:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们必须使用 `-lcmocka` 来将前面的程序与已安装的 CMocka 库链接。输出显示了测试用例名称和通过测试的数量。接下来，我们更改一个测试用例使其失败。我们只是修改了
    `next_even_number__even_numbers_should_be_returned` 测试用例中的第一个断言：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code Box 22-11: Changing one of the CMocka test cases in example 22.1'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 22-11: 修改示例 22.1 中的一个 CMocka 测试用例'
- en: 'Now, build the tests and run them again:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建测试并再次运行它们：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Shell Box 22-5: Building and running CMocka unit tests after modifying one
    of them'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 22-5：修改其中一个测试用例后构建和运行 CMocka 单元测试
- en: In the preceding output, you see that one of the test cases has been failed
    and the reason is shown as an error in the middle of the logs. It shows an integer
    equality assertion failure. As we have explained before, using `assert_int_equal`
    instead of using an ordinary `assert` call allows CMocka to print a helpful message
    in the execution log instead of just terminating the program.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，您可以看到有一个测试用例失败了，原因在日志中间显示为一个错误。它显示了一个整数相等断言失败。正如我们之前解释的，使用 `assert_int_equal`
    而不是使用普通的 `assert` 调用允许 CMocka 在执行日志中打印出有用的消息，而不是仅仅终止程序。
- en: Our next example is about using CMocka's function mocking feature. CMocka allows
    you to mock a function and this way, you can instrument the function to return
    a specific result when a certain input is provided.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的示例是关于使用 CMocka 的函数模拟功能。CMocka 允许您模拟一个函数，这样，您可以在提供特定输入时使函数返回特定的结果。
- en: 'In the next example, *example 22.2*, we want to demonstrate how to use the
    mocking feature. In this example, the standard function `rand` is used to generate
    random numbers. There is also a function, named `random_boolean`, that returns
    a Boolean based on the oddity of the number returned from the `rand` function.
    Before showing CMocka''s mocking feature, we want to show how to create a stub
    for the `rand` function. You see that this example is different from *example
    22.1*. Next, you can see the declaration of the `random_boolean` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例，即 *示例 22.2* 中，我们想展示如何使用模拟功能。在这个示例中，标准函数 `rand` 用于生成随机数。还有一个名为 `random_boolean`
    的函数，它根据 `rand` 函数返回的数字的奇偶性返回一个布尔值。在展示 CMocka 的模拟功能之前，我们想展示如何为 `rand` 函数创建存根。您可以看到这个示例与
    *示例 22.1* 不同。接下来，您可以看到 `random_boolean` 函数的声明：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Code Box 22-12 [ExtremeC_examples_chapter22_2.h]: The header file of example
    22.2'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 22-12 [ExtremeC_examples_chapter22_2.h]: 示例 22.2 的头文件'
- en: 'And the following code box contains the definition:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含定义：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Code Box 22-13 [ExtremeC_examples_chapter22_2.c]: The definition of the random_boolean
    function in example 22.2'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 22-13 [ExtremeC_examples_chapter22_2.c]: 示例 22.2 中 random_boolean 函数的定义'
- en: First of all, we cannot let `random_boolean` use the actual `rand` definition
    in the tests because, as its name implies, it generates random numbers and we
    cannot have a random element in our tests. Tests are about checking expectations
    and the expectations, and the provided inputs, must be predictable. More than
    that, the definition of the `rand` function is part of the C standard library,
    for instance *glibc* in Linux, and using a stub function for it won't be easy
    like what we did in *example 22.1*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不能让 `random_boolean` 在测试中使用实际的 `rand` 定义，因为，正如其名称所暗示的，它生成随机数，我们测试中不能有随机元素。测试是关于检查预期的，而预期和提供的输入必须是可预测的。更重要的是，`rand`
    函数的定义是 C 标准库的一部分，例如 Linux 中的 *glibc*，使用存根函数对它进行操作不会像我们在 *示例 22.1* 中做的那样简单。
- en: In the previous example, we could send a function pointer to the stub definition
    very easily. But in this example, we are using the `rand` function directly. We
    cannot change the definition of `random_boolean`, and we have to come up with
    another trick to use the stub function for `rand`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们可以非常容易地将函数指针发送到存根定义。但在这个示例中，我们直接使用 `rand` 函数。我们不能更改 `random_boolean`
    的定义，我们必须想出另一个技巧来使用存根函数 `rand`。
- en: In order to use a different definition for the `rand` function, one of the easiest
    ways in C is to play with *symbols* in the final object file. In the *symbol table*
    of the resulting object file, there is an entry for `rand` which refers to its
    actual definition in the C standard library. If we change this entry to refer
    to a different definition of the `rand` function in our testing binaries, we can
    easily substitute the definition of `rand` with our stub one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `rand` 函数的不同定义，在 C 中最简单的方法是玩弄最终目标文件的 *symbols*。在结果目标文件的 *symbol table*
    中，有一个指向 `rand` 的条目，它引用了其在 C 标准库中的实际定义。如果我们更改此条目以引用测试二进制文件中 `rand` 函数的不同定义，我们就可以轻松地用我们的存根定义替换
    `rand` 的定义。
- en: 'In the following code box, you can see how we have defined the stub function
    and the tests together. This would be very similar to what we did for *example
    22.1*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码框中，您可以看到我们如何定义存根函数和测试。这会非常类似于我们在 *example 22.1* 中所做的那样：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Code Box 22-14 [ExtremeC_examples_chapter22_2_cmocka_tests_with_stub.c]: Writing
    CMocka test cases using a stub function'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 22-14 [ExtremeC_examples_chapter22_2_cmocka_tests_with_stub.c]：使用存根函数编写
    CMocka 测试用例
- en: 'As you can see, the preceding code is mostly following the same pattern that
    we saw as part of the CMocka tests written for *example 22.1* in *Code Box 22-10*.
    Let''s build the preceding file and run the tests. What we expect is to have all
    tests failed because, no matter how you define the stub function, the `random_boolean`
    is picking the `rand` from the C standard library:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的代码主要遵循我们在 *Code Box 22-10* 中的 *example 22.1* 编写的 CMocka 测试中看到的相同模式。让我们构建前面的文件并运行测试。我们期望所有测试都失败，因为无论您如何定义存根函数，`random_boolean`
    都会从 C 标准库中选取 `rand`：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Shell Box 22-6: Building and running CMocka unit tests for example 22.2'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 22-6：构建和运行示例 22.2 的 CMocka 单元测试
- en: 'Now it''s time do the trick and change the definition behind the `rand` symbol
    defined as part of the `ex22_2_cmocka_tests_with_stub.out` executable file. Note
    that the following commands are only applicable to Linux systems. We do it as
    follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候施展技巧，更改 `rand` 符号背后的定义，该定义作为 `ex22_2_cmocka_tests_with_stub.out` 可执行文件的一部分。请注意，以下命令仅适用于
    Linux 系统。我们这样做：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Shell Box 22-7: Building and running CMocka unit tests for example 22.2 after
    wrapping the rand symbol'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 22-7：在包装 rand 符号后构建和运行示例 22.2 的 CMocka 单元测试
- en: As you see in the output, the standard `rand` function is not being called anymore
    and instead, the stub function returns what we have told it to return. The main
    trick that makes the function `__wrap_rand` be called instead of standard `rand`
    function lies in using the option `-Wl`,`--wrap=rand` in the `gcc` link command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中看到的，标准的 `rand` 函数不再被调用，取而代之的是存根函数返回我们告诉它返回的内容。使函数 `__wrap_rand` 被调用而不是标准
    `rand` 函数的技巧主要在于在 `gcc` 链接命令中使用选项 `-Wl`,`--wrap=rand`。
- en: Note that this option is only available for the `ld` program in Linux and you
    have to use other tricks like *inter-positioning* to call a different function
    in macOS or other systems using a linker other than the GNU linker.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此选项仅适用于 Linux 中的 `ld` 程序，您必须使用其他技巧，如 *inter-positioning*，在 macOS 或使用非 GNU
    链接器的其他系统中调用不同的函数。
- en: The option `--wrap=rand` tells the linker to update the entry for the symbol
    `rand` in the final executable's symbol table, which is going to refer to the
    definition of the `__wrap_rand` function. Note that this is not a custom name
    and you have to name the stub function like that. The function `__wrap_rand` is
    said to be a *wrapper function*. After updating the symbol table, any call to
    the `rand` function results in calling the `__wrap_func` function. This can be
    verified by looking at the symbol table of the final test binary.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 `--wrap=rand` 告诉链接器更新最终可执行文件符号表中 `rand` 符号的条目，这将引用 `__wrap_rand` 函数的定义。请注意，这不是一个自定义名称，您必须将存根函数命名为这样。函数
    `__wrap_rand` 被称为 *wrapper function*。更新符号表后，对 `rand` 函数的任何调用都会导致调用 `__wrap_func`
    函数。这可以通过查看最终测试二进制的符号表来验证。
- en: Apart from updating the `rand` symbol in the symbol table, the linker also creates
    another entry. The new entry has the symbol `__real_rand`, which refers to the
    actual definition of the standard `rand` function. Therefore, if we needed to
    run the standard `rand`, we still can use the function name `__real_rand`. This
    is a great usage of the symbol table and the symbols in it, in order to call a
    wrapper function, despite the fact that some people don't like it and they prefer
    to preload a shared object that wraps the actual `rand` function. Whichever method
    you use, you need to finally redirect the calls to the `rand` symbol to another
    stub function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在符号表中更新 `rand` 符号外，链接器还创建另一个条目。新条目具有符号 `__real_rand`，它指向标准 `rand` 函数的实际定义。因此，如果我们需要运行标准的
    `rand`，我们仍然可以使用函数名 `__real_rand`。这是符号表及其符号的出色用法，以便调用包装函数，尽管有些人不喜欢这样做，他们更喜欢预加载一个包装实际
    `rand` 函数的共享对象。无论你使用哪种方法，你最终都需要将调用重定向到 `rand` 符号的另一个存根函数。
- en: 'The preceding mechanism would be the basis to demonstrate how function mocking
    works in CMocka. Instead of having a global variable `next_random_num`, as seen
    in *Code Box 22-14*, we can use a mocked function to return the specified value.
    Next, you can see the same CMocka tests but using a mocked function to read the
    test inputs:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述机制将是演示 CMocka 中函数模拟如何工作的基础。与 *代码框 22-14* 中看到的全局变量 `next_random_num` 不同，我们可以使用一个模拟函数来返回指定的值。接下来，你可以看到相同的
    CMocka 测试，但使用模拟函数来读取测试输入：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Code Box 22-15 [ExtremeC_examples_chapter22_2_cmocka_tests_with_mock.c]: Writing
    CMocka test cases using a mock function'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 22-15 [ExtremeC_examples_chapter22_2_cmocka_tests_with_mock.c]：使用模拟函数编写
    CMocka 测试用例
- en: Now that we know how the wrapper function `__wrap_rand` is called, we can explain
    the mocking part. Mocking functionality is provided by the pair of functions `will_return`
    and `mock_type`. First, `will_return` should be called, which specifies the value
    that the mock function should return. Then, when the mock function, in this case
    `__wrap_rand`, is called, the function `mock_type` returns the specified value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了包装函数 `__wrap_rand` 的调用方式，我们可以解释模拟部分。模拟功能由 `will_return` 和 `mock_type`
    函数对提供。首先，应该调用 `will_return`，指定模拟函数应返回的值。然后，当模拟函数（在这种情况下为 `__wrap_rand`）被调用时，`mock_type`
    函数返回指定的值。
- en: As an example, we define `10` to be returned from `__wrap_rand` by using `will_return(__wrap_rand,
    10)`, and then the value `10` is returned when the function `mock_type` is called
    inside `__wrap_rand`. Note that every `will_return` must pair with a `mock_type`
    call; otherwise, the test fails. Therefore, if `__wrap_rand` is not called because
    of any reason, the test fails.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们通过使用 `will_return(__wrap_rand, 10)` 将 `__wrap_rand` 定义为返回 `10`，然后在 `__wrap_rand`
    内部调用 `mock_type` 函数时返回值 `10`。请注意，每个 `will_return` 都必须与一个 `mock_type` 调用配对；否则，测试将失败。因此，如果由于任何原因没有调用
    `__wrap_rand`，则测试将失败。
- en: As the last note in this section, the output of the preceding code would be
    the same as we saw in Shell Boxes *22-6* and *22-7*. In addition, the same commands,
    of course for the source file `ExtremeC_examples_chapter22_2_cmocka_tests_with_mock.c`,
    must be used to build the code and run the tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的最后一条注释，前面代码的输出将与我们在 Shell Boxes *22-6* 和 *22-7* 中看到的一样。此外，当然对于源文件 `ExtremeC_examples_chapter22_2_cmocka_tests_with_mock.c`，必须使用相同的命令来构建代码并运行测试。
- en: In this section, we showed how we can use the CMocka library to write test cases,
    perform assertions, and write mock functions. In the next section, we talk about
    Google Test, another testing framework that can be used to unit test C programs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何使用 CMocka 库编写测试用例、执行断言和编写模拟函数。在下一节中，我们将讨论 Google Test，这是另一个可以用于单元测试
    C 程序的测试框架。
- en: Google Test
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Test
- en: Google Test is a C++ testing framework that can be used for unit testing both
    C and C++ programs. Despite being developed in C++, it can be used for testing
    C code. Some consider this as a bad practice, because the test environment is
    not set up using the same compiler and linker that you are going to use for setting
    up the production environment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 是一个 C++ 测试框架，可用于单元测试 C 和 C++ 程序。尽管它是用 C++ 开发的，但它可以用于测试 C 代码。有些人认为这是一种不好的做法，因为测试环境不是使用你将用于设置生产环境的相同编译器和链接器来设置的。
- en: 'Before being able to use Google Test for writing test cases for *example 22.1*,
    we need to modify the header file in *example 22.1* a bit. The following is the
    new header file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够使用 Google Test 为 *示例 22.1* 编写测试用例之前，我们需要稍微修改 *示例 22.1* 中的头文件。以下是新头文件：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Code Box 22-16 [ExtremeC_examples_chapter22_1.h]: The modified header file
    as part of example 22.1'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'Code Box 22-16 [ExtremeC_examples_chapter22_1.h]: 作为示例22.1一部分修改的头文件'
- en: As you can see, we have put the declarations in the `extern C { ... }` block.
    We do that only if the macro `_cplusplus` is defined. The preceding change simply
    means that when the compiler is C++, we want to have the symbols *unmangled* in
    the resulting object files, otherwise we will get link errors when the linker
    tries to find definitions for *mangled symbols*. If you don't know about C++ *name
    mangling*, please refer to the last section in *Chapter 2*, *Compilation and Linking*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们将声明放在了`extern C { ... }`块中。我们只在定义了宏`_cplusplus`时这样做。前面的更改简单地说，就是当编译器是C++时，我们希望在生成的目标文件中拥有未混淆的符号，否则当链接器尝试查找*混淆符号*的定义时，我们将得到链接错误。如果你不了解C++的*名称混淆*，请参阅*第2章*的最后部分，*编译和链接*。
- en: 'Now, let''s continue and write the test cases using Google Test:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续使用Google Test编写测试用例：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code Box 22-17 [ExtremeC_examples_chapter22_1_gtests.cpp]: The test cases written
    using Google Test for example 22.1'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'Code Box 22-17 [ExtremeC_examples_chapter22_1_gtests.cpp]: 使用Google Test为示例22.1编写的测试用例'
- en: The test cases are defined using the `TEST(...)` macro. This is an example of
    how well macros can be used to form a DSL. There are also other macros like `TEST_F(...)`
    and `TEST_P(...)`, which are C++ specific. The first argument passed to the macro
    is the test's class name (Google Test is written for object-oriented C++), which
    can be thought of as the test suite that contains a number of test cases. The
    second argument is the name of the test case.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例使用`TEST(...)`宏定义。这是一个如何有效地使用宏来形成领域特定语言的例子。还有其他宏，如`TEST_F(...)`和`TEST_P(...)`,
    这些是C++特定的。传递给宏的第一个参数是测试类的名称（Google Test是为面向对象的C++编写的），可以将其视为包含多个测试用例的测试套件。第二个参数是测试用例的名称。
- en: Note the `ASSERT_EQ` macro, which is used to assert the equality of objects,
    not just integers. There are a great number of expectation checker macros in Google
    Test, which makes it a complete unit testing framework. The final part is the
    `main` function, which runs all the defined tests. Note that the above code should
    be compiled using a C++11-compliant compiler like `g++` and `clang++`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`ASSERT_EQ`宏，它用于断言对象的相等性，而不仅仅是整数。Google Test中有大量的期望检查宏，使其成为一个完整的单元测试框架。最后一部分是`main`函数，它运行所有定义的测试。请注意，上述代码应该使用符合C++11规范的编译器（如`g++`和`clang++`）进行编译。
- en: 'The following commands build the preceding code. Note using the `g++` compiler
    and the option `-std=c++11` which is passed to it. It indicates that C++11 should
    be used:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令构建前面的代码。注意使用`g++`编译器和传递给它的选项`-std=c++11`，这表示应使用C++11：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Shell Box 22-8: Building and running Google Test unit tests for example 22.1'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 22-8：构建和运行示例22.1的Google Test单元测试
- en: 'The above output shows a similar output to the CMocka output. It indicates
    that five test cases have been passed. Let''s change the same test case as we
    did for CMocka to break the test suite:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示与CMocka输出类似。它表明有五个测试用例已经通过。让我们改变与CMocka相同的测试用例来破坏测试套件：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Code Box 22-18: Changing one of the test cases written in Google Test'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 22-18：修改Google Test编写的测试用例之一
- en: 'Let''s build the tests again and run them:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次构建测试并运行它们：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Shell Box 22-9: Building and running Google Test unit tests for example 22.1
    after modifying one of the test cases'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 22-9：修改一个测试用例后构建和运行示例22.1的Google Test单元测试
- en: As you can see and exactly like CMocka, Google Test also prints out where the
    tests are broken and shows a helpful report. As a final note on Google Test, it
    supports test fixtures but not in the same way that CMocka supports. Test fixtures
    should be defined in a *test class*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，并且与CMocka完全一样，Google Test也会打印出测试失败的位置，并显示一个有用的报告。关于Google Test的最后一句话，它支持测试固定值，但不是像CMocka那样支持。测试固定值应该在*测试类*中定义。
- en: '**Note**:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: For having mock objects and the mocking functionality, the *Google Mock* (or
    *gmock*) library can be used, but we don't cover it in this book.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有模拟对象和模拟功能，可以使用*Google Mock*（或*gmock*）库，但我们在本书中不涉及它。
- en: In this section, we went through two of the most well-known unit testing libraries
    for C. In the next part of the chapter, we dive into the topic of debugging, which
    is of course a necessary skill for every programmer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了C语言中最著名的两个单元测试库。在章节的下一部分，我们将深入探讨调试这一主题，这对于每一位程序员来说当然是一项必要的技能。
- en: Debugging
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: There are situations in which one test or a group of tests fail. Also, there
    are times when you find a bug. In both of these situations, there is a bug, and
    you need to find the root cause and fix it. This involves many sessions of debugging
    and going through the source code to search for the cause of the bug and planning
    the required fixes. But what does it mean to *debug* a piece of software?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候一个测试或一组测试会失败。也有时候你会发现一个错误。在这两种情况下，都存在错误，你需要找到根本原因并修复它。这涉及到许多调试会话，通过查看源代码来寻找错误的原因并规划所需的修复。但“调试”一段软件究竟意味着什么呢？
- en: '**Note**:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'It is a popularly held belief that the term "debug" originates from the days
    when computers were so large that real bugs (such as moths) could get caught in
    the system''s machinery and lead to malfunctions. Therefore, some people, officially
    called *debuggers*, were sent into the hardware room to remove the bugs from the
    equipment. See this link for more information: https://en.wikipedia.org/wiki/Debugging.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍认为，“调试”这个术语起源于计算机如此庞大，以至于真正的虫子（如蛾子）可以卡在系统机械中并导致故障的时代。因此，一些人，官方称为*调试器*，被派到硬件室去从设备中移除虫子。更多信息请见此链接：https://en.wikipedia.org/wiki/Debugging。
- en: Debugging is an investigative task to find the root cause of an observed bug
    by looking inside and/or outside of a program. When running a program, you usually
    look at it as a black box. When something is wrong with the results or something
    interrupts the execution, however, you need to have a deeper look inside and see
    how the issue is produced. This means that you have to observe the program as
    a white box in which everything can be seen.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是一项调查任务，通过查看程序内部和/或外部来找到观察到的错误的根本原因。当运行程序时，你通常将其视为一个黑盒。然而，当结果出现问题时或执行被中断时，你需要更深入地查看并了解问题是如何产生的。这意味着你必须将程序视为一个白盒，其中一切都可以被看到。
- en: 'That''s basically why we can have two different builds for a program: *release*
    and *build*. In release builds, the focus is on the execution and the functionality,
    and the program is mostly seen as a black box, but in debug builds, we can trace
    all the events happening and see the inside of the program as a white box. Debug
    builds are generally useful for development and test environments, but release
    builds are targeted at deployment and production environments.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们可以为程序拥有两种不同构建的原因：*发布*和*构建*。在发布构建中，重点是执行和功能，程序主要被视为一个黑盒，但在调试构建中，我们可以跟踪所有发生的事件，并将程序视为一个白盒。调试构建通常用于开发和测试环境，而发布构建则针对部署和生产环境。
- en: In order to have a debug build, all of the products of a software project, or
    a limited set of them, need to contain *debugging* symbols, which enable a developer
    to track and see the *stack trace* and the execution flow of the program. Usually,
    a release product (executable or libraries) is not suitable for debugging purposes
    because it is not transparent enough to let an observer examine the internals
    of a program. In *Chapter 4*, *Process Memory Structure*, and *Chapter 5*, *Stack
    and Heap*, we discussed how we can build C sources for debugging purposes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有调试构建版本，软件项目的所有产品或其中的一部分需要包含*调试*符号，这些符号允许开发者跟踪和查看程序的*堆栈跟踪*和执行流程。通常，发布产品（可执行文件或库）不适合调试目的，因为它不够透明，无法让观察者检查程序的内部结构。在*第4章*，*进程内存结构*和*第5章*，*栈和堆*中，我们讨论了如何为调试目的构建C源代码。
- en: For debugging a program, we mainly use debuggers. Debuggers are standalone programs
    that attach to the target process in order to control or monitor it. While debuggers
    are our main tools for our investigation when working on an issue, other debugging
    tools can also be used to study the memory, concurrent execution flows, or the
    performance of a program. We will talk about these tools in the following sections.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试程序，我们主要使用调试器。调试器是独立程序，它们附着到目标进程上以控制或监视它。当我们在处理问题时，调试器是我们调查的主要工具，但其他调试工具也可以用来研究内存、并发执行流程或程序的性能。我们将在接下来的章节中讨论这些工具。
- en: A great portion of bugs are *reproducible*, but there are bugs that cannot be
    reproduced or observed in debugging sessions; this is mostly because of the *observer
    effect*. It says, when you want to look at the internals of a program, you alter
    the way it works, and it might prevent some bugs from happening. These sorts of
    issues are disastrous, and they are usually very hard to fix because you cannot
    use your debugging tools to investigate the root cause of the problem!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数错误都是*可复现的*，但也有一些错误无法复现或在调试会话中观察到；这主要是因为*观察者效应*。它说，当你想查看程序的内幕时，你会改变它的工作方式，这可能会阻止一些错误发生。这类问题非常严重，通常很难修复，因为你不能使用你的调试工具来调查问题的根本原因！
- en: Some threading bugs in high-performance environments can be categorized in this
    group.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在高性能环境中，一些线程错误可以归入这一类。
- en: In the following sections, we are going to talk about different categories of
    bugs. Then, we introduce the tools that we use in modern C/C++ development in
    order to investigate bugs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论不同类别的错误。然后，我们将介绍我们在现代C/C++开发中使用的工具，以调查错误。
- en: Bug categories
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误类别
- en: 'There can be thousands of bugs reported in a piece of software throughout the
    years that it is in use by a customer. But if you look at the types of these bugs,
    they are not many. Next, you can see a list of bug categories that we think are
    important and require special skills to deal with. For sure, this list is not
    complete and there can be other types of bugs that we are missing:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件被客户使用的过程中，可能会有成千上万的错误被报告。但如果你看看这些错误的类型，它们并不多。接下来，你可以看到我们认为重要且需要特殊技能来处理的一些错误类别列表。当然，这个列表并不完整，可能还有我们遗漏的其他类型的错误：
- en: '**Logical bugs**: In order to investigate these bugs, you need to know the
    code and the execution flow of the code. To see the actual execution flow of a program,
    a debugger should be attached to a running process. Only then, the execution flow
    can be *traced* and analyzed. *Execution logs* can also be used when debugging
    a program, especially when debugging symbols are not available in the final binaries
    or a debugger cannot be used to attach to an actual running instance of the program.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑错误**：为了调查这些错误，你需要了解代码和代码的执行流程。为了看到程序的实际执行流程，应该将调试器附加到正在运行的过程中。只有这样，才能*追踪*和分析执行流程。在调试程序时，*执行日志*也可以使用，尤其是在最终二进制文件中没有调试符号或调试器无法附加到程序的实际运行实例时。'
- en: '**Memory bugs**: These bugs are memory related. They occur usually because
    of dangling pointers, buffer overflows, double frees, and so on. These bugs should
    be investigated using a *memory profiler*, which acts as a debugging tool for
    observing and monitoring memory.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存错误**：这些错误与内存相关。它们通常是由于悬挂指针、缓冲区溢出、双重释放等原因引起的。这些错误应该使用*内存分析器*进行调查，它作为一种调试工具，用于观察和监控内存。'
- en: '**Concurrency bugs**: Multi-processing and multithreading programs have always
    been the birthplace of some of the hardest-to-solve bugs found in the software
    industry. You need special tools like *thread sanitizers* in order to detect particularly
    difficult issues such as race conditions and data races.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发错误**：多进程和多线程程序一直是软件行业中一些最难以解决的错误的发源地。你需要特殊的工具，如*线程检查器*，来检测诸如竞态条件和数据竞争等特别困难的问题。'
- en: '**Performance bugs**: New developments may result in *performance degradation*
    or performance bugs. These bugs should be investigated using further and more
    focused testing and even debugging. Execution logs, which contain annotated historical
    data for the previous executions, can be useful in order to find the exact change
    or changes that have initiated the degradation.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能错误**：新的发展可能会导致*性能下降*或性能错误。这些错误应该使用更深入和更专注的测试甚至调试来调查。包含先前执行的历史数据的*执行日志*在寻找导致下降的确切变化或变化时可能很有用。'
- en: In the following sections, we are going to talk about various tools introduced
    in the preceding list.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论前面列表中介绍的各种工具。
- en: Debuggers
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器
- en: 'We have talked about debuggers, especially `gdb`, in *Chapter 4*, *Process
    Memory Structure*, and we used it to see inside a process''s memory. In this section,
    we are going to give debuggers a second look and describe their role in daily
    software development. The following is a list of common features provided by most
    modern debuggers:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第4章*，*进程内存结构*中讨论了调试器，特别是`gdb`，我们用它来查看进程的内存。在本节中，我们将再次审视调试器，并描述它们在日常软件开发中的作用。以下是由大多数现代调试器提供的常见功能列表：
- en: A debugger is a program, and like all other programs, it runs as a process.
    The debugger process can attach to another process given the target process ID.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试器是一个程序，就像所有其他程序一样，它作为一个进程运行。调试器进程可以附加到另一个进程，前提是给出目标进程ID。
- en: A debugger can control the execution of the instructions in the target process
    after a successful attachment; therefore, the user is able to pause and continue
    the flow of the execution in the target process, using an interactive debugging
    session.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试器可以在成功附加到目标进程后控制目标进程中的指令执行；因此，用户可以使用交互式调试会话暂停并继续目标进程的执行流程。
- en: Debuggers can see inside the protected memory of a process. They can also modify
    the contents, therefore a developer can run the same group of instructions while
    the memory content is being changed deliberately.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试器可以查看进程的保护内存。它们还可以修改内容，因此开发者可以在故意更改内存内容的同时运行相同的指令组。
- en: Almost all of the known debuggers, if the debugging symbols are provided while
    compiling the sources to relocatable object files, can trace back the instructions
    to the source code. In other words, when you pause on an instruction, you can
    go to its corresponding line of code in the source file.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎所有已知的调试器，如果在编译源代码到可重定位目标文件时提供了调试符号，都可以追踪指令到源代码。换句话说，当你暂停在一条指令上时，你可以转到源文件中对应的代码行。
- en: If the debugging symbols are not provided in the target object file, the debugger
    can show the disassembly code of a target instruction, which can still be useful.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标对象文件中没有提供调试符号，调试器可以显示目标指令的汇编代码，这仍然可能是有用的。
- en: Some debuggers are language-specific, but most of them are not. **Java Virtual
    Machine** (**JVM**) languages such as Java, Scala, and Groovy have to use JVM
    debuggers in order to see and control the internals of a JVM instance.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些调试器是针对特定语言的，但大多数不是。**Java虚拟机**（**JVM**）语言，如Java、Scala和Groovy，必须使用JVM调试器才能查看和控制JVM实例的内部结构。
- en: Interpreted languages like Python have also their own debuggers, which can be
    used to pause and control a script. While the low-level debuggers like `gdb` are
    still usable for JVM or scripting languages, they try to debug the JVM or interpreter
    processes instead of the executing Java bytecode or Python script.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释型语言如Python也有它们自己的调试器，可以用来暂停和控制脚本。虽然像`gdb`这样的低级调试器仍然可用于JVM或脚本语言，但它们试图调试JVM或解释器进程，而不是执行Java字节码或Python脚本。
- en: 'A list of the debuggers can be found on Wikipedia as part of the following
    link: https://en.wikipedia.org/wiki/List_of_debuggers. From this list, the following
    debuggers are eye-catching:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下链接的维基百科上找到调试器的列表：https://en.wikipedia.org/wiki/List_of_debuggers。从这个列表中，以下调试器引人注目：
- en: '**Advanced Debugger** (**adb**): The default Unix debugger. It has different
    implementations based on the actual Unix implementation. It has been the default
    debugger on Solaris Unix.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高级调试器**（**adb**）：默认的Unix调试器。它根据实际的Unix实现有不同的实现。它一直是Solaris Unix的默认调试器。'
- en: '**GNU Debugger** (**gdb**): The GNU version of the Unix debugger, which is
    the default debugger on many Unix-like operating systems including Linux.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GNU调试器**（**gdb**）：Unix调试器的GNU版本，它是许多类Unix操作系统的默认调试器，包括Linux。'
- en: '**LLDB**: A debugger mainly designed for debugging object files produced by
    LLVM compilers.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**LLDB**：主要设计用于调试由LLVM编译器生成的目标文件的调试器。'
- en: '**Python Debugger**: Used in Python to debug Python script.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Python调试器**：用于Python调试Python脚本。'
- en: '**Java Platform Debugger Architecture** (**JPDA**): This one is not a debugger,
    but it is an API designed for debugging programs running inside a JVM instance.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Java平台调试架构**（**JPDA**）：这不是一个调试器，但它是一个为在JVM实例中运行的程序设计的API。'
- en: '**OllyDbg**: A debugger and disassembler used in Microsoft Windows for debugging
    GUI applications.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**OllyDbg**：用于Microsoft Windows调试GUI应用的调试器和反汇编器。'
- en: '**Microsoft Visual Studio Debugger**: The main debugger used by Microsoft Visual
    Studio.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Microsoft Visual Studio调试器**：Microsoft Visual Studio使用的调试器。'
- en: In addition to `gdb`, one can use `cgdb`. The `cgdb` program shows a terminal
    code editor next to the `gdb` interactive shell that allows you to move between
    the code lines easier.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`gdb`，还可以使用`cgdb`。`cgdb`程序在`gdb`交互式shell旁边显示一个终端代码编辑器，这使得你更容易在代码行之间移动。
- en: In this section, we discussed debuggers as the main tools for investigating
    an issue. In the next section, we will be talking about memory profilers, which
    are vital for investigating memory-related bugs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了调试器作为调查问题的主要工具。在下一节中，我们将讨论内存分析器，这对于调查内存相关错误至关重要。
- en: Memory checkers
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存检查器
- en: Sometimes when you encounter a memory-related bug or a crash, a debugger alone
    cannot help much. You need another tool that can detect the memory corruptions
    and invalid read or writes to the memory cells. The tool you need is a *memory
    checker* or a *memory profiler*. It could be part of a debugger, but it is usually
    provided as a separate program and the way it detects memory misbehaviors is different
    from a debugger.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候当你遇到与内存相关的错误或崩溃时，仅使用调试器并不能提供太多帮助。你需要另一个工具来检测内存损坏以及对内存单元的无效读写。你需要的是*内存检查器*或*内存分析器*。它可能是调试器的一部分，但通常作为一个独立的程序提供，并且它检测内存异常行为的方式与调试器不同。
- en: 'We usually can expect the following features from a memory checker:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以期待内存检查器具有以下功能：
- en: Reporting the total amount of allocated memory, freed memory, used static memory,
    Heap allocations, Stack allocations, and so on.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告分配的内存总量、释放的内存、使用的静态内存、堆分配、栈分配等。
- en: Memory-leak detection, which can be considered as the most important feature
    that a memory checker provides.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏检测，这可以被认为是内存检查器提供的最重要的功能。
- en: Detection of invalid memory read/write operations like out-of-bound access regarding
    buffers and arrays, writes to an already freed memory region, and so on.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测无效的内存读写操作，如缓冲区和数组越界访问、写入已释放的内存区域等。
- en: Detection of a *double free* issue. It happens when a program tries to free
    an already freed memory region.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测*双重释放*问题。当程序尝试释放已释放的内存区域时会发生这种情况。
- en: So far, we have seen memory checkers like *Memcheck* (one of the Valgrind's
    tools) in some of the chapters, particularly *Chapter 5*, *Stack and Heap*. We
    have also discussed the different types of memory checkers and memory profilers
    in chapter 5\. Here, we want to explain them again, and give more details about
    each of them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在一些章节中看到了内存检查器，如*Memcheck*（Valgrind的工具之一），尤其是在*第五章*，*栈和堆*。我们在第五章也讨论了不同类型的内存检查器和内存分析器。在这里，我们再次解释它们，并给出每个的更多细节。
- en: 'Memory checkers all do the same thing, but the underlying technique they use
    to monitor memory operations can be different. Therefore, we group them based
    on the technique they use:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 内存检查器都做同样的事情，但它们用于监控内存操作的技术可能不同。因此，我们根据它们使用的技术将它们分组：
- en: '**Compile-time overriding**: For using a memory checker employing this technique,
    you need to make some, usually slight, changes to your source code like including
    a header file from the memory checker library. Then, you need to compile your
    binaries again. Sometimes, it is necessary to link the binaries against the libraries
    provided by the memory checker. The advantage is that the performance drop of
    the executing binary is less than the other techniques, but the disadvantage is
    that you need to recompile your binaries. **LLVM AddressSanitizer** (**ASan**),
    Memwatch, Dmalloc, and Mtrace are memory profilers using this technique.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译时覆盖**：对于使用这种技术的内存检查器，你需要对你的源代码进行一些通常很小的修改，比如包含内存检查器库的头文件。然后，你需要重新编译你的二进制文件。有时，有必要将二进制文件链接到内存检查器提供的库。优点是执行二进制文件的性能下降小于其他技术，但缺点是需要重新编译你的二进制文件。**LLVM
    AddressSanitizer**（**ASan**）、Memwatch、Dmalloc和Mtrace都是使用这种技术的内存分析器。'
- en: '**Link-time overriding**: This group of memory checkers is like the previous
    group of memory checkers, but the difference is that you don''t need to change
    your source code. Instead, you only have to link the resulting binaries with the
    provided libraries from the memory checker and no change is made to the source
    code. The *heap checker* utility in *gperftools* can be used as a link-time memory
    checker.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链接时覆盖**：这个内存检查器组类似于之前的内存检查器组，但不同之处在于你不需要更改源代码。相反，你只需要将生成的二进制文件与内存检查器提供的库链接起来，而无需更改源代码。*gperftools*中的*heap
    checker*实用程序可以用作链接时内存检查器。'
- en: '**Runtime interception**: A memory checker using this technique sits between
    the program and the OS and tries to intercept and track all memory-related operations
    and report whenever a misbehavior or invalid access is seen. It also can give
    leak reports based on the total allocations and freed memory blocks. The main
    advantage of using this technique is that you don''t need to recompile or relink
    your program in order to use the memory checker. The big disadvantage is the significant
    overhead it introduces to the execution of the program. Also, the memory footprint
    would be much higher than when running the program without the memory checker.
    This is definitely not an ideal environment to debug high-performance and embedded
    programs. The Memcheck tool in Valgrind can be used as a runtime interceptor memory
    checker. These memory profilers should be used with a debug build of the code
    base.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行时拦截**：使用这种技术的内存检查器位于程序和操作系统之间，试图拦截和跟踪所有与内存相关的操作，并在发现任何不当行为或无效访问时报告。它还可以根据总分配和释放的内存块生成泄漏报告。使用这种技术的最大优点是您无需重新编译或重新链接程序即可使用内存检查器。其重大缺点是它给程序执行引入了显著的开销。此外，内存占用会比在没有内存检查器运行程序时高得多。这绝对不是调试高性能和嵌入式程序的理想环境。Valgrind中的Memcheck工具可以用作运行时拦截内存检查器。这些内存分析器应该与代码库的调试构建一起使用。'
- en: '**Preloading libraries**: Some memory checkers use *inter-positioning* in order
    to wrap standard memory functions. Therefore, by preloading the memory checker''s
    shared libraries using the `LD_PRELOAD` environment variable, the program can
    use the wrapper functions and the memory checker can intercept the calls to underlying
    standard memory functions. The *heap checker* utility in *gperftools* can be used
    like this.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预加载库**：一些内存检查器使用*插入位置*来包装标准内存函数。因此，通过使用`LD_PRELOAD`环境变量预加载内存检查器的共享库，程序可以使用包装函数，内存检查器可以拦截对底层标准内存函数的调用。*堆检查器*实用程序在*gperftools*中可以这样使用。'
- en: Usually, it is not enough to use a specific tool for all memory issues because
    each of them has its own advantages and disadvantages, which make that tool specific
    to a certain context.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，仅使用特定工具来解决所有内存问题是不够的，因为每个工具都有其自身的优缺点，这使得该工具特定于某个特定环境。
- en: In this section, we went through the available memory profilers and categorized
    them based on the technique they use to record memory allocations and deallocations.
    In the next section, we are going to talk about thread sanitizers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了可用的内存分析器，并根据它们记录内存分配和释放的技术进行了分类。在下一节中，我们将讨论线程清理器。
- en: Thread debuggers
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程调试器
- en: '*Thread sanitizers* or *thread debuggers* are programs that are used to debug
    multithreading programs to find concurrency-related issues while the program is
    running. Some of the issues they can find are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程清理器*或*线程调试器*是用于在程序运行时调试多线程程序以查找并发相关问题的程序。它们可以找到的一些问题如下：'
- en: Data races, and the exact places in different threads where the read/write operations
    have caused the data race
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据竞争，以及在不同线程中读写操作导致数据竞争的确切位置
- en: Misusing the threading API, especially POSIX threading API in POSIX-compliant
    systems
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误使用线程API，尤其是在POSIX兼容系统中的POSIX线程API
- en: Possible deadlocks
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的死锁
- en: Lock ordering issues
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定顺序问题
- en: Both thread debuggers and memory checkers can detect issues as *false positives*.
    In other words, they may find and report some issues but after being investigated,
    it becomes clear that they are not issues. This really depends on the technique
    these libraries use for tracking the events, and making a final decision about
    that event.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 线程调试器和内存检查器都可能检测到假阳性问题。换句话说，它们可能会找到并报告一些问题，但在调查后，它们变得明显不是问题。这实际上取决于这些库用于跟踪事件的技巧以及对该事件的最终决定。
- en: 'In the following list, you can find a number of well-known available thread
    debuggers:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，您可以找到许多知名的可用线程调试器：
- en: '**Helgrind** (**from Valgrind**): It is another tool inside Valgrind mainly
    used for thread debugging. DRD is also another thread debugger as part of the
    Valgri[nd toolkit. The list of features and differenc](http://valgrind.org/docs/manual/hg-manual.html)es
    ca[n be seen in these links: http://valgrind.org/d](http://valgrind.org/docs/manual/drd-manual.html)ocs/manual/hg-manual.html
    and http://valgrind.org/docs/manual/drd-manual.html. Like all other tools from
    Valgrind, using Helgrind doesn''t need you to modify your source. For running
    Helgrind, you need to run the command `valgrind --tool=helgrind [path-to-executable]`.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helgrind**（**来自 Valgrind**）：它是 Valgrind 内的另一个工具，主要用于线程调试。DRD 也是 Valgrind
    工具包的一部分，另一个线程调试器。功能和差异的列表可以在以下链接中查看：http://valgrind.org/docs/manual/hg-manual.html
    和 http://valgrind.org/docs/manual/drd-manual.html。像 Valgrind 的所有其他工具一样，使用 Helgrind
    不需要您修改源代码。要运行 Helgrind，您需要运行命令 `valgrind --tool=helgrind [path-to-executable]`。'
- en: '**Intel Inspector**: This successor to *Intel Thread Checker* performs an analysis
    of threading errors and memory issues. Therefore, it is a thread debugger as well
    as a memory checker. It is not free like Valgrind, and proper licenses must be
    purchased in order to use the tool.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Intel Inspector**：这是 *Intel Thread Checker* 的继任者，它执行线程错误和内存问题的分析。因此，它既是线程调试器也是内存检查器。与
    Valgrind 不同，它不是免费的，使用此工具需要购买适当的许可证。'
- en: '**LLVM ThreadSanitizer** (**TSan**): This is part of the LLVM toolkit, and
    it comes with LLVM AddressSanitizer, described in the previous section. Some slight
    compile-time modifications are needed in order to use the debugger and the code
    base should be recompiled.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LLVM ThreadSanitizer**（**TSan**）：这是 LLVM 工具包的一部分，并附带 LLVM AddressSanitizer，这在前面章节中已描述。为了使用调试器和重新编译代码库，需要进行一些轻微的编译时修改。'
- en: In this section, we discussed thread debuggers and we introduced some of the
    available thread debuggers in order to debug threading issues. In the next section,
    we provide the programs and toolkits that are used to tune the performance of
    a program.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了线程调试器，并介绍了一些可用的线程调试器，以便调试线程问题。在下一节中，我们将提供用于调整程序性能的程序和工具包。
- en: Performance profilers
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析器
- en: Sometimes the results of a group of non-functional tests indicate a degradation
    in performance. There are specialized tools for investigating the cause of the
    degradation. In this section, we are going to have a quick look at the tools which
    can be used to analyze performance and find performance bottlenecks.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一组非功能性测试的结果表明性能有所下降。有一些专门的工具用于调查性能下降的原因。在本节中，我们将快速查看可用于分析性能和找到性能瓶颈的工具。
- en: 'These performance debuggers usually offer a subset of the following features:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些性能调试器通常提供以下功能的子集：
- en: Gather statistics about every single function call
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集每个单独函数调用的统计数据
- en: Provide a *function call graph* used to trace function calls
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个用于跟踪函数调用的 *函数调用图*
- en: Gather memory-related statistics for each function call
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集每个函数调用的内存相关统计数据
- en: Gather lock contention statistics
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集锁竞争统计数据
- en: Gather memory allocation/deallocation statistics
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集内存分配/释放统计数据
- en: Cache analysis, giving cache usage statistics and showing parts of the code
    that are not cache-friendly
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存分析，提供缓存使用统计数据，并显示不友好的代码部分
- en: Gather statistics about threading and synchronization events
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集关于线程和同步事件的统计数据
- en: 'The following is a list of the most well-known programs and toolkits that can
    be used for performance profiling:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用于性能分析的最知名程序和工具包列表：
- en: '**Google Performance Tools** (**gperftools**): This is actually a performant
    `malloc` implementation, but as it says on its home page, it provides some performance
    analytics tools like *heap checker*, which was introduced in the previous sections
    as a memory profiler. It should be linked with the final binary in order to be
    usable.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google 性能工具**（**gperftools**）：这实际上是一个高性能的 `malloc` 实现，但正如其主页上所述，它提供了一些性能分析工具，如
    *heap checker*，这在前面章节中作为内存分析器被介绍。为了使用它，需要将其链接到最终二进制文件。'
- en: '**Callgrind** (**as part of Valgrind**): Mainly gathers statistics about the
    function calls and the caller/callee relationship between two functions. There
    is no need to change the source code or link the final binaries and it can be
    used on the fly, with a debug build, of course.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Callgrind**（**作为 Valgrind 的一部分**）：主要收集关于函数调用以及两个函数之间调用者/被调用者关系的统计数据。无需更改源代码或链接最终二进制文件，它可以在运行时使用，当然，前提是使用调试构建。'
- en: '**Intel VTune**: This is a performance profiling suite from Intel that is a complete
    set of all the features given in the preceding list. Proper licenses must be purchased
    in order to use it.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Intel VTune**：这是一个来自Intel的性能分析套件，包含了前面列表中提到的所有功能。为了使用它，必须购买适当的许可证。'
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter was about unit testing and debugging C programs. As a summary,
    in this chapter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于单元测试和调试C程序。作为总结，在本章中：
- en: We talked about testing, and why it is important to us as software engineers
    and development teams.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了测试，以及为什么它对我们作为软件工程师和开发团队来说很重要。
- en: We also discussed the different levels of testing like unit testing, integration
    testing, and system testing.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还讨论了不同级别的测试，如单元测试、集成测试和系统测试。
- en: Functional and non-functional testing were also covered.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性和非功能性测试也被涵盖。
- en: Regression testing was explained.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试被解释了。
- en: CMocka and Google Test, as two well-known testing libraries for C, were explored
    and some examples were given.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMocka和Google Test，作为两个著名的C语言测试库，被探索，并给出了一些示例。
- en: We talked about debugging and various types of bugs.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了调试以及各种类型的错误。
- en: We discussed debuggers, memory profilers, thread debuggers, and performance
    debuggers which can help us to have a more successful investigation while working
    on a bug.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了调试器、内存分析器、线程调试器和性能调试器，这些可以帮助我们在处理错误时进行更成功的调查。
- en: The next chapter is about the *build systems* available for C projects. We will
    discuss what a build system is and what features it can bring in, which will eventually
    help us to automate the process of building a huge C project.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍适用于C项目的*构建系统*。我们将讨论构建系统是什么以及它能够带来哪些功能，这最终将帮助我们自动化构建大型C项目的流程。
