- en: Reactive GUI Programming Using Qt/C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt/C++进行响应式GUI编程
- en: The Qt (pronounced *cute*) ecosystem is a comprehensive C++ based framework
    for writing cross-platform and multiplatform GUI applications. If you write your
    programs using the portable core of the library, you can leverage the *Write Once
    and Compile Everywhere* paradigm supported by the framework. In some cases, people
    use the platform-specific features, such as support for the ActiveX programming
    model for writing Windows-based applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Qt（发音为可爱）生态系统是一个全面的基于C++的框架，用于编写跨平台和多平台GUI应用程序。如果您使用库的可移植核心编写程序，可以利用该框架支持的“一次编写，到处编译”范式。在某些情况下，人们使用特定于平台的功能，例如支持ActiveX编程模型以编写基于Windows的应用程序。
- en: We come across situations where Qt is preferred over MFC for writing applications
    in Windows. A plausible reason for this could be ease of programming, as Qt uses
    a very tiny subset of C++ language features for its library. The original goal
    of the framework was, of course, cross-platform development. Qt's single source
    portability across platforms, feature richness, availability of source code, and
    well-updated documentation, make it a very programmer-friendly framework. This
    has helped it thrive for more than two decades, ever since its first release,
    in 1995.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了一些情况，Qt在Windows上编写应用程序时优于MFC。这可能是因为编程简单，因为Qt仅使用C++语言特性的一个非常小的子集来构建其库。该框架的最初目标当然是跨平台开发。Qt在各个平台上的单一源可移植性、功能丰富性、源代码的可用性以及完善的文档使其成为一个非常友好的框架。这些特点使其在1995年首次发布以来，已经繁荣了二十多年。
- en: Qt provides a complete interface environment, with support for developing multiplatform
    GUI applications, Webkit APIs, media streamers, filesystem browsers, OpenGL APIs,
    and so on. Covering the full features of this wonderful library would take a book
    of its own. The purpose of this chapter is to introduce how to write reactive
    GUI applications, by leveraging Qt and the RxCpp library. We have already covered
    the core of the Reactive programming model in Chapter 7, *Introduction to Data
    Flow Computation and the RxCpp Library*, and Chapter 8, *RxCpp – the Key Elements*.
    Now, it is time to put what we learned in the previous chapters into practice!
    The Qt framework itself has a robust event processing system, and one needs to
    learn these library features before he or she can incorporate RxCpp constructs
    into the mix.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一个完整的接口环境，支持开发多平台GUI应用程序、Webkit API、媒体流、文件系统浏览器、OpenGL API等。涵盖这个精彩库的全部功能需要一本专门的书。本章的目的是介绍如何通过利用Qt和RxCpp库来编写响应式GUI应用程序。我们已经在第7章“数据流计算和RxCpp库介绍”和第8章“RxCpp
    - 关键元素”中介绍了响应式编程模型的核心。现在是时候将我们在前几章中学到的知识付诸实践了！Qt框架本身具有强大的事件处理系统，人们需要学习这些库特性，然后才能将RxCpp构造整合到其中。
- en: 'In this chapter, we will explore:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨：
- en: A quick introduction to Qt GUI programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt GUI编程的快速介绍
- en: Hello World – Qt program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hello World - Qt程序
- en: The Qt event model, with signals/slots/MOC – an example
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt事件模型，使用信号/槽/MOC - 一个例子
- en: Integrating the RxCpp library with the Qt event model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将RxCpp库与Qt事件模型集成
- en: Creating Custom Operators in Rxcpp
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rxcpp中创建自定义操作符
- en: A quick introduction to Qt GUI programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt GUI编程的快速介绍
- en: Qt is a cross-platform application development framework for writing software
    that can run on numerous platforms as a native application without changing much
    code, with native platform capabilities and speed. Aside from GUI applications,
    we can also write console or command-line applications using the framework—but
    the primary use cases are graphical user interfaces.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个跨平台应用程序开发框架，用于编写可以在多个平台上作为本机应用程序运行的软件，而无需更改太多代码，具有本机平台功能和速度。除了GUI应用程序，我们还可以使用该框架编写控制台或命令行应用程序，但主要用例是图形用户界面。
- en: Although applications using Qt are usually written in C++,  QML bindings to
    other languages also exist. Qt simplifies many aspects of C++ development, using
    comprehensive and powerful APIs and tools. Qt supports many compiler toolchains,
    such as the GCC C++ compiler and the Visual C++ compiler. Qt also provides Qt
    Quick (which includes QML, a declarative scripting language based on ECMAScript)
    to write logic. This helps with rapid application development for mobile platforms,
    although the logic can be written using native code for the best possible performance.
    The ECMAScript/C++ combination provides the best of declarative development and
    native code speed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用Qt编写的应用程序通常是用C++编写的，但也存在QML绑定到其他语言的情况。Qt简化了C++开发的许多方面，使用了全面而强大的API和工具。Qt支持许多编译器工具链，如GCC
    C++编译器和Visual C++编译器。Qt还提供了Qt Quick（包括QML，一种基于ECMAScript的声明性脚本语言）来编写逻辑。这有助于快速开发移动平台应用程序，尽管逻辑可以使用本机代码编写以获得最佳性能。ECMAScript/C++组合提供了声明式开发和本机代码速度的最佳结合。
- en: Qt is currently being developed and maintained by The Qt Company, and the framework
    is available with open source and proprietary licenses. When first launched, Qt
    used its own paint engine and controls by emulating the look and feel of a different
    platform (thanks to the custom paint engine, one can create a Windows look and
    feel under GNU Linux). This helped developers easily port across platforms, because
    of the minimal target platform dependency. As the emulation was imperfect, Qt
    started to use native-style APIs for the platforms, with its own native widget
    set. This resolved the issue with emulation of Qt's own paint engine, but at the
    cost of no more uniform look and feel across the platforms. The Qt library has
    an excellent binding with the Python programming language, christened as PyQt.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Qt目前由The Qt Company开发和维护，并且该框架可用于开源和专有许可证。刚开始时，Qt使用自己的绘图引擎和控件来模拟不同平台的外观和感觉（由于自定义绘图引擎，可以在GNU
    Linux下创建Windows的外观和感觉）。这有助于开发人员轻松地跨平台移植，因为目标平台依赖性很小。由于模拟不完美，Qt开始使用平台的本机样式API，以及自己的本机小部件集。这解决了Qt自己的绘图引擎模拟的问题，但代价是在各个平台上不再具有统一的外观和感觉。Qt库与Python编程语言有很好的绑定，被称为PyQt。
- en: There are some essential things a programmer must understand before he/she leverages
    the library. In the following sections, we will quickly cover aspects of the Qt
    object model, signals and slots, the event system, and the meta-object system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序员利用库之前，有一些基本的东西程序员必须了解。在接下来的几节中，我们将快速介绍Qt对象模型、信号和槽、事件系统和元对象系统的方面。
- en: Qt object model
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt对象模型
- en: In a GUI framework, both run-time efficiency and high-level flexibility are
    key factors. The standard C++ object model provides very efficient run-time support,
    but its static nature is inflexible in certain problematic domains. The Qt framework
    combines the speed of C++ with the flexibility of the Qt object model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI框架中，运行时效率和高级灵活性是关键因素。标准C++对象模型提供了非常高效的运行时支持，但其静态性在某些问题领域是不灵活的。Qt框架将C++的速度与Qt对象模型的灵活性结合起来。
- en: 'The Qt object model supports the following features:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Qt对象模型支持以下功能：
- en: '**Signals and slots**, for seamless object communication'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号和槽**，用于无缝对象通信'
- en: Queryable and designable **object properties**
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可查询和可设计的**对象属性**
- en: Powerful events and event filters
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的事件和事件过滤器
- en: Powerful internally driven timers, enabling smooth, non-blocking work in many
    of the tasks in an event-driven GUI
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的内部驱动定时器，实现在事件驱动的GUI中许多任务的平滑、非阻塞工作
- en: '**Internationalization** with contextual string translation'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**国际化**与上下文字符串翻译'
- en: Guarded pointers (**QPointers**) that are automatically set to 0 when the referenced
    object is destroyed
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的指针（**QPointers**），当引用的对象被销毁时自动设置为0
- en: A **dynamic cast** working across library boundaries
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨库边界工作的**动态转换**
- en: Many of these features are implemented as standard C++ classes, based on inheritance
    from `QObject`. Others, like signals and slots and the object properties system,
    require the meta-object system provided by Qt's own **Meta-object compiler** (**MOC**).
    The meta-object system is an extension of the C++ language, to make it better
    suited for GUI programming. The MOC acts as an pre-compiler, which generates code
    based on the hints embedded in the source, and removes those hints for an ANSI
    C++ compiler to perform its normal compilation tasks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其中许多功能是作为标准C++类实现的，基于从`QObject`继承。其他功能，如信号和槽以及对象属性系统，需要Qt自己的**元对象编译器**（**MOC**）提供的元对象系统。元对象系统是C++语言的扩展，使其更适合GUI编程。MOC充当预编译器，根据源代码中嵌入的提示生成代码，并删除这些提示，以便ANSI
    C++编译器执行其正常的编译任务。
- en: 'Let us look at some classes in the Qt object model:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Qt对象模型中的一些类：
- en: '| **Class Name** | **Description** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **类名** | **描述** |'
- en: '| `QObject` | The base class of all Qt objects ([http://doc.qt.io/archives/qt-4.8/qobject.html](http://doc.qt.io/archives/qt-4.8/qobject.html))
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `QObject` | 所有Qt对象的基类（[http://doc.qt.io/archives/qt-4.8/qobject.html](http://doc.qt.io/archives/qt-4.8/qobject.html)）|'
- en: '| `QPointer` | The template class that provides guarded pointers to `QObject` ([http://doc.qt.io/archives/qt-4.8/qpointer.html](http://doc.qt.io/archives/qt-4.8/qpointer.html))
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `QPointer` | 为`QObject`提供受保护指针的模板类（[http://doc.qt.io/archives/qt-4.8/qpointer.html](http://doc.qt.io/archives/qt-4.8/qpointer.html)）|'
- en: '| `QSignalMapper` | Bundles signals from identifiable senders ([http://doc.qt.io/archives/qt-4.8/qsignalmapper.html](http://doc.qt.io/archives/qt-4.8/qsignalmapper.html))
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `QSignalMapper` | 将可识别发送者的信号捆绑在一起（[http://doc.qt.io/archives/qt-4.8/qsignalmapper.html](http://doc.qt.io/archives/qt-4.8/qsignalmapper.html)）|'
- en: '| `QVariant` | Acts like a union for the most common Qt data types ([http://doc.qt.io/archives/qt-4.8/qvariant.html](http://doc.qt.io/archives/qt-4.8/qvariant.html))
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `QVariant` | 作为最常见的Qt数据类型的联合体（[http://doc.qt.io/archives/qt-4.8/qvariant.html](http://doc.qt.io/archives/qt-4.8/qvariant.html)）|'
- en: '| `QMetaClassInfo` | Additional information about a class ([http://doc.qt.io/archives/qt-4.8/qmetaclassinfo.html](http://doc.qt.io/archives/qt-4.8/qmetaclassinfo.html))
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `QMetaClassInfo` | 类的附加信息（[http://doc.qt.io/archives/qt-4.8/qmetaclassinfo.html](http://doc.qt.io/archives/qt-4.8/qmetaclassinfo.html)）|'
- en: '| `QMetaEnum` | Metadata about an enumerator ([http://doc.qt.io/archives/qt-4.8/qmetaenum.html](http://doc.qt.io/archives/qt-4.8/qmetaenum.html))
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `QMetaEnum` | 枚举类型的元数据（[http://doc.qt.io/archives/qt-4.8/qmetaenum.html](http://doc.qt.io/archives/qt-4.8/qmetaenum.html)）|'
- en: '| `QMetaMethod` | Metadata about a member function ([http://doc.qt.io/archives/qt-4.8/qmetamethod.html](http://doc.qt.io/archives/qt-4.8/qmetamethod.html))
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `QMetaMethod` | 成员函数的元数据（[http://doc.qt.io/archives/qt-4.8/qmetamethod.html](http://doc.qt.io/archives/qt-4.8/qmetamethod.html)）|'
- en: '| `QMetaObject` | Contains meta-information about Qt objects ([http://doc.qt.io/archives/qt-4.8/qmetaobject.html](http://doc.qt.io/archives/qt-4.8/qmetaobject.html))
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '`QMetaObject` | 包含有关Qt对象的元信息（[http://doc.qt.io/archives/qt-4.8/qmetaobject.html](http://doc.qt.io/archives/qt-4.8/qmetaobject.html)）|'
- en: '| `QMetaProperty` | Metadata about a property ([http://doc.qt.io/archives/qt-4.8/qmetaproperty.html](http://doc.qt.io/archives/qt-4.8/qmetaproperty.html))
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `QMetaProperty` | 关于属性的元数据（[http://doc.qt.io/archives/qt-4.8/qmetaproperty.html](http://doc.qt.io/archives/qt-4.8/qmetaproperty.html)）
    |'
- en: '| `QMetaType` | Manages named types in the meta-object system ([http://doc.qt.io/archives/qt-4.8/qmetatype.html](http://doc.qt.io/archives/qt-4.8/qmetatype.html))
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `QMetaType` | 管理元对象系统中的命名类型（[http://doc.qt.io/archives/qt-4.8/qmetatype.html](http://doc.qt.io/archives/qt-4.8/qmetatype.html)）
    |'
- en: '| `QObjectCleanupHandler` | Watches the lifetimes of multiple `QObject` ([http://doc.qt.io/archives/qt-4.8/qobjectcleanuphandler.html](http://doc.qt.io/archives/qt-4.8/qobjectcleanuphandler.html))
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `QObjectCleanupHandler` | 监视多个`QObject`的生命周期（[http://doc.qt.io/archives/qt-4.8/qobjectcleanuphandler.html](http://doc.qt.io/archives/qt-4.8/qobjectcleanuphandler.html)）
    |'
- en: Qt objects are generally treated as identities, not values. Identities are cloned,
    not copied or assigned; cloning an identity is a more complex operation than copying
    or assigning a value. Therefore, `QObject` and all subclasses of `QObject` (direct
    or indirect) have their copy constructors and assignment operators disabled.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Qt对象通常被视为标识，而不是值。标识被克隆，而不是复制或分配；克隆标识是比复制或分配值更复杂的操作。因此，`QObject`和所有`QObject`的子类（直接或间接）都禁用了它们的复制构造函数和赋值运算符。
- en: Signals and slots
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽
- en: Signals and slots are mechanisms used in Qt to achieve communication between
    objects. The signals and slots mechanism is a central feature of Qt, as a GUI
    framework. Widgets get notified about changes in other widgets in Qt through this
    mechanism. In general, objects of any kind communicate with one another using
    this mechanism. For example, when a user clicks on a close button, we probably
    want the window's `close()` function to be called.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽是Qt中用于实现对象间通信的机制。信号和槽机制是Qt的一个核心特性，作为GUI框架。在Qt中，小部件通过这种机制得知其他小部件的变化。一般来说，任何类型的对象都使用这种机制相互通信。例如，当用户点击关闭按钮时，我们可能希望调用窗口的`close()`函数。
- en: Signals and slots are alternatives to the callback technique in C/C++. A signal
    gets emitted when a particular event occurs. All of the widgets in the Qt framework
    have predefined signals, but we can always subclass a widget to add our own signals
    to it. A slot is a function that gets called in response to a signal. Similar
    to predefined signals, the Qt widgets have many predefined slots, but we can add
    custom slots to handle the signals that we are interested in.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽是C/C++中回调技术的替代品。当特定事件发生时，会发出信号。Qt框架中的所有小部件都有预定义的信号，但我们总是可以对小部件进行子类化，以添加我们自己的信号。槽是响应信号调用的函数。与预定义信号类似，Qt小部件有许多预定义的槽，但我们可以添加自定义槽来处理我们感兴趣的信号。
- en: 'The following diagram from Qt''s official documentation ([http://doc.qt.io/archives/qt-4.8/signalsandslots.html](http://doc.qt.io/archives/qt-4.8/signalsandslots.html)),
    demonstrates how inter-object communication happens through signals and slots:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Qt官方文档（[http://doc.qt.io/archives/qt-4.8/signalsandslots.html](http://doc.qt.io/archives/qt-4.8/signalsandslots.html)）的以下图表演示了通过信号和槽进行对象间通信的过程：
- en: '![](img/08250b9c-326e-4c29-905e-2296d3d94f91.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08250b9c-326e-4c29-905e-2296d3d94f91.jpg)'
- en: Signals and slots are loosely coupled communication mechanisms; the class that
    emits a signal doesn't care about the slot which receives the signal. Signals
    are a perfect example of fire and forget systems. The signals and slots system
    ensures that if a signal is connected to a slot, the slot will be called with
    the signal's parameters at the right time. Both signals and slots can take any
    number of arguments of any type, and they are completely type safe. The signatures
    of both signals and receiving slots must match; hence, the compilers can help
    us to detect type mismatches, as a bonus.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽是松散耦合的通信机制；发出信号的类不关心接收信号的槽。信号是忘记即发的完美例子。信号和槽系统确保如果信号连接到槽，槽将在适当的时间以信号的参数被调用。信号和槽都可以接受任意数量和任意类型的参数，并且它们是完全类型安全的。因此，信号和接收槽的签名必须匹配；因此，编译器可以帮助我们检测类型不匹配，作为一个奖励。
- en: All objects inherited from `QObject`, or any of its subclasses (such as `QWidget`),
    can contain signals and slots. Signals are emitted by an object when it changes
    its state, which may be interesting to other objects. The object doesn't know
    (or care) if there are any objects at the receiving end. A signal can be connected
    to as many slots as needed. Similarly, we can connect as many signals as we want
    to a single slot. It is even possible to connect a signal to another signal; thus,
    signal chaining is possible.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从`QObject`或其任何子类（如`QWidget`）继承的对象都可以包含信号和槽。当对象改变其状态时，会发出信号，这可能对其他对象很有趣。对象不知道（或不关心）接收端是否有任何对象。一个信号可以连接到尽可能多的槽。同样，我们可以将尽可能多的信号连接到单个槽。甚至可以将一个信号连接到另一个信号；因此，信号链是可能的。
- en: Hence, together, signals and systems make an extremely flexible and pluggable
    component programming mechanism.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，信号和系统一起构成了一个非常灵活和可插拔的组件编程机制。
- en: Event system
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件系统
- en: In Qt, events represent things that have happened within an application or a
    user activity that the application needs to know about. In Qt, events are the
    objects derived from an abstract `QEvent` class. Events can be received and handled
    by any instance of a `QObject` subclass, but they are especially relevant to widgets.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，事件代表应用程序中发生的事情或应用程序需要知道的用户活动。在Qt中，事件是从抽象的`QEvent`类派生的对象。任何`QObject`子类的实例都可以接收和处理事件，但它们对小部件特别相关。
- en: Whenever an event occurs, an appropriate `QEvent` subclass instance gets constructed
    and gives its possession to a particular instance of `QObject` (or any relevant
    subclass) by calling its `event()` function. This function does not handle the
    event itself; based on the type of event delivered, it calls an event handler
    for that specific type of event and sends a response based on whether the event
    was accepted or ignored.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每当事件发生时，适当的`QEvent`子类实例被构造，并通过调用其`event()`函数将其所有权交给特定的`QObject`实例（或任何相关的子类）。这个函数本身不处理事件；根据传递的事件类型，它调用特定类型事件的事件处理程序，并根据事件是否被接受或被忽略发送响应。
- en: Some events, such as `QCloseEvent` and `QMoveEvent`, come from the application
    itself; some, such as `QMouseEvent` and `QKeyEvent`, come from the window system;
    and some, such as `QTimerEvent`, come from other sources. Most events have specific
    subclasses derived from `QEvent`, and sometimes event-specific functions to meet
    the specific behavior of the extended events. To exemplify, the `QMouseEvent`
    class adds `x()` and `y()` functions to enable widgets to discover the positions
    of the mouse cursor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件，比如`QCloseEvent`和`QMoveEvent`，来自应用程序本身；一些，比如`QMouseEvent`和`QKeyEvent`，来自窗口系统；还有一些，比如`QTimerEvent`，来自其他来源。大多数事件都有从`QEvent`派生的特定子类，并且有时还有特定于事件的函数来满足扩展事件的特定行为。举例来说，`QMouseEvent`类添加了`x()`和`y()`函数，以便小部件发现鼠标光标的位置。
- en: Every event has a type associated with it, defined under `QEvent::Type`, and
    this is a convenient source of run-time type information that is used to quickly
    identify what subclass the event has been constructed from.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都有与之关联的类型，在`QEvent::Type`下定义，这是一种方便的运行时类型信息的来源，用于快速识别事件从哪个子类构造而来。
- en: Event handlers
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理程序
- en: Generally, events are rendered by calling associated virtual functions. The
    virtual function is responsible for responding as intended. If custom virtual
    function implementations do not perform all that is necessary, we may need to
    call the base class's implementations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过调用相关的虚函数来渲染事件。虚函数负责按预期响应。如果自定义虚函数实现不执行所有必要的操作，我们可能需要调用基类的实现。
- en: 'For example, the following example handles the left mouse button clicks on
    a custom label widget, while passing all other button clicks to the base `QLabel`
    class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下示例处理自定义标签小部件上的鼠标左键单击，同时将所有其他按钮单击传递给基类`QLabel`类：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we want to replace base class functionality, we must implement everything
    in the virtual function override. If the requirement is to simply extend base
    class functionality, we can implement what we want, and call the base class function
    for any other case that we don't want to handle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要替换基类功能，我们必须在虚函数覆盖中实现所有内容。如果要求只是简单地扩展基类功能，我们可以实现我们想要的内容，并调用基类函数处理我们不想处理的其他情况。
- en: Sending events
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送事件
- en: Many applications that are using the Qt framework want to send their own events,
    just like the framework-provided events. Suitable custom events can be constructed
    by using event objects and sending them with `QCoreApplication::sendEvent()` and
    `QCoreApplication::postEvent()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 许多使用Qt框架的应用程序希望发送自己的事件，就像框架提供的事件一样。可以通过使用事件对象构造适当的自定义事件，并使用`QCoreApplication::sendEvent()`和`QCoreApplication::postEvent()`发送它们。
- en: '`sendEvent()` is synchronous in execution; therefore, it processes the event
    immediately. For many event classes, there is a function called `isAccepted()`,
    which tells us whether the event was accepted or rejected by the last handler
    that was called.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendEvent()`是同步执行的；因此，它会立即处理事件。对于许多事件类，有一个名为`isAccepted()`的函数，告诉我们上一个被调用的处理程序是否接受或拒绝了事件。'
- en: '`postEvent()` is asynchronous in execution; hence, it posts the event in a
    queue for later dispatch. The next time Qt''s main event loop runs, it dispatches
    all posted events, with some optimization. For example, if there are several resize
    events, they are compressed into one, as a union of all resize events, which avoids
    flickering in the user interface.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`postEvent()`是异步执行的；因此，它将事件发布到队列中以供以后调度。下次Qt的主事件循环运行时，它会调度所有发布的事件，进行一些优化。例如，如果有多个调整大小事件，它们会被压缩成一个，作为所有调整大小事件的并集，从而避免用户界面的闪烁。'
- en: Meta-object system
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元对象系统
- en: The Qt meta-object system realizes the signals and slots mechanism for inter-object
    communication, the dynamic property system, and run-time type information.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Qt元对象系统实现了信号和槽机制用于对象间通信，动态属性系统和运行时类型信息。
- en: 'The Qt meta-object system is based on three key aspects:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Qt元对象系统基于三个关键方面：
- en: '`QObject` class: The base class that provides the advantages of the meta-object
    system to Qt objects'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QObject`类：为Qt对象提供元对象系统的优势的基类'
- en: '`Q_OBJECT` macro: The macro to provide in the private section of the class
    declarations, used to enable meta-object features, such as dynamic properties,
    signals, and slots'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q_OBJECT`宏：在类声明的私有部分提供的宏，用于启用元对象特性，如动态属性、信号和槽'
- en: 'The MOC: It supplies each `QObject` subclass with the necessary code to implement
    meta-object features'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MOC：为每个`QObject`子类提供实现元对象特性所需的代码
- en: The MOC executes before the actual compilation of a Qt source file. When the
    MOC finds class declarations that contain the `Q_OBJECT` macro, it produces another
    C++ source file, with meta-object code, for each of those classes. This generated
    source file is either included in the class's source file using `#include` or,
    more usually, compiled and linked with the class's implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: MOC在Qt源文件的实际编译之前执行。当MOC发现包含`Q_OBJECT`宏的类声明时，它会为这些类中的每一个生成另一个带有元对象代码的C++源文件。生成的源文件要么通过`#include`包含在类的源文件中，要么更常见的是与类的实现一起编译和链接。
- en: Hello World – Qt program
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World - Qt程序
- en: Now, let's get started with GUI application development using Qt/C++. Before
    getting into the following sections, download Qt SDK and Qt Creator from Qt's
    official site ([https://www.qt.io/download](https://www.qt.io/download)). The
    codes that we are going to discuss in this chapter are entirely LGPL compatible
    and will be hand-coded by writing pure C++ code. The Qt framework is designed
    to be pleasant and intuitive so that you can handcode an entire application without
    using the Qt Creator IDE.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用Qt/C++进行GUI应用程序开发。在进入下面的章节之前，从Qt的官方网站([https://www.qt.io/download](https://www.qt.io/download))下载Qt
    SDK和Qt Creator。我们将在本章讨论的代码完全符合LGPL，并且将通过编写纯C++代码手工编码。Qt框架旨在使编码愉快和直观，以便您可以手工编写整个应用程序，而不使用Qt
    Creator IDE。
- en: Qt Creator is a cross-platform C++, JavaScript, and QML integrated development
    environment, a part of the SDK for the Qt GUI application development framework.
    It includes a visual debugger and an integrated GUI layout and forms designer.
    The editor's features include syntax highlighting and autocompletion. Qt Creator
    uses the C++ compiler from the GNU Compiler Collection on Linux and FreeBSD. On
    Windows, it can use MinGW or MSVC, with the default install, and can also use
    Microsoft Console Debugger, when compiled from source code. Clang is also supported. – *Wikipedia*
    ([https://en.wikipedia.org/wiki/Qt_Creator](https://en.wikipedia.org/wiki/Qt_Creator))
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator是一个跨平台的C++、JavaScript和QML集成开发环境，是Qt GUI应用程序开发框架的一部分。它包括一个可视化调试器和集成的GUI布局和表单设计器。编辑器的功能包括语法高亮和自动补全。Qt
    Creator在Linux和FreeBSD上使用GNU编译器集合的C++编译器。在Windows上，它可以使用MinGW或MSVC，默认安装时还可以使用Microsoft控制台调试器，当从源代码编译时。也支持Clang。-
    *维基百科* ([https://en.wikipedia.org/wiki/Qt_Creator](https://en.wikipedia.org/wiki/Qt_Creator))
- en: 'Let''s begin with a simple *Hello World* program, using a label widget. In
    this example, we will create and show a label widget, with the text `Hello World,
    QT!`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的*Hello World*程序开始，使用一个标签小部件。在这个例子中，我们将创建并显示一个带有文本`Hello World, QT!`的标签小部件：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, we have included two libraries: `<QApplication>` and `<QLabel>`.
    The `QApplication` object is defined in the `QApplication` library, which manages
    the resources in an application, and it is required to run any Qt GUI-based application.
    This object accepts the command-line arguments from the program, and, when `app.execute()`
    is called, the Qt event loop gets launched.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们包含了两个库：`<QApplication>`和`<QLabel>`。`QApplication`对象定义在`QApplication`库中，它管理应用程序中的资源，并且是运行任何Qt基于GUI的应用程序所必需的。这个对象接受程序的命令行参数，当调用`app.execute()`时，Qt事件循环就会启动。
- en: An **event loop** is a program structure that permits events to be prioritized,
    queued, and dispatched to objects. In an event-based application, certain functions
    are implemented as passive interfaces that get called in response to certain events.
    The event loop generally continues running until a terminating event occurs (the
    user clicks on the QUIT button, for example).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件循环**是一种程序结构，允许事件被优先级排序、排队和分派给对象。在基于事件的应用程序中，某些函数被实现为被动接口，以响应某些事件的调用。事件循环通常会持续运行，直到发生终止事件（例如用户点击退出按钮）。'
- en: '`QLabel` is the simplest widget among all Qt widgets, defined in `<QLabel>`.
    In this code, the label is instantiated with the text `Hello World, QT`. When
    `label.show()` gets called, a label with instantiated text will appear on the
    screen in its own window frame.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLabel`是所有Qt小部件中最简单的小部件，定义在`<QLabel>`中。在这段代码中，标签被实例化为文本`Hello World, QT`。当调用`label.show()`时，一个带有实例化文本的标签将出现在屏幕上，显示在自己的窗口框架中。'
- en: 'Now, to build and run the application, the first thing we need is a project
    file. To create a project file and compile the application, we need to follow
    these steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要构建和运行应用程序，我们需要的第一件事是一个项目文件。要创建一个项目文件并编译应用程序，我们需要按照以下步骤进行：
- en: Create a directory and save the source code in a CPP file, residing in this
    directory.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录，并将源代码保存在该目录中的CPP文件中。
- en: Open a shell and verify the version of `qmake` installed by using the `qmake
    -v`command. If `qmake` can't be found, the installation path needs to be added
    to the environment variable.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个shell，并使用`qmake -v`命令验证安装的`qmake`版本。如果找不到`qmake`，则需要将安装路径添加到环境变量中。
- en: Now, change the directory into the Qt file path in the shell, and execute the `qmake
    -project` command. This will create a project file for the application.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在shell中切换到Qt文件路径，并执行`qmake -project`命令。这将为应用程序创建一个项目文件。
- en: 'Open the project file and add the following line to the `.pro` file after `INCLUDEPATH`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目文件，并在`INCLUDEPATH`之后的`.pro`文件中添加以下行：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, run `qmake` without arguments to create the `make` file that contains
    the rules to build your application.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行`qmake`而不带参数，以创建包含构建应用程序规则的`make`文件。
- en: Run `make` (`nmake` or `gmake`, depending on the platform), which builds the
    application according to the rules specified in `Makefile`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make`（根据平台的不同可能是`nmake`或`gmake`），它将根据`Makefile`中指定的规则构建应用程序。
- en: If you run the application, a small window with a label saying Hello World,
    QT! will appear.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，一个带有标签的小窗口将出现，上面写着Hello World, QT!。
- en: The steps to building any Qt GUI applications are the same, except for the changes
    that may be required in project files. For all of the future examples that we
    will discuss in this chapter, *build and run* means to follow these steps.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 构建任何Qt GUI应用程序的步骤都是相同的，只是可能需要在项目文件中进行一些更改。对于我们将在本章讨论的所有未来示例，*构建和运行*意味着遵循这些步骤。
- en: 'Before we go on to the next example, let''s have some fun. Replace the `QLabel`
    instantiation with the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个示例之前，让我们玩一些。用以下代码替换`QLabel`的实例化：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, rebuild and run the application. As this code illustrates, it is easy to
    customize the Qt's user interface by using some simple HTML-style formatting.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新构建并运行应用程序。正如这段代码所说明的，通过使用一些简单的HTML样式格式化，定制Qt的用户界面是很容易的。
- en: In the next section, we will learn how to handle the Qt events and the use of
    signals and slots for object communication.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何处理Qt事件以及使用信号和槽来进行对象通信。
- en: Qt event model with signals/slots/MOC – an example
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt事件模型与信号/槽/MOC - 一个例子
- en: 'In this section, we will create an application to handle mouse events in `QLabel`.
    We will override the mouse events in a custom `QLabel` and handle them in the
    dialog where the custom label is placed. The approach to this application is as
    follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将创建一个应用程序来处理`QLabel`中的鼠标事件。我们将在自定义的`QLabel`中重写鼠标事件，并在放置自定义标签的对话框中处理它们。这个应用程序的方法如下：
- en: Create a custom `my_QLabel` class, inherited from the framework `QLabel` class,
    and override the mouse events, such as mouse-move, mouse-pressed, and mouse-leave.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义的`my_QLabel`类，继承自框架`QLabel`类，并重写鼠标事件，如鼠标移动、鼠标按下和鼠标离开。
- en: Define the signals that correspond to these events in `my_QLabel`, and emit
    them from the corresponding event handlers.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my_QLabel`中定义与这些事件对应的信号，并从相应的事件处理程序中发出它们。
- en: Create a dialog class inherited from the `QDialog` class, and handcode the positions
    and layouts of all of the widgets, including the custom widget created to handle
    mouse events.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从`QDialog`类继承的对话框类，并手动编写所有小部件的位置和布局，包括用于处理鼠标事件的自定义小部件。
- en: In the dialog class, define the slots to handle the emitted signals from the `my_QLabel`
    object, and display the appropriate results in the dialog.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框类中，定义槽来处理从`my_QLabel`对象发出的信号，并在对话框中显示适当的结果。
- en: Instantiate this dialog under the `QApplication` object, and execute.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QApplication`对象下实例化这个对话框，并执行。
- en: Create the project file to build a widget application and get it up and running.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目文件以构建小部件应用程序并使其运行起来。
- en: Creating a custom widget
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义小部件
- en: 'Let''s write the header file `my_qlabel.h` to declare the class `my_QLabel`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写头文件`my_qlabel.h`来声明类`my_QLabel`：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`QLabel` and `QMouseEvent` are defined under the included libraries, `<QLabel>`
    and `<QMouseEvent>`. The class is derived from `QLabel` to inherit its default
    behavior, and `QObject` is propertied to handle the signaling mechanism.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLabel`和`QMouseEvent`在包含的库`<QLabel>`和`<QMouseEvent>`中被定义。该类从`QLabel`派生，以继承其默认行为，并且`QObject`被赋予处理信号机制的属性。'
- en: In the private section of the header file, we have added a `Q_OBJECT` macro
    to notify the MOC that it must generate meta-object code for this class. The meta-object
    code is required for the signals and slots mechanism, the run-time type information,
    and the dynamic property system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件的私有部分，我们添加了一个`Q_OBJECT`宏，通知MOC它必须为这个类生成元对象代码。元对象代码是信号和槽机制、运行时类型信息和动态属性系统所必需的。
- en: In the class header, along with the constructor declaration, the mouse events
    such as mouse-move event, mouse-press event, and mouse-leave event are overridden.
    Also, the public integer variables hold the current *X* and *Y* coordinates of
    the mouse pointer. Finally, the signals emitted from each mouse event are declared
    under the signals section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在类头部，除了构造函数声明之外，还重写了鼠标事件，如鼠标移动事件、鼠标按下事件和鼠标离开事件。此外，公共整数变量保存了鼠标指针的当前*X*和*Y*坐标。最后，在信号部分声明了从每个鼠标事件发出的信号。
- en: 'Now, let''s define these items in a CPP file, `my_qlabel.cpp`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个CPP文件`my_qlabel.cpp`中定义这些项目：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the constructor, the parent is passed on to the `QLabel` base class to inherit
    the unhandled cases in the overridden class, and the coordinate variables are
    initialized to zero. In the `mouse-move` event handler, the member variables holding
    the mouse coordinates get updated, and a signal `Mouse_Position()` is emitted.
    The dialog using `my_QLabel` can connect this signal to the corresponding `mouse-move`
    slot in the parent dialog class and update the GUI:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，将父类传递给`QLabel`基类，以继承重写类中未处理的情况，并将坐标变量初始化为零。在`mouse-move`事件处理程序中，更新保存鼠标坐标的成员变量，并发出信号`Mouse_Position()`。使用`my_QLabel`的对话框可以将这个信号连接到父对话框类中相应的`mouse-move`槽，并更新GUI：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the `mouse-press` event handlers, the signal `Mouse_Pressed()` is emitted,
    and from the `mouse-leave` event, the `Mouse_Left()` signal is emitted. These
    signals get connected to corresponding slots in the parent widget (`Dialog` class)
    and update the GUI. Hence, we have written a custom label class to handle the
    mouse events.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从`mouse-press`事件处理程序中发出信号`Mouse_Pressed()`，从`mouse-leave`事件中发出`Mouse_Left()`信号。这些信号被连接到父窗口（`Dialog`类）中相应的槽，并更新GUI。因此，我们编写了一个自定义标签类来处理鼠标事件。
- en: Creating the application dialog
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序对话框
- en: 'As the label class has been implemented, we need to implement the dialog class
    to place all of the widgets and handle all of the signals emitted from the `my_QLabel`
    object. Let''s start with the `dialog.h` header file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标签类已经被实现，我们需要实现对话框类来放置所有的小部件，并处理从`my_QLabel`对象发出的所有信号。让我们从`dialog.h`头文件开始：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are creating a `Dialog` class inherited from `QDialog`, defined under
    the `<QDialog>` library. The classes `QLabel` and `my_QLabel` are forward declared
    in this class header, as the actual libraries will be included in the class definition
    file. As we already discussed, the `Q_OBJECT` macro must be included to generate
    meta-object code for enabling signals and slots mechanisms, the run-time type
    information, and the dynamic property system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个从`QDialog`继承的`Dialog`类，在`<QDialog>`库下定义。在这个类头文件中，`QLabel`和`my_QLabel`类被提前声明，因为实际的库将被包含在类定义文件中。正如我们已经讨论过的，必须包含`Q_OBJECT`宏来生成元对象代码，以启用信号和槽机制、运行时类型信息和动态属性系统。
- en: In addition to the constructor and destructor declarations, private slots are
    declared to connect to the signals emitted from the `my_QLabel` object. The slots
    are normal functions, and can be called normally; their only special feature is
    that signals can be connected to them. The `Mouse_CurrentPosition()` slot will
    be connected to the signal emitted from the `mouseMoveEvent()` of the `my_QLabel`
    object. Similarly, `Mouse_Pressed()` will be connected to `mousePressEvent()`,
    and `MouseLeft()` will be connected to the `leaveEvent()` of the `my_QLabel` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数和析构函数声明之外，还声明了私有槽，用于连接到`my_QLabel`对象发出的信号。这些槽是普通函数，可以正常调用；它们唯一的特殊功能是可以连接到信号。`Mouse_CurrentPosition()`槽将连接到`my_QLabel`对象的`mouseMoveEvent()`发出的信号。类似地，`Mouse_Pressed()`将连接到`mousePressEvent()`，`MouseLeft()`将连接到`my_QLabel`对象的`leaveEvent()`。
- en: Finally, the declaration of all widget pointers and one private function called `initializeWidgets()` is
    done to instantiate and lay out the widgets in the dialog.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，声明了所有部件指针和一个名为`initializeWidgets()`的私有函数，用于在对话框中实例化和布局部件。
- en: 'The implementation of the `Dialog` class belongs in `dialog.cpp`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dialog`类的实现属于`dialog.cpp`：'
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the constructor, the title of the application dialog is set to `My Mouse-Event
    Handling App`. Then, the `initializeWidgets()` function gets called—that function
    will be explained shortly. After creating and setting the layouts calling `initializeWidgets()`,
    the signals that emit from `my_QLabel` objects are connected to the corresponding
    slots declared in the `Dialog` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，应用程序对话框的标题设置为`My Mouse-Event Handling App`。然后调用`initializeWidgets()`函数—该函数将在稍后解释。在创建和设置布局后调用`initializeWidgets()`，从`my_QLabel`对象发出的信号将连接到`Dialog`类中声明的相应槽：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Mouse_CurrentPosition()` function is the slot to the signal emitted from
    the mouse-move event of the `my_QLabel` object. In this function, the label widget `label_Mouse_CurPos`
    gets updated with the current mouse coordinates, and `label_MouseEvents` updates
    its text to `Mouse Moving!`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mouse_CurrentPosition()`函数是与`my_QLabel`对象的鼠标移动事件发出的信号相连接的槽。在这个函数中，标签部件`label_Mouse_CurPos`会被当前鼠标坐标更新，而`label_MouseEvents`会将其文本更新为`Mouse
    Moving!`：'
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Mouse_Pressed()` function is the slot to the signal which has been emitted
    from the mouse-press event that gets called every time a user clicks inside of
    the mouse area (the `my_QLabel` object). The function updates the text in the `label_MouseEvents`
    label as `"Mouse Pressed!"`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mouse_Pressed()`函数是与鼠标按下事件发出的信号相连接的槽，每次用户在鼠标区域（`my_QLabel`对象）内单击时都会调用该函数。该函数会将`label_MouseEvents`标签中的文本更新为`"Mouse
    Pressed!"`：'
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, whenever the mouse leaves the mouse area, the mouse-leave event of
    the `my_QLabel` object emits a signal connected to the `Mouse_Left()` slot function.
    Then, it updates the text in the `label_MouseEvents` label to `"Mouse Left!"`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每当鼠标离开鼠标区域时，`my_QLabel`对象的鼠标离开事件会发出一个信号，连接到`Mouse_Left()`槽函数。然后，它会将`label_MouseEvents`标签中的文本更新为`"Mouse
    Left!"`。
- en: 'Use the `initializeWidgets()` function to instantiate and set the layouts in
    the dialog, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`initializeWidgets()`函数在对话框中实例化和设置布局，如下所示：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code, the `label_MouseArea` object is instantiated with the custom label
    class, `my_QLabel`*.* Then, the label properties are modified (such as the label
    text modified to `"Mouse Area"`), mouse tracking is enabled inside the `label_MouseArea`
    object, the alignment is set to center and the frame style is set to a thick line.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，使用自定义标签类`my_QLabel`实例化了`label_MouseArea`对象。然后修改了标签属性（例如将标签文本修改为`"Mouse
    Area"`），在`label_MouseArea`对象内启用了鼠标跟踪，将对齐设置为居中，并将框架样式设置为粗线。
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The label objects `label_Mouse_CurPos` and `label_MouseEvents` are updating
    its properties, such as text alignment and frame style, similar to the `label_MouseArea`
    object. But the text in `label_Mouse_CurPos` is initially set to `"X = 0, Y =
    0"`, and the `label_MouseEvents` label to `"Mouse current events!"`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`label_Mouse_CurPos`和`label_MouseEvents`标签对象正在更新其属性，例如文本对齐和框架样式，与`label_MouseArea`对象类似。但是，`label_Mouse_CurPos`中的文本最初设置为`"X
    = 0, Y = 0"`，而`label_MouseEvents`标签设置为`"Mouse current events!"`：'
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, a vertical box layout (`QVBoxLayout`) is created, and the `label_Mouse_CurPos`
    and `label_MouseEvents` label widgets are added to it. Also, a group box is created
    with the tag `Mouse Events`, and the layout of the group box is made into a vertical
    box layout, created with the widgets. At last, the positions and sizes of the
    mouse area label and the mouse events group box are set to predefined values.
    Hence, the widget creation and layout settings are done.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建了一个垂直框布局（`QVBoxLayout`），并将`label_Mouse_CurPos`和`label_MouseEvents`标签部件添加到其中。还创建了一个带有标签`Mouse
    Events`的分组框，并将分组框的布局设置为垂直框布局，用部件创建。最后，将鼠标区域标签和鼠标事件分组框的位置和大小设置为预定义值。因此，部件的创建和布局设置已完成。
- en: Executing the application
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行应用程序
- en: 'We can now write `main.cpp` to create the `Dialog` class and display it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写`main.cpp`来创建`Dialog`类并显示它：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This piece of code is exactly like the Hello World Qt application that we discussed.
    Instead of a `QLabel`, we are instantiating the `Dialog` class we created, resizing
    the dialog window frame to a predefined value by using the `resize()` function.
    Now, the application is ready to build and run. But, before building the application,
    let us handcode the project file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们讨论过的Hello World Qt应用程序完全相同。我们实例化了我们创建的`Dialog`类，将对话框窗口框架的大小调整为预定义值，然后应用程序准备构建和运行。但是，在构建应用程序之前，让我们手动编写项目文件：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, build the application and run it. A dialog box will pop up as follows
    (Windows platform):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建应用程序并运行。对话框将如下弹出（Windows平台）：
- en: '![](img/364c4bdf-cdad-490f-8f1f-5d5c30eee32b.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/364c4bdf-cdad-490f-8f1f-5d5c30eee32b.jpg)'
- en: As we hover the mouse pointer through the left side label (Mouse Area), the
    coordinates of the mouse will get updated in the first label on the right side,
    and the second label on the right side will display the text, Mouse Moving! Upon
    pressing any mouse button in the mouse area, the text in the second label will
    change to Mouse Pressed! When the mouse pointer leaves the mouse area, the text
    will be updated to Mouse Left!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将鼠标指针悬停在左侧标签（鼠标区域）上时，鼠标的坐标将在右侧的第一个标签中更新，右侧的第二个标签将显示文本“鼠标移动！”。在鼠标区域按下任意鼠标按钮时，第二个标签中的文本将更改为“鼠标按下！”当鼠标指针离开鼠标区域时，文本将更新为“鼠标离开！”
- en: In this section, we learned how to create a dialog window, widgets under a dialog,
    layouts in the widgets, and so on. We also learned how to enable customizing a
    widget (the label widget), and how to handle system events. We then learned about
    the creation and connection of objects using user-defined signals and slots. Finally,
    we used all of these widgets, including a custom widget, and created an application
    to handle Qt mouse events in a window.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了如何创建对话框窗口、对话框下的小部件、小部件中的布局等。我们还学习了如何启用自定义小部件（标签小部件），以及如何处理系统事件。然后，我们学习了使用用户定义的信号和槽创建和连接对象。最后，我们使用了所有这些小部件，包括自定义小部件，并创建了一个应用程序来处理窗口中的Qt鼠标事件。
- en: Now, let's implement a similar application to handle mouse events in a `QLabel`
    and display mouse coordinates in another label. Here, the event handling is performed
    by using event subscription and event filtering, with `RxCpp` observables and
    Qt event filters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个类似的应用程序来处理`QLabel`中的鼠标事件，并在另一个标签中显示鼠标坐标。在这里，事件处理是通过使用`RxCpp`可观察对象和Qt事件过滤器进行事件订阅和事件过滤的。
- en: Integrating the RxCpp library with the Qt event model
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将RxCpp库与Qt事件模型集成
- en: We already saw the Qt framework from a bird's eye view in the previous sections.
    We learned how to handle Qt events, especially mouse events and the signals/slots
    mechanism. We also learned about the `RxCpp` library and its programming model
    in the previous two chapters. In the process, we came across many significant
    reactive operators that matter while writing programs leveraging the reactive
    approach.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的部分中，我们已经从鸟瞰视角看到了Qt框架。我们学习了如何处理Qt事件，特别是鼠标事件和信号/槽机制。我们还在前两章中学习了`RxCpp`库及其编程模型。在这个过程中，我们遇到了许多重要的响应式操作符，这些操作符在编写利用响应式方法的程序时很重要。
- en: In this section, we are going to write an application to handle mouse events
    in a label widget, which is similar to the previous example. In this example,
    instead of handling mouse events to emit signals (like we did in the last example),
    we will be subscribing to Qt mouse events using the `RxCpp` subscriber and will
    filter different mouse events from the resultant mouse events Stream. The events
    (that are not filtered out) will be related to the subscribers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将编写一个应用程序来处理标签小部件中的鼠标事件，这与之前的示例类似。在这个例子中，我们不是像在上一个例子中那样处理鼠标事件来发出信号，而是使用`RxCpp`订阅者订阅Qt鼠标事件，并将不同的鼠标事件从结果鼠标事件流中过滤出来。事件（未被过滤掉的）将与订阅者相关联。
- en: Qt event filter – a reactive approach
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt事件过滤器-一种响应式方法
- en: 'As mentioned previously, the Qt framework has a robust event mechanism. We
    need to bridge between the Qt and RxCpp scheme of things. To get started with
    this application, we are going to write a header file, `rx_eventfilter.h`, wrapping
    the required RxCpp headers and the Qt event filter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Qt框架具有强大的事件机制。我们需要在Qt和RxCpp的事务之间建立桥梁。为了开始使用这个应用程序，我们将编写一个头文件`rx_eventfilter.h`，其中包含所需的RxCpp头文件和Qt事件过滤器。
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `<rxcpp/rx.hpp>` library is included to get the definitions for `RxxCppsubscriber`
    and `observable`, which we use in this class, and the `<QEvent>` library for `QEvent`
    definition. The entire header file is defined under the namespace `rxevt`. Now,
    the `EventEater` class is a Qt event filter class implanted to `filter-in` the
    only Qt events the member `eventType` is initialized with. To achieve that, the
    class has two member variables. The first one is `eventSubscriber`, which is an `rxcpp::subscriber`
    of the `QEvent` type, and the next one is `eventType`, to hold the `QEvent::Type`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`<rxcpp/rx.hpp>`库以获取`RxxCppsubscriber`和`observable`的定义，我们在这个类中使用这些定义，以及`<QEvent>`库以获取`QEvent`的定义。整个头文件都在`rxevt`命名空间下定义。现在，`EventEater`类是一个Qt事件过滤器类，用于`filter-in`只有成员`eventType`初始化的Qt事件。为了实现这一点，该类有两个成员变量。第一个是`eventSubscriber`，它是`QEvent`类型的`rxcpp::subscriber`，下一个是`eventType`，用于保存`QEvent::Type`。
- en: 'In the constructor, the parent `QObject` (the widget upon which events need
    to be filtered) is passed to the base class `QObject`. The member variables `eventType`
    and `eventSubscriber` get initialized with the `QEvent::Type` that needs to be
    filtered and the `rxcpp::subscriber` of the corresponding event type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，将父`QObject`（需要过滤事件的小部件）传递给基类`QObject`。成员变量`eventType`和`eventSubscriber`使用需要过滤的`QEvent::Type`和相应事件类型的`rxcpp::subscriber`进行初始化：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have overridden the `eventFilter()` function to call `on_next()` only if
    the event type is the same as the initialized type. The `EventEater` is an event
    filter object that receives all events that are sent to this object. The filter
    can either stop the event or forward it to this object. The `EventEater` object
    receives events via its `eventFilter()` function. The `eventFilter()` function
    ([http://doc.qt.io/qt-5/qobject.html#eventFilter](http://doc.qt.io/qt-5/qobject.html#eventFilter))
    must return true if the event should be filtered (in other words, stopped); otherwise,
    it must return `false`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了`eventFilter()`函数，只有在事件类型与初始化的类型相同时才调用`on_next()`。`EventEater`是一个事件过滤器对象，它接收发送到该对象的所有事件。过滤器可以停止事件，也可以将其转发到该对象。`EventEater`对象通过其`eventFilter()`函数接收事件。`eventFilter()`函数（[http://doc.qt.io/qt-5/qobject.html#eventFilter](http://doc.qt.io/qt-5/qobject.html#eventFilter)）必须在事件应该被过滤（换句话说，停止）时返回true；否则，必须返回`false`：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, let''s write a utility function under the same header file to create and
    return an `rxcpp::observable` from the event Stream using the `EventEater` object:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在同一个头文件下编写一个实用函数，使用`EventEater`对象从事件流创建并返回一个`rxcpp::observable`：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this function, we are returning the observable of `QEvent` from the stream
    of events that we will filter using the `EventEater` object. A `QObject` instance
    can be set to monitor the events of another `QObject` instance before the latter
    object even sees them. This a really powerful feature of Qt's event model. The
    call of the `installEventFilter()` function makes it possible, and the `EventEater`
    class has the conditions to perform filtering.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们从事件流中返回`QEvent`的observable，我们将使用`EventEater`对象进行过滤。在后者对象看到它们之前，可以设置`QObject`实例来监视另一个`QObject`实例的事件。这是Qt事件模型的一个非常强大的特性。`installEventFilter()`函数的调用使其成为可能，`EventEater`类具有执行过滤的条件。
- en: Creating the window – setting layouts and alignments
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建窗口-设置布局和对齐
- en: Now, let's write the application code to create the widget window, which contains
    two label widgets. One label will be used as the mouse area, similar to the previous
    example, and the latter will be used to display the filtered mouse event and the
    mouse coordinates.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写应用程序代码来创建包含两个标签小部件的窗口小部件。一个标签将用作鼠标区域，类似于上一个示例，另一个将用于显示过滤后的鼠标事件和鼠标坐标。
- en: 'Let''s look into the code in `main.cpp` as two sections. Initially, we will
    discuss the code to create and set the layout for the widgets:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`main.cpp`中的代码分为两个部分。首先，我们将讨论创建和设置小部件布局的代码：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have included the `rx_eventfilter.h` header file to use the event filtering
    mechanism implemented using the `RxCpp` library. In this application, instead
    of creating these widgets inside of a dialog, a `QWidget` object is created, and
    the two `QLabel` widgets are added into a `QVBoxLayout` layout; this is set as
    the layout of the application widget. The size of the application window is a
    predefined value of `200pixels` wide and `280pixels` high. Similar to the previous
    application, mouse tracing is enabled for the first label:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了`rx_eventfilter.h`头文件，以使用`RxCpp`库实现的事件过滤机制。在这个应用程序中，不是在对话框内创建这些小部件，而是创建了一个`QWidget`对象，并将两个`QLabel`小部件添加到`QVBoxLayout`布局中；这被设置为应用程序窗口的布局。应用程序窗口的大小是预定义的，宽度为`200像素`，高度为`280像素`。与之前的应用程序类似，为第一个标签启用了鼠标跟踪：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The size policy of both widgets is set to `QSizePolicy::Expanding` to allow
    for the stretching of widgets inside the vertical layout box. This allows us to
    make the mouse area label larger than the status display label. The `setStretch()`
    function sets the stretch factor at the position index to stretch.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 两个小部件的大小策略都设置为`QSizePolicy::Expanding`，以允许垂直布局框内的小部件拉伸。这使我们可以使鼠标区域标签比状态显示标签更大。`setStretch()`函数设置位置索引处的拉伸系数。
- en: Event type specific observables
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定事件类型的observables
- en: 'The code to subscribe to the `rxcpp::observable` of mouse events is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅`rxcpp::observable`的鼠标事件的代码如下：
- en: Mouse move
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标移动
- en: Mouse button press
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标按钮按下
- en: Mouse button double-click
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标按钮双击
- en: 'The program is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 程序如下：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `rxevt::from()` function returns the `rxcpp::observable` of the events
    from `label_mouseArea`, based on the `QEvent::Type` we are passing as the argument.
    In this code, we are subscribing to an Observable of events in `label_mouseArea`,
    which are of the `QEvent::MouseMove` type. Here, we are updating the `label_coordinates`
    text with the current *X* and *Y* positions of the mouse pointer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`rxevt::from()`函数返回基于我们传递的`QEvent::Type`参数的`label_mouseArea`事件的`rxcpp::observable`。在这段代码中，我们正在订阅`label_mouseArea`中的事件的Observable，这些事件的类型是`QEvent::MouseMove`。在这里，我们正在使用鼠标指针的当前*X*和*Y*位置更新`label_coordinates`文本：'
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similar to mouse-move filtering, an observable of `QEvent` is returned by the
    `rxevt::from()` function, including only events of the type `QEvent::MouseButtonPress`.
    Then, the text is updated in `label_coordinates`, with the position of the mouse
    click:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与鼠标移动过滤类似，`rxevt::from()`函数返回`QEvent`的observable，仅包括类型为`QEvent::MouseButtonPress`的事件。然后，在`label_coordinates`中更新鼠标点击的位置：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, the event type `QEvent::MouseButtonDblClick` is also handled similar
    to a single mouse click, and the text in `label_coordinates` is also updated with
    the double-click position. Then, the `show()` function of the application window
    widget is called, and the `exec()` function is called to start the event loop.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，事件类型`QEvent::MouseButtonDblClick`也类似于单击鼠标，更新了`label_coordinates`中的文本，并显示了双击位置。然后，调用应用程序窗口小部件的`show()`函数，并调用`exec()`函数启动事件循环。
- en: 'The project file, `Mouse_EventFilter.pro`, is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 项目文件`Mouse_EventFilter.pro`如下：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since the RxCpp library is a header-only library, a folder named `include` is
    created inside of the project directory, and the RxCpp library folder is copied
    there. Updating `INCLUDEPATH` will help the application to fetch any include files
    present in the directories specified there. Now, let's build and run the application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RxCpp库是一个仅包含头文件的库，在项目目录内创建了一个名为`include`的文件夹，并将RxCpp库文件夹复制到其中。更新`INCLUDEPATH`将帮助应用程序获取指定目录中存在的任何包含文件。现在，让我们构建并运行应用程序。
- en: An introduction to RxQt
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxQt简介
- en: 'The `RxQt` library is a public domain library written over the `RxCpp` library
    and makes it easy to program with Qt events and signals in a reactive manner.
    To understand the library, let us jump into an example so that we can track the
    mouse events and filter them using the observable supplied by the library. The
    library can be downloaded from the GitHub repository at [https://github.com/tetsurom/rxqt](https://github.com/tetsurom/rxqt):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxQt`库是一个基于`RxCpp`库编写的公共领域库，它使得以一种响应式的方式使用Qt事件和信号变得容易。为了理解该库，让我们跳转到一个示例中，这样我们就可以跟踪鼠标事件并使用该库提供的observable进行过滤。该库可以从GitHub存储库[https://github.com/tetsurom/rxqt](https://github.com/tetsurom/rxqt)下载：'
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code creates `QWidget`, which acts as the parent of two other
    `QLabels`. Two label widgets are created to move inside the parent widget, along
    the top and left border of the windows. The dockable label along the *X*-axis
    is colored red, and the one along the *Y*-axis is blue in color:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个`QWidget`，它充当另外两个`QLabel`的父类。创建了两个标签小部件，以在父小部件内移动，沿着窗口的顶部和左边缘。沿*X*轴的可停靠标签为红色，*Y*轴的标签为蓝色。
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, the `rxqt::from_event()` function filters all of the
    events from the widget class, except for the `QEvent::MouseButtonPress` event,
    and returns a `rxcpp::observable<QEvent*>` instance. The `rxcpp::observable` here
    is already filtered with those mouse events if the button is the left mouse button.
    Then, inside the Lambda function of the `subscribe()` method, we are changing
    the cursor into `Qt::ClosedHandCursor`. We also set the position of `xDock` to
    the mouse *x*-position value, along with the top edge of the window, and the `yDock`
    position to the mouse *y*-position, along with the left edge of the window:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`rxqt::from_event()`函数过滤了除`QEvent::MouseButtonPress`事件之外的所有小部件类事件，并返回了一个`rxcpp::observable<QEvent*>`实例。这里的`rxcpp::observable`已经根据鼠标事件进行了过滤，如果按钮是左鼠标按钮。然后，在`subscribe()`方法的Lambda函数内，我们将光标更改为`Qt::ClosedHandCursor`。我们还将`xDock`的位置设置为鼠标*x*位置值，以及窗口的顶部边缘，将`yDock`的位置设置为鼠标*y*位置值，以及窗口的左边缘：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this code, we are filtering all the mouse-move events from the widget window
    using the `RxQt` library. The observable here is a stream of mouse events with
    both mouse-move and left mouse button press events are present. Inside the subscribe
    method, the code updates the position of  `xDock` and `yDock` along the top and
    left edges of the window:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用`RxQt`库过滤了窗口小部件的所有鼠标移动事件。这里的observable是一个包含鼠标移动和左鼦按键事件的鼠标事件流。在subscribe方法内，代码更新了`xDock`和`yDock`的位置，沿着窗口的顶部和左边缘：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, the filtered mouse button release events are filtered, and the mouse
    cursor is set back to `Qt::OpenHandCursor`. To add some more fun to this application,
    let''s create one more widget, similar to `xDock` and `yDock`; this will be a
    gravity object. The gravity object will follow the mouse cursor when it is pressed:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，过滤了鼠标释放事件，并将鼠标光标设置回`Qt::OpenHandCursor`。为了给这个应用程序增添一些乐趣，让我们创建一个与`xDock`和`yDock`类似的小部件；这将是一个重力对象。当按下鼠标时，重力对象将跟随鼠标光标移动：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we must create an instance of the gravity widget under the application
    window (from the newly created `Gravity_QLabel` class):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在应用程序窗口下创建一个`gravity`小部件的实例（从新创建的`Gravity_QLabel`类）：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similar to the creation and size settings of `xDock` and `yDock`, the new `gravityDock`
    object has been created. Also, the position of this object must be set in the
    mouse coordinate values whenever a `press` event is thrown. Therefore, inside
    of the Lambda function of the subscribe method for `QEvent::MouseButtonPress`,
    we need to add the following line of code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与`xDock`和`yDock`的创建和大小设置类似，新的`gravityDock`对象已经创建。此外，每当抛出`press`事件时，必须将此对象的位置设置为鼠标坐标值。因此，在`QEvent::MouseButtonPress`的`subscribe`方法的Lambda函数内，我们需要添加以下代码行：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, the position of `gravityDock` needs to be updated, as per the mouse
    move. To achieve that, inside of the Lambda function of the `subscribe` method
    for `QEvent::MouseMove`, we need to add the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要根据鼠标移动更新`gravityDock`的位置。为了实现这一点，在`QEvent::MouseMove`的`subscribe`方法的Lambda函数内，我们需要添加以下代码：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the position of `gravityDock` is updated to a new value, which is the
    sum of 96% of the previous value and 4% of the new position. Hence, we are filtering
    the Qt events using the `RxQt` and RxCpp libraries to create an *X*-*Y* mouse
    position indicator and a gravity object. Now, let's build and run the application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`gravityDock`的位置更新为一个新值，该值是先前值的96%和新位置的4%之和。因此，我们使用`RxQt`和RxCpp库来过滤Qt事件，以创建*X*-*Y*鼠标位置指示器和重力对象。现在，让我们构建并运行应用程序。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we dealt with the topic of reactive GUI programming using Qt.
    We started with a quick overview of GUI application development using Qt. We learned
    about concepts in the Qt framework, such as the Qt object hierarchy, the meta-object
    system, and signals and slots. We wrote a basic *Hello World* application using
    a simple label widget. Then, we wrote a mouse event handling application using
    a custom label widget. In that application, we learned more about how the Qt event
    system works, and how to use the signals and slots mechanism for object communication.
    Finally, we wrote an application to handle mouse events and filter them by using
    the `RxCpp` subscription model and Qt event filters. We covered how RxCpp can
    be used in a GUI framework (such as Qt) to follow a Reactive programming model.
    We also covered the `RxQt` library, a public domain that integrates RxCpp and
    the Qt library.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用Qt进行响应式GUI编程的主题。我们从快速概述使用Qt进行GUI应用程序开发开始。我们了解了Qt框架中的概念，如Qt对象层次结构，元对象系统以及信号和槽。我们使用简单的标签小部件编写了一个基本的“Hello
    World”应用程序。然后，我们使用自定义标签小部件编写了一个鼠标事件处理应用程序。在该应用程序中，我们更多地了解了Qt事件系统的工作原理，以及如何使用信号和槽机制进行对象通信。最后，我们编写了一个应用程序，使用`RxCpp`订阅模型和Qt事件过滤器来处理鼠标事件并对其进行过滤。我们介绍了如何在GUI框架（如Qt）中使用RxCpp来遵循响应式编程模型。我们还介绍了`RxQt`库，这是一个集成了RxCpp和Qt库的公共领域。
- en: 'Before proceeding to the next chapter, you need to learn about writing *custom
    operators for RxCpp observables*. This topic is covered in the online section.
    You can refer to the following link: [https://www.packtpub.com/sites/default/files/downloads/Creating_Custom_Operators_in_RxCpp.pdf](https://www.packtpub.com/sites/default/files/downloads/Creating_Custom_Operators_in_RxCpp.pdf).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，您需要了解如何为RxCpp observables编写*自定义操作符*。这个主题在在线部分有介绍。您可以参考以下链接：[https://www.packtpub.com/sites/default/files/downloads/Creating_Custom_Operators_in_RxCpp.pdf](https://www.packtpub.com/sites/default/files/downloads/Creating_Custom_Operators_in_RxCpp.pdf)。
- en: After you have completed reading the preceding mentioned topic, we can proceed
    to the next chapter, where we will take a look at design patterns and idioms for
    C++ reactive programming.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成阅读上述提到的主题之后，我们可以继续下一章，我们将看一下C++响应式编程的设计模式和习语。
