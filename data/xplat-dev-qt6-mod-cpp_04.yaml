- en: '*Chapter 3*: GUI Design Using Qt Widgets'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用Qt小部件进行GUI设计'
- en: Qt Widgets is a module that offers a set of **user interface** (**UI**) elements
    for building classic UIs. In this chapter, you will be introduced to the **Qt
    Widgets** module and will learn about basic widgets. We will look at what widgets
    are and the various kinds that are available for creating **graphical UIs** (**GUIs**).
    In addition to this, you will be introduced to layouts with **Qt Designer**, and
    you will also learn how to create your own custom controls. We will take a close
    look into what Qt can offer us when it comes to designing sleek-looking GUIs with
    ease. At the beginning of this chapter, you will be introduced to the types of
    widgets provided by Qt and their functionalities. After that, we will walk through
    a series of steps and design our first form application using Qt. You will then
    learn about Style Sheets, **Qt Style Sheets** (**QSS files**), and theming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Qt小部件是一个模块，提供了一组用于构建经典UI的用户界面（UI）元素。在本章中，您将介绍Qt小部件模块，并了解基本小部件。我们将看看小部件是什么，以及可用于创建图形UI（GUI）的各种小部件。除此之外，您还将通过Qt
    Designer介绍布局，并学习如何创建自定义控件。我们将仔细研究Qt在设计时如何为我们提供时尚的GUI。在本章开始时，您将了解Qt提供的小部件类型及其功能。之后，我们将逐步进行一系列步骤，并使用Qt设计我们的第一个表单应用程序。然后，您将了解样式表、Qt样式表（QSS文件）和主题。
- en: 'The following main topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Introducing Qt widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Qt小部件
- en: Creating a UI with Qt Designer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt Designer创建UI
- en: Managing layouts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理布局
- en: Creating custom widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义小部件
- en: Creating Qt Style Sheets and custom themes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Qt样式表和自定义主题
- en: Exploring custom styles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索自定义样式
- en: Using widgets, windows, and dialogs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用小部件、窗口和对话框
- en: By the end of this chapter, you will understand the basics of GUI elements and
    their corresponding C++ classes, how to create your own UI without writing a single
    line of code, and how to customize the look and feel of your UI using Style Sheets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解GUI元素及其相应的C++类的基础知识，如何在不编写一行代码的情况下创建自己的UI，以及如何使用样式表自定义UI的外观和感觉。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter include Qt 6.0.0 MinGW 64-bit,
    Qt Creator 4.14.0, and Windows 10/Ubuntu 20.04/macOS 10.14\. All the code used
    in this chapter can be downloaded from the following GitHub link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter03](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter03).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括Qt 6.0.0 MinGW 64位，Qt Creator 4.14.0和Windows 10/Ubuntu 20.04/macOS
    10.14。本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter03](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter03)。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The screenshots used in this chapter are taken from a Windows environment. You
    will see similar screens based on the underlying platforms in your machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的屏幕截图来自Windows环境。您将在您的机器上基于底层平台看到类似的屏幕。
- en: Introducing Qt widgets
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Qt小部件
- en: 'A widget is the basic element of a GUI. It is also known as a `QObject`. `QWidget`
    is a basic widget and is the base class of all UI widgets. It contains most of
    the properties required to describe a widget, along with properties such as geometry,
    color, mouse, keyboard behavior, tooltips, and so on. Let''s have a look at `QWidget`
    inheritance hierarchy in the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是GUI的基本元素。它也被称为`QObject`。`QWidget`是一个基本小部件，是所有UI小部件的基类。它包含描述小部件所需的大多数属性，以及几何、颜色、鼠标、键盘行为、工具提示等属性。让我们在下图中看一下`QWidget`的继承层次结构：
- en: '![Figure 3.1 – QWidget class hierarchy'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – QWidget类层次结构'
- en: '](img/Figure_3.1_B16231.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B16231.jpg)'
- en: Figure 3.1 – QWidget class hierarchy
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – QWidget类层次结构
- en: 'Most of the Qt widget names are self-explanatory and can be identified easily
    as they start with *Q*. Some of them are listed here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Qt小部件的名称都是不言自明的，并且很容易识别，因为它们以*Q*开头。以下是其中一些：
- en: '`QPushButton` is used to command an application to perform a certain action.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QPushButton`用于命令应用程序执行特定操作。'
- en: '`QCheckBox` allows the user to make a binary choice.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCheckBox`允许用户进行二进制选择。'
- en: '`QRadioButton` allows the user to make only one choice from a set of mutually
    exclusive options.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QRadioButton`允许用户从一组互斥选项中只做出一个选择。'
- en: '`QFrame` displays a frame.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QFrame`显示一个框架。'
- en: '`QLabel` is used to display text or an image.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QLabel`用于显示文本或图像。'
- en: '`QLineEdit` allows the user to enter and edit a single line of plain text.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QLineEdit`允许用户输入和编辑单行纯文本。'
- en: '`QTabWidget` is used to display pages related to each tab in a stack of tabbed
    widgets.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTabWidget`用于在选项卡堆栈中显示与每个选项卡相关的页面。'
- en: 'One of the advantages of using Qt Widgets is its parenting system. Any object
    that inherits from `QObject` has a parent-child relationship. This relationship
    makes many things convenient for developers, such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt小部件的优势之一是其父子系统。从`QObject`继承的任何对象都具有父子关系。这种关系使开发人员的许多事情变得方便，例如以下内容：
- en: When a widget is destroyed, all its children are destroyed as well due to the
    parent-children hierarchy. This avoids memory leaks.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当小部件被销毁时，由于父子关系层次结构，所有子项也会被销毁。这可以避免内存泄漏。
- en: You can find children of a given `QWidget` class by using `findChild()` and
    `findChildren()`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`findChild()`和`findChildren()`找到给定`QWidget`类的子项。
- en: Child widgets in a `Qwidget` automatically appear inside the parent widget.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QWidget`中的子小部件会自动出现在父小部件内部。'
- en: A typical C++ program terminates when the main returns, but in a GUI application
    we can't do that, or the application will be unusable. Thus, we will need the
    GUI to be present until the user closes the window. To accomplish this, the program
    should run in a loop till this happens. The GUI application waits for user input
    events.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的C++程序在主函数返回时终止，但在GUI应用程序中我们不能这样做，否则应用程序将无法使用。因此，我们需要GUI一直存在，直到用户关闭窗口。为了实现这一点，程序应该在发生这种情况之前一直运行。GUI应用程序等待用户输入事件。
- en: 'Let''s use `QLabel` to display a text with a simple GUI program, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`QLabel`来显示一个简单GUI程序的文本，如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Remember to add the following line to the `helloworld.pro` file to enable the
    Qt Widgets module:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住将以下行添加到`helloworld.pro`文件中以启用Qt Widgets模块：
- en: '`QT += widgets`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`QT += widgets`'
- en: 'You need to run `qmake` after you make changes to your `.pro` file. If you
    are using the command line, then proceed with the following commands:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`.pro`文件进行更改后，您需要运行`qmake`。如果您正在使用命令行，则继续执行以下命令：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, hit the **Run** button to build and run the application. You will soon
    see a UI with **Hello World!** displayed, as illustrated in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击**Run**按钮来构建和运行应用程序。很快您将看到一个显示**Hello World!**的UI，如下截图所示：
- en: '![Figure 3.2 – Simple GUI application'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - 简单的GUI应用程序'
- en: '](img/Figure_3.2_B16231.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B16231.jpg)'
- en: Figure 3.2 – Simple GUI application
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 简单的GUI应用程序
- en: 'You can also run the application from the command line on Windows, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在Windows命令行中运行应用程序，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can run the application from the command line on Linux distributions, as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Linux发行版的命令行中运行应用程序，如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In command-line mode, you may see a few error dialogs if the libraries are not
    found in the application path. You can copy the Qt libraries and plugin files
    to that binary folder to resolve the issue. To avoid these issues, we will stick
    to Qt Creator to build and run our sample programs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行模式下，如果库未在应用程序路径中找到，您可能会看到一些错误对话框。您可以将Qt库和插件文件复制到二进制文件夹中以解决此问题。为了避免这些问题，我们将坚持使用Qt
    Creator来构建和运行我们的示例程序。
- en: In this section, we learned how to create a simple GUI using the Qt Widgets
    module. In the next section, we will explore the available widgets and creating
    a UI with Qt Designer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了如何使用Qt Widgets模块创建一个简单的GUI。在下一节中，我们将探索可用的小部件，并使用Qt Designer创建UI。
- en: Creating a UI with Qt Designer
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt Designer创建UI
- en: 'Let''s get familiar with Qt Designer''s interface before we start learning
    how to design our own UI. The following screenshot shows different sections of
    **Qt Designer**. We will gradually learn about these sections while designing
    our UI:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习如何设计自己的UI之前，让我们熟悉一下Qt Designer的界面。以下截图显示了**Qt Designer**的不同部分。在设计我们的UI时，我们将逐渐了解这些部分：
- en: '![Figure 3.3 – Qt Designer UI'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - Qt Designer UI'
- en: '](img/Figure_3.3_B16231.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.3_B16231.jpg)'
- en: Figure 3.3 – Qt Designer UI
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - Qt Designer UI
- en: The Qt Widgets module comes with ready-to-use widgets. All these widgets can
    be found under the **Widget Box** section. Qt provides an option to create a UI
    by a drag-and-drop method. Let's explore these widgets by simply dragging them
    from the **Widget Box** area and dropping them into the **Form Editor** area.
    You can do this by grabbing an item and then pressing and releasing the mouse
    or trackpad over the intended region. Don't release your mouse or trackpad until
    the item reaches the **Form Editor** area.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Widgets模块带有现成的小部件。所有这些小部件都可以在**Widget Box**部分找到。Qt提供了通过拖放方法创建UI的选项。让我们通过简单地从**Widget
    Box**区域拖动它们并将它们放入**Form Editor**区域来探索这些小部件。您可以通过抓取一个项目，然后在预定区域上按下并释放鼠标或触控板来执行此操作。在项目到达**Form
    Editor**区域之前，请不要释放鼠标或触控板。
- en: 'The following screenshot shows different types of widgets available in the
    **Widget Box** section. We have added several ready-made widgets such as **Label**,
    **Push Button**, **Radio Button**, **Check Box**, **Combo Box**, **Progress Bar**,
    and **Line Edit** into the **Form Editor** area. These widgets are very commonly
    used widgets. You can explore the widget-specific properties in **Property Editor**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**Widget Box**部分提供的不同类型的小部件。我们已经将几个现成的小部件，如**Label**、**Push Button**、**Radio
    Button**、**Check Box**、**Combo Box**、**Progress Bar**和**Line Edit**添加到**Form Editor**区域。这些小部件是非常常用的小部件。您可以在**Property
    Editor**中探索特定于小部件的属性：
- en: '![Figure 3.4 – Different types of GUI widgets'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 - 不同类型的GUI小部件'
- en: '](img/Figure_3.4_B16231.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4_B16231.jpg)'
- en: Figure 3.4 – Different types of GUI widgets
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 不同类型的GUI小部件
- en: 'You can preview your UI by selecting the **Preview…** option under the **Form**
    menu, as shown in the following screenshot, or you can hit *Ctrl* + *R*. You will
    see a window with the UI preview:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在**Form**菜单下选择**Preview…**选项来预览您的UI，如下截图所示，或者您可以按下*Ctrl* + *R*。您将看到一个带有UI预览的窗口：
- en: '![Figure 3.5 – Previewing your custom UI'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 - 预览您的自定义UI'
- en: '](img/Figure_3.5_B16231.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.5_B16231.jpg)'
- en: Figure 3.5 – Previewing your custom UI
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 - 预览您的自定义UI
- en: 'You can find the created C++ code for your UI by selecting the **View C++ Code…**
    option under the **Form** menu, as shown in the following screenshot. You will
    see a window with the generated code. You can reuse the code while creating a
    dynamic UI:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在**Form**菜单下选择**View C++ Code…**选项来查找UI的创建的C++代码，如下截图所示。您将看到一个显示生成代码的窗口。您可以在创建动态UI时重用该代码：
- en: '![Figure 3.6 – Option to view corresponding C++ code'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 - 查看相应的C++代码的选项'
- en: '](img/Figure_3.6_B16231.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.6_B16231.jpg)'
- en: Figure 3.6 – Option to view corresponding C++ code
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 查看相应的C++代码的选项
- en: In this section, we got familiar with the Qt Designer UI. You can also find
    the same interface embedded in `.ui` file. In the next section, you will learn
    about different types of layouts and how to use them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们熟悉了Qt Designer UI。您还可以在`.ui`文件中找到相同的界面。在下一节中，您将学习不同类型的布局以及如何使用它们。
- en: Managing layouts
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理布局
- en: Qt provides a set of convenient layout management classes to automatically arrange
    child widgets within another widget to ensure that the UI remains usable. The
    `QLayout` class is the base class of all layout managers. You can also create
    your own layout manager by reimplementing the `setGeometry()`, `sizeHint()`, `addItem()`,
    `itemAt()`, `takeAt()`, and `minimumSize()` functions. Please note that once the
    layout manager is deleted, the layout management will also stop.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一组方便的布局管理类，以自动安排另一个小部件中的子小部件，以确保UI保持可用。`QLayout`类是所有布局管理器的基类。您还可以通过重新实现`setGeometry()`、`sizeHint()`、`addItem()`、`itemAt()`、`takeAt()`和`minimumSize()`函数来创建自己的布局管理器。请注意，一旦布局管理器被删除，布局管理也将停止。
- en: 'The following list provides a brief description of the major layout classes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了主要布局类的简要描述：
- en: '`QVBoxLayout` lines up widgets vertically.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QVBoxLayout`将小部件垂直排列。'
- en: '`QHBoxLayout` lines up widgets horizontally.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QHBoxLayout`将小部件水平排列。'
- en: '`QGridLayout` lays widgets out in a grid.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGridLayout`以网格形式布置小部件。'
- en: '`QFormLayout` manages forms of input widgets and their associated labels.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QFormLayout`管理输入小部件及其关联标签的表单。'
- en: '`QStackedLayout` provides a stack of widgets where only one widget is visible
    at a time.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QStackedLayout`提供了一个小部件堆栈，一次只有一个小部件可见。'
- en: '`QLayout` uses multiple inheritances by inheriting from `QObject` and `QLayoutItem`.
    The subclasses of `QLayout` are `QBoxLayout`, `QGridLayout`, `QFormLayout`, and
    `QStackedLayout`. `QVBoxLayout` and `QHBoxLayout` are inherited from `QBoxLayout`
    with the addition of orientation information.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLayout`通过从`QObject`和`QLayoutItem`继承来使用多重继承。`QLayout`的子类包括`QBoxLayout`、`QGridLayout`、`QFormLayout`和`QStackedLayout`。`QVBoxLayout`和`QHBoxLayout`是从`QBoxLayout`继承的，并添加了方向信息。'
- en: Let's use the Qt Designer module to lay out a few `QPushButtons`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Qt Designer模块来布置一些`QPushButtons`。
- en: QVBoxLayout
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QVBoxLayout
- en: 'In the `QVBoxLayout` class, widgets are arranged vertically, and they are aligned
    in the layout from top to bottom. At this point, you can do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`QVBoxLayout`类中，小部件垂直排列，并且它们在布局中从上到下对齐。此时，您可以做以下事情：
- en: Drag four push buttons onto the **Form Editor**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个按钮拖放到**表单编辑器**上。
- en: Rename the push buttons and select the push buttons by pressing the *Ctrl* key
    on your keyboard.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名按钮并按下键盘上的*Ctrl*键选择按钮。
- en: In the **Form** toolbar, click on the vertical layout button. You can find this
    by hovering on the toolbar button that says **Lay Out Vertically**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**表单**工具栏中，单击垂直布局按钮。您可以通过悬停在工具栏按钮上找到这个按钮，该按钮上写着**垂直布局**。
- en: 'You can see the push buttons get arranged vertically in a top-down manner in
    the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到按钮垂直排列在从上到下的方式：
- en: '![Figure 3.7 – Layout management with QVBoxLayout'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – 使用QVBoxLayout进行布局管理'
- en: '](img/Figure_3.7_B16231.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.7_B16231.jpg)'
- en: Figure 3.7 – Layout management with QVBoxLayout
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 使用QVBoxLayout进行布局管理
- en: 'You can also dynamically add a vertical layout through C++ code, as shown in
    the following snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过C++代码动态添加垂直布局，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This program illustrates how to use a vertical layout object. Note that the
    `QWidget` instance, `widget`, will become the main window of the application.
    Here, the layout is set directly as the top-level layout. The first push button
    added to the `addWidget()` method occupies the top of the layout, while the last
    push button occupies the bottom of the layout. The `addWidget()` method adds a
    widget to the end of the layout, with a stretch factor and alignment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序演示了如何使用垂直布局对象。请注意，`QWidget`实例`widget`将成为应用程序的主窗口。在这里，布局直接设置为顶级布局。添加到`addWidget()`方法的第一个按钮占据布局的顶部，而最后一个按钮占据布局的底部。`addWidget()`方法将一个小部件添加到布局的末尾，带有拉伸因子和对齐方式。
- en: If you don't set the parent window in the constructor, then you will have to
    use `QWidget::setLayout()` later to install the layout and reparent to the `widget`
    instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在构造函数中没有设置父窗口，那么您将不得不稍后使用`QWidget::setLayout()`来安装布局并将其重新设置为`widget`实例的父对象。
- en: Next, we will look at the `QHBoxLayout` class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看`QHBoxLayout`类。
- en: QHBoxLayout
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QHBoxLayout
- en: In the `QHBoxLayout` class, widgets are arranged horizontally, and they are
    aligned from left to right.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`QHBoxLayout`类中，小部件水平排列，并且它们从左到右对齐。
- en: 'We can now do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以做以下事情：
- en: Drag four push buttons onto the **Form Editor**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个按钮拖放到**表单编辑器**上。
- en: Rename the push buttons and select the push buttons by pressing the *Ctrl* key
    on your keyboard.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名按钮并按下键盘上的*Ctrl*键选择按钮。
- en: In the **Form** toolbar, click on the horizontal layout button. You can find
    this by hovering on the toolbar button that says **Lay Out Horizontally**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**表单**工具栏中，单击水平布局按钮。您可以通过悬停在工具栏按钮上找到这个按钮，该按钮上写着**水平布局**。
- en: 'You can see the push buttons get arranged horizontally in a left-to-right manner
    in this screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此屏幕截图中看到按钮水平排列在左到右的方式：
- en: '![Figure 3.8 – Layout management with QHBoxLayout'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 使用QHBoxLayout进行布局管理'
- en: '](img/Figure_3.8_B16231.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.8_B16231.jpg)'
- en: Figure 3.8 – Layout management with QHBoxLayout
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 使用QHBoxLayout进行布局管理
- en: 'You can also dynamically add a horizontal layout through C++ code, as shown
    in the following snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过C++代码动态添加水平布局，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding example demonstrates how to use a horizontal layout object. Similar
    to the vertical layout example, the `QWidget` instance will become the main window
    of the application. In this case, the layout is set directly as the top-level
    layout. By default, the first push button added to the `addWidget()` method occupies
    the leftmost side of the layout, while the last push button occupies the rightmost
    side of the layout. You can change the direction of growth when widgets are added
    to the layout by using the `setDirection()` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例演示了如何使用水平布局对象。与垂直布局示例类似，`QWidget`实例将成为应用程序的主窗口。在这种情况下，布局直接设置为顶级布局。默认情况下，添加到`addWidget()`方法的第一个按钮占据布局的最左侧，而最后一个按钮占据布局的最右侧。您可以使用`setDirection()`方法在将小部件添加到布局时更改增长方向。
- en: In the next section, we will look at the `QGridLayout` class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下`QGridLayout`类。
- en: QGridLayout
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QGridLayout
- en: In the `QGridLayout` class, widgets are arranged in a grid by specifying the
    number of rows and columns. It resembles a grid-like structure with rows and columns,
    and widgets are inserted as items.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`QGridLayout`类中，通过指定行数和列数将小部件排列成网格。它类似于具有行和列的网格结构，并且小部件被插入为项目。
- en: 'Here, we should do the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该执行以下操作：
- en: Drag four push buttons onto the **Form Editor**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个按钮拖放到**表单编辑器**中。
- en: Rename the push buttons and select the push buttons by pressing the *Ctrl* key
    on your keyboard.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名按钮并按下键盘上的*Ctrl*键选择按钮。
- en: In the **Form** toolbar, click on the grid layout button. You can find this
    by hovering on the toolbar button that says **Lay Out in a Grid**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**表单**工具栏中，单击网格布局按钮。您可以在工具栏按钮上悬停，找到标有**以网格形式布局**的按钮。
- en: 'You can see the push buttons get arranged in a grid in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下截图中看到按钮以网格形式排列：
- en: '![Figure 3.9 – Layout management with QGridLayout'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 - 使用QGridLayout进行布局管理'
- en: '](img/Figure_3.9_B16231.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B16231.jpg)'
- en: Figure 3.9 – Layout management with QGridLayout
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 - 使用QGridLayout进行布局管理
- en: 'You can also dynamically add grid layout through C++ code, as shown in the
    following snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过C++代码动态添加网格布局，如下段代码所示：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding snippet explains how to use a grid layout object. The layout concept
    remains the same as in the previous sections. You can explore `QFormLayout` and
    `QStackedLayout` layouts from the Qt documentation. Let's proceed to the next
    section on how to create your custom widget and export it to the Qt Designer module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码段解释了如何使用网格布局对象。布局概念与前几节中的相同。您可以从Qt文档中探索`QFormLayout`和`QStackedLayout`布局。让我们继续下一节，了解如何创建自定义小部件并将其导出到Qt设计师模块。
- en: Creating custom widgets
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义小部件
- en: Qt provides ready-to-use essential `QLabel` as our first custom widget. A custom
    widget collection can have multiple custom widgets.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了现成的基本`QLabel`作为我们的第一个自定义小部件。自定义小部件集合可以有多个自定义小部件。
- en: 'Follow these steps to build your first Qt custom widgets library:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建您的第一个Qt自定义小部件库：
- en: To create a new Qt custom widget project in Qt, click on the **File menu** option
    on the menu bar or hit *Ctrl* + *N*. Alternatively, you can also click on the
    **New Project** button located on the **Welcome** screen. Select the **Other Project**
    template and then select **Qt Custom Designer Widget**, as shown in the following
    screenshot:![Figure 3.10 – Creating a custom widget library project
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Qt中创建新的自定义小部件项目，请单击菜单栏上的**文件菜单**选项或按下*Ctrl* + *N*。或者，您也可以单击**欢迎**屏幕上的**新建项目**按钮。选择**其他项目**模板，然后选择**Qt自定义设计师小部件**，如下截图所示：![图3.10
    - 创建自定义小部件库项目
- en: '](img/Figure_3.10_B16231.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B16231.jpg)'
- en: Figure 3.10 – Creating a custom widget library project
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 - 创建自定义小部件库项目
- en: In the next step, you will be asked to choose the project name and project location.
    You can navigate to the desired project location by clicking the `MyWidgets`.
    Then, click on the **Next** button to proceed to the next screen. The following
    screenshot illustrates this step:![Figure 3.11 – Creating custom controls library
    project
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，您将被要求选择项目名称和项目位置。单击`MyWidgets`以导航到所需的项目位置。然后，单击**下一步**按钮，进入下一个屏幕。以下截图说明了这一步骤：![图3.11
    - 创建自定义控件库项目
- en: '](img/Figure_3.11_B16231.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B16231.jpg)'
- en: Figure 3.11 – Creating custom controls library project
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 - 创建自定义控件库项目
- en: In the next step, you can select a kit from a set of kits to build and run your
    project. To build and run the project, at least one kit must be active and selectable.
    Select the default **Desktop Qt 6.0.0 MinGW 64-bit** kit. Click on the **Next**
    button to proceed to the next screen. The following screenshot illustrates this
    step:![Figure 3.12 – Kit selection screen
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，您可以从一组套件中选择一个套件来构建和运行您的项目。要构建和运行项目，至少一个套件必须处于活动状态且可选择。选择默认的**桌面Qt 6.0.0
    MinGW 64位**套件。单击**下一步**按钮，进入下一个屏幕。以下截图说明了这一步骤：![图3.12 - 套件选择屏幕
- en: '](img/Figure_3.12_B16231.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.12_B16231.jpg)'
- en: Figure 3.12 – Kit selection screen
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 - 套件选择屏幕
- en: In this step, you can define your custom widget class name and inheritance details.
    Let's create our own custom label with the class name `MyLabel`. Click on the
    **Next** button to proceed to the next screen. The following screenshot illustrates
    this step:![Figure 3.13 – Creating a custom widget from an existing widget's screen
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，您可以定义自定义小部件类名称和继承详细信息。让我们使用类名`MyLabel`创建自己的自定义标签。单击**下一步**按钮，进入下一个屏幕。以下截图说明了这一步骤：![图3.13
    - 从现有小部件屏幕创建自定义小部件
- en: '](img/Figure_3.13_B16231.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B16231.jpg)'
- en: Figure 3.13 – Creating a custom widget from an existing widget's screen
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 - 从现有小部件屏幕创建自定义小部件
- en: In the next step, you can add more custom widgets to create a widget collection.
    Let's create our own custom frame with the class name `MyFrame`. You can add more
    information to the **Description** tab or can modify it later. Click on the checkbox
    that says **The widget is a container** to use the frame as a container. Click
    on the **Next** button to proceed to the next screen. The following screenshot
    illustrates this step:![Figure 3.14 – Creating a custom widget container
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，您可以添加更多自定义小部件以创建一个小部件集合。让我们使用类名`MyFrame`创建自己的自定义框架。您可以在**描述**选项卡中添加更多信息，或者稍后进行修改。选中**小部件是一个容器**的复选框，以将框架用作容器。单击**下一步**按钮，进入下一个屏幕。以下截图说明了这一步骤：![图3.14
    - 创建自定义小部件容器
- en: '](img/Figure_3.14_B16231.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B16231.jpg)'
- en: Figure 3.14 – Creating a custom widget container
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 - 创建自定义小部件容器
- en: In this step, you can specify the collection class name and the plugin information
    to automatically generate the project skeleton. Let's name the collection class
    `MyWidgetCollection`. Click on the **Next** button to proceed to the next screen.
    The following screenshot illustrates this step:![Figure 3.15 – Option to specify
    plugin and collection class information
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，您可以指定集合类名称和插件信息，以自动生成项目骨架。让我们将集合类命名为`MyWidgetCollection`。单击**下一步**按钮，进入下一个屏幕。以下截图说明了这一步骤：![图3.15
    - 指定插件和集合类信息的选项
- en: '](img/Figure_3.15_B16231.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15_B16231.jpg)'
- en: Figure 3.15 – Option to specify plugin and collection class information
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 - 指定插件和集合类信息的选项
- en: The next step is to add your custom widget project to the installed version
    control system. You may skip version control for this project. Click on the **Finish**
    button to create the project with the generated files. The following screenshot
    illustrates this step:![Figure 3.16 – Project management screen
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将您的自定义小部件项目添加到已安装的版本控制系统中。您可以跳过此项目的版本控制。单击**完成**按钮以使用生成的文件创建项目。以下截图说明了这一步骤：![图3.16
    - 项目管理屏幕
- en: '](img/Figure_3.16_B16231.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16_B16231.jpg)'
- en: Figure 3.16 – Project management screen
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 - 项目管理屏幕
- en: Expand the `mylabel.h` file. We will modify the contents to extend the functionalities.
    Add a `QDESIGNER_WIDGET_EXPORT` macro before the custom widget class name to ensure
    the class is exported properly in the `#include <QtDesigner>` to the header file
    after you insert the macro. The following screenshot illustrates this step:![Figure
    3.17 – Modifying the custom widget from the created skeleton
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`mylabel.h`文件。我们将修改内容以扩展功能。在自定义小部件类名之前添加`QDESIGNER_WIDGET_EXPORT`宏，以确保在插入宏后将类正确导出到`#include
    <QtDesigner>`头文件中。以下截图说明了这一步骤：![图3.17 - 修改创建的骨架中的自定义小部件
- en: '](img/Figure_3.17_B16231.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.17_B16231.jpg)'
- en: Figure 3.17 – Modifying the custom widget from the created skeleton
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 - 修改创建的骨架中的自定义小部件
- en: Important note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: On some platforms, the build system may remove the symbols required by Qt Designer
    module to create new widgets, making them unusable. Using the `QDESIGNER_WIDGET_EXPORT`
    macro ensures that the symbols are retained on those platforms. This is important
    while creating a cross-platform library. There are no side effects on other platforms.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些平台上，构建系统可能会删除Qt Designer模块创建新小部件所需的符号，使它们无法使用。使用`QDESIGNER_WIDGET_EXPORT`宏可以确保这些符号在这些平台上被保留。这在创建跨平台库时非常重要。其他平台没有副作用。
- en: 'Now, open the `mylabelplugin.h` file. You will find that the plugin class is
    inherited from a new class named `QDesignerCustomWidgetInterface`. This class
    allows Qt Designer to access and create custom widgets. Please note that you must
    update the header file as follows to avoid deprecated warnings:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`mylabelplugin.h`文件。您会发现插件类是从一个名为`QDesignerCustomWidgetInterface`的新类继承而来。这个类允许Qt
    Designer访问和创建自定义小部件。请注意，为了避免弃用警告，您必须按照以下方式更新头文件：
- en: '`#include <QtUiPlugin/QDesignerCustomWidgetInterface>`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include <QtUiPlugin/QDesignerCustomWidgetInterface>`'
- en: 'You will find several functions auto created in `mylabelplugin.h`. Don''t remove
    these functions. You can specify the values in the `name()`, `group()`, and `icon()`
    functions that appear in the Qt Designer module. Note that if you don''t specify
    an icon path in `icon()`, then Qt Designer will use the default Qt icon. The `group()`
    function is illustrated in the following code snippet:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mylabelplugin.h`中会自动生成几个函数。不要删除这些函数。您可以在`name()`、`group()`和`icon()`函数中指定在Qt
    Designer模块中显示的值。请注意，如果在`icon()`中没有指定图标路径，那么Qt Designer将使用默认的Qt图标。`group()`函数在以下代码片段中说明：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see in the following code snippet that `isContainer()` returns `false`
    in `MyLabel` and `true` in `MyFrame`, since `MyLabel` is not designed to hold
    other widgets. Qt Designer calls `createWidget()` to obtain an instance of `MyLabel`
    or `MyFrame`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在以下代码片段中看到，`isContainer()`在`MyLabel`中返回`false`，在`MyFrame`中返回`true`，因为`MyLabel`不设计用来容纳其他小部件。Qt
    Designer调用`createWidget()`来获取`MyLabel`或`MyFrame`的实例：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To create a widget with a defined geometry or any other properties, you specify
    these in the `domXML()` method. The function returns an `MyLabel` width as `100`
    `16` px, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建具有定义几何形状或其他属性的小部件，您可以在`domXML()`方法中指定这些属性。该函数返回`MyLabel`宽度为`100` `16`像素，如下所示：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s have a look at the `MyWidgets.pro` file. It contains all the information
    required by `qmake` to build the custom widget collection library. You can see
    in the following code snippet that the project is a library type and is configured
    to be used as a plugin:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`MyWidgets.pro`文件。它包含了`qmake`构建自定义小部件集合库所需的所有信息。您可以在以下代码片段中看到，该项目是一个库类型，并配置为用作插件：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have gone through the custom widget creation process. Let's run `qmake` and
    build the library in the `inside release` folder. On the Windows platform, you
    can manually copy the `mywidgetcollectionplugin.dll` created plugin library to
    the `D:\Qt\6.0.0\mingw81_64\plugins\designer` path. This path and extension vary
    for different operating systems:![Figure 3.18 – Option to build your custom widget
    library
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了自定义小部件创建过程。让我们运行`qmake`并在`inside release`文件夹中构建库。在Windows平台上，您可以手动将创建的`mywidgetcollectionplugin.dll`插件库复制到`D:\Qt\6.0.0\mingw81_64\plugins\designer`路径。这个路径和扩展名在不同的操作系统上会有所不同：![图3.18
    - 生成自定义小部件库的选项
- en: '](img/Figure_3.18_B16231.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.18_B16231.jpg)'
- en: Figure 3.18 – Option to build your custom widget library
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 - 生成自定义小部件库的选项
- en: We have created our custom plugin. Now, close the plugin project and click on
    the `designer.exe` file present inside `D:\Qt\6.0.0\mingw81_64\bin`. You can see
    `MyFrame` under the **Custom Widgets** section, as shown in the following screenshot.
    Click on the **Create** button or use a widget template. You can also register
    your own form as a template by doing platform-specific modifications. Let's use
    the Qt Designer-provided widget template:![Figure 3.19 – Custom container in the
    new form screen
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的自定义插件。现在，关闭插件项目，然后单击`D:\Qt\6.0.0\mingw81_64\bin`中的`designer.exe`文件。您可以在**自定义小部件**部分下看到`MyFrame`，如下面的屏幕截图所示。单击**创建**按钮或使用小部件模板。您还可以通过进行特定于平台的修改来将自己的表单注册为模板。让我们使用Qt
    Designer提供的小部件模板：![图3.19–新表单屏幕中的自定义容器
- en: '](img/Figure_3.19_B16231.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.19_B16231.jpg)'
- en: Figure 3.19 – Custom container in the new form screen
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19–新表单屏幕中的自定义容器
- en: 'You can see our custom widgets in the left-side **Widget Box** section, at
    the bottom. Drag the **MyLabel** widget to the form. You can find created properties
    such as **multiLine** and **fontCase** along with **QLabel** properties under
    **Property Editor**, as illustrated in the following screenshot:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在左侧的**小部件框**部分看到我们的自定义小部件，位于底部。将**MyLabel**小部件拖到表单中。您可以在**属性编辑器**下找到创建的属性，例如**multiLine**和**fontCase**以及**QLabel**属性，如下面的屏幕截图所示：
- en: '![Figure 3.20 – Exported widgets available in Qt Designer'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.20–在Qt Designer中可用的导出小部件'
- en: '](img/Figure_3.20_B16231.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.20_B16231.jpg)'
- en: Figure 3.20 – Exported widgets available in Qt Designer
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20–在Qt Designer中可用的导出小部件
- en: 'You can also find detailed instructions with examples in the following Qt documentation
    link:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在以下Qt文档链接中找到详细的带有示例的说明：
- en: '[https://doc.qt.io/qt-6/designer-creating-custom-widgets.html](https://doc.qt.io/qt-6/designer-creating-custom-widgets.html)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/designer-creating-custom-widgets.html](https://doc.qt.io/qt-6/designer-creating-custom-widgets.html)'
- en: Congratulations! You have successfully created your custom widgets with new
    properties. You can create complex custom widgets by combining multiple widgets.
    In the next section, you will learn how to customize the look and feel of widgets.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功创建了具有新属性的自定义小部件。您可以通过组合多个小部件来创建复杂的自定义小部件。在下一节中，您将学习如何自定义小部件的外观和感觉。
- en: Creating Qt Style Sheets and custom themes
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Qt样式表和自定义主题
- en: In the last section, we created our custom widget, but the widget still has
    a native look. Qt provides several ways to customize the look and feel of the
    UI. A `{}` and separated by semicolons.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了我们的自定义小部件，但是小部件仍然具有本机外观。Qt提供了几种自定义UI外观和感觉的方法。用大括号`{}`分隔，并用分号分隔。
- en: 'Let''s have look at the simple `QPushButton` Style Sheet syntax, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下简单的`QPushButton`样式表语法，如下所示：
- en: '`QPushButton { color: green; background-color: rgb (193, 255, 216);}`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPushButton { color: green; background-color: rgb (193, 255, 216);}`'
- en: 'You can also change the look and feel of widgets by applying Style Sheet in
    Qt Designer with the stylesheet editor, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在Qt Designer中使用样式表编辑器来改变小部件的外观和感觉，方法如下：
- en: Open the Qt Designer module and create a new form. Drag and place a push button
    on the form.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Qt Designer模块并创建一个新表单。将一个按钮拖放到表单上。
- en: Then, right-click on the push button or anywhere in the form to get the context
    menu.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，右键单击按钮或表单中的任何位置以获取上下文菜单。
- en: Next, click on the **Change styleSheet…** option, as shown in the following
    screenshot:![Figure 3.21 – Adding Style Sheet using Qt Designer
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，单击**更改样式表…**选项，如下面的屏幕截图所示：![图3.21–使用Qt Designer添加样式表
- en: '](img/Figure_3.21_B16231.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.21_B16231.jpg)'
- en: Figure 3.21 – Adding Style Sheet using Qt Designer
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21–使用Qt Designer添加样式表
- en: 'We have used the following Style sheet to create the previous look and feel.
    You can also change a Style Sheet from the `QWidget` properties in **Property
    Editor**:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了以下样式表来创建之前的外观和感觉。您还可以在**属性编辑器**中从`QWidget`属性中更改样式表：
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, only `Push Button` will get the style described in
    the Style Sheet, and all other widgets will have the native styling. You can also
    create different styles for each push button and apply the styles to respective
    push buttons by mentioning their object names in the Style Sheet, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，只有`Push Button`将获得样式表中描述的样式，而所有其他小部件将具有本机样式。您还可以为每个按钮创建不同的样式，并通过在样式表中提及它们的对象名称来将样式应用于相应的按钮，方法如下：
- en: '`QPushButton#pushButtonID`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPushButton#pushButtonID`'
- en: Important note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To learn more about Style Sheet and their usage, read the documentation at
    the following links:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于样式表及其用法的信息，请阅读以下链接中的文档：
- en: '[https://doc.qt.io/qt-6/stylesheet-reference.html](https://doc.qt.io/qt-6/stylesheet-reference.html)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/stylesheet-reference.html](https://doc.qt.io/qt-6/stylesheet-reference.html)'
- en: '[https://doc.qt.io/qt-6/stylesheet-syntax.html](https://doc.qt.io/qt-6/stylesheet-syntax.html)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/stylesheet-syntax.html](https://doc.qt.io/qt-6/stylesheet-syntax.html)'
- en: '[https://doc.qt.io/qt-6/stylesheet-customizing.html](https://doc.qt.io/qt-6/stylesheet-customizing.html)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/stylesheet-customizing.html](https://doc.qt.io/qt-6/stylesheet-customizing.html)'
- en: Using a QSS file
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用QSS文件
- en: 'You can combine all Style Sheet code in a defined `.qss` file. This helps in
    ensuring the look and feel is maintained across the application in all screens.
    QSS files are analogous to `.css` files, which contain the definitions for the
    look and feel of GUI elements such as color, background color, font, and mouse
    interaction behaviors. They can be created and edited with any text editor. You
    can create a new Style Sheet file with the `.qss` file extension and then add
    it to the resource file (`.qrc`). You may or may not have `.ui` files for all
    projects. The GUI controls can be created dynamically through code. You can apply
    a Style Sheet to a widget or to a whole application, as shown in the following
    code snippet. This is how we do it for a custom widget or form:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将所有样式表代码组合在一个定义的`.qss`文件中。这有助于确保在所有屏幕中应用程序的外观和感觉保持一致。QSS文件类似于`.css`文件，其中包含GUI元素的外观和感觉的定义，如颜色、背景颜色、字体和鼠标交互行为。它们可以使用任何文本编辑器创建和编辑。您可以创建一个新的样式表文件，使用`.qss`文件扩展名，然后将其添加到资源文件（`.qrc`）中。您可能并非所有项目都有`.ui`文件。GUI控件可以通过代码动态创建。您可以将样式表应用于小部件或整个应用程序，如下面的代码片段所示。这是我们为自定义小部件或表单执行的方式：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is how we apply it for the whole application:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们为整个应用程序应用的方式：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding program illustrates how to use a Style Sheet file for the entire
    Qt GUI application. You need to add the .`qss` file into the resources. Open the
    .`qss` file using `QFile` and pass the customized QSS rules as an argument to
    the `setStyleSheet()` method on the `QApplication` object. You will see all screens
    will have the Style Sheet applied to them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序演示了如何为整个Qt GUI应用程序使用样式表文件。您需要将`.qss`文件添加到资源中。使用`QFile`打开`.qss`文件，并将自定义的QSS规则作为参数传递给`QApplication`对象上的`setStyleSheet()`方法。您会看到所有屏幕都应用了样式表。
- en: In this section, you learned about customizing the look and feel of an application
    using Style Sheets, but there are more ways to change an application's look and
    feel. These approaches depend on your project need. In the next section, you will
    learn about custom styles.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了使用样式表自定义应用程序外观和感觉的方法，但还有更多改变应用程序外观和感觉的方法。这些方法取决于您的项目需求。在下一节中，您将了解自定义样式。
- en: Exploring custom styles
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索自定义样式
- en: Qt provides several `QStyle` subclasses that emulate the styles of the different
    platforms supported by Qt. These styles are readily available with the Qt GUI
    module. You can build your own `QStyle` for rendering the Qt widgets to ensure
    their look and feel, as per native widgets.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了几个`QStyle`子类，模拟Qt支持的不同平台的样式。这些样式可以在Qt GUI模块中轻松获得。您可以构建自己的`QStyle`来渲染Qt小部件，以确保它们的外观和感觉与本机小部件一致。
- en: 'On a Unix distribution, you can get a Windows-style UI for your application
    by running the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix发行版上，您可以通过运行以下命令为您的应用程序获取Windows风格的用户界面：
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can set a style on an individual widget using the `QWidget::setStyle()`
    method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`QWidget::setStyle()`方法为单个小部件设置样式。
- en: Creating a custom style
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义样式
- en: You can customize the look and feel of your GUI by creating a custom style.
    There are two different approaches to creating a custom style. In a static approach,
    you can subclass the `QStyle` class and reimplement virtual functions to deliver
    the desired behavior, or rewrite the `QStyle` class from scratch. `QCommonStyle`
    is generally used as a base class instead of `QStyle`. In a dynamic approach,
    you can subclass `QProxyStyle` and modify the behavior of your system style at
    runtime. You can also develop style-aware custom widgets by using `QStyle` functions
    such as `drawPrimitive()`, `drawItemText()`, and `drawControl()`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建自定义样式来自定义GUI的外观和感觉。有两种不同的方法可以创建自定义样式。在静态方法中，您可以子类化`QStyle`类并重新实现虚拟函数以提供所需的行为，或者从头开始重写`QStyle`类。通常使用`QCommonStyle`作为基类，而不是`QStyle`。在动态方法中，您可以子类化`QProxyStyle`并在运行时修改系统样式的行为。您还可以使用`QStyle`函数（如`drawPrimitive()`，`drawItemText()`和`drawControl()`）开发样式感知的自定义小部件。
- en: 'This section is an advanced Qt topic. You need to understand Qt in depth to
    create your own style plugin. You can skip this section if you are a beginner.
    You can learn about the QStyle classes and custom styles in the Qt documentation
    at the following link:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是一个高级的Qt主题。您需要深入了解Qt才能创建自己的样式插件。如果您是初学者，可以跳过本节。您可以在以下链接的Qt文档中了解有关QStyle类和自定义样式的信息：
- en: '[https://doc.qt.io/qt-6/qstyle.html](https://doc.qt.io/qt-6/qstyle.html)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/qstyle.html](https://doc.qt.io/qt-6/qstyle.html)'
- en: Using a custom style
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义样式
- en: 'There are several ways to apply a custom style in a Qt application. The easiest
    way is to call the `QApplication::setStyle()` static function before creating
    a `QApplication` object, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt应用程序中应用自定义样式有几种方法。最简单的方法是在创建`QApplication`对象之前调用`QApplication::setStyle()`静态函数，如下所示：
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also apply a custom style as a command-line argument, like so:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将自定义样式作为命令行参数应用，方法如下：
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Custom styles can be difficult to implement but can be faster and more flexible.
    QSS is easy to learn and implement, but the performance may get affected, especially
    at the application launch time, as the QSS parsing may take time. You can choose
    the approach convenient to you or your organization. We have learned how to customize
    the GUI. Now, let's understand what widgets, windows, and dialogs are in the last
    section of this chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义样式可能难以实现，但可能更快速和更灵活。QSS易于学习和实现，但性能可能会受到影响，特别是在应用程序启动时，因为QSS解析可能需要时间。您可以选择适合您或您的组织的方法。我们已经学会了如何自定义GUI。现在，让我们在本章的最后一节中了解小部件、窗口和对话框是什么。
- en: Using widgets, windows, and dialogs
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用小部件、窗口和对话框
- en: A widget is a GUI element that can be displayed on the screen. This could include
    labels, push buttons, list views, windows, dialogs, and so on. All widgets display
    certain information to a user on the screen, and most of them allow user interactions
    through the keyboard or mouse.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是可以显示在屏幕上的GUI元素。这可能包括标签、按钮、列表视图、窗口、对话框等。所有小部件在屏幕上向用户显示某些信息，并且大多数允许用户通过键盘或鼠标进行交互。
- en: A window is a top-level widget that doesn't have another parent widget. Generally,
    windows have a title bar and border unless any window flags are specified. The
    window style and certain policies are determined by the underlying windowing system.
    Some of the common window classes in Qt are `QMainWindow`, `QMessageBox`, and
    `QDialog`. A main window usually follows a predefined layout for desktop applications
    that comprises a menu bar, a toolbar, a central widget area, and a status bar.
    `QMainWindow` requires a central widget even if it is just a placeholder. Other
    components can be removed in a main window. *Figure 3.22* illustrates the layout
    structure of `QMainWindow`. We typically call the `show()` method to display a
    widget or main window.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口是一个没有父窗口的顶级小部件。通常，窗口具有标题栏和边框，除非指定了任何窗口标志。窗口样式和某些策略由底层窗口系统确定。Qt中一些常见的窗口类包括`QMainWindow`、`QMessageBox`和`QDialog`。主窗口通常遵循桌面应用程序的预定义布局，包括菜单栏、工具栏、中央小部件区域和状态栏。`QMainWindow`即使只是一个占位符，也需要一个中央小部件。主窗口中的其他组件可以被移除。*图3.22*说明了`QMainWindow`的布局结构。我们通常调用`show()`方法来显示一个小部件或主窗口。
- en: '`QMenuBar` is present at the top of `QMainWindow`. You can add menu options
    such as `QMenuBar`, there is `QToolBar`. `QDockWidget` provides a widget that
    can be docked inside `QMainWindow` or floated as a top-level window. The central
    widget is the primary view area where you can add your form or child widgets.
    Create your own view area with child widgets and then call `setCentralWidget()`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMenuBar`位于`QMainWindow`的顶部。您可以添加诸如`QMenuBar`之类的菜单选项，还有`QToolBar`。`QDockWidget`提供了一个可以停靠在`QMainWindow`内或作为顶级窗口浮动的小部件。中央小部件是主要的视图区域，您可以在其中添加您的表单或子小部件。使用子小部件创建自己的视图区域，然后调用`setCentralWidget()`：'
- en: '![Figure 3.22 – QMainWindow layout'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.22 – QMainWindow布局'
- en: '](img/Figure_3.22_B16231.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.22_B16231.jpg)'
- en: Figure 3.22 – QMainWindow layout
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 – QMainWindow布局
- en: Important note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`QMainWindow` shouldn''t be confused with `QWindow`. `QWindow` is a convenient
    class that represents a window in the underlying windowing system. Usually, applications
    use `QWidget` or `QMainWindow` for their UI. However, it is possible to render
    directly to `QWindow`, if you want to keep minimal dependencies.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMainWindow`不应与`QWindow`混淆。`QWindow`是一个方便的类，表示底层窗口系统中的窗口。通常，应用程序使用`QWidget`或`QMainWindow`来构建UI。但是，如果您希望保持最小的依赖关系，也可以直接渲染到`QWindow`。'
- en: 'Dialogs are temporary windows that are used to provide notifications or receive
    user inputs and usually have `QMessageBox` is a type of dialog that is used to
    show information and alerts or to ask a question to the user. Typically, the `exec()`
    method is used to show a dialog. The dialog is shown as a modal dialog and is
    blocking in nature until the user closes it. A simple message box can be created
    with the following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框是用于提供通知或接收用户输入的临时窗口，通常具有`QMessageBox`是一种用于显示信息和警报或向用户提问的对话框类型。通常使用`exec()`方法来显示对话框。对话框显示为模态对话框，在用户关闭它之前是阻塞的。可以使用以下代码片段创建一个简单的消息框：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The takeaway is that all of these are widgets. Windows are the top-level widgets,
    and dialogs are a special kind of window.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是所有这些都是小部件。窗口是顶级小部件，对话框是一种特殊类型的窗口。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explained the fundamentals of the Qt Widgets module and how to
    create a custom UI. Here, you learned to design and build GUIs with Qt Designer.
    Traditional desktop applications are usually built with Qt Designer. Features
    such as custom widget plugins allow you to create and use your own widget collection
    with Qt Designer. We also discussed customizing the look and feel of your application
    with style sheets and styles, as well as looking at the uses of and differences
    between widgets, windows, and dialogs. Now, you can create a GUI application with
    your own custom widgets with extended functionalities and create your own themes
    for your desktop application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Qt Widgets模块的基础知识以及如何创建自定义UI。在这里，您学会了如何使用Qt Designer设计和构建GUI。传统的桌面应用程序通常使用Qt
    Designer构建。诸如自定义小部件插件之类的功能允许您在Qt Designer中创建和使用自己的小部件集合。我们还讨论了使用样式表和样式自定义应用程序的外观和感觉，以及查看小部件、窗口和对话框之间的用途和区别。现在，您可以使用自己的自定义小部件创建具有扩展功能的GUI应用程序，并为桌面应用程序创建自己的主题。
- en: In the next chapter, we will discuss `QtQuick` and QML. Here, you will learn
    about `QtQuick` controls, Qt Quick Designer, and how to build a custom QML application.
    We will also discuss an alternate option of using Qt Quick for GUI design rather
    than widgets.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论`QtQuick`和QML。在这里，您将学习关于`QtQuick`控件、Qt Quick Designer以及如何构建自定义QML应用程序。我们还将讨论使用Qt
    Quick而不是小部件进行GUI设计的另一种选择。
