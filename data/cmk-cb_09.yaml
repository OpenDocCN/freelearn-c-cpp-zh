- en: The Superbuild Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级构建模式
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using the superbuild pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用超级构建模式
- en: 'Managing dependencies with a superbuild: I. The Boost libraries'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用超级构建管理依赖：I. Boost库
- en: 'Managing dependencies with a superbuild: II. The FFTW library'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用超级构建管理依赖：II. FFTW库
- en: 'Managing dependencies with a superbuild: III. The Google Test framework'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用超级构建管理依赖：III. Google Test框架
- en: Managing your project as a superbuild
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目作为超级构建进行管理
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'Every project has to deal with dependencies and CMake makes it relatively easy
    to find out whether these dependencies are present on the system where we configure
    our project. [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, showed how to find dependencies installed on
    the system and we have used that same pattern so far. However, if dependencies
    are not satisfied, the most we can achieve is fail the configuration and alert
    the user of the reasons for such a failure. However, with CMake it is possible
    to organize our projects such that dependencies can be automatically fetched and
    built if they are not found on the system. This chapter will present and analyze
    the `ExternalProject.cmake` and `FetchContent.cmake` standard modules and their
    use in the *superbuild pattern*. The former allows us to retrieve the dependencies
    of our project at *build time* and has been a part of CMake for a long time. The
    latter module was added in version 3.11 of CMake and allows us to retrieve dependencies
    at *configure time*. With the superbuild pattern, we can effectively leverage
    CMake as an advanced package manager: within your project you will handle dependencies
    in the same manner, whether already available on the system or whether they need
    to be built from scratch. The next five recipes will walk you through the pattern
    and show how it can be used to fetch and build virtually any dependency.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都必须处理依赖关系，而CMake使得在配置项目的系统上查找这些依赖关系变得相对容易。[第3章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*，展示了如何在系统上找到已安装的依赖项，并且到目前为止我们一直使用相同的模式。然而，如果依赖关系未得到满足，我们最多只能导致配置失败并告知用户失败的原因。但是，使用CMake，我们可以组织项目，以便在系统上找不到依赖项时自动获取和构建它们。本章将介绍和分析`ExternalProject.cmake`和`FetchContent.cmake`标准模块以及它们在*超级构建模式*中的使用。前者允许我们在*构建时间*获取项目的依赖项，并且长期以来一直是CMake的一部分。后者模块是在CMake
    3.11版本中添加的，允许我们在*配置时间*获取依赖项。通过超级构建模式，我们可以有效地利用CMake作为高级包管理器：在您的项目中，您将以相同的方式处理依赖项，无论它们是否已经在系统上可用，或者它们是否需要从头开始构建。接下来的五个示例将引导您了解该模式，并展示如何使用它来获取和构建几乎任何依赖项。
- en: Both modules are extensively documented online. For `ExternalProject.cmake`,
    we refer the reader to [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html).
    For `FetchContent.cmake`, we refer the reader to [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模块都在网上有详尽的文档。对于`ExternalProject.cmake`，我们建议读者参考[https://cmake.org/cmake/help/v3.5/module/ExternalProject.html](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html)。对于`FetchContent.cmake`，我们建议读者参考[https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html)。
- en: Using the superbuild pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超级构建模式
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-01) and
    has a C++ example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-01)找到，并包含一个C++示例。该示例适用于CMake
    3.5（及以上）版本，并在GNU/Linux、macOS和Windows上进行了测试。
- en: This recipe will introduce the superbuild pattern with a very simple example.
    We will show how to use the `ExternalProject_Add` command to build a simple "Hello,
    World" program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将通过一个非常简单的示例介绍超级构建模式。我们将展示如何使用`ExternalProject_Add`命令来构建一个简单的“Hello, World”程序。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe will build the "Hello, World" executable from the following source
    code (`hello-world.cpp`):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将构建以下源代码（`hello-world.cpp`）中的“Hello, World”可执行文件：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The project is structured as follows, with a root `CMakeLists.txt`, and a `src/CMakeLists.txt`
    file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构如下，包含一个根目录`CMakeLists.txt`和一个`src/CMakeLists.txt`文件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us first look at `CMakeLists.txt` in the root folder:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看一下根文件夹中的`CMakeLists.txt`：
- en: 'We declare a C++11 project, with a minimum required CMake version:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个C++11项目，并指定最低要求的CMake版本：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We set the `EP_BASE` directory property for the current and any underlying
    directories. This will be discussed shortly:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为当前和任何底层目录设置`EP_BASE`目录属性。这将在稍后讨论：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We include the `ExternalProject.cmake` standard module. This module provides
    the `ExternalProject_Add` function:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含`ExternalProject.cmake`标准模块。该模块提供了`ExternalProject_Add`函数：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The source code for our "Hello, World" example is added as an external project
    by invoking the `ExternalProject_Add` function. The name of the external project
    is `recipe-01_core`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`ExternalProject_Add`函数，将我们的“Hello, World”示例的源代码作为外部项目添加。外部项目的名称为`recipe-01_core`：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We set the source directory for the external project using the `SOURCE_DIR`
    option:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`SOURCE_DIR`选项设置外部项目的源目录：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `src` subdirectory contains a full-fledged CMake project. To configure
    and build it, we pass the appropriate CMake options to the external project *via*
    the `CMAKE_ARGS` option. In our case, we only need to pass the C++ compiler and
    the requirements for the C++ standard:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`src`子目录包含一个完整的CMake项目。为了配置和构建它，我们通过`CMAKE_ARGS`选项将适当的CMake选项传递给外部项目。在我们的情况下，我们只需要传递C++编译器和对C++标准的要求：'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also set the C++ compiler flags. These are passed using the `CMAKE_CACHE_ARGS`
    option to the `ExternalProject_Add` command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还设置了C++编译器标志。这些标志通过`CMAKE_CACHE_ARGS`选项传递给`ExternalProject_Add`命令：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We configure the external project so that it is always built:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们配置外部项目，使其始终处于构建状态：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The install step will not execute any actions (we will revisit installation
    in Recipe 4, *Installing a superbuild*, in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer):*
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装步骤不会执行任何操作（我们将在第4个配方中重新讨论安装，即“编写安装程序”中的“安装超级构建”）：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us now move on to `src/CMakeLists.txt`. Since we are adding our "Hello,
    World" sources as an external project, this is a full-fledged `CMakeLists.txt`
    file for a standalone project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向`src/CMakeLists.txt`。由于我们将“Hello, World”源代码作为外部项目添加，这是一个完整的`CMakeLists.txt`文件，用于独立项目：
- en: 'Also, here we declare a minimum required CMake version:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，这里我们声明了最低要求的CMake版本：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We declare a C++ project:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个C++项目：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we add an executable target, `hello-world`, from the `hello-world.cpp`
    source file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从`hello-world.cpp`源文件添加一个可执行目标，即`hello-world`：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Configuring and building our project is done as usual:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 配置和构建我们的项目按照常规方式进行：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The structure of the build directory is now slightly more complex. In particular,
    we notice the `subprojects` folder with the following contents:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 构建目录的结构现在稍微复杂一些。特别是，我们注意到`subprojects`文件夹及其内容：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`recipe-01_core` has been built into a subdirectory of `build/subprojects`, called
    `Build/recipe-01_core`, which is the `EP_BASE` we have set.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`recipe-01_core`已构建到`build/subprojects`的子目录中，称为`Build/recipe-01_core`，这是我们设置的`EP_BASE`。'
- en: The `hello-world` executable has been created under `Build/recipe-01_core`.
    The additional subfolders `tmp/recipe-01_core` and `Stamp/recipe-01_core` contain
    temporary files, such as the CMake cache script `recipe-01_core-cache-.cmake`,
    and the stamp files for the various steps CMake has performed to build the external
    project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello-world`可执行文件已在`Build/recipe-01_core`下创建。额外的子文件夹`tmp/recipe-01_core`和`Stamp/recipe-01_core`包含临时文件，例如CMake缓存脚本`recipe-01_core-cache-.cmake`，以及CMake为构建外部项目执行的各种步骤的标记文件。'
- en: How it works
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The `ExternalProject_Add` command can be used to add sources from third parties.
    Our first example, however, shows how to manage our own project as an assembly
    of different CMake projects. In this example, both the root and the leaf `CMakeLists.txt`
    declared a CMake project, that is, both of them used the `project` command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject_Add`命令可用于添加第三方源代码。然而，我们的第一个示例展示了如何将我们自己的项目作为不同CMake项目的集合来管理。在这个示例中，根目录和叶目录的`CMakeLists.txt`都声明了一个CMake项目，即它们都使用了`project`命令。'
- en: '`ExternalProject_Add` has many options that can be used to fine-tune all aspects
    of the configuration and compilation of external projects. These options can be
    classified into the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject_Add`有许多选项，可用于微调外部项目的配置和编译的所有方面。这些选项可以分为以下几类：'
- en: '**Directory** options: These are used to tune the structure of the source and
    build directories for the external project. In our case, we used the `SOURCE_DIR`
    option to let CMake know that the sources are available in the `${CMAKE_CURRENT_LIST_DIR}/src`
    folder and thus should not be fetched from somewhere else. The directories for
    building the project and storing temporary files can also be specified in this
    class of options or as directory properties. We have followed the latter route
    by setting the `EP_BASE` directory property. CMake will set up all directories
    for the various subprojects with the following layout:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**选项：这些用于调整外部项目的源代码和构建目录的结构。在我们的例子中，我们使用了 `SOURCE_DIR` 选项让 CMake 知道源代码可在
    `${CMAKE_CURRENT_LIST_DIR}/src` 文件夹中找到，因此不应从其他地方获取。构建项目和存储临时文件的目录也可以在此类选项中指定，或者作为目录属性指定。我们通过设置
    `EP_BASE` 目录属性遵循了后者的方式。CMake 将为各种子项目设置所有目录，布局如下：'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Download** options: The code for the external project might have to be downloaded
    from an online repository or resource. Options in this class let you control all
    aspects of this step.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载**选项：外部项目的代码可能需要从在线存储库或资源下载。此类选项允许您控制此步骤的所有方面。'
- en: '**Update** and **Patch** options: This class of options can be used to define
    how to update the sources for the external project or how to apply patches.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**和**补丁**选项：这类选项可用于定义如何更新外部项目的源代码或如何应用补丁。'
- en: '**Configure** options: By default, CMake assumes that the external project
    is itself configured using CMake. As the following recipes will show, we are however
    not limited to this case. If the external project is a CMake project, `ExternalProject_Add`
    will call the CMake executable and pass options to it. For our current example,
    we passed configuration arguments *via* the `CMAKE_ARGS` and `CMAKE_CACHE_ARGS`
    options. The former are passed directly as a command line argument, whereas the
    latter are passed *via* a CMake script file. In our example, the script file is
    in `build/subprojects/tmp/recipe-01_core/recipe-01_core-cache-.cmake`. The configuration
    would then look like this example:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**选项：默认情况下，CMake 假设外部项目本身使用 CMake 进行配置。然而，正如后续章节将展示的，我们并不局限于这种情况。如果外部项目是
    CMake 项目，`ExternalProject_Add` 将调用 CMake 可执行文件并传递选项给它。对于我们当前的示例，我们通过 `CMAKE_ARGS`
    和 `CMAKE_CACHE_ARGS` 选项传递配置参数。前者直接作为命令行参数传递，而后者通过 CMake 脚本文件传递。在我们的示例中，脚本文件位于
    `build/subprojects/tmp/recipe-01_core/recipe-01_core-cache-.cmake`。配置将如下所示：'
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Build** options: This class of options can be used to tweak the actual compilation
    of the external project. Our example used the `BUILD_ALWAYS` option to ensure
    that the external project is always freshly built.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**选项：这类选项可用于调整外部项目的实际编译。我们的示例使用了 `BUILD_ALWAYS` 选项以确保外部项目总是被新鲜构建。'
- en: '**Install** options: These are options to configure how the external project
    should be installed. Our example left `INSTALL_COMMAND` empty and we will discuss
    installation with CMake in more detail in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer*.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装**选项：这些是配置外部项目应如何安装的选项。我们的示例将 `INSTALL_COMMAND` 留空，我们将在 [第10章](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml)，*编写安装程序*中更详细地讨论使用
    CMake 进行安装。'
- en: '**Test** options: It is always a good idea to run tests for any piece of software
    that is built from sources. This class of options to `ExternalProject_Add` is
    here for this purpose. Our example did not use these options, as the "Hello, World"
    example didn''t have any tests, but in Recipe 5, *Managing your project as a superbuild*,
    we will trigger a test step.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**选项：对于从源代码构建的任何软件，运行测试总是一个好主意。`ExternalProject_Add` 的这类选项就是为了这个目的。我们的示例没有使用这些选项，因为“Hello,
    World”示例没有任何测试，但在第5章，*将您的项目作为超级构建管理*中，我们将触发测试步骤。'
- en: '`ExternalProject.cmake` defines the command `ExternalProject_Get_Property`
    which, as the name suggests, is useful to retrieve properties of external projects.
    The properties on external projects are set when first invoking the `ExternalProject_Add`
    command. For example, retrieving the arguments to be passed to CMake when configuring
    `recipe-01_core` can be achieved with:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject.cmake` 定义了命令 `ExternalProject_Get_Property`，顾名思义，这对于检索外部项目的属性非常有用。外部项目的属性在首次调用
    `ExternalProject_Add` 命令时设置。例如，检索配置 `recipe-01_core` 时传递给 CMake 的参数可以通过以下方式实现：'
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The complete list of options to `ExternalProject_Add` can be found in the CMake
    documentation: [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject_Add`的完整选项列表可以在CMake文档中找到：[https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add)'
- en: There is more
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'We will explore in detail the flexibility of the `ExternalProject_Add` command
    in the following recipes. Sometimes, however, the external project we want to
    use might require additional, non-standard steps to be performed. For this reason,
    the `ExternalProject.cmake` module defines the following additional commands:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下配方中详细探讨`ExternalProject_Add`命令的灵活性。然而，有时我们想要使用的外部项目可能需要执行额外的、非标准的步骤。为此，`ExternalProject.cmake`模块定义了以下附加命令：
- en: '`ExternalProject_Add_Step`. Once an external project has been added, this command
    allows to latch additional commands on it as custom steps. See also: [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_step](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_step)'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExternalProject_Add_Step`。一旦添加了外部项目，此命令允许将附加命令作为自定义步骤附加到该项目上。另请参见：[https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_step](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_step)'
- en: '`ExternalProject_Add_StepTargets`. Lets you define steps, for example the build
    and test steps, in any external project as separate targets. This means that one
    can trigger these steps separately from the full external project and allows fine-grained
    control over complex dependencies within your project. See also: [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_steptargets](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_steptargets)'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExternalProject_Add_StepTargets`。它允许您在任何外部项目中定义步骤，例如构建和测试步骤，作为单独的目标。这意味着可以从完整的外部项目中单独触发这些步骤，并允许对项目内的复杂依赖关系进行精细控制。另请参见：[https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_steptargets](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_steptargets)'
- en: '`ExternalProject_Add_StepDependencies`. Sometimes steps for an external project
    might depend on targets outside it and this command is designed to take care of
    these cases. See also: [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_stepdependencies](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_stepdependencies)'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExternalProject_Add_StepDependencies`。有时外部项目的步骤可能依赖于项目之外的目标，此命令旨在处理这些情况。另请参见：[https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_stepdependencies](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_stepdependencies)'
- en: 'Managing dependencies with a superbuild: I. The Boost libraries'
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超级构建管理依赖项：I. Boost库
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-02) and
    has a C++ example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows with MSYS Makefiles and Ninja.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-02) 获取，并包含一个C++示例。该配方适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS、Windows（使用MSYS
    Makefiles和Ninja）上进行了测试。
- en: 'The Boost libraries provide a rich C++ programming infrastructure and are popular
    among C++ developers. We have already shown how to find the Boost libraries on
    our system in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*. Sometimes, however, the version of Boost required
    by your project might not be available on the system. This recipe will show how
    to leverage the superbuild pattern to ship your code with the confidence that
    a missing dependency will not stop the configuration. We will reuse the code example
    from Recipe 8, *Detecting the Boost libraries*, in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml),
    *Detecting External Libraries and Programs*, but reorganize it in the form of
    a superbuild. This will be the layout of the project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Boost库提供了丰富的C++编程基础设施，并且受到C++开发者的欢迎。我们已经在[第三章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*中展示了如何在系统上找到Boost库。然而，有时您的项目所需的Boost版本可能不在系统上。本食谱将展示如何利用超级构建模式来确保缺少的依赖不会阻止配置。我们将重用来自[第三章](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml)，*检测外部库和程序*中第8个食谱，*检测Boost库*的代码示例，但将其重新组织为超级构建的形式。这将是项目的布局：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will notice that there are four `CMakeLists.txt` files in the project source
    tree. The following section will walk you through these.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到项目源代码树中有四个`CMakeLists.txt`文件。以下部分将引导您了解这些文件。
- en: How to do it
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We will begin with the root `CMakeLists.txt`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从根`CMakeLists.txt`开始：
- en: 'We declare a C++11 project as usual:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样声明一个C++11项目：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We set the `EP_BASE` directory property:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置`EP_BASE`目录属性：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We set the `STAGED_INSTALL_PREFIX` variable. This directory will be used to
    install the dependencies within our build tree:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置`STAGED_INSTALL_PREFIX`变量。该目录将用于在我们的构建树中安装依赖项：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our project needs the filesystem and system components of the Boost libraries.
    We declare a list variable to hold this information and also set the minimum required
    version of Boost:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的项目需要Boost库的文件系统和系统组件。我们声明一个列表变量来保存此信息，并设置所需的最小Boost版本：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We add the `external/upstream` subdirectory, which will in turn add the `external/upstream/boost`
    subdirectory:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加`external/upstream`子目录，它将依次添加`external/upstream/boost`子目录：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we include the `ExternalProject.cmake` standard CMake module. This defines,
    among others, the `ExternalProject_Add` command, which is the key to orchestrating
    superbuilds:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们包含`ExternalProject.cmake`标准CMake模块。这定义了，除其他外，`ExternalProject_Add`命令，这是协调超级构建的关键：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our project resides under the `src` subdirectory and we add it as an external
    project. We pass CMake options using `CMAKE_ARGS` and `CMAKE_CACHE_ARGS`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的项目位于`src`子目录下，并将其作为外部项目添加。我们使用`CMAKE_ARGS`和`CMAKE_CACHE_ARGS`传递CMake选项：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let us now look at the `CMakeLists.txt` in `external/upstream`. This file simply
    adds the `boost` folder as an additional directory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`external/upstream`中的`CMakeLists.txt`文件。该文件只是将`boost`文件夹添加为附加目录：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `CMakeLists.txt` in `external/upstream/boost` describes the operations
    needed to satisfy the dependency on Boost. Our goal is simple, if the desired
    version is not installed, download the source archive and build it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`external/upstream/boost`中的`CMakeLists.txt`描述了满足对Boost依赖所需的操作。我们的目标很简单，如果所需版本未安装，下载源代码存档并构建它：'
- en: 'First of all, we attempt to find the Boost components needed for the minimum
    required version:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们尝试找到所需的最小版本的Boost组件：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If these are found, we add an interface library, `boost_external`. This is
    a dummy target, needed to properly handle build order in our superbuild:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到这些选项，我们会添加一个接口库，`boost_external`。这是一个虚拟目标，用于在我们的超级构建中正确处理构建顺序：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If `find_package` was not successful or we are forcing the superbuild, we need
    to set up a local build of Boost and for this, we enter the else-section of the
    previous conditional:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`find_package`不成功或者我们强制进行超级构建，我们需要设置一个本地的Boost构建，为此，我们进入前一个条件语句的else部分：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since these libraries do not use CMake, we need to prepare the arguments for
    their native build toolchain. First, we set the compiler to be used for Boost:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这些库不使用CMake，我们需要为它们的原生构建工具链准备参数。首先，我们设置要使用的编译器：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We prepare the list of libraries to be built based on the required components.
    We define some list variables: `_build_byproducts`, to contain the absolute path
    to the libraries that will be built; `_b2_select_libraries`, to contain the list
    of libraries we want to build; and `_bootstrap_select_libraries`, which is a string
    with the same contents in a different format:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据所需组件准备要构建的库列表。我们定义了一些列表变量：`_build_byproducts`，用于包含将要构建的库的绝对路径；`_b2_select_libraries`，用于包含我们想要构建的库列表；以及`_bootstrap_select_libraries`，这是一个内容相同但格式不同的字符串：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now add the Boost project as an external project. First of all, we specify
    the download URL and the checksum in the **Download** options class. `DOWNLOAD_NO_PROGRESS`
    is set to `1` to suppress printing download progress information:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将Boost项目作为外部项目添加。首先，我们在**下载**选项类中指定下载URL和校验和。将`DOWNLOAD_NO_PROGRESS`设置为`1`以抑制打印下载进度信息：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we set **Update/Patch** and **Configure** options:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置**更新/修补**和**配置**选项：
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The Build options are set using the `BUILD_COMMAND` directive. `BUILD_IN_SOURCE`
    is set to `1` to signal that building will happen within the source directory.
    Moreover, we set `LOG_BUILD` to `1` to log ouput from the build script to a file:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BUILD_COMMAND`指令设置构建选项。将`BUILD_IN_SOURCE`设置为`1`以指示构建将在源目录内发生。此外，我们将`LOG_BUILD`设置为`1`以将构建脚本的输出记录到文件中：
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The Install options are set using the `INSTALL_COMMAND` directive. Note the
    use of the `LOG_INSTALL` option to also log the install step to file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`INSTALL_COMMAND`指令设置安装选项。注意使用`LOG_INSTALL`选项也将安装步骤记录到文件中：
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we list our libraries as `BUILD_BYPRODUCTS` and close the `ExternalProject_Add`
    command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将我们的库列为`BUILD_BYPRODUCTS`并关闭`ExternalProject_Add`命令：
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We set some variables useful for directing the detection of the newly installed
    Boost:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了一些对指导新安装的Boost检测有用的变量：
- en: '[PRE39]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The final action performed in the else-branch of the conditional is to unset
    all internal variables:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在条件分支的最后执行的操作是取消设置所有内部变量：
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, let us look at `src/CMakeLists.txt`. This file describes a standalone
    project:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`src/CMakeLists.txt`。该文件描述了一个独立项目：
- en: 'We declare a C++ project:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个C++项目：
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The project depends on Boost and we invoke `find_package`. The configuration
    of the project from the root `CMakeLists.txt` guarantees that the dependency is
    always satisfied, either by using Boost pre-installed on the system or the ones
    we built as a subproject:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目依赖于Boost，我们调用`find_package`。从根目录的`CMakeLists.txt`配置项目保证了依赖项始终得到满足，无论是使用系统上预装的Boost还是我们作为子项目构建的Boost：
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We add our example executable target, describing its link libraries:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加我们的示例可执行目标，描述其链接库：
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The use of imported targets, while neat, is not guaranteed to work for arbitrary
    Boost and CMake version combinations. This is because the CMake `FindBoost.cmake`
    module creates the imported targets by hand, so if the Boost version was unknown
    at the time of the CMake release, there will be `Boost_LIBRARIES` and `Boost_INCLUDE_DIRS`,
    but no imported targets (see also [https://stackoverflow.com/questions/42123509/cmake-finds-boost-but-the-imported-targets-not-available-for-boost-version](https://stackoverflow.com/questions/42123509/cmake-finds-boost-but-the-imported-targets-not-available-for-boost-version)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然导入目标的使用很整洁，但并不能保证对任意Boost和CMake版本组合都能正常工作。这是因为CMake的`FindBoost.cmake`模块手动创建了导入目标，所以如果CMake发布时不知道Boost版本，将会有`Boost_LIBRARIES`和`Boost_INCLUDE_DIRS`，但没有导入目标（另请参见[https://stackoverflow.com/questions/42123509/cmake-finds-boost-but-the-imported-targets-not-available-for-boost-version](https://stackoverflow.com/questions/42123509/cmake-finds-boost-but-the-imported-targets-not-available-for-boost-version)）。
- en: How it works
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'This recipe shows how the superbuild pattern can be harnessed to muster the
    dependencies of your project. Let us take another look at the layout of the project:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了如何利用超级构建模式来集结项目的依赖项。让我们再次审视项目的布局：
- en: '[PRE44]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have introduced four `CMakeLists.txt` files in the project source tree:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目源树中引入了四个`CMakeLists.txt`文件：
- en: The root `CMakeLists.txt` will coordinate the superbuild.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根目录的`CMakeLists.txt`将协调超级构建。
- en: The file in `external/upstream` will lead us to the `boost` leaf directory.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位于`external/upstream`的文件将引导我们到`boost`叶目录。
- en: '`external/upstream/boost/CMakeLists.txt` will take care of the Boost dependency.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`external/upstream/boost/CMakeLists.txt`将负责处理Boost依赖项。'
- en: Finally, the `CMakeLists.txt` under `src` will build our example code, which
    depends on Boost.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，位于`src`下的`CMakeLists.txt`将构建我们的示例代码，该代码依赖于Boost。
- en: 'Let us start start the discussion with the `external/upstream/boost/CMakeLists.txt`
    file. Boost uses its own build system and hence we need to be slightly more verbose
    in our `ExternalProject_Add` to get everything set up correctly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`external/upstream/boost/CMakeLists.txt`文件开始讨论。Boost使用自己的构建系统，因此我们需要在`ExternalProject_Add`中稍微详细一些，以确保一切正确设置：
- en: We keep the default values for the **Directory** options.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们保留**目录**选项的默认值。
- en: The **Download** step will download an archive of the desired version of Boost
    from their online server. We therefore set up the `URL` and the `URL_HASH`. The
    latter is needed to check the integrity of the downloaded archive. Since we do
    not wish to see a progress report of the download, we also set the `DOWNLOAD_NO_PROGRESS`
    option to true.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载**步骤将从Boost的在线服务器下载所需版本的存档。因此，我们设置了`URL`和`URL_HASH`。后者用于检查下载存档的完整性。由于我们不希望看到下载的进度报告，我们还设置了`DOWNLOAD_NO_PROGRESS`选项为true。'
- en: The **Update** step is left blank. If anything needs rebuilding, we do not want
    to download Boost once again.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新**步骤留空。如果需要重新构建，我们不希望再次下载Boost。'
- en: 'The **Configure** step will use the native configuration tool provided by Boost
    in `CONFIGURE_COMMAND`. Since we want the superbuild to be cross-platform, we
    use the `<SOURCE_DIR>` variable to refer to the location for the unpacked sources:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置**步骤将使用Boost提供的本地配置工具，在`CONFIGURE_COMMAND`中。由于我们希望超级构建是跨平台的，我们使用`<SOURCE_DIR>`变量来引用解压源代码的位置：'
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The **Build** options declare an *in-source* build, by setting the `BUILD_IN_SOURCE`
    option to true. `BUILD_COMMAND` uses the Boost native build tool, `b2`. Since
    we will be doing an in-source build, we use again the `<SOURCE_DIR>` variable
    to refer to the location of the unpacked sources.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建**选项声明了一个*源码内*构建，通过将`BUILD_IN_SOURCE`选项设置为true。`BUILD_COMMAND`使用Boost的本地构建工具`b2`。由于我们将进行源码内构建，我们再次使用`<SOURCE_DIR>`变量来引用解压源代码的位置。'
- en: We then move on to the **Install** options. Boost manages installation using
    the same native build tool. In fact, the build and installation commands could
    easily be collapsed into one.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们转向**安装**选项。Boost使用相同的本地构建工具进行管理。实际上，构建和安装命令可以很容易地合并为一个。
- en: The **Output** logging options `LOG_BUILD` and `LOG_INSTALL` direct `ExternalProject_Add`
    to write log files for the build and installation operations, instead of outputting
    to screen.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**输出**日志选项`LOG_BUILD`和`LOG_INSTALL`指示`ExternalProject_Add`为构建和安装操作编写日志文件，而不是输出到屏幕。'
- en: Finally, the `BUILD_BYPRODUCTS` option lets `ExternalProject_Add` keep track
    of the freshly built Boost libraries in subsequent builds, even though their modification
    times might not get updated.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`BUILD_BYPRODUCTS`选项允许`ExternalProject_Add`在后续构建中跟踪新近构建的Boost库，即使它们的修改时间可能不会更新。
- en: 'Once Boost has been built, the `${STAGED_INSTALL_PREFIX}/boost` folder in the
    build directory will contain our desired libraries. We need to pass this information
    down to our project, whose build system is generated in `src/CMakeLists.txt`.
    To achieve this goal, we pass two additional `CMAKE_CACHE_ARGS` in the `ExternalProject_Add`
    in the root `CMakeLists.txt`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Boost构建完成后，构建目录中的`${STAGED_INSTALL_PREFIX}/boost`文件夹将包含我们所需的库。我们需要将此信息传递给我们的项目，其构建系统在`src/CMakeLists.txt`中生成。为了实现这一目标，我们在根`CMakeLists.txt`中的`ExternalProject_Add`中传递两个额外的`CMAKE_CACHE_ARGS`：
- en: '`CMAKE_INCLUDE_PATH`: The path where CMake will look for C/C++ headers'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMAKE_INCLUDE_PATH`：CMake查找C/C++头文件的路径'
- en: '`CMAKE_LIBRARY_PATH`: The path where CMake will look for libraries'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMAKE_LIBRARY_PATH`：CMake查找库的路径'
- en: By setting these variables to our freshly built installation of Boost, we ensure
    that the dependency will be properly picked up.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些变量设置为我们新近构建的Boost安装，我们确保依赖项将被正确地检测到。
- en: 'Setting the `CMAKE_DISABLE_FIND_PACKAGE_Boost` to `ON` when configuring the
    project will skip detection of the Boost libraries and always perform the superbuild.
    See the documentation: [https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置项目时将`CMAKE_DISABLE_FIND_PACKAGE_Boost`设置为`ON`，将跳过Boost库的检测并始终执行超级构建。请参阅文档：[https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html)
- en: 'Managing dependencies with a superbuild: II. The FFTW library'
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超级构建管理依赖项：II. FFTW库
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-03) and
    has a C example. The recipe is valid with CMake version 3.5 (and higher) and has
    been tested on GNU/Linux, macOS, and Windows.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-03)找到，并包含一个C语言示例。该示例适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: The superbuild pattern can be used to manage fairly complex dependencies, for
    projects in all the languages supported by CMake. As demonstrated in the previous
    recipe, it is not necessary for the various subprojects to managed by CMake as
    well. In contrast to the previous recipe, the external subproject in this recipe
    will be a CMake project and will show how to download, build, and install the
    FFTW library using a superbuild. FFTW is a Fast Fourier Transform library, freely
    available at [http://www.fftw.org.](http://www.fftw.org/)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 超级构建模式可用于管理CMake支持的所有语言项目的相当复杂的依赖关系。如前一示例所示，各个子项目并非必须由CMake管理。与前一示例相反，本示例中的外部子项目将是一个CMake项目，并将展示如何使用超级构建下载、构建和安装FFTW库。FFTW是一个快速傅里叶变换库，可免费在[http://www.fftw.org](http://www.fftw.org/)获取。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The directory layout for this recipe shows the now familiar structure for a
    superbuild:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的目录布局展示了超级构建的熟悉结构：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The code for our project, `fftw_example.c`, is located in the `src` subdirectory
    and will calculate the Fourier transform of a function defined in the source code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的代码`fftw_example.c`位于`src`子目录中，并将计算源代码中定义的函数的傅里叶变换。
- en: How to do it
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us start from the root `CMakeLists.txt`. This file puts together the whole
    superbuild process:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从根`CMakeLists.txt`开始。此文件组合了整个超级构建过程：
- en: 'We declare a C99 project:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个C99项目：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As in the previous recipe, we set the `EP_BASE` directory property and the
    staging installation prefix:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前一示例一样，我们设置`EP_BASE`目录属性和暂存安装前缀：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The dependency on FFTW is checked in the `external/upstream` subdirectory and
    we proceed to add this subdirectory to the build system:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FFTW的依赖关系在`external/upstream`子目录中进行检查，我们继续将此子目录添加到构建系统中：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We include the `ExternalProject.cmake` module:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含`ExternalProject.cmake`模块：
- en: '[PRE50]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We declare the `recipe-03_core` external project. The sources for this project
    are in the `${CMAKE_CURRENT_LIST_DIR}/src` folder. The project is set up to pick
    the correct FFTW library using the `FFTW3_DIR` option:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明`recipe-03_core`外部项目。该项目的源代码位于`${CMAKE_CURRENT_LIST_DIR}/src`文件夹中。该项目设置为使用`FFTW3_DIR`选项选择正确的FFTW库：
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `external/upstream` subdirectory also contains a `CMakeLists.txt`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`external/upstream`子目录中还包含一个`CMakeLists.txt`：
- en: 'In this file, we add the `fftw3` folder as another subdirectory in the build
    system:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，我们将`fftw3`文件夹添加为构建系统中的另一个子目录：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `CMakeLists.txt` in `external/upstream/fftw3` takes care of our dependencies:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`external/upstream/fftw3`中的`CMakeLists.txt`负责我们的依赖关系：'
- en: 'First, we attempt to find the FFTW3 library on the system. Note that we used
    the `CONFIG` argument to `find_package`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们尝试在系统上查找FFTW3库。请注意，我们使用了`find_package`的`CONFIG`参数：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If the library was found we can use the imported target, `FFTW3::fftw3`, to
    link against it. We print a message to our users showing where the library is
    located. We add a dummy `INTERFACE` library, `fftw3_external`. This is needed
    to properly fix dependency trees between subprojects in the superbuild:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了库，我们可以使用导入的目标`FFTW3::fftw3`与之链接。我们向用户打印一条消息，显示库的位置。我们添加一个虚拟的`INTERFACE`库`fftw3_external`。这在超级构建中子项目之间的依赖树正确修复时是必需的：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If CMake was unable to locate a pre-installed version of FFTW, we enter the
    else-branch of the conditional, in which we download, build, and install it using
    `ExternalProject_Add`. The name of the external project is `fftw3_external`. The `fftw3_external` project
    will be downloaded from the official online archive. The integrity of the download
    will be checked using the MD5 checksum:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果CMake无法找到预安装的FFTW版本，我们进入条件语句的else分支，在其中我们使用`ExternalProject_Add`下载、构建和安装它。外部项目的名称为`fftw3_external`。`fftw3_external`项目将从官方在线档案下载。下载的完整性将使用MD5校验和进行检查：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We disable progress printing for the download and define the update command
    to be empty:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们禁用下载的进度打印，并将更新命令定义为空：
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Configuration, building, and installation output will be logged to a file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置、构建和安装输出将被记录到文件中：
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We set the installation prefix for the `fftw3_external` project to the `STAGED_INSTALL_PREFIX`
    directory previously defined and turn off building the test suite for FFTW3:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`fftw3_external`项目的安装前缀设置为之前定义的`STAGED_INSTALL_PREFIX`目录，并关闭FFTW3的测试套件构建：
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we are building on Windows, we set the `WITH_OUR_MALLOC` preprocessor option by
    means of a generator expression and close the `ExternalProject_Add` command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在Windows上构建，我们通过生成表达式设置`WITH_OUR_MALLOC`预处理器选项，并关闭`ExternalProject_Add`命令：
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we define the `FFTW3_DIR` variable and cache it. This variable will
    be used by CMake as a search directory for the exported `FFTW3::fftw3` target:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了`FFTW3_DIR`变量并将其缓存。该变量将由CMake用作导出的`FFTW3::fftw3`目标的搜索目录：
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `CMakeLists.txt` in the `src` folder is fairly compact:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`src`文件夹中的`CMakeLists.txt`文件相当简洁：
- en: 'Also in this file, we declare a C project:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样在这个文件中，我们声明了一个C项目：
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We call `find_package` to detect the FFTW library. Once again, we are using
    the `CONFIG` detection mode:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`find_package`来检测FFTW库。再次使用`CONFIG`检测模式：
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We add the `fftw_example.c` source file to the executable target `fftw_example`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`fftw_example.c`源文件添加到可执行目标`fftw_example`中：
- en: '[PRE63]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We set link libraries for our executable target:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为目标可执行文件设置链接库：
- en: '[PRE64]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: This recipe demonstrated how to download, build, and install an external project
    whose build system is managed by CMake. In contrast to the previous recipe, where
    a custom build system had to be used, this superbuild setup is rather compact.
    It is important to note the use of the `CONFIG` option to the `find_package` command;
    this tells CMake to first look for a `FFTW3Config.cmake` file in order to locate
    the FFTW3 library. Such a file exports the library as a target to be picked up
    by third-party projects. The target contains the version, configuration, and location
    of the library, that is, complete information on how the target was configured
    and built. In case the library is not installed on the system, we need to tell
    CMake where the `FFTW3Config.cmake` file is located. This can be done by setting
    the `FFTW3_DIR` variable. This was the very last step in the `external/upstream/fftw3/CMakeLists.txt`
    file, where, by using the `GNUInstallDirs.cmake` module, we set `FFTW3_DIR` as
    a cache variable to be picked up later on in the superbuild.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了如何下载、构建和安装由CMake管理的构建系统的外部项目。与之前的示例不同，那里必须使用自定义构建系统，这种超级构建设置相对简洁。值得注意的是，`find_package`命令使用了`CONFIG`选项；这告诉CMake首先查找`FFTW3Config.cmake`文件以定位FFTW3库。这样的文件将库作为目标导出，供第三方项目使用。目标包含版本、配置和库的位置，即有关目标如何配置和构建的完整信息。如果系统上未安装该库，我们需要告诉CMake`FFTW3Config.cmake`文件的位置。这可以通过设置`FFTW3_DIR`变量来完成。这是在`external/upstream/fftw3/CMakeLists.txt`文件的最后一步，通过使用`GNUInstallDirs.cmake`模块，我们将`FFTW3_DIR`设置为缓存变量，以便稍后在超级构建中被拾取。
- en: 'Setting the `CMAKE_DISABLE_FIND_PACKAGE_FFTW3` to `ON` when configuring the
    project will skip detection of the FFTW library and always perform the superbuild.
    See the documentation: [https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置项目时将`CMAKE_DISABLE_FIND_PACKAGE_FFTW3`设置为`ON`，将跳过FFTW库的检测并始终执行超级构建。请参阅文档：[https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html)
- en: 'Managing dependencies with a superbuild: III. The Google Test framework'
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超级构建管理依赖项：III. Google Test框架
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-04),
    and has a C++ example. The recipe is valid with CMake version 3.11 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows. The code repository also
    contains an example compatible with CMake 3.5.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-04)找到，并包含一个C++示例。该示例适用于CMake版本3.11（及以上），并在GNU/Linux、macOS和Windows上进行了测试。代码仓库还包含一个与CMake
    3.5兼容的示例。
- en: In [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating and Running
    Tests*, Recipe 3, *Defining a unit test and linking against Google Test*, we implemented unit
    testing using the Google Test framework and fetched the Google Test sources at
    configure time using the relatively new `FetchContent` module (available since
    CMake 3.11). In this chapter, we will revisit this recipe, focus less on the testing
    aspect, and dive a bit deeper into `FetchContent`, which provides a compact and
    versatile module to assemble project dependencies at configure time. For additional
    insight and for CMake below 3.11, we will also discuss how to emulate `FetchContent`
    using `ExternalProject_Add` *at configure time*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*，第3个菜谱，*定义单元测试并链接到Google
    Test*，我们使用Google Test框架实现了单元测试，并在配置时使用相对较新的`FetchContent`模块（自CMake 3.11起可用）获取了Google
    Test源码。在本章中，我们将重温这个菜谱，减少对测试方面的关注，并深入探讨`FetchContent`，它提供了一个紧凑且多功能的模块，用于在配置时组装项目依赖。为了获得更多见解，以及对于CMake
    3.11以下的版本，我们还将讨论如何使用`ExternalProject_Add` *在配置时*模拟`FetchContent`。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will build and test the same source files, `main.cpp`, `sum_integers.cpp`, `sum_integers.hpp`,
    and `test.cpp`, as in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml),
    *Creating and Running Tests*, Recipe 3, *Defining a unit test and linking against
    Google Test*. We will download all required Google Test sources at configure time
    using `FetchContent` or `ExternalProject_Add` and in this recipe only focus on
    the fetching of dependencies at configure time, not so much on the actual source
    code and its unit tests.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将构建并测试与[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*，第3个菜谱，*定义单元测试并链接到Google
    Test*中相同的源文件，`main.cpp`、`sum_integers.cpp`、`sum_integers.hpp`和`test.cpp`。我们将使用`FetchContent`或`ExternalProject_Add`在配置时下载所有必需的Google
    Test源码，并且在本菜谱中只关注在配置时获取依赖，而不是实际的源码及其单元测试。
- en: How to do it
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'In this recipe, we will only focus on how to fetch the Google Test sources
    to build the `gtest_main` target. For a discussion on how this target is used
    to test the example sources, we refer the reader to [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml),
    *Creating and Running Tests*, Recipe 3, *Defining a unit test and linking against
    Google Test*:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将只关注如何获取Google Test源码以构建`gtest_main`目标。关于如何使用该目标测试示例源码的讨论，我们请读者参考[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*，第3个菜谱，*定义单元测试并链接到Google
    Test*：
- en: 'We first include the `FetchContent` module, which will provide the functions
    that we will require to declare, query, and populate the dependency:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先包含`FetchContent`模块，它将提供我们所需的函数来声明、查询和填充依赖：
- en: '[PRE65]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, we declare the content - its name, repository location, and the precise
    version to fetch:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们声明内容——其名称、仓库位置以及要获取的确切版本：
- en: '[PRE66]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We then query whether the content has already been fetched/populated:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们查询内容是否已经被获取/填充：
- en: '[PRE67]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The previous function call defines `googletest_POPULATED`. If the content is
    not yet populated, we fetch the content and configure the subproject:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的函数调用定义了`googletest_POPULATED`。如果内容尚未填充，我们将获取内容并配置子项目：
- en: '[PRE68]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Notice how the content is fetched at configure time:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意内容是在配置时获取的：
- en: '[PRE69]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This generates the following build directory tree. The Google Test sources
    are now in place to be processed by CMake and provide the required target(s):'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将生成以下构建目录树。Google Test源码现在已就位，可以由CMake处理并提供所需的目标：
- en: '[PRE70]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The `FetchContent` module enables populating content at configure time. In
    our case, we have fetched a Git repository with a well defined Git tag:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent`模块允许在配置时填充内容。在我们的例子中，我们获取了一个带有明确Git标签的Git仓库：'
- en: '[PRE71]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `FetchContent` module supports fetching content *via* any method supported
    by the `ExternalProject` module - in other words, *via* Subversion, Mercurial,
    CVS, or HTTP(S). The content name "googletest" was our choice and with this we
    will be able to reference the content when querying its properties, when populating
    directories, and later also when configuring the subproject. Before populating
    the project, we checked whether the content was already fetched, otherwise `FetchContent_Populate()` would
    have thrown an error if it was called more than once:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent`模块支持通过`ExternalProject`模块支持的任何方法*获取*内容 - 换句话说，*通过*Subversion、Mercurial、CVS或HTTP(S)。内容名称“googletest”是我们的选择，有了这个，我们将能够在查询其属性、填充目录以及稍后配置子项目时引用内容。在填充项目之前，我们检查内容是否已经获取，否则如果`FetchContent_Populate()`被调用超过一次，它将抛出错误：'
- en: '[PRE72]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Only then did we configure the subdirectory, which we can reference with the
    `googletest_SOURCE_DIR` and `googletest_BINARY_DIR` variables. They were set by
    `FetchContent_Populate(googletest)` and constructed based on the project name
    we gave when declaring the content:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在那时我们才配置了子目录，我们可以通过`googletest_SOURCE_DIR`和`googletest_BINARY_DIR`变量来引用它。这些变量是由`FetchContent_Populate(googletest)`设置的，并根据我们在声明内容时给出的项目名称构建的。
- en: '[PRE73]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `FetchContent` module has a number of options (see [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html))
    and here we can show one: how to change the default path into which the external
    project will be placed. Previously, we saw that by default the content is saved
    to `${CMAKE_BINARY_DIR}/_deps`. We can change this location by setting `FETCHCONTENT_BASE_DIR`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent`模块有许多选项（参见[https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html)），这里我们可以展示一个：如何更改外部项目将被放置的默认路径。之前，我们看到默认情况下内容被保存到`${CMAKE_BINARY_DIR}/_deps`。我们可以通过设置`FETCHCONTENT_BASE_DIR`来更改此位置：'
- en: '[PRE74]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`FetchContent` has become a standard part of CMake in its 3.11 version. In
    the following code, we will try to emulate `FetchContent` using `ExternalProject_Add` at
    *configure time*. This will not only be practical for older CMake versions, it
    will hopefully also give us more insight into what is happening underneath the `FetchContent`
    layer and provide an interesting alternative to the typical build-time fetching
    of projects included using `ExternalProject_Add`. Our goal will be to write a
    `fetch_git_repo` macro and place it in `fetch_git_repo.cmake` so that we can fetch
    the content like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent`已成为CMake 3.11版本中的标准部分。在下面的代码中，我们将尝试在*配置时间*使用`ExternalProject_Add`来模拟`FetchContent`。这不仅对旧版本的CMake实用，而且有望让我们更深入地了解`FetchContent`层下面发生的事情，并提供一个有趣的替代方案，以替代使用`ExternalProject_Add`在构建时间获取项目的典型方式。我们的目标是编写一个`fetch_git_repo`宏，并将其放置在`fetch_git_repo.cmake`中，以便我们可以这样获取内容：'
- en: '[PRE75]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This feels similar to the use of `FetchContent`. Under the hood, we will use `ExternalProject_Add`.
    Let us now lift the hood and inspect the definition of `fetch_git_repo` in `fetch_git_repo.cmake`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这感觉类似于使用`FetchContent`。在幕后，我们将使用`ExternalProject_Add`。现在让我们揭开盖子，检查`fetch_git_repo`在`fetch_git_repo.cmake`中的定义：
- en: '[PRE76]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The macro receives the project name, download root, Git repository URL, and
    a Git tag. The macro defines `${_project_name}_SOURCE_DIR` and `${_project_name}_BINARY_DIR`,
    and we use a macro instead of a function since `${_project_name}_SOURCE_DIR` and
    `${_project_name}_BINARY_DIR` need to survive the scope of `fetch_git_repo` because
    we use them later in the main scope to configure the subdirectory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 宏接收项目名称、下载根目录、Git仓库URL和Git标签。宏定义了`${_project_name}_SOURCE_DIR`和`${_project_name}_BINARY_DIR`，我们使用宏而不是函数，因为`${_project_name}_SOURCE_DIR`和`${_project_name}_BINARY_DIR`需要在`fetch_git_repo`的作用域之外存活，因为我们稍后在主作用域中使用它们来配置子目录：
- en: '[PRE77]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Inside the `fetch_git_repo` macro, we wish to use `ExternalProject_Add` to
    fetch the external project at *configure time* and we achieve this with a trick
    in three steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fetch_git_repo`宏内部，我们希望使用`ExternalProject_Add`在*配置时间*获取外部项目，我们通过一个三步的技巧来实现这一点：
- en: 'First, we configure `fetch_at_configure_step.in`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们配置`fetch_at_configure_step.in`：
- en: '[PRE78]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Using `configure_file`, we generate a `CMakeLists.txt` file in which the previous
    placeholders are replaced by values defined in `fetch_git_repo.cmake`. Note that
    the previous `ExternalProject_Add` command is constructed to only fetch, not to configure,
    build, install, or test.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`configure_file`，我们生成一个`CMakeLists.txt`文件，其中之前的占位符被替换为在`fetch_git_repo.cmake`中定义的值。注意，之前的`ExternalProject_Add`命令被构造为仅获取，而不进行配置、构建、安装或测试。
- en: 'Second, we trigger the `ExternalProject_Add` at configure time (from the perspective
    of the root project) using a configure step:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们在配置时间（从根项目的角度）使用配置步骤触发`ExternalProject_Add`：
- en: '[PRE79]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Third and final trick triggers a configure-time build step in `fetch_git_repo.cmake`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个也是最后一个技巧在`fetch_git_repo.cmake`中触发配置时间构建步骤：
- en: '[PRE80]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: One nice aspect of this solution is that since the external dependency is not
    configured by `ExternalProject_Add`, we do not need to channel any configuration
    settings to the project *via* the `ExternalProject_Add` call. We can configure
    and build the module using `add_subdirectory` as if the external dependency was
    part of our project source tree. Brilliant disguise!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的一个很好的方面是，由于外部依赖项不是由`ExternalProject_Add`配置的，我们不需要通过`ExternalProject_Add`调用将任何配置设置传递给项目。我们可以使用`add_subdirectory`配置和构建模块，就好像外部依赖项是我们项目源代码树的一部分一样。巧妙的伪装！
- en: See also
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For a detailed discussion of the available `FetchContent` options, please consult [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用的`FetchContent`选项的详细讨论，请咨询[https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html)。
- en: 'The configure time `ExternalProject_Add` solution is inspired by the work and
    blog post of Craig Scott: [https://crascit.com/2015/07/25/cmake-gtest/](https://crascit.com/2015/07/25/cmake-gtest/).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 配置时间`ExternalProject_Add`解决方案的灵感来自Craig Scott的工作和博客文章：[https://crascit.com/2015/07/25/cmake-gtest/](https://crascit.com/2015/07/25/cmake-gtest/)。
- en: Managing your project as a superbuild
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的项目作为超级构建进行管理
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-05)
    and has a C++ example. The recipe is valid with CMake version 3.6 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-05)获取，并且有一个C++示例。本示例适用于CMake版本3.6（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: '`ExternalProject` and `FetchContent` are two very powerful tools in your CMake
    arsenal. The previous recipes should have convinced you how versatile the superbuild
    approach is in managing projects with complex dependencies. We have so far shown
    how to use `ExternalProject` to handle the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject`和`FetchContent`是CMake工具箱中的两个非常强大的工具。之前的示例应该已经说服了您超级构建方法在管理具有复杂依赖关系的项目方面的多功能性。到目前为止，我们已经展示了如何使用`ExternalProject`来处理以下内容：'
- en: Sources stored within your source tree
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在您的源代码树中的源代码
- en: Sources retrieved from archives available on online servers
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从在线服务器上的档案中检索来源
- en: The previous recipe showed how to use `FetchContent` to handle dependencies
    available from open source Git repositories. This recipe will show how to use
    `ExternalProject` to the same effect. This last recipe will introduce an example
    that will be reused in Recipe 4, *Installing a superbuild*, in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了如何使用`FetchContent`来处理来自开源Git存储库的依赖项。本示例将展示如何使用`ExternalProject`达到相同的效果。最后一个示例将介绍一个将在第4个示例中重复使用的示例，即*安装超级构建*，在[第10章](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml)，*编写安装程序*。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The source tree for this superbuild should now feel familiar:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个超级构建的源代码树现在应该感觉很熟悉：
- en: '[PRE81]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The root directory has a `CMakeLists.txt`, which we already know will orchestrate
    the superbuild. The leaf directories `src` and `external` host our own source
    code and the CMake directives needed to satisfy the dependency on the `message`
    library, which we will build in this example.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录有一个`CMakeLists.txt`，我们已经知道它将协调超级构建。叶目录`src`和`external`托管我们自己的源代码和满足对`message`库的依赖所需的CMake指令，我们将在本示例中构建该库。
- en: How to do it
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The process of setting up a superbuild should by now feel familiar. Let us
    once again look at the necessary steps, starting with the root `CMakeLists.txt`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，设置超级构建的过程应该感觉很熟悉。让我们再次看一下必要的步骤，从根`CMakeLists.txt`开始：
- en: 'We declare a C++11 project with a same default build type:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个具有相同默认构建类型的C++11项目：
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `EP_BASE` directory property is set. This will fix the layout for all subprojects
    managed by `ExternalProject`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置了`EP_BASE`目录属性。这将固定由`ExternalProject`管理的所有子项目的布局：
- en: '[PRE83]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We set `STAGED_INSTALL_PREFIX`. As before, this location will be used as the
    installation prefix within the build tree for the dependencies:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了`STAGED_INSTALL_PREFIX`。与之前一样，此位置将用作构建树中依赖项的安装前缀：
- en: '[PRE84]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We add the `external/upstream` subdirectory:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加`external/upstream`子目录：
- en: '[PRE85]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Our own project will also be managed by the superbuild and is hence added with
    `ExternalProject_Add`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们自己的项目也将由超级构建管理，因此使用`ExternalProject_Add`添加：
- en: '[PRE86]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `CMakeLists.txt` in `external/upstream` only contains one command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`external/upstream`中的`CMakeLists.txt`只包含一个命令：'
- en: '[PRE87]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Jumping into the `message` folder, we again see the usual commands for managing
    our dependency on the `message` library:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到`message`文件夹，我们再次看到管理我们对`message`库依赖的常用命令：
- en: 'First of all, we call `find_package` to find a suitable version of the library:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们调用`find_package`来找到一个合适的库版本：
- en: '[PRE88]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If it is found, we inform the user and add a dummy `INTERFACE` library:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到，我们通知用户并添加一个虚拟的`INTERFACE`库：
- en: '[PRE89]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If it is not found, we again inform the user and proceed with `ExternalProject_Add`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未找到，我们再次通知用户并继续使用`ExternalProject_Add`：
- en: '[PRE90]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The project is hosted in a public Git repository and we use the `GIT_TAG` option
    to specify which branch to download. As before, we leave the `UPDATE_COMMAND`
    option empty:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该项目托管在一个公共Git仓库中，我们使用`GIT_TAG`选项来指定下载哪个分支。像之前一样，我们让`UPDATE_COMMAND`选项保持空白：
- en: '[PRE91]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The external project is configured and built using CMake. We pass on all the
    necessary build options:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部项目使用CMake进行配置和构建。我们传递所有必要的构建选项：
- en: '[PRE92]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We decide to test the project after it has been installed:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们决定在项目安装后进行测试：
- en: '[PRE93]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We do not wish to see progress on downloads, nor information on configuring,
    building, and installing to be reported onscreen, and we close the `ExternalProject_Add`
    command:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望看到下载进度，也不希望屏幕上显示配置、构建和安装的信息，我们关闭`ExternalProject_Add`命令：
- en: '[PRE94]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To ensure that the subproject is discoverable within the rest of the superbuild,
    we set the `message_DIR` directory:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保子项目在超级构建的其余部分中可被发现，我们设置`message_DIR`目录：
- en: '[PRE95]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Finally, let us look at the `CMakeLists.txt` in the `src` folder:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`src`文件夹中的`CMakeLists.txt`：
- en: 'Again, we declare a C++11 project:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们声明一个C++11项目：
- en: '[PRE96]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This project requires the `message` library:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个项目需要`message`库：
- en: '[PRE97]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We declare an executable target and link it to the `message-shared` library
    provided by our dependency:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个可执行目标，并将其链接到我们依赖项提供的`message-shared`库：
- en: '[PRE98]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: How it works
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'This recipe highlighted some new options to the `ExternalProject_Add` command:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方突出了`ExternalProject_Add`命令的一些新选项：
- en: '`GIT_REPOSITORY`: This can be used to specify the URL of the repository containing
    the sources of our dependency. CMake can also use other version control systems,
    such as CVS (`CVS_REPOSITORY`), SVN (`SVN_REPOSITORY`), or Mercurial (`HG_REPOSITORY`).'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GIT_REPOSITORY`：这可以用来指定包含我们依赖源代码的仓库的URL。CMake还可以使用其他版本控制系统，如CVS（`CVS_REPOSITORY`）、SVN（`SVN_REPOSITORY`）或Mercurial（`HG_REPOSITORY`）。'
- en: '`GIT_TAG`: By default, CMake will check out the default branch of the given
    repository. However, it is preferable to depend on a well-defined version that
    is known to be stable. This can be specified with this option, which can accept
    any identifier recognized by Git as "version" information, such as a Git commit
    SHA, a Git tag, or just a branch name. Similar options are also available for
    the other version control systems understood by CMake.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GIT_TAG`：默认情况下，CMake将检出给定仓库的默认分支。然而，依赖于一个已知稳定的定义良好的版本是更可取的。这可以通过这个选项来指定，它可以接受Git识别为“版本”信息的任何标识符，如Git提交SHA、Git标签，或者仅仅是一个分支名称。对于CMake理解的其他版本控制系统，也有类似的选项。'
- en: '`TEST_AFTER_INSTALL`: Most likely, your dependency has a test suite of its
    own and you might want to run the test suite to ensure that everything went smoothly
    during the superbuild. This option will run the tests right after the installation
    step.'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TEST_AFTER_INSTALL`：很可能，你的依赖项有自己的测试套件，你可能想要运行测试套件以确保超级构建过程中一切顺利。这个选项将在安装步骤之后立即运行测试。'
- en: 'The additional **Test** options understood by `ExternalProject_Add` are as
    follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`ExternalProject_Add`理解的额外**测试**选项：
- en: '`TEST_BEFORE_INSTALL`, which will run the test suite *before* the installation
    step'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEST_BEFORE_INSTALL`，它将在安装步骤*之前*运行测试套件'
- en: '`TEST_EXCLUDE_FROM_MAIN`, with which we can remove the dependency on the main
    target of the external project from the test suite'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEST_EXCLUDE_FROM_MAIN`，我们可以使用它从测试套件中移除对外部项目主要目标的依赖'
- en: These options assume that the external project manages testing using CTest.
    If the external project does not use CTest to manage testing, we can set the `TEST_COMMAND`
    option to execute tests.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项假设外部项目使用CTest管理测试。如果外部项目不使用CTest管理测试，我们可以设置`TEST_COMMAND`选项来执行测试。
- en: Introducing the superbuild pattern even for modules that are part of your own
    project comes at the cost of introducing an additional layer, re-declaring small
    CMake projects, and passing configuration settings explicitly through `ExternalProject_Add`.
    The benefit of introducing this additional layer is a clear separation of variable
    and target scopes, which can help to manage complexity, dependencies, and namespaces
    in projects consisting of several components, where these components can be internal
    or external, and composed together by CMake.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 引入超级构建模式，即使对于项目中包含的模块，也会带来额外的层次，重新声明小型CMake项目，并通过`ExternalProject_Add`显式传递配置设置。引入这一额外层次的好处是变量和目标作用域的清晰分离，这有助于管理复杂性、依赖关系和由多个组件组成的项目的命名空间，这些组件可以是内部的或外部的，并通过CMake组合在一起。
