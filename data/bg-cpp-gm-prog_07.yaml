- en: Chapter 7. C++ References, Sprite Sheets, and Vertex Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。C++引用、精灵表和顶点数组
- en: 'In [Chapter 4](ch04.html "Chapter 4.  Loops, Arrays, Switch, Enumerations,
    and Functions – Implementing Game Mechanics"): *Loops, Arrays, Switch, Enumerations,
    and Functions - Implementing Game Mechanics*, we talked about scope. The concept
    that variables declared in a function or inner block of code only have scope (can
    be seen or used) in that function or block. Using only the C++ knowledge we have
    at the moment, this can cause a problem. What do we do if we need to work on a
    number of complex objects which are needed in `main`? This could imply that all
    the code must be in `main`.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。循环、数组、开关、枚举和函数-实现游戏机制")中，我们谈到了作用域。在函数或内部代码块中声明的变量只在该函数或块中具有作用域（可以被看到或使用）。仅使用我们目前拥有的C++知识，这可能会导致问题。如果我们需要处理一些复杂对象，这些对象在`main`中是必需的，我们该怎么办？这可能意味着所有的代码都必须在`main`中。
- en: In this chapter we will explore **C++references** which allow us to work on
    variables and objects that are otherwise out of scope. In addition, references
    will help us avoid having to pass large objects between functions, which is a
    slow process. It is a slow process because each time we do this, a copy of the
    variable or object must be made.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**C++引用**，它允许我们处理变量和对象，否则它们将超出作用域。此外，引用将帮助我们避免在函数之间传递大型对象，这是一个缓慢的过程。这是一个缓慢的过程，因为每次这样做时，都必须制作变量或对象的副本。
- en: Armed with this new knowledge about references, we will take a look at the SFML
    `VertexArray` class that allows us to build up a large image that can be very
    quickly and efficiently drawn to the screen using multiple images from a single
    image file. By the end of the chapter we will have a scaleable, random, scrolling
    background, using references, and a `VertexArray` object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了关于引用的这些新知识后，我们将看一下SFML `VertexArray`类，它允许我们构建一个大图像，可以使用来自单个图像文件的多个图像快速有效地绘制到屏幕上。在本章结束时，我们将拥有一个可扩展的、随机的、滚动的背景，使用引用和一个`VertexArray`对象。
- en: 'We will now talk about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论以下主题：
- en: C++ references
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++引用
- en: SFML vertex arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML顶点数组
- en: Coding a random and scrolling background
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写随机和滚动的背景
- en: C++ References
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++引用
- en: When we pass values to a function or return values from a function, that is
    exactly what we are doing. Passing/returning by **value**. What happens is that
    a copy of the value held by the variable is made, and sent into the function where
    it is used.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向函数传递值或从函数返回值时，这正是我们所做的。通过**值**传递/返回。发生的情况是变量持有的值的副本被制作，并发送到函数中使用。
- en: 'The significance of this is two-fold:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有双重意义：
- en: If we want the function to make a permanent change to a variable, this system
    is no good to us.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们希望函数对变量进行永久性更改，那么这个系统对我们来说就不好了。
- en: When a copy is made, to pass in as an argument or return from the function,
    processing power and memory are consumed. For a simple `int` or even perhaps a
    sprite, this is fairly insignificant. However, for a complex object, perhaps an
    entire game world (or background), the copying process will seriously affect our
    game's performance.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当制作副本以作为参数传递或从函数返回时，会消耗处理能力和内存。对于一个简单的`int`，甚至可能是一个精灵，这是相当微不足道的。然而，对于一个复杂的对象，也许是整个游戏世界（或背景），复制过程将严重影响我们游戏的性能。
- en: 'References are the solution to these two problems. A reference is a special
    type of variable. A reference refers to another variable. An example will be useful:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是这两个问题的解决方案。引用是一种特殊类型的变量。引用指的是另一个变量。一个例子将是有用的：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the code above we declare and initialize a regular `int` called `numZombies`.
    We then declare and initialize an `int` reference called `rNumZombies`. The reference
    operator `&` that follows the type, determines that a reference is being declared.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们声明并初始化了一个常规的`int`，名为`numZombies`。然后我们声明并初始化了一个`int`引用，名为`rNumZombies`。跟随类型的引用运算符`&`确定正在声明一个引用。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `r` prefix at the front of the reference name is optional but useful for
    remembering that we are dealing with a reference.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 引用名称前面的`r`前缀是可选的，但对于记住我们正在处理引用是有用的。
- en: Now we have an `int` called `numZombies` which stores the value `100` and an
    `int` reference called `rNumZombies` that refers to `numZombies`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为`numZombies`的`int`，它存储值`100`，以及一个引用`int`，名为`rNumZombies`，它指的是`numZombies`。
- en: 'Anything we do to `numZombies` can be seen through `rNumZombies`, and anything
    we do to `rNumZombies` we are actually doing to `numZombies`. Take a look at the
    following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`numZombies`所做的任何事情都可以通过`rNumZombies`看到，我们对`rNumZombies`所做的任何事情实际上都是在做`numZombies`。看一下以下代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous code we declare an `int` called `score`. Next we declare an
    `int` reference called `rScore` that refers to `score`. Remember that anything
    we do to `score` can be seen by `rScore` and anything we do to `rScore` is actually
    being done to `score`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个名为`score`的`int`。接下来，我们声明了一个引用`int`，名为`rScore`，它指的是`score`。请记住，我们对`score`所做的任何事情都可以被`rScore`看到，我们对`rScore`所做的任何事情实际上都是在做`score`。
- en: 'Therefore, when we increment score like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们像这样增加分数时：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The score variable now stores the value 11\. In addition, if we were to output
    `rScore` it would also output 11\. The following line of code is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 分数变量现在存储值11。此外，如果我们输出`rScore`，它也将输出11。以下代码行如下：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now `score` actually holds the value 12 because anything we do to `rScore` is
    actually done to `score`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`score`实际上持有值12，因为我们对`rScore`所做的任何事情实际上都是对`score`做的。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to know how this works then more will be revealed in the next chapter
    when we discuss **pointers**. But simply put, you can consider a reference as
    storing a place/address in the computer's memory. That place in memory is the
    same place where the variable it refers to stores its value. Therefore, an operation
    on either the reference or the variable has exactly the same effect.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道这是如何工作的，那么在下一章中讨论**指针**时将会有更多揭示。但简单来说，您可以将引用视为存储计算机内存中的位置/地址。内存中的位置与其引用的变量存储其值的位置相同。因此，对引用或变量的操作具有完全相同的效果。
- en: 'For now, it is much more important to talk more about the *why* of references.
    There are two reasons to use references and we have already mentioned them. Here
    they are summarized again:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更重要的是更多地讨论引用的*原因*。使用引用有两个原因，我们已经提到过。这里再次总结一下：
- en: Changing/reading the value of a variable/object in another function which is
    otherwise out of scope
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改/读取另一个函数中变量/对象的值，否则超出范围
- en: Passing/returning without making a copy (and therefore more efficiently)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递/返回而不制作副本（因此更有效）
- en: 'Study this code and then we can discuss it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 研究这段代码，然后我们可以讨论它：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous code begins with the prototypes of two functions, `add` and `referenceAdd`.
    The `add` function takes three `int` variables and the `referenceAdd` function
    takes two `int` variables and an `int` reference.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码以`add`和`referenceAdd`两个函数的原型开始。`add`函数接受三个`int`变量，而`referenceAdd`函数接受两个`int`变量和一个`int`引用。
- en: When the `add` function is called and the variables `number1`, `number2`, and
    `answer` are passed in, a copy of the values is made and new local variables to
    add (`n1`, `n2`, and `a`) are manipulated. As a result of this, `answer`, back
    in `main`, remains at zero.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`add`函数并传入变量`number1`，`number2`和`answer`时，将复制这些值并操作新的本地变量以添加（`n1`，`n2`和`a`）。因此，`main`中的`answer`仍然为零。
- en: When the `referenceAdd` function is called, `number1` and `number2` are again
    passed by value. However, `answer` is passed by reference. When the value of `n1`
    added to `n2` is assigned to the reference `a`, what is really happening is that
    the value is assigned to `answer` back in the `main` function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`referenceAdd`函数时，`number1`和`number2`再次按值传递。但是，`answer`是按引用传递的。当将`n1`加到`n2`的值分配给引用`a`时，实际上发生的是该值被分配回`main`函数中的`answer`。
- en: It is probably obvious that we would never need to actually use a reference
    for something this simple. It does, however, demonstrate the mechanics of passing
    by reference.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们永远不需要实际使用引用来处理如此简单的事情。但是，它确实演示了按引用传递的机制。
- en: References summary
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考摘要
- en: The previous code demonstrated how a reference can be used to alter the value
    of a variable in one scope using code in another. As well as being extremely convenient,
    passing by reference is also very efficient because no copy is made. The example
    using a reference to an `int` is a bit ambiguous because as an `int` is so small
    there is no real efficiency gain. Later in the chapter we will use a reference
    to pass an entire level layout and the efficiency gain will be significant.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码演示了如何使用引用来使用另一个作用域中的代码来更改变量的值。除了非常方便之外，按引用传递也非常高效，因为不会进行复制。使用引用传递`int`的示例有点模糊，因为`int`太小，没有真正的效率提升。在本章后期，我们将使用引用传递整个级别布局，效率提升将是显著的。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is one gotcha with references! You must assign the reference to a variable
    at the time you create it. This means it is not completely flexible. Don't worry
    about this for now. We will explore references further as well as their more flexible
    (and slightly more complicated) relations, pointers, in the next chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 引用有一个需要注意的地方！您必须在创建引用时将其分配给一个变量。这意味着它并不完全灵活。现在不要担心这个问题。我们将在下一章中进一步探讨引用以及它们更灵活（稍微更复杂）的关系，指针。
- en: This is largely irrelevant for an `int` but potentially significant for a large
    object of a class. We will use this exact technique when we implement the scrolling
    background of the Zombie Arena game.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于`int`来说并不重要，但对于类的大对象来说可能很重要。当我们实现僵尸竞技场游戏的滚动背景时，我们将使用这种确切的技术。
- en: SFML vertex arrays and sprite sheets
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML顶点数组和精灵表
- en: We are nearly ready to implement the scrolling background. We just need to learn
    about SFML vertex arrays and sprite sheets.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '我们几乎准备好实现滚动背景了。我们只需要学习关于SFML顶点数组和精灵表。 '
- en: What is a sprite sheet?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是精灵表？
- en: 'A **sprite sheet** is a set of images, either frames of animation or totally
    individual graphics, contained in one image file. Take a closer look at the sprite
    sheet that contains four separate images that will be used to draw the background
    in Zombie Arena:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵表**是一组图像，可以是动画帧或完全独立的图形，包含在一个图像文件中。仔细观察包含四个单独图像的精灵表，这些图像将用于绘制僵尸竞技场的背景：'
- en: '![What is a sprite sheet?](img/image_07_001.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![什么是精灵表？](img/image_07_001.jpg)'
- en: SFML allows us to load a sprite sheet as a regular texture in exactly the same
    way we have done for every texture in the book so far. When we load multiple images
    as a single texture, the GPU can handle it much more efficiently.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SFML允许我们以与本书中迄今为止的每个纹理完全相同的方式加载精灵表作为常规纹理。当我们将多个图像加载为单个纹理时，GPU可以更有效地处理它。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Actually a modern PC could handle these four textures without using a sprite
    sheet. It is worth using these techniques as our games are going to start getting
    progressively more demanding on the hardware.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，现代PC可以处理这四个纹理而不使用精灵表。由于我们的游戏将逐渐对硬件要求更高，因此值得使用这些技术。
- en: 'What we need to do when we draw an image from the sprite sheet is make sure
    we refer to the precise pixel coordinates of the part of the sprite sheet we require:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从精灵表中绘制图像时，我们需要确保引用我们需要的精灵表部分的精确像素坐标：
- en: '![What is a sprite sheet?](img/image_07_002.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![什么是精灵表？](img/image_07_002.jpg)'
- en: The previous image labels each part/tile with the coordinates of its position
    within the sprite sheet. These coordinates are called **texture coordinates**.
    We will use these texture coordinates in our code to draw just the right parts
    that we require.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图标记了每个部分/瓦片在精灵表中位置的坐标。这些坐标称为**纹理坐标**。我们将在我们的代码中使用这些纹理坐标来绘制我们需要的部分。
- en: What is a vertex array?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是顶点数组？
- en: 'First we need to ask: what is a vertex? A **vertex** is a single graphical
    point, a coordinate. This point is defined by a horizontal and vertical position.
    The plural of vertex is vertices. A vertex array, then, is a whole collection
    of vertices.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要问：什么是顶点？**顶点**是单个图形点，一个坐标。这个点由水平和垂直位置定义。顶点的复数是顶点。然后，顶点数组是整个顶点的集合。
- en: In SFML, each vertex in a vertex array also has a color and a related additional
    vertex (pair of coordinates) called texture coordinates. Texture coordinates are
    the position in a sprite sheet of the image we want to use. We will see quite
    soon how we position graphics and choose a part of the sprite sheet to display
    at each position, all with a single vertex array.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在SFML中，顶点数组中的每个顶点还具有颜色和相关的额外顶点（一对坐标）称为纹理坐标。纹理坐标是我们想要使用的图像在精灵表中的位置。我们很快将看到如何使用单个顶点数组定位图形并选择要在每个位置显示的精灵表的一部分。
- en: The SFML `VertexArray` class can hold different types of vertex set. But each
    `VertexArray` should only hold one type of set. We use the type of set that suits
    the occasion.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: SFML `VertexArray`类可以保存不同类型的顶点集。但是每个`VertexArray`只能保存一种类型的集。我们使用适合场合的集类型。
- en: 'Common scenarios in video games include, but are not limited to, the following
    **primitive** types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏中常见的场景包括但不限于以下**基元**类型：
- en: '**Point**: A single vertex per point.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点**：每个点一个单独的顶点。'
- en: '**Line**: Two vertices per set that define the start and endpoint of the line.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线**：每组两个顶点定义线的起点和终点。'
- en: '**Triangle**: Three vertices per point. Among the thousands used, this is probably
    the most common for complex 3D models or in pairs to create a simple rectangle,
    like a sprite.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三角形**：每个点三个顶点。在使用的成千上万个中，这可能是复杂的3D模型或成对创建简单矩形（如精灵）中最常见的。'
- en: '**Quad**: Four vertices per set, a convenient way to map rectangular areas
    from a sprite sheet.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四边形**：每组四个顶点，一种方便的方式来从精灵表中映射矩形区域。'
- en: We will use quads in this project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用四边形。
- en: Building a background from tiles
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从瓦片构建背景
- en: The Zombie Arena background will be made up of a random arrangement of square
    images. You can think of this arrangement like tiles on a floor.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 僵尸竞技场背景将由随机排列的方形图像组成。您可以将此排列视为地板上的瓦片。
- en: In this project we will be using vertex arrays with **quad** sets. Each vertex
    will be part of a set of four (a quad). Each vertex will define one corner of
    a tile from our background. Each texture coordinate will hold an appropriate value
    based on a specific image from the sprite sheet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用带有**四边形**集的顶点数组。每个顶点将是四个（一个四边形）的集的一部分。每个顶点将定义背景瓦片的一个角落。每个纹理坐标将根据精灵表中特定图像的适当值进行保持。
- en: Let's take a look at some code to get us started. This isn't the exact code
    we will use in the project but it is fairly close and enables us to study vertex
    arrays before we move on to the actual implementation we will use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些代码来开始。这不是我们在项目中将使用的确切代码，但它非常接近，并使我们能够在转向我们将使用的实际实现之前研究顶点数组。
- en: Building a vertex array
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建顶点数组
- en: 'As we do when we create an instance of a class, we declare our new object.
    The following code declares a new object of type `VertexArray` called background:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们创建类的实例时一样，我们声明我们的新对象。以下代码声明了一个名为背景的`VertexArray`类型的新对象：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We want to let our instance of `VertexArray` know which type of primitive we
    will be using. Remember that points, lines, triangles, and quads all have a different
    number of vertices. By setting the `VertexArray` to hold a particular type, it
    will be possible to know the start of each primitive. In our case we want quads.
    Here is the code that will do this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望让我们的`VertexArray`实例知道我们将使用哪种类型的基元。请记住，点、线、三角形和四边形都有不同数量的顶点。通过设置`VertexArray`来保存特定类型，将可以知道每个基元的起始位置。在我们的情况下，我们想要四边形。以下是将执行此操作的代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As with regular C++ arrays, a `VertexArray` needs to be set to a size. The
    `VertexArray` is more flexible, however. It allows us to change its size while
    the game is running. The size could be configured at the same time as the declaration
    but our background needs to expand with each wave. The `VertexArray` class provides
    this functionality with the `resize` function. Here is the code that would set
    the size of our arena to a 10 by 10 tile size:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的C++数组一样，`VertexArray`需要设置大小。但是，`VertexArray`更加灵活。它允许我们在游戏运行时更改其大小。大小可以在声明的同时配置，但是我们的背景需要随着每一波扩展。`VertexArray`类通过`resize`函数提供了这种功能。以下是将设置我们的竞技场大小为10x10个瓦片大小的代码：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous line of code, the first `10` is the width, the second `10` is
    the height, and `4` is the number of vertices in a quad. We could have just passed
    in 400 but showing the calculation like this makes it clear what we are doing.
    When we code the project for real, we will go a step further and declare variables
    for each part of the calculation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，第一个`10`是宽度，第二个`10`是高度，`4`是四边形中的顶点数。我们可以直接传入400，但是像这样显示计算清楚我们正在做什么。当我们真正编写项目时，我们将进一步声明每个计算部分的变量。
- en: 'We now have a `VertexArray` ready to have its hundreds of vertices configured.
    Here is how we set the position coordinates on the first four vertices (the first
    quad):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`VertexArray`准备好配置其数百个顶点。以下是我们如何设置前四个顶点（第一个四边形）的位置坐标：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is how we set the texture coordinates of these same vertices to the first
    image in the sprite sheet. These coordinates in the image file are `0,0` (in the
    top left corner) to `49,49` (in the bottom right):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何将这些相同顶点的纹理坐标设置为精灵表中的第一个图像。图像文件中的这些坐标是`0,0`（在左上角）到`49,49`（在右下角）：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we wanted to set the texture coordinates to the second image in the sprite
    sheet we would have written the code like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将纹理坐标设置为精灵表中的第二个图像，我们将编写如下代码：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, if we define each and every vertex like this individually, then we
    are going to be configuring even a simple `10` by `10` arena for a long time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们像这样逐个定义每个顶点，那么即使是一个简单的`10`乘`10`的竞技场也需要很长时间来配置。
- en: When we implement our background for real, we will devise a set of nested `for`
    loops that loop through each quad, pick a random background image, and assign
    the appropriate texture coordinates.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们真正实现背景时，我们将设计一组嵌套的`for`循环，循环遍历每个四边形，选择一个随机的背景图像，并分配适当的纹理坐标。
- en: The code will need to be quite smart. It will need to know when it is an edge
    tile so it can use the wall image from the sprite sheet. It will also need to
    use appropriate variables that know the position of each background tile in the
    sprite sheet as well as the overall size of the required arena.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要非常智能。它需要知道何时是边缘瓷砖，以便可以使用精灵表中的墙图像。它还需要使用适当的变量，知道精灵表中每个背景瓷砖的位置以及所需竞技场的总体大小。
- en: We will make this complexity manageable by putting all the code in both a separate
    function and a separate file. We will make the `VertexArray` usable in `main`
    by using a C++ reference.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将所有代码放在单独的函数和单独的文件中，使这种复杂性变得可管理。我们将通过使用C++引用，使`VertexArray`在`main`中可用。
- en: We will come to these details soon. You may have noticed that at no point have
    we associated a texture (the sprite sheet with the vertex array).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会谈到这些细节。您可能已经注意到，在任何时候我们都没有关联纹理（使用顶点数组的精灵表）。
- en: Using the vertex array to draw
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用顶点数组进行绘制
- en: 'We can load the sprite sheet as a texture in exactly the same way as we load
    any other texture, as shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与加载任何其他纹理相同的方式加载精灵表作为纹理，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can then draw the entire `VertexArray` with one call to `draw`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过一次调用`draw`来绘制整个`VertexArray`：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous code is many times more efficient than drawing each and every tile
    as an individual sprite.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码比将每个瓷砖作为单独精灵绘制要高效得多。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we move on, notice the slightly odd looking `&` before `textureBackground`.
    Your immediate thought might be that this has something to do with references.
    What is going on here is we are passing the address of our texture instead of
    the actual texture. We will learn more about this in the next chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意`textureBackground`之前看起来有点奇怪的`&`。您可能会立刻想到这与引用有关。这里发生的是，我们传递纹理的地址而不是实际的纹理。我们将在下一章中了解更多关于这个的知识。
- en: We are now in a position to use our knowledge of references and vertex arrays
    to implement the next stage of the Zombie Arena project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以利用我们对引用和顶点数组的知识来实现Zombie Arena项目的下一个阶段。
- en: Creating a randomly generated scrolling background
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建随机生成的滚动背景
- en: We will create the function that makes a background in a separate file. We will
    ensure the background will be available (in scope) to the `main` function by using
    a vertex array reference.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个在单独文件中创建背景的函数。我们将确保通过使用顶点数组引用，背景将可用（在范围内）到`main`函数。
- en: As we will be writing other functions that share data with the `main` function,
    we will write them all in their own `.cpp` files. We will provide prototypes for
    these functions in a new header file that we will include (with an include directive)
    in `ZombieArena.cpp`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将编写其他与`main`函数共享数据的函数，我们将在一个新的头文件中提供这些函数的原型，并在`ZombieArena.cpp`中包含它们（使用包含指令）。
- en: To achieve this, let's first make the new header file. Right-click **Header
    Files** in the **Solution Explorer** and select **Add** | **New Item...**. In
    the **Add New Item** window, highlight (by left-clicking) **Header File** (`.h`),
    and then in the **Name** field type `ZombieArena.h`. Finally click the **Add**
    button. We are now ready to code the header file for our new function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，让我们首先制作新的头文件。在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，突出显示（通过左键单击）**头文件**（`.h`），然后在**名称**字段中键入`ZombieArena.h`。最后点击**添加**按钮。现在我们准备好为我们的新函数编写头文件。
- en: 'In this new `ZombieArena.h` header file, add the following highlighted code
    including the function prototype:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的`ZombieArena.h`头文件中，添加以下突出显示的代码，包括函数原型：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code enables us to write the definition of a function called `createBackground`.
    To match the prototype, the function must return an `int` value and receive as
    parameters a `VertexArray` reference and an `IntRect` object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使我们能够编写名为`createBackground`的函数的定义。为了匹配原型，函数必须返回一个`int`值，并接收`VertexArray`引用和`IntRect`对象作为参数。
- en: Now we can create a new `.cpp` file in which we will code the function definition.
    Right-click **Source Files** in the **Solution Explorer** and select **Add** |
    **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File** ( **`.cpp`** ), and then in the **Name** field type `CreateBackground.cpp`.
    Finally click the **Add** button. We are now ready to code the function definition
    that will create our background.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的`.cpp`文件，在其中我们将编写函数定义。在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，突出显示（通过左键单击）**C++文件**（**`.cpp`**），然后在**名称**字段中键入`CreateBackground.cpp`。最后点击**添加**按钮。现在我们准备好编写将创建我们的背景的函数定义。
- en: 'Add the following code to the `CreateBackground.cpp` file and then we will
    review it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CreateBackground.cpp`文件中，然后我们将对其进行审查：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code, we write the function signature as well as the opening
    and closing curly brackets that mark out the function body.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们编写了函数签名以及标记函数主体的大括号。
- en: Within the function body we declare and initialize three new `int` constants
    to hold values that we will need to refer to throughout the rest of the function.
    They are `TILE_SIZE`, `TILE_TYPES`, and `VERTS_IN_QUAD`. The `TILE_SIZE` constant
    refers to the size in pixels of each tile within the sprite sheet. `TILE_TYPES`
    refers to the number of different tiles within the sprite sheet. We could add
    more tiles into our sprite sheet, change `TILE_TYPES` to match, and the code we
    are about to write would still work. `VERTS_IN_QUAD` refers to the fact that there
    are four vertices in every quad. It is less error-prone to use this constant compared
    to repeatedly typing the number `4`, which is less clear.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数主体中，我们声明并初始化了三个新的`int`常量，用于保存我们在函数其余部分需要引用的值。它们是`TILE_SIZE`、`TILE_TYPES`和`VERTS_IN_QUAD`。`TILE_SIZE`常量指的是精灵表中每个图块的像素大小。`TILE_TYPES`指的是精灵表中不同图块的数量。我们可以向精灵表中添加更多图块，将`TILE_TYPES`更改为匹配，即将仍然有效。`VERTS_IN_QUAD`指的是每个四边形中有四个顶点。与反复输入数字`4`相比，使用这个常量更不容易出错，这点更清晰。
- en: We then declare and initialize two `int` variables, `worldWidth` and `worldHeight`.
    These variables might appear blindingly obvious as to their use. They are betrayed
    by their names but it is worth pointing out that they refer to the width and height
    of the world in number of tiles, not pixels. The `worldWidth` and `worldHeight`
    variables are initialized by dividing the height and width of the passed-in arena
    by the constant, `TILE_SIZE`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明并初始化了两个`int`变量，`worldWidth`和`worldHeight`。这些变量可能看起来显而易见，因为它们的用途。它们的名称已经透露了它们的用途，但值得指出的是，它们指的是世界在图块数量上的宽度和高度，而不是像素。`worldWidth`和`worldHeight`变量通过将传入的竞技场的高度和宽度除以常量`TILE_SIZE`来初始化。
- en: Next, we get to use our reference for the first time. Remember that anything
    we do to `rVA` we are really doing to the variable that was passed-in which is
    in scope in the `main` function (or will be when we code it).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将首次使用我们的引用。请记住，我们对`rVA`所做的任何事情实际上都是对传入的变量所做的，该变量在`main`函数中是可见的（或者当我们编写它时将可见）。
- en: First we prepare the vertex array to use quads using `rVA.setType`, and then
    we make it just the right size by calling `rVA.resize`. To the `resize` function
    we pass in the result of `worldWidth * worldHeight * VERTS_IN_QUAD`, which equates
    to exactly the number of vertices that our vertex array will have when we are
    done preparing it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们准备使用`rVA.setType`将顶点数组设置为四边形，然后通过调用`rVA.resize`将其调整为合适的大小。我们向`resize`函数传递`worldWidth
    * worldHeight * VERTS_IN_QUAD`的结果，这恰好等于我们在准备完成后顶点数组的数量。
- en: The last line of code declares and initializes `currentVertex` to zero. We will
    use `currentVertex` as we loop through the vertex array initializing all the vertices.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行声明并初始化`currentVertex`为零。我们将使用`currentVertex`循环遍历顶点数组，初始化所有顶点。
- en: 'We can now write the first part of a nested `for` loop that will prepare the
    vertex array. Add the following highlighted code, and based on what we have learnt
    about vertex arrays, try and work out what it does:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写嵌套的`for`循环的第一部分，以准备顶点数组。添加以下突出显示的代码，并根据我们对顶点数组的了解，尝试弄清楚它的作用：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code that we just added steps through the vertex array by using a nested
    `for` loop that first steps through the first four vertices. `currentVertex +
    1`, `currentVertex + 2`, and so on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码通过使用嵌套的`for`循环来遍历顶点数组，首先遍历前四个顶点。`currentVertex + 1`，`currentVertex
    + 2`等等。
- en: We access each vertex in the array using array notation. `rvA[currentVertex
    + 0]..` and so on. Using array notation we call the `position` function `rvA[currentVertex
    + 0].position...`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数组表示法访问数组中的每个顶点。`rvA[currentVertex + 0]..`等等。使用数组表示法，我们调用`position`函数`rvA[currentVertex
    + 0].position...`。
- en: Into the `position` function we pass the horizontal and vertical coordinates
    of each vertex. We can work these coordinates out programmatically by using a
    combination of `w`, `h`, and `TILE_SIZE`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`position`函数中，我们传递每个顶点的水平和垂直坐标。我们可以通过使用`w`、`h`和`TILE_SIZE`的组合来以编程方式计算这些坐标。
- en: At the end of the previous code we position `currentVertex` ready for the next
    pass through the nested `for` loop by advancing it four places (adding four) with
    the code `currentVertex = currentVertex + VERTS_IN_QUAD`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码结束时，我们通过使用代码`currentVertex = currentVertex + VERTS_IN_QUAD`将`currentVertex`定位到下一个嵌套`for`循环的位置，使其向前移动四个位置（加四）。
- en: Of course, all this does is set the coordinates of our vertices; it doesn't
    assign a texture coordinate from the sprite sheet. This is what we will do next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些只是设置了我们顶点的坐标；它并没有从精灵表中分配纹理坐标。这是我们接下来要做的事情。
- en: 'To make it absolutely clear where the new code goes I have shown it in context
    with all the code that we wrote a moment ago. Add and study the highlighted code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地表明新代码放在哪里，我已经在我们刚刚编写的所有代码的上下文中显示了它。添加并学习突出显示的代码：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous code sets up the coordinates within the sprite sheet that each
    vertex is related to. Notice the somewhat long if condition. The condition checks
    whether the current quad is either one of the very first or the very last quads
    in the arena. If it is then this means it is part of the boundary. We can then
    use a simple formula using `TILE_SIZE` and `TILE_TYPES` to target the wall texture
    from the sprite sheet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码设置了每个顶点在精灵表中的坐标。请注意有点长的if条件。该条件检查当前四边形是否是竞技场中的第一个或最后一个四边形。如果是，则意味着它是边界的一部分。然后我们可以使用一个简单的公式，使用`TILE_SIZE`和`TILE_TYPES`来从精灵表中选择墙壁纹理。
- en: Array notation and the `texCoords` member are initialized for each vertex in
    turn to assign the appropriate corner of the wall texture within the sprite sheet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个初始化数组表示法和`texCoords`成员，以为每个顶点分配墙纹理在精灵表中的适当角落。
- en: 'The following code is wrapped in an `else` block. This means that it will run
    each time through the nested for loop when the quad does not represent a border/wall
    tile. Add the highlighted code amongst the existing code and we can then examine
    it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含在`else`块中。这意味着每次通过嵌套的for循环时，当四边形不代表边界/墙砖时，它将运行。在现有代码中添加突出显示的代码，然后我们可以检查它：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The previous new code starts by seeding the random number generator with a formula
    that will be different each pass through the loop. Then the `mOrG` variable is
    initialized with a number between 0 and `TILE_TYPES`. This is just what we need
    to pick one of the tile types randomly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的新代码首先使用一个公式来为随机数生成器提供种子，每次通过循环时都会有不同的公式。然后，`mOrG`变量用一个介于0和`TILE_TYPES`之间的数字进行初始化。这正是我们随机选择瓦片类型所需要的。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`mOrG` stands for mud or grass. The name is arbitrary.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`mOrG`代表泥土或草。名称是任意的。'
- en: Now we declare and initialize a variable called `verticalOffset` by multiplying
    `mOrG` by `TileSize`. We now have a vertical reference point within the sprite
    sheet to the starting height of the randomly chosen texture for the current quad.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过将`mOrG`乘以`TileSize`来声明和初始化一个名为`verticalOffset`的变量。现在我们在精灵表中有一个垂直参考点，指向当前四边形随机选择的纹理的起始高度。
- en: Now we use a simple formula involving `TILE_SIZE` and `verticalOffset` to assign
    the precise coordinates of each corner of the texture to the appropriate vertex.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用一个简单的公式，涉及`TILE_SIZE`和`verticalOffset`，来为纹理的每个角分配精确的坐标到适当的顶点。
- en: Now we can put our new function to work in the game engine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让我们的新函数在游戏引擎中发挥作用了。
- en: Using the background
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用背景
- en: 'We have done the tricky stuff, this will be simple. There are three steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了棘手的事情，这将很简单。有三个步骤：
- en: Create a `VertexArray`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`VertexArray`。
- en: Initialize it after leveling up each wave.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个波次升级后初始化它。
- en: Draw it in each frame.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一帧中绘制它。
- en: 'Add the code highlighted in the following to declare a `VertexArray` called
    `background` and load the `background_sheet.png` as a texture:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码来声明一个名为`background`的`VertexArray`，并加载`background_sheet.png`作为纹理：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code to call the `createBackground` function, passing in
    `background` as a reference and `arena` by value. Notice in the highlighted code
    that we have also modified the way that we initialize the `tileSize` variable.
    Add the highlighted code exactly as shown:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码来调用`createBackground`函数，传入`background`作为引用和`arena`作为值。请注意在突出显示的代码中，我们还修改了初始化`tileSize`变量的方式。按照突出显示的代码精确添加：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note we have replaced the `int tileSize = 50` line of code because we get the
    value directly from the return value of the `createBackground` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经替换了`int tileSize = 50`这行代码，因为我们直接从`createBackground`函数的返回值中获取了该值。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the sake of future code clarity, you should delete the `int tileSize = 50`
    line of code and its related comment. I just commented it out to give the new
    code a clearer context.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以后的代码清晰起见，你应该删除`int tileSize = 50`这行代码及其相关的注释。我只是将它注释掉，以便为新代码提供更清晰的上下文。
- en: 'Finally, it is time to do the drawing. This is really simple. All we do is
    call `window.draw` and pass the `VertexArray` along with the `textureBackground`
    texture:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候开始绘制了。这很简单。我们只需要调用`window.draw`并传递`VertexArray`以及`textureBackground`纹理：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are wondering what is going on with the odd-looking `&` sign in front
    of `textureBackground`, then all will be made clear in the next chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道`textureBackground`前面那个奇怪的`&`符号是什么意思，那么一切将在下一章中变得清晰起来。
- en: 'You can now run the game as shown in this next image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以按照下图运行游戏：
- en: '![Using the background](img/image_07_003.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![使用背景](img/image_07_003.jpg)'
- en: 'Note how the player sprite glides and rotates smoothly within the arena confines.
    Although the current code in main draws a small arena, the `CreateBackground`
    function can create an arena of any size we tell it. We will see arenas bigger
    than the screen in [Chapter 11](ch11.html "Chapter 11. Sound Effects, File I/O,
    and Finishing the Game"): *Sound Effects, File I/O, and Finishing the Game*.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，玩家精灵在竞技场范围内平稳滑动和旋转。尽管主要代码中绘制了一个小竞技场，但`CreateBackground`函数可以创建我们告诉它的任何大小的竞技场。我们将在[第11章](ch11.html
    "第11章。声音效果，文件I/O和完成游戏")中看到比屏幕更大的竞技场：*声音效果，文件I/O和完成游戏*。
- en: FAQ
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FAQ
- en: 'Here are some questions that might be on your mind:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能在你脑海中的问题：
- en: Q) Can you summarize these references again?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Q）你能再总结一下这些参考资料吗？
- en: A) You must initialize a reference immediately and cannot change it to reference
    another variable. Use references with functions so you are not working on a copy.
    This is good for efficiency because it avoids making copies and helps us more
    easily abstract our code into functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: A）你必须立即初始化引用，并且不能将其更改为引用另一个变量。使用引用与函数一起，这样你就不会在副本上工作。这对效率很有好处，因为它避免了制作副本，并帮助我们更容易地将代码抽象成函数。
- en: Q) Is there an easy way to remember the main benefit of using references?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Q）有没有一种简单的方法来记住使用引用的主要好处？
- en: 'A) To help you remember what a reference is for, consider this short rhyme:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: A）为了帮助你记住引用的用途，考虑一下这首简短的韵文：
- en: '*Moving large objects can make our games choppy, passing by reference is faster
    than copy.*'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*移动大对象可能会使我们的游戏变得卡顿，通过引用传递比复制更快。*'
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we discovered C++ references that are special variables that
    act as an alias to another variable. When we pass a variable by reference instead
    of by value, then any work we do on the reference happens to the variable back
    in the calling function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了C++引用，它们是特殊的变量，充当另一个变量的别名。当我们通过引用而不是值传递变量时，我们对引用所做的任何工作都会发生在调用函数中的变量上。
- en: We also learnt about vertex arrays and created a vertex array full of quads
    to draw the tiles from a sprite sheet as a background.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了关于顶点数组，并创建了一个充满四边形的顶点数组，以从精灵表中绘制瓦片作为背景。
- en: The elephant in the room, of course, is that our zombie game doesn't have any
    zombies. Let's fix that now by learning about C++ pointers and the Standard Template
    Library.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，房间里的大象是，我们的僵尸游戏没有任何僵尸。现在让我们通过学习C++指针和标准模板库来解决这个问题。
