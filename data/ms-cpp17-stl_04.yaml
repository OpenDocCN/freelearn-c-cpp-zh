- en: The Container Zoo
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器动物园
- en: 'In the previous two chapters, we introduced the ideas of *iterators* and *ranges*
    ([Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d), *Iterators
    and Ranges*) and the vast library of standard *generic algorithms* that operate
    on ranges of data elements defined by pairs of those iterators ([Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*). In this chapter, we''ll look at where those data
    elements themselves are allocated and stored. That is, now that we know all about
    how to iterate, the question gains urgency: what is it that we are iterating *over?*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们介绍了 *迭代器* 和 *范围* 的概念（[第 2 章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)，*迭代器和范围*）以及操作由这些迭代器定义的数据元素范围的庞大标准
    *泛型算法* 库（[第 3 章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，*迭代器对算法*）。在本章中，我们将探讨这些数据元素本身是如何分配和存储的。也就是说，现在我们已经了解了如何迭代，问题变得紧迫：我们是在迭代
    *什么*？
- en: 'In the Standard Template Library, the answer to that question is generally:
    We are iterating over some sub-range of the elements contained in a *container*.
    A container is simply a C++ class (or class template) which, by its nature, *contains*
    (or *owns*) a homogeneous range of data elements, and exposes that range for iteration
    by generic algorithms.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准模板库中，对这个问题的回答通常是：我们正在迭代一个 *容器* 中包含的元素的一些子范围。容器简单地是一个 C++ 类（或类模板），根据其本质，*包含*（或*拥有*）一组同质的数据元素，并通过泛型算法公开该范围以进行迭代。
- en: 'Topics we will cover in this chapter are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题是：
- en: The notion of one object *owning* another (this being the essential difference
    between a *container* and a *range*)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象 *拥有* 另一个对象的概念（这是 *容器* 和 *范围* 之间的本质区别）
- en: The sequence containers (`array`, `vector`, `list`, and `forward_list`)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列容器（`array`、`vector`、`list` 和 `forward_list`）
- en: The pitfalls of iterator invalidation and reference invalidation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器无效化和引用无效化的陷阱
- en: The container adaptors (`stack`, `queue`, and `priority_queue`)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器适配器（`stack`、`queue` 和 `priority_queue`）
- en: The associative containers (`set`, `map`, and friends)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联容器（`set`、`map` 和相关容器）
- en: When it is appropriate to provide a *comparator*, *hash function*, *equality
    comparator*, or *allocator* as additional template type parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提供 *比较器*、*哈希函数*、*等价比较器* 或 *分配器* 作为额外的模板类型参数是合适的时候
- en: The notion of ownership
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有权的概念
- en: When we say that object `A` *owns* object `B`, what we mean is that object `A`
    manages the lifetime of object `B`--that `A` controls the construction, copying,
    moving, and destruction of object `B`. The user of object `A` can (and should)
    "forget about" managing `B` (for example, via explicit calls to `delete B`, `fclose(B)`,
    and so on).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说对象 `A` *拥有* 对象 `B` 时，我们的意思是对象 `A` 管理对象 `B` 的生命周期--即 `A` 控制对象 `B` 的构造、复制、移动和销毁。对象
    `A` 的用户可以（并且应该）“忘记”管理 `B`（例如，通过显式调用 `delete B`、`fclose(B)` 等）。
- en: 'The simplest way for an object `A` to "own" an object `B` is for `B` to be
    a member variable of `A`. For example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对象 `A` “拥有”对象 `B` 的最简单方式是让 `B` 成为 `A` 的成员变量。例如：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another way is for `A` to hold a pointer to `B`, with the appropriate code
    in `~A()` (and, if necessary, in the copy and move operations of `A`) to clean
    up the resources associated with that pointer:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是让 `A` 持有对 `B` 的指针，并在 `~A()`（以及必要时在 `A` 的复制和移动操作中）中编写适当的代码来清理与该指针关联的资源：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The notion of *ownership* is tightly bound up with the C++-specific catchphrase
    **Resource Allocation Is Initialization**, which you will often see abbreviated
    as **RAII**. (That cumbersome abbreviation should properly have been more like
    "Resource Freeing Is Destruction", but that acronym was taken.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有权的概念与 C++ 特有的口号 **资源分配是初始化** 紧密相关，这个口号通常缩写为 **RAII**。（这个繁琐的缩写本应更像是“资源释放是销毁”，但那个缩写已被占用。）
- en: The goal of the standard *container classes* is to provide access to a particular
    bunch of data objects `B`, while making sure that the *ownership* of those objects
    is always clear--namely, a container always has ownership of its data elements.
    (Contrariwise, an *iterator*, or a pair of iterators defining a *range*, never
    owns its data elements; we saw in [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*, that the standard iterator-based algorithms such
    as `std::remove_if` never actually deallocate any elements, but instead simply
    permute the values of the elements in various ways.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 *容器类* 的目标是提供对特定的一组数据对象 `B` 的访问，同时确保这些对象的 *所有权* 总是清晰的——也就是说，容器总是拥有其数据元素的所有权。（相反，*迭代器*
    或定义 *范围* 的迭代器对，永远不会拥有其数据元素；我们在 [第 3 章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，*迭代器对算法*
    中看到，标准的基于迭代器的算法，如 `std::remove_if`，实际上从未真正释放任何元素，而是简单地以各种方式重新排列元素值。）
- en: In the remainder of this chapter, we'll explore the various standard container
    classes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将探讨各种标准容器类。
- en: 'The simplest container: std::array<T, N>'
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最简单的容器：std::array<T, N>
- en: The simplest standard container class is `std::array<T, N>`, which behaves just
    like a built-in ("C-style") array. The first template parameter to `std::array`
    indicates the type of the array's elements, and the second template parameter
    indicates the number of elements in the array. This is one of the very few places
    in the standard library where a template parameter is an integer value instead
    of the name of a type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的标准容器类是 `std::array<T, N>`，它的行为就像内置的（“C 风格”）数组。`std::array` 的第一个模板参数指示数组元素的类型，第二个模板参数指示数组中的元素数量。这是标准库中非常少数几个模板参数是整数值而不是类型名称的地方。
- en: '![](img/00006.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00006.jpeg)'
- en: 'Normal C-style arrays, being part of the core language (and a part that dates
    back to the 1970s, at that!), do not provide any built-in operations that would
    take linear time to run. C-style arrays let you index into them with `operator[]`,
    and compare their addresses, since those operations can be done in constant time;
    but if you want to assign the entire contents of one C-style array to another,
    or compare the contents of two arrays, you''ll find that you can''t do it straightforwardly.
    You''ll have to use some of the standard algorithms we discussed in [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*, such as `std::copy` or `std::equal` (the function
    template `std::swap`, being an "algorithm" already, *does* work for C-style arrays.
    It would be a shame if it didn''t work.):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '正常的 C 风格数组，作为核心语言的一部分（并且是追溯到 1970 年代的那一部分！），不提供任何会以线性时间运行的内置操作。C 风格数组允许你使用
    `operator[]` 来索引它们，并比较它们的地址，因为这些操作可以在常数时间内完成；但如果你想要将一个 C 风格数组的全部内容赋值给另一个，或者比较两个数组的全部内容，你会发现你不能直接这样做。你必须使用我们在
    [第 3 章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，*迭代器对算法* 中讨论的一些标准算法，例如
    `std::copy` 或 `std::equal`（函数模板 `std::swap` 已经是一个“算法”，*确实* 可以用于 C 风格数组。如果它不起作用，那就太遗憾了）： '
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`std::array` behaves just like a C-style array, but with more syntactic sugar.
    It offers `.begin()` and `.end()` member functions; and it overloads the operators
    `=`, `==`, and `<` to do the natural things. All of these operations still take
    time linear in the size of the array, because they have to walk through the array
    copying (or swapping or comparing) each individual element one at a time.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array` 的行为就像 C 风格数组，但提供了更多的语法糖。它提供了 `.begin()` 和 `.end()` 成员函数；并且它重载了
    `=`, `==`, 和 `<` 运算符以执行自然的事情。所有这些操作仍然需要与数组大小成线性时间的开销，因为它们必须遍历数组，逐个复制（或交换或比较）每个单独的元素。'
- en: 'One gripe about `std::array`, which you''ll see recurring for a few of these
    standard container classes, is that when you construct a `std::array` with an
    initializer list inside a set of curly braces, you actually need to write *two*
    sets of curly braces. That''s one set for the "outer object" of type `std::array<T,
    N>`, and another set for the "inner data member" of type `T[N]`. This is a bit
    annoying at first, but the double-brace syntax will quickly become second nature
    once you have used it a few times:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `std::array` 有一点抱怨，你会在这些标准容器类中看到，那就是当你使用花括号内的初始化列表构造一个 `std::array` 时，你实际上需要写
    *两组* 花括号。这是为 `std::array<T, N>` 类型的“外部对象”写的一组，以及为 `T[N]` 类型的“内部数据成员”写的一组。一开始这有点烦人，但一旦你使用了几次，双花括号语法会很快成为第二本能：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One other benefit of `std::array` is that you can return one from a function,
    which you can''t do with C-style arrays:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array` 的另一个好处是你可以从函数中返回一个，这是你不能用 C 风格数组做到的：'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because `std::array` has a copy constructor and a copy assignment operator,
    you can also store them in containers: for example, `std::vector<std::array<int,
    3>>` is fine whereas `std::vector<int[3]>` wouldn''t work.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `std::array` 有拷贝构造函数和拷贝赋值运算符，你还可以将它们存储在容器中：例如，`std::vector<std::array<int,
    3>>` 是可以的，而 `std::vector<int[3]>` 则不行。
- en: However, if you find yourself returning arrays from functions or storing arrays
    in containers very often, you should consider whether "array" is really the right
    abstraction for your purposes. Would it be more appropriate to wrap that array
    up into some kind of class type?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你发现自己经常从函数中返回数组或将数组存储在容器中，你应该考虑“数组”是否真的是你目的的正确抽象。将那个数组封装成某种类类型可能更合适吗？
- en: 'In the case of our `cross_product` example, it turns out to be an extremely
    good idea to encapsulate our "array of three integers" in a class type. Not only
    does this allow us to name the members (`x`, `y`, and `z`), but we can also initialize
    objects of the `Vec3` class type more easily (no second pair of curly braces!)
    and perhaps most importantly for our future sanity, we can avoid defining the
    comparison operators such as `operator<` which don''t actually make sense for
    our mathematical domain. Using `std::array`, we have to deal with the fact that
    the array `{1, 2, 3}` compares "less than" the array `{1, 3, -9}`--but when we
    define our own `class Vec3`, we can simply omit any mention of `operator<` and
    thus ensure that nobody will ever accidentally misuse it in a mathematical context:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `cross_product` 示例中，将我们的“三个整数的数组”封装成一个类类型是一个非常极好的主意。这不仅允许我们命名成员（`x`、`y`
    和 `z`），而且我们可以更容易地初始化 `Vec3` 类类型的对象（不需要第二对花括号！）并且也许最重要的是，为了我们未来的理智，我们可以避免定义比较运算符，如
    `operator<`，这些运算符实际上对我们数学领域没有意义。使用 `std::array`，我们必须处理这样一个事实，即数组 `{1, 2, 3}` 与数组
    `{1, 3, -9}` 相比是“小于”的——但当我们定义自己的 `class Vec3` 时，我们可以简单地省略对 `operator<` 的任何提及，从而确保没有人会意外地在数学环境中误用它：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`std::array` holds its elements inside itself. Therefore, `sizeof (std::array<int,
    100>)` is equal to `sizeof (int[100])`, which is equal to `100 * sizeof (int)`.
    Don''t make the mistake of trying to place a gigantic array on the stack as a
    local variable!'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array` 在其内部持有其元素。因此，`sizeof (std::array<int, 100>)` 等于 `sizeof (int[100])`，等于
    `100 * sizeof (int)`。不要犯试图将巨大的数组作为局部变量放在栈上的错误！'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Working with "gigantic arrays" is a job for the next container on our list:
    `std::vector`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与“巨大的数组”打交道是我们列表中下一个容器的工作：`std::vector`。
- en: 'The workhorse: std::vector<T>'
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作马：`std::vector<T>`
- en: '`std::vector` represents a contiguous array of data elements, but allocated
    on the heap instead of on the stack. This improves on `std::array` in two ways:
    First, it allows us to create a really gigantic array without blowing our stack.
    Second, it allows us to resize the underlying array dynamically--unlike `std::array<int,
    3>` where the size of the array is an immutable part of the type, a `std::vector<int>`
    has no intrinsic size. A vector''s `.size()` method actually yields useful information
    about the current state of the vector.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 表示一个数据元素的字节连续数组，但分配在堆上而不是栈上。这比 `std::array` 有两个改进：首先，它允许我们创建一个非常大的数组而不会耗尽栈空间。其次，它允许我们动态地调整底层数组的大小——与
    `std::array<int, 3>` 不同，其中数组的大小是类型不可变的一部分，一个 `std::vector<int>` 没有固有的大小。向量的 `.size()`
    方法实际上提供了关于向量当前状态的 useful 信息。'
- en: 'A `std::vector` has one other salient attribute: its *capacity*. The capacity
    of a vector is always at least as large as its size, and represents the number
    of elements that the vector currently *could* hold, before it would need to reallocate
    its underlying array:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 有另一个显著的属性：其 *容量*。向量的容量始终不小于其大小，表示向量当前 *可以* 持有的元素数量，在它需要重新分配其底层数组之前：'
- en: '![](img/00007.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: Other than its resizeability, `vector` behaves similarly to `array`. Like arrays,
    vectors are copyable (copying all their data elements, in linear time) and comparable
    (`std::vector<T>::operator<` will report the lexicographical order of the operands
    by delegating to `T::operator<`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可调整大小之外，`vector` 的行为与 `array` 类似。像数组一样，向量是可复制的（在线性时间内复制所有数据元素）并且可比较的（`std::vector<T>::operator<`
    将通过委托给 `T::operator<` 报告操作数的字典序）。
- en: Generally speaking, `std::vector` is the most commonly used container in the
    entire standard library. Any time you need to store a "lot" of elements (or "I'm
    not sure how many elements I have"), your first thought should always be to use
    a `vector`. Why? Because `vector` gives you all the flexibility of a resizeable
    container, with all the simplicity and efficiency of a contiguous array.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，`std::vector`是整个标准库中最常用的容器。每次你需要存储“大量”元素（或“我不确定我有多少元素”）时，你的第一个想法应该是使用`vector`。为什么？因为`vector`提供了可调整大小容器的所有灵活性，同时具有连续数组的简单性和效率。
- en: 'Contiguous arrays are the most efficient data structures (on typical hardware)
    because they provide good *locality*, also known as `cache-friendliness`. When
    you''re traversing a vector in order from its `.begin()` to its `.end()`, you''re
    also traversing *memory* in order, which means that the computer''s hardware can
    predict with very high accuracy the next piece of memory you''re going to look
    at. Compare this to a linked list, in which traversing from `.begin()` to `.end()`
    might well involve following pointers all over the address space, and accessing
    memory locations in no sensible order. With a linked list, pretty much every address
    you hit will be unrelated to the previous one, and so none of them will be in
    the CPU''s cache. With a vector (or array), the opposite is true: every address
    you hit will be related to the previous one by a simple linear relationship, and
    the CPU will be able to have the values all ready and waiting for you by the time
    you need them.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 连续数组是最有效的数据结构（在典型硬件上），因为它们提供了良好的**局部性**，也称为`缓存友好性`。当你按顺序从`.begin()`到`.end()`遍历向量时，你也在按顺序遍历**内存**，这意味着计算机的硬件可以非常准确地预测你将要查看的下一块内存。将此与链表进行比较，其中从`.begin()`到`.end()`的遍历可能涉及在整个地址空间中跟随指针，并且按无序的方式访问内存位置。在链表中，几乎每个你访问的地址都与前一个地址无关，因此它们都不会在CPU的缓存中。在向量（或数组）中，情况正好相反：你访问的每个地址都将与前一个地址通过简单的线性关系相关联，CPU将能够在你需要时准备好所有这些值。
- en: Even if your data is "more structured" than a simple list of values, you can
    often get away with using a `vector` to store it. We'll see near the end of this
    chapter how you can use `vector` to simulate a stack or a priority queue.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的数据比简单的值列表“更有结构”，你通常也可以使用`vector`来存储它。我们将在本章末尾看到如何使用`vector`来模拟栈或优先队列。
- en: Resizing a std::vector
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整`std::vector`的大小
- en: '`std::vector` has a whole family of member functions concerned with adding
    and deleting elements. These member functions aren''t present in `std::array`
    because `std::array` isn''t resizable; but they *are* present in most of the other
    containers we''re going to be talking about in this chapter. So it''s a good idea
    to get familiar with them now.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`有一系列成员函数，用于添加和删除元素。这些成员函数在`std::array`中不存在，因为`std::array`是不可调整大小的；但它们在其他我们将要讨论的容器中大多数都存在。因此，现在熟悉它们是个好主意。'
- en: 'Let''s start with the two primitive operations specific to `vector` itself:
    `.resize()` and `.reserve()`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从针对`vector`本身的两个基本操作开始：`.resize()`和`.reserve()`。
- en: '`vec.reserve(c)` updates the capacity of the vector--it "reserves" space for
    as many as `c` elements (total) in the underlying array. If `c <= vec.capacity()`
    then nothing happens; but if `c > vec.capacity()` then the vector will have to
    reallocate its underlying array. Reallocation follows an algorithm equivalent
    to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec.reserve(c)`更新向量的容量——它“预留”了足够的空间来存储多达`c`个元素（总计）。如果`c <= vec.capacity()`，则不会发生任何操作；但如果`c
    > vec.capacity()`，则向量将不得不重新分配其基本数组。重新分配遵循以下等效算法：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you''ve been reading this book in order, you might recognize that the crucial
    for-loop in this `.reserve()` function closely resembles the implementation of
    `std::uninitialized_copy(a,b,c)` from [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*. Indeed, if you were implementing `.reserve()`
    on a container that was not allocator-aware (see [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d),
    *Allocators*), you might reuse that standard algorithm:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按顺序阅读这本书，你可能会认出这个`.reserve()`函数中的关键for循环与[第3章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)中`std::uninitialized_copy(a,b,c)`的实现非常相似，*迭代器对算法*。实际上，如果你在一个非分配器感知的容器上实现`.reserve()`（见[第8章](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d)，*分配器*），你可能重用那个标准算法：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`vec.resize(s)` changes the size of the vector--it chops elements off the end
    of the vector (calling their destructors in the process), or adds additional elements
    to the vector (default-constructing them), until the size of the vector is equal
    to `s`. If `s > vec.capacity()`, then the vector will have to reallocate its underlying
    array, just as in the `.reserve()` case.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec.resize(s)`改变向量的大小——它从向量末尾切掉元素（在这个过程中调用它们的析构函数），或者向向量中添加额外的元素（默认构造它们），直到向量的大小等于`s`。如果`s
    > vec.capacity()`，则向量将不得不像在`.reserve()`情况下一样重新分配其底层数组。'
- en: 'You may have noticed that when a vector reallocates its underlying array, the
    elements change addresses: the address of `vec[0]` before the reallocation is
    different from the address of `vec[0]` after the reallocation. Any pointers that
    pointed to the vector''s old elements become "dangling pointers." And since `std::vector::iterator`
    is essentially just a pointer as well, any *iterators* that pointed to the vector''s
    old elements become invalid as well. This phenomenon is called *iterator invalidation*,
    and it is a major source of bugs in C++ code. Watch out when you''re dealing with
    iterators and resizing vectors at the same time!'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当一个向量重新分配其底层数组时，元素地址会发生变化：重新分配前`vec[0]`的地址与重新分配后`vec[0]`的地址不同。任何指向向量旧元素的指针都变成了“悬垂指针”。由于`std::vector::iterator`本质上也是一个指针，因此任何指向向量旧元素的迭代器也变得无效。这种现象被称为*迭代器失效*，它是C++代码中bug的主要来源。当你同时处理迭代器和调整向量大小时要小心！
- en: 'Here are some classic cases of iterator invalidation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些经典的迭代器失效案例：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here''s another case, familiar from many other programming languages as
    well, in which erasing elements from a container while iterating over it produces
    subtle bugs:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个案例，这在许多其他编程语言中也很常见，即在迭代容器的同时删除元素会产生微妙的bug：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Inserting and erasing in a std::vector
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在std::vector中插入和删除
- en: '`vec.push_back(t)` adds an item to the end of the vector. There is no corresponding
    `.push_front()` member function, because as you can see from the diagram at the
    start of this section, there''s no efficient way to push anything onto the *front*
    of a vector.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec.push_back(t)`向向量的末尾添加一个项目。没有对应的`.push_front()`成员函数，因为正如本节开头所示，没有一种有效的方法可以将任何东西推送到向量的*前端*。'
- en: '`vec.emplace_back(args...)` is a perfect-forwarding variadic function template
    that acts just like `.push_back(t)`, except that, instead of placing a copy of
    `t` at the end of the vector, it places a `T` object constructed as if by `T(args...)`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec.emplace_back(args...)`是一个完美前向变长函数模板，其行为就像`.push_back(t)`一样，除了它不是在向量的末尾放置`t`的副本，而是放置一个`T`对象，就像通过`T(args...)`构造一样。'
- en: Both `push_back` and `emplace_back` have what is called "amortized constant
    time" performance. To see what this means, consider what would happen to a naive
    vector if you call `v.emplace_back()` a hundred times in a row. With each call,
    the vector needs to get just a little bit bigger; so it reallocates its underlying
    array and moves all `v.size()` elements from the old array to the new one. Soon
    you'd be spending more time copying old data from place to place than you're spending
    actually "pushing back" new data! Fortunately, `std::vector` is smart enough to
    avoid this trap. Whenever an operation such as `v.emplace_back()` causes reallocation,
    the vector won't make room for just `capacity() + 1` elements in the new array;
    it will make room for `k * capacity()` elements (where `k` is 2 for libc++ and
    libstdc++, and approximately 1.5 for Visual Studio). So, although reallocation
    gets more and more expensive as the vector grows, you do fewer and fewer reallocations
    per `push_back`--and so the cost of a single `push_back` is constant, *on average*.
    This trick is known as *geometric resizing*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`push_back`和`emplace_back`都有所谓的“摊销常数时间”性能。要了解这意味着什么，考虑如果你连续调用`v.emplace_back()`一百次会发生什么。每次调用，向量都需要稍微变大；因此它重新分配其底层数组并将所有`v.size()`个元素从旧数组移动到新数组。很快，你花费在复制旧数据上的时间就会比实际“推回”新数据的时间多！幸运的是，`std::vector`足够聪明，可以避免这个陷阱。每当像`v.emplace_back()`这样的操作导致重新分配时，向量不会只为`capacity()
    + 1`个元素在新数组中留出空间；它将为`k * capacity()`个元素留出空间（其中`k`对于libc++和libstdc++是2，对于Visual
    Studio大约是1.5）。因此，尽管随着向量的增长重新分配变得越来越昂贵，但每次`push_back`的重新分配次数越来越少——因此单个`push_back`的成本在平均上是常数。这个技巧被称为*几何扩展*。'
- en: '`vec.insert(it, t)` adds an item into the middle of the vector, at the position
    indicated by the iterator `it`. If `it == vec.end()`, then this is equivalent
    to `push_back`; if `it == vec.begin()`, then this is a poor man''s version of
    `push_front`. Notice that, if you insert anywhere but the end of the vector, all
    the elements after the insertion point in the underlying array will get shifted
    over to make room; this can be expensive.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec.insert(it, t)`将一个项目插入到向量的中间，位置由迭代器`it`指示。如果`it == vec.end()`，则这相当于`push_back`；如果`it
    == vec.begin()`，则这是一个简化的`push_front`版本。请注意，如果你不在向量的末尾插入，那么在插入点之后的底层数组中的所有元素都将被移位以腾出空间；这可能会很昂贵。'
- en: 'There are several different overloads of `.insert()`. Generally speaking, none
    of these will be useful to you, but you might want to be aware of them in order
    to interpret the cryptic error messages (or cryptic runtime bugs) that will show
    up if you accidentally provide the wrong arguments to `.insert()` and overload
    resolution ends up picking one of these instead of the one you expected:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`.insert()`有几个不同的重载。一般来说，这些都不会对你有用，但你可能想了解它们，以便解释当你错误地提供`.insert()`的参数时出现的神秘错误消息（或神秘的运行时错误）；如果重载解析最终选择的是你期望之外的这些中的一个：'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`vec.emplace(it, args...)` is to `insert` as `emplace_back` is to `push_back`:
    it''s a perfect-forwarding version of the C++03 function. Prefer `emplace` and
    `emplace_back` over `insert` and `push_back`, when possible.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec.emplace(it, args...)`与`insert`的关系类似于`emplace_back`与`push_back`的关系：它是C++03函数的一个完美转发版本。当可能时，优先使用`emplace`和`emplace_back`而不是`insert`和`push_back`。'
- en: '`vec.erase(it)` erases a single item from the middle of a vector, at the position
    indicated by the iterator `it`. There''s also a two-iterator version, `vec.erase(it,
    it)`, which erases a contiguous range of items. Notice that this two-iterator
    version is the same one we used in the *erase-remove idiom* in the previous chapter.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec.erase(it)`从向量的中间位置删除单个项目，位置由迭代器`it`指示。还有一个两个迭代器的版本，`vec.erase(it, it)`，用于删除一系列连续的项目。请注意，这个两个迭代器的版本与我们在上一章中使用的*erase-remove习语*是相同的。'
- en: To delete just the last element from the vector, you could use either `vec.erase(vec.end()-1)`
    or `vec.erase(vec.end()-1, vec.end())`; but since this is a common operation,
    the standard library provides a synonym in the form of `vec.pop_back()`. You can
    implement a dynamically growable *stack* using nothing more than the `push_back()`
    and `pop_back()` methods of `std::vector`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要从向量中删除最后一个元素，你可以使用`vec.erase(vec.end()-1)`或`vec.erase(vec.end()-1, vec.end())`；但由于这是一个常见的操作，标准库提供了一个同义词，形式为`vec.pop_back()`。你可以仅使用`std::vector`的`push_back()`和`pop_back()`方法来实现一个动态增长的*栈*。
- en: Pitfalls with vector<bool>
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量<bool>的陷阱
- en: 'The `std::vector` template has one special case: `std::vector<bool>`. Since
    the `bool` datatype has only two possible values, the values of eight bools can
    be packed into a single byte. `std::vector<bool>` uses this optimization, which
    means that it uses eight times less heap-allocated memory than you might naturally
    expect.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`模板有一个特殊情况：`std::vector<bool>`。由于`bool`数据类型只有两个可能的值，八个`bool`的值可以打包到一个字节中。`std::vector<bool>`使用这种优化，这意味着它使用的堆分配内存比预期的少八倍。'
- en: '![](img/00008.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00008.jpeg)'
- en: The downside of this packing is that the return type of `vector<bool>::operator[]`
    cannot be `bool&`, because the vector doesn't store actual `bool` objects anywhere.
    Therefore, `operator[]` returns a customized class type, `std::vector<bool>::reference`,
    which is convertible to `bool` but which is not, itself, a `bool` (types like
    this are often called "proxy types" or "proxy references").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种打包的缺点是`vector<bool>::operator[]`的返回类型不能是`bool&`，因为向量没有在任何地方存储实际的`bool`对象。因此，`operator[]`返回一个定制的类类型，`std::vector<bool>::reference`，它可以转换为`bool`，但它本身不是`bool`（这种类型的类型通常被称为“代理类型”或“代理引用”）。
- en: 'The result type of `operator[] const` is "officially" `bool`, but in practice,
    some libraries (notably libc++) return a proxy type for `operator[] const`. This
    means that code using `vector<bool>` is not only subtle but sometimes non-portable
    as well; I advise avoiding `vector<bool>` if you can:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator[] const`的结果类型“官方上”是`bool`，但在实践中，一些库（特别是libc++）为`operator[] const`返回一个代理类型。这意味着使用`vector<bool>`的代码不仅微妙，有时甚至不可移植；如果你可以的话，我建议避免使用`vector<bool>`：'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Pitfalls with non-noexcept move constructors
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非noexcept移动构造函数的陷阱
- en: Recall the implementation of `vector::resize()` from section *Resizing a std::vector*.
    When the vector resizes, it reallocates its underlying array and moves its elements
    into the new array--unless the element type is not "nothrow move-constructible,"
    in which case it *copies* its elements! What this means is that resizing a vector
    of your own class type will be unnecessarily "pessimized" unless you go out of
    your way to specify that your move constructor is `noexcept`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在 *Resizing a std::vector* 部分中 `vector::resize()` 的实现。当向量调整大小时，它会重新分配其底层数组并将元素移动到新数组中——除非元素类型不是“nothrow
    move-constructible”，在这种情况下它会*复制*其元素！这意味着，除非你特意指定你的移动构造函数是 `noexcept`，否则调整你自己的类类型向量的大小将会是不必要的“最优化”。
- en: 'Consider the following class definitions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类定义：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can test the behavior of these classes in isolation using a test harness
    such as the following. Running `test()` will print "copy Bad--move Good--copy
    Bad--move Good." What an appropriate mantra!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下测试框架等单独测试这些类的行为。运行 `test()` 将打印 "copy Bad--move Good--copy Bad--move
    Good。"多么恰当的咒语！
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is a subtle and arcane point, but it can have a major effect on the efficiency
    of your C++ code in practice. A good rule of thumb is: Whenever you declare your
    own move constructor or swap function, make sure you declare it `noexcept`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙且晦涩的观点，但它可能会对你在实践中 C++ 代码的效率产生重大影响。一个很好的经验法则是：无论何时声明你自己的移动构造函数或交换函数，确保你声明它为
    `noexcept`。
- en: 'The speedy hybrid: std::deque<T>'
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速混合型：std::deque<T>
- en: 'Like `std::vector`, `std::deque` presents the interface of a contiguous array--it
    is random-access, and its elements are stored in contiguous blocks for cache-friendliness.
    But unlike `vector`, its elements are only "chunkwise" contiguous. A single deque
    is made up of an arbitrary number of "chunks," each containing a fixed number
    of elements. To insert more elements on either end of the container is cheap;
    to insert elements in the middle is still expensive. In memory it looks something
    like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::vector` 类似，`std::deque` 提供了连续数组的接口——它是随机访问的，并且其元素以连续块的形式存储，以便于缓存友好。但与
    `vector` 不同，其元素只是“块状”连续的。一个 deque 由任意数量的“块”组成，每个块包含固定数量的元素。在容器的两端插入更多元素的成本较低；在中间插入元素的成本仍然较高。在内存中它看起来像这样：
- en: '![](img/00009.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00009.jpeg)'
- en: '`std::deque<T>` exposes all the same member functions as `std::vector<T>`,
    including an overloaded `operator[]`. In addition to vector''s `push_back` and
    `pop_back` methods, `deque` exposes an efficient `push_front` and `pop_front`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque<T>` 展示了与 `std::vector<T>` 相同的所有成员函数，包括重载的 `operator[]`。除了向量的 `push_back`
    和 `pop_back` 方法外，`deque` 还暴露了一个高效的 `push_front` 和 `pop_front`。'
- en: 'Notice that, when you repeatedly `push_back` into a vector, you eventually
    trigger a reallocation of the underlying array and invalidate all your iterators
    and all your pointers and references to elements within the container. With `deque`,
    iterator invalidation still happens, but individual elements never change their
    addresses unless you insert or erase elements in the middle of the deque (in which
    case one end of the deque or the other will have to shift outward to make room,
    or shift inward to fill the gap):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你反复向向量中 `push_back` 时，你最终会触发底层数组的重新分配，并使所有迭代器以及容器内元素的指针和引用无效。在 `deque` 中，迭代器失效仍然会发生，但除非你在
    deque 的中间插入或删除元素（在这种情况下，deque 的一个端点或另一个端点将不得不向外移动以腾出空间，或者向内移动以填补空隙），否则单个元素永远不会改变它们的地址：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Another advantage of `std::deque<T>` is that there is no specialization for
    `std::deque<bool>`; the container presents a uniform public interface no matter
    what `T` is.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque<T>` 的另一个优点是，没有为 `std::deque<bool>` 进行特殊化；无论 `T` 是什么，容器都提供了一个统一的公共接口。'
- en: The disadvantage of `std::deque<T>` is that its iterators are significantly
    more expensive to increment and dereference, since they have to navigate the array
    of pointers depicted in the following diagram. This is a significant enough disadvantage
    that it makes sense to stick with `vector`, unless you happen to need quick insertion
    and deletion at both ends of the container.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::deque<T>` 的缺点在于其迭代器的递增和解引用操作要显著昂贵，因为它们必须导航到以下图中所示的指针数组。这是一个相当大的缺点，以至于坚持使用
    `vector` 是有意义的，除非你恰好需要在容器的两端快速插入和删除。'
- en: 'A particular set of skills: std::list<T>'
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定的技能集：std::list<T>
- en: 'The container `std::list<T>` represents a linked list in memory. Schematically,
    it looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 容器 `std::list<T>` 在内存中代表一个链表。示意图如下：
- en: '![](img/00010.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00010.jpeg)'
- en: Notice that each node in the list contains pointers to its "next" and "previous"
    nodes, so this is a doubly linked list. The benefit of a doubly linked list is
    that its iterators can move both forwards and backwards through the list--that
    is, `std::list<T>::iterator` is a *bidirectional iterator* (but it is not *random-access*;
    getting to the *n*th element of the list still requires O(*n*) time).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，列表中的每个节点都包含对其“下一个”和“上一个”节点的指针，因此这是一个双向链表。双向链表的优点是它的迭代器可以向前和向后遍历列表--也就是说，`std::list<T>::iterator`
    是一个**双向迭代器**（但它不是**随机访问**；到达列表的第 *n* 个元素仍然需要 O(*n*) 的时间）。
- en: '`std::list` supports many of the same operations as `std::vector`, except for
    those operations that require random access (such as `operator[]`). It can afford
    to add member functions for pushing and popping from the front of the list, since
    pushing and popping from a `list` doesn''t require expensive move operations.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list` 支持与 `std::vector` 相同的许多操作，但除了那些需要随机访问的操作（例如 `operator[]`）。由于从列表的前端进行推入和弹出不需要昂贵的移动操作，因此它可以添加用于从列表前端推入和弹出的成员函数。'
- en: In general, `std::list` is much less performant than a contiguous data structure
    such as `std::vector` or `std::deque`, because following pointers to "randomly"
    allocated addresses is much harder on the cache than following pointers into a
    contiguous block of memory. Therefore, you should treat `std::list` as a generally
    *undesirable* container; you should only pull it out of your toolbox when you
    absolutely need one of the things it does *better* than `vector`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`std::list` 的性能远低于 `std::vector` 或 `std::deque` 这样的连续数据结构，因为跟踪“随机”分配的地址比跟踪内存连续块中的指针要困难得多。因此，你应该将
    `std::list` 视为一个通常**不推荐**的容器；你应该只在绝对需要它做得比 `vector` 更好的事情时才从工具箱中取出它。
- en: What are the special skills of std::list?
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::list` 有哪些特殊技能？'
- en: First, there's no *iterator invalidation* for lists! `lst.push_back(v)` and
    `lst.push_front(v)` always operate in constant time, and don't ever need to "resize"
    or "move" any data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于列表没有**迭代器失效**！`lst.push_back(v)` 和 `lst.push_front(v)` 总是常数时间操作，并且永远不需要“调整大小”或“移动”任何数据。
- en: 'Second, many mutating operations that would be expensive on `vector` or require
    out-of-line storage ("scratch space") become cheap for linked lists. Here are
    some examples:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在 `vector` 上成本高昂或在行外存储（“临时空间”）中需要存储的许多修改操作，对于链表来说变得便宜。以下是一些例子：
- en: '`lst.splice(it, otherlst)` "splices" the entirety of `otherlst` into `lst`,
    as if by repeated calls to `lst.insert(it++, other_elt)`; except that the "inserted"
    nodes are actually stolen from the right-hand `otherlst`. The entire splicing
    operation can be done with just a couple of pointer swaps. After this operation,
    `otherlst.size() == 0`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`lst.splice(it, otherlst)` “拼接”整个 `otherlst` 到 `lst` 中，就像通过重复调用 `lst.insert(it++,
    other_elt)`；但是“插入”的节点实际上是偷自右侧的 `otherlst`。整个拼接操作只需几个指针交换即可完成。在此操作之后，`otherlst.size()
    == 0`。'
- en: '`lst.merge(otherlst)` similarly empties out `otherlst` into `lst` using only
    pointer swaps, but has the effect of "merging sorted lists." For example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`lst.merge(otherlst)` 类似地仅使用指针交换将 `otherlst` 清空到 `lst` 中，但具有“合并排序列表”的效果。例如：'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As always with STL operations that involve comparison, there is a version taking
    a comparator: `lst.merge(otherlst, less)`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与涉及比较的 STL 操作一样，有一个接受比较器的版本：`lst.merge(otherlst, less)`。
- en: 'Another operation that can be done only with pointer swaps is reversing the
    list in place: `lst.reverse()` switches all the "next" and "previous" links so
    that the head of the list is now the tail, and vice versa.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个只能通过指针交换来完成的操作是在原地反转列表：`lst.reverse()` 切换所有“下一个”和“上一个”链接，使得列表的头部现在是尾部，反之亦然。
- en: Notice that all of these operations *mutate the list in place*, and generally
    return `void`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些操作都会**原地修改列表**，并且通常返回 `void`。
- en: 'Another kind of operation that is cheap on linked lists (but not on contiguous
    containers) is removal of elements. Recall from [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*, that the STL provides algorithms such as `std::remove_if`
    and `std::unique` for use with contiguous containers; these algorithms shuffle
    the "removed" elements to the end of the container so that they can be picked
    off in a single `erase()`. With `std::list`, shuffling elements is more expensive
    than simply erasing them in-place. So, `std::list` provides the following member
    functions, with names that are unfortunately similar to the non-erasing STL algorithms:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在链表上（但在连续容器上不是）成本低廉的操作是删除元素。回想一下[第3章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，*迭代器对算法*，STL
    提供了 `std::remove_if` 和 `std::unique` 等算法，用于与连续容器一起使用；这些算法将“已删除”的元素洗牌到容器的末尾，以便可以在单个
    `erase()` 中取下。对于 `std::list`，洗牌元素比简单地就地删除它们更昂贵。因此，`std::list` 提供了以下成员函数，不幸的是，它们的名称与非删除
    STL 算法相似：
- en: '`lst.remove(v)` removes *and erases* all elements equal to `v`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lst.remove(v)` 移除并删除所有等于 `v` 的元素。'
- en: '`lst.remove_if(p)` removes *and erases* all elements `e` which satisfy the
    unary predicate `p(e)`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lst.remove_if(p)` 移除并删除所有满足一元谓词 `p(e)` 的元素 `e`。'
- en: '`lst.unique()` removes *and erases* all but the first element of each "run"
    of consecutive equal elements. As always with STL operations that involve comparison,
    there is a version taking a comparator: `lst.unique(eq)` removes and erases `e2`
    whenever `p(e1, e2)`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lst.unique()` 移除并删除每个“连续相等元素序列”中除了第一个元素之外的所有元素。像往常一样，与涉及比较的 STL 操作一样，有一个接受比较器的版本：`lst.unique(eq)`
    当 `p(e1, e2)` 成立时移除并删除 `e2`。'
- en: '`lst.sort()` sorts the list in-place. This is particularly helpful because
    the permutative algorithm `std::sort(ctr.begin(), ctr.end())` does not work on
    the non-random-access `std::list::iterator`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lst.sort()` 在原地排序列表。这特别有用，因为排列算法 `std::sort(ctr.begin(), ctr.end())` 不能在非随机访问的
    `std::list::iterator` 上工作。'
- en: It's strange that `lst.sort()` can only sort the entire container, instead of
    taking a sub-range the way `std::sort` does. But if you want to sort just a sub-range
    of `lst`, you can do it with--say it with me--just a couple of pointer swaps!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 很奇怪，`lst.sort()` 只能对整个容器进行排序，而不是像 `std::sort` 那样接受一个子范围。但如果你只想对 `lst` 的子范围进行排序，你可以通过——跟我一起说——仅仅几个指针交换来实现！
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Roughing it with std::forward_list<T>
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::forward_list<T> 进行简化
- en: 'The standard container `std::forward_list<T>` is a linked list like `std::list`,
    but with fewer amenities--no way to get its size, no way to iterate backward.
    In memory it looks similar to `std::list<T>`, but with smaller nodes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 标准容器 `std::forward_list<T>` 与 `std::list` 类似，但功能较少——无法获取其大小，无法向后迭代。在内存中它看起来与
    `std::list<T>` 类似，但节点更小：
- en: '![](img/00011.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: Nevertheless, `std::forward_list` retains almost all of the "special skills"
    of `std::list`. The only operations that it can't do are `splice` (because that
    involves inserting "before" the given iterator) and `push_back` (because that
    involves finding the end of the list in constant time).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`std::forward_list` 保留了 `std::list` 几乎所有的“特殊技能”。它无法执行的操作只有 `splice`（因为这涉及到在给定迭代器之前插入）和
    `push_back`（因为这涉及到在常数时间内找到列表的末尾）。
- en: '`forward_list` replaces these missing member functions with `_after` versions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward_list` 用 `_after` 版本替换了这些缺失的成员函数：'
- en: '`flst.erase_after(it)` to erase the element *after* the given position'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flst.erase_after(it)` 删除给定位置之后的元素'
- en: '`flst.insert_after(it, v)` to insert a new element *after* the given position'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flst.insert_after(it, v)` 在给定位置之后插入一个新元素'
- en: '`flst.splice_after(it, otherflst)` to insert the elements of `otherflst` *after*
    the given position'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flst.splice_after(it, otherflst)` 在给定位置之后插入 `otherflst` 的元素'
- en: As with `std::list`, you should avoid using `forward_list` at all unless you
    are in need of its particular set of skills.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::list` 一样，除非你需要它特定的技能集，否则应尽量避免使用 `forward_list`。
- en: Abstracting with std::stack<T> and std::queue<T>
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::stack<T> 和 std::queue<T> 进行抽象
- en: We've now seen three different standard containers with the member functions
    `push_back()` and `pop_back()` (and, although we didn't mention it, `back()` to
    retrieve a reference to the last element of the container). These are the operations
    we'd need if we wanted to implement a stack data structure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了三个不同的标准容器，它们具有 `push_back()` 和 `pop_back()` 成员函数（尽管我们没有提到，但 `back()`
    用于获取容器最后一个元素的引用）。如果我们想要实现一个栈数据结构，我们需要这些操作。
- en: The standard library provides a convenient way to abstract the idea of a stack,
    with the container known as (what else?) `std::stack`. Unlike the containers we've
    seen so far, though, `std::stack` takes an extra template parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一个方便的方式来抽象栈的概念，容器被称为（还能是什么？）`std::stack`。然而，与迄今为止我们所看到的容器不同，`std::stack`
    需要一个额外的模板参数。
- en: '`std::stack<T, Ctr>` represents a stack of elements of type `T`, where the
    underlying storage is managed by an instance of the container type `Ctr`. For
    example, `stack<T, vector<T>>` uses a vector to manage its elements; `stack<T,
    list<T>>` uses a list; and so on. The default value for the template parameter
    `Ctr` is actually `std::deque<T>`; you may recall that `deque` takes up more memory
    than `vector` but has the benefit of never needing to reallocate its underlying
    array or move elements post-insertion.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stack<T, Ctr>` 表示一个类型为 `T` 的元素栈，其底层存储由容器类型 `Ctr` 的一个实例管理。例如，`stack<T,
    vector<T>>` 使用向量来管理其元素；`stack<T, list<T>>` 使用列表；等等。模板参数 `Ctr` 的默认值实际上是 `std::deque<T>`；你可能还记得，`deque`
    比向量占用更多内存，但它的好处是永远不需要重新分配其底层数组或移动插入后的元素。'
- en: 'To interact with a `std::stack<T, Ctr>`, you must restrict yourself to only
    the operations `push` (corresponding to `push_back` on the underlying container),
    `pop` (corresponding to `pop_back`), `top` (corresponding to `back`), and a few
    other accessors such as `size` and `empty`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 `std::stack<T, Ctr>` 交互，你必须限制自己只使用 `push` 操作（对应于底层容器上的 `push_back`），`pop`
    操作（对应于 `pop_back`），`top` 操作（对应于 `back`），以及一些其他访问器，如 `size` 和 `empty`：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: One bizarre feature of `std::stack` is that it supports the comparison operators
    `==`, `!=`, `<`, `<=`, `>`, and `>=`; and that these operators work by comparing
    the underlying containers (using whatever semantics the underlying container type
    has defined). Since the underlying container type generally compares via lexicographical
    order, the result is that comparing two stacks compares them "lexicographically
    bottom up."
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stack` 的一个奇特特性是它支持比较运算符 `==`、`!=`、`<`、`<=`、`>` 和 `>=`；并且这些运算符通过比较底层容器（使用底层容器类型定义的任何语义）来工作。由于底层容器类型通常通过字典序比较，结果是比较两个栈时是“从下往上”进行字典序比较的。'
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is fine if you're using only `==` and `!=`, or if you're relying on `operator<`
    to produce a consistent ordering for `std::set` or `std::map`; but it's certainly
    surprising the first time you see it!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只使用 `==` 和 `!=`，或者依赖于 `operator<` 为 `std::set` 或 `std::map` 生成一致排序，那么这没问题；但当你第一次看到它时，这确实会让人感到惊讶！
- en: The standard library also provides an abstraction for "queue." `std::queue<T,
    Ctr>` exposes the methods `push_back` and `pop_front` (corresponding to `push_back`
    and `pop_front` on the underlying container), as well as a few other accessors
    such as `front`, `back`, `size`, and `empty`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库还提供了一个“队列”的抽象。`std::queue<T, Ctr>` 提供了 `push_back` 和 `pop_front` 方法（对应于底层容器上的
    `push_back` 和 `pop_front`），以及一些其他访问器，如 `front`、`back`、`size` 和 `empty`。
- en: Knowing that the container must support these primitive operations as efficiently
    as possible, you should be able to guess the *default* value of `Ctr`. Yes, it's
    `std::deque<T>`, the low-overhead double-ended queue.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 知道容器必须尽可能高效地支持这些基本操作，你应该能够猜出 `Ctr` 的 *默认* 值。是的，它是 `std::deque<T>`，这是一个低开销的双端队列。
- en: Notice that, if you were implementing a queue from scratch using `std::deque<T>`,
    you could choose whether to push on the front of the deque and pop from the back,
    or to push on the back of the deque and pop from the front. The standard `std::queue<T,
    std::deque<T>>` chooses specifically to push on the back and pop from the front,
    which is easy to remember if you think about a "queue" in the real world. When
    you're queueing up at a ticket counter or a lunch line, you join the queue at
    the back and are served when you get to the front--never vice versa! It is a useful
    art to choose technical terms (such as `queue`, `front`, and `back`) whose technical
    meanings are an accurate mirror of their real-world counterparts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你从头开始使用 `std::deque<T>` 实现队列，你可以选择是在双端队列的前端入队并在后端出队，或者是在后端入队并在前端出队。标准的
    `std::queue<T, std::deque<T>>` 特意选择在后端入队并在前端出队，如果你考虑现实世界中的“队列”，这很容易记住。当你排队在售票窗口或午餐队伍中时，你会在队伍的后面加入，当你到达前面时才会被服务——永远不会反过来！选择技术术语（如
    `queue`、`front` 和 `back`）的艺术是很有用的，这些术语的技术含义是它们现实世界对应物的准确反映。
- en: 'The useful adaptor: std::priority_queue<T>'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的适配器：std::priority_queue<T>
- en: 'In [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d), *The
    Iterator-Pair Algorithms*, we introduced the family of "heap" algorithms: `make_heap`,
    `push_heap`, and `pop_heap`. You can use these algorithms to give a range of elements
    the max-heap property. If you maintain the max-heap property on your data as an
    invariant, you get a data structure commonly known as a *priority queue*. In data-structure
    textbooks, a priority queue is often depicted as a kind of *binary tree*, but
    as we saw in [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*, there''s nothing about the max-heap property that
    requires an explicitly pointer-based tree structure.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，“迭代器对算法”中，我们介绍了“堆”算法系列：`make_heap`、`push_heap`
    和 `pop_heap`。您可以使用这些算法给一系列元素赋予最大堆属性。如果您将最大堆属性作为数据的不变性来维护，您将得到一个通常称为**优先队列**的数据结构。在数据结构教科书中，优先队列通常被描绘为一种**二叉树**，但正如我们在[第3章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，“迭代器对算法”中看到的，最大堆属性并没有要求显式地使用基于指针的树结构。
- en: The standard container `std::priority_queue<T, Ctr, Cmp>` represents a priority
    queue, represented internally as an instance of `Ctr` where the elements of the
    `Ctr` are invariably in max-heap order (as determined by an instance of the comparator
    type `Cmp`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 标准容器 `std::priority_queue<T, Ctr, Cmp>` 表示一个优先队列，内部表示为一个 `Ctr` 的实例，其中 `Ctr`
    的元素始终按照最大堆顺序排列（由比较器类型 `Cmp` 的实例确定）。
- en: The default value of `Ctr` in this case is `std::vector<T>`. Remember that `vector`
    is the most efficient container; the only reason `std::stack` and `std::queue`
    chose `deque` as their default is that they didn't want to move elements after
    they'd been inserted. But with a priority queue, the elements are moving all the
    time, moving up and down in the max-heap as other elements are inserted or erased.
    So there's no particular benefit to using `deque` as the underlying container;
    therefore, the standard library followed the same rule I've been repeating like
    a drumbeat--use `std::vector` unless you have a specific reason to need something
    else!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Ctr` 的默认值是 `std::vector<T>`。记住，`vector` 是最有效的容器；`std::stack` 和 `std::queue`
    选择 `deque` 作为它们的默认值，唯一的原因是它们不想在插入元素后移动元素。但是，对于优先队列，元素始终在移动，随着其他元素的插入或删除，在最大堆中上下移动。因此，使用
    `deque` 作为底层容器没有特别的优点；因此，标准库遵循了我一直在重复的相同规则——除非有特定的原因需要其他东西，否则使用 `std::vector`！
- en: The default value of `Cmp` is the standard library type `std::less<T>`, which
    represents `operator<`. In other words, the `std::priority_queue` container uses
    the same comparator by default as the `std::push_heap` and `std::pop_heap` algorithms
    from [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d), *The
    Iterator-Pair Algorithms*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cmp` 的默认值是标准库类型 `std::less<T>`，它表示 `operator<`。换句话说，`std::priority_queue`
    容器默认使用与[第3章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，“迭代器对算法”中的
    `std::push_heap` 和 `std::pop_heap` 算法相同的比较器。'
- en: The member functions exposed by `std::priority_queue<T, Ctr>` are `push`, `pop`,
    and `top`. Conceptually, the item at the front of the underlying container is
    at the "top" of the heap. One thing to remember is that in a max-heap, the item
    at the "top" of the heap is the *greatest* item--think of the items as playing
    King of the Hill, so that the biggest one wins and ends up on the top of the heap.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::priority_queue<T, Ctr>` 暴露的成员函数是 `push`、`pop` 和 `top`。从概念上讲，底层容器前面的项目位于堆的“顶部”。要记住的一件事是，在最大堆中，“顶部”的项目是**最大的**项目——想象一下这些项目像玩山丘之王，最大的项目获胜并最终位于堆的顶部。'
- en: '`pq.push(v)` inserts a new item into the priority queue, as if by `std::push_heap()`
    on the underlying container'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pq.push(v)` 将新项目插入到优先队列中，就像在底层容器上执行 `std::push_heap()` 一样'
- en: '`pq.top()` returns a reference to the element currently on top of the priority
    queue, as if by calling `ctr.front()` on the underlying container'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pq.top()` 返回对优先队列顶部元素的引用，就像在底层容器上调用 `ctr.front()` 一样'
- en: '`pq.pop()` pops off the maximum element and updates the heap, as if by `std::pop_heap()`
    on the underlying container'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pq.pop()` 从优先队列中移除最大元素并更新堆，就像在底层容器上执行 `std::pop_heap()` 一样'
- en: 'To get a *min-heap* instead of a max-heap, simply reverse the sense of the
    comparator you provide to the `priority_queue` template:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得**最小堆**而不是最大堆，只需简单地反转提供给 `priority_queue` 模板的比较器的意义：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The trees: std::set<T> and std::map<K, V>'
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树：`std::set<T>` 和 `std::map<K, V>`
- en: 'The class template `std::set<T>` provides the interface of a "unique set" for
    any `T` that implements `operator<`. As always with STL operations that involve
    comparison, there is a version taking a comparator: `std::set<T, Cmp>` provides
    "unique set" functionality using `Cmp(a,b)` instead of `(a < b)` to sort the data
    elements.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::set<T>` 为任何实现 `operator<` 的 `T` 提供了“唯一集合”的接口。与涉及比较的 STL 操作一样，有一个接受比较器的版本：`std::set<T,
    Cmp>` 使用 `Cmp(a,b)` 而不是 `(a < b)` 来排序数据元素。
- en: 'A `std::set` is conceptually a binary search tree, analogous to Java''s `TreeSet`.
    In all popular implementations it''s specifically a *red-black tree*, which is
    a particular kind of self-balancing binary search tree: even if you are constantly
    inserting and removing items from the tree, it will never get *too* unbalanced,
    which means that `insert` and `find` will always run in O(log *n*) time on average.
    Notice the number of pointers involved in its memory layout:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `std::set` 在概念上是一个二叉搜索树，类似于 Java 的 `TreeSet`。在所有流行的实现中，它特别是一个 *红黑树*，这是一种特定的自平衡二叉搜索树：即使你不断地从树中插入和删除项目，它也不会变得
    *太不平衡*，这意味着 `insert` 和 `find` 在平均情况下总是以 O(log *n*) 的时间复杂度运行。注意其内存布局中涉及的指针数量：
- en: '![](img/00012.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.jpeg)'
- en: 'Since, by definition, a binary search tree''s elements are stored in their
    sort order (least to greatest), it would not be meaningful for `std::set` to provide
    member functions `push_front` or `push_back`. Instead, to add an element `v` to
    the set, you use `s.insert(v)`; and to delete an element, you use `s.erase(v)`
    or `s.erase(it)`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二叉搜索树的定义是元素按排序顺序（从小到大）存储，因此 `std::set` 提供成员函数 `push_front` 或 `push_back` 没有意义。相反，为了向集合中添加元素
    `v`，你使用 `s.insert(v)`；要删除元素，则使用 `s.erase(v)` 或 `s.erase(it)`：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The return value of `s.insert(v)` is interesting. When we `insert` into a vector,
    there are only two possible outcomes: either the value is successfully added to
    the vector (and we get back an iterator to the newly inserted element), or else
    the insertion fails and an exception is thrown. When we `insert` into a set, there
    is a third possible outcome: maybe the insertion doesn''t happen because there
    is already a copy of `v` in the set! That''s not a "failure" worthy of exceptional
    control flow, but it''s still something that the caller might want to know about.
    So `s.insert(v)` always returns a `pair` of return values: `ret.first` is the
    usual iterator to the copy of `v` now in the data structure (no matter whether
    it was just now inserted), and `ret.second` is `true` if the pointed-to `v` was
    just inserted and `false` if the pointed-to `v` was already in the set to begin
    with:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.insert(v)` 的返回值很有趣。当我们向一个向量 `insert` 时，只有两种可能的结果：要么值成功添加到向量中（并返回一个指向新插入元素的迭代器），要么插入失败并抛出异常。当我们向一个集合
    `insert` 时，还有一种可能的结果：可能由于集合中已经存在 `v` 的副本而没有发生插入！这并不是一个值得异常控制流的“失败”，但仍然是一些调用者可能想要了解的事情。因此，`s.insert(v)`
    总是返回一个 `pair` 的返回值：`ret.first` 是数据结构中 `v` 的副本的常规迭代器（无论它是否刚刚插入），而 `ret.second`
    如果指向的 `v` 是刚刚插入的则为 `true`，如果指向的 `v` 最初就在集合中则为 `false`：'
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The square-bracketed variable definitions in the preceding snippet are using
    C++17 *structured bindings*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个片段中使用的方括号变量定义正在使用 C++17 *结构化绑定*。
- en: As the example just prior to this one shows, the elements of a `set` are stored
    in order--not just conceptually but visibly, in that `*s.begin()` is going to
    be the least element in the set and `*std::prev(s.end())` is going to be the greatest
    element. Iterating over the set using a standard algorithm or a ranged `for` loop
    will give you the set's elements in ascending order (remember, what "ascending"
    means is dictated by your choice of comparator--the `Cmp` parameter to the class
    template `set`).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前的示例所示，集合的元素是有序存储的——不仅概念上，而且在可见性上，`*s.begin()` 将是集合中的最小元素，而 `*std::prev(s.end())`
    将是最大的元素。使用标准算法或范围 `for` 循环遍历集合将按升序（记住，“升序”的含义由你的比较器选择决定——类模板 `set` 的 `Cmp` 参数）给出集合的元素。
- en: 'The tree-based structure of a `set` implies that some standard algorithms such
    as `std::find` and `std::lower_bound` ([Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d),
    *The Iterator-Pair Algorithms*) will still work, but only inefficiently--the algorithm''s
    iterators will spend a lot of time climbing up and down in the foothills of the
    tree, whereas if we had access to the tree structure itself, we could descend
    directly from the root of the tree and find a given element''s position very quickly.
    Therefore, `std::set` provides member functions that can be used as replacements
    for the inefficient algorithms:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 的基于树的结构意味着一些标准算法，如 `std::find` 和 `std::lower_bound` ([第 3 章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d)，*迭代器对算法*)
    仍然可以工作，但效率低下——算法的迭代器将在树的丘陵上花费大量时间上下爬升，而如果我们能够访问树结构本身，我们可以直接从树的根开始下降，并快速找到给定元素的位置。因此，`std::set`
    提供了可以作为低效算法替代的成员函数：'
- en: For `std::find(s.begin(), s.end(), v)`, use `s.find(v)`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `std::find(s.begin(), s.end(), v)`，使用 `s.find(v)`
- en: For `std::lower_bound(s.begin(), s.end(), v)`, use `s.lower_bound(v)`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `std::lower_bound(s.begin(), s.end(), v)`，使用 `s.lower_bound(v)`
- en: For `std::upper_bound(s.begin(), s.end(), v)`, use `s.upper_bound(v)`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `std::upper_bound(s.begin(), s.end(), v)`，使用 `s.upper_bound(v)`
- en: For `std::count(s.begin(), s.end(), v)`, use `s.count(v)`
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `std::count(s.begin(), s.end(), v)`，使用 `s.count(v)`
- en: For `std::equal_range(s.begin(), s.end(), v)`, use `s.equal_range(v)`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `std::equal_range(s.begin(), s.end(), v)`，使用 `s.equal_range(v)`
- en: Notice that `s.count(v)` will only ever return 0 or 1, because the set's elements
    are deduplicated. This makes `s.count(v)` a handy synonym for the set-membership
    operation--what Python would call `v in s` or what Java would call `s.contains(v)`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`s.count(v)` 只会返回 0 或 1，因为集合的元素是去重的。这使得 `s.count(v)` 成为一个方便的同义词，用于集合成员操作——Python
    会称之为 `v in s` 或 Java 会称之为 `s.contains(v)`。
- en: '`std::map<K, V>` is just like `std::set<K>`, except that each key `K` is allowed
    to have a value `V` associated with it; this makes a data structure analogous
    to Java''s `TreeMap` or Python''s `dict`. As always, there''s `std::map<K, V,
    Cmp>` if you need a sorting order on your keys that''s different from the natural
    `K::operator<`. Although you won''t often think of `std::map` as "just a thin
    wrapper around a `std::set` of pairs," that''s exactly how it looks in memory:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map<K, V>` 就像 `std::set<K>`，只不过每个键 `K` 都可以有一个与之关联的值 `V`；这使得数据结构类似于 Java
    的 `TreeMap` 或 Python 的 `dict`。始终如一，如果你需要与自然 `K::operator<` 不同的键排序顺序，那么有 `std::map<K,
    V, Cmp>`。虽然你不会经常将 `std::map` 视为“只是一个围绕 `std::set` 对对的薄包装”，但在内存中它确实是这样：'
- en: '![](img/00013.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00013.jpeg)'
- en: '`std::map` supports indexing with `operator[]`, but with a surprising twist.
    When you index into a size-zero vector with `vec[42]`, you get undefined behavior.
    When you index into a size-zero *map* with `m[42]`, the map helpfully inserts
    the key-value pair `{42, {}}` into itself and returns a reference to the second
    element of that pair!'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map` 支持使用 `operator[]` 进行索引，但有一个令人惊讶的转折。当你用 `vec[42]` 对大小为零的向量进行索引时，你会得到未定义的行为。当你用
    `m[42]` 对大小为零的 *映射* 进行索引时，映射会友好地插入键值对 `{42, {}}` 到它自己中，并返回该对第二个元素的引用！'
- en: 'This quirky behavior is actually helpful for writing code that''s easy on the
    eyes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种古怪的行为实际上对编写易于阅读的代码很有帮助：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But it can lead to confusion if you don''t pay attention:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不注意，可能会导致混淆：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You''ll notice that there is no `operator[] const` for maps, because `operator[]`
    always reserves the potential to insert a new key-value pair into `*this`. If
    you have a const map--or just a map that you really don''t want to insert into
    right now--then the appropriate way to query it non-mutatively is with `m.find(k)`.
    Another reason to avoid `operator[]` is if your map''s value type `V` is not default-constructible,
    in which case `operator[]` simply won''t compile. In that case (real talk: in
    *any* case) you should use `m.insert(kv)` or `m.emplace(k, v)` to insert the new
    key-value pair exactly as you want it, instead of default-constructing a value
    just to assign over it again. Here''s an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，对于映射没有 `operator[] const`，因为 `operator[]` 总是保留将新的键值对插入到 `*this` 中的可能性。如果你有一个常量映射——或者你真的现在不想插入的映射——那么查询它的非突变方式是使用
    `m.find(k)`。避免 `operator[]` 的另一个原因是如果你的映射的值类型 `V` 不是默认可构造的，在这种情况下，`operator[]`
    简单地无法编译。在这种情况下（实话实说：在任何情况下）你应该使用 `m.insert(kv)` 或 `m.emplace(k, v)` 来插入新的键值对，而不是为了再次赋值而默认构造一个值。以下是一个例子：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Received wisdom in the post–C++11 world is that `std::map` and `std::set`, being
    based on trees of pointers, are so cache-unfriendly that you should avoid them
    by default and prefer to use `std::unordered_map` and `std::unordered_set` instead.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之后的世界里，人们普遍认为基于指针树的 `std::map` 和 `std::set` 由于对缓存不友好，应该默认避免使用，而应该首选使用
    `std::unordered_map` 和 `std::unordered_set`。
- en: A note about transparent comparators
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于透明比较器的说明
- en: In the last code example, I wrote `m.find("hello")`. Notice that `"hello"` is
    a value of type `const char[6]`, whereas `decltype(m)::key_type` is `std::string`,
    and (since we didn't specify anything special) `decltype(m)::key_compare` is `std::less<std::string>`.
    This means that when we call `m.find("hello")`, we're calling a function whose
    first parameter is of type `std::string`--and so we're implicitly constructing
    `std::string("hello")` to pass as the argument to `find`. In general, the argument
    to `m.find` is going to get implicitly converted to `decltype(m)::key_type`, which
    may be an expensive conversion.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个代码示例中，我写的是 `m.find("hello")`。请注意，`"hello"` 是类型为 `const char[6]` 的值，而 `decltype(m)::key_type`
    是 `std::string`，并且（因为我们没有指定任何特殊的东西）`decltype(m)::key_compare` 是 `std::less<std::string>`。这意味着当我们调用
    `m.find("hello")` 时，我们调用的是一个第一个参数类型为 `std::string` 的函数--因此我们隐式地构造了 `std::string("hello")`
    来作为 `find` 的参数。一般来说，`m.find` 的参数将被隐式转换为 `decltype(m)::key_type`，这可能会是一个昂贵的转换。
- en: 'If our `operator<` behaves properly, we can avoid this overhead by changing
    the comparator of `m` to some class with a *heterogeneous* `operator()` which
    also defines the member typedef `is_transparent`, like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 `operator<` 行为正常，我们可以通过将 `m` 的比较器更改为具有 *异构* `operator()` 的某个类，并定义成员类型定义
    `is_transparent` 来避免这种开销，如下所示：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The "magic" here is all happening inside the library''s implementation of `std::map`;
    the `find` member function specifically checks for the member `is_transparent`
    and changes its behavior accordingly. The member functions `count`, `lower_bound`,
    `upper_bound`, and `equal_range` all change their behavior as well. But oddly,
    the member function `erase` does not! This is probably because it would be too
    difficult for overload resolution to distinguish an intended `m.erase(v)` from
    an intended `m.erase(it)`. Anyway, if you want heterogeneous comparison during
    deletion as well, you can get it in two steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的“魔法”全部发生在库对 `std::map` 的实现中；`find` 成员函数特别检查成员 `is_transparent` 并相应地改变其行为。成员函数
    `count`、`lower_bound`、`upper_bound` 和 `equal_range` 也都改变了它们的行为。但奇怪的是，成员函数 `erase`
    并没有！这可能是由于区分有意为之的 `m.erase(v)` 和有意为之的 `m.erase(it)` 对于重载解析来说太难了。无论如何，如果你想在删除时进行异构比较，你可以分两步实现：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Oddballs: std::multiset<T> and std::multimap<K, V>'
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奇异物：`std::multiset<T>` 和 `std::multimap<K, V>`
- en: 'In STL-speak, a "set" is an ordered, deduplicated collection of elements. So
    naturally, a "multiset" is an ordered, non-deduplicated collection of elements!
    Its memory layout is exactly the same as the layout of `std::set`; only its invariants
    are different. Notice in the following diagram that `std::multiset` allows two
    elements with value `42`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 STL 术语中，“set” 是一个有序且去重的元素集合。因此，一个“multiset”自然是一个有序且非去重的元素集合！它的内存布局与 `std::set`
    的布局完全相同；只是它的不变量不同。注意以下图中 `std::multiset` 允许两个值为 `42` 的元素：
- en: '![](img/00014.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: '`std::multiset<T, Cmp>` behaves just like `std::set<T, Cmp>`, except that it
    can store duplicate elements. The same goes for `std::multimap<K, V, Cmp>`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multiset<T, Cmp>` 的行为与 `std::set<T, Cmp>` 类似，不同之处在于它可以存储重复元素。对于 `std::multimap<K,
    V, Cmp>` 也是如此：'
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In a multiset or multimap, `mm.find(v)` returns an iterator to *some* element
    (or key-value pair) matching `v`--not necessarily the first one in iteration order.
    `mm.erase(v)` erases all the elements (or key-value pairs) with keys equal to
    `v`. And `mm[v]` doesn''t exist. For example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 multiset 或 multimap 中，`mm.find(v)` 返回一个指向 *某个* 与 `v` 匹配的元素（或键值对）的迭代器（或键值对），不一定是迭代顺序中的第一个。`mm.erase(v)`
    删除所有键等于 `v` 的元素（或键值对）。而 `mm[v]` 不存在。例如：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Moving elements without moving them
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不移动元素而移动元素
- en: Recall that, with `std::list`, we were able to splice lists together, move elements
    from one list to another, and so on, by using the "particular set of skills" of
    `std::list`. As of C++17, the tree-based containers have acquired similar skills!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，使用 `std::list`，我们能够通过使用 `std::list` 的“特定技能”将列表拼接在一起，从一个列表移动元素到另一个列表，等等。从
    C++17 开始，基于树的容器也获得了类似的技能！
- en: 'The syntax for merging two sets or maps (or multisets or multimaps) is deceptively
    similar to the syntax for merging sorted `std::list`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个集合或映射（或多重集合或多重映射）的语法与合并排序的 `std::list` 的语法具有欺骗性的相似性：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: However, notice what happens when there are duplicates! The duplicated elements
    are *not* transferred; they're left behind in the right-hand-side map! This is
    the exact opposite of what you'd expect if you're coming from a language such
    as Python, where `d.update(otherd)` inserts all the mappings from the right-hand
    dict into the left-hand dict, overwriting anything that was there already.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，当存在重复项时会发生什么！重复的元素*不会*被传输；它们被留在右侧映射中！如果你来自像 Python 这样的语言，这与你预期的正好相反，在
    Python 中 `d.update(otherd)` 将右侧字典中的所有映射插入到左侧字典中，覆盖任何已经存在的内容。
- en: The C++ equivalent of `d.update(otherd)` is `m.insert(otherm.begin(), otherm.end()`.
    The only case in which it makes sense to use `m.merge(otherm)` is if you know
    that you don't want to overwrite duplicates, *and* you're okay with trashing the
    old value of `otherm` (for example, if it's a temporary that's going out of scope
    soon).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中 `d.update(otherd)` 的等价操作是 `m.insert(otherm.begin(), otherm.end())`。唯一有意义的用例是，如果你知道你不想覆盖重复项，*并且*你接受丢弃
    `otherm` 的旧值（例如，如果它是一个即将超出作用域的临时变量）。
- en: 'Another way to transfer elements between tree-based containers is to use the
    member functions `extract` and `insert` to transfer individual elements:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于树的容器之间传输元素的另一种方法是使用成员函数 `extract` 和 `insert` 来传输单个元素：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The type of the object returned by `extract` is something called a "node handle"--essentially
    a pointer into the guts of the data structure. You can use the accessor methods
    `nh.key()` and `nh.mapped()` to manipulate the pieces of the entry in a `std::map`
    (or `nh.value()` for the single piece of data in an element of a `std::set`).
    Thus you can extract, manipulate, and reinsert a key without ever copying or moving
    its actual data! In the following code sample, the "manipulation" consists of
    a call to `std::transform`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract` 返回的对象类型被称为“节点句柄”——本质上是指向数据结构内部的指针。你可以使用访问器方法 `nh.key()` 和 `nh.mapped()`
    来操作 `std::map`（或 `std::set` 元素中的单个数据项的 `nh.value()`）中的条目。因此，你可以提取、操作并重新插入一个键，而无需复制或移动其实际数据！在下面的代码示例中，“操作”包括对
    `std::transform` 的调用：'
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, the interface to this functionality isn''t as tidy as `lst.splice(it,
    otherlst)`; the subtlety of the interface is one reason it took until C++17 to
    get this functionality into the standard library. There is one clever bit to notice,
    though: Suppose you `extract` a node from a set and then throw an exception before
    you''ve managed to `insert` it into the destination set. What happens to the orphaned
    node--does it leak? It turns out that the designers of the library thought of
    this possibility; if a node handle''s destructor is called before the node handle
    has been inserted into its new home, the destructor will correctly clean up the
    memory associated with the node. Therefore, `extract` by itself (without `insert`)
    will behave just like `erase`!'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此功能的接口不如 `lst.splice(it, otherlst)` 整洁；接口的微妙之处是它直到 C++17 才被纳入标准库的原因之一。不过，有一个巧妙的点需要注意：假设你从一个集合中
    `extract` 一个节点，然后在将其插入到目标集合之前抛出一个异常。这个孤立的节点会发生什么——它会泄漏吗？事实证明，库的设计者考虑到了这种可能性；如果一个节点句柄的析构函数在节点句柄被插入到其新家之前被调用，析构函数将正确清理与节点关联的内存。因此，仅
    `extract`（没有 `insert`）的行为就像 `erase`！
- en: 'The hashes: std::unordered_set<T> and std::unordered_map<K, V>'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 散列：`std::unordered_set<T>` 和 `std::unordered_map<K, V>`
- en: 'The `std::unordered_set` class template represents a chained hash table--that
    is, a fixed-size array of "buckets," each bucket containing a singly linked list
    of data elements. As new data elements are added to the container, each element
    is placed in the linked list associated with the "hash" of the element''s value.
    This is almost exactly the same as Java''s `HashSet`. In memory it looks like
    this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_set` 类模板表示一个链表散列表——也就是说，一个固定大小的“桶”数组，每个桶包含一个数据元素的单链表。当新数据元素被添加到容器中时，每个元素都被放置在与其值“散列”相关联的链表中。这与
    Java 的 `HashSet` 几乎完全相同。在内存中它看起来像这样：'
- en: '![](img/00015.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: The literature on hash tables is extensive, and `std::unordered_set` does not
    represent even remotely the state of the art; but because it eliminates a certain
    amount of pointer-chasing, it tends to perform better than the tree-based `std::set`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哈希表的文献非常丰富，`std::unordered_set` 并不代表当前技术的最前沿；但因为它消除了某些指针追踪，所以通常比基于树的 `std::set`
    表现得更好。
- en: To eliminate the rest of the pointers, you'd have to replace the linked lists
    with a technique called "open addressing," which is far out of scope for this
    book; but it's worth looking up if `std::unordered_set` proves too slow for your
    use-case.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除其余的指针，你需要用一种称为“开放寻址”的技术来替换链表，但这超出了本书的范围；但如果 `std::unordered_set` 对于你的用例来说太慢，那么查找它是有价值的。
- en: '`std::unordered_set` was designed to be a drop-in replacement for `std::set`,
    so it provides the same interface that we''ve already seen: `insert` and `erase`,
    plus iteration with `begin` and `end`. However, unlike `std::set`, the elements
    of a `std::unordered_set` are not stored in sorted order (it''s *unordered*, you
    see?) and it provides only forward iterators, as opposed to the bidirectional
    iterators provided by `std::set`. (Check the preceding illustration--there are
    "next" pointers but no "previous" pointers, so iterating backwards in a `std::unordered_set`
    is impossible.)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_set` 是为了替代 `std::set` 而设计的，因此它提供了我们已见过的相同接口：`insert` 和 `erase`，以及使用
    `begin` 和 `end` 进行迭代。然而，与 `std::set` 不同，`std::unordered_set` 中的元素不是按顺序存储的（它是无序的，明白吗？）并且它只提供前向迭代器，而不是
    `std::set` 提供的双向迭代器。（查看前面的插图——有“下一个”指针但没有“上一个”指针，所以在 `std::unordered_set` 中反向迭代是不可能的。）'
- en: '`std::unordered_map<K, V>` is to `std::unordered_set<T>` as `std::map<K, V>`
    is to `std::set<T>`. That is, it looks exactly the same in memory, except that
    it stores key-value pairs instead of just keys:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_map<K, V>` 相对于 `std::unordered_set<T>`，就像 `std::map<K, V>`
    相对于 `std::set<T>`。也就是说，在内存中看起来完全一样，只是它存储的是键值对而不是仅仅是键：'
- en: '![](img/00016.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00016.jpeg)'
- en: 'Like `set` and `map`, which take an optional comparator parameter, `unordered_set`
    and `unordered_map` take some optional parameters as well. The two optional parameters
    are `Hash` (which defaults to `std::hash<K>`) and `KeyEqual` (which defaults to
    `std::equal_to<K>`, which is to say, `operator==`). Passing in a different hash
    function or a different key-comparison function causes the hash table to use those
    functions instead of the defaults. This might be useful if you''re interfacing
    with some old-school C++ class type that doesn''t implement value semantics or
    `operator==`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `set` 和 `map`，它们可以接受一个可选的比较器参数，`unordered_set` 和 `unordered_map` 也可以接受一些可选参数。这两个可选参数是
    `Hash`（默认为 `std::hash<K>`）和 `KeyEqual`（默认为 `std::equal_to<K>`，也就是说，`operator==`）。传递不同的哈希函数或不同的键比较函数会导致哈希表使用这些函数而不是默认值。如果你正在与某些不支持值语义或
    `operator==` 的旧式 C++ 类类型进行交互，这可能是有用的：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Load factor and bucket lists
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载因子和桶列表
- en: Like Java's `HashSet`, `std::unordered_set` exposes all kinds of administrative
    details about its buckets. You probably will never need to interact with these
    administrative functions!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Java 的 `HashSet`，`std::unordered_set` 揭示了其桶的所有管理细节。你可能永远不需要与这些管理函数交互！
- en: '`s.bucket_count()` returns the current number of buckets in the array.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.bucket_count()` 返回数组中当前桶的数量。'
- en: '`s.bucket(v)` returns the index *i* of the bucket in which you''d find the'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.bucket(v)` 返回你将在其中找到元素 `v` 的桶的索引 *i*。'
- en: element `v`, if it existed in this `unordered_set`.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在这个 `unordered_set` 中存在元素 `v`。
- en: '`s.bucket_size(i)` returns the number of elements in the *i*th bucket. Observe
    that invariably `s.count(v) <= s.bucket_size(s.bucket(v))`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.bucket_size(i)` 返回第 *i* 个桶中的元素数量。注意，总是 `s.count(v) <= s.bucket_size(s.bucket(v))`。'
- en: '`s.load_factor()` returns `s.size() / s.bucket_count()` as a `float` value.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.load_factor()` 返回 `s.size() / s.bucket_count()` 作为 `float` 值。'
- en: '`s.rehash(n)` increases (or decreases) the size of the bucket array to exactly
    `n`.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.rehash(n)` 将桶数组的尺寸精确增加到 `n`。'
- en: You might have noticed that `load_factor` seems out of place so far; what's
    so important about `s.size() / s.bucket_count()` that it gets its own member function?
    Well, this is the mechanism by which `unordered_set` scales itself as its number
    of elements grows. Each `unordered_set` object `s` has a value `s.max_load_factor()`
    indicating exactly how large `s.load_factor()` is allowed to get. If an insertion
    would push `s.load_factor()` over the top, then `s` will reallocate its array
    of buckets and rehash its elements in order to keep `s.load_factor()` smaller
    than `s.max_load_factor()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `load_factor` 似乎有些不合适；`s.size() / s.bucket_count()` 有什么重要之处，以至于它有自己的成员函数？嗯，这是
    `unordered_set` 随着元素数量的增长而扩展的机制。每个 `unordered_set` 对象 `s` 都有一个值 `s.max_load_factor()`，它精确地表示
    `s.load_factor()` 允许达到的大小。如果一个插入操作会将 `s.load_factor()` 推过顶点，那么 `s` 将重新分配其桶数组，并重新散列其元素，以保持
    `s.load_factor()` 小于 `s.max_load_factor()`。
- en: '`s.max_load_factor()` is `1.0` by default. You can set it to a different value
    `k` by using the one-parameter overload: `s.max_load_factor(k)`. However, that''s
    basically never necessary or a good idea.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.max_load_factor()` 默认值为 `1.0`。您可以通过使用单参数重载 `s.max_load_factor(k)` 将其设置为不同的值
    `k`。然而，这基本上从未必要，也不是一个好主意。'
- en: One administrative operation that *does* make sense is `s.reserve(k)`. Like
    `vec.reserve(k)` for vectors, this `reserve` member function means "I'm planning
    to do insertions that bring the size of this container up into the vicinity of
    `k`. Please pre-allocate enough space for those `k` elements right now." In the
    case of `vector`, that meant allocating an array of `k` elements. In the case
    of `unordered_set`, it means allocating a bucket array of `k / max_load_factor()`
    pointers, so that even if `k` elements are inserted (with the expected number
    of collisions), the load factor will still only be `max_load_factor()`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有意义的行政操作是 `s.reserve(k)`。类似于 `vec.reserve(k)` 对于向量，这个 `reserve` 成员函数意味着“我计划进行插入操作，这将使这个容器的大小达到
    `k` 附近。请现在就为这些 `k` 个元素预分配足够的空间。”在 `vector` 的情况下，这意味着分配一个包含 `k` 个元素的数组。在 `unordered_set`
    的情况下，这意味着分配一个包含 `k / max_load_factor()` 个指针的桶数组，这样即使插入 `k` 个元素（预期会有一定数量的冲突），负载因子仍然只会是
    `max_load_factor()`。
- en: Where does the memory come from?
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存从哪里来？
- en: Throughout this whole chapter, I've actually been lying to you! Each of the
    containers described in this chapter--except for `std::array`--takes one *more*
    optional template type parameter. This parameter is called the *allocator*, and
    it indicates where the memory comes from for operations such as "reallocating
    the underlying array" or "allocating a new node on the linked list." `std::array`
    doesn't need an allocator because it holds all of its memory inside itself; but
    every other container type needs to know where to get its allocations from.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个本章中，我实际上一直在对你撒谎！本章中描述的每个容器——除了 `std::array` 之外——都多了一个可选的模板类型参数。这个参数被称为*分配器*，它表示“reallocating
    the underlying array”或“allocating a new node on the linked list”等操作所需的内存来源。“std::array”不需要分配器，因为它在其内部持有所有内存；但每个其他容器类型都需要知道从哪里获取其分配。
- en: The default value for this template parameter is the standard library type `std::allocator<T>`,
    which is certainly good enough for most users. We'll talk more about allocators
    in [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d), *Allocators*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板参数的默认值是标准库类型 `std::allocator<T>`，这对于大多数用户来说肯定足够好了。我们将在第 8 章[分配器](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d)中更多地讨论分配器。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter we''ve learned the following: A *container* manages the *ownership*
    of a collection of elements. STL containers are always class templates parameterized
    on the element type, and sometimes on other relevant parameters as well. Every
    container except `std::array<T, N>` can be parameterized by an *allocator* type
    to specify the manner in which it allocates and deallocates memory. Containers
    that use comparison can be parameterized by a *comparator* type. Consider using
    transparent comparator types such as `std::less<>` instead of homogeneous comparators.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了以下内容：*容器*管理一组元素的*所有权*。STL 容器始终是类模板，参数化元素类型，有时也参数化其他相关参数。除了 `std::array<T,
    N>` 之外，每个容器都可以通过一个*分配器*类型进行参数化，以指定其分配和释放内存的方式。使用比较的容器可以由一个*比较器*类型进行参数化。考虑使用透明比较器类型，如
    `std::less<>` 而不是同质比较器。
- en: When using `std::vector`, watch out for reallocation and address invalidation.
    When using most container types, watch out for iterator invalidation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `std::vector` 时，请注意重新分配和地址无效化。当使用大多数容器类型时，请注意迭代器无效化。
- en: The standard library's philosophy is to support no operation that is naturally
    inefficient (such as `vector::push_front`); and to support any operation that
    is naturally efficient (such as `list::splice`). If you can think of an efficient
    implementation for a particular operation, odds are that the STL has already implemented
    it under some name; you just have to figure out how it's spelled.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的哲学是支持没有自然低效操作（例如 `vector::push_front`）；并支持任何自然高效的操作（例如 `list::splice`）。如果你能想到某个特定操作的效率实现，那么很可能是STL已经以某个名称实现了它；你只需要弄清楚它的拼写。
- en: When in doubt, use `std::vector`. Use other container types only when you need
    their particular set of skills. Specifically, avoid the pointer-based containers
    (`set`, `map`, `list`) unless you need their special skills (maintaining sorted
    order; extracting, merging, and splicing).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不确定，请使用 `std::vector`。只有在你需要特定容器类型的功能时才使用其他容器类型。具体来说，除非你需要它们的特殊功能（维护排序顺序；提取、合并和拼接），否则请避免使用基于指针的容器（`set`、`map`、`list`）。
- en: Online references such as [cppreference.com](http://cppreference.com) are your
    best resource for figuring these things out.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在线参考资料，如 [cppreference.com](http://cppreference.com)，是解决这些问题的最佳资源。
