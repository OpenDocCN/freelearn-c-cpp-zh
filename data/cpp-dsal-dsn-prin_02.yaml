- en: 2\. Trees, Heaps, and Graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 树、堆和图
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Analyze and identify where non-linear data structures can be used
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析和确定非线性数据结构可以使用的地方
- en: Implement and manipulate tree structures to represent data and solve problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和操作树结构来表示数据和解决问题
- en: Traverse a tree using various methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种方法遍历树
- en: Implement a graph structure to represent data and solve problems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现图结构来表示数据和解决问题
- en: Represent a graph using different methods based on a given scenario
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据给定的场景使用不同的方法表示图
- en: In this chapter, we will look at two non-linear data structures, namely trees
    and graphs, and how they can be used to represent real-world scenarios and solve
    various problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看两种非线性数据结构，即树和图，以及它们如何用于表示现实世界的场景和解决各种问题。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we implemented different types of linear data structures
    to store and manage data in a linear fashion. In linear structures, we can traverse
    in, at most, two directions – forward or backward. However, the scope of these
    structures is very limited, and they can't be used to solve advanced problems.
    In this chapter, we'll explore a more advanced class of problems. We will see
    that the solutions we implemented previously are not good enough to be used directly.
    Due to this, we'll expand upon those data structures to make more complex structures
    that can be used to represent non-linear data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了不同类型的线性数据结构，以线性方式存储和管理数据。在线性结构中，我们最多可以沿着两个方向遍历 - 向前或向后。然而，这些结构的范围非常有限，不能用来解决高级问题。在本章中，我们将探讨更高级的问题。我们将看到我们之前实现的解决方案不足以直接使用。因此，我们将扩展这些数据结构，以创建更复杂的结构，用于表示非线性数据。
- en: After looking at these problems, we'll discuss basic solutions using the **tree**
    data structure. We'll implement different types of trees to solve different kinds
    of problems. After that, we'll have a look at a special type of tree called a
    **heap**, as well as its possible implementation and applications. Following that,
    we'll look at another complex structure – **graphs**. We'll implement two different
    representations of a graph. These structures help translate real-world scenarios
    into a mathematical form. Then, we will apply our programming skills and techniques
    to solve problems related to those scenarios.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了这些问题之后，我们将讨论使用**树**数据结构的基本解决方案。我们将实现不同类型的树来解决不同类型的问题。之后，我们将看一种特殊类型的树，称为**堆**，以及它的可能实现和应用。接下来，我们将看另一种复杂结构
    - **图**。我们将实现图的两种不同表示。这些结构有助于将现实世界的场景转化为数学形式。然后，我们将应用我们的编程技能和技术来解决与这些场景相关的问题。
- en: A strong understanding of trees and graphs serves as the basis for understanding
    even more advanced problems. Databases (B-trees), data encoding/compression (Huffman
    tree), graph coloring, assignment problems, minimum distance problems, and many
    more problems are solved using certain variants of trees and graphs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对树和图有深刻的理解是理解更高级问题的基础。数据库（B树）、数据编码/压缩（哈夫曼树）、图着色、分配问题、最小距离问题等许多问题都是使用树和图的某些变体来解决的。
- en: Now, let's look at some examples of problems that cannot be represented by linear
    data structures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些不能用线性数据结构表示的问题的例子。
- en: Non-Linear Problems
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非线性问题
- en: Two main categories of situations that cannot be represented with the help of
    linear data structures are hierarchical problems and cyclic dependencies. Let's
    take a closer look at these cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无法使用线性数据结构表示的两种主要情况是分层问题和循环依赖。让我们更仔细地看看这些情况。
- en: Hierarchical Problems
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分层问题
- en: 'Let''s look at a couple of examples that inherently have hierarchical properties.
    The following is the structure of an organization:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些固有分层属性的例子。以下是一个组织的结构：
- en: '![Figure 2.1: Organization structure](img/C14498_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：组织结构](img/C14498_02_01.jpg)'
- en: 'Figure 2.1: Organization structure'
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.1：组织结构
- en: As we can see, the CEO is the head of the company and manages the Deputy Director.
    The Deputy Director leads three other officers, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，CEO是公司的负责人，管理副总监。副总监领导其他三名官员，依此类推。
- en: 'The data is inherently hierarchical in nature. This type of data is difficult
    to manage using simple arrays, vectors, or linked lists. To solidify our understanding,
    let''s look at another use case; that is, a university course''s structure, as
    shown in the following figure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据本质上是分层的。使用简单的数组、向量或链表来管理这种类型的数据是困难的。为了巩固我们的理解，让我们看另一个用例；即，大学课程的结构，如下图所示：
- en: '![](img/C14498_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_02_02.jpg)'
- en: 'Figure 2.2: Course hierarchy in a university course structure'
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.2：大学课程结构中的课程层次结构
- en: 'The preceding figure shows the course dependencies for some courses in a hypothetical
    university. As we can see, to learn Advanced Physics II, the student must have
    successfully completed the following courses: Advanced Physics and Advanced Mathematics.
    Similarly, many other courses have their own prerequisites.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了一个假设大学中一些课程的课程依赖关系。正如我们所看到的，要学习高等物理II，学生必须成功完成以下课程：高等物理和高等数学。同样，许多其他课程也有它们自己的先决条件。
- en: Given such data, we can have different types of queries. For example, we may
    want to find out which courses need to be completed successfully so that we can
    learn Advanced Mathematics.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的数据，我们可以有不同类型的查询。例如，我们可能想找出需要成功完成哪些课程，以便学习高等数学。
- en: These kinds of problems can be solved using a data structure called a tree.
    All of the objects are known as the nodes of a tree, while the paths leading from
    one node to another are known as edges. We'll take a deeper look at this in the
    *Graphs* section, later in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以使用一种称为树的数据结构来解决。所有的对象都被称为树的节点，而从一个节点到另一个节点的路径被称为边。我们将在本章后面的*图*部分更深入地研究这一点。
- en: Cyclic Dependencies
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环依赖
- en: 'Let''s look at another complex real-world scenario that can be represented
    better with a non-linear structure. The following figure represents the friendship
    between a few people:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个可以用非线性结构更好地表示的复杂现实场景。以下图表示了几个人之间的友谊：
- en: '![Figure 2.3: A network of friends](img/C14498_02_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：朋友网络](img/C14498_02_03.jpg)'
- en: 'Figure 2.3: A network of friends'
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.3：朋友网络
- en: This structure is called a graph. The names of people, or the elements, are
    called nodes, and the relations between them are represented as edges. Such structures
    are commonly used by various social networks to represent their users and the
    connections between them. We can observe that Alice is friends with Charlie, who
    is friends with Eddard, who is friends with Grace, and so on. We can also infer
    that Alice, Bob, and Charlie know each other. We may also infer that Eddard is
    a first-level connection for Grace, Charlie is a second-level connection, and
    Alice and Bob are third-level connections.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构称为图。人的名字，或元素，称为节点，它们之间的关系表示为边。各种社交网络通常使用这样的结构来表示他们的用户及其之间的连接。我们可以观察到Alice和Charlie是朋友，Charlie和Eddard是朋友，Eddard和Grace是朋友，依此类推。我们还可以推断Alice、Bob和Charlie彼此认识。我们还可以推断Eddard是Grace的一级连接，Charlie是二级连接，Alice和Bob是三级连接。
- en: Another area where graphs are useful is when we want to represent networks of
    roads between cities, as you will see in the *Graphs* section later in this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图表在*图表*部分中的另一个有用的领域是当我们想要表示城市之间的道路网络时，您将在本章后面的*图表*部分中看到。
- en: Tree – It's Upside Down!
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树-它颠倒了！
- en: As we discussed in the previous section, a tree is nothing but some objects
    or nodes connected to other nodes via a relationship that results in some sort
    of hierarchy. If we were to show this hierarchy in a graphical way, it would look
    like a tree, while the different edges would look like its branches. The main
    node, which is not dependent on any other node, is also known as a root node and
    is usually represented at the top. So, unlike an actual tree, this tree is upside
    down, with the root at its top!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的那样，树只是通过关系连接到其他节点的一些对象或节点，从而产生某种层次结构。如果我们要以图形方式显示这种层次结构，它看起来像一棵树，而不同的边缘看起来像它的分支。主节点，不依赖于任何其他节点，也被称为根节点，并通常表示在顶部。因此，与实际树不同，这棵树是颠倒的，根在顶部！
- en: Let's try to construct a structure for a very basic version of an organizational
    hierarchy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建一个非常基本版本的组织层次结构的结构。
- en: 'Exercise 7: Creating an Organizational Structure'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7：创建组织结构
- en: 'In this exercise, we will implement a basic version of the organizational tree
    we saw in the introduction to this chapter. Let''s get started:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现我们在本章开头看到的组织树的基本版本。让我们开始吧：
- en: 'First, let''s include the required headers:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们包括所需的标头：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For simplicity, we''ll assume that any person can have, at most, two subordinates.
    We''ll see that this is not difficult to extend to resemble real-life situations.
    This kind of tree is also known as a **binary tree**. Let''s write a basic structure
    for that:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为简单起见，我们假设任何人最多可以有两个下属。我们将看到这不难扩展以类似于现实生活中的情况。这种树也被称为**二叉树**。让我们为此编写一个基本结构：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, any node will have two links to other nodes – both of their subordinates.
    By doing this, we can show the recursive structure of the data. We are only storing
    the position at the moment, but we can easily extend this to include a name at
    that position or even a whole struct comprising all the information about the
    person in that position.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，任何节点都将有两个链接到其他节点-它们的下属。通过这样做，我们可以显示数据的递归结构。我们目前只存储位置，但我们可以轻松扩展此功能，以包括该位置的名称，甚至包括关于该位置的人的所有信息的整个结构。
- en: 'We don''t want end users to deal with this kind of raw data structure. So,
    let''s wrap this in a nice interface called `org_tree`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望最终用户处理这种原始数据结构。因此，让我们将其包装在一个名为`org_tree`的良好接口中：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s add a function to create the root, starting with the highest commanding
    officer of the company:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个函数来创建根，从公司的最高指挥官开始：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a static function just to create the tree. Now, let's see how we can
    extend the tree.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个静态函数，用于创建树。现在，让我们看看如何扩展树。
- en: 'Now, we want to add a subordinate of an employee. The function should take
    two parameters – the name of the already existing employee in the tree and the
    name of the new employee to be added as a subordinate. But before that, let''s
    write another function that will help us find a particular node based on a value
    to make our insertion function easier:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要添加一个员工的下属。该函数应该接受两个参数-树中已存在的员工的名字和要添加为下属的新员工的名字。但在此之前，让我们编写另一个函数，以便更容易地找到基于值的特定节点来帮助我们编写插入函数：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While we are traversing the tree in search of an element, either the element
    will be the node we are at, or it will be in either of the right or left subtrees.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在搜索元素时遍历树时，要么元素将是我们所在的节点，要么它将在右子树或左子树中。
- en: Hence, we need to check the root node first. If it is not the desired node,
    we'll try to find it in the left subtree. Finally, if we haven't succeeded in
    doing that, we'll look at the right subtree.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要首先检查根节点。如果不是所需的节点，我们将尝试在左子树中找到它。最后，如果我们没有成功做到这一点，我们将查看右子树。
- en: 'Now, let''s implement the insertion function. We''ll make use of the `find`
    function in order to reuse the code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现插入函数。我们将利用`find`函数以便重用代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, the function returns a Boolean, indicating whether we can insert
    the node successfully or not.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，该函数返回一个布尔值，指示我们是否可以成功插入节点。
- en: 'Now, let''s use this code to create a tree in the `main` function:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用此代码在`main`函数中创建一棵树：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get the following output upon executing the preceding code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上述代码后，您应该获得以下输出：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This output is illustrated in the following diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出在以下图表中说明：
- en: '![Figure 2.4: Binary family tree based on an organization’s hierarchy](img/C14498_02_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：基于组织层次结构的二叉家谱树](img/C14498_02_04.jpg)'
- en: 'Figure 2.4: Binary tree based on an organization''s hierarchy'
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.4：基于组织层次结构的二叉树
- en: Up until now, we've just inserted elements. Now, we'll look at how we can traverse
    the tree. Although we've already seen how to traverse using the `find` function,
    that's just one of the ways we can do it. We can traverse a tree in many other
    ways, all of which we'll look at in the following section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是插入了元素。现在，我们将看看如何遍历树。虽然我们已经看到了如何使用`find`函数进行遍历，但这只是我们可以做的其中一种方式。我们可以以许多其他方式遍历树，所有这些方式我们将在下一节中看到。
- en: Traversing Trees
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历树
- en: 'Once we have a tree, there are various ways we can traverse it and get to the
    node that we require. Let''s take a brief look at the various traversal methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一棵树，就有各种方法可以遍历它并到达我们需要的节点。让我们简要看一下各种遍历方法：
- en: '**Preorder traversal**: In this method, we visit the current node first, followed
    by the left child of the current node, and then the right child of the current
    node in a recursive fashion. Here, the prefix "pre" indicates that the parent
    node is visited before its children. Traversing the tree shown in *figure 2.4*
    using the preorder method goes like this:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先序遍历：在这种方法中，我们首先访问当前节点，然后是当前节点的左子节点，然后是当前节点的右子节点，以递归的方式。这里，前缀“pre”表示父节点在其子节点之前被访问。使用先序方法遍历*图2.4*中显示的树如下：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see, we are always visiting the parent node, followed by the left
    child node, followed by the right child node. We do this not just for the root,
    but for any node with respect to its subtree. We implement preorder traversal
    using a function like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们总是先访问父节点，然后是左子节点，然后是右子节点。我们不仅对根节点是这样，对于任何节点都是这样。我们使用以下函数实现前序遍历：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**In-order traversal**: In this type of traversal, first we''ll visit the left
    node, then the parent node, and finally the right node. Traversing the tree that''s
    shown in *figure 2.4* goes like this:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中序遍历：在这种遍历中，首先访问左节点，然后是父节点，最后是右节点。遍历*图2.4*中显示的树如下：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can implement this in a function like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样实现一个函数：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Post-order traversal**: In this traversal, we first visit both the children,
    followed by the parent node. Traversing the tree that''s shown in *figure 2.4*
    goes like this:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后序遍历：在这种遍历中，我们首先访问两个子节点，然后是父节点。遍历*图2.4*中显示的树如下：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can implement this in a function like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样实现一个函数：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Level order traversal**: This requires us to traverse the tree level by level,
    from top to bottom, and from left to right. This is similar to listing the elements
    at each level of the tree, starting from the root level. The results of such a
    traversal are usually represented as per the levels, as shown here:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次遍历：这要求我们逐层遍历树，从顶部到底部，从左到右。这类似于列出树的每个级别的元素，从根级别开始。这种遍历的结果通常表示为每个级别，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The implementation of this method of traversal is demonstrated in the following
    exercise.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历方法的实现在以下练习中演示。
- en: 'Exercise 8: Demonstrating Level Order Traversal'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8：演示层次遍历
- en: 'In this exercise, we''ll implement level order traversal in the organizational
    structure we created in *Exercise 7*, *Creating an Organizational Structure*.
    Unlike the previous traversal methods, here, we are not traversing to the nodes
    that are directly connected to the current node. This means that traversing is
    easier to achieve without recursion. We will extend the code that was shown in
    *Exercise 7* to demonstrate this traversal. Let''s get started:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在*练习7*中创建的组织结构中实现层次遍历。与先前的遍历方法不同，这里我们不是直接遍历到当前节点直接连接的节点。这意味着遍历更容易实现而不需要递归。我们将扩展*练习7*中显示的代码来演示这种遍历。让我们开始吧：
- en: 'First, we''ll add the following function inside the `org_tree` structure from
    *Exercise 7*:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在*练习7*中的`org_tree`结构中添加以下函数：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As shown in the preceding code, first, we're traversing the root node, followed
    by its children. While visiting the children, we push their children in the queue
    to be processed after the current level is completed. The idea is to start the
    queue from the first level and add the nodes of the next level to the queue. We
    will continue doing this until the queue is empty – indicating there are no more
    nodes in the next level.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，首先我们遍历根节点，然后是它的子节点。在访问子节点时，我们将它们的子节点推入队列中，以便在当前级别完成后处理。这个想法是从第一级开始队列，并将下一级的节点添加到队列中。我们将继续这样做，直到队列为空，表示下一级没有更多的节点。
- en: 'This is what our output should look like:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的输出应该是这样的：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Variants of Trees
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树的变体
- en: In the previous exercises, we've mainly looked at the **binary tree**, which
    is one of the most common kinds of trees. In a binary tree, each node can have
    two child nodes at most. However, a plain binary tree doesn't always serve this
    purpose. Next, we'll look at a more specialized version of the binary tree, called
    a binary search tree.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的练习中，我们主要看了**二叉树**，这是最常见的树之一。在二叉树中，每个节点最多可以有两个子节点。然而，普通的二叉树并不总是满足这个目的。接下来，我们将看一下二叉树的更专业版本，称为二叉搜索树。
- en: Binary Search Tree
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'A **binary search tree** (**BST**) is a popular version of the binary tree.
    BST is nothing but a binary tree with the following properties:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉搜索树**（**BST**）是二叉树的一种流行版本。BST只是具有以下属性的二叉树：'
- en: Value of the parent node ≥ value of the left child
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父节点的值≥左子节点的值
- en: Value of the parent node ≤ value of the right child
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父节点的值≤右子节点的值
- en: In short, left child ≤ parent ≤ right child.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，左子节点≤父节点≤右子节点。
- en: This leads us to an interesting feature. At any point in time, we can always
    say that all the elements that are less than or equal to the parent node will
    be on the left side, while those greater than or equal to the parent node will
    be on the right side. So, the problem of searching an element keeps on reducing
    by half, in terms of search space, at each step.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们到一个有趣的特性。在任何时候，我们总是可以说小于或等于父节点的所有元素将在左侧，而大于或等于父节点的所有元素将在右侧。因此，搜索元素的问题在每一步中都会减少一半，就搜索空间而言。
- en: If the BST is constructed in a way that all the elements except those at the
    last level have both children, the height of the tree will be *log n*, where *n*
    is the number of elements. Due to this, the searching and insertion will have
    a time complexity of *O(log n)*. This type of binary tree is also known as a **complete
    binary tree**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果BST构造成除了最后一级的所有元素都有两个子节点的方式，树的高度将为*log n*，其中*n*是元素的数量。由于这个原因，搜索和插入的时间复杂度将为*O(log
    n)*。这种二叉树也被称为**完全二叉树**。
- en: '**Searching in a BST**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**在BST中搜索**'
- en: 'Let''s look at how we can search, insert, and delete elements in a binary search
    tree. Consider a BST with unique positive integers, as shown in the following
    figure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在二叉搜索树中搜索、插入和删除元素。考虑一个具有唯一正整数的BST，如下图所示：
- en: '![Figure 2.5: Searching for an element in a binary search tree](img/C14498_02_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：在二叉搜索树中搜索元素](img/C14498_02_05.jpg)'
- en: 'Figure 2.5: Searching for an element in a binary search tree'
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.5：在二叉搜索树中搜索元素
- en: Let's say that we have to search for 7\. As we can see from the steps represented
    by arrows in the preceding figure, we choose the side after comparing the value
    with the current node's data. As we've already mentioned, all the nodes on the
    left will always be less than the current node, and all the nodes on the right
    will always be greater than the current node.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要搜索7。从前面图中箭头表示的步骤中可以看出，我们在比较值与当前节点数据后选择侧边。正如我们已经提到的，左侧的所有节点始终小于当前节点，右侧的所有节点始终大于当前节点。
- en: Thus, we start by comparing the root node with 7\. If it is greater than 7,
    we move to the left subtree, since all the elements there are smaller than the
    parent node, and vice versa. We compare each child node until we stumble upon
    7, or a node less than 7 with no right node. In this case, coming to node 4 leads
    to our target, 7.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先将根节点与7进行比较。如果大于7，则移动到左子树，因为那里的所有元素都小于父节点，反之亦然。我们比较每个子节点，直到我们遇到7，或者小于7且没有右节点的节点。在这种情况下，来到节点4会导致我们的目标7。
- en: As we can see, we're not traversing the whole tree. Instead, we are reducing
    our scope by half every time the current node is not the desired one, which we
    do by choosing either the left or the right side. This works similar to a binary
    search for linear structures, which we will learn about in *Chapter* *4*, *Divide
    and Conquer*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们并没有遍历整个树。相反，每次当前节点不是所需节点时，我们通过选择左侧或右侧来减少我们的范围一半。这类似于对线性结构进行二分搜索，我们将在第4章“分而治之”中学习。
- en: '**Inserting a New Element into a BST**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**向BST中插入新元素**'
- en: 'Now, let''s look at how insertion works. The steps are shown in the following
    figure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看插入是如何工作的。步骤如下图所示：
- en: '![Figure 2.6: Inserting an element into a binary search tree](img/C14498_02_06.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6：向二叉搜索树插入元素](img/C14498_02_06.jpg)'
- en: 'Figure 2.6: Inserting an element into a binary search tree'
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.6：向二叉搜索树插入元素
- en: As you can see, first, we have to find the parent node where we want to insert
    the new value. Thus, we have to take a similar approach to the one we took for
    searching; that is, by going in the direction based on comparing each node with
    our new element, starting with the root node. At the last step, 18 is greater
    than 17, but 17 doesn't have a right child. Therefore, we insert 18 in that position.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，首先我们必须找到要插入新值的父节点。因此，我们必须采取与搜索相似的方法；也就是说，通过根据每个节点与我们的新元素进行比较的方向前进，从根节点开始。在最后一步，18大于17，但17没有右子节点。因此，我们在那个位置插入18。
- en: '**Deleting an Element from a BST**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**从BST中删除元素**'
- en: 'Now, let''s look at how deletion works. Consider the following BST:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看删除是如何工作的。考虑以下BST：
- en: '![Figure 2.7: Binary search tree rooted at 12](img/C14498_02_07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：根节点为12的二叉搜索树](img/C14498_02_07.jpg)'
- en: 'Figure 2.7: Binary search tree rooted at 12'
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.7：根节点为12的二叉搜索树
- en: We will delete the root node, 12, in the tree. Let's look at how we can delete
    any value. It's a bit trickier than insertion since we need to find the replacement
    of the deleted node so that the properties of the BST remain true.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除树中的根节点12。让我们看看如何删除任何值。这比插入要棘手，因为我们需要找到已删除节点的替代品，以使BST的属性保持真实。
- en: 'The first step is to find the node to be deleted. After that, there are three
    possibilities:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是找到要删除的节点。之后，有三种可能性：
- en: 'The node has no children: simply delete the node.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点没有子节点：只需删除节点。
- en: 'The node has only one child: point the parent node''s corresponding pointer
    to the only existing child.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点只有一个子节点：将父节点的相应指针指向唯一存在的子节点。
- en: 'The node has two children: in this case, we replace the current node with its
    successor.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点有两个子节点：在这种情况下，我们用它的后继替换当前节点。
- en: The successor is the next biggest number after the current node. Or, in other
    words, the successor is the smallest element among all the elements greater than
    the current one. Therefore, we'll first go to the right subtree, which contains
    all the elements greater than the current one, and find the smallest among them.
    Finding the smallest node means going to the left side of the subtree as much
    as we can because the left child node is always less than its parent. In the tree
    shown in *figure 2.7*, the right subtree of 12 starts at 18\. So, we start looking
    from there, and then try to move down to the left child of 15\. But 15 does not
    have a left child, and the other child, 16, is larger than 15\. Hence, 15 should
    be the successor here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 后继是当前节点之后的下一个最大数。换句话说，后继是所有大于当前元素的所有元素中最小的元素。因此，我们首先转到右子树，其中包含所有大于当前元素的元素，并找到其中最小的元素。找到最小的节点意味着尽可能多地向子树的左侧移动，因为左子节点始终小于其父节点。在*图2.7*中显示的树中，12的右子树从18开始。因此，我们从那里开始查找，然后尝试向15的左子节点移动。但是15没有左子节点，另一个子节点16大于15。因此，15应该是这里的后继。
- en: 'To replace 12 with 15, first, we will copy the value of the successor at the
    root while deleting 12, as shown in the following figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要用15替换12，首先，我们将复制根节点处的后继的值，同时删除12，如下图所示：
- en: '![Figure 2.8: Successor copied to the root node](img/C14498_02_08.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8：后继复制到根节点](img/C14498_02_08.jpg)'
- en: 'Figure 2.8: Successor copied to the root node'
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.8：后继复制到根节点
- en: 'Next, we need to delete the successor, 15, from its old place in the right
    subtree, as shown in the following figure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从右子树中删除后继15，如下图所示：
- en: '![Figure 2.9: Successor deleted from its old place](img/C14498_02_09.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9：从旧位置删除的后继](img/C14498_02_09.jpg)'
- en: 'Figure 2.9: Successor deleted from its old place'
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.9：从旧位置删除的后继
- en: In the last step, we're deleting node 15\. We use the same process for this
    deletion as well. Since 15 had just one child, we replace the left child of 18
    with the child of 15\. So, the whole subtree rooted at 16 becomes the left child
    of 18.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们正在删除节点15。我们对此删除使用相同的过程。由于15只有一个子节点，我们将用15的子节点替换18的左子节点。因此，以16为根的整个子树成为18的左子节点。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The successor node can only have one child at most. If it had a left child,
    we would have picked that child and not the current node as the successor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 后继节点最多只能有一个子节点。如果它有一个左子节点，我们将选择该子节点而不是当前节点作为后继。
- en: Time Complexities of Operations on a Tree
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树上操作的时间复杂度
- en: Now, let's look at the time complexity of these functions. Theoretically, we
    can say that we reduce the scope of the search by half each time. Hence, the time
    that's required to search for the BST with *n* nodes is *T(n) = T(n / 2) + 1*.
    This equation results in a time complexity of *T(n) = O(log n)*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这些函数的时间复杂度。理论上，我们可以说每次将搜索范围减半。因此，搜索具有*n*个节点的BST所需的时间为*T(n) = T(n / 2)
    + 1*。这个方程导致时间复杂度为*T(n) = O(log n)*。
- en: But there's a catch to this. If we look at the insertion function closely, the
    order of insertion actually determines the shape of the tree. And it is not necessarily
    true that we'll always reduce the scope of the search by half, as described by
    *T(n/2)* in the previous formula. Therefore, the complexity *O(log n)* is not
    always accurate. We'll look at this problem and its solution in more depth in
    the *Balanced Tree* section, where we will see how we can calculate time complexity
    more accurately.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个问题。如果我们仔细看插入函数，插入的顺序实际上决定了树的形状。并不一定总是减半搜索范围，如前面公式中的*T(n/2)*所描述的那样。因此，复杂度*O(log
    n)*并不总是准确的。我们将在*平衡树*部分更深入地研究这个问题及其解决方案，我们将看到如何更准确地计算时间复杂度。
- en: For now, let's implement the operations we just saw in C++.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在C++中实现我们刚刚看到的操作。
- en: 'Exercise 9: Implementing a Binary Search Tree'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9：实现二叉搜索树
- en: 'In this exercise, we will implement the BST shown in *figure 2.7* and add a
    `find` function to search for elements. We will also try our hand at the insertion
    and deletion of elements, as explained in the previous subsections. Let''s get
    started:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现*图2.7*中显示的BST，并添加一个“查找”函数来搜索元素。我们还将尝试在前面的子节中解释的插入和删除元素。让我们开始吧：
- en: 'First, let''s include the required headers:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们包括所需的头文件：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s write a node. This will be similar to our previous exercise, except
    we''ll have an integer instead of a string:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们写一个节点。这将类似于我们之前的练习，只是我们将有一个整数而不是一个字符串：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s add a wrapper over the node to provide a clean interface:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在节点上添加一个包装器，以提供一个清晰的接口：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before writing the insertion function, we''ll need to write the `find` function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写插入函数之前，我们需要编写“查找”函数：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since this is recursive, we have kept the implementation in a separate function
    and made it private so as to prevent someone from using it directly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是递归的，我们将实现放在一个单独的函数中，并将其设置为私有，以防止有人直接使用它。
- en: 'Now, let''s write an `insert` function. It will be similar to the `find` function,
    but with small tweaks. First, let''s find the parent node, which is where we want
    to insert the new value:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个“插入”函数。它将类似于“查找”函数，但有一些小调整。首先，让我们找到父节点，这是我们想要插入新值的地方：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, we are checking whether the value should be inserted in the left
    or right subtree. If there's nothing on the desired side, we directly insert the
    node there; otherwise, we call the `insert` function for that side recursively.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们正在检查值应该插入左侧还是右侧子树。如果所需侧面没有任何内容，我们直接在那里插入节点；否则，我们递归调用该侧的“插入”函数。
- en: 'Now, let''s write an `inorder` traversal function. In-order traversal provides
    an important advantage when applied to BST, as we will see in the output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个“中序”遍历函数。中序遍历在应用于BST时提供了重要的优势，正如我们将在输出中看到的：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s implement a utility function to get the successor:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个实用函数来获取后继：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This follows the logic we discussed in the *Deleting an Element in BST* subsection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了我们在*删除BST中的元素*子节中讨论的逻辑。
- en: 'Now, let''s look at the actual implementation of `delete`. Since deletion requires
    repointing the parent node, we''ll do that by returning the new node every time.
    We''ll hide this complexity by putting a better interface over it. We''ll name
    the interface `deleteValue` since `delete` is a reserved keyword, as per the C++
    standard:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`delete`的实际实现。由于删除需要重新指向父节点，我们将通过每次返回新节点来执行此操作。我们将通过在其上放置更好的接口来隐藏这种复杂性。我们将命名接口为`deleteValue`，因为`delete`是C++标准中的保留关键字：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s write the `main` function so that we can use the BST:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写`main`函数，以便我们可以使用BST：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output upon executing the preceding code should be as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码的输出应该如下所示：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Observe the preceding results of in-order traversal for a BST. In-order will
    visit the left subtree first, then the current node, and then the right subtree,
    recursively, as shown in the comments in the code snippet. So, as per BST properties,
    we'll visit all the values smaller than the current one first, then the current
    one, and after that, we'll visit all the values greater than the current one.
    And since this happens recursively, we'll get our data sorted in ascending order.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 观察BST的中序遍历结果。中序遍历将首先访问左子树，然后是当前节点，然后是右子树，如代码片段中的注释所示。因此，根据BST的属性，我们将首先访问所有小于当前值的值，然后是当前值，然后我们将访问所有大于当前值的值。由于这是递归进行的，我们将按升序排序获取我们的数据。
- en: Balanced Tree
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平衡树
- en: 'Before we understand a balanced tree, let''s start with an example of a BST
    for the following insertion order:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解平衡树之前，让我们从以下插入顺序的BST示例开始：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This BST can be visualized with the help of the following figure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下图来可视化这个BST：
- en: '![Figure 2.10: Skewed binary search tree](img/C14498_02_10.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10：倾斜的二叉搜索树](img/C14498_02_10.jpg)'
- en: 'Figure 2.10: Skewed binary search tree'
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.10：倾斜的二叉搜索树
- en: 'As shown in the preceding figure, almost the whole tree is skewed to the left
    side. If we call the `find` function, that is, `bst.find(4)`, the steps will look
    as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，几乎整个树都向左倾斜。如果我们调用`find`函数，即`bst.find(4)`，步骤将如下所示：
- en: '![Figure 2.11: Finding an element in a skewed binary search tree](img/C14498_02_11.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11：在倾斜的二叉搜索树中查找元素](img/C14498_02_11.jpg)'
- en: 'Figure 2.11: Finding an element in a skewed binary search tree'
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.11：在倾斜的二叉搜索树中查找元素
- en: 'As we can see, the number of steps is almost equal to the number of elements.
    Now, let''s try the same thing again with a different insertion order, as shown
    here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，步骤数几乎等于元素数。现在，让我们尝试以不同的插入顺序再次尝试相同的操作，如下所示：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The BST and the steps required to find element 4 will now look as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查找元素4所需的BST和步骤如下：
- en: '![Figure 2.12: Finding an element in a balanced tree](img/C14498_02_12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12：在平衡树中查找元素](img/C14498_02_12.jpg)'
- en: 'Figure 2.12: Finding an element in a balanced tree'
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.12：在平衡树中查找元素
- en: As we can see, the tree is not skewed anymore. Or, in other words, the tree
    is balanced. The steps to find 4 have been considerably reduced with this configuration.
    Thus, the time complexity of `find` is not just dependent on the number of elements,
    but also on their configuration in the tree. If we look at the steps closely,
    we are always going one step toward the bottom of the tree while searching for
    something. And at the end, we end up at the leaf nodes (nodes without any children).
    Here, we return either the desired node or NULL based on the availability of the
    element. So, we can say that the number of steps is always less than the maximum
    number of levels in the BST, also known as the height of the BST. So, the actual
    time complexity for finding an element is O(height).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，树不再倾斜。换句话说，树是平衡的。通过这种配置，查找4的步骤已经大大减少。因此，`find`的时间复杂度不仅取决于元素的数量，还取决于它们在树中的配置。如果我们仔细观察步骤，我们在搜索时总是朝树的底部前进一步。最后，我们将到达叶节点（没有任何子节点的节点）。在这里，我们根据元素的可用性返回所需的节点或NULL。因此，我们可以说步骤数始终小于BST的最大级别数，也称为BST的高度。因此，查找元素的实际时间复杂度为O(height)。
- en: In order to optimize the time complexity, we need to optimize the height of
    the tree. This is also called *balancing a tree*. The idea is to reorganize the
    nodes after insertion/deletion to reduce the skewness of the tree. The resultant
    tree is called a height-balanced BST.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化时间复杂度，我们需要优化树的高度。这也被称为*平衡树*。其思想是在插入/删除后重新组织节点以减少树的倾斜程度。结果树称为高度平衡BST。
- en: 'There are various ways in which we can do this and get different types of trees,
    such as an AVL tree, a Red-Black tree, and so on. The idea behind an AVL tree
    is to perform some rotations to balance the height of the tree, while still maintaining
    the BST properties. Consider the example that''s shown in the following figure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以各种方式执行此操作并获得不同类型的树，例如AVL树、红黑树等。AVL树的思想是执行一些旋转以平衡树的高度，同时仍保持BST的属性。考虑下面图中显示的例子：
- en: '![Figure 2.13: Rotating a tree](img/C14498_02_13.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13：旋转树](img/C14498_02_13.jpg)'
- en: 'Figure 2.13: Rotating a tree'
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.13：旋转树
- en: As we can see, the tree on the right is more balanced compared to the one on
    the left. Rotation is out of the scope of this book and so we will not venture
    into the details of this example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，右侧的树与左侧的树相比更加平衡。旋转超出了本书的范围，因此我们不会深入探讨这个例子的细节。
- en: N-ary Tree
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: N叉树
- en: 'Up until now, we''ve mainly seen binary trees or their variants. For an N-ary
    tree, each node can have *N* children. Since *N* is arbitrary here, we are going
    to store it in a vector. So, the final structure looks something like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要看到了二叉树或其变体。对于N叉树，每个节点可以有*N*个子节点。由于*N*在这里是任意的，我们将其存储在一个向量中。因此，最终的结构看起来像这样：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see, there can be any number of children for each node. Hence, the
    whole tree is completely arbitrary. However, just like a plain binary tree, a
    plain N-ary tree also isn't very useful. Therefore, we have to build a different
    tree for different kinds of applications, where the hierarchy is of a higher degree
    than a binary tree. The example shown in *figure 2.1*, which represents an organization's
    hierarchy, is an N-ary tree.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，每个节点可以有任意数量的子节点。因此，整个树是完全任意的。然而，就像普通的二叉树一样，普通的N叉树也不是很有用。因此，我们必须为不同类型的应用构建不同的树，其中的层次结构比二叉树的度要高。*图2.1*中所示的例子代表了一个组织的层次结构，是一个N叉树。
- en: 'In the computer world, there are two really good, well-known implementations
    of N-ary trees, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机世界中，有两种非常好的、著名的N叉树实现，如下所示：
- en: 'Filesystem structures in computers: Starting from `root` (`/`) in Linux or
    drives in Windows, we can have any number of files (terminal nodes) and any number
    of folders inside any folder. We''ll look at this in greater detail in *Activity
    1, Creating a Data Structure for a Filesystem*.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机中的文件系统结构：从Linux中的`root`（`/`）或Windows中的驱动器开始，我们可以在任何文件夹内拥有任意数量的文件（终端节点）和任意数量的文件夹。我们将在*活动1，为文件系统创建数据结构*中更详细地讨论这一点。
- en: 'Compilers: Most compilers build an Abstract Syntax Tree (AST) based on syntax
    defined by the standard that''s used for the source code. Compilers generate lower-level
    code by parsing the AST.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器：大多数编译器根据源代码的语法构建抽象语法树（AST）。编译器通过解析AST生成低级别代码。
- en: 'Activity 4: Create a Data Structure for a Filesystem'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动4：为文件系统创建数据结构
- en: 'Create a data structure using an N-ary tree for a filesystem that supports
    the following operations: go to directory, find file/directory, add file/directory,
    and list file/directory. Our tree will hold the information and folder hierarchy
    (path) of all the elements (files and folders) in the filesystem.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用N叉树创建一个文件系统的数据结构，支持以下操作：转到目录，查找文件/目录，添加文件/目录和列出文件/目录。我们的树将保存文件系统中所有元素（文件和文件夹）的信息和文件夹层次结构（路径）。
- en: 'Perform the following steps to solve this activity:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来解决此活动：
- en: Create an N-ary tree with two data elements in a node – the name of the directory/file
    and a flag indicating whether it's a directory or a file.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个N叉树，其中一个节点中有两个数据元素-目录/文件的名称和指示它是目录还是文件的标志。
- en: Add a data member to store the current directory.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个数据成员来存储当前目录。
- en: Initialize the tree with a single directory root (`/`).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用单个目录根（`/`）初始化树。
- en: Add the find directory/file function, which takes a single parameter – `path`.
    The `path` can be either absolute (starting with `/`) or relative.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加查找目录/文件的函数，它接受一个参数-`path`。`path`可以是绝对的（以`/`开头）或相对的。
- en: Add functions to add a file/directory and list files/directories located at
    a given path.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加函数以添加文件/目录并列出位于给定路径的文件/目录。
- en: Similarly, add a function to change the current directory.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，添加一个函数来更改当前目录。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 490.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第490页找到。
- en: We've printed directories with `d` in front to distinguish them from files,
    which are printed with a "`–`" (hyphen) in front. You can experiment by creating
    more directories and files with absolute or relative paths.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打印了带有`d`的目录，以区分它们与文件，文件是以"`-`"（连字符）开头打印的。您可以通过创建具有绝对或相对路径的更多目录和文件来进行实验。
- en: So far, we haven't supported certain Linux conventions, such as addressing any
    directory with a single dot and addressing a parent directory with double dots.
    This can be done by extending our node to also hold a pointer to its parent node.
    This way, we can traverse in both directions very easily. There are various other
    extensions possible, such as the addition of symlinks, as well as globing operators
    to expand the names of the various files/directories using "`*`". This exercise
    provides us with a base so that we can build something on our own based on our
    requirements.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有支持某些Linux约定，例如用单个点寻址任何目录和用双点寻址父目录。这可以通过扩展我们的节点来完成，以便还保存指向其父节点的指针。这样，我们可以非常容易地在两个方向上遍历。还有其他各种可能的扩展，例如添加符号链接，以及使用"`*`"扩展各种文件/目录名称的通配符操作符。这个练习为我们提供了一个基础，这样我们就可以根据自己的需求构建一些东西。
- en: Heaps
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆
- en: 'In the previous chapter, we had a brief look at heaps and how C++ provides
    heaps via STL. In this chapter, we''ll take a deeper look at heaps. Just to recap,
    the following are the intended time complexities:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了堆以及C++如何通过STL提供堆。在本章中，我们将更深入地了解堆。简而言之，以下是预期的时间复杂度：
- en: '*O(1)*: Immediate access to the max element'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O(1)*：立即访问最大元素'
- en: '*O(log n)*: Insertion of any element'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O(log n)*：插入任何元素'
- en: '*O(log n)*: Deletion of the max element'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O(log n)*：删除最大元素'
- en: 'To achieve *O(log n)* insertion/deletion, we''ll use a tree to store data.
    But in this case, we''ll ''use a complete tree. A **complete tree** is defined
    as a tree where nodes at all the levels except the last one have two children,
    and the last level has as many of the elements on the left side as possible. For
    example, consider the two trees shown in the following figure:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现*O(log n)*的插入/删除，我们将使用树来存储数据。但在这种情况下，我们将使用完全树。**完全树**被定义为一个树，其中除了最后一层以外的所有级别的节点都有两个子节点，并且最后一层尽可能多地在左侧具有元素。例如，考虑以下图中显示的两棵树：
- en: '![Figure 2.14: Complete versus non-complete tree](img/C14498_02_14.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14：完全树与非完全树](img/C14498_02_14.jpg)'
- en: 'Figure 2.14: Complete versus non-complete tree'
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.14：完全树与非完全树
- en: Thus, a complete tree can be constructed by inserting elements in the last level,
    as long as there's enough space there. If not, we will insert them at the leftmost
    position on the new level. This gives us a very good opportunity to store this
    tree using an array, level by level. So, the root of the tree will be the first
    element of the array/vector, followed by its left child and then the right child,
    and so on. Unlike other trees, this is a very efficient memory structure because
    there is no extra memory required to store pointers. To go from a parent to its
    child node, we can easily use the index of the array. If the parent is the *i**th*
    node, its children will always be *2*i + 1* and *2*i + 2* indices. And similarly,
    we can get the parent node for the *i**th* child node by using *(i – 1) / 2*.
    We can also confirm this from the preceding figure.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过在最后一级插入元素来构建完整的树，只要那里有足够的空间。如果没有，我们将在新级别的最左边位置插入它们。这给了我们一个很好的机会，可以使用数组逐级存储这棵树。因此，树的根将是数组/向量的第一个元素，其后是其左孩子，然后是右孩子，依此类推。与其他树不同，这是一种非常高效的内存结构，因为不需要额外的内存来存储指针。要从父节点到其子节点，我们可以轻松地使用数组的索引。如果父节点是第*i*个节点，其子节点将始终是*2*i
    + 1*和*2*i + 2*索引。同样，我们可以通过使用*(i – 1) / 2*来获取第*i*个子节点的父节点。我们也可以从前面的图中确认这一点。
- en: Now, let's have a look at the invariants (or conditions) we need to maintain
    upon every insertion/deletion. The first requirement is instant access to the
    max element. For that, we need to fix its position so that it is accessible immediately
    every time. We'll always keep our max element at the top – the root position.
    Now, to maintain this, we also need to maintain another invariant – the parent
    node must be greater than both of its children. Such a heap is also known as a
    **max heap**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们需要在每次插入/删除时保持的不变量（或条件）。第一个要求是立即访问最大元素。为此，我们需要固定其位置，以便每次都可以立即访问。我们将始终将我们的最大元素保持在顶部
    - 根位置。为了保持这一点，我们还需要保持另一个不变量 - 父节点必须大于其两个子节点。这样的堆也被称为**最大堆**。
- en: As you can probably guess, the properties that are required for fast access
    to the maximum element can be easily inverted for fast access to the minimum element.
    All we need to do is invert our comparison function while performing heap operations.
    This kind of heap is known as a **min heap**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，为了快速访问最大元素所需的属性可以很容易地反转，以便快速访问最小元素。我们在执行堆操作时所需要做的就是反转我们的比较函数。这种堆被称为**最小堆**。
- en: Heap Operations
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆操作
- en: In this section, we will see how we can perform different operations on a heap.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何在堆上执行不同的操作。
- en: '**Inserting an Element into a Heap**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**向堆中插入元素**'
- en: As the first step of insertion, we will preserve the most important invariant,
    which provides us with a way to represent this structure as an array – a complete
    tree. This can easily be done by inserting the new element at the end since it
    will represent the element in the last level, right after all the existing elements,
    or as the first element in a new level if the current last level is full.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为插入的第一步，我们将保留最重要的不变量，这为我们提供了一种将此结构表示为数组的方式 - 完整树。这可以很容易地通过在末尾插入新元素来完成，因为它将代表最后一级的元素，就在所有现有元素之后，或者作为新级别中的第一个元素，如果当前的最后一级已满。
- en: Now, we need to preserve the other invariant – all the nodes must have a value
    greater than both of their children, if available. Assuming that our current tree
    is already following this invariant, after the insertion of the new element in
    the last position, the only element where the invariant may fail would be the
    last element. To resolve this, we swap the element with its parent if the parent
    is smaller than the element. Even if the parent already has another element, it
    will be smaller than the new element (new element > parent > child).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要保持另一个不变量 - 所有节点的值必须大于它们的两个子节点的值，如果有的话。假设我们当前的树已经遵循这个不变量，在最后位置插入新元素后，唯一可能违反不变量的元素将是最后一个元素。为了解决这个问题，如果父节点比元素小，我们将元素与其父节点交换。即使父节点已经有另一个元素，它也将小于新元素（新元素
    > 父节点 > 子节点）。
- en: 'Thus, the subtree that''s created by considering the new element as the root
    satisfies all the invariants. However, the new element may still be greater than
    its new parent. Therefore, we need to keep on swapping the nodes until the invariant
    is satisfied for the whole tree. Since the height of a complete tree is *O(log
    n)* at most, the entire operation will take a maximum of *O(log n)* time. The
    following figure illustrates the operation of inserting elements into a tree:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过将新元素视为根创建的子树满足所有不变量。然而，新元素可能仍然大于其新父节点。因此，我们需要不断交换节点，直到整个树的不变量得到满足。由于完整树的高度最多为*O(log
    n)*，整个操作将最多需要*O(log n)*时间。下图说明了向树中插入元素的操作：
- en: '![Figure 2.15: Inserting an element into a heap with one node](img/C14498_02_15.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15：向具有一个节点的堆中插入元素](img/C14498_02_15.jpg)'
- en: 'Figure 2.15: Inserting an element into a heap with one node'
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.15：向具有一个节点的堆中插入元素
- en: 'As shown in the preceding figure, after inserting 11, the tree doesn''t have
    the heap property anymore. Therefore, we''ll swap 10 and 11 to make it a heap
    again. This concept is clearer with the following example, which has more levels:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在插入11后，树不再具有堆属性。因此，我们将交换10和11以使其再次成为堆。这个概念在下面的例子中更清晰，该例子有更多级别：
- en: '![Figure 2.16: Inserting an element into a heap with several nodes](img/C14498_02_16.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16：向具有多个节点的堆中插入元素](img/C14498_02_16.jpg)'
- en: 'Figure 2.16: Inserting an element into a heap with several nodes'
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.16：向具有多个节点的堆中插入元素
- en: '**Deleting an Element from a Heap**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**从堆中删除元素**'
- en: 'The first thing to notice is that we can only delete the max element. We can''t
    directly touch any other element. The max element is always present at the root.
    Hence, we''ll remove the root element. But we also need to decide who''ll take
    its position. For that, we first need to swap the root with the last element,
    and then remove the last element.That way, our root will be deleted, but it will
    break the invariant of having each parent node greater than its children. To resolve
    this, we''ll compare the root with its two children and swap it with the greater
    one. Now, the invariant is broken at one of the subtrees. We continue the swapping
    process recursively throughout the subtree. That way, the breaking point of the
    invariant is bubbled down the tree. Just like insertion, we follow this until
    we meet the invariant. The maximum number of steps required will be equal to the
    height of the tree, which is *O(log n)*. The following figure illustrates this
    process:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们只能删除最大的元素。我们不能直接触摸任何其他元素。最大的元素始终存在于根部。因此，我们将删除根元素。但我们还需要决定谁将接替它的位置。为此，我们首先需要将根与最后一个元素交换，然后删除最后一个元素。这样，我们的根将被删除，但它将打破每个父节点都大于其子节点的不变性。为了解决这个问题，我们将根与它的两个子节点进行比较，并与较大的子节点交换。现在，不变性在一个子树中被破坏。我们继续在整个子树中递归地进行交换过程。这样，不变性的破坏点就会沿着树向下冒泡。就像插入一样，我们一直遵循这个过程，直到满足不变性。所需的最大步数将等于树的高度，即*O(log
    n)*。下图说明了这个过程：
- en: '![Figure 2.17: Deleting an element in a heap](img/C14498_02_17.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17：删除堆中的一个元素](img/C14498_02_17.jpg)'
- en: 'Figure 2.17: Deleting an element in a heap'
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.17：删除堆中的一个元素
- en: '**Initialization of a Heap**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化堆**'
- en: Now, let's look at one of the most important steps – the initialization of a
    heap. Unlike vectors, lists, deques, and so on, a heap is not simple to initialize
    because we need to maintain the invariants of the heap. One easy solution would
    be to insert all the elements starting from an empty heap, one by one. But the
    time required for this would be *O(n * log(n))*, which is not efficient.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看最重要的一步 - 初始化堆。与向量、列表、双端队列等不同，堆的初始化并不简单，因为我们需要维护堆的不变性。一个简单的解决方案是从一个空堆开始逐个插入所有元素。但是这样需要的时间是*O(n
    * log(n))*，这并不高效。
- en: However, there's a `std::make_heap`, which can take any array or vector iterators
    and convert them into a heap.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个`std::make_heap`，它可以接受任何数组或向量迭代器，并将它们转换为堆。
- en: 'Exercise 10: Streaming Median'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习10：流式中位数
- en: 'In this exercise, we''ll solve an interesting problem that frequently occurs
    in data analysis-related applications, including machine learning. Imagine that
    some source is giving us data one element at a time continuously (a stream of
    data). We need to find the median of the elements that have been received up until
    now after receiving each and every element. One simple way of doing this would
    be to sort the data every time a new element comes in and return the middle element.
    But this would have an *O(n log n)* time complexity because of sorting. Depending
    on the rate of incoming elements, this can be very resource-intensive. However,
    we''ll optimize this with the help of heaps. Let''s get started:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将解决一个在数据分析相关应用中经常出现的有趣问题，包括机器学习。想象一下，某个来源不断地给我们提供数据（数据流）中的一个元素。我们需要在每次接收到每个元素后找到到目前为止已接收到的元素的中位数。一个简单的方法是每次有新元素进来时对数据进行排序并返回中间元素。但是由于排序的原因，这将具有*O(n
    log n)*的时间复杂度。根据输入元素的速率，这可能非常消耗资源。然而，我们将通过堆来优化这个问题。让我们开始吧：
- en: 'Let''s include the required headers first:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先让我们包括所需的头文件：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s write a container to store the data we''ve received up until now.
    We''ll store the data among two heaps – one min heap and one max heap. We''ll
    store the smaller, first half of the elements in a max heap, and the larger, or
    the other half, in a min heap. So, at any point, the median can be calculated
    using only the top elements of the heaps, which are easily accessible:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个容器来存储到目前为止收到的数据。我们将数据存储在两个堆中 - 一个最小堆和一个最大堆。我们将把较小的前半部分元素存储在最大堆中，将较大的或另一半存储在最小堆中。因此，在任何时候，中位数可以使用堆的顶部元素来计算，这些元素很容易访问：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s write an `insert` function so that we can insert the newly arrived
    data:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个`insert`函数，以便我们可以插入新到达的数据：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s write a `get` function so that we can get the median from the containers:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个`get`函数，以便我们可以从容器中获取中位数：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s write a `main` function so that we can use this class:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个`main`函数，以便我们可以使用这个类：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序的输出如下：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This way, we only need to insert any newly arriving elements, which only has
    a time complexity of *O(log n)*, compared to the time complexity of *O(n log n)*
    if we were to sort the elements with each new element.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们只需要插入任何新到达的元素，这只需要*O(log n)*的时间复杂度，与如果我们每次有新元素就对元素进行排序的时间复杂度*O(n log n)*相比。
- en: 'Activity 5: K-Way Merge Using Heaps'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动5：使用堆进行K路合并
- en: Consider a biomedical application related to genetics being used for processing
    large datasets. It requires ranks of DNA in a sorted manner to calculate similarity.
    But since the dataset is huge, it can't fit on a single machine. Therefore, it
    processes and stores data in a distributed cluster, and each node has a set of
    sorted values. The main processing engine requires all of the data to be in a
    sorted fashion and in a single stream. So, basically, we need to merge multiple
    sorted arrays into a single sorted array. Simulate this situation with the help
    of vectors.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个与遗传学相关的生物医学应用，用于处理大型数据集。它需要对DNA的排名进行排序以计算相似性。但由于数据集很大，无法放在一台机器上。因此，它在分布式集群中处理和存储数据，每个节点都有一组排序的值。主处理引擎需要所有数据以排序方式和单个流的形式。因此，基本上，我们需要将多个排序数组合并成一个排序数组。借助向量模拟这种情况。
- en: 'Perform the following steps to solve this activity:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来解决这个活动：
- en: The smallest number will be present in the first element of all the lists since
    all the lists have already been sorted individually. To get that minimum faster,
    we'll build a heap of those elements.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小的数字将出现在所有列表的第一个元素中，因为所有列表已经分别排序。为了更快地获取最小值，我们将构建这些元素的堆。
- en: After getting the minimum element from the heap, we need to remove it and replace
    it with the next element from the same list it belongs to.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从堆中获取最小元素后，我们需要将其移除并用它所属列表中的下一个元素替换。
- en: The heap node must contain information about the list so that it can find the
    next number from that list.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆节点必须包含关于列表的信息，以便它可以从该列表中找到下一个数字。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 495.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第495页找到。
- en: Now, let's calculate the time complexity of the preceding algorithm. If there
    are *k* lists available, our heap size will be k, and all of our heap operations
    will be *O(log k)*. Building heap will be *O(k log k)*. After that, we'll have
    to perform a heap operation for each element in the result. The total elements
    are *n × k*. Therefore, the total complexity will be *O(nk log k)*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们计算前面算法的时间复杂度。如果有*k*个列表可用，我们的堆大小将为*k*，我们所有的堆操作都将是*O(log k)*。构建堆将是*O(k log
    k)*。之后，我们将不得不为结果中的每个元素执行堆操作。总元素为*n × k*。因此，总复杂度将是*O(nk log k)*。
- en: The wonderful thing about this algorithm is that, considering the real-life
    scenario we described earlier, it doesn't actually need to store all the *n ×
    k* elements at the same time; it only needs to store *k* elements at any point
    in time, where *k* is the number of lists or nodes in the cluster. Due to this,
    the value of *k* will never be too large. With the help of a heap, we can generate
    one number at a time and either process the number immediately or stream it elsewhere
    for processing without actually storing it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的奇妙之处在于，考虑到我们之前描述的现实场景，它实际上并不需要同时存储所有的*n × k*元素；它只需要在任何时刻存储*k*个元素，其中*k*是集群中列表或节点的数量。由于这个原因，*k*的值永远不会太大。借助堆，我们可以一次生成一个数字，然后立即处理该数字，或者将其流式传输到其他地方进行处理，而无需实际存储它。
- en: Graphs
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图
- en: Although a tree is a pretty good way to represent hierarchical data, we can't
    represent circular or cyclic dependencies in a tree because we always have a single
    and unique path to go from one node to another. However, there are more complex
    scenarios that have a cyclic structure inherently. For example, consider a road
    network. There can be multiple ways to go from one place (places can be represented
    as nodes) to another. Such a set of scenarios can be better represented using
    graphs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管树是表示分层数据的一种很好的方式，但我们无法在树中表示循环依赖，因为我们总是有一条单一且唯一的路径可以从一个节点到另一个节点。然而，还有更复杂的情况具有固有的循环结构。例如，考虑一个道路网络。可以有多种方式从一个地点（地点可以表示为节点）到另一个地点。这样的一组情景可以更好地用图来表示。
- en: Unlike a tree, a graph has to store data for the nodes, as well as for the edges
    between the nodes. For example, in any road network, for each node (place), we
    have to store the information about which other nodes (places) it connects to.
    This way, we can form a graph with all the required nodes and edges. This is called
    an **unweighted graph**. We can add *weights*, or more information, to each of
    the edges. For our road network example, we can add the distance of each edge
    (path) from one node (place) to another. This representation, called a **weighted
    graph**, has all the information about a road network that's required to solve
    problems such as finding the path that has the minimum distance between one place
    and another.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与树不同，图必须存储节点的数据，以及节点之间的边的数据。例如，在任何道路网络中，对于每个节点（地点），我们都必须存储它连接到哪些其他节点（地点）的信息。这样，我们就可以形成一个包含所有所需节点和边的图。这被称为**无权图**。我们可以为每条边添加*权重*或更多信息。对于我们的道路网络示例，我们可以添加每条边（路径）从一个节点（地点）到另一个节点的距离。这种表示被称为**加权图**，它包含了解决诸如找到两个地点之间最小距离的路径等问题所需的道路网络的所有信息。
- en: There are two types of graphs – undirected and directed. An **undirected graph**
    indicates that the edges are bidirectional. Bidirectional indicates a bilateral
    or commutative property. For the road network example, a bidirectional edge between
    points A and B implies that we can go from A to B, as well as from B to A. But
    let's say we have some roads with a one-way restriction – we need to use a **directed
    graph** to represent that. In a direct graph, whenever we need to indicate that
    we can go in either direction, we use two edges – from point A to B, and B to
    A. We'll mainly focus on bidirectional graphs, but the things we'll learn here
    about structure and traversing methods hold true for directed graphs as well.
    The only change will be how we add edges to the graph.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图有两种类型 - 无向图和有向图。**无向图**表示边是双向的。双向表示具有双边或可交换属性。对于道路网络示例，点A和点B之间的双向边意味着我们可以从A到B，也可以从B到A。但假设我们有一些有单向限制的道路
    - 我们需要使用**有向图**来表示。在有向图中，每当我们需要指示可以双向行驶时，我们使用两条边 - 从点A到B，以及从B到A。我们主要关注双向图，但我们在这里学到的关于结构和遍历方法的知识对于有向图也是正确的。唯一的变化将是我们如何向图中添加边。
- en: Since a graph can have cyclic edges and more than one way to go from one node
    to another, we need to identify each node uniquely. For that, we can assign an
    identifier to each node. To represent the graph's data, we don't really need to
    build a node-like structure programmatically, as we did in trees. In fact, we
    can store the whole graph by combining `std` containers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图可以具有循环边和从一个节点到另一个节点的多条路径，我们需要唯一标识每个节点。为此，我们可以为每个节点分配一个标识符。为了表示图的数据，我们实际上不需要像在树中那样以编程方式构建类似节点的结构。事实上，我们可以通过组合`std`容器来存储整个图。
- en: Representing a Graph as an Adjacency Matrix
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将图表示为邻接矩阵
- en: Here is one of the simplest ways to understand a graph – consider a set of nodes,
    where any node can connect to any other node among the set directly. This means
    that we can represent this using a 2D array that's *N × N* in size for a graph
    with *N* nodes. The value in each cell will indicate the weight of the edge between
    the corresponding nodes based on the indices of the cell. So, `data[1][2]` will
    indicate the weight of the edge between node 1 and node 2\. This method is known
    as an **adjacency matrix**. We can indicate the absence of an edge using a weight
    of -1.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是理解图的最简单方法之一——考虑一组节点，其中任何节点都可以直接连接到该组中的任何其他节点。这意味着我们可以使用大小为*N×N*的二维数组来表示这一点，其中*N*为节点数。每个单元格中的值将根据单元格的索引指示相应节点之间的边的权重。因此，`data[1][2]`将指示节点1和节点2之间边的权重。这种方法称为**邻接矩阵**。我们可以使用-1的权重表示边的缺失。
- en: 'Consider the weighted graph shown in the following figure, which represents
    an aviation network between a few major international cities, with hypothetical
    distances:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下图中所示的加权图，它表示了一些主要国际城市之间的航空网络，带有假设的距离：
- en: '![Figure 2.18: Aviation network between some cities](img/C14498_02_18.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18：一些城市之间的航空网络](img/C14498_02_18.jpg)'
- en: 'Figure 2.18: Aviation network between some cities'
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.18：一些城市之间的航空网络
- en: As shown in the preceding figure, we can go from London to Dubai via Istanbul
    or directly. There are multiple ways to go from one place to another, which was
    not the case with trees. Also, we can traverse from one node to another and come
    back to the original node via some different edges, which was also not possible
    in a tree.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图所示，我们可以通过伊斯坦布尔或直接从伦敦到迪拜。从一个地方到另一个地方有多种方式，这在树的情况下是不可能的。此外，我们可以从一个节点遍历到另一个节点，然后通过一些不同的边回到原始节点，这在树中也是不可能的。
- en: Let's implement the matrix representation method for the graph shown in the
    preceding figure.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现前面图中所示的图的矩阵表示方法。
- en: 'Exercise 11: Implementing a Graph and Representing it as an Adjacency Matrix'
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习11：实现图并将其表示为邻接矩阵
- en: 'In this exercise, we will implement a graph representing the network of cities
    shown in the preceding figure, and demonstrate how it can be stored as an adjacency
    matrix. Let''s get started:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个代表前面图中所示的城市网络的图，并演示如何将其存储为邻接矩阵。让我们开始吧：
- en: 'First, let''s include the required headers:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们包括所需的头文件：
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s add an `enum` class so that we can store the names of the cities:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个`enum`类，以便我们可以存储城市的名称：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s also add a `<<` operator for the `city` enum:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还为`city`枚举添加`<<`运算符：
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s write the `struct graph`, which will encapsulate our data:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写`struct graph`，它将封装我们的数据：
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s add a constructor that will create an empty graph (a graph without
    any edges) with a given number of nodes:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个构造函数，它将创建一个空图（没有任何边的图）并给定节点数：
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s add the most important function – `addEdge`. It will take three
    parameters – the two cities to be connected and the weight (distance) of the edge:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加最重要的函数——`addEdge`。它将接受三个参数——要连接的两个城市和边的权重（距离）：
- en: '[PRE41]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s add a function so that we can remove an edge from the graph:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个函数，这样我们就可以从图中删除一条边：
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s write the `main` function so that we can use these functions:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写`main`函数，以便我们可以使用这些函数：
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Upon executing this program, we should get the following output:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此程序后，我们应该得到以下输出：
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we can see, we are storing the data in a vector of a vector, with both dimensions
    equal to the number of nodes. Hence, the total space required for this representation
    is proportional to *V2*, where *V* is the number of nodes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们正在将数据存储在一个向量的向量中，两个维度都等于节点数。因此，这种表示所需的总空间与*V2*成正比，其中*V*是节点数。
- en: Representing a Graph as an Adjacency List
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将图表示为邻接表
- en: A major problem with a matrix representation of a graph is that the amount of
    memory required is directly proportional to the number of nodes squared. As you
    might imagine, this adds up quickly with the number of nodes. Let's see how we
    can improve this so that we use less memory.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵表示图的一个主要问题是所需的内存量与节点数的平方成正比。可以想象，随着节点数的增加，这会迅速增加。让我们看看如何改进这一点，以便使用更少的内存。
- en: In any graph, we'll have a fixed number of nodes, and each node will have a
    fixed maximum number of connected nodes, which is equal to the total nodes. In
    a matrix, we have to store all the edges for all the nodes, even if two nodes
    are not directly connected to each other. Instead, we'll only store the IDs of
    the nodes in each row, indicating which nodes are directly connected to the current
    one. This representation is also called an **adjacency list**.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何图中，我们将有固定数量的节点，每个节点将有固定数量的连接节点，等于总节点数。在矩阵中，我们必须存储所有节点的所有边，即使两个节点不直接连接。相反，我们只会在每一行中存储节点的ID，指示哪些节点直接连接到当前节点。这种表示也称为**邻接表**。
- en: Let's see how the implementation differs compared to the previous exercise.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现与之前练习的不同之处。
- en: 'Exercise 12: Implementing a Graph and Representing it as an Adjacency List'
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习12：实现图并将其表示为邻接表
- en: 'In this exercise, we will implement a graph representing the network of cities
    shown in *figure 2.18*, and demonstrate how it can be stored as an adjacency list.
    Let''s get started:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个代表城市网络的图，如*图2.18*所示，并演示如何将其存储为邻接表。让我们开始吧：
- en: 'We''ll implement an adjacency list representation in this exercise. Let''s
    start with headers, as usual:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现邻接表表示。让我们像往常一样从头文件开始：
- en: '[PRE45]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s add an `enum` class so that we can store the names of the cities:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个`enum`类，以便我们可以存储城市的名称：
- en: '[PRE46]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s also add the `<<` operator for the `city` enum:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还为`city`枚举添加`<<`运算符：
- en: '[PRE47]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s write the `struct graph`, which will encapsulate our data:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写`struct graph`，它将封装我们的数据：
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s see how our constructor defers from a matrix representation:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们的构造函数与矩阵表示有何不同：
- en: '[PRE49]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we can see, we are initializing the data with a 2D vector, but all the rows
    are initially empty because there are no edges present at the start.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们正在用2D向量初始化数据，但所有行最初都是空的，因为开始时没有边。
- en: 'Let''s implement the `addEdge` function for this:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为此实现`addEdge`函数：
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, let''s write `removeEdge` so that we can remove an edge from the graph:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写`removeEdge`，这样我们就可以从图中移除一条边：
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s write the `main` function so that we can use these functions:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写`main`函数，这样我们就可以使用这些函数：
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Upon executing this program, we should get the following output:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此程序后，我们应该得到以下输出：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Since we are storing a list of adjacent nodes for each node, this method is
    called an adjacency list. This method also uses a vector of a vector to store
    the data, just like the former method. But the dimension of the inner vector is
    not equal to the number of nodes; instead, it depends on the number of edges.
    For each edge in the graph, we'll have two entries, as per our `addEdge` function.
    The memory that's required for this type of representation would be proportional
    to E, where E is the number of edges.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为每个节点存储了一个相邻节点的列表，这种方法被称为邻接表。这种方法也使用了一个向量的向量来存储数据，就像前一种方法一样。但内部向量的维度不等于节点的数量；相反，它取决于边的数量。对于图中的每条边，根据我们的`addEdge`函数，我们将有两个条目。这种表示所需的内存将与E成正比，其中E是边的数量。
- en: Up until now, we've only seen how to build a graph. We need to traverse a graph
    to be able to perform any operations while using it. There are two widely used
    methods available – Breadth-First Search (BFS) and Depth-First Search (DFS), both
    of which we'll look at in *Chapter 6*, *Graph Algorithms I*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了如何构建图。我们需要遍历图才能执行任何操作。有两种广泛使用的方法可用——广度优先搜索（BFS）和深度优先搜索（DFS），我们将在*第6章*，*图算法I*中看到这两种方法。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at a more advanced class of problems compared to
    the previous chapter, which helped us to describe a wider range of real-world
    scenarios. We looked at and implemented two major data structures – trees and
    graphs. We also looked at various types of trees that we can use in different
    situations. Then, we looked at different ways of representing data programmatically
    for these structures. With the help of this chapter, you should be able to apply
    these techniques to solve real-world problems of similar kinds.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了与上一章相比更高级的问题类别，这有助于我们描述更广泛的现实场景。我们看了并实现了两种主要的数据结构——树和图。我们还看了我们可以在不同情况下使用的各种类型的树。然后，我们看了不同的方式来以编程方式表示这些结构的数据。通过本章的帮助，您应该能够应用这些技术来解决类似种类的现实世界问题。
- en: Now that we've looked at linear and non-linear data structures, in the next
    chapter, we'll look at a very specific but widely used concept called lookup,
    where the goal is to store values in a container so that searching is super fast.
    We will also look at the fundamental idea behind hashing and how can we implement
    such a container.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过线性和非线性数据结构，在下一章中，我们将看一个非常特定但广泛使用的概念，称为查找，目标是将值存储在容器中，以便搜索非常快速。我们还将看一下哈希的基本思想以及如何实现这样的容器。
