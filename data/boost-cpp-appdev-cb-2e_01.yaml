- en: Starting to Write Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写你的应用程序
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Getting configuration options
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取配置选项
- en: Storing any value in a container/variable
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任何值存储在一个容器/变量中
- en: Storing multiple chosen types in a container/variable
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个选择的类型存储在一个容器/变量中
- en: Using a safer way to work with a container that stores multiple chosen types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更安全的方式处理存储多个选择类型的容器
- en: Returning a value or flag where there is no value
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有值的情况下返回一个值或标志
- en: Returning an array from a function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数返回数组
- en: Combining multiple values into one
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个值合并为一个
- en: Binding and reordering function parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定和重新排序函数参数
- en: Getting a human-readable type name
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取可读的类型名称
- en: Using the C++11 move emulation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++11移动模拟
- en: Making a noncopyable class
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个不可复制的类
- en: Making a noncopyable but movable class
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个不可复制但可移动的类
- en: Using C++14 and C++11 algorithms
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++14和C++11算法
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '**Boost** is a collection of C++ libraries. Each library has been reviewed
    by many professional programmers before being accepted by Boost. Libraries are
    tested on multiple platforms using many compilers and many C++ standard library
    implementations. While using Boost, you can be sure that you are using one of
    the most portable, fast, and reliable solutions that is distributed under a license
    suitable for commercial and open source projects.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boost**是一个C++库集合。每个库在被Boost接受之前都经过许多专业程序员的审查。库在多个平台上使用多个编译器和多个C++标准库实现进行测试。在使用Boost时，您可以确信您正在使用一个最具可移植性、快速和可靠的解决方案之一，该解决方案在商业和开源项目中都适用的许可证下分发。'
- en: Many parts of Boost have been included into C++11, C++14, and C++17\. Furthermore,
    Boost libraries will be included in the next standard of C++. You will find C++
    standard-specific notes in each recipe of this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Boost的许多部分已经包含在C++11、C++14和C++17中。此外，Boost库将包含在C++的下一个标准中。您将在本书的每个配方中找到特定于C++标准的注释。
- en: Without a long introduction, let's get started!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要长篇介绍，让我们开始吧！
- en: In this chapter, we will see some recipes for everyday use. We'll see how to
    get configuration options from different sources and what can be cooked up using
    some of the data types introduced by Boost library authors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到一些日常使用的配方。我们将看到如何从不同来源获取配置选项，以及使用Boost库作者介绍的一些数据类型可以做些什么。
- en: Getting configuration options
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取配置选项
- en: 'Take a look at some of the console programs, such as `cp` in Linux. They all
    have a fancy help; their input parameters do not depend on any position and have
    a human-readable syntax. For example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 看看一些控制台程序，比如Linux中的`cp`。它们都有一个漂亮的帮助；它们的输入参数不依赖于任何位置，并且具有人类可读的语法。例如：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can implement the same functionality for your program in 10 minutes. All
    you need is the `Boost.ProgramOptions` library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在10分钟内为你的程序实现相同的功能。你所需要的只是`Boost.ProgramOptions`库。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Basic knowledge of C++ is all you need for this recipe. Remember that this library
    is not only a header, so your program has to link against the `libboost_program_options`
    library.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方只需要基本的C++知识。请记住，这个库不仅仅是一个头文件，所以你的程序必须链接到`libboost_program_options`库。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start with a simple program that accepts the count of `apples` and `oranges`
    as input and counts the total number of fruits. We want to achieve the following
    result:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的程序开始，该程序接受`apples`和`oranges`的数量作为输入，并计算水果的总数。我们希望实现以下结果：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Perform the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Include the `boost/program_options.hpp` header and make an alias for the `boost::program_options`
    namespace (it is too long to type it!). We would also need an `<iostream>` header:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括`boost/program_options.hpp`头文件，并为`boost::program_options`命名空间创建一个别名（它太长了！）。我们还需要一个`<iostream>`头文件：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we are ready to describe our options in the `main()` function:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备在`main()`函数中描述我们的选项：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s parse the command line:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们解析命令行：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s add some code for processing the `help` option:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为处理`help`选项添加一些代码：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Final step. Counting fruits may be implemented in the following way:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步。计算水果可以以以下方式实现：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, if we call our program with the `help` parameter, we''ll get the following
    output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用`help`参数调用我们的程序，我们将得到以下输出：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we do not provide a type for the `help` option's value, because
    we do not expect any values to be passed to it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们没有为`help`选项的值提供类型，因为我们不希望向其传递任何值。
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This example is pretty simple to understand from code and comments. Running
    it produces the expected result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子从代码和注释中很容易理解。运行它会产生预期的结果：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The C++ standard adopted many Boost libraries; however, you won't find `Boost.ProgramOptions`
    even in C++17\. Currently, there's no plan to adopt it into C++2a.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准采用了许多Boost库；然而，即使在C++17中，你也找不到`Boost.ProgramOptions`。目前，没有计划将其纳入C++2a。
- en: 'The `ProgramOptions` library is very powerful and has many features. Here''s
    how to:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgramOptions`库非常强大，具有许多功能。以下是如何做的：'
- en: 'Parse configuration option values directly into a variable and make that option
    a required one:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置选项值直接解析到一个变量中，并将该选项设置为必需的：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Get some mandatory string option:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一些必需的字符串选项：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add short name for apple, set `10` as a default value for `apples`:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为苹果添加简称，将`10`设置为`apples`的默认值：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Get the missing options from the configuration file:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从配置文件获取缺失的选项：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The configuration file syntax differs from the command-line syntax. We do not
    need to place minuses before the options. So, our `apples_oranges.cfg` file must
    look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件语法与命令行语法不同。我们不需要在选项前加上减号。因此，我们的`apples_oranges.cfg`文件必须如下所示：
- en: '`oranges=20`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`oranges=20`'
- en: 'Validate that all the required options were set:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证是否设置了所有必需的选项：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we combine all the mentioned tips into a single executable, then its `help`
    command will produce this output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有提到的提示组合成一个可执行文件，那么它的`help`命令将产生以下输出：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running it without a configuration file will produce the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有配置文件运行，将产生以下输出：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the program with `oranges=20` in the configuration file will generate
    ++, because the default value for apples is `10`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中以`oranges=20`运行程序将生成++，因为apples的默认值是`10`：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Boost's official documentation contains many more examples and tells us about
    more advanced features of `Boost.ProgramOptions`, such as position-dependent options,
    nonconventional syntax, and more; this is available at [http://boost.org/libs/program_options](http://boost.org/libs/program_options)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档包含了更多的例子，并告诉我们关于`Boost.ProgramOptions`更高级的特性，比如位置相关的选项，非常规的语法等；可以在[http://boost.org/libs/program_options](http://boost.org/libs/program_options)找到。
- en: You can modify and run all the examples from this book online at [http://apolukhin.github.io/Boost-Cookbook](http://apolukhin.github.io/Boost-Cookbook)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[http://apolukhin.github.io/Boost-Cookbook](http://apolukhin.github.io/Boost-Cookbook)上修改并运行本书中的所有示例。
- en: Storing any value in a container/variable
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器/变量中存储任何值
- en: 'If you have been programming in Java, C#, or Delphi, you will definitely miss
    the ability of creating containers with the `Object` value type in C++. The `Object`
    class in those languages is a basic class for almost all types, so you are able
    to assign almost any value to it at any time. Just imagine how great it would
    be to have such a feature in C++:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在使用Java、C#或Delphi进行编程，你肯定会想念在C++中使用`Object`值类型创建容器的能力。在这些语言中，`Object`类是几乎所有类型的基本类，因此你可以随时将几乎任何值赋给它。想象一下，如果C++中有这样的功能会多么棒：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be working with the header-only library. The basic knowledge of C++ is
    all you need for this recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个仅包含头文件的库。这个示例只需要基本的C++知识。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Boost offers a solution, the `Boost.Any` library, that has an even better syntax:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Boost提供了一个解决方案，`Boost.Any`库，它具有更好的语法：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Great, isn't it? By the way, it has an empty state, which could be checked using
    the `empty()` member function (just like in standard library containers).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，不是吗？顺便说一句，它有一个空状态，可以使用`empty()`成员函数进行检查（就像标准库容器一样）。
- en: 'You can get the value from `boost::any` using two approaches:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两种方法从`boost::any`中获取值：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::any` class just stores any value in it. To achieve this, it uses
    the **type erasure** technique (close to what Java or C# does with all types).
    To use this library you do not really need to know its internal implementation
    in detail, but here's a quick glance at the type erasure technique for the curious.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::any`类只是在其中存储任何值。为了实现这一点，它使用**类型擦除**技术（与Java或C#对所有类型的处理方式相似）。要使用这个库，你不需要详细了解它的内部实现，但是对于好奇的人来说，这里有一个类型擦除技术的快速概述。'
- en: 'On the assignment of some variable of type `T`, `Boost.Any` instantiates a
    `holder<T>` type that may store a value of the specified type `T` and is derived
    from some base-type `placeholder`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在对类型为`T`的某个变量进行赋值时，`Boost.Any`实例化一个`holder<T>`类型，该类型可以存储指定类型`T`的值，并且派生自某个基本类型`placeholder`：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A `placeholder` type has virtual functions for getting `std::type_info` of
    a stored type `T` and for cloning a stored type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`placeholder`类型有虚函数，用于获取存储类型`T`的`std::type_info`和克隆存储类型：'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`boost::any` stores `ptr`-- a pointer to `placeholder`. When `any_cast<T>()`
    is used, `boost::any` checks that calling `ptr->type()` gives `std::type_info`
    equal to `typeid(T)` and returns `static_cast<holder<T>*>(ptr)->held`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::any`存储`ptr`-- 指向`placeholder`的指针。当使用`any_cast<T>()`时，`boost::any`会检查调用`ptr->type()`是否给出`std::type_info`等于`typeid(T)`，并返回`static_cast<holder<T>*>(ptr)->held`。'
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Such flexibility never comes without any cost. Copy constructing, value constructing,
    copy assigning, and assigning values to instances of `boost::any` do dynamic memory
    allocation; all the type casts do **RunTime Type Information** (**RTTI**) checks;
    `boost::any` uses virtual functions a lot. If you are keen on performance, the
    next recipe will give you an idea of how to achieve almost the same results without
    dynamic allocations and RTTI usage.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性并非没有代价。对`boost::any`的实例进行复制构造、值构造、复制赋值和赋值操作都会进行动态内存分配；所有类型转换都会进行**运行时类型信息**（**RTTI**）检查；`boost::any`大量使用虚函数。如果你对性能很敏感，下一个示例将让你了解如何在不使用动态分配和RTTI的情况下实现几乎相同的结果。
- en: '`boost::any` makes use of **rvalue references** but can not be used in **constexpr**.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::any`使用**右值引用**，但不能在**constexpr**中使用。'
- en: The `Boost.Any` library was accepted into C++17\. If your compiler is C++17
    compatible and you wish to avoid using Boost for `any`, just replace the `boost`
    namespace with namespace `std` and include `<any>` instead of `<boost/any.hpp>`.
    Your standard library implementation may work slightly faster if you are storing
    tiny objects in `std::any`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Any`库已被接受到C++17中。如果你的编译器兼容C++17，并且希望避免使用`boost`来使用`any`，只需将`boost`命名空间替换为`std`命名空间，并包含`<any>`而不是`<boost/any.hpp>`。如果你在`std::any`中存储小对象，你的标准库实现可能会稍微更快。'
- en: '`std::any` has the `reset()` function instead of `clear()` and `has_value()`
    instead of `empty()`. Almost all exceptions in Boost derived from the `std::exception`
    class or from its derivatives, for example, `boost::bad_any_cast` is derived from
    `std::bad_cast`. It means that you can catch almost all Boost exceptions using
    `catch (const std::exception& e)`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::any`具有`reset()`函数，而不是`clear()`，还有`has_value()`而不是`empty()`。Boost中几乎所有的异常都源自`std::exception`类或其派生类，例如，`boost::bad_any_cast`源自`std::bad_cast`。这意味着你几乎可以使用`catch
    (const std::exception& e)`捕获所有Boost异常。'
- en: See also
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Boost's official documentation may give you some more examples; it can be found
    at [http://boost.org/libs/any](http://www.boost.org/libs/any)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档可能会给你一些更多的例子；可以在[http://boost.org/libs/any](http://www.boost.org/libs/any)找到。
- en: The *Using a safer way to work with a container that stores multiple chosen
    types* recipe for more info on the topic
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅*使用更安全的方式处理存储多种选择类型的容器*的示例
- en: Storing multiple chosen types in a container/variable
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器/变量中存储多种选择类型
- en: C++03 unions can only hold extremely simple types called **Plain Old Data**
    (**POD**). For example in C++03, you cannot store `std::string` or `std::vector`
    in a union.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: C++03联合体只能容纳称为**POD**（**Plain Old Data**）的极其简单的类型。例如，在C++03中，你不能在联合体中存储`std::string`或`std::vector`。
- en: Are you aware of the concept of **unrestricted unions** in C++11? Let me tell
    you about it briefly. C++11 relaxes requirements for unions, but you have to manage
    the construction and destruction of non POD types by yourself. You have to call
    in-place construction/destruction and remember what type is stored in a union.
    A huge amount of work, isn't it?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否了解C++11中**不受限制的联合体**的概念？让我简要地告诉你。C++11放宽了对联合体的要求，但你必须自己管理非POD类型的构造和销毁。你必须调用就地构造/销毁，并记住联合体中存储的类型。这是一项巨大的工作，不是吗？
- en: Can we have an unrestricted union like variable in C++03 that manages the object
    lifetime and remembers the type it has?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否可以在C++03中拥有一个像变量一样管理对象生命周期并记住其类型的不受限制的联合体？
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be working with the header-only library, which is simple to use. Basic
    knowledge of C++ is all you need for this recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个只有头文件的库，它很容易使用。这个配方只需要基本的C++知识。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let me introduce the `Boost.Variant` library to you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向你介绍`Boost.Variant`库。
- en: 'The `Boost.Variant` library can store any of the types specified at compile
    time. It also manages in-place construction/destruction and even does not even
    require the C++11 standard:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Boost.Variant`库可以在编译时存储任何指定的类型。它还管理就地构造/销毁，甚至不需要C++11标准：'
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Great, isn't it?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，不是吗？
- en: '`Boost.Variant` has no empty state, but has an `empty()` function which is
    useless and always returns `false`. If you need to represent an empty state, just
    add some simple type at the first position of the types supported by the `Boost.Variant`
    library. When `Boost.Variant` contains that type, interpret it as an empty state.
    Here is an example in which we will use a `boost::blank` type to represent an
    empty state:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Boost.Variant`没有空状态，但有一个无用且总是返回`false`的`empty()`函数。如果你需要表示一个空状态，只需在`Boost.Variant`库支持的类型列表的第一个位置添加一些简单的类型。当`Boost.Variant`包含该类型时，将其解释为空状态。以下是一个例子，我们将使用`boost::blank`类型来表示一个空状态：'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can get a value from a variant using two approaches:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用两种方法从变体中获取值：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::variant` class holds an array of bytes and stores values in that
    array. The size of the array is determined at compile time by applying `sizeof()`
    and functions to get alignment to each of the template types. On assignment, or
    construction of `boost::variant`, the previous values are in-place destructed
    and new values are constructed on top of the byte array, using the placement new.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::variant`类持有一个字节数组并在该数组中存储值。数组的大小是通过在编译时应用`sizeof()`和函数来获取每个模板类型的对齐方式来确定的。在赋值或构造`boost::variant`时，先前的值将就地销毁，并且新值将在字节数组的顶部构造，使用就地新放置。'
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Variant` variables usually do not dynamically allocate memory, and
    they do not require RTTI to be enabled. `Boost.Variant` is extremely fast and
    used widely by other Boost libraries. To achieve maximum performance, make sure
    that there is a simple type in the list of supported types at the first position.
    `boost::variant` takes advantage of C++11 rvalue references if they are available
    on your compiler.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Variant`变量通常不会动态分配内存，也不需要启用RTTI。`Boost.Variant`非常快速，并被其他Boost库广泛使用。为了实现最大的性能，确保在支持的类型列表的第一个位置有一个简单的类型。如果你的编译器支持C++11的右值引用，`boost::variant`将会利用它。'
- en: '`Boost.Variant` is part of the C++17 standard. `std::variant` differs slightly
    from the`boost::variant`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Variant`是C++17标准的一部分。`std::variant`与`boost::variant`略有不同：'
- en: '`std::variant` is declared in the `<variant>` header file rather than in `<boost.variant.hpp>`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::variant`声明在`<variant>`头文件中，而不是在`<boost.variant.hpp>`中。'
- en: '`std::variant` never ever allocates memory'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::variant`永远不会分配内存'
- en: '`std::variant` is usable with constexpr'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::variant`可用于constexpr'
- en: Instead of writing `boost::get<int>(&variable)`, you have to write `std::get_if<int>(&variable)`
    for `std::variant`
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不再需要写`boost::get<int>(&variable)`，而是需要为`std::variant`写`std::get_if<int>(&variable)`
- en: '`std::variant` can not recursively hold itself and misses some other advanced
    techniques'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::variant`不能递归地持有自身，并且缺少一些其他高级技术'
- en: '`std::variant` can in-place construct objects'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::variant`可以就地构造对象'
- en: '`std::variant` has `index()` instead of `which()`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::variant`有`index()`而不是`which()`'
- en: See also
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using a safer way to work with a container that stores multiple chosen
    types* recipe
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用更安全的方式来处理存储多种选择类型的容器*配方'
- en: 'Boost''s official documentation contains more examples and descriptions of
    some other features of `Boost.Variant`, and can be found at: [http://boost.org/libs/variant](http://www.boost.org/libs/variant)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档包含了更多的例子和对`Boost.Variant`的一些其他特性的描述，可以在[http://boost.org/libs/variant](http://www.boost.org/libs/variant)找到
- en: Experiment with the code online at [http://apolukhin.github.io/Boost-Cookbook](http://apolukhin.github.io/Boost-Cookbook)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[http://apolukhin.github.io/Boost-Cookbook](http://apolukhin.github.io/Boost-Cookbook)上在线尝试这段代码
- en: Using a safer way to work with a container that stores multiple chosen types
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更安全的方式来处理存储多种选择类型的容器
- en: Imagine that you are creating a wrapper around some SQL database interface.
    You decided that `boost::any` will perfectly match the requirements for a single
    cell of the database table.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在创建一个围绕某个SQL数据库接口的包装器。你决定`boost::any`完全符合数据库表的单个单元格的要求。
- en: Some other programmer will use your classes, and his/her task would be to get
    a row from the database and count the sum of the arithmetic types in a row.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其他程序员将使用你的类，他/她的任务是从数据库中获取一行并计算该行中算术类型的总和。
- en: 'This is what such a code would look like:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这样一个代码会是什么样子：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you compile and run this example, it will output a correct answer:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行这个例子，它将输出一个正确的答案：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Do you remember what your own thoughts were when reading the implementation
    of `operator()`? I guess they were, *"And what about double, long, short, unsigned,
    and other types?"* The same thoughts will come into the head of a programmer who
    will use your interface. So, you need to carefully document values stored by your
    `cell_t` or use a more elegant solution as described in the following sections.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您还记得阅读`operator()`实现时的想法吗？我猜它们是：“那double、long、short、unsigned和其他类型呢？”使用您的接口的程序员的头脑中也会出现同样的想法。因此，您需要仔细记录`cell_t`存储的值，或者使用以下部分描述的更优雅的解决方案。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Reading the previous two recipes is highly recommended if you are not already
    familiar with the `Boost.Variant` and `Boost.Any` libraries.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还不熟悉`Boost.Variant`和`Boost.Any`库，强烈建议阅读前两个教程。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The `Boost.Variant` library implements a visitor programming pattern for accessing
    the stored data, which is much safer than getting values via `boost::get<>`. This
    pattern forces the programmer to take care of each type in variant, otherwise
    the code will fail to compile. You can use this pattern via the `boost::apply_visitor`
    function, which takes a `visitor` functional object as the first parameter and
    a `variant` as the second parameter. If you are using a pre C++14 compiler, then
    `visitor` functional objects must derive from the `boost::static_visitor<T>` class,
    where `T` is a type being returned by a `visitor`. A `visitor` object must have
    overloads of `operator()` for each type stored by a variant.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Variant`库实现了访问存储数据的访问者编程模式，比通过`boost::get<>`获取值更安全。这种模式强制程序员注意variant中的每种类型，否则代码将无法编译。您可以通过`boost::apply_visitor`函数使用此模式，该函数将`visitor`函数对象作为第一个参数，将`variant`作为第二个参数。如果您使用的是C++14之前的编译器，则`visitor`函数对象必须派生自`boost::static_visitor<T>`类，其中`T`是`visitor`返回的类型。`visitor`对象必须对variant存储的每种类型重载`operator()`。'
- en: 'Let''s change the `cell_t` type to `boost::variant<int, float, string>` and
    modify our example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`cell_t`类型更改为`boost::variant<int, float, string>`并修改我们的例子：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'At compile time, the `Boost.Variant` library generates a big `switch` statement,
    each case of which calls a `visitor` for a single type from the variant''s list
    of types. At runtime, the index of the stored type is retrieved using `which()`
    and jumps to a correct case in `switch` statement is made. Something like this
    will be generated for `boost::variant<int, float, std::string>`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，`Boost.Variant`库生成一个大的`switch`语句，每个case都调用variant类型列表中的单个类型的`visitor`。在运行时，使用`which()`检索存储类型的索引，并跳转到`switch`语句中的正确case。对于`boost::variant<int,
    float, std::string>`，将生成类似于以下内容：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the `address()` function returns a pointer to the internal storage of
    `boost::variant<int, float, std::string>`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`address()`函数返回一个指向`boost::variant<int, float, std::string>`内部存储的指针。
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we compare this example with the first example in this recipe, we''ll see
    the following advantages of `boost::variant`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个例子与本教程中的第一个例子进行比较，我们会看到`boost::variant`的以下优点：
- en: We know what types a variable can store
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道变量可以存储哪些类型。
- en: If a library writer of the SQL interface adds or modifies a type held by a `variant`,
    we'll get a compile-time error instead of incorrect behavior
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果SQL接口的库编写者添加或修改了`variant`持有的类型，我们将得到编译时错误而不是不正确的行为
- en: '`std::variant` from C++17 also supports visitation. Just write `std::visit`
    instead of `boost::apply_visitor` and you''re done.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中的`std::variant`也支持访问。只需使用`std::visit`而不是`boost::apply_visitor`即可。
- en: You can download the example code files for all Packt books that you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/](http://www.PacktPub.com/)support,
    and register to have the files emailed directly to you.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.PacktPub.com](http://www.PacktPub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了本书，可以访问[http://www.PacktPub.com/](http://www.PacktPub.com/)support，并注册以直接通过电子邮件接收文件。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: After reading some recipes from [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-Time Tricks*, you'll be able to make generic `visitor` objects that work
    correctly even if underlying types change
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读[第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)的一些教程后，即*编译时技巧*，即使底层类型发生变化，您也能够正确地编写通用的`visitor`对象
- en: 'Boost''s official documentation contains more examples and a description of
    some other features of `Boost.Variant`; it is available at the following link:
    [http://boost.org/libs/variant](http://www.boost.org/libs/variant)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档包含更多示例和`Boost.Variant`的一些其他特性的描述；可以在以下链接找到：[http://boost.org/libs/variant](http://www.boost.org/libs/variant)
- en: Returning a value or flag where there is no value
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在没有值的情况下返回值或标志
- en: Imagine that we have a function that does not throw an exception and returns
    a value or indicates that an error has occurred. In Java or C# programming languages,
    such cases are handled by comparing a return value from a function value with
    a `null` pointer. If the function returned `null`, then an error has occurred.
    In C++, returning a pointer from a function confuses library users and usually
    requires slow dynamic memory allocation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个不会抛出异常并返回值或指示发生错误的函数。在Java或C#编程语言中，通过将函数值与`null`指针进行比较来处理这种情况。如果函数返回了`null`，则发生了错误。在C++中，从函数返回指针会使库用户感到困惑，并且通常需要缓慢的动态内存分配。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Only basic knowledge of C++ is required for this recipe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程只需要基本的C++知识。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Ladies and gentlemen, let me introduce you to the `Boost.Optional` library
    using the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 女士们先生们，让我通过以下示例向您介绍`Boost.Optional`库：
- en: 'The `try_lock_device()` function tries to acquire a lock for a device and may
    succeed or not, depending on different conditions (in our example it depends on
    some `try_lock_device_impl()` function call):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_lock_device()`函数尝试获取设备的锁，可能成功也可能不成功，这取决于不同的条件（在我们的示例中，这取决于一些`try_lock_device_impl()`函数的调用）：'
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The function returns the `boost::optional` variable that can be converted to
    a `bool`. If the returned value is equal to `true`, then the lock is acquired
    and an instance of a class to work with the device can be obtained by dereferencing
    the returned optional variable:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回可转换为`bool`的`boost::optional`变量。如果返回值等于`true`，则锁已获取，并且可以通过解引用返回的可选变量获得用于处理设备的类的实例：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This program will output the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将输出以下内容：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The default constructed `optional` variable is convertible to `false` and must
    not be dereferenced, because such an `optional` does not have an underlying type
    constructed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造的`optional`变量可转换为`false`，不得解引用，因为这样的`optional`没有构造的基础类型。
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`boost::optional<T>` under the hood has a properly aligned array of bytes where
    the object of type `T` can be an in-place constructed. It also has a `bool` variable
    to remember the state of the object (is it constructed or not?).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::optional<T>`在内部有一个正确对齐的字节数组，可以在其中就地构造类型为`T`的对象。它还有一个`bool`变量来记住对象的状态（它是否被构造了？）。'
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Optional` class does not use dynamic allocation and it does not require
    a default constructor for the underlying type. The current `boost::optional` implementation
    can work with C++11 rvalue references but is not usable with constexpr.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Optional`类不使用动态分配，也不需要基础类型的默认构造函数。当前的`boost::optional`实现可以使用C++11的右值引用，但不能在constexpr中使用。'
- en: If you have a class `T` that has no empty state but your program logic requires
    an empty state or uninitialized `T`, then you have to come up with some workaround.
    Traditionally, users create some smart pointer to the class `T`, keep a `nullptr`
    in it, and dynamically allocate `T` if non empty state is required. Stop doing
    that! Use `boost::optional<T>` instead. It's a much faster and more reliable solution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个类`T`，它没有空状态，但你的程序逻辑需要一个空状态或未初始化的`T`，那么你必须想出一些解决方法。传统上，用户会创建一些指向类`T`的智能指针，在其中保留一个`nullptr`，并在需要非空状态时动态分配`T`。别这样做！使用`boost::optional<T>`。这是一个更快、更可靠的解决方案。
- en: The C++17 standard includes the `std::optional` class. Just replace `<boost/optional.hpp>`
    with `<optional>` and `boost::` with `std::` to use the standard version of this
    class. `std::optional` is usable with constexpr.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: C++17标准包括`std::optional`类。只需将`<boost/optional.hpp>`替换为`<optional>`，将`boost::`替换为`std::`即可使用此类的标准版本。`std::optional`可在constexpr中使用。
- en: See also
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Boost''s official documentation contains more examples and describes advanced
    features of `Boost.Optional` (like in-place construction). The documentation is
    available at the following link: [http://boost.org/libs/optional.](http://www.boost.org/libs/optional)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Boost的官方文档包含了更多例子，并描述了`Boost.Optional`的高级特性（比如就地构造）。文档可在以下链接找到：[http://boost.org/libs/optional.](http://www.boost.org/libs/optional)
- en: Returning an array from a function
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数返回数组
- en: Let's play a game of guessing! What can you tell about the following function?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来玩一个猜谜游戏！你能从以下函数中得出什么？
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Should return values be deallocated by the programmer or not? Does the function
    attempt to deallocate the input parameter? Should the input parameter be zero-terminated,
    or should the function assume that the input parameter has a specified width?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是否应该由程序员释放？函数是否尝试释放输入参数？输入参数是否应该以零结尾，还是函数应该假定输入参数具有指定的宽度？
- en: 'Now, let''s make the task harder! Take a look at the following line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让任务更加困难！看看以下行：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Do not worry. I've also been scratching my head for half an hour before getting
    an idea of what is happening here. `vector_advance` is a function that accepts
    and returns an array of four elements. Is there a way to write such a function
    clearly?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心。在弄清楚这里发生了什么之前，我也曾经思考了半个小时。`vector_advance`是一个接受并返回四个元素的数组的函数。有没有办法清晰地编写这样的函数？
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ is required for this recipe.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方只需要基本的C++知识。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can rewrite the function like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样重写函数：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, `boost::array<char, 4>` is just a simple wrapper around an array of four
    `char` elements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`boost::array<char, 4>`只是一个围绕四个`char`元素的数组的简单包装器。
- en: This code answers all the questions from our first example and is much more
    readable than the code from the second example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码回答了我们第一个例子中的所有问题，并且比第二个例子中的代码更易读。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`boost::array` is a fixed-size array. The first template parameter of `boost::array`
    is the element type and the second one is the size of an array. If you need to
    change the array size at runtime, use `std::vector` , `boost::container::small_vector`,
    `boost::container::stack_vector`, or `boost::container::vector` instead.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::array`是一个固定大小的数组。`boost::array`的第一个模板参数是元素类型，第二个是数组的大小。如果需要在运行时更改数组大小，可以使用`std::vector`、`boost::container::small_vector`、`boost::container::stack_vector`或`boost::container::vector`。'
- en: The `boost::array<>` class has no handwritten constructors and all its members
    are public, so the compiler will treat it as a POD type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::array<>`类没有手写的构造函数，所有成员都是公共的，因此编译器会将其视为POD类型。'
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s see some more examples of the usage of `boost::array`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些更多关于`boost::array`的用法的例子：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One of the biggest advantages of `boost::array` is that it does not allocated
    dynamic memory and provides exactly the same performance as a usual C array. People
    from the C++ Standard committee also liked it, so it was accepted to the C++11
    standard. Try to include the `<array>` header and check for the availability of
    `std::array`. `std::array` has a better support for usage with constexpr since
    C++17.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::array`最大的优势之一是它不分配动态内存，并且提供与普通C数组完全相同的性能。C++标准委员会的人员也很喜欢它，因此它被接受为C++11标准。尝试包含`<array>`头文件，并检查`std::array`的可用性。`std::array`自C++17以来对constexpr的使用支持更好。'
- en: See also
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Boost''s official documentation gives a complete list of the `Boost.Array`
    methods with a description of the method''s complexity and throw behavior. It
    is available at the following link: [http://boost.org/libs/array.](http://www.boost.org/libs/array)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档提供了`Boost.Array`方法的完整列表，包括方法的复杂性和抛出行为的描述。可以在以下链接找到：[http://boost.org/libs/array.](http://www.boost.org/libs/array)
- en: The `boost::array` function is widely used across recipes; for example, refer
    to the *Binding a value as a function parameter* recipe.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::array`函数在许多配方中被广泛使用；例如，参考*将值绑定为函数参数*配方。'
- en: Combining multiple values into one
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个值组合成一个
- en: There is a very nice present for those who like `std::pair`. Boost has a library
    called `Boost.Tuple`. It is just like `std::pair`, but it can also work with triples,
    quads, and even bigger collections of types.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些喜欢`std::pair`的人来说，这是一个非常好的礼物。Boost有一个名为`Boost.Tuple`的库。它就像`std::pair`，但也可以处理三元组、四元组甚至更大的类型集合。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ and a standard library is required for this recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方只需要基本的C++知识和标准库。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to combine multiple values into one:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤将多个值组合成一个：
- en: 'To start working with tuples, you need to include a proper header and declare
    a variable:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用元组，您需要包含适当的头文件并声明一个变量：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Getting a specific value is implemented via the `boost::get<N>()` function,
    where `N` is a zero-based index of a required value:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`boost::get<N>()`函数实现获取特定值，其中`N`是所需值的基于零的索引：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `boost::get<>` function has many overloads and is used widely across Boost.
    We already saw how it can be used with other libraries in the *Storing multiple
    chosen types in a container/variable* recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::get<>`函数有许多重载，在Boost中被广泛使用。我们已经看到它如何与其他库一起在*将多个选择的类型存储在容器/变量中*配方中使用。'
- en: 'You can construct tuples using the `boost::make_tuple()` function, which is
    shorter to write, because you do not need to fully qualify the tuple type:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`boost::make_tuple()`函数构造元组，这样写起来更短，因为不需要完全限定元组类型：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another function that makes life easier is `boost::tie()`. It works almost
    as `make_tuple`, but adds a nonconst reference for each of the passed types. Such
    a tuple can be used to get values to a variable from another tuple. It can be
    better understood from the following example:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个使生活更轻松的函数是`boost::tie()`。它几乎与`make_tuple`一样工作，但为传递的每种类型添加了一个非const引用。这样的元组可以用于从另一个元组中获取值到变量。可以从以下示例更好地理解：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Some readers may wonder why we need a tuple when we can always write our own
    structures with better names; for example, instead of writing `boost::tuple<int,
    std::string>`, we can create a structure:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会想知道为什么我们需要元组，当我们总是可以编写自己的结构并使用更好的名称；例如，我们可以创建一个结构，而不是写`boost::tuple<int,
    std::string>`：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Well, this structure is definitely clearer than `boost::tuple<int, std::string>`.
    The main idea behind the tuple's library is to simplify template programming.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这个结构肯定比`boost::tuple<int, std::string>`更清晰。元组库的主要思想是简化模板编程。
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A tuple works as fast as `std::pair` (it does not allocate memory on a heap
    and has no virtual functions). The C++ committee found this class to be very useful
    and it was included in the standard library. You can find it in a C++11 compatible
    implementation in the header file `<tuple>` (don't forget to replace all the `boost::`
    namespaces with `std::`).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的工作速度与`std::pair`一样快（它不在堆上分配内存，也没有虚函数）。C++委员会发现这个类非常有用，因此它被包含在标准库中。您可以在头文件`<tuple>`中找到与C++11兼容的实现（不要忘记用`std::`替换所有`boost::`命名空间）。
- en: 'The standard library version of tuple must have multiple micro optimizations
    and typically provides a slightly better user experience. However, there is no
    guarantee on the order of construction of tuple elements, so, if you need a tuple
    that constructs its elements starting from the first, you have to use the `boost::tuple`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的标准库版本必须具有多个微优化，并通常提供略好的用户体验。但是，不能保证元组元素的构造顺序，因此，如果需要一个从第一个元素开始构造其元素的元组，必须使用`boost::tuple`：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The current Boost implementation of a tuple does not use variadic templates,
    does not support rvalue references, does not support C++17 structured bindings,
    and is not usable with constexpr.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的Boost元组实现不使用可变模板，不支持右值引用，不支持C++17结构化绑定，并且不支持constexpr。
- en: See also
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Boost's official documentation contains more examples, information about performance,
    and abilities of `Boost.Tuple`. It is available at the link [http://boost.org/libs/tuple](http://www.boost.org/libs/tuple).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档包含了更多关于`Boost.Tuple`的示例、性能信息和能力。可以在以下链接找到：[http://boost.org/libs/tuple](http://www.boost.org/libs/tuple)。
- en: The *Converting all tuple elements to a string* recipe in [Chapter 8](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Metaprogramming,* shows some advanced usages of tuples.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd)的*元编程*中，*将所有元组元素转换为字符串*配方展示了元组的一些高级用法。
- en: Binding and reordering function parameters
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定和重新排序函数参数
- en: 'If you work with the standard library a lot and use the `<algorithm>` header,
    you definitely write a lot of functional objects. In C++14, you can use generic
    lambdas for that. In C++11, you only have non generic lambdas. In the earlier
    versions of the C++ standard, you can construct functional objects using adapter
    functions such as `bind1st`, `bind2nd`, `ptr_fun`, `mem_fun`, `mem_fun_ref`, or
    you can write them by hand (because adapter functions look scary). Here is some
    good news: `Boost.Bind` can be used instead of ugly adapter functions, and it
    provides a more human-readable syntax.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常使用标准库并使用`<algorithm>`头文件，那么您肯定会编写很多功能对象。在C++14中，您可以使用通用lambda来实现。在C++11中，您只能使用非通用lambda。在较早版本的C++标准中，您可以使用适配器函数（如`bind1st`、`bind2nd`、`ptr_fun`、`mem_fun`、`mem_fun_ref`），或者您可以手动编写它们（因为适配器函数看起来很可怕）。好消息是：`Boost.Bind`可以代替丑陋的适配器函数，并提供更易读的语法。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A knowledge of standard library functions and algorithms will be helpful.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉标准库函数和算法将会有所帮助。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see some examples of the usage of `Boost.Bind` along with C++11 lambda
    classes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些使用`Boost.Bind`与C++11 lambda类的例子：
- en: 'All the samples require the following headers:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有示例都需要以下头文件：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Count values greater than 5 as shown in the following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码显示的方式计算大于5的值：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is how we may count empty strings:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何计算空字符串的方法：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s count strings with a length less than `5`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们计算长度小于`5`的字符串：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Compare the strings:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较字符串：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::bind` function returns a functional object that stores a copy of
    bound values and a copy of the original functional object. When the actual call
    to `operator()` is performed, the stored parameters are passed to the original
    functional object along with the parameters passed at the time of call.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::bind`函数返回一个存储绑定值的功能对象，以及原始功能对象的副本。当实际调用`operator()`时，存储的参数将与调用时传递的参数一起传递给原始功能对象。'
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Take a look at the previous examples. When we are binding values, we copy a
    value into a functional object. For some classes this operation is expensive.
    Is there a way to bypass copying?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下之前的例子。当我们绑定值时，我们将一个值复制到一个函数对象中。对于一些类来说，这个操作是昂贵的。有没有办法避免复制？
- en: 'Yes, there is! `Boost.Ref` library will help us here! It contains two functions,
    `boost::ref()` and `boost::cref()`, the first of which allows us to pass a parameter
    as a reference, and the second one passes the parameter as a constant reference.
    The `ref()` and `cref()` functions just construct an object of type `reference_wrapper<T>`
    or `reference_wrapper<const T>`, which is implicitly convertible to a reference
    type. Let''s change our last examples:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有！`Boost.Ref`库将在这里帮助我们！它包含两个函数，`boost::ref()`和`boost::cref()`，第一个允许我们将参数作为引用传递，第二个将参数作为常量引用传递。`ref()`和`cref()`函数只是构造了一个`reference_wrapper<T>`或`reference_wrapper<const
    T>`类型的对象，它们可以隐式转换为引用类型。让我们改变我们的最后一些例子：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can also reorder, ignore, and duplicate function parameters using `bind`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`bind`重新排序、忽略和复制函数参数：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The functions `ref` , `cref`, and `bind` are accepted to the C++11 standard
    and are defined in the `<functional>` header in the `std::` namespace. All these
    functions do not dynamically allocate memory and do not use virtual functions.
    The objects returned by them are easy to optimize for a good compiler.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`、`cref`和`bind`函数被C++11标准接受，并在`std::`命名空间的`<functional>`头文件中定义。所有这些函数都不会动态分配内存，也不会使用虚函数。它们返回的对象易于优化，适用于良好的编译器。'
- en: Standard library implementations of those functions may have additional optimizations
    to reduce compilation time or just compiler-specific optimizations. You may use
    the standard library versions of `bind`, `ref`, `cref` functions with any Boost
    library or even mix Boost and standard library versions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的标准库实现可能具有额外的优化，以减少编译时间或仅仅是特定于编译器的优化。您可以使用`bind`、`ref`、`cref`函数的标准库版本与任何Boost库一起使用，甚至混合使用Boost和标准库版本。
- en: If you are using the C++14 compiler, then use generic lambdas instead of `std::bind`
    and `boost::bind`, as they are less obscure and simpler to understand. C++17 lambdas
    are usable with constexpr, unlike `std::bind` and `boost::bind`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是C++14编译器，那么请使用通用lambda代替`std::bind`和`boost::bind`，因为它们更不晦涩，更容易理解。C++17的lambda可以与constexpr一起使用，而`std::bind`和`boost::bind`不行。
- en: See also
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation contains many more examples and a description of
    advanced features at [http://boost.org/libs/bind.](http://www.boost.org/libs/bind)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档包含更多示例和高级功能的描述，网址为[http://boost.org/libs/bind.](http://www.boost.org/libs/bind)
- en: Getting a human-readable type name
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取可读的类型名称
- en: 'There is often a need to get a readable type name at runtime:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要在运行时获取可读的类型名称：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, the example from earlier is not very portable. It does not work when
    RTTI is disabled, and it does not always produce a nice human-readable name. On
    some platforms, code from earlier will output just `i` or `d`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，之前的例子并不是很通用。当禁用RTTI时，它无法工作，并且并不总是产生一个漂亮的可读名称。在一些平台上，之前的代码将只输出`i`或`d`。
- en: 'Things get worse if we need a type name without stripping the `const`, `volatile`,
    and references:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个不带`const`、`volatile`和引用的类型名称，情况会变得更糟：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Unfortunately, the preceding code outputs `int` in the best case, which is not
    what we were expecting.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，前面的代码在最好的情况下输出`int`，这不是我们期望的结果。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this recipe.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要对C++有基本的了解。
- en: How to do it
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做
- en: 'In the first case, we need a human-readable type name without qualifiers. The
    `Boost.TypeIndex` library will help us out:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们需要一个不带限定符的可读类型名称。`Boost.TypeIndex`库将帮助我们：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the second case, we need to keep the qualifiers, so we need to call a slightly
    different function from the same library:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们需要保留限定符，因此我们需要从同一库中调用一个略有不同的函数：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Boost.TypeIndex` library has a lot of workarounds for different compilers
    and knows the most efficient way to produce a human-readable name for the type.
    If you provide a type as a template parameter, the library guarantees that all
    the possible type related computations will be performed at compile time and code
    will work even if RTTI is disabled.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.TypeIndex`库为不同的编译器提供了许多解决方法，并且知道为类型生成可读名称的最有效方式。如果你将类型作为模板参数提供，该库保证所有可能的类型相关计算将在编译时执行，并且即使禁用了RTTI，代码也能正常工作。'
- en: '`cvr` in `boost::typeindex::type_id_with_cvr` stands for `const`, `volatile`,
    and reference. That makes sure that the type won''t be decayed.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::typeindex::type_id_with_cvr`中的`cvr`代表`const`、`volatile`和引用。这可以确保类型不会被衰减。'
- en: There's more...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All the `boost::typeindex::type_id*` functions return instances of `boost::typeindex::type_index`.
    It is very close to `std::type_index`; however, it additionally, it has a `raw_name()`
    method for getting a raw type name, and `pretty_name()` for getting human-readable
    type name.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`boost::typeindex::type_id*`函数返回`boost::typeindex::type_index`的实例。它与`std::type_index`非常接近；另外，它还有一个`raw_name()`方法用于获取原始类型名称，以及一个`pretty_name()`用于获取可读的类型名称。
- en: Even in C++17, `std::type_index` and `std::type_info` return platform-specific
    type names representations that are rather hard to decode or use portably.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在C++17中，`std::type_index`和`std::type_info`返回的是平台特定的类型名称表示，而这些表示相当难以解码或在可移植性上使用。
- en: Unlike the standard library's `typeid()`, some classes from `Boost.TypeIndex`
    are usable with constexpr. It means that you can get a textual representation
    of your type at compile time if you use a specific `boost::typeindex::ctti_type_index`
    class.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准库的`typeid()`不同，`Boost.TypeIndex`的一些类可用于constexpr。这意味着如果你使用特定的`boost::typeindex::ctti_type_index`类，你可以在编译时获取类型的文本表示。
- en: Users can invent their own RTTI implementations using the `Boost.TypeIndex`
    library. This could be useful for embedded developers and for applications that
    require extremely efficient RTTI tuned for particular types.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用`Boost.TypeIndex`库发明自己的RTTI实现。这对于嵌入式开发人员和需要针对特定类型进行极其高效的RTTI的应用程序非常有用。
- en: See also
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on advanced features and more examples are available at [http://boost.org/libs/type_index.](http://www.boost.org/libs/type_index)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 高级特性和更多示例的文档可在[http://boost.org/libs/type_index](http://www.boost.org/libs/type_index)找到。
- en: Using the C++11 move emulation
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++11移动模拟
- en: One of the greatest features of the C++11 standard is rvalue references. This
    feature allows us to modify temporary objects, stealing resources from them. As
    you can guess, the C++03 standard has no rvalue references, but using the `Boost.Move`
    library, you can write a portable code that emulates them.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准的最大特点之一是右值引用。这个特性允许我们修改临时对象，从中窃取资源。你可以猜到，C++03标准没有右值引用，但是使用`Boost.Move`库，你可以编写一个模拟它们的可移植代码。
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: It is highly recommended that you are at least familiar with the basics of C++11
    rvalue references.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您至少熟悉C++11右值引用的基础知识。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Imagine that you have a class with multiple fields, some of which are standard
    library containers:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有一个类，其中包含多个字段，其中一些是标准库容器：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It is time to add the move assignment and move constructors to it! Just remember
    that in the C++03 standard library, containers have neither move operators nor
    move constructors.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候为其添加移动赋值和移动构造函数了！只需记住，在C++03标准库中，容器既没有移动运算符也没有移动构造函数。
- en: 'The correct implementation of the move assignment is the same move constructing
    an object and swapping it with `this`. The correct implementation of the move
    constructor is close to the default construct and `swap`. So, let''s start with
    the `swap` member function:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动赋值的正确实现与移动构造对象并与`this`交换的方式相同。移动构造函数的正确实现接近于默认构造和`swap`。因此，让我们从`swap`成员函数开始：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, put the following macro in the `private` section:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`private`部分放入以下宏：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Write a copy constructor.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个拷贝构造函数。
- en: 'Write a copy assignment, taking the parameter as: `BOOST_COPY_ASSIGN_REF(person_info)`.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个拷贝赋值，参数为：`BOOST_COPY_ASSIGN_REF(person_info)`。
- en: 'Write a `move` constructor and a move assignment, taking the parameter as `BOOST_RV_REF(person_info)`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`move`构造函数和一个移动赋值，参数为`BOOST_RV_REF(person_info)`：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, we have a portable fast implementation of the move assignment and move
    construction operators of the `person_info` class.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了`person_info`类的可移植快速实现的移动赋值和移动构造运算符。
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Here is an example of how the move assignment can be used:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是移动赋值的示例用法：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `Boost.Move` library is implemented in a very efficient way. When the C++11
    compiler is used, all the macros for rvalues emulation are expanded to C++11-specific
    features otherwise (on C++03 compilers), rvalues are emulated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Move`库的实现非常高效。当使用C++11编译器时，所有用于模拟右值的宏都会扩展为C++11特定的特性，否则（在C++03编译器上），右值将被模拟。'
- en: There's more...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Have you noticed the `boost::swap` call? It is a really helpful utility function,
    which first searches for a `swap` function in the namespace of a variable (in
    our example, it's namespace `other::`), and if there is no matching swap function,
    it uses the `std::swap`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了`boost::swap`的调用吗？这是一个非常有用的实用函数，它首先在变量的命名空间中搜索`swap`函数（在我们的示例中是`other::`命名空间），如果没有匹配的交换函数，则使用`std::swap`。
- en: See also
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information about emulation implementation can be found on the Boost website
    and in the sources of the `Boost.Move` library at [http://boost.org/libs/move.](http://www.boost.org/libs/move)
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关模拟实现的更多信息可以在Boost网站上找到，并且在`Boost.Move`库的源代码中找到[http://boost.org/libs/move](http://www.boost.org/libs/move)。
- en: The `Boost.Utility` library is the one that contains `boost::swap`, and it has
    many useful functions and classes. Refer to [http://boost.org/libs/utility](http://www.boost.org/libs/utility)
    for its documentation.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Utility`库包含`boost::swap`，并且拥有许多有用的函数和类。请参考[http://boost.org/libs/utility](http://www.boost.org/libs/utility)获取其文档。'
- en: The *Initializing a base class by the member of derived* recipe in [Chapter
    2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd), *Managing Resources.*
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd)的*通过派生类的成员初始化基类*食谱中，*管理资源*
- en: The *Making a noncopyable class* recipe.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个不可复制类*食谱。'
- en: In the *Making a noncopyable but movable class* recipe, there is more info about
    `Boost.Move` and some examples on how we can use the movable objects in containers
    in a portable and efficient way.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*创建一个不可复制但可移动的类*食谱中，有关`Boost.Move`的更多信息以及如何以便携和高效的方式在容器中使用可移动对象的一些示例。
- en: Making a noncopyable class
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个不可复制的类
- en: 'You have almost certainly encountered certain situations, where a class owns
    some resources that must not be copied for technical reasons:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎肯定遇到过某些情况，其中一个类拥有一些由于技术原因不能被复制的资源：
- en: '[PRE58]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The C++ compiler in the preceding example generates a copy constructor and
    an assignment operator, so the potential user of the `descriptor_owner` class
    will be able to create the following awful things:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，C++编译器生成了一个复制构造函数和一个赋值运算符，因此`descriptor_owner`类的潜在用户将能够创建以下糟糕的事情：
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only very basic knowledge of C++ is required for this recipe.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱只需要非常基本的C++知识。
- en: How to do it...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To avoid such situations, the `boost::noncopyable` class was invented. If you
    derive your own class from it, the copy constructor and assignment operator won''t
    be generated by the C++ compiler:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，发明了`boost::noncopyable`类。如果你从它派生自己的类，C++编译器将不会生成复制构造函数和赋值运算符：
- en: '[PRE60]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, the user won''t be able to do bad things:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户将无法做坏事：
- en: '[PRE61]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A refined reader will note that we can achieve exactly the same result by:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经过精心雕琢的读者会注意到，我们可以通过以下方式实现完全相同的结果：
- en: Making a copy constructor and an assignment operator of `descriptor_owning_fixed`
    private
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`descriptor_owning_fixed`的复制构造函数和赋值运算符设为私有
- en: Defining them without actual implementation
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义它们而不实际实现
- en: Explicitly deleting them using C++11 syntax `= delete;`
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++11语法`= delete;`显式删除它们
- en: Yes, you are correct. Depending on the abilities of your compiler, `boost::noncopyable`
    class chooses the best way to make the class noncopyable.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你是正确的。根据你的编译器的能力，`boost::noncopyable`类选择了使类不可复制的最佳方式。
- en: '`boost::noncopyable` also serves as a good documentation for your class. It
    never raises questions such as "Is the copy constructor body defined elsewhere?"
    or "Does it have a nonstandard copy constructor (with a non-const referenced parameter)?"'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::noncopyable`也可以作为您的类的良好文档。它永远不会引发诸如“复制构造函数体在其他地方定义吗？”或“它有一个非标准的复制构造函数（带有非const引用参数）吗？”等问题。'
- en: See also
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Making a noncopyable, but movable class* recipe will give you ideas on
    how to allow unique owning of a resource in C++03 by moving it
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个不可复制但可移动的类*食谱将为您提供如何通过移动来允许在C++03中独占资源的想法'
- en: You may find a lot of helpful functions and classes in the `Boost.Core` library's
    official documentation at [http://boost.org/libs/core](http://boost.org/libs/core)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在`Boost.Core`库的官方文档[http://boost.org/libs/core](http://boost.org/libs/core)中找到许多有用的函数和类
- en: The *Initializing a base class by the member of derived* recipe in [Chapter
    2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd), *Managing Resources*
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd)的*通过派生类的成员初始化基类*食谱中，*管理资源*
- en: The *Using C++11 move emulation* recipe
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用C++11移动模拟*食谱'
- en: Making a noncopyable but movable class
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个不可复制但可移动的类
- en: 'Now, imagine the following situation: we have a resource that cannot be copied,
    which should be correctly freed in a destructor, and we want to return it from
    a function:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下以下情况：我们有一个不能复制的资源，应该在析构函数中正确释放，并且我们希望从一个函数中返回它：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Actually, you can work around such situations using the `swap` method:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用`swap`方法解决这种情况：
- en: '[PRE63]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: However, such a workaround does not allow us to use `descriptor_owner` in containers.
    By the way, it looks awful!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样的变通方法不允许我们在容器中使用`descriptor_owner`。顺便说一句，这看起来很糟糕！
- en: Getting ready
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is highly recommended that you are at least familiar with the basics of C++11
    rvalue references. Reading the *Using C++11 move emulation* recipe is also recommended.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您至少熟悉C++11右值引用的基础知识。阅读*使用C++11移动模拟*食谱也是推荐的。
- en: How to do it...
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Those readers who use C++11, already know about the move-only classes (like
    `std::unique_ptr` or `std::thread`). Using such an approach, we can make a move-only
    `descriptor_owner` class:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 那些使用C++11的读者已经知道移动唯一类（如`std::unique_ptr`或`std::thread`）。使用这种方法，我们可以创建一个仅移动的`descriptor_owner`类：
- en: '[PRE64]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This will work only on the C++11 compatible compilers. That is the right moment
    for `Boost.Move`! Let's modify our example, so it can be used on C++03 compilers.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这只适用于C++11兼容的编译器。这是`Boost.Move`的正确时机！让我们修改我们的示例，以便在C++03编译器上使用。
- en: 'According to the documentation, to write a movable but noncopyable type in
    portable syntax, we need to follow these simple steps:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，要以便携的语法编写一个可移动但不可复制的类型，我们需要遵循这些简单的步骤：
- en: 'Put the `BOOST_MOVABLE_BUT_NOT_COPYABLE(classname)` macro in the `private`
    section:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BOOST_MOVABLE_BUT_NOT_COPYABLE(classname)`宏放在`private`部分：
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Write a move constructor and a move assignment, taking the parameter as `BOOST_RV_REF(classname)`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个移动构造函数和一个移动赋值，将参数作为`BOOST_RV_REF(classname)`：
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, we have a movable, but non copyable, class that can be used even on C++03
    compilers and in `Boost.Containers`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个可移动的，但不可复制的类，即使在C++03编译器和`Boost.Containers`中也可以使用：
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Unfortunately, C++03 standard library containers still won't be able to use
    it (that is why we used a vector from `Boost.Containers` in the previous example).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，C++03标准库容器仍然无法使用它（这就是为什么我们在前面的示例中使用了来自`Boost.Containers`的vector）。
- en: There's more...
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you want to use `Boost.Containers` on C++03 compilers, but standard library
    containers on C++11 compilers, you can do the following simple trick. Add the
    header file to your project with the following content:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在C++03编译器上使用`Boost.Containers`，但在C++11编译器上使用标准库容器，您可以使用以下简单技巧。将以下内容的头文件添加到您的项目中：
- en: '[PRE68]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, you can include `<your_project/vector.hpp>` and use a vector from the
    namespace `your_project_namespace`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以包含`<your_project/vector.hpp>`并使用命名空间`your_project_namespace`中的向量：
- en: '[PRE69]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: However, beware of compiler and standard library implementation-specific issues!
    For example, this code will compile on GCC 4.7 in C++11 mode only if you mark
    the move constructor, destructor, and move assignment operators with `noexcept`
    or `BOOST_NOECEPT`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要注意编译器和标准库实现特定的问题！例如，只有在GCC 4.7的C++11模式下，如果您使用`noexcept`或`BOOST_NOECEPT`标记移动构造函数、析构函数和移动赋值运算符，此代码才会编译。
- en: See also
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Reducing code size and increasing performance of user-defined type in C++11*
    recipe in [Chapter 10](part0525.html#FKLNA0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Gathering Platform and Compiler Information*, provides more info on `noexcept`
    and `BOOST_NOEXCEPT`.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](part0525.html#FKLNA0-712b4ba1126a4c7c89e1d44de61b4bdd)中的*C++11中减少代码大小和增加用户定义类型性能*食谱提供了有关`noexcept`和`BOOST_NOEXCEPT`的更多信息。'
- en: More information about `Boost.Move` can be found on Boost's website [http://boost.org/libs/move.](http://www.boost.org/libs/move)
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Boost.Move`的更多信息可以在Boost的网站上找到[http://boost.org/libs/move.](http://www.boost.org/libs/move)
- en: Using C++14 and C++11 algorithms
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++14和C++11算法
- en: 'C++11 has a bunch of new cool algorithms in `<algorithm>` header. C++14 has
    even more algorithms. If you''re stuck with the pre-C++11 compiler, you have to
    write those from scratch. For example, if you wish to output characters from 65
    to 125 code points, you have to write the following code on a pre-C++11 compiler:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: C++11在`<algorithm>`头文件中有一堆新的酷算法。C++14有更多的算法。如果您被困在C++11之前的编译器上，您必须从头开始编写这些算法。例如，如果您希望输出从65到125的字符编码点，您必须在C++11之前的编译器上编写以下代码：
- en: '[PRE70]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Getting ready
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this recipe along with basic knowledge
    of `Boost.Array` library.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱需要基本的C++知识以及对`Boost.Array`库的基本了解。
- en: How to do it...
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `Boost.Algorithm` library has all the new C++11 and C++14 algorithms. Using
    it, you can rewrite the previous example in the following manner:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Algorithm`库具有所有新的C++11和C++14算法。使用它，您可以按照以下方式重写前面的示例：'
- en: '[PRE71]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works...
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you are probably aware, `Boost.Algorithm` has a header file for each algorithm.
    Just include the header file and use the required function.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经知道，`Boost.Algorithm`为每个算法都有一个头文件。只需包含头文件并使用所需的函数。
- en: There's more...
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It''s boring to have a library that just implements algorithms from C++ standard.
    That''s not innovative; that''s not the Boost way! That''s why you can find in
    `Boost.Algorithm`, functions that are not part of C++. Here, for example, is a
    function that converts input into hexadecimal representation:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个仅实现C++标准算法的库是无聊的。那不是创新的；那不是Boost的方式！这就是为什么在`Boost.Algorithm`中，您可以找到不是C++一部分的函数。例如，这里有一个将输入转换为十六进制表示的函数：
- en: '[PRE72]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The preceding code outputs the following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码输出如下：
- en: '[PRE73]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'What''s more interesting, all the functions have additional overloads that
    accept a range as a first parameter instead of two iterators. **Range** is a concept
    from **Ranges TS**. Arrays and containers that have `.begin()` and `.end()` functions
    satisfy the range concept. With that knowledge the previous example could be shortened:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，所有函数都有额外的重载，接受范围作为第一个参数，而不是两个迭代器。**Range**是**Ranges TS**的概念。具有`.begin()`和`.end()`函数的数组和容器满足范围概念。有了这个知识，前面的示例可以被缩短：
- en: '[PRE74]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: C++17 will have searching algorithms from `Boost.Algorithm`. `Boost.Algorithm`
    library will be soon extended with new algorithms and C++20 features like constexpr
    usable algorithms. Keep an eye on that library, as some day, it may get an out-of-the-box
    solution for a problem that you're dealing with.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: C++17将具有来自`Boost.Algorithm`的搜索算法。`Boost.Algorithm`库将很快扩展为具有新算法和C++20功能，如可用的constexpr算法。密切关注该库，因为有一天，它可能会为您正在处理的问题提供现成的解决方案。
- en: See also
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Official documentation for `Boost.Algorithm` contains a full list of functions
    and short descriptions for them at [http://boost.org/libs/algorithm](http://boost.org/libs/algorithm)
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Algorithm`的官方文档包含了所有函数的完整列表以及它们的简短描述，网址为[http://boost.org/libs/algorithm](http://boost.org/libs/algorithm)'
- en: 'Experiment with new algorithms online: [http://apolukhin.github.io/Boost-Cookbook](http://apolukhin.github.io/Boost-Cookbook)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线尝试新算法：[http://apolukhin.github.io/Boost-Cookbook](http://apolukhin.github.io/Boost-Cookbook)
