- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Spawning the Player Projectile
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成玩家投射物
- en: In the previous chapter, you made great progress with the enemy character’s
    AI by creating a behavior tree that would allow the enemy to randomly select points
    from the `BP_AIPoints` actor you created. This gave the `SuperSideScroller` game
    more life as you can now have multiple enemies moving around your game world.
    Additionally, you learned about the different tools available in **Unreal Engine
    5** (**UE5**) that are used together to make AI of various degrees of complexity.
    These tools included the Navigation Mesh, behavior trees, and Blackboards.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你通过创建一个行为树，使敌人能够从你创建的 `BP_AIPoints` 角色中随机选择点，从而在敌人角色的 AI 方面取得了很大的进步。这使得
    `SuperSideScroller` 游戏更加生动，因为你现在可以在游戏世界中拥有多个移动的敌人。此外，你还了解了 **Unreal Engine 5**
    (**UE5**) 中可用的不同工具，这些工具可以组合起来创建不同复杂程度的 AI。这些工具包括导航网格、行为树和黑板。
- en: Now that you have enemies running around your level, you need to allow the player
    to defeat these enemies with the player projectile you started to create at the
    end of the previous chapter. Our goal for this chapter is to use a custom `UAnimNotify`
    class that we will implement within our `Throw` Animation Montage to spawn the
    `Player Projectile`. Additionally, we will add polish elements to the projectile
    such as Particle Systems and Sound Cues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经让敌人开始在关卡中移动，你需要允许玩家使用你在上一章末尾开始创建的玩家投射物击败这些敌人。本章的目标是使用我们将在 `Throw` 动画蒙太奇中实现的自定义
    `UAnimNotify` 类来生成 `Player Projectile`。此外，我们还将为投射物添加润色元素，例如粒子系统和声音提示。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to use the `UAnimNotify` class to spawn the player projectile during the
    `Throw` Animation Montage.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `UAnimNotify` 类在 `Throw` 动画蒙太奇期间生成玩家投射物。
- en: Creating a new `Socket` for the main character skeleton from which the projectile
    will spawn.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为主要角色骨架创建一个新的 `Socket`，投射物将从该 `Socket` 生成。
- en: Learn how to use Particle Systems and Soundcues to add a layer of visual and
    audio polish to the game.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用粒子系统和声音提示为游戏添加视觉和音频润色。
- en: By the end of this chapter, you will be able to play Animation Montages in both
    Blueprints and C++ and know how to spawn objects into the game world using C++
    and the `UWorld` class. These elements of the game will be given audio and visual
    components as an added layer of polish, and your `SuperSideScroller` player character
    will be able to throw projectiles that destroy enemies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够在蓝图和 C++ 中播放动画蒙太奇，并了解如何使用 C++ 和 `UWorld` 类将对象生成到游戏世界中。这些游戏元素将添加音频和视觉组件，作为额外的润色层，你的
    `SuperSideScroller` 玩家角色将能够投掷能够摧毁敌人的投射物。
- en: Technical requirements
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following technical requirements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下技术要求：
- en: Unreal Engine 5 installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal Engine 5 已安装
- en: Visual Studio 2019 installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019 已安装
- en: Unreal Engine 4.27 installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal Engine 4.27 已安装
- en: 'The project for this chapter can be found in the `Chapter14` folder of the
    code bundle for this book, which can be downloaded here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的 `Chapter14` 文件夹中找到，可以在此处下载：
- en: '[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)'
- en: Let’s begin this chapter by learning about `UAnimNotify` class so that you can
    spawn the player projectile during the `Throw` Animation Montage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个章节开始，先了解 `UAnimNotify` 类，这样你就可以在 `Throw` 动画蒙太奇期间生成玩家投射物。
- en: Anim Notifies and Anim Notify States
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Anim Notifies 和 Anim Notify States
- en: When it comes to creating polished and complex animations, there needs to be
    a way for animators and programmers to add custom events within the animation
    that will allow for additional effects, layers, and functionality to occur. The
    solution in UE5 is to use **Anim Notifies** and **Anim Notify States**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到创建精致且复杂的动画时，动画师和程序员需要在动画中添加自定义事件，以便实现额外的效果、层和功能。UE5 的解决方案是使用 **Anim Notifies**
    和 **Anim Notify States**。
- en: 'The main difference between **Anim Notify** and **Anim Notify State** is that
    **Anim Notify State** possesses three distinct events that **Anim Notify** does
    not. These events are **Notify Begin**, **Notify End**, and **Notify Tick**, all
    of which can be used in Blueprints or C++. When it comes to these events, UE5
    secures the following behaviors:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Anim Notify**和**Anim Notify State**之间的主要区别在于**Anim Notify State**拥有三个独特的事件，而**Anim
    Notify**没有。这些事件是**Notify Begin**、**Notify End**和**Notify Tick**，所有这些都可以在蓝图或C++中使用。当涉及到这些事件时，UE5确保以下行为：'
- en: '**Notify State** will always start with **Notify Begin Event**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Notify State**总是从**Notify Begin Event**开始'
- en: '**Notify State** will always finish with **Notify End Event**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Notify State**总是以**Notify End Event**结束'
- en: '**Notify Tick Event** will always take place between the **Notify Begin** and
    **Notify End** events'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Notify Tick Event**总是在**Notify Begin**和**Notify End**事件之间发生'
- en: '`Notify()`, to allow programmers to add functionality to the notify itself.
    It works with the mindset of *fire and forget*, meaning you don’t need to worry
    about what happens at the start, end, or anywhere in-between the `Notify()` event.
    It is due to this simplicity of `SuperSideScroller` game.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notify()`，允许程序员向通知本身添加功能。它采用“发射后不管”的心态，意味着你不需要担心`Notify()`事件开始、结束或中间发生的事情。这正是`SuperSideScroller`游戏简单性的原因。'
- en: 'Before moving on to the following exercise, where you will create a custom
    **Anim Notify** in C++, let’s briefly discuss some examples of existing Anim Notifies
    that UE5 provides by default. A full list of default **Anim Notify** states can
    be seen in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个练习之前，你将在C++中创建一个自定义的**Anim Notify**，让我们简要讨论一些UE5默认提供的现有Anim Notifies的例子。默认**Anim
    Notify**状态的完整列表可以在以下屏幕截图中查看：
- en: '![Figure 14.1 – The full list of default Anim Notifies provided in UE5 ](img/Figure_14.01_B18531.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – UE5提供的默认Anim Notifies的完整列表](img/Figure_14.01_B18531.jpg)'
- en: Figure 14.1 – The full list of default Anim Notifies provided in UE5
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – UE5提供的默认Anim Notifies的完整列表
- en: 'There are two **Anim Notifies** that you will be using later in this chapter:
    **Play Particle Effect** and **Play Sound**. Let’s discuss these two in more detail
    so that you are familiar with them by the time you use them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续内容中，你将使用两个**Anim Notify**：**Play Particle Effect**和**Play Sound**。让我们更详细地讨论这两个，以便你在使用它们时熟悉它们：
- en: '**Play Particle Effect**: The **Play Particle Effect** notify, as its name
    suggests, allows you to spawn and play a Particle System at a certain frame of
    your animation. As shown in the following screenshot, you have options to change
    the **visual effects** (**VFX**) that are being used, such as updating the **Location
    Offset**, **Rotation Offset**, and **Scale** settings of the particle. You can
    even attach the particle to a specified **Socket Name** if you so choose:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Play Particle Effect**：正如其名所示，**Play Particle Effect**通知允许你在动画的某个帧上生成并播放粒子系统。如图所示，你可以更改正在使用的**视觉效果**（**VFX**），例如更新粒子的**位置偏移**、**旋转偏移**和**缩放**设置。如果你选择的话，你甚至可以将粒子附加到指定的**Socket
    Name**：'
- en: '![Figure 14.2 – The Details panel of the Play Particle Effect notify ](img/Figure_14.02_B18531.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 播放粒子效果通知的详细信息面板](img/Figure_14.02_B18531.jpg)'
- en: Figure 14.2 – The Details panel of the Play Particle Effect notify
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 播放粒子效果通知的详细信息面板
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visual effects, or VFX for short, are crucial elements for any game. VFX, in
    UE5, are created using a tool called **Niagara** inside the editor. Niagara has
    been around since Unreal Engine 4 version 4.20, as a free plugin to improve the
    quality and pipeline for how VFX are made. **Cascade**, the previous VFX tool,
    will become deprecated in a later version of UE5\. You can learn more about Niagara
    here: [https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉效果，或简称VFX，是任何游戏的关键元素。在UE5中，使用编辑器内的**Niagara**工具创建VFX。Niagara自Unreal Engine
    4版本4.20以来一直存在，作为一个免费插件，用于提高VFX制作的质量和流程。之前的VFX工具**Cascade**将在UE5的后续版本中弃用。你可以在这里了解更多关于Niagara的信息：[https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml)。
- en: A very common example that’s used in games is to use this type of notify to
    spawn dirt or other effects underneath the player’s feet while they walk or run.
    Having the ability to specify at which frame of the animation these effects spawn
    is very powerful and allows you to create convincing effects for your character.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中常用的一个例子是使用这种类型的通知在玩家行走或跑步时在其脚下生成泥土或其他效果。能够指定这些效果在动画的哪个帧生成是非常强大的，并允许您为角色创建令人信服的效果。
- en: '**Play Sound**: The **Play Sound** notify allows you to play a **Soundcue**
    or **Soundwave** at a certain frame of your animation. As shown in the following
    screenshot, you have options for changing the sound being used, updating its **Volume
    Multiplier** and **Pitch Multiplier** values, and even having the sound follow
    the owner of the sound by attaching it to a specified **Attach Name**:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放声音**：**播放声音** 通知允许您在动画的某个帧播放 **Soundcue** 或 **Soundwave**。如图所示，您可以选择更改正在使用的声音，更新其
    **音量乘数** 和 **音调乘数** 值，甚至可以通过将其附加到指定的 **附加名称** 来使声音跟随声音的所有者：'
- en: '![Figure 14.3 – The Details panel of the Play Sound notify ](img/Figure_14.03_B18531.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 播放声音通知的详细信息面板](img/Figure_14.03_B18531.jpg)'
- en: Figure 14.3 – The Details panel of the Play Sound notify
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 播放声音通知的详细信息面板
- en: Much like the example given for the **Play Particle Effect** notify, the **Play
    Sound** notify can also be commonly used to play the sounds of footsteps while
    the character is moving. By having control of exactly where on the animation timeline
    you can play a sound, it is possible to create believable sound effects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与示例中给出的 **播放粒子效果** 通知类似，**播放声音** 通知也可以常用以在角色移动时播放脚步声。通过精确控制动画时间线上何时播放声音，可以创建逼真的音效。
- en: 'Although you will not be using an **Anim Notify State**, it is still important
    to at least know the options that are available to you by default, as shown in
    the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可能不会使用 **Anim Notify State**，但了解默认情况下可用的选项仍然很重要，如下面的截图所示：
- en: '![Figure 14.4 – The full list of default Anim Notify States provided to you
    in UE5 ](img/Figure_14.04_B18531.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – UE5 提供的默认 Anim Notify States 完整列表](img/Figure_14.04_B18531.jpg)'
- en: Figure 14.4 – The full list of default Anim Notify States provided to you in
    UE5
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – UE5 提供的默认 Anim Notify States 完整列表
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The two Notify states that are not available in Animation Sequences are the
    **Montage Notify Window** and **Disable Root Motion** states, as shown in the
    preceding screenshot. For more information regarding notifies, please refer to
    the following documentation: [docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.xhtml](http://docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.xhtml).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画序列中不可用的两个 Notify 状态是 **蒙太奇通知窗口** 和 **禁用根运动** 状态，如前述截图所示。有关通知的更多信息，请参阅以下文档：[docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.xhtml](http://docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.xhtml)。
- en: Now that you are more familiar with **Anim Notify** and **Anim Notify State**,
    let’s move on to the first exercise, where you will create a custom **Anim Notify**
    in C++ that you will use to spawn the player projectile.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对 **Anim Notify** 和 **Anim Notify State** 更加熟悉了，让我们继续进行第一个练习，您将在其中创建一个自定义的
    **Anim Notify**，并将其用于生成玩家投射物。
- en: Exercise 14.01 – creating a UAnimNotify class
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.01 – 创建 UAnimNotify 类
- en: The main offensive ability that the player character will have in the `SuperSideScroller`
    game is the projectile that the player can throw at enemies. In the previous chapter,
    you set up the framework and base functionality of the projectile, but right now,
    there is no way for the player to use it. To make spawning, or throwing, the projectile
    convincing to the eye, you need to create a custom **Anim Notify** that you will
    then add to the **Throw** Animation Montage. This **Anim Notify** will let the
    player know it’s time to spawn the projectile.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色在 `SuperSideScroller` 游戏中的主要攻击能力是可以向敌人投掷的投射物。在前一章中，您设置了投射物的框架和基本功能，但现在，玩家还没有使用它的方法。为了使生成或投掷投射物的视觉效果更加逼真，您需要创建一个自定义的
    **Anim Notify**，然后将其添加到 **投掷** 动画蒙太奇中。这个 **Anim Notify** 将让玩家知道是时候生成投射物了。
- en: 'Follow these steps to create the new `UAnimNotify` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建新的 `UAnimNotify` 类：
- en: Inside UE5, navigate to the **Tools** option and *left-click* on the **New C++
    Class** option.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 UE5 中，导航到 **工具** 选项，然后 *左键单击* **新建 C++ 类** 选项。
- en: From the `Anim Notify` and *left-click* the **AnimNotify** option. Then, *left-click*
    the **Next** option to name the new class.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**动画通知**中*左键点击***动画通知**选项。然后，*左键点击***下一步**选项来命名新的类。
- en: Name this new class `Anim_ProjectileNotify`. Once it's been named, *left-click*
    the `Anim_ProjectileNotify.h`, and the source file, `Anim_ProjectileNotify.cpp`,
    available to you.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新类命名为`Anim_ProjectileNotify`。一旦命名完成，*左键点击*`Anim_ProjectileNotify.h`，以及可用的源文件`Anim_ProjectileNotify.cpp`。
- en: 'The `UAnimNotify` base class has one function that needs to be implemented
    inside your class:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UAnimNotify`基类有一个需要在你的类中实现的功能：'
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function is called automatically when the notify is hit on the timeline
    it is being used in. By overriding this function, you will be able to add logic
    to the notify. This function also gives you access to both the `Skeletal Mesh`
    component of the owning notify and the Animation Sequence currently being played.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当通知在它被使用的时间轴上被击中时，这个函数会自动被调用。通过覆盖这个函数，你将能够向通知中添加逻辑。这个函数还让你能够访问拥有通知的`Skeletal
    Mesh`组件以及当前正在播放的动画序列。
- en: 'Next, let’s add the override declaration of this function to the header file.
    In the `Anim_ProjectileNotify.h` header file, add the following code underneath
    `GENERATED_BODY()`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将这个函数的覆盖声明添加到头文件中。在`Anim_ProjectileNotify.h`头文件中，在`GENERATED_BODY()`下面添加以下代码：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that you’ve added the function to the header file, it is time to define
    the function inside the `Anim_ProjectileNotify` source file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将函数添加到头文件中，是时候在`Anim_ProjectileNotify`源文件中定义这个函数了。
- en: 'Inside the `Anim_ProjectileNotify.cpp` source file, define the function and
    add a `UE_LOG()` call that prints the text `"Throw Notify"`, as shown in the following
    code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Anim_ProjectileNotify.cpp`源文件中，定义函数并添加一个`UE_LOG()`调用，打印文本`"Throw Notify"`，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For now, you will just use this `UE_LOG()` debugging tool to know that this
    function is being called correctly when you add this notify to the **Throw** Animation
    Montage in the next exercise.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你将只使用这个`UE_LOG()`调试工具来确认当你将这个通知添加到下一个练习中的**投掷**动画蒙太奇时，这个函数被正确调用。
- en: 'In this exercise, you created the groundwork necessary to implement your own
    `Anim Notify` class by adding the following function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你通过添加以下函数创建了实现你自己的`Anim Notify`类所需的基础：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside this function, you are using `UE_LOG()` to print the custom text `"Throw
    Notify"` in the output log so that you know that this notify is working correctly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，你使用`UE_LOG()`在输出日志中打印自定义文本`"Throw Notify"`，以便你知道这个通知正在正确工作。
- en: Later in this chapter, you will update this function so that it calls logic
    that will spawn the player projectile, but first, let’s add the new notify to
    the **Throw** Animation montage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将更新这个函数，使其调用能够生成玩家投射物的逻辑，但首先，让我们将新的通知添加到**投掷**动画蒙太奇中。
- en: Exercise 14.02 – adding the new notify to the Throw Animation Montage
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.02 – 向投掷动画蒙太奇添加新的通知
- en: Now that you have your `Anim_ProjectileNotify` notify, it is time to add it
    to the **Throw** Animation Montage so that it can be of use to you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了`Anim_ProjectileNotify`通知，是时候将它添加到**投掷**动画蒙太奇中，以便你可以使用它。
- en: In this exercise, you will add `Anim_ProjectileNotify` to the timeline of the
    **Throw** Animation Montage at the exact frame of the animation that you’d expect
    the projectile to spawn.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将在动画中你期望投射物生成的确切帧将`Anim_ProjectileNotify`添加到**投掷**动画蒙太奇的时间轴上。
- en: 'Follow these steps to achieve this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Back inside UE5, navigate to the `/MainCharacter/Animation/` directory. Inside
    this directory, *double-click* the `AM_Throw` asset to open the **Animation Montage**
    editor.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE5中，导航到`/MainCharacter/Animation/`目录。在这个目录中，*双击*`AM_Throw`资产以打开**动画蒙太奇**编辑器。
- en: At the very bottom of the **Animation Montage** editor, you will find the timeline
    for the animation. By default, you will observe that the *red-colored bar* will
    be moving along the timeline as the animation plays.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在**动画蒙太奇编辑器**的底部，你可以找到动画的时间轴。默认情况下，你会看到当动画播放时，红色的条形会沿着时间轴移动。
- en: '*Left-click* this red bar and manually move it to the 22nd frame, as close
    as you can, as shown in the following screenshot:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击*这个红色条形，并将其手动移动到第22帧，尽可能接近，如图下面的屏幕截图所示：'
- en: '![Figure 14.5 – The red-colored bar allows you to manually position notifies
    anywhere on the timeline ](img/Figure_14.05_B18531.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 红色条形允许你将通知手动放置在时间轴上的任何位置](img/Figure_14.05_B18531.jpg)'
- en: Figure 14.5 – The red-colored bar allows you to manually position notifies anywhere
    on the timeline
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 红色条允许你手动在时间轴上定位通知
- en: 'The 22nd frame of the **Throw** animation is the exact moment in the throw
    that you would expect a projectile to spawn and be thrown by the player. The following
    screenshot shows the frame of the **Throw** animation, as seen inside the editor
    within **Persona**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**投掷**动画的第22帧是投掷动作中你期望投射物生成并被玩家抛出的确切时刻。以下截图显示了**投掷**动画的帧，如图所示在**Persona**编辑器内部：'
- en: '![Figure 14.6 – The exact moment the player projectile should spawn ](img/Figure_14.06_B18531.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 玩家投射物应该生成的确切时刻](img/Figure_14.06_B18531.jpg)'
- en: Figure 14.6 – The exact moment the player projectile should spawn
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 玩家投射物应该生成的确切时刻
- en: Now that you know the position on the timeline that the notify should be played,
    you can *right-click* on the thin red line within the **Notifies** timeline.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经知道了通知应该在时间轴上的位置，你可以在**Notifies**时间轴内的细红线处**右键单击**。
- en: A popup will appear where you can add a **Notify** or a **Notify State**. In
    some cases, the **Notifies** timeline may be collapsed and hard to find; simply
    left-click on the word **Notifies** to toggle between collapsed and expanded.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将会出现一个弹出窗口，你可以添加**通知**或**通知状态**。在某些情况下，**Notifies**时间轴可能被折叠且难以找到；只需左键单击单词**Notifies**来在折叠和展开之间切换。
- en: Select **Add Notify** and, from the options provided, find and select **Anim
    Projectile Notify**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加通知**，从提供的选项中找到并选择**Anim Projectile Notify**。
- en: 'After adding **Anim Projectile Notify** to the **Notifies** timeline, you will
    see the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Notifies**时间轴上添加**Anim Projectile Notify**后，你会看到以下内容：
- en: '![Figure 14.7 – Anim_ProjectileNotify successfully added to the Throw Animation
    Montage ](img/Figure_14.07_B18531.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7 – Anim_ProjectileNotify成功添加到投掷动画蒙太奇](img/Figure_14.07_B18531.jpg)'
- en: Figure 14.7 – Anim_ProjectileNotify successfully added to the Throw Animation
    Montage
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 – Anim_ProjectileNotify成功添加到投掷动画蒙太奇
- en: With the `Anim_ProjectileNotify` notify in place on the **Throw** Animation
    Montage timeline, save the montage.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**投掷**动画蒙太奇时间轴上放置了`Anim_ProjectileNotify`通知后，保存蒙太奇。
- en: If the **Output Log** window is not visible, please re-enable the window by
    navigating to the **Window** option and hovering over it to find the option for
    **Output Log**. Then, *left-click* to enable it.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**输出日志**窗口不可见，请通过导航到**窗口**选项并悬停在它上面找到**输出日志**选项来重新启用窗口。然后，**左键单击**以启用它。
- en: Now, use `PIE` and, once in-game, use the *left mouse button* to start playing
    the **Throw** montage.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`PIE`，一旦进入游戏，使用**左鼠标按钮**开始播放**投掷**蒙太奇。
- en: At the point in the animation where you added the notify, you will now see the
    `Throw Notify` debugging log text appear in the output log.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画中添加通知的点上，你现在将在输出日志中看到`投掷通知`调试日志文本出现。
- en: As you may recall from [*Chapter 12*](B18531_12.xhtml#_idTextAnchor247), *Animation
    Blending and Montages*, you added the `Play Montage` function to the player character
    Blueprint – that is, `BP_SuperSideScroller_MainCharacter`. For the sake of learning
    C++ in the context of UE5, you will be moving this logic from Blueprint to C++
    in the upcoming exercises. This is so that we don’t rely too heavily on Blueprint
    scripts for the base behavior of the player character.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从[*第12章*](B18531_12.xhtml#_idTextAnchor247)中回忆起的，*动画混合和蒙太奇*，你将`Play Montage`函数添加到玩家角色蓝图——即`BP_SuperSideScroller_MainCharacter`。为了在UE5的上下文中学习C++，你将在接下来的练习中将此逻辑从蓝图移动到C++。这样做是为了我们不要过度依赖蓝图脚本来实现玩家角色的基本行为。
- en: With this exercise complete, you have successfully added your custom `Anim Notify`
    class, `Anim_ProjectileNotify`, to the `EnhancedInputAction` event, `ThrowProjectile`,
    is called when using the *left mouse button*. Before making the transition from
    playing the **Throw** Animation Montage in Blueprints to playing it in C++, let’s
    discuss playing Animation Montages some more.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，你已经成功将自定义的`Anim Notify`类，`Anim_ProjectileNotify`，添加到`EnhancedInputAction`事件中，当使用**左鼠标按钮**时调用`ThrowProjectile`。在从蓝图中的**投掷**动画蒙太奇切换到C++播放之前，让我们再讨论一下播放动画蒙太奇。
- en: Playing Animation Montages
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放动画蒙太奇
- en: As you learned in [*Chapter 12*](B18531_12.xhtml#_idTextAnchor247), *Animation
    Blending and Montages*, these assets are useful for allowing animators to combine
    individual Animation Sequences into one complete montage. By splitting the montage
    into unique sections and adding notifies for particles and sound, animators and
    animation programmers can make complex sets of montages that handle all the different
    aspects of the animation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[*第12章*](B18531_12.xhtml#_idTextAnchor247)中学习的，*动画混合和蒙太奇*，这些资源对于允许动画师将单个动画序列组合成一个完整的蒙太奇非常有用。通过将蒙太奇分割成独特的部分，并为粒子效果和声音添加通知，动画师和动画程序员可以制作出处理动画所有不同方面的复杂蒙太奇集。
- en: But once the Animation Montage is ready, how do we play it on a character? You
    are already familiar with the first method, which is via Blueprints.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但一旦动画蒙太奇准备就绪，我们如何在角色上播放它？您已经熟悉第一种方法，即通过蓝图（Blueprints）。
- en: Playing Animation Montages in Blueprints
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在蓝图（Blueprints）中播放动画蒙太奇
- en: 'In Blueprints, the **Play Montage** function can be used, as shown in the following
    screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图（Blueprints）中，可以使用**Play Montage**功能，如下面的截图所示：
- en: '![Figure 14.8 – The Play Montage function in Blueprints ](img/Figure_14.08_B18531.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – 蓝图中的播放蒙太奇功能](img/Figure_14.08_B18531.jpg)'
- en: Figure 14.8 – The Play Montage function in Blueprints
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 蓝图中的播放蒙太奇功能
- en: You have already used the `Play Montage` function to play the `AM_Throw` Animation
    Montage. This function requires the **Skeletal Mesh** component that the montage
    must be played on, and it requires the Animation Montage to play.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用`Play Montage`函数播放了`AM_Throw`动画蒙太奇。此函数需要蒙太奇必须播放的**骨骼网格**组件，并且需要动画蒙太奇进行播放。
- en: 'The remaining parameters are optional, depending on how your montage will work.
    Let’s have a quick look at these parameters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的参数是可选的，具体取决于您的蒙太奇如何工作。让我们快速看一下这些参数：
- en: '**Play Rate**: The **Play Rate** parameter allows you to increase or decrease
    the playback speed of the Animation Montage. For faster playback, you would increase
    this value; otherwise, you would decrease it.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放速率**: **Play Rate**参数允许您增加或减少动画蒙太奇的播放速度。为了加快播放，您会增加此值；否则，您会减少它。'
- en: '`1.0f` position instead of at `0.0f`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`1.0f`位置而不是`0.0f`。
- en: '**Starting Section**: The **Starting Section** parameter allows you to tell
    the Animation Montage to start at a specific section. Depending on how your montage
    is set up, you could have multiple sections created for different parts of the
    montage. For example, a shotgun weapon-reloading Animation Montage would include
    a section for the initial movement for reloading, a looped section for the actual
    bullet reload, and a final section for re-equipping the weapon so that it is ready
    to fire again.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起始部分**: **Starting Section**参数允许您告诉动画蒙太奇从特定部分开始。根据您的蒙太奇设置，您可以为蒙太奇的各个部分创建多个部分。例如，霰弹枪装弹动画蒙太奇将包括一个用于装弹初始动作的部分，一个用于实际子弹装弹的循环部分，以及一个用于重新装备武器以便再次开火的部分。'
- en: 'When it comes to the outputs of the **Play Montage** function, you have a few
    different options:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到**Play Montage**函数的输出时，您有几个不同的选项：
- en: '**On Completed**: The **On Completed** output is called when the Animation
    Montage has finished playing and has been fully blended out.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成时**: 当动画蒙太奇播放完成并完全混合退出时，会调用**On Completed**输出。'
- en: '**On Blend Out**: The **On Blend Out** output is called when the Animation
    Montage begins to blend out. This can occur during **Blend Out Trigger Time**,
    or if the montage ends prematurely.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于混合退出**: 当动画蒙太奇开始混合退出时，会调用**On Blend Out**输出。这可以在**混合退出触发时间**期间发生，或者如果蒙太奇提前结束。'
- en: '**On Interrupted**: The **On Interrupted** output is called when the montage
    begins to blend out due to it being interrupted by another montage that is trying
    to play on the same skeleton.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断时**: 当蒙太奇由于被另一个尝试在相同骨架上播放的蒙太奇中断而开始混合退出时，会调用**On Interrupted**输出。'
- en: '**On Notify Begin** and **On Notify End**: Both the **On Notify Begin** and
    **On Notify End** outputs are called if you are using the **Montage Notify** option
    under the **Notifies** category in the Animation Montage. The name that’s given
    to **Montage Notify** is returned via the **Notify Name** parameter.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知开始**和**通知结束**: 如果您在动画蒙太奇的**Notifies**类别下使用**Montage Notify**选项，则**On Notify
    Begin**和**On Notify End**输出都会被调用。返回的**Montage Notify**名称通过**Notify Name**参数给出。'
- en: Now that we have a better understanding of the Blueprint implementation of the
    **Play Montage** function, let’s take a look at how to play animations in C++.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对**播放蒙太奇**函数的蓝图实现有了更好的理解，让我们看看如何在C++中播放动画。
- en: Playing Animation Montages in C++
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C++中播放动画蒙太奇
- en: On the C++ side, there is only one thing you need to know about, and that is
    the `UAnimInstance::Montage_Play()` function. This function requires the Animation
    Montage to play, the play rate in which to play back the montage, a value of the
    `EMontagePlayReturnType` type, a `float` value for determining the start position
    to play the montage, and a `Boolean` value for determining whether playing this
    montage should stop or interrupt all montages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++方面，你只需要了解一件事，那就是`UAnimInstance::Montage_Play()`函数。这个函数需要动画蒙太奇来播放，播放速率，一个`EMontagePlayReturnType`类型的值，一个用于确定播放蒙太奇起始位置的`float`值，以及一个用于确定播放此蒙太奇是否停止或中断所有蒙太奇的布尔值。
- en: 'Although you will not be changing the default parameter of `EMontagePlayReturnType`,
    which is `EMontagePlayReturnType::MontageLength`, it is still important to know
    the two values that exist for this enumerator:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不会更改`EMontagePlayReturnType`的默认参数，该参数为`EMontagePlayReturnType::MontageLength`，但了解这个枚举器存在的两个值仍然很重要：
- en: '`Montage` `Length`: The `Montage` `Length` value returns the length of the
    montage itself, in seconds.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Montage Length`：`Montage Length`值返回蒙太奇本身的长度，以秒为单位。'
- en: '`Duration`: The `Duration` value returns the play duration of the montage,
    which is equal to the length of the montage, divided by the play rate.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duration`：`Duration`值返回蒙太奇的播放时长，等于蒙太奇长度除以播放速率。'
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more details regarding the `UAnimMontage` class, please refer to the following
    documentation: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/UAnimMontage/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/UAnimMontage/index.xhtml).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`UAnimMontage`类的更多详细信息，请参阅以下文档：[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/UAnimMontage/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/UAnimMontage/index.xhtml)。
- en: You will learn more about the C++ implementation of playing an Animation Montage
    in the next exercise.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一项练习中了解更多关于在C++中播放动画蒙太奇的实施方法。
- en: Exercise 14.03 – playing the Throw animation in C++
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.03 – 在C++中播放投掷动画
- en: Now that you have a better understanding of how to play Animation Montages in
    UE5, both via Blueprints and C++, it is time to migrate the logic for playing
    the **Throw** Animation Montage from Blueprints to C++. The reason behind this
    change is that the Blueprint logic was put into place as a placeholder method
    so that you could preview the **Throw** montage. This book is a more heavily focused
    C++ guide to game development, and as such, it is important to learn how to implement
    this logic in code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对如何在UE5中播放动画蒙太奇（Animation Montages）有了更好的理解，无论是通过蓝图还是C++，现在是时候将播放**投掷**动画蒙太奇（Throw
    Animation Montage）的逻辑从蓝图迁移到C++了。这种变化背后的原因是，蓝图逻辑被放置为一个占位符方法，以便你可以预览**投掷**蒙太奇。这本书更侧重于C++游戏开发指南，因此学习如何在代码中实现这种逻辑是很重要的。
- en: Let’s begin by removing the logic from Blueprints, and then move on to recreating
    the logic in C++ inside the player character class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从蓝图（Blueprints）中移除逻辑，然后继续在玩家角色类（player character class）内部用C++重新创建逻辑。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: Navigate to the player character Blueprint, `BP_SuperSideScroller_MainCharacter`,
    which can be found in the `/MainCharacter/Blueprints/` directory. *Double-click*
    this asset to open it.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到玩家角色蓝图`BP_SuperSideScroller_MainCharacter`，它位于`/MainCharacter/Blueprints/`目录中。*双击*此资产以打开它。
- en: 'Inside this Blueprint, you will find the **EnhancedInputAction IA_Throw** event
    and the **Play Montage** function that you created to preview the **Throw** Animation
    Montage, as shown in the following screenshot. Delete this logic and then recompile
    and save the player character Blueprint:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个蓝图内部，你会找到**增强输入动作 IA_Throw**事件和**播放蒙太奇**函数，这些是你创建来预览**投掷**动画蒙太奇的，如下截图所示。删除这个逻辑，然后重新编译并保存玩家角色蓝图：
- en: '![Figure 14.9 – You no longer need this placeholder logic inside the player
    character Blueprint ](img/Figure_14.09_B18531.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9 – 你不再需要在玩家角色蓝图内使用这个占位符逻辑](img/Figure_14.09_B18531.jpg)'
- en: Figure 14.9 – You no longer need this placeholder logic inside the player character
    Blueprint
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – 你不再需要在玩家角色蓝图内使用这个占位符逻辑
- en: Now, use `PIE` and attempt to throw with the player character by using the *left
    mouse button*. You will observe that the player character no longer plays the
    **Throw** Animation Montage. Let’s fix this by adding the required logic in C++.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `PIE` 并尝试使用玩家角色通过使用 *左鼠标按钮* 来投掷。您将观察到玩家角色不再播放 **投掷** 动画蒙太奇。让我们通过在 C++
    中添加所需的逻辑来修复这个问题。
- en: Open the header file for the player character in Visual Studio – that is, `SuperSideScroller_Player.h`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开玩家角色的头文件——即 `SuperSideScroller_Player.h`。
- en: 'The first thing you need to do is create a new variable for the player character
    that will be used for the `Private` access modifier:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是为玩家角色创建一个新的变量，该变量将用于 `Private` 访问修饰符：
- en: '[PRE4]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you have a variable that will represent the `SuperSideScroller_Player.cpp`
    file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个将代表 `SuperSideScroller_Player.cpp` 文件的变量。
- en: 'Before you can make the call to `UAnimInstance::Montage_Play()`, you need to
    add the following `include` directory to the existing list at the top of the source
    file to have access to this function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `UAnimInstance::Montage_Play()` 之前，您需要将以下 `include` 目录添加到源文件顶部现有的列表中，以便访问此函数：
- en: '[PRE5]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we know from [*Chapter 9*](B18531_09.xhtml#_idTextAnchor183), *Adding Audio-Visual
    Elements*, the player character already has a function called `ThrowProjectile`
    that is called whenever the *left mouse button* is pressed. As a reminder, this
    is where the binding occurs in C++:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从 [*第 9 章*](B18531_09.xhtml#_idTextAnchor183) 中所知，*添加音视频元素*，玩家角色已经有一个名为
    `ThrowProjectile` 的函数，每当 *左鼠标按钮* 被按下时都会调用。作为提醒，这是在 C++ 中绑定的地方：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update `ThrowProjectile` so that it plays `ThrowMontage`, which you set up
    earlier in this exercise. Add the following code to the `ThrowProjectile()` function.
    Then, we can discuss what is happening here:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `ThrowProjectile` 以播放您在此练习中之前设置的 `ThrowMontage`。将以下代码添加到 `ThrowProjectile()`
    函数中。然后，我们可以讨论这里发生的事情：
- en: '[PRE7]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line is checking if `ThrowMontage` is valid; if we don’t have a valid
    Animation Montage assigned, there is no point in continuing the logic. It can
    also be dangerous to use a `NULL` object in further function calls as it could
    result in a crash. Next, we are declaring a new Boolean variable, called `bIsMontagePlaying`,
    that determines whether `ThrowMontage` is already playing on the player character’s
    skeletal mesh. This check is made because the **Throw** Animation Montage should
    not be played while it is already playing; this will cause the animation to break
    if the player repeatedly presses the *left mouse button*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是检查 `ThrowMontage` 是否有效；如果没有分配有效的动画蒙太奇，就没有继续逻辑的必要。在后续函数调用中使用 `NULL` 对象也可能很危险，因为它可能导致崩溃。接下来，我们声明一个新的布尔变量，称为
    `bIsMontagePlaying`，它确定 `ThrowMontage` 是否已经在玩家角色的骨骼网格上播放。进行此检查是因为 **投掷** 动画蒙太奇不应该在已经播放时播放；如果玩家反复按下
    *左鼠标按钮*，这将导致动画中断。
- en: So long as the preceding conditions are met, it is safe to move on and play
    the Animation Montage.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 只要满足前面的条件，就可以安全地继续并播放动画蒙太奇。
- en: Inside the `If` statement, you are telling the player’s skeletal mesh to play
    `ThrowMontage` with a play rate of `1.0f`. This value is used so that the Animation
    Montage plays back at the speed it is intended to. Values larger than `1.0f` will
    make the montage play back faster, while values lower than `1.0f` will make the
    montage play back slower. The other parameters that you learned about, such as
    the start position or the `EMontagePlayReturnType` parameter, can be left at their
    defaults. Back inside the UE5 editor, perform a recompile of the code, as you
    have done in the past.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `If` 语句内部，您正在告诉玩家的骨骼网格播放 `ThrowMontage`，播放速率为 `1.0f`。此值用于确保动画蒙太奇以预期速度回放。大于
    `1.0f` 的值将使蒙太奇回放速度加快，而小于 `1.0f` 的值将使蒙太奇回放速度减慢。您之前了解的其他参数，例如起始位置或 `EMontagePlayReturnType`
    参数，可以保留其默认值。回到 UE5 编辑器中，像过去一样重新编译代码。
- en: After the code recompiles successfully, navigate back to the player character
    Blueprint, `BP_SuperSideScroller_MainCharacter`, which can be found in the `/MainCharacter/Blueprints/`
    directory. *Double-click* this asset to open it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码成功重新编译后，导航回玩家角色蓝图，`BP_SuperSideScroller_MainCharacter`，它位于 `/MainCharacter/Blueprints/`
    目录下。*双击* 此资产以打开它。
- en: In the `Throw Montage` parameter that you added.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您添加的 `Throw Montage` 参数中。
- en: '*Left-click* on the drop-down menu for the `Throw Montage` parameter to find
    the `AM_Throw` montage. *Left-click* again on the `AM_Throw` montage to select
    it for this parameter. Please refer to the following screenshot to see how the
    variable should be set up:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击*`投掷蒙太奇`参数的下拉菜单以找到`AM_Throw`蒙太奇。*再次左键点击*`AM_Throw`蒙太奇以选择此参数。请参考以下截图以了解变量应该如何设置：'
- en: '![Figure 14.10 – The Throw montage has been assigned the AM_Throw montage ](img/Figure_14.10_B18531.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10 – 投掷蒙太奇已分配给 AM_Throw 蒙太奇](img/Figure_14.10_B18531.jpg)'
- en: Figure 14.10 – The Throw montage has been assigned the AM_Throw montage
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – 投掷蒙太奇已分配给 AM_Throw 蒙太奇
- en: 'Recompile and save the player character Blueprint. Then, use `PIE` to spawn
    the player character and use the *left mouse button* to play `Throw Montage`.
    The following screenshot shows this in action:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译并保存玩家角色蓝图。然后，使用`PIE`生成玩家角色，并使用*左鼠标按钮*播放`投掷蒙太奇`。以下截图显示了这一过程：
- en: '![Figure 14.11 – The player character is now able to perform the Throw animation
    again ](img/Figure_14.11_B18531.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11 – 玩家角色现在能够再次执行投掷动画](img/Figure_14.11_B18531.jpg)'
- en: Figure 14.11 – The player character is now able to perform the Throw animation
    again
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 – 玩家角色现在能够再次执行投掷动画
- en: By completing this exercise, you have learned how to add an `Animation Montage`
    parameter to the player character, as well as how to play the montage in C++.
    In addition to playing the `Throw` input and causing the animation to break or
    not play entirely.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经学会了如何向玩家角色添加`Animation Montage`参数，以及如何在C++中播放蒙太奇。此外，还包括播放`Throw`输入并导致动画中断或完全无法播放。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Try setting the play rate of `Animation Montage` from `1.0f` to `2.0f` and recompile
    the code. Observe how increasing the play rate of the animation affects how the
    animation looks and feels for the player.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将`Animation Montage`的播放速率从`1.0f`调整为`2.0f`并重新编译代码。观察增加动画播放速率如何影响玩家对动画的外观和感觉。
- en: Before moving on to spawning the player projectile, let’s set up the `Socket`
    location in the player character’s **Skeleton** so that the projectile can spawn
    from the *player’s hand* during the **Throw** animation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续生成玩家投射物之前，让我们在玩家角色的**骨骼**中设置`Socket`位置，以便在**投掷**动画期间从**玩家的手**生成投射物。
- en: Exercise 14.04 – creating the projectile spawn socket
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.04 – 创建投射物生成Socket
- en: To spawn the player projectile, you need to determine the **Transform** properties
    in which the projectile will spawn while primarily focusing on **Location** and
    **Rotation**, rather than **Scale**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成玩家投射物，你需要确定投射物将生成的**变换**属性，主要关注**位置**和**旋转**，而不是**缩放**。
- en: In this exercise, you will create a new **Socket** on the player character’s
    **Skeleton** that you can then reference in code to obtain the transform from
    which to spawn the projectile.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将在玩家角色的**骨骼**上创建一个新的**Socket**，然后你可以在代码中引用它以获取生成投射物的变换。
- en: 'Let’s get started:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Inside UE5, navigate to the `/MainCharacter/Mesh/` directory.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE5内部，导航到`/MainCharacter/Mesh/`目录。
- en: In this directory, find the `MainCharacter_Skeleton.uasset`. *Double-click*
    to open this **Skeleton**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录下找到`MainCharacter_Skeleton.uasset`。*双击*打开此**骨骼**。
- en: To determine the best position for where the projectile should spawn, we need
    to add the **Throw** Animation Montage as the preview animation for the skeleton.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定投射物应该生成的最佳位置，我们需要将**投掷**动画蒙太奇作为骨骼的预览动画添加。
- en: In the `Preview Controller` parameter and select the **Use Specific Animation**
    option.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Preview Controller`参数中选择**使用特定动画**选项。
- en: Next, *left-click* on the drop-down menu to find and select the **AM_Throw**
    Animation Montage from the list of available animations.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*左键点击*下拉菜单以找到并选择列表中可用的**AM_Throw**动画蒙太奇。
- en: 'Now, the player character’s **Skeleton** will start previewing the **Throw**
    Animation Montage, as shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家角色的**骨骼**将开始预览**投掷**动画蒙太奇，如下面的截图所示：
- en: '![Figure 14.12 – The player character previewing the Throw Animation Montage
    ](img/Figure_14.12_B18531.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12 – 玩家角色预览投掷动画蒙太奇](img/Figure_14.12_B18531.jpg)'
- en: Figure 14.12 – The player character previewing the Throw Animation Montage
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – 玩家角色预览投掷动画蒙太奇
- en: As you may recall from *Exercise 14.02 – adding the notify to the Throw montage*,
    you added `Anim_ProjectileNotify` at the 22nd frame of the **Throw** animation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的，从 *练习 14.02 – 向抛掷蒙太奇添加通知* 中，你在抛掷动画的第 22 帧添加了 `Anim_ProjectileNotify`。
- en: 'Using the timeline at the bottom of the **Skeleton** editor, move the red bar
    to as close to the 22nd frame as you can. Please refer to the following screenshot:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **骨骼** 编辑器底部的时间轴，将红色条移动到尽可能接近第 22 帧。请参考以下截图：
- en: '![Figure 14.13 – The same 22nd frame in which you added Anim_ProjectileNotify
    earlier ](img/Figure_14.13_B18531.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13 – 你之前添加 Anim_ProjectileNotify 的相同第 22 帧](img/Figure_14.13_B18531.jpg)'
- en: Figure 14.13 – The same 22nd frame in which you added Anim_ProjectileNotify
    earlier
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13 – 你之前添加 Anim_ProjectileNotify 的相同第 22 帧
- en: 'At the 22nd frame of the **Throw** animation, the player character should look
    as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在抛掷动画的第 22 帧时，玩家角色应该看起来如下：
- en: '![Figure 14.14 – The character’s hand in position to release a projectile ](img/Figure_14.14_B18531.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.14 – 角色手部处于释放投射物的位置](img/Figure_14.14_B18531.jpg)'
- en: Figure 14.14 – The character’s hand in position to release a projectile
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14 – 角色手部处于释放投射物的位置
- en: As shown in the preceding screenshot, at the 22nd frame of the **Throw** Animation
    Montage, the character’s hand is in position to release a projectile.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，在抛掷动画蒙太奇的第 22 帧时，角色的手处于释放投射物的位置。
- en: 'As you can see, the player character will be throwing the projectile from their
    *right hand*, so the new `Socket` should be attached to it. Let’s take a look
    at the skeletal hierarchy of the player character, as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，玩家角色将从他们的*右手*抛出投射物，因此新的 `Socket` 应该连接到它。让我们看一下玩家角色的骨骼层次结构，如下面的截图所示：
- en: '![Figure 14.15 – The RightHand bone within the hierarchy of the player character’s
    skeleton ](img/Figure_14.15_B18531.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.15 – 玩家角色骨骼层次结构中的右手骨](img/Figure_14.15_B18531.jpg)'
- en: Figure 14.15 – The RightHand bone within the hierarchy of the player character’s
    skeleton
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15 – 玩家角色骨骼层次结构中的右手骨
- en: From the skeletal hierarchy, find the **RightHand** bone. This can be found
    underneath the **RightShoulder** bone hierarchy structure.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从骨骼层次结构中找到 **右手** 骨。这可以在 **右肩** 骨层次结构结构下找到。
- en: '*Right-click* on the **RightHand** bone and *left-click* the **Add Socket**
    option from the list of options that appears. Name this socket **ProjectileSocket**.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键点击* **右手** 骨，并从出现的选项列表中选择 *添加 Socket*。将此 Socket 命名为 **ProjectileSocket**。'
- en: Also, when adding a new `Socket`, the hierarchy of the entire **RightHand**
    will expand and the new socket will appear at the bottom.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当添加一个新的 `Socket` 时，整个 **右手** 的层次结构将展开，新的 socket 将出现在底部。
- en: 'With `Socket` at the following location:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下位置有 `Socket`：
- en: '[PRE8]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final result should look as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该如下所示：
- en: '![Figure 14.16 – The final position of ProjectileSocket at the 22nd frame of
    the Throw animation in world space ](img/Figure_14.16_B18531.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.16 – 在世界空间中抛掷动画的第 22 帧时 ProjectileSocket 的最终位置](img/Figure_14.16_B18531.jpg)'
- en: Figure 14.16 – The final position of ProjectileSocket at the 22nd frame of the
    Throw animation in world space
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16 – 在世界空间中抛掷动画的第 22 帧时 ProjectileSocket 的最终位置
- en: If your gizmo looks a bit different, that is because the preceding screenshot
    shows the socket location in world space, not local space.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Gizmo 看起来有点不同，那是因为前述截图显示的是 Socket 位置在世界空间中，而不是局部空间中。
- en: Now that `MainCharacter_Skeleton` asset.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`MainCharacter_Skeleton` 资产。
- en: With this exercise complete, you now know the location that the player projectile
    will spawn from. Since you used the `Anim_ProjectileNotify` will fire.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你现在知道了玩家投射物将从中生成的位置。由于你使用了 `Anim_ProjectileNotify` 将会触发。
- en: Now, let’s spawn the player projectile in C++.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 C++ 中生成玩家投射物。
- en: Exercise 14.05 – preparing the SpawnProjectile() Function
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.05 – 准备 SpawnProjectile() 函数
- en: Now that you have **ProjectileSocket** in place and there is a location from
    which to spawn the player projectile, let’s add the code necessary to spawn the
    player projectile.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了**ProjectileSocket**，并且有一个位置可以用来生成玩家投射物，让我们添加生成玩家投射物所需的代码。
- en: By the end of this exercise, you will have the function ready to spawn the projectile
    and it will be ready to call from the `Anim_ProjectileNotify` class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个练习结束时，你将有一个准备好的函数来生成投射物，并且它将可以从 `Anim_ProjectileNotify` 类中调用。
- en: 'Follow these steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: From Visual Studio, navigate to the `SuperSideScroller_Player.h` header file.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Visual Studio 中，导航到 `SuperSideScroller_Player.h` 头文件。
- en: 'You need a class reference variable for the `PlayerProjectile` class. You can
    do this using the `TsubclassOf` variable template class type. Add the following
    code to the header file, under the `Private` access modifier:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要一个 `PlayerProjectile` 类的类引用变量。您可以使用 `TsubclassOf` 变量模板类类型来完成此操作。将以下代码添加到头文件中，在
    `Private` 访问修饰符下：
- en: '[PRE9]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that you have the variable ready, it is time to declare the function you
    will use to spawn the projectile.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量已经准备好了，是时候声明您将用于生成项目的函数了。
- en: 'Add the following function declaration under the declaration of the void `ThrowProjectile()`
    function and the `Public` access modifier:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `void ThrowProjectile()` 函数和 `Public` 访问修饰符的声明下添加以下函数声明：
- en: '[PRE10]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Before preparing the definition of the `SpawnProjectile()` function, add the
    following `include` directories to the list of includes in the `SuperSideScroller_Player.cpp`
    source file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在准备 `SpawnProjectile()` 函数的定义之前，将以下 `include` 目录添加到 `SuperSideScroller_Player.cpp`
    源文件中的包含列表中：
- en: '[PRE11]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You need to include `PlayerProjectile.h` because it is required to reference
    the collision component of the projectile class. Next, you must use the `Engine/World.h`
    include to use the `SpawnActor()` function and access the `FActorSpawnParameters`
    struct. Lastly, you need to use the `Components/SphereComponent.h` include to
    update the collision component of the player projectile so that it will ignore
    the player.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要包含 `PlayerProjectile.h`，因为需要引用项目类中的碰撞组件。接下来，您必须使用 `Engine/World.h` 包含来使用
    `SpawnActor()` 函数和访问 `FActorSpawnParameters` 结构体。最后，您需要使用 `Components/SphereComponent.h`
    包含来更新玩家项目的碰撞组件，以便它将忽略玩家。
- en: 'Next, create the definition of the `SpawnProjectile()` function at the bottom
    of the `SuperSideScroller_Player.cpp` source file, as shown here:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `SuperSideScroller_Player.cpp` 源文件的底部创建 `SpawnProjectile()` 函数的定义，如下所示：
- en: '[PRE12]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first thing this function needs to do is check whether the `PlayerProjectile`
    class variable is valid. If this object is not valid, there is no point in continuing
    to try and spawn it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数需要做的第一件事是检查 `PlayerProjectile` 类变量是否有效。如果此对象无效，就没有必要继续尝试生成它。
- en: 'Update the `SpawnProjectile()` function so that it looks as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `SpawnProjectile()` 函数，使其看起来如下：
- en: '[PRE13]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if the `PlayerProjectile` object is valid, you’ll want to obtain the `UWorld`
    object that the player currently exists in and ensure that this world is valid
    before continuing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 `PlayerProjectile` 对象有效，您将想要获取玩家当前存在的 `UWorld` 对象，并在继续之前确保该世界有效。
- en: 'Update the `SpawnProjectile()` function to the following:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `SpawnProjectile()` 函数，如下所示：
- en: '[PRE14]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, you have made safety checks to ensure that both `PlayerProjectile`
    and `UWorld` are valid, so now, it is safe to attempt to spawn the projectile.
    The first thing you must do is declare a new variable of the `FactorSpawnParameters`
    type and assign the player as the owner.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您已经进行了安全检查，以确保 `PlayerProjectile` 和 `UWorld` 都有效，因此现在可以安全地尝试生成项目。您必须做的第一件事是声明一个新的
    `FActorSpawnParameters` 类型的变量，并将玩家作为所有者分配给它。
- en: 'Add the following code within the most recent `if` statement so that the `SpawnProjectile()`
    function looks like this:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最近的 `if` 语句中添加以下代码，以便 `SpawnProjectile()` 函数看起来如下：
- en: '[PRE15]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you learned previously, the `SpawnActor()` function call from the `UWorld`
    object will require the `FActorSpawnParameters` struct as part of the spawned
    object’s initialization. In the case of the player projectile, you can use the
    `this` keyword as a reference to the player character class for the owner of the
    projectile.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所学的，从 `UWorld` 对象调用 `SpawnActor()` 函数需要 `FActorSpawnParameters` 结构体作为生成对象初始化的一部分。在玩家项目的例子中，您可以使用
    `this` 关键字作为项目所有者玩家角色类的引用。
- en: 'Next, you need to handle the `Location` and `Rotation` parameters of the `SpawnActor()`
    function. Add the following lines under the latest line – that is, `SpawnParams.Owner
    = this`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要处理 `SpawnActor()` 函数的 `Location` 和 `Rotation` 参数。在最新的行（即 `SpawnParams.Owner
    = this`）下添加以下行：
- en: '[PRE16]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the first line, you declare a new `FVector` variable called `SpawnLocation`.
    This vector uses the `Socket` location of the `ProjectileSocket` socket that you
    created in the previous exercise. The `Skeletal Mesh` component returned from
    the `GetMesh()` function contains a function called `GetSocketLocation()` that
    will return the location of the socket with the `FName` property that is passed
    in – in this case, `ProjectileSocket`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，你声明了一个新的`FVector`变量，名为`SpawnLocation`。这个向量使用了你在上一个练习中创建的`ProjectileSocket`插座的`Socket`位置。从`GetMesh()`函数返回的`Skeletal
    Mesh`组件包含一个名为`GetSocketLocation()`的函数，该函数将返回具有传入的`FName`属性的插座位置——在这种情况下，`ProjectileSocket`。
- en: In the second line, you are declaring a new `FRotator` variable called `Rotation`.
    This value is set to the player’s forward vector and converted into a `Rotator`
    container. This will ensure that the rotation – or in other words, the direction
    in which the player projectile will spawn – will be in front of the player, and
    it will move away from the player.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，你声明了一个新的`FRotator`变量，名为`Rotation`。这个值被设置为玩家的前方向量，并转换为`Rotator`容器。这将确保旋转——换句话说，玩家投射物生成的方向——将在玩家前方，并且它将远离玩家。
- en: Now, all of the parameters required to spawn the projectile are ready.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有生成投射物所需的参数都已准备就绪。
- en: 'Add the following line underneath the code from the previous step:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的代码下面添加以下行：
- en: '[PRE17]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `World->SpawnActor()` function will return an object of the class you are
    attempting to spawn in – in this case, `APlayerProjectile`. This is why you are
    adding `APlayerProjectile* Projectile` before the actual spawning occurs. Then,
    you are passing in the `SpawnLocation`, `Rotation`, and `SpawnParams` parameters
    to ensure that the projectile is spawning where and how you want.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`World->SpawnActor()`函数将返回你试图创建的类的对象——在这种情况下，`APlayerProjectile`。这就是为什么你在实际生成之前添加了`APlayerProjectile*
    Projectile`。然后，你传递`SpawnLocation`、`Rotation`和`SpawnParams`参数以确保投射物将在你想要的位置和方式生成。'
- en: Return to the editor to recompile the newly added code. After the code compiles
    successfully, this exercise is complete.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回编辑器重新编译新添加的代码。在代码编译成功后，这个练习就完成了。
- en: With this exercise complete, you now have a function that will spawn the player
    projectile class that is assigned inside the player character. By adding safety
    checks for the validity of both the projectile and the world, you can ensure that
    if an object is spawned, it is a valid object inside a valid world.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你现在有一个函数可以生成玩家投射物类，该类被分配在玩家角色内部。通过添加对投射物和世界的有效性检查，你可以确保如果生成了一个对象，它是在一个有效世界中有效的对象。
- en: You set up the appropriate `location`, `rotation`, and `FActorSpawnParameters`
    parameters for the `UWorld SpawnActor()` function to ensure that the player projectile
    spawns at the right location, based on the socket location from the previous exercise,
    with the appropriate direction so that it moves away from the player, and with
    the player character as its owner.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你为`UWorld SpawnActor()`函数设置了适当的`location`、`rotation`和`FActorSpawnParameters`参数，以确保玩家投射物根据上一个练习中的插座位置在正确的位置生成，具有适当的移动方向，以便它远离玩家，并以玩家角色为其所有者。
- en: Now, it is time to update the `Anim_ProjectileNotify` source file so that it
    spawns the projectile.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更新`Anim_ProjectileNotify`源文件，以便它生成投射物。
- en: Exercise 14.06 – updating the Anim_ProjectileNotify class
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.06 – 更新Anim_ProjectileNotify类
- en: The function that allows the player projectile to spawn is ready, but you aren’t
    calling this function anywhere yet. Back in *Exercise 14.01 – creating a UAnim
    Notify class*, you created the `Anim_ProjectileNotify` class, while in *Exercise
    14.02 – adding the notify to the Throw montage*, you added this notify to the
    **Throw** Animation Montage.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 允许玩家投射物生成的函数已经准备好了，但你还没有在任何地方调用这个函数。回到*练习14.01 – 创建UAnim Notify类*，你创建了`Anim_ProjectileNotify`类，而在*练习14.02
    – 将通知添加到Throw蒙太奇*中，你将这个通知添加到了**Throw**动画蒙太奇。
- en: Now, it is time to update the `UanimNotify` class so that it calls the `SpawnProjectile()`
    function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更新`UanimNotify`类，以便它调用`SpawnProjectile()`函数。
- en: 'Follow these steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: In Visual Studio, open the `Anim_ProjectileNotify.cpp` source file.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`Anim_ProjectileNotify.cpp`源文件。
- en: 'In the source file, you have the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件中，你有以下代码：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Remove the `UE_LOG()` line from the `Notify()` function.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Notify()`函数中删除`UE_LOG()`行。
- en: 'Next, add the following `include` lines underneath `Anim_ProjectileNotify.h`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Anim_ProjectileNotify.h`下面添加以下`include`行：
- en: '[PRE19]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You need to include the `SuperSideScroller_Player.h` header file because it
    is required to call the `SpawnProjectile()` function you created in the previous
    exercise. We also included `SkeletalMeshComponent.h` because we will reference
    this component inside the `Notify()` function, so it’s best to include it here
    too.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要包含`SuperSideScroller_Player.h`头文件，因为它是调用您在上一练习中创建的`SpawnProjectile()`函数所必需的。我们还包含了`SkeletalMeshComponent.h`，因为我们将在`Notify()`函数中引用此组件，所以最好在这里也包含它。
- en: The `Notify()` function passes in a reference to the owning `Skeletal Mesh`,
    labeled `MeshComp`. You can use this skeletal mesh to get a reference to the player
    character by using the `GetOwner()` function and casting the returned actor to
    your `SuperSideScroller_Player` class. We’ll do this next.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notify()`函数传递一个指向拥有者`Skeletal Mesh`的引用，标记为`MeshComp`。您可以使用这个骨骼网格通过`GetOwner()`函数获取对玩家角色的引用，并将返回的演员强制转换为您的`SuperSideScroller_Player`类。我们将在下一步这样做。'
- en: 'Inside the `Notify()` function, add the following line of code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Notify()`函数内部，添加以下代码行：
- en: '[PRE20]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that you have a reference to the player, you need to add a validity check
    for the `Player` variable before making a call to the `SpawnProjectile()` function.
    Add the following lines of code after the line from the previous step:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经获得了对玩家的引用，在调用`SpawnProjectile()`函数之前，您需要在`Player`变量上添加一个有效性检查。在上一步骤的代码行之后添加以下代码行：
- en: '[PRE21]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that the `SpawnProjectile()` function is being called from the `Notify()`
    function, return to the editor to recompile and hot-reload the code changes you
    have made.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`SpawnProjectile()`函数是从`Notify()`函数中调用的，返回到编辑器以重新编译和热重载您所做的代码更改。
- en: Before you can use `PIE` to run around and throw the player projectile, you
    need to assign the `Player Projectile` variable from the previous exercise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用`PIE`四处跑动并投掷玩家投射物之前，您需要将上一练习中的`Player Projectile`变量分配。
- en: Inside the `/MainCharacter/Blueprints` directory to find the `BP_SuperSideScroller_MainCharacter`
    Blueprint. *Double-click* to open the Blueprint.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/MainCharacter/Blueprints`目录中找到`BP_SuperSideScroller_MainCharacter`蓝图。*双击*以打开蓝图。
- en: In the `Throw Montage` parameter, you will find the `Player Projectile` parameter.
    *Left-click* the drop-down option for this parameter and find `BP_PlayerProjectile`.
    *Left-click* on this option to assign it to the `Player Projectile` variable.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Throw Montage`参数中，您将找到`Player Projectile`参数。*左单击*此参数的下拉选项，找到`BP_PlayerProjectile`。*左单击*此选项将其分配给`Player
    Projectile`变量。
- en: Recompile and save the `BP_SuperSideScroller_MainCharacter` Blueprint.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译并保存`BP_SuperSideScroller_MainCharacter`蓝图。
- en: Now, use `PIE` and use the *left mouse button*. The player character will play
    the **Throw** animation and the player projectile will spawn.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`PIE`并使用*左鼠标按钮*。玩家角色将播放**投掷**动画，玩家投射物将被生成。
- en: 'Notice that the projectile is spawned from the `ProjectileSocket` function
    you created and that it moves away from the player. The following screenshot shows
    this in action:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，投射物是从您创建的`ProjectileSocket`函数中生成的，并且它从玩家处移动开去。以下截图显示了这一过程：
- en: '![Figure 14.17 – The player can now throw the player projectile ](img/Figure_14.17_B18531.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图14.17 – 玩家现在可以投掷玩家投射物](img/Figure_14.17_B18531.jpg)'
- en: Figure 14.17 – The player can now throw the player projectile
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17 – 玩家现在可以投掷玩家投射物
- en: With this exercise complete, the player can now throw the player projectile.
    The player projectile, in its current state, is ineffective against enemies and
    just flies through the air. It took a lot of moving parts between the `Anim_ProjectileNotify`
    class, and the player character to get the player to throw the projectile.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这个练习的完成，玩家现在可以投掷玩家投射物。在当前状态下，玩家投射物对敌人无效，只是在空中飞行。要使玩家能够投掷投射物，需要在`Anim_ProjectileNotify`类和玩家角色之间进行很多部分的移动。
- en: In the upcoming section and exercises, you will update the player projectile
    so that it destroys enemies and play additional effects such as particles and
    sound.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节和练习中，您将更新玩家投射物，使其能够销毁敌人并播放额外的效果，如粒子效果和声音。
- en: Destroying actors
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁演员
- en: 'So far in this chapter, we have put a lot of focus on spawning, or creating,
    actors inside the game world; the player character uses the `UWorld` class to
    spawn the projectile. UE5 and its base `Actor` class come with a default function
    that you can use to destroy, or remove, an actor from the game world:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经在游戏世界中大量关注了生成或创建演员；玩家角色使用`UWorld`类来生成投射物。UE5及其基础`Actor`类自带一个默认函数，您可以使用它来销毁或从游戏世界中移除演员：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can find the full implementation of this function in Visual Studio by finding
    the `Actor.cpp` source file in the `/Source/Runtime/Engine/Actor.cpp` directory.
    This function exists in all the classes that extend from the `Actor` class, and
    in the case of UE5, it exists in all classes that can be spawned, or placed, inside
    the game world. To be more explicit, both the `EnemyBase` and `PlayerProjectile`
    classes are *children* of the `Actor` class, so they can be destroyed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Visual Studio 中通过在 `/Source/Runtime/Engine/Actor.cpp` 目录下找到 `Actor.cpp`
    源文件来找到这个函数的完整实现。这个函数存在于所有从 `Actor` 类扩展的类中，在 UE5 的情况下，它存在于所有可以生成或放置在游戏世界中的类中。更具体地说，`EnemyBase`
    和 `PlayerProjectile` 类都是 `Actor` 类的 *子类*，因此它们可以被销毁。
- en: 'Looking further into the `AActor::Destroy()` function, you will find the following
    line:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步查看 `AActor::Destroy()` 函数，你会找到以下行：
- en: '[PRE23]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We won’t be going into further detail about what exactly the `UWorld` class
    does to destroy an actor, but it is important to emphasize the fact that the `UWorld`
    class is responsible for both creating and destroying actors inside the world.
    Feel free to dig deeper into the source engine code to find more information about
    how the `UWorld` class handles destroying and spawning actors.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨 `UWorld` 类是如何销毁演员的，但重要的是强调 `UWorld` 类负责在世界上创建和销毁演员。你可以自由地深入研究源引擎代码，以找到更多关于
    `UWorld` 类如何处理销毁和生成演员的信息。
- en: Now that you have more context regarding how UE5 handles destroying and removing
    actors from the game world, we’ll implement this ourselves for the enemy character.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了 UE5 如何处理销毁和从游戏世界中移除演员的更多背景信息，我们将自己实现敌对角色的这一功能。
- en: Exercise 14.07 – creating the DestroyEnemy() function
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.07 – 创建 DestroyEnemy() 函数
- en: The main part of the gameplay for the `Super` `SideScroller` game is for the
    player to move around the level and use the projectile to destroy enemies. At
    this point in the project, you have handled the player movement and spawning the
    player projectile. However, the projectile does not destroy enemies yet.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Super SideScroller` 游戏的主要游戏玩法是玩家在关卡中移动并使用投射物来摧毁敌人。在项目当前阶段，你已经处理了玩家移动和生成玩家投射物的功能。然而，投射物目前还不能摧毁敌人。
- en: To get this functionality in place, we’ll start by adding some logic to the
    `EnemyBase` class so that it knows how to handle its destruction and remove it
    from the game once it collides with the player projectile.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，我们首先将在 `EnemyBase` 类中添加一些逻辑，以便它知道如何处理自己的销毁，并在与玩家投射物碰撞后将其从游戏中移除。
- en: 'Follow these steps to achieve this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现：
- en: First, navigate to Visual Studio and open the `EnemyBase.h` header file.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到 Visual Studio 并打开 `EnemyBase.h` 头文件。
- en: 'In the header file, create the declaration of a new function called `DestroyEnemy()`
    under the `Public` access modifier, as shown here:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中，在 `Public` 访问修饰符下创建一个名为 `DestroyEnemy()` 的新函数声明，如下所示：
- en: '[PRE24]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Make sure this function definition is written underneath `GENERATED_BODY()`,
    within the class definition.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这个函数定义写在 `GENERATED_BODY()` 之下，在类定义内部。
- en: Save these changes to the header file and open the `EnemyBase.cpp` source file
    to add the implementation of this function.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些更改保存到头文件中，并打开 `EnemyBase.cpp` 源文件以添加此函数的实现。
- en: 'Below the `#include` lines, add the following function definition:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `#include` 行下面，添加以下函数定义：
- en: '[PRE25]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For now, this function will be very simple. All you need to do is call the inherited
    `Destroy()` function from the base `Actor` class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个功能将非常简单。你所需要做的就是从基类 `Actor` 调用继承的 `Destroy()` 函数。
- en: 'Update the `DestroyEnemy()` function so that it looks like this:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `DestroyEnemy()` 函数，使其看起来像这样：
- en: '[PRE26]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this function complete, save the source file and return to the editor so
    that you can recompile and hot-reload the code.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个函数后，保存源文件并返回到编辑器，以便你可以重新编译和热重载代码。
- en: With this exercise complete, the enemy character now has a function that can
    easily handle the destruction of the actor whenever you choose. The `DestroyEnemy()`
    function is publicly accessible so that it can be called by other classes, which
    will come in handy later when you handle the destruction of the player projectile.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，敌对角色现在有一个可以轻松处理演员销毁的函数，无论何时选择都可以调用。`DestroyEnemy()` 函数是公开可访问的，这样其他类就可以调用它，这在稍后处理玩家投射物的销毁时将非常有用。
- en: The reason you’re creating a unique function to destroy the enemy actor is that
    you will use this function later in this chapter to add VFX and SFX to the enemy
    when they are destroyed by the player projectile.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个独特的函数来销毁敌人演员的原因是，你将在本章后面使用这个函数，当敌人被玩家弹射物销毁时，为它添加 VFX 和 SFX。
- en: Before polishing the elements of the enemy’s destruction, let’s implement a
    similar function inside the player projectile class so that it can also be destroyed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在完善敌人的销毁元素之前，让我们在玩家弹射物类内部实现一个类似的功能，以便它也可以被销毁。
- en: Exercise 14.08 – destroying projectiles
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.08 – 销毁弹射物
- en: Now that the enemy characters can handle being destroyed through the new `DestroyEnemy()`
    function you implemented in the previous exercise, it is time to do the same for
    the player projectile.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在敌人角色可以通过你在上一个练习中实现的新的 `DestroyEnemy()` 函数来处理销毁，是时候为玩家弹射物做同样的事情了。
- en: By the end of this exercise, the player projectile will have a unique function
    to handle it being destroyed and removed from the game world.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个练习结束时，玩家弹射物将有一个独特的函数来处理它被销毁并从游戏世界中移除。
- en: 'Let’s get started:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: In Visual Studio, open the header file for the player projectile – that is,
    `PlayerProjectile.h`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，打开玩家弹射物的头文件——即 `PlayerProjectile.h`。
- en: 'Under the `Public` access modifier, add the following function declaration:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Public` 访问修饰符下，添加以下函数声明：
- en: '[PRE27]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, open the source file for the player projectile – that is, `PlayerProjectile.cpp`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开玩家弹射物的源文件——即 `PlayerProjectile.cpp`。
- en: 'Underneath the void `APlayerProjectile::OnHit` function, add the definition
    of the `ExplodeProjectile()` function:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 void `APlayerProjectile::OnHit` 函数下方，添加 `ExplodeProjectile()` 函数的定义。
- en: '[PRE28]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For now, this function will work identically to the `DestroyEnemy()` function
    from the previous exercise.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个函数将和上一个练习中的 `DestroyEnemy()` 函数工作方式相同。
- en: 'Add the inherited `Destroy()` function to the new `ExplodeProjectile()` function,
    like so:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将继承的 `Destroy()` 函数添加到新的 `ExplodeProjectile()` 函数中，如下所示：
- en: '[PRE29]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this function complete, save the source file and return to the editor so
    that you can recompile and hot-reload the code.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个函数后，保存源文件并返回到编辑器，以便你可以重新编译和热重载代码。
- en: With this exercise complete, the player projectile now has a function that can
    easily handle the destruction of the actor whenever you choose. The reason you
    need to create a unique function to handle destroying the player projectile actor
    is the same reason you created the `DestroyEnemy()` function – you will use this
    function later in this chapter to add VFX and SFX to the player projectile when
    it collides with another actor.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，玩家弹射物现在有一个可以轻松处理演员销毁的功能，无论何时选择。你需要创建一个独特的函数来处理玩家弹射物演员的销毁，原因和你创建 `DestroyEnemy()`
    函数的原因相同——你将在本章后面使用这个函数，当玩家弹射物与另一个演员碰撞时，为它添加 VFX 和 SFX。
- en: Now that you have experience with implementing the `Destroy()` function inside
    both the player projectile and the enemy character, it is time to put these two
    elements together.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在玩家弹射物和敌人角色内部实现了 `Destroy()` 函数，是时候将这两个元素放在一起了。
- en: In the next activity, you will enable the player projectile to destroy the enemy
    character when they collide.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，你将使玩家弹射物能够在它们碰撞时销毁敌人角色。
- en: Activity 14.01 – Allow the projectile to destroy enemies
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 14.01 – 允许弹射物销毁敌人
- en: Now that both the player projectile and the enemy character can handle being
    destroyed, it is time to go the extra mile and allow the player projectile to
    destroy the enemy character when they collide.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家弹射物和敌人角色都可以处理被销毁的情况，是时候更进一步，允许玩家弹射物在它们碰撞时销毁敌人角色。
- en: 'Follow these steps to achieve this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这一点：
- en: Add the `#include` statement for the `EnemyBase.h` header file toward the top
    of the `PlayerProjectile.cpp` source file.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerProjectile.cpp` 源文件顶部添加 `#include` 语句以包含 `EnemyBase.h` 头文件。
- en: Within the void `APlayerProjectile::OnHit()` function, create a new variable
    of the `AEnemyBase*` type and call this variable `Enemy`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `APlayerProjectile::OnHit()` 的 void 函数内，创建一个新的 `AEnemyBase*` 类型的变量，并将其命名为
    `Enemy`。
- en: Cast the `OtherActor` parameter of the `APlayerProjectile::OnHit()` function
    to the `AEnemyBase*` class and set the `Enemy` variable to the result of this
    cast.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `APlayerProjectile::OnHit()` 函数的 `OtherActor` 参数转换为 `AEnemyBase*` 类，并将 `Enemy`
    变量设置为这个转换的结果。
- en: Use an `if()` statement to check the validity of the `Enemy` variable.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `if()` 语句检查 `Enemy` 变量的有效性。
- en: If the `Enemy` variable is valid, call the `DestroyEnemy()` function from this
    `Enemy`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `Enemy` 变量有效，则从该 `Enemy` 调用 `DestroyEnemy()` 函数。
- en: After the `if()` block, make a call to the `ExplodeProjectile()` function.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `if()` 块之后，调用 `ExplodeProjectile()` 函数。
- en: Save the changes to the source file and return to the UE5 editor.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存源文件的更改并返回到 UE5 编辑器。
- en: Use `PIE` and then use the player projectile against an enemy to observe the
    results.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `PIE`，然后用玩家投射物攻击敌人以观察结果。
- en: 'The expected output is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 14.18 – The player throwing the projectile ](img/Figure_14.18_B18531.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.18 – 玩家投掷投射物](img/Figure_14.18_B18531.jpg)'
- en: Figure 14.18 – The player throwing the projectile
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18 – 玩家投掷投射物
- en: 'When the projectile hits the enemy, the enemy character is destroyed, as shown
    here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当投射物击中敌人时，敌人角色将被摧毁，如下所示：
- en: '![Figure 14.19 – The projectile and enemy have been destroyed ](img/Figure_14.19_B18531.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.19 – 投射物和敌人已被摧毁](img/Figure_14.19_B18531.jpg)'
- en: Figure 14.19 – The projectile and enemy have been destroyed
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19 – 投射物和敌人已被摧毁
- en: With this activity complete, the player projectile and the enemy character can
    be destroyed when they collide with each other. Additionally, the player projectile
    will be destroyed whenever another actor triggers its `APlayerProjectile::OnHit()`
    function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个活动后，玩家投射物和敌人角色在它们相互碰撞时可以被摧毁。此外，每当另一个角色触发其 `APlayerProjectile::OnHit()`
    函数时，玩家投射物也将被摧毁。
- en: 'With that, a major element of the `Super` `SideScroller` game has been completed:
    the player projectile spawning and the enemies being destroyed when they collide
    with the projectile. You can observe that destroying these actors is very simple
    and not very interesting to the player.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，`Super SideScroller` 游戏的一个主要元素已经完成：玩家投射物生成，以及当它们与投射物碰撞时敌人被摧毁。你可以观察到摧毁这些角色非常简单，对玩家来说并不很有趣。
- en: This is why, in the upcoming exercises in this chapter, you will learn more
    about **visual effects** and **audio effects**, or **VFX** and **SFX**, respectively.
    You will also implement these elements for the enemy character and player projectile.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在本章接下来的练习中，你将学习更多关于**视觉效果**和**音频效果**，或者分别称为**VFX**和**SFX**。你还将为敌人角色和玩家投射物实现这些元素。
- en: Now that both the enemy character and the player projectile can be destroyed,
    let’s briefly discuss what VFX and SFX are, and how they will impact the project.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然敌人角色和玩家投射物都可以被摧毁，让我们简要讨论一下 VFX 和 SFX 是什么，以及它们将如何影响项目。
- en: Note
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: Understanding and implementing visual and audio effects
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现视觉和音频效果
- en: VFX such as Particle Systems and sound effects such as sound cues play an important
    role in video games. They add a level of polish on top of systems, game mechanics,
    and even basic actions that make these elements more interesting or more pleasing
    to perform.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: VFX，如粒子系统，以及声音效果，如声音提示，在视频游戏中扮演着重要的角色。它们在系统、游戏机制甚至基本动作上增加了一层润色，使这些元素更加有趣或更令人愉悦。
- en: Let’s start by understanding VFX, followed by SFX.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从理解 VFX 开始，然后是 SFX。
- en: VFX
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VFX
- en: VFX, in the context of UE5, are made up of what’s called **particle systems**.
    Particle Systems are made up of emitters, and emitters consist of modules. In
    these modules, you can control the appearance and behavior of the emitter using
    materials, meshes, and mathematical modules. The result can be anything from a
    fire torch or snow falling to rain, dust, and so on.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE5 的上下文中，VFX 由所谓的**粒子系统**组成。粒子系统由发射器组成，而发射器由模块组成。在这些模块中，你可以使用材料、网格和数学模块来控制发射器的外观和行为。结果可以是火焰火炬、下雪、雨、灰尘等等。
- en: Note
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more here: [https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.xhtml](https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.xhtml).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多信息：[https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.xhtml](https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.xhtml)。
- en: Audio effects (SFX)
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频效果（SFX）
- en: 'SFX, in the context of UE5, are made up of a combination of sound waves and
    sound cues:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE5的背景下，SFX是由声音波和声音提示的组合构成的：
- en: Sound waves are `.wav` audio format files that can be imported into UE5.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音波是`.wav`音频格式文件，可以导入到UE5中。
- en: Sound cues combine sound wave audio files with other nodes such as **Oscillator**,
    **Modulator**, and **Concatenator** to create unique and complex sounds for your
    game.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音提示将声音波音频文件与其他节点（如**振荡器**、**调制器**和**连接器**）结合，为您游戏创建独特且复杂的音效。
- en: Note
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more here: [https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.xhtml).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多信息：[https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.xhtml).
- en: 'In the context of UE5, VFX were created using a tool called **Cascade**, where
    artists could combine the use of **materials**, **static meshes**, and **math**
    to create interesting and convincing effects for the game world. This book will
    not dive into how this tool works, but you can find information about Cascade
    here: [https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/ParticleSystems/](https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/ParticleSystems/).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE5的背景下，VFX是通过一个名为**Cascade**的工具创建的，艺术家们可以结合使用**材质**、**静态网格**和**数学**来为游戏世界创建有趣且令人信服的效果。本书不会深入探讨这个工具的工作原理，但您可以在以下链接中找到有关Cascade的信息：[https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/ParticleSystems/](https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/ParticleSystems/).
- en: 'In more recent versions of the engine, starting in the 4.20 update, there is
    a plugin called **Niagara** that can be enabled to create VFX. Niagara, unlike
    Cascade, uses a system similar to Blueprints, where you can visually script the
    behaviors of the effect rather than use preset modules with predefined behavior.
    You can find more information about Niagara here: [https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml).
    Furthermore, Cascade will be deprecated in new versions of UE5 and Niagara will
    be used. For the sake of this book, we will still use Cascade particle effects.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎的较新版本中，从4.20更新开始，有一个名为**Niagara**的插件可以被启用以创建VFX。与Cascade不同，Niagara使用类似于Blueprints的系统，您可以通过视觉脚本来编写效果的行为，而不是使用预设的模块。您可以在以下链接中找到有关Niagara的更多信息：[https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.xhtml).
    此外，Cascade将在UE5的新版本中弃用，而Niagara将被使用。为了本书的目的，我们仍将使用Cascade粒子效果。
- en: In [*Chapter 9*](B18531_09.xhtml#_idTextAnchor183), *Adding* *Audio-Visual Elements*,
    you learned more about audio and how audio is handled inside UE5\. All you need
    to know right now is that UE5 uses the `.wav` file format to import audio into
    the engine. From there, you can use the `.wav` file directly, referred to as sound
    waves in the editor, or you can convert these assets into sound cues, which allow
    you to add audio effects on top of the sound wave.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18531_09.xhtml#_idTextAnchor183)，*添加* *音频-视觉元素*，您学习了更多关于音频以及如何在UE5中处理音频的知识。您现在需要知道的是，UE5使用`.wav`文件格式将音频导入到引擎中。从那里，您可以直接使用`.wav`文件，在编辑器中称为声音波，或者将这些资产转换为声音提示，这允许您在声音波上添加音频效果。
- en: 'Lastly, there is one important class to know about that you will be referencing
    in the upcoming exercises, and this class is called `UGameplayStatics`. This is
    a static class in UE5 that can be used from both C++ and Blueprints, and it offers
    a variety of useful gameplay-related functions. The two functions you will be
    working with in the upcoming exercise are as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个重要的类需要了解，您将在接下来的练习中引用，这个类被称为`UGameplayStatics`。这是一个UE5中的静态类，可以从C++和Blueprints中使用，并提供各种与游戏相关的实用功能。您将在接下来的练习中使用的两个函数如下：
- en: '[PRE30]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These two functions work in very similar ways; they both require a `World` context
    object in which to spawn the effect, the Particle System or audio to spawn, and
    the location in which to spawn the effect. You will be using these functions to
    spawn the destroy effects for the enemy in the next exercise.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数以非常相似的方式工作；它们都需要一个`World`上下文对象来在其中生成效果，要生成的粒子系统或音频，以及生成效果的位置。您将使用这些函数来生成下一练习中敌人的摧毁效果。
- en: Exercise 14.09 – adding effects when the enemy is destroyed
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.09 – 在敌人被摧毁时添加效果
- en: In this exercise, you will add new content to the project that comes included
    with this chapter and exercise. This includes theVFX andSFX, and all of their
    required assets. Then, you will update the `EnemyBase` class so that it can use
    audio and Particle System parameters to add the layer of polish needed when the
    enemy is destroyed by the player projectile.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将向项目添加本章和练习中包含的新内容。这包括 VFX 和 SFX，以及它们的所有必需资产。然后，你将更新 `EnemyBase` 类，使其能够使用音频和粒子系统参数，在敌人被玩家投射物摧毁时添加所需的磨光层。
- en: By the end of this exercise, you will have an enemy that is visually and audibly
    destroyed when it collides with the player projectile.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个练习之后，你将拥有一个敌人，当它与玩家的投射物碰撞时，在视觉和听觉上都会被摧毁。
- en: 'Let’s get started:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: To begin, we need to migrate specific assets from the **Action RPG** project,
    which can be found in the **Learn** tab of **Unreal Engine Launcher**.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从 **Action RPG** 项目迁移特定的资产，该项目可以在 **Unreal Engine Launcher** 的 **Learn**
    选项卡中找到。
- en: 'From **Epic Games Launcher**, navigate to the **Samples** tab and, in the **UE
    Legacy Samples** category, you will find **Action RPG**:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Epic Games Launcher**，导航到 **Samples** 选项卡，在 **UE Legacy Samples** 类别中，你可以找到
    **Action RPG**：
- en: '![Figure 14.20 – The Action RPG sample project ](img/Figure_14.20_B18531.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.20 – Action RPG 示例项目](img/Figure_14.20_B18531.jpg)'
- en: Figure 14.20 – The Action RPG sample project
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.20 – Action RPG 示例项目
- en: Note
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will be taking additional assets from the **Action RPG** project in later
    exercises of this chapter, so you should keep this project open to avoid redundantly
    opening the project. The assets for this exercise can be downloaded from [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter14/Exercise14.09](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter14/Exercise14.09).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章的后续练习中从 **Action RPG** 项目中获取额外的资产，因此你应该保持此项目打开，以避免重复打开项目。本练习的资产可以从 [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter14/Exercise14.09](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Chapter14/Exercise14.09)
    下载。
- en: Left-click the **Action RPG** game project and then left-click the **Create
    Project** option.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键点击 **Action RPG** 游戏项目，然后左键点击 **创建项目** 选项。
- en: From here, select engine version 4.27 and choose which directory to download
    the project to. Then, *left-click* the **Create** button to start installing the
    project.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，选择引擎版本 4.27 并选择将项目下载到哪个目录。然后，*左键点击* **创建** 按钮以开始安装项目。
- en: Once the **Action RPG** project has finished downloading, navigate to the **Library**
    tab of **Epic Games Launcher** to find **ActionRPG** under the **My Projects**
    section.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 **Action RPG** 项目下载完成，导航到 **Epic Games Launcher** 的 **Library** 选项卡，在 **My
    Projects** 部分找到 **ActionRPG**。
- en: '*Double-click* the **ActionRPG** project to open it in the UE5 editor.'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击* **ActionRPG** 项目以在 UE5 编辑器中打开它。'
- en: In the editor, find the **A_Guardian_Death_Cue** audio asset in the **Content
    Browser** interface. *Right-click* this asset and select **Asset Actions** and
    then **Migrate**.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，在 **Content Browser** 界面中找到 **A_Guardian_Death_Cue** 音频资产。*右键点击* 此资产，选择
    **Asset Actions** 然后选择 **迁移**。
- en: After selecting **Migrate**, you will be presented with all the assets that
    are referenced in **A_Guardian_Death_Cue**. This includes all audio classes and
    sound wave files. Choose **OK** from the **Asset Report** dialog window.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 **迁移** 之后，你将看到所有在 **A_Guardian_Death_Cue** 中引用的资产。这包括所有音频类和声音波形文件。从 **Asset
    Report** 对话窗口中选择 **OK**。
- en: Next, you will need to navigate to the `Content` folder for your `Super SideScroller`
    project and *left-click* **Select Folder**.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要导航到你的 `Super SideScroller` 项目的 `Content` 文件夹，并 *左键点击* **选择文件夹**。
- en: Once the migration process is complete, you will see a notification in the editor
    stating that the migration was completed successfully.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦迁移过程完成，你将在编辑器中看到一个通知，表明迁移已成功完成。
- en: 'Do the same migration steps for the `P_Goblin_Death` VFX asset. The two primary
    assets you will be adding to the project are as follows:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `P_Goblin_Death` VFX 资产，执行相同的迁移步骤。你将添加到项目中的两个主要资产如下：
- en: '[PRE31]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `P_Goblin_Death` Particle System asset references additional assets such
    as materials and textures that are included in the `Effects` directory, while
    `A_Guardian_Death_Cue` references additional sound wave assets included in the
    `Assets` directory.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`P_Goblin_Death` 粒子系统资产引用了包含在 `Effects` 目录中的其他资产，如材质和纹理，而 `A_Guardian_Death_Cue`
    引用了包含在 `Assets` 目录中的其他声音波形资产。'
- en: After migrating these folders into your `Content` directory, open the UE5 editor
    for your `SuperSideScroller` project to find the new folders included in your
    project’s **Content Drawer**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些文件夹迁移到你的 `Content` 目录后，打开你的 `SuperSideScroller` 项目的 UE5 编辑器，以找到项目 **内容抽屉**
    中包含的新文件夹。
- en: The particle you will be using for the enemy character’s destruction is called
    `P_Goblin_Death` and can be found in the `/Effects/FX_Particle/` directory. The
    sound you will be using for the enemy character’s destruction is called `A_Guardian_Death_Cue`
    and can be found in the `/Assets/Sounds/Creatures/Guardian/` directory. Now that
    the assets you need have been imported into the editor, let’s move on to the code.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你将用于敌人角色摧毁的粒子称为 `P_Goblin_Death`，可以在 `/Effects/FX_Particle/` 目录中找到。你将用于敌人角色摧毁的声音称为
    `A_Guardian_Death_Cue`，可以在 `/Assets/Sounds/Creatures/Guardian/` 目录中找到。现在，所需的资产已经导入到编辑器中，让我们继续编写代码。
- en: Open Visual Studio and navigate to the header file for the enemy base class
    – that is, `EnemyBase.h`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并导航到敌人基类的头文件 – 即 `EnemyBase.h`。
- en: 'Add the following `UPROPERTY()` variable. This will represent the Particle
    System for when the enemy is destroyed. Make sure this is declared under the `Public`
    access modifier:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `UPROPERTY()` 变量。这代表敌人被摧毁时的粒子系统。确保在 `Public` 访问修饰符下声明：
- en: '[PRE32]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following `UPROPERTY()` variable. This will represent the sound for
    when the enemy is destroyed. Make sure this is declared under the `Public` access
    modifier:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `UPROPERTY()` 变量。这代表敌人被摧毁时的声音。确保在 `Public` 访问修饰符下声明：
- en: '[PRE33]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With these two properties defined, let’s move on and add the logic required
    to spawn and use these effects for when the enemy is destroyed.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这两个属性后，让我们继续添加当敌人被摧毁时生成和使用这些效果的逻辑。
- en: 'Inside the source file for the enemy base class, `EnemyBase.cpp`, add the following
    includes for the `UGameplayStatics` and `UWorld` classes:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敌人基类源文件 `EnemyBase.cpp` 中，添加以下包含 `UGameplayStatics` 和 `UWorld` 类的代码：
- en: '[PRE34]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You will be using the `UGameplayStatics` and `UWorld` classes to spawn the sound
    and Particle System into the world when the enemy is destroyed.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `UGameplayStatics` 和 `UWorld` 类在敌人被摧毁时将声音和粒子系统生成到世界中。
- en: 'Within the `AEnemyBase::DestroyEnemy()` function, you have one line of code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AEnemyBase::DestroyEnemy()` 函数中，你有一行代码：
- en: '[PRE35]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following line of code above the `Destroy()` function call:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Destroy()` 函数调用之前添加以下行代码：
- en: '[PRE36]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is necessary to define the `UWorld` object before attempting to spawn a Particle
    System or sound because a `World` context object is required.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试生成粒子系统或声音之前，必须定义 `UWorld` 对象，因为需要一个 `World` 上下文对象。
- en: 'Next, use an `if()` statement to check the validity of the `World` object you
    just defined:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用一个 `if()` 语句来检查你刚刚定义的 `World` 对象的有效性：
- en: '[PRE37]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Within the `if()` block, add the following code to check the validity of the
    `DeathEffect` property, and then spawn this effect using the `SpawnEmitterAtLocation`
    function from `UGameplayStatics`:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `if()` 块中，添加以下代码来检查 `DeathEffect` 属性的有效性，然后使用 `UGameplayStatics::SpawnEmitterAtLocation`
    函数生成此效果：
- en: '[PRE38]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It cannot be emphasized enough that you should ensure an object is valid before
    attempting to spawn or manipulate the object. By doing so, you can avoid engine
    crashes.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 强调这一点的重要性无可置疑，你应该在尝试生成或操作对象之前确保对象是有效的。这样做可以避免引擎崩溃。
- en: 'After the `if(DeathEffect)` block, perform the same validity check of the `DeathSound`
    property and then spawn the sound using the `UGameplayStatics::SpawnSoundAtLocation`
    function:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `if(DeathEffect)` 块之后，对 `DeathSound` 属性进行相同的有效性检查，然后使用 `UGameplayStatics::SpawnSoundAtLocation`
    函数生成声音：
- en: '[PRE39]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Before calling the `Destroy()` function, you need to make checks regarding whether
    both the `DeathEffect` and `DeathSound` properties are valid, and if so, spawn
    those effects using the proper `UGameplayStatics` function. This ensures that
    regardless of whether either property is valid, the enemy character will still
    be destroyed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `Destroy()` 函数之前，你需要检查 `DeathEffect` 和 `DeathSound` 属性是否有效，如果是，则使用适当的 `UGameplayStatics`
    函数生成这些效果。这确保了无论哪个属性是否有效，敌人角色都将被摧毁。
- en: Now that the `AEnemyBase::DestroyEnemy()` function has been updated to spawn
    these effects, return to the UE5 editor to compile and hot-reload these code changes.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`AEnemyBase::DestroyEnemy()` 函数已经更新为生成这些效果，返回 UE5 编辑器以编译和热重载这些代码更改。
- en: Within the `/Enemy/Blueprints/` directory. *Double-click* the `BP_Enemy` asset
    to open it.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/Enemy/Blueprints/` 目录下。*双击* `BP_Enemy` 资产以打开它。
- en: In the `Death Effect` and `Death Sound` properties. *Left-click* on the drop-down
    list for the `Death Effect` property and find the `P_Goblin_Death` Particle System.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Death Effect` 和 `Death Sound` 属性中。*左键点击* `Death Effect` 属性的下拉列表，找到 `P_Goblin_Death`
    粒子系统。
- en: Next, underneath the `Death Effect` parameter, *left-click* on the drop-down
    list for the `Death Sound` property and find the **A_Guardian_Death_Cue** sound
    cue.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `Death Effect` 参数下，*左键点击* `Death Sound` 属性的下拉列表，找到 **A_Guardian_Death_Cue**
    声音提示。
- en: Now that these parameters have been updated and assigned the correct effect,
    compile and save the enemy Blueprint.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这些参数已经更新并分配了正确的效果，请编译并保存敌人蓝图。
- en: 'Using `PIE`, spawn the player character and throw a player projectile at an
    enemy. If an enemy is not present in your level, please add one. When the player
    projectile collides with the enemy, the VFX and SFX you added will play, as shown
    in the following screenshot:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `PIE` 生成玩家角色并向敌人投掷玩家投射物。如果您的关卡中没有敌人，请添加一个。当玩家投射物与敌人碰撞时，您添加的 VFX 和 SFX 将会播放，如下面的截图所示：
- en: '![Figure 14.21 – Now, the enemy explodes and gets destroyed in a blaze of glory
    ](img/Figure_14.21_B18531.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.21 – 现在，敌人爆炸并伴随着荣耀的火焰被摧毁](img/Figure_14.21_B18531.jpg)'
- en: Figure 14.21 – Now, the enemy explodes and gets destroyed in a blaze of glory
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.21 – 现在，敌人爆炸并伴随着荣耀的火焰被摧毁
- en: With this exercise complete, the enemy character now plays a Particle System
    and a sound cue when it is destroyed by the player projectile. This adds a nice
    layer of polish to the game, and it makes it more satisfying to destroy the enemies.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，当敌人被玩家投射物摧毁时，敌人角色现在会播放粒子系统和声音提示。这为游戏增添了一层漂亮的润色，并使摧毁敌人更加令人满意。
- en: In the next exercise, you will add a new Particle System and audio components
    to the player projectile so that it looks and sounds more interesting while it
    flies through the air.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将为玩家投射物添加新的粒子系统和音频组件，使其在空中飞行时看起来和听起来更加有趣。
- en: Exercise 14.10 – adding effects to the player projectile
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.10 – 向玩家投射物添加效果
- en: In its current state, the player projectile functions the way it is intended
    to; it flies through the air, collides with objects in the game world, and is
    destroyed. However, visually, the player projectile is just a ball with a plain
    white texture.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，玩家投射物按预期的方式工作；它在空中飞行，与游戏世界中的对象碰撞，然后被摧毁。然而，从视觉上看，玩家投射物只是一个带有普通白色纹理的球体。
- en: In this exercise, you will add a layer of polish to the player projectile by
    adding both a Particle System and an audio component so that the projectile is
    more enjoyable to use.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将通过添加粒子系统和音频组件来为玩家投射物添加一层润色，使其在空中飞行时更加有趣。
- en: 'Follow these steps to achieve this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Much like the previous exercises, we will need to migrate assets from the **Action
    RPG** project to our **SuperSideScroller** project. Please refer to *Exercise
    14.09 – adding effects when the enemy is destroyed*, on how to install and migrate
    assets from the **Action RPG** project.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的练习类似，我们需要将 **Action RPG** 项目的资产迁移到我们的 **SuperSideScroller** 项目中。请参考 *练习
    14.09 – 当敌人被摧毁时添加效果*，了解如何从 **Action RPG** 项目安装和迁移资产。
- en: 'The two primary assets you will be adding to the project are as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您将添加到项目中的两个主要资产如下：
- en: '[PRE40]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `P_Env_Fire_Grate_01` Particle System asset references additional assets,
    such as materials and textures, that are included in the `Effects` directory,
    while `A_Ambient_Fire01_Cue` references additional sound wave and sound attenuation
    assets included in the `Assets` directory.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`P_Env_Fire_Grate_01` 粒子系统资产引用了包含在 `Effects` 目录中的其他资产，例如材料和纹理，而 `A_Ambient_Fire01_Cue`
    引用了包含在 `Assets` 目录中的其他声音波和声音衰减资产。'
- en: The particle you will be using for the player projectile is called `P_Env_Fire_Grate_01`
    and can be found in the `/Effects/FX_Particle/` directory. This is the same directory
    that’s used by the `P_Goblin_Death` VFX from the previous exercise. The sound
    you will be using for the player projectile is called `A_Ambient_Fire01_Cue` and
    can be found in the `/Assets/Sounds/Ambient/` directory.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您将用于玩家投射物的粒子被称为 `P_Env_Fire_Grate_01`，可以在 `/Effects/FX_Particle/` 目录中找到。这是与之前练习中的
    `P_Goblin_Death` VFX 相同的目录。您将用于玩家投射物的声音被称为 `A_Ambient_Fire01_Cue`，可以在 `/Assets/Sounds/Ambient/`
    目录中找到。
- en: '*Right-click* on each of these assets in the **Content Browser** interface
    of the **Action RPG** project and select **Asset Actions** and then **Migrate**.'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**界面中，*右键单击*这些资产，选择**资产操作**然后**迁移**。
- en: Make sure that you choose the directory of the **Content** folder for your **SuperSideScroller**
    project before confirming the migration.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认迁移之前，请确保选择**SuperSideScroller**项目的**内容**文件夹目录。
- en: Now that the required assets have been migrated to our project, let’s continue
    creating the player projectile class.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所需的资产已迁移到我们的项目中，让我们继续创建玩家弹射类。
- en: Open Visual Studio and navigate to the header file for the player projectile
    class – that is, `PlayerProjectile.h`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并导航到玩家弹射类的大纲文件——即`PlayerProjectile.h`。
- en: 'Under the `Private` access modifier, underneath the declaration of the `UStaticMeshComponent*
    MeshComp` class component, add the following code to declare a new audio component
    for the player projectile:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Private`访问修饰符下，在`UStaticMeshComponent* MeshComp`类组件声明下方添加以下代码，以声明一个新的音频组件用于玩家弹射：
- en: '[PRE41]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, add the following code underneath the declaration of the audio component
    to declare a new Particle System component:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在音频组件声明下方添加以下代码，以声明一个新的粒子系统组件：
- en: '[PRE42]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Instead of using properties that can be defined within the Blueprint, such as
    in the enemy character class, these effects will be components of the player projectile.
    This is because these effects should be attached to the collision component of
    the projectile so that they move with the projectile as it travels across the
    level when thrown.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 与在敌人角色类中定义的属性不同，这些效果将是玩家弹射的组件。这是因为这些效果应该附加到弹射的碰撞组件上，以便在投掷时随着弹射物穿越关卡而移动。
- en: 'With these two components declared in the header file, open the source file
    for the player projectile and add the following includes to the list of `include`
    lines at the top of the file:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中声明了这两个组件后，打开玩家弹射的源文件，并将以下包含项添加到文件顶部的`include`行列表中：
- en: '[PRE43]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You need a reference to both the audio component and the Particle System classes
    to create these subobjects using the `CreateDefaultSubobject` function, as well
    as to attach these components to **RootComponent**.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CreateDefaultSubobject`函数创建这些子对象时，需要同时引用音频组件和粒子系统类，以及将这些组件附加到**RootComponent**。
- en: 'Add the following lines to create the default subobject of the `ProjectileMovementSound`
    component, and to attach this component to **RootComponent**:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下行以创建`ProjectileMovementSound`组件的默认子对象，并将此组件附加到**RootComponent**：
- en: '[PRE44]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, add the following lines to create the default subobject for the `ProjectileEffect`
    component, and to attach this component to **RootComponent**:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下行以创建`ProjectileEffect`组件的默认子对象，并将此组件附加到**RootComponent**：
- en: '[PRE45]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that you have created, initialized, and attached these two components to
    **RootComponent**, return to the UE5 editor to recompile and hot-reload these
    code changes.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已创建、初始化并将这两个组件附加到**RootComponent**，请返回UE5编辑器以重新编译和热重载这些代码更改。
- en: From the `Content Drawer` interface, navigate to the `/MainCharacter/Projectile/`
    directory. Find the `BP_PlayerProjectile` asset and *double-click* it to open
    the Blueprint.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`内容抽屉`界面导航到`/MainCharacter/Projectile/`目录。找到`BP_PlayerProjectile`资产，并*双击*它以打开蓝图。
- en: In the **Components** tab, you will find the two new components you added using
    the preceding code. Observe that these components are attached to the **CollisionComp**
    component, also known as **RootComponent**.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在**组件**选项卡中，您将找到使用前面代码添加的两个新组件。注意，这些组件已附加到**CollisionComp**组件，也称为**RootComponent**。
- en: '*Left-click* to select the `P_Env_Fire_Grate_01` VFX asset to this parameter,
    as shown in the following screenshot:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*选择`P_Env_Fire_Grate_01` VFX资产到该参数，如图所示：'
- en: '![Figure 14.22 – Assigning the VFX to the particle system component ](img/Figure_14.22_B18531.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图14.22 – 将VFX分配给粒子系统组件](img/Figure_14.22_B18531.jpg)'
- en: Figure 14.22 – Assigning the VFX to the particle system component
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22 – 将VFX分配给粒子系统组件
- en: 'Before assigning the audio component, let’s adjust the `ProjectileEffect` VFX
    asset. Update the **Rotation** and **Scale** values of the **Transform** property
    for the VFX so that they match what is shown in the following screenshot:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分配音频组件之前，让我们调整`ProjectileEffect` VFX资产。更新VFX的**变换**属性的**旋转**和**缩放**值，使其与以下截图所示相匹配：
- en: '![Figure 14.23 – The updated Transform of the Particle System component so
    that it fits better with the projectile ](img/Figure_14.23_B18531.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.23 – 粒子系统组件更新的变换，以便更好地与投射物匹配](img/Figure_14.23_B18531.jpg)'
- en: Figure 14.23 – The updated Transform of the Particle System component so that
    it fits better with the projectile
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.23 – 粒子系统组件更新的变换，以便更好地与投射物匹配
- en: 'Navigate to the `Viewport` tab within the Blueprint to view these changes to
    the `ProjectileEffect` should look as follows:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到蓝图中的 `视口` 选项卡以查看对 `ProjectileEffect` 的这些更改应如下所示：
- en: '![Figure 14.24 – Now, the fire VFX has been scaled and rotated appropriately
    ](img/Figure_14.24_B18531.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.24 – 现在，火焰 VFX 已经适当地缩放和旋转](img/Figure_14.24_B18531.jpg)'
- en: Figure 14.24 – Now, the fire VFX has been scaled and rotated appropriately
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.24 – 现在，火焰 VFX 已经适当地缩放和旋转
- en: Now that the VFX has been set up, *left-click* the `ProjectileMovementSound`
    component and assign `A_Ambient_Fire01_Cue` to it.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在VFX已经设置好，*左键单击* `ProjectileMovementSound` 组件并将其分配给 `A_Ambient_Fire01_Cue`。
- en: 'Save and recompile the `BP_PlayerProjectile` Blueprint. Use `PIE` and observe
    that when you throw the projectile, it now shows the VFX asset and plays the assigned
    sound:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并重新编译 `BP_PlayerProjectile` 蓝图。使用 `PIE` 并观察当你投掷投射物时，它现在显示 VFX 资产并播放指定的声音：
- en: '![Figure 14.25 – The player projectile now has a VFX and an SFX as it flies
    through the air ](img/Figure_14.25_B18531.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.25 – 玩家投射物现在在空中飞行时具有 VFX 和 SFX](img/Figure_14.25_B18531.jpg)'
- en: Figure 14.25 – The player projectile now has a VFX and an SFX as it flies through
    the air
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.25 – 玩家投射物现在在空中飞行时具有 VFX 和 SFX
- en: With this exercise complete, the player projectile now has a VFX and an SFX
    that play together while it flies through the air. These elements bring the projectile
    to life and make the projectile much more interesting to use.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，玩家投射物现在在空中飞行时具有 VFX 和 SFX，这些元素使投射物栩栩如生，并使其使用起来更加有趣。
- en: Since the VFX and SFX have been created as components of the projectile, they
    are also destroyed when the projectile is destroyed.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 VFX 和 SFX 已经被创建为投射物的组件，因此当投射物被销毁时，它们也会被销毁。
- en: In the next exercise, you will add a particle notify and a sound notify to the
    **Throw** Animation Montage to provide more of an impact when the player throws
    the player projectile.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将为 **Throw** 动画蒙太奇添加粒子通知和声音通知，以便在玩家投掷玩家投射物时产生更大的影响。
- en: Exercise 14.11 – adding VFX and SFX notifies
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.11 – 添加 VFX 和 SFX 通知
- en: So far, you have been implementing polish elements to the game via C++, which
    is a valid means of implementation. To give variety, and expand your knowledge
    of the UE5 toolset, this exercise will walk you through how to use notifies in
    Animation Montages to add Particle Systems and audio within the animation. Let’s
    get started!
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直通过 C++ 实现游戏的高级元素，这是一种有效的实现方式。为了增加多样性，并扩展你对 UE5 工具集的了解，本练习将指导你如何使用动画蒙太奇中的通知来添加粒子系统和音频。让我们开始吧！
- en: Much like the previous exercises, we will need to migrate assets from the `Action
    RPG` project to our **SuperSideScroller** project. Please refer to *Exercise 14.09
    – adding effects when the enemy is destroyed*, to learn how to install and migrate
    assets from the **Action RPG** project.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的练习类似，我们需要将 `Action RPG` 项目的资产迁移到我们的 **SuperSideScroller** 项目中。请参考 *练习 14.09
    – 在敌人被销毁时添加效果*，了解如何从 **Action RPG** 项目安装和迁移资产。
- en: 'Follow these steps:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Open the **ActionRPG** project and navigate to the **Content Browser** interface.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **ActionRPG** 项目并导航到 **内容浏览器** 界面。
- en: 'The two primary assets you will be adding to the project are as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 你将添加到项目中两个主要资源如下：
- en: '[PRE46]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `P_Skill_001` Particle System asset references additional assets such as
    *materials* and *textures* that are included in the `Effects` directory, while
    `A_Ability_FireballCast_Cue` references additional *sound wave* assets included
    in the `Assets` directory.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`P_Skill_001` 粒子系统资产引用了包含在 `Effects` 目录中的其他资产，如 *材质* 和 *纹理*，而 `A_Ability_FireballCast_Cue`
    引用了包含在 `Assets` 目录中的其他 *声音波形* 资产。'
- en: The particle you will be using for the player when the projectile is thrown
    is called `P_Skill_001` and can be found in the `/Effects/FX_Particle/` directory.
    This is the same directory that was used by the `P_Goblin_Death` and `P_Env_Fire_Grate_01`
    VFX assets in the previous exercises. The sound you will be using for the enemy
    character destruction is called `A_Ambient_Fire01_Cue` and can be found in the
    `/Assets/Sounds/Ambient/` directory.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当投掷投射物时，你将使用的玩家粒子称为 `P_Skill_001`，可以在 `/Effects/FX_Particle/` 目录中找到。这是之前练习中
    `P_Goblin_Death` 和 `P_Env_Fire_Grate_01` VFX 资产所使用的同一目录。你将用于敌人角色破坏的声音称为 `A_Ambient_Fire01_Cue`，可以在
    `/Assets/Sounds/Ambient/` 目录中找到。
- en: '*Right-click* on each of these assets in the **Content Browser** interface
    of the **Action RPG** project and select **Asset Actions** and then **Migrate**.'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Action RPG** 项目的 **Content Browser** 界面中，*右键点击* 这些资产，然后选择 **Asset Actions**
    和 **Migrate**。
- en: Make sure that you choose the directory of the `Content` folder for your **SuperSideScroller**
    project before confirming the migration.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认迁移之前，请确保为你的 **SuperSideScroller** 项目选择 `Content` 文件夹的目录。
- en: Now that the assets you need have been migrated into your project, let’s move
    on to adding the required notifies to the `AM_Throw` asset. Make sure that you
    return to your **SuperSideScroller** project before continuing with this exercise.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所需的资产已迁移到你的项目中，让我们继续将所需的通知添加到 `AM_Throw` 资产中。在继续此练习之前，请确保返回到你的 **SuperSideScroller**
    项目。
- en: From the `/MainCharacter/Animation/` directory. Find the `AM_Throw` asset and
    *double-click* it to open it.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `/MainCharacter/Animation/` 目录。找到 `AM_Throw` 资产，*双击* 它以打开它。
- en: Underneath the preview window in the center of the `Anim_ProjectileNotify` earlier
    in this chapter.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章前面 `Anim_ProjectileNotify` 中预览窗口的下方。
- en: 'To the left of the **Notifies** track, you will find a **▼** sign that allows
    you to use additional notify tracks. *Left-click* to add a new notify track, as
    shown in the following screenshot:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Notifies** 轨道左侧，你会找到一个 **▼** 符号，它允许你使用额外的通知轨道。*左键点击* 添加新的通知轨道，如图下截图所示：
- en: '![Figure 14.26 – Adding a new notify track ](img/Figure_14.26_B18531.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.26 – 添加新的通知轨道](img/Figure_14.26_B18531.jpg)'
- en: Figure 14.26 – Adding a new notify track
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.26 – 添加新的通知轨道
- en: It is useful to add multiple tracks to the timeline to keep things organized
    when adding multiple notifies.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加多个通知时，向时间轴添加多个轨道以保持事物组织是有用的。
- en: In the same frame as `Anim_ProjectileNotify`, *right-click* within the new track
    you created in the previous step. From the `Play Particle Effect`.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章前面 `Anim_ProjectileNotify` 的同一帧中，*右键点击* 在上一步创建的新轨道内。从 `Play Particle Effect`。
- en: Once created, *left-click* to select the new notify and access its `P_Skill_001`
    VFX asset to the `Particle System` parameter.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建，*左键点击* 选择新的通知，并访问其 `P_Skill_001` VFX 资产到 `Particle System` 参数。
- en: 'Once you’ve added this new VFX, you will notice that the VFX is placed almost
    toward the bottom, where the player character’s feet are, but not exactly where
    you want it. This VFX should be placed directly on the floor, or at the base of
    the character. The following screenshot demonstrates this location:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了此新 VFX，你会注意到 VFX 几乎放置在底部，即玩家角色的脚部，但不是你想要的位置。这个 VFX 应该直接放在地板上，或者放在角色的底部。以下截图演示了此位置：
- en: '![Figure 14.27 – The location of the particle notify is not on the ground ](img/Figure_14.27_B18531.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.27 – 粒子通知的位置不在地面上](img/Figure_14.27_B18531.jpg)'
- en: Figure 14.27 – The location of the particle notify is not on the ground
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.27 – 粒子通知的位置不在地面上
- en: To fix this, you need to add a new `Socket` to the player character’s skeleton.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要向玩家角色的骨骼添加一个新的 `Socket`。
- en: Navigate to the `/MainCharacter/Mesh/` directory. *Double-click* the `MainCharacter_Skeleton`
    asset to open it.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `/MainCharacter/Mesh/` 目录。*双击* `MainCharacter_Skeleton` 资产以打开它。
- en: From the `EffectSocket`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `EffectSocket`。
- en: '*Left-click* this socket from the hierarchy of bones to view its current location.
    By default, its location is set to the same position as the **Hips** bone. The
    following screenshot shows this location:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击* 从骨骼层次结构中此插座以查看其当前位置。默认情况下，其位置设置为与 **Hips** 骨相同的位置。以下截图显示了此位置：'
- en: '![Figure 14.28 – The default location of this socket is in the center of the
    player’s skeleton ](img/Figure_14.28_B18531.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.28 – 此插座的默认位置在玩家骨骼的中心](img/Figure_14.28_B18531.jpg)'
- en: Figure 14.28 – The default location of this socket is in the center of the player’s
    skeleton
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.28 – 此插座的默认位置在玩家骨骼的中心。
- en: 'Using the `EffectSocket` so that its position is set to the following:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `EffectSocket` 以使其位置设置为以下：
- en: '[PRE47]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This position will be closer to the ground and the player character’s feet.
    The final location can be seen in the following screenshot:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这个位置将更接近地面和玩家角色的脚。最终位置可以在以下屏幕截图中看到：
- en: '![Figure 14.29 – Moving the socket’s location to the base of the player skeleton
    ](img/Figure_14.29_B18531.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.29 – 将套接字的位置移动到玩家骨骼的底部](img/Figure_14.29_B18531.jpg)'
- en: Figure 14.29 – Moving the socket’s location to the base of the player skeleton
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.29 – 将套接字的位置移动到玩家骨骼的底部
- en: Now that you have a location for the particle notify, return to the `AM_Throw`
    Animation Montage.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你有了粒子通知的位置，返回到 `AM_Throw` 动画蒙太奇。
- en: Within the `Socket Name` parameter. Name it `EffectSocket`.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `套接字名称` 参数中。命名为 `EffectSocket`。
- en: Note
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If `EffectSocket` does not appear via the autocomplete, close and reopen the
    Animation Montage. Once it's reopened, the `EffectSocket` option should appear
    for you.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `EffectSocket` 通过自动完成没有出现，请关闭并重新打开动画蒙太奇。一旦重新打开，`EffectSocket` 选项应该会显示出来。
- en: 'Lastly, the scale of the particle effect is a little too big, so adjust the
    scale of the projectile so that its value is as follows:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，粒子效果的比例有点太大，所以调整投射物的比例，使其值如下：
- en: '[PRE48]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, when the particle effect is played via this notify, its position and scale
    will be correct, as shown here:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当通过此通知播放粒子效果时，其位置和缩放将正确，如图所示：
- en: '![Figure 14.30 – The particle now plays at the base of the player character’s
    skeleton ](img/Figure_14.30_B18531.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.30 – 粒子现在在玩家角色骨骼的底部播放](img/Figure_14.30_B18531.jpg)'
- en: Figure 14.30 – The particle now plays at the base of the player character’s
    skeleton
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.30 – 粒子现在在玩家角色骨骼的底部播放
- en: To add the `Play Sound` notify, add a new track to the **Notifies** timeline
    section; you should have three in total.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加 `Play Sound` 通知，向 **通知** 时间线部分添加一个新轨道；你应该总共有三个。
- en: 'On this new track, and at the same frame position as both the `Play Particle
    Effect` and `Anim_ProjectileNotify` notifies, *right-click* and select the **Play
    Sound** notify from the **Add Notify** selection. The following screenshot shows
    where this notify can be found:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新轨道上，并且与 `Play Particle Effect` 和 `Anim_ProjectileNotify` 通知相同的帧位置，*右键单击*
    并从 **添加通知** 选择中选中 **播放声音** 通知。以下屏幕截图显示了此通知的位置：
- en: '![Figure 14.31 – The Play Sound notify that you learned about earlier in this
    chapter ](img/Figure_14.31_B18531.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.31 – 本章前面提到的播放声音通知](img/Figure_14.31_B18531.jpg)'
- en: Figure 14.31 – The Play Sound notify that you learned about earlier in this
    chapter
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.31 – 本章前面提到的播放声音通知
- en: Next, *left-click* to select the **Play Sound** notify and access its **Details**
    panel.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*左键单击* 选中 **播放声音** 通知并访问其 **详细信息** 面板。
- en: From the `A_Ability_FireballCast_Cue`.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `A_Ability_FireballCast_Cue`。
- en: 'With the sound assigned, when the **Throw** animation is played back, you will
    see the VFX play and you will hear the sound. The **Notifies** tracks should look
    as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配了声音后，当 **投掷** 动画回放时，你会看到 VFX 播放，并且你会听到声音。**通知** 轨道应该如下所示：
- en: '![Figure 14.32 – The final notify set up on the Throw Animation Montage timeline
    ](img/Figure_14.32_B18531.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.32 – 投掷动画蒙太奇时间线上的最终通知设置](img/Figure_14.32_B18531.jpg)'
- en: Figure 14.32 – The final notify set up on the Throw Animation Montage timeline
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.32 – 投掷动画蒙太奇时间线上的最终通知设置
- en: Save the `AM_Throw` asset and use `PIE` to throw the player projectile.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `AM_Throw` 资产并使用 `PIE` 投掷玩家投射物。
- en: 'Now, when you throw the projectile, you will see the particle notify play the
    `P_Skill_001` VFX and you will hear the `A_Ability_FireballCast_Cue` SFX. The
    result will look as follows:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你投掷投射物时，你会看到粒子通知播放 `P_Skill_001` VFX，并且你会听到 `A_Ability_FireballCast_Cue`
    SFX。结果将如下所示：
- en: '![Figure 14.33 – Now, when the player throws the projectile, powerful VFX and
    SFX are played ](img/Figure_14.33_B18531.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.33 – 现在，当玩家投掷投射物时，播放强大的 VFX 和 SFX](img/Figure_14.33_B18531.jpg)'
- en: Figure 14.33 – Now, when the player throws the projectile, powerful VFX and
    SFX are played
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.33 – 现在，当玩家投掷投射物时，播放强大的 VFX 和 SFX
- en: With this final exercise complete, the player now plays powerful VFX and SFX
    when the player projectile is thrown. This gives the throw animation more power
    and it feels like the player character is using a lot of energy to throw the projectile.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个最终练习后，玩家现在在投掷玩家投射物时播放强大的 VFX 和 SFX。这给投掷动画增加了更多力量，感觉玩家角色在投掷投射物时使用了大量能量。
- en: In the final activity, you will use the knowledge you’ve gained from the last
    few exercises to add VFX and SFX to the player projectile when it is destroyed.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终活动中，你将使用从最后几项练习中获得的知识，在玩家投射物被摧毁时添加VFX和SFX。
- en: Activity 14.02 – adding effects for when the projectile is destroyed
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动14.02 – 添加投射物被摧毁时的效果
- en: In this final activity, you will use the knowledge that you’ve gained from adding
    VFX and SFX elements to the player projectile and the enemy character to create
    an explosion effect for when the projectile collides with an object instead. The
    reason we’re adding this additional explosion effect is to add a level of polish
    on top of destroying the projectile when it collides with environmental objects.
    It would look awkward and out of place if the player projectile were to hit an
    object and disappear without any audio or visual feedback from the player.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终活动中，你将使用从为玩家投射物和敌人角色添加VFX和SFX元素中获得的知识，在投射物与物体碰撞时创建爆炸效果。我们添加这个额外的爆炸效果是为了在投射物与环境物体碰撞时摧毁投射物之外增加一个精细度。如果玩家投射物击中物体后消失，没有任何音频或视觉反馈，看起来会显得尴尬和不合适。
- en: You will add both a Particle System and sound cue parameters to the player projectile
    and spawn these elements when the projectile collides with an object.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为玩家投射物添加一个粒子系统和声音提示参数，并在投射物与物体碰撞时生成这些元素。
- en: 'Follow these steps to achieve the expected output:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现预期输出：
- en: Inside the `PlayerProjectile.h` header file, add a new Particle System variable
    and a new sound base variable.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.h`头文件中，添加一个新的粒子系统变量和一个新的声音基础变量。
- en: Name the Particle System variable `DestroyEffect` and name the sound base variable
    `DestroySound`.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将粒子系统变量命名为`DestroyEffect`，将声音基础变量命名为`DestroySound`。
- en: In the `PlayerProjectile.cpp` source file, add the include for `UGameplayStatics`
    to the list of includes.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.cpp`源文件中，将`UGameplayStatics`的包含添加到包含列表中。
- en: Update the `APlayerProjectile::ExplodeProjectile()` function so that it now
    spawns both the `DestroyEffect` and `DestroySound` objects. Return to the UE5
    editor and recompile the new C++ code. Inside the `BP_PlayerProjectile` Blueprint,
    assign the `P_Explosion` VFX, which is already included in your project by default,
    to the `Destroy Effect` parameter of the projectile.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`APlayerProjectile::ExplodeProjectile()`函数，使其现在生成`DestroyEffect`和`DestroySound`对象。返回UE5编辑器并重新编译新的C++代码。在`BP_PlayerProjectile`蓝图内，将默认包含在项目中的`P_Explosion`
    VFX分配给投射物的`Destroy Effect`参数。
- en: Assign the `Explosion_Cue` SFX, which is already included in your project by
    default, to the `Destroy Sound` parameter of the projectile.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认包含在项目中的`Explosion_Cue` SFX分配给投射物的`Destroy Sound`参数。
- en: Save and compile the player projectile Blueprint.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译玩家投射物蓝图。
- en: Use `PIE` to observe the new player projectile’s destruction VFX and SFX.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PIE`观察新的玩家投射物的摧毁VFX和SFX。
- en: 'The expected output is as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 14.34 – Projectile VFX and SFX ](img/Figure_14.34_B18531.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![图14.34 – 投射物VFX和SFX](img/Figure_14.34_B18531.jpg)'
- en: Figure 14.34 – Projectile VFX and SFX
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.34 – 投射物VFX和SFX
- en: With this activity complete, you now have experience with adding polished elements
    to the game. Not only have you added these elements through C++ code, but you’ve
    added elements through other tools from UE5\. At this point, you have enough experience
    to add Particle Systems and audio to your game without having to worry about how
    to implement these features.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个活动后，你现在有在游戏中添加精细元素的经验。你不仅通过C++代码添加了这些元素，还通过UE5的其他工具添加了元素。在这个阶段，你已经有足够的经验在不担心如何实现这些功能的情况下，为你的游戏添加粒子系统和音频。
- en: Note
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: Summary
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the importance of VFX and SFX in the world
    of game development. Using a combination of C++ code and notifies, you were able
    to bring gameplay functionality to the player projectile and the enemy character
    colliding, as well as a layer of polish to this functionality by adding VFX and
    SFX. On top of this, you learned about how objects are spawned and destroyed in
    UE5.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了在游戏开发世界中VFX和SFX的重要性。通过结合C++代码和通知，你能够将游戏玩法功能带给玩家投射物和敌人角色碰撞，并通过添加VFX和SFX为这一功能增添了一层磨光。除此之外，你还学习了在UE5中对象是如何生成和销毁的。
- en: Moreover, you learned about how Animation Montages are played, both from Blueprints
    and through C++. By migrating the logic of playing the **Throw** Animation Montage
    from Blueprint to C++, you learned how both methods work and how to use both implementations
    for your game.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还学习了如何通过蓝图和C++两种方式播放动画蒙太奇。通过将播放**投掷**动画蒙太奇的逻辑从蓝图迁移到C++，你了解了这两种方法的工作原理以及如何将这两种实现用于你的游戏。
- en: By adding a new Animation Notify using C++, you were able to add this notify
    to the `UWorld->SpawnActor()` function and adding a new socket to the player skeleton,
    you were able to spawn the player projectile at the exact frame of the **Throw**
    animation, and at the exact position that you wanted to.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用C++添加新的动画通知，你能够将这个通知添加到`UWorld->SpawnActor()`函数中，并为玩家骨骼添加一个新的套接字，这样你就能在**投掷**动画的精确帧以及在你想放置的确切位置生成玩家投射物。
- en: Lastly, you learned how to use the **Play Particle Effect** and **Play Sound**
    notifies within the **Throw** Animation Montage to add VFX and SFX to the throw
    of the player projectile. This chapter taught you about the different methods
    that exist inside UE5 when it comes to using VFX and SFX for your game.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了如何在**投掷**动画蒙太奇中使用**播放粒子效果**和**播放声音**通知来为玩家投射物的投掷添加VFX和SFX。本章教你关于在UE5中使用VFX和SFX为你的游戏存在的不同方法。
- en: Now that the player projectile can be thrown and destroy enemy characters, it
    is time to implement the final set of mechanics for the game. In the next chapter,
    you will create the collectibles that the player can collect, and you will also
    create a powerup for the player that will improve the player’s movement mechanics
    for a short period.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家投射物可以投掷并摧毁敌人角色，是时候实现游戏的最终一套机制了。在下一章中，你将创建玩家可以收集的物品，同时也会为玩家创建一个可以短暂提升玩家移动机制的道具。
