- en: Chapter 6. Manipulating Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 操作任务
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Registering a task for processing an arbitrary datatype
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册一个任务以处理任意数据类型
- en: Making timers and processing timer events as tasks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建计时器并将计时器事件作为任务处理
- en: Network communication as a task
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络通信作为任务
- en: Accepting incoming connections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受传入的连接
- en: Executing different tasks in parallel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行执行不同的任务
- en: Conveyor tasks processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传送带任务处理
- en: Making a nonblocking barrier
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个非阻塞屏障
- en: Storing an exception and making a task from it
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储异常并从它创建任务
- en: Getting and processing system signals as tasks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将获取和处理系统信号作为任务
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is all about tasks. We'll be calling the functional object a task
    (because it is shorter and better reflects what it shall do). The main idea of
    this chapter is that we can split all the processing, computations, and interactions
    into **functors** (tasks) and process each of those tasks almost independently.
    Moreover, we may not block on some slow operations (such as receiving data from
    a socket or waiting for a time-out), but instead provide a callback task and continue
    working with other tasks. Once the OS finishes the slow operation, our callback
    will be executed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于任务。我们将调用功能对象为任务（因为它更短，更好地反映了它应该做什么）。本章的主要思想是我们可以将所有处理、计算和交互分解为 **functors**（任务），并几乎独立地处理每个任务。此外，我们可能不会在某些慢操作（如从套接字接收数据或等待超时）上阻塞，而是提供一个回调任务并继续与其他任务一起工作。一旦操作系统完成慢操作，我们的回调将被执行。
- en: Before you start
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前
- en: This chapter requires at least a basic knowledge of the first, third, and fifth
    chapters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章至少需要了解第一、第三和第五章。
- en: Registering a task for processing an arbitrary datatype
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册一个任务以处理任意数据类型
- en: 'First of all, let''s take care of the class that will hold all the tasks and
    provide methods for their execution. We were already doing something like this
    in the *Creating a work_queue class* recipe, but some of the following problems
    were not addressed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们关注将持有所有任务并提供执行方法类的结构。我们已经在 *创建 work_queue 类* 的配方中做了类似的事情，但以下一些问题尚未解决：
- en: A task may throw an exception that leads a call to `std::terminate`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个任务可能会抛出一个异常，导致调用 `std::terminate`
- en: An interrupted thread may not notice interruption but will finish its task and
    interrupt only during the next task (which is not what we wanted; we wanted to
    interrupt the previous task)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个被中断的线程可能不会注意到中断，但会完成其任务，并在下一个任务期间中断（这不是我们想要的；我们想要中断上一个任务）
- en: Our `work_queue` class was only storing and returning tasks, but we need to
    add methods for executing existing tasks
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `work_queue` 类只存储和返回任务，但我们需要添加执行现有任务的方法
- en: We need a way to stop processing the tasks
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一种停止处理任务的方法
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe requires linking with the `libboost_system` library. Knowledge of
    `Boost.Bind` and basic knowledge of `Boost.Thread` is also required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要链接到 `libboost_system` 库。还需要了解 `Boost.Bind` 以及对 `Boost.Thread` 的基本了解。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We'll be using `boost::io_service` instead of `work_queue` from the previous
    chapter. There is a reason for doing this, and we'll see it in the following recipes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `boost::io_service` 而不是上一章中的 `work_queue`。这样做有原因，我们将在接下来的配方中看到。
- en: 'Let''s start with the structure that wraps around a user task:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从围绕用户任务的包装结构开始：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For ease of use, we''ll create a function that produces `task_wrapped` from
    the user''s functor:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了便于使用，我们将创建一个函数，从用户的函数对象生成 `task_wrapped`：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we are ready to write the `tasks_processor` class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写 `tasks_processor` 类：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we will add the `push_task` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将添加 `push_task` 方法：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s finish this class by adding the member functions for starting and stopping
    a task''s execution loop:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加启动和停止任务执行循环的成员函数来完成这个类：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is time to test our class. For that, we''ll create a testing function:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是时候测试我们的类了。为此，我们将创建一个测试函数：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `main` function might look like this:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`main` 函数可能看起来像这样：'
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `boost::io_service` variable can store and execute tasks posted to it.
    But we may not post a user''s tasks to it directly because they may throw or receive
    an interruption addressed to other tasks. That is why we wrap a user''s task in
    the `detail::task_wrapped` structure. It resets all the previous interruptions
    by calling:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::io_service`变量可以存储和执行发送给它的任务。但我们可能不能直接将用户的任务发送给它，因为它们可能会抛出或接收针对其他任务的干扰。这就是为什么我们用`detail::task_wrapped`结构包装用户的任务。它通过调用以下方式重置所有之前的干扰：'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And this executes the task within the `try{}catch()` block making sure that
    no exception will leave the `operator()` bounds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在`try{}catch()`块中执行任务，确保没有异常会离开`operator()`的作用域。
- en: The `boost::io_service::run()` method will be getting ready tasks from the queue
    and executing them one by one. This loop is stopped via a call to `boost::io_service::stop()`.
    The `boost::io_service` class will return from the `run()` function if there are
    no more tasks left, so we force it to continue execution using an instance of
    `boost::asio::io_service::work`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::io_service::run()`方法将从队列中获取准备好的任务并逐个执行。这个循环通过调用`boost::io_service::stop()`来停止。如果没有更多任务，`boost::io_service`类将从`run()`函数返回，因此我们使用`boost::asio::io_service::work`的一个实例强制它继续执行。'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **iostream** classes and variables such as `std::cerr` and `std::cout` are
    not thread safe. In real projects, additional synchronization must be used to
    get readable output. For simplicity, we do not do that here.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`iostream`类以及如`std::cerr`和`std::cout`这样的变量不是线程安全的。在实际项目中，必须使用额外的同步来获取可读的输出。为了简单起见，我们这里没有这样做。'
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The C++11 STL library has no `io_service`; however, it (and a large part of
    the `Boost.Asio` library) is proposed as a **Technical Report** (**TR**) as an
    addition to C++.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 STL库没有`io_service`；然而，它（以及`Boost.Asio`库的大部分内容）被提议作为**技术报告**（**TR**）作为C++的补充。
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The following recipes will show you why we chose `boost::io_service` instead
    of our handwritten code
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下菜谱将展示我们为什么选择`boost::io_service`而不是我们手写的代码。
- en: You may consider the `Boost.Asio` documentation to get some examples, tutorials,
    and class references at [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以考虑阅读`Boost.Asio`文档，以获取一些示例、教程和类参考，请访问[http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html)。
- en: You may also read the *Boost.Asio C++ Network Programming* book, which gives
    a smoother introduction to `Boost.Asio` and covers some details that are not covered
    in this book
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以阅读《Boost.Asio C++网络编程》这本书，它对`Boost.Asio`提供了一个更平滑的介绍，并涵盖了本书未涉及的一些细节。
- en: Making timers and processing timer events as tasks
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将计时器和处理计时器事件作为任务
- en: 'It is a common task to check something at specified intervals; for example,
    we need to check some session for an activity once every 5 seconds. There are
    two popular solutions to such a problem: creating a thread or sleeping for 5 seconds.
    This is a very lame solution that consumes a lot of system resources and scales
    badly. We could instead use system specific APIs for manipulating timers asynchronously.
    This is a better solution, but it requires a lot of work and is not very portable
    (until you write many wrappers for different platforms). It also makes you work
    with OS APIs that are not always very nice.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 检查指定间隔内的某些内容是一个常见任务；例如，我们每5秒钟需要检查一些会话的活动。对此类问题有两种流行的解决方案：创建一个线程或睡眠5秒钟。这是一个非常糟糕的解决方案，它会消耗大量的系统资源，并且扩展性很差。我们可以使用特定于系统的API来异步操作计时器，这是一个更好的解决方案，但它需要大量的工作，并且不太便携（直到你为不同的平台编写了许多包装器）。它还让你与那些并不总是很友好的操作系统API打交道。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must know how to use `Boost.Bind` and `Boost.SmartPtr`. See the first recipe
    of this chapter to get information about the `boost::asio::io_service` and `task_queue`
    classes. Link this recipe with the `libboost_system` library.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须知道如何使用`Boost.Bind`和`Boost.SmartPtr`。参见本章的第一道菜谱，以获取有关`boost::asio::io_service`和`task_queue`类的信息。将此菜谱与`libboost_system`库链接。
- en: This recipe is a tricky one, so get ready!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱有点棘手，所以请做好准备！
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This recipe is based on the code from the previous recipe. We just modify the
    `tasks_processor` class by adding new methods to run a task at some specified
    time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱基于前一道菜谱中的代码。我们只是通过添加新方法来修改`tasks_processor`类，以便在指定时间运行任务。
- en: 'Let''s add a method to our `tasks_processor` class for running a task at some
    time:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`tasks_processor`类中添加一个方法，以便在某个时间运行一个任务：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We add a method to our `task_queue` class for running a task after the required
    time duration passes:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为 `task_queue` 类添加了一个方法，用于在所需的时间间隔过后运行一个任务：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s time to take care of the `detail::make_timer_task` function:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候照顾 `detail::make_timer_task` 函数了：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And the final step will be writing a `timer_task` structure:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步将是编写一个 `timer_task` 结构：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'That''s how it all works; the user provides a timeout and a functor to the
    `run_after` function. In it, a `detail::timer_task` object is constructed that
    stores a user provided functor and creates a shared pointer to `boost::asio::deadline_timer`.
    The constructed `detail::timer_task` object is pushed as a functor that must be
    called when the timer is triggered. The `detail::timer_task::operator()` method
    accepts `boost::system::error_code`, which will contain the description of any
    error that occurred while waiting. If no error is occurred, we call the user''s
    functor that is wrapped to catch exceptions (we re-use the `detail::task_wrapped`
    structure from the first recipe). The following diagram illustrates this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有工作的原理；用户向 `run_after` 函数提供超时和一个函数对象。在其中，构建了一个 `detail::timer_task` 对象，该对象存储了一个用户提供的函数对象并创建了一个指向
    `boost::asio::deadline_timer` 的共享指针。构建的 `detail::timer_task` 对象被推送到一个函数对象，该函数对象必须在定时器触发时被调用。`detail::timer_task::operator()`
    方法接受 `boost::system::error_code`，它将包含等待过程中发生的任何错误的描述。如果没有发生错误，我们调用被包裹的用户函数对象来捕获异常（我们重用第一道菜谱中的
    `detail::task_wrapped` 结构）。以下图表说明了这一点：
- en: '![How it works...](img/4880OS_06_01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/4880OS_06_01.jpg)'
- en: Note that we wrapped `boost::asio::deadline_timer` in `boost::shared_ptr` and
    passed the whole `timer_task` functor (including `shared_ptr`) in `timer_->async_wait(*this)`.
    This is done because `boost::asio::deadline_timer` must not be destroyed until
    it is triggered, and storing the `timer_task` functor in `io_service` guarantees
    this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将 `boost::asio::deadline_timer` 包裹在 `boost::shared_ptr` 中，并将整个 `timer_task`
    函数对象（包括 `shared_ptr`）传递给 `timer_->async_wait(*this)`。这样做是因为 `boost::asio::deadline_timer`
    必须在触发之前不被销毁，将 `timer_task` 函数对象存储在 `io_service` 中可以保证这一点。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In short, when a specified amount of time has passed, `boost::asio::deadline_timer`
    will push the user's task to the `boost::asio::io_service queue` class for execution.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当指定的时间经过后，`boost::asio::deadline_timer` 将将用户的任务推送到 `boost::asio::io_service`
    队列类以执行。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some platforms have no APIs to implement timers in a good way, so the `Boost.Asio`
    library emulates the behavior of the asynchronous timer using an additional execution
    thread per `io_service`. Anyways, `Boost.Asio` is one of the most portable and
    effective libraries to deal with timers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台没有提供良好的定时器API，因此 `Boost.Asio` 库通过为每个 `io_service` 创建一个额外的执行线程来模拟异步定时器的行为。无论如何，`Boost.Asio`
    是处理定时器的最便携和最有效的库之一。
- en: See also
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Reading the first recipe from this chapter will teach you the basics of `boost::asio::io_service`.
    The following recipes will provide you with more examples of `io_service` usage
    and will show you how to deal with network communications, signals, and other
    features using `Boost.Asio`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读本章的第一道菜谱将教会你 `boost::asio::io_service` 的基础知识。接下来的菜谱将为你提供更多 `io_service` 用法的示例，并展示如何使用
    `Boost.Asio` 处理网络通信、信号和其他功能。
- en: You may consider the `Boost.Asio` documentation to get some examples, tutorials,
    and class references at [http://www.boost.org/doc/libs/1_53_0/doc/htm](http://www.boost.org/doc/libs/1_53_0/doc/htm)[l/boost_asio.html](http://l/boost_asio.html).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以考虑查看 `Boost.Asio` 文档以获取一些示例、教程和类参考，请访问 [http://www.boost.org/doc/libs/1_53_0/doc/htm](http://www.boost.org/doc/libs/1_53_0/doc/htm)[l/boost_asio.html](http://l/boost_asio.html)。
- en: Network communication as a task
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络通信作为一个任务
- en: Receiving or sending data by network is a slow operation. While packets are
    received by the machine, and while the OS verifies them and copies the data to
    the user-specified buffer, multiple seconds may pass. And we may be able to do
    a lot of work instead of waiting. Let's modify our `tasks_processor` class so
    that it will be capable of sending and receiving data in an asynchronous manner.
    In nontechnical terms, we ask it to "receive at least N bytes from the remote
    host and after that is done, call our functor. And by the way, do not block on
    this call". Those readers who know about `libev`, `libevent`, or `Node.js` will
    find a lot of familiar things in this recipe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络接收或发送数据是一个缓慢的操作。当机器接收数据包，操作系统验证它们并将数据复制到用户指定的缓冲区时，可能需要几秒钟的时间。而我们可能能够做很多工作而不是等待。让我们修改我们的`tasks_processor`类，使其能够以异步方式发送和接收数据。用非技术术语来说，我们要求它“从远程主机接收至少N个字节，然后完成这个操作后，调用我们的函数。顺便说一下，不要在这个调用上阻塞”。那些了解`libev`、`libevent`或`Node.js`的读者会发现这个配方中有许多熟悉的东西。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The previous and first recipes from this chapter are required to adopt this
    material more easily. Knowledge of `boost::bind`, `boost::shared_ptr`, and placeholders
    are required to get through it. Also, information on linking this recipe with
    the `libboost_system` library is required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地采用这一材料，需要了解`boost::bind`、`boost::shared_ptr`和占位符。还需要了解如何将此配方与`libboost_system`库链接的信息。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's extend the code from the previous recipe by adding methods to create connections.
    A connection would be represented by a `tcp_connection_ptr` class, which must
    be constructed using only `tasks_processor` (As an analogy, `tasks_processor`
    is a factory for constructing such connections).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加创建连接的方法来扩展前面配方中的代码。一个连接将由`tcp_connection_ptr`类表示，它必须仅使用`tasks_processor`来构造（作为一个类比，`tasks_processor`是构造此类连接的工厂）。
- en: 'We need a method in `tasks_processor` to create sockets to endpoints (we will
    be calling them connections):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`tasks_processor`中添加一个方法来创建端点（我们将称它们为连接）的套接字：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ll need a lot of header files included as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含以下许多头文件：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The class `tcp_connection_ptr` is required to manage connections. It owns the
    socket and manages its lifetime. It's just a thin wrapper around `boost::shared_ptr<boost::asio::ip::tcp::socket>`
    that hides `Boost.Asio` from the user.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tcp_connection_ptr`类需要管理连接。它拥有套接字并管理其生命周期。它只是`boost::shared_ptr<boost::asio::ip::tcp::socket>`的一个薄包装器，它隐藏了`Boost.Asio`对用户。'
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `tcp_connection_ptr` class will need methods for reading data:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tcp_connection_ptr`类将需要读取数据的方法：'
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Methods for writing data are also required:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要编写数据的方法：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will also add a method to shutdown the connection:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将添加一个关闭连接的方法：
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now the library user can use the preceding class like this to send the data:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，图书馆用户可以使用前面的类这样发送数据：
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Users may also use it like this to receive data:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户也可以这样使用它来接收数据：
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And this is how a library user may handle the received data:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是图书馆用户可能处理接收到的数据的方式：
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: All the interesting things happen in the `async_*` function's call. Just as
    in the case of timers, asynchronous calls return immediately without executing
    a function. They only tell the `boost::asio::io_service` class to execute the
    callback task after some operation (for example, reading data from the socket)
    finishes. `io_service` will execute our function in one of the threads that called
    the `io_service::run()` method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有有趣的事情都发生在`async_*`函数的调用中。就像定时器的情况一样，异步调用会立即返回而不执行函数。它们只告诉`boost::asio::io_service`类在某个操作（例如从套接字读取数据）完成后执行回调任务。`io_service`将在调用`io_service::run()`方法的线程之一中执行我们的函数。
- en: 'The following diagram illustrates this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这一点：
- en: '![How it works...](img/4880OS_06_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4880OS_06_02.jpg)'
- en: Now, let's examine this step-by-step.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步地检查这个步骤。
- en: The `tcp_connection_ptr` class holds a shared pointer to `boost::asio::ip::tcp::socket`,
    which is a `Boost.Asio` wrapper around native sockets. We do not want to give
    a user the ability to use this wrapper directly because it has synchronous methods
    whose usage we are trying to avoid.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcp_connection_ptr`类持有对`boost::asio::ip::tcp::socket`的共享指针，它是围绕本地套接字的`Boost.Asio`包装器。我们不希望用户能够直接使用这个包装器，因为它有同步方法，我们正在试图避免使用这些方法。'
- en: The first constructor accepts a pointer to the socket (and will be used in our
    next recipe). This constructor won't be used by the user because the `boost::asio::ip::tcp::socket`
    constructor requires a reference to `boost::asio::io_service`, which is hidden
    inside `tasks_processor`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个构造函数接受套接字的指针（并将用于我们的下一个配方）。这个构造函数不会由用户使用，因为 `boost::asio::ip::tcp::socket`
    构造函数需要一个对 `boost::asio::io_service` 的引用，它隐藏在 `tasks_processor` 中。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, some users of our library could be smart enough to create an instance
    of `boost::asio::io_service`, initialize sockets, and push tasks to that instance.
    Moving the `Boost.Asio` library's contents into the source file and implementing
    the **Pimpl idiom** will help you to protect users from shooting their own feet,
    but we won't implement it here for simplicity. Another way to do things is to
    declare the `tasks_processor` class as a friend to `tcp_connection_ptr` and make
    the `tcp_connection_ptr` constructors private.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们库的一些用户可能足够聪明，能够创建一个 `boost::asio::io_service` 的实例，初始化套接字，并将任务推送到该实例。将 `Boost.Asio`
    库的内容移动到源文件并实现 **Pimpl 习语**可以帮助你保护用户免受自己伤害，但为了简单起见，我们不会在这里实现它。另一种做事的方式是将 `tasks_processor`
    类声明为 `tcp_connection_ptr` 的朋友，并使 `tcp_connection_ptr` 构造函数私有。
- en: The second constructor accepts a remote endpoint and a reference to `io_service`.
    There you may see how the socket is connected to an endpoint using the `socket_->connect(endpoint)`
    method. Also, this constructor should not be used by the user; the user should
    use `tasks_processor::create_connection` instead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数接受一个远程端点和 `io_service` 的引用。在那里，你可以看到如何使用 `socket_->connect(endpoint)`
    方法将套接字连接到端点。此外，这个构造函数不应该由用户使用；用户应该使用 `tasks_processor::create_connection` 代替。
- en: 'Special care should be taken while using the `async_write` and `async_read`
    functions. Socket and buffer must not be destructed until the asynchronous operation
    is completed; that is why we bind `shared_ptr` to the functional object when calling
    the `async_*` functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `async_write` 和 `async_read` 函数时应该格外小心。套接字和缓冲区必须在异步操作完成之前不能被销毁；这就是为什么在调用
    `async_*` 函数时我们将 `shared_ptr` 绑定到功能对象：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Binding the shared pointer to the functional object, which will be called at
    the end of the asynchronous operation, guarantees that at least one instance of
    `boost::shared_ptr` to the connection and data exists. This means that both connection
    and data won't be destroyed until the functional object destructor is called.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将共享指针绑定到将在异步操作结束时调用的功能对象，确保至少存在一个 `boost::shared_ptr` 的连接和数据实例。这意味着连接和数据将不会在功能对象析构函数被调用之前被销毁。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Boost.Asio` may copy functors and that is why we used a `boost::shared_ptr<std::string>`
    class instead of passing the `std::string` class by value (which would invalidate
    `boost::asio::buffer(*data)` and lead to a segmentation fault).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Asio` 可能会复制函数对象，这就是为什么我们使用 `boost::shared_ptr<std::string>` 类而不是按值传递
    `std::string` 类（这将使 `boost::asio::buffer(*data)` 无效并导致段错误）。'
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Take a closer look at the `finsh_socket_auth_task` function. It checks for `err
    != boost::asio::error::eof`. This is done because the end of a data input is treated
    as an error; however, this may also mean that the end host closed the socket,
    which is not always bad (in our example, we treat it as a nonerror behavior).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看 `finsh_socket_auth_task` 函数。它检查 `err != boost::asio::error::eof`。这样做是因为数据输入的末尾被视为一个错误；然而，这也可能意味着端点主机关闭了套接字，这并不总是坏事（在我们的例子中，我们将其视为非错误行为）。
- en: '`Boost.Asio` is not a part of C++11, but it is proposed for inclusion in C++,
    and we may see it (or at least some parts of it) included in the next TR.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Asio` 并不是 C++11 的一部分，但它被提议包含在 C++ 中，我们可能会在下一个 TR 中看到它（或者至少它的某些部分）被包含。'
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the official documentation to `Boost.Asio` for more examples, tutorials,
    and full references at [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html),
    as well as an example of how to use the UDP and ICMP protocols. For readers familiar
    with the BSD socket API, the [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/overview/networking/bsd_sockets.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/overview/networking/bsd_sockets.html)
    page provides information about what a BSD call looks like in `Boost.Asio`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html)的官方文档，了解更多关于`Boost.Asio`的示例、教程和完整参考，以及如何使用UDP和ICMP协议的示例。对于熟悉BSD套接字API的读者，[http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/overview/networking/bsd_sockets.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/overview/networking/bsd_sockets.html)页面提供了关于在`Boost.Asio`中BSD调用看起来像什么的信息。
- en: Read the *Recording the parameters of function* and *Binding a value as a function
    parameter* recipes from [Chapter 1](ch01.html "Chapter 1. Starting to Write Your
    Application"), *Starting to Write Your Application*, for more information about
    `Boost.Bind`. The *Reference counting of pointers to classes used across methods*
    recipe from [Chapter 3](ch03.html "Chapter 3. Managing Resources"), *Managing
    Resources*, will give you more information about what the `boost::shared_ptr`
    class does.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Boost.Bind`的更多信息，请阅读[第1章](ch01.html "第1章。开始编写您的应用程序")中的*记录函数参数*和*将值绑定为函数参数*菜谱，*开始编写您的应用程序*。第3章[管理资源](ch03.html
    "第3章。管理资源")中的*跨方法使用类指针的引用计数*菜谱将为您提供更多关于`boost::shared_ptr`类所做工作的信息。
- en: You may also read the book *Boost.Asio C++ Network Programming*, *Packt Publishing*,
    which describes `Boost.Asio` in more detail.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以阅读《Boost.Asio C++网络编程》这本书，*Packt Publishing*，它更详细地描述了`Boost.Asio`。
- en: Accepting incoming connections
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受传入的连接
- en: A server side working with a network usually looks like a sequence where we
    first get data, then process it, and then send the result. Imagine that we are
    creating some kind of authorization server that will process a huge number of
    requests per second. In that case, we will need to receive and send data asynchronously
    and process tasks in multiple threads.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络一起工作的服务器通常看起来像这样一个序列：我们首先获取数据，然后处理它，最后发送结果。想象一下，我们正在创建一种授权服务器，它每秒将处理大量的请求。在这种情况下，我们需要异步接收和发送数据，并在多个线程中处理任务。
- en: In this recipe, we'll see how to extend our `tasks_processor` class to accept
    and process incoming connections, and in the next recipe, we'll see how to make
    it multithreaded.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何扩展我们的`tasks_processor`类以接受和处理传入的连接，在下一个菜谱中，我们将看到如何使其多线程化。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires a good knowledge of `boost::asio::io_service` basics as
    described in the first and third recipes of this chapter. Some knowledge of network
    communications will be of help to you. Knowledge of `boost::bind, boost::function`,
    `boost::shared_ptr`, and information from at least the two previous recipes is
    also required. Don't forget to link this example with `libboost_system`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱需要您对`boost::asio::io_service`基础知识有很好的了解，这些知识在本书的第一和第三道菜谱中有描述。一些关于网络通信的知识将有助于您。了解`boost::bind,
    boost::function`, `boost::shared_ptr`以及至少前两道菜谱中的信息也是必需的。别忘了将此示例与`libboost_system`链接。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Just as in the previous recipes, we'll be adding new methods to our `tasks_processor`
    class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在前面的菜谱中一样，我们将向我们的`tasks_processor`类添加新方法。
- en: 'First of all, we need to add a function that starts listening on a specified
    port:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要添加一个在指定端口上开始监听的函数：
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will also add a `std::map` variable that holds all the listeners:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将添加一个`std::map`变量来保存所有监听器：
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And a function to stop the listener:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及一个用于停止监听器的函数：
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we need to take care of the `detail::tcp_listener` class itself. It must
    have an acceptor:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要关注`detail::tcp_listener`类本身。它必须有一个接受者：
- en: '[PRE25]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And a function that will be called on a successful accept:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及一个在成功接受时将被调用的函数：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is what a function for starting an accept will look like:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个用于启动接受的函数的样子：
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A function to stop accepting is written like this:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止接受的函数编写如下：
- en: '[PRE28]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And that is our wrapper function that will be called on a successful accept:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们将在成功接受时调用的包装函数：
- en: '[PRE29]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The function `add_listener` just checks that we have no listeners on the specified
    port already, constructs a new `detail::tcp_listener`, and adds it to the `listeners_`
    list.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_listener`函数只是检查我们是否已经在指定的端口上没有监听器，构造一个新的`detail::tcp_listener`，并将其添加到`listeners_`列表中。'
- en: When we construct `boost::asio::ip::tcp::acceptor` specifying the endpoint (see
    step 5), it opens a socket at the specified address.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构造`boost::asio::ip::tcp::acceptor`并指定端点（见步骤5）时，它将在指定的地址上打开一个套接字。
- en: 'Calling `async_accept(socket, handler)` for `boost::asio::ip::tcp::acceptor`
    makes a call to our handler when the incoming connection is accepted. When a new
    connection comes in, `acceptor_` binds this connection to a socket and pushes
    the ready task to execute the handler in `task_queue` (in `boost::asio::io_service`).
    As we understood from the previous recipe, all the `async_*` calls return immediately
    and `async_accept` is not a special case, so it won''t call the handler directly.
    Let''s take a closer look at our handler:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对`boost::asio::ip::tcp::acceptor`的`async_accept(socket, handler)`调用，当接受传入连接时将调用我们的处理程序。当有新的连接进入时，`acceptor_`将此连接绑定到一个套接字，并将准备好的任务推送到`task_queue`（在`boost::asio::io_service`中）以执行处理程序。正如我们从先前的配方中理解的那样，所有的`async_*`调用都会立即返回，`async_accept`不是一个特殊情况，因此它不会直接调用处理程序。让我们更仔细地看看我们的处理程序：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We need an instance of the current class to be alive when an accepting operation
    occurs, so we provide a `boost::shared_ptr` variable as a second parameter for
    `boost::bind` (we do it via `this->shared_from_this()` call). We also need to
    keep the socket alive, so we provide it as a third parameter. The last parameter
    is a placeholder (such as `_1` and `_2` for `boost::bind`) that says where the
    `async_accept` function should put the `error` variable into your method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生接受操作时，我们需要当前类的实例保持活跃，因此我们为`boost::bind`提供了一个`boost::shared_ptr`变量作为第二个参数（我们通过`this->shared_from_this()`调用来实现）。我们还需要保持套接字活跃，因此将其作为第三个参数提供。最后一个参数是一个占位符（例如`_1`和`_2`对于`boost::bind`），它说明了`async_accept`函数应该将`error`变量放在你的方法中的位置。
- en: Now let's take a closer look at our `handle_accept` method. Calling the `push_task()`
    method is required to restart accepting our `acceptor_`. After that, we will check
    for errors and if there are no errors, we will bind the user-provided handler
    to `tcp_connection_ptr`, make an instance of `task_wrapped` from it (required
    for correctly handling exceptions and interruption points), and execute it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看看我们的`handle_accept`方法。调用`push_task()`方法是必需的，以便重新启动`acceptor_`的接受。之后，我们将检查错误，如果没有错误，我们将用户提供的处理程序绑定到`tcp_connection_ptr`，从它创建一个`task_wrapped`实例（这对于正确处理异常和中断点是有必要的），并执行它。
- en: Now let's take a look at the `remove_listener()` method. On call, it will find
    a listener in the list and call `stop()` for it. Inside `stop()`, we will call
    `close()` for an acceptor, return to the `remove_listener` method, and erase the
    shared pointer to `tcp_listener` from the map of listeners. After that, shared
    pointers to `tcp_listener` remain only in one accept task.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`remove_listener()`方法。在调用时，它将在列表中找到一个监听器并对其调用`stop()`。在`stop()`内部，我们将对接受器调用`close()`，然后返回到`remove_listener`方法，并从监听器映射中删除指向`tcp_listener`的共享指针。之后，指向`tcp_listener`的共享指针仅剩在一个接受任务中。
- en: When we call `stop()` for an acceptor, all of its asynchronous operations will
    be canceled and handlers will be called. If we take a look at the `handle_accept`
    method in the last step, we'll see that in case of an error (or stopped acceptor),
    no more accepting tasks will be added.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为接受器调用`stop()`时，它所有的异步操作都将被取消，并且将调用处理程序。如果我们查看上一步中的`handle_accept`方法，我们会看到在发生错误（或停止的接受器）的情况下，不会添加更多的接受任务。
- en: After all the handlers are called, no shared pointer to the acceptor remains
    and a destructor for `tcp_connection` will be called.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有处理程序被调用之后，没有接受器的共享指针将保留，并且将调用`tcp_connection`的析构函数。
- en: There's more...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We did not use all the features of the `boost::asio::ip::tcp::acceptor` class.
    It can bind to a specific IPv6 or IPv4 address, if we provide a specific `boost::asio::ip::tcp::endpoint`.
    You may also get a native socket via the `native_handle()` method and use some
    OS-specific calls to tune the behavior. You may set up some options for `acceptor_`
    by calling `set_option`. For example, this is how you may force an acceptor to
    reuse the address:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用`boost::asio::ip::tcp::acceptor`类的所有功能。如果我们提供一个特定的`boost::asio::ip::tcp::endpoint`，它可以绑定到特定的IPv6或IPv4地址。你也可以通过`native_handle()`方法获取本地套接字，并使用一些特定于操作系统的调用来调整行为。你可以通过调用`set_option`为`acceptor_`设置一些选项。例如，这是如何强制接受器重用地址的：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Reusing the address provides an ability to restart the server quickly after
    it was terminated without correct shutdown. After the server was terminated, a
    socket may be opened for some time and you won't be able to start the server on
    the same address without the `reuse_address` option.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重新使用地址提供了一种在服务器正确关闭后快速重新启动服务器的功能。服务器终止后，套接字可能打开一段时间，如果没有 `reuse_address` 选项，你将无法在相同的地址上启动服务器。
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Starting this chapter from the beginning is a good idea to get much more information
    about `Boost.Asio`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本章的开始部分开始，这是一个获取更多关于 `Boost.Asio` 信息的不错主意。
- en: See the official documentation of `Boost.Asio` for more examples, tutorials,
    and a complete reference at [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见 `Boost.Asio` 的官方文档，了解更多示例、教程和完整的参考信息，请访问 [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html)。
- en: Read the *Reordering the parameters of function* and *Binding a value as a function
    parameter* recipes from [Chapter 1](ch01.html "Chapter 1. Starting to Write Your
    Application"), *Starting to Write Your Application*, for more information about
    `Boost.Bind`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 [第1章](ch01.html "第1章。开始编写您的应用程序") 中关于 *重新排序函数参数* 和 *将值绑定为函数参数* 的食谱，以获取更多关于
    `Boost.Bind` 的信息。
- en: The *Reference counting of pointers to classes used across methods* recipe in
    [Chapter 3](ch03.html "Chapter 3. Managing Resources"), *Managing Resources*,
    will give you more information about what `boost::shared_ptr` does.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。管理资源") 中关于 *跨方法使用类指针的引用计数* 的食谱将为你提供更多关于 `boost::shared_ptr`
    做了什么的信息。'
- en: Executing different tasks in parallel
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行执行不同的任务
- en: Now it is time to make our `tasks_queue` process tasks in multiple threads.
    How hard could this be?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让我们的 `tasks_queue` 在多个线程中处理任务了。这能有多难？
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to read the first recipe from this chapter. Some knowledge of
    multithreading is also required, especially reading the *Manipulating a group
    of threads* recipe in [Chapter 5](ch05.html "Chapter 5. Multithreading"), *Multithreading*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要阅读本章的第一篇食谱。还需要了解一些多线程知识，特别是阅读 [第5章](ch05.html "第5章。多线程") 中关于 *操纵一组线程* 的食谱。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'All we need to do is to add the `start_multiple` method to our `tasks_queue`
    class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是将 `start_multiple` 方法添加到我们的 `tasks_queue` 类中：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And now we are able to do much more work, as illustrated in the following diagram:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以做更多的工作，如下面的图示所示：
- en: '![How to do it...](img/4880OS_06_03.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/4880OS_06_03.jpg)'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::asio::io_service::run` method is thread safe. Almost all the methods
    of `Boost.Asio` are thread safe, so all we need to do is run the `boost::asio::io_service::run`
    method from different threads.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::asio::io_service::run` 方法是线程安全的。几乎所有的 `Boost.Asio` 方法都是线程安全的，所以我们只需要从不同的线程中运行
    `boost::asio::io_service::run` 方法。'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are executing tasks that modify a common resource, you will need to add
    mutexes around that resource.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在执行修改公共资源的任务，你将需要在那个资源周围添加互斥锁。
- en: See the call to `boost::thread::hardware_concurrency()`? It returns the number
    of threads that can be run concurrently. But it is just a hint and may sometimes
    return a `0` value, which is why we are calling the `std::max` function for it.
    This ensures that `threads_count` will store at least the value `1`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 看到对 `boost::thread::hardware_concurrency()` 的调用吗？它返回可以同时运行的线程数。但它只是一个提示，有时可能会返回一个
    `0` 值，这就是为什么我们调用 `std::max` 函数的原因。这确保了 `threads_count` 至少存储了 `1` 的值。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We wrapped `std::max` in parenthesis because some popular compilers define the
    `min()` and `max()` macros, so we need additional tricks to work-around this.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `std::max` 放在括号中，因为一些流行的编译器定义了 `min()` 和 `max()` 宏，所以我们需要额外的技巧来解决这个问题。
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::thread::hardware_concurrency()` function is a part of C++11; you
    will find it in the `<thread>` header of the `std::` namespace. However, not all
    the `boost::asio` classes are part of C++11 (but they are proposed for inclusion,
    so we may see them in the next Technical Report (TR) for C++).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread::hardware_concurrency()` 函数是 C++11 的一部分；你将在 `std::` 命名空间中的 `<thread>`
    头文件中找到它。然而，并不是所有的 `boost::asio` 类都是 C++11 的一部分（但它们被提议包含在内，所以我们可能会在下一个技术报告（TR）中看到它们）。'
- en: See also
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the `Boost.Asio` documentation for more examples and information about different
    classes at [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html)上的`Boost.Asio`文档，获取更多示例和有关不同类的信息。
- en: See the `Boost.Thread` documentation for information about `boost::thread_group`
    and `boost::threads` at [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)上的`Boost.Thread`文档，了解有关`boost::thread_group`和`boost::threads`的信息。
- en: Recipes from [Chapter 5](ch05.html "Chapter 5. Multithreading"), *Multithreading*,
    (especially the last recipe called *Manipulating a group of threads*) will give
    you information about `Boost.Thread` usage
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。多线程")中的食谱（特别是最后一个名为“操作线程组”的食谱）将为您提供有关`Boost.Thread`使用的更多信息。'
- en: The *Binding a value as a function parameter* recipe will help you to understand
    the `boost::``bind` function better
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “将值绑定为函数参数”的食谱将帮助您更好地理解`boost::bind`函数。
- en: Conveyor tasks processing
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传送带任务处理
- en: Sometimes there is a requirement to process tasks within a specified time interval.
    Compared to previous recipes, where we were trying to process tasks in the order
    of their appearance in the queue, this is a big difference.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要在一个指定的时间间隔内处理任务。与之前尝试按任务在队列中出现的顺序处理任务的食谱相比，这是一个很大的不同。
- en: Consider an example where we are writing a program that connects two subsystems,
    one of which produces data packets and the other writes modified data to the disk
    (something like this can be seen in video cameras, sound recorders, and other
    devices). We need to process data packets one by one, smoothly with the least
    jitter, and in multiple threads.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们正在编写一个程序，该程序连接两个子系统，其中一个生成数据包，另一个将修改后的数据写入磁盘（这种类型的东西可以在视频摄像头、录音机和其它设备中看到）。我们需要逐个处理数据包，以最小的抖动平滑处理，并在多个线程中处理。
- en: 'Our previous `tasks_queue` was bad at processing tasks in a specified order:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的`tasks_queue`在按指定顺序处理任务方面做得不好：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So how can we solve this?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们该如何解决这个问题呢？
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of `boost::asio::io_service` is required for this recipe; read
    at least the first recipe from this chapter. The *Creating a work_queue class*
    recipe from [Chapter 5](ch05.html "Chapter 5. Multithreading"), *Multithreading*,
    is required for understanding this example. Code must be linked against the `boost_thread`
    library.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，需要了解`boost::asio::io_service`的基本知识；至少阅读本章的第一个食谱。为了理解这个例子，需要了解[第5章](ch05.html
    "第5章。多线程")中“创建一个工作队列类”的食谱。代码必须链接到`boost_thread`库。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This recipe is based on the code of the `work_queue` class from the *Creating
    a work_queue class* recipe of [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*. We'll make some modifications and will be using a few instances
    of that class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱基于[第5章](ch05.html "第5章。多线程")中“创建一个工作队列类”食谱的`work_queue`类的代码。我们将进行一些修改，并使用该类的一些实例。
- en: 'Let''s start by creating separate queues for data decoding, data compressing,
    and data sending:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先为数据解码、数据压缩和数据发送创建单独的队列：
- en: '[PRE34]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now it is time to refactor the operator `<<` and split it into multiple functions:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是重构操作符`<<`并将其拆分为多个函数的时候了：
- en: '[PRE35]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our `work_queue` class from [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, had no `stop()` function. Let''s add it:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在第5章[第5章。多线程](ch05.html "第5章。多线程")中的`work_queue`类没有`stop()`函数。让我们添加它：
- en: '[PRE36]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now the `work_queue` class can be stopped. The `pop_task()` method will return
    empty tasks if `work_queue` is stopped and no further tasks remain in the `tasks_`
    variable.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在可以停止`work_queue`类。如果`work_queue`被停止且`tasks_`变量中没有更多的任务，`pop_task()`方法将返回空的任务。
- en: 'After doing all that is shown in step 3, we can write the code like this:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成第3步中显示的所有操作后，我们可以编写如下代码：
- en: '[PRE37]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That is all! Now we only need to start the conveyor:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那就是全部了！现在我们只需要启动传送带：
- en: '[PRE38]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The conveyor can be stopped like this:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以这样停止传送带：
- en: '[PRE39]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The trick is to split the processing of a single data packet into some equally
    small subtasks and process them one by one in different `work_queues`. In this
    example, we can split the data process into data decoding, data compression, and
    data send.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是将单个数据包的处理分解成一些同样小的子任务，并在不同的`work_queues`中逐个处理它们。在本例中，我们可以将数据处理分解为数据解码、数据压缩和数据发送。
- en: 'The processing of six packets, ideally, would look like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，处理六个数据包的过程将看起来像这样：
- en: '| Time | Receiving | Decoding | Compressing | Sending |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 时间 | 接收 | 解码 | 压缩 | 发送 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `Tick 1:` | `packet #1` |   |   |   |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `Tick 1:` | `数据包 #1` |   |   |   |'
- en: '| `Tick 2:` | `packet #2` | `packet #1` |   |   |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `Tick 2:` | `数据包 #2` | `数据包 #1` |   |   |'
- en: '| `Tick 3:` | `packet #3` | `packet #2` | `packet #1` |   |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `Tick 3:` | `数据包 #3` | `数据包 #2` | `数据包 #1` |   |'
- en: '| `Tick 4:` | `packet #4` | `packet #3` | `packet #2` | `packet #1` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `Tick 4:` | `数据包 #4` | `数据包 #3` | `数据包 #2` | `数据包 #1` |'
- en: '| `Tick 5:` | `packet #5` | `packet #4` | `packet #3` | `packet #2` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `Tick 5:` | `数据包 #5` | `数据包 #4` | `数据包 #3` | `数据包 #2` |'
- en: '| `Tick 6:` | `packet #6` | `packet #5` | `packet #4` | `packet #3` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `Tick 6:` | `数据包 #6` | `数据包 #5` | `数据包 #4` | `数据包 #3` |'
- en: '| `Tick 7:` |   | `packet #6` | `packet #5` | `packet #4` |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `Tick 7:` |   | `数据包 #6` | `数据包 #5` | `数据包 #4` |'
- en: '| `Tick 8:` |   |   | `packet #6` | `packet #5` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `Tick 8:` |   |   | `数据包 #6` | `数据包 #5` |'
- en: '| `Tick 9:` |   |   |   | `packet #6` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `Tick 9:` |   |   |   | `数据包 #6` |'
- en: However, our world is not ideal, so some tasks may finish faster than others.
    For example, receiving may go faster than decoding and in that case, the decoding
    queue will be holding a set of tasks to be done. We did not use `io_service` in
    our example because it does not guarantee that posted tasks will be executed in
    order of their posting.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的世界并不完美，所以一些任务可能比其他任务完成得更快。例如，接收可能比解码快，在这种情况下，解码队列将保留一组待完成的任务。我们没有在我们的示例中使用`io_service`，因为它不能保证按任务提交的顺序执行已提交的任务。
- en: There's more...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All the tools used to create a conveyor in this example are available in C++11,
    so nothing would stop you creating the same things without Boost on a C++11 compatible
    compiler. However, Boost will make your code more portable, and usable on C++03
    compilers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中创建传送带所使用的所有工具都可在C++11中找到，因此没有任何东西会阻止你在C++11兼容的编译器上创建相同的东西而不使用Boost。然而，Boost会使你的代码更易于移植，并且可以在C++03编译器上使用。
- en: See also
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: This technique is well known and used by processor developers. See [http://en.wikipedia.org/wiki/Instruction_pipeline](http://en.wikipedia.org/wiki/Instruction_pipeline).
    Here you will find a brief description of all the characteristics of the conveyor.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术广为人知，并被处理器开发者所使用。参见[指令流水线](http://en.wikipedia.org/wiki/Instruction_pipeline)。在这里，你可以找到关于传送带所有特性的简要描述。
- en: The *Creating a work_queue* *class* recipe from [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, and the *Binding a value as a function parameter* recipe from
    [Chapter 1](ch01.html "Chapter 1. Starting to Write Your Application"), *Starting
    to Write Your Application*, will give you more information about methods used
    in this recipe.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[第5章](ch05.html "第5章。多线程")的*创建工作队列* *类*配方和[第1章](ch01.html "第1章。开始编写您的应用程序")的*将值绑定为函数参数*配方中，*开始编写您的应用程序*，将为您提供有关在此配方中使用的方法的更多信息。
- en: Making a nonblocking barrier
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作非阻塞屏障
- en: In multithreaded programming, there is an abstraction called **barrier** . It
    stops execution threads that reach it until the requested number of threads are
    not blocked on it. After that, all the threads are released and they continue
    with their execution. Consider the following example of where it can be used.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程编程中，有一个称为**屏障**的抽象。它阻止到达它的执行线程，直到请求的线程数不是阻塞在它上面。之后，所有线程都会被释放，并继续执行。考虑以下示例，看看它可以用在哪里。
- en: 'We want to process different parts of the data in different threads and then
    send the data:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在不同线程中处理数据的不同部分，然后发送数据：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `data_barrier.wait()` method blocks until all the threads fill the data.
    After that, all the threads are released; the thread with the index `0` will compute
    data to be sent using `compute_send_data(data)`, while others are again waiting
    at the barrier as shown in the following diagram:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_barrier.wait()`方法会阻塞，直到所有线程填充数据。之后，所有线程都会被释放；索引为`0`的线程将使用`compute_send_data(data)`计算要发送的数据，而其他线程则再次在屏障处等待，如下面的图所示：'
- en: '![Making a nonblocking barrier](img/4880OS_06_04.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![制作非阻塞屏障](img/4880OS_06_04.jpg)'
- en: Looks lame, isn't it?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很笨拙，不是吗？
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe requires knowledge of the first recipe of this chapter. Knowledge
    of `Boost.Bind` and `Boost.Thread` is also required. Code from this recipe requires
    linking against the `boost_thread` and `boost_system` libraries.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要了解本章的第一个配方。还需要了解`Boost.Bind`和`Boost.Thread`。本配方的代码需要链接到`boost_thread`和`boost_system`库。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We do not need to block at all! Let's take a closer look at the example. All
    we need to do is to post four `fill_data` tasks and make the last finished task
    call `compute_send_data(data)`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根本不需要阻塞！让我们更仔细地看看这个例子。我们只需要发布四个`fill_data`任务，并让最后一个完成的任务调用`compute_send_data(data)`。
- en: We'll need the `tasks_processor` class from the first recipe; no changes to
    it are needed.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从第一个配方中获取`tasks_processor`类；不需要对其进行任何更改。
- en: 'Instead of a barrier, we''ll be using the atomic variable:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是使用屏障，我们将使用原子变量：
- en: '[PRE41]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our new runner function will look like this:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新运行函数将看起来像这样：
- en: '[PRE42]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Only the main function will change slightly, as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有主函数会略有变化，如下所示：
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We don't block as no threads will be waiting for resources. Instead of blocking,
    we count the tasks that finished filling the data. This is done by the `counter
    atomic` variable. The last remaining task will have a `counter` variable equal
    to `data_t::static_size`. It will only need to compute and send the data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会阻塞，因为没有线程会等待资源。而不是阻塞，我们通过`counter atomic`变量来计算完成填充数据的任务数。最后一个剩余的任务将有一个`counter`变量等于`data_t::static_size`。它只需要计算并发送数据。
- en: After that, we check for the exit condition (1000 iterations are done), and
    post the new data by filling tasks to the queue.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们检查退出条件（已完成1000次迭代），并通过向队列中填充任务来发布新数据。
- en: There's more...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Is this solution better? Well, first of all, it scales better:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案更好吗？首先，它的可扩展性更好：
- en: '![There''s more...](img/4880OS_06_05.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/4880OS_06_05.jpg)'
- en: This method can also be more effective for situations where a program does a
    lot of different work. Because no threads are waiting in barriers, free threads
    may do other work while one of the threads computes and sends the data.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于程序执行大量不同工作的情况也可能更有效。因为没有线程在屏障中等待，空闲线程可以在其中一个线程计算和发送数据的同时执行其他工作。
- en: All the tools used for this example are available in C++11 (you'll only need
    to replace `io_service` inside `tasks_processor` with `work_queue` from [Chapter
    5](ch05.html "Chapter 5. Multithreading"), *Multithreading*).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此示例的所有工具都可在C++11中找到（您只需将`tasks_processor`中的`io_service`替换为[第5章](ch05.html
    "第5章。多线程")中的`work_queue`即可）。
- en: See also
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation for `Boost.Asio` may give you more information about
    `io_service` usage at [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Asio`的官方文档可能为您提供有关`io_service`使用的更多信息，请参阅[http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html)'
- en: See all the `Boost.Function` related recipes from [Chapter 3](ch03.html "Chapter 3. Managing
    Resources"), *Managing Resources*, and the official documentation at [http://www.boost.org/doc/libs/1_53_0/doc/html/function.html](http://www.boost.org/doc/libs/1_53_0/doc/html/function.html)
    for getting an idea of how tasks work
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[第3章](ch03.html "第3章。管理资源")中所有与`Boost.Function`相关的配方，*管理资源*，以及官方文档[http://www.boost.org/doc/libs/1_53_0/doc/html/function.html](http://www.boost.org/doc/libs/1_53_0/doc/html/function.html)，以了解任务是如何工作的
- en: See the recipes from [Chapter 1](ch01.html "Chapter 1. Starting to Write Your
    Application"), *Starting to Write Your Application*, related to `Boost.Bind` to
    get more information about what the `boost::bind` function does, or see the official
    documentation at [http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html](http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[第1章](ch01.html "第1章。开始编写您的应用程序")中与`Boost.Bind`相关的配方，*开始编写您的应用程序*，以获取有关`boost::bind`函数更多信息，或者查看官方文档[http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html](http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html)
- en: Storing an exception and making a task from it
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储异常并从它创建任务
- en: Processing exceptions is not always trivial and may take a lot of time. Consider
    the situation where an exception must be serialized and sent by the network. This
    may take milliseconds and a few thousand lines of code. After the exception is
    caught is not always the best time and place to process it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常并不总是简单的，可能需要花费很多时间。考虑这种情况，异常必须被序列化并通过网络发送。这可能需要毫秒级和几千行代码。在捕获异常后并不总是处理它的最佳时间和地点。
- en: So, can we store exceptions and delay their processing?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能否存储异常并延迟它们的处理？
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires knowledge of `boost::asio::io_service`, which was described
    in the first recipe of this chapter. Knowledge of `Boost.Bind` is also required.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要了解 `boost::asio::io_service`，这在本章的第一个配方中已经描述过。还需要了解 `Boost.Bind`。
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: All we need is to have the ability to store exceptions and pass them between
    threads just like a normal variable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要的只是能够像普通变量一样存储异常并在线程之间传递它们。
- en: 'Let''s start with the function that processes exceptions. In our case, it will
    only be outputting the exception information to the console:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从处理异常的函数开始。在我们的例子中，它只会将异常信息输出到控制台：
- en: '[PRE44]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we will write some functions to demonstrate how exceptions work:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一些函数来演示异常是如何工作的：
- en: '[PRE45]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, if we run the example like this:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们像这样运行示例：
- en: '[PRE46]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''ll get the following output:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE47]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Boost.Exception` library provides an ability to store and rethrow exceptions.
    The `boost::current_exception()` method must be called from inside the `catch()`
    block, and it returns an object of the type `boost::exception_ptr`. So in `func_test1()`,
    the `boost::bad_lexical_cast` exception will be thrown, which will be returned
    by `boost::current_exception()`, and a task (a functional object) will be created
    from that exception and the `process_exception` function's pointer.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Exception` 库提供了一种存储和重新抛出异常的能力。必须从 `catch()` 块内部调用 `boost::current_exception()`
    方法，它返回一个 `boost::exception_ptr` 类型的对象。因此，在 `func_test1()` 中，将抛出 `boost::bad_lexical_cast`
    异常，它将由 `boost::current_exception()` 返回，并从该异常和 `process_exception` 函数的指针创建一个任务（一个函数对象）。'
- en: The `process_exception` function will re-throw the exception (the only way to
    restore the exception type from `boost::exception_ptr` is to rethrow it using
    `boost::rethrow_exception(exc)` and then catch it by specifying the exception
    type).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_exception` 函数将重新抛出异常（从 `boost::exception_ptr` 恢复异常类型的方法是通过使用 `boost::rethrow_exception(exc)`
    重新抛出它，然后通过指定异常类型来捕获它）。'
- en: 'In `func_test2`, we are throwing a `std::logic_error` exception using the `BOOST_THROW_EXCEPTION`
    macro. This macro does a lot of useful work: it checks that our exception is derived
    from `std::exception` and adds information to our exception about the source filename,
    function name, and the number of the line of code where the exception was thrown.
    So when an exception is re-thrown and caught by `catch(...)`, `boost::current_exception_diagnostic_information()`,
    we will be able to output much more information about it.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `func_test2` 中，我们使用 `BOOST_THROW_EXCEPTION` 宏抛出一个 `std::logic_error` 异常。这个宏做了很多有用的工作：它检查我们的异常是否从
    `std::exception` 派生，并添加有关异常来源的文件名、函数名和抛出异常的代码行号的信息。因此，当异常被重新抛出并由 `catch(...)`
    捕获时，通过 `boost::current_exception_diagnostic_information()`，我们将能够输出更多关于它的信息。
- en: There's more...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Usually, `exception_ptr` is used to pass exceptions between threads. For example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`exception_ptr` 用于在线程之间传递异常。例如：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `boost::exception_ptr` class may allocate memory through heap multiple times,
    uses atomics, and implements some of the operations by rethrowing and catching
    exceptions. Try not to use it without an actual need.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::exception_ptr` 类可能会通过堆多次分配内存，使用原子操作，并通过重新抛出和捕获异常来实现一些操作。尽量在没有实际需要的情况下不要使用它。'
- en: C++11 has adopted `boost::current_exception`, `boost::rethrow_exception`, and
    `boost::exception_ptr`. You will find them in the `<exception>` header of the
    `std::` namespace. However, the `BOOST_THROW_EXCEPTION` and `boost::current_exception_diagnostic_information()`
    methods are not in C++11, so you'll need to realize them on your own (or just
    use the Boost versions).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 已经采用了 `boost::current_exception`、`boost::rethrow_exception` 和 `boost::exception_ptr`。你将在
    `std::` 命名空间中的 `<exception>` 头文件中找到它们。然而，`BOOST_THROW_EXCEPTION` 和 `boost::current_exception_diagnostic_information()`
    方法不在 C++11 中，所以你需要自己实现它们（或者只需使用 Boost 版本）。
- en: See also
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation for `Boost.Exception` contains a lot of useful information
    about implementation and restrictions at [http://www.boost.org/doc/libs/1_53_0/libs/exception/doc/boost-exception.html](http://www.boost.org/doc/libs/1_53_0/libs/exception/doc/boost-exception.html).
    You may also find some information that is not covered in this recipe (for example,
    how to add additional information to an already thrown exception).
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Exception`的官方文档包含了关于实现和限制的许多有用信息，请参阅[http://www.boost.org/doc/libs/1_53_0/libs/exception/doc/boost-exception.html](http://www.boost.org/doc/libs/1_53_0/libs/exception/doc/boost-exception.html)。您也可能找到一些本食谱中没有涵盖的信息（例如，如何向已抛出的异常添加附加信息）。'
- en: The first recipe from this chapter will give you information about the `tasks_processor`
    class. Recipes *Binding a value as a function parameter* from [Chapter 1](ch01.html
    "Chapter 1. Starting to Write Your Application"), *Starting to Write Your Application*,
    and *Converting strings to numbers* from [Chapter 2](ch02.html "Chapter 2. Converting
    Data"), *Converting Data*, will help you with `Boost.Bind` and `Boost.LexicalCast`.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的第一个食谱将为您提供有关`tasks_processor`类的信息。来自[第1章](ch01.html "第1章。开始编写您的应用程序")的*将值绑定为函数参数*食谱，来自[第2章](ch02.html
    "第2章。转换数据")的*转换字符串为数字*食谱将帮助您使用`Boost.Bind`和`Boost.LexicalCast`。
- en: Getting and processing system signals as tasks
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将获取和处理系统信号作为任务
- en: When writing some server applications (especially for Linux OS), catching and
    processing signals is required. Usually, all the signal handlers are set up at
    server start and do not change during the application's execution.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写某些服务器应用程序（特别是针对Linux操作系统）时，需要捕获和处理信号。通常，所有信号处理程序都在服务器启动时设置，并且在应用程序执行期间不会改变。
- en: The goal of this recipe is to make our `tasks_processor` class capable of processing
    signals.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的目标是使我们的`tasks_processor`类能够处理信号。
- en: Getting ready
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need code from the first recipe of this chapter. Good knowledge of `Boost.Bind`
    and `Boost.Function` is also required.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要本章第一个食谱中的代码。对`Boost.Bind`和`Boost.Function`有良好的了解也是必需的。
- en: How to do it...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: This recipe is similar to previous ones; we have some signal handlers, functions
    to register them, and some support code.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱与之前的食谱类似；我们有一些信号处理程序、注册它们的函数和一些支持代码。
- en: 'Let''s start with including the following headers:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从包含以下头文件开始：
- en: '[PRE49]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we add a member for signals processing to the `tasks_processor` class:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们向`tasks_processor`类添加一个用于信号处理的成员：
- en: '[PRE50]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The function that will be called upon signal capture is as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在信号捕获时将被调用的函数如下：
- en: '[PRE51]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Do not forget to initialize the `signals_` member in the `tasks_processor`
    constructor:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在`tasks_processor`构造函数中初始化`signals_`成员：
- en: '[PRE52]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And now we need a function for registering the signals handler:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个用于注册信号处理程序的函数：
- en: '[PRE53]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That''s all. Now we are ready to process signals. Following is a test program:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这些。现在我们已准备好处理信号。以下是一个测试程序：
- en: '[PRE54]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will give the following output:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE55]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Nothing is difficult here (compared to some previous recipes from this chapter).
    The `register_signals_handler` function adds the signal numbers that will be processed.
    It is done via a call to the `boost::asio::signal_set::add` function for each
    element of the `signals_to_wait` vector (we do it using `std::for_each` and some
    magic of `boost::bind`).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么是困难的（与本章的一些先前食谱相比）。`register_signals_handler`函数添加将被处理的信号编号。这是通过调用`boost::asio::signal_set::add`函数对`signals_to_wait`向量的每个元素进行操作来完成的（我们使用`std::for_each`和`boost::bind`的一些魔法来完成）。
- en: Next, the instruction makes `signals_ member` wait for the signal and calls
    the `tasks_processor::handle_signals` member function for `this` on the signal
    capture. The `tasks_processor::handle_signals` function checks for errors and
    if there is no error, it creates a functional object by referring to `users_signal_handler_`
    and the signal number. This functional object will be wrapped in the `task_wrapped`
    structure (that handles all the exceptions) and executed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，指令使`signals_成员`等待信号，并在信号捕获时调用`tasks_processor::handle_signals`成员函数。`tasks_processor::handle_signals`函数检查错误，如果没有错误，它通过引用`users_signal_handler_`和信号编号创建一个功能对象。这个功能对象将被包裹在`task_wrapped`结构中（该结构处理所有异常）并执行。
- en: After that, we make `signals_ member` wait for a signal again.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们再次使`signals_成员`等待信号。
- en: There's more...
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When a thread-safe dynamic adding and removing of signals is required, we may
    modify this example to look like `detail::timer_task` from the *Making timers
    and processing timer events as tasks* recipe of this chapter. When multiple `boost::asio::signal_set`
    objects are registered as waiting on the same signals, a handler from each of
    `signal_set` will be called on a single signal.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要线程安全的动态添加和删除信号时，我们可以修改这个示例，使其看起来像本章的*制作定时器和处理定时事件作为任务*配方中的`detail::timer_task`。当多个`boost::asio::signal_set`对象注册为等待同一信号时，每个`signal_set`的处理程序将在单个信号上被调用。
- en: C++ has been capable of processing signals for a long time using the `signal`
    function from the `<csignal>` header. However, it is incapable of using functional
    objects (which is a huge disadvantage).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: C++长期以来一直能够使用`<csignal>`头文件中的`signal`函数处理信号。然而，它无法使用功能性对象（这是一个巨大的缺点）。
- en: See also
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The *Binding a value as a function parameter* and *Reordering the parameters
    of function* recipes from [Chapter 1](ch01.html "Chapter 1. Starting to Write
    Your Application"), *Starting to Write Your Application*, provide a lot of information
    about `boost::bind`. The official documentation may also help: [http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html](http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第1章](ch01.html "第1章。开始编写您的应用程序")的*将值绑定为函数参数*和*重新排序函数参数*配方，提供了关于`boost::bind`的大量信息。官方文档也可能有所帮助：[http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html](http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html)
- en: The *Storing any functional object in a variable* recipe (on `Boost.Function`)
    from [Chapter 3](ch03.html "Chapter 3. Managing Resources"), *Managing Resources*,
    provides information about `boost::function`.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第3章](ch03.html "第3章。管理资源")的*将任何功能性对象存储在变量中*配方（关于`Boost.Function`），提供了关于`boost::function`的信息。
- en: See the official `Boost.Asio` documentation has more information and examples
    on `boost::asio::signal_set` and other features of this great library at [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[官方`Boost.Asio`文档](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html)以获取更多关于`boost::asio::signal_set`和其他该伟大库特性的信息和示例。
